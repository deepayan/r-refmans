<!DOCTYPE html><html><head><title>Help for package igraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {igraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#igraph-package'><p>The igraph package</p></a></li>
<li><a href='#+5B.igraph'><p>Query and manipulate a graph as it were an adjacency matrix</p></a></li>
<li><a href='#+5B+5B.igraph'><p>Query and manipulate a graph as it were an adjacency list</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Magrittr's pipes</p></a></li>
<li><a href='#+2B.igraph'><p>Add vertices, edges or another graph to a graph</p></a></li>
<li><a href='#add_edges'><p>Add edges to a graph</p></a></li>
<li><a href='#add_layout_'><p>Add layout to graph</p></a></li>
<li><a href='#add_vertices'><p>Add vertices to a graph</p></a></li>
<li><a href='#add.edges'><p>Add edges to a graph</p></a></li>
<li><a href='#add.vertex.shape'><p>Various vertex shapes when plotting igraph graphs</p></a></li>
<li><a href='#add.vertices'><p>Add vertices to a graph</p></a></li>
<li><a href='#adjacent_vertices'><p>Adjacent vertices of multiple vertices in a graph</p></a></li>
<li><a href='#adjacent.triangles'><p>Find triangles in graphs</p></a></li>
<li><a href='#aging.ba.game'><p>Generate an evolving random graph with preferential attachment and aging</p></a></li>
<li><a href='#aging.barabasi.game'><p>Generate an evolving random graph with preferential attachment and aging</p></a></li>
<li><a href='#aging.prefatt.game'><p>Generate an evolving random graph with preferential attachment and aging</p></a></li>
<li><a href='#all_simple_paths'><p>List all simple paths from one source</p></a></li>
<li><a href='#alpha_centrality'><p>Find Bonacich alpha centrality scores of network positions</p></a></li>
<li><a href='#alpha.centrality'><p>Find Bonacich alpha centrality scores of network positions</p></a></li>
<li><a href='#are_adjacent'><p>Are two vertices adjacent?</p></a></li>
<li><a href='#are.connected'><p>Are two vertices adjacent?</p></a></li>
<li><a href='#arpack_defaults'><p>ARPACK eigenvector calculation</p></a></li>
<li><a href='#articulation_points'><p>Articulation points and bridges of a graph</p></a></li>
<li><a href='#articulation.points'><p>Articulation points and bridges of a graph</p></a></li>
<li><a href='#as_adj_list'><p>Adjacency lists</p></a></li>
<li><a href='#as_adjacency_matrix'><p>Convert a graph to an adjacency matrix</p></a></li>
<li><a href='#as_biadjacency_matrix'><p>Bipartite adjacency matrix of a bipartite graph</p></a></li>
<li><a href='#as_data_frame'><p>Creating igraph graphs from data frames or vice-versa</p></a></li>
<li><a href='#as_edgelist'><p>Convert a graph to an edge list</p></a></li>
<li><a href='#as_graphnel'><p>Convert igraph graphs to graphNEL objects from the graph package</p></a></li>
<li><a href='#as_ids'><p>Convert a vertex or edge sequence to an ordinary vector</p></a></li>
<li><a href='#as_incidence_matrix'><p>As incidence matrix</p></a></li>
<li><a href='#as_long_data_frame'><p>Convert a graph to a long data frame</p></a></li>
<li><a href='#as_membership'><p>Declare a numeric vector as a membership vector</p></a></li>
<li><a href='#as_phylo'><p>as_phylo</p></a></li>
<li><a href='#as.directed'><p>Convert between directed and undirected graphs</p></a></li>
<li><a href='#as.igraph'><p>Conversion to igraph</p></a></li>
<li><a href='#as.matrix.igraph'><p>Convert igraph objects to adjacency or edge list matrices</p></a></li>
<li><a href='#assortativity'><p>Assortativity coefficient</p></a></li>
<li><a href='#assortativity.degree'><p>Assortativity coefficient</p></a></li>
<li><a href='#assortativity.nominal'><p>Assortativity coefficient</p></a></li>
<li><a href='#asymmetric.preference.game'><p>Trait-based random generation</p></a></li>
<li><a href='#authority.score'><p>Kleinberg's hub and authority centrality scores.</p></a></li>
<li><a href='#autocurve.edges'><p>Optimal edge curvature when plotting graphs</p></a></li>
<li><a href='#automorphism_group'><p>Generating set of the automorphism group of a graph</p></a></li>
<li><a href='#automorphisms'><p>Number of automorphisms</p></a></li>
<li><a href='#average.path.length'><p>Shortest (directed or undirected) paths between vertices</p></a></li>
<li><a href='#ba.game'><p>Generate random graphs using preferential attachment</p></a></li>
<li><a href='#barabasi.game'><p>Generate random graphs using preferential attachment</p></a></li>
<li><a href='#betweenness'><p>Vertex and edge betweenness centrality</p></a></li>
<li><a href='#bfs'><p>Breadth-first search</p></a></li>
<li><a href='#biconnected_components'><p>Biconnected components</p></a></li>
<li><a href='#biconnected.components'><p>Biconnected components</p></a></li>
<li><a href='#bipartite_mapping'><p>Decide whether a graph is bipartite</p></a></li>
<li><a href='#bipartite_projection'><p>Project a bipartite graph</p></a></li>
<li><a href='#bipartite.mapping'><p>Decide whether a graph is bipartite</p></a></li>
<li><a href='#bipartite.projection'><p>Project a bipartite graph</p></a></li>
<li><a href='#bipartite.projection.size'><p>Project a bipartite graph</p></a></li>
<li><a href='#bipartite.random.game'><p>Bipartite random graphs</p></a></li>
<li><a href='#blockGraphs'><p>Calculate Cohesive Blocks</p></a></li>
<li><a href='#bonpow'><p>Find Bonacich Power Centrality Scores of Network Positions</p></a></li>
<li><a href='#c.igraph.es'><p>Concatenate edge sequences</p></a></li>
<li><a href='#c.igraph.vs'><p>Concatenate vertex sequences</p></a></li>
<li><a href='#callaway.traits.game'><p>Graph generation based on different vertex types</p></a></li>
<li><a href='#canonical_permutation'><p>Canonical permutation of a graph</p></a></li>
<li><a href='#canonical.permutation'><p>Canonical permutation of a graph</p></a></li>
<li><a href='#categorical_pal'><p>Palette for categories</p></a></li>
<li><a href='#centr_betw'><p>Centralize a graph according to the betweenness of vertices</p></a></li>
<li><a href='#centr_betw_tmax'><p>Theoretical maximum for betweenness centralization</p></a></li>
<li><a href='#centr_clo'><p>Centralize a graph according to the closeness of vertices</p></a></li>
<li><a href='#centr_clo_tmax'><p>Theoretical maximum for closeness centralization</p></a></li>
<li><a href='#centr_degree'><p>Centralize a graph according to the degrees of vertices</p></a></li>
<li><a href='#centr_degree_tmax'><p>Theoretical maximum for degree centralization</p></a></li>
<li><a href='#centr_eigen'><p>Centralize a graph according to the eigenvector centrality of vertices</p></a></li>
<li><a href='#centr_eigen_tmax'><p>Theoretical maximum for betweenness centralization</p></a></li>
<li><a href='#centralization.betweenness'><p>Centralize a graph according to the betweenness of vertices</p></a></li>
<li><a href='#centralization.betweenness.tmax'><p>Theoretical maximum for betweenness centralization</p></a></li>
<li><a href='#centralization.closeness'><p>Centralize a graph according to the closeness of vertices</p></a></li>
<li><a href='#centralization.closeness.tmax'><p>Theoretical maximum for closeness centralization</p></a></li>
<li><a href='#centralization.degree'><p>Centralize a graph according to the degrees of vertices</p></a></li>
<li><a href='#centralization.degree.tmax'><p>Theoretical maximum for degree centralization</p></a></li>
<li><a href='#centralization.evcent'><p>Centralize a graph according to the eigenvector centrality of vertices</p></a></li>
<li><a href='#centralization.evcent.tmax'><p>Theoretical maximum for betweenness centralization</p></a></li>
<li><a href='#centralize'><p>Centralization of a graph</p></a></li>
<li><a href='#centralize.scores'><p>Centralization of a graph</p></a></li>
<li><a href='#cited.type.game'><p>Random citation graphs</p></a></li>
<li><a href='#citing.cited.type.game'><p>Random citation graphs</p></a></li>
<li><a href='#clique.number'><p>Functions to find cliques, i.e. complete subgraphs in a graph</p></a></li>
<li><a href='#cliques'><p>Functions to find cliques, i.e. complete subgraphs in a graph</p></a></li>
<li><a href='#closeness'><p>Closeness centrality of vertices</p></a></li>
<li><a href='#cluster_edge_betweenness'><p>Community structure detection based on edge betweenness</p></a></li>
<li><a href='#cluster_fast_greedy'><p>Community structure via greedy optimization of modularity</p></a></li>
<li><a href='#cluster_fluid_communities'><p>Community detection algorithm based on interacting fluids</p></a></li>
<li><a href='#cluster_infomap'><p>Infomap community finding</p></a></li>
<li><a href='#cluster_label_prop'><p>Finding communities based on propagating labels</p></a></li>
<li><a href='#cluster_leading_eigen'><p>Community structure detecting based on the leading eigenvector of the</p>
community matrix</a></li>
<li><a href='#cluster_leiden'><p>Finding community structure of a graph using the Leiden algorithm of Traag,</p>
van Eck &amp; Waltman.</a></li>
<li><a href='#cluster_louvain'><p>Finding community structure by multi-level optimization of modularity</p></a></li>
<li><a href='#cluster_optimal'><p>Optimal community structure</p></a></li>
<li><a href='#cluster_spinglass'><p>Finding communities in graphs based on statistical meachanics</p></a></li>
<li><a href='#cluster_walktrap'><p>Community structure via short random walks</p></a></li>
<li><a href='#cluster.distribution'><p>Connected components of a graph</p></a></li>
<li><a href='#clusters'><p>Connected components of a graph</p></a></li>
<li><a href='#cocitation'><p>Cocitation coupling</p></a></li>
<li><a href='#code.length'><p>Functions to deal with the result of network community detection</p></a></li>
<li><a href='#cohesive_blocks'><p>Calculate Cohesive Blocks</p></a></li>
<li><a href='#cohesive.blocks'><p>Calculate Cohesive Blocks</p></a></li>
<li><a href='#compare'><p>Compares community structures using various metrics</p></a></li>
<li><a href='#complementer'><p>Complementer of a graph</p></a></li>
<li><a href='#component_distribution'><p>Connected components of a graph</p></a></li>
<li><a href='#component_wise'><p>Component-wise layout</p></a></li>
<li><a href='#compose'><p>Compose two graphs as binary relations</p></a></li>
<li><a href='#connect'><p>Neighborhood of graph vertices</p></a></li>
<li><a href='#connect.neighborhood'><p>Neighborhood of graph vertices</p></a></li>
<li><a href='#consensus_tree'><p>Create a consensus tree from several hierarchical random graph models</p></a></li>
<li><a href='#console'><p>The igraph console</p></a></li>
<li><a href='#constraint'><p>Burt's constraint</p></a></li>
<li><a href='#contract'><p>Contract several vertices into a single one</p></a></li>
<li><a href='#contract.vertices'><p>Contract several vertices into a single one</p></a></li>
<li><a href='#convex_hull'><p>Convex hull of a set of vertices</p></a></li>
<li><a href='#convex.hull'><p>Convex hull of a set of vertices</p></a></li>
<li><a href='#coreness'><p>K-core decomposition of graphs</p></a></li>
<li><a href='#count_automorphisms'><p>Number of automorphisms</p></a></li>
<li><a href='#count_isomorphisms'><p>Count the number of isomorphic mappings between two graphs</p></a></li>
<li><a href='#count_motifs'><p>Graph motifs</p></a></li>
<li><a href='#count_subgraph_isomorphisms'><p>Count the isomorphic mappings between a graph and the subgraphs of</p>
another graph</a></li>
<li><a href='#count.multiple'><p>Find the multiple or loop edges in a graph</p></a></li>
<li><a href='#create.communities'><p>Creates a communities object.</p></a></li>
<li><a href='#curve_multiple'><p>Optimal edge curvature when plotting graphs</p></a></li>
<li><a href='#cutat'><p>Functions to deal with the result of network community detection</p></a></li>
<li><a href='#decompose'><p>Decompose a graph into components</p></a></li>
<li><a href='#decompose.graph'><p>Decompose a graph into components</p></a></li>
<li><a href='#degree'><p>Degree and degree distribution of the vertices</p></a></li>
<li><a href='#degree.distribution'><p>Degree and degree distribution of the vertices</p></a></li>
<li><a href='#degree.sequence.game'><p>Generate random graphs with a given degree sequence</p></a></li>
<li><a href='#delete_edge_attr'><p>Delete an edge attribute</p></a></li>
<li><a href='#delete_edges'><p>Delete edges from a graph</p></a></li>
<li><a href='#delete_graph_attr'><p>Delete a graph attribute</p></a></li>
<li><a href='#delete_vertex_attr'><p>Delete a vertex attribute</p></a></li>
<li><a href='#delete_vertices'><p>Delete vertices from a graph</p></a></li>
<li><a href='#delete.edges'><p>Delete edges from a graph</p></a></li>
<li><a href='#delete.vertices'><p>Delete vertices from a graph</p></a></li>
<li><a href='#dendPlot'><p>Community structure dendrogram plots</p></a></li>
<li><a href='#dfs'><p>Depth-first search</p></a></li>
<li><a href='#diameter'><p>Diameter of a graph</p></a></li>
<li><a href='#difference'><p>Difference of two sets</p></a></li>
<li><a href='#difference.igraph'><p>Difference of graphs</p></a></li>
<li><a href='#difference.igraph.es'><p>Difference of edge sequences</p></a></li>
<li><a href='#difference.igraph.vs'><p>Difference of vertex sequences</p></a></li>
<li><a href='#dim_select'><p>Dimensionality selection for singular values using profile likelihood.</p></a></li>
<li><a href='#disjoint_union'><p>Disjoint union of graphs</p></a></li>
<li><a href='#distance_table'><p>Shortest (directed or undirected) paths between vertices</p></a></li>
<li><a href='#diverging_pal'><p>Diverging palette</p></a></li>
<li><a href='#diversity'><p>Graph diversity</p></a></li>
<li><a href='#dominator_tree'><p>Dominator tree</p></a></li>
<li><a href='#dominator.tree'><p>Dominator tree</p></a></li>
<li><a href='#dot-data'><p><code>.data</code> and <code>.env</code> pronouns</p></a></li>
<li><a href='#Drawing+20graphs'><p>Drawing graphs</p></a></li>
<li><a href='#dyad_census'><p>Dyad census of a graph</p></a></li>
<li><a href='#dyad.census'><p>Dyad census of a graph</p></a></li>
<li><a href='#E'><p>Edges of a graph</p></a></li>
<li><a href='#each_edge'><p>Rewires the endpoints of the edges of a graph to a random vertex</p></a></li>
<li><a href='#eccentricity'><p>Eccentricity of the vertices in a graph</p></a></li>
<li><a href='#edge'><p>Helper function for adding and deleting edges</p></a></li>
<li><a href='#edge_attr'><p>Query edge attributes of a graph</p></a></li>
<li><a href='#edge_attr_names'><p>List names of edge attributes</p></a></li>
<li><a href='#edge_attr+26lt+3B-'><p>Set one or more edge attributes</p></a></li>
<li><a href='#edge_connectivity'><p>Edge connectivity</p></a></li>
<li><a href='#edge_density'><p>Graph density</p></a></li>
<li><a href='#edge.betweenness'><p>Vertex and edge betweenness centrality</p></a></li>
<li><a href='#edge.betweenness.community'><p>Community structure detection based on edge betweenness</p></a></li>
<li><a href='#edge.connectivity'><p>Edge connectivity</p></a></li>
<li><a href='#edge.disjoint.paths'><p>Edge connectivity</p></a></li>
<li><a href='#eigen_centrality'><p>Find Eigenvector Centrality Scores of Network Positions</p></a></li>
<li><a href='#embed_adjacency_matrix'><p>Spectral Embedding of Adjacency Matrices</p></a></li>
<li><a href='#embed_laplacian_matrix'><p>Spectral Embedding of the Laplacian of a Graph</p></a></li>
<li><a href='#ends'><p>Incident vertices of some graph edges</p></a></li>
<li><a href='#erdos.renyi.game'><p>Generate random graphs according to the Erdős-Rényi model</p></a></li>
<li><a href='#establishment.game'><p>Graph generation based on different vertex types</p></a></li>
<li><a href='#estimate_betweenness'><p>Deprecated version of <code>betweenness()</code></p></a></li>
<li><a href='#estimate_closeness'><p>Deprecated version of <code>closeness()</code></p></a></li>
<li><a href='#estimate_edge_betweenness'><p>Deprecated version of <code>edge_betweenness()</code></p></a></li>
<li><a href='#evcent'><p>Find Eigenvector Centrality Scores of Network Positions</p></a></li>
<li><a href='#exportPajek'><p>Calculate Cohesive Blocks</p></a></li>
<li><a href='#farthest.nodes'><p>Diameter of a graph</p></a></li>
<li><a href='#fastgreedy.community'><p>Community structure via greedy optimization of modularity</p></a></li>
<li><a href='#feedback_arc_set'><p>Finding a feedback arc set in a graph</p></a></li>
<li><a href='#fit_hrg'><p>Fit a hierarchical random graph model</p></a></li>
<li><a href='#fit_power_law'><p>Fitting a power-law distribution function to discrete data</p></a></li>
<li><a href='#forest.fire.game'><p>Forest Fire Network Model</p></a></li>
<li><a href='#from_incidence_matrix'><p>Graph from incidence matrix</p></a></li>
<li><a href='#get.adjacency'><p>Convert a graph to an adjacency matrix</p></a></li>
<li><a href='#get.adjedgelist'><p>Adjacency lists</p></a></li>
<li><a href='#get.adjlist'><p>Adjacency lists</p></a></li>
<li><a href='#get.all.shortest.paths'><p>Shortest (directed or undirected) paths between vertices</p></a></li>
<li><a href='#get.data.frame'><p>Creating igraph graphs from data frames or vice-versa</p></a></li>
<li><a href='#get.diameter'><p>Diameter of a graph</p></a></li>
<li><a href='#get.edge.attribute'><p>Query edge attributes of a graph</p></a></li>
<li><a href='#get.edge.ids'><p>Find the edge ids based on the incident vertices of the edges</p></a></li>
<li><a href='#get.edgelist'><p>Convert a graph to an edge list</p></a></li>
<li><a href='#get.graph.attribute'><p>Graph attributes of a graph</p></a></li>
<li><a href='#get.incidence'><p>Bipartite adjacency matrix of a bipartite graph</p></a></li>
<li><a href='#get.shortest.paths'><p>Shortest (directed or undirected) paths between vertices</p></a></li>
<li><a href='#get.stochastic'><p>Stochastic matrix of a graph</p></a></li>
<li><a href='#get.vertex.attribute'><p>Query vertex attributes of a graph</p></a></li>
<li><a href='#getIgraphOpt'><p>Parameters for the igraph package</p></a></li>
<li><a href='#girth'><p>Girth of a graph</p></a></li>
<li><a href='#global_efficiency'><p>Efficiency of a graph</p></a></li>
<li><a href='#gorder'><p>Order (number of vertices) of a graph</p></a></li>
<li><a href='#graph_'><p>Convert object to a graph</p></a></li>
<li><a href='#graph_attr'><p>Graph attributes of a graph</p></a></li>
<li><a href='#graph_attr_names'><p>List names of graph attributes</p></a></li>
<li><a href='#graph_attr+26lt+3B-'><p>Set all or some graph attributes</p></a></li>
<li><a href='#graph_from_adj_list'><p>Create graphs from adjacency lists</p></a></li>
<li><a href='#graph_from_adjacency_matrix'><p>Create graphs from adjacency matrices</p></a></li>
<li><a href='#graph_from_atlas'><p>Create a graph from the Graph Atlas</p></a></li>
<li><a href='#graph_from_biadjacency_matrix'><p>Create graphs from a bipartite adjacency matrix</p></a></li>
<li><a href='#graph_from_edgelist'><p>Create a graph from an edge list matrix</p></a></li>
<li><a href='#graph_from_graphdb'><p>Load a graph from the graph database for testing graph isomorphism.</p></a></li>
<li><a href='#graph_from_graphnel'><p>Convert graphNEL objects from the graph package to igraph</p></a></li>
<li><a href='#graph_from_incidence_matrix'><p>From incidence matrix</p></a></li>
<li><a href='#graph_from_isomorphism_class'><p>Create a graph from an isomorphism class</p></a></li>
<li><a href='#graph_from_lcf'><p>Creating a graph from LCF notation</p></a></li>
<li><a href='#graph_from_literal'><p>Creating (small) graphs via a simple interface</p></a></li>
<li><a href='#graph_id'><p>Get the id of a graph</p></a></li>
<li><a href='#graph_version'><p>igraph data structure versions</p></a></li>
<li><a href='#graph.adhesion'><p>Edge connectivity</p></a></li>
<li><a href='#graph.adjacency'><p>Create graphs from adjacency matrices</p></a></li>
<li><a href='#graph.adjlist'><p>Create graphs from adjacency lists</p></a></li>
<li><a href='#graph.automorphisms'><p>Number of automorphisms</p></a></li>
<li><a href='#graph.bfs'><p>Breadth-first search</p></a></li>
<li><a href='#graph.cohesion'><p>Vertex connectivity</p></a></li>
<li><a href='#graph.complementer'><p>Complementer of a graph</p></a></li>
<li><a href='#graph.compose'><p>Compose two graphs as binary relations</p></a></li>
<li><a href='#graph.coreness'><p>K-core decomposition of graphs</p></a></li>
<li><a href='#graph.data.frame'><p>Creating igraph graphs from data frames or vice-versa</p></a></li>
<li><a href='#graph.density'><p>Graph density</p></a></li>
<li><a href='#graph.dfs'><p>Depth-first search</p></a></li>
<li><a href='#graph.difference'><p>Difference of two sets</p></a></li>
<li><a href='#graph.disjoint.union'><p>Disjoint union of graphs</p></a></li>
<li><a href='#graph.diversity'><p>Graph diversity</p></a></li>
<li><a href='#graph.edgelist'><p>Create a graph from an edge list matrix</p></a></li>
<li><a href='#graph.eigen'><p>Eigenvalues and eigenvectors of the adjacency matrix of a graph</p></a></li>
<li><a href='#graph.graphdb'><p>Load a graph from the graph database for testing graph isomorphism.</p></a></li>
<li><a href='#graph.incidence'><p>Create graphs from a bipartite adjacency matrix</p></a></li>
<li><a href='#graph.intersection'><p>Intersection of two or more sets</p></a></li>
<li><a href='#graph.isocreate'><p>Create a graph from an isomorphism class</p></a></li>
<li><a href='#graph.knn'><p>Average nearest neighbor degree</p></a></li>
<li><a href='#graph.laplacian'><p>Graph Laplacian</p></a></li>
<li><a href='#graph.maxflow'><p>Maximum flow in a graph</p></a></li>
<li><a href='#graph.mincut'><p>Minimum cut in a graph</p></a></li>
<li><a href='#graph.motifs'><p>Graph motifs</p></a></li>
<li><a href='#graph.motifs.est'><p>Graph motifs</p></a></li>
<li><a href='#graph.motifs.no'><p>Graph motifs</p></a></li>
<li><a href='#graph.neighborhood'><p>Neighborhood of graph vertices</p></a></li>
<li><a href='#graph.strength'><p>Strength or weighted vertex degree</p></a></li>
<li><a href='#graph.union'><p>Union of graphs</p></a></li>
<li><a href='#graphlet_basis'><p>Graphlet decomposition of a graph</p></a></li>
<li><a href='#graphlets.candidate.basis'><p>Graphlet decomposition of a graph</p></a></li>
<li><a href='#graphlets.project'><p>Graphlet decomposition of a graph</p></a></li>
<li><a href='#greedy_vertex_coloring'><p>Greedy vertex coloring</p></a></li>
<li><a href='#grg.game'><p>Geometric random graphs</p></a></li>
<li><a href='#groups'><p>Groups of a vertex partitioning</p></a></li>
<li><a href='#growing.random.game'><p>Growing random graph generation</p></a></li>
<li><a href='#gsize'><p>The size of the graph (number of edges)</p></a></li>
<li><a href='#handle_vertex_type_arg'><p>Common handler for vertex type arguments in igraph functions</p></a></li>
<li><a href='#harmonic_centrality'><p>Harmonic centrality of vertices</p></a></li>
<li><a href='#has_eulerian_path'><p>Find Eulerian paths or cycles in a graph</p></a></li>
<li><a href='#has.multiple'><p>Find the multiple or loop edges in a graph</p></a></li>
<li><a href='#head_of'><p>Head of the edge(s) in a graph</p></a></li>
<li><a href='#head_print'><p>Print the only the head of an R object</p></a></li>
<li><a href='#hrg'><p>Create a hierarchical random graph from an igraph graph</p></a></li>
<li><a href='#hrg_tree'><p>Create an igraph graph from a hierarchical random graph model</p></a></li>
<li><a href='#hrg-methods'><p>Hierarchical random graphs</p></a></li>
<li><a href='#hrg.consensus'><p>Create a consensus tree from several hierarchical random graph models</p></a></li>
<li><a href='#hrg.create'><p>Create a hierarchical random graph from an igraph graph</p></a></li>
<li><a href='#hrg.dendrogram'><p>Create an igraph graph from a hierarchical random graph model</p></a></li>
<li><a href='#hrg.fit'><p>Fit a hierarchical random graph model</p></a></li>
<li><a href='#hrg.game'><p>Sample from a hierarchical random graph model</p></a></li>
<li><a href='#hrg.predict'><p>Predict edges based on a hierarchical random graph model</p></a></li>
<li><a href='#hub_score'><p>Kleinberg's hub and authority centrality scores.</p></a></li>
<li><a href='#hub.score'><p>Kleinberg's hub and authority centrality scores.</p></a></li>
<li><a href='#identical_graphs'><p>Decide if two graphs are identical</p></a></li>
<li><a href='#igraph_demo'><p>Run igraph demos, step by step</p></a></li>
<li><a href='#igraph_options'><p>Parameters for the igraph package</p></a></li>
<li><a href='#igraph_test'><p>Run package tests</p></a></li>
<li><a href='#igraph_version'><p>Query igraph's version string</p></a></li>
<li><a href='#igraph-attribute-combination'><p>How igraph functions handle attributes when the graph changes</p></a></li>
<li><a href='#igraph-dollar'><p>Getting and setting graph attributes, shortcut</p></a></li>
<li><a href='#igraph-es-attributes'><p>Query or set attributes of the edges in an edge sequence</p></a></li>
<li><a href='#igraph-es-indexing'><p>Indexing edge sequences</p></a></li>
<li><a href='#igraph-es-indexing2'><p>Select edges and show their metadata</p></a></li>
<li><a href='#igraph-minus'><p>Delete vertices or edges from a graph</p></a></li>
<li><a href='#igraph-vs-attributes'><p>Query or set attributes of the vertices in a vertex sequence</p></a></li>
<li><a href='#igraph-vs-indexing'><p>Indexing vertex sequences</p></a></li>
<li><a href='#igraph-vs-indexing2'><p>Select vertices and show their metadata</p></a></li>
<li><a href='#igraph.console'><p>The igraph console</p></a></li>
<li><a href='#igraph.from.graphNEL'><p>Convert graphNEL objects from the graph package to igraph</p></a></li>
<li><a href='#igraph.options'><p>Parameters for the igraph package</p></a></li>
<li><a href='#igraph.sample'><p>Sampling a random integer sequence</p></a></li>
<li><a href='#igraph.shape.noclip'><p>Various vertex shapes when plotting igraph graphs</p></a></li>
<li><a href='#igraph.shape.noplot'><p>Various vertex shapes when plotting igraph graphs</p></a></li>
<li><a href='#igraph.to.graphNEL'><p>Convert igraph graphs to graphNEL objects from the graph package</p></a></li>
<li><a href='#igraph.version'><p>Query igraph's version string</p></a></li>
<li><a href='#igraphdemo'><p>Run igraph demos, step by step</p></a></li>
<li><a href='#igraphtest'><p>Run package tests</p></a></li>
<li><a href='#incident'><p>Incident edges of a vertex in a graph</p></a></li>
<li><a href='#incident_edges'><p>Incident edges of multiple vertices in a graph</p></a></li>
<li><a href='#indent_print'><p>Indent a printout</p></a></li>
<li><a href='#independence.number'><p>Independent vertex sets</p></a></li>
<li><a href='#independent.vertex.sets'><p>Independent vertex sets</p></a></li>
<li><a href='#induced.subgraph'><p>Subgraph of a graph</p></a></li>
<li><a href='#infomap.community'><p>Infomap community finding</p></a></li>
<li><a href='#interconnected.islands.game'><p>A graph with subgraphs that are each a random graph.</p></a></li>
<li><a href='#intersection'><p>Intersection of two or more sets</p></a></li>
<li><a href='#intersection.igraph'><p>Intersection of graphs</p></a></li>
<li><a href='#intersection.igraph.es'><p>Intersection of edge sequences</p></a></li>
<li><a href='#intersection.igraph.vs'><p>Intersection of vertex sequences</p></a></li>
<li><a href='#is_acyclic'><p>Acyclic graphs</p></a></li>
<li><a href='#is_biconnected'><p>Check biconnectedness</p></a></li>
<li><a href='#is_bipartite'><p>Checks whether the graph has a vertex attribute called <code>type</code>.</p></a></li>
<li><a href='#is_chordal'><p>Chordality of a graph</p></a></li>
<li><a href='#is_dag'><p>Directed acyclic graphs</p></a></li>
<li><a href='#is_degseq'><p>Check if a degree sequence is valid for a multi-graph</p></a></li>
<li><a href='#is_directed'><p>Check whether a graph is directed</p></a></li>
<li><a href='#is_forest'><p>Decide whether a graph is a forest.</p></a></li>
<li><a href='#is_graphical'><p>Is a degree sequence graphical?</p></a></li>
<li><a href='#is_igraph'><p>Is this object an igraph graph?</p></a></li>
<li><a href='#is_matching'><p>Matching</p></a></li>
<li><a href='#is_min_separator'><p>Minimal vertex separators</p></a></li>
<li><a href='#is_named'><p>Named graphs</p></a></li>
<li><a href='#is_printer_callback'><p>Is this a printer callback?</p></a></li>
<li><a href='#is_separator'><p>Vertex separators</p></a></li>
<li><a href='#is_tree'><p>Decide whether a graph is a tree.</p></a></li>
<li><a href='#is_weighted'><p>Weighted graphs</p></a></li>
<li><a href='#is.bipartite'><p>Checks whether the graph has a vertex attribute called <code>type</code></p></a></li>
<li><a href='#is.chordal'><p>Chordality of a graph</p></a></li>
<li><a href='#is.connected'><p>Connected components of a graph</p></a></li>
<li><a href='#is.dag'><p>Directed acyclic graphs</p></a></li>
<li><a href='#is.degree.sequence'><p>Check if a degree sequence is valid for a multi-graph</p></a></li>
<li><a href='#is.directed'><p>Check whether a graph is directed</p></a></li>
<li><a href='#is.graphical.degree.sequence'><p>Is a degree sequence graphical?</p></a></li>
<li><a href='#is.hierarchical'><p>Functions to deal with the result of network community detection</p></a></li>
<li><a href='#is.igraph'><p>Is this object an igraph graph?</p></a></li>
<li><a href='#is.loop'><p>Find the multiple or loop edges in a graph</p></a></li>
<li><a href='#is.matching'><p>Matching</p></a></li>
<li><a href='#is.maximal.matching'><p>Matching</p></a></li>
<li><a href='#is.minimal.separator'><p>Minimal vertex separators</p></a></li>
<li><a href='#is.multiple'><p>Find the multiple or loop edges in a graph</p></a></li>
<li><a href='#is.mutual'><p>Find mutual edges in a directed graph</p></a></li>
<li><a href='#is.named'><p>Named graphs</p></a></li>
<li><a href='#is.separator'><p>Vertex separators</p></a></li>
<li><a href='#is.simple'><p>Simple graphs</p></a></li>
<li><a href='#is.weighted'><p>Weighted graphs</p></a></li>
<li><a href='#isomorphic'><p>Decide if two graphs are isomorphic</p></a></li>
<li><a href='#isomorphism_class'><p>Isomorphism class of a graph</p></a></li>
<li><a href='#isomorphisms'><p>Calculate all isomorphic mappings between the vertices of two graphs</p></a></li>
<li><a href='#ivs'><p>Independent vertex sets</p></a></li>
<li><a href='#k_shortest_paths'><p>Find the <code class="reqn">k</code> shortest paths between two vertices</p></a></li>
<li><a href='#k.regular.game'><p>Create a random regular graph</p></a></li>
<li><a href='#keeping_degseq'><p>Graph rewiring while preserving the degree distribution</p></a></li>
<li><a href='#knn'><p>Average nearest neighbor degree</p></a></li>
<li><a href='#label.propagation.community'><p>Finding communities based on propagating labels</p></a></li>
<li><a href='#laplacian_matrix'><p>Graph Laplacian</p></a></li>
<li><a href='#largest.cliques'><p>Functions to find cliques, i.e. complete subgraphs in a graph</p></a></li>
<li><a href='#largest.independent.vertex.sets'><p>Independent vertex sets</p></a></li>
<li><a href='#lastcit.game'><p>Random citation graphs</p></a></li>
<li><a href='#layout_'><p>Graph layouts</p></a></li>
<li><a href='#layout_as_bipartite'><p>Simple two-row layout for bipartite graphs</p></a></li>
<li><a href='#layout_as_star'><p>Generate coordinates to place the vertices of a graph in a star-shape</p></a></li>
<li><a href='#layout_as_tree'><p>The Reingold-Tilford graph layout algorithm</p></a></li>
<li><a href='#layout_in_circle'><p>Graph layout with vertices on a circle.</p></a></li>
<li><a href='#layout_nicely'><p>Choose an appropriate graph layout algorithm automatically</p></a></li>
<li><a href='#layout_on_grid'><p>Simple grid layout</p></a></li>
<li><a href='#layout_on_sphere'><p>Graph layout with vertices on the surface of a sphere</p></a></li>
<li><a href='#layout_randomly'><p>Randomly place vertices on a plane or in 3d space</p></a></li>
<li><a href='#layout_with_dh'><p>The Davidson-Harel layout algorithm</p></a></li>
<li><a href='#layout_with_drl'><p>The DrL graph layout generator</p></a></li>
<li><a href='#layout_with_fr'><p>The Fruchterman-Reingold layout algorithm</p></a></li>
<li><a href='#layout_with_gem'><p>The GEM layout algorithm</p></a></li>
<li><a href='#layout_with_graphopt'><p>The graphopt layout algorithm</p></a></li>
<li><a href='#layout_with_kk'><p>The Kamada-Kawai layout algorithm</p></a></li>
<li><a href='#layout_with_lgl'><p>Large Graph Layout</p></a></li>
<li><a href='#layout_with_mds'><p>Graph layout by multidimensional scaling</p></a></li>
<li><a href='#layout_with_sugiyama'><p>The Sugiyama graph layout generator</p></a></li>
<li><a href='#layout.auto'><p>Choose an appropriate graph layout algorithm automatically</p></a></li>
<li><a href='#layout.bipartite'><p>Simple two-row layout for bipartite graphs</p></a></li>
<li><a href='#layout.davidson.harel'><p>The Davidson-Harel layout algorithm</p></a></li>
<li><a href='#layout.drl'><p>The DrL graph layout generator</p></a></li>
<li><a href='#layout.fruchterman.reingold.grid'><p>Grid Fruchterman-Reingold layout, this was removed from igraph</p></a></li>
<li><a href='#layout.gem'><p>The GEM layout algorithm</p></a></li>
<li><a href='#layout.graphopt'><p>The graphopt layout algorithm</p></a></li>
<li><a href='#layout.grid'><p>Simple grid layout</p></a></li>
<li><a href='#layout.mds'><p>Graph layout by multidimensional scaling</p></a></li>
<li><a href='#layout.merge'><p>Merging graph layouts</p></a></li>
<li><a href='#layout.norm'><p>Normalize coordinates for plotting graphs</p></a></li>
<li><a href='#layout.reingold.tilford'><p>Deprecated layout functions</p></a></li>
<li><a href='#layout.spring'><p>Spring layout, this was removed from igraph</p></a></li>
<li><a href='#layout.star'><p>Generate coordinates to place the vertices of a graph in a star-shape</p></a></li>
<li><a href='#layout.sugiyama'><p>The Sugiyama graph layout generator</p></a></li>
<li><a href='#layout.svd'><p>SVD layout, this was removed from igraph</p></a></li>
<li><a href='#leading.eigenvector.community'><p>Community structure detecting based on the leading eigenvector of the community matrix</p></a></li>
<li><a href='#list.edge.attributes'><p>List names of edge attributes</p></a></li>
<li><a href='#list.graph.attributes'><p>List names of graph attributes</p></a></li>
<li><a href='#list.vertex.attributes'><p>List names of vertex attributes</p></a></li>
<li><a href='#local_scan'><p>Compute local scan statistics on graphs</p></a></li>
<li><a href='#make_'><p>Make a new graph</p></a></li>
<li><a href='#make_bipartite_graph'><p>Create a bipartite graph</p></a></li>
<li><a href='#make_chordal_ring'><p>Create an extended chordal ring graph</p></a></li>
<li><a href='#make_clusters'><p>Creates a communities object.</p></a></li>
<li><a href='#make_de_bruijn_graph'><p>De Bruijn graphs</p></a></li>
<li><a href='#make_empty_graph'><p>A graph with no edges</p></a></li>
<li><a href='#make_from_prufer'><p>Create an undirected tree graph from its Prüfer sequence</p></a></li>
<li><a href='#make_full_bipartite_graph'><p>Create a full bipartite graph</p></a></li>
<li><a href='#make_full_citation_graph'><p>Create a complete (full) citation graph</p></a></li>
<li><a href='#make_full_graph'><p>Create a full graph</p></a></li>
<li><a href='#make_graph'><p>Create an igraph graph from a list of edges, or a notable graph</p></a></li>
<li><a href='#make_kautz_graph'><p>Kautz graphs</p></a></li>
<li><a href='#make_lattice'><p>Create a lattice graph</p></a></li>
<li><a href='#make_line_graph'><p>Line graph of a graph</p></a></li>
<li><a href='#make_ring'><p>Create a ring graph</p></a></li>
<li><a href='#make_star'><p>Create a star graph, a tree with n vertices and n - 1 leaves</p></a></li>
<li><a href='#make_tree'><p>Create tree graphs</p></a></li>
<li><a href='#match_vertices'><p>Match Graphs given a seeding of vertex correspondences</p></a></li>
<li><a href='#max_cardinality'><p>Maximum cardinality search</p></a></li>
<li><a href='#max_flow'><p>Maximum flow in a graph</p></a></li>
<li><a href='#maxcohesion'><p>Calculate Cohesive Blocks</p></a></li>
<li><a href='#maximal.cliques'><p>Functions to find cliques, i.e. complete subgraphs in a graph</p></a></li>
<li><a href='#maximal.cliques.count'><p>Functions to find cliques, i.e. complete subgraphs in a graph</p></a></li>
<li><a href='#maximal.independent.vertex.sets'><p>Independent vertex sets</p></a></li>
<li><a href='#maximum.bipartite.matching'><p>Matching</p></a></li>
<li><a href='#maximum.cardinality.search'><p>Maximum cardinality search</p></a></li>
<li><a href='#membership'><p>Functions to deal with the result of network community detection</p></a></li>
<li><a href='#merge_coords'><p>Merging graph layouts</p></a></li>
<li><a href='#min_cut'><p>Minimum cut in a graph</p></a></li>
<li><a href='#min_separators'><p>Minimum size vertex separators</p></a></li>
<li><a href='#min_st_separators'><p>Minimum size vertex separators</p></a></li>
<li><a href='#minimal.st.separators'><p>Minimum size vertex separators</p></a></li>
<li><a href='#minimum.size.separators'><p>Minimum size vertex separators</p></a></li>
<li><a href='#minimum.spanning.tree'><p>Minimum spanning tree</p></a></li>
<li><a href='#mod.matrix'><p>Modularity of a community structure of a graph</p></a></li>
<li><a href='#modularity.igraph'><p>Modularity of a community structure of a graph</p></a></li>
<li><a href='#motifs'><p>Graph motifs</p></a></li>
<li><a href='#mst'><p>Minimum spanning tree</p></a></li>
<li><a href='#multilevel.community'><p>Finding community structure by multi-level optimization of modularity</p></a></li>
<li><a href='#neighborhood.size'><p>Neighborhood of graph vertices</p></a></li>
<li><a href='#neighbors'><p>Neighboring (adjacent) vertices in a graph</p></a></li>
<li><a href='#no.clusters'><p>Connected components of a graph</p></a></li>
<li><a href='#norm_coords'><p>Normalize coordinates for plotting graphs</p></a></li>
<li><a href='#normalize'><p>Normalize layout</p></a></li>
<li><a href='#optimal.community'><p>Optimal community structure</p></a></li>
<li><a href='#page_rank'><p>The Page Rank algorithm</p></a></li>
<li><a href='#page.rank'><p>The Page Rank algorithm</p></a></li>
<li><a href='#path'><p>Helper function to add or delete edges along a path</p></a></li>
<li><a href='#path.length.hist'><p>Shortest (directed or undirected) paths between vertices</p></a></li>
<li><a href='#permute'><p>Permute the vertices of a graph</p></a></li>
<li><a href='#permute.vertices'><p>Permute the vertices of a graph</p></a></li>
<li><a href='#Pie+20charts+20as+20vertices'><p>Using pie charts as vertices in graph plots</p></a></li>
<li><a href='#piecewise.layout'><p>Merging graph layouts</p></a></li>
<li><a href='#plot_dendrogram'><p>Community structure dendrogram plots</p></a></li>
<li><a href='#plot_dendrogram.igraphHRG'><p>HRG dendrogram plot</p></a></li>
<li><a href='#plot.igraph'><p>Plotting of graphs</p></a></li>
<li><a href='#plot.sir'><p>Plotting the results on multiple SIR model runs</p></a></li>
<li><a href='#plotHierarchy'><p>Calculate Cohesive Blocks</p></a></li>
<li><a href='#power_centrality'><p>Find Bonacich Power Centrality Scores of Network Positions</p></a></li>
<li><a href='#power.law.fit'><p>Fitting a power-law distribution function to discrete data</p></a></li>
<li><a href='#predict_edges'><p>Predict edges based on a hierarchical random graph model</p></a></li>
<li><a href='#preference.game'><p>Trait-based random generation</p></a></li>
<li><a href='#print.igraph'><p>Print graphs to the terminal</p></a></li>
<li><a href='#print.igraph.es'><p>Print an edge sequence to the screen</p></a></li>
<li><a href='#print.igraph.vs'><p>Show a vertex sequence on the screen</p></a></li>
<li><a href='#print.igraphHRG'><p>Print a hierarchical random graph model to the screen</p></a></li>
<li><a href='#print.igraphHRGConsensus'><p>Print a hierarchical random graph consensus tree to the screen</p></a></li>
<li><a href='#printer_callback'><p>Create a printer callback function</p></a></li>
<li><a href='#r_pal'><p>The default R palette</p></a></li>
<li><a href='#radius'><p>Radius of a graph</p></a></li>
<li><a href='#random_walk'><p>Random walk on a graph</p></a></li>
<li><a href='#read_graph'><p>Reading foreign file formats</p></a></li>
<li><a href='#read.graph'><p>Reading foreign file formats</p></a></li>
<li><a href='#realize_bipartite_degseq'><p>Creating a bipartite graph from two degree sequences, deterministically</p></a></li>
<li><a href='#realize_degseq'><p>Creating a graph from a given degree sequence, deterministically</p></a></li>
<li><a href='#reciprocity'><p>Reciprocity of graphs</p></a></li>
<li><a href='#remove.edge.attribute'><p>Delete an edge attribute</p></a></li>
<li><a href='#remove.graph.attribute'><p>Delete a graph attribute</p></a></li>
<li><a href='#remove.vertex.attribute'><p>Delete a vertex attribute</p></a></li>
<li><a href='#rep.igraph'><p>Replicate a graph multiple times</p></a></li>
<li><a href='#rev.igraph.es'><p>Reverse the order in an edge sequence</p></a></li>
<li><a href='#rev.igraph.vs'><p>Reverse the order in a vertex sequence</p></a></li>
<li><a href='#reverse_edges'><p>Reverse edges in a graph</p></a></li>
<li><a href='#rewire'><p>Rewiring edges of a graph</p></a></li>
<li><a href='#rglplot'><p>3D plotting of graphs with OpenGL</p></a></li>
<li><a href='#running_mean'><p>Running mean of a time series</p></a></li>
<li><a href='#running.mean'><p>Running mean of a time series</p></a></li>
<li><a href='#sample_'><p>Sample from a random graph model</p></a></li>
<li><a href='#sample_bipartite'><p>Bipartite random graphs</p></a></li>
<li><a href='#sample_correlated_gnp'><p>Generate a new random graph from a given graph by randomly</p>
adding/removing edges</a></li>
<li><a href='#sample_correlated_gnp_pair'><p>Sample a pair of correlated <code class="reqn">G(n,p)</code> random graphs</p></a></li>
<li><a href='#sample_degseq'><p>Generate random graphs with a given degree sequence</p></a></li>
<li><a href='#sample_dirichlet'><p>Sample from a Dirichlet distribution</p></a></li>
<li><a href='#sample_dot_product'><p>Generate random graphs according to the random dot product graph model</p></a></li>
<li><a href='#sample_fitness'><p>Random graphs from vertex fitness scores</p></a></li>
<li><a href='#sample_fitness_pl'><p>Scale-free random graphs, from vertex fitness scores</p></a></li>
<li><a href='#sample_forestfire'><p>Forest Fire Network Model</p></a></li>
<li><a href='#sample_gnm'><p>Generate random graphs according to the <code class="reqn">G(n,m)</code> Erdős-Rényi model</p></a></li>
<li><a href='#sample_gnp'><p>Generate random graphs according to the <code class="reqn">G(n,p)</code> Erdős-Rényi model</p></a></li>
<li><a href='#sample_grg'><p>Geometric random graphs</p></a></li>
<li><a href='#sample_growing'><p>Growing random graph generation</p></a></li>
<li><a href='#sample_hierarchical_sbm'><p>Sample the hierarchical stochastic block model</p></a></li>
<li><a href='#sample_hrg'><p>Sample from a hierarchical random graph model</p></a></li>
<li><a href='#sample_islands'><p>A graph with subgraphs that are each a random graph.</p></a></li>
<li><a href='#sample_k_regular'><p>Create a random regular graph</p></a></li>
<li><a href='#sample_last_cit'><p>Random citation graphs</p></a></li>
<li><a href='#sample_motifs'><p>Graph motifs</p></a></li>
<li><a href='#sample_pa'><p>Generate random graphs using preferential attachment</p></a></li>
<li><a href='#sample_pa_age'><p>Generate an evolving random graph with preferential attachment and aging</p></a></li>
<li><a href='#sample_pref'><p>Trait-based random generation</p></a></li>
<li><a href='#sample_sbm'><p>Sample stochastic block model</p></a></li>
<li><a href='#sample_seq'><p>Sampling a random integer sequence</p></a></li>
<li><a href='#sample_smallworld'><p>The Watts-Strogatz small-world model</p></a></li>
<li><a href='#sample_spanning_tree'><p>Samples from the spanning trees of a graph randomly and uniformly</p></a></li>
<li><a href='#sample_sphere_surface'><p>Sample vectors uniformly from the surface of a sphere</p></a></li>
<li><a href='#sample_sphere_volume'><p>Sample vectors uniformly from the volume of a sphere</p></a></li>
<li><a href='#sample_traits_callaway'><p>Graph generation based on different vertex types</p></a></li>
<li><a href='#sample_tree'><p>Sample trees randomly and uniformly</p></a></li>
<li><a href='#sbm.game'><p>Sample stochastic block model</p></a></li>
<li><a href='#scan_stat'><p>Scan statistics on a time series of graphs</p></a></li>
<li><a href='#sequential_pal'><p>Sequential palette</p></a></li>
<li><a href='#set_edge_attr'><p>Set edge attributes</p></a></li>
<li><a href='#set_graph_attr'><p>Set a graph attribute</p></a></li>
<li><a href='#set_vertex_attr'><p>Set vertex attributes</p></a></li>
<li><a href='#set.edge.attribute'><p>Set edge attributes</p></a></li>
<li><a href='#set.graph.attribute'><p>Set a graph attribute</p></a></li>
<li><a href='#set.vertex.attribute'><p>Set vertex attributes</p></a></li>
<li><a href='#shapes'><p>Various vertex shapes when plotting igraph graphs</p></a></li>
<li><a href='#shortest.paths'><p>Shortest (directed or undirected) paths between vertices</p></a></li>
<li><a href='#showtrace'><p>Functions to deal with the result of network community detection</p></a></li>
<li><a href='#similarity'><p>Similarity measures of two vertices</p></a></li>
<li><a href='#simplified'><p>Constructor modifier to drop multiple and loop edges</p></a></li>
<li><a href='#simplify'><p>Simple graphs</p></a></li>
<li><a href='#spectrum'><p>Eigenvalues and eigenvectors of the adjacency matrix of a graph</p></a></li>
<li><a href='#spinglass.community'><p>Finding communities in graphs based on statistical meachanics</p></a></li>
<li><a href='#split_join_distance'><p>Split-join distance of two community structures</p></a></li>
<li><a href='#st_cuts'><p>List all (s,t)-cuts of a graph</p></a></li>
<li><a href='#st_min_cuts'><p>List all minimum <code class="reqn">(s,t)</code>-cuts of a graph</p></a></li>
<li><a href='#static.fitness.game'><p>Random graphs from vertex fitness scores</p></a></li>
<li><a href='#static.power.law.game'><p>Scale-free random graphs, from vertex fitness scores</p></a></li>
<li><a href='#stCuts'><p>List all (s,t)-cuts of a graph</p></a></li>
<li><a href='#stMincuts'><p>List all minimum \((s,t)\)-cuts of a graph</p></a></li>
<li><a href='#stochastic_matrix'><p>Stochastic matrix of a graph</p></a></li>
<li><a href='#strength'><p>Strength or weighted vertex degree</p></a></li>
<li><a href='#subcomponent'><p>In- or out- component of a vertex</p></a></li>
<li><a href='#subgraph'><p>Subgraph of a graph</p></a></li>
<li><a href='#subgraph_centrality'><p>Find subgraph centrality scores of network positions</p></a></li>
<li><a href='#subgraph_isomorphic'><p>Decide if a graph is subgraph isomorphic to another one</p></a></li>
<li><a href='#subgraph_isomorphisms'><p>All isomorphic mappings between a graph and subgraphs of another graph</p></a></li>
<li><a href='#subgraph.centrality'><p>Find subgraph centrality scores of network positions</p></a></li>
<li><a href='#tail_of'><p>Tails of the edge(s) in a graph</p></a></li>
<li><a href='#time_bins'><p>SIR model on graphs</p></a></li>
<li><a href='#tkigraph'><p>Experimental basic igraph GUI</p></a></li>
<li><a href='#tkplot'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.canvas'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.center'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.close'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.export.postscript'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.fit.to.screen'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.getcoords'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.off'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.reshape'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.rotate'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#tkplot.setcoords'><p>Interactive plotting of graphs</p></a></li>
<li><a href='#to_prufer'><p>Convert a tree graph to its Prüfer sequence</p></a></li>
<li><a href='#topo_sort'><p>Topological sorting of vertices in a graph</p></a></li>
<li><a href='#topological.sort'><p>Topological sorting of vertices in a graph</p></a></li>
<li><a href='#transitivity'><p>Transitivity of a graph</p></a></li>
<li><a href='#triad_census'><p>Triad census, subgraphs with three vertices</p></a></li>
<li><a href='#triad.census'><p>Triad census, subgraphs with three vertices</p></a></li>
<li><a href='#triangles'><p>Find triangles in graphs</p></a></li>
<li><a href='#unfold_tree'><p>Convert a general graph into a forest</p></a></li>
<li><a href='#unfold.tree'><p>Convert a general graph into a forest</p></a></li>
<li><a href='#union'><p>Union of two or more sets</p></a></li>
<li><a href='#union.igraph'><p>Union of graphs</p></a></li>
<li><a href='#union.igraph.es'><p>Union of edge sequences</p></a></li>
<li><a href='#union.igraph.vs'><p>Union of vertex sequences</p></a></li>
<li><a href='#unique.igraph.es'><p>Remove duplicate edges from an edge sequence</p></a></li>
<li><a href='#unique.igraph.vs'><p>Remove duplicate vertices from a vertex sequence</p></a></li>
<li><a href='#upgrade_graph'><p>igraph data structure versions</p></a></li>
<li><a href='#V'><p>Vertices of a graph</p></a></li>
<li><a href='#vertex'><p>Helper function for adding and deleting vertices</p></a></li>
<li><a href='#vertex_attr'><p>Query vertex attributes of a graph</p></a></li>
<li><a href='#vertex_attr_names'><p>List names of vertex attributes</p></a></li>
<li><a href='#vertex_attr+26lt+3B-'><p>Set one or more vertex attributes</p></a></li>
<li><a href='#vertex_connectivity'><p>Vertex connectivity</p></a></li>
<li><a href='#vertex.connectivity'><p>Vertex connectivity</p></a></li>
<li><a href='#vertex.disjoint.paths'><p>Vertex connectivity</p></a></li>
<li><a href='#vertex.shapes'><p>Various vertex shapes when plotting igraph graphs</p></a></li>
<li><a href='#voronoi_cells'><p>Voronoi partitioning of a graph</p></a></li>
<li><a href='#walktrap.community'><p>Community structure via short random walks</p></a></li>
<li><a href='#watts.strogatz.game'><p>The Watts-Strogatz small-world model</p></a></li>
<li><a href='#weighted_cliques'><p>Functions to find weighted cliques, i.e. vertex-weighted complete subgraphs in a graph</p></a></li>
<li><a href='#which_multiple'><p>Find the multiple or loop edges in a graph</p></a></li>
<li><a href='#which_mutual'><p>Find mutual edges in a directed graph</p></a></li>
<li><a href='#with_edge_'><p>Constructor modifier to add edge attributes</p></a></li>
<li><a href='#with_graph_'><p>Constructor modifier to add graph attributes</p></a></li>
<li><a href='#with_igraph_opt'><p>Run code with a temporary igraph options setting</p></a></li>
<li><a href='#with_vertex_'><p>Constructor modifier to add vertex attributes</p></a></li>
<li><a href='#without_attr'><p>Construtor modifier to remove all attributes from a graph</p></a></li>
<li><a href='#without_loops'><p>Constructor modifier to drop loop edges</p></a></li>
<li><a href='#without_multiples'><p>Constructor modifier to drop multiple edges</p></a></li>
<li><a href='#write_graph'><p>Writing the graph to a file in some format</p></a></li>
<li><a href='#write.graph'><p>Writing the graph to a file in some format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Title:</td>
<td>Network Analysis and Visualization</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for simple graphs and network analysis. It can
    handle large graphs very well and provides functions for generating
    random and regular graphs, graph visualization, centrality methods and
    much more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r.igraph.org/">https://r.igraph.org/</a>, <a href="https://igraph.org/">https://igraph.org/</a>,
<a href="https://igraph.discourse.group/">https://igraph.discourse.group/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/igraph/rigraph/issues">https://github.com/igraph/rigraph/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, graphics, grDevices, lifecycle, magrittr, Matrix,
pkgconfig (&ge; 2.0.0), rlang, stats, utils, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape (&ge; 5.7-0.1), callr, decor, digest, graph, igraphdata,
knitr, rgl, rmarkdown, scales, stats4, tcltk, testthat, vdiffr,
withr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.4.7)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/build:</td>
<td>roxygen2, devtools, irlba, pkgconfig</td>
</tr>
<tr>
<td>Config/Needs/coverage:</td>
<td>covr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>readr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/start-first:</td>
<td>vs-es, scan, vs-operators, weakref,
watts.strogatz.game</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libxml2 (optional), glpk (&gt;= 4.57, optional)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-12 18:19:12 UTC; kirill</td>
</tr>
<tr>
<td>Author:</td>
<td>Gábor Csárdi <a href="https://orcid.org/0000-0001-7098-9676"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Tamás Nepusz <a href="https://orcid.org/0000-0002-1451-338X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Vincent Traag <a href="https://orcid.org/0000-0003-3170-3879"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Szabolcs Horvát <a href="https://orcid.org/0000-0002-3100-523X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Fabio Zanini <a href="https://orcid.org/0000-0001-7097-8539"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel Noom [aut],
  Kirill Müller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Maëlle Salmon [ctb],
  Michael Antonov [ctb],
  Chan Zuckerberg Initiative [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kirill Müller &lt;kirill@cynkra.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-13 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='igraph-package'>The igraph package</h2><span id='topic+igraph-package'></span><span id='topic+igraph'></span>

<h3>Description</h3>

<p>igraph is a library and R package for network analysis.
</p>


<h3>Introduction</h3>

<p>The main goals of the igraph library is to provide a set of data types
and functions for 1) pain-free implementation of graph algorithms, 2)
fast handling of large graphs, with millions of vertices and edges, 3)
allowing rapid prototyping via high level languages like R.
</p>


<h3>igraph graphs</h3>

<p>igraph graphs have a class &lsquo;<code>igraph</code>&rsquo;. They are printed to
the screen in a special format, here is an example, a ring graph
created using <code><a href="#topic+make_ring">make_ring()</a></code>: </p>
<pre>
    IGRAPH U--- 10 10 -- Ring graph
    + attr: name (g/c), mutual (g/x), circular (g/x)  </pre>
<p>&lsquo;<code>IGRAPH</code>&rsquo; denotes that this is an igraph graph. Then
come four bits that denote the kind of the graph: the first is
&lsquo;<code>U</code>&rsquo; for undirected and &lsquo;<code>D</code>&rsquo; for directed
graphs. The second is &lsquo;<code>N</code>&rsquo; for named graph (i.e. if the
graph has the &lsquo;<code>name</code>&rsquo; vertex attribute set). The third is
&lsquo;<code>W</code>&rsquo; for weighted graphs (i.e. if the
&lsquo;<code>weight</code>&rsquo; edge attribute is set). The fourth is
&lsquo;<code>B</code>&rsquo; for bipartite graphs (i.e. if the
&lsquo;<code>type</code>&rsquo; vertex attribute is set).
</p>
<p>Then come two numbers, the number of vertices and the number of edges
in the graph, and after a double dash, the name of the graph (the
&lsquo;<code>name</code>&rsquo; graph attribute) is printed if present. The
second line is optional and it contains all the attributes of the
graph. This graph has a &lsquo;<code>name</code>&rsquo; graph attribute, of type
character, and two other graph attributes called
&lsquo;<code>mutual</code>&rsquo; and &lsquo;<code>circular</code>&rsquo;, of a complex
type. A complex type is simply anything that is not numeric or
character. See the documentation of <code><a href="#topic+print.igraph">print.igraph()</a></code> for
details.
</p>
<p>If you want to see the edges of the graph as well, then use the
<code><a href="#topic+print_all">print_all()</a></code> function: </p>
<pre>    &gt; print_all(g)
    IGRAPH badcafe U--- 10 10 -- Ring graph
    + attr: name (g/c), mutual (g/x), circular (g/x)
    + edges:
     [1] 1-- 2 2-- 3 3-- 4 4-- 5 5-- 6 6-- 7 7-- 8 8-- 9 9--10 1--10 </pre>


<h3>Creating graphs</h3>

<p>There are many functions in igraph for creating graphs, both
deterministic and stochastic; stochastic graph constructors are called
&lsquo;games&rsquo;.
</p>
<p>To create small graphs with a given structure probably the
<code><a href="#topic+graph_from_literal">graph_from_literal()</a></code> function is easiest. It uses R's formula
interface, its manual page contains many examples. Another option is
<code><a href="#topic+graph">graph()</a></code>, which takes numeric vertex ids directly.
<code><a href="#topic+graph_from_atlas">graph_from_atlas()</a></code> creates graph from the Graph Atlas,
<code><a href="#topic+make_graph">make_graph()</a></code> can create some special graphs.
</p>
<p>To create graphs from field data, <code><a href="#topic+graph_from_edgelist">graph_from_edgelist()</a></code>,
<code><a href="#topic+graph_from_data_frame">graph_from_data_frame()</a></code> and <code><a href="#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix()</a></code> are
probably the best choices.
</p>
<p>The igraph package includes some classic random graphs like the
Erdős-Rényi GNP and GNM graphs (<code><a href="#topic+sample_gnp">sample_gnp()</a></code>, <code><a href="#topic+sample_gnm">sample_gnm()</a></code>) and
some recent  popular models, like preferential attachment
(<code><a href="#topic+sample_pa">sample_pa()</a></code>) and the small-world model
(<code><a href="#topic+sample_smallworld">sample_smallworld()</a></code>).
</p>


<h3>Vertex and edge IDs</h3>

<p>Vertices and edges have numerical vertex ids in igraph. Vertex ids are
always consecutive and they start with one. I.e. for a graph with
<code class="reqn">n</code> vertices the vertex ids are between <code class="reqn">1</code> and
<code class="reqn">n</code>. If some operation changes the number of vertices in the
graphs, e.g. a subgraph is created via <code><a href="#topic+induced_subgraph">induced_subgraph()</a></code>, then
the vertices are renumbered to satisfy this criteria.
</p>
<p>The same is true for the edges as well, edge ids are always between
one and <code class="reqn">m</code>, the total number of edges in the graph.
</p>
<p>It is often desirable to follow vertices along a number of graph
operations, and vertex ids don't allow this because of the
renumbering. The solution is to assign attributes to the
vertices. These are kept by all operations, if possible. See more
about attributes in the next section.
</p>


<h3>Attributes</h3>

<p>In igraph it is possible to assign attributes to the vertices or edges
of a graph, or to the graph itself. igraph provides flexible
constructs for selecting a set of vertices or edges based on their
attribute values, see <code><a href="#topic+vertex_attr">vertex_attr()</a></code>,
<code><a href="#topic+V">V()</a></code> and <code><a href="#topic+E">E()</a></code> for details.
</p>
<p>Some vertex/edge/graph attributes are treated specially. One of them
is the &lsquo;name&rsquo; attribute. This is used for printing the graph
instead of the numerical ids, if it exists. Vertex names can also be
used to specify a vector or set of vertices, in all igraph
functions. E.g. <code><a href="#topic+degree">degree()</a></code> has a <code>v</code> argument
that gives the vertices for which the degree is calculated. This
argument can be given as a character vector of vertex names.
</p>
<p>Edges can also have a &lsquo;name&rsquo; attribute, and this is treated
specially as well. Just like for vertices, edges can also be selected
based on their names, e.g. in the <code><a href="#topic+delete_edges">delete_edges()</a></code> and
other functions.
</p>
<p>We note here, that vertex names can also be used to select edges.
The form &lsquo;<code>from|to</code>&rsquo;, where &lsquo;<code>from</code>&rsquo; and
&lsquo;<code>to</code>&rsquo; are vertex names, select a single, possibly
directed, edge going from &lsquo;<code>from</code>&rsquo; to
&lsquo;<code>to</code>&rsquo;. The two forms can also be mixed in the same edge
selector.
</p>
<p>Other attributes define visualization parameters, see
<a href="#topic+igraph.plotting">igraph.plotting</a> for details.
</p>
<p>Attribute values can be set to any R object, but note that storing the
graph in some file formats might result the loss of complex attribute
values. All attribute values are preserved if you use
<code><a href="base.html#topic+save">base::save()</a></code> and <code><a href="base.html#topic+load">base::load()</a></code> to store/retrieve your
graphs.
</p>


<h3>Visualization</h3>

<p>igraph provides three different ways for visualization. The first is
the <code><a href="#topic+plot.igraph">plot.igraph()</a></code> function. (Actually you don't need to
write <code>plot.igraph()</code>, <code><a href="base.html#topic+plot">plot()</a></code> is enough. This function uses
regular R graphics and can be used with any R device.
</p>
<p>The second function is <code><a href="#topic+tkplot">tkplot()</a></code>, which uses a Tk GUI for
basic interactive graph manipulation. (Tk is quite resource hungry, so
don't try this for very large graphs.)
</p>
<p>The third way requires the <code>rgl</code> package and uses OpenGL. See the
<code><a href="#topic+rglplot">rglplot()</a></code> function for the details.
</p>
<p>Make sure you read <a href="#topic+igraph.plotting">igraph.plotting</a> before you start
plotting your graphs.
</p>


<h3>File formats</h3>

<p>igraph can handle various graph file formats, usually both for reading
and writing. We suggest that you use the GraphML file format for your
graphs, except if the graphs are too big. For big graphs a simpler
format is recommended. See <code><a href="#topic+read_graph">read_graph()</a></code> and
<code><a href="#topic+write_graph">write_graph()</a></code> for details.
</p>


<h3>Further information</h3>

<p>The igraph homepage is at <a href="https://igraph.org">https://igraph.org</a>.
See especially the documentation section. Join the discussion forum at
<a href="https://igraph.discourse.group">https://igraph.discourse.group</a> if you have questions or comments.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kirill Müller <a href="mailto:kirill@cynkra.com">kirill@cynkra.com</a> (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Gábor Csárdi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> (<a href="https://orcid.org/0000-0001-7098-9676">ORCID</a>)
</p>
</li>
<li><p> Tamás Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> (<a href="https://orcid.org/0000-0002-1451-338X">ORCID</a>)
</p>
</li>
<li><p> Vincent Traag (<a href="https://orcid.org/0000-0003-3170-3879">ORCID</a>)
</p>
</li>
<li><p> Szabolcs Horvát <a href="mailto:szhorvat@gmail.com">szhorvat@gmail.com</a> (<a href="https://orcid.org/0000-0002-3100-523X">ORCID</a>)
</p>
</li>
<li><p> Fabio Zanini <a href="mailto:fabio.zanini@unsw.edu.au">fabio.zanini@unsw.edu.au</a> (<a href="https://orcid.org/0000-0001-7097-8539">ORCID</a>)
</p>
</li>
<li><p> Daniel Noom
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Maëlle Salmon [contributor]
</p>
</li>
<li><p> Michael Antonov [contributor]
</p>
</li>
<li><p> Chan Zuckerberg Initiative [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://r.igraph.org/">https://r.igraph.org/</a>
</p>
</li>
<li> <p><a href="https://igraph.org/">https://igraph.org/</a>
</p>
</li>
<li> <p><a href="https://igraph.discourse.group/">https://igraph.discourse.group/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/igraph/rigraph/issues">https://github.com/igraph/rigraph/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.igraph'>Query and manipulate a graph as it were an adjacency matrix</h2><span id='topic++5B.igraph'></span>

<h3>Description</h3>

<p>Query and manipulate a graph as it were an adjacency matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'

  x[
  i,
  j,
  ...,
  from,
  to,
  sparse = igraph_opt("sparsematrices"),
  edges = FALSE,
  drop = TRUE,
  attr = if (is_weighted(x)) "weight" else NULL
]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.igraph_+3A_x">x</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_i">i</code></td>
<td>
<p>Index. Vertex ids or names or logical vectors. See details
below.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_j">j</code></td>
<td>
<p>Index. Vertex ids or names or logical vectors. See details
below.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_from">from</code></td>
<td>
<p>A numeric or character vector giving vertex ids or
names. Together with the <code>to</code> argument, it can be used to
query/set a sequence of edges. See details below. This argument cannot
be present together with any of the <code>i</code> and <code>j</code> arguments
and if it is present, then the <code>to</code> argument must be present as
well.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_to">to</code></td>
<td>
<p>A numeric or character vector giving vertex ids or
names. Together with the <code>from</code> argument, it can be used to
query/set a sequence of edges. See details below. This argument cannot
be present together with any of the <code>i</code> and <code>j</code> arguments
and if it is present, then the <code>from</code> argument must be present as
well.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to return sparse matrices.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_edges">edges</code></td>
<td>
<p>Logical scalar, whether to return edge ids.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_drop">drop</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="+2B5B.igraph_+3A_attr">attr</code></td>
<td>
<p>If not <code>NULL</code>, then it should be the name of an edge
attribute. This attribute is queried and returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The single bracket indexes the (possibly weighted) adjacency matrix of
the graph. Here is what you can do with it:
</p>

<ol>
<li><p> Check whether there is an edge between two vertices (<code class="reqn">v</code>
and <code class="reqn">w</code>) in the graph: </p>
<pre>  graph[v, w]</pre>
<p>A numeric scalar is returned, one if the edge exists, zero
otherwise.
</p>
</li>
<li><p> Extract the (sparse) adjacency matrix of the graph, or part of
it: </p>
<pre>  graph[]
graph[1:3,5:6]
graph[c(1,3,5),]</pre>
<p>The first variants returns the full adjacency matrix, the other
two return part of it.
</p>
</li>
<li><p> The <code>from</code> and <code>to</code> arguments can be used to check
the existence of many edges. In this case, both <code>from</code> and
<code>to</code> must be present and they must have the same length. They
must contain vertex ids or names. A numeric vector is returned, of
the same length as <code>from</code> and <code>to</code>, it contains ones
for existing edges edges and zeros for non-existing ones.
Example: </p>
<pre>  graph[from=1:3, to=c(2,3,5)]</pre><p>.
</p>
</li>
<li><p> For weighted graphs, the <code>[</code> operator returns the edge
weights. For non-esistent edges zero weights are returned. Other
edge attributes can be queried as well, by giving the <code>attr</code>
argument.
</p>
</li>
<li><p> Querying edge ids instead of the existance of edges or edge
attributes. E.g. </p>
<pre>  graph[1, 2, edges=TRUE]</pre>
<p>returns the id of the edge between vertices 1 and 2, or zero if
there is no such edge.
</p>
</li>
<li><p> Adding one or more edges to a graph. For this the element(s) of
the imaginary adjacency matrix must be set to a non-zero numeric
value (or <code>TRUE</code>): </p>
<pre>  graph[1, 2] &lt;- 1
graph[1:3,1] &lt;- 1
graph[from=1:3, to=c(2,3,5)] &lt;- TRUE</pre>
<p>This does not affect edges that are already present in the graph,
i.e. no multiple edges are created.
</p>
</li>
<li><p> Adding weighted edges to a graph. The <code>attr</code> argument
contains the name of the edge attribute to set, so it does not
have to be &lsquo;weight&rsquo;: </p>
<pre>  graph[1, 2, attr="weight"]&lt;- 5
graph[from=1:3, to=c(2,3,5)] &lt;- c(1,-1,4)</pre>
<p>If an edge is already present in the network, then only its
weights or other attribute are updated. If the graph is already
weighted, then the <code>attr="weight"</code> setting is implicit, and
one does not need to give it explicitly.
</p>
</li>
<li><p> Deleting edges. The replacement syntax allow the deletion of
edges, by specifying <code>FALSE</code> or <code>NULL</code> as the
replacement value: </p>
<pre>  graph[v, w] &lt;- FALSE</pre>
<p>removes the edge from vertex <code class="reqn">v</code> to vertex <code class="reqn">w</code>.
As this can be used to delete edges between two sets of vertices,
either pairwise: </p>
<pre>  graph[from=v, to=w] &lt;- FALSE</pre>
<p>or not: </p>
<pre>  graph[v, w] &lt;- FALSE </pre>
<p>if <code class="reqn">v</code> and <code class="reqn">w</code> are vectors of edge ids or names.
</p>
</li></ol>

<p>&lsquo;<code>[</code>&rsquo; allows logical indices and negative indices as well,
with the usual R semantics. E.g. </p>
<pre>  graph[degree(graph)==0, 1] &lt;- 1</pre>
<p>adds an edge from every isolate vertex to vertex one,
and </p>
<pre>  G &lt;- make_empty_graph(10)
G[-1,1] &lt;- TRUE</pre>
<p>creates a star graph.
</p>
<p>Of course, the indexing operators support vertex names,
so instead of a numeric vertex id a vertex can also be given to
&lsquo;<code>[</code>&rsquo; and &lsquo;<code>[[</code>&rsquo;.
</p>


<h3>Value</h3>

<p>A scalar or matrix. See details below.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>

<hr>
<h2 id='+5B+5B.igraph'>Query and manipulate a graph as it were an adjacency list</h2><span id='topic++5B+5B.igraph'></span>

<h3>Description</h3>

<p>Query and manipulate a graph as it were an adjacency list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
x[[i, j, from, to, ..., directed = TRUE, edges = FALSE, exact = TRUE]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_x">x</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_i">i</code></td>
<td>
<p>Index, integer, character or logical, see details below.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_j">j</code></td>
<td>
<p>Index, integer, character or logical, see details below.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_from">from</code></td>
<td>
<p>A numeric or character vector giving vertex ids or
names. Together with the <code>to</code> argument, it can be used to
query/set a sequence of edges. See details below. This argument cannot
be present together with any of the <code>i</code> and <code>j</code> arguments
and if it is present, then the <code>to</code> argument must be present as
well.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_to">to</code></td>
<td>
<p>A numeric or character vector giving vertex ids or
names. Together with the <code>from</code> argument, it can be used to
query/set a sequence of edges. See details below. This argument cannot
be present together with any of the <code>i</code> and <code>j</code> arguments
and if it is present, then the <code>from</code> argument must be present as
well.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_...">...</code></td>
<td>
<p>Additional arguments are not used currently.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to consider edge directions
in directed graphs. It is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_edges">edges</code></td>
<td>
<p>Logical scalar, whether to return edge ids.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.igraph_+3A_exact">exact</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The double bracket operator indexes the (imaginary) adjacency list
of the graph. This can used for the following operations:
</p>

<ol>
<li><p> Querying the adjacent vertices for one or more
vertices: </p>
<pre>  graph[[1:3,]]
graph[[,1:3]]</pre>
<p>The first form gives the successors, the second the predecessors
or the 1:3 vertices. (For undirected graphs they are equivalent.)
</p>
</li>
<li><p> Querying the incident edges for one or more vertices,
if the <code>edges</code> argument is set to
<code>TRUE</code>: </p>
<pre>  graph[[1:3, , edges=TRUE]]
graph[[, 1:3, edges=TRUE]]</pre>
</li>
<li><p> Querying the edge ids between two sets or vertices,
if both indices are used. E.g. </p>
<pre>  graph[[v, w, edges=TRUE]]</pre>
<p>gives the edge ids of all the edges that exist from vertices
<code class="reqn">v</code> to vertices <code class="reqn">w</code>.
</p>
</li></ol>

<p>The alternative argument names <code>from</code> and <code>to</code> can be used
instead of the usual <code>i</code> and <code>j</code>, to make the code more
readable: </p>
<pre> graph[[from = 1:3]]
graph[[from = v, to = w, edges = TRUE]]</pre>
<p>&lsquo;<code>[[</code>&rsquo; operators allows logical indices and negative indices
as well, with the usual R semantics.
</p>
<p>Vertex names are also supported, so instead of a numeric vertex id a
vertex can also be given to &lsquo;<code>[</code>&rsquo; and &lsquo;<code>[[</code>&rsquo;.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Magrittr's pipes</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>igraph re-exports the <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code> operator of magrittr, because
we find it very useful. Please see the documentation in the
<code>magrittr</code> package.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>Left hand side of the pipe.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>Right hand side of the pipe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of applying the right hand side to the
result of the left hand side.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_ring(10) %&gt;%
  add_edges(c(1, 6)) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='+2B.igraph'>Add vertices, edges or another graph to a graph</h2><span id='topic++2B.igraph'></span>

<h3>Description</h3>

<p>Add vertices, edges or another graph to a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
e1 + e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.igraph_+3A_e1">e1</code></td>
<td>
<p>First argument, probably an igraph graph, but see details
below.</p>
</td></tr>
<tr><td><code id="+2B2B.igraph_+3A_e2">e2</code></td>
<td>
<p>Second argument, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plus operator can be used to add vertices or edges to graph.
The actual operation that is performed depends on the type of the
right hand side argument.
</p>

<ul>
<li><p> If is is another igraph graph object and they are both
named graphs, then the union of the two graphs are calculated,
see <code><a href="#topic+union">union()</a></code>.
</p>
</li>
<li><p> If it is another igraph graph object, but either of the two
are not named, then the disjoint union of
the two graphs is calculated, see <code><a href="#topic+disjoint_union">disjoint_union()</a></code>.
</p>
</li>
<li><p> If it is a numeric scalar, then the specified number of vertices
are added to the graph.
</p>
</li>
<li><p> If it is a character scalar or vector, then it is interpreted as
the names of the vertices to add to the graph.
</p>
</li>
<li><p> If it is an object created with the <code><a href="#topic+vertex">vertex()</a></code> or
<code><a href="#topic+vertices">vertices()</a></code> function, then new vertices are added to the
graph. This form is appropriate when one wants to add some vertex
attributes as well. The operands of the <code>vertices()</code> function
specifies the number of vertices to add and their attributes as
well.
</p>
<p>The unnamed arguments of <code>vertices()</code> are concatenated and
used as the &lsquo;<code>name</code>&rsquo; vertex attribute (i.e. vertex
names), the named arguments will be added as additional vertex
attributes. Examples: </p>
<pre>  g &lt;- g +
        vertex(shape="circle", color= "red")
  g &lt;- g + vertex("foo", color="blue")
  g &lt;- g + vertex("bar", "foobar")
  g &lt;- g + vertices("bar2", "foobar2", color=1:2, shape="rectangle")</pre>
<p><code>vertex()</code> is just an alias to <code>vertices()</code>, and it is
provided for readability. The user should use it if a single vertex
is added to the graph.
</p>
</li>
<li><p> If it is an object created with the <code><a href="#topic+edge">edge()</a></code> or
<code><a href="#topic+edges">edges()</a></code> function, then new edges will be added to the
graph. The new edges and possibly their attributes can be specified as
the arguments of the <code>edges()</code> function.
</p>
<p>The unnamed arguments of <code>edges()</code> are concatenated and used
as vertex ids of the end points of the new edges. The named
arguments will be added as edge attributes.
</p>
<p>Examples: </p>
<pre>  g &lt;- make_empty_graph() +
         vertices(letters[1:10]) +
         vertices("foo", "bar", "bar2", "foobar2")
  g &lt;- g + edge("a", "b")
  g &lt;- g + edges("foo", "bar", "bar2", "foobar2")
  g &lt;- g + edges(c("bar", "foo", "foobar2", "bar2"), color="red", weight=1:2)</pre>
<p>See more examples below.
</p>
<p><code>edge()</code> is just an alias to <code>edges()</code> and it is provided
for readability. The user should use it if a single edge is added to
the graph.
</p>
</li>
<li><p> If it is an object created with the <code><a href="#topic+path">path()</a></code> function, then
new edges that form a path are added. The edges and possibly their
attributes are specified as the arguments to the <code>path()</code>
function. The non-named arguments are concatenated and interpreted
as the vertex ids along the path. The remaining arguments are added
as edge attributes.
</p>
<p>Examples: </p>
<pre>  g &lt;- make_empty_graph() + vertices(letters[1:10])
  g &lt;- g + path("a", "b", "c", "d")
  g &lt;- g + path("e", "f", "g", weight=1:2, color="red")
  g &lt;- g + path(c("f", "c", "j", "d"), width=1:3, color="green")</pre>
</li></ul>

<p>It is important to note that, although the plus operator is
commutative, i.e. is possible to write </p>
<pre>  graph &lt;- "foo" + make_empty_graph()</pre>
<p>it is not associative, e.g. </p>
<pre>  graph &lt;- "foo" + "bar" + make_empty_graph()</pre>
<p>results a syntax error, unless parentheses are used: </p>
<pre>  graph &lt;- "foo" + ( "bar" + make_empty_graph() )</pre>
<p>For clarity, we suggest to always put the graph object on the left
hand side of the operator: </p>
<pre>  graph &lt;- make_empty_graph() + "foo" + "bar"</pre>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 10 vertices named a,b,c,... and no edges
g &lt;- make_empty_graph() + vertices(letters[1:10])

# Add edges to make it a ring
g &lt;- g + path(letters[1:10], letters[1], color = "grey")

# Add some extra random edges
g &lt;- g + edges(sample(V(g), 10, replace = TRUE), color = "red")
g$layout &lt;- layout_in_circle
plot(g)
</code></pre>

<hr>
<h2 id='add_edges'>Add edges to a graph</h2><span id='topic+add_edges'></span>

<h3>Description</h3>

<p>The new edges are given as a vertex sequence, e.g. internal
numeric vertex ids, or vertex names. The first edge points from
<code>edges[1]</code> to <code>edges[2]</code>, the second from <code>edges[3]</code>
to <code>edges[4]</code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_edges(graph, edges, ..., attr = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_edges_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="add_edges_+3A_edges">edges</code></td>
<td>
<p>The edges to add, a vertex sequence with even number
of vertices.</p>
</td></tr>
<tr><td><code id="add_edges_+3A_...">...</code></td>
<td>
<p>Additional arguments, they must be named,
and they will be added as edge attributes, for the newly added
edges. See also details below.</p>
</td></tr>
<tr><td><code id="add_edges_+3A_attr">attr</code></td>
<td>
<p>A named list, its elements will be added
as edge attributes, for the newly added edges. See also details
below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If attributes are supplied, and they are not present in the graph,
their values for the original edges of the graph are set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>The graph, with the edges (and attributes) added.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_empty_graph(n = 5) %&gt;%
  add_edges(c(
    1, 2,
    2, 3,
    3, 4,
    4, 5
  )) %&gt;%
  set_edge_attr("color", value = "red") %&gt;%
  add_edges(c(5, 1), color = "green")
E(g)[[]]
plot(g)
</code></pre>

<hr>
<h2 id='add_layout_'>Add layout to graph</h2><span id='topic+add_layout_'></span>

<h3>Description</h3>

<p>Add layout to graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_layout_(graph, ..., overwrite = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_layout__+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="add_layout__+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code><a href="#topic+layout_">layout_()</a></code>.</p>
</td></tr>
<tr><td><code id="add_layout__+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to overwrite the layout of the graph,
if it already has one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input graph, with the layout added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout_">layout_()</a></code> for a description of the layout API.
</p>
<p>Other graph layouts: 
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(make_star(11) + make_star(11)) %&gt;%
  add_layout_(as_star(), component_wise()) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='add_vertices'>Add vertices to a graph</h2><span id='topic+add_vertices'></span>

<h3>Description</h3>

<p>If attributes are supplied, and they are not present in the graph,
their values for the original vertices of the graph are set to
<code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_vertices(graph, nv, ..., attr = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_vertices_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="add_vertices_+3A_nv">nv</code></td>
<td>
<p>The number of vertices to add.</p>
</td></tr>
<tr><td><code id="add_vertices_+3A_...">...</code></td>
<td>
<p>Additional arguments, they must be named,
and they will be added as vertex attributes, for the newly added
vertices. See also details below.</p>
</td></tr>
<tr><td><code id="add_vertices_+3A_attr">attr</code></td>
<td>
<p>A named list, its elements will be added
as vertex attributes, for the newly added vertices. See also details
below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the vertices (and attributes) added.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_empty_graph() %&gt;%
  add_vertices(3, color = "red") %&gt;%
  add_vertices(2, color = "green") %&gt;%
  add_edges(c(
    1, 2,
    2, 3,
    3, 4,
    4, 5
  ))
g
V(g)[[]]
plot(g)
</code></pre>

<hr>
<h2 id='add.edges'>Add edges to a graph</h2><span id='topic+add.edges'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>add.edges()</code> was renamed to <code>add_edges()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.edges(graph, edges, ..., attr = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.edges_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="add.edges_+3A_edges">edges</code></td>
<td>
<p>The edges to add, a vertex sequence with even number
of vertices.</p>
</td></tr>
<tr><td><code id="add.edges_+3A_...">...</code></td>
<td>
<p>Additional arguments, they must be named,
and they will be added as edge attributes, for the newly added
edges. See also details below.</p>
</td></tr>
<tr><td><code id="add.edges_+3A_attr">attr</code></td>
<td>
<p>A named list, its elements will be added
as edge attributes, for the newly added edges. See also details
below.</p>
</td></tr>
</table>

<hr>
<h2 id='add.vertex.shape'>Various vertex shapes when plotting igraph graphs</h2><span id='topic+add.vertex.shape'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>add.vertex.shape()</code> was renamed to <code>add_shape()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.vertex.shape(
  shape,
  clip = shape_noclip,
  plot = shape_noplot,
  parameters = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.vertex.shape_+3A_shape">shape</code></td>
<td>
<p>Character scalar, name of a vertex shape. If it is
<code>NULL</code> for <code>shapes()</code>, then the names of all defined
vertex shapes are returned.</p>
</td></tr>
<tr><td><code id="add.vertex.shape_+3A_clip">clip</code></td>
<td>
<p>An R function object, the clipping function.</p>
</td></tr>
<tr><td><code id="add.vertex.shape_+3A_plot">plot</code></td>
<td>
<p>An R function object, the plotting function.</p>
</td></tr>
<tr><td><code id="add.vertex.shape_+3A_parameters">parameters</code></td>
<td>
<p>Named list, additional plot/vertex/edge
parameters. The element named define the new parameters, and the
elements themselves define their default values.
Vertex parameters should have a prefix
&lsquo;<code>vertex.</code>&rsquo;, edge parameters a prefix
&lsquo;<code>edge.</code>&rsquo;. Other general plotting parameters should have
a prefix &lsquo;<code>plot.</code>&rsquo;. See Details below.</p>
</td></tr>
</table>

<hr>
<h2 id='add.vertices'>Add vertices to a graph</h2><span id='topic+add.vertices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>add.vertices()</code> was renamed to <code>add_vertices()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.vertices(graph, nv, ..., attr = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.vertices_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="add.vertices_+3A_nv">nv</code></td>
<td>
<p>The number of vertices to add.</p>
</td></tr>
<tr><td><code id="add.vertices_+3A_...">...</code></td>
<td>
<p>Additional arguments, they must be named,
and they will be added as vertex attributes, for the newly added
vertices. See also details below.</p>
</td></tr>
<tr><td><code id="add.vertices_+3A_attr">attr</code></td>
<td>
<p>A named list, its elements will be added
as vertex attributes, for the newly added vertices. See also details
below.</p>
</td></tr>
</table>

<hr>
<h2 id='adjacent_vertices'>Adjacent vertices of multiple vertices in a graph</h2><span id='topic+adjacent_vertices'></span>

<h3>Description</h3>

<p>This function is similar to <code><a href="#topic+neighbors">neighbors()</a></code>, but it queries
the adjacent vertices for multiple vertices at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacent_vertices(graph, v, mode = c("out", "in", "all", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacent_vertices_+3A_graph">graph</code></td>
<td>
<p>Input graph.</p>
</td></tr>
<tr><td><code id="adjacent_vertices_+3A_v">v</code></td>
<td>
<p>The vertices to query.</p>
</td></tr>
<tr><td><code id="adjacent_vertices_+3A_mode">mode</code></td>
<td>
<p>Whether to query outgoing (&lsquo;out&rsquo;), incoming
(&lsquo;in&rsquo;) edges, or both types (&lsquo;all&rsquo;). This is
ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vertex sequences.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Zachary")
adjacent_vertices(g, c(1, 34))
</code></pre>

<hr>
<h2 id='adjacent.triangles'>Find triangles in graphs</h2><span id='topic+adjacent.triangles'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>adjacent.triangles()</code> was renamed to <code>count_triangles()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacent.triangles(graph, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacent.triangles_+3A_graph">graph</code></td>
<td>
<p>The input graph. It might be directed, but edge directions are
ignored.</p>
</td></tr>
<tr><td><code id="adjacent.triangles_+3A_vids">vids</code></td>
<td>
<p>The vertices to query, all of them by default. This might be a
vector of numeric ids, or a character vector of symbolic vertex names for
named graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='aging.ba.game'>Generate an evolving random graph with preferential attachment and aging</h2><span id='topic+aging.ba.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>aging.ba.game()</code> was renamed to <code>sample_pa_age()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aging.ba.game(
  n,
  pa.exp,
  aging.exp,
  m = NULL,
  aging.bin = 300,
  out.dist = NULL,
  out.seq = NULL,
  out.pref = FALSE,
  directed = TRUE,
  zero.deg.appeal = 1,
  zero.age.appeal = 0,
  deg.coef = 1,
  age.coef = 1,
  time.window = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aging.ba.game_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_pa.exp">pa.exp</code></td>
<td>
<p>The preferential attachment exponent, see the details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_aging.exp">aging.exp</code></td>
<td>
<p>The exponent of the aging, usually a non-positive number,
see details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_m">m</code></td>
<td>
<p>The number of edges each new vertex creates (except the very first
vertex). This argument is used only if both the <code>out.dist</code> and
<code>out.seq</code> arguments are NULL.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_aging.bin">aging.bin</code></td>
<td>
<p>The number of bins to use for measuring the age of
vertices, see details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_out.dist">out.dist</code></td>
<td>
<p>The discrete distribution to generate the number of edges to
add in each time step if <code>out.seq</code> is NULL. See details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_out.seq">out.seq</code></td>
<td>
<p>The number of edges to add in each time step, a vector
containing as many elements as the number of vertices. See details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_out.pref">out.pref</code></td>
<td>
<p>Logical constant, whether to include edges not initiated by
the vertex as a basis of preferential attachment. See details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to generate a directed graph. See
details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_zero.deg.appeal">zero.deg.appeal</code></td>
<td>
<p>The degree-dependent part of the
&lsquo;attractiveness&rsquo; of the vertices with no adjacent edges. See also
details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_zero.age.appeal">zero.age.appeal</code></td>
<td>
<p>The age-dependent part of the &lsquo;attrativeness&rsquo;
of the vertices with age zero. It is usually zero, see details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_deg.coef">deg.coef</code></td>
<td>
<p>The coefficient of the degree-dependent
&lsquo;attractiveness&rsquo;. See details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_age.coef">age.coef</code></td>
<td>
<p>The coefficient of the age-dependent part of the
&lsquo;attractiveness&rsquo;. See details below.</p>
</td></tr>
<tr><td><code id="aging.ba.game_+3A_time.window">time.window</code></td>
<td>
<p>Integer constant, if NULL only adjacent added in the last
<code>time.windows</code> time steps are counted as a basis of the preferential
attachment. See also details below.</p>
</td></tr>
</table>

<hr>
<h2 id='aging.barabasi.game'>Generate an evolving random graph with preferential attachment and aging</h2><span id='topic+aging.barabasi.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>aging.barabasi.game()</code> was renamed to <code>sample_pa_age()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aging.barabasi.game(
  n,
  pa.exp,
  aging.exp,
  m = NULL,
  aging.bin = 300,
  out.dist = NULL,
  out.seq = NULL,
  out.pref = FALSE,
  directed = TRUE,
  zero.deg.appeal = 1,
  zero.age.appeal = 0,
  deg.coef = 1,
  age.coef = 1,
  time.window = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aging.barabasi.game_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_pa.exp">pa.exp</code></td>
<td>
<p>The preferential attachment exponent, see the details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_aging.exp">aging.exp</code></td>
<td>
<p>The exponent of the aging, usually a non-positive number,
see details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_m">m</code></td>
<td>
<p>The number of edges each new vertex creates (except the very first
vertex). This argument is used only if both the <code>out.dist</code> and
<code>out.seq</code> arguments are NULL.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_aging.bin">aging.bin</code></td>
<td>
<p>The number of bins to use for measuring the age of
vertices, see details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_out.dist">out.dist</code></td>
<td>
<p>The discrete distribution to generate the number of edges to
add in each time step if <code>out.seq</code> is NULL. See details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_out.seq">out.seq</code></td>
<td>
<p>The number of edges to add in each time step, a vector
containing as many elements as the number of vertices. See details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_out.pref">out.pref</code></td>
<td>
<p>Logical constant, whether to include edges not initiated by
the vertex as a basis of preferential attachment. See details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to generate a directed graph. See
details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_zero.deg.appeal">zero.deg.appeal</code></td>
<td>
<p>The degree-dependent part of the
&lsquo;attractiveness&rsquo; of the vertices with no adjacent edges. See also
details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_zero.age.appeal">zero.age.appeal</code></td>
<td>
<p>The age-dependent part of the &lsquo;attrativeness&rsquo;
of the vertices with age zero. It is usually zero, see details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_deg.coef">deg.coef</code></td>
<td>
<p>The coefficient of the degree-dependent
&lsquo;attractiveness&rsquo;. See details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_age.coef">age.coef</code></td>
<td>
<p>The coefficient of the age-dependent part of the
&lsquo;attractiveness&rsquo;. See details below.</p>
</td></tr>
<tr><td><code id="aging.barabasi.game_+3A_time.window">time.window</code></td>
<td>
<p>Integer constant, if NULL only adjacent added in the last
<code>time.windows</code> time steps are counted as a basis of the preferential
attachment. See also details below.</p>
</td></tr>
</table>

<hr>
<h2 id='aging.prefatt.game'>Generate an evolving random graph with preferential attachment and aging</h2><span id='topic+aging.prefatt.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>aging.prefatt.game()</code> was renamed to <code>sample_pa_age()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aging.prefatt.game(
  n,
  pa.exp,
  aging.exp,
  m = NULL,
  aging.bin = 300,
  out.dist = NULL,
  out.seq = NULL,
  out.pref = FALSE,
  directed = TRUE,
  zero.deg.appeal = 1,
  zero.age.appeal = 0,
  deg.coef = 1,
  age.coef = 1,
  time.window = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aging.prefatt.game_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_pa.exp">pa.exp</code></td>
<td>
<p>The preferential attachment exponent, see the details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_aging.exp">aging.exp</code></td>
<td>
<p>The exponent of the aging, usually a non-positive number,
see details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_m">m</code></td>
<td>
<p>The number of edges each new vertex creates (except the very first
vertex). This argument is used only if both the <code>out.dist</code> and
<code>out.seq</code> arguments are NULL.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_aging.bin">aging.bin</code></td>
<td>
<p>The number of bins to use for measuring the age of
vertices, see details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_out.dist">out.dist</code></td>
<td>
<p>The discrete distribution to generate the number of edges to
add in each time step if <code>out.seq</code> is NULL. See details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_out.seq">out.seq</code></td>
<td>
<p>The number of edges to add in each time step, a vector
containing as many elements as the number of vertices. See details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_out.pref">out.pref</code></td>
<td>
<p>Logical constant, whether to include edges not initiated by
the vertex as a basis of preferential attachment. See details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to generate a directed graph. See
details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_zero.deg.appeal">zero.deg.appeal</code></td>
<td>
<p>The degree-dependent part of the
&lsquo;attractiveness&rsquo; of the vertices with no adjacent edges. See also
details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_zero.age.appeal">zero.age.appeal</code></td>
<td>
<p>The age-dependent part of the &lsquo;attrativeness&rsquo;
of the vertices with age zero. It is usually zero, see details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_deg.coef">deg.coef</code></td>
<td>
<p>The coefficient of the degree-dependent
&lsquo;attractiveness&rsquo;. See details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_age.coef">age.coef</code></td>
<td>
<p>The coefficient of the age-dependent part of the
&lsquo;attractiveness&rsquo;. See details below.</p>
</td></tr>
<tr><td><code id="aging.prefatt.game_+3A_time.window">time.window</code></td>
<td>
<p>Integer constant, if NULL only adjacent added in the last
<code>time.windows</code> time steps are counted as a basis of the preferential
attachment. See also details below.</p>
</td></tr>
</table>

<hr>
<h2 id='all_simple_paths'>List all simple paths from one source</h2><span id='topic+all_simple_paths'></span>

<h3>Description</h3>

<p>This function lists are simple paths from one source vertex to another
vertex or vertices. A path is simple if the vertices it visits are not
visited more than once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_simple_paths(
  graph,
  from,
  to = V(graph),
  mode = c("out", "in", "all", "total"),
  cutoff = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_simple_paths_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="all_simple_paths_+3A_from">from</code></td>
<td>
<p>The source vertex.</p>
</td></tr>
<tr><td><code id="all_simple_paths_+3A_to">to</code></td>
<td>
<p>The target vertex of vertices. Defaults to all vertices.</p>
</td></tr>
<tr><td><code id="all_simple_paths_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or
from the given vertices should be calculated for directed graphs. If
<code>out</code> then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code>
then <em>to</em> it will be considered. If <code>all</code>, the default, then
the corresponding undirected graph will be used, i.e. not directed paths
are searched. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="all_simple_paths_+3A_cutoff">cutoff</code></td>
<td>
<p>Maximum length of path that is considered. If negative, paths of all lengths are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that potentially there are exponentially many paths between two
vertices of a graph, and you may run out of memory when using this
function, if your graph is lattice-like.
</p>
<p>This function currently ignored multiple and loop edges.
</p>


<h3>Value</h3>

<p>A list of integer vectors, each integer vector is a path from
the source vertex to one of the target vertices. A path is given by its
vertex ids.
</p>


<h3>See Also</h3>

<p>Other paths: 
<code><a href="#topic+diameter">diameter</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+eccentricity">eccentricity</a>()</code>,
<code><a href="#topic+radius">radius</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
all_simple_paths(g, 1, 5)
all_simple_paths(g, 1, c(3, 5))

</code></pre>

<hr>
<h2 id='alpha_centrality'>Find Bonacich alpha centrality scores of network positions</h2><span id='topic+alpha_centrality'></span>

<h3>Description</h3>

<p><code>alpha_centrality()</code> calculates the alpha centrality of some (or all)
vertices in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha_centrality(
  graph,
  nodes = V(graph),
  alpha = 1,
  loops = FALSE,
  exo = 1,
  weights = NULL,
  tol = 1e-07,
  sparse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha_centrality_+3A_graph">graph</code></td>
<td>
<p>The input graph, can be directed or undirected. In undirected
graphs, edges are treated as if they were reciprocal directed ones.</p>
</td></tr>
<tr><td><code id="alpha_centrality_+3A_nodes">nodes</code></td>
<td>
<p>Vertex sequence, the vertices for which the alpha centrality
values are returned. (For technical reasons they will be calculated for all
vertices, anyway.)</p>
</td></tr>
<tr><td><code id="alpha_centrality_+3A_alpha">alpha</code></td>
<td>
<p>Parameter specifying the relative importance of endogenous
versus exogenous factors in the determination of centrality. See details
below.</p>
</td></tr>
<tr><td><code id="alpha_centrality_+3A_loops">loops</code></td>
<td>
<p>Whether to eliminate loop edges from the graph before the
calculation.</p>
</td></tr>
<tr><td><code id="alpha_centrality_+3A_exo">exo</code></td>
<td>
<p>The exogenous factors, in most cases this is either a constant &ndash;
the same factor for every node, or a vector giving the factor for every
vertex. Note that too long vectors will be truncated and too short vectors
will be replicated to match the number of vertices.</p>
</td></tr>
<tr><td><code id="alpha_centrality_+3A_weights">weights</code></td>
<td>
<p>A character scalar that gives the name of the edge attribute
to use in the adjacency matrix. If it is <code>NULL</code>, then the
&lsquo;weight&rsquo; edge attribute of the graph is used, if there is one.
Otherwise, or if it is <code>NA</code>, then the calculation uses the standard
adjacency matrix.</p>
</td></tr>
<tr><td><code id="alpha_centrality_+3A_tol">tol</code></td>
<td>
<p>Tolerance for near-singularities during matrix inversion, see
<code><a href="base.html#topic+solve">solve()</a></code>.</p>
</td></tr>
<tr><td><code id="alpha_centrality_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to use sparse matrices for the
calculation. The &lsquo;Matrix&rsquo; package is required for sparse matrix
support</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The alpha centrality measure can be considered as a generalization of
eigenvector centrality to directed graphs. It was proposed by Bonacich in
2001 (see reference below).
</p>
<p>The alpha centrality of the vertices in a graph is defined as the solution
of the following matrix equation: </p>
<p style="text-align: center;"><code class="reqn">x=\alpha A^T x+e,</code>
</p>

<p>where <code class="reqn">A</code> is the (not necessarily symmetric) adjacency matrix of the
graph, <code class="reqn">e</code> is the vector of exogenous sources of status of the
vertices and <code class="reqn">\alpha</code> is the relative importance of the
endogenous versus exogenous factors.
</p>


<h3>Value</h3>

<p>A numeric vector contaning the centrality scores for the selected
vertices.
</p>


<h3>Warning</h3>

<p>Singular adjacency matrices cause problems for this
algorithm, the routine may fail is certain cases.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Bonacich, P. and Lloyd, P. (2001). &ldquo;Eigenvector-like
measures of centrality for asymmetric relations&rdquo; <em>Social Networks</em>,
23, 191-201.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigen_centrality">eigen_centrality()</a></code> and <code><a href="#topic+power_centrality">power_centrality()</a></code>
</p>
<p>Centrality measures
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The examples from Bonacich's paper
g.1 &lt;- make_graph(c(1, 3, 2, 3, 3, 4, 4, 5))
g.2 &lt;- make_graph(c(2, 1, 3, 1, 4, 1, 5, 1))
g.3 &lt;- make_graph(c(1, 2, 2, 3, 3, 4, 4, 1, 5, 1))
alpha_centrality(g.1)
alpha_centrality(g.2)
alpha_centrality(g.3, alpha = 0.5)

</code></pre>

<hr>
<h2 id='alpha.centrality'>Find Bonacich alpha centrality scores of network positions</h2><span id='topic+alpha.centrality'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>alpha.centrality()</code> was renamed to <code>alpha_centrality()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.centrality(
  graph,
  nodes = V(graph),
  alpha = 1,
  loops = FALSE,
  exo = 1,
  weights = NULL,
  tol = 1e-07,
  sparse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alpha.centrality_+3A_graph">graph</code></td>
<td>
<p>The input graph, can be directed or undirected. In undirected
graphs, edges are treated as if they were reciprocal directed ones.</p>
</td></tr>
<tr><td><code id="alpha.centrality_+3A_nodes">nodes</code></td>
<td>
<p>Vertex sequence, the vertices for which the alpha centrality
values are returned. (For technical reasons they will be calculated for all
vertices, anyway.)</p>
</td></tr>
<tr><td><code id="alpha.centrality_+3A_alpha">alpha</code></td>
<td>
<p>Parameter specifying the relative importance of endogenous
versus exogenous factors in the determination of centrality. See details
below.</p>
</td></tr>
<tr><td><code id="alpha.centrality_+3A_loops">loops</code></td>
<td>
<p>Whether to eliminate loop edges from the graph before the
calculation.</p>
</td></tr>
<tr><td><code id="alpha.centrality_+3A_exo">exo</code></td>
<td>
<p>The exogenous factors, in most cases this is either a constant &ndash;
the same factor for every node, or a vector giving the factor for every
vertex. Note that too long vectors will be truncated and too short vectors
will be replicated to match the number of vertices.</p>
</td></tr>
<tr><td><code id="alpha.centrality_+3A_weights">weights</code></td>
<td>
<p>A character scalar that gives the name of the edge attribute
to use in the adjacency matrix. If it is <code>NULL</code>, then the
&lsquo;weight&rsquo; edge attribute of the graph is used, if there is one.
Otherwise, or if it is <code>NA</code>, then the calculation uses the standard
adjacency matrix.</p>
</td></tr>
<tr><td><code id="alpha.centrality_+3A_tol">tol</code></td>
<td>
<p>Tolerance for near-singularities during matrix inversion, see
<code><a href="base.html#topic+solve">solve()</a></code>.</p>
</td></tr>
<tr><td><code id="alpha.centrality_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to use sparse matrices for the
calculation. The &lsquo;Matrix&rsquo; package is required for sparse matrix
support</p>
</td></tr>
</table>

<hr>
<h2 id='are_adjacent'>Are two vertices adjacent?</h2><span id='topic+are_adjacent'></span>

<h3>Description</h3>

<p>The order of the vertices only matters in directed graphs,
where the existence of a directed <code style="white-space: pre;">&#8288;(v1, v2)&#8288;</code> edge is queried.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are_adjacent(graph, v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are_adjacent_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="are_adjacent_+3A_v1">v1</code></td>
<td>
<p>The first vertex, tail in directed graphs.</p>
</td></tr>
<tr><td><code id="are_adjacent_+3A_v2">v2</code></td>
<td>
<p>The second vertex, head in directed graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar, <code>TRUE</code> if edge <code style="white-space: pre;">&#8288;(v1, v2)&#8288;</code> exists in the graph.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ug &lt;- make_ring(10)
ug
are_adjacent(ug, 1, 2)
are_adjacent(ug, 2, 1)

dg &lt;- make_ring(10, directed = TRUE)
dg
are_adjacent(ug, 1, 2)
are_adjacent(ug, 2, 1)
</code></pre>

<hr>
<h2 id='are.connected'>Are two vertices adjacent?</h2><span id='topic+are.connected'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>are.connected()</code> was renamed to <code>are_adjacent()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are.connected(graph, v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are.connected_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="are.connected_+3A_v1">v1</code></td>
<td>
<p>The first vertex, tail in directed graphs.</p>
</td></tr>
<tr><td><code id="are.connected_+3A_v2">v2</code></td>
<td>
<p>The second vertex, head in directed graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='arpack_defaults'>ARPACK eigenvector calculation</h2><span id='topic+arpack_defaults'></span><span id='topic+arpack'></span><span id='topic+arpack-options'></span><span id='topic+arpack.unpack.complex'></span>

<h3>Description</h3>

<p>Interface to the ARPACK library for calculating eigenvectors of sparse
matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arpack_defaults()

arpack(
  func,
  extra = NULL,
  sym = FALSE,
  options = arpack_defaults(),
  env = parent.frame(),
  complex = !sym
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arpack_defaults_+3A_func">func</code></td>
<td>
<p>The function to perform the matrix-vector multiplication. ARPACK
requires to perform these by the user. The function gets the vector <code class="reqn">x</code>
as the first argument, and it should return <code class="reqn">Ax</code>, where <code class="reqn">A</code> is the
&ldquo;input matrix&rdquo;. (The input matrix is never given explicitly.) The
second argument is <code>extra</code>.</p>
</td></tr>
<tr><td><code id="arpack_defaults_+3A_extra">extra</code></td>
<td>
<p>Extra argument to supply to <code>func</code>.</p>
</td></tr>
<tr><td><code id="arpack_defaults_+3A_sym">sym</code></td>
<td>
<p>Logical scalar, whether the input matrix is symmetric. Always
supply <code>TRUE</code> here if it is, since it can speed up the computation.</p>
</td></tr>
<tr><td><code id="arpack_defaults_+3A_options">options</code></td>
<td>
<p>Options to ARPACK, a named list to overwrite some of the
default option values. See details below.</p>
</td></tr>
<tr><td><code id="arpack_defaults_+3A_env">env</code></td>
<td>
<p>The environment in which <code>func</code> will be evaluated.</p>
</td></tr>
<tr><td><code id="arpack_defaults_+3A_complex">complex</code></td>
<td>
<p>Whether to convert the eigenvectors returned by ARPACK into R
complex vectors. By default this is not done for symmetric problems (these
only have real eigenvectors/values), but only non-symmetric ones. If you
have a non-symmetric problem, but you're sure that the results will be real,
then supply <code>FALSE</code> here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ARPACK is a library for solving large scale eigenvalue problems.  The
package is designed to compute a few eigenvalues and corresponding
eigenvectors of a general <code class="reqn">n</code> by <code class="reqn">n</code> matrix <code class="reqn">A</code>. It is most
appropriate for large sparse or structured matrices <code class="reqn">A</code> where structured
means that a matrix-vector product <code>w &lt;- Av</code> requires order <code class="reqn">n</code>
rather than the usual order <code class="reqn">n^2</code> floating point operations.
</p>
<p>This function is an interface to ARPACK. igraph does not contain all ARPACK
routines, only the ones dealing with symmetric and non-symmetric eigenvalue
problems using double precision real numbers.
</p>
<p>The eigenvalue calculation in ARPACK (in the simplest case) involves the
calculation of the <code class="reqn">Av</code> product where <code class="reqn">A</code> is the matrix we work with
and <code class="reqn">v</code> is an arbitrary vector. The function supplied in the <code>fun</code>
argument is expected to perform this product. If the product can be done
efficiently, e.g. if the matrix is sparse, then <code>arpack()</code> is usually
able to calculate the eigenvalues very quickly.
</p>
<p>The <code>options</code> argument specifies what kind of calculation to perform.
It is a list with the following members, they correspond directly to ARPACK
parameters. On input it has the following fields: </p>

<dl>
<dt>bmat</dt><dd><p>Character constant, possible values: &lsquo;<code>I</code>&rsquo;, standard
eigenvalue problem, <code class="reqn">Ax=\lambda x</code>; and &lsquo;<code>G</code>&rsquo;,
generalized eigenvalue problem, <code class="reqn">Ax=\lambda B x</code>.
Currently only &lsquo;<code>I</code>&rsquo; is supported.</p>
</dd> <dt>n</dt><dd><p>Numeric scalar. The
dimension of the eigenproblem. You only need to set this if you call
<code><a href="#topic+arpack">arpack()</a></code> directly. (I.e. not needed for
<code><a href="#topic+eigen_centrality">eigen_centrality()</a></code>, <code><a href="#topic+page_rank">page_rank()</a></code>, etc.)</p>
</dd>
<dt>which</dt><dd><p>Specify which eigenvalues/vectors to compute, character
constant with exactly two characters.
</p>
<p>Possible values for symmetric input matrices: </p>

<dl>
<dt>&quot;LA&quot;</dt><dd><p>Compute <code>nev</code> largest (algebraic) eigenvalues.</p>
</dd>
<dt>&quot;SA&quot;</dt><dd><p>Compute <code>nev</code> smallest (algebraic)
eigenvalues.</p>
</dd> <dt>&quot;LM&quot;</dt><dd><p>Compute <code>nev</code> largest (in
magnitude) eigenvalues.</p>
</dd> <dt>&quot;SM&quot;</dt><dd><p>Compute <code>nev</code> smallest
(in magnitude) eigenvalues.</p>
</dd> <dt>&quot;BE&quot;</dt><dd><p>Compute <code>nev</code>
eigenvalues, half from each end of the spectrum. When <code>nev</code> is odd,
compute one more from the high end than from the low end.</p>
</dd> </dl>

<p>Possible values for non-symmetric input matrices: </p>

<dl>
<dt>&quot;LM&quot;</dt><dd><p>Compute <code>nev</code> eigenvalues of largest
magnitude.</p>
</dd> <dt>&quot;SM&quot;</dt><dd><p>Compute <code>nev</code> eigenvalues of
smallest magnitude.</p>
</dd> <dt>&quot;LR&quot;</dt><dd><p>Compute <code>nev</code> eigenvalues
of largest real part.</p>
</dd> <dt>&quot;SR&quot;</dt><dd><p>Compute <code>nev</code>
eigenvalues of smallest real part.</p>
</dd> <dt>&quot;LI&quot;</dt><dd><p>Compute
<code>nev</code> eigenvalues of largest imaginary part.</p>
</dd>
<dt>&quot;SI&quot;</dt><dd><p>Compute <code>nev</code> eigenvalues of smallest imaginary
part.</p>
</dd> </dl>

<p>This parameter is sometimes overwritten by the various functions, e.g.
<code><a href="#topic+page_rank">page_rank()</a></code> always sets &lsquo;<code>LM</code>&rsquo;.  </p>
</dd>
<dt>nev</dt><dd><p>Numeric scalar. The number of eigenvalues to be computed.</p>
</dd>
<dt>tol</dt><dd><p>Numeric scalar. Stopping criterion: the relative accuracy of the
Ritz value is considered acceptable if its error is less than <code>tol</code>
times its estimated value. If this is set to zero then machine precision is
used.</p>
</dd> <dt>ncv</dt><dd><p>Number of Lanczos vectors to be generated.</p>
</dd>
<dt>ldv</dt><dd><p>Numberic scalar. It should be set to zero in the current
implementation.</p>
</dd> <dt>ishift</dt><dd><p>Either zero or one. If zero then the shifts
are provided by the user via reverse communication. If one then exact shifts
with respect to the reduced tridiagonal matrix <code class="reqn">T</code>.  Please always set
this to one.</p>
</dd> <dt>maxiter</dt><dd><p>Maximum number of Arnoldi update iterations
allowed. </p>
</dd> <dt>nb</dt><dd><p>Blocksize to be used in the recurrence. Please always
leave this on the default value, one.</p>
</dd> <dt>mode</dt><dd><p>The type of the
eigenproblem to be solved.  Possible values if the input matrix is
symmetric: </p>
 <dl>
<dt>1</dt><dd><p><code class="reqn">Ax=\lambda x</code>, <code class="reqn">A</code> is
symmetric.</p>
</dd> <dt>2</dt><dd><p><code class="reqn">Ax=\lambda Mx</code>, <code class="reqn">A</code> is
symmetric, <code class="reqn">M</code> is symmetric positive definite.</p>
</dd> <dt>3</dt><dd><p><code class="reqn">Kx=\lambda
Mx</code>, <code class="reqn">K</code> is symmetric, <code class="reqn">M</code> is symmetric positive
semi-definite.</p>
</dd> <dt>4</dt><dd><p><code class="reqn">Kx=\lambda KGx</code>, <code class="reqn">K</code> is
symmetric positive semi-definite, <code class="reqn">KG</code> is symmetric indefinite.</p>
</dd>
<dt>5</dt><dd><p><code class="reqn">Ax=\lambda Mx</code>, <code class="reqn">A</code> is symmetric, <code class="reqn">M</code>
is symmetric positive semi-definite. (Cayley transformed mode.)</p>
</dd> </dl>
<p> Please
note that only <code>mode==1</code> was tested and other values might not work
properly.
</p>
<p>Possible values if the input matrix is not symmetric: </p>

<dl>
<dt>1</dt><dd><p><code class="reqn">Ax=\lambda x</code>.</p>
</dd> <dt>2</dt><dd><p><code class="reqn">Ax=\lambda
Mx</code>, <code class="reqn">M</code> is symmetric positive definite.</p>
</dd>
<dt>3</dt><dd><p><code class="reqn">Ax=\lambda Mx</code>, <code class="reqn">M</code> is symmetric
semi-definite.</p>
</dd> <dt>4</dt><dd><p><code class="reqn">Ax=\lambda Mx</code>, <code class="reqn">M</code> is
symmetric semi-definite.</p>
</dd> </dl>
<p> Please note that only <code>mode==1</code> was tested
and other values might not work properly.  </p>
</dd> <dt>start</dt><dd><p>Not used
currently. Later it be used to set a starting vector.</p>
</dd> <dt>sigma</dt><dd><p>Not used
currently.</p>
</dd> <dt>sigmai</dt><dd><p>Not use currently.</p>
</dd>
</dl>
<p>On output the following additional fields are added: </p>

<dl>
<dt>info</dt><dd><p>Error flag of ARPACK. Possible values: </p>

<dl>
<dt>0</dt><dd><p>Normal exit.</p>
</dd> <dt>1</dt><dd><p>Maximum number of iterations taken.</p>
</dd>
<dt>3</dt><dd><p>No shifts could be applied during a cycle of the Implicitly
restarted Arnoldi iteration. One possibility is to increase the size of
<code>ncv</code> relative to <code>nev</code>.</p>
</dd> </dl>

<p>ARPACK can return more error conditions than these, but they are converted
to regular igraph errors.  </p>
</dd> <dt>iter</dt><dd><p>Number of Arnoldi iterations
taken.</p>
</dd> <dt>nconv</dt><dd><p>Number of &ldquo;converged&rdquo; Ritz values. This
represents the number of Ritz values that satisfy the convergence critetion.
</p>
</dd> <dt>numop</dt><dd><p>Total number of matrix-vector multiplications.</p>
</dd>
<dt>numopb</dt><dd><p>Not used currently.</p>
</dd> <dt>numreo</dt><dd><p>Total number of steps of
re-orthogonalization.</p>
</dd> </dl>
 <p> Please see the ARPACK documentation for
additional details.
</p>


<h3>Value</h3>

<p>A named list with the following members: </p>
<table>
<tr><td><code>values</code></td>
<td>
<p>Numeric
vector, the desired eigenvalues.</p>
</td></tr> <tr><td><code>vectors</code></td>
<td>
<p>Numeric matrix, the desired
eigenvectors as columns. If <code>complex=TRUE</code> (the default for
non-symmetric problems), then the matrix is complex.</p>
</td></tr> <tr><td><code>options</code></td>
<td>
<p>A named
list with the supplied <code>options</code> and some information about the
performed calculation, including an ARPACK exit code. See the details above.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rich Lehoucq, Kristi Maschhoff, Danny Sorensen, Chao Yang for
ARPACK, Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the R interface.
</p>


<h3>References</h3>

<p>D.C. Sorensen, Implicit Application of Polynomial Filters in a
k-Step Arnoldi Method. <em>SIAM J. Matr. Anal. Apps.</em>, 13 (1992), pp
357-385.
</p>
<p>R.B. Lehoucq, Analysis and Implementation of an Implicitly Restarted Arnoldi
Iteration. <em>Rice University Technical Report</em> TR95-13, Department of
Computational and Applied Mathematics.
</p>
<p>B.N. Parlett &amp; Y. Saad, Complex Shift and Invert Strategies for Real
Matrices. <em>Linear Algebra and its Applications</em>, vol 88/89, pp 575-595,
(1987).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigen_centrality">eigen_centrality()</a></code>, <code><a href="#topic+page_rank">page_rank()</a></code>,
<code><a href="#topic+hub_score">hub_score()</a></code>, <code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen()</a></code> are some of the
functions in igraph that use ARPACK.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Identity matrix
f &lt;- function(x, extra = NULL) x
arpack(f, options = list(n = 10, nev = 2, ncv = 4), sym = TRUE)

# Graph laplacian of a star graph (undirected), n&gt;=2
# Note that this is a linear operation
f &lt;- function(x, extra = NULL) {
  y &lt;- x
  y[1] &lt;- (length(x) - 1) * x[1] - sum(x[-1])
  for (i in 2:length(x)) {
    y[i] &lt;- x[i] - x[1]
  }
  y
}

arpack(f, options = list(n = 10, nev = 1, ncv = 3), sym = TRUE)

# double check
eigen(laplacian_matrix(make_star(10, mode = "undirected")))

## First three eigenvalues of the adjacency matrix of a graph
## We need the 'Matrix' package for this
if (require(Matrix)) {
  set.seed(42)
  g &lt;- sample_gnp(1000, 5 / 1000)
  M &lt;- as_adj(g, sparse = TRUE)
  f2 &lt;- function(x, extra = NULL) {
    cat(".")
    as.vector(M %*% x)
  }
  baev &lt;- arpack(f2, sym = TRUE, options = list(
    n = vcount(g), nev = 3, ncv = 8,
    which = "LM", maxiter = 2000
  ))
}
</code></pre>

<hr>
<h2 id='articulation_points'>Articulation points and bridges of a graph</h2><span id='topic+articulation_points'></span><span id='topic+bridges'></span>

<h3>Description</h3>

<p><code>articulation_points()</code> finds the articulation points (or cut vertices)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>articulation_points(graph)

bridges(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="articulation_points_+3A_graph">graph</code></td>
<td>
<p>The input graph. It is treated as an undirected graph, even if
it is directed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Articulation points or cut vertices are vertices whose removal increases the
number of connected components in a graph. Similarly, bridges or cut-edges
are edges whose removal increases the number of connected components in a
graph. If the original graph was connected, then the removal of a single
articulation point or a single bridge makes it disconnected. If a graph
contains no articulation points, then its vertex connectivity is at least
two.
</p>


<h3>Value</h3>

<p>For <code>articulation_points()</code>, a numeric vector giving the vertex
IDs of the articulation points of the input graph. For <code>bridges()</code>, a
numeric vector giving the edge IDs of the bridges of the input graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biconnected_components">biconnected_components()</a></code>, <code><a href="#topic+components">components()</a></code>,
<code><a href="#topic+is_connected">is_connected()</a></code>, <code><a href="#topic+vertex_connectivity">vertex_connectivity()</a></code>,
<code><a href="#topic+edge_connectivity">edge_connectivity()</a></code>
</p>
<p>Connected components
<code><a href="#topic+biconnected_components">biconnected_components</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+decompose">decompose</a>()</code>,
<code><a href="#topic+is_biconnected">is_biconnected</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- disjoint_union(make_full_graph(5), make_full_graph(5))
clu &lt;- components(g)$membership
g &lt;- add_edges(g, c(match(1, clu), match(2, clu)))
articulation_points(g)

g &lt;- make_graph("krackhardt_kite")
bridges(g)

</code></pre>

<hr>
<h2 id='articulation.points'>Articulation points and bridges of a graph</h2><span id='topic+articulation.points'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>articulation.points()</code> was renamed to <code>articulation_points()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>articulation.points(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="articulation.points_+3A_graph">graph</code></td>
<td>
<p>The input graph. It is treated as an undirected graph, even if
it is directed.</p>
</td></tr>
</table>

<hr>
<h2 id='as_adj_list'>Adjacency lists</h2><span id='topic+as_adj_list'></span><span id='topic+as_adj_edge_list'></span>

<h3>Description</h3>

<p>Create adjacency lists from a graph, either for adjacent edges or for
neighboring vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adj_list(
  graph,
  mode = c("all", "out", "in", "total"),
  loops = c("twice", "once", "ignore"),
  multiple = TRUE
)

as_adj_edge_list(
  graph,
  mode = c("all", "out", "in", "total"),
  loops = c("twice", "once", "ignore")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_adj_list_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="as_adj_list_+3A_mode">mode</code></td>
<td>
<p>Character scalar, it gives what kind of adjacent edges/vertices
to include in the lists. &lsquo;<code>out</code>&rsquo; is for outgoing edges/vertices,
&lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo; is for incoming edges/vertices, &lsquo;<code>all</code>&rsquo; is
for both. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="as_adj_list_+3A_loops">loops</code></td>
<td>
<p>Character scalar, one of <code>"ignore"</code> (to omit loops), <code>"twice"</code>
(to include loop edges twice) and <code>"once"</code> (to include them once). <code>"twice"</code>
is not allowed for directed graphs and will be replaced with <code>"once"</code>.</p>
</td></tr>
<tr><td><code id="as_adj_list_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, set to <code>FALSE</code> to use only one representative
of each set of parallel edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_adj_list()</code> returns a list of numeric vectors, which include the ids
of neighbor vertices (according to the <code>mode</code> argument) of all
vertices.
</p>
<p><code>as_adj_edge_list()</code> returns a list of numeric vectors, which include the
ids of adjacent edges (according to the <code>mode</code> argument) of all
vertices.
</p>
<p>If <code>igraph_opt("return.vs.es")</code> is true (default), the numeric
vectors of the adjacency lists are coerced to <code>igraph.vs</code>, this can be
a very expensive operation on large graphs.
</p>


<h3>Value</h3>

<p>A list of <code>igraph.vs</code> or a list of numeric vectors depending on
the value of <code>igraph_opt("return.vs.es")</code>, see details for performance
characteristics.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_edgelist">as_edgelist()</a></code>, <code><a href="#topic+as_adj">as_adj()</a></code>
</p>
<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
as_adj_list(g)
as_adj_edge_list(g)

</code></pre>

<hr>
<h2 id='as_adjacency_matrix'>Convert a graph to an adjacency matrix</h2><span id='topic+as_adjacency_matrix'></span><span id='topic+as_adj'></span>

<h3>Description</h3>

<p>Sometimes it is useful to work with a standard representation of a
graph, like an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adjacency_matrix(
  graph,
  type = c("both", "upper", "lower"),
  attr = NULL,
  edges = FALSE,
  names = TRUE,
  sparse = igraph_opt("sparsematrices")
)

as_adj(
  graph,
  type = c("both", "upper", "lower"),
  attr = NULL,
  edges = FALSE,
  names = TRUE,
  sparse = igraph_opt("sparsematrices")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_adjacency_matrix_+3A_graph">graph</code></td>
<td>
<p>The graph to convert.</p>
</td></tr>
<tr><td><code id="as_adjacency_matrix_+3A_type">type</code></td>
<td>
<p>Gives how to create the adjacency matrix for undirected graphs.
It is ignored for directed graphs. Possible values: <code>upper</code>: the upper
right triangle of the matrix is used, <code>lower</code>: the lower left triangle
of the matrix is used. <code>both</code>: the whole matrix is used, a symmetric
matrix is returned.</p>
</td></tr>
<tr><td><code id="as_adjacency_matrix_+3A_attr">attr</code></td>
<td>
<p>Either <code>NULL</code> or a character string giving an edge
attribute name. If <code>NULL</code> a traditional adjacency matrix is returned.
If not <code>NULL</code> then the values of the given edge attribute are included
in the adjacency matrix. If the graph has multiple edges, the edge attribute
of an arbitrarily chosen edge (for the multiple edges) is included. This
argument is ignored if <code>edges</code> is <code>TRUE</code>.
</p>
<p>Note that this works only for certain attribute types. If the <code>sparse</code>
argumen is <code>TRUE</code>, then the attribute must be either logical or
numeric. If the <code>sparse</code> argument is <code>FALSE</code>, then character is
also allowed. The reason for the difference is that the <code>Matrix</code>
package does not support character sparse matrices yet.</p>
</td></tr>
<tr><td><code id="as_adjacency_matrix_+3A_edges">edges</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Logical scalar, whether to return the edge ids in the matrix.
For non-existant edges zero is returned.</p>
</td></tr>
<tr><td><code id="as_adjacency_matrix_+3A_names">names</code></td>
<td>
<p>Logical constant, whether to assign row and column names
to the matrix. These are only assigned if the <code>name</code> vertex attribute
is present in the graph.</p>
</td></tr>
<tr><td><code id="as_adjacency_matrix_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to create a sparse matrix. The
&lsquo;<code>Matrix</code>&rsquo; package must be installed for creating sparse
matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_adjacency_matrix()</code> returns the adjacency matrix of a graph, a
regular matrix if <code>sparse</code> is <code>FALSE</code>, or a sparse matrix, as
defined in the &lsquo;<code>Matrix</code>&rsquo; package, if <code>sparse</code> if
<code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>vcount(graph)</code> by <code>vcount(graph)</code> (usually) numeric
matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix()</a></code>, <code><a href="#topic+read_graph">read_graph()</a></code>
</p>
<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(10, 2 / 10)
as_adjacency_matrix(g)
V(g)$name &lt;- letters[1:vcount(g)]
as_adjacency_matrix(g)
E(g)$weight &lt;- runif(ecount(g))
as_adjacency_matrix(g, attr = "weight")
</code></pre>

<hr>
<h2 id='as_biadjacency_matrix'>Bipartite adjacency matrix of a bipartite graph</h2><span id='topic+as_biadjacency_matrix'></span>

<h3>Description</h3>

<p>This function can return a sparse or dense bipartite adjacency matrix of a bipartite
network. The bipartite adjacency matrix is an <code class="reqn">n</code> times <code class="reqn">m</code> matrix, <code class="reqn">n</code>
and <code class="reqn">m</code> are the number of vertices of the two kinds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_biadjacency_matrix(
  graph,
  types = NULL,
  attr = NULL,
  names = TRUE,
  sparse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_biadjacency_matrix_+3A_graph">graph</code></td>
<td>
<p>The input graph. The direction of the edges is ignored in
directed graphs.</p>
</td></tr>
<tr><td><code id="as_biadjacency_matrix_+3A_types">types</code></td>
<td>
<p>An optional vertex type vector to use instead of the
<code>type</code> vertex attribute. You must supply this argument if the graph has
no <code>type</code> vertex attribute.</p>
</td></tr>
<tr><td><code id="as_biadjacency_matrix_+3A_attr">attr</code></td>
<td>
<p>Either <code>NULL</code> or a character string giving an edge
attribute name. If <code>NULL</code>, then a traditional bipartite adjacency matrix is
returned. If not <code>NULL</code> then the values of the given edge attribute are
included in the bipartite adjacency matrix. If the graph has multiple edges, the edge
attribute of an arbitrarily chosen edge (for the multiple edges) is
included.</p>
</td></tr>
<tr><td><code id="as_biadjacency_matrix_+3A_names">names</code></td>
<td>
<p>Logical scalar, if <code>TRUE</code> and the vertices in the graph
are named (i.e. the graph has a vertex attribute called <code>name</code>), then
vertex names will be added to the result as row and column names. Otherwise
the ids of the vertices are used as row and column names.</p>
</td></tr>
<tr><td><code id="as_biadjacency_matrix_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, if it is <code>TRUE</code> then a sparse matrix is
created, you will need the <code>Matrix</code> package for this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bipartite graphs have a <code>type</code> vertex attribute in igraph, this is
boolean and <code>FALSE</code> for the vertices of the first kind and <code>TRUE</code>
for vertices of the second kind.
</p>
<p>Some authors refer to the bipartite adjacency matrix as the
&quot;bipartite incidence matrix&quot;. igraph 1.6.0 and later does not use
this naming to avoid confusion with the edge-vertex incidence matrix.
</p>


<h3>Value</h3>

<p>A sparse or dense matrix.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_from_biadjacency_matrix">graph_from_biadjacency_matrix()</a></code> for the opposite operation.
</p>
<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_bipartite_graph(c(0, 1, 0, 1, 0, 0), c(1, 2, 2, 3, 3, 4))
as_biadjacency_matrix(g)

</code></pre>

<hr>
<h2 id='as_data_frame'>Creating igraph graphs from data frames or vice-versa</h2><span id='topic+as_data_frame'></span><span id='topic+graph_from_data_frame'></span><span id='topic+from_data_frame'></span>

<h3>Description</h3>

<p>This function creates an igraph graph from one or two data frames containing
the (symbolic) edge list and edge/vertex attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_data_frame(x, what = c("edges", "vertices", "both"))

graph_from_data_frame(d, directed = TRUE, vertices = NULL)

from_data_frame(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_data_frame_+3A_x">x</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="as_data_frame_+3A_what">what</code></td>
<td>
<p>Character constant, whether to return info about vertices,
edges, or both. The default is &lsquo;edges&rsquo;.</p>
</td></tr>
<tr><td><code id="as_data_frame_+3A_d">d</code></td>
<td>
<p>A data frame containing a symbolic edge list in the first two
columns. Additional columns are considered as edge attributes.  Since
version 0.7 this argument is coerced to a data frame with
<code>as.data.frame</code>.</p>
</td></tr>
<tr><td><code id="as_data_frame_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether or not to create a directed graph.</p>
</td></tr>
<tr><td><code id="as_data_frame_+3A_vertices">vertices</code></td>
<td>
<p>A data frame with vertex metadata, or <code>NULL</code>. See
details below. Since version 0.7 this argument is coerced to a data frame
with <code>as.data.frame</code>, if not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="as_data_frame_+3A_...">...</code></td>
<td>
<p>Passed to <code>graph_from_data_frame()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>graph_from_data_frame()</code> creates igraph graphs from one or two data frames.
It has two modes of operation, depending whether the <code>vertices</code>
argument is <code>NULL</code> or not.
</p>
<p>If <code>vertices</code> is <code>NULL</code>, then the first two columns of <code>d</code>
are used as a symbolic edge list and additional columns as edge attributes.
The names of the attributes are taken from the names of the columns.
</p>
<p>If <code>vertices</code> is not <code>NULL</code>, then it must be a data frame giving
vertex metadata. The first column of <code>vertices</code> is assumed to contain
symbolic vertex names, this will be added to the graphs as the
&lsquo;<code>name</code>&rsquo; vertex attribute. Other columns will be added as
additional vertex attributes. If <code>vertices</code> is not <code>NULL</code> then the
symbolic edge list given in <code>d</code> is checked to contain only vertex names
listed in <code>vertices</code>.
</p>
<p>Typically, the data frames are exported from some spreadsheet software like
Excel and are imported into R via <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="utils.html#topic+read.delim">read.delim()</a></code> or <code><a href="utils.html#topic+read.csv">read.csv()</a></code>.
</p>
<p>All edges in the data frame are included in the graph, which may include
multiple parallel edges and loops.
</p>
<p><code>as_data_frame()</code> converts the igraph graph into one or more data
frames, depending on the <code>what</code> argument.
</p>
<p>If the <code>what</code> argument is <code>edges</code> (the default), then the edges of
the graph and also the edge attributes are returned. The edges will be in
the first two columns, named <code>from</code> and <code>to</code>. (This also denotes
edge direction for directed graphs.)  For named graphs, the vertex names
will be included in these columns, for other graphs, the numeric vertex ids.
The edge attributes will be in the other columns. It is not a good idea to
have an edge attribute named <code>from</code> or <code>to</code>, because then the
column named in the data frame will not be unique. The edges are listed in
the order of their numeric ids.
</p>
<p>If the <code>what</code> argument is <code>vertices</code>, then vertex attributes are
returned. Vertices are listed in the order of their numeric vertex ids.
</p>
<p>If the <code>what</code> argument is <code>both</code>, then both vertex and edge data
is returned, in a list with named entries <code>vertices</code> and <code>edges</code>.
</p>


<h3>Value</h3>

<p>An igraph graph object for <code>graph_from_data_frame()</code>, and either a
data frame or a list of two data frames named <code>edges</code> and
<code>vertices</code> for <code>as.data.frame</code>.
</p>


<h3>Note</h3>

<p>For <code>graph_from_data_frame()</code> <code>NA</code> elements in the first two
columns &lsquo;d&rsquo; are replaced by the string &ldquo;NA&rdquo; before creating
the graph. This means that all <code>NA</code>s will correspond to a single
vertex.
</p>
<p><code>NA</code> elements in the first column of &lsquo;vertices&rsquo; are also
replaced by the string &ldquo;NA&rdquo;, but the rest of &lsquo;vertices&rsquo; is not
touched. In other words, vertex names (=the first column) cannot be
<code>NA</code>, but other vertex attributes can.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_from_literal">graph_from_literal()</a></code>
for another way to create graphs, <code><a href="utils.html#topic+read.table">read.table()</a></code> to read in tables
from files.
</p>
<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>
<p>Other biadjacency: 
<code><a href="#topic+graph_from_biadjacency_matrix">graph_from_biadjacency_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A simple example with a couple of actors
## The typical case is that these tables are read in from files....
actors &lt;- data.frame(
  name = c(
    "Alice", "Bob", "Cecil", "David",
    "Esmeralda"
  ),
  age = c(48, 33, 45, 34, 21),
  gender = c("F", "M", "F", "M", "F")
)
relations &lt;- data.frame(
  from = c(
    "Bob", "Cecil", "Cecil", "David",
    "David", "Esmeralda"
  ),
  to = c("Alice", "Bob", "Alice", "Alice", "Bob", "Alice"),
  same.dept = c(FALSE, FALSE, TRUE, FALSE, FALSE, TRUE),
  friendship = c(4, 5, 5, 2, 1, 1), advice = c(4, 5, 5, 4, 2, 3)
)
g &lt;- graph_from_data_frame(relations, directed = TRUE, vertices = actors)
print(g, e = TRUE, v = TRUE)

## The opposite operation
as_data_frame(g, what = "vertices")
as_data_frame(g, what = "edges")

</code></pre>

<hr>
<h2 id='as_edgelist'>Convert a graph to an edge list</h2><span id='topic+as_edgelist'></span>

<h3>Description</h3>

<p>Sometimes it is useful to work with a standard representation of a
graph, like an edge list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_edgelist(graph, names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_edgelist_+3A_graph">graph</code></td>
<td>
<p>The graph to convert.</p>
</td></tr>
<tr><td><code id="as_edgelist_+3A_names">names</code></td>
<td>
<p>Whether to return a character matrix containing vertex
names (i.e. the <code>name</code> vertex attribute) if they exist or numeric
vertex ids.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_edgelist()</code> returns the list of edges in a graph.
</p>


<h3>Value</h3>

<p>A <code>ecount(graph)</code> by 2 numeric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix()</a></code>, <code><a href="#topic+read_graph">read_graph()</a></code>
</p>
<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(10, 2 / 10)
as_edgelist(g)

V(g)$name &lt;- LETTERS[seq_len(gorder(g))]
as_edgelist(g)

</code></pre>

<hr>
<h2 id='as_graphnel'>Convert igraph graphs to graphNEL objects from the graph package</h2><span id='topic+as_graphnel'></span>

<h3>Description</h3>

<p>The graphNEL class is defined in the <code>graph</code> package, it is another
way to represent graphs. These functions are provided to convert between
the igraph and the graphNEL objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_graphnel(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_graphnel_+3A_graph">graph</code></td>
<td>
<p>An igraph graph object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as_graphnel()</code> converts an igraph graph to a graphNEL graph. It
converts all graph/vertex/edge attributes. If the igraph graph has a
vertex attribute &lsquo;<code>name</code>&rsquo;, then it will be used to assign
vertex names in the graphNEL graph. Otherwise numeric igraph vertex ids
will be used for this purpose.
</p>


<h3>Value</h3>

<p><code>as_graphnel()</code> returns a graphNEL graph object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_from_graphnel">graph_from_graphnel()</a></code> for the other direction,
<code><a href="#topic+as_adj">as_adj()</a></code>, <code><a href="#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix()</a></code>,
<code><a href="#topic+as_adj_list">as_adj_list()</a></code> and <code><a href="#topic+graph.adjlist">graph.adjlist()</a></code> for
other graph representations.
</p>
<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Undirected
## Not run: 
g &lt;- make_ring(10)
V(g)$name &lt;- letters[1:10]
GNEL &lt;- as_graphnel(g)
g2 &lt;- graph_from_graphnel(GNEL)
g2

## Directed
g3 &lt;- make_star(10, mode = "in")
V(g3)$name &lt;- letters[1:10]
GNEL2 &lt;- as_graphnel(g3)
g4 &lt;- graph_from_graphnel(GNEL2)
g4

## End(Not run)
</code></pre>

<hr>
<h2 id='as_ids'>Convert a vertex or edge sequence to an ordinary vector</h2><span id='topic+as_ids'></span><span id='topic+as_ids.igraph.vs'></span><span id='topic+as_ids.igraph.es'></span>

<h3>Description</h3>

<p>Convert a vertex or edge sequence to an ordinary vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_ids(seq)

## S3 method for class 'igraph.vs'
as_ids(seq)

## S3 method for class 'igraph.es'
as_ids(seq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_ids_+3A_seq">seq</code></td>
<td>
<p>The vertex or edge sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For graphs without names, a numeric vector is returned, containing the
internal numeric vertex or edge ids.
</p>
<p>For graphs with names, and vertex sequences, the vertex names are
returned in a character vector.
</p>
<p>For graphs with names and edge sequences, a character vector is
returned, with the &lsquo;bar&rsquo; notation: <code>a|b</code> means an edge from
vertex <code>a</code> to vertex <code>b</code>.
</p>


<h3>Value</h3>

<p>A character or numeric vector, see details below.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
as_ids(V(g))
as_ids(E(g))

V(g)$name &lt;- letters[1:10]
as_ids(V(g))
as_ids(E(g))
</code></pre>

<hr>
<h2 id='as_incidence_matrix'>As incidence matrix</h2><span id='topic+as_incidence_matrix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>as_incidence_matrix()</code> was renamed to <code>as_biadjacency_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_incidence_matrix(...)
</code></pre>


<h3>Details</h3>

<p>Some authors refer to the bipartite adjacency matrix as the
&quot;bipartite incidence matrix&quot;. igraph 1.6.0 and later does not use
this naming to avoid confusion with the edge-vertex incidence matrix.
</p>

<hr>
<h2 id='as_long_data_frame'>Convert a graph to a long data frame</h2><span id='topic+as_long_data_frame'></span>

<h3>Description</h3>

<p>A long data frame contains all metadata about both the vertices
and edges of the graph. It contains one row for each edge, and
all metadata about that edge and its incident vertices are included
in that row. The names of the columns that contain the metadata
of the incident vertices are prefixed with <code>from_</code> and <code>to_</code>.
The first two columns are always named <code>from</code> and <code>to</code> and
they contain the numeric ids of the incident vertices. The rows are
listed in the order of numeric vertex ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_long_data_frame(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_long_data_frame_+3A_graph">graph</code></td>
<td>
<p>Input graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A long data frame.
</p>


<h3>See Also</h3>

<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(
  ring(10),
  with_vertex_(name = letters[1:10], color = "red"),
  with_edge_(weight = 1:10, color = "green")
)
as_long_data_frame(g)
</code></pre>

<hr>
<h2 id='as_membership'>Declare a numeric vector as a membership vector</h2><span id='topic+as_membership'></span>

<h3>Description</h3>

<p>This is useful if you want to use functions defined on
membership vectors, but your membership vector does not
come from an igraph clustering method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_membership(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_membership_+3A_x">x</code></td>
<td>
<p>The input vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input vector, with the <code>membership</code> class added.
</p>


<h3>See Also</h3>

<p>Community detection
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare to the correct clustering
g &lt;- (make_full_graph(10) + make_full_graph(10)) %&gt;%
  rewire(each_edge(p = 0.2))
correct &lt;- rep(1:2, each = 10) %&gt;% as_membership()
fc &lt;- cluster_fast_greedy(g)
compare(correct, fc)
compare(correct, membership(fc))
</code></pre>

<hr>
<h2 id='as_phylo'>as_phylo</h2><span id='topic+as_phylo'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>as_phylo</code> methods were renamed <code>as.phylo</code>
for more consistency with other R methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_phylo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_phylo_+3A_x">x</code></td>
<td>
<p>object to be coerced</p>
</td></tr>
<tr><td><code id="as_phylo_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='as.directed'>Convert between directed and undirected graphs</h2><span id='topic+as.directed'></span><span id='topic+as.undirected'></span>

<h3>Description</h3>

<p><code>as.directed()</code> converts an undirected graph to directed,
<code>as.undirected()</code> does the opposite, it converts a directed graph to
undirected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.directed(graph, mode = c("mutual", "arbitrary", "random", "acyclic"))

as.undirected(
  graph,
  mode = c("collapse", "each", "mutual"),
  edge.attr.comb = igraph_opt("edge.attr.comb")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.directed_+3A_graph">graph</code></td>
<td>
<p>The graph to convert.</p>
</td></tr>
<tr><td><code id="as.directed_+3A_mode">mode</code></td>
<td>
<p>Character constant, defines the conversion algorithm. For
<code>as.directed()</code> it can be <code>mutual</code> or <code>arbitrary</code>. For
<code>as.undirected()</code> it can be <code>each</code>, <code>collapse</code> or
<code>mutual</code>. See details below.</p>
</td></tr>
<tr><td><code id="as.directed_+3A_edge.attr.comb">edge.attr.comb</code></td>
<td>
<p>Specifies what to do with edge attributes, if
<code>mode="collapse"</code> or <code>mode="mutual"</code>.  In these cases many edges
might be mapped to a single one in the new graph, and their attributes are
combined. Please see <code><a href="#topic+attribute.combination">attribute.combination()</a></code> for details on
this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conversion algorithms for <code>as.directed()</code>: </p>

<dl>
<dt>&quot;arbitrary&quot;</dt><dd><p>The number of edges in the graph stays the same, an
arbitrarily directed edge is created for each undirected edge, but the
direction of the edge is deterministic (i.e. it always points the same
way if you call the function multiple times).</p>
</dd>
<dt>&quot;mutual&quot;</dt><dd><p>Two directed edges are created for each undirected
edge, one in each direction.</p>
</dd>
<dt>&quot;random&quot;</dt><dd><p>The number of edges in the graph stays the same, and
a randomly directed edge is created for each undirected edge. You
will get different results if you call the function multiple times
with the same graph.</p>
</dd>
<dt>&quot;acyclic&quot;</dt><dd><p>The number of edges in the graph stays the same, and
a directed edge is created for each undirected edge such that the
resulting graph is guaranteed to be acyclic. This is achieved by ensuring
that edges always point from a lower index vertex to a higher index.
Note that the graph may include cycles of length 1 if the original
graph contained loop edges.</p>
</dd>
</dl>

<p>Conversion algorithms for <code>as.undirected()</code>: </p>

<dl>
<dt>&quot;each&quot;</dt><dd><p>The number of edges remains constant, an undirected edge
is created for each directed one, this version might create graphs with
multiple edges.</p>
</dd> <dt>&quot;collapse&quot;</dt><dd><p>One undirected edge will be created
for each pair of vertices which are connected with at least one directed
edge, no multiple edges will be created.</p>
</dd> <dt>&quot;mutual&quot;</dt><dd><p>One
undirected edge will be created for each pair of mutual edges. Non-mutual
edges are ignored. This mode might create multiple edges if there are more
than one mutual edge pairs between the same pair of vertices.  </p>
</dd> </dl>



<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplify">simplify()</a></code> for removing multiple and/or loop edges from
a graph.
</p>
<p>Other conversion: 
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
as.directed(g, "mutual")
g2 &lt;- make_star(10)
as.undirected(g)

# Combining edge attributes
g3 &lt;- make_ring(10, directed = TRUE, mutual = TRUE)
E(g3)$weight &lt;- seq_len(ecount(g3))
ug3 &lt;- as.undirected(g3)
print(ug3, e = TRUE)

x11(width = 10, height = 5)
layout(rbind(1:2))
plot(g3, layout = layout_in_circle, edge.label = E(g3)$weight)
plot(ug3, layout = layout_in_circle, edge.label = E(ug3)$weight)


g4 &lt;- make_graph(c(
  1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 4,
  6, 7, 7, 6, 7, 8, 7, 8, 8, 7, 8, 9, 8, 9,
  9, 8, 9, 8, 9, 9, 10, 10, 10, 10
))
E(g4)$weight &lt;- seq_len(ecount(g4))
ug4 &lt;- as.undirected(g4,
  mode = "mutual",
  edge.attr.comb = list(weight = length)
)
print(ug4, e = TRUE)

</code></pre>

<hr>
<h2 id='as.igraph'>Conversion to igraph</h2><span id='topic+as.igraph'></span><span id='topic+as.igraph.igraphHRG'></span>

<h3>Description</h3>

<p>These functions convert various objects to igraph graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.igraph(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.igraph_+3A_x">x</code></td>
<td>
<p>The object to convert.</p>
</td></tr>
<tr><td><code id="as.igraph_+3A_...">...</code></td>
<td>
<p>Additional arguments. None currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can use <code>as.igraph()</code> to convert various objects to igraph graphs.
Right now the following objects are supported: </p>
 <ul>
<li><p> codeigraphHRG
These objects are created by the <code><a href="#topic+fit_hrg">fit_hrg()</a></code> and
<code><a href="#topic+consensus_tree">consensus_tree()</a></code> functions.  </p>
</li></ul>



<h3>Value</h3>

<p>All these functions return an igraph graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_full_graph(5) + make_full_graph(5)
hrg &lt;- fit_hrg(g)
as.igraph(hrg)

</code></pre>

<hr>
<h2 id='as.matrix.igraph'>Convert igraph objects to adjacency or edge list matrices</h2><span id='topic+as.matrix.igraph'></span>

<h3>Description</h3>

<p>Get adjacency or edgelist representation of the network stored as an
<code>igraph</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
as.matrix(x, matrix.type = c("adjacency", "edgelist"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.igraph_+3A_x">x</code></td>
<td>
<p>object of class igraph, the network</p>
</td></tr>
<tr><td><code id="as.matrix.igraph_+3A_matrix.type">matrix.type</code></td>
<td>
<p>character, type of matrix to return, currently &quot;adjacency&quot;
or &quot;edgelist&quot; are supported</p>
</td></tr>
<tr><td><code id="as.matrix.igraph_+3A_...">...</code></td>
<td>
<p>other arguments to/from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>matrix.type</code> is <code>"edgelist"</code>, then a two-column numeric edge list
matrix is returned.  The value of <code>attrname</code> is ignored.
</p>
<p>If <code>matrix.type</code> is <code>"adjacency"</code>, then a square adjacency matrix is
returned. For adjacency matrices, you can use the <code>attr</code> keyword argument
to use the values of an edge attribute in the matrix cells. See the
documentation of <a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a> for more details.
</p>
<p>Other arguments passed through <code>...</code> are passed to either
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix()</a></code> or <code><a href="#topic+as_edgelist">as_edgelist()</a></code>
depending on the value of <code>matrix.type</code>.
</p>


<h3>Value</h3>

<p>Depending on the value of <code>matrix.type</code> either a square
adjacency matrix or a two-column numeric matrix representing the edgelist.
</p>


<h3>Author(s)</h3>

<p>Michal Bojanowski, originally from the <code>intergraph</code> package
</p>


<h3>See Also</h3>

<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph("zachary")
as.matrix(g, "adjacency")
as.matrix(g, "edgelist")
# use edge attribute "weight"
E(g)$weight &lt;- rep(1:10, length.out = ecount(g))
as.matrix(g, "adjacency", sparse = FALSE, attr = "weight")

</code></pre>

<hr>
<h2 id='assortativity'>Assortativity coefficient</h2><span id='topic+assortativity'></span><span id='topic+assortativity_nominal'></span><span id='topic+assortativity_degree'></span>

<h3>Description</h3>

<p>The assortativity coefficient is positive if similar vertices (based on some
external property) tend to connect to each, and negative otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assortativity(
  graph,
  values,
  ...,
  values.in = NULL,
  directed = TRUE,
  normalized = TRUE,
  types1 = NULL,
  types2 = NULL
)

assortativity_nominal(graph, types, directed = TRUE, normalized = TRUE)

assortativity_degree(graph, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assortativity_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected.</p>
</td></tr>
<tr><td><code id="assortativity_+3A_values">values</code></td>
<td>
<p>The vertex values, these can be arbitrary numeric values.</p>
</td></tr>
<tr><td><code id="assortativity_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="assortativity_+3A_values.in">values.in</code></td>
<td>
<p>A second value vector to use for the incoming edges when
calculating assortativity for a directed graph.
Supply <code>NULL</code> here if
you want to use the same values for outgoing and incoming edges.
This
argument is ignored (with a warning) if it is not <code>NULL</code> and undirected
assortativity coefficient is being calculated.</p>
</td></tr>
<tr><td><code id="assortativity_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to consider edge directions for
directed graphs.
This argument is ignored for undirected graphs.
Supply
<code>TRUE</code> here to do the natural thing, i.e. use directed version of the
measure for directed graphs and the undirected version for undirected
graphs.</p>
</td></tr>
<tr><td><code id="assortativity_+3A_normalized">normalized</code></td>
<td>
<p>Boolean, whether to compute the normalized assortativity.
The non-normalized nominal assortativity is identical to modularity.
The non-normalized value-based assortativity is simply the covariance of the
values at the two ends of edges.</p>
</td></tr>
<tr><td><code id="assortativity_+3A_types1">types1</code>, <code id="assortativity_+3A_types2">types2</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Deprecated aliases for <code>values</code> and <code>values.in</code>, respectively.</p>
</td></tr>
<tr><td><code id="assortativity_+3A_types">types</code></td>
<td>
<p>Vector giving the vertex types. They as assumed to be integer
numbers, starting with one. Non-integer values are converted to integers
with <code><a href="base.html#topic+as.integer">as.integer()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assortativity coefficient measures the level of homophyly of the graph,
based on some vertex labeling or values assigned to vertices. If the
coefficient is high, that means that connected vertices tend to have the
same labels or similar assigned values.
</p>
<p>M.E.J. Newman defined two kinds of assortativity coefficients, the first one
is for categorical labels of vertices. <code>assortativity_nominal()</code>
calculates this measure. It is defined as
</p>
<p style="text-align: center;"><code class="reqn">r=\frac{\sum_i e_{ii}-\sum_i a_i b_i}{1-\sum_i a_i b_i}</code>
</p>

<p>where <code class="reqn">e_{ij}</code> is the fraction of edges connecting vertices of
type <code class="reqn">i</code> and <code class="reqn">j</code>, <code class="reqn">a_i=\sum_j e_{ij}</code> and
<code class="reqn">b_j=\sum_i e_{ij}</code>.
</p>
<p>The second assortativity variant is based on values assigned to the
vertices. <code>assortativity()</code> calculates this measure. It is defined as
</p>
<p style="text-align: center;"><code class="reqn">r=\frac1{\sigma_q^2}\sum_{jk} jk(e_{jk}-q_j q_k)</code>
</p>

<p>for undirected graphs (<code class="reqn">q_i=\sum_j e_{ij}</code>) and as
</p>
<p style="text-align: center;"><code class="reqn">r=\frac1{\sigma_o\sigma_i}\sum_{jk}jk(e_{jk}-q_j^o q_k^i)</code>
</p>

<p>for directed ones. Here <code class="reqn">q_i^o=\sum_j e_{ij}</code>,
<code class="reqn">q_i^i=\sum_j e_{ji}</code>, moreover,
<code class="reqn">\sigma_q</code>, <code class="reqn">\sigma_o</code> and
<code class="reqn">\sigma_i</code> are the standard deviations of <code class="reqn">q</code>,
<code class="reqn">q^o</code> and <code class="reqn">q^i</code>, respectively.
</p>
<p>The reason of the difference is that in directed networks the relationship
is not symmetric, so it is possible to assign different values to the
outgoing and the incoming end of the edges.
</p>
<p><code>assortativity_degree()</code> uses vertex degree as vertex values
and calls <code>assortativity()</code>.
</p>
<p>Undirected graphs are effectively treated as directed ones with all-reciprocal edges.
Thus, self-loops are taken into account twice in undirected graphs.
</p>


<h3>Value</h3>

<p>A single real number.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>M. E. J. Newman: Mixing patterns in networks, <em>Phys. Rev.
E</em> 67, 026126 (2003) <a href="https://arxiv.org/abs/cond-mat/0209450">https://arxiv.org/abs/cond-mat/0209450</a>
</p>
<p>M. E. J. Newman: Assortative mixing in networks, <em>Phys. Rev. Lett.</em> 89,
208701 (2002) <a href="https://arxiv.org/abs/cond-mat/0205405">https://arxiv.org/abs/cond-mat/0205405</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# random network, close to zero
assortativity_degree(sample_gnp(10000, 3 / 10000))

# BA model, tends to be dissortative
assortativity_degree(sample_pa(10000, m = 4))
</code></pre>

<hr>
<h2 id='assortativity.degree'>Assortativity coefficient</h2><span id='topic+assortativity.degree'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>assortativity.degree()</code> was renamed to <code>assortativity_degree()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assortativity.degree(graph, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assortativity.degree_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected.</p>
</td></tr>
<tr><td><code id="assortativity.degree_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to consider edge directions for
directed graphs.
This argument is ignored for undirected graphs.
Supply
<code>TRUE</code> here to do the natural thing, i.e. use directed version of the
measure for directed graphs and the undirected version for undirected
graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='assortativity.nominal'>Assortativity coefficient</h2><span id='topic+assortativity.nominal'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>assortativity.nominal()</code> was renamed to <code>assortativity_nominal()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assortativity.nominal(graph, types, directed = TRUE, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assortativity.nominal_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected.</p>
</td></tr>
<tr><td><code id="assortativity.nominal_+3A_types">types</code></td>
<td>
<p>Vector giving the vertex types. They as assumed to be integer
numbers, starting with one. Non-integer values are converted to integers
with <code><a href="base.html#topic+as.integer">as.integer()</a></code>.</p>
</td></tr>
<tr><td><code id="assortativity.nominal_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to consider edge directions for
directed graphs.
This argument is ignored for undirected graphs.
Supply
<code>TRUE</code> here to do the natural thing, i.e. use directed version of the
measure for directed graphs and the undirected version for undirected
graphs.</p>
</td></tr>
<tr><td><code id="assortativity.nominal_+3A_normalized">normalized</code></td>
<td>
<p>Boolean, whether to compute the normalized assortativity.
The non-normalized nominal assortativity is identical to modularity.
The non-normalized value-based assortativity is simply the covariance of the
values at the two ends of edges.</p>
</td></tr>
</table>

<hr>
<h2 id='asymmetric.preference.game'>Trait-based random generation</h2><span id='topic+asymmetric.preference.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>asymmetric.preference.game()</code> was renamed to <code>sample_asym_pref()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymmetric.preference.game(
  nodes,
  types,
  type.dist.matrix = matrix(1, types, types),
  pref.matrix = matrix(1, types, types),
  loops = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asymmetric.preference.game_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graphs.</p>
</td></tr>
<tr><td><code id="asymmetric.preference.game_+3A_types">types</code></td>
<td>
<p>The number of different vertex types.</p>
</td></tr>
<tr><td><code id="asymmetric.preference.game_+3A_type.dist.matrix">type.dist.matrix</code></td>
<td>
<p>The joint distribution of the in- and out-vertex
types.</p>
</td></tr>
<tr><td><code id="asymmetric.preference.game_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>A square matrix giving the preferences of the vertex
types. The matrix has &lsquo;types&rsquo; rows and columns. When generating
an undirected graph, it must be symmetric.</p>
</td></tr>
<tr><td><code id="asymmetric.preference.game_+3A_loops">loops</code></td>
<td>
<p>Logical constant, whether self-loops are allowed in the graph.</p>
</td></tr>
</table>

<hr>
<h2 id='authority.score'>Kleinberg's hub and authority centrality scores.</h2><span id='topic+authority.score'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>authority.score()</code> was renamed to <code>authority_score()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>authority.score(
  graph,
  scale = TRUE,
  weights = NULL,
  options = arpack_defaults()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="authority.score_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="authority.score_+3A_scale">scale</code></td>
<td>
<p>Logical scalar, whether to scale the result to have a maximum
score of one. If no scaling is used then the result vector has unit length
in the Euclidean norm.</p>
</td></tr>
<tr><td><code id="authority.score_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
scores. If the graph has a <code>weight</code> edge attribute, then this is used
by default.
This function interprets edge weights as connection strengths. In the
random surfer model, an edge with a larger weight is more likely to be
selected by the surfer.</p>
</td></tr>
<tr><td><code id="authority.score_+3A_options">options</code></td>
<td>
<p>A named list, to override some ARPACK options. See
<code><a href="#topic+arpack">arpack()</a></code> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='autocurve.edges'>Optimal edge curvature when plotting graphs</h2><span id='topic+autocurve.edges'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>autocurve.edges()</code> was renamed to <code>curve_multiple()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocurve.edges(graph, start = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocurve.edges_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="autocurve.edges_+3A_start">start</code></td>
<td>
<p>The curvature at the two extreme edges. All edges will have a
curvature between <code>-start</code> and <code>start</code>, spaced equally.</p>
</td></tr>
</table>

<hr>
<h2 id='automorphism_group'>Generating set of the automorphism group of a graph</h2><span id='topic+automorphism_group'></span>

<h3>Description</h3>

<p>Compute the generating set of the automorphism group of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>automorphism_group(
  graph,
  colors = NULL,
  sh = c("fm", "f", "fs", "fl", "flm", "fsm"),
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="automorphism_group_+3A_graph">graph</code></td>
<td>
<p>The input graph, it is treated as undirected.</p>
</td></tr>
<tr><td><code id="automorphism_group_+3A_colors">colors</code></td>
<td>
<p>The colors of the individual vertices of the graph; only
vertices having the same color are allowed to match each other in an
automorphism. When omitted, igraph uses the <code>color</code> attribute of the
vertices, or, if there is no such vertex attribute, it simply assumes that
all vertices have the same color. Pass NULL explicitly if the graph has a
<code>color</code> vertex attribute but you do not want to use it.</p>
</td></tr>
<tr><td><code id="automorphism_group_+3A_sh">sh</code></td>
<td>
<p>The splitting heuristics for the BLISS algorithm. Possible values
are: &lsquo;<code>f</code>&rsquo;: first non-singleton cell, &lsquo;<code>fl</code>&rsquo;: first
largest non-singleton cell, &lsquo;<code>fs</code>&rsquo;: first smallest non-singleton
cell, &lsquo;<code>fm</code>&rsquo;: first maximally non-trivially connected
non-singleton cell, &lsquo;<code>flm</code>&rsquo;: first largest maximally
non-trivially connected non-singleton cell, &lsquo;<code>fsm</code>&rsquo;: first
smallest maximally non-trivially connected non-singleton cell.</p>
</td></tr>
<tr><td><code id="automorphism_group_+3A_details">details</code></td>
<td>
<p>Specifies whether to provide additional details about the
BLISS internals in the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An automorphism of a graph is a permutation of its vertices which brings the
graph into itself. The automorphisms of a graph form a group and there exists
a subset of this group (i.e. a set of permutations) such that every other
permutation can be expressed as a combination of these permutations. These
permutations are called the generating set of the automorphism group.
</p>
<p>This function calculates a possible generating set of the automorphism of
a graph using the BLISS algorithm. See also the BLISS homepage at
<a href="http://www.tcs.hut.fi/Software/bliss/index.html">http://www.tcs.hut.fi/Software/bliss/index.html</a>. The calculated
generating set is not necessarily minimal, and it may depend on the splitting
heuristics used by BLISS.
</p>


<h3>Value</h3>

<p>When <code>details</code> is <code>FALSE</code>, a list of vertex permutations
that form a generating set of the automorphism group of the input graph.
When <code>details</code> is <code>TRUE</code>, a named list with two members:
</p>
<table>
<tr><td><code>generators</code></td>
<td>
<p>Returns the generators themselves</p>
</td></tr> <tr><td><code>info</code></td>
<td>
<p>Additional
information about the BLISS internals. See <code><a href="#topic+count_automorphisms">count_automorphisms()</a></code> for
more details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tommi Junttila (<a href="http://users.ics.aalto.fi/tjunttil/">http://users.ics.aalto.fi/tjunttil/</a>) for BLISS,
Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the igraph glue code and
Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> for this manual page.
</p>


<h3>References</h3>

<p>Tommi Junttila and Petteri Kaski: Engineering an Efficient
Canonical Labeling Tool for Large and Sparse Graphs, <em>Proceedings of
the Ninth Workshop on Algorithm Engineering and Experiments and the Fourth
Workshop on Analytic Algorithms and Combinatorics.</em> 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+canonical_permutation">canonical_permutation()</a></code>, <code><a href="#topic+permute">permute()</a></code>,
<code><a href="#topic+count_automorphisms">count_automorphisms()</a></code>
</p>
<p>Other graph automorphism: 
<code><a href="#topic+count_automorphisms">count_automorphisms</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A ring has n*2 automorphisms, and a possible generating set is one that
## "turns" the ring by one vertex to the left or right
g &lt;- make_ring(10)
automorphism_group(g)
</code></pre>

<hr>
<h2 id='automorphisms'>Number of automorphisms</h2><span id='topic+automorphisms'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>automorphisms()</code> was renamed to <code>count_automorphisms()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>automorphisms(
  graph,
  colors = NULL,
  sh = c("fm", "f", "fs", "fl", "flm", "fsm")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="automorphisms_+3A_graph">graph</code></td>
<td>
<p>The input graph, it is treated as undirected.</p>
</td></tr>
<tr><td><code id="automorphisms_+3A_colors">colors</code></td>
<td>
<p>The colors of the individual vertices of the graph; only
vertices having the same color are allowed to match each other in an
automorphism. When omitted, igraph uses the <code>color</code> attribute of the
vertices, or, if there is no such vertex attribute, it simply assumes that
all vertices have the same color. Pass NULL explicitly if the graph has a
<code>color</code> vertex attribute but you do not want to use it.</p>
</td></tr>
<tr><td><code id="automorphisms_+3A_sh">sh</code></td>
<td>
<p>The splitting heuristics for the BLISS algorithm. Possible values
are: &lsquo;<code>f</code>&rsquo;: first non-singleton cell, &lsquo;<code>fl</code>&rsquo;: first
largest non-singleton cell, &lsquo;<code>fs</code>&rsquo;: first smallest non-singleton
cell, &lsquo;<code>fm</code>&rsquo;: first maximally non-trivially connected
non-singleton cell, &lsquo;<code>flm</code>&rsquo;: first largest maximally
non-trivially connected non-singleton cell, &lsquo;<code>fsm</code>&rsquo;: first
smallest maximally non-trivially connected non-singleton cell.</p>
</td></tr>
</table>

<hr>
<h2 id='average.path.length'>Shortest (directed or undirected) paths between vertices</h2><span id='topic+average.path.length'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>average.path.length()</code> was renamed to <code>mean_distance()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average.path.length(
  graph,
  weights = NULL,
  directed = TRUE,
  unconnected = TRUE,
  details = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average.path.length_+3A_graph">graph</code></td>
<td>
<p>The graph to work on.</p>
</td></tr>
<tr><td><code id="average.path.length_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then the
attribute is used. If this is <code>NA</code> then no weights are used (even if
the graph has a <code>weight</code> attribute).</p>
</td></tr>
<tr><td><code id="average.path.length_+3A_directed">directed</code></td>
<td>
<p>Whether to consider directed paths in directed graphs,
this argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="average.path.length_+3A_unconnected">unconnected</code></td>
<td>
<p>What to do if the graph is unconnected (not
strongly connected if directed paths are considered). If TRUE, only
the lengths of the existing paths are considered and averaged; if
FALSE, the length of the missing paths are considered as having infinite
length, making the mean distance infinite as well.</p>
</td></tr>
<tr><td><code id="average.path.length_+3A_details">details</code></td>
<td>
<p>Whether to provide additional details in the result.
Functions accepting this argument (like <code>mean_distance()</code>) return
additional information like the number of disconnected vertex pairs in
the result when this parameter is set to <code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='ba.game'>Generate random graphs using preferential attachment</h2><span id='topic+ba.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>ba.game()</code> was renamed to <code>sample_pa()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ba.game(
  n,
  power = 1,
  m = NULL,
  out.dist = NULL,
  out.seq = NULL,
  out.pref = FALSE,
  zero.appeal = 1,
  directed = TRUE,
  algorithm = c("psumtree", "psumtree-multiple", "bag"),
  start.graph = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ba.game_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_power">power</code></td>
<td>
<p>The power of the preferential attachment, the default is one,
i.e. linear preferential attachment.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_m">m</code></td>
<td>
<p>Numeric constant, the number of edges to add in each time step This
argument is only used if both <code>out.dist</code> and <code>out.seq</code> are omitted
or NULL.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_out.dist">out.dist</code></td>
<td>
<p>Numeric vector, the distribution of the number of edges to
add in each time step. This argument is only used if the <code>out.seq</code>
argument is omitted or NULL.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_out.seq">out.seq</code></td>
<td>
<p>Numeric vector giving the number of edges to add in each time
step. Its first element is ignored as no edges are added in the first time
step.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_out.pref">out.pref</code></td>
<td>
<p>Logical, if true the total degree is used for calculating
the citation probability, otherwise the in-degree is used.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_zero.appeal">zero.appeal</code></td>
<td>
<p>The &lsquo;attractiveness&rsquo; of the vertices with no
adjacent edges. See details below.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use for the graph generation.
<code>psumtree</code> uses a partial prefix-sum tree to generate the graph, this
algorithm can handle any <code>power</code> and <code>zero.appeal</code> values and
never generates multiple edges.  <code>psumtree-multiple</code> also uses a
partial prefix-sum tree, but the generation of multiple edges is allowed.
Before the 0.6 version igraph used this algorithm if <code>power</code> was not
one, or <code>zero.appeal</code> was not one.  <code>bag</code> is the algorithm that
was previously (before version 0.6) used if <code>power</code> was one and
<code>zero.appeal</code> was one as well. It works by putting the ids of the
vertices into a bag (multiset, really), exactly as many times as their
(in-)degree, plus once more. Then the required number of cited vertices are
drawn from the bag, with replacement. This method might generate multiple
edges. It only works if <code>power</code> and <code>zero.appeal</code> are equal one.</p>
</td></tr>
<tr><td><code id="ba.game_+3A_start.graph">start.graph</code></td>
<td>
<p><code>NULL</code> or an igraph graph. If a graph, then the
supplied graph is used as a starting graph for the preferential attachment
algorithm. The graph should have at least one vertex. If a graph is supplied
here and the <code>out.seq</code> argument is not <code>NULL</code>, then it should
contain the out degrees of the new vertices only, not the ones in the
<code>start.graph</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='barabasi.game'>Generate random graphs using preferential attachment</h2><span id='topic+barabasi.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>barabasi.game()</code> was renamed to <code>sample_pa()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barabasi.game(
  n,
  power = 1,
  m = NULL,
  out.dist = NULL,
  out.seq = NULL,
  out.pref = FALSE,
  zero.appeal = 1,
  directed = TRUE,
  algorithm = c("psumtree", "psumtree-multiple", "bag"),
  start.graph = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barabasi.game_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_power">power</code></td>
<td>
<p>The power of the preferential attachment, the default is one,
i.e. linear preferential attachment.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_m">m</code></td>
<td>
<p>Numeric constant, the number of edges to add in each time step This
argument is only used if both <code>out.dist</code> and <code>out.seq</code> are omitted
or NULL.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_out.dist">out.dist</code></td>
<td>
<p>Numeric vector, the distribution of the number of edges to
add in each time step. This argument is only used if the <code>out.seq</code>
argument is omitted or NULL.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_out.seq">out.seq</code></td>
<td>
<p>Numeric vector giving the number of edges to add in each time
step. Its first element is ignored as no edges are added in the first time
step.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_out.pref">out.pref</code></td>
<td>
<p>Logical, if true the total degree is used for calculating
the citation probability, otherwise the in-degree is used.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_zero.appeal">zero.appeal</code></td>
<td>
<p>The &lsquo;attractiveness&rsquo; of the vertices with no
adjacent edges. See details below.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use for the graph generation.
<code>psumtree</code> uses a partial prefix-sum tree to generate the graph, this
algorithm can handle any <code>power</code> and <code>zero.appeal</code> values and
never generates multiple edges.  <code>psumtree-multiple</code> also uses a
partial prefix-sum tree, but the generation of multiple edges is allowed.
Before the 0.6 version igraph used this algorithm if <code>power</code> was not
one, or <code>zero.appeal</code> was not one.  <code>bag</code> is the algorithm that
was previously (before version 0.6) used if <code>power</code> was one and
<code>zero.appeal</code> was one as well. It works by putting the ids of the
vertices into a bag (multiset, really), exactly as many times as their
(in-)degree, plus once more. Then the required number of cited vertices are
drawn from the bag, with replacement. This method might generate multiple
edges. It only works if <code>power</code> and <code>zero.appeal</code> are equal one.</p>
</td></tr>
<tr><td><code id="barabasi.game_+3A_start.graph">start.graph</code></td>
<td>
<p><code>NULL</code> or an igraph graph. If a graph, then the
supplied graph is used as a starting graph for the preferential attachment
algorithm. The graph should have at least one vertex. If a graph is supplied
here and the <code>out.seq</code> argument is not <code>NULL</code>, then it should
contain the out degrees of the new vertices only, not the ones in the
<code>start.graph</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='betweenness'>Vertex and edge betweenness centrality</h2><span id='topic+betweenness'></span><span id='topic+betweenness.estimate'></span><span id='topic+edge.betweenness.estimate'></span><span id='topic+edge_betweenness'></span>

<h3>Description</h3>

<p>The vertex and edge betweenness are (roughly) defined by the number of
geodesics (shortest paths) going through a vertex or an edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betweenness(
  graph,
  v = V(graph),
  directed = TRUE,
  weights = NULL,
  normalized = FALSE,
  cutoff = -1
)

edge_betweenness(
  graph,
  e = E(graph),
  directed = TRUE,
  weights = NULL,
  cutoff = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betweenness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_v">v</code></td>
<td>
<p>The vertices for which the vertex betweenness will be calculated.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_directed">directed</code></td>
<td>
<p>Logical, whether directed paths should be considered while
determining the shortest paths.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
betweenness. If the graph has a <code>weight</code> edge attribute, then this is
used by default. Weights are used to calculate weighted shortest paths,
so they are interpreted as distances.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to normalize the betweenness
scores. If <code>TRUE</code>, then the results are normalized by the number of ordered
or unordered vertex pairs in directed and undirected graphs, respectively.
In an undirected graph,
</p>
<p style="text-align: center;"><code class="reqn">B^n=\frac{2B}{(n-1)(n-2)},</code>
</p>
<p> where
<code class="reqn">B^n</code> is the normalized, <code class="reqn">B</code> the raw betweenness, and <code class="reqn">n</code>
is the number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating the
betweenness. If zero or negative then there is no such limit.</p>
</td></tr>
<tr><td><code id="betweenness_+3A_e">e</code></td>
<td>
<p>The edges for which the edge betweenness will be calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vertex betweenness of vertex <code>v</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i\ne j, i\ne v, j\ne v} g_{ivj}/g_{ij}</code>
</p>

<p>The edge betweenness of edge <code>e</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i\ne j} g_{iej}/g_{ij}.</code>
</p>

<p><code>betweenness()</code> calculates vertex betweenness, <code>edge_betweenness()</code>
calculates edge betweenness.
</p>
<p>Here <code class="reqn">g_{ij}</code> is the total number of shortest paths between vertices
<code class="reqn">i</code> and <code class="reqn">j</code> while <code class="reqn">g_{ivj}</code> is the number of those shortest paths
which pass though vertex <code class="reqn">v</code>.
</p>
<p>Both functions allow you to consider only paths of length <code>cutoff</code> or
smaller; this can be run for larger graphs, as the running time is not
quadratic (if <code>cutoff</code> is small). If <code>cutoff</code> is negative (the default),
then the function calculates the exact betweenness scores. Since igraph 1.6.0,
a <code>cutoff</code> value of zero is treated literally, i.e. paths of length larger
than zero are ignored.
</p>
<p>For calculating the betweenness a similar algorithm to the one proposed by
Brandes (see References) is used.
</p>


<h3>Value</h3>

<p>A numeric vector with the betweenness score for each vertex in
<code>v</code> for <code>betweenness()</code>.
</p>
<p>A numeric vector with the edge betweenness score for each edge in <code>e</code>
for <code>edge_betweenness()</code>.
</p>


<h3>Note</h3>

<p><code>edge_betweenness()</code> might give false values for graphs with
multiple edges.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Freeman, L.C. (1979). Centrality in Social Networks I:
Conceptual Clarification. <em>Social Networks</em>, 1, 215-239.
</p>
<p>Ulrik Brandes, A Faster Algorithm for Betweenness Centrality. <em>Journal
of Mathematical Sociology</em> 25(2):163-177, 2001.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+closeness">closeness()</a></code>, <code><a href="#topic+degree">degree()</a></code>, <code><a href="#topic+harmonic_centrality">harmonic_centrality()</a></code>
</p>
<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(10, 3 / 10)
betweenness(g)
edge_betweenness(g)

</code></pre>

<hr>
<h2 id='bfs'>Breadth-first search</h2><span id='topic+bfs'></span>

<h3>Description</h3>

<p>Breadth-first search is an algorithm to traverse a graph. We start from a
root vertex and spread along every edge &ldquo;simultaneously&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfs(
  graph,
  root,
  mode = c("out", "in", "all", "total"),
  unreachable = TRUE,
  restricted = NULL,
  order = TRUE,
  rank = FALSE,
  father = FALSE,
  pred = FALSE,
  succ = FALSE,
  dist = FALSE,
  callback = NULL,
  extra = NULL,
  rho = parent.frame(),
  neimode
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfs_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="bfs_+3A_root">root</code></td>
<td>
<p>Numeric vector, usually of length one. The root vertex, or root
vertices to start the search from.</p>
</td></tr>
<tr><td><code id="bfs_+3A_mode">mode</code></td>
<td>
<p>For directed graphs specifies the type of edges to follow.
&lsquo;out&rsquo; follows outgoing, &lsquo;in&rsquo; incoming edges. &lsquo;all&rsquo;
ignores edge directions completely. &lsquo;total&rsquo; is a synonym for
&lsquo;all&rsquo;. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="bfs_+3A_unreachable">unreachable</code></td>
<td>
<p>Logical scalar, whether the search should visit the
vertices that are unreachable from the given root vertex (or vertices). If
<code>TRUE</code>, then additional searches are performed until all vertices are
visited.</p>
</td></tr>
<tr><td><code id="bfs_+3A_restricted">restricted</code></td>
<td>
<p><code>NULL</code> (=no restriction), or a vector of vertices
(ids or symbolic names). In the latter case, the search is restricted to the
given vertices.</p>
</td></tr>
<tr><td><code id="bfs_+3A_order">order</code></td>
<td>
<p>Logical scalar, whether to return the ordering of the vertices.</p>
</td></tr>
<tr><td><code id="bfs_+3A_rank">rank</code></td>
<td>
<p>Logical scalar, whether to return the rank of the vertices.</p>
</td></tr>
<tr><td><code id="bfs_+3A_father">father</code></td>
<td>
<p>Logical scalar, whether to return the father of the vertices.</p>
</td></tr>
<tr><td><code id="bfs_+3A_pred">pred</code></td>
<td>
<p>Logical scalar, whether to return the predecessors of the
vertices.</p>
</td></tr>
<tr><td><code id="bfs_+3A_succ">succ</code></td>
<td>
<p>Logical scalar, whether to return the successors of the
vertices.</p>
</td></tr>
<tr><td><code id="bfs_+3A_dist">dist</code></td>
<td>
<p>Logical scalar, whether to return the distance from the root of
the search tree.</p>
</td></tr>
<tr><td><code id="bfs_+3A_callback">callback</code></td>
<td>
<p>If not <code>NULL</code>, then it must be callback function. This
is called whenever a vertex is visited. See details below.</p>
</td></tr>
<tr><td><code id="bfs_+3A_extra">extra</code></td>
<td>
<p>Additional argument to supply to the callback function.</p>
</td></tr>
<tr><td><code id="bfs_+3A_rho">rho</code></td>
<td>
<p>The environment in which the callback function is evaluated.</p>
</td></tr>
<tr><td><code id="bfs_+3A_neimode">neimode</code></td>
<td>
<p>This argument is deprecated from igraph 1.3.0; use
<code>mode</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The callback function must have the following arguments:
</p>

<dl>
<dt>graph</dt><dd><p>The input graph is passed to the callback function here.</p>
</dd>
<dt>data</dt><dd><p>A named numeric vector, with the following entries:
&lsquo;vid&rsquo;, the vertex that was just visited, &lsquo;pred&rsquo;, its
predecessor (zero if this is the first vertex), &lsquo;succ&rsquo;, its successor
(zero if this is the last vertex), &lsquo;rank&rsquo;, the rank of the
current vertex, &lsquo;dist&rsquo;, its distance from the root of the search
tree.</p>
</dd>
<dt>extra</dt><dd><p>The extra argument.</p>
</dd>
</dl>

<p>The callback must return <code>FALSE</code>
to continue the search or <code>TRUE</code> to terminate it. See examples below on how to
use the callback function.
</p>


<h3>Value</h3>

<p>A named list with the following entries:
</p>
<table>
<tr><td><code>root</code></td>
<td>
<p>Numeric scalar.
The root vertex that was used as the starting point of the search.</p>
</td></tr>
<tr><td><code>neimode</code></td>
<td>
<p>Character scalar. The <code>mode</code> argument of the function
call. Note that for undirected graphs this is always &lsquo;all&rsquo;,
irrespectively of the supplied value.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p>Numeric vector. The
vertex ids, in the order in which they were visited by the search.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Numeric vector. The rank for each vertex, zero for unreachable vertices.</p>
</td></tr>
<tr><td><code>father</code></td>
<td>
<p>Numeric
vector. The father of each vertex, i.e. the vertex it was discovered from.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>Numeric vector. The previously visited vertex for each vertex,
or 0 if there was no such vertex.</p>
</td></tr>
<tr><td><code>succ</code></td>
<td>
<p>Numeric vector. The next
vertex that was visited after the current one, or 0 if there was no such
vertex.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>Numeric vector, for each vertex its distance from the
root of the search tree. Unreachable vertices have a negative distance
as of igraph 1.6.0, this used to be <code>NaN</code>.</p>
</td></tr>
</table>
<p>Note that <code>order</code>, <code>rank</code>, <code>father</code>, <code>pred</code>, <code>succ</code>
and <code>dist</code> might be <code>NULL</code> if their corresponding argument is
<code>FALSE</code>, i.e. if their calculation is not requested.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dfs">dfs()</a></code> for depth-first search.
</p>
<p>Other structural.properties: 
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two rings
bfs(make_ring(10) %du% make_ring(10),
  root = 1, "out",
  order = TRUE, rank = TRUE, father = TRUE, pred = TRUE,
  succ = TRUE, dist = TRUE
)

## How to use a callback
f &lt;- function(graph, data, extra) {
  print(data)
  FALSE
}
tmp &lt;- bfs(make_ring(10) %du% make_ring(10),
  root = 1, "out",
  callback = f
)

## How to use a callback to stop the search
## We stop after visiting all vertices in the initial component
f &lt;- function(graph, data, extra) {
  data["succ"] == -1
}
bfs(make_ring(10) %du% make_ring(10), root = 1, callback = f)

</code></pre>

<hr>
<h2 id='biconnected_components'>Biconnected components</h2><span id='topic+biconnected_components'></span>

<h3>Description</h3>

<p>Finding the biconnected components of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biconnected_components(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biconnected_components_+3A_graph">graph</code></td>
<td>
<p>The input graph. It is treated as an undirected graph, even if
it is directed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graph is biconnected if the removal of any single vertex (and its adjacent
edges) does not disconnect it.
</p>
<p>A biconnected component of a graph is a maximal biconnected subgraph of it.
The biconnected components of a graph can be given by the partition of its
edges: every edge is a member of exactly one biconnected component. Note
that this is not true for vertices: the same vertex can be part of many
biconnected components.
</p>


<h3>Value</h3>

<p>A named list with three components: </p>
<table>
<tr><td><code>no</code></td>
<td>
<p>Numeric scalar, an
integer giving the number of biconnected components in the graph.</p>
</td></tr>
<tr><td><code>tree_edges</code></td>
<td>
<p>The components themselves, a list of numeric vectors. Each
vector is a set of edge ids giving the edges in a biconnected component.
These edges define a spanning tree of the component.</p>
</td></tr>
<tr><td><code>component_edges</code></td>
<td>
<p>A list of numeric vectors. It gives all edges in the
components.</p>
</td></tr> <tr><td><code>components</code></td>
<td>
<p>A list of numeric vectors, the vertices of
the components.</p>
</td></tr> <tr><td><code>articulation_points</code></td>
<td>
<p>The articulation points of the
graph. See <code><a href="#topic+articulation_points">articulation_points()</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+articulation_points">articulation_points()</a></code>, <code><a href="#topic+components">components()</a></code>,
<code><a href="#topic+is_connected">is_connected()</a></code>, <code><a href="#topic+vertex_connectivity">vertex_connectivity()</a></code>
</p>
<p>Connected components
<code><a href="#topic+articulation_points">articulation_points</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+decompose">decompose</a>()</code>,
<code><a href="#topic+is_biconnected">is_biconnected</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- disjoint_union(make_full_graph(5), make_full_graph(5))
clu &lt;- components(g)$membership
g &lt;- add_edges(g, c(which(clu == 1), which(clu == 2)))
bc &lt;- biconnected_components(g)
</code></pre>

<hr>
<h2 id='biconnected.components'>Biconnected components</h2><span id='topic+biconnected.components'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>biconnected.components()</code> was renamed to <code>biconnected_components()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biconnected.components(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biconnected.components_+3A_graph">graph</code></td>
<td>
<p>The input graph. It is treated as an undirected graph, even if
it is directed.</p>
</td></tr>
</table>

<hr>
<h2 id='bipartite_mapping'>Decide whether a graph is bipartite</h2><span id='topic+bipartite_mapping'></span>

<h3>Description</h3>

<p>This function decides whether the vertices of a network can be mapped to two
vertex types in a way that no vertices of the same type are connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartite_mapping(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartite_mapping_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bipartite graph in igraph has a &lsquo;<code>type</code>&rsquo; vertex attribute
giving the two vertex types.
</p>
<p>This function simply checks whether a graph <em>could</em> be bipartite. It
tries to find a mapping that gives a possible division of the vertices into
two classes, such that no two vertices of the same class are connected by an
edge.
</p>
<p>The existence of such a mapping is equivalent of having no circuits of odd
length in the graph. A graph with loop edges cannot bipartite.
</p>
<p>Note that the mapping is not necessarily unique, e.g. if the graph has at
least two components, then the vertices in the separate components can be
mapped independently.
</p>


<h3>Value</h3>

<p>A named list with two elements: </p>
<table>
<tr><td><code>res</code></td>
<td>
<p>A logical scalar,
<code>TRUE</code> if the can be bipartite, <code>FALSE</code> otherwise.</p>
</td></tr> <tr><td><code>type</code></td>
<td>
<p>A
possible vertex type mapping, a logical vector. If no such mapping exists,
then an empty vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Bipartite graphs
<code><a href="#topic+bipartite_projection">bipartite_projection</a>()</code>,
<code><a href="#topic+is_bipartite">is_bipartite</a>()</code>,
<code><a href="#topic+make_bipartite_graph">make_bipartite_graph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Rings with an even number of vertices are bipartite
g &lt;- make_ring(10)
bipartite_mapping(g)

## All star graphs are bipartite
g2 &lt;- make_star(10)
bipartite_mapping(g2)

## A graph containing a triangle is not bipartite
g3 &lt;- make_ring(10)
g3 &lt;- add_edges(g3, c(1, 3))
bipartite_mapping(g3)
</code></pre>

<hr>
<h2 id='bipartite_projection'>Project a bipartite graph</h2><span id='topic+bipartite_projection'></span><span id='topic+bipartite_projection_size'></span>

<h3>Description</h3>

<p>A bipartite graph is projected into two one-mode networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartite_projection(
  graph,
  types = NULL,
  multiplicity = TRUE,
  probe1 = NULL,
  which = c("both", "true", "false"),
  remove.type = TRUE
)

bipartite_projection_size(graph, types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartite_projection_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can be directed, but edge directions are
ignored during the computation.</p>
</td></tr>
<tr><td><code id="bipartite_projection_+3A_types">types</code></td>
<td>
<p>An optional vertex type vector to use instead of the
&lsquo;<code>type</code>&rsquo; vertex attribute. You must supply this argument if the
graph has no &lsquo;<code>type</code>&rsquo; vertex attribute.</p>
</td></tr>
<tr><td><code id="bipartite_projection_+3A_multiplicity">multiplicity</code></td>
<td>
<p>If <code>TRUE</code>, then igraph keeps the multiplicity of
the edges as an edge attribute called &lsquo;weight&rsquo;.
E.g. if there is an A-C-B and also an A-D-B
triple in the bipartite graph (but no more X, such that A-X-B is also in the
graph), then the multiplicity of the A-B edge in the projection will be 2.</p>
</td></tr>
<tr><td><code id="bipartite_projection_+3A_probe1">probe1</code></td>
<td>
<p>This argument can be used to specify the order of the
projections in the resulting list. If given, then it is considered as a
vertex id (or a symbolic vertex name); the projection containing this vertex
will be the first one in the result list.  This argument is ignored if only
one projection is requested in argument <code>which</code>.</p>
</td></tr>
<tr><td><code id="bipartite_projection_+3A_which">which</code></td>
<td>
<p>A character scalar to specify which projection(s) to calculate.
The default is to calculate both.</p>
</td></tr>
<tr><td><code id="bipartite_projection_+3A_remove.type">remove.type</code></td>
<td>
<p>Logical scalar, whether to remove the <code>type</code> vertex
attribute from the projections. This makes sense because these graphs are
not bipartite any more. However if you want to combine them with each other
(or other bipartite graphs), then it is worth keeping this attribute. By
default it will be removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bipartite graphs have a <code>type</code> vertex attribute in igraph, this is
boolean and <code>FALSE</code> for the vertices of the first kind and <code>TRUE</code>
for vertices of the second kind.
</p>
<p><code>bipartite_projection_size()</code> calculates the number of vertices and edges
in the two projections of the bipartite graphs, without calculating the
projections themselves. This is useful to check how much memory the
projections would need if you have a large bipartite graph.
</p>
<p><code>bipartite_projection()</code> calculates the actual projections.  You can use
the <code>probe1</code> argument to specify the order of the projections in the
result. By default vertex type <code>FALSE</code> is the first and <code>TRUE</code> is
the second.
</p>
<p><code>bipartite_projection()</code> keeps vertex attributes.
</p>


<h3>Value</h3>

<p>A list of two undirected graphs. See details above.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Bipartite graphs
<code><a href="#topic+bipartite_mapping">bipartite_mapping</a>()</code>,
<code><a href="#topic+is_bipartite">is_bipartite</a>()</code>,
<code><a href="#topic+make_bipartite_graph">make_bipartite_graph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Projection of a full bipartite graph is a full graph
g &lt;- make_full_bipartite_graph(10, 5)
proj &lt;- bipartite_projection(g)
graph.isomorphic(proj[[1]], make_full_graph(10))
graph.isomorphic(proj[[2]], make_full_graph(5))

## The projection keeps the vertex attributes
M &lt;- matrix(0, nrow = 5, ncol = 3)
rownames(M) &lt;- c("Alice", "Bob", "Cecil", "Dan", "Ethel")
colnames(M) &lt;- c("Party", "Skiing", "Badminton")
M[] &lt;- sample(0:1, length(M), replace = TRUE)
M
g2 &lt;- graph_from_biadjacency_matrix(M)
g2$name &lt;- "Event network"
proj2 &lt;- bipartite_projection(g2)
print(proj2[[1]], g = TRUE, e = TRUE)
print(proj2[[2]], g = TRUE, e = TRUE)

</code></pre>

<hr>
<h2 id='bipartite.mapping'>Decide whether a graph is bipartite</h2><span id='topic+bipartite.mapping'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>bipartite.mapping()</code> was renamed to <code>bipartite_mapping()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartite.mapping(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartite.mapping_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>

<hr>
<h2 id='bipartite.projection'>Project a bipartite graph</h2><span id='topic+bipartite.projection'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>bipartite.projection()</code> was renamed to <code>bipartite_projection()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartite.projection(
  graph,
  types = NULL,
  multiplicity = TRUE,
  probe1 = NULL,
  which = c("both", "true", "false"),
  remove.type = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartite.projection_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can be directed, but edge directions are
ignored during the computation.</p>
</td></tr>
<tr><td><code id="bipartite.projection_+3A_types">types</code></td>
<td>
<p>An optional vertex type vector to use instead of the
&lsquo;<code>type</code>&rsquo; vertex attribute. You must supply this argument if the
graph has no &lsquo;<code>type</code>&rsquo; vertex attribute.</p>
</td></tr>
<tr><td><code id="bipartite.projection_+3A_multiplicity">multiplicity</code></td>
<td>
<p>If <code>TRUE</code>, then igraph keeps the multiplicity of
the edges as an edge attribute called &lsquo;weight&rsquo;.
E.g. if there is an A-C-B and also an A-D-B
triple in the bipartite graph (but no more X, such that A-X-B is also in the
graph), then the multiplicity of the A-B edge in the projection will be 2.</p>
</td></tr>
<tr><td><code id="bipartite.projection_+3A_probe1">probe1</code></td>
<td>
<p>This argument can be used to specify the order of the
projections in the resulting list. If given, then it is considered as a
vertex id (or a symbolic vertex name); the projection containing this vertex
will be the first one in the result list.  This argument is ignored if only
one projection is requested in argument <code>which</code>.</p>
</td></tr>
<tr><td><code id="bipartite.projection_+3A_which">which</code></td>
<td>
<p>A character scalar to specify which projection(s) to calculate.
The default is to calculate both.</p>
</td></tr>
<tr><td><code id="bipartite.projection_+3A_remove.type">remove.type</code></td>
<td>
<p>Logical scalar, whether to remove the <code>type</code> vertex
attribute from the projections. This makes sense because these graphs are
not bipartite any more. However if you want to combine them with each other
(or other bipartite graphs), then it is worth keeping this attribute. By
default it will be removed.</p>
</td></tr>
</table>

<hr>
<h2 id='bipartite.projection.size'>Project a bipartite graph</h2><span id='topic+bipartite.projection.size'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>bipartite.projection.size()</code> was renamed to <code>bipartite_projection_size()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartite.projection.size(graph, types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartite.projection.size_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can be directed, but edge directions are
ignored during the computation.</p>
</td></tr>
<tr><td><code id="bipartite.projection.size_+3A_types">types</code></td>
<td>
<p>An optional vertex type vector to use instead of the
&lsquo;<code>type</code>&rsquo; vertex attribute. You must supply this argument if the
graph has no &lsquo;<code>type</code>&rsquo; vertex attribute.</p>
</td></tr>
</table>

<hr>
<h2 id='bipartite.random.game'>Bipartite random graphs</h2><span id='topic+bipartite.random.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>bipartite.random.game()</code> was renamed to <code>sample_bipartite()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bipartite.random.game(
  n1,
  n2,
  type = c("gnp", "gnm"),
  p,
  m,
  directed = FALSE,
  mode = c("out", "in", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bipartite.random.game_+3A_n1">n1</code></td>
<td>
<p>Integer scalar, the number of bottom vertices.</p>
</td></tr>
<tr><td><code id="bipartite.random.game_+3A_n2">n2</code></td>
<td>
<p>Integer scalar, the number of top vertices.</p>
</td></tr>
<tr><td><code id="bipartite.random.game_+3A_type">type</code></td>
<td>
<p>Character scalar, the type of the graph, &lsquo;gnp&rsquo; creates a
<code class="reqn">G(n,p)</code> graph, &lsquo;gnm&rsquo; creates a <code class="reqn">G(n,m)</code> graph. See details below.</p>
</td></tr>
<tr><td><code id="bipartite.random.game_+3A_p">p</code></td>
<td>
<p>Real scalar, connection probability for <code class="reqn">G(n,p)</code> graphs. Should not
be given for <code class="reqn">G(n,m)</code> graphs.</p>
</td></tr>
<tr><td><code id="bipartite.random.game_+3A_m">m</code></td>
<td>
<p>Integer scalar, the number of edges for <code class="reqn">G(n,m)</code> graphs. Should not
be given for <code class="reqn">G(n,p)</code> graphs.</p>
</td></tr>
<tr><td><code id="bipartite.random.game_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to create a directed graph. See also
the <code>mode</code> argument.</p>
</td></tr>
<tr><td><code id="bipartite.random.game_+3A_mode">mode</code></td>
<td>
<p>Character scalar, specifies how to direct the edges in directed
graphs. If it is &lsquo;out&rsquo;, then directed edges point from bottom
vertices to top vertices. If it is &lsquo;in&rsquo;, edges point from top
vertices to bottom vertices. &lsquo;out&rsquo; and &lsquo;in&rsquo; do not generate
mutual edges. If this argument is &lsquo;all&rsquo;, then each edge direction is
considered independently and mutual edges might be generated. This argument
is ignored for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='blockGraphs'>Calculate Cohesive Blocks</h2><span id='topic+blockGraphs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>blockGraphs()</code> was renamed to <code>graphs_from_cohesive_blocks()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockGraphs(blocks, graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockGraphs_+3A_graph">graph</code></td>
<td>
<p>For <code>cohesive_blocks()</code> a graph object of class
<code>igraph</code>. It must be undirected and simple. (See
<code><a href="#topic+is_simple">is_simple()</a></code>.)
</p>
<p>For <code>graphs_from_cohesive_blocks()</code> and <code>export_pajek()</code> the same graph must be
supplied whose cohesive block structure is given in the <code>blocks()</code>
argument.</p>
</td></tr>
</table>

<hr>
<h2 id='bonpow'>Find Bonacich Power Centrality Scores of Network Positions</h2><span id='topic+bonpow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>bonpow()</code> was renamed to <code>power_centrality()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bonpow(
  graph,
  nodes = V(graph),
  loops = FALSE,
  exponent = 1,
  rescale = FALSE,
  tol = 1e-07,
  sparse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bonpow_+3A_graph">graph</code></td>
<td>
<p>the input graph.</p>
</td></tr>
<tr><td><code id="bonpow_+3A_nodes">nodes</code></td>
<td>
<p>vertex sequence indicating which vertices are to be included in
the calculation.  By default, all vertices are included.</p>
</td></tr>
<tr><td><code id="bonpow_+3A_loops">loops</code></td>
<td>
<p>boolean indicating whether or not the diagonal should be
treated as valid data.  Set this true if and only if the data can contain
loops.  <code>loops</code> is <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="bonpow_+3A_exponent">exponent</code></td>
<td>
<p>exponent (decay rate) for the Bonacich power centrality
score; can be negative</p>
</td></tr>
<tr><td><code id="bonpow_+3A_rescale">rescale</code></td>
<td>
<p>if true, centrality scores are rescaled such that they sum to
1.</p>
</td></tr>
<tr><td><code id="bonpow_+3A_tol">tol</code></td>
<td>
<p>tolerance for near-singularities during matrix inversion (see
<code><a href="base.html#topic+solve">solve()</a></code>)</p>
</td></tr>
<tr><td><code id="bonpow_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to use sparse matrices for the
calculation. The &lsquo;Matrix&rsquo; package is required for sparse matrix
support</p>
</td></tr>
</table>

<hr>
<h2 id='c.igraph.es'>Concatenate edge sequences</h2><span id='topic+c.igraph.es'></span>

<h3>Description</h3>

<p>Concatenate edge sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.igraph.es_+3A_...">...</code></td>
<td>
<p>The edge sequences to concatenate. They must
all refer to the same graph.</p>
</td></tr>
<tr><td><code id="c.igraph.es_+3A_recursive">recursive</code></td>
<td>
<p>Ignored, included for S3 compatibility with the
base <code>c</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge sequence, the input sequences concatenated.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
c(E(g)[1], E(g)["A|B"], E(g)[1:4])
</code></pre>

<hr>
<h2 id='c.igraph.vs'>Concatenate vertex sequences</h2><span id='topic+c.igraph.vs'></span>

<h3>Description</h3>

<p>Concatenate vertex sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
c(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.igraph.vs_+3A_...">...</code></td>
<td>
<p>The vertex sequences to concatenate. They must
refer to the same graph.</p>
</td></tr>
<tr><td><code id="c.igraph.vs_+3A_recursive">recursive</code></td>
<td>
<p>Ignored, included for S3 compatibility with
the base <code>c</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vertex sequence, the input sequences concatenated.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
c(V(g)[1], V(g)["A"], V(g)[1:4])
</code></pre>

<hr>
<h2 id='callaway.traits.game'>Graph generation based on different vertex types</h2><span id='topic+callaway.traits.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>callaway.traits.game()</code> was renamed to <code>sample_traits_callaway()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callaway.traits.game(
  nodes,
  types,
  edge.per.step = 1,
  type.dist = rep(1, types),
  pref.matrix = matrix(1, types, types),
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callaway.traits.game_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="callaway.traits.game_+3A_types">types</code></td>
<td>
<p>The number of different vertex types.</p>
</td></tr>
<tr><td><code id="callaway.traits.game_+3A_edge.per.step">edge.per.step</code></td>
<td>
<p>The number of edges to add to the graph per time step.</p>
</td></tr>
<tr><td><code id="callaway.traits.game_+3A_type.dist">type.dist</code></td>
<td>
<p>The distribution of the vertex types. This is assumed to be
stationary in time.</p>
</td></tr>
<tr><td><code id="callaway.traits.game_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>A matrix giving the preferences of the given vertex
types. These should be probabilities, i.e. numbers between zero and one.</p>
</td></tr>
<tr><td><code id="callaway.traits.game_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to generate directed graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='canonical_permutation'>Canonical permutation of a graph</h2><span id='topic+canonical_permutation'></span>

<h3>Description</h3>

<p>The canonical permutation brings every isomorphic graphs into the same
(labeled) graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canonical_permutation(
  graph,
  colors = NULL,
  sh = c("fm", "f", "fs", "fl", "flm", "fsm")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canonical_permutation_+3A_graph">graph</code></td>
<td>
<p>The input graph, treated as undirected.</p>
</td></tr>
<tr><td><code id="canonical_permutation_+3A_colors">colors</code></td>
<td>
<p>The colors of the individual vertices of the graph; only
vertices having the same color are allowed to match each other in an
automorphism. When omitted, igraph uses the <code>color</code> attribute of the
vertices, or, if there is no such vertex attribute, it simply assumes that
all vertices have the same color. Pass NULL explicitly if the graph has a
<code>color</code> vertex attribute but you do not want to use it.</p>
</td></tr>
<tr><td><code id="canonical_permutation_+3A_sh">sh</code></td>
<td>
<p>Type of the heuristics to use for the BLISS algorithm. See details
for possible values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>canonical_permutation()</code> computes a permutation which brings the graph
into canonical form, as defined by the BLISS algorithm.  All isomorphic
graphs have the same canonical form.
</p>
<p>See the paper below for the details about BLISS. This and more information
is available at <a href="http://www.tcs.hut.fi/Software/bliss/index.html">http://www.tcs.hut.fi/Software/bliss/index.html</a>.
</p>
<p>The possible values for the <code>sh</code> argument are: </p>

<dl>
<dt>&quot;f&quot;</dt><dd><p>First non-singleton cell.</p>
</dd> <dt>&quot;fl&quot;</dt><dd><p>First largest
non-singleton cell.</p>
</dd> <dt>&quot;fs&quot;</dt><dd><p>First smallest non-singleton cell.</p>
</dd>
<dt>&quot;fm&quot;</dt><dd><p>First maximally non-trivially connectec non-singleton
cell.</p>
</dd> <dt>&quot;flm&quot;</dt><dd><p>Largest maximally non-trivially connected
non-singleton cell.</p>
</dd> <dt>&quot;fsm&quot;</dt><dd><p>Smallest maximally non-trivially
connected non-singleton cell.</p>
</dd> </dl>
<p> See the paper in references for details
about these.
</p>


<h3>Value</h3>

<p>A list with the following members: </p>
<table>
<tr><td><code>labeling</code></td>
<td>
<p>The canonical
permutation which takes the input graph into canonical form. A numeric
vector, the first element is the new label of vertex 0, the second element
for vertex 1, etc. </p>
</td></tr> <tr><td><code>info</code></td>
<td>
<p>Some information about the BLISS
computation. A named list with the following members: </p>

<dl>
<dt>&quot;nof_nodes&quot;</dt><dd><p>The number of nodes in the search tree.</p>
</dd>
<dt>&quot;nof_leaf_nodes&quot;</dt><dd><p>The number of leaf nodes in the search tree.</p>
</dd>
<dt>&quot;nof_bad_nodes&quot;</dt><dd><p>Number of bad nodes.</p>
</dd>
<dt>&quot;nof_canupdates&quot;</dt><dd><p>Number of canrep updates.</p>
</dd>
<dt>&quot;max_level&quot;</dt><dd><p>Maximum level.</p>
</dd> <dt>&quot;group_size&quot;</dt><dd><p>The size
of the automorphism group of the input graph, as a string. The string
representation is necessary because the group size can easily exceed
values that are exactly representable in floating point.</p>
</dd> </dl>
 </td></tr>
</table>


<h3>Author(s)</h3>

<p>Tommi Junttila for BLISS, Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the igraph and R interfaces.
</p>


<h3>References</h3>

<p>Tommi Junttila and Petteri Kaski: Engineering an Efficient
Canonical Labeling Tool for Large and Sparse Graphs, <em>Proceedings of
the Ninth Workshop on Algorithm Engineering and Experiments and the Fourth
Workshop on Analytic Algorithms and Combinatorics.</em> 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+permute">permute()</a></code> to apply a permutation to a graph,
<code><a href="#topic+graph.isomorphic">graph.isomorphic()</a></code> for deciding graph isomorphism, possibly
based on canonical labels.
</p>
<p>Other graph isomorphism: 
<code><a href="#topic+count_isomorphisms">count_isomorphisms</a>()</code>,
<code><a href="#topic+count_subgraph_isomorphisms">count_subgraph_isomorphisms</a>()</code>,
<code><a href="#topic+graph_from_isomorphism_class">graph_from_isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphic">isomorphic</a>()</code>,
<code><a href="#topic+isomorphism_class">isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphisms">isomorphisms</a>()</code>,
<code><a href="#topic+subgraph_isomorphic">subgraph_isomorphic</a>()</code>,
<code><a href="#topic+subgraph_isomorphisms">subgraph_isomorphisms</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Calculate the canonical form of a random graph
g1 &lt;- sample_gnm(10, 20)
cp1 &lt;- canonical_permutation(g1)
cf1 &lt;- permute(g1, cp1$labeling)

## Do the same with a random permutation of it
g2 &lt;- permute(g1, sample(vcount(g1)))
cp2 &lt;- canonical_permutation(g2)
cf2 &lt;- permute(g2, cp2$labeling)

## Check that they are the same
el1 &lt;- as_edgelist(cf1)
el2 &lt;- as_edgelist(cf2)
el1 &lt;- el1[order(el1[, 1], el1[, 2]), ]
el2 &lt;- el2[order(el2[, 1], el2[, 2]), ]
all(el1 == el2)
</code></pre>

<hr>
<h2 id='canonical.permutation'>Canonical permutation of a graph</h2><span id='topic+canonical.permutation'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>canonical.permutation()</code> was renamed to <code>canonical_permutation()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canonical.permutation(
  graph,
  colors = NULL,
  sh = c("fm", "f", "fs", "fl", "flm", "fsm")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canonical.permutation_+3A_graph">graph</code></td>
<td>
<p>The input graph, treated as undirected.</p>
</td></tr>
<tr><td><code id="canonical.permutation_+3A_colors">colors</code></td>
<td>
<p>The colors of the individual vertices of the graph; only
vertices having the same color are allowed to match each other in an
automorphism. When omitted, igraph uses the <code>color</code> attribute of the
vertices, or, if there is no such vertex attribute, it simply assumes that
all vertices have the same color. Pass NULL explicitly if the graph has a
<code>color</code> vertex attribute but you do not want to use it.</p>
</td></tr>
<tr><td><code id="canonical.permutation_+3A_sh">sh</code></td>
<td>
<p>Type of the heuristics to use for the BLISS algorithm. See details
for possible values.</p>
</td></tr>
</table>

<hr>
<h2 id='categorical_pal'>Palette for categories</h2><span id='topic+categorical_pal'></span>

<h3>Description</h3>

<p>This is a color blind friendly palette from
<a href="https://jfly.uni-koeln.de/color/">https://jfly.uni-koeln.de/color/</a>. It has 8 colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorical_pal(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="categorical_pal_+3A_n">n</code></td>
<td>
<p>The number of colors in the palette. We simply take the first
<code>n</code> colors from the total 8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the suggested palette for visualizations where vertex colors
mark categories, e.g. community membership.
</p>


<h3>Value</h3>

<p>A character vector of RGB color codes.
</p>


<h3>Examples</h3>

<pre>
library(igraphdata)
data(karate)
karate &lt;- karate 
  add_layout_(with_fr()) 
  set_vertex_attr("size", value = 10)

cl_k &lt;- cluster_optimal(karate)

V(karate)$color &lt;- membership(cl_k)
karate$palette &lt;- categorical_pal(length(cl_k))
plot(karate)
</pre>


<h3>See Also</h3>

<p>Other palettes: 
<code><a href="#topic+diverging_pal">diverging_pal</a>()</code>,
<code><a href="#topic+r_pal">r_pal</a>()</code>,
<code><a href="#topic+sequential_pal">sequential_pal</a>()</code>
</p>

<hr>
<h2 id='centr_betw'>Centralize a graph according to the betweenness of vertices</h2><span id='topic+centr_betw'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+centralize">centralize()</a></code> for a summary of graph centralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_betw(graph, directed = TRUE, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centr_betw_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="centr_betw_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether to use directed shortest paths for
calculating betweenness.</p>
</td></tr>
<tr><td><code id="centr_betw_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the theoretical maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>The node-level centrality scores.</p>
</td></tr>
<tr><td><code>centralization</code></td>
<td>
<p>The graph level centrality index.</p>
</td></tr>
<tr><td><code>theoretical_max</code></td>
<td>
<p>The maximum theoretical graph level
centralization score for a graph with the given number of vertices,
using the same parameters. If the <code>normalized</code> argument was
<code>TRUE</code>, then the result was divided by this number.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw_tmax">centr_betw_tmax</a>()</code>,
<code><a href="#topic+centr_clo">centr_clo</a>()</code>,
<code><a href="#topic+centr_clo_tmax">centr_clo_tmax</a>()</code>,
<code><a href="#topic+centr_degree">centr_degree</a>()</code>,
<code><a href="#topic+centr_degree_tmax">centr_degree_tmax</a>()</code>,
<code><a href="#topic+centr_eigen">centr_eigen</a>()</code>,
<code><a href="#topic+centr_eigen_tmax">centr_eigen_tmax</a>()</code>,
<code><a href="#topic+centralize">centralize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_degree(g)$centralization
centr_clo(g, mode = "all")$centralization
centr_betw(g, directed = FALSE)$centralization
centr_eigen(g, directed = FALSE)$centralization
</code></pre>

<hr>
<h2 id='centr_betw_tmax'>Theoretical maximum for betweenness centralization</h2><span id='topic+centr_betw_tmax'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+centralize">centralize()</a></code> for a summary of graph centralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_betw_tmax(graph = NULL, nodes = 0, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centr_betw_tmax_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can also be <code>NULL</code>, if
<code>nodes</code> is given.</p>
</td></tr>
<tr><td><code id="centr_betw_tmax_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices. This is ignored if the graph is
given.</p>
</td></tr>
<tr><td><code id="centr_betw_tmax_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether to use directed shortest paths
for calculating betweenness.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real scalar, the theoretical maximum (unnormalized) graph
betweenness centrality score for graphs with given order and other
parameters.
</p>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw">centr_betw</a>()</code>,
<code><a href="#topic+centr_clo">centr_clo</a>()</code>,
<code><a href="#topic+centr_clo_tmax">centr_clo_tmax</a>()</code>,
<code><a href="#topic+centr_degree">centr_degree</a>()</code>,
<code><a href="#topic+centr_degree_tmax">centr_degree_tmax</a>()</code>,
<code><a href="#topic+centr_eigen">centr_eigen</a>()</code>,
<code><a href="#topic+centr_eigen_tmax">centr_eigen_tmax</a>()</code>,
<code><a href="#topic+centralize">centralize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_betw(g, normalized = FALSE)$centralization %&gt;%
  `/`(centr_betw_tmax(g))
centr_betw(g, normalized = TRUE)$centralization
</code></pre>

<hr>
<h2 id='centr_clo'>Centralize a graph according to the closeness of vertices</h2><span id='topic+centr_clo'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+centralize">centralize()</a></code> for a summary of graph centralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_clo(graph, mode = c("out", "in", "all", "total"), normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centr_clo_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="centr_clo_+3A_mode">mode</code></td>
<td>
<p>This is the same as the <code>mode</code> argument of
<code>closeness()</code>.</p>
</td></tr>
<tr><td><code id="centr_clo_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the theoretical maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>The node-level centrality scores.</p>
</td></tr>
<tr><td><code>centralization</code></td>
<td>
<p>The graph level centrality index.</p>
</td></tr>
<tr><td><code>theoretical_max</code></td>
<td>
<p>The maximum theoretical graph level
centralization score for a graph with the given number of vertices,
using the same parameters. If the <code>normalized</code> argument was
<code>TRUE</code>, then the result was divided by this number.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw">centr_betw</a>()</code>,
<code><a href="#topic+centr_betw_tmax">centr_betw_tmax</a>()</code>,
<code><a href="#topic+centr_clo_tmax">centr_clo_tmax</a>()</code>,
<code><a href="#topic+centr_degree">centr_degree</a>()</code>,
<code><a href="#topic+centr_degree_tmax">centr_degree_tmax</a>()</code>,
<code><a href="#topic+centr_eigen">centr_eigen</a>()</code>,
<code><a href="#topic+centr_eigen_tmax">centr_eigen_tmax</a>()</code>,
<code><a href="#topic+centralize">centralize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_degree(g)$centralization
centr_clo(g, mode = "all")$centralization
centr_betw(g, directed = FALSE)$centralization
centr_eigen(g, directed = FALSE)$centralization
</code></pre>

<hr>
<h2 id='centr_clo_tmax'>Theoretical maximum for closeness centralization</h2><span id='topic+centr_clo_tmax'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+centralize">centralize()</a></code> for a summary of graph centralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_clo_tmax(graph = NULL, nodes = 0, mode = c("out", "in", "all", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centr_clo_tmax_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can also be <code>NULL</code>, if
<code>nodes</code> is given.</p>
</td></tr>
<tr><td><code id="centr_clo_tmax_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices. This is ignored if the graph is
given.</p>
</td></tr>
<tr><td><code id="centr_clo_tmax_+3A_mode">mode</code></td>
<td>
<p>This is the same as the <code>mode</code> argument of
<code>closeness()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real scalar, the theoretical maximum (unnormalized) graph
closeness centrality score for graphs with given order and other
parameters.
</p>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw">centr_betw</a>()</code>,
<code><a href="#topic+centr_betw_tmax">centr_betw_tmax</a>()</code>,
<code><a href="#topic+centr_clo">centr_clo</a>()</code>,
<code><a href="#topic+centr_degree">centr_degree</a>()</code>,
<code><a href="#topic+centr_degree_tmax">centr_degree_tmax</a>()</code>,
<code><a href="#topic+centr_eigen">centr_eigen</a>()</code>,
<code><a href="#topic+centr_eigen_tmax">centr_eigen_tmax</a>()</code>,
<code><a href="#topic+centralize">centralize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_clo(g, normalized = FALSE)$centralization %&gt;%
  `/`(centr_clo_tmax(g))
centr_clo(g, normalized = TRUE)$centralization
</code></pre>

<hr>
<h2 id='centr_degree'>Centralize a graph according to the degrees of vertices</h2><span id='topic+centr_degree'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+centralize">centralize()</a></code> for a summary of graph centralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_degree(
  graph,
  mode = c("all", "out", "in", "total"),
  loops = TRUE,
  normalized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centr_degree_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="centr_degree_+3A_mode">mode</code></td>
<td>
<p>This is the same as the <code>mode</code> argument of
<code>degree()</code>.</p>
</td></tr>
<tr><td><code id="centr_degree_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether to consider loops edges when
calculating the degree.</p>
</td></tr>
<tr><td><code id="centr_degree_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the theoretical maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following components:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>The node-level centrality scores.</p>
</td></tr>
<tr><td><code>centralization</code></td>
<td>
<p>The graph level centrality index.</p>
</td></tr>
<tr><td><code>theoretical_max</code></td>
<td>
<p>The maximum theoretical graph level
centralization score for a graph with the given number of vertices,
using the same parameters. If the <code>normalized</code> argument was
<code>TRUE</code>, then the result was divided by this number.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw">centr_betw</a>()</code>,
<code><a href="#topic+centr_betw_tmax">centr_betw_tmax</a>()</code>,
<code><a href="#topic+centr_clo">centr_clo</a>()</code>,
<code><a href="#topic+centr_clo_tmax">centr_clo_tmax</a>()</code>,
<code><a href="#topic+centr_degree_tmax">centr_degree_tmax</a>()</code>,
<code><a href="#topic+centr_eigen">centr_eigen</a>()</code>,
<code><a href="#topic+centr_eigen_tmax">centr_eigen_tmax</a>()</code>,
<code><a href="#topic+centralize">centralize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_degree(g)$centralization
centr_clo(g, mode = "all")$centralization
centr_betw(g, directed = FALSE)$centralization
centr_eigen(g, directed = FALSE)$centralization
</code></pre>

<hr>
<h2 id='centr_degree_tmax'>Theoretical maximum for degree centralization</h2><span id='topic+centr_degree_tmax'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+centralize">centralize()</a></code> for a summary of graph centralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_degree_tmax(
  graph = NULL,
  nodes = 0,
  mode = c("all", "out", "in", "total"),
  loops
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centr_degree_tmax_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can also be <code>NULL</code>, if
<code>nodes</code>, <code>mode</code> and <code>loops</code> are all given.</p>
</td></tr>
<tr><td><code id="centr_degree_tmax_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices. This is ignored if the graph is given.</p>
</td></tr>
<tr><td><code id="centr_degree_tmax_+3A_mode">mode</code></td>
<td>
<p>This is the same as the <code>mode</code> argument of
<code>degree()</code>.</p>
</td></tr>
<tr><td><code id="centr_degree_tmax_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether to consider loops edges when
calculating the degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real scalar, the theoretical maximum (unnormalized) graph degree
centrality score for graphs with given order and other parameters.
</p>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw">centr_betw</a>()</code>,
<code><a href="#topic+centr_betw_tmax">centr_betw_tmax</a>()</code>,
<code><a href="#topic+centr_clo">centr_clo</a>()</code>,
<code><a href="#topic+centr_clo_tmax">centr_clo_tmax</a>()</code>,
<code><a href="#topic+centr_degree">centr_degree</a>()</code>,
<code><a href="#topic+centr_eigen">centr_eigen</a>()</code>,
<code><a href="#topic+centr_eigen_tmax">centr_eigen_tmax</a>()</code>,
<code><a href="#topic+centralize">centralize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_degree(g, normalized = FALSE)$centralization %&gt;%
  `/`(centr_degree_tmax(g, loops = FALSE))
centr_degree(g, normalized = TRUE)$centralization
</code></pre>

<hr>
<h2 id='centr_eigen'>Centralize a graph according to the eigenvector centrality of vertices</h2><span id='topic+centr_eigen'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+centralize">centralize()</a></code> for a summary of graph centralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_eigen(
  graph,
  directed = FALSE,
  scale = TRUE,
  options = arpack_defaults(),
  normalized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centr_eigen_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="centr_eigen_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether to use directed shortest paths for
calculating eigenvector centrality.</p>
</td></tr>
<tr><td><code id="centr_eigen_+3A_scale">scale</code></td>
<td>
<p>Whether to rescale the eigenvector centrality scores, such that
the maximum score is one.</p>
</td></tr>
<tr><td><code id="centr_eigen_+3A_options">options</code></td>
<td>
<p>This is passed to <code><a href="#topic+eigen_centrality">eigen_centrality()</a></code>, the options
for the ARPACK eigensolver.</p>
</td></tr>
<tr><td><code id="centr_eigen_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the theoretical maximum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with the following components:
</p>
<table>
<tr><td><code>vector</code></td>
<td>
<p>The node-level centrality scores.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The corresponding eigenvalue.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>ARPACK options, see the return value of
<code><a href="#topic+eigen_centrality">eigen_centrality()</a></code> for details.</p>
</td></tr>
<tr><td><code>centralization</code></td>
<td>
<p>The graph level centrality index.</p>
</td></tr>
<tr><td><code>theoretical_max</code></td>
<td>
<p>The same as above, the theoretical maximum
centralization score for a graph with the same number of vertices.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw">centr_betw</a>()</code>,
<code><a href="#topic+centr_betw_tmax">centr_betw_tmax</a>()</code>,
<code><a href="#topic+centr_clo">centr_clo</a>()</code>,
<code><a href="#topic+centr_clo_tmax">centr_clo_tmax</a>()</code>,
<code><a href="#topic+centr_degree">centr_degree</a>()</code>,
<code><a href="#topic+centr_degree_tmax">centr_degree_tmax</a>()</code>,
<code><a href="#topic+centr_eigen_tmax">centr_eigen_tmax</a>()</code>,
<code><a href="#topic+centralize">centralize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_degree(g)$centralization
centr_clo(g, mode = "all")$centralization
centr_betw(g, directed = FALSE)$centralization
centr_eigen(g, directed = FALSE)$centralization

# The most centralized graph according to eigenvector centrality
g0 &lt;- make_graph(c(2, 1), n = 10, dir = FALSE)
g1 &lt;- make_star(10, mode = "undirected")
centr_eigen(g0)$centralization
centr_eigen(g1)$centralization
</code></pre>

<hr>
<h2 id='centr_eigen_tmax'>Theoretical maximum for betweenness centralization</h2><span id='topic+centr_eigen_tmax'></span>

<h3>Description</h3>

<p>See <code><a href="#topic+centralize">centralize()</a></code> for a summary of graph centralization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centr_eigen_tmax(graph = NULL, nodes = 0, directed = FALSE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centr_eigen_tmax_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can also be <code>NULL</code>, if
<code>nodes</code> is given.</p>
</td></tr>
<tr><td><code id="centr_eigen_tmax_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices. This is ignored if the graph is
given.</p>
</td></tr>
<tr><td><code id="centr_eigen_tmax_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether to use directed shortest paths
for calculating betweenness.</p>
</td></tr>
<tr><td><code id="centr_eigen_tmax_+3A_scale">scale</code></td>
<td>
<p>Whether to rescale the eigenvector centrality scores,
such that the maximum score is one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Real scalar, the theoretical maximum (unnormalized) graph
betweenness centrality score for graphs with given order and other
parameters.
</p>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw">centr_betw</a>()</code>,
<code><a href="#topic+centr_betw_tmax">centr_betw_tmax</a>()</code>,
<code><a href="#topic+centr_clo">centr_clo</a>()</code>,
<code><a href="#topic+centr_clo_tmax">centr_clo_tmax</a>()</code>,
<code><a href="#topic+centr_degree">centr_degree</a>()</code>,
<code><a href="#topic+centr_degree_tmax">centr_degree_tmax</a>()</code>,
<code><a href="#topic+centr_eigen">centr_eigen</a>()</code>,
<code><a href="#topic+centralize">centralize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_eigen(g, normalized = FALSE)$centralization %&gt;%
  `/`(centr_eigen_tmax(g))
centr_eigen(g, normalized = TRUE)$centralization
</code></pre>

<hr>
<h2 id='centralization.betweenness'>Centralize a graph according to the betweenness of vertices</h2><span id='topic+centralization.betweenness'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralization.betweenness()</code> was renamed to <code>centr_betw()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralization.betweenness(graph, directed = TRUE, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralization.betweenness_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="centralization.betweenness_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether to use directed shortest paths for
calculating betweenness.</p>
</td></tr>
<tr><td><code id="centralization.betweenness_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the theoretical maximum.</p>
</td></tr>
</table>

<hr>
<h2 id='centralization.betweenness.tmax'>Theoretical maximum for betweenness centralization</h2><span id='topic+centralization.betweenness.tmax'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralization.betweenness.tmax()</code> was renamed to <code>centr_betw_tmax()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralization.betweenness.tmax(graph = NULL, nodes = 0, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralization.betweenness.tmax_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can also be <code>NULL</code>, if
<code>nodes</code> is given.</p>
</td></tr>
<tr><td><code id="centralization.betweenness.tmax_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices. This is ignored if the graph is
given.</p>
</td></tr>
<tr><td><code id="centralization.betweenness.tmax_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether to use directed shortest paths
for calculating betweenness.</p>
</td></tr>
</table>

<hr>
<h2 id='centralization.closeness'>Centralize a graph according to the closeness of vertices</h2><span id='topic+centralization.closeness'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralization.closeness()</code> was renamed to <code>centr_clo()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralization.closeness(
  graph,
  mode = c("out", "in", "all", "total"),
  normalized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralization.closeness_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="centralization.closeness_+3A_mode">mode</code></td>
<td>
<p>This is the same as the <code>mode</code> argument of
<code>closeness()</code>.</p>
</td></tr>
<tr><td><code id="centralization.closeness_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the theoretical maximum.</p>
</td></tr>
</table>

<hr>
<h2 id='centralization.closeness.tmax'>Theoretical maximum for closeness centralization</h2><span id='topic+centralization.closeness.tmax'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralization.closeness.tmax()</code> was renamed to <code>centr_clo_tmax()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralization.closeness.tmax(
  graph = NULL,
  nodes = 0,
  mode = c("out", "in", "all", "total")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralization.closeness.tmax_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can also be <code>NULL</code>, if
<code>nodes</code> is given.</p>
</td></tr>
<tr><td><code id="centralization.closeness.tmax_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices. This is ignored if the graph is
given.</p>
</td></tr>
<tr><td><code id="centralization.closeness.tmax_+3A_mode">mode</code></td>
<td>
<p>This is the same as the <code>mode</code> argument of
<code>closeness()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='centralization.degree'>Centralize a graph according to the degrees of vertices</h2><span id='topic+centralization.degree'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralization.degree()</code> was renamed to <code>centr_degree()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralization.degree(
  graph,
  mode = c("all", "out", "in", "total"),
  loops = TRUE,
  normalized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralization.degree_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="centralization.degree_+3A_mode">mode</code></td>
<td>
<p>This is the same as the <code>mode</code> argument of
<code>degree()</code>.</p>
</td></tr>
<tr><td><code id="centralization.degree_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether to consider loops edges when
calculating the degree.</p>
</td></tr>
<tr><td><code id="centralization.degree_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the theoretical maximum.</p>
</td></tr>
</table>

<hr>
<h2 id='centralization.degree.tmax'>Theoretical maximum for degree centralization</h2><span id='topic+centralization.degree.tmax'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralization.degree.tmax()</code> was renamed to <code>centr_degree_tmax()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralization.degree.tmax(
  graph = NULL,
  nodes = 0,
  mode = c("all", "out", "in", "total"),
  loops = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralization.degree.tmax_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can also be <code>NULL</code>, if
<code>nodes</code>, <code>mode</code> and <code>loops</code> are all given.</p>
</td></tr>
<tr><td><code id="centralization.degree.tmax_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices. This is ignored if the graph is given.</p>
</td></tr>
<tr><td><code id="centralization.degree.tmax_+3A_mode">mode</code></td>
<td>
<p>This is the same as the <code>mode</code> argument of
<code>degree()</code>.</p>
</td></tr>
<tr><td><code id="centralization.degree.tmax_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether to consider loops edges when
calculating the degree.</p>
</td></tr>
</table>

<hr>
<h2 id='centralization.evcent'>Centralize a graph according to the eigenvector centrality of vertices</h2><span id='topic+centralization.evcent'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralization.evcent()</code> was renamed to <code>centr_eigen()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralization.evcent(
  graph,
  directed = FALSE,
  scale = TRUE,
  options = arpack_defaults(),
  normalized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralization.evcent_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="centralization.evcent_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether to use directed shortest paths for
calculating eigenvector centrality.</p>
</td></tr>
<tr><td><code id="centralization.evcent_+3A_scale">scale</code></td>
<td>
<p>Whether to rescale the eigenvector centrality scores, such that
the maximum score is one.</p>
</td></tr>
<tr><td><code id="centralization.evcent_+3A_options">options</code></td>
<td>
<p>This is passed to <code><a href="#topic+eigen_centrality">eigen_centrality()</a></code>, the options
for the ARPACK eigensolver.</p>
</td></tr>
<tr><td><code id="centralization.evcent_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the theoretical maximum.</p>
</td></tr>
</table>

<hr>
<h2 id='centralization.evcent.tmax'>Theoretical maximum for betweenness centralization</h2><span id='topic+centralization.evcent.tmax'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralization.evcent.tmax()</code> was renamed to <code>centr_eigen_tmax()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralization.evcent.tmax(
  graph = NULL,
  nodes = 0,
  directed = FALSE,
  scale = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralization.evcent.tmax_+3A_graph">graph</code></td>
<td>
<p>The input graph. It can also be <code>NULL</code>, if
<code>nodes</code> is given.</p>
</td></tr>
<tr><td><code id="centralization.evcent.tmax_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices. This is ignored if the graph is
given.</p>
</td></tr>
<tr><td><code id="centralization.evcent.tmax_+3A_directed">directed</code></td>
<td>
<p>logical scalar, whether to use directed shortest paths
for calculating betweenness.</p>
</td></tr>
<tr><td><code id="centralization.evcent.tmax_+3A_scale">scale</code></td>
<td>
<p>Whether to rescale the eigenvector centrality scores,
such that the maximum score is one.</p>
</td></tr>
</table>

<hr>
<h2 id='centralize'>Centralization of a graph</h2><span id='topic+centralize'></span><span id='topic+centralization'></span>

<h3>Description</h3>

<p>Centralization is a method for creating a graph level centralization
measure from the centrality scores of the vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralize(scores, theoretical.max = 0, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralize_+3A_scores">scores</code></td>
<td>
<p>The vertex level centrality scores.</p>
</td></tr>
<tr><td><code id="centralize_+3A_theoretical.max">theoretical.max</code></td>
<td>
<p>Real scalar. The graph-level centralization measure of
the most centralized graph with the same number of vertices as the graph
under study. This is only used if the <code>normalized</code> argument is set
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="centralize_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the supplied theoretical maximum.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Centralization is a general method for calculating a graph-level
centrality score based on node-level centrality measure. The formula for
this is
</p>
<p style="text-align: center;"><code class="reqn">C(G)=\sum_v (\max_w c_w - c_v),</code>
</p>

<p>where <code class="reqn">c_v</code> is the centrality of vertex <code class="reqn">v</code>.
</p>
<p>The graph-level centralization measure can be normalized by dividing by the
maximum theoretical score for a graph with the same number of vertices,
using the same parameters, e.g. directedness, whether we consider loop
edges, etc.
</p>
<p>For degree, closeness and betweenness the most centralized structure is
some version of the star graph, in-star, out-star or undirected star.
</p>
<p>For eigenvector centrality the most centralized structure is the graph
with a single edge (and potentially many isolates).
</p>
<p><code>centralize()</code> implements general centralization formula to calculate
a graph-level score from vertex-level scores.
</p>


<h3>Value</h3>

<p>A real scalar, the centralization of the graph from which
<code>scores</code> were derived.
</p>


<h3>References</h3>

<p>Freeman, L.C.  (1979).  Centrality in Social Networks I:
Conceptual Clarification. <em>Social Networks</em> 1, 215&ndash;239.
</p>
<p>Wasserman, S., and Faust, K.  (1994).  <em>Social Network Analysis:
Methods and Applications.</em> Cambridge University Press.
</p>


<h3>See Also</h3>

<p>Other centralization related: 
<code><a href="#topic+centr_betw">centr_betw</a>()</code>,
<code><a href="#topic+centr_betw_tmax">centr_betw_tmax</a>()</code>,
<code><a href="#topic+centr_clo">centr_clo</a>()</code>,
<code><a href="#topic+centr_clo_tmax">centr_clo_tmax</a>()</code>,
<code><a href="#topic+centr_degree">centr_degree</a>()</code>,
<code><a href="#topic+centr_degree_tmax">centr_degree_tmax</a>()</code>,
<code><a href="#topic+centr_eigen">centr_eigen</a>()</code>,
<code><a href="#topic+centr_eigen_tmax">centr_eigen_tmax</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A BA graph is quite centralized
g &lt;- sample_pa(1000, m = 4)
centr_degree(g)$centralization
centr_clo(g, mode = "all")$centralization
centr_eigen(g, directed = FALSE)$centralization

# Calculate centralization from pre-computed scores
deg &lt;- degree(g)
tmax &lt;- centr_degree_tmax(g, loops = FALSE)
centralize(deg, tmax)

# The most centralized graph according to eigenvector centrality
g0 &lt;- make_graph(c(2, 1), n = 10, dir = FALSE)
g1 &lt;- make_star(10, mode = "undirected")
centr_eigen(g0)$centralization
centr_eigen(g1)$centralization
</code></pre>

<hr>
<h2 id='centralize.scores'>Centralization of a graph</h2><span id='topic+centralize.scores'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>centralize.scores()</code> was renamed to <code>centralize()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centralize.scores(scores, theoretical.max = 0, normalized = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centralize.scores_+3A_scores">scores</code></td>
<td>
<p>The vertex level centrality scores.</p>
</td></tr>
<tr><td><code id="centralize.scores_+3A_theoretical.max">theoretical.max</code></td>
<td>
<p>Real scalar. The graph-level centralization measure of
the most centralized graph with the same number of vertices as the graph
under study. This is only used if the <code>normalized</code> argument is set
to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="centralize.scores_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar. Whether to normalize the graph level
centrality score by dividing by the supplied theoretical maximum.</p>
</td></tr>
</table>

<hr>
<h2 id='cited.type.game'>Random citation graphs</h2><span id='topic+cited.type.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>cited.type.game()</code> was renamed to <code>sample_cit_types()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cited.type.game(
  n,
  edges = 1,
  types = rep(0, n),
  pref = rep(1, length(types)),
  directed = TRUE,
  attr = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cited.type.game_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="cited.type.game_+3A_edges">edges</code></td>
<td>
<p>Number of edges per step.</p>
</td></tr>
<tr><td><code id="cited.type.game_+3A_types">types</code></td>
<td>
<p>Vector of length &lsquo;<code>n</code>&rsquo;, the types of the vertices.
Types are numbered from zero.</p>
</td></tr>
<tr><td><code id="cited.type.game_+3A_pref">pref</code></td>
<td>
<p>Vector (<code>sample_last_cit()</code> and <code>sample_cit_types()</code> or
matrix (<code>sample_cit_cit_types()</code>) giving the (unnormalized) citation
probabilities for the different vertex types.</p>
</td></tr>
<tr><td><code id="cited.type.game_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to generate directed networks.</p>
</td></tr>
<tr><td><code id="cited.type.game_+3A_attr">attr</code></td>
<td>
<p>Logical scalar, whether to add the vertex types to the generated
graph as a vertex attribute called &lsquo;<code>type</code>&rsquo;.</p>
</td></tr>
</table>

<hr>
<h2 id='citing.cited.type.game'>Random citation graphs</h2><span id='topic+citing.cited.type.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>citing.cited.type.game()</code> was renamed to <code>sample_cit_cit_types()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>citing.cited.type.game(
  n,
  edges = 1,
  types = rep(0, n),
  pref = matrix(1, nrow = length(types), ncol = length(types)),
  directed = TRUE,
  attr = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="citing.cited.type.game_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="citing.cited.type.game_+3A_edges">edges</code></td>
<td>
<p>Number of edges per step.</p>
</td></tr>
<tr><td><code id="citing.cited.type.game_+3A_types">types</code></td>
<td>
<p>Vector of length &lsquo;<code>n</code>&rsquo;, the types of the vertices.
Types are numbered from zero.</p>
</td></tr>
<tr><td><code id="citing.cited.type.game_+3A_pref">pref</code></td>
<td>
<p>Vector (<code>sample_last_cit()</code> and <code>sample_cit_types()</code> or
matrix (<code>sample_cit_cit_types()</code>) giving the (unnormalized) citation
probabilities for the different vertex types.</p>
</td></tr>
<tr><td><code id="citing.cited.type.game_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to generate directed networks.</p>
</td></tr>
<tr><td><code id="citing.cited.type.game_+3A_attr">attr</code></td>
<td>
<p>Logical scalar, whether to add the vertex types to the generated
graph as a vertex attribute called &lsquo;<code>type</code>&rsquo;.</p>
</td></tr>
</table>

<hr>
<h2 id='clique.number'>Functions to find cliques, i.e. complete subgraphs in a graph</h2><span id='topic+clique.number'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>clique.number()</code> was renamed to <code>clique_num()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clique.number(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clique.number_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs will be considered as
undirected ones, multiple edges and loops are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='cliques'>Functions to find cliques, i.e. complete subgraphs in a graph</h2><span id='topic+cliques'></span><span id='topic+largest_cliques'></span><span id='topic+max_cliques'></span><span id='topic+count_max_cliques'></span><span id='topic+clique_num'></span><span id='topic+largest_weighted_cliques'></span><span id='topic+weighted_clique_num'></span><span id='topic+clique_size_counts'></span>

<h3>Description</h3>

<p>These functions find all, the largest or all the maximal cliques in an
undirected graph. The size of the largest clique can also be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cliques(graph, min = 0, max = 0)

largest_cliques(graph)

max_cliques(graph, min = NULL, max = NULL, subset = NULL, file = NULL)

count_max_cliques(graph, min = NULL, max = NULL, subset = NULL)

clique_num(graph)

largest_weighted_cliques(graph, vertex.weights = NULL)

weighted_clique_num(graph, vertex.weights = NULL)

clique_size_counts(graph, min = 0, max = 0, maximal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cliques_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs will be considered as
undirected ones, multiple edges and loops are ignored.</p>
</td></tr>
<tr><td><code id="cliques_+3A_min">min</code></td>
<td>
<p>Numeric constant, lower limit on the size of the cliques to find.
<code>NULL</code> means no limit, i.e. it is the same as 0.</p>
</td></tr>
<tr><td><code id="cliques_+3A_max">max</code></td>
<td>
<p>Numeric constant, upper limit on the size of the cliques to find.
<code>NULL</code> means no limit.</p>
</td></tr>
<tr><td><code id="cliques_+3A_subset">subset</code></td>
<td>
<p>If not <code>NULL</code>, then it must be a vector of vertex ids,
numeric or symbolic if the graph is named. The algorithm is run from these
vertices only, so only a subset of all maximal cliques is returned. See the
Eppstein paper for details. This argument makes it possible to easily
parallelize the finding of maximal cliques.</p>
</td></tr>
<tr><td><code id="cliques_+3A_file">file</code></td>
<td>
<p>If not <code>NULL</code>, then it must be a file name, i.e. a
character scalar. The output of the algorithm is written to this file. (If
it exists, then it will be overwritten.) Each clique will be a separate line
in the file, given with the numeric ids of its vertices, separated by
whitespace.</p>
</td></tr>
<tr><td><code id="cliques_+3A_vertex.weights">vertex.weights</code></td>
<td>
<p>Vertex weight vector. If the graph has a <code>weight</code>
vertex attribute, then this is used by default. If the graph does not have a
<code>weight</code> vertex attribute and this argument is <code>NULL</code>, then every
vertex is assumed to have a weight of 1. Note that the current implementation
of the weighted clique finder supports positive integer weights only.</p>
</td></tr>
<tr><td><code id="cliques_+3A_maximal">maximal</code></td>
<td>
<p>Specifies whether to look for all weighted cliques (<code>FALSE</code>)
or only the maximal ones (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cliques()</code> find all complete subgraphs in the input graph, obeying the
size limitations given in the <code>min</code> and <code>max</code> arguments.
</p>
<p><code>largest_cliques()</code> finds all largest cliques in the input graph. A
clique is largest if there is no other clique including more vertices.
</p>
<p><code>max_cliques()</code> finds all maximal cliques in the input graph.  A
clique is maximal if it cannot be extended to a larger clique. The largest
cliques are always maximal, but a maximal clique is not necessarily the
largest.
</p>
<p><code>count_max_cliques()</code> counts the maximal cliques.
</p>
<p><code>clique_num()</code> calculates the size of the largest clique(s).
</p>
<p><code>clique_size_counts()</code> returns a numeric vector representing a histogram
of clique sizes, between the given minimum and maximum clique size.
</p>


<h3>Value</h3>

<p><code>cliques()</code>, <code>largest_cliques()</code> and <code>clique_num()</code>
return a list containing numeric vectors of vertex ids. Each list element is
a clique, i.e. a vertex sequence of class <code><a href="#topic+V">igraph.vs()</a></code>.
</p>
<p><code>max_cliques()</code> returns <code>NULL</code>, invisibly, if its <code>file</code>
argument is not <code>NULL</code>. The output is written to the specified file in
this case.
</p>
<p><code>clique_num()</code> and <code>count_max_cliques()</code> return an integer
scalar.
</p>
<p><code>clique_size_counts()</code> returns a numeric vector with the clique sizes such that
the i-th item belongs to cliques of size i. Trailing zeros are currently
truncated, but this might change in future versions.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>For maximal cliques the following algorithm is implemented:
David Eppstein, Maarten Loffler, Darren Strash: Listing All Maximal Cliques
in Sparse Graphs in Near-optimal Time.  <a href="https://arxiv.org/abs/1006.5440">https://arxiv.org/abs/1006.5440</a>
</p>


<h3>See Also</h3>

<p>Other cliques: 
<code><a href="#topic+ivs">ivs</a>()</code>,
<code><a href="#topic+weighted_cliques">weighted_cliques</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# this usually contains cliques of size six
g &lt;- sample_gnp(100, 0.3)
clique_num(g)
cliques(g, min = 6)
largest_cliques(g)

# To have a bit less maximal cliques, about 100-200 usually
g &lt;- sample_gnp(100, 0.03)
max_cliques(g)
</code></pre>

<hr>
<h2 id='closeness'>Closeness centrality of vertices</h2><span id='topic+closeness'></span><span id='topic+closeness.estimate'></span>

<h3>Description</h3>

<p>Closeness centrality measures how many steps is required to access every other
vertex from a given vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closeness(
  graph,
  vids = V(graph),
  mode = c("out", "in", "all", "total"),
  weights = NULL,
  normalized = FALSE,
  cutoff = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="closeness_+3A_vids">vids</code></td>
<td>
<p>The vertices for which closeness will be calculated.</p>
</td></tr>
<tr><td><code id="closeness_+3A_mode">mode</code></td>
<td>
<p>Character string, defined the types of the paths used for
measuring the distance in directed graphs. &ldquo;in&rdquo; measures the paths
<em>to</em> a vertex, &ldquo;out&rdquo; measures paths <em>from</em> a vertex,
<em>all</em> uses undirected paths. This argument is ignored for undirected
graphs.</p>
</td></tr>
<tr><td><code id="closeness_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
closeness. If the graph has a <code>weight</code> edge attribute, then this is
used by default. Weights are used for calculating weighted shortest
paths, so they are interpreted as distances.</p>
</td></tr>
<tr><td><code id="closeness_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to calculate the normalized
closeness, i.e. the inverse average distance to all reachable vertices.
The non-normalized closeness is the inverse of the sum of distances to
all reachable vertices.</p>
</td></tr>
<tr><td><code id="closeness_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating the
closeness. If zero or negative then there is no such limit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The closeness centrality of a vertex is defined as the inverse of the
sum of distances to all the other vertices in the graph:
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\sum_{i\ne v} d_{vi}}</code>
</p>

<p>If there is no (directed) path between vertex <code>v</code> and <code>i</code>, then
<code>i</code> is omitted from the calculation. If no other vertices are reachable
from <code>v</code>, then its closeness is returned as NaN.
</p>
<p><code>cutoff</code> or smaller. This can be run for larger graphs, as the running
time is not quadratic (if <code>cutoff</code> is small). If <code>cutoff</code> is
negative (which is the default), then the function calculates the exact
closeness scores. Since igraph 1.6.0, a <code>cutoff</code> value of zero is treated
literally, i.e. path with a length greater than zero are ignored.
</p>
<p>Closeness centrality is meaningful only for connected graphs. In disconnected
graphs, consider using the harmonic centrality with
<code><a href="#topic+harmonic_centrality">harmonic_centrality()</a></code>
</p>


<h3>Value</h3>

<p>Numeric vector with the closeness values of all the vertices in
<code>v</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Freeman, L.C. (1979). Centrality in Social Networks I:
Conceptual Clarification. <em>Social Networks</em>, 1, 215-239.
</p>


<h3>See Also</h3>

<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
g2 &lt;- make_star(10)
closeness(g)
closeness(g2, mode = "in")
closeness(g2, mode = "out")
closeness(g2, mode = "all")

</code></pre>

<hr>
<h2 id='cluster_edge_betweenness'>Community structure detection based on edge betweenness</h2><span id='topic+cluster_edge_betweenness'></span>

<h3>Description</h3>

<p>Many networks consist of modules which are densely connected themselves but
sparsely connected to other modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_edge_betweenness(
  graph,
  weights = NULL,
  directed = TRUE,
  edge.betweenness = TRUE,
  merges = TRUE,
  bridges = TRUE,
  modularity = TRUE,
  membership = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_edge_betweenness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="cluster_edge_betweenness_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. Edge weights
are used to calculate weighted edge betweenness. This means that edges are
interpreted as distances, not as connection strengths.</p>
</td></tr>
<tr><td><code id="cluster_edge_betweenness_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to calculate directed edge
betweenness for directed graphs. It is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="cluster_edge_betweenness_+3A_edge.betweenness">edge.betweenness</code></td>
<td>
<p>Logical constant, whether to return the edge
betweenness of the edges at the time of their removal.</p>
</td></tr>
<tr><td><code id="cluster_edge_betweenness_+3A_merges">merges</code></td>
<td>
<p>Logical constant, whether to return the merge matrix
representing the hierarchical community structure of the network.  This
argument is called <code>merges</code>, even if the community structure algorithm
itself is divisive and not agglomerative: it builds the tree from top to
bottom. There is one line for each merge (i.e. split) in matrix, the first
line is the first merge (last split). The communities are identified by
integer number starting from one. Community ids smaller than or equal to
<code class="reqn">N</code>, the number of vertices in the graph, belong to singleton
communities, i.e. individual vertices. Before the first merge we have <code class="reqn">N</code>
communities numbered from one to <code class="reqn">N</code>. The first merge, the first line of
the matrix creates community <code class="reqn">N+1</code>, the second merge creates community
<code class="reqn">N+2</code>, etc.</p>
</td></tr>
<tr><td><code id="cluster_edge_betweenness_+3A_bridges">bridges</code></td>
<td>
<p>Logical constant, whether to return a list the edge removals
which actually splitted a component of the graph.</p>
</td></tr>
<tr><td><code id="cluster_edge_betweenness_+3A_modularity">modularity</code></td>
<td>
<p>Logical constant, whether to calculate the maximum
modularity score, considering all possibly community structures along the
edge-betweenness based edge removals.</p>
</td></tr>
<tr><td><code id="cluster_edge_betweenness_+3A_membership">membership</code></td>
<td>
<p>Logical constant, whether to calculate the membership
vector corresponding to the highest possible modularity score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The edge betweenness score of an edge measures the number of shortest paths
through it, see <code><a href="#topic+edge_betweenness">edge_betweenness()</a></code> for details. The idea of the
edge betweenness based community structure detection is that it is likely
that edges connecting separate modules have high edge betweenness as all the
shortest paths from one module to another must traverse through them. So if
we gradually remove the edge with the highest edge betweenness score we will
get a hierarchical map, a rooted tree, called a dendrogram of the graph. The
leafs of the tree are the individual vertices and the root of the tree
represents the whole graph.
</p>
<p><code>cluster_edge_betweenness()</code> performs this algorithm by calculating the
edge betweenness of the graph, removing the edge with the highest edge
betweenness score, then recalculating edge betweenness of the edges and
again removing the one with the highest score, etc.
</p>
<p><code>edge.betweeness.community</code> returns various information collected
through the run of the algorithm. See the return value down here.
</p>


<h3>Value</h3>

<p><code>cluster_edge_betweenness()</code> returns a
<code><a href="#topic+communities">communities()</a></code> object, please see the <code><a href="#topic+communities">communities()</a></code>
manual page for details.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>M Newman and M Girvan: Finding and evaluating community
structure in networks, <em>Physical Review E</em> 69, 026113 (2004)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edge_betweenness">edge_betweenness()</a></code> for the definition and calculation
of the edge betweenness, <code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen()</a></code> for other community detection
methods.
</p>
<p>See <code><a href="#topic+communities">communities()</a></code> for extracting the results of the community
detection.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_pa(100, m = 2, directed = FALSE)
eb &lt;- cluster_edge_betweenness(g)

g &lt;- make_full_graph(10) %du% make_full_graph(10)
g &lt;- add_edges(g, c(1, 11))
eb &lt;- cluster_edge_betweenness(g)
eb

</code></pre>

<hr>
<h2 id='cluster_fast_greedy'>Community structure via greedy optimization of modularity</h2><span id='topic+cluster_fast_greedy'></span>

<h3>Description</h3>

<p>This function tries to find dense subgraph, also called communities in
graphs via directly optimizing a modularity score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_fast_greedy(
  graph,
  merges = TRUE,
  modularity = TRUE,
  membership = TRUE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_fast_greedy_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="cluster_fast_greedy_+3A_merges">merges</code></td>
<td>
<p>Logical scalar, whether to return the merge matrix.</p>
</td></tr>
<tr><td><code id="cluster_fast_greedy_+3A_modularity">modularity</code></td>
<td>
<p>Logical scalar, whether to return a vector containing the
modularity after each merge.</p>
</td></tr>
<tr><td><code id="cluster_fast_greedy_+3A_membership">membership</code></td>
<td>
<p>Logical scalar, whether to calculate the membership vector
corresponding to the maximum modularity score, considering all possible
community structures along the merges.</p>
</td></tr>
<tr><td><code id="cluster_fast_greedy_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the fast greedy modularity optimization algorithm
for finding community structure, see A Clauset, MEJ Newman, C Moore: Finding
community structure in very large networks,
http://www.arxiv.org/abs/cond-mat/0408187 for the details.
</p>


<h3>Value</h3>

<p><code>cluster_fast_greedy()</code> returns a <code><a href="#topic+communities">communities()</a></code>
object, please see the <code><a href="#topic+communities">communities()</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the R interface.
</p>


<h3>References</h3>

<p>A Clauset, MEJ Newman, C Moore: Finding community structure in
very large networks, http://www.arxiv.org/abs/cond-mat/0408187
</p>


<h3>See Also</h3>

<p><code><a href="#topic+communities">communities()</a></code> for extracting the results.
</p>
<p>See also <code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass()</a></code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen()</a></code> and
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness()</a></code>, <code><a href="#topic+cluster_louvain">cluster_louvain()</a></code>
<code><a href="#topic+cluster_leiden">cluster_leiden()</a></code> for other methods.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1, 6, 1, 11, 6, 11))
fc &lt;- cluster_fast_greedy(g)
membership(fc)
sizes(fc)

</code></pre>

<hr>
<h2 id='cluster_fluid_communities'>Community detection algorithm based on interacting fluids</h2><span id='topic+cluster_fluid_communities'></span>

<h3>Description</h3>

<p>The algorithm detects communities based on the simple idea of
several fluids interacting in a non-homogeneous environment
(the graph topology), expanding and contracting based on their
interaction and density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_fluid_communities(graph, no.of.communities)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_fluid_communities_+3A_graph">graph</code></td>
<td>
<p>The input graph. The graph must be simple and connected.
Empty graphs are not supported as well as single vertex graphs.
Edge directions are ignored. Weights are not considered.</p>
</td></tr>
<tr><td><code id="cluster_fluid_communities_+3A_no.of.communities">no.of.communities</code></td>
<td>
<p>The number of communities to be found. Must be
greater than 0 and fewer than number of vertices in the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cluster_fluid_communities()</code> returns a <code><a href="#topic+communities">communities()</a></code>
object, please see the <code><a href="#topic+communities">communities()</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Ferran Parés
</p>


<h3>References</h3>

<p>Parés F, Gasulla DG, et. al. (2018) Fluid Communities: A Competitive,
Scalable and Diverse Community Detection Algorithm. In: Complex Networks
&amp; Their Applications VI: Proceedings of Complex Networks 2017 (The Sixth
International Conference on Complex Networks and Their Applications),
Springer, vol 689, p 229, doi: 10.1007/978-3-319-72150-7_19
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+communities">communities()</a></code> for extracting the membership,
modularity scores, etc. from the results.
</p>
<p>Other community detection algorithms: <code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass()</a></code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen()</a></code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness()</a></code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop()</a></code>
<code><a href="#topic+cluster_louvain">cluster_louvain()</a></code>,
<code><a href="#topic+cluster_leiden">cluster_leiden()</a></code>
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Zachary")
comms &lt;- cluster_fluid_communities(g, 2)
</code></pre>

<hr>
<h2 id='cluster_infomap'>Infomap community finding</h2><span id='topic+cluster_infomap'></span>

<h3>Description</h3>

<p>Find community structure that minimizes the expected description length of a
random walker trajectory. If the graph is directed, edge directions will
be taken into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_infomap(
  graph,
  e.weights = NULL,
  v.weights = NULL,
  nb.trials = 10,
  modularity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_infomap_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions will be taken into account.</p>
</td></tr>
<tr><td><code id="cluster_infomap_+3A_e.weights">e.weights</code></td>
<td>
<p>If not <code>NULL</code>, then a numeric vector of edge weights.
The length must match the number of edges in the graph.  By default the
&lsquo;<code>weight</code>&rsquo; edge attribute is used as weights. If it is not
present, then all edges are considered to have the same weight.
Larger edge weights correspond to stronger connections.</p>
</td></tr>
<tr><td><code id="cluster_infomap_+3A_v.weights">v.weights</code></td>
<td>
<p>If not <code>NULL</code>, then a numeric vector of vertex
weights. The length must match the number of vertices in the graph.  By
default the &lsquo;<code>weight</code>&rsquo; vertex attribute is used as weights. If
it is not present, then all vertices are considered to have the same weight.
A larger vertex weight means a larger probability that the random surfer
jumps to that vertex.</p>
</td></tr>
<tr><td><code id="cluster_infomap_+3A_nb.trials">nb.trials</code></td>
<td>
<p>The number of attempts to partition the network (can be any
integer value equal or larger than 1).</p>
</td></tr>
<tr><td><code id="cluster_infomap_+3A_modularity">modularity</code></td>
<td>
<p>Logical scalar, whether to calculate the modularity score
of the detected community structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see the details of this method in the references given below.
</p>


<h3>Value</h3>

<p><code>cluster_infomap()</code> returns a <code><a href="#topic+communities">communities()</a></code> object,
please see the <code><a href="#topic+communities">communities()</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Martin Rosvall wrote the original C++ code. This was ported to
be more igraph-like by Emmanuel Navarro.  The R interface and
some cosmetics was done by Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>.
</p>


<h3>References</h3>

<p>The original paper: M. Rosvall and C. T. Bergstrom, Maps of
information flow reveal community structure in complex networks, <em>PNAS</em>
105, 1118 (2008) <a href="https://doi.org/10.1073/pnas.0706851105">doi:10.1073/pnas.0706851105</a>, <a href="https://arxiv.org/abs/0707.0609">https://arxiv.org/abs/0707.0609</a>
</p>
<p>A more detailed paper: M. Rosvall, D. Axelsson, and C. T. Bergstrom, The map
equation, <em>Eur. Phys. J. Special Topics</em> 178, 13 (2009).
<a href="https://doi.org/10.1140/epjst/e2010-01179-1">doi:10.1140/epjst/e2010-01179-1</a>, <a href="https://arxiv.org/abs/0906.1405">https://arxiv.org/abs/0906.1405</a>.
</p>


<h3>See Also</h3>

<p>Other community finding methods and <code><a href="#topic+communities">communities()</a></code>.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Zachary's karate club
g &lt;- make_graph("Zachary")

imc &lt;- cluster_infomap(g)
membership(imc)
communities(imc)

</code></pre>

<hr>
<h2 id='cluster_label_prop'>Finding communities based on propagating labels</h2><span id='topic+cluster_label_prop'></span>

<h3>Description</h3>

<p>This is a fast, nearly linear time algorithm for detecting community
structure in networks. In works by labeling the vertices with unique labels
and then updating the labels by majority voting in the neighborhood of the
vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_label_prop(
  graph,
  weights = NULL,
  ...,
  mode = c("out", "in", "all"),
  initial = NULL,
  fixed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_label_prop_+3A_graph">graph</code></td>
<td>
<p>The input graph. Note that the algorithm wsa originally
defined for undirected graphs. You are advised to set &lsquo;mode&rsquo; to
<code>all</code> if you pass a directed graph here to treat it as
undirected.</p>
</td></tr>
<tr><td><code id="cluster_label_prop_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="cluster_label_prop_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="cluster_label_prop_+3A_mode">mode</code></td>
<td>
<p>Logical, whether to consider edge directions for the label propagation,
and if so, in which direction the labels should propagate. Ignored for undirected graphs.
&quot;all&quot; means to ignore edge directions (even in directed graphs).
&quot;out&quot; means to propagate labels along the natural direction of the edges.
&quot;in&quot; means to propagate labels backwards (i.e. from head to tail).</p>
</td></tr>
<tr><td><code id="cluster_label_prop_+3A_initial">initial</code></td>
<td>
<p>The initial state. If <code>NULL</code>, every vertex will have a
different label at the beginning. Otherwise it must be a vector with an
entry for each vertex. Non-negative values denote different labels, negative
entries denote vertices without labels.</p>
</td></tr>
<tr><td><code id="cluster_label_prop_+3A_fixed">fixed</code></td>
<td>
<p>Logical vector denoting which labels are fixed. Of course this
makes sense only if you provided an initial state, otherwise this element
will be ignored. Also note that vertices without labels cannot be fixed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the community detection method described in:
Raghavan, U.N. and Albert, R. and Kumara, S.: Near linear time algorithm to
detect community structures in large-scale networks. Phys Rev E 76, 036106.
(2007). This version extends the original method by the ability to take edge
weights into consideration and also by allowing some labels to be fixed.
</p>
<p>From the abstract of the paper: &ldquo;In our algorithm every node is
initialized with a unique label and at every step each node adopts the label
that most of its neighbors currently have. In this iterative process densely
connected groups of nodes form a consensus on a unique label to form
communities.&rdquo;
</p>


<h3>Value</h3>

<p><code>cluster_label_prop()</code> returns a
<code><a href="#topic+communities">communities()</a></code> object, please see the <code><a href="#topic+communities">communities()</a></code>
manual page for details.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> for the C implementation,
Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for this manual page.
</p>


<h3>References</h3>

<p>Raghavan, U.N. and Albert, R. and Kumara, S.: Near linear time
algorithm to detect community structures in large-scale networks. <em>Phys
Rev E</em> 76, 036106. (2007)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+communities">communities()</a></code> for extracting the actual results.
</p>
<p><code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code>, <code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass()</a></code>, <code><a href="#topic+cluster_louvain">cluster_louvain()</a></code> and
<code><a href="#topic+cluster_leiden">cluster_leiden()</a></code> for other community detection methods.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(10, 5 / 10) %du% sample_gnp(9, 5 / 9)
g &lt;- add_edges(g, c(1, 12))
cluster_label_prop(g)

</code></pre>

<hr>
<h2 id='cluster_leading_eigen'>Community structure detecting based on the leading eigenvector of the
community matrix</h2><span id='topic+cluster_leading_eigen'></span>

<h3>Description</h3>

<p>This function tries to find densely connected subgraphs in a graph by
calculating the leading non-negative eigenvector of the modularity matrix of
the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_leading_eigen(
  graph,
  steps = -1,
  weights = NULL,
  start = NULL,
  options = arpack_defaults(),
  callback = NULL,
  extra = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_leading_eigen_+3A_graph">graph</code></td>
<td>
<p>The input graph. Should be undirected as the method needs a
symmetric matrix.</p>
</td></tr>
<tr><td><code id="cluster_leading_eigen_+3A_steps">steps</code></td>
<td>
<p>The number of steps to take, this is actually the number of
tries to make a step. It is not a particularly useful parameter.</p>
</td></tr>
<tr><td><code id="cluster_leading_eigen_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="cluster_leading_eigen_+3A_start">start</code></td>
<td>
<p><code>NULL</code>, or a numeric membership vector, giving the start
configuration of the algorithm.</p>
</td></tr>
<tr><td><code id="cluster_leading_eigen_+3A_options">options</code></td>
<td>
<p>A named list to override some ARPACK options.</p>
</td></tr>
<tr><td><code id="cluster_leading_eigen_+3A_callback">callback</code></td>
<td>
<p>If not <code>NULL</code>, then it must be callback function. This
is called after each iteration, after calculating the leading eigenvector of
the modularity matrix. See details below.</p>
</td></tr>
<tr><td><code id="cluster_leading_eigen_+3A_extra">extra</code></td>
<td>
<p>Additional argument to supply to the callback function.</p>
</td></tr>
<tr><td><code id="cluster_leading_eigen_+3A_env">env</code></td>
<td>
<p>The environment in which the callback function is evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function documented in these section implements the &lsquo;leading
eigenvector&rsquo; method developed by Mark Newman, see the reference below.
</p>
<p>The heart of the method is the definition of the modularity matrix,
<code>B</code>, which is <code>B=A-P</code>, <code>A</code> being the adjacency matrix of the
(undirected) network, and <code>P</code> contains the probability that certain
edges are present according to the &lsquo;configuration model&rsquo;. In other
words, a <code>P[i,j]</code> element of <code>P</code> is the probability that there is
an edge between vertices <code>i</code> and <code>j</code> in a random network in which
the degrees of all vertices are the same as in the input graph.
</p>
<p>The leading eigenvector method works by calculating the eigenvector of the
modularity matrix for the largest positive eigenvalue and then separating
vertices into two community based on the sign of the corresponding element
in the eigenvector. If all elements in the eigenvector are of the same sign
that means that the network has no underlying comuunity structure.  Check
Newman's paper to understand why this is a good method for detecting
community structure.
</p>


<h3>Value</h3>

<p><code>cluster_leading_eigen()</code> returns a named list with the
following members: </p>
<table>
<tr><td><code>membership</code></td>
<td>
<p>The membership vector at the end of the
algorithm, when no more splits are possible.</p>
</td></tr> <tr><td><code>merges</code></td>
<td>
<p>The merges
matrix starting from the state described by the <code>membership</code> member.
This is a two-column matrix and each line describes a merge of two
communities, the first line is the first merge and it creates community
&lsquo;<code>N</code>&rsquo;, <code>N</code> is the number of initial communities in the
graph, the second line creates community <code>N+1</code>, etc.  </p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>Information about the underlying ARPACK computation, see
<code><a href="#topic+arpack">arpack()</a></code> for details.  </p>
</td></tr>
</table>


<h3>Callback functions</h3>

<p>The <code>callback</code> argument can be used to
supply a function that is called after each eigenvector calculation. The
following arguments are supplied to this function: </p>

<dl>
<dt>membership</dt><dd><p>The actual membership vector, with zero-based indexing.</p>
</dd>
<dt>community</dt><dd><p>The community that the algorithm just tried to split,
community numbering starts with zero here.</p>
</dd>
<dt>value</dt><dd><p>The eigenvalue belonging to the leading eigenvector the
algorithm just found.</p>
</dd>
<dt>vector</dt><dd><p>The leading eigenvector the algorithm just found.</p>
</dd>
<dt>multiplier</dt><dd><p>An R function that can be used to multiple the actual
modularity matrix with an arbitrary vector. Supply the vector as an
argument to perform this multiplication. This function can be used
with ARPACK.</p>
</dd>
<dt>extra</dt><dd><p>The <code>extra</code> argument that was passed to
<code>cluster_leading_eigen()</code>. </p>
</dd>
</dl>
<p>The callback function should return a scalar number. If this number
is non-zero, then the clustering is terminated.

</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>MEJ Newman: Finding community structure using the eigenvectors
of matrices, Physical Review E 74 036104, 2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modularity">modularity()</a></code>, <code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness()</a></code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code>, <code><a href="stats.html#topic+as.dendrogram">as.dendrogram()</a></code>
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1, 6, 1, 11, 6, 11))
lec &lt;- cluster_leading_eigen(g)
lec

cluster_leading_eigen(g, start = membership(lec))

</code></pre>

<hr>
<h2 id='cluster_leiden'>Finding community structure of a graph using the Leiden algorithm of Traag,
van Eck &amp; Waltman.</h2><span id='topic+cluster_leiden'></span>

<h3>Description</h3>

<p>The Leiden algorithm is similar to the Louvain algorithm,
<code><a href="#topic+cluster_louvain">cluster_louvain()</a></code>, but it is faster and yields higher quality
solutions. It can optimize both modularity and the Constant Potts Model,
which does not suffer from the resolution-limit (see preprint
http://arxiv.org/abs/1104.3083).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_leiden(
  graph,
  objective_function = c("CPM", "modularity"),
  weights = NULL,
  resolution_parameter = 1,
  beta = 0.01,
  initial_membership = NULL,
  n_iterations = 2,
  vertex_weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_leiden_+3A_graph">graph</code></td>
<td>
<p>The input graph, only undirected graphs are supported.</p>
</td></tr>
<tr><td><code id="cluster_leiden_+3A_objective_function">objective_function</code></td>
<td>
<p>Whether to use the Constant Potts Model (CPM) or
modularity. Must be either <code>"CPM"</code> or <code>"modularity"</code>.</p>
</td></tr>
<tr><td><code id="cluster_leiden_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="cluster_leiden_+3A_resolution_parameter">resolution_parameter</code></td>
<td>
<p>The resolution parameter to use. Higher
resolutions lead to more smaller communities, while lower resolutions lead
to fewer larger communities.</p>
</td></tr>
<tr><td><code id="cluster_leiden_+3A_beta">beta</code></td>
<td>
<p>Parameter affecting the randomness in the Leiden algorithm.
This affects only the refinement step of the algorithm.</p>
</td></tr>
<tr><td><code id="cluster_leiden_+3A_initial_membership">initial_membership</code></td>
<td>
<p>If provided, the Leiden algorithm
will try to improve this provided membership. If no argument is
provided, the aglorithm simply starts from the singleton partition.</p>
</td></tr>
<tr><td><code id="cluster_leiden_+3A_n_iterations">n_iterations</code></td>
<td>
<p>the number of iterations to iterate the Leiden
algorithm. Each iteration may improve the partition further.</p>
</td></tr>
<tr><td><code id="cluster_leiden_+3A_vertex_weights">vertex_weights</code></td>
<td>
<p>the vertex weights used in the Leiden algorithm.
If this is not provided, it will be automatically determined on the basis
of the <code>objective_function</code>. Please see the details of this function
how to interpret the vertex weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Leiden algorithm consists of three phases: (1) local moving of nodes,
(2) refinement of the partition and (3) aggregation of the network based on
the refined partition, using the non-refined partition to create an initial
partition for the aggregate network. In the local move procedure in the
Leiden algorithm, only nodes whose neighborhood has changed are visited. The
refinement is done by restarting from a singleton partition within each
cluster and gradually merging the subclusters. When aggregating, a single
cluster may then be represented by several nodes (which are the subclusters
identified in the refinement).
</p>
<p>The Leiden algorithm provides several guarantees. The Leiden algorithm is
typically iterated: the output of one iteration is used as the input for the
next iteration. At each iteration all clusters are guaranteed to be
connected and well-separated. After an iteration in which nothing has
changed, all nodes and some parts are guaranteed to be locally optimally
assigned. Finally, asymptotically, all subsets of all clusters are
guaranteed to be locally optimally assigned. For more details, please see
Traag, Waltman &amp; van Eck (2019).
</p>
<p>The objective function being optimized is
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2m} \sum_{ij} (A_{ij} - \gamma n_i n_j)\delta(\sigma_i, \sigma_j)</code>
</p>

<p>where <code class="reqn">m</code> is the total edge weight, <code class="reqn">A_{ij}</code> is the weight
of edge <code class="reqn">(i, j)</code>, <code class="reqn">\gamma</code> is the so-called resolution
parameter, <code class="reqn">n_i</code> is the node weight of node <code class="reqn">i</code>, <code class="reqn">\sigma_i</code>
is the cluster of node <code class="reqn">i</code> and <code class="reqn">\delta(x, y) = 1</code> if and
only if <code class="reqn">x = y</code> and <code class="reqn">0</code> otherwise. By setting <code class="reqn">n_i = k_i</code>, the
degree of node <code class="reqn">i</code>, and dividing <code class="reqn">\gamma</code> by <code class="reqn">2m</code>, you
effectively obtain an expression for modularity.
</p>
<p>Hence, the standard modularity will be optimized when you supply the degrees
as <code>vertex_weights</code> and by supplying as a resolution parameter
<code class="reqn">\frac{1}{2m}</code>, with <code class="reqn">m</code> the number of edges. If you do not
specify any <code>vertex_weights</code>, the correct vertex weights and scaling of
<code class="reqn">\gamma</code> is determined automatically by the
<code>objective_function</code> argument.
</p>


<h3>Value</h3>

<p><code>cluster_leiden()</code> returns a <code><a href="#topic+communities">communities()</a></code>
object, please see the <code><a href="#topic+communities">communities()</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Vincent Traag
</p>


<h3>References</h3>

<p>Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From Louvain
to Leiden: guaranteeing well-connected communities. Scientific
reports, 9(1), 5233. doi: 10.1038/s41598-019-41695-z, arXiv:1810.08473v3 [cs.SI]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+communities">communities()</a></code> for extracting the membership,
modularity scores, etc. from the results.
</p>
<p>Other community detection algorithms: <code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass()</a></code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen()</a></code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness()</a></code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop()</a></code>
<code><a href="#topic+cluster_louvain">cluster_louvain()</a></code>
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities()</a></code>
<code><a href="#topic+cluster_infomap">cluster_infomap()</a></code>
<code><a href="#topic+cluster_optimal">cluster_optimal()</a></code>
<code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Zachary")
# By default CPM is used
r &lt;- quantile(strength(g))[2] / (gorder(g) - 1)
# Set seed for sake of reproducibility
set.seed(1)
ldc &lt;- cluster_leiden(g, resolution_parameter = r)
print(ldc)
plot(ldc, g)
</code></pre>

<hr>
<h2 id='cluster_louvain'>Finding community structure by multi-level optimization of modularity</h2><span id='topic+cluster_louvain'></span>

<h3>Description</h3>

<p>This function implements the multi-level modularity optimization algorithm
for finding community structure, see references below. It is based on the
modularity measure and a hierarchical approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_louvain(graph, weights = NULL, resolution = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_louvain_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="cluster_louvain_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="cluster_louvain_+3A_resolution">resolution</code></td>
<td>
<p>Optional resolution parameter that allows the user to
adjust the resolution parameter of the modularity function that the algorithm
uses internally. Lower values typically yield fewer, larger clusters. The
original definition of modularity is recovered when the resolution parameter
is set to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the multi-level modularity optimization algorithm
for finding community structure, see VD Blondel, J-L Guillaume, R Lambiotte
and E Lefebvre: Fast unfolding of community hierarchies in large networks,
<a href="https://arxiv.org/abs/0803.0476">https://arxiv.org/abs/0803.0476</a> for the details.
</p>
<p>It is based on the modularity measure and a hierarchical approach.
Initially, each vertex is assigned to a community on its own. In every step,
vertices are re-assigned to communities in a local, greedy way: each vertex
is moved to the community with which it achieves the highest contribution to
modularity. When no vertices can be reassigned, each community is considered
a vertex on its own, and the process starts again with the merged
communities. The process stops when there is only a single vertex left or
when the modularity cannot be increased any more in a step. Since igraph 1.3,
vertices are processed in a random order.
</p>
<p>This function was contributed by Tom Gregorovic.
</p>


<h3>Value</h3>

<p><code>cluster_louvain()</code> returns a <code><a href="#topic+communities">communities()</a></code>
object, please see the <code><a href="#topic+communities">communities()</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Tom Gregorovic, Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>Vincent D. Blondel, Jean-Loup Guillaume, Renaud Lambiotte,
Etienne Lefebvre: Fast unfolding of communities in large networks. J. Stat.
Mech. (2008) P10008
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+communities">communities()</a></code> for extracting the membership,
modularity scores, etc. from the results.
</p>
<p>Other community detection algorithms: <code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass()</a></code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen()</a></code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness()</a></code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop()</a></code>
<code><a href="#topic+cluster_leiden">cluster_leiden()</a></code>
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is so simple that we will have only one level
g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1, 6, 1, 11, 6, 11))
cluster_louvain(g)

</code></pre>

<hr>
<h2 id='cluster_optimal'>Optimal community structure</h2><span id='topic+cluster_optimal'></span>

<h3>Description</h3>

<p>This function calculates the optimal community structure of a graph, by
maximizing the modularity measure over all possible partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_optimal(graph, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_optimal_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions are ignored for directed
graphs.</p>
</td></tr>
<tr><td><code id="cluster_optimal_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the optimal community structure for a graph, in
terms of maximal modularity score.
</p>
<p>The calculation is done by transforming the modularity maximization into an
integer programming problem, and then calling the GLPK library to solve
that. Please the reference below for details.
</p>
<p>Note that modularity optimization is an NP-complete problem, and all known
algorithms for it have exponential time complexity. This means that you
probably don't want to run this function on larger graphs. Graphs with up to
fifty vertices should be fine, graphs with a couple of hundred vertices
might be possible.
</p>


<h3>Value</h3>

<p><code>cluster_optimal()</code> returns a <code><a href="#topic+communities">communities()</a></code> object,
please see the <code><a href="#topic+communities">communities()</a></code> manual page for details.
</p>


<h3>Examples</h3>

<pre>

## Zachary's karate club
g &lt;- make_graph("Zachary")

## We put everything into a big 'try' block, in case
## igraph was compiled without GLPK support

## The calculation only takes a couple of seconds
oc &lt;- cluster_optimal(g)

## Double check the result
print(modularity(oc))
print(modularity(g, membership(oc)))

## Compare to the greedy optimizer
fc &lt;- cluster_fast_greedy(g)
print(modularity(fc))
</pre>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Ulrik Brandes, Daniel Delling, Marco Gaertler, Robert Gorke,
Martin Hoefer, Zoran Nikoloski, Dorothea Wagner: On Modularity Clustering,
<em>IEEE Transactions on Knowledge and Data Engineering</em> 20(2):172-188,
2008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+communities">communities()</a></code> for the documentation of the result,
<code><a href="#topic+modularity">modularity()</a></code>. See also <code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code> for a
fast greedy optimizer.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>

<hr>
<h2 id='cluster_spinglass'>Finding communities in graphs based on statistical meachanics</h2><span id='topic+cluster_spinglass'></span>

<h3>Description</h3>

<p>This function tries to find communities in graphs via a spin-glass model and
simulated annealing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_spinglass(
  graph,
  weights = NULL,
  vertex = NULL,
  spins = 25,
  parupdate = FALSE,
  start.temp = 1,
  stop.temp = 0.01,
  cool.fact = 0.99,
  update.rule = c("config", "random", "simple"),
  gamma = 1,
  implementation = c("orig", "neg"),
  gamma.minus = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_spinglass_+3A_graph">graph</code></td>
<td>
<p>The input graph, can be directed but the direction of the edges
is neglected.</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_vertex">vertex</code></td>
<td>
<p>This parameter can be used to calculate the community of a
given vertex without calculating all communities. Note that if this argument
is present then some other arguments are ignored.</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_spins">spins</code></td>
<td>
<p>Integer constant, the number of spins to use. This is the upper
limit for the number of communities. It is not a problem to supply a
(reasonably) big number here, in which case some spin states will be
unpopulated.</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_parupdate">parupdate</code></td>
<td>
<p>Logical constant, whether to update the spins of the
vertices in parallel (synchronously) or not. This argument is ignored if the
second form of the function is used (i.e. the &lsquo;<code>vertex</code>&rsquo; argument
is present). It is also not implemented in the &ldquo;neg&rdquo; implementation.</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_start.temp">start.temp</code></td>
<td>
<p>Real constant, the start temperature.  This argument is
ignored if the second form of the function is used (i.e. the
&lsquo;<code>vertex</code>&rsquo; argument is present).</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_stop.temp">stop.temp</code></td>
<td>
<p>Real constant, the stop temperature. The simulation
terminates if the temperature lowers below this level.  This argument is
ignored if the second form of the function is used (i.e. the
&lsquo;<code>vertex</code>&rsquo; argument is present).</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_cool.fact">cool.fact</code></td>
<td>
<p>Cooling factor for the simulated annealing.  This argument
is ignored if the second form of the function is used (i.e. the
&lsquo;<code>vertex</code>&rsquo; argument is present).</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_update.rule">update.rule</code></td>
<td>
<p>Character constant giving the &lsquo;null-model&rsquo; of the
simulation. Possible values: &ldquo;simple&rdquo; and &ldquo;config&rdquo;.
&ldquo;simple&rdquo; uses a random graph with the same number of edges as the
baseline probability and &ldquo;config&rdquo; uses a random graph with the same
vertex degrees as the input graph.</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_gamma">gamma</code></td>
<td>
<p>Real constant, the gamma argument of the algorithm. This
specifies the balance between the importance of present and non-present
edges in a community. Roughly, a comunity is a set of vertices having many
edges inside the community and few edges outside the community. The default
1.0 value makes existing and non-existing links equally important. Smaller
values make the existing links, greater values the missing links more
important.</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_implementation">implementation</code></td>
<td>
<p>Character scalar. Currently igraph contains two
implementations for the Spin-glass community finding algorithm. The faster
original implementation is the default. The other implementation, that takes
into account negative weights, can be chosen by supplying &lsquo;neg&rsquo; here.</p>
</td></tr>
<tr><td><code id="cluster_spinglass_+3A_gamma.minus">gamma.minus</code></td>
<td>
<p>Real constant, the gamma.minus parameter of the
algorithm. This specifies the balance between the importance of present and
non-present negative weighted edges in a community. Smaller values of
gamma.minus, leads to communities with lesser negative intra-connectivity.
If this argument is set to zero, the algorithm reduces to a graph coloring
algorithm, using the number of spins as the number of colors. This argument
is ignored if the &lsquo;orig&rsquo; implementation is chosen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tries to find communities in a graph. A community is a set of
nodes with many edges inside the community and few edges between outside it
(i.e. between the community itself and the rest of the graph.)
</p>
<p>This idea is reversed for edges having a negative weight, i.e. few negative
edges inside a community and many negative edges between communities. Note
that only the &lsquo;neg&rsquo; implementation supports negative edge weights.
</p>
<p>The <code>spinglass.cummunity</code> function can solve two problems related to
community detection. If the <code>vertex</code> argument is not given (or it is
<code>NULL</code>), then the regular community detection problem is solved
(approximately), i.e. partitioning the vertices into communities, by
optimizing the an energy function.
</p>
<p>If the <code>vertex</code> argument is given and it is not <code>NULL</code>, then it
must be a vertex id, and the same energy function is used to find the
community of the the given vertex. See also the examples below.
</p>


<h3>Value</h3>

<p>If the <code>vertex</code> argument is not given, i.e. the first form is
used then a <code><a href="#topic+cluster_spinglass">cluster_spinglass()</a></code> returns a
<code><a href="#topic+communities">communities()</a></code> object.
</p>
<p>If the <code>vertex</code> argument is present, i.e. the second form is used then a
named list is returned with the following components:
</p>
<table>
<tr><td><code>community</code></td>
<td>
<p>Numeric vector giving the ids of the vertices in the same
community as <code>vertex</code>.</p>
</td></tr> <tr><td><code>cohesion</code></td>
<td>
<p>The cohesion score of the
result, see references.</p>
</td></tr> <tr><td><code>adhesion</code></td>
<td>
<p>The adhesion score of the result,
see references.</p>
</td></tr> <tr><td><code>inner.links</code></td>
<td>
<p>The number of edges within the community
of <code>vertex</code>.</p>
</td></tr> <tr><td><code>outer.links</code></td>
<td>
<p>The number of edges between the
community of <code>vertex</code> and the rest of the graph. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jorg Reichardt for the original code and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the igraph glue code.
</p>
<p>Changes to the original function for including the possibility of negative
ties were implemented by Vincent Traag (<a href="https://www.traag.net/">https://www.traag.net/</a>).
</p>


<h3>References</h3>

<p>J. Reichardt and S. Bornholdt: Statistical Mechanics of
Community Detection, <em>Phys. Rev. E</em>, 74, 016110 (2006),
<a href="https://arxiv.org/abs/cond-mat/0603718">https://arxiv.org/abs/cond-mat/0603718</a>
</p>
<p>M. E. J. Newman and M. Girvan: Finding and evaluating community structure in
networks, <em>Phys. Rev. E</em> 69, 026113 (2004)
</p>
<p>V.A. Traag and Jeroen Bruggeman: Community detection in networks with
positive and negative links, <a href="https://arxiv.org/abs/0811.2329">https://arxiv.org/abs/0811.2329</a> (2008).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+communities">communities()</a></code>, <code><a href="#topic+components">components()</a></code>
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(10, 5 / 10) %du% sample_gnp(9, 5 / 9)
g &lt;- add_edges(g, c(1, 12))
g &lt;- induced_subgraph(g, subcomponent(g, 1))
cluster_spinglass(g, spins = 2)
cluster_spinglass(g, vertex = 1)

</code></pre>

<hr>
<h2 id='cluster_walktrap'>Community structure via short random walks</h2><span id='topic+cluster_walktrap'></span>

<h3>Description</h3>

<p>This function tries to find densely connected subgraphs, also called
communities in a graph via random walks. The idea is that short random walks
tend to stay in the same community.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_walktrap(
  graph,
  weights = NULL,
  steps = 4,
  merges = TRUE,
  modularity = TRUE,
  membership = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_walktrap_+3A_graph">graph</code></td>
<td>
<p>The input graph, edge directions are ignored in directed
graphs.</p>
</td></tr>
<tr><td><code id="cluster_walktrap_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. Larger edge
weights increase the probability that an edge is selected by the random
walker. In other words, larger edge weights correspond to stronger connections.</p>
</td></tr>
<tr><td><code id="cluster_walktrap_+3A_steps">steps</code></td>
<td>
<p>The length of the random walks to perform.</p>
</td></tr>
<tr><td><code id="cluster_walktrap_+3A_merges">merges</code></td>
<td>
<p>Logical scalar, whether to include the merge matrix in the
result.</p>
</td></tr>
<tr><td><code id="cluster_walktrap_+3A_modularity">modularity</code></td>
<td>
<p>Logical scalar, whether to include the vector of the
modularity scores in the result. If the <code>membership</code> argument is true,
then it will always be calculated.</p>
</td></tr>
<tr><td><code id="cluster_walktrap_+3A_membership">membership</code></td>
<td>
<p>Logical scalar, whether to calculate the membership vector
for the split corresponding to the highest modularity value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the implementation of the Walktrap community finding
algorithm, see Pascal Pons, Matthieu Latapy: Computing communities in large
networks using random walks, https://arxiv.org/abs/physics/0512106
</p>


<h3>Value</h3>

<p><code>cluster_walktrap()</code> returns a <code><a href="#topic+communities">communities()</a></code>
object, please see the <code><a href="#topic+communities">communities()</a></code> manual page for details.
</p>


<h3>Author(s)</h3>

<p>Pascal Pons (<a href="http://psl.pons.free.fr/">http://psl.pons.free.fr/</a>) and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the R and igraph interface
</p>


<h3>References</h3>

<p>Pascal Pons, Matthieu Latapy: Computing communities in large
networks using random walks, https://arxiv.org/abs/physics/0512106
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+communities">communities()</a></code> on getting the actual membership
vector, merge matrix, modularity score, etc.
</p>
<p><code><a href="#topic+modularity">modularity()</a></code> and <code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass()</a></code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen()</a></code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness()</a></code>, <code><a href="#topic+cluster_louvain">cluster_louvain()</a></code>,
and <code><a href="#topic+cluster_leiden">cluster_leiden()</a></code> for other community detection
methods.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1, 6, 1, 11, 6, 11))
cluster_walktrap(g)

</code></pre>

<hr>
<h2 id='cluster.distribution'>Connected components of a graph</h2><span id='topic+cluster.distribution'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>cluster.distribution()</code> was renamed to <code>component_distribution()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.distribution(graph, cumulative = FALSE, mul.size = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster.distribution_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="cluster.distribution_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical, if TRUE the cumulative distirubution (relative
frequency) is calculated.</p>
</td></tr>
<tr><td><code id="cluster.distribution_+3A_mul.size">mul.size</code></td>
<td>
<p>Logical. If TRUE the relative frequencies will be multiplied
by the cluster sizes.</p>
</td></tr>
<tr><td><code id="cluster.distribution_+3A_...">...</code></td>
<td>
<p>Additional attributes to pass to <code>cluster</code>, right now only
<code>mode</code> makes sense.</p>
</td></tr>
</table>

<hr>
<h2 id='clusters'>Connected components of a graph</h2><span id='topic+clusters'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>clusters()</code> was renamed to <code>components()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusters(graph, mode = c("weak", "strong"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusters_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="clusters_+3A_mode">mode</code></td>
<td>
<p>Character string, either &ldquo;weak&rdquo; or &ldquo;strong&rdquo;.  For
directed graphs &ldquo;weak&rdquo; implies weakly, &ldquo;strong&rdquo; strongly
connected components to search. It is ignored for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='cocitation'>Cocitation coupling</h2><span id='topic+cocitation'></span><span id='topic+bibcoupling'></span>

<h3>Description</h3>

<p>Two vertices are cocited if there is another vertex citing both of them.
<code>cocitation()</code> simply counts how many types two vertices are cocited. The
bibliographic coupling of two vertices is the number of other vertices they
both cite, <code>bibcoupling()</code> calculates this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cocitation(graph, v = V(graph))

bibcoupling(graph, v = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cocitation_+3A_graph">graph</code></td>
<td>
<p>The graph object to analyze</p>
</td></tr>
<tr><td><code id="cocitation_+3A_v">v</code></td>
<td>
<p>Vertex sequence or numeric vector, the vertex ids for which the
cocitation or bibliographic coupling values we want to calculate. The
default is all vertices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cocitation()</code> calculates the cocitation counts for the vertices in the
<code>v</code> argument and all vertices in the graph.
</p>
<p><code>bibcoupling()</code> calculates the bibliographic coupling for vertices in
<code>v</code> and all vertices in the graph.
</p>
<p>Calculating the cocitation or bibliographic coupling for only one vertex
costs the same amount of computation as for all vertices. This might change
in the future.
</p>


<h3>Value</h3>

<p>A numeric matrix with <code>length(v)</code> lines and
<code>vcount(graph)</code> columns. Element <code style="white-space: pre;">&#8288;(i,j)&#8288;</code> contains the cocitation
or bibliographic coupling for vertices <code>v[i]</code> and <code>j</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other cocitation: 
<code><a href="#topic+similarity">similarity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_kautz_graph(2, 3)
cocitation(g)
bibcoupling(g)

</code></pre>

<hr>
<h2 id='code.length'>Functions to deal with the result of network community detection</h2><span id='topic+code.length'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>code.length()</code> was renamed to <code>code_len()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code.length(communities)
</code></pre>

<hr>
<h2 id='cohesive_blocks'>Calculate Cohesive Blocks</h2><span id='topic+cohesive_blocks'></span><span id='topic+cohesiveBlocks'></span><span id='topic+blocks'></span><span id='topic+hierarchy'></span><span id='topic+parent'></span><span id='topic+export_pajek'></span><span id='topic+plot.cohesiveBlocks'></span><span id='topic+summary.cohesiveBlocks'></span><span id='topic+length.cohesiveBlocks'></span><span id='topic+print.cohesiveBlocks'></span><span id='topic+graphs_from_cohesive_blocks'></span><span id='topic+cohesion.cohesiveBlocks'></span><span id='topic+plot_hierarchy'></span><span id='topic+max_cohesion'></span>

<h3>Description</h3>

<p>Calculates cohesive blocks for objects of class <code>igraph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohesive_blocks(graph, labels = TRUE)

## S3 method for class 'cohesiveBlocks'
length(x)

blocks(blocks)

graphs_from_cohesive_blocks(blocks, graph)

## S3 method for class 'cohesiveBlocks'
cohesion(x, ...)

hierarchy(blocks)

parent(blocks)

## S3 method for class 'cohesiveBlocks'
print(x, ...)

## S3 method for class 'cohesiveBlocks'
summary(object, ...)

## S3 method for class 'cohesiveBlocks'
plot(
  x,
  y,
  colbar = rainbow(max(cohesion(x)) + 1),
  col = colbar[max_cohesion(x) + 1],
  mark.groups = blocks(x)[-1],
  ...
)

plot_hierarchy(
  blocks,
  layout = layout_as_tree(hierarchy(blocks), root = 1),
  ...
)

export_pajek(blocks, graph, file, project.file = TRUE)

max_cohesion(blocks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohesive_blocks_+3A_graph">graph</code></td>
<td>
<p>For <code>cohesive_blocks()</code> a graph object of class
<code>igraph</code>. It must be undirected and simple. (See
<code><a href="#topic+is_simple">is_simple()</a></code>.)
</p>
<p>For <code>graphs_from_cohesive_blocks()</code> and <code>export_pajek()</code> the same graph must be
supplied whose cohesive block structure is given in the <code>blocks()</code>
argument.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_labels">labels</code></td>
<td>
<p>Logical scalar, whether to add the vertex labels to the result
object. These labels can be then used when reporting and plotting the
cohesive blocks.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_blocks">blocks</code>, <code id="cohesive_blocks_+3A_x">x</code>, <code id="cohesive_blocks_+3A_object">object</code></td>
<td>
<p>A <code>cohesiveBlocks</code> object, created with the
<code>cohesive_blocks()</code> function.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_...">...</code></td>
<td>
<p>Additional arguments. <code>plot_hierarchy()</code> and <code><a href="base.html#topic+plot">plot()</a></code> pass
them to <code>plot.igraph()</code>.  <code><a href="base.html#topic+print">print()</a></code> and <code><a href="base.html#topic+summary">summary()</a></code> ignore them.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_y">y</code></td>
<td>
<p>The graph whose cohesive blocks are supplied in the <code>x</code>
argument.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_colbar">colbar</code></td>
<td>
<p>Color bar for the vertex colors. Its length should be at least
<code class="reqn">m+1</code>, where <code class="reqn">m</code> is the maximum cohesion in the graph.
Alternatively, the vertex colors can also be directly specified via the
<code>col</code> argument.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_col">col</code></td>
<td>
<p>A vector of vertex colors, in any of the usual formats. (Symbolic
color names (e.g. &lsquo;red&rsquo;, &lsquo;blue&rsquo;, etc.) , RGB colors (e.g.
&lsquo;#FF9900FF&rsquo;), integer numbers referring to the current palette. By
default the given <code>colbar</code> is used and vertices with the same maximal
cohesion will have the same color.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_mark.groups">mark.groups</code></td>
<td>
<p>A list of vertex sets to mark on the plot by circling
them. By default all cohesive blocks are marked, except the one
corresponding to the all vertices.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_layout">layout</code></td>
<td>
<p>The layout of a plot, it is simply passed on to
<code>plot.igraph()</code>, see the possible formats there. By default the
Reingold-Tilford layout generator is used.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_file">file</code></td>
<td>
<p>Defines the file (or connection) the Pajek file is written to.
</p>
<p>If the <code>project.file</code> argument is <code>TRUE</code>, then it can be a
filename (with extension), a file object, or in general any king of
connection object. The file/connection will be opened if it wasn't already.
</p>
<p>If the <code>project.file</code> argument is <code>FALSE</code>, then several files are
created and <code>file</code> must be a character scalar containing the base name
of the files, without extension. (But it can contain the path to the files.)
</p>
<p>See also details below.</p>
</td></tr>
<tr><td><code id="cohesive_blocks_+3A_project.file">project.file</code></td>
<td>
<p>Logical scalar, whether to create a single Pajek project
file containing all the data, or to create separated files for each item.
See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cohesive blocking is a method of determining hierarchical subsets of graph
vertices based on their structural cohesion (or vertex connectivity). For a
given graph <code class="reqn">G</code>, a subset of its vertices <code class="reqn">S\subset V(G)</code> is said
to be maximally <code class="reqn">k</code>-cohesive if there is no superset of <code class="reqn">S</code> with
vertex connectivity greater than or equal to <code class="reqn">k</code>. Cohesive blocking is a
process through which, given a <code class="reqn">k</code>-cohesive set of vertices, maximally
<code class="reqn">l</code>-cohesive subsets are recursively identified with <code class="reqn">l&gt;k</code>. Thus a
hierarchy of vertex subsets is found, with the entire graph <code class="reqn">G</code> at its
root.
</p>
<p>The function <code>cohesive_blocks()</code> implements cohesive blocking.  It
returns a <code>cohesiveBlocks</code> object. <code>cohesiveBlocks</code> should be
handled as an opaque class, i.e. its internal structure should not be
accessed directly, but through the functions listed here.
</p>
<p>The function <code>length</code> can be used on <code>cohesiveBlocks</code> objects and
it gives the number of blocks.
</p>
<p>The function <code>blocks()</code> returns the actual blocks stored in the
<code>cohesiveBlocks</code> object. They are returned in a list of numeric
vectors, each containing vertex ids.
</p>
<p>The function <code>graphs_from_cohesive_blocks()</code> is similar, but returns the blocks as
(induced) subgraphs of the input graph. The various (graph, vertex and edge)
attributes are kept in the subgraph.
</p>
<p>The function <code>cohesion()</code> returns a numeric vector, the cohesion of the
different blocks. The order of the blocks is the same as for the
<code>blocks()</code> and <code>graphs_from_cohesive_blocks()</code> functions.
</p>
<p>The block hierarchy can be queried using the <code>hierarchy()</code> function. It
returns an igraph graph, its vertex ids are ordered according the order of
the blocks in the <code>blocks()</code> and <code>graphs_from_cohesive_blocks()</code>, <code>cohesion()</code>,
etc. functions.
</p>
<p><code>parent()</code> gives the parent vertex of each block, in the block hierarchy,
for the root vertex it gives 0.
</p>
<p><code>plot_hierarchy()</code> plots the hierarchy tree of the cohesive blocks on the
active graphics device, by calling <code>igraph.plot</code>.
</p>
<p>The <code>export_pajek()</code> function can be used to export the graph and its
cohesive blocks in Pajek format. It can either export a single Pajek project
file with all the information, or a set of files, depending on its
<code>project.file</code> argument. If <code>project.file</code> is <code>TRUE</code>, then
the following information is written to the file (or connection) given in
the <code>file</code> argument: (1) the input graph, together with its attributes,
see <code><a href="#topic+write_graph">write_graph()</a></code> for details; (2) the hierarchy graph; and (3)
one binary partition for each cohesive block. If <code>project.file</code> is
<code>FALSE</code>, then the <code>file</code> argument must be a character scalar and
it is used as the base name for the generated files. If <code>file</code> is
&lsquo;basename&rsquo;, then the following files are created: (1)
&lsquo;basename.net&rsquo; for the original graph; (2)
&lsquo;basename_hierarchy.net&rsquo; for the hierarchy graph; (3)
&lsquo;basename_block_x.net&rsquo; for each cohesive block, where &lsquo;x&rsquo; is
the number of the block, starting with one.
</p>
<p><code>max_cohesion()</code> returns the maximal cohesion of each vertex, i.e. the
cohesion of the most cohesive block of the vertex.
</p>
<p>The generic function <code><a href="base.html#topic+summary">summary()</a></code> works on <code>cohesiveBlocks</code> objects
and it prints a one line summary to the terminal.
</p>
<p>The generic function <code><a href="base.html#topic+print">print()</a></code> is also defined on <code>cohesiveBlocks</code>
objects and it is invoked automatically if the name of the
<code>cohesiveBlocks</code> object is typed in. It produces an output like this:
</p>
<pre> Cohesive block structure:
B-1 c 1, n 23
'- B-2 c 2, n 14 oooooooo.. .o......oo ooo
'- B-4 c 5, n  7 ooooooo... .......... ...
'- B-3 c 2, n 10 ......o.oo o.oooooo.. ...
'- B-5 c 3, n  4 ......o.oo o......... ...  </pre>
<p>The left part shows the block structure, in this case for five
blocks. The first block always corresponds to the whole graph, even if its
cohesion is zero. Then cohesion of the block and the number of vertices in
the block are shown. The last part is only printed if the display is wide
enough and shows the vertices in the blocks, ordered by vertex ids.
&lsquo;o&rsquo; means that the vertex is included, a dot means that it is not,
and the vertices are shown in groups of ten.
</p>
<p>The generic function <code><a href="base.html#topic+plot">plot()</a></code> plots the graph, showing one or more
cohesive blocks in it.
</p>


<h3>Value</h3>

<p><code>cohesive_blocks()</code> returns a <code>cohesiveBlocks</code> object.
</p>
<p><code>blocks()</code> returns a list of numeric vectors, containing vertex ids.
</p>
<p><code>graphs_from_cohesive_blocks()</code> returns a list of igraph graphs, corresponding to the
cohesive blocks.
</p>
<p><code>cohesion()</code> returns a numeric vector, the cohesion of each block.
</p>
<p><code>hierarchy()</code> returns an igraph graph, the representation of the cohesive
block hierarchy.
</p>
<p><code>parent()</code> returns a numeric vector giving the parent block of each
cohesive block, in the block hierarchy. The block at the root of the
hierarchy has no parent and <code>0</code> is returned for it.
</p>
<p><code>plot_hierarchy()</code>, <code><a href="base.html#topic+plot">plot()</a></code> and <code>export_pajek()</code> return <code>NULL</code>,
invisibly.
</p>
<p><code>max_cohesion()</code> returns a numeric vector with one entry for each vertex,
giving the cohesion of its most cohesive block.
</p>
<p><code><a href="base.html#topic+print">print()</a></code> and <code><a href="base.html#topic+summary">summary()</a></code> return the <code>cohesiveBlocks</code> object
itself, invisibly.
</p>
<p><code>length</code> returns a numeric scalar, the number of blocks.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the current
implementation, Peter McMahan (<a href="https://socialsciences.uchicago.edu/news/alumni-profile-peter-mcmahan-phd17-sociology">https://socialsciences.uchicago.edu/news/alumni-profile-peter-mcmahan-phd17-sociology</a>)
wrote the first version in R.
</p>


<h3>References</h3>

<p>J. Moody and D. R. White. Structural cohesion and embeddedness:
A hierarchical concept of social groups. <em>American Sociological
Review</em>, 68(1):103&ndash;127, Feb 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cohesion">cohesion()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The graph from the Moody-White paper
mw &lt;- graph_from_literal(
  1 - 2:3:4:5:6, 2 - 3:4:5:7, 3 - 4:6:7, 4 - 5:6:7,
  5 - 6:7:21, 6 - 7, 7 - 8:11:14:19, 8 - 9:11:14, 9 - 10,
  10 - 12:13, 11 - 12:14, 12 - 16, 13 - 16, 14 - 15, 15 - 16,
  17 - 18:19:20, 18 - 20:21, 19 - 20:22:23, 20 - 21,
  21 - 22:23, 22 - 23
)

mwBlocks &lt;- cohesive_blocks(mw)

# Inspect block membership and cohesion
mwBlocks
blocks(mwBlocks)
cohesion(mwBlocks)

# Save results in a Pajek file
file &lt;- tempfile(fileext = ".paj")
export_pajek(mwBlocks, mw, file = file)
if (!interactive()) {
  unlink(file)
}

# Plot the results
plot(mwBlocks, mw)

## The science camp network
camp &lt;- graph_from_literal(
  Harry:Steve:Don:Bert - Harry:Steve:Don:Bert,
  Pam:Brazey:Carol:Pat - Pam:Brazey:Carol:Pat,
  Holly - Carol:Pat:Pam:Jennie:Bill,
  Bill - Pauline:Michael:Lee:Holly,
  Pauline - Bill:Jennie:Ann,
  Jennie - Holly:Michael:Lee:Ann:Pauline,
  Michael - Bill:Jennie:Ann:Lee:John,
  Ann - Michael:Jennie:Pauline,
  Lee - Michael:Bill:Jennie,
  Gery - Pat:Steve:Russ:John,
  Russ - Steve:Bert:Gery:John,
  John - Gery:Russ:Michael
)
campBlocks &lt;- cohesive_blocks(camp)
campBlocks

plot(campBlocks, camp,
  vertex.label = V(camp)$name, margin = -0.2,
  vertex.shape = "rectangle", vertex.size = 24, vertex.size2 = 8,
  mark.border = 1, colbar = c(NA, NA, "cyan", "orange")
)

</code></pre>

<hr>
<h2 id='cohesive.blocks'>Calculate Cohesive Blocks</h2><span id='topic+cohesive.blocks'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>cohesive.blocks()</code> was renamed to <code>cohesive_blocks()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohesive.blocks(graph, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohesive.blocks_+3A_graph">graph</code></td>
<td>
<p>For <code>cohesive_blocks()</code> a graph object of class
<code>igraph</code>. It must be undirected and simple. (See
<code><a href="#topic+is_simple">is_simple()</a></code>.)
</p>
<p>For <code>graphs_from_cohesive_blocks()</code> and <code>export_pajek()</code> the same graph must be
supplied whose cohesive block structure is given in the <code>blocks()</code>
argument.</p>
</td></tr>
<tr><td><code id="cohesive.blocks_+3A_labels">labels</code></td>
<td>
<p>Logical scalar, whether to add the vertex labels to the result
object. These labels can be then used when reporting and plotting the
cohesive blocks.</p>
</td></tr>
</table>

<hr>
<h2 id='compare'>Compares community structures using various metrics</h2><span id='topic+compare'></span><span id='topic+compare.communities'></span><span id='topic+compare.membership'></span>

<h3>Description</h3>

<p>This function assesses the distance between two community structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(
  comm1,
  comm2,
  method = c("vi", "nmi", "split.join", "rand", "adjusted.rand")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_comm1">comm1</code></td>
<td>
<p>A <code><a href="#topic+communities">communities()</a></code> object containing a community
structure; or a numeric vector, the membership vector of the first community
structure. The membership vector should contain the community id of each
vertex, the numbering of the communities starts with one.</p>
</td></tr>
<tr><td><code id="compare_+3A_comm2">comm2</code></td>
<td>
<p>A <code><a href="#topic+communities">communities()</a></code> object containing a community
structure; or a numeric vector, the membership vector of the second
community structure, in the same format as for the previous argument.</p>
</td></tr>
<tr><td><code id="compare_+3A_method">method</code></td>
<td>
<p>Character scalar, the comparison method to use. Possible
values: &lsquo;vi&rsquo; is the variation of information (VI) metric of Meila
(2003), &lsquo;nmi&rsquo; is the normalized mutual information measure proposed
by Danon et al. (2005), &lsquo;split.join&rsquo; is the split-join distance of
can Dongen (2000), &lsquo;rand&rsquo; is the Rand index of Rand (1971),
&lsquo;adjusted.rand&rsquo; is the adjusted Rand index by Hubert and Arabie
(1985).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>Meila M: Comparing clusterings by the variation of information.
In: Scholkopf B, Warmuth MK (eds.). <em>Learning Theory and Kernel
Machines: 16th Annual Conference on Computational Learning Theory and 7th
Kernel Workshop</em>, COLT/Kernel 2003, Washington, DC, USA. Lecture Notes in
Computer Science, vol. 2777, Springer, 2003. ISBN: 978-3-540-40720-1.
</p>
<p>Danon L, Diaz-Guilera A, Duch J, Arenas A: Comparing community structure
identification. <em>J Stat Mech</em> P09008, 2005.
</p>
<p>van Dongen S: Performance criteria for graph clustering and Markov cluster
experiments. Technical Report INS-R0012, National Research Institute for
Mathematics and Computer Science in the Netherlands, Amsterdam, May 2000.
</p>
<p>Rand WM: Objective criteria for the evaluation of clustering methods.
<em>J Am Stat Assoc</em> 66(336):846-850, 1971.
</p>
<p>Hubert L and Arabie P: Comparing partitions. <em>Journal of
Classification</em> 2:193-218, 1985.
</p>


<h3>See Also</h3>

<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph("Zachary")
sg &lt;- cluster_spinglass(g)
le &lt;- cluster_leading_eigen(g)
compare(sg, le, method = "rand")
compare(membership(sg), membership(le))

</code></pre>

<hr>
<h2 id='complementer'>Complementer of a graph</h2><span id='topic+complementer'></span>

<h3>Description</h3>

<p>A complementer graph contains all edges that were not present in the input
graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complementer(graph, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complementer_+3A_graph">graph</code></td>
<td>
<p>The input graph, can be directed or undirected.</p>
</td></tr>
<tr><td><code id="complementer_+3A_loops">loops</code></td>
<td>
<p>Logical constant, whether to generate loop edges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>complementer()</code> creates the complementer of a graph. Only edges
which are <em>not</em> present in the original graph will be included in the
new graph.
</p>
<p><code>complementer()</code> keeps graph and vertex attriubutes, edge
attributes are lost.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Complementer of a ring
g &lt;- make_ring(10)
complementer(g)

## A graph and its complementer give together the full graph
g &lt;- make_ring(10)
gc &lt;- complementer(g)
gu &lt;- union(g, gc)
gu
graph.isomorphic(gu, make_full_graph(vcount(g)))

</code></pre>

<hr>
<h2 id='component_distribution'>Connected components of a graph</h2><span id='topic+component_distribution'></span><span id='topic+largest_component'></span><span id='topic+components'></span><span id='topic+is_connected'></span><span id='topic+count_components'></span>

<h3>Description</h3>

<p>Calculate the maximal (weakly or strongly) connected components of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>component_distribution(graph, cumulative = FALSE, mul.size = FALSE, ...)

largest_component(graph, mode = c("weak", "strong"))

components(graph, mode = c("weak", "strong"))

is_connected(graph, mode = c("weak", "strong"))

count_components(graph, mode = c("weak", "strong"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="component_distribution_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="component_distribution_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical, if TRUE the cumulative distirubution (relative
frequency) is calculated.</p>
</td></tr>
<tr><td><code id="component_distribution_+3A_mul.size">mul.size</code></td>
<td>
<p>Logical. If TRUE the relative frequencies will be multiplied
by the cluster sizes.</p>
</td></tr>
<tr><td><code id="component_distribution_+3A_...">...</code></td>
<td>
<p>Additional attributes to pass to <code>cluster</code>, right now only
<code>mode</code> makes sense.</p>
</td></tr>
<tr><td><code id="component_distribution_+3A_mode">mode</code></td>
<td>
<p>Character string, either &ldquo;weak&rdquo; or &ldquo;strong&rdquo;.  For
directed graphs &ldquo;weak&rdquo; implies weakly, &ldquo;strong&rdquo; strongly
connected components to search. It is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_connected()</code> decides whether the graph is weakly or strongly
connected. The null graph is considered disconnected.
</p>
<p><code>components()</code> finds the maximal (weakly or strongly) connected components
of a graph.
</p>
<p><code>count_components()</code> does almost the same as <code>components()</code> but returns only
the number of clusters found instead of returning the actual clusters.
</p>
<p><code>component_distribution()</code> creates a histogram for the maximal connected
component sizes.
</p>
<p><code>largest_component()</code> returns the largest connected component of a graph. For
directed graphs, optionally the largest weakly or strongly connected component.
In case of a tie, the first component by vertex ID order is returned. Vertex
IDs from the original graph are not retained in the returned graph.
</p>
<p>The weakly connected components are found by a simple breadth-first search.
The strongly connected components are implemented by two consecutive
depth-first searches.
</p>


<h3>Value</h3>

<p>For <code>is_connected()</code> a logical constant.
</p>
<p>For <code>components()</code> a named list with three components:
</p>
<table>
<tr><td><code>membership</code></td>
<td>
<p>numeric vector giving the cluster id to which each vertex
belongs.</p>
</td></tr> <tr><td><code>csize</code></td>
<td>
<p>numeric vector giving the sizes of the clusters.</p>
</td></tr>
<tr><td><code>no</code></td>
<td>
<p>numeric constant, the number of clusters.</p>
</td></tr>
</table>
<p>For <code>count_components()</code> an integer constant is returned.
</p>
<p>For <code>component_distribution()</code> a numeric vector with the relative
frequencies. The length of the vector is the size of the largest component
plus one. Note that (for currently unknown reasons) the first element of the
vector is the number of clusters of size zero, so this is always zero.
</p>
<p>For <code>largest_component()</code> the largest connected component of the graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decompose">decompose()</a></code>, <code><a href="#topic+subcomponent">subcomponent()</a></code>, <code><a href="#topic+groups">groups()</a></code>
</p>
<p>Connected components
<code><a href="#topic+articulation_points">articulation_points</a>()</code>,
<code><a href="#topic+biconnected_components">biconnected_components</a>()</code>,
<code><a href="#topic+decompose">decompose</a>()</code>,
<code><a href="#topic+is_biconnected">is_biconnected</a>()</code>
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(20, 1 / 20)
clu &lt;- components(g)
groups(clu)
largest_component(g)
</code></pre>

<hr>
<h2 id='component_wise'>Component-wise layout</h2><span id='topic+component_wise'></span>

<h3>Description</h3>

<p>This is a layout modifier function, and it can be used
to calculate the layout separately for each component
of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>component_wise(merge_method = "dla")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="component_wise_+3A_merge_method">merge_method</code></td>
<td>
<p>Merging algorithm, the <code>method</code>
argument of <code><a href="#topic+merge_coords">merge_coords()</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+merge_coords">merge_coords()</a></code>, <code><a href="#topic+layout_">layout_()</a></code>.
</p>
<p>Other layout modifiers: 
<code><a href="#topic+normalize">normalize</a>()</code>
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) + make_ring(10)
g %&gt;%
  add_layout_(in_circle(), component_wise()) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='compose'>Compose two graphs as binary relations</h2><span id='topic+compose'></span><span id='topic++25c+25'></span>

<h3>Description</h3>

<p>Relational composition of two graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose(g1, g2, byname = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_+3A_g1">g1</code></td>
<td>
<p>The first input graph.</p>
</td></tr>
<tr><td><code id="compose_+3A_g2">g2</code></td>
<td>
<p>The second input graph.</p>
</td></tr>
<tr><td><code id="compose_+3A_byname">byname</code></td>
<td>
<p>A logical scalar, or the character scalar <code>auto</code>. Whether
to perform the operation based on symbolic vertex names. If it is
<code>auto</code>, that means <code>TRUE</code> if both graphs are named and
<code>FALSE</code> otherwise. A warning is generated if <code>auto</code> and one graph,
but not both graphs are named.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compose()</code> creates the relational composition of two graphs. The
new graph will contain an (a,b) edge only if there is a vertex c, such that
edge (a,c) is included in the first graph and (c,b) is included in the
second graph. The corresponding operator is <code style="white-space: pre;">&#8288;%c%&#8288;</code>.
</p>
<p>The function gives an error if one of the input graphs is directed and the
other is undirected.
</p>
<p>If the <code>byname</code> argument is <code>TRUE</code> (or <code>auto</code> and the graphs
are all named), then the operation is performed based on symbolic vertex
names. Otherwise numeric vertex ids are used.
</p>
<p><code>compose()</code> keeps the attributes of both graphs. All graph, vertex
and edge attributes are copied to the result. If an attribute is present in
multiple graphs and would result a name clash, then this attribute is
renamed by adding suffixes: _1, _2, etc.
</p>
<p>The <code>name</code> vertex attribute is treated specially if the operation is
performed based on symbolic vertex names. In this case <code>name</code> must be
present in both graphs, and it is not renamed in the result graph.
</p>
<p>Note that an edge in the result graph corresponds to two edges in the input,
one in the first graph, one in the second. This mapping is not injective and
several edges in the result might correspond to the same edge in the first
(and/or the second) graph. The edge attributes in the result graph are
updated accordingly.
</p>
<p>Also note that the function may generate multigraphs, if there are more than
one way to find edges (a,b) in g1 and (b,c) in g2 for an edge (a,c) in the
result. See <code><a href="#topic+simplify">simplify()</a></code> if you want to get rid of the multiple
edges.
</p>
<p>The function may create loop edges, if edges (a,b) and (b,a) are present in
g1 and g2, respectively, then (a,a) is included in the result. See
<code><a href="#topic+simplify">simplify()</a></code> if you want to get rid of the self-loops.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- make_ring(10)
g2 &lt;- make_star(10, mode = "undirected")
gc &lt;- compose(g1, g2)
print_all(gc)
print_all(simplify(gc))

</code></pre>

<hr>
<h2 id='connect'>Neighborhood of graph vertices</h2><span id='topic+connect'></span><span id='topic+ego_size'></span><span id='topic+neighborhood_size'></span><span id='topic+ego'></span><span id='topic+neighborhood'></span><span id='topic+ego_graph'></span><span id='topic+make_ego_graph'></span><span id='topic+make_neighborhood_graph'></span>

<h3>Description</h3>

<p>These functions find the vertices not farther than a given limit from
another fixed vertex, these are called the neighborhood of the vertex.
Note that <code>ego()</code> and <code>neighborhood()</code>,
<code>ego_size()</code> and <code>neighborhood_size()</code>,
<code>make_ego_graph()</code> and <code style="white-space: pre;">&#8288;make_neighborhood()_graph()&#8288;</code>,
are synonyms (aliases).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect(graph, order, mode = c("all", "out", "in", "total"))

ego_size(
  graph,
  order = 1,
  nodes = V(graph),
  mode = c("all", "out", "in"),
  mindist = 0
)

neighborhood_size(
  graph,
  order = 1,
  nodes = V(graph),
  mode = c("all", "out", "in"),
  mindist = 0
)

ego(
  graph,
  order = 1,
  nodes = V(graph),
  mode = c("all", "out", "in"),
  mindist = 0
)

neighborhood(
  graph,
  order = 1,
  nodes = V(graph),
  mode = c("all", "out", "in"),
  mindist = 0
)

make_ego_graph(
  graph,
  order = 1,
  nodes = V(graph),
  mode = c("all", "out", "in"),
  mindist = 0
)

make_neighborhood_graph(
  graph,
  order = 1,
  nodes = V(graph),
  mode = c("all", "out", "in"),
  mindist = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connect_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="connect_+3A_order">order</code></td>
<td>
<p>Integer giving the order of the neighborhood.</p>
</td></tr>
<tr><td><code id="connect_+3A_mode">mode</code></td>
<td>
<p>Character constant, it specifies how to use the direction of
the edges if a directed graph is analyzed. For &lsquo;out&rsquo; only the
outgoing edges are followed, so all vertices reachable from the source
vertex in at most <code>order</code> steps are counted. For &lsquo;&quot;in&quot;&rsquo; all
vertices from which the source vertex is reachable in at most <code>order</code>
steps are counted. &lsquo;&quot;all&quot;&rsquo; ignores the direction of the edges. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="connect_+3A_nodes">nodes</code></td>
<td>
<p>The vertices for which the calculation is performed.</p>
</td></tr>
<tr><td><code id="connect_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance to include the vertex in the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The neighborhood of a given order <code>r</code> of a vertex <code>v</code> includes all
vertices which are closer to <code>v</code> than the order. I.e. order 0 is always
<code>v</code> itself, order 1 is <code>v</code> plus its immediate neighbors, order 2
is order 1 plus the immediate neighbors of the vertices in order 1, etc.
</p>
<p><code>ego_size()</code>/<code>neighborhood_size()</code> (synonyms) returns the size of the neighborhoods of the given order,
for each given vertex.
</p>
<p><code>ego()</code>/<code>neighborhood()</code> (synonyms) returns the vertices belonging to the neighborhoods of the given
order, for each given vertex.
</p>
<p><code>make_ego_graph()</code>/<code style="white-space: pre;">&#8288;make_neighborhood()_graph()&#8288;</code> (synonyms) is creates (sub)graphs from all neighborhoods of
the given vertices with the given order parameter. This function preserves
the vertex, edge and graph attributes.
</p>
<p><code>connect()</code> creates a new graph by connecting each vertex to
all other vertices in its neighborhood.
</p>


<h3>Value</h3>


<ul>
<li><p><code>ego_size()</code>/<code>neighborhood_size()</code> returns with an integer vector.
</p>
</li>
<li><p><code>ego()</code>/<code>neighborhood()</code> (synonyms) returns A list of <code>igraph.vs</code> or a list of numeric
vectors depending on the value of <code>igraph_opt("return.vs.es")</code>,
see details for performance characteristics.
</p>
</li>
<li><p><code>make_ego_graph()</code>/<code>make_neighborhood_graph()</code> returns with a list of graphs.
</p>
</li>
<li><p><code>connect()</code> returns with a new graph object.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>, the first version was
done by Vincent Matossian
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)

ego_size(g, order = 0, 1:3)
ego_size(g, order = 1, 1:3)
ego_size(g, order = 2, 1:3)

# neighborhood_size() is an alias of ego_size()
neighborhood_size(g, order = 0, 1:3)
neighborhood_size(g, order = 1, 1:3)
neighborhood_size(g, order = 2, 1:3)

ego(g, order = 0, 1:3)
ego(g, order = 1, 1:3)
ego(g, order = 2, 1:3)

# neighborhood() is an alias of ego()
neighborhood(g, order = 0, 1:3)
neighborhood(g, order = 1, 1:3)
neighborhood(g, order = 2, 1:3)

# attributes are preserved
V(g)$name &lt;- c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")
make_ego_graph(g, order = 2, 1:3)
# make_neighborhood_graph() is an alias of make_ego_graph()
make_neighborhood_graph(g, order = 2, 1:3)

# connecting to the neighborhood
g &lt;- make_ring(10)
g &lt;- connect(g, 2)

</code></pre>

<hr>
<h2 id='connect.neighborhood'>Neighborhood of graph vertices</h2><span id='topic+connect.neighborhood'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>connect.neighborhood()</code> was renamed to <code>connect()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect.neighborhood(graph, order, mode = c("all", "out", "in", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connect.neighborhood_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="connect.neighborhood_+3A_order">order</code></td>
<td>
<p>Integer giving the order of the neighborhood.</p>
</td></tr>
<tr><td><code id="connect.neighborhood_+3A_mode">mode</code></td>
<td>
<p>Character constant, it specifies how to use the direction of
the edges if a directed graph is analyzed. For &lsquo;out&rsquo; only the
outgoing edges are followed, so all vertices reachable from the source
vertex in at most <code>order</code> steps are counted. For &lsquo;&quot;in&quot;&rsquo; all
vertices from which the source vertex is reachable in at most <code>order</code>
steps are counted. &lsquo;&quot;all&quot;&rsquo; ignores the direction of the edges. This
argument is ignored for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='consensus_tree'>Create a consensus tree from several hierarchical random graph models</h2><span id='topic+consensus_tree'></span>

<h3>Description</h3>

<p><code>consensus_tree()</code> creates a consensus tree from several fitted
hierarchical random graph models, using phylogeny methods. If the <code>hrg()</code>
argument is given and <code>start</code> is set to <code>TRUE</code>, then it starts
sampling from the given HRG. Otherwise it optimizes the HRG log-likelihood
first, and then samples starting from the optimum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensus_tree(graph, hrg = NULL, start = FALSE, num.samples = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consensus_tree_+3A_graph">graph</code></td>
<td>
<p>The graph the models were fitted to.</p>
</td></tr>
<tr><td><code id="consensus_tree_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model, in the form of an
<code>igraphHRG</code> object. <code>consensus_tree()</code> allows this to be
<code>NULL</code> as well, then a HRG is fitted to the graph first, from a
random starting point.</p>
</td></tr>
<tr><td><code id="consensus_tree_+3A_start">start</code></td>
<td>
<p>Logical, whether to start the fitting/sampling from the
supplied <code>igraphHRG</code> object, or from a random starting point.</p>
</td></tr>
<tr><td><code id="consensus_tree_+3A_num.samples">num.samples</code></td>
<td>
<p>Number of samples to use for consensus generation or
missing edge prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>consensus_tree()</code> returns a list of two objects. The first
is an <code>igraphHRGConsensus</code> object, the second is an
<code>igraphHRG</code> object.  The <code>igraphHRGConsensus</code> object has the
following members:
</p>
<table>
<tr><td><code>parents</code></td>
<td>
<p>For each vertex, the id of its parent vertex is stored,
or zero, if the vertex is the root vertex in the tree. The first n
vertex ids (from 0) refer to the original vertices of the graph, the
other ids refer to vertex groups.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Numeric vector, counts the number of times a given tree
split occurred in the generated network samples, for each internal
vertices. The order is the same as in the <code>parents</code> vector.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+fit_hrg">fit_hrg</a>()</code>,
<code><a href="#topic+hrg">hrg</a>()</code>,
<code><a href="#topic+hrg-methods">hrg-methods</a></code>,
<code><a href="#topic+hrg_tree">hrg_tree</a>()</code>,
<code><a href="#topic+predict_edges">predict_edges</a>()</code>,
<code><a href="#topic+print.igraphHRG">print.igraphHRG</a>()</code>,
<code><a href="#topic+print.igraphHRGConsensus">print.igraphHRGConsensus</a>()</code>,
<code><a href="#topic+sample_hrg">sample_hrg</a>()</code>
</p>

<hr>
<h2 id='console'>The igraph console</h2><span id='topic+console'></span><span id='topic+.igraph.progress'></span><span id='topic+.igraph.status'></span>

<h3>Description</h3>

<p>The igraph console is a GUI window that shows what the currently running
igraph function is doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>console()

.igraph.progress(percent, message, clean = FALSE)

.igraph.status(message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="console_+3A_percent">percent</code>, <code id="console_+3A_message">message</code>, <code id="console_+3A_clean">clean</code></td>
<td>
<p>Used internally by <code>.igraph.progress()</code> and <code>.igraph.status()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The console can be started by calling the <code>console()</code> function.
Then it stays open, until the user closes it.
</p>
<p>Another way to start it to set the <code>verbose</code> igraph option to
&ldquo;tkconsole&rdquo; via <code>igraph_options()</code>. Then the console (re)opens
each time an igraph function supporting it starts; to close it, set the
<code>verbose</code> option to another value.
</p>
<p>The console is written in Tcl/Tk and required the <code>tcltk</code> package.
</p>


<h3>Value</h3>

<p><code>NULL</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+igraph_options">igraph_options()</a></code> and the <code>verbose</code> option.
</p>

<hr>
<h2 id='constraint'>Burt's constraint</h2><span id='topic+constraint'></span>

<h3>Description</h3>

<p>Given a graph, <code>constraint()</code> calculates Burt's constraint for each
vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraint(graph, nodes = V(graph), weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraint_+3A_graph">graph</code></td>
<td>
<p>A graph object, the input graph.</p>
</td></tr>
<tr><td><code id="constraint_+3A_nodes">nodes</code></td>
<td>
<p>The vertices for which the constraint will be calculated.
Defaults to all vertices.</p>
</td></tr>
<tr><td><code id="constraint_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. If this is <code>NULL</code> and there is
a <code>weight</code> edge attribute this is used. If there is no such edge
attribute all edges will have the same weight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Burt's constraint is higher if ego has less, or mutually
stronger related (i.e. more redundant) contacts. Burt's measure of
constraint, <code class="reqn">C_i</code>, of vertex <code class="reqn">i</code>'s ego network
<code class="reqn">V_i</code>, is defined for directed and valued graphs,
</p>
<p style="text-align: center;"><code class="reqn">C_i=\sum_{j \in V_i \setminus \{i\}} (p_{ij}+\sum_{q \in V_i
    \setminus \{i,j\}} p_{iq} p_{qj})^2</code>
</p>

<p>for a graph of order (i.e. number of vertices) <code class="reqn">N</code>, where
proportional tie strengths are defined as
</p>
<p style="text-align: center;"><code class="reqn">p_{ij} = \frac{a_{ij}+a_{ji}}{\sum_{k \in V_i \setminus \{i\}}(a_{ik}+a_{ki})},</code>
</p>

<p><code class="reqn">a_{ij}</code> are elements of <code class="reqn">A</code> and the latter being the
graph adjacency matrix. For isolated vertices, constraint is undefined.
</p>


<h3>Value</h3>

<p>A numeric vector of constraint scores
</p>


<h3>Author(s)</h3>

<p>Jeroen Bruggeman
(<a href="https://sites.google.com/site/jebrug/jeroen-bruggeman-social-science">https://sites.google.com/site/jebrug/jeroen-bruggeman-social-science</a>)
and Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Burt, R.S. (2004). Structural holes and good ideas.
<em>American Journal of Sociology</em> 110, 349-399.
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(20, 5 / 20)
constraint(g)

</code></pre>

<hr>
<h2 id='contract'>Contract several vertices into a single one</h2><span id='topic+contract'></span>

<h3>Description</h3>

<p>This function creates a new graph, by merging several vertices into one. The
vertices in the new graph correspond to sets of vertices in the input graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract(graph, mapping, vertex.attr.comb = igraph_opt("vertex.attr.comb"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contract_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected.</p>
</td></tr>
<tr><td><code id="contract_+3A_mapping">mapping</code></td>
<td>
<p>A numeric vector that specifies the mapping. Its elements
correspond to the vertices, and for each element the id in the new graph is
given.</p>
</td></tr>
<tr><td><code id="contract_+3A_vertex.attr.comb">vertex.attr.comb</code></td>
<td>
<p>Specifies how to combine the vertex attributes in
the new graph. Please see <code><a href="#topic+attribute.combination">attribute.combination()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The attributes of the graph are kept. Graph and edge attributes are
unchanged, vertex attributes are combined, according to the
<code>vertex.attr.comb</code> parameter.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
g$name &lt;- "Ring"
V(g)$name &lt;- letters[1:vcount(g)]
E(g)$weight &lt;- runif(ecount(g))

g2 &lt;- contract(g, rep(1:5, each = 2),
  vertex.attr.comb = toString
)

## graph and edge attributes are kept, vertex attributes are
## combined using the 'toString' function.
print(g2, g = TRUE, v = TRUE, e = TRUE)

</code></pre>

<hr>
<h2 id='contract.vertices'>Contract several vertices into a single one</h2><span id='topic+contract.vertices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>contract.vertices()</code> was renamed to <code>contract()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract.vertices(
  graph,
  mapping,
  vertex.attr.comb = igraph_opt("vertex.attr.comb")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contract.vertices_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected.</p>
</td></tr>
<tr><td><code id="contract.vertices_+3A_mapping">mapping</code></td>
<td>
<p>A numeric vector that specifies the mapping. Its elements
correspond to the vertices, and for each element the id in the new graph is
given.</p>
</td></tr>
<tr><td><code id="contract.vertices_+3A_vertex.attr.comb">vertex.attr.comb</code></td>
<td>
<p>Specifies how to combine the vertex attributes in
the new graph. Please see <code><a href="#topic+attribute.combination">attribute.combination()</a></code> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='convex_hull'>Convex hull of a set of vertices</h2><span id='topic+convex_hull'></span>

<h3>Description</h3>

<p>Calculate the convex hull of a set of points, i.e. the covering polygon that
has the smallest area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convex_hull(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convex_hull_+3A_data">data</code></td>
<td>
<p>The data points, a numeric matrix with two columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with components: </p>
<table>
<tr><td><code>resverts</code></td>
<td>
<p>The indices of the
input vertices that constritute the convex hull.</p>
</td></tr> <tr><td><code>rescoords</code></td>
<td>
<p>The
coordinates of the corners of the convex hull.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and
Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and
McGraw-Hill, 2001. ISBN 0262032937. Pages 949-955 of section 33.3: Finding
the convex hull.
</p>


<h3>See Also</h3>

<p>Other other: 
<code><a href="#topic+running_mean">running_mean</a>()</code>,
<code><a href="#topic+sample_seq">sample_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
M &lt;- cbind(runif(100), runif(100))
convex_hull(M)
</code></pre>

<hr>
<h2 id='convex.hull'>Convex hull of a set of vertices</h2><span id='topic+convex.hull'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>convex.hull()</code> was renamed to <code>convex_hull()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convex.hull(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convex.hull_+3A_data">data</code></td>
<td>
<p>The data points, a numeric matrix with two columns.</p>
</td></tr>
</table>

<hr>
<h2 id='coreness'>K-core decomposition of graphs</h2><span id='topic+coreness'></span>

<h3>Description</h3>

<p>The k-core of graph is a maximal subgraph in which each vertex has at least
degree k. The coreness of a vertex is k if it belongs to the k-core but not
to the (k+1)-core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coreness(graph, mode = c("all", "out", "in"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coreness_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected</p>
</td></tr>
<tr><td><code id="coreness_+3A_mode">mode</code></td>
<td>
<p>The type of the core in directed graphs. Character constant,
possible values: <code style="white-space: pre;">&#8288;in&#8288;</code>: in-cores are computed, <code>out</code>: out-cores are
computed, <code>all</code>: the corresponding undirected graph is considered. This
argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-core of a graph is the maximal subgraph in which every vertex has at
least degree k. The cores of a graph form layers: the (k+1)-core is always a
subgraph of the k-core.
</p>
<p>This function calculates the coreness for each vertex.
</p>


<h3>Value</h3>

<p>Numeric vector of integer numbers giving the coreness of each
vertex.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Vladimir Batagelj, Matjaz Zaversnik: An O(m) Algorithm for Cores
Decomposition of Networks, 2002
</p>
<p>Seidman S. B. (1983) Network structure and minimum degree, <em>Social
Networks</em>, 5, 269&ndash;287.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degree">degree()</a></code>
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
g &lt;- add_edges(g, c(1, 2, 2, 3, 1, 3))
coreness(g) # small core triangle in a ring

</code></pre>

<hr>
<h2 id='count_automorphisms'>Number of automorphisms</h2><span id='topic+count_automorphisms'></span>

<h3>Description</h3>

<p>Calculate the number of automorphisms of a graph, i.e. the number of
isomorphisms to itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_automorphisms(
  graph,
  colors = NULL,
  sh = c("fm", "f", "fs", "fl", "flm", "fsm")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_automorphisms_+3A_graph">graph</code></td>
<td>
<p>The input graph, it is treated as undirected.</p>
</td></tr>
<tr><td><code id="count_automorphisms_+3A_colors">colors</code></td>
<td>
<p>The colors of the individual vertices of the graph; only
vertices having the same color are allowed to match each other in an
automorphism. When omitted, igraph uses the <code>color</code> attribute of the
vertices, or, if there is no such vertex attribute, it simply assumes that
all vertices have the same color. Pass NULL explicitly if the graph has a
<code>color</code> vertex attribute but you do not want to use it.</p>
</td></tr>
<tr><td><code id="count_automorphisms_+3A_sh">sh</code></td>
<td>
<p>The splitting heuristics for the BLISS algorithm. Possible values
are: &lsquo;<code>f</code>&rsquo;: first non-singleton cell, &lsquo;<code>fl</code>&rsquo;: first
largest non-singleton cell, &lsquo;<code>fs</code>&rsquo;: first smallest non-singleton
cell, &lsquo;<code>fm</code>&rsquo;: first maximally non-trivially connected
non-singleton cell, &lsquo;<code>flm</code>&rsquo;: first largest maximally
non-trivially connected non-singleton cell, &lsquo;<code>fsm</code>&rsquo;: first
smallest maximally non-trivially connected non-singleton cell.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An automorphism of a graph is a permutation of its vertices which brings the
graph into itself.
</p>
<p>This function calculates the number of automorphism of a graph using the
BLISS algorithm. See also the BLISS homepage at
<a href="http://www.tcs.hut.fi/Software/bliss/index.html">http://www.tcs.hut.fi/Software/bliss/index.html</a>. If you need the
automorphisms themselves, use <code><a href="#topic+automorphism_group">automorphism_group()</a></code> to obtain
a compact representation of the automorphism group.
</p>


<h3>Value</h3>

<p>A named list with the following members: </p>
<table>
<tr><td><code>group_size</code></td>
<td>
<p>The size
of the automorphism group of the input graph, as a string. This number is
exact if igraph was compiled with the GMP library, and approximate
otherwise.</p>
</td></tr> <tr><td><code>nof_nodes</code></td>
<td>
<p>The number of nodes in the search tree.</p>
</td></tr>
<tr><td><code>nof_leaf_nodes</code></td>
<td>
<p>The number of leaf nodes in the search tree.</p>
</td></tr>
<tr><td><code>nof_bad_nodes</code></td>
<td>
<p>Number of bad nodes.</p>
</td></tr> <tr><td><code>nof_canupdates</code></td>
<td>
<p>Number of
canrep updates.</p>
</td></tr> <tr><td><code>max_level</code></td>
<td>
<p>Maximum level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tommi Junttila (<a href="http://users.ics.aalto.fi/tjunttil/">http://users.ics.aalto.fi/tjunttil/</a>) for BLISS
and Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the igraph glue code
and this manual page.
</p>


<h3>References</h3>

<p>Tommi Junttila and Petteri Kaski: Engineering an Efficient
Canonical Labeling Tool for Large and Sparse Graphs, <em>Proceedings of
the Ninth Workshop on Algorithm Engineering and Experiments and the Fourth
Workshop on Analytic Algorithms and Combinatorics.</em> 2007.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+canonical_permutation">canonical_permutation()</a></code>, <code><a href="#topic+permute">permute()</a></code>,
and <code><a href="#topic+automorphism_group">automorphism_group()</a></code> for a compact representation of all
automorphisms
</p>
<p>Other graph automorphism: 
<code><a href="#topic+automorphism_group">automorphism_group</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A ring has n*2 automorphisms, you can "turn" it by 0-9 vertices
## and each of these graphs can be "flipped"
g &lt;- make_ring(10)
count_automorphisms(g)

## A full graph has n! automorphisms; however, we restrict the vertex
## matching by colors, leading to only 4 automorphisms
g &lt;- make_full_graph(4)
count_automorphisms(g, colors = c(1, 2, 1, 2))
</code></pre>

<hr>
<h2 id='count_isomorphisms'>Count the number of isomorphic mappings between two graphs</h2><span id='topic+count_isomorphisms'></span><span id='topic+graph.count.isomorphisms.vf2'></span>

<h3>Description</h3>

<p>Count the number of isomorphic mappings between two graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_isomorphisms(graph1, graph2, method = "vf2", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_isomorphisms_+3A_graph1">graph1</code></td>
<td>
<p>The first graph.</p>
</td></tr>
<tr><td><code id="count_isomorphisms_+3A_graph2">graph2</code></td>
<td>
<p>The second graph.</p>
</td></tr>
<tr><td><code id="count_isomorphisms_+3A_method">method</code></td>
<td>
<p>Currently only &lsquo;vf2&rsquo; is supported, see
<code><a href="#topic+isomorphic">isomorphic()</a></code> for details about it and extra arguments.</p>
</td></tr>
<tr><td><code id="count_isomorphisms_+3A_...">...</code></td>
<td>
<p>Passed to the individual methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of isomorphic mappings between the two graphs.
</p>


<h3>References</h3>

<p>LP Cordella,  P Foggia, C Sansone, and M Vento: An improved algorithm
for matching large graphs, <em>Proc. of the 3rd IAPR TC-15 Workshop
on Graphbased Representations in Pattern Recognition</em>, 149&ndash;159, 2001.
</p>


<h3>See Also</h3>

<p>Other graph isomorphism: 
<code><a href="#topic+canonical_permutation">canonical_permutation</a>()</code>,
<code><a href="#topic+count_subgraph_isomorphisms">count_subgraph_isomorphisms</a>()</code>,
<code><a href="#topic+graph_from_isomorphism_class">graph_from_isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphic">isomorphic</a>()</code>,
<code><a href="#topic+isomorphism_class">isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphisms">isomorphisms</a>()</code>,
<code><a href="#topic+subgraph_isomorphic">subgraph_isomorphic</a>()</code>,
<code><a href="#topic+subgraph_isomorphisms">subgraph_isomorphisms</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># colored graph isomorphism
g1 &lt;- make_ring(10)
g2 &lt;- make_ring(10)
isomorphic(g1, g2)

V(g1)$color &lt;- rep(1:2, length = vcount(g1))
V(g2)$color &lt;- rep(2:1, length = vcount(g2))
# consider colors by default
count_isomorphisms(g1, g2)
# ignore colors
count_isomorphisms(g1, g2,
  vertex.color1 = NULL,
  vertex.color2 = NULL
)
</code></pre>

<hr>
<h2 id='count_motifs'>Graph motifs</h2><span id='topic+count_motifs'></span>

<h3>Description</h3>

<p>Graph motifs are small connected induced subgraphs with a well-defined
structure.  These functions search a graph for various motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_motifs(graph, size = 3, cut.prob = rep(0, size))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_motifs_+3A_graph">graph</code></td>
<td>
<p>Graph object, the input graph.</p>
</td></tr>
<tr><td><code id="count_motifs_+3A_size">size</code></td>
<td>
<p>The size of the motif.</p>
</td></tr>
<tr><td><code id="count_motifs_+3A_cut.prob">cut.prob</code></td>
<td>
<p>Numeric vector giving the probabilities that the search
graph is cut at a certain level. Its length should be the same as the size
of the motif (the <code>size</code> argument). By default no cuts are made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>count_motifs()</code> calculates the total number of motifs of a given
size in graph.
</p>


<h3>Value</h3>

<p><code>count_motifs()</code> returns  a numeric scalar.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isomorphism_class">isomorphism_class()</a></code>
</p>
<p>Other graph motifs: 
<code><a href="#topic+dyad_census">dyad_census</a>()</code>,
<code><a href="#topic+motifs">motifs</a>()</code>,
<code><a href="#topic+sample_motifs">sample_motifs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_pa(100)
motifs(g, 3)
count_motifs(g, 3)
sample_motifs(g, 3)
</code></pre>

<hr>
<h2 id='count_subgraph_isomorphisms'>Count the isomorphic mappings between a graph and the subgraphs of
another graph</h2><span id='topic+count_subgraph_isomorphisms'></span><span id='topic+graph.count.subisomorphisms.vf2'></span>

<h3>Description</h3>

<p>Count the isomorphic mappings between a graph and the subgraphs of
another graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_subgraph_isomorphisms(pattern, target, method = c("lad", "vf2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_subgraph_isomorphisms_+3A_pattern">pattern</code></td>
<td>
<p>The smaller graph, it might be directed or
undirected. Undirected graphs are treated as directed graphs with
mutual edges.</p>
</td></tr>
<tr><td><code id="count_subgraph_isomorphisms_+3A_target">target</code></td>
<td>
<p>The bigger graph, it might be directed or
undirected. Undirected graphs are treated as directed graphs with
mutual edges.</p>
</td></tr>
<tr><td><code id="count_subgraph_isomorphisms_+3A_method">method</code></td>
<td>
<p>The method to use. Possible values:
&lsquo;lad&rsquo;, &lsquo;vf2&rsquo;. See their details below.</p>
</td></tr>
<tr><td><code id="count_subgraph_isomorphisms_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the various methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical scalar, <code>TRUE</code> if the <code>pattern</code> is
isomorphic to a (possibly induced) subgraph of <code>target</code>.
</p>


<h3>&lsquo;lad&rsquo; method</h3>

<p>This is the LAD algorithm by Solnon, see the reference below. It has
the following extra arguments:
</p>

<dl>
<dt>domains</dt><dd><p>If not <code>NULL</code>, then it specifies matching
restrictions. It must be a list of <code>target</code> vertex sets, given
as numeric vertex ids or symbolic vertex names. The length of the
list must be <code>vcount(pattern)</code> and for each vertex in
<code>pattern</code> it gives the allowed matching vertices in
<code>target</code>. Defaults to <code>NULL</code>.</p>
</dd>
<dt>induced</dt><dd><p>Logical scalar, whether to search for an induced
subgraph. It is <code>FALSE</code> by default.</p>
</dd>
<dt>time.limit</dt><dd><p>The processor time limit for the computation, in
seconds. It defaults to <code>Inf</code>, which means no limit.</p>
</dd>
</dl>



<h3>&lsquo;vf2&rsquo; method</h3>

<p>This method uses the VF2 algorithm by Cordella, Foggia et al., see
references below. It supports vertex and edge colors and have the
following extra arguments:
</p>

<dl>
<dt>vertex.color1, vertex.color2</dt><dd><p>Optional integer vectors giving the
colors of the vertices for colored graph isomorphism. If they
are not given, but the graph has a &ldquo;color&rdquo; vertex attribute,
then it will be used. If you want to ignore these attributes, then
supply <code>NULL</code> for both of these arguments. See also examples
below.</p>
</dd>
<dt>edge.color1, edge.color2</dt><dd><p>Optional integer vectors giving the
colors of the edges for edge-colored (sub)graph isomorphism. If they
are not given, but the graph has a &ldquo;color&rdquo; edge attribute,
then it will be used. If you want to ignore these attributes, then
supply <code>NULL</code> for both of these arguments.</p>
</dd>
</dl>



<h3>References</h3>

<p>LP Cordella,  P Foggia, C Sansone, and M Vento: An improved algorithm
for matching large graphs, <em>Proc. of the 3rd IAPR TC-15 Workshop
on Graphbased Representations in Pattern Recognition</em>, 149&ndash;159, 2001.
</p>
<p>C. Solnon: AllDifferent-based Filtering for Subgraph Isomorphism,
<em>Artificial Intelligence</em> 174(12-13):850&ndash;864, 2010.
</p>


<h3>See Also</h3>

<p>Other graph isomorphism: 
<code><a href="#topic+canonical_permutation">canonical_permutation</a>()</code>,
<code><a href="#topic+count_isomorphisms">count_isomorphisms</a>()</code>,
<code><a href="#topic+graph_from_isomorphism_class">graph_from_isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphic">isomorphic</a>()</code>,
<code><a href="#topic+isomorphism_class">isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphisms">isomorphisms</a>()</code>,
<code><a href="#topic+subgraph_isomorphic">subgraph_isomorphic</a>()</code>,
<code><a href="#topic+subgraph_isomorphisms">subgraph_isomorphisms</a>()</code>
</p>

<hr>
<h2 id='count.multiple'>Find the multiple or loop edges in a graph</h2><span id='topic+count.multiple'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>count.multiple()</code> was renamed to <code>count_multiple()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count.multiple(graph, eids = E(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count.multiple_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="count.multiple_+3A_eids">eids</code></td>
<td>
<p>The edges to which the query is restricted. By default this is
all edges in the graph.</p>
</td></tr>
</table>

<hr>
<h2 id='create.communities'>Creates a communities object.</h2><span id='topic+create.communities'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>create.communities()</code> was renamed to <code>make_clusters()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.communities(
  graph,
  membership = NULL,
  algorithm = NULL,
  merges = NULL,
  modularity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.communities_+3A_graph">graph</code></td>
<td>
<p>The graph of the community structure.</p>
</td></tr>
<tr><td><code id="create.communities_+3A_membership">membership</code></td>
<td>
<p>The membership vector of the community structure, a
numeric vector denoting the id of the community for each vertex. It
might be <code>NULL</code> for hierarchical community structures.</p>
</td></tr>
<tr><td><code id="create.communities_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string, the algorithm that generated
the community structure, it can be arbitrary.</p>
</td></tr>
<tr><td><code id="create.communities_+3A_merges">merges</code></td>
<td>
<p>A merge matrix, for hierarchical community structures (or
<code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code id="create.communities_+3A_modularity">modularity</code></td>
<td>
<p>Modularity value of the community structure. If this
is <code>TRUE</code> and the membership vector is available, then it the
modularity values is calculated automatically.</p>
</td></tr>
</table>

<hr>
<h2 id='curve_multiple'>Optimal edge curvature when plotting graphs</h2><span id='topic+curve_multiple'></span>

<h3>Description</h3>

<p>If graphs have multiple edges, then drawing them as straight lines does not
show them when plotting the graphs; they will be on top of each other. One
solution is to bend the edges, with diffenent curvature, so that all of them
are visible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curve_multiple(graph, start = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curve_multiple_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="curve_multiple_+3A_start">start</code></td>
<td>
<p>The curvature at the two extreme edges. All edges will have a
curvature between <code>-start</code> and <code>start</code>, spaced equally.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>curve_multiple()</code> calculates the optimal <code>edge.curved</code> vector for
plotting a graph with multiple edges, so that all edges are visible.
</p>


<h3>Value</h3>

<p>A numeric vector, its length is the number of edges in the graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+igraph.plotting">igraph.plotting</a> for all plotting parameters,
<code><a href="#topic+plot.igraph">plot.igraph()</a></code>, <code><a href="#topic+tkplot">tkplot()</a></code> and <code><a href="#topic+rglplot">rglplot()</a></code>
for plotting functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph(c(
  0, 1, 1, 0, 1, 2, 1, 3, 1, 3, 1, 3,
  2, 3, 2, 3, 2, 3, 2, 3, 0, 1
) + 1)

curve_multiple(g)

set.seed(42)
plot(g)

</code></pre>

<hr>
<h2 id='cutat'>Functions to deal with the result of network community detection</h2><span id='topic+cutat'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>cutat()</code> was renamed to <code>cut_at()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutat(communities, no, steps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutat_+3A_no">no</code></td>
<td>
<p>Integer scalar, the desired number of communities. If too low or
two high, then an error message is given. Exactly one of <code>no</code> and
<code>steps</code> must be supplied.</p>
</td></tr>
<tr><td><code id="cutat_+3A_steps">steps</code></td>
<td>
<p>The number of merge operations to perform to produce the
communities. Exactly one of <code>no</code> and <code>steps</code> must be supplied.</p>
</td></tr>
</table>

<hr>
<h2 id='decompose'>Decompose a graph into components</h2><span id='topic+decompose'></span>

<h3>Description</h3>

<p>Creates a separate graph for each connected component of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompose(graph, mode = c("weak", "strong"), max.comps = NA, min.vertices = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decompose_+3A_graph">graph</code></td>
<td>
<p>The original graph.</p>
</td></tr>
<tr><td><code id="decompose_+3A_mode">mode</code></td>
<td>
<p>Character constant giving the type of the components, wither
<code>weak</code> for weakly connected components or <code>strong</code> for strongly
connected components.</p>
</td></tr>
<tr><td><code id="decompose_+3A_max.comps">max.comps</code></td>
<td>
<p>The maximum number of components to return. The first
<code>max.comps</code> components will be returned (which hold at least
<code>min.vertices</code> vertices, see the next parameter), the others will be
ignored. Supply <code>NA</code> here if you don't want to limit the number of
components.</p>
</td></tr>
<tr><td><code id="decompose_+3A_min.vertices">min.vertices</code></td>
<td>
<p>The minimum number of vertices a component should
contain in order to place it in the result list. E.g. supply 2 here to ignore
isolate vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of graph objects.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_connected">is_connected()</a></code> to decide whether a graph is connected,
<code><a href="#topic+components">components()</a></code> to calculate the connected components of a graph.
</p>
<p>Connected components
<code><a href="#topic+articulation_points">articulation_points</a>()</code>,
<code><a href="#topic+biconnected_components">biconnected_components</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+is_biconnected">is_biconnected</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the diameter of each component in a random graph
g &lt;- sample_gnp(1000, 1 / 1000)
components &lt;- decompose(g, min.vertices = 2)
sapply(components, diameter)

</code></pre>

<hr>
<h2 id='decompose.graph'>Decompose a graph into components</h2><span id='topic+decompose.graph'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>decompose.graph()</code> was renamed to <code>decompose()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decompose.graph(
  graph,
  mode = c("weak", "strong"),
  max.comps = NA,
  min.vertices = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decompose.graph_+3A_graph">graph</code></td>
<td>
<p>The original graph.</p>
</td></tr>
<tr><td><code id="decompose.graph_+3A_mode">mode</code></td>
<td>
<p>Character constant giving the type of the components, wither
<code>weak</code> for weakly connected components or <code>strong</code> for strongly
connected components.</p>
</td></tr>
<tr><td><code id="decompose.graph_+3A_max.comps">max.comps</code></td>
<td>
<p>The maximum number of components to return. The first
<code>max.comps</code> components will be returned (which hold at least
<code>min.vertices</code> vertices, see the next parameter), the others will be
ignored. Supply <code>NA</code> here if you don't want to limit the number of
components.</p>
</td></tr>
<tr><td><code id="decompose.graph_+3A_min.vertices">min.vertices</code></td>
<td>
<p>The minimum number of vertices a component should
contain in order to place it in the result list. E.g. supply 2 here to ignore
isolate vertices.</p>
</td></tr>
</table>

<hr>
<h2 id='degree'>Degree and degree distribution of the vertices</h2><span id='topic+degree'></span><span id='topic+degree_distribution'></span>

<h3>Description</h3>

<p>The degree of a vertex is its most basic structural property, the number of
its adjacent edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree(
  graph,
  v = V(graph),
  mode = c("all", "out", "in", "total"),
  loops = TRUE,
  normalized = FALSE
)

degree_distribution(graph, cumulative = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="degree_+3A_v">v</code></td>
<td>
<p>The ids of vertices of which the degree will be calculated.</p>
</td></tr>
<tr><td><code id="degree_+3A_mode">mode</code></td>
<td>
<p>Character string, &ldquo;out&rdquo; for out-degree, &ldquo;in&rdquo; for
in-degree or &ldquo;total&rdquo; for the sum of the two. For undirected graphs
this argument is ignored. &ldquo;all&rdquo; is a synonym of &ldquo;total&rdquo;.</p>
</td></tr>
<tr><td><code id="degree_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
<tr><td><code id="degree_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to normalize the degree.  If
<code>TRUE</code> then the result is divided by <code class="reqn">n-1</code>, where <code class="reqn">n</code> is the
number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="degree_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical; whether the cumulative degree distribution is to
be calculated.</p>
</td></tr>
<tr><td><code id="degree_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>degree()</code>, e.g. <code>mode</code>
is useful but also <code>v</code> and <code>loops</code> make sense.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>degree()</code> a numeric vector of the same length as argument
<code>v</code>.
</p>
<p>For <code>degree_distribution()</code> a numeric vector of the same length as the
maximum degree plus one. The first element is the relative frequency zero
degree vertices, the second vertices with degree one, etc.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
degree(g)
g2 &lt;- sample_gnp(1000, 10 / 1000)
degree_distribution(g2)

</code></pre>

<hr>
<h2 id='degree.distribution'>Degree and degree distribution of the vertices</h2><span id='topic+degree.distribution'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>degree.distribution()</code> was renamed to <code>degree_distribution()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree.distribution(graph, cumulative = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.distribution_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="degree.distribution_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical; whether the cumulative degree distribution is to
be calculated.</p>
</td></tr>
<tr><td><code id="degree.distribution_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>degree()</code>, e.g. <code>mode</code>
is useful but also <code>v</code> and <code>loops</code> make sense.</p>
</td></tr>
</table>

<hr>
<h2 id='degree.sequence.game'>Generate random graphs with a given degree sequence</h2><span id='topic+degree.sequence.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>degree.sequence.game()</code> was renamed to <code>sample_degseq()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree.sequence.game(
  out.deg,
  in.deg = NULL,
  method = c("simple", "vl", "simple.no.multiple", "simple.no.multiple.uniform")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="degree.sequence.game_+3A_out.deg">out.deg</code></td>
<td>
<p>Numeric vector, the sequence of degrees (for undirected
graphs) or out-degrees (for directed graphs). For undirected graphs its sum
should be even. For directed graphs its sum should be the same as the sum of
<code>in.deg</code>.</p>
</td></tr>
<tr><td><code id="degree.sequence.game_+3A_in.deg">in.deg</code></td>
<td>
<p>For directed graph, the in-degree sequence. By default this is
<code>NULL</code> and an undirected graph is created.</p>
</td></tr>
<tr><td><code id="degree.sequence.game_+3A_method">method</code></td>
<td>
<p>Character, the method for generating the graph. Right now the
&ldquo;simple&rdquo;, &ldquo;simple.no.multiple&rdquo; and &ldquo;vl&rdquo; methods are
implemented.</p>
</td></tr>
</table>

<hr>
<h2 id='delete_edge_attr'>Delete an edge attribute</h2><span id='topic+delete_edge_attr'></span>

<h3>Description</h3>

<p>Delete an edge attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_edge_attr(graph, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_edge_attr_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
<tr><td><code id="delete_edge_attr_+3A_name">name</code></td>
<td>
<p>The name of the edge attribute to delete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the specified edge attribute removed.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_edge_attr("name", value = LETTERS[1:10])
edge_attr_names(g)
g2 &lt;- delete_edge_attr(g, "name")
edge_attr_names(g2)
</code></pre>

<hr>
<h2 id='delete_edges'>Delete edges from a graph</h2><span id='topic+delete_edges'></span>

<h3>Description</h3>

<p>Delete edges from a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_edges(graph, edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_edges_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="delete_edges_+3A_edges">edges</code></td>
<td>
<p>The edges to remove, specified as an edge sequence. Typically
this is either a numeric vector containing edge IDs, or a character vector
containing the IDs or names of the source and target vertices, separated by
<code>|</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the edges removed.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  delete_edges(seq(1, 9, by = 2))
g

g &lt;- make_ring(10) %&gt;%
  delete_edges("10|1")
g

g &lt;- make_ring(5)
g &lt;- delete_edges(g, get.edge.ids(g, c(1, 5, 4, 5)))
g
</code></pre>

<hr>
<h2 id='delete_graph_attr'>Delete a graph attribute</h2><span id='topic+delete_graph_attr'></span>

<h3>Description</h3>

<p>Delete a graph attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_graph_attr(graph, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_graph_attr_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="delete_graph_attr_+3A_name">name</code></td>
<td>
<p>Name of the attribute to delete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the specified attribute removed.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
graph_attr_names(g)
g2 &lt;- delete_graph_attr(g, "name")
graph_attr_names(g2)
</code></pre>

<hr>
<h2 id='delete_vertex_attr'>Delete a vertex attribute</h2><span id='topic+delete_vertex_attr'></span>

<h3>Description</h3>

<p>Delete a vertex attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_vertex_attr(graph, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_vertex_attr_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
<tr><td><code id="delete_vertex_attr_+3A_name">name</code></td>
<td>
<p>The name of the vertex attribute to delete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the specified vertex attribute removed.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = LETTERS[1:10])
vertex_attr_names(g)
g2 &lt;- delete_vertex_attr(g, "name")
vertex_attr_names(g2)
</code></pre>

<hr>
<h2 id='delete_vertices'>Delete vertices from a graph</h2><span id='topic+delete_vertices'></span>

<h3>Description</h3>

<p>Delete vertices from a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_vertices(graph, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_vertices_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="delete_vertices_+3A_v">v</code></td>
<td>
<p>The vertices to remove, a vertex sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the vertices removed.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = LETTERS[1:10])
g
V(g)

g2 &lt;- delete_vertices(g, c(1, 5)) %&gt;%
  delete_vertices("B")
g2
V(g2)
</code></pre>

<hr>
<h2 id='delete.edges'>Delete edges from a graph</h2><span id='topic+delete.edges'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>delete.edges()</code> was renamed to <code>delete_edges()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.edges(graph, edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete.edges_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="delete.edges_+3A_edges">edges</code></td>
<td>
<p>The edges to remove, specified as an edge sequence. Typically
this is either a numeric vector containing edge IDs, or a character vector
containing the IDs or names of the source and target vertices, separated by
<code>|</code></p>
</td></tr>
</table>

<hr>
<h2 id='delete.vertices'>Delete vertices from a graph</h2><span id='topic+delete.vertices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>delete.vertices()</code> was renamed to <code>delete_vertices()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete.vertices(graph, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete.vertices_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="delete.vertices_+3A_v">v</code></td>
<td>
<p>The vertices to remove, a vertex sequence.</p>
</td></tr>
</table>

<hr>
<h2 id='dendPlot'>Community structure dendrogram plots</h2><span id='topic+dendPlot'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>dendPlot()</code> was renamed to <code>plot_dendrogram()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dendPlot(x, mode = igraph_opt("dend.plot.type"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dendPlot_+3A_x">x</code></td>
<td>
<p>An object containing the community structure of a graph. See
<code><a href="#topic+communities">communities()</a></code> for details.</p>
</td></tr>
<tr><td><code id="dendPlot_+3A_mode">mode</code></td>
<td>
<p>Which dendrogram plotting function to use. See details below.</p>
</td></tr>
<tr><td><code id="dendPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments to supply to the dendrogram plotting
function.</p>
</td></tr>
</table>

<hr>
<h2 id='dfs'>Depth-first search</h2><span id='topic+dfs'></span>

<h3>Description</h3>

<p>Depth-first search is an algorithm to traverse a graph. It starts from a
root vertex and tries to go quickly as far from as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfs(
  graph,
  root,
  mode = c("out", "in", "all", "total"),
  unreachable = TRUE,
  order = TRUE,
  order.out = FALSE,
  father = FALSE,
  dist = FALSE,
  in.callback = NULL,
  out.callback = NULL,
  extra = NULL,
  rho = parent.frame(),
  neimode
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfs_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="dfs_+3A_root">root</code></td>
<td>
<p>The single root vertex to start the search from.</p>
</td></tr>
<tr><td><code id="dfs_+3A_mode">mode</code></td>
<td>
<p>For directed graphs specifies the type of edges to follow.
&lsquo;out&rsquo; follows outgoing, &lsquo;in&rsquo; incoming edges. &lsquo;all&rsquo;
ignores edge directions completely. &lsquo;total&rsquo; is a synonym for
&lsquo;all&rsquo;. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="dfs_+3A_unreachable">unreachable</code></td>
<td>
<p>Logical scalar, whether the search should visit the
vertices that are unreachable from the given root vertex (or vertices). If
<code>TRUE</code>, then additional searches are performed until all vertices are
visited.</p>
</td></tr>
<tr><td><code id="dfs_+3A_order">order</code></td>
<td>
<p>Logical scalar, whether to return the DFS ordering of the
vertices.</p>
</td></tr>
<tr><td><code id="dfs_+3A_order.out">order.out</code></td>
<td>
<p>Logical scalar, whether to return the ordering based on
leaving the subtree of the vertex.</p>
</td></tr>
<tr><td><code id="dfs_+3A_father">father</code></td>
<td>
<p>Logical scalar, whether to return the father of the vertices.</p>
</td></tr>
<tr><td><code id="dfs_+3A_dist">dist</code></td>
<td>
<p>Logical scalar, whether to return the distance from the root of
the search tree.</p>
</td></tr>
<tr><td><code id="dfs_+3A_in.callback">in.callback</code></td>
<td>
<p>If not <code>NULL</code>, then it must be callback function.
This is called whenever a vertex is visited. See details below.</p>
</td></tr>
<tr><td><code id="dfs_+3A_out.callback">out.callback</code></td>
<td>
<p>If not <code>NULL</code>, then it must be callback function.
This is called whenever the subtree of a vertex is completed by the
algorithm. See details below.</p>
</td></tr>
<tr><td><code id="dfs_+3A_extra">extra</code></td>
<td>
<p>Additional argument to supply to the callback function.</p>
</td></tr>
<tr><td><code id="dfs_+3A_rho">rho</code></td>
<td>
<p>The environment in which the callback function is evaluated.</p>
</td></tr>
<tr><td><code id="dfs_+3A_neimode">neimode</code></td>
<td>
<p>This argument is deprecated from igraph 1.3.0; use
<code>mode</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The callback functions must have the following arguments: </p>

<dl>
<dt>graph</dt><dd><p>The input graph is passed to the callback function here.</p>
</dd>
<dt>data</dt><dd><p>A named numeric vector, with the following entries:
&lsquo;vid&rsquo;, the vertex that was just visited and &lsquo;dist&rsquo;, its
distance from the root of the search tree.</p>
</dd> <dt>extra</dt><dd><p>The extra
argument.</p>
</dd> </dl>
<p> The callback must return FALSE to continue the search or TRUE
to terminate it. See examples below on how to use the callback functions.
</p>


<h3>Value</h3>

<p>A named list with the following entries: </p>
<table>
<tr><td><code>root</code></td>
<td>
<p>Numeric scalar.
The root vertex that was used as the starting point of the search.</p>
</td></tr>
<tr><td><code>neimode</code></td>
<td>
<p>Character scalar. The <code>mode</code> argument of the function
call. Note that for undirected graphs this is always &lsquo;all&rsquo;,
irrespectively of the supplied value.</p>
</td></tr> <tr><td><code>order</code></td>
<td>
<p>Numeric vector. The
vertex ids, in the order in which they were visited by the search.</p>
</td></tr>
<tr><td><code>order.out</code></td>
<td>
<p>Numeric vector, the vertex ids, in the order of the
completion of their subtree.</p>
</td></tr> <tr><td><code>father</code></td>
<td>
<p>Numeric vector. The father of
each vertex, i.e. the vertex it was discovered from.</p>
</td></tr> <tr><td><code>dist</code></td>
<td>
<p>Numeric
vector, for each vertex its distance from the root of the search tree.</p>
</td></tr>
</table>
<p>Note that <code>order</code>, <code>order.out</code>, <code>father</code>, and <code>dist</code>
might be <code>NULL</code> if their corresponding argument is <code>FALSE</code>, i.e.
if their calculation is not requested.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bfs">bfs()</a></code> for breadth-first search.
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A graph with two separate trees
dfs(make_tree(10) %du% make_tree(10),
  root = 1, "out",
  TRUE, TRUE, TRUE, TRUE
)

## How to use a callback
f.in &lt;- function(graph, data, extra) {
  cat("in:", paste(collapse = ", ", data), "\n")
  FALSE
}
f.out &lt;- function(graph, data, extra) {
  cat("out:", paste(collapse = ", ", data), "\n")
  FALSE
}
tmp &lt;- dfs(make_tree(10),
  root = 1, "out",
  in.callback = f.in, out.callback = f.out
)

## Terminate after the first component, using a callback
f.out &lt;- function(graph, data, extra) {
  data["vid"] == 1
}
tmp &lt;- dfs(make_tree(10) %du% make_tree(10),
  root = 1,
  out.callback = f.out
)

</code></pre>

<hr>
<h2 id='diameter'>Diameter of a graph</h2><span id='topic+diameter'></span><span id='topic+get_diameter'></span><span id='topic+farthest_vertices'></span>

<h3>Description</h3>

<p>The diameter of a graph is the length of the longest geodesic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diameter(graph, directed = TRUE, unconnected = TRUE, weights = NULL)

get_diameter(graph, directed = TRUE, unconnected = TRUE, weights = NULL)

farthest_vertices(graph, directed = TRUE, unconnected = TRUE, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="diameter_+3A_directed">directed</code></td>
<td>
<p>Logical, whether directed or undirected paths are to be
considered. This is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="diameter_+3A_unconnected">unconnected</code></td>
<td>
<p>Logical, what to do if the graph is unconnected. If
FALSE, the function will return a number that is one larger the largest
possible diameter, which is always the number of vertices. If TRUE, the
diameters of the connected components will be calculated and the largest one
will be returned.</p>
</td></tr>
<tr><td><code id="diameter_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
distances. If the graph has a <code>weight</code> edge attribute, then this is
used by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diameter is calculated by using a breadth-first search like method.
</p>
<p><code>get_diameter()</code> returns a path with the actual diameter. If there are
many shortest paths of the length of the diameter, then it returns the first
one found.
</p>
<p><code>farthest_vertices()</code> returns two vertex ids, the vertices which are
connected by the diameter path.
</p>


<h3>Value</h3>

<p>A numeric constant for <code>diameter()</code>, a numeric vector for
<code>get_diameter()</code>. <code>farthest_vertices()</code> returns a list with two
entries: </p>

<ul>
<li> <p><code>vertices</code> The two vertices that are the farthest.
</p>
</li>
<li> <p><code>distance</code> Their distance.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distances">distances()</a></code>
</p>
<p>Other paths: 
<code><a href="#topic+all_simple_paths">all_simple_paths</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+eccentricity">eccentricity</a>()</code>,
<code><a href="#topic+radius">radius</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
g2 &lt;- delete_edges(g, c(1, 2, 1, 10))
diameter(g2, unconnected = TRUE)
diameter(g2, unconnected = FALSE)

## Weighted diameter
set.seed(1)
g &lt;- make_ring(10)
E(g)$weight &lt;- sample(seq_len(ecount(g)))
diameter(g)
get_diameter(g)
diameter(g, weights = NA)
get_diameter(g, weights = NA)

</code></pre>

<hr>
<h2 id='difference'>Difference of two sets</h2><span id='topic+difference'></span>

<h3>Description</h3>

<p>This is an S3 generic function. See <code>methods("difference")</code>
for the actual implementations for various S3 classes. Initially
it is implemented for igraph graphs (difference of edges in two graphs),
and igraph vertex and edge sequences. See
<code><a href="#topic+difference.igraph">difference.igraph()</a></code>, and
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difference(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference_+3A_...">...</code></td>
<td>
<p>Arguments, their number and interpretation depends on
the function that implements <code>difference()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the function that implements this method.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>

<hr>
<h2 id='difference.igraph'>Difference of graphs</h2><span id='topic+difference.igraph'></span><span id='topic++25m+25'></span>

<h3>Description</h3>

<p>The difference of two graphs are created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
difference(big, small, byname = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference.igraph_+3A_big">big</code></td>
<td>
<p>The left hand side argument of the minus operator. A directed or
undirected graph.</p>
</td></tr>
<tr><td><code id="difference.igraph_+3A_small">small</code></td>
<td>
<p>The right hand side argument of the minus operator. A directed
ot undirected graph.</p>
</td></tr>
<tr><td><code id="difference.igraph_+3A_byname">byname</code></td>
<td>
<p>A logical scalar, or the character scalar <code>auto</code>. Whether
to perform the operation based on symbolic vertex names. If it is
<code>auto</code>, that means <code>TRUE</code> if both graphs are named and
<code>FALSE</code> otherwise. A warning is generated if <code>auto</code> and one graph,
but not both graphs are named.</p>
</td></tr>
<tr><td><code id="difference.igraph_+3A_...">...</code></td>
<td>
<p>Ignored, included for S3 compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>difference()</code> creates the difference of two graphs. Only edges
present in the first graph but not in the second will be be included in the
new graph. The corresponding operator is <code style="white-space: pre;">&#8288;%m%&#8288;</code>.
</p>
<p>If the <code>byname</code> argument is <code>TRUE</code> (or <code>auto</code> and the graphs
are all named), then the operation is performed based on symbolic vertex
names. Otherwise numeric vertex ids are used.
</p>
<p><code>difference()</code> keeps all attributes (graph, vertex and edge) of the
first graph.
</p>
<p>Note that <code>big</code> and <code>small</code> must both be directed or both be
undirected, otherwise an error message is given.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create a wheel graph
wheel &lt;- union(
  make_ring(10),
  make_star(11, center = 11, mode = "undirected")
)
V(wheel)$name &lt;- letters[seq_len(vcount(wheel))]

## Subtract a star graph from it
sstar &lt;- make_star(6, center = 6, mode = "undirected")
V(sstar)$name &lt;- letters[c(1, 3, 5, 7, 9, 11)]
G &lt;- wheel %m% sstar
print_all(G)
plot(G, layout = layout_nicely(wheel))
</code></pre>

<hr>
<h2 id='difference.igraph.es'>Difference of edge sequences</h2><span id='topic+difference.igraph.es'></span>

<h3>Description</h3>

<p>Difference of edge sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
difference(big, small, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference.igraph.es_+3A_big">big</code></td>
<td>
<p>The &lsquo;big&rsquo; edge sequence.</p>
</td></tr>
<tr><td><code id="difference.igraph.es_+3A_small">small</code></td>
<td>
<p>The &lsquo;small&rsquo; edge sequence.</p>
</td></tr>
<tr><td><code id="difference.igraph.es_+3A_...">...</code></td>
<td>
<p>Ignored, included for S3 signature compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They must belong to the same graph. Note that this function has
&lsquo;set&rsquo; semantics and the multiplicity of edges is lost in the
result.
</p>


<h3>Value</h3>

<p>An edge sequence that contains only edges that are part of
<code>big</code>, but not part of <code>small</code>.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
difference(V(g), V(g)[6:10])
</code></pre>

<hr>
<h2 id='difference.igraph.vs'>Difference of vertex sequences</h2><span id='topic+difference.igraph.vs'></span>

<h3>Description</h3>

<p>Difference of vertex sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
difference(big, small, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difference.igraph.vs_+3A_big">big</code></td>
<td>
<p>The &lsquo;big&rsquo; vertex sequence.</p>
</td></tr>
<tr><td><code id="difference.igraph.vs_+3A_small">small</code></td>
<td>
<p>The &lsquo;small&rsquo; vertex sequence.</p>
</td></tr>
<tr><td><code id="difference.igraph.vs_+3A_...">...</code></td>
<td>
<p>Ignored, included for S3 signature compatibility.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They must belong to the same graph. Note that this function has
&lsquo;set&rsquo; semantics and the multiplicity of vertices is lost in the
result.
</p>


<h3>Value</h3>

<p>A vertex sequence that contains only vertices that are part of
<code>big</code>, but not part of <code>small</code>.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
difference(V(g), V(g)[6:10])
</code></pre>

<hr>
<h2 id='dim_select'>Dimensionality selection for singular values using profile likelihood.</h2><span id='topic+dim_select'></span>

<h3>Description</h3>

<p>Select the number of significant singular values, by finding the
&lsquo;elbow&rsquo; of the scree plot, in a principled way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dim_select(sv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim_select_+3A_sv">sv</code></td>
<td>
<p>A numeric vector, the ordered singular values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input of the function is a numeric vector which contains the measure of
&lsquo;importance&rsquo; for each dimension.
</p>
<p>For spectral embedding, these are the singular values of the adjacency
matrix. The singular values are assumed to be generated from a Gaussian
mixture distribution with two components that have different means and same
variance. The dimensionality <code class="reqn">d</code> is chosen to maximize the likelihood
when the <code class="reqn">d</code> largest singular values are assigned to one component of
the mixture and the rest of the singular values assigned to the other
component.
</p>
<p>This function can also be used for the general separation problem, where we
assume that the left and the right of the vector are coming from two Normal
distributions, with different means, and we want to know their border. See
examples below.
</p>


<h3>Value</h3>

<p>A numeric scalar, the estimate of <code class="reqn">d</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>M. Zhu, and A. Ghodsi (2006). Automatic dimensionality selection
from the scree plot via the use of profile likelihood. <em>Computational
Statistics and Data Analysis</em>, Vol. 51, 918&ndash;930.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+embed_adjacency_matrix">embed_adjacency_matrix()</a></code>
</p>
<p>Other embedding: 
<code><a href="#topic+embed_adjacency_matrix">embed_adjacency_matrix</a>()</code>,
<code><a href="#topic+embed_laplacian_matrix">embed_laplacian_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate the two groups of singular values with
# Gaussian mixture of two components that have different means
sing.vals &lt;- c(rnorm(10, mean = 1, sd = 1), rnorm(10, mean = 3, sd = 1))
dim.chosen &lt;- dim_select(sing.vals)
dim.chosen

# Sample random vectors with multivariate normal distribution
# and normalize to unit length
lpvs &lt;- matrix(rnorm(200), 10, 20)
lpvs &lt;- apply(lpvs, 2, function(x) {
  (abs(x) / sqrt(sum(x^2)))
})
RDP.graph &lt;- sample_dot_product(lpvs)
dim_select(embed_adjacency_matrix(RDP.graph, 10)$D)

# Sample random vectors with the Dirichlet distribution
lpvs.dir &lt;- sample_dirichlet(n = 20, rep(1, 10))
RDP.graph.2 &lt;- sample_dot_product(lpvs.dir)
dim_select(embed_adjacency_matrix(RDP.graph.2, 10)$D)

# Sample random vectors from hypersphere with radius 1.
lpvs.sph &lt;- sample_sphere_surface(dim = 10, n = 20, radius = 1)
RDP.graph.3 &lt;- sample_dot_product(lpvs.sph)
dim_select(embed_adjacency_matrix(RDP.graph.3, 10)$D)

</code></pre>

<hr>
<h2 id='disjoint_union'>Disjoint union of graphs</h2><span id='topic+disjoint_union'></span><span id='topic++25du+25'></span>

<h3>Description</h3>

<p>The union of two or more graphs are created. The graphs are assumed to have
disjoint vertex sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disjoint_union(...)

x %du% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disjoint_union_+3A_...">...</code></td>
<td>
<p>Graph objects or lists of graph objects.</p>
</td></tr>
<tr><td><code id="disjoint_union_+3A_x">x</code>, <code id="disjoint_union_+3A_y">y</code></td>
<td>
<p>Graph objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>disjoint_union()</code> creates a union of two or more disjoint graphs.
Thus first the vertices in the second, third, etc. graphs are relabeled to
have completely disjoint graphs. Then a simple union is created. This
function can also be used via the <code style="white-space: pre;">&#8288;%du%&#8288;</code> operator.
</p>
<p><code>graph.disjont.union</code> handles graph, vertex and edge attributes.  In
particular, it merges vertex and edge attributes using the basic <code>c()</code>
function. For graphs that lack some vertex/edge attribute, the corresponding
values in the new graph are set to <code>NA</code>. Graph attributes are simply
copied to the result. If this would result a name clash, then they are
renamed by adding suffixes: _1, _2, etc.
</p>
<p>Note that if both graphs have vertex names (i.e. a <code>name</code> vertex
attribute), then the concatenated vertex names might be non-unique in the
result. A warning is given if this happens.
</p>
<p>An error is generated if some input graphs are directed and others are
undirected.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A star and a ring
g1 &lt;- make_star(10, mode = "undirected")
V(g1)$name &lt;- letters[1:10]
g2 &lt;- make_ring(10)
V(g2)$name &lt;- letters[11:20]
print_all(g1 %du% g2)
</code></pre>

<hr>
<h2 id='distance_table'>Shortest (directed or undirected) paths between vertices</h2><span id='topic+distance_table'></span><span id='topic+mean_distance'></span><span id='topic+distances'></span><span id='topic+shortest_paths'></span><span id='topic+all_shortest_paths'></span>

<h3>Description</h3>

<p><code>distances()</code> calculates the length of all the shortest paths from
or to the vertices in the network. <code>shortest_paths()</code> calculates one
shortest path (the path itself, and not just its length) from or to the
given vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_table(graph, directed = TRUE)

mean_distance(
  graph,
  weights = NULL,
  directed = TRUE,
  unconnected = TRUE,
  details = FALSE
)

distances(
  graph,
  v = V(graph),
  to = V(graph),
  mode = c("all", "out", "in"),
  weights = NULL,
  algorithm = c("automatic", "unweighted", "dijkstra", "bellman-ford", "johnson",
    "floyd-warshall")
)

shortest_paths(
  graph,
  from,
  to = V(graph),
  mode = c("out", "all", "in"),
  weights = NULL,
  output = c("vpath", "epath", "both"),
  predecessors = FALSE,
  inbound.edges = FALSE,
  algorithm = c("automatic", "unweighted", "dijkstra", "bellman-ford")
)

all_shortest_paths(
  graph,
  from,
  to = V(graph),
  mode = c("out", "all", "in"),
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_table_+3A_graph">graph</code></td>
<td>
<p>The graph to work on.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_directed">directed</code></td>
<td>
<p>Whether to consider directed paths in directed graphs,
this argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then the
attribute is used. If this is <code>NA</code> then no weights are used (even if
the graph has a <code>weight</code> attribute).</p>
</td></tr>
<tr><td><code id="distance_table_+3A_unconnected">unconnected</code></td>
<td>
<p>What to do if the graph is unconnected (not
strongly connected if directed paths are considered). If TRUE, only
the lengths of the existing paths are considered and averaged; if
FALSE, the length of the missing paths are considered as having infinite
length, making the mean distance infinite as well.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_details">details</code></td>
<td>
<p>Whether to provide additional details in the result.
Functions accepting this argument (like <code>mean_distance()</code>) return
additional information like the number of disconnected vertex pairs in
the result when this parameter is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_v">v</code></td>
<td>
<p>Numeric vector, the vertices from which the shortest paths will be
calculated.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_to">to</code></td>
<td>
<p>Numeric vector, the vertices to which the shortest paths will be
calculated. By default it includes all vertices. Note that for
<code>distances()</code> every vertex must be included here at most once. (This
is not required for <code>shortest_paths()</code>.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the corresponding
undirected graph will be used, i.e. not directed paths are searched. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_algorithm">algorithm</code></td>
<td>
<p>Which algorithm to use for the calculation. By default
igraph tries to select the fastest suitable algorithm. If there are no
weights, then an unweighted breadth-first search is used, otherwise if all
weights are positive, then Dijkstra's algorithm is used. If there are
negative weights and we do the calculation for more than 100 sources, then
Johnson's algorithm is used. Otherwise the Bellman-Ford algorithm is used.
You can override igraph's choice by explicitly giving this parameter. Note
that the igraph C core might still override your choice in obvious cases,
i.e. if there are no edge weights, then the unweighted algorithm will be
used, regardless of this argument.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_from">from</code></td>
<td>
<p>Numeric constant, the vertex from or to the shortest paths will
be calculated. Note that right now this is not a vector of vertex ids, but
only a single vertex.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_output">output</code></td>
<td>
<p>Character scalar, defines how to report the shortest paths.
&ldquo;vpath&rdquo; means that the vertices along the paths are reported, this
form was used prior to igraph version 0.6. &ldquo;epath&rdquo; means that the
edges along the paths are reported. &ldquo;both&rdquo; means that both forms are
returned, in a named list with components &ldquo;vpath&rdquo; and &ldquo;epath&rdquo;.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_predecessors">predecessors</code></td>
<td>
<p>Logical scalar, whether to return the predecessor vertex
for each vertex. The predecessor of vertex <code>i</code> in the tree is the
vertex from which vertex <code>i</code> was reached. The predecessor of the start
vertex (in the <code>from</code> argument) is itself by definition. If the
predecessor is zero, it means that the given vertex was not reached from the
source during the search. Note that the search terminates if all the
vertices in <code>to</code> are reached.</p>
</td></tr>
<tr><td><code id="distance_table_+3A_inbound.edges">inbound.edges</code></td>
<td>
<p>Logical scalar, whether to return the inbound edge for
each vertex. The inbound edge of vertex <code>i</code> in the tree is the edge via
which vertex <code>i</code> was reached. The start vertex and vertices that were
not reached during the search will have zero in the corresponding entry of
the vector. Note that the search terminates if all the vertices in <code>to</code>
are reached.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shortest path, or geodesic between two pair of vertices is a path with
the minimal number of vertices. The functions documented in this manual page
all calculate shortest paths between vertex pairs.
</p>
<p><code>distances()</code> calculates the lengths of pairwise shortest paths from
a set of vertices (<code>from</code>) to another set of vertices (<code>to</code>). It
uses different algorithms, depending on the <code>algorithm</code> argument and
the <code>weight</code> edge attribute of the graph. The implemented algorithms
are breadth-first search (&lsquo;<code>unweighted</code>&rsquo;), this only works for
unweighted graphs; the Dijkstra algorithm (&lsquo;<code>dijkstra</code>&rsquo;), this
works for graphs with non-negative edge weights; the Bellman-Ford algorithm
(&lsquo;<code>bellman-ford</code>&rsquo;); Johnson's algorithm
(&lsquo;<code>johnson</code>&rsquo;); and a faster version of the Floyd-Warshall algorithm
with expected quadratic running time (&lsquo;<code>floyd-warshall</code>&rsquo;). The latter
three algorithms work with arbitrary
edge weights, but (naturally) only for graphs that don't have a negative
cycle. Note that a negative-weight edge in an undirected graph implies
such a cycle. Johnson's algorithm performs better than the Bellman-Ford
one when many source (and target) vertices are given, with all-pairs
shortest path length calculations being the typical use case.
</p>
<p>igraph can choose automatically between algorithms, and chooses the most
efficient one that is appropriate for the supplied weights (if any). For
automatic algorithm selection, supply &lsquo;<code>automatic</code>&rsquo; as the
<code>algorithm</code> argument. (This is also the default.)
</p>
<p><code>shortest_paths()</code> calculates a single shortest path (i.e. the path
itself, not just its length) between the source vertex given in <code>from</code>,
to the target vertices given in <code>to</code>. <code>shortest_paths()</code> uses
breadth-first search for unweighted graphs and Dijkstra's algorithm for
weighted graphs. The latter only works if the edge weights are non-negative.
</p>
<p><code>all_shortest_paths()</code> calculates <em>all</em> shortest paths between
pairs of vertices, including several shortest paths of the same length.
More precisely, it computerd all shortest path starting at <code>from</code>, and
ending at any vertex given in <code>to</code>. It uses a breadth-first search for
unweighted graphs and Dijkstra's algorithm for weighted ones. The latter
only supports non-negative edge weights. Caution: in multigraphs, the
result size is exponentially large in the number of vertex pairs with
multiple edges between them.
</p>
<p><code>mean_distance()</code> calculates the average path length in a graph, by
calculating the shortest paths between all pairs of vertices (both ways for
directed graphs). It uses a breadth-first search for unweighted graphs and
Dijkstra's algorithm for weighted ones. The latter only supports non-negative
edge weights.
</p>
<p><code>distance_table()</code> calculates a histogram, by calculating the shortest
path length between each pair of vertices. For directed graphs both
directions are considered, so every pair of vertices appears twice in the
histogram.
</p>


<h3>Value</h3>

<p>For <code>distances()</code> a numeric matrix with <code>length(to)</code>
columns and <code>length(v)</code> rows. The shortest path length from a vertex to
itself is always zero. For unreachable vertices <code>Inf</code> is included.
</p>
<p>For <code>shortest_paths()</code> a named list with four entries is returned:
</p>
<table>
<tr><td><code>vpath</code></td>
<td>
<p>This itself is a list, of length <code>length(to)</code>; list
element <code>i</code> contains the vertex ids on the path from vertex <code>from</code>
to vertex <code>to[i]</code> (or the other way for directed graphs depending on
the <code>mode</code> argument). The vector also contains <code>from</code> and <code>i</code>
as the first and last elements. If <code>from</code> is the same as <code>i</code> then
it is only included once. If there is no path between two vertices then a
numeric vector of length zero is returned as the list element. If this
output is not requested in the <code>output</code> argument, then it will be
<code>NULL</code>.</p>
</td></tr> <tr><td><code>epath</code></td>
<td>
<p>This is a list similar to <code>vpath</code>, but the
vectors of the list contain the edge ids along the shortest paths, instead
of the vertex ids. This entry is set to <code>NULL</code> if it is not requested
in the <code>output</code> argument.</p>
</td></tr> <tr><td><code>predecessors</code></td>
<td>
<p>Numeric vector, the
predecessor of each vertex in the <code>to</code> argument, or <code>NULL</code> if it
was not requested.</p>
</td></tr> <tr><td><code>inbound_edges</code></td>
<td>
<p>Numeric vector, the inbound edge
for each vertex, or <code>NULL</code>, if it was not requested.</p>
</td></tr>
</table>
<p>For <code>all_shortest_paths()</code> a list is returned, each list element
contains a shortest path from <code>from</code> to a vertex in <code>to</code>. The
shortest paths to the same vertex are collected into consecutive elements
of the list.
</p>
<p>For <code>mean_distance()</code> a single number is returned if <code>details=FALSE</code>,
or a named list with two entries: <code>res</code> is the mean distance as a numeric
scalar and <code>unconnected</code> is the number of unconnected vertex pairs,
also as a numeric scalar.
</p>
<p><code>distance_table()</code> returns a named list with two entries: <code>res</code> is
a numeric vector, the histogram of distances, <code>unconnected</code> is a
numeric scalar, the number of pairs for which the first vertex is not
reachable from the second. In undirected and directed graphs, unorderde
and ordered pairs are considered, respectively. Therefore the sum of the
two entries is always <code class="reqn">n(n-1)</code> for directed graphs and <code class="reqn">n(n-1)/2</code>
for undirected graphs.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>West, D.B. (1996). <em>Introduction to Graph Theory.</em> Upper
Saddle River, N.J.: Prentice Hall.
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>
<p>Other paths: 
<code><a href="#topic+all_simple_paths">all_simple_paths</a>()</code>,
<code><a href="#topic+diameter">diameter</a>()</code>,
<code><a href="#topic+eccentricity">eccentricity</a>()</code>,
<code><a href="#topic+radius">radius</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
distances(g)
shortest_paths(g, 5)
all_shortest_paths(g, 1, 6:8)
mean_distance(g)
## Weighted shortest paths
el &lt;- matrix(
  ncol = 3, byrow = TRUE,
  c(
    1, 2, 0,
    1, 3, 2,
    1, 4, 1,
    2, 3, 0,
    2, 5, 5,
    2, 6, 2,
    3, 2, 1,
    3, 4, 1,
    3, 7, 1,
    4, 3, 0,
    4, 7, 2,
    5, 6, 2,
    5, 8, 8,
    6, 3, 2,
    6, 7, 1,
    6, 9, 1,
    6, 10, 3,
    8, 6, 1,
    8, 9, 1,
    9, 10, 4
  )
)
g2 &lt;- add_edges(make_empty_graph(10), t(el[, 1:2]), weight = el[, 3])
distances(g2, mode = "out")

</code></pre>

<hr>
<h2 id='diverging_pal'>Diverging palette</h2><span id='topic+diverging_pal'></span>

<h3>Description</h3>

<p>This is the &lsquo;PuOr&rsquo; palette from <a href="https://colorbrewer2.org/">https://colorbrewer2.org/</a>.
It has at most eleven colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diverging_pal(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diverging_pal_+3A_n">n</code></td>
<td>
<p>The number of colors in the palette. The maximum is eleven
currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is similar to <code><a href="#topic+sequential_pal">sequential_pal()</a></code>, but it also puts
emphasis on the mid-range values, plus the the two extreme ends.
Use this palette, if you have such a quantity to mark with vertex
colors.
</p>


<h3>Value</h3>

<p>A character vector of RGB color codes.
</p>


<h3>See Also</h3>

<p>Other palettes: 
<code><a href="#topic+categorical_pal">categorical_pal</a>()</code>,
<code><a href="#topic+r_pal">r_pal</a>()</code>,
<code><a href="#topic+sequential_pal">sequential_pal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraphdata)
data(foodwebs)
fw &lt;- foodwebs[[1]] %&gt;%
  induced_subgraph(V(.)[ECO == 1]) %&gt;%
  add_layout_(with_fr()) %&gt;%
  set_vertex_attr("label", value = seq_len(gorder(.))) %&gt;%
  set_vertex_attr("size", value = 10) %&gt;%
  set_edge_attr("arrow.size", value = 0.3)

V(fw)$color &lt;- scales::dscale(V(fw)$Biomass %&gt;% cut(10), diverging_pal)
plot(fw)

data(karate)
karate &lt;- karate %&gt;%
  add_layout_(with_kk()) %&gt;%
  set_vertex_attr("size", value = 10)

V(karate)$color &lt;- scales::dscale(degree(karate) %&gt;% cut(5), diverging_pal)
plot(karate)
</code></pre>

<hr>
<h2 id='diversity'>Graph diversity</h2><span id='topic+diversity'></span>

<h3>Description</h3>

<p>Calculates a measure of diversity for all vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity(graph, weights = NULL, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions are ignored.</p>
</td></tr>
<tr><td><code id="diversity_+3A_weights">weights</code></td>
<td>
<p><code>NULL</code>, or the vector of edge weights to use for the
computation. If <code>NULL</code>, then the &lsquo;weight&rsquo; attibute is used. Note
that this measure is not defined for unweighted graphs.</p>
</td></tr>
<tr><td><code id="diversity_+3A_vids">vids</code></td>
<td>
<p>The vertex ids for which to calculate the measure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The diversity of a vertex is defined as the (scaled) Shannon entropy of the
weights of its incident edges:
</p>
<p style="text-align: center;"><code class="reqn">D(i)=\frac{H(i)}{\log k_i}</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">H(i)=-\sum_{j=1}^{k_i} p_{ij}\log p_{ij},</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">p_{ij}=\frac{w_{ij}}{\sum_{l=1}^{k_i}}V_{il},</code>
</p>
<p> and <code class="reqn">k_i</code> is the (total) degree of vertex
<code class="reqn">i</code>, <code class="reqn">w_{ij}</code> is the weight of the edge(s) between vertices
<code class="reqn">i</code> and <code class="reqn">j</code>.
</p>
<p>For vertices with degree less than two the function returns <code>NaN</code>.
</p>


<h3>Value</h3>

<p>A numeric vector, its length is the number of vertices.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Nathan Eagle, Michael Macy and Rob Claxton: Network Diversity
and Economic Development, <em>Science</em> <strong>328</strong>, 1029&ndash;1031, 2010.
</p>


<h3>See Also</h3>

<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- sample_gnp(20, 2 / 20)
g2 &lt;- sample_gnp(20, 2 / 20)
g3 &lt;- sample_gnp(20, 5 / 20)
E(g1)$weight &lt;- 1
E(g2)$weight &lt;- runif(ecount(g2))
E(g3)$weight &lt;- runif(ecount(g3))
diversity(g1)
diversity(g2)
diversity(g3)
</code></pre>

<hr>
<h2 id='dominator_tree'>Dominator tree</h2><span id='topic+dominator_tree'></span>

<h3>Description</h3>

<p>Dominator tree of a directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominator_tree(graph, root, mode = c("out", "in", "all", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominator_tree_+3A_graph">graph</code></td>
<td>
<p>A directed graph. If it is not a flowgraph, and it contains
some vertices not reachable from the root vertex, then these vertices will
be collected and returned as part of the result.</p>
</td></tr>
<tr><td><code id="dominator_tree_+3A_root">root</code></td>
<td>
<p>The id of the root (or source) vertex, this will be the root of
the tree.</p>
</td></tr>
<tr><td><code id="dominator_tree_+3A_mode">mode</code></td>
<td>
<p>Constant, must be &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo; or &lsquo;<code>out</code>&rsquo;. If
it is &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo;, then all directions are considered as opposite to
the original one in the input graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A flowgraph is a directed graph with a distinguished start (or root) vertex
<code class="reqn">r</code>, such that for any vertex <code class="reqn">v</code>, there is a path from <code class="reqn">r</code> to
<code class="reqn">v</code>. A vertex <code class="reqn">v</code> dominates another vertex <code class="reqn">w</code> (not equal to
<code class="reqn">v</code>), if every path from <code class="reqn">r</code> to <code class="reqn">w</code> contains <code class="reqn">v</code>. Vertex
<code class="reqn">v</code> is the immediate dominator or <code class="reqn">w</code>,
<code class="reqn">v=\textrm{idom}(w)</code>, if <code class="reqn">v</code> dominates <code class="reqn">w</code> and every
other dominator of <code class="reqn">w</code> dominates <code class="reqn">v</code>. The edges
<code class="reqn">{(\textrm{idom}(w), w)| w \ne r}</code> form a
directed tree, rooted at <code class="reqn">r</code>, called the dominator tree of the graph.
Vertex <code class="reqn">v</code> dominates vertex <code class="reqn">w</code> if and only if <code class="reqn">v</code> is an
ancestor of <code class="reqn">w</code> in the dominator tree.
</p>
<p>This function implements the Lengauer-Tarjan algorithm to construct the
dominator tree of a directed graph. For details see the reference below.
</p>


<h3>Value</h3>

<p>A list with components: </p>
<table>
<tr><td><code>dom</code></td>
<td>
<p> A numeric vector giving the
immediate dominators for each vertex. For vertices that are unreachable from
the root, it contains <code>NaN</code>. For the root vertex itself it contains
minus one.  </p>
</td></tr> <tr><td><code>domtree</code></td>
<td>
<p> A graph object, the dominator tree. Its vertex
ids are the as the vertex ids of the input graph. Isolate vertices are the
ones that are unreachable from the root.  </p>
</td></tr> <tr><td><code>leftout</code></td>
<td>
<p> A numeric vector
containing the vertex ids that are unreachable from the root.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Thomas Lengauer, Robert Endre Tarjan: A fast algorithm for
finding dominators in a flowgraph, <em>ACM Transactions on Programming
Languages and Systems (TOPLAS)</em> I/1, 121&ndash;141, 1979.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The example from the paper
g &lt;- graph_from_literal(
  R -+ A:B:C, A -+ D, B -+ A:D:E, C -+ F:G, D -+ L,
  E -+ H, F -+ I, G -+ I:J, H -+ E:K, I -+ K, J -+ I,
  K -+ I:R, L -+ H
)
dtree &lt;- dominator_tree(g, root = "R")
layout &lt;- layout_as_tree(dtree$domtree, root = "R")
layout[, 2] &lt;- -layout[, 2]
plot(dtree$domtree, layout = layout, vertex.label = V(dtree$domtree)$name)
</code></pre>

<hr>
<h2 id='dominator.tree'>Dominator tree</h2><span id='topic+dominator.tree'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>dominator.tree()</code> was renamed to <code>dominator_tree()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominator.tree(graph, root, mode = c("out", "in", "all", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominator.tree_+3A_graph">graph</code></td>
<td>
<p>A directed graph. If it is not a flowgraph, and it contains
some vertices not reachable from the root vertex, then these vertices will
be collected and returned as part of the result.</p>
</td></tr>
<tr><td><code id="dominator.tree_+3A_root">root</code></td>
<td>
<p>The id of the root (or source) vertex, this will be the root of
the tree.</p>
</td></tr>
<tr><td><code id="dominator.tree_+3A_mode">mode</code></td>
<td>
<p>Constant, must be &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo; or &lsquo;<code>out</code>&rsquo;. If
it is &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo;, then all directions are considered as opposite to
the original one in the input graph.</p>
</td></tr>
</table>

<hr>
<h2 id='dot-data'><code>.data</code> and <code>.env</code> pronouns</h2><span id='topic+dot-data'></span><span id='topic+.data'></span><span id='topic+dot-env'></span><span id='topic+.env'></span>

<h3>Description</h3>

<p>The <code>.data</code> and <code>.env</code> pronouns make it explicit where to look up attribute
names when indexing <code>V(g)</code> or <code>E(g)</code>, i.e. the vertex or edge sequence of a
graph. These pronouns are inspired by <code>.data</code> and <code>.env</code> in <code>rlang</code> - thanks
to Michał Bojanowski for bringing these to our attention.
</p>
<p>The rules are simple:
</p>

<ul>
<li> <p><code>.data</code> retrieves attributes from the graph whose vertex or edge sequence
is being evaluated.
</p>
</li>
<li> <p><code>.env</code> retrieves variables from the calling environment.
</p>
</li></ul>

<p>Note that <code>.data</code> and <code>.env</code> are injected dynamically into the environment
where the indexing expressions are evaluated; you cannot get access to these
objects outside the context of an indexing expression. To avoid warnings
printed by <code style="white-space: pre;">&#8288;R CMD check&#8288;</code> when code containing <code>.data</code> and <code>.env</code> is checked,
you can import <code>.data</code> and <code>.env</code> from <code>igraph</code> if needed. Alternatively,
you can declare them explicitly with <code>utils::globalVariables()</code> to silence
the warnings.
</p>

<hr>
<h2 id='Drawing+20graphs'>Drawing graphs</h2><span id='topic+igraph.plotting'></span>

<h3>Description</h3>

<p>The common bits of the three plotting functions
<code>plot.igraph</code>, <code>tkplot</code> and <code>rglplot</code> are discussed in
this manual page</p>


<h3>Details</h3>

<p>There are currently three different functions in the igraph package
which can draw graph in various ways:
</p>
<p><code>plot.igraph</code> does simple non-interactive 2D plotting to R devices.
Actually it is an implementation of the <code><a href="graphics.html#topic+plot">plot</a></code>
generic function, 
so you can write <code>plot(graph)</code> instead of
<code>plot.igraph(graph)</code>. As it used the standard R devices it
supports every output format for which R has an output device. The
list is quite impressing: PostScript, PDF files, XFig files, SVG
files, JPG, PNG and of course you can plot to the screen as well using
the default devices, or the good-looking anti-aliased Cairo device.
See <code><a href="#topic+plot.igraph">plot.igraph</a></code> for some more information.
</p>
<p><code><a href="#topic+tkplot">tkplot</a></code> does interactive 2D plotting using the <code>tcltk</code>
package. It can only handle graphs of moderate size, a thousand
vertices is probably already too many. Some parameters of the plotted
graph can be changed interactively after issuing the <code>tkplot</code>
command: the position, color and size of the vertices and the color
and width of the edges. See <code><a href="#topic+tkplot">tkplot</a></code> for details.
</p>
<p><code><a href="#topic+rglplot">rglplot</a></code> is an experimental function to draw graphs in 3D
using OpenGL. See <code><a href="#topic+rglplot">rglplot</a></code> for some more information.
</p>
<p>Please also check the examples below.
</p>


<h3>How to specify graphical parameters</h3>

<p>There are three ways to give values to the parameters described below,
in section 'Parameters'. We give these three ways here in the order of
their precedence. 
</p>
<p>The first method is to supply named arguments to the plotting commands:
<code><a href="#topic+plot.igraph">plot.igraph</a></code>, <code><a href="#topic+tkplot">tkplot</a></code> or
<code><a href="#topic+rglplot">rglplot</a></code>. Parameters for vertices start with prefix
&lsquo;<code>vertex.</code>&rsquo;, parameters for edges have prefix
&lsquo;<code>edge.</code>&rsquo;, and global parameters have no prefix. Eg. the
color of the vertices can be given via argument <code>vertex.color</code>,
whereas <code>edge.color</code> sets the color of the edges. <code>layout</code>
gives the layout of the graphs.
</p>
<p>The second way is to assign vertex, edge and graph attributes to the
graph. These attributes have no prefix, ie. the color of the vertices
is taken from the <code>color</code> vertex attribute and the color of the
edges from the <code>color</code> edge attribute. The layout of the graph is
given by the <code>layout</code> graph attribute. (Always assuming that the
corresponding command argument is not present.) Setting vertex and
edge attributes are handy if you want to assign a given &lsquo;look&rsquo;
to a graph, attributes are saved with the graph is you save it with
<code><a href="base.html#topic+save">save</a></code> or in GraphML format with
<code><a href="#topic+write_graph">write_graph</a></code>, so the graph will have the same look after
loading it again.
</p>
<p>If a parameter is not given in the command line, and the corresponding
vertex/edge/graph attribute is also missing then the general igraph
parameters handled by <code><a href="#topic+igraph_options">igraph_options</a></code> are also
checked. Vertex parameters have prefix &lsquo;<code>vertex.</code>&rsquo;, edge
parameters are prefixed with &lsquo;<code>edge.</code>&rsquo;, general parameters
like <code>layout</code> are prefixed with &lsquo;<code>plot</code>&rsquo;.
These parameters are useful if you want
all or most of your graphs to have the same look, vertex size, vertex
color, etc. Then you don't need to set these at every plotting, and
you also don't need to assign vertex/edge attributes to every graph.
</p>
<p>If the value of a parameter is not specified by any of the three ways
described here, its default valued is used, as given in the source
code.
</p>
<p>Different parameters can have different type, eg. vertex colors can be
given as a character vector with color names, or as an integer vector
with the color numbers from the current palette. Different types are
valid for different parameters, this is discussed in detail in the
next section. It is however always true that the parameter can always
be a function object in which it will be called with the graph as its
single argument to get the &ldquo;proper&rdquo; value of the parameter.
(If the function returns another function object that will <em>not</em>
be called again...)
</p>


<h3>The list of parameters</h3>

<p>Vertex parameters first, note that the &lsquo;<code>vertex.</code>&rsquo; prefix
needs to be added if they are used as an argument or when setting via
<code><a href="#topic+igraph_options">igraph_options</a></code>. The value of the parameter may be scalar
valid for every vertex or a vector with a separate value for each
vertex. (Shorter vectors are recycled.)
</p>

<dl>
<dt>size</dt><dd><p>The size of the vertex, a numeric scalar or vector, in
the latter case each vertex sizes may differ. This vertex sizes
are scaled in order have about the same size of vertices for a
given value for all three plotting commands. It does not need to
be an integer number.
</p>
<p>The default value is 15. This is big enough to place short labels
on vertices.</p>
</dd>
<dt>size2</dt><dd><p>The &ldquo;other&rdquo; size of the vertex, for some vertex
shapes. For the various rectangle shapes this gives the height of
the vertices, whereas <code>size</code> gives the width. It is ignored
by shapes for which the size can be specified with a single
number.
</p>
<p>The default is 15.
</p>
</dd>
<dt>color</dt><dd><p>The fill color of the vertex. If it is numeric then
the current palette is used, see
<code><a href="grDevices.html#topic+palette">palette</a></code>. If it is a character vector then
it may either contain integer values, named colors or RGB
specified colors with three or four bytes. All strings starting
with &lsquo;<code>#</code>&rsquo; are assumed to be RGB color
specifications. It is possible to mix named color and RGB
colors. Note that <code><a href="#topic+tkplot">tkplot</a></code> ignores the fourth byte
(alpha channel) in the RGB color specification.
</p>
<p>For <code>plot.igraph</code> and integer values, the default igraph
palette is used (see the &lsquo;palette&rsquo; parameter below. Note
that this is different from the R palette.
</p>
<p>If you don't want (some) vertices to have any color, supply
<code>NA</code> as the color name.
</p>
<p>The default value is &ldquo;<code>SkyBlue2</code>&rdquo;.
</p>
</dd>
<dt>frame.color</dt><dd><p>The color of the frame of the vertices, the same
formats are allowed as for the fill color.
</p>
<p>If you don't want vertices to have a frame, supply <code>NA</code> as
the color name.
</p>
<p>By default it is &ldquo;black&rdquo;.
</p>
</dd>
<dt>frame.width</dt><dd><p>The width of the frame of the vertices.
</p>
<p>The default value is 1.
</p>
</dd>
<dt>shape</dt><dd><p>The shape of the vertex, currently
&ldquo;<code>circle</code>&rdquo;, &ldquo;<code>square</code>&rdquo;,
&ldquo;<code>csquare</code>&rdquo;, &ldquo;<code>rectangle</code>&rdquo;,
&ldquo;<code>crectangle</code>&rdquo;, &ldquo;<code>vrectangle</code>&rdquo;,
&ldquo;<code>pie</code>&rdquo; (see <a href="#topic+vertex.shape.pie">vertex.shape.pie</a>),
&lsquo;<code>sphere</code>&rsquo;, and &ldquo;<code>none</code>&rdquo; are supported,
and only by the <code><a href="#topic+plot.igraph">plot.igraph</a></code>
command. &ldquo;<code>none</code>&rdquo; does not draw the vertices at all,
although vertex label are plotted (if given). See
<code><a href="#topic+shapes">shapes</a></code> for details about vertex
shapes and <code><a href="#topic+vertex.shape.pie">vertex.shape.pie</a></code> for using pie charts as
vertices.
</p>
<p>The &ldquo;<code>sphere</code>&rdquo; vertex shape plots vertices as 3D
ray-traced spheres, in the given color and size. This produces a
raster image and it is only supported with some graphics
devices. On some devices raster transparency is not supported and
the spheres do not have a transparent background. See
<code><a href="grDevices.html#topic+dev.capabilities">dev.capabilities</a></code> and the &lsquo;<code>rasterImage</code>&rsquo;
capability to check that your device is supported.
</p>
<p>By default vertices are drawn as circles.
</p>
</dd>
<dt>label</dt><dd><p>The vertex labels. They will be converted to
character. Specify <code>NA</code> to omit vertex labels.
</p>
<p>The default vertex labels are the vertex ids.
</p>
</dd>
<dt>label.family</dt><dd><p>The font family to be used for vertex labels.
As different plotting commands can used different fonts, they
interpret this parameter different ways. The basic notation is,
however, understood by both <code><a href="#topic+plot.igraph">plot.igraph</a></code> and
<code><a href="#topic+tkplot">tkplot</a></code>. <code><a href="#topic+rglplot">rglplot</a></code> does not support fonts
at all right now, it ignores this parameter completely.
</p>
<p>For <code><a href="#topic+plot.igraph">plot.igraph</a></code> this parameter is simply passed to
<code><a href="graphics.html#topic+text">text</a></code> as argument <code>family</code>.
</p>
<p>For <code><a href="#topic+tkplot">tkplot</a></code> some
conversion is performed. If this parameter is the name of an
exixting Tk font, then that font is used and the <code>label.font</code>
and <code>label.cex</code> parameters are ignored complerely. If it is
one of the base families (serif, sans, mono) then Times,
Helvetica or Courier fonts are used, there are guaranteed to exist
on all systems. For the &lsquo;symbol&rsquo; base family we used the
symbol font is available, otherwise the first font which has
&lsquo;symbol&rsquo; in its name. If the parameter is not a name of the
base families and it is also not a named Tk font then we pass it
to <code><a href="tcltk.html#topic+tkfont.create">tkfont.create</a></code> and hope the user knows what
she is doing. The <code>label.font</code> and <code>label.cex</code>
parameters are also passed to <code><a href="tcltk.html#topic+tkfont.create">tkfont.create</a></code>
in this case.
</p>
<p>The default value is &lsquo;serif&rsquo;.
</p>
</dd>
<dt>label.font</dt><dd><p>The font within the font family to use for the
vertex labels. It is interpreted the same way as the the
<code>font</code> graphical parameter: 1 is plain text, 2 is bold face,
3 is italic, 4 is bold and italic and 5 specifies the symbol
font.
</p>
<p>For <code><a href="#topic+plot.igraph">plot.igraph</a></code> this parameter is simply passed to
<code><a href="graphics.html#topic+text">text</a></code>.
</p>
<p>For <code><a href="#topic+tkplot">tkplot</a></code>, if the <code>label.family</code> parameter is
not the name of a Tk font then this parameter is used to set
whether the newly created font should be italic and/or
boldface. Otherwise it is ignored.
</p>
<p>For <code><a href="#topic+rglplot">rglplot</a></code> it is ignored.
</p>
<p>The default value is 1.
</p>
</dd>
<dt>label.cex</dt><dd><p>The font size for vertex labels. It is interpreted
as a multiplication factor of some device-dependent base font
size.
</p>
<p>For <code><a href="#topic+plot.igraph">plot.igraph</a></code> it is simply passed to
<code><a href="graphics.html#topic+text">text</a></code> as argument <code>cex</code>.
</p>
<p>For <code><a href="#topic+tkplot">tkplot</a></code> it is multiplied by 12 and then used as
the <code>size</code> argument for <code><a href="tcltk.html#topic+tkfont.create">tkfont.create</a></code>.
The base font is thus 12 for tkplot.
</p>
<p>For <code><a href="#topic+rglplot">rglplot</a></code> it is ignored.
</p>
<p>The default value is 1.
</p>
</dd>
<dt>label.dist</dt><dd>
<p>The distance of the label from the center of the vertex. If it is 0
then the label is centered on the vertex. If it is 1 then the
label is displayed beside the vertex.
</p>
<p>The default value is 0.
</p>
</dd>
<dt>label.degree</dt><dd>
<p>It defines the position of the vertex labels, relative to the
center of the vertices. It is interpreted as an angle in radian,
zero means &lsquo;to the right&rsquo;, and &lsquo;<code>pi</code>&rsquo; means to
the left, up is <code>-pi/2</code> and down is <code>pi/2</code>.
</p>
<p>The default value is <code>-pi/4</code>.
</p>
</dd>
<dt>label.color</dt><dd><p>The color of the labels, see the <code>color</code>
vertex parameter discussed earlier for the possible values.
</p>
<p>The default value is <code>black</code>.
</p>
</dd>    
</dl>

<p>Edge parameters require to add the &lsquo;<code>edge.</code>&rsquo; prefix when
used as arguments or set by <code><a href="#topic+igraph_options">igraph_options</a></code>. The edge
parameters:
</p>

<dl>
<dt>color</dt><dd><p>The color of the edges, see the <code>color</code> vertex
parameter for the possible values.
</p>
<p>By default this parameter is <code>darkgrey</code>.
</p>
</dd>
<dt>width</dt><dd><p>The width of the edges.
</p>
<p>The default value is 1.
</p>
</dd>
<dt>arrow.size</dt><dd><p>The size of the arrows. Currently this is a
constant, so it is the same for every edge. If a vector is
submitted then only the first element is used, ie. if this is
taken from an edge attribute then only the attribute of the first
edge is used for all arrows. This will likely change in the future.
</p>
<p>The default value is 1.
</p>
</dd>
<dt>arrow.width</dt><dd><p>The width of the arrows. Currently this is a
constant, so it is the same for every edge. If a vector is
submitted then only the first element is used, ie. if this is
taken from an edge attribute then only the attribute of the first
edge is used for all arrows. This will likely change in the future.
</p>
<p>This argument is currently only used by <code><a href="#topic+plot.igraph">plot.igraph</a></code>.
</p>
<p>The default value is 1, which gives the same width as before
this option appeared in igraph.
</p>
</dd>
<dt>lty</dt><dd><p>The line type for the edges. Almost the same format is
accepted as for the standard graphics <code><a href="graphics.html#topic+par">par</a></code>,
0 and &ldquo;blank&rdquo; mean no edges, 1 and &ldquo;solid&rdquo; are for
solid lines, the other possible values are: 2 (&ldquo;dashed&rdquo;),
3 (&ldquo;dotted&rdquo;), 4 (&ldquo;dotdash&rdquo;), 5 (&ldquo;longdash&rdquo;),
6 (&ldquo;twodash&rdquo;).
</p>
<p><code><a href="#topic+tkplot">tkplot</a></code> also accepts standard Tk line type strings,
it does not however support &ldquo;blank&rdquo; lines, instead of type
&lsquo;0&rsquo; type &lsquo;1&rsquo;, ie. solid lines will be drawn.
</p>
<p>This argument is ignored for <code><a href="#topic+rglplot">rglplot</a></code>.
</p>
<p>The default value is type 1, a solid line.
</p>
</dd>
<dt>label</dt><dd><p>The edge labels. They will be converted to
character. Specify <code>NA</code> to omit edge labels.
</p>
<p>Edge labels are omitted by default.</p>
</dd>
<dt>label.family</dt><dd><p>Font family of the edge labels. See the vertex
parameter with the same name for the details.</p>
</dd>
<dt>label.font</dt><dd><p>The font for the edge labels. See the
corresponding vertex parameter discussed earlier for details.</p>
</dd>
<dt>label.cex</dt><dd><p>The font size for the edge labels, see the
corresponding vertex parameter for details.</p>
</dd>
<dt>label.color</dt><dd><p>The color of the edge labels, see the
<code>color</code> vertex parameters on how to specify colors. </p>
</dd>
<dt>label.x</dt><dd><p>The horizontal coordinates of the edge labels might
be given here, explicitly. The <code>NA</code> elements will be
replaced by automatically calculated coordinates. If <code>NULL</code>,
then all edge horizontal coordinates are calculated
automatically. This parameter is only supported by
<code>plot.igraph</code>.</p>
</dd>
<dt>label.y</dt><dd><p>The same as <code>label.x</code>, but for vertical
coordinates.</p>
</dd>
<dt>curved</dt><dd><p>Specifies whether to draw curved edges, or not. This
can be a logical or a numeric vector or scalar. 
</p>
<p>First the vector is replicated to have the same length as the
number of edges in the graph. Then it is interpreted for each edge
separately. A numeric value specifies the curvature of the edge;
zero curvature means straight edges, negative values means the
edge bends clockwise, positive values the opposite. <code>TRUE</code>
means curvature 0.5, <code>FALSE</code> means curvature zero.
</p>
<p>By default the vector specifying the curvatire is calculated via a
call to the <code><a href="#topic+curve_multiple">curve_multiple</a></code> function. This function makes
sure that multiple edges are curved and are all visible. This
parameter is ignored for loop edges. 
</p>
<p>The default value is <code>FALSE</code>.
</p>
<p>This parameter is currently ignored by <code><a href="#topic+rglplot">rglplot</a></code>.</p>
</dd>
<dt>arrow.mode</dt><dd><p>This parameter can be used to specify for which
edges should arrows be drawn. If this parameter is given by the
user (in either of the three ways) then it specifies which edges
will have forward, backward arrows, or both, or no arrows at all.
As usual, this parameter can be a vector or a scalar value.
It can be an integer or character type. If it is integer then 0
means no arrows, 1 means backward arrows, 2 is for forward arrows
and 3 for both. If it is a character vector then &ldquo;&lt;&rdquo; and
&ldquo;&lt;-&rdquo; specify backward, &ldquo;&gt;&rdquo; and &ldquo;-&gt;&rdquo; forward
arrows and &ldquo;&lt;&gt;&rdquo; and &ldquo;&lt;-&gt;&rdquo; stands for both arrows.
All other values mean no arrows, perhaps you should use &ldquo;-&rdquo;
or &ldquo;&ndash;&rdquo; to specify no arrows.
</p>
<p>Hint: this parameter can be used as a &lsquo;cheap&rsquo; solution for
drawing &ldquo;mixed&rdquo; graphs: graphs in which some edges are
directed some are not. If you want do this, then please create a
<em>directed</em> graph, because as of version 0.4 the vertex pairs
in the edge lists can be swapped in undirected graphs.
</p>
<p>By default, no arrows will be drawn for undirected graphs, and for 
directed graphs, an arrow will be drawn for each edge, according
to its direction. This is not very surprising, it is the expected
behavior.
</p>
</dd>
<dt>loop.angle</dt><dd><p>Gives the angle in radian for plotting loop
edges. See the <code>label.dist</code> vertex parameter to see how this
is interpreted.
</p>
<p>The default value is 0.
</p>
</dd>    
<dt>loop.angle2</dt><dd><p>Gives the second angle in radian for plotting
loop edges. This is only used in 3D, <code>loop.angle</code> is enough
in 2D.
</p>
<p>The default value is 0.
</p>
</dd>
</dl>

<p>Other parameters:
</p>

<dl>
<dt>layout</dt><dd>
<p>Either a function or a numeric
matrix. It specifies how the vertices will be placed on the plot.
</p>
<p>If it is a numeric matrix, then the matrix has to have one line for
each vertex, specifying its coordinates. The matrix should have at
least two columns, for the <code>x</code> and <code>y</code> coordinates, and
it can also have third column, this will be the <code>z</code>
coordinate for 3D plots and it is ignored for 2D plots.
</p>
<p>If a two column matrix is given for the 3D plotting function
<code><a href="#topic+rglplot">rglplot</a></code> then the third column is assumed to be 1 for
each vertex.
</p>
<p>If <code>layout</code> is a function, this function will be called with the
<code>graph</code> as the single parameter to determine the
actual coordinates. The function should return a matrix with two
or three columns. For the 2D plots the third column is ignored.
</p>
<p>The default value is <code>layout_nicely</code>, a smart function that
chooses a layouter based on the graph.</p>
</dd>
<dt>margin</dt><dd><p>The amount of empty space below, over, at the left and
right of the plot, it is a numeric vector of length four. Usually
values between 0 and 0.5 are meaningful, but negative values are
also possible, that will make the plot zoom in to a part of the
graph. If it is shorter than four then it is recycled.
</p>
<p><code><a href="#topic+rglplot">rglplot</a></code> does not support this parameter, as it can
zoom in and out the graph in a more flexible way.
</p>
<p>Its default value is 0.
</p>
</dd>
<dt>palette</dt><dd><p>The color palette to use for vertex color.
The default is <code><a href="#topic+categorical_pal">categorical_pal</a></code>, which is a
color-blind friendly categorical palette. See its manual page
for details and other palettes. This parameters is only supported
by <code>plot</code>, and not by <code>tkplot</code> and <code>rglplot</code>.
</p>
</dd>
<dt>rescale</dt><dd><p>Logical constant, whether to rescale the coordinates
to the [-1,1]x[-1,1](x[-1,1]) interval. This parameter is not
implemented for <code>tkplot</code>.
</p>
<p>Defaults to <code>TRUE</code>, the layout will be rescaled.
</p>
</dd>
<dt>asp</dt><dd><p>A numeric constant, it gives the <code>asp</code> parameter
for <code><a href="base.html#topic+plot">plot</a></code>, the aspect ratio. Supply 0 here if you
don't want to give an aspect ratio. It is ignored by <code>tkplot</code>
and <code>rglplot</code>.
</p>
<p>Defaults to 1.
</p>
</dd>
<dt>frame</dt><dd><p>Boolean, whether to plot a frame around the graph. It
is ignored by <code>tkplot</code> and <code>rglplot</code>.
</p>
<p>Defaults to <code>FALSE</code>.
</p>
</dd>
<dt>main</dt><dd><p>Overall title for the main plot. The default is empty if
the <code>annotate.plot</code> igraph option is <code>FALSE</code>, and the
graph's <code>name</code> attribute otherwise. See the same argument of
the base <code>plot</code> function. Only supported by <code>plot</code>.</p>
</dd>
<dt>sub</dt><dd><p>Subtitle of the main plot, the default is empty. Only
supported by <code>plot</code>.</p>
</dd>
<dt>xlab</dt><dd><p>Title for the x axis, the default is empty if the
<code>annotate.plot</code> igraph option is <code>FALSE</code>, and the number
of vertices and edges, if it is <code>TRUE</code>. Only supported by
<code>plot</code>.</p>
</dd>
<dt>ylab</dt><dd><p>Title for the y axis, the default is empty. Only
supported by <code>plot</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot.igraph">plot.igraph</a></code>, <code><a href="#topic+tkplot">tkplot</a></code>,
<code><a href="#topic+rglplot">rglplot</a></code>, <code><a href="#topic+igraph_options">igraph_options</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# plotting a simple ring graph, all default parameters, except the layout
g &lt;- make_ring(10)
g$layout &lt;- layout_in_circle
plot(g)
tkplot(g)
rglplot(g)

# plotting a random graph, set the parameters in the command arguments
g &lt;- barabasi.game(100)
plot(g, layout=layout_with_fr, vertex.size=4,
     vertex.label.dist=0.5, vertex.color="red", edge.arrow.size=0.5)

# plot a random graph, different color for each component
g &lt;- sample_gnp(100, 1/100)
comps &lt;- components(g)$membership
colbar &lt;- rainbow(max(comps)+1)
V(g)$color &lt;- colbar[comps+1]
plot(g, layout=layout_with_fr, vertex.size=5, vertex.label=NA)

# plot communities in a graph
g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1,6, 1,11, 6,11))
com &lt;- cluster_spinglass(g, spins=5)
V(g)$color &lt;- com$membership+1
g &lt;- set_graph_attr(g, "layout", layout_with_kk(g))
plot(g, vertex.label.dist=1.5)

# draw a bunch of trees, fix layout
igraph_options(plot.layout=layout_as_tree)
plot(make_tree(20, 2))
plot(make_tree(50, 3), vertex.size=3, vertex.label=NA)
tkplot(make_tree(50, 2, mode="undirected"), vertex.size=10,
vertex.color="green")

## End(Not run)
</code></pre>

<hr>
<h2 id='dyad_census'>Dyad census of a graph</h2><span id='topic+dyad_census'></span>

<h3>Description</h3>

<p>Classify dyads in a directed graphs. The relationship between each pair of
vertices is measured. It can be in three states: mutual, asymmetric or
non-existent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyad_census(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyad_census_+3A_graph">graph</code></td>
<td>
<p>The input graph. A warning is given if it is not directed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector with three elements: </p>
<table>
<tr><td><code>mut</code></td>
<td>
<p>The number of
pairs with mutual connections.</p>
</td></tr> <tr><td><code>asym</code></td>
<td>
<p>The number of pairs with
non-mutual connections.</p>
</td></tr> <tr><td><code>null</code></td>
<td>
<p>The number of pairs with no connection
between them.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Holland, P.W. and Leinhardt, S. A Method for Detecting Structure
in Sociometric Data. <em>American Journal of Sociology</em>, 76, 492&ndash;513.
1970.
</p>
<p>Wasserman, S., and Faust, K. <em>Social Network Analysis: Methods and
Applications.</em> Cambridge: Cambridge University Press. 1994.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+triad_census">triad_census()</a></code> for the same classification, but with
triples.
</p>
<p>Other graph motifs: 
<code><a href="#topic+count_motifs">count_motifs</a>()</code>,
<code><a href="#topic+motifs">motifs</a>()</code>,
<code><a href="#topic+sample_motifs">sample_motifs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_pa(100)
dyad_census(g)
</code></pre>

<hr>
<h2 id='dyad.census'>Dyad census of a graph</h2><span id='topic+dyad.census'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>dyad.census()</code> was renamed to <code>dyad_census()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyad.census(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyad.census_+3A_graph">graph</code></td>
<td>
<p>The input graph. A warning is given if it is not directed.</p>
</td></tr>
</table>

<hr>
<h2 id='E'>Edges of a graph</h2><span id='topic+E'></span>

<h3>Description</h3>

<p>An edge sequence is a vector containing numeric edge ids, with a special
class attribute that allows custom operations: selecting subsets of
edges based on attributes, or graph structure, creating the
intersection, union of edges, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E(graph, P = NULL, path = NULL, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="E_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="E_+3A_p">P</code></td>
<td>
<p>A list of vertices to select edges via pairs of vertices.
The first and second vertices select the first edge, the third
and fourth the second, etc.</p>
</td></tr>
<tr><td><code id="E_+3A_path">path</code></td>
<td>
<p>A list of vertices, to select edges along a path.
Note that this only works reliable for simple graphs. If the graph
has multiple edges, one of them will be chosen arbitrarily to
be included in the edge sequence.</p>
</td></tr>
<tr><td><code id="E_+3A_directed">directed</code></td>
<td>
<p>Whether to consider edge directions in the <code>P</code>
argument, for directed graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Edge sequences are usually used as igraph function arguments that
refer to edges of a graph.
</p>
<p>An edge sequence is tied to the graph it refers to: it really denoted
the specific edges of that graph, and cannot be used together with
another graph.
</p>
<p>An edge sequence is most often created by the <code>E()</code> function. The
result includes edges in increasing edge id order by default (if. none
of the <code>P</code> and <code>path</code> arguments are used). An edge
sequence can be indexed by a numeric vector, just like a regular R
vector. See links to other edge sequence operations below.
</p>


<h3>Value</h3>

<p>An edge sequence of the graph.
</p>


<h3>Indexing edge sequences</h3>

<p>Edge sequences mostly behave like regular vectors, but there are some
additional indexing operations that are specific for them;
e.g. selecting edges based on graph structure, or based on edge
attributes. See <code><a href="#topic++5B.igraph.es">[.igraph.es</a></code> for details.
</p>


<h3>Querying or setting attributes</h3>

<p>Edge sequences can be used to query or set attributes for the
edges in the sequence. See <code><a href="#topic++24.igraph.es">$.igraph.es()</a></code> for details.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Edges of an unnamed graph
g &lt;- make_ring(10)
E(g)

# Edges of a named graph
g2 &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = letters[1:10])
E(g2)
</code></pre>

<hr>
<h2 id='each_edge'>Rewires the endpoints of the edges of a graph to a random vertex</h2><span id='topic+each_edge'></span>

<h3>Description</h3>

<p>This function can be used together with <code><a href="#topic+rewire">rewire()</a></code>.
This method rewires the endpoints of the edges with a constant probability
uniformly randomly to a new vertex in a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>each_edge(
  prob,
  loops = FALSE,
  multiple = FALSE,
  mode = c("all", "out", "in", "total")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="each_edge_+3A_prob">prob</code></td>
<td>
<p>The rewiring probability, a real number between zero and one.</p>
</td></tr>
<tr><td><code id="each_edge_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether loop edges are allowed in the rewired
graph.</p>
</td></tr>
<tr><td><code id="each_edge_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether multiple edges are allowed in the
generated graph.</p>
</td></tr>
<tr><td><code id="each_edge_+3A_mode">mode</code></td>
<td>
<p>Character string, specifies which endpoint of the edges to rewire
in directed graphs. &lsquo;all&rsquo; rewires both endpoints, &lsquo;in&rsquo; rewires
the start (tail) of each directed edge, &lsquo;out&rsquo; rewires the end (head)
of each directed edge. Ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this method might create graphs with multiple and/or loop edges.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other rewiring functions: 
<code><a href="#topic+keeping_degseq">keeping_degseq</a>()</code>,
<code><a href="#topic+rewire">rewire</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Some random shortcuts shorten the distances on a lattice
g &lt;- make_lattice(length = 100, dim = 1, nei = 5)
mean_distance(g)
g &lt;- rewire(g, each_edge(prob = 0.05))
mean_distance(g)

# Rewiring the start of each directed edge preserves the in-degree distribution
# but not the out-degree distribution
g &lt;- sample_pa(1000)
g2 &lt;- g %&gt;% rewire(each_edge(mode = "in", multiple = TRUE, prob = 0.2))
degree(g, mode = "in") == degree(g2, mode = "in")
</code></pre>

<hr>
<h2 id='eccentricity'>Eccentricity of the vertices in a graph</h2><span id='topic+eccentricity'></span>

<h3>Description</h3>

<p>The eccentricity of a vertex is its shortest path distance from the farthest
other node in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eccentricity(graph, vids = V(graph), mode = c("all", "out", "in", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eccentricity_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected.</p>
</td></tr>
<tr><td><code id="eccentricity_+3A_vids">vids</code></td>
<td>
<p>The vertices for which the eccentricity is calculated.</p>
</td></tr>
<tr><td><code id="eccentricity_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the corresponding
undirected graph will be used, edge directions will be ignored. This
argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The eccentricity of a vertex is calculated by measuring the shortest
distance from (or to) the vertex, to (or from) all vertices in the graph,
and taking the maximum.
</p>
<p>This implementation ignores vertex pairs that are in different components.
Isolate vertices have eccentricity zero.
</p>


<h3>Value</h3>

<p><code>eccentricity()</code> returns a numeric vector, containing the
eccentricity score of each given vertex.
</p>


<h3>References</h3>

<p>Harary, F. Graph Theory. Reading, MA: Addison-Wesley, p. 35,
1994.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+radius">radius()</a></code> for a related concept,
<code><a href="#topic+distances">distances()</a></code> for general shortest path calculations.
</p>
<p>Other paths: 
<code><a href="#topic+all_simple_paths">all_simple_paths</a>()</code>,
<code><a href="#topic+diameter">diameter</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+radius">radius</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_star(10, mode = "undirected")
eccentricity(g)
</code></pre>

<hr>
<h2 id='edge'>Helper function for adding and deleting edges</h2><span id='topic+edge'></span><span id='topic+edges'></span>

<h3>Description</h3>

<p>This is a helper function that simplifies adding and deleting
edges to/from graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge(...)

edges(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_+3A_...">...</code></td>
<td>
<p>See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>edges()</code> is an alias for <code>edge()</code>.
</p>
<p>When adding edges via <code>+</code>, all unnamed arguments of
<code>edge()</code> (or <code>edges()</code>) are concatenated, and then passed to
<code><a href="#topic+add_edges">add_edges()</a></code>. They are interpreted as pairs of vertex ids,
and an edge will added between each pair. Named arguments will be
used as edge attributes for the new edges.
</p>
<p>When deleting edges via <code>-</code>, all arguments of <code>edge()</code> (or
<code>edges()</code>) are concatenated via <code>c()</code> and passed to
<code><a href="#topic+delete_edges">delete_edges()</a></code>.
</p>


<h3>Value</h3>

<p>A special object that can be used with together with
igraph graphs and the plus and minus operators.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_edge_attr("color", value = "red")

g &lt;- g + edge(1, 5, color = "green") +
  edge(2, 6, color = "blue") -
  edge("8|9")

E(g)[[]]

g %&gt;%
  add_layout_(in_circle()) %&gt;%
  plot()

g &lt;- make_ring(10) + edges(1:10)
plot(g)
</code></pre>

<hr>
<h2 id='edge_attr'>Query edge attributes of a graph</h2><span id='topic+edge_attr'></span><span id='topic+edge.attributes'></span>

<h3>Description</h3>

<p>Query edge attributes of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_attr(graph, name, index = E(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_attr_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
<tr><td><code id="edge_attr_+3A_name">name</code></td>
<td>
<p>The name of the attribute to query. If missing, then
all edge attributes are returned in a list.</p>
</td></tr>
<tr><td><code id="edge_attr_+3A_index">index</code></td>
<td>
<p>An optional edge sequence to query edge attributes
for a subset of edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the edge attribute, or the list of all
edge attributes if <code>name</code> is missing.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_edge_attr("weight", value = 1:10) %&gt;%
  set_edge_attr("color", value = "red")
g
plot(g, edge.width = E(g)$weight)
</code></pre>

<hr>
<h2 id='edge_attr_names'>List names of edge attributes</h2><span id='topic+edge_attr_names'></span>

<h3>Description</h3>

<p>List names of edge attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_attr_names(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_attr_names_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector, the names of the edge attributes.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_edge_attr("label", value = letters[1:10])
edge_attr_names(g)
plot(g)
</code></pre>

<hr>
<h2 id='edge_attr+26lt+3B-'>Set one or more edge attributes</h2><span id='topic+edge_attr+3C-'></span><span id='topic+edge.attributes+3C-'></span>

<h3>Description</h3>

<p>Set one or more edge attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_attr(graph, name, index = E(graph)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_attr+2B26lt+2B3B-_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="edge_attr+2B26lt+2B3B-_+3A_name">name</code></td>
<td>
<p>The name of the edge attribute to set. If missing,
then <code>value</code> must be a named list, and its entries are
set as edge attributes.</p>
</td></tr>
<tr><td><code id="edge_attr+2B26lt+2B3B-_+3A_index">index</code></td>
<td>
<p>An optional edge sequence to set the attributes
of a subset of edges.</p>
</td></tr>
<tr><td><code id="edge_attr+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The new value of the attribute(s) for all
(or <code>index</code>) edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the edge attribute(s) added or set.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
edge_attr(g) &lt;- list(
  name = LETTERS[1:10],
  color = rep("green", gsize(g))
)
edge_attr(g, "label") &lt;- E(g)$name
g
plot(g)
</code></pre>

<hr>
<h2 id='edge_connectivity'>Edge connectivity</h2><span id='topic+edge_connectivity'></span><span id='topic+edge_disjoint_paths'></span><span id='topic+adhesion'></span>

<h3>Description</h3>

<p>The edge connectivity of a graph or two vertices, this is recently also
called group adhesion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_connectivity(graph, source = NULL, target = NULL, checks = TRUE)

edge_disjoint_paths(graph, source, target)

adhesion(graph, checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_connectivity_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="edge_connectivity_+3A_source">source</code></td>
<td>
<p>The id of the source vertex, for <code>edge_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="edge_connectivity_+3A_target">target</code></td>
<td>
<p>The id of the target vertex, for <code>edge_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="edge_connectivity_+3A_checks">checks</code></td>
<td>
<p>Logical constant. Whether to check that the graph is connected
and also the degree of the vertices. If the graph is not (strongly)
connected then the connectivity is obviously zero. Otherwise if the minimum
degree is one then the edge connectivity is also one. It is a good idea to
perform these checks, as they can be done quickly compared to the
connectivity calculation itself.  They were suggested by Peter McMahan,
thanks Peter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar real value.
</p>


<h3><code>edge_connectivity()</code> Edge connectivity</h3>

<p>The edge connectivity of a pair of vertices (<code>source</code> and
<code>target</code>) is the minimum number of edges needed to remove to eliminate
all (directed) paths from <code>source</code> to <code>target</code>.
<code>edge_connectivity()</code> calculates this quantity if both the <code>source</code>
and <code>target</code> arguments are given (and not <code>NULL</code>).
</p>
<p>The edge connectivity of a graph is the minimum of the edge connectivity of
every (ordered) pair of vertices in the graph.  <code>edge_connectivity()</code>
calculates this quantity if neither the <code>source</code> nor the <code>target</code>
arguments are given (i.e. they are both <code>NULL</code>).
</p>


<h3><code>edge_disjoint_paths()</code> The maximum number of edge-disjoint paths between two vertices</h3>

<p>A set of paths between two vertices is called edge-disjoint if they do not
share any edges. The maximum number of edge-disjoint paths are calculated
by this function using maximum flow techniques. Directed paths are
considered in directed graphs.
</p>
<p>A set of edge disjoint paths between two vertices is a set of paths between
them containing no common edges. The maximum number of edge disjoint paths
between two vertices is the same as their edge connectivity.
</p>
<p>When there are no direct edges between the source and the target, the number
of vertex-disjoint paths is the same as the vertex connectivity of
the two vertices. When some edges are present, each one of them
contributes one extra path.
</p>


<h3><code>adhesion()</code> Adhesion of a graph</h3>

<p>The adhesion of a graph is the minimum number of edges needed to remove to
obtain a graph which is not strongly connected. This is the same as the edge
connectivity of the graph.
</p>


<h3>All three functions</h3>

<p>The three functions documented on this page calculate similar properties,
more precisely the most general is <code>edge_connectivity()</code>, the others are
included only for having more descriptive function names.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Douglas R. White and Frank Harary: The cohesiveness of blocks in
social networks: node connectivity and conditional density, TODO: citation
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_pa(100, m = 1)
g2 &lt;- sample_pa(100, m = 5)
edge_connectivity(g, 100, 1)
edge_connectivity(g2, 100, 1)
edge_disjoint_paths(g2, 100, 1)

g &lt;- sample_gnp(50, 5 / 50)
g &lt;- as.directed(g)
g &lt;- induced_subgraph(g, subcomponent(g, 1))
adhesion(g)

</code></pre>

<hr>
<h2 id='edge_density'>Graph density</h2><span id='topic+edge_density'></span>

<h3>Description</h3>

<p>The density of a graph is the ratio of the actual number of edges and the
largest possible number of edges in the graph, assuming that no multi-edges
are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_density(graph, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge_density_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="edge_density_+3A_loops">loops</code></td>
<td>
<p>Logical constant, whether loop edges may exist in the graph.
This affects the calculation of the largest possible number of edges in the
graph. If this parameter is set to FALSE yet the graph contains self-loops,
the result will not be meaningful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The concept of density is ill-defined for multigraphs. Note that this function
does not check whether the graph has multi-edges and will return meaningless
results for such graphs.
</p>


<h3>Value</h3>

<p>A real constant. This function returns <code>NaN</code> (=0.0/0.0) for an
empty graph with zero vertices.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Wasserman, S., and Faust, K.  (1994).  Social Network Analysis:
Methods and Applications.  Cambridge: Cambridge University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcount">vcount()</a></code>, <code><a href="#topic+ecount">ecount()</a></code>, <code><a href="#topic+simplify">simplify()</a></code>
to get rid of the multiple and/or loop edges.
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- make_empty_graph(n = 10)
g2 &lt;- make_full_graph(n = 10)
g3 &lt;- sample_gnp(n = 10, 0.4)

# loop edges
g &lt;- make_graph(c(1, 2, 2, 2, 2, 3)) # graph with a self-loop
edge_density(g, loops = FALSE) # this is wrong!!!
edge_density(g, loops = TRUE) # this is right!!!
edge_density(simplify(g), loops = FALSE) # this is also right, but different

</code></pre>

<hr>
<h2 id='edge.betweenness'>Vertex and edge betweenness centrality</h2><span id='topic+edge.betweenness'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>edge.betweenness()</code> was renamed to <code>edge_betweenness()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.betweenness(
  graph,
  e = E(graph),
  directed = TRUE,
  weights = NULL,
  cutoff = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.betweenness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="edge.betweenness_+3A_e">e</code></td>
<td>
<p>The edges for which the edge betweenness will be calculated.</p>
</td></tr>
<tr><td><code id="edge.betweenness_+3A_directed">directed</code></td>
<td>
<p>Logical, whether directed paths should be considered while
determining the shortest paths.</p>
</td></tr>
<tr><td><code id="edge.betweenness_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
betweenness. If the graph has a <code>weight</code> edge attribute, then this is
used by default. Weights are used to calculate weighted shortest paths,
so they are interpreted as distances.</p>
</td></tr>
<tr><td><code id="edge.betweenness_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating the
betweenness. If zero or negative then there is no such limit.</p>
</td></tr>
</table>

<hr>
<h2 id='edge.betweenness.community'>Community structure detection based on edge betweenness</h2><span id='topic+edge.betweenness.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>edge.betweenness.community()</code> was renamed to <code>cluster_edge_betweenness()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.betweenness.community(
  graph,
  weights = NULL,
  directed = TRUE,
  edge.betweenness = TRUE,
  merges = TRUE,
  bridges = TRUE,
  modularity = TRUE,
  membership = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.betweenness.community_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="edge.betweenness.community_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. Edge weights
are used to calculate weighted edge betweenness. This means that edges are
interpreted as distances, not as connection strengths.</p>
</td></tr>
<tr><td><code id="edge.betweenness.community_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to calculate directed edge
betweenness for directed graphs. It is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="edge.betweenness.community_+3A_edge.betweenness">edge.betweenness</code></td>
<td>
<p>Logical constant, whether to return the edge
betweenness of the edges at the time of their removal.</p>
</td></tr>
<tr><td><code id="edge.betweenness.community_+3A_merges">merges</code></td>
<td>
<p>Logical constant, whether to return the merge matrix
representing the hierarchical community structure of the network.  This
argument is called <code>merges</code>, even if the community structure algorithm
itself is divisive and not agglomerative: it builds the tree from top to
bottom. There is one line for each merge (i.e. split) in matrix, the first
line is the first merge (last split). The communities are identified by
integer number starting from one. Community ids smaller than or equal to
<code class="reqn">N</code>, the number of vertices in the graph, belong to singleton
communities, i.e. individual vertices. Before the first merge we have <code class="reqn">N</code>
communities numbered from one to <code class="reqn">N</code>. The first merge, the first line of
the matrix creates community <code class="reqn">N+1</code>, the second merge creates community
<code class="reqn">N+2</code>, etc.</p>
</td></tr>
<tr><td><code id="edge.betweenness.community_+3A_bridges">bridges</code></td>
<td>
<p>Logical constant, whether to return a list the edge removals
which actually splitted a component of the graph.</p>
</td></tr>
<tr><td><code id="edge.betweenness.community_+3A_modularity">modularity</code></td>
<td>
<p>Logical constant, whether to calculate the maximum
modularity score, considering all possibly community structures along the
edge-betweenness based edge removals.</p>
</td></tr>
<tr><td><code id="edge.betweenness.community_+3A_membership">membership</code></td>
<td>
<p>Logical constant, whether to calculate the membership
vector corresponding to the highest possible modularity score.</p>
</td></tr>
</table>

<hr>
<h2 id='edge.connectivity'>Edge connectivity</h2><span id='topic+edge.connectivity'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>edge.connectivity()</code> was renamed to <code>edge_connectivity()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.connectivity(graph, source = NULL, target = NULL, checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.connectivity_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="edge.connectivity_+3A_source">source</code></td>
<td>
<p>The id of the source vertex, for <code>edge_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="edge.connectivity_+3A_target">target</code></td>
<td>
<p>The id of the target vertex, for <code>edge_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="edge.connectivity_+3A_checks">checks</code></td>
<td>
<p>Logical constant. Whether to check that the graph is connected
and also the degree of the vertices. If the graph is not (strongly)
connected then the connectivity is obviously zero. Otherwise if the minimum
degree is one then the edge connectivity is also one. It is a good idea to
perform these checks, as they can be done quickly compared to the
connectivity calculation itself.  They were suggested by Peter McMahan,
thanks Peter.</p>
</td></tr>
</table>

<hr>
<h2 id='edge.disjoint.paths'>Edge connectivity</h2><span id='topic+edge.disjoint.paths'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>edge.disjoint.paths()</code> was renamed to <code>edge_connectivity()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge.disjoint.paths(graph, source = NULL, target = NULL, checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edge.disjoint.paths_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="edge.disjoint.paths_+3A_source">source</code></td>
<td>
<p>The id of the source vertex, for <code>edge_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="edge.disjoint.paths_+3A_target">target</code></td>
<td>
<p>The id of the target vertex, for <code>edge_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="edge.disjoint.paths_+3A_checks">checks</code></td>
<td>
<p>Logical constant. Whether to check that the graph is connected
and also the degree of the vertices. If the graph is not (strongly)
connected then the connectivity is obviously zero. Otherwise if the minimum
degree is one then the edge connectivity is also one. It is a good idea to
perform these checks, as they can be done quickly compared to the
connectivity calculation itself.  They were suggested by Peter McMahan,
thanks Peter.</p>
</td></tr>
</table>

<hr>
<h2 id='eigen_centrality'>Find Eigenvector Centrality Scores of Network Positions</h2><span id='topic+eigen_centrality'></span>

<h3>Description</h3>

<p><code>eigen_centrality()</code> takes a graph (<code>graph</code>) and returns the
eigenvector centralities of positions <code>v</code> within it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_centrality(
  graph,
  directed = FALSE,
  scale = TRUE,
  weights = NULL,
  options = arpack_defaults()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigen_centrality_+3A_graph">graph</code></td>
<td>
<p>Graph to be analyzed.</p>
</td></tr>
<tr><td><code id="eigen_centrality_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to consider direction of the edges
in directed graphs. It is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="eigen_centrality_+3A_scale">scale</code></td>
<td>
<p>Logical scalar, whether to scale the result to have a maximum
score of one. If no scaling is used then the result vector has unit length
in the Euclidean norm.</p>
</td></tr>
<tr><td><code id="eigen_centrality_+3A_weights">weights</code></td>
<td>
<p>A numerical vector or <code>NULL</code>. This argument can be used
to give edge weights for calculating the weighted eigenvector centrality of
vertices. If this is <code>NULL</code> and the graph has a <code>weight</code> edge
attribute then that is used. If <code>weights</code> is a numerical vector then it is
used, even if the graph has a <code>weight</code> edge attribute. If this is
<code>NA</code>, then no edge weights are used (even if the graph has a
<code>weight</code> edge attribute). Note that if there are negative edge weights
and the direction of the edges is considered, then the eigenvector might be
complex. In this case only the real part is reported.
This function interprets weights as connection strength. Higher
weights spread the centrality better.</p>
</td></tr>
<tr><td><code id="eigen_centrality_+3A_options">options</code></td>
<td>
<p>A named list, to override some ARPACK options. See
<code><a href="#topic+arpack">arpack()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eigenvector centrality scores correspond to the values of the first
eigenvector of the graph adjacency matrix; these scores may, in turn, be
interpreted as arising from a reciprocal process in which the centrality of
each actor is proportional to the sum of the centralities of those actors to
whom he or she is connected.  In general, vertices with high eigenvector
centralities are those which are connected to many other vertices which are,
in turn, connected to many others (and so on).  (The perceptive may realize
that this implies that the largest values will be obtained by individuals in
large cliques (or high-density substructures).  This is also intelligible
from an algebraic point of view, with the first eigenvector being closely
related to the best rank-1 approximation of the adjacency matrix (a
relationship which is easy to see in the special case of a diagonalizable
symmetric real matrix via the <code class="reqn">SLS^-1</code>
decomposition).)
</p>
<p>The adjacency matrix used in the eigenvector centrality calculation assumes
that loop edges are counted <em>twice</em>; this is because each loop edge has
<em>two</em> endpoints that are both connected to the same vertex, and you
could traverse the loop edge via either endpoint.
</p>
<p>In the directed case, the left eigenvector of the adjacency matrix is
calculated. In other words, the centrality of a vertex is proportional to
the sum of centralities of vertices pointing to it.
</p>
<p>Eigenvector centrality is meaningful only for connected graphs. Graphs that
are not connected should be decomposed into connected components, and the
eigenvector centrality calculated for each separately. This function does
not verify that the graph is connected. If it is not, in the undirected case
the scores of all but one component will be zeros.
</p>
<p>Also note that the adjacency matrix of a directed acyclic graph or the
adjacency matrix of an empty graph does not possess positive eigenvalues,
therefore the eigenvector centrality is not defined for these graphs.
igraph will return an eigenvalue of zero in such cases. The eigenvector
centralities will all be equal for an empty graph and will all be zeros for
a directed acyclic graph. Such pathological cases can be detected by checking
whether the eigenvalue is very close to zero.
</p>
<p>From igraph version 0.5 this function uses ARPACK for the underlying
computation, see <code><a href="#topic+arpack">arpack()</a></code> for more about ARPACK in igraph.
</p>


<h3>Value</h3>

<p>A named list with components: </p>
<table>
<tr><td><code>vector</code></td>
<td>
<p>A vector containing the
centrality scores.</p>
</td></tr> <tr><td><code>value</code></td>
<td>
<p>The eigenvalue corresponding to the
calculated eigenvector, i.e. the centrality scores.</p>
</td></tr> <tr><td><code>options</code></td>
<td>
<p>A named
list, information about the underlying ARPACK computation. See
<code><a href="#topic+arpack">arpack()</a></code> for the details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> and Carter T. Butts
(<a href="http://www.faculty.uci.edu/profile.cfm?faculty_id=5057">http://www.faculty.uci.edu/profile.cfm?faculty_id=5057</a>) for the
manual page.
</p>


<h3>References</h3>

<p>Bonacich, P.  (1987).  Power and Centrality: A Family of
Measures. <em>American Journal of Sociology</em>, 92, 1170-1182.
</p>


<h3>See Also</h3>

<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some test data
g &lt;- make_ring(10, directed = FALSE)
# Compute eigenvector centrality scores
eigen_centrality(g)
</code></pre>

<hr>
<h2 id='embed_adjacency_matrix'>Spectral Embedding of Adjacency Matrices</h2><span id='topic+embed_adjacency_matrix'></span>

<h3>Description</h3>

<p>Spectral decomposition of the adjacency matrices of graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embed_adjacency_matrix(
  graph,
  no,
  weights = NULL,
  which = c("lm", "la", "sa"),
  scaled = TRUE,
  cvec = strength(graph, weights = weights)/(vcount(graph) - 1),
  options = arpack_defaults()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embed_adjacency_matrix_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed or undirected.</p>
</td></tr>
<tr><td><code id="embed_adjacency_matrix_+3A_no">no</code></td>
<td>
<p>An integer scalar. This value is the embedding dimension of the
spectral embedding. Should be smaller than the number of vertices. The
largest <code>no</code>-dimensional non-zero singular values are used for the
spectral embedding.</p>
</td></tr>
<tr><td><code id="embed_adjacency_matrix_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating a weighted
embedding. If the graph has a <code>weight</code> edge attribute, then this is
used by default. In a weighted embedding, the edge weights are used instead
of the binary adjacencny matrix.</p>
</td></tr>
<tr><td><code id="embed_adjacency_matrix_+3A_which">which</code></td>
<td>
<p>Which eigenvalues (or singular values, for directed graphs) to
use. &lsquo;lm&rsquo; means the ones with the largest magnitude, &lsquo;la&rsquo; is
the ones (algebraic) largest, and &lsquo;sa&rsquo; is the (algebraic) smallest
eigenvalues. The default is &lsquo;lm&rsquo;. Note that for directed graphs
&lsquo;la&rsquo; and &lsquo;lm&rsquo; are the equivalent, because the singular values
are used for the ordering.</p>
</td></tr>
<tr><td><code id="embed_adjacency_matrix_+3A_scaled">scaled</code></td>
<td>
<p>Logical scalar, if <code>FALSE</code>, then <code class="reqn">U</code> and <code class="reqn">V</code> are
returned instead of <code class="reqn">X</code> and <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="embed_adjacency_matrix_+3A_cvec">cvec</code></td>
<td>
<p>A numeric vector, its length is the number vertices in the
graph. This vector is added to the diagonal of the adjacency matrix.</p>
</td></tr>
<tr><td><code id="embed_adjacency_matrix_+3A_options">options</code></td>
<td>
<p>A named list containing the parameters for the SVD
computation algorithm in ARPACK. By default, the list of values is assigned
the values given by <code><a href="#topic+arpack_defaults">arpack_defaults()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a <code>no</code>-dimensional Euclidean representation of
the graph based on its adjacency matrix, <code class="reqn">A</code>. This representation is
computed via the singular value decomposition of the adjacency matrix,
<code class="reqn">A=UDV^T</code>.In the case, where the graph is a random dot product graph
generated using latent position vectors in <code class="reqn">R^{no}</code> for each vertex, the
embedding will provide an estimate of these latent vectors.
</p>
<p>For undirected graphs the latent positions are calculated as
<code class="reqn">X=U^{no}D^{1/2}</code>, where <code class="reqn">U^{no}</code> equals
to the first <code>no</code> columns of <code class="reqn">U</code>, and <code class="reqn">D^{1/2}</code> is
a diagonal matrix containing the top <code>no</code> singular values on the
diagonal.
</p>
<p>For directed graphs the embedding is defined as the pair
<code class="reqn">X=U^{no}D^{1/2}</code> and <code class="reqn">Y=V^{no}D^{1/2}</code>. (For undirected graphs <code class="reqn">U=V</code>, so it is enough to keep one
of them.)
</p>


<h3>Value</h3>

<p>A list containing with entries: </p>
<table>
<tr><td><code>X</code></td>
<td>
<p>Estimated latent positions,
an <code>n</code> times <code>no</code> matrix, <code>n</code> is the number of vertices.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>NULL</code> for undirected graphs, the second half of the latent
positions for directed graphs, an <code>n</code> times <code>no</code> matrix, <code>n</code>
is the number of vertices.</p>
</td></tr> <tr><td><code>D</code></td>
<td>
<p>The eigenvalues (for undirected graphs)
or the singular values (for directed graphs) calculated by the algorithm.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>A named list, information about the underlying ARPACK
computation. See <code><a href="#topic+arpack">arpack()</a></code> for the details.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E.  A
Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,
<em>Journal of the American Statistical Association</em>, Vol. 107(499), 2012
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_dot_product">sample_dot_product()</a></code>
</p>
<p>Other embedding: 
<code><a href="#topic+dim_select">dim_select</a>()</code>,
<code><a href="#topic+embed_laplacian_matrix">embed_laplacian_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A small graph
lpvs &lt;- matrix(rnorm(200), 20, 10)
lpvs &lt;- apply(lpvs, 2, function(x) {
  return(abs(x) / sqrt(sum(x^2)))
})
RDP &lt;- sample_dot_product(lpvs)
embed &lt;- embed_adjacency_matrix(RDP, 5)
</code></pre>

<hr>
<h2 id='embed_laplacian_matrix'>Spectral Embedding of the Laplacian of a Graph</h2><span id='topic+embed_laplacian_matrix'></span>

<h3>Description</h3>

<p>Spectral decomposition of Laplacian matrices of graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>embed_laplacian_matrix(
  graph,
  no,
  weights = NULL,
  which = c("lm", "la", "sa"),
  type = c("default", "D-A", "DAD", "I-DAD", "OAP"),
  scaled = TRUE,
  options = arpack_defaults()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="embed_laplacian_matrix_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed or undirected.</p>
</td></tr>
<tr><td><code id="embed_laplacian_matrix_+3A_no">no</code></td>
<td>
<p>An integer scalar. This value is the embedding dimension of the
spectral embedding. Should be smaller than the number of vertices. The
largest <code>no</code>-dimensional non-zero singular values are used for the
spectral embedding.</p>
</td></tr>
<tr><td><code id="embed_laplacian_matrix_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating a weighted
embedding. If the graph has a <code>weight</code> edge attribute, then this is
used by default. For weighted embedding, edge weights are used instead
of the binary adjacency matrix, and vertex strength (see
<code><a href="#topic+strength">strength()</a></code>) is used instead of the degrees.</p>
</td></tr>
<tr><td><code id="embed_laplacian_matrix_+3A_which">which</code></td>
<td>
<p>Which eigenvalues (or singular values, for directed graphs) to
use. &lsquo;lm&rsquo; means the ones with the largest magnitude, &lsquo;la&rsquo; is
the ones (algebraic) largest, and &lsquo;sa&rsquo; is the (algebraic) smallest
eigenvalues. The default is &lsquo;lm&rsquo;. Note that for directed graphs
&lsquo;la&rsquo; and &lsquo;lm&rsquo; are the equivalent, because the singular values
are used for the ordering.</p>
</td></tr>
<tr><td><code id="embed_laplacian_matrix_+3A_type">type</code></td>
<td>
<p>The type of the Laplacian to use. Various definitions exist for
the Laplacian of a graph, and one can choose between them with this
argument.
</p>
<p>Possible values: <code>D-A</code> means <code class="reqn">D-A</code> where <code class="reqn">D</code> is the degree
matrix and <code class="reqn">A</code> is the adjacency matrix; <code>DAD</code> means
<code class="reqn">D^{1/2}</code> times <code class="reqn">A</code> times <code class="reqn">D^{1/2}{D^1/2}</code>,
<code class="reqn">D^{1/2}</code> is the inverse of the square root of the degree matrix;
<code>I-DAD</code> means <code class="reqn">I-D^{1/2}</code>, where <code class="reqn">I</code> is the identity
matrix.  <code>OAP</code> is <code class="reqn">O^{1/2}AP^{1/2}</code>, where
<code class="reqn">O^{1/2}</code> is the inverse of the square root of the out-degree
matrix and <code class="reqn">P^{1/2}</code> is the same for the in-degree matrix.
</p>
<p><code>OAP</code> is not defined for undirected graphs, and is the only defined type
for directed graphs.
</p>
<p>The default (i.e. type <code>default</code>) is to use <code>D-A</code> for undirected
graphs and <code>OAP</code> for directed graphs.</p>
</td></tr>
<tr><td><code id="embed_laplacian_matrix_+3A_scaled">scaled</code></td>
<td>
<p>Logical scalar, if <code>FALSE</code>, then <code class="reqn">U</code> and <code class="reqn">V</code> are
returned instead of <code class="reqn">X</code> and <code class="reqn">Y</code>.</p>
</td></tr>
<tr><td><code id="embed_laplacian_matrix_+3A_options">options</code></td>
<td>
<p>A named list containing the parameters for the SVD
computation algorithm in ARPACK. By default, the list of values is assigned
the values given by <code><a href="#topic+arpack_defaults">arpack_defaults()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a <code>no</code>-dimensional Euclidean representation of
the graph based on its Laplacian matrix, <code class="reqn">L</code>. This representation is
computed via the singular value decomposition of the Laplacian matrix.
</p>
<p>They are essentially doing the same as <code><a href="#topic+embed_adjacency_matrix">embed_adjacency_matrix()</a></code>,
but work on the Laplacian matrix, instead of the adjacency matrix.
</p>


<h3>Value</h3>

<p>A list containing with entries: </p>
<table>
<tr><td><code>X</code></td>
<td>
<p>Estimated latent positions,
an <code>n</code> times <code>no</code> matrix, <code>n</code> is the number of vertices.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p><code>NULL</code> for undirected graphs, the second half of the latent
positions for directed graphs, an <code>n</code> times <code>no</code> matrix, <code>n</code>
is the number of vertices.</p>
</td></tr> <tr><td><code>D</code></td>
<td>
<p>The eigenvalues (for undirected graphs)
or the singular values (for directed graphs) calculated by the algorithm.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>A named list, information about the underlying ARPACK
computation. See <code><a href="#topic+arpack">arpack()</a></code> for the details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Sussman, D.L., Tang, M., Fishkind, D.E., Priebe, C.E.  A
Consistent Adjacency Spectral Embedding for Stochastic Blockmodel Graphs,
<em>Journal of the American Statistical Association</em>, Vol. 107(499), 2012
</p>


<h3>See Also</h3>

<p><code><a href="#topic+embed_adjacency_matrix">embed_adjacency_matrix()</a></code>,
<code><a href="#topic+sample_dot_product">sample_dot_product()</a></code>
</p>
<p>Other embedding: 
<code><a href="#topic+dim_select">dim_select</a>()</code>,
<code><a href="#topic+embed_adjacency_matrix">embed_adjacency_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A small graph
lpvs &lt;- matrix(rnorm(200), 20, 10)
lpvs &lt;- apply(lpvs, 2, function(x) {
  return(abs(x) / sqrt(sum(x^2)))
})
RDP &lt;- sample_dot_product(lpvs)
embed &lt;- embed_laplacian_matrix(RDP, 5)
</code></pre>

<hr>
<h2 id='ends'>Incident vertices of some graph edges</h2><span id='topic+ends'></span><span id='topic+get.edges'></span><span id='topic+get.edge'></span>

<h3>Description</h3>

<p>Incident vertices of some graph edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ends(graph, es, names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ends_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="ends_+3A_es">es</code></td>
<td>
<p>The sequence of edges to query</p>
</td></tr>
<tr><td><code id="ends_+3A_names">names</code></td>
<td>
<p>Whether to return vertex names or
numeric vertex ids. By default vertex names are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two column matrix of vertex names or vertex ids.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(5)
ends(g, E(g))
</code></pre>

<hr>
<h2 id='erdos.renyi.game'>Generate random graphs according to the Erdős-Rényi model</h2><span id='topic+erdos.renyi.game'></span><span id='topic+random.graph.game'></span>

<h3>Description</h3>

<p>Simple random graph model, specifying the edge count either precisely
(<code class="reqn">G(n,m)</code> model) or on average through a connection probability
(<code class="reqn">G(n,p)</code> model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erdos.renyi.game(
  n,
  p.or.m,
  type = c("gnp", "gnm"),
  directed = FALSE,
  loops = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erdos.renyi.game_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="erdos.renyi.game_+3A_p.or.m">p.or.m</code></td>
<td>
<p>Either the probability for drawing an edge between two
arbitrary vertices (<code class="reqn">G(n,p)</code> graph), or the number of edges in
the graph (for <code class="reqn">G(n,m)</code> graphs).</p>
</td></tr>
<tr><td><code id="erdos.renyi.game_+3A_type">type</code></td>
<td>
<p>The type of the random graph to create, either <code>gnp()</code>
(<code class="reqn">G(n,p)</code> graph) or <code>gnm()</code> (<code class="reqn">G(n,m)</code> graph).</p>
</td></tr>
<tr><td><code id="erdos.renyi.game_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the graph will be directed, defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="erdos.renyi.game_+3A_loops">loops</code></td>
<td>
<p>Logical, whether to add loop edges, defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code class="reqn">G(n,m)</code> graphs, there are precisely <code>m</code> edges.
</p>
<p>In <code class="reqn">G(n,p)</code> graphs, all vertex pairs are connected with the same
probability <code>p</code>.
</p>
<p><code>random.graph.game()</code> is an alias to this function.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Deprecated</h3>

<p>Since igraph version 0.8.0, both <code>erdos.renyi.game()</code> and
<code>random.graph.game()</code> are deprecated, and <code><a href="#topic+sample_gnp">sample_gnp()</a></code> and
<code><a href="#topic+sample_gnm">sample_gnm()</a></code> should be used instead. See these for more details.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Erdős, P. and Rényi, A., On random graphs, <em>Publicationes
Mathematicae</em> 6, 290&ndash;297 (1959).
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- erdos.renyi.game(1000, 1 / 1000)
degree_distribution(g)

</code></pre>

<hr>
<h2 id='establishment.game'>Graph generation based on different vertex types</h2><span id='topic+establishment.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>establishment.game()</code> was renamed to <code>sample_traits()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>establishment.game(
  nodes,
  types,
  k = 1,
  type.dist = rep(1, types),
  pref.matrix = matrix(1, types, types),
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="establishment.game_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="establishment.game_+3A_types">types</code></td>
<td>
<p>The number of different vertex types.</p>
</td></tr>
<tr><td><code id="establishment.game_+3A_k">k</code></td>
<td>
<p>The number of trials per time step, see details below.</p>
</td></tr>
<tr><td><code id="establishment.game_+3A_type.dist">type.dist</code></td>
<td>
<p>The distribution of the vertex types. This is assumed to be
stationary in time.</p>
</td></tr>
<tr><td><code id="establishment.game_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>A matrix giving the preferences of the given vertex
types. These should be probabilities, i.e. numbers between zero and one.</p>
</td></tr>
<tr><td><code id="establishment.game_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to generate directed graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='estimate_betweenness'>Deprecated version of <code>betweenness()</code></h2><span id='topic+estimate_betweenness'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Use <code><a href="#topic+betweenness">betweenness()</a></code> with the <code>cutoff</code> argument instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_betweenness(
  graph,
  vids = V(graph),
  directed = TRUE,
  cutoff,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_betweenness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="estimate_betweenness_+3A_vids">vids</code></td>
<td>
<p>The vertices for which the vertex betweenness estimation will be
calculated.</p>
</td></tr>
<tr><td><code id="estimate_betweenness_+3A_directed">directed</code></td>
<td>
<p>Logical, whether directed paths should be considered while
determining the shortest paths.</p>
</td></tr>
<tr><td><code id="estimate_betweenness_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating the
betweenness. If zero or negative then there is no such limit.</p>
</td></tr>
<tr><td><code id="estimate_betweenness_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
betweenness. If the graph has a <code>weight</code> edge attribute, then this is
used by default. Weights are used to calculate weighted shortest paths,
so they are interpreted as distances.</p>
</td></tr>
</table>

<hr>
<h2 id='estimate_closeness'>Deprecated version of <code>closeness()</code></h2><span id='topic+estimate_closeness'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Use <code><a href="#topic+closeness">closeness()</a></code> with the <code>cutoff</code> argument instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_closeness(
  graph,
  vids = V(graph),
  mode = c("out", "in", "all", "total"),
  cutoff,
  weights = NULL,
  normalized = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_closeness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="estimate_closeness_+3A_vids">vids</code></td>
<td>
<p>The vertices for which closeness will be calculated.</p>
</td></tr>
<tr><td><code id="estimate_closeness_+3A_mode">mode</code></td>
<td>
<p>Character string, defined the types of the paths used for
measuring the distance in directed graphs. &ldquo;in&rdquo; measures the paths
<em>to</em> a vertex, &ldquo;out&rdquo; measures paths <em>from</em> a vertex,
<em>all</em> uses undirected paths. This argument is ignored for undirected
graphs.</p>
</td></tr>
<tr><td><code id="estimate_closeness_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating the
closeness. If zero or negative then there is no such limit.</p>
</td></tr>
<tr><td><code id="estimate_closeness_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
closeness. If the graph has a <code>weight</code> edge attribute, then this is
used by default. Weights are used for calculating weighted shortest
paths, so they are interpreted as distances.</p>
</td></tr>
<tr><td><code id="estimate_closeness_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to calculate the normalized
closeness, i.e. the inverse average distance to all reachable vertices.
The non-normalized closeness is the inverse of the sum of distances to
all reachable vertices.</p>
</td></tr>
</table>

<hr>
<h2 id='estimate_edge_betweenness'>Deprecated version of <code>edge_betweenness()</code></h2><span id='topic+estimate_edge_betweenness'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Use <code><a href="#topic+edge_betweenness">edge_betweenness()</a></code> with the <code>cutoff</code> argument instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_edge_betweenness(
  graph,
  e = E(graph),
  directed = TRUE,
  cutoff,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_edge_betweenness_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="estimate_edge_betweenness_+3A_e">e</code></td>
<td>
<p>The edges for which the edge betweenness will be calculated.</p>
</td></tr>
<tr><td><code id="estimate_edge_betweenness_+3A_directed">directed</code></td>
<td>
<p>Logical, whether directed paths should be considered while
determining the shortest paths.</p>
</td></tr>
<tr><td><code id="estimate_edge_betweenness_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating the
betweenness. If zero or negative then there is no such limit.</p>
</td></tr>
<tr><td><code id="estimate_edge_betweenness_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
betweenness. If the graph has a <code>weight</code> edge attribute, then this is
used by default. Weights are used to calculate weighted shortest paths,
so they are interpreted as distances.</p>
</td></tr>
</table>

<hr>
<h2 id='evcent'>Find Eigenvector Centrality Scores of Network Positions</h2><span id='topic+evcent'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>evcent()</code> was renamed to <code>eigen_centrality()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evcent(
  graph,
  directed = FALSE,
  scale = TRUE,
  weights = NULL,
  options = arpack_defaults()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evcent_+3A_graph">graph</code></td>
<td>
<p>Graph to be analyzed.</p>
</td></tr>
<tr><td><code id="evcent_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to consider direction of the edges
in directed graphs. It is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="evcent_+3A_scale">scale</code></td>
<td>
<p>Logical scalar, whether to scale the result to have a maximum
score of one. If no scaling is used then the result vector has unit length
in the Euclidean norm.</p>
</td></tr>
<tr><td><code id="evcent_+3A_weights">weights</code></td>
<td>
<p>A numerical vector or <code>NULL</code>. This argument can be used
to give edge weights for calculating the weighted eigenvector centrality of
vertices. If this is <code>NULL</code> and the graph has a <code>weight</code> edge
attribute then that is used. If <code>weights</code> is a numerical vector then it is
used, even if the graph has a <code>weight</code> edge attribute. If this is
<code>NA</code>, then no edge weights are used (even if the graph has a
<code>weight</code> edge attribute). Note that if there are negative edge weights
and the direction of the edges is considered, then the eigenvector might be
complex. In this case only the real part is reported.
This function interprets weights as connection strength. Higher
weights spread the centrality better.</p>
</td></tr>
<tr><td><code id="evcent_+3A_options">options</code></td>
<td>
<p>A named list, to override some ARPACK options. See
<code><a href="#topic+arpack">arpack()</a></code> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='exportPajek'>Calculate Cohesive Blocks</h2><span id='topic+exportPajek'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>exportPajek()</code> was renamed to <code>export_pajek()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportPajek(blocks, graph, file, project.file = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportPajek_+3A_graph">graph</code></td>
<td>
<p>For <code>cohesive_blocks()</code> a graph object of class
<code>igraph</code>. It must be undirected and simple. (See
<code><a href="#topic+is_simple">is_simple()</a></code>.)
</p>
<p>For <code>graphs_from_cohesive_blocks()</code> and <code>export_pajek()</code> the same graph must be
supplied whose cohesive block structure is given in the <code>blocks()</code>
argument.</p>
</td></tr>
<tr><td><code id="exportPajek_+3A_file">file</code></td>
<td>
<p>Defines the file (or connection) the Pajek file is written to.
</p>
<p>If the <code>project.file</code> argument is <code>TRUE</code>, then it can be a
filename (with extension), a file object, or in general any king of
connection object. The file/connection will be opened if it wasn't already.
</p>
<p>If the <code>project.file</code> argument is <code>FALSE</code>, then several files are
created and <code>file</code> must be a character scalar containing the base name
of the files, without extension. (But it can contain the path to the files.)
</p>
<p>See also details below.</p>
</td></tr>
<tr><td><code id="exportPajek_+3A_project.file">project.file</code></td>
<td>
<p>Logical scalar, whether to create a single Pajek project
file containing all the data, or to create separated files for each item.
See details below.</p>
</td></tr>
</table>

<hr>
<h2 id='farthest.nodes'>Diameter of a graph</h2><span id='topic+farthest.nodes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>farthest.nodes()</code> was renamed to <code>farthest_vertices()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>farthest.nodes(graph, directed = TRUE, unconnected = TRUE, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="farthest.nodes_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="farthest.nodes_+3A_directed">directed</code></td>
<td>
<p>Logical, whether directed or undirected paths are to be
considered. This is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="farthest.nodes_+3A_unconnected">unconnected</code></td>
<td>
<p>Logical, what to do if the graph is unconnected. If
FALSE, the function will return a number that is one larger the largest
possible diameter, which is always the number of vertices. If TRUE, the
diameters of the connected components will be calculated and the largest one
will be returned.</p>
</td></tr>
<tr><td><code id="farthest.nodes_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
distances. If the graph has a <code>weight</code> edge attribute, then this is
used by default.</p>
</td></tr>
</table>

<hr>
<h2 id='fastgreedy.community'>Community structure via greedy optimization of modularity</h2><span id='topic+fastgreedy.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>fastgreedy.community()</code> was renamed to <code>cluster_fast_greedy()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastgreedy.community(
  graph,
  merges = TRUE,
  modularity = TRUE,
  membership = TRUE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastgreedy.community_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="fastgreedy.community_+3A_merges">merges</code></td>
<td>
<p>Logical scalar, whether to return the merge matrix.</p>
</td></tr>
<tr><td><code id="fastgreedy.community_+3A_modularity">modularity</code></td>
<td>
<p>Logical scalar, whether to return a vector containing the
modularity after each merge.</p>
</td></tr>
<tr><td><code id="fastgreedy.community_+3A_membership">membership</code></td>
<td>
<p>Logical scalar, whether to calculate the membership vector
corresponding to the maximum modularity score, considering all possible
community structures along the merges.</p>
</td></tr>
<tr><td><code id="fastgreedy.community_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
</table>

<hr>
<h2 id='feedback_arc_set'>Finding a feedback arc set in a graph</h2><span id='topic+feedback_arc_set'></span>

<h3>Description</h3>

<p>A feedback arc set of a graph is a subset of edges whose removal breaks all
cycles in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feedback_arc_set(graph, weights = NULL, algo = c("approx_eades", "exact_ip"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feedback_arc_set_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="feedback_arc_set_+3A_weights">weights</code></td>
<td>
<p>Potential edge weights. If the graph has an edge
attribute called &lsquo;<code>weight</code>&rsquo;, and this argument is
<code>NULL</code>, then the edge attribute is used automatically. The goal of
the feedback arc set problem is to find a feedback arc set with the smallest
total weight.</p>
</td></tr>
<tr><td><code id="feedback_arc_set_+3A_algo">algo</code></td>
<td>
<p>Specifies the algorithm to use. &ldquo;<code>exact_ip</code>&rdquo; solves
the feedback arc set problem with an exact integer programming algorithm that
guarantees that the total weight of the removed edges is as small as possible.
&ldquo;<code>approx_eades</code>&rdquo; uses a fast (linear-time) approximation
algorithm from Eades, Lin and Smyth. &ldquo;<code>exact</code>&rdquo; is an alias to
&ldquo;<code>exact_ip</code>&rdquo; while &ldquo;<code>approx</code>&rdquo; is an alias to
&ldquo;<code>approx_eades</code>&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Feedback arc sets are typically used in directed graphs. The removal of a
feedback arc set of a directed graph ensures that the remaining graph is a
directed acyclic graph (DAG). For undirected graphs, the removal of a feedback
arc set ensures that the remaining graph is a forest (i.e. every connected
component is a tree).
</p>


<h3>Value</h3>

<p>An edge sequence (by default, but see the <code>return.vs.es</code> option
of <code><a href="#topic+igraph_options">igraph_options()</a></code>) containing the feedback arc set.
</p>


<h3>References</h3>

<p>Peter Eades, Xuemin Lin and W.F.Smyth: A fast and effective
heuristic for the feedback arc set problem. <em>Information Processing Letters</em>
47:6, pp. 319-323, 1993
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>
<p>Graph cycles
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+has_eulerian_path">has_eulerian_path</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnm(20, 40, directed = TRUE)
feedback_arc_set(g)
feedback_arc_set(g, algo = "approx")
</code></pre>

<hr>
<h2 id='fit_hrg'>Fit a hierarchical random graph model</h2><span id='topic+fit_hrg'></span>

<h3>Description</h3>

<p><code>fit_hrg()</code> fits a HRG to a given graph. It takes the specified
<code>steps</code> number of MCMC steps to perform the fitting, or a convergence
criteria if the specified number of steps is zero. <code>fit_hrg()</code> can start
from a given HRG, if this is given in the <code>hrg()</code> argument and the
<code>start</code> argument is <code>TRUE</code>. It can be converted to the <code>hclust</code> class using
<code>as.hclust()</code> provided in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_hrg(graph, hrg = NULL, start = FALSE, steps = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_hrg_+3A_graph">graph</code></td>
<td>
<p>The graph to fit the model to. Edge directions are ignored in
directed graphs.</p>
</td></tr>
<tr><td><code id="fit_hrg_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model, in the form of an
<code>igraphHRG</code> object. <code>fit_hrg()</code> allows this to be <code>NULL</code>, in
which case a random starting point is used for the fitting.</p>
</td></tr>
<tr><td><code id="fit_hrg_+3A_start">start</code></td>
<td>
<p>Logical, whether to start the fitting/sampling from the
supplied <code>igraphHRG</code> object, or from a random starting point.</p>
</td></tr>
<tr><td><code id="fit_hrg_+3A_steps">steps</code></td>
<td>
<p>The number of MCMC steps to make. If this is zero, then the
MCMC procedure is performed until convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fit_hrg()</code> returns an <code>igraphHRG</code> object. This is a list
with the following members:
</p>
<table>
<tr><td><code>left</code></td>
<td>
<p>Vector that contains the left children of the internal
tree vertices. The first vertex is always the root vertex, so the
first element of the vector is the left child of the root
vertex. Internal vertices are denoted with negative numbers, starting
from -1 and going down, i.e. the root vertex is -1. Leaf vertices
are denoted by non-negative number, starting from zero and up.</p>
</td></tr>
<tr><td><code>right</code></td>
<td>
<p>Vector that contains the right children of the vertices,
with the same encoding as the <code>left</code> vector.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>The connection probabilities attached to the internal
vertices, the first number belongs to the root vertex (i.e. internal
vertex -1), the second to internal vertex -2, etc.</p>
</td></tr>
<tr><td><code>edges</code></td>
<td>
<p>The number of edges in the subtree below the given
internal vertex.</p>
</td></tr>
<tr><td><code>vertices</code></td>
<td>
<p>The number of vertices in the subtree below the
given internal vertex, including itself.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Clauset, C. Moore, and M.E.J. Newman. Hierarchical structure
and the prediction of missing links in networks. <em>Nature</em> 453, 98&ndash;101
(2008);
</p>
<p>A. Clauset, C. Moore, and M.E.J. Newman. Structural Inference of Hierarchies
in Networks. In E. M. Airoldi et al. (Eds.): ICML 2006 Ws, <em>Lecture
Notes in Computer Science</em> 4503, 1&ndash;13. Springer-Verlag, Berlin Heidelberg
(2007).
</p>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+consensus_tree">consensus_tree</a>()</code>,
<code><a href="#topic+hrg">hrg</a>()</code>,
<code><a href="#topic+hrg-methods">hrg-methods</a></code>,
<code><a href="#topic+hrg_tree">hrg_tree</a>()</code>,
<code><a href="#topic+predict_edges">predict_edges</a>()</code>,
<code><a href="#topic+print.igraphHRG">print.igraphHRG</a>()</code>,
<code><a href="#topic+print.igraphHRGConsensus">print.igraphHRGConsensus</a>()</code>,
<code><a href="#topic+sample_hrg">sample_hrg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## We are not running these examples any more, because they
## take a long time (~15 seconds) to run and this is against the CRAN
## repository policy. Copy and paste them by hand to your R prompt if
## you want to run them.

## A graph with two dense groups
g &lt;- sample_gnp(10, p = 1 / 2) + sample_gnp(10, p = 1 / 2)
hrg &lt;- fit_hrg(g)
hrg
summary(as.hclust(hrg))

## The consensus tree for it
consensus_tree(g, hrg = hrg, start = TRUE)

## Prediction of missing edges
g2 &lt;- make_full_graph(4) + (make_full_graph(4) - path(1, 2))
predict_edges(g2)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_power_law'>Fitting a power-law distribution function to discrete data</h2><span id='topic+fit_power_law'></span>

<h3>Description</h3>

<p><code>fit_power_law()</code> fits a power-law distribution to a data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_power_law(
  x,
  xmin = NULL,
  start = 2,
  force.continuous = FALSE,
  implementation = c("plfit", "R.mle"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_power_law_+3A_x">x</code></td>
<td>
<p>The data to fit, a numeric vector. For implementation
&lsquo;<code>R.mle</code>&rsquo; the data must be integer values. For the
&lsquo;<code>plfit</code>&rsquo; implementation non-integer values might be present and
then a continuous power-law distribution is fitted.</p>
</td></tr>
<tr><td><code id="fit_power_law_+3A_xmin">xmin</code></td>
<td>
<p>Numeric scalar, or <code>NULL</code>. The lower bound for fitting the
power-law. If <code>NULL</code>, the smallest value in <code>x</code> will be used for
the &lsquo;<code>R.mle</code>&rsquo; implementation, and its value will be
automatically determined for the &lsquo;<code>plfit</code>&rsquo; implementation. This
argument makes it possible to fit only the tail of the distribution.</p>
</td></tr>
<tr><td><code id="fit_power_law_+3A_start">start</code></td>
<td>
<p>Numeric scalar. The initial value of the exponent for the
minimizing function, for the &lsquo;<code>R.mle</code>&rsquo; implementation. Usually
it is safe to leave this untouched.</p>
</td></tr>
<tr><td><code id="fit_power_law_+3A_force.continuous">force.continuous</code></td>
<td>
<p>Logical scalar. Whether to force a continuous
distribution for the &lsquo;<code>plfit</code>&rsquo; implementation, even if the
sample vector contains integer values only (by chance). If this argument is
false, igraph will assume a continuous distribution if at least one sample
is non-integer and assume a discrete distribution otherwise.</p>
</td></tr>
<tr><td><code id="fit_power_law_+3A_implementation">implementation</code></td>
<td>
<p>Character scalar. Which implementation to use. See
details below.</p>
</td></tr>
<tr><td><code id="fit_power_law_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the maximum likelihood
optimizing function, <code><a href="stats4.html#topic+mle">stats4::mle()</a></code>, if the &lsquo;<code>R.mle</code>&rsquo;
implementation is chosen. It is ignored by the &lsquo;<code>plfit</code>&rsquo;
implementation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a power-law distribution to a vector containing samples
from a distribution (that is assumed to follow a power-law of course). In a
power-law distribution, it is generally assumed that <code class="reqn">P(X=x)</code> is
proportional to <code class="reqn">x^{-\alpha}</code>, where <code class="reqn">x</code> is a positive
number and <code class="reqn">\alpha</code> is greater than 1. In many real-world cases,
the power-law behaviour kicks in only above a threshold value
<code class="reqn">x_\text{min}</code>. The goal of this function is to determine
<code class="reqn">\alpha</code> if <code class="reqn">x_\text{min}</code> is given, or to determine
<code class="reqn">x_\text{min}</code> and the corresponding value of <code class="reqn">\alpha</code>.
</p>
<p><code>fit_power_law()</code> provides two maximum likelihood implementations.  If
the <code>implementation</code> argument is &lsquo;<code>R.mle</code>&rsquo;, then the BFGS
optimization (see <a href="stats4.html#topic+mle">mle</a>) algorithm is applied.  The additional
arguments are passed to the mle function, so it is possible to change the
optimization method and/or its parameters.  This implementation can
<em>not</em> to fit the <code class="reqn">x_\text{min}</code> argument, so use the
&lsquo;<code>plfit</code>&rsquo; implementation if you want to do that.
</p>
<p>The &lsquo;<code>plfit</code>&rsquo; implementation also uses the maximum likelihood
principle to determine <code class="reqn">\alpha</code> for a given <code class="reqn">x_\text{min}</code>;
When <code class="reqn">x_\text{min}</code> is not given in advance, the algorithm will attempt
to find itsoptimal value for which the <code class="reqn">p</code>-value of a Kolmogorov-Smirnov
test between the fitted distribution and the original sample is the largest.
The function uses the method of Clauset, Shalizi and Newman to calculate the
parameters of the fitted distribution. See references below for the details.
</p>


<h3>Value</h3>

<p>Depends on the <code>implementation</code> argument. If it is
&lsquo;<code>R.mle</code>&rsquo;, then an object with class &lsquo;<code>mle</code>&rsquo;. It can
be used to calculate confidence intervals and log-likelihood. See
<code><a href="stats4.html#topic+mle-class">stats4::mle-class()</a></code> for details.
</p>
<p>If <code>implementation</code> is &lsquo;<code>plfit</code>&rsquo;, then the result is a
named list with entries: </p>
<table>
<tr><td><code>continuous</code></td>
<td>
<p>Logical scalar, whether the
fitted power-law distribution was continuous or discrete.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Numeric scalar, the exponent of the fitted power-law
distribution.</p>
</td></tr> <tr><td><code>xmin</code></td>
<td>
<p>Numeric scalar, the minimum value from which the
power-law distribution was fitted. In other words, only the values larger
than <code>xmin</code> were used from the input vector.</p>
</td></tr> <tr><td><code>logLik</code></td>
<td>
<p>Numeric
scalar, the log-likelihood of the fitted parameters.</p>
</td></tr> <tr><td><code>KS.stat</code></td>
<td>
<p>Numeric
scalar, the test statistic of a Kolmogorov-Smirnov test that compares the
fitted distribution with the input vector. Smaller scores denote better
fit.</p>
</td></tr> <tr><td><code>KS.p</code></td>
<td>
<p>Numeric scalar, the p-value of the Kolmogorov-Smirnov
test. Small p-values (less than 0.05) indicate that the test rejected the
hypothesis that the original data could have been drawn from the fitted
power-law distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Power laws, Pareto distributions and Zipf's law, M. E. J.
Newman, <em>Contemporary Physics</em>, 46, 323-351, 2005.
</p>
<p>Aaron Clauset, Cosma R .Shalizi and Mark E.J. Newman: Power-law
distributions in empirical data. SIAM Review 51(4):661-703, 2009.
</p>


<h3>See Also</h3>

<p><code><a href="stats4.html#topic+mle">stats4::mle()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This should approximately yield the correct exponent 3
g &lt;- sample_pa(1000) # increase this number to have a better estimate
d &lt;- degree(g, mode = "in")
fit1 &lt;- fit_power_law(d + 1, 10)
fit2 &lt;- fit_power_law(d + 1, 10, implementation = "R.mle")

fit1$alpha
stats4::coef(fit2)
fit1$logLik
stats4::logLik(fit2)

</code></pre>

<hr>
<h2 id='forest.fire.game'>Forest Fire Network Model</h2><span id='topic+forest.fire.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>forest.fire.game()</code> was renamed to <code>sample_forestfire()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forest.fire.game(nodes, fw.prob, bw.factor = 1, ambs = 1, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forest.fire.game_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="forest.fire.game_+3A_fw.prob">fw.prob</code></td>
<td>
<p>The forward burning probability, see details below.</p>
</td></tr>
<tr><td><code id="forest.fire.game_+3A_bw.factor">bw.factor</code></td>
<td>
<p>The backward burning ratio. The backward burning
probability is calculated as <code>bw.factor*fw.prob</code>.</p>
</td></tr>
<tr><td><code id="forest.fire.game_+3A_ambs">ambs</code></td>
<td>
<p>The number of ambassador vertices.</p>
</td></tr>
<tr><td><code id="forest.fire.game_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to create a directed graph.</p>
</td></tr>
</table>

<hr>
<h2 id='from_incidence_matrix'>Graph from incidence matrix</h2><span id='topic+from_incidence_matrix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph_from_incidence_matrix()</code> was renamed to <code>graph_from_biadjacency_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from_incidence_matrix(...)
</code></pre>


<h3>Details</h3>

<p>Some authors refer to the bipartite adjacency matrix as the
&quot;bipartite incidence matrix&quot;. igraph 1.6.0 and later does not use
this naming to avoid confusion with the edge-vertex incidence matrix.
</p>

<hr>
<h2 id='get.adjacency'>Convert a graph to an adjacency matrix</h2><span id='topic+get.adjacency'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.adjacency()</code> was renamed to <code>as_adjacency_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.adjacency(
  graph,
  type = c("both", "upper", "lower"),
  attr = NULL,
  edges = FALSE,
  names = TRUE,
  sparse = igraph_opt("sparsematrices")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.adjacency_+3A_graph">graph</code></td>
<td>
<p>The graph to convert.</p>
</td></tr>
<tr><td><code id="get.adjacency_+3A_type">type</code></td>
<td>
<p>Gives how to create the adjacency matrix for undirected graphs.
It is ignored for directed graphs. Possible values: <code>upper</code>: the upper
right triangle of the matrix is used, <code>lower</code>: the lower left triangle
of the matrix is used. <code>both</code>: the whole matrix is used, a symmetric
matrix is returned.</p>
</td></tr>
<tr><td><code id="get.adjacency_+3A_attr">attr</code></td>
<td>
<p>Either <code>NULL</code> or a character string giving an edge
attribute name. If <code>NULL</code> a traditional adjacency matrix is returned.
If not <code>NULL</code> then the values of the given edge attribute are included
in the adjacency matrix. If the graph has multiple edges, the edge attribute
of an arbitrarily chosen edge (for the multiple edges) is included. This
argument is ignored if <code>edges</code> is <code>TRUE</code>.
</p>
<p>Note that this works only for certain attribute types. If the <code>sparse</code>
argumen is <code>TRUE</code>, then the attribute must be either logical or
numeric. If the <code>sparse</code> argument is <code>FALSE</code>, then character is
also allowed. The reason for the difference is that the <code>Matrix</code>
package does not support character sparse matrices yet.</p>
</td></tr>
<tr><td><code id="get.adjacency_+3A_edges">edges</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Logical scalar, whether to return the edge ids in the matrix.
For non-existant edges zero is returned.</p>
</td></tr>
<tr><td><code id="get.adjacency_+3A_names">names</code></td>
<td>
<p>Logical constant, whether to assign row and column names
to the matrix. These are only assigned if the <code>name</code> vertex attribute
is present in the graph.</p>
</td></tr>
<tr><td><code id="get.adjacency_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to create a sparse matrix. The
&lsquo;<code>Matrix</code>&rsquo; package must be installed for creating sparse
matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='get.adjedgelist'>Adjacency lists</h2><span id='topic+get.adjedgelist'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.adjedgelist()</code> was renamed to <code>as_adj_edge_list()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.adjedgelist(
  graph,
  mode = c("all", "out", "in", "total"),
  loops = c("twice", "once", "ignore")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.adjedgelist_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="get.adjedgelist_+3A_mode">mode</code></td>
<td>
<p>Character scalar, it gives what kind of adjacent edges/vertices
to include in the lists. &lsquo;<code>out</code>&rsquo; is for outgoing edges/vertices,
&lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo; is for incoming edges/vertices, &lsquo;<code>all</code>&rsquo; is
for both. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="get.adjedgelist_+3A_loops">loops</code></td>
<td>
<p>Character scalar, one of <code>"ignore"</code> (to omit loops), <code>"twice"</code>
(to include loop edges twice) and <code>"once"</code> (to include them once). <code>"twice"</code>
is not allowed for directed graphs and will be replaced with <code>"once"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='get.adjlist'>Adjacency lists</h2><span id='topic+get.adjlist'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.adjlist()</code> was renamed to <code>as_adj_list()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.adjlist(
  graph,
  mode = c("all", "out", "in", "total"),
  loops = c("twice", "once", "ignore"),
  multiple = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.adjlist_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="get.adjlist_+3A_mode">mode</code></td>
<td>
<p>Character scalar, it gives what kind of adjacent edges/vertices
to include in the lists. &lsquo;<code>out</code>&rsquo; is for outgoing edges/vertices,
&lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo; is for incoming edges/vertices, &lsquo;<code>all</code>&rsquo; is
for both. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="get.adjlist_+3A_loops">loops</code></td>
<td>
<p>Character scalar, one of <code>"ignore"</code> (to omit loops), <code>"twice"</code>
(to include loop edges twice) and <code>"once"</code> (to include them once). <code>"twice"</code>
is not allowed for directed graphs and will be replaced with <code>"once"</code>.</p>
</td></tr>
<tr><td><code id="get.adjlist_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, set to <code>FALSE</code> to use only one representative
of each set of parallel edges.</p>
</td></tr>
</table>

<hr>
<h2 id='get.all.shortest.paths'>Shortest (directed or undirected) paths between vertices</h2><span id='topic+get.all.shortest.paths'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.all.shortest.paths()</code> was renamed to <code>all_shortest_paths()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.all.shortest.paths(
  graph,
  from,
  to = V(graph),
  mode = c("out", "all", "in"),
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.all.shortest.paths_+3A_graph">graph</code></td>
<td>
<p>The graph to work on.</p>
</td></tr>
<tr><td><code id="get.all.shortest.paths_+3A_from">from</code></td>
<td>
<p>Numeric constant, the vertex from or to the shortest paths will
be calculated. Note that right now this is not a vector of vertex ids, but
only a single vertex.</p>
</td></tr>
<tr><td><code id="get.all.shortest.paths_+3A_to">to</code></td>
<td>
<p>Numeric vector, the vertices to which the shortest paths will be
calculated. By default it includes all vertices. Note that for
<code>distances()</code> every vertex must be included here at most once. (This
is not required for <code>shortest_paths()</code>.</p>
</td></tr>
<tr><td><code id="get.all.shortest.paths_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the corresponding
undirected graph will be used, i.e. not directed paths are searched. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="get.all.shortest.paths_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then the
attribute is used. If this is <code>NA</code> then no weights are used (even if
the graph has a <code>weight</code> attribute).</p>
</td></tr>
</table>

<hr>
<h2 id='get.data.frame'>Creating igraph graphs from data frames or vice-versa</h2><span id='topic+get.data.frame'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.data.frame()</code> was renamed to <code>as_data_frame()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.data.frame(x, what = c("edges", "vertices", "both"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.data.frame_+3A_x">x</code></td>
<td>
<p>An igraph object.</p>
</td></tr>
<tr><td><code id="get.data.frame_+3A_what">what</code></td>
<td>
<p>Character constant, whether to return info about vertices,
edges, or both. The default is &lsquo;edges&rsquo;.</p>
</td></tr>
</table>

<hr>
<h2 id='get.diameter'>Diameter of a graph</h2><span id='topic+get.diameter'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.diameter()</code> was renamed to <code>get_diameter()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.diameter(graph, directed = TRUE, unconnected = TRUE, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.diameter_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="get.diameter_+3A_directed">directed</code></td>
<td>
<p>Logical, whether directed or undirected paths are to be
considered. This is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="get.diameter_+3A_unconnected">unconnected</code></td>
<td>
<p>Logical, what to do if the graph is unconnected. If
FALSE, the function will return a number that is one larger the largest
possible diameter, which is always the number of vertices. If TRUE, the
diameters of the connected components will be calculated and the largest one
will be returned.</p>
</td></tr>
<tr><td><code id="get.diameter_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
distances. If the graph has a <code>weight</code> edge attribute, then this is
used by default.</p>
</td></tr>
</table>

<hr>
<h2 id='get.edge.attribute'>Query edge attributes of a graph</h2><span id='topic+get.edge.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.edge.attribute()</code> was renamed to <code>edge_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.edge.attribute(graph, name, index = E(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.edge.attribute_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
<tr><td><code id="get.edge.attribute_+3A_name">name</code></td>
<td>
<p>The name of the attribute to query. If missing, then
all edge attributes are returned in a list.</p>
</td></tr>
<tr><td><code id="get.edge.attribute_+3A_index">index</code></td>
<td>
<p>An optional edge sequence to query edge attributes
for a subset of edges.</p>
</td></tr>
</table>

<hr>
<h2 id='get.edge.ids'>Find the edge ids based on the incident vertices of the edges</h2><span id='topic+get.edge.ids'></span>

<h3>Description</h3>

<p>Find the edges in an igraph graph that have the specified end points. This
function handles multi-graph (graphs with multiple edges) and can consider
or ignore the edge directions in directed graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.edge.ids(graph, vp, directed = TRUE, error = FALSE, multi = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.edge.ids_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="get.edge.ids_+3A_vp">vp</code></td>
<td>
<p>The incident vertices, given as vertex ids or symbolic vertex
names. They are interpreted pairwise, i.e. the first and second are used for
the first edge, the third and fourth for the second, etc.</p>
</td></tr>
<tr><td><code id="get.edge.ids_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to consider edge directions in
directed graphs. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="get.edge.ids_+3A_error">error</code></td>
<td>
<p>Logical scalar, whether to report an error if an edge is not
found in the graph. If <code>FALSE</code>, then no error is reported, and zero is
returned for the non-existant edge(s).</p>
</td></tr>
<tr><td><code id="get.edge.ids_+3A_multi">multi</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>igraph vertex ids are natural numbers, starting from one, up to the number
of vertices in the graph. Similarly, edges are also numbered from one, up to
the number of edges.
</p>
<p>This function allows finding the edges of the graph, via their incident
vertices.
</p>


<h3>Value</h3>

<p>A numeric vector of edge ids, one for each pair of input vertices.
If there is no edge in the input graph for a given pair of vertices, then
zero is reported. (If the <code>error</code> argument is <code>FALSE</code>.)
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
ei &lt;- get.edge.ids(g, c(1, 2, 4, 5))
E(g)[ei]

## non-existant edge
get.edge.ids(g, c(2, 1, 1, 4, 5, 4))

## For multiple edges, a single edge id is returned,
## as many times as corresponding pairs in the vertex series.
g &lt;- make_graph(rep(c(1, 2), 5))
eis &lt;- get.edge.ids(g, c(1, 2, 1, 2))
eis
E(g)[eis]

</code></pre>

<hr>
<h2 id='get.edgelist'>Convert a graph to an edge list</h2><span id='topic+get.edgelist'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.edgelist()</code> was renamed to <code>as_edgelist()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.edgelist(graph, names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.edgelist_+3A_graph">graph</code></td>
<td>
<p>The graph to convert.</p>
</td></tr>
<tr><td><code id="get.edgelist_+3A_names">names</code></td>
<td>
<p>Whether to return a character matrix containing vertex
names (i.e. the <code>name</code> vertex attribute) if they exist or numeric
vertex ids.</p>
</td></tr>
</table>

<hr>
<h2 id='get.graph.attribute'>Graph attributes of a graph</h2><span id='topic+get.graph.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.graph.attribute()</code> was renamed to <code>graph_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.graph.attribute(graph, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.graph.attribute_+3A_graph">graph</code></td>
<td>
<p>Input graph.</p>
</td></tr>
<tr><td><code id="get.graph.attribute_+3A_name">name</code></td>
<td>
<p>The name of attribute to query. If missing, then all
attributes are returned in a list.</p>
</td></tr>
</table>

<hr>
<h2 id='get.incidence'>Bipartite adjacency matrix of a bipartite graph</h2><span id='topic+get.incidence'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.incidence()</code> was renamed to <code>as_biadjacency_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.incidence(graph, types = NULL, attr = NULL, names = TRUE, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.incidence_+3A_graph">graph</code></td>
<td>
<p>The input graph. The direction of the edges is ignored in
directed graphs.</p>
</td></tr>
<tr><td><code id="get.incidence_+3A_types">types</code></td>
<td>
<p>An optional vertex type vector to use instead of the
<code>type</code> vertex attribute. You must supply this argument if the graph has
no <code>type</code> vertex attribute.</p>
</td></tr>
<tr><td><code id="get.incidence_+3A_attr">attr</code></td>
<td>
<p>Either <code>NULL</code> or a character string giving an edge
attribute name. If <code>NULL</code>, then a traditional bipartite adjacency matrix is
returned. If not <code>NULL</code> then the values of the given edge attribute are
included in the bipartite adjacency matrix. If the graph has multiple edges, the edge
attribute of an arbitrarily chosen edge (for the multiple edges) is
included.</p>
</td></tr>
<tr><td><code id="get.incidence_+3A_names">names</code></td>
<td>
<p>Logical scalar, if <code>TRUE</code> and the vertices in the graph
are named (i.e. the graph has a vertex attribute called <code>name</code>), then
vertex names will be added to the result as row and column names. Otherwise
the ids of the vertices are used as row and column names.</p>
</td></tr>
<tr><td><code id="get.incidence_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, if it is <code>TRUE</code> then a sparse matrix is
created, you will need the <code>Matrix</code> package for this.</p>
</td></tr>
</table>

<hr>
<h2 id='get.shortest.paths'>Shortest (directed or undirected) paths between vertices</h2><span id='topic+get.shortest.paths'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.shortest.paths()</code> was renamed to <code>shortest_paths()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.shortest.paths(
  graph,
  from,
  to = V(graph),
  mode = c("out", "all", "in"),
  weights = NULL,
  output = c("vpath", "epath", "both"),
  predecessors = FALSE,
  inbound.edges = FALSE,
  algorithm = c("automatic", "unweighted", "dijkstra", "bellman-ford")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.shortest.paths_+3A_graph">graph</code></td>
<td>
<p>The graph to work on.</p>
</td></tr>
<tr><td><code id="get.shortest.paths_+3A_from">from</code></td>
<td>
<p>Numeric constant, the vertex from or to the shortest paths will
be calculated. Note that right now this is not a vector of vertex ids, but
only a single vertex.</p>
</td></tr>
<tr><td><code id="get.shortest.paths_+3A_to">to</code></td>
<td>
<p>Numeric vector, the vertices to which the shortest paths will be
calculated. By default it includes all vertices. Note that for
<code>distances()</code> every vertex must be included here at most once. (This
is not required for <code>shortest_paths()</code>.</p>
</td></tr>
<tr><td><code id="get.shortest.paths_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the corresponding
undirected graph will be used, i.e. not directed paths are searched. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="get.shortest.paths_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then the
attribute is used. If this is <code>NA</code> then no weights are used (even if
the graph has a <code>weight</code> attribute).</p>
</td></tr>
<tr><td><code id="get.shortest.paths_+3A_output">output</code></td>
<td>
<p>Character scalar, defines how to report the shortest paths.
&ldquo;vpath&rdquo; means that the vertices along the paths are reported, this
form was used prior to igraph version 0.6. &ldquo;epath&rdquo; means that the
edges along the paths are reported. &ldquo;both&rdquo; means that both forms are
returned, in a named list with components &ldquo;vpath&rdquo; and &ldquo;epath&rdquo;.</p>
</td></tr>
<tr><td><code id="get.shortest.paths_+3A_predecessors">predecessors</code></td>
<td>
<p>Logical scalar, whether to return the predecessor vertex
for each vertex. The predecessor of vertex <code>i</code> in the tree is the
vertex from which vertex <code>i</code> was reached. The predecessor of the start
vertex (in the <code>from</code> argument) is itself by definition. If the
predecessor is zero, it means that the given vertex was not reached from the
source during the search. Note that the search terminates if all the
vertices in <code>to</code> are reached.</p>
</td></tr>
<tr><td><code id="get.shortest.paths_+3A_inbound.edges">inbound.edges</code></td>
<td>
<p>Logical scalar, whether to return the inbound edge for
each vertex. The inbound edge of vertex <code>i</code> in the tree is the edge via
which vertex <code>i</code> was reached. The start vertex and vertices that were
not reached during the search will have zero in the corresponding entry of
the vector. Note that the search terminates if all the vertices in <code>to</code>
are reached.</p>
</td></tr>
<tr><td><code id="get.shortest.paths_+3A_algorithm">algorithm</code></td>
<td>
<p>Which algorithm to use for the calculation. By default
igraph tries to select the fastest suitable algorithm. If there are no
weights, then an unweighted breadth-first search is used, otherwise if all
weights are positive, then Dijkstra's algorithm is used. If there are
negative weights and we do the calculation for more than 100 sources, then
Johnson's algorithm is used. Otherwise the Bellman-Ford algorithm is used.
You can override igraph's choice by explicitly giving this parameter. Note
that the igraph C core might still override your choice in obvious cases,
i.e. if there are no edge weights, then the unweighted algorithm will be
used, regardless of this argument.</p>
</td></tr>
</table>

<hr>
<h2 id='get.stochastic'>Stochastic matrix of a graph</h2><span id='topic+get.stochastic'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.stochastic()</code> was renamed to <code>stochastic_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.stochastic(
  graph,
  column.wise = FALSE,
  sparse = igraph_opt("sparsematrices")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.stochastic_+3A_graph">graph</code></td>
<td>
<p>The input graph. Must be of class <code>igraph</code>.</p>
</td></tr>
<tr><td><code id="get.stochastic_+3A_column.wise">column.wise</code></td>
<td>
<p>If <code>FALSE</code>, then the rows of the stochastic matrix
sum up to one; otherwise it is the columns.</p>
</td></tr>
<tr><td><code id="get.stochastic_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to return a sparse matrix. The
<code>Matrix</code> package is needed for sparse matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='get.vertex.attribute'>Query vertex attributes of a graph</h2><span id='topic+get.vertex.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>get.vertex.attribute()</code> was renamed to <code>vertex_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.vertex.attribute(graph, name, index = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.vertex.attribute_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="get.vertex.attribute_+3A_name">name</code></td>
<td>
<p>Name of the attribute to query. If missing, then
all vertex attributes are returned in a list.</p>
</td></tr>
<tr><td><code id="get.vertex.attribute_+3A_index">index</code></td>
<td>
<p>An optional vertex sequence to query the attribute only
for these vertices.</p>
</td></tr>
</table>

<hr>
<h2 id='getIgraphOpt'>Parameters for the igraph package</h2><span id='topic+getIgraphOpt'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>getIgraphOpt()</code> was renamed to <code>igraph_opt()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIgraphOpt(x, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIgraphOpt_+3A_x">x</code></td>
<td>
<p>A character string holding an option name.</p>
</td></tr>
<tr><td><code id="getIgraphOpt_+3A_default">default</code></td>
<td>
<p>If the specified option is not set in the options list, this
value is returned. This facilitates retrieving an option and checking
whether it is set and setting it separately if not.</p>
</td></tr>
</table>

<hr>
<h2 id='girth'>Girth of a graph</h2><span id='topic+girth'></span>

<h3>Description</h3>

<p>The girth of a graph is the length of the shortest circle in it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>girth(graph, circle = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="girth_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but the algorithm searches
for undirected circles anyway.</p>
</td></tr>
<tr><td><code id="girth_+3A_circle">circle</code></td>
<td>
<p>Logical scalar, whether to return the shortest circle itself.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current implementation works for undirected graphs only, directed graphs
are treated as undirected graphs. Loop edges and multiple edges are ignored.
If the graph is a forest (i.e. acyclic), then <code>Inf</code> is returned.
</p>
<p>This implementation is based on Alon Itai and Michael Rodeh: Finding a
minimum circuit in a graph <em>Proceedings of the ninth annual ACM
symposium on Theory of computing</em>, 1-10, 1977. The first implementation of
this function was done by Keith Briggs, thanks Keith.
</p>


<h3>Value</h3>

<p>A named list with two components: </p>
<table>
<tr><td><code>girth</code></td>
<td>
<p>Integer constant, the
girth of the graph, or 0 if the graph is acyclic.</p>
</td></tr> <tr><td><code>circle</code></td>
<td>
<p>Numeric
vector with the vertex ids in the shortest circle.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Alon Itai and Michael Rodeh: Finding a minimum circuit in a
graph <em>Proceedings of the ninth annual ACM symposium on Theory of
computing</em>, 1-10, 1977
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>
<p>Graph cycles
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+has_eulerian_path">has_eulerian_path</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# No circle in a tree
g &lt;- make_tree(1000, 3)
girth(g)

# The worst case running time is for a ring
g &lt;- make_ring(100)
girth(g)

# What about a random graph?
g &lt;- sample_gnp(1000, 1 / 1000)
girth(g)

</code></pre>

<hr>
<h2 id='global_efficiency'>Efficiency of a graph</h2><span id='topic+global_efficiency'></span><span id='topic+local_efficiency'></span><span id='topic+average_local_efficiency'></span>

<h3>Description</h3>

<p>These functions calculate the global or average local efficiency of a network,
or the local efficiency of every vertex in the network. See below for
definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>global_efficiency(graph, weights = NULL, directed = TRUE)

local_efficiency(
  graph,
  vids = V(graph),
  weights = NULL,
  directed = TRUE,
  mode = c("all", "out", "in", "total")
)

average_local_efficiency(
  graph,
  weights = NULL,
  directed = TRUE,
  mode = c("all", "out", "in", "total")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global_efficiency_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="global_efficiency_+3A_weights">weights</code></td>
<td>
<p>The edge weights. All edge weights must be non-negative;
additionally, no edge weight may be NaN. If it is <code>NULL</code> (the default)
and the graph has a <code>weight</code> edge attribute, then it is used automatically.</p>
</td></tr>
<tr><td><code id="global_efficiency_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to consider directed paths. Ignored
for undirected graphs.</p>
</td></tr>
<tr><td><code id="global_efficiency_+3A_vids">vids</code></td>
<td>
<p>The vertex ids of the vertices for which the calculation will be done.
Applies to the local efficiency calculation only.</p>
</td></tr>
<tr><td><code id="global_efficiency_+3A_mode">mode</code></td>
<td>
<p>Specifies how to define the local neighborhood of a vertex in
directed graphs. &ldquo;out&rdquo; considers out-neighbors only, &ldquo;in&rdquo;
considers in-neighbors only, &ldquo;all&rdquo; considers both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>global_efficiency()</code>, the global efficiency of the graph as a
single number. For <code>average_local_efficiency()</code>, the average local
efficiency of the graph as a single number. For <code>local_efficiency()</code>, the
local efficiency of each vertex in a vector.
</p>


<h3>Global efficiency</h3>

<p>The global efficiency of a network is defined as the average of inverse
distances between all pairs of vertices.
</p>
<p>More precisely:
</p>
<p style="text-align: center;"><code class="reqn">E_g = \frac{1}{n (n-1)} \sum_{i \ne j} \frac{1}{d_{ij}}</code>
</p>

<p>where <code class="reqn">n</code> is the number of vertices.
</p>
<p>The inverse distance between pairs that are not reachable from each other is
considered to be zero. For graphs with fewer than 2 vertices, NaN is returned.
</p>


<h3>Local efficiency</h3>

<p>The local efficiency of a network around a vertex is defined as follows: We
remove the vertex and compute the distances (shortest path lengths) between
its neighbours through the rest of the network. The local efficiency around
the removed vertex is the average of the inverse of these distances.
</p>
<p>The inverse distance between two vertices which are not reachable from each
other is considered to be zero. The local efficiency around a vertex with
fewer than two neighbours is taken to be zero by convention.
</p>


<h3>Average local efficiency</h3>

<p>The average local efficiency of a network is simply the arithmetic mean of
the local efficiencies of all the vertices; see the definition for local
efficiency above.
</p>


<h3>References</h3>

<p>V. Latora and M. Marchiori: Efficient Behavior of Small-World
Networks, Phys. Rev. Lett. 87, 198701 (2001).
</p>
<p>I. Vragović, E. Louis, and A. Díaz-Guilera, Efficiency of informational
transfer in regular and complex networks, Phys. Rev. E 71, 1 (2005).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph("zachary")
global_efficiency(g)
average_local_efficiency(g)
</code></pre>

<hr>
<h2 id='gorder'>Order (number of vertices) of a graph</h2><span id='topic+gorder'></span><span id='topic+vcount'></span>

<h3>Description</h3>

<p><code>vcount()</code> and <code>gorder()</code> are aliases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcount(graph)

gorder(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gorder_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of vertices, numeric scalar.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
gorder(g)
vcount(g)
</code></pre>

<hr>
<h2 id='graph_'>Convert object to a graph</h2><span id='topic+graph_'></span>

<h3>Description</h3>

<p>This is a generic function to convert R objects to igraph graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph__+3A_...">...</code></td>
<td>
<p>Parameters, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## These are equivalent
graph_(cbind(1:5, 2:6), from_edgelist(directed = FALSE))
graph_(cbind(1:5, 2:6), from_edgelist(), directed = FALSE)
</code></pre>

<hr>
<h2 id='graph_attr'>Graph attributes of a graph</h2><span id='topic+graph_attr'></span><span id='topic+graph.attributes'></span>

<h3>Description</h3>

<p>Graph attributes of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_attr(graph, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_attr_+3A_graph">graph</code></td>
<td>
<p>Input graph.</p>
</td></tr>
<tr><td><code id="graph_attr_+3A_name">name</code></td>
<td>
<p>The name of attribute to query. If missing, then all
attributes are returned in a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of graph attributes, or a single graph attribute.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
graph_attr(g)
graph_attr(g, "name")
</code></pre>

<hr>
<h2 id='graph_attr_names'>List names of graph attributes</h2><span id='topic+graph_attr_names'></span><span id='topic+attributes'></span>

<h3>Description</h3>

<p>List names of graph attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_attr_names(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_attr_names_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector, the names of the graph attributes.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
graph_attr_names(g)
</code></pre>

<hr>
<h2 id='graph_attr+26lt+3B-'>Set all or some graph attributes</h2><span id='topic+graph_attr+3C-'></span><span id='topic+graph.attributes+3C-'></span>

<h3>Description</h3>

<p>Set all or some graph attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_attr(graph, name) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_attr+2B26lt+2B3B-_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="graph_attr+2B26lt+2B3B-_+3A_name">name</code></td>
<td>
<p>The name of the attribute to set. If missing, then
<code>value</code> should be a named list, and all list members
are set as attributes.</p>
</td></tr>
<tr><td><code id="graph_attr+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The value of the attribute to set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the attribute(s) added.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph(~ A - B:C:D)
graph_attr(g, "name") &lt;- "4-star"
g

graph_attr(g) &lt;- list(
  layout = layout_with_fr(g),
  name = "4-star layed out"
)
plot(g)
</code></pre>

<hr>
<h2 id='graph_from_adj_list'>Create graphs from adjacency lists</h2><span id='topic+graph_from_adj_list'></span>

<h3>Description</h3>

<p>An adjacency list is a list of numeric vectors, containing the neighbor
vertices for each vertex. This function creates an igraph graph object from
such a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_adj_list(
  adjlist,
  mode = c("out", "in", "all", "total"),
  duplicate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_adj_list_+3A_adjlist">adjlist</code></td>
<td>
<p>The adjacency list. It should be consistent, i.e. the maximum
throughout all vectors in the list must be less than the number of vectors
(=the number of vertices in the graph).</p>
</td></tr>
<tr><td><code id="graph_from_adj_list_+3A_mode">mode</code></td>
<td>
<p>Character scalar, it specifies whether the graph to create is
undirected (&lsquo;all&rsquo; or &lsquo;total&rsquo;) or directed; and in the latter
case, whether it contains the outgoing (&lsquo;out&rsquo;) or the incoming
(&lsquo;in&rsquo;) neighbors of the vertices.</p>
</td></tr>
<tr><td><code id="graph_from_adj_list_+3A_duplicate">duplicate</code></td>
<td>
<p>Logical scalar. For undirected graphs it gives whether
edges are included in the list twice. E.g. if it is <code>TRUE</code> then for an
undirected <code>{A,B}</code> edge <code>graph_from_adj_list()</code> expects <code>A</code>
included in the neighbors of <code>B</code> and <code>B</code> to be included in the
neighbors of <code>A</code>.
</p>
<p>This argument is ignored if <code>mode</code> is <code>out</code> or <code style="white-space: pre;">&#8288;in&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adjacency lists are handy if you intend to do many (small) modifications to
a graph. In this case adjacency lists are more efficient than igraph graphs.
</p>
<p>The idea is that you convert your graph to an adjacency list by
<code><a href="#topic+as_adj_list">as_adj_list()</a></code>, do your modifications to the graphs and finally
create again an igraph graph by calling <code>graph_from_adj_list()</code>.
</p>


<h3>Value</h3>

<p>An igraph graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_edgelist">as_edgelist()</a></code>
</p>
<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_graphnel">graph_from_graphnel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Directed
g &lt;- make_ring(10, directed = TRUE)
al &lt;- as_adj_list(g, mode = "out")
g2 &lt;- graph_from_adj_list(al)
graph.isomorphic(g, g2)

## Undirected
g &lt;- make_ring(10)
al &lt;- as_adj_list(g)
g2 &lt;- graph_from_adj_list(al, mode = "all")
graph.isomorphic(g, g2)
ecount(g2)
g3 &lt;- graph_from_adj_list(al, mode = "all", duplicate = FALSE)
ecount(g3)
which_multiple(g3)
</code></pre>

<hr>
<h2 id='graph_from_adjacency_matrix'>Create graphs from adjacency matrices</h2><span id='topic+graph_from_adjacency_matrix'></span><span id='topic+from_adjacency'></span>

<h3>Description</h3>

<p><code>graph_from_adjacency_matrix()</code> is a flexible function for creating <code>igraph</code>
graphs from adjacency matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_adjacency_matrix(
  adjmatrix,
  mode = c("directed", "undirected", "max", "min", "upper", "lower", "plus"),
  weighted = NULL,
  diag = TRUE,
  add.colnames = NULL,
  add.rownames = NA
)

from_adjacency(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_adjacency_matrix_+3A_adjmatrix">adjmatrix</code></td>
<td>
<p>A square adjacency matrix. From igraph version 0.5.1 this
can be a sparse matrix created with the <code>Matrix</code> package.</p>
</td></tr>
<tr><td><code id="graph_from_adjacency_matrix_+3A_mode">mode</code></td>
<td>
<p>Character scalar, specifies how igraph should interpret the
supplied matrix. See also the <code>weighted</code> argument, the interpretation
depends on that too. Possible values are: <code>directed</code>,
<code>undirected</code>, <code>upper</code>, <code>lower</code>, <code>max</code>, <code>min</code>,
<code>plus</code>. See details below.</p>
</td></tr>
<tr><td><code id="graph_from_adjacency_matrix_+3A_weighted">weighted</code></td>
<td>
<p>This argument specifies whether to create a weighted graph
from an adjacency matrix. If it is <code>NULL</code> then an unweighted graph is
created and the elements of the adjacency matrix gives the number of edges
between the vertices. If it is a character constant then for every non-zero
matrix entry an edge is created and the value of the entry is added as an
edge attribute named by the <code>weighted</code> argument. If it is <code>TRUE</code>
then a weighted graph is created and the name of the edge attribute will be
<code>weight</code>. See also details below.</p>
</td></tr>
<tr><td><code id="graph_from_adjacency_matrix_+3A_diag">diag</code></td>
<td>
<p>Logical scalar, whether to include the diagonal of the matrix in
the calculation. If this is <code>FALSE</code> then the diagonal is zerod out
first.</p>
</td></tr>
<tr><td><code id="graph_from_adjacency_matrix_+3A_add.colnames">add.colnames</code></td>
<td>
<p>Character scalar, whether to add the column names as
vertex attributes. If it is &lsquo;<code>NULL</code>&rsquo; (the default) then, if
present, column names are added as vertex attribute &lsquo;name&rsquo;. If
&lsquo;<code>NA</code>&rsquo; then they will not be added.  If a character constant,
then it gives the name of the vertex attribute to add.</p>
</td></tr>
<tr><td><code id="graph_from_adjacency_matrix_+3A_add.rownames">add.rownames</code></td>
<td>
<p>Character scalar, whether to add the row names as vertex
attributes. Possible values the same as the previous argument. By default
row names are not added. If &lsquo;<code>add.rownames</code>&rsquo; and
&lsquo;<code>add.colnames</code>&rsquo; specify the same vertex attribute, then the
former is ignored.</p>
</td></tr>
<tr><td><code id="graph_from_adjacency_matrix_+3A_...">...</code></td>
<td>
<p>Passed to <code>graph_from_adjacency_matrix()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the vertices are preserved, i.e. the vertex corresponding to
the first row will be vertex 0 in the graph, etc.
</p>
<p><code>graph_from_adjacency_matrix()</code> operates in two main modes, depending on the
<code>weighted</code> argument.
</p>
<p>If this argument is <code>NULL</code> then an unweighted graph is created and an
element of the adjacency matrix gives the number of edges to create between
the two corresponding vertices.  The details depend on the value of the
<code>mode</code> argument: </p>
 <dl>
<dt>&quot;directed&quot;</dt><dd><p>The graph will be
directed and a matrix element gives the number of edges between two
vertices.</p>
</dd> <dt>&quot;undirected&quot;</dt><dd><p>This is exactly the same as <code>max</code>,
for convenience. Note that it is <em>not</em> checked whether the matrix is
symmetric.</p>
</dd> <dt>&quot;max&quot;</dt><dd><p>An undirected graph will be created and
<code>max(A(i,j), A(j,i))</code> gives the number of edges.</p>
</dd>
<dt>&quot;upper&quot;</dt><dd><p>An undirected graph will be created, only the upper
right triangle (including the diagonal) is used for the number of edges.</p>
</dd>
<dt>&quot;lower&quot;</dt><dd><p>An undirected graph will be created, only the lower
left triangle (including the diagonal) is used for creating the edges.</p>
</dd>
<dt>&quot;min&quot;</dt><dd><p>undirected graph will be created with <code>min(A(i,j), A(j,i))</code> edges between vertex <code>i</code> and <code>j</code>.</p>
</dd> <dt>&quot;plus&quot;</dt><dd>
<p>undirected graph will be created with <code>A(i,j)+A(j,i)</code> edges between
vertex <code>i</code> and <code>j</code>.</p>
</dd> </dl>

<p>If the <code>weighted</code> argument is not <code>NULL</code> then the elements of the
matrix give the weights of the edges (if they are not zero).  The details
depend on the value of the <code>mode</code> argument: </p>

<dl>
<dt>&quot;directed&quot;</dt><dd><p>The graph will be directed and a matrix element
gives the edge weights.</p>
</dd> <dt>&quot;undirected&quot;</dt><dd><p>First we check that the
matrix is symmetric. It is an error if not. Then only the upper triangle is
used to create a weighted undirected graph.</p>
</dd> <dt>&quot;max&quot;</dt><dd><p>An
undirected graph will be created and <code>max(A(i,j), A(j,i))</code> gives the
edge weights.</p>
</dd> <dt>&quot;upper&quot;</dt><dd><p>An undirected graph will be created,
only the upper right triangle (including the diagonal) is used (for the edge
weights).</p>
</dd> <dt>&quot;lower&quot;</dt><dd><p>An undirected graph will be created, only
the lower left triangle (including the diagonal) is used for creating the
edges.</p>
</dd> <dt>&quot;min&quot;</dt><dd><p>An undirected graph will be created,
<code>min(A(i,j), A(j,i))</code> gives the edge weights.</p>
</dd> <dt>&quot;plus&quot;</dt><dd><p>An
undirected graph will be created, <code>A(i,j)+A(j,i)</code> gives the edge
weights.</p>
</dd> </dl>



<h3>Value</h3>

<p>An igraph graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph">graph()</a></code> and <code><a href="#topic+graph_from_literal">graph_from_literal()</a></code> for other ways to
create graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
adjm &lt;- matrix(sample(0:1, 100, replace = TRUE, prob = c(0.9, 0.1)), ncol = 10)
g1 &lt;- graph_from_adjacency_matrix(adjm)
adjm &lt;- matrix(sample(0:5, 100,
  replace = TRUE,
  prob = c(0.9, 0.02, 0.02, 0.02, 0.02, 0.02)
), ncol = 10)
g2 &lt;- graph_from_adjacency_matrix(adjm, weighted = TRUE)
E(g2)$weight

## various modes for weighted graphs, with some tests
nzs &lt;- function(x) sort(x[x != 0])
adjm &lt;- matrix(runif(100), 10)
adjm[adjm &lt; 0.5] &lt;- 0
g3 &lt;- graph_from_adjacency_matrix((adjm + t(adjm)) / 2,
  weighted = TRUE,
  mode = "undirected"
)

g4 &lt;- graph_from_adjacency_matrix(adjm, weighted = TRUE, mode = "max")
all(nzs(pmax(adjm, t(adjm))[upper.tri(adjm)]) == sort(E(g4)$weight))

g5 &lt;- graph_from_adjacency_matrix(adjm, weighted = TRUE, mode = "min")
all(nzs(pmin(adjm, t(adjm))[upper.tri(adjm)]) == sort(E(g5)$weight))

g6 &lt;- graph_from_adjacency_matrix(adjm, weighted = TRUE, mode = "upper")
all(nzs(adjm[upper.tri(adjm)]) == sort(E(g6)$weight))

g7 &lt;- graph_from_adjacency_matrix(adjm, weighted = TRUE, mode = "lower")
all(nzs(adjm[lower.tri(adjm)]) == sort(E(g7)$weight))

g8 &lt;- graph_from_adjacency_matrix(adjm, weighted = TRUE, mode = "plus")
d2 &lt;- function(x) {
  diag(x) &lt;- diag(x) / 2
  x
}
all(nzs((d2(adjm + t(adjm)))[lower.tri(adjm)]) == sort(E(g8)$weight))

g9 &lt;- graph_from_adjacency_matrix(adjm, weighted = TRUE, mode = "plus", diag = FALSE)
d0 &lt;- function(x) {
  diag(x) &lt;- 0
}
all(nzs((d0(adjm + t(adjm)))[lower.tri(adjm)]) == sort(E(g9)$weight))

## row/column names
rownames(adjm) &lt;- sample(letters, nrow(adjm))
colnames(adjm) &lt;- seq(ncol(adjm))
g10 &lt;- graph_from_adjacency_matrix(adjm, weighted = TRUE, add.rownames = "code")
summary(g10)

</code></pre>

<hr>
<h2 id='graph_from_atlas'>Create a graph from the Graph Atlas</h2><span id='topic+graph_from_atlas'></span><span id='topic+graph.atlas'></span><span id='topic+atlas'></span>

<h3>Description</h3>

<p><code>graph_from_atlas()</code> creates graphs from the book
&lsquo;An Atlas of Graphs&rsquo; by
Roland C. Read and Robin J. Wilson. The atlas contains all undirected
graphs with up to seven vertices, numbered from 0 up to 1252. The
graphs are listed:
</p>

<ol>
<li><p> in increasing order of number of nodes;
</p>
</li>
<li><p> for a fixed number of nodes, in increasing order of the number
of edges;
</p>
</li>
<li><p> for fixed numbers of nodes and edges, in increasing order of
the degree sequence, for example 111223 &lt; 112222;
</p>
</li>
<li><p> for fixed degree sequence, in increasing number of
automorphisms.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>graph_from_atlas(n)

atlas(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_atlas_+3A_n">n</code></td>
<td>
<p>The id of the graph to create.</p>
</td></tr>
<tr><td><code id="graph_from_atlas_+3A_...">...</code></td>
<td>
<p>Passed to <code>graph_from_atlas()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some randomly picked graphs from the atlas
graph_from_atlas(sample(0:1252, 1))
graph_from_atlas(sample(0:1252, 1))
</code></pre>

<hr>
<h2 id='graph_from_biadjacency_matrix'>Create graphs from a bipartite adjacency matrix</h2><span id='topic+graph_from_biadjacency_matrix'></span>

<h3>Description</h3>

<p><code>graph_from_biadjacency_matrix()</code> creates a bipartite igraph graph from an incidence
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_biadjacency_matrix(
  incidence,
  directed = FALSE,
  mode = c("all", "out", "in", "total"),
  multiple = FALSE,
  weighted = NULL,
  add.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_biadjacency_matrix_+3A_incidence">incidence</code></td>
<td>
<p>The input bipartite adjacency matrix. It can also be a sparse matrix
from the <code>Matrix</code> package.</p>
</td></tr>
<tr><td><code id="graph_from_biadjacency_matrix_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="graph_from_biadjacency_matrix_+3A_mode">mode</code></td>
<td>
<p>A character constant, defines the direction of the edges in
directed graphs, ignored for undirected graphs. If &lsquo;<code>out</code>&rsquo;, then
edges go from vertices of the first kind (corresponding to rows in the
bipartite adjacency matrix) to vertices of the second kind (columns in the incidence
matrix). If &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo;, then the opposite direction is used. If
&lsquo;<code>all</code>&rsquo; or &lsquo;<code>total</code>&rsquo;, then mutual edges are created.</p>
</td></tr>
<tr><td><code id="graph_from_biadjacency_matrix_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, specifies how to interpret the matrix
elements. See details below.</p>
</td></tr>
<tr><td><code id="graph_from_biadjacency_matrix_+3A_weighted">weighted</code></td>
<td>
<p>This argument specifies whether to create a weighted graph
from the bipartite adjacency matrix. If it is <code>NULL</code> then an unweighted graph is
created and the <code>multiple</code> argument is used to determine the edges of
the graph. If it is a character constant then for every non-zero matrix
entry an edge is created and the value of the entry is added as an edge
attribute named by the <code>weighted</code> argument. If it is <code>TRUE</code> then a
weighted graph is created and the name of the edge attribute will be
&lsquo;<code>weight</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="graph_from_biadjacency_matrix_+3A_add.names">add.names</code></td>
<td>
<p>A character constant, <code>NA</code> or <code>NULL</code>.
<code>graph_from_biadjacency_matrix()</code> can add the row and column names of the incidence
matrix as vertex attributes. If this argument is <code>NULL</code> (the default)
and the bipartite adjacency matrix has both row and column names, then these are added
as the &lsquo;<code>name</code>&rsquo; vertex attribute. If you want a different vertex
attribute for this, then give the name of the attributes as a character
string. If this argument is <code>NA</code>, then no vertex attributes (other than
type) will be added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bipartite graphs have a &lsquo;<code>type</code>&rsquo; vertex attribute in igraph,
this is boolean and <code>FALSE</code> for the vertices of the first kind and
<code>TRUE</code> for vertices of the second kind.
</p>
<p><code>graph_from_biadjacency_matrix()</code> can operate in two modes, depending on the
<code>multiple</code> argument. If it is <code>FALSE</code> then a single edge is
created for every non-zero element in the bipartite adjacency matrix. If
<code>multiple</code> is <code>TRUE</code>, then the matrix elements are rounded up to
the closest non-negative integer to get the number of edges to create
between a pair of vertices.
</p>
<p>Some authors refer to the bipartite adjacency matrix as the
&quot;bipartite incidence matrix&quot;. igraph 1.6.0 and later does not use
this naming to avoid confusion with the edge-vertex incidence matrix.
</p>


<h3>Value</h3>

<p>A bipartite igraph graph. In other words, an igraph graph that has a
vertex attribute <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_bipartite_graph">make_bipartite_graph()</a></code> for another way to create bipartite
graphs
</p>
<p>Other biadjacency: 
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
inc &lt;- matrix(sample(0:1, 15, repl = TRUE), 3, 5)
colnames(inc) &lt;- letters[1:5]
rownames(inc) &lt;- LETTERS[1:3]
graph_from_biadjacency_matrix(inc)

</code></pre>

<hr>
<h2 id='graph_from_edgelist'>Create a graph from an edge list matrix</h2><span id='topic+graph_from_edgelist'></span><span id='topic+from_edgelist'></span>

<h3>Description</h3>

<p><code>graph_from_edgelist()</code> creates a graph from an edge list. Its argument
is a two-column matrix, each row defines one edge. If it is
a numeric matrix then its elements are interpreted as vertex ids. If
it is a character matrix then it is interpreted as symbolic vertex
names and a vertex id will be assigned to each name, and also a
<code>name</code> vertex attribute will be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_edgelist(el, directed = TRUE)

from_edgelist(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_edgelist_+3A_el">el</code></td>
<td>
<p>The edge list, a two column matrix, character or numeric.</p>
</td></tr>
<tr><td><code id="graph_from_edgelist_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="graph_from_edgelist_+3A_...">...</code></td>
<td>
<p>Passed to <code>graph_from_edgelist()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>el &lt;- matrix(c("foo", "bar", "bar", "foobar"), nc = 2, byrow = TRUE)
graph_from_edgelist(el)

# Create a ring by hand
graph_from_edgelist(cbind(1:10, c(2:10, 1)))
</code></pre>

<hr>
<h2 id='graph_from_graphdb'>Load a graph from the graph database for testing graph isomorphism.</h2><span id='topic+graph_from_graphdb'></span>

<h3>Description</h3>

<p>This function downloads a graph from a database created for the evaluation
of graph isomorphism testing algothitms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_graphdb(
  url = NULL,
  prefix = "iso",
  type = "r001",
  nodes = NULL,
  pair = "A",
  which = 0,
  base = "http://cneurocvs.rmki.kfki.hu/graphdb/gzip",
  compressed = TRUE,
  directed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_graphdb_+3A_url">url</code></td>
<td>
<p>If not <code>NULL</code> it is a complete URL with the file to import.</p>
</td></tr>
<tr><td><code id="graph_from_graphdb_+3A_prefix">prefix</code></td>
<td>
<p>Gives the prefix. See details below. Possible values:
<code>iso</code>, <code>i2</code>, <code>si4</code>, <code>si6</code>, <code>mcs10</code>, <code>mcs30</code>,
<code>mcs50</code>, <code>mcs70</code>, <code>mcs90</code>.</p>
</td></tr>
<tr><td><code id="graph_from_graphdb_+3A_type">type</code></td>
<td>
<p>Gives the graph type identifier. See details below. Possible
values: <code>r001</code>, <code>r005</code>, <code>r01</code>, <code>r02</code>, <code>m2D</code>,
<code>m2Dr2</code>, <code>m2Dr4</code>, <code>m2Dr6</code> <code>m3D</code>, <code>m3Dr2</code>,
<code>m3Dr4</code>, <code>m3Dr6</code>, <code>m4D</code>, <code>m4Dr2</code>, <code>m4Dr4</code>,
<code>m4Dr6</code>, <code>b03</code>, <code>b03m</code>, <code>b06</code>, <code>b06m</code>, <code>b09</code>,
<code>b09m</code>.</p>
</td></tr>
<tr><td><code id="graph_from_graphdb_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="graph_from_graphdb_+3A_pair">pair</code></td>
<td>
<p>Specifies which graph of the pair to read. Possible values:
<code>A</code> and <code>B</code>.</p>
</td></tr>
<tr><td><code id="graph_from_graphdb_+3A_which">which</code></td>
<td>
<p>Gives the number of the graph to read. For every graph type
there are a number of actual graphs in the database. This argument specifies
which one to read.</p>
</td></tr>
<tr><td><code id="graph_from_graphdb_+3A_base">base</code></td>
<td>
<p>The base address of the database. See details below.</p>
</td></tr>
<tr><td><code id="graph_from_graphdb_+3A_compressed">compressed</code></td>
<td>
<p>Logical constant, if TRUE than the file is expected to be
compressed by gzip. If <code>url</code> is <code>NULL</code> then a &lsquo;<code>.gz</code>&rsquo;
suffix is added to the filename.</p>
</td></tr>
<tr><td><code id="graph_from_graphdb_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to create a directed graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>graph_from_graphdb()</code> reads a graph from the graph database from an FTP or
HTTP server or from a local copy. It has two modes of operation:
</p>
<p>If the <code>url</code> argument is specified then it should the complete path to
a local or remote graph database file. In this case we simply call
<code><a href="#topic+read_graph">read_graph()</a></code> with the proper arguments to read the file.
</p>
<p>If <code>url</code> is <code>NULL</code>, and this is the default, then the filename is
assembled from the <code>base</code>, <code>prefix</code>, <code>type</code>, <code>nodes</code>,
<code>pair</code> and <code>which</code> arguments.
</p>
<p>Unfortunately the original graph database homepage is now defunct, but see
its old version at
<a href="http://web.archive.org/web/20090215182331/http://amalfi.dis.unina.it/graph/db/doc/graphdbat.html">http://web.archive.org/web/20090215182331/http://amalfi.dis.unina.it/graph/db/doc/graphdbat.html</a>
for the actual format of a graph database file and other information.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Examples</h3>

<pre>
g &lt;- graph_from_graphdb(prefix="iso", type="r001", nodes=20, pair="A",
  which=10, compressed=TRUE)
g2 &lt;- graph_from_graphdb(prefix="iso", type="r001", nodes=20, pair="B",
  which=10, compressed=TRUE)
graph.isomorphic.vf2(g, g2)	% should be TRUE
g3 &lt;- graph_from_graphdb(url=paste(sep="/",
                              "http://cneurocvs.rmki.kfki.hu",
                              "graphdb/gzip/iso/bvg/b06m",
                              "iso_b06m_m200.A09.gz"))
</pre>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>M. De Santo, P. Foggia, C. Sansone, M. Vento: A large database
of graphs and its use for benchmarking graph isomorphism algorithms,
<em>Pattern Recognition Letters</em>, Volume 24, Issue 8 (May 2003)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_graph">read_graph()</a></code>, <code><a href="#topic+graph.isomorphic.vf2">graph.isomorphic.vf2()</a></code>
</p>
<p>Foreign format readers
<code><a href="#topic+read_graph">read_graph</a>()</code>,
<code><a href="#topic+write_graph">write_graph</a>()</code>
</p>

<hr>
<h2 id='graph_from_graphnel'>Convert graphNEL objects from the graph package to igraph</h2><span id='topic+graph_from_graphnel'></span>

<h3>Description</h3>

<p>The graphNEL class is defined in the <code>graph</code> package, it is another
way to represent graphs. <code>graph_from_graphnel()</code> takes a graphNEL
graph and converts it to an igraph graph. It handles all
graph/vertex/edge attributes. If the graphNEL graph has a vertex
attribute called &lsquo;<code>name</code>&rsquo; it will be used as igraph vertex
attribute &lsquo;<code>name</code>&rsquo; and the graphNEL vertex names will be
ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_graphnel(graphNEL, name = TRUE, weight = TRUE, unlist.attrs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_graphnel_+3A_graphnel">graphNEL</code></td>
<td>
<p>The graphNEL graph.</p>
</td></tr>
<tr><td><code id="graph_from_graphnel_+3A_name">name</code></td>
<td>
<p>Logical scalar, whether to add graphNEL vertex names as an
igraph vertex attribute called &lsquo;<code>name</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="graph_from_graphnel_+3A_weight">weight</code></td>
<td>
<p>Logical scalar, whether to add graphNEL edge weights as an
igraph edge attribute called &lsquo;<code>weight</code>&rsquo;. (graphNEL graphs are
always weighted.)</p>
</td></tr>
<tr><td><code id="graph_from_graphnel_+3A_unlist.attrs">unlist.attrs</code></td>
<td>
<p>Logical scalar. graphNEL attribute query functions
return the values of the attributes in R lists, if this argument is
<code>TRUE</code> (the default) these will be converted to atomic vectors,
whenever possible, before adding them to the igraph graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because graphNEL graphs poorly support multiple edges, the edge
attributes of the multiple edges are lost: they are all replaced by the
attributes of the first of the multiple edges.
</p>


<h3>Value</h3>

<p><code>graph_from_graphnel()</code> returns an igraph graph object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_graphnel">as_graphnel()</a></code> for the other direction,
<code><a href="#topic+as_adj">as_adj()</a></code>, <code><a href="#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix()</a></code>,
<code><a href="#topic+as_adj_list">as_adj_list()</a></code> and <code><a href="#topic+graph.adjlist">graph.adjlist()</a></code> for other
graph representations.
</p>
<p>Other conversion: 
<code><a href="#topic+as.directed">as.directed</a>()</code>,
<code><a href="#topic+as.matrix.igraph">as.matrix.igraph</a>()</code>,
<code><a href="#topic+as_adj_list">as_adj_list</a>()</code>,
<code><a href="#topic+as_adjacency_matrix">as_adjacency_matrix</a>()</code>,
<code><a href="#topic+as_biadjacency_matrix">as_biadjacency_matrix</a>()</code>,
<code><a href="#topic+as_data_frame">as_data_frame</a>()</code>,
<code><a href="#topic+as_edgelist">as_edgelist</a>()</code>,
<code><a href="#topic+as_graphnel">as_graphnel</a>()</code>,
<code><a href="#topic+as_long_data_frame">as_long_data_frame</a>()</code>,
<code><a href="#topic+graph_from_adj_list">graph_from_adj_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Undirected
g &lt;- make_ring(10)
V(g)$name &lt;- letters[1:10]
GNEL &lt;- as_graphnel(g)
g2 &lt;- graph_from_graphnel(GNEL)
g2

## Directed
g3 &lt;- make_star(10, mode = "in")
V(g3)$name &lt;- letters[1:10]
GNEL2 &lt;- as_graphnel(g3)
g4 &lt;- graph_from_graphnel(GNEL2)
g4

## End(Not run)
</code></pre>

<hr>
<h2 id='graph_from_incidence_matrix'>From incidence matrix</h2><span id='topic+graph_from_incidence_matrix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph_from_incidence_matrix()</code> was renamed to <code>graph_from_biadjacency_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_incidence_matrix(...)
</code></pre>


<h3>Details</h3>

<p>Some authors refer to the bipartite adjacency matrix as the
&quot;bipartite incidence matrix&quot;. igraph 1.6.0 and later does not use
this naming to avoid confusion with the edge-vertex incidence matrix.
</p>

<hr>
<h2 id='graph_from_isomorphism_class'>Create a graph from an isomorphism class</h2><span id='topic+graph_from_isomorphism_class'></span>

<h3>Description</h3>

<p>The isomorphism class is a non-negative integer number.
Graphs (with the same number of vertices) having the same isomorphism
class are isomorphic and isomorphic graphs always have the same
isomorphism class. Currently it can handle directed graphs with 3 or 4
vertices and undirected graphd with 3 to 6 vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_isomorphism_class(size, number, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_isomorphism_class_+3A_size">size</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="graph_from_isomorphism_class_+3A_number">number</code></td>
<td>
<p>The isomorphism class.</p>
</td></tr>
<tr><td><code id="graph_from_isomorphism_class_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph (the default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object, the graph of the given size, directedness
and isomorphism class.
</p>


<h3>See Also</h3>

<p>Other graph isomorphism: 
<code><a href="#topic+canonical_permutation">canonical_permutation</a>()</code>,
<code><a href="#topic+count_isomorphisms">count_isomorphisms</a>()</code>,
<code><a href="#topic+count_subgraph_isomorphisms">count_subgraph_isomorphisms</a>()</code>,
<code><a href="#topic+isomorphic">isomorphic</a>()</code>,
<code><a href="#topic+isomorphism_class">isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphisms">isomorphisms</a>()</code>,
<code><a href="#topic+subgraph_isomorphic">subgraph_isomorphic</a>()</code>,
<code><a href="#topic+subgraph_isomorphisms">subgraph_isomorphisms</a>()</code>
</p>

<hr>
<h2 id='graph_from_lcf'>Creating a graph from LCF notation</h2><span id='topic+graph_from_lcf'></span><span id='topic+graph.lcf'></span>

<h3>Description</h3>

<p>LCF is short for Lederberg-Coxeter-Frucht, it is a concise notation for
3-regular Hamiltonian graphs. It constists of three parameters, the number
of vertices in the graph, a list of shifts giving additional edges to a
cycle backbone and another integer giving how many times the shifts should
be performed. See <a href="http://mathworld.wolfram.com/LCFNotation.html">http://mathworld.wolfram.com/LCFNotation.html</a> for
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_lcf(n, shifts, repeats = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_lcf_+3A_n">n</code></td>
<td>
<p>Integer, the number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="graph_from_lcf_+3A_shifts">shifts</code></td>
<td>
<p>Integer vector, the shifts.</p>
</td></tr>
<tr><td><code id="graph_from_lcf_+3A_repeats">repeats</code></td>
<td>
<p>Integer constant, how many times to repeat the shifts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph">graph()</a></code> can create arbitrary graphs, see also the other
functions on the its manual page for creating special graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This is the Franklin graph:
g1 &lt;- graph_from_lcf(12, c(5, -5), 6)
g2 &lt;- make_graph("Franklin")
isomorphic(g1, g2)
</code></pre>

<hr>
<h2 id='graph_from_literal'>Creating (small) graphs via a simple interface</h2><span id='topic+graph_from_literal'></span><span id='topic+graph.formula'></span><span id='topic+from_literal'></span>

<h3>Description</h3>

<p>This function is useful if you want to create a small (named) graph
quickly, it works for both directed and undirected graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_literal(..., simplify = TRUE)

from_literal(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_from_literal_+3A_...">...</code></td>
<td>
<p>For <code>graph_from_literal()</code> the formulae giving the
structure of the graph, see details below. For <code>from_literal()</code>
all arguments are passed to <code>graph_from_literal()</code>.</p>
</td></tr>
<tr><td><code id="graph_from_literal_+3A_simplify">simplify</code></td>
<td>
<p>Logical scalar, whether to call <code><a href="#topic+simplify">simplify()</a></code>
on the created graph. By default the graph is simplified, loop and
multiple edges are removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>graph_from_literal()</code> is very handy for creating small graphs quickly.
You need to supply one or more R expressions giving the structure of
the graph. The expressions consist of vertex names and edge
operators. An edge operator is a sequence of &lsquo;<code>-</code>&rsquo; and
&lsquo;<code>+</code>&rsquo; characters, the former is for the edges and the
latter is used for arrow heads. The edges can be arbitrarily long,
i.e. you may use as many &lsquo;<code>-</code>&rsquo; characters to &ldquo;draw&rdquo;
them as you like.
</p>
<p>If all edge operators consist of only &lsquo;<code>-</code>&rsquo; characters
then the graph will be undirected, whereas a single &lsquo;<code>+</code>&rsquo;
character implies a directed graph.
</p>
<p>Let us see some simple examples. Without arguments the function
creates an empty graph:
</p>
<pre>  graph_from_literal()
</pre>
<p>A simple undirected graph with two vertices called &lsquo;A&rsquo; and
&lsquo;B&rsquo; and one edge only:
</p>
<pre>  graph_from_literal(A-B)
</pre>
<p>Remember that the length of the edges does not matter, so we could
have written the following, this creates the same graph:
</p>
<pre>  graph_from_literal( A-----B )
</pre>
<p>If you have many disconnected components in the graph, separate them
with commas. You can also give isolate vertices.
</p>
<pre>  graph_from_literal( A--B, C--D, E--F, G--H, I, J, K )
</pre>
<p>The &lsquo;<code>:</code>&rsquo; operator can be used to define vertex sets. If
an edge operator connects two vertex sets then every vertex from the
first set will be connected to every vertex in the second set. The
following form creates a full graph, including loop edges:
</p>
<pre>  graph_from_literal( A:B:C:D -- A:B:C:D )
</pre>
<p>In directed graphs, edges will be created only if the edge operator
includes a arrow head (&lsquo;+&rsquo;) <em>at the end</em> of the edge:
</p>
<pre>  graph_from_literal( A -+ B -+ C )
  graph_from_literal( A +- B -+ C )
  graph_from_literal( A +- B -- C )
</pre>
<p>Thus in the third example no edge is created between vertices <code>B</code>
and <code>C</code>.
</p>
<p>Mutual edges can be also created with a simple edge operator:
</p>
<pre>  graph_from_literal( A +-+ B +---+ C ++ D + E)
</pre>
<p>Note again that the length of the edge operators is arbitrary,
&lsquo;<code>+</code>&rsquo;, &lsquo;<code style="white-space: pre;">&#8288;++&#8288;</code>&rsquo; and &lsquo;<code style="white-space: pre;">&#8288;+-----+&#8288;</code>&rsquo; have
exactly the same meaning.
</p>
<p>If the vertex names include spaces or other special characters then
you need to quote them:
</p>
<pre>  graph_from_literal( "this is" +- "a silly" -+ "graph here" )
</pre>
<p>You can include any character in the vertex names this way, even
&lsquo;+&rsquo; and &lsquo;-&rsquo; characters.
</p>
<p>See more examples below.
</p>


<h3>Value</h3>

<p>An igraph graph
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A simple undirected graph
g &lt;- graph_from_literal(
  Alice - Bob - Cecil - Alice,
  Daniel - Cecil - Eugene,
  Cecil - Gordon
)
g

# Another undirected graph, ":" notation
g2 &lt;- graph_from_literal(Alice - Bob:Cecil:Daniel, Cecil:Daniel - Eugene:Gordon)
g2

# A directed graph
g3 &lt;- graph_from_literal(
  Alice +-+ Bob --+ Cecil +-- Daniel,
  Eugene --+ Gordon:Helen
)
g3

# A graph with isolate vertices
g4 &lt;- graph_from_literal(Alice -- Bob -- Daniel, Cecil:Gordon, Helen)
g4
V(g4)$name

# "Arrows" can be arbitrarily long
g5 &lt;- graph_from_literal(Alice +---------+ Bob)
g5

# Special vertex names
g6 &lt;- graph_from_literal("+" -- "-", "*" -- "/", "%%" -- "%/%")
g6

</code></pre>

<hr>
<h2 id='graph_id'>Get the id of a graph</h2><span id='topic+graph_id'></span>

<h3>Description</h3>

<p>Graph ids are used to check that a vertex or edge sequence
belongs to a graph. If you create a new graph by changing the
structure of a graph, the new graph will have a new id.
Changing the attributes will not change the id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_id(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_id_+3A_x">x</code></td>
<td>
<p>A graph or a vertex sequence or an edge sequence.</p>
</td></tr>
<tr><td><code id="graph_id_+3A_...">...</code></td>
<td>
<p>Not used currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The id of the graph, a character scalar. For
vertex and edge sequences the id of the graph they were created from.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
graph_id(g)
graph_id(V(g))
graph_id(E(g))

g2 &lt;- g + 1
graph_id(g2)
</code></pre>

<hr>
<h2 id='graph_version'>igraph data structure versions</h2><span id='topic+graph_version'></span>

<h3>Description</h3>

<p>igraph's internal data representation changes sometimes between
versions. This means that it is not always possible to use igraph objects
that were created (and possibly saved to a file) with an older
igraph version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_version(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_version_+3A_graph">graph</code></td>
<td>
<p>The input graph. If it is missing, then
the version number of the current data format is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>graph_version()</code> queries the current data format,
or the data format of a possibly older igraph graph.
</p>
<p><code><a href="#topic+upgrade_graph">upgrade_graph()</a></code> can convert an older data format
to the current one.
</p>


<h3>Value</h3>

<p>An integer scalar.
</p>


<h3>See Also</h3>

<p>upgrade_graph to convert the data format of a graph.
</p>
<p>Other versions: 
<code><a href="#topic+upgrade_graph">upgrade_graph</a>()</code>
</p>

<hr>
<h2 id='graph.adhesion'>Edge connectivity</h2><span id='topic+graph.adhesion'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.adhesion()</code> was renamed to <code>adhesion()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.adhesion(graph, checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.adhesion_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.adhesion_+3A_checks">checks</code></td>
<td>
<p>Logical constant. Whether to check that the graph is connected
and also the degree of the vertices. If the graph is not (strongly)
connected then the connectivity is obviously zero. Otherwise if the minimum
degree is one then the edge connectivity is also one. It is a good idea to
perform these checks, as they can be done quickly compared to the
connectivity calculation itself.  They were suggested by Peter McMahan,
thanks Peter.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.adjacency'>Create graphs from adjacency matrices</h2><span id='topic+graph.adjacency'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.adjacency()</code> was renamed to <code>graph_from_adjacency_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.adjacency(
  adjmatrix,
  mode = c("directed", "undirected", "max", "min", "upper", "lower", "plus"),
  weighted = NULL,
  diag = TRUE,
  add.colnames = NULL,
  add.rownames = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.adjacency_+3A_adjmatrix">adjmatrix</code></td>
<td>
<p>A square adjacency matrix. From igraph version 0.5.1 this
can be a sparse matrix created with the <code>Matrix</code> package.</p>
</td></tr>
<tr><td><code id="graph.adjacency_+3A_mode">mode</code></td>
<td>
<p>Character scalar, specifies how igraph should interpret the
supplied matrix. See also the <code>weighted</code> argument, the interpretation
depends on that too. Possible values are: <code>directed</code>,
<code>undirected</code>, <code>upper</code>, <code>lower</code>, <code>max</code>, <code>min</code>,
<code>plus</code>. See details below.</p>
</td></tr>
<tr><td><code id="graph.adjacency_+3A_weighted">weighted</code></td>
<td>
<p>This argument specifies whether to create a weighted graph
from an adjacency matrix. If it is <code>NULL</code> then an unweighted graph is
created and the elements of the adjacency matrix gives the number of edges
between the vertices. If it is a character constant then for every non-zero
matrix entry an edge is created and the value of the entry is added as an
edge attribute named by the <code>weighted</code> argument. If it is <code>TRUE</code>
then a weighted graph is created and the name of the edge attribute will be
<code>weight</code>. See also details below.</p>
</td></tr>
<tr><td><code id="graph.adjacency_+3A_diag">diag</code></td>
<td>
<p>Logical scalar, whether to include the diagonal of the matrix in
the calculation. If this is <code>FALSE</code> then the diagonal is zerod out
first.</p>
</td></tr>
<tr><td><code id="graph.adjacency_+3A_add.colnames">add.colnames</code></td>
<td>
<p>Character scalar, whether to add the column names as
vertex attributes. If it is &lsquo;<code>NULL</code>&rsquo; (the default) then, if
present, column names are added as vertex attribute &lsquo;name&rsquo;. If
&lsquo;<code>NA</code>&rsquo; then they will not be added.  If a character constant,
then it gives the name of the vertex attribute to add.</p>
</td></tr>
<tr><td><code id="graph.adjacency_+3A_add.rownames">add.rownames</code></td>
<td>
<p>Character scalar, whether to add the row names as vertex
attributes. Possible values the same as the previous argument. By default
row names are not added. If &lsquo;<code>add.rownames</code>&rsquo; and
&lsquo;<code>add.colnames</code>&rsquo; specify the same vertex attribute, then the
former is ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.adjlist'>Create graphs from adjacency lists</h2><span id='topic+graph.adjlist'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.adjlist()</code> was renamed to <code>graph_from_adj_list()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.adjlist(adjlist, mode = c("out", "in", "all", "total"), duplicate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.adjlist_+3A_adjlist">adjlist</code></td>
<td>
<p>The adjacency list. It should be consistent, i.e. the maximum
throughout all vectors in the list must be less than the number of vectors
(=the number of vertices in the graph).</p>
</td></tr>
<tr><td><code id="graph.adjlist_+3A_mode">mode</code></td>
<td>
<p>Character scalar, it specifies whether the graph to create is
undirected (&lsquo;all&rsquo; or &lsquo;total&rsquo;) or directed; and in the latter
case, whether it contains the outgoing (&lsquo;out&rsquo;) or the incoming
(&lsquo;in&rsquo;) neighbors of the vertices.</p>
</td></tr>
<tr><td><code id="graph.adjlist_+3A_duplicate">duplicate</code></td>
<td>
<p>Logical scalar. For undirected graphs it gives whether
edges are included in the list twice. E.g. if it is <code>TRUE</code> then for an
undirected <code>{A,B}</code> edge <code>graph_from_adj_list()</code> expects <code>A</code>
included in the neighbors of <code>B</code> and <code>B</code> to be included in the
neighbors of <code>A</code>.
</p>
<p>This argument is ignored if <code>mode</code> is <code>out</code> or <code style="white-space: pre;">&#8288;in&#8288;</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.automorphisms'>Number of automorphisms</h2><span id='topic+graph.automorphisms'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.automorphisms()</code> was renamed to <code>count_automorphisms()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.automorphisms(
  graph,
  colors = NULL,
  sh = c("fm", "f", "fs", "fl", "flm", "fsm")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.automorphisms_+3A_graph">graph</code></td>
<td>
<p>The input graph, it is treated as undirected.</p>
</td></tr>
<tr><td><code id="graph.automorphisms_+3A_colors">colors</code></td>
<td>
<p>The colors of the individual vertices of the graph; only
vertices having the same color are allowed to match each other in an
automorphism. When omitted, igraph uses the <code>color</code> attribute of the
vertices, or, if there is no such vertex attribute, it simply assumes that
all vertices have the same color. Pass NULL explicitly if the graph has a
<code>color</code> vertex attribute but you do not want to use it.</p>
</td></tr>
<tr><td><code id="graph.automorphisms_+3A_sh">sh</code></td>
<td>
<p>The splitting heuristics for the BLISS algorithm. Possible values
are: &lsquo;<code>f</code>&rsquo;: first non-singleton cell, &lsquo;<code>fl</code>&rsquo;: first
largest non-singleton cell, &lsquo;<code>fs</code>&rsquo;: first smallest non-singleton
cell, &lsquo;<code>fm</code>&rsquo;: first maximally non-trivially connected
non-singleton cell, &lsquo;<code>flm</code>&rsquo;: first largest maximally
non-trivially connected non-singleton cell, &lsquo;<code>fsm</code>&rsquo;: first
smallest maximally non-trivially connected non-singleton cell.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.bfs'>Breadth-first search</h2><span id='topic+graph.bfs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.bfs()</code> was renamed to <code>bfs()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.bfs(
  graph,
  root,
  mode = c("out", "in", "all", "total"),
  unreachable = TRUE,
  restricted = NULL,
  order = TRUE,
  rank = FALSE,
  father = FALSE,
  pred = FALSE,
  succ = FALSE,
  dist = FALSE,
  callback = NULL,
  extra = NULL,
  rho = parent.frame(),
  neimode
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.bfs_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_root">root</code></td>
<td>
<p>Numeric vector, usually of length one. The root vertex, or root
vertices to start the search from.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_mode">mode</code></td>
<td>
<p>For directed graphs specifies the type of edges to follow.
&lsquo;out&rsquo; follows outgoing, &lsquo;in&rsquo; incoming edges. &lsquo;all&rsquo;
ignores edge directions completely. &lsquo;total&rsquo; is a synonym for
&lsquo;all&rsquo;. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_unreachable">unreachable</code></td>
<td>
<p>Logical scalar, whether the search should visit the
vertices that are unreachable from the given root vertex (or vertices). If
<code>TRUE</code>, then additional searches are performed until all vertices are
visited.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_restricted">restricted</code></td>
<td>
<p><code>NULL</code> (=no restriction), or a vector of vertices
(ids or symbolic names). In the latter case, the search is restricted to the
given vertices.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_order">order</code></td>
<td>
<p>Logical scalar, whether to return the ordering of the vertices.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_rank">rank</code></td>
<td>
<p>Logical scalar, whether to return the rank of the vertices.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_father">father</code></td>
<td>
<p>Logical scalar, whether to return the father of the vertices.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_pred">pred</code></td>
<td>
<p>Logical scalar, whether to return the predecessors of the
vertices.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_succ">succ</code></td>
<td>
<p>Logical scalar, whether to return the successors of the
vertices.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_dist">dist</code></td>
<td>
<p>Logical scalar, whether to return the distance from the root of
the search tree.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_callback">callback</code></td>
<td>
<p>If not <code>NULL</code>, then it must be callback function. This
is called whenever a vertex is visited. See details below.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_extra">extra</code></td>
<td>
<p>Additional argument to supply to the callback function.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_rho">rho</code></td>
<td>
<p>The environment in which the callback function is evaluated.</p>
</td></tr>
<tr><td><code id="graph.bfs_+3A_neimode">neimode</code></td>
<td>
<p>This argument is deprecated from igraph 1.3.0; use
<code>mode</code> instead.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.cohesion'>Vertex connectivity</h2><span id='topic+graph.cohesion'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.cohesion()</code> was renamed to <code>cohesion()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.cohesion(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.cohesion_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="graph.cohesion_+3A_...">...</code></td>
<td>
<p>passed to <code>cohesion()</code></p>
</td></tr>
</table>

<hr>
<h2 id='graph.complementer'>Complementer of a graph</h2><span id='topic+graph.complementer'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.complementer()</code> was renamed to <code>complementer()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.complementer(graph, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.complementer_+3A_graph">graph</code></td>
<td>
<p>The input graph, can be directed or undirected.</p>
</td></tr>
<tr><td><code id="graph.complementer_+3A_loops">loops</code></td>
<td>
<p>Logical constant, whether to generate loop edges.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.compose'>Compose two graphs as binary relations</h2><span id='topic+graph.compose'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.compose()</code> was renamed to <code>compose()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.compose(g1, g2, byname = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.compose_+3A_g1">g1</code></td>
<td>
<p>The first input graph.</p>
</td></tr>
<tr><td><code id="graph.compose_+3A_g2">g2</code></td>
<td>
<p>The second input graph.</p>
</td></tr>
<tr><td><code id="graph.compose_+3A_byname">byname</code></td>
<td>
<p>A logical scalar, or the character scalar <code>auto</code>. Whether
to perform the operation based on symbolic vertex names. If it is
<code>auto</code>, that means <code>TRUE</code> if both graphs are named and
<code>FALSE</code> otherwise. A warning is generated if <code>auto</code> and one graph,
but not both graphs are named.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.coreness'>K-core decomposition of graphs</h2><span id='topic+graph.coreness'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.coreness()</code> was renamed to <code>coreness()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.coreness(graph, mode = c("all", "out", "in"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.coreness_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected</p>
</td></tr>
<tr><td><code id="graph.coreness_+3A_mode">mode</code></td>
<td>
<p>The type of the core in directed graphs. Character constant,
possible values: <code style="white-space: pre;">&#8288;in&#8288;</code>: in-cores are computed, <code>out</code>: out-cores are
computed, <code>all</code>: the corresponding undirected graph is considered. This
argument is ignored for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.data.frame'>Creating igraph graphs from data frames or vice-versa</h2><span id='topic+graph.data.frame'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.data.frame()</code> was renamed to <code>graph_from_data_frame()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.data.frame(d, directed = TRUE, vertices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.data.frame_+3A_d">d</code></td>
<td>
<p>A data frame containing a symbolic edge list in the first two
columns. Additional columns are considered as edge attributes.  Since
version 0.7 this argument is coerced to a data frame with
<code>as.data.frame</code>.</p>
</td></tr>
<tr><td><code id="graph.data.frame_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether or not to create a directed graph.</p>
</td></tr>
<tr><td><code id="graph.data.frame_+3A_vertices">vertices</code></td>
<td>
<p>A data frame with vertex metadata, or <code>NULL</code>. See
details below. Since version 0.7 this argument is coerced to a data frame
with <code>as.data.frame</code>, if not <code>NULL</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.density'>Graph density</h2><span id='topic+graph.density'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.density()</code> was renamed to <code>edge_density()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.density(graph, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.density_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.density_+3A_loops">loops</code></td>
<td>
<p>Logical constant, whether loop edges may exist in the graph.
This affects the calculation of the largest possible number of edges in the
graph. If this parameter is set to FALSE yet the graph contains self-loops,
the result will not be meaningful.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.dfs'>Depth-first search</h2><span id='topic+graph.dfs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.dfs()</code> was renamed to <code>dfs()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.dfs(
  graph,
  root,
  mode = c("out", "in", "all", "total"),
  unreachable = TRUE,
  order = TRUE,
  order.out = FALSE,
  father = FALSE,
  dist = FALSE,
  in.callback = NULL,
  out.callback = NULL,
  extra = NULL,
  rho = parent.frame(),
  neimode
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.dfs_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_root">root</code></td>
<td>
<p>The single root vertex to start the search from.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_mode">mode</code></td>
<td>
<p>For directed graphs specifies the type of edges to follow.
&lsquo;out&rsquo; follows outgoing, &lsquo;in&rsquo; incoming edges. &lsquo;all&rsquo;
ignores edge directions completely. &lsquo;total&rsquo; is a synonym for
&lsquo;all&rsquo;. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_unreachable">unreachable</code></td>
<td>
<p>Logical scalar, whether the search should visit the
vertices that are unreachable from the given root vertex (or vertices). If
<code>TRUE</code>, then additional searches are performed until all vertices are
visited.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_order">order</code></td>
<td>
<p>Logical scalar, whether to return the DFS ordering of the
vertices.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_order.out">order.out</code></td>
<td>
<p>Logical scalar, whether to return the ordering based on
leaving the subtree of the vertex.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_father">father</code></td>
<td>
<p>Logical scalar, whether to return the father of the vertices.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_dist">dist</code></td>
<td>
<p>Logical scalar, whether to return the distance from the root of
the search tree.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_in.callback">in.callback</code></td>
<td>
<p>If not <code>NULL</code>, then it must be callback function.
This is called whenever a vertex is visited. See details below.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_out.callback">out.callback</code></td>
<td>
<p>If not <code>NULL</code>, then it must be callback function.
This is called whenever the subtree of a vertex is completed by the
algorithm. See details below.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_extra">extra</code></td>
<td>
<p>Additional argument to supply to the callback function.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_rho">rho</code></td>
<td>
<p>The environment in which the callback function is evaluated.</p>
</td></tr>
<tr><td><code id="graph.dfs_+3A_neimode">neimode</code></td>
<td>
<p>This argument is deprecated from igraph 1.3.0; use
<code>mode</code> instead.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.difference'>Difference of two sets</h2><span id='topic+graph.difference'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.difference()</code> was renamed to <code>difference()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.difference(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.difference_+3A_...">...</code></td>
<td>
<p>Arguments, their number and interpretation depends on
the function that implements <code>difference()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.disjoint.union'>Disjoint union of graphs</h2><span id='topic+graph.disjoint.union'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.disjoint.union()</code> was renamed to <code>disjoint_union()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.disjoint.union(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.disjoint.union_+3A_...">...</code></td>
<td>
<p>Graph objects or lists of graph objects.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.diversity'>Graph diversity</h2><span id='topic+graph.diversity'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.diversity()</code> was renamed to <code>diversity()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.diversity(graph, weights = NULL, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.diversity_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions are ignored.</p>
</td></tr>
<tr><td><code id="graph.diversity_+3A_weights">weights</code></td>
<td>
<p><code>NULL</code>, or the vector of edge weights to use for the
computation. If <code>NULL</code>, then the &lsquo;weight&rsquo; attibute is used. Note
that this measure is not defined for unweighted graphs.</p>
</td></tr>
<tr><td><code id="graph.diversity_+3A_vids">vids</code></td>
<td>
<p>The vertex ids for which to calculate the measure.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.edgelist'>Create a graph from an edge list matrix</h2><span id='topic+graph.edgelist'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.edgelist()</code> was renamed to <code>graph_from_edgelist()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.edgelist(el, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.edgelist_+3A_el">el</code></td>
<td>
<p>The edge list, a two column matrix, character or numeric.</p>
</td></tr>
<tr><td><code id="graph.edgelist_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.eigen'>Eigenvalues and eigenvectors of the adjacency matrix of a graph</h2><span id='topic+graph.eigen'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.eigen()</code> was renamed to <code>spectrum()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.eigen(
  graph,
  algorithm = c("arpack", "auto", "lapack", "comp_auto", "comp_lapack", "comp_arpack"),
  which = list(),
  options = arpack_defaults()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.eigen_+3A_graph">graph</code></td>
<td>
<p>The input graph, can be directed or undirected.</p>
</td></tr>
<tr><td><code id="graph.eigen_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use. Currently only <code>arpack</code> is
implemented, which uses the ARPACK solver. See also <code><a href="#topic+arpack">arpack()</a></code>.</p>
</td></tr>
<tr><td><code id="graph.eigen_+3A_which">which</code></td>
<td>
<p>A list to specify which eigenvalues and eigenvectors to
calculate. By default the leading (i.e. largest magnitude) eigenvalue and
the corresponding eigenvector is calculated.</p>
</td></tr>
<tr><td><code id="graph.eigen_+3A_options">options</code></td>
<td>
<p>Options for the ARPACK solver. See
<code><a href="#topic+arpack_defaults">arpack_defaults()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.graphdb'>Load a graph from the graph database for testing graph isomorphism.</h2><span id='topic+graph.graphdb'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.graphdb()</code> was renamed to <code>graph_from_graphdb()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.graphdb(
  url = NULL,
  prefix = "iso",
  type = "r001",
  nodes = NULL,
  pair = "A",
  which = 0,
  base = "http://cneurocvs.rmki.kfki.hu/graphdb/gzip",
  compressed = TRUE,
  directed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.graphdb_+3A_url">url</code></td>
<td>
<p>If not <code>NULL</code> it is a complete URL with the file to import.</p>
</td></tr>
<tr><td><code id="graph.graphdb_+3A_prefix">prefix</code></td>
<td>
<p>Gives the prefix. See details below. Possible values:
<code>iso</code>, <code>i2</code>, <code>si4</code>, <code>si6</code>, <code>mcs10</code>, <code>mcs30</code>,
<code>mcs50</code>, <code>mcs70</code>, <code>mcs90</code>.</p>
</td></tr>
<tr><td><code id="graph.graphdb_+3A_type">type</code></td>
<td>
<p>Gives the graph type identifier. See details below. Possible
values: <code>r001</code>, <code>r005</code>, <code>r01</code>, <code>r02</code>, <code>m2D</code>,
<code>m2Dr2</code>, <code>m2Dr4</code>, <code>m2Dr6</code> <code>m3D</code>, <code>m3Dr2</code>,
<code>m3Dr4</code>, <code>m3Dr6</code>, <code>m4D</code>, <code>m4Dr2</code>, <code>m4Dr4</code>,
<code>m4Dr6</code>, <code>b03</code>, <code>b03m</code>, <code>b06</code>, <code>b06m</code>, <code>b09</code>,
<code>b09m</code>.</p>
</td></tr>
<tr><td><code id="graph.graphdb_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="graph.graphdb_+3A_pair">pair</code></td>
<td>
<p>Specifies which graph of the pair to read. Possible values:
<code>A</code> and <code>B</code>.</p>
</td></tr>
<tr><td><code id="graph.graphdb_+3A_which">which</code></td>
<td>
<p>Gives the number of the graph to read. For every graph type
there are a number of actual graphs in the database. This argument specifies
which one to read.</p>
</td></tr>
<tr><td><code id="graph.graphdb_+3A_base">base</code></td>
<td>
<p>The base address of the database. See details below.</p>
</td></tr>
<tr><td><code id="graph.graphdb_+3A_compressed">compressed</code></td>
<td>
<p>Logical constant, if TRUE than the file is expected to be
compressed by gzip. If <code>url</code> is <code>NULL</code> then a &lsquo;<code>.gz</code>&rsquo;
suffix is added to the filename.</p>
</td></tr>
<tr><td><code id="graph.graphdb_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to create a directed graph.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.incidence'>Create graphs from a bipartite adjacency matrix</h2><span id='topic+graph.incidence'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.incidence()</code> was renamed to <code>graph_from_biadjacency_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.incidence(
  incidence,
  directed = FALSE,
  mode = c("all", "out", "in", "total"),
  multiple = FALSE,
  weighted = NULL,
  add.names = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.incidence_+3A_incidence">incidence</code></td>
<td>
<p>The input bipartite adjacency matrix. It can also be a sparse matrix
from the <code>Matrix</code> package.</p>
</td></tr>
<tr><td><code id="graph.incidence_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="graph.incidence_+3A_mode">mode</code></td>
<td>
<p>A character constant, defines the direction of the edges in
directed graphs, ignored for undirected graphs. If &lsquo;<code>out</code>&rsquo;, then
edges go from vertices of the first kind (corresponding to rows in the
bipartite adjacency matrix) to vertices of the second kind (columns in the incidence
matrix). If &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo;, then the opposite direction is used. If
&lsquo;<code>all</code>&rsquo; or &lsquo;<code>total</code>&rsquo;, then mutual edges are created.</p>
</td></tr>
<tr><td><code id="graph.incidence_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, specifies how to interpret the matrix
elements. See details below.</p>
</td></tr>
<tr><td><code id="graph.incidence_+3A_weighted">weighted</code></td>
<td>
<p>This argument specifies whether to create a weighted graph
from the bipartite adjacency matrix. If it is <code>NULL</code> then an unweighted graph is
created and the <code>multiple</code> argument is used to determine the edges of
the graph. If it is a character constant then for every non-zero matrix
entry an edge is created and the value of the entry is added as an edge
attribute named by the <code>weighted</code> argument. If it is <code>TRUE</code> then a
weighted graph is created and the name of the edge attribute will be
&lsquo;<code>weight</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="graph.incidence_+3A_add.names">add.names</code></td>
<td>
<p>A character constant, <code>NA</code> or <code>NULL</code>.
<code>graph_from_biadjacency_matrix()</code> can add the row and column names of the incidence
matrix as vertex attributes. If this argument is <code>NULL</code> (the default)
and the bipartite adjacency matrix has both row and column names, then these are added
as the &lsquo;<code>name</code>&rsquo; vertex attribute. If you want a different vertex
attribute for this, then give the name of the attributes as a character
string. If this argument is <code>NA</code>, then no vertex attributes (other than
type) will be added.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.intersection'>Intersection of two or more sets</h2><span id='topic+graph.intersection'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.intersection()</code> was renamed to <code>intersection()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.intersection(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.intersection_+3A_...">...</code></td>
<td>
<p>Arguments, their number and interpretation depends on
the function that implements <code>intersection()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.isocreate'>Create a graph from an isomorphism class</h2><span id='topic+graph.isocreate'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.isocreate()</code> was renamed to <code>graph_from_isomorphism_class()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.isocreate(size, number, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.isocreate_+3A_size">size</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="graph.isocreate_+3A_number">number</code></td>
<td>
<p>The isomorphism class.</p>
</td></tr>
<tr><td><code id="graph.isocreate_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph (the default).</p>
</td></tr>
</table>

<hr>
<h2 id='graph.knn'>Average nearest neighbor degree</h2><span id='topic+graph.knn'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.knn()</code> was renamed to <code>knn()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.knn(
  graph,
  vids = V(graph),
  mode = c("all", "out", "in", "total"),
  neighbor.degree.mode = c("all", "out", "in", "total"),
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.knn_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed.</p>
</td></tr>
<tr><td><code id="graph.knn_+3A_vids">vids</code></td>
<td>
<p>The vertices for which the calculation is performed. Normally it
includes all vertices. Note, that if not all vertices are given here, then
both &lsquo;<code>knn</code>&rsquo; and &lsquo;<code>knnk</code>&rsquo; will be calculated based
on the given vertices only.</p>
</td></tr>
<tr><td><code id="graph.knn_+3A_mode">mode</code></td>
<td>
<p>Character constant to indicate the type of neighbors to consider
in directed graphs. <code>out</code> considers out-neighbors, <code style="white-space: pre;">&#8288;in&#8288;</code> considers
in-neighbors and <code>all</code> ignores edge directions.</p>
</td></tr>
<tr><td><code id="graph.knn_+3A_neighbor.degree.mode">neighbor.degree.mode</code></td>
<td>
<p>The type of degree to average in directed graphs.
<code>out</code> averages out-degrees, <code style="white-space: pre;">&#8288;in&#8288;</code> averages in-degrees and <code>all</code>
ignores edge directions for the degree calculation.</p>
</td></tr>
<tr><td><code id="graph.knn_+3A_weights">weights</code></td>
<td>
<p>Weight vector. If the graph has a <code>weight</code> edge
attribute, then this is used by default. If this argument is given, then
vertex strength (see <code><a href="#topic+strength">strength()</a></code>) is used instead of vertex
degree. But note that <code>knnk</code> is still given in the function of the
normal vertex degree.
Weights are are used to calculate a weighted degree (also called
<code><a href="#topic+strength">strength()</a></code>) instead of the degree.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.laplacian'>Graph Laplacian</h2><span id='topic+graph.laplacian'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.laplacian()</code> was renamed to <code>laplacian_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.laplacian(
  graph,
  normalized = FALSE,
  weights = NULL,
  sparse = igraph_opt("sparsematrices")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.laplacian_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.laplacian_+3A_normalized">normalized</code></td>
<td>
<p>Whether to calculate the normalized Laplacian. See
definitions below.</p>
</td></tr>
<tr><td><code id="graph.laplacian_+3A_weights">weights</code></td>
<td>
<p>An optional vector giving edge weights for weighted Laplacian
matrix. If this is <code>NULL</code> and the graph has an edge attribute called
<code>weight</code>, then it will be used automatically. Set this to <code>NA</code> if
you want the unweighted Laplacian on a graph that has a <code>weight</code> edge
attribute.</p>
</td></tr>
<tr><td><code id="graph.laplacian_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to return the result as a sparse
matrix. The <code>Matrix</code> package is required for sparse matrices.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.maxflow'>Maximum flow in a graph</h2><span id='topic+graph.maxflow'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.maxflow()</code> was renamed to <code>max_flow()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.maxflow(graph, source, target, capacity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.maxflow_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.maxflow_+3A_source">source</code></td>
<td>
<p>The id of the source vertex.</p>
</td></tr>
<tr><td><code id="graph.maxflow_+3A_target">target</code></td>
<td>
<p>The id of the target vertex (sometimes also called sink).</p>
</td></tr>
<tr><td><code id="graph.maxflow_+3A_capacity">capacity</code></td>
<td>
<p>Vector giving the capacity of the edges. If this is
<code>NULL</code> (the default) then the <code>capacity</code> edge attribute is used.
Note that the <code>weight</code> edge attribute is not used by this function.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.mincut'>Minimum cut in a graph</h2><span id='topic+graph.mincut'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.mincut()</code> was renamed to <code>min_cut()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.mincut(
  graph,
  source = NULL,
  target = NULL,
  capacity = NULL,
  value.only = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.mincut_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.mincut_+3A_source">source</code></td>
<td>
<p>The id of the source vertex.</p>
</td></tr>
<tr><td><code id="graph.mincut_+3A_target">target</code></td>
<td>
<p>The id of the target vertex (sometimes also called sink).</p>
</td></tr>
<tr><td><code id="graph.mincut_+3A_capacity">capacity</code></td>
<td>
<p>Vector giving the capacity of the edges. If this is
<code>NULL</code> (the default) then the <code>capacity</code> edge attribute is used.</p>
</td></tr>
<tr><td><code id="graph.mincut_+3A_value.only">value.only</code></td>
<td>
<p>Logical scalar, if <code>TRUE</code> only the minimum cut value
is returned, if <code>FALSE</code> the edges in the cut and a the two (or more)
partitions are also returned.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.motifs'>Graph motifs</h2><span id='topic+graph.motifs'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.motifs()</code> was renamed to <code>motifs()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.motifs(graph, size = 3, cut.prob = rep(0, size))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.motifs_+3A_graph">graph</code></td>
<td>
<p>Graph object, the input graph.</p>
</td></tr>
<tr><td><code id="graph.motifs_+3A_size">size</code></td>
<td>
<p>The size of the motif, currently sizes 3 and 4 are supported in
directed graphs and sizes 3-6 in undirected graphs.</p>
</td></tr>
<tr><td><code id="graph.motifs_+3A_cut.prob">cut.prob</code></td>
<td>
<p>Numeric vector giving the probabilities that the search
graph is cut at a certain level. Its length should be the same as the size
of the motif (the <code>size</code> argument). By default no cuts are made.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.motifs.est'>Graph motifs</h2><span id='topic+graph.motifs.est'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.motifs.est()</code> was renamed to <code>sample_motifs()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.motifs.est(
  graph,
  size = 3,
  cut.prob = rep(0, size),
  sample.size = vcount(graph)/10,
  sample = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.motifs.est_+3A_graph">graph</code></td>
<td>
<p>Graph object, the input graph.</p>
</td></tr>
<tr><td><code id="graph.motifs.est_+3A_size">size</code></td>
<td>
<p>The size of the motif, currently size 3 and 4 are supported
in directed graphs and sizes 3-6 in undirected graphs.</p>
</td></tr>
<tr><td><code id="graph.motifs.est_+3A_cut.prob">cut.prob</code></td>
<td>
<p>Numeric vector giving the probabilities that the search
graph is cut at a certain level. Its length should be the same as the size
of the motif (the <code>size</code> argument). By default no cuts are made.</p>
</td></tr>
<tr><td><code id="graph.motifs.est_+3A_sample.size">sample.size</code></td>
<td>
<p>The number of vertices to use as a starting point for
finding motifs. Only used if the <code>sample</code> argument is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="graph.motifs.est_+3A_sample">sample</code></td>
<td>
<p>If not <code>NULL</code> then it specifies the vertices to use as a
starting point for finding motifs.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.motifs.no'>Graph motifs</h2><span id='topic+graph.motifs.no'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.motifs.no()</code> was renamed to <code>count_motifs()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.motifs.no(graph, size = 3, cut.prob = rep(0, size))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.motifs.no_+3A_graph">graph</code></td>
<td>
<p>Graph object, the input graph.</p>
</td></tr>
<tr><td><code id="graph.motifs.no_+3A_size">size</code></td>
<td>
<p>The size of the motif.</p>
</td></tr>
<tr><td><code id="graph.motifs.no_+3A_cut.prob">cut.prob</code></td>
<td>
<p>Numeric vector giving the probabilities that the search
graph is cut at a certain level. Its length should be the same as the size
of the motif (the <code>size</code> argument). By default no cuts are made.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.neighborhood'>Neighborhood of graph vertices</h2><span id='topic+graph.neighborhood'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.neighborhood()</code> was renamed to <code>make_ego_graph()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.neighborhood(
  graph,
  order = 1,
  nodes = V(graph),
  mode = c("all", "out", "in"),
  mindist = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.neighborhood_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.neighborhood_+3A_order">order</code></td>
<td>
<p>Integer giving the order of the neighborhood.</p>
</td></tr>
<tr><td><code id="graph.neighborhood_+3A_nodes">nodes</code></td>
<td>
<p>The vertices for which the calculation is performed.</p>
</td></tr>
<tr><td><code id="graph.neighborhood_+3A_mode">mode</code></td>
<td>
<p>Character constant, it specifies how to use the direction of
the edges if a directed graph is analyzed. For &lsquo;out&rsquo; only the
outgoing edges are followed, so all vertices reachable from the source
vertex in at most <code>order</code> steps are counted. For &lsquo;&quot;in&quot;&rsquo; all
vertices from which the source vertex is reachable in at most <code>order</code>
steps are counted. &lsquo;&quot;all&quot;&rsquo; ignores the direction of the edges. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="graph.neighborhood_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance to include the vertex in the result.</p>
</td></tr>
</table>

<hr>
<h2 id='graph.strength'>Strength or weighted vertex degree</h2><span id='topic+graph.strength'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.strength()</code> was renamed to <code>strength()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.strength(
  graph,
  vids = V(graph),
  mode = c("all", "out", "in", "total"),
  loops = TRUE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.strength_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="graph.strength_+3A_vids">vids</code></td>
<td>
<p>The vertices for which the strength will be calculated.</p>
</td></tr>
<tr><td><code id="graph.strength_+3A_mode">mode</code></td>
<td>
<p>Character string, &ldquo;out&rdquo; for out-degree, &ldquo;in&rdquo; for
in-degree or &ldquo;all&rdquo; for the sum of the two. For undirected graphs this
argument is ignored.</p>
</td></tr>
<tr><td><code id="graph.strength_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
<tr><td><code id="graph.strength_+3A_weights">weights</code></td>
<td>
<p>Weight vector. If the graph has a <code>weight</code> edge
attribute, then this is used by default. If the graph does not have a
<code>weight</code> edge attribute and this argument is <code>NULL</code>, then a
<code><a href="#topic+degree">degree()</a></code> is called. If this is <code>NA</code>, then no edge weights are used
(even if the graph has a <code>weight</code> edge attribute).</p>
</td></tr>
</table>

<hr>
<h2 id='graph.union'>Union of graphs</h2><span id='topic+graph.union'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graph.union()</code> was renamed to <code>union.igraph()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph.union(..., byname = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph.union_+3A_...">...</code></td>
<td>
<p>Graph objects or lists of graph objects.</p>
</td></tr>
<tr><td><code id="graph.union_+3A_byname">byname</code></td>
<td>
<p>A logical scalar, or the character scalar <code>auto</code>. Whether
to perform the operation based on symbolic vertex names. If it is
<code>auto</code>, that means <code>TRUE</code> if all graphs are named and <code>FALSE</code>
otherwise. A warning is generated if <code>auto</code> and some (but not all)
graphs are named.</p>
</td></tr>
</table>

<hr>
<h2 id='graphlet_basis'>Graphlet decomposition of a graph</h2><span id='topic+graphlet_basis'></span><span id='topic+graphlet_proj'></span><span id='topic+graphlets'></span>

<h3>Description</h3>

<p>Graphlet decomposition models a weighted undirected graph via the union of
potentially overlapping dense social groups.  This is done by a two-step
algorithm. In the first step a candidate set of groups (a candidate basis)
is created by finding cliques if the thresholded input graph. In the second
step these the graph is projected on the candidate basis, resulting a weight
coefficient for each clique in the candidate basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphlet_basis(graph, weights = NULL)

graphlet_proj(
  graph,
  weights = NULL,
  cliques,
  niter = 1000,
  Mu = rep(1, length(cliques))
)

graphlets(graph, weights = NULL, niter = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphlet_basis_+3A_graph">graph</code></td>
<td>
<p>The input graph, edge directions are ignored. Only simple graph
(i.e. graphs without self-loops and multiple edges) are supported.</p>
</td></tr>
<tr><td><code id="graphlet_basis_+3A_weights">weights</code></td>
<td>
<p>Edge weights. If the graph has a <code>weight</code> edge attribute
and this argument is <code>NULL</code> (the default), then the <code>weight</code> edge
attribute is used.</p>
</td></tr>
<tr><td><code id="graphlet_basis_+3A_cliques">cliques</code></td>
<td>
<p>A list of vertex ids, the graphlet basis to use for the
projection.</p>
</td></tr>
<tr><td><code id="graphlet_basis_+3A_niter">niter</code></td>
<td>
<p>Integer scalar, the number of iterations to perform.</p>
</td></tr>
<tr><td><code id="graphlet_basis_+3A_mu">Mu</code></td>
<td>
<p>Starting weights for the projection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>igraph contains three functions for performing the graph decomponsition of a
graph. The first is <code>graphlets()</code>, which performed both steps on the
method and returns a list of subgraphs, with their corresponding weights.
The second and third functions correspond to the first and second steps of
the algorithm, and they are useful if the user wishes to perform them
individually: <code>graphlet_basis()</code> and <code>graphlet_proj()</code>.
</p>


<h3>Value</h3>

<p><code>graphlets()</code> returns a list with two members: </p>
<table>
<tr><td><code>cliques</code></td>
<td>
<p>A
list of subgraphs, the candidate graphlet basis. Each subgraph is give by a
vector of vertex ids.</p>
</td></tr> <tr><td><code>Mu</code></td>
<td>
<p>The weights of the subgraphs in graphlet
basis.</p>
</td></tr>
</table>
<p><code>graphlet_basis()</code> returns a list of two elements: </p>
<table>
<tr><td><code>cliques</code></td>
<td>
<p>A list
of subgraphs, the candidate graphlet basis. Each subgraph is give by a
vector of vertex ids.</p>
</td></tr> <tr><td><code>thresholds</code></td>
<td>
<p>The weight thresholds used for
finding the subgraphs.</p>
</td></tr>
</table>
<p><code>graphlet_proj()</code> return a numeric vector, the weights of the graphlet
basis subgraphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Create an example graph first
D1 &lt;- matrix(0, 5, 5)
D2 &lt;- matrix(0, 5, 5)
D3 &lt;- matrix(0, 5, 5)
D1[1:3, 1:3] &lt;- 2
D2[3:5, 3:5] &lt;- 3
D3[2:5, 2:5] &lt;- 1

g &lt;- simplify(graph_from_adjacency_matrix(D1 + D2 + D3,
  mode = "undirected", weighted = TRUE
))
V(g)$color &lt;- "white"
E(g)$label &lt;- E(g)$weight
E(g)$label.cex &lt;- 2
E(g)$color &lt;- "black"
layout(matrix(1:6, nrow = 2, byrow = TRUE))
co &lt;- layout_with_kk(g)
par(mar = c(1, 1, 1, 1))
plot(g, layout = co)

## Calculate graphlets
gl &lt;- graphlets(g, niter = 1000)

## Plot graphlets
for (i in 1:length(gl$cliques)) {
  sel &lt;- gl$cliques[[i]]
  V(g)$color &lt;- "white"
  V(g)[sel]$color &lt;- "#E495A5"
  E(g)$width &lt;- 1
  E(g)[V(g)[sel] %--% V(g)[sel]]$width &lt;- 2
  E(g)$label &lt;- ""
  E(g)[width == 2]$label &lt;- round(gl$Mu[i], 2)
  E(g)$color &lt;- "black"
  E(g)[width == 2]$color &lt;- "#E495A5"
  plot(g, layout = co)
}
</code></pre>

<hr>
<h2 id='graphlets.candidate.basis'>Graphlet decomposition of a graph</h2><span id='topic+graphlets.candidate.basis'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graphlets.candidate.basis()</code> was renamed to <code>graphlet_basis()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphlets.candidate.basis(graph, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphlets.candidate.basis_+3A_graph">graph</code></td>
<td>
<p>The input graph, edge directions are ignored. Only simple graph
(i.e. graphs without self-loops and multiple edges) are supported.</p>
</td></tr>
<tr><td><code id="graphlets.candidate.basis_+3A_weights">weights</code></td>
<td>
<p>Edge weights. If the graph has a <code>weight</code> edge attribute
and this argument is <code>NULL</code> (the default), then the <code>weight</code> edge
attribute is used.</p>
</td></tr>
</table>

<hr>
<h2 id='graphlets.project'>Graphlet decomposition of a graph</h2><span id='topic+graphlets.project'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>graphlets.project()</code> was renamed to <code>graphlet_proj()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphlets.project(
  graph,
  weights = NULL,
  cliques,
  niter = 1000,
  Mu = rep(1, length(cliques))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphlets.project_+3A_graph">graph</code></td>
<td>
<p>The input graph, edge directions are ignored. Only simple graph
(i.e. graphs without self-loops and multiple edges) are supported.</p>
</td></tr>
<tr><td><code id="graphlets.project_+3A_weights">weights</code></td>
<td>
<p>Edge weights. If the graph has a <code>weight</code> edge attribute
and this argument is <code>NULL</code> (the default), then the <code>weight</code> edge
attribute is used.</p>
</td></tr>
<tr><td><code id="graphlets.project_+3A_cliques">cliques</code></td>
<td>
<p>A list of vertex ids, the graphlet basis to use for the
projection.</p>
</td></tr>
<tr><td><code id="graphlets.project_+3A_niter">niter</code></td>
<td>
<p>Integer scalar, the number of iterations to perform.</p>
</td></tr>
<tr><td><code id="graphlets.project_+3A_mu">Mu</code></td>
<td>
<p>Starting weights for the projection.</p>
</td></tr>
</table>

<hr>
<h2 id='greedy_vertex_coloring'>Greedy vertex coloring</h2><span id='topic+greedy_vertex_coloring'></span>

<h3>Description</h3>

<p><code>greedy_vertex_coloring()</code> finds a coloring for the vertices of a graph
based on a simple greedy algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedy_vertex_coloring(graph, heuristic = c("colored_neighbors", "dsatur"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="greedy_vertex_coloring_+3A_graph">graph</code></td>
<td>
<p>The graph object to color.</p>
</td></tr>
<tr><td><code id="greedy_vertex_coloring_+3A_heuristic">heuristic</code></td>
<td>
<p>The selection heuristic for the next vertex to consider.
Possible values are: &ldquo;colored_neighbors&rdquo; selects the vertex with the
largest number of already colored neighbors. &ldquo;dsatur&rdquo; selects the
vertex with the largest number of unique colors in its neighborhood, i.e.
its &quot;saturation degree&quot;; when there are several maximum saturation degree
vertices, the one with the most uncolored neighbors will be selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of vertex coloring is to assign a &quot;color&quot; (represented as a positive
integer) to each vertex of the graph such that neighboring vertices never
have the same color. This function solves the problem by considering the
vertices one by one according to a heuristic, always choosing the smallest
color that differs from that of already colored neighbors. The coloring
obtained this way is not necessarily minimum but it can be calculated in
linear time.
</p>


<h3>Value</h3>

<p>A numeric vector where item <code>i</code> contains the color index
associated to vertex <code>i</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph("petersen")
col &lt;- greedy_vertex_coloring(g)
plot(g, vertex.color = col)

</code></pre>

<hr>
<h2 id='grg.game'>Geometric random graphs</h2><span id='topic+grg.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>grg.game()</code> was renamed to <code>sample_grg()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grg.game(nodes, radius, torus = FALSE, coords = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grg.game_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="grg.game_+3A_radius">radius</code></td>
<td>
<p>The radius within which the vertices will be connected by an
edge.</p>
</td></tr>
<tr><td><code id="grg.game_+3A_torus">torus</code></td>
<td>
<p>Logical constant, whether to use a torus instead of a square.</p>
</td></tr>
<tr><td><code id="grg.game_+3A_coords">coords</code></td>
<td>
<p>Logical scalar, whether to add the positions of the vertices
as vertex attributes called &lsquo;<code>x</code>&rsquo; and &lsquo;<code>y</code>&rsquo;.</p>
</td></tr>
</table>

<hr>
<h2 id='groups'>Groups of a vertex partitioning</h2><span id='topic+groups'></span><span id='topic+groups.default'></span><span id='topic+groups.communities'></span>

<h3>Description</h3>

<p>Create a list of vertex groups from some graph clustering or community
structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groups(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groups_+3A_x">x</code></td>
<td>
<p>Some object that represents a grouping of the vertices. See details
below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently two methods are defined for this function. The default method
works on the output of <code><a href="#topic+components">components()</a></code>. (In fact it works on any
object that is a list with an entry called <code>membership</code>.)
</p>
<p>The second method works on <code><a href="#topic+communities">communities()</a></code> objects.
</p>


<h3>Value</h3>

<p>A named list of numeric or character vectors. The names are just
numbers that refer to the groups. The vectors themselves are numeric or
symbolic vertex ids.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+components">components()</a></code> and the various community finding
functions.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Zachary")
fgc &lt;- cluster_fast_greedy(g)
groups(fgc)

g2 &lt;- make_ring(10) + make_full_graph(5)
groups(components(g2))
</code></pre>

<hr>
<h2 id='growing.random.game'>Growing random graph generation</h2><span id='topic+growing.random.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>growing.random.game()</code> was renamed to <code>sample_growing()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growing.random.game(n, m = 1, directed = TRUE, citation = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growing.random.game_+3A_n">n</code></td>
<td>
<p>Numeric constant, number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="growing.random.game_+3A_m">m</code></td>
<td>
<p>Numeric constant, number of edges added in each time step.</p>
</td></tr>
<tr><td><code id="growing.random.game_+3A_directed">directed</code></td>
<td>
<p>Logical, whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="growing.random.game_+3A_citation">citation</code></td>
<td>
<p>Logical. If <code>TRUE</code> a citation graph is created, i.e. in
each time step the added edges are originating from the new vertex.</p>
</td></tr>
</table>

<hr>
<h2 id='gsize'>The size of the graph (number of edges)</h2><span id='topic+gsize'></span><span id='topic+ecount'></span>

<h3>Description</h3>

<p><code>ecount()</code> and <code>gsize()</code> are aliases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsize(graph)

ecount(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsize_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric scalar, the number of edges.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_gnp(100, 2 / 100)
gsize(g)
ecount(g)

# Number of edges in a G(n,p) graph
replicate(100, sample_gnp(10, 1 / 2), simplify = FALSE) %&gt;%
  vapply(gsize, 0) %&gt;%
  hist()
</code></pre>

<hr>
<h2 id='handle_vertex_type_arg'>Common handler for vertex type arguments in igraph functions</h2><span id='topic+handle_vertex_type_arg'></span>

<h3>Description</h3>

<p>This function takes the <code>types</code> and <code>graph</code> arguments from a
public igraph function call and validates the vertex type vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handle_vertex_type_arg(types, graph, required = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handle_vertex_type_arg_+3A_types">types</code></td>
<td>
<p>the vertex types</p>
</td></tr>
<tr><td><code id="handle_vertex_type_arg_+3A_graph">graph</code></td>
<td>
<p>the graph</p>
</td></tr>
<tr><td><code id="handle_vertex_type_arg_+3A_required">required</code></td>
<td>
<p>whether the graph has to be bipartite</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the provided vertex types are NULL and the graph has a <code>types</code>
vertex attribute, then the value of this vertex attribute will be used as
vertex types. Non-logical vertex type vectors are coerced into logical
vectors after printing a warning.
</p>


<h3>Value</h3>

<p>A logical vector representing the resolved vertex type for each
vertex in the graph
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>

<hr>
<h2 id='harmonic_centrality'>Harmonic centrality of vertices</h2><span id='topic+harmonic_centrality'></span>

<h3>Description</h3>

<p>The harmonic centrality of a vertex is the mean inverse distance to all other
vertices. The inverse distance to an unreachable vertex is considered to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonic_centrality(
  graph,
  vids = V(graph),
  mode = c("out", "in", "all", "total"),
  weights = NULL,
  normalized = FALSE,
  cutoff = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonic_centrality_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="harmonic_centrality_+3A_vids">vids</code></td>
<td>
<p>The vertices for which harmonic centrality will be calculated.</p>
</td></tr>
<tr><td><code id="harmonic_centrality_+3A_mode">mode</code></td>
<td>
<p>Character string, defining the types of the paths used for
measuring the distance in directed graphs. &ldquo;out&rdquo; follows paths along
the edge directions only, &ldquo;in&rdquo; traverses the edges in reverse, while
&ldquo;all&rdquo; ignores edge directions. This argument is ignored for undirected
graphs.</p>
</td></tr>
<tr><td><code id="harmonic_centrality_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
harmonic centrality. If the graph has a <code>weight</code> edge attribute, then
this is used by default. Weights are used for calculating weighted shortest
paths, so they are interpreted as distances.</p>
</td></tr>
<tr><td><code id="harmonic_centrality_+3A_normalized">normalized</code></td>
<td>
<p>Logical scalar, whether to calculate the normalized
harmonic centrality. If true, the result is the mean inverse path length to
other vertices, i.e. it is normalized by the number of vertices minus one.
If false, the result is the sum of inverse path lengths to other vertices.</p>
</td></tr>
<tr><td><code id="harmonic_centrality_+3A_cutoff">cutoff</code></td>
<td>
<p>The maximum path length to consider when calculating the
harmonic centrality. There is no such limit when the cutoff is negative. Note that
zero cutoff means that only paths of at most length 0 are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>cutoff</code> argument can be used to restrict the calculation to paths
of length <code>cutoff</code> or smaller only; this can be used for larger graphs
to speed up the calculation. If <code>cutoff</code> is negative (which is the
default), then the function calculates the exact harmonic centrality scores.
</p>


<h3>Value</h3>

<p>Numeric vector with the harmonic centrality scores of all the vertices in
<code>v</code>.
</p>


<h3>References</h3>

<p>M. Marchiori and V. Latora, Harmony in the small-world,
<em>Physica A</em> 285, pp. 539-546 (2000).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betweenness">betweenness()</a></code>, <code><a href="#topic+closeness">closeness()</a></code>
</p>
<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
g2 &lt;- make_star(10)
harmonic_centrality(g)
harmonic_centrality(g2, mode = "in")
harmonic_centrality(g2, mode = "out")
harmonic_centrality(g %du% make_full_graph(5), mode = "all")

</code></pre>

<hr>
<h2 id='has_eulerian_path'>Find Eulerian paths or cycles in a graph</h2><span id='topic+has_eulerian_path'></span><span id='topic+has_eulerian_cycle'></span><span id='topic+eulerian_path'></span><span id='topic+eulerian_cycle'></span>

<h3>Description</h3>

<p><code>has_eulerian_path()</code> and <code>has_eulerian_cycle()</code> checks whether there
is an Eulerian path or cycle in the input graph. <code>eulerian_path()</code> and
<code>eulerian_cycle()</code> return such a path or cycle if it exists, and throws
an error otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_eulerian_path(graph)

has_eulerian_cycle(graph)

eulerian_path(graph)

eulerian_cycle(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_eulerian_path_+3A_graph">graph</code></td>
<td>
<p>An igraph graph object</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>has_eulerian_path()</code> decides whether the input graph has an Eulerian
<em>path</em>, i.e. a path that passes through every edge of the graph exactly
once, and returns a logical value as a result. <code>eulerian_path()</code> returns
a possible Eulerian path, described with its edge and vertex sequence, or
throws an error if no such path exists.
</p>
<p><code>has_eulerian_cycle()</code> decides whether the input graph has an Eulerian
<em>cycle</em>, i.e. a path that passes through every edge of the graph exactly
once and that returns to its starting point, and returns a logical value as
a result. <code>eulerian_cycle()</code> returns a possible Eulerian cycle, described
with its edge and vertex sequence, or throws an error if no such cycle exists.
</p>


<h3>Value</h3>

<p>For <code>has_eulerian_path()</code> and <code>has_eulerian_cycle()</code>, a logical
value that indicates whether the graph contains an Eulerian path or cycle.
For <code>eulerian_path()</code> and <code>eulerian_cycle()</code>, a named list with two
entries: </p>
<table>
<tr><td><code>epath</code></td>
<td>
<p>A vector containing the edge ids along the Eulerian
path or cycle.</p>
</td></tr> <tr><td><code>vpath</code></td>
<td>
<p>A vector containing the vertex ids along the
Eulerian path or cycle.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Graph cycles
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph(~ A - B - C - D - E - A - F - D - B - F - E)

has_eulerian_path(g)
eulerian_path(g)

has_eulerian_cycle(g)
try(eulerian_cycle(g))

</code></pre>

<hr>
<h2 id='has.multiple'>Find the multiple or loop edges in a graph</h2><span id='topic+has.multiple'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>has.multiple()</code> was renamed to <code>any_multiple()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has.multiple(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has.multiple_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>

<hr>
<h2 id='head_of'>Head of the edge(s) in a graph</h2><span id='topic+head_of'></span>

<h3>Description</h3>

<p>For undirected graphs, head and tail is not defined.  In this case
<code>head_of()</code> returns vertices incident to the supplied edges, and
<code>tail_of()</code> returns the other end(s) of the edge(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_of(graph, es)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_of_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="head_of_+3A_es">es</code></td>
<td>
<p>The edges to query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vertex sequence with the head(s) of the edge(s).
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>

<hr>
<h2 id='head_print'>Print the only the head of an R object</h2><span id='topic+head_print'></span>

<h3>Description</h3>

<p>Print the only the head of an R object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head_print(
  x,
  max_lines = 20,
  header = "",
  footer = "",
  omitted_footer = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_print_+3A_x">x</code></td>
<td>
<p>The object to print, or a callback function. See
<code><a href="#topic+printer_callback">printer_callback()</a></code> for details.</p>
</td></tr>
<tr><td><code id="head_print_+3A_max_lines">max_lines</code></td>
<td>
<p>Maximum number of lines to print, <em>not</em>
including the header and the footer.</p>
</td></tr>
<tr><td><code id="head_print_+3A_header">header</code></td>
<td>
<p>The header, if a function, then it will be called,
otherwise printed using <code>cat</code>.</p>
</td></tr>
<tr><td><code id="head_print_+3A_footer">footer</code></td>
<td>
<p>The footer, if a function, then it will be called,
otherwise printed using <code>cat</code>.</p>
</td></tr>
<tr><td><code id="head_print_+3A_omitted_footer">omitted_footer</code></td>
<td>
<p>Footer that is only printed if anything
is omitted from the printout. If a function, then it will be called,
otherwise printed using <code>cat</code>.</p>
</td></tr>
<tr><td><code id="head_print_+3A_...">...</code></td>
<td>
<p>Extra arguments to pass to <code>print()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code>, invisibly.
</p>

<hr>
<h2 id='hrg'>Create a hierarchical random graph from an igraph graph</h2><span id='topic+hrg'></span>

<h3>Description</h3>

<p><code>hrg()</code> creates a HRG from an igraph graph. The igraph graph must be
a directed binary tree, with <code class="reqn">n-1</code> internal and <code class="reqn">n</code> leaf
vertices. The <code>prob</code> argument contains the HRG probability labels
for each vertex; these are ignored for leaf vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrg(graph, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrg_+3A_graph">graph</code></td>
<td>
<p>The igraph graph to create the HRG from.</p>
</td></tr>
<tr><td><code id="hrg_+3A_prob">prob</code></td>
<td>
<p>A vector of probabilities, one for each vertex, in the order of
vertex ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hrg()</code> returns an <code>igraphHRG</code> object.
</p>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+consensus_tree">consensus_tree</a>()</code>,
<code><a href="#topic+fit_hrg">fit_hrg</a>()</code>,
<code><a href="#topic+hrg-methods">hrg-methods</a></code>,
<code><a href="#topic+hrg_tree">hrg_tree</a>()</code>,
<code><a href="#topic+predict_edges">predict_edges</a>()</code>,
<code><a href="#topic+print.igraphHRG">print.igraphHRG</a>()</code>,
<code><a href="#topic+print.igraphHRGConsensus">print.igraphHRGConsensus</a>()</code>,
<code><a href="#topic+sample_hrg">sample_hrg</a>()</code>
</p>

<hr>
<h2 id='hrg_tree'>Create an igraph graph from a hierarchical random graph model</h2><span id='topic+hrg_tree'></span>

<h3>Description</h3>

<p><code>hrg_tree()</code> creates the corresponsing igraph tree of a hierarchical
random graph model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrg_tree(hrg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrg_tree_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph with a vertex attribute called <code>"probability"</code>.
</p>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+consensus_tree">consensus_tree</a>()</code>,
<code><a href="#topic+fit_hrg">fit_hrg</a>()</code>,
<code><a href="#topic+hrg">hrg</a>()</code>,
<code><a href="#topic+hrg-methods">hrg-methods</a></code>,
<code><a href="#topic+predict_edges">predict_edges</a>()</code>,
<code><a href="#topic+print.igraphHRG">print.igraphHRG</a>()</code>,
<code><a href="#topic+print.igraphHRGConsensus">print.igraphHRGConsensus</a>()</code>,
<code><a href="#topic+sample_hrg">sample_hrg</a>()</code>
</p>

<hr>
<h2 id='hrg-methods'>Hierarchical random graphs</h2><span id='topic+hrg-methods'></span>

<h3>Description</h3>

<p>Fitting and sampling hierarchical random graph models.
</p>


<h3>Details</h3>

<p>A hierarchical random graph is an ensemble of undirected graphs with <code class="reqn">n</code>
vertices. It is defined via a binary tree with <code class="reqn">n</code> leaf and <code class="reqn">n-1</code>
internal vertices, where the internal vertices are labeled with
probabilities.  The probability that two vertices are connected in the
random graph is given by the probability label at their closest common
ancestor.
</p>
<p>Please see references below for more about hierarchical random graphs.
</p>
<p>igraph contains functions for fitting HRG models to a given network
(<code>fit_hrg()</code>, for generating networks from a given HRG ensemble
(<code>sample_hrg()</code>), converting an igraph graph to a HRG and back
(<code>hrg()</code>, <code>hrg_tree()</code>), for calculating a consensus tree from a set
of sampled HRGs (<code>consensus_tree()</code>) and for predicting missing edges in
a network based on its HRG models (<code>predict_edges()</code>).
</p>
<p>The igraph HRG implementation is heavily based on the code published by
Aaron Clauset, at his website (not functional any more).
</p>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+consensus_tree">consensus_tree</a>()</code>,
<code><a href="#topic+fit_hrg">fit_hrg</a>()</code>,
<code><a href="#topic+hrg">hrg</a>()</code>,
<code><a href="#topic+hrg_tree">hrg_tree</a>()</code>,
<code><a href="#topic+predict_edges">predict_edges</a>()</code>,
<code><a href="#topic+print.igraphHRG">print.igraphHRG</a>()</code>,
<code><a href="#topic+print.igraphHRGConsensus">print.igraphHRGConsensus</a>()</code>,
<code><a href="#topic+sample_hrg">sample_hrg</a>()</code>
</p>

<hr>
<h2 id='hrg.consensus'>Create a consensus tree from several hierarchical random graph models</h2><span id='topic+hrg.consensus'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>hrg.consensus()</code> was renamed to <code>consensus_tree()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrg.consensus(graph, hrg = NULL, start = FALSE, num.samples = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrg.consensus_+3A_graph">graph</code></td>
<td>
<p>The graph the models were fitted to.</p>
</td></tr>
<tr><td><code id="hrg.consensus_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model, in the form of an
<code>igraphHRG</code> object. <code>consensus_tree()</code> allows this to be
<code>NULL</code> as well, then a HRG is fitted to the graph first, from a
random starting point.</p>
</td></tr>
<tr><td><code id="hrg.consensus_+3A_start">start</code></td>
<td>
<p>Logical, whether to start the fitting/sampling from the
supplied <code>igraphHRG</code> object, or from a random starting point.</p>
</td></tr>
<tr><td><code id="hrg.consensus_+3A_num.samples">num.samples</code></td>
<td>
<p>Number of samples to use for consensus generation or
missing edge prediction.</p>
</td></tr>
</table>

<hr>
<h2 id='hrg.create'>Create a hierarchical random graph from an igraph graph</h2><span id='topic+hrg.create'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>hrg.create()</code> was renamed to <code>hrg()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrg.create(graph, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrg.create_+3A_graph">graph</code></td>
<td>
<p>The igraph graph to create the HRG from.</p>
</td></tr>
<tr><td><code id="hrg.create_+3A_prob">prob</code></td>
<td>
<p>A vector of probabilities, one for each vertex, in the order of
vertex ids.</p>
</td></tr>
</table>

<hr>
<h2 id='hrg.dendrogram'>Create an igraph graph from a hierarchical random graph model</h2><span id='topic+hrg.dendrogram'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>hrg.dendrogram()</code> was renamed to <code>hrg_tree()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrg.dendrogram(hrg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrg.dendrogram_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model.</p>
</td></tr>
</table>

<hr>
<h2 id='hrg.fit'>Fit a hierarchical random graph model</h2><span id='topic+hrg.fit'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>hrg.fit()</code> was renamed to <code>fit_hrg()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrg.fit(graph, hrg = NULL, start = FALSE, steps = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrg.fit_+3A_graph">graph</code></td>
<td>
<p>The graph to fit the model to. Edge directions are ignored in
directed graphs.</p>
</td></tr>
<tr><td><code id="hrg.fit_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model, in the form of an
<code>igraphHRG</code> object. <code>fit_hrg()</code> allows this to be <code>NULL</code>, in
which case a random starting point is used for the fitting.</p>
</td></tr>
<tr><td><code id="hrg.fit_+3A_start">start</code></td>
<td>
<p>Logical, whether to start the fitting/sampling from the
supplied <code>igraphHRG</code> object, or from a random starting point.</p>
</td></tr>
<tr><td><code id="hrg.fit_+3A_steps">steps</code></td>
<td>
<p>The number of MCMC steps to make. If this is zero, then the
MCMC procedure is performed until convergence.</p>
</td></tr>
</table>

<hr>
<h2 id='hrg.game'>Sample from a hierarchical random graph model</h2><span id='topic+hrg.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>hrg.game()</code> was renamed to <code>sample_hrg()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrg.game(hrg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrg.game_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model.</p>
</td></tr>
</table>

<hr>
<h2 id='hrg.predict'>Predict edges based on a hierarchical random graph model</h2><span id='topic+hrg.predict'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>hrg.predict()</code> was renamed to <code>predict_edges()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrg.predict(
  graph,
  hrg = NULL,
  start = FALSE,
  num.samples = 10000,
  num.bins = 25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hrg.predict_+3A_graph">graph</code></td>
<td>
<p>The graph to fit the model to. Edge directions are ignored in
directed graphs.</p>
</td></tr>
<tr><td><code id="hrg.predict_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model, in the form of an
<code>igraphHRG</code> object. <code>predict_edges()</code> allow this to be
<code>NULL</code> as well, then a HRG is fitted to the graph first, from a
random starting point.</p>
</td></tr>
<tr><td><code id="hrg.predict_+3A_start">start</code></td>
<td>
<p>Logical, whether to start the fitting/sampling from the
supplied <code>igraphHRG</code> object, or from a random starting point.</p>
</td></tr>
<tr><td><code id="hrg.predict_+3A_num.samples">num.samples</code></td>
<td>
<p>Number of samples to use for consensus generation or
missing edge prediction.</p>
</td></tr>
<tr><td><code id="hrg.predict_+3A_num.bins">num.bins</code></td>
<td>
<p>Number of bins for the edge probabilities. Give a higher
number for a more accurate prediction.</p>
</td></tr>
</table>

<hr>
<h2 id='hub_score'>Kleinberg's hub and authority centrality scores.</h2><span id='topic+hub_score'></span><span id='topic+authority_score'></span>

<h3>Description</h3>

<p>The hub scores of the vertices are defined as the principal eigenvector
of <code class="reqn">A A^T</code>, where <code class="reqn">A</code> is the adjacency matrix of the
graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hub_score(graph, scale = TRUE, weights = NULL, options = arpack_defaults())

authority_score(
  graph,
  scale = TRUE,
  weights = NULL,
  options = arpack_defaults()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hub_score_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="hub_score_+3A_scale">scale</code></td>
<td>
<p>Logical scalar, whether to scale the result to have a maximum
score of one. If no scaling is used then the result vector has unit length
in the Euclidean norm.</p>
</td></tr>
<tr><td><code id="hub_score_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
scores. If the graph has a <code>weight</code> edge attribute, then this is used
by default.
This function interprets edge weights as connection strengths. In the
random surfer model, an edge with a larger weight is more likely to be
selected by the surfer.</p>
</td></tr>
<tr><td><code id="hub_score_+3A_options">options</code></td>
<td>
<p>A named list, to override some ARPACK options. See
<code><a href="#topic+arpack">arpack()</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similarly, the authority scores of the vertices are defined as the principal
eigenvector of <code class="reqn">A^T A</code>, where <code class="reqn">A</code> is the adjacency matrix of
the graph.
</p>
<p>For undirected matrices the adjacency matrix is symmetric and the hub
scores are the same as authority scores.
</p>


<h3>Value</h3>

<p>A named list with members:
</p>
<table>
<tr><td><code>vector</code></td>
<td>
<p>The hub or authority scores of the vertices.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The corresponding eigenvalue of the calculated
principal eigenvector.</p>
</td></tr>
<tr><td><code>options</code></td>
<td>
<p>Some information about the ARPACK computation, it has
the same members as the <code>options</code> member returned
by <code><a href="#topic+arpack">arpack()</a></code>, see that for documentation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. Kleinberg. Authoritative sources in a hyperlinked
environment. <em>Proc. 9th ACM-SIAM Symposium on Discrete Algorithms</em>,
1998. Extended version in <em>Journal of the ACM</em> 46(1999). Also appears
as IBM Research Report RJ 10076, May 1997.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigen_centrality">eigen_centrality()</a></code> for eigenvector centrality,
<code><a href="#topic+page_rank">page_rank()</a></code> for the Page Rank scores. <code><a href="#topic+arpack">arpack()</a></code> for
the underlining machinery of the computation.
</p>
<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## An in-star
g &lt;- make_star(10)
hub_score(g)$vector
authority_score(g)$vector

## A ring
g2 &lt;- make_ring(10)
hub_score(g2)$vector
authority_score(g2)$vector
</code></pre>

<hr>
<h2 id='hub.score'>Kleinberg's hub and authority centrality scores.</h2><span id='topic+hub.score'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>hub.score()</code> was renamed to <code>hub_score()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hub.score(graph, scale = TRUE, weights = NULL, options = arpack_defaults())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hub.score_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="hub.score_+3A_scale">scale</code></td>
<td>
<p>Logical scalar, whether to scale the result to have a maximum
score of one. If no scaling is used then the result vector has unit length
in the Euclidean norm.</p>
</td></tr>
<tr><td><code id="hub.score_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
scores. If the graph has a <code>weight</code> edge attribute, then this is used
by default.
This function interprets edge weights as connection strengths. In the
random surfer model, an edge with a larger weight is more likely to be
selected by the surfer.</p>
</td></tr>
<tr><td><code id="hub.score_+3A_options">options</code></td>
<td>
<p>A named list, to override some ARPACK options. See
<code><a href="#topic+arpack">arpack()</a></code> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='identical_graphs'>Decide if two graphs are identical</h2><span id='topic+identical_graphs'></span>

<h3>Description</h3>

<p>Two graphs are considered identical by this function if and only if
they are represented in exactly the same way in the internal R
representation. This means that the two graphs must have the same
list of vertices and edges, in exactly the same order, with same
directedness, and the two graphs must also have identical graph, vertex and
edge attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identical_graphs(g1, g2, attrs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identical_graphs_+3A_g1">g1</code>, <code id="identical_graphs_+3A_g2">g2</code></td>
<td>
<p>The two graphs</p>
</td></tr>
<tr><td><code id="identical_graphs_+3A_attrs">attrs</code></td>
<td>
<p>Whether to compare the attributes of the graphs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is similar to <code>identical</code> in the <code>base</code> package,
but it ignores the mutable piece of igraph objects; those might be
different even if the two graphs are identical.
</p>
<p>Attribute comparison can be turned off with the <code>attrs</code> parameter if
the attributes of the two graphs are allowed to be different.
</p>


<h3>Value</h3>

<p>Logical scalar
</p>

<hr>
<h2 id='igraph_demo'>Run igraph demos, step by step</h2><span id='topic+igraph_demo'></span>

<h3>Description</h3>

<p>Run one of the accompanying igraph demos, somewhat interactively, using a Tk
window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph_demo(which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph_demo_+3A_which">which</code></td>
<td>
<p>If not given, then the names of the available demos are listed.
Otherwise it should be either a filename or the name of an igraph demo.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a somewhat nicer interface to igraph demos that come
with the package, than the standard <code><a href="utils.html#topic+demo">demo()</a></code> function. igraph
demos are divided into chunks and <code>igraph_demo()</code> runs them chunk by
chunk, with the possibility of inspecting the workspace between two chunks.
</p>
<p>The <code>tcltk</code> package is needed for <code>igraph_demo()</code>.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+demo">demo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
igraph_demo()
if (interactive() &amp;&amp; requireNamespace("tcltk", quietly = TRUE)) {
  igraph_demo("centrality")
}

</code></pre>

<hr>
<h2 id='igraph_options'>Parameters for the igraph package</h2><span id='topic+igraph_options'></span><span id='topic+igraph_opt'></span>

<h3>Description</h3>

<p>igraph has some parameters which (usually) affect the behavior of many
functions. These can be set for the whole session via <code>igraph_options()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph_options(...)

igraph_opt(x, default = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph_options_+3A_...">...</code></td>
<td>
<p>A list may be given as the only argument, or any number of
arguments may be in the <code>name=value</code> form, or no argument at all may be
given. See the Value and Details sections for explanation.</p>
</td></tr>
<tr><td><code id="igraph_options_+3A_x">x</code></td>
<td>
<p>A character string holding an option name.</p>
</td></tr>
<tr><td><code id="igraph_options_+3A_default">default</code></td>
<td>
<p>If the specified option is not set in the options list, this
value is returned. This facilitates retrieving an option and checking
whether it is set and setting it separately if not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter values set via a call to the <code>igraph_options()</code> function
will remain in effect for the rest of the session, affecting the subsequent
behaviour of the other functions of the <code>igraph</code> package for which the
given parameters are relevant.
</p>
<p>This offers the possibility of customizing the functioning of the
<code>igraph</code> package, for instance by insertions of appropriate calls to
<code>igraph_options()</code> in a load hook for package <span class="pkg">igraph</span>.
</p>
<p>The currently used parameters in alphabetical order:
</p>

<dl>
<dt>add.params</dt><dd><p>Logical scalar, whether to add model
parameter to the graphs that are created by the various
graph constructors. By default it is <code>TRUE</code>.</p>
</dd>
<dt>add.vertex.names</dt><dd><p>Logical scalar, whether to add
vertex names to node level indices, like degree, betweenness
scores, etc. By default it is <code>TRUE</code>.</p>
</dd>
<dt>annotate.plot</dt><dd><p>Logical scalar, whether to annotate igraph
plots with the graph's name (<code>name</code> graph attribute, if
present) as <code>main</code>, and with the number of vertices and edges
as <code>xlab</code>. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>dend.plot.type</dt><dd><p>The plotting function to use when plotting
community structure dendrograms via
<code><a href="#topic+plot_dendrogram">plot_dendrogram()</a></code></p>
</dd></dl>
<p>. Possible values are &lsquo;auto&rsquo; (the
default), &lsquo;phylo&rsquo;, &lsquo;hclust&rsquo; and
&lsquo;dendrogram&rsquo;. See <code><a href="#topic+plot_dendrogram">plot_dendrogram()</a></code> for details.
</p>
<dl>
<dt>edge.attr.comb</dt><dd><p>Specifies what to do with the edge
attributes if the graph is modified. The default value is
<code>list(weight="sum", name="concat", "ignore")</code>. See
<code><a href="#topic+attribute.combination">attribute.combination()</a></code> for details on this.</p>
</dd>
<dt>print.edge.attributes</dt><dd><p>Logical constant, whether to print edge
attributes when printing graphs. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>print.full</dt><dd><p>Logical scalar, whether <code><a href="#topic+print.igraph">print.igraph()</a></code>
should show the graph structure as well, or only a summary of the
graph.</p>
</dd>
<dt>print.graph.attributes</dt><dd><p>Logical constant, whether to print
graph attributes when printing graphs. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>print.vertex.attributes</dt><dd><p>Logical constant, whether to print
vertex attributes when printing graphs. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>return.vs.es</dt><dd><p>Whether functions that return a set or sequence
of vertices/edges should return formal vertex/edge sequence
objects. This option was introduced in igraph version 1.0.0 and
defaults to TRUE. If your package requires the old behavior,
you can set it to FALSE in the <code>.onLoad</code> function of
your package, without affecting other packages.</p>
</dd>
<dt>sparsematrices</dt><dd><p>Whether to use the <code>Matrix</code> package for
(sparse) matrices. It is recommended, if the user works with
larger graphs.</p>
</dd>
<dt>verbose</dt><dd><p>Logical constant, whether igraph functions should
talk more than minimal. E.g. if <code>TRUE</code> then some functions
will use progress bars while computing. Defaults to <code>FALSE</code>.</p>
</dd>
<dt>vertex.attr.comb</dt><dd><p>Specifies what to do with the vertex
attributes if the graph is modified. The default value is
<code>list(name="concat", "ignore")</code> See
<code><a href="#topic+attribute.combination">attribute.combination()</a></code> for details on this.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>igraph_options()</code> returns a list with the old values of the
updated parameters, invisibly. Without any arguments, it returns the
values of all options.
</p>
<p>For <code>igraph_opt()</code>, the current value set for option <code>x</code>, or
<code>NULL</code> if the option is unset.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>igraph_options()</code> is similar to <code><a href="base.html#topic+options">options()</a></code> and
<code>igraph_opt()</code> is similar to <code><a href="base.html#topic+getOption">getOption()</a></code>.
</p>
<p>Other igraph options: 
<code><a href="#topic+with_igraph_opt">with_igraph_opt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
oldval &lt;- igraph_opt("verbose")
igraph_options(verbose = TRUE)
layout_with_kk(make_ring(10))
igraph_options(verbose = oldval)

oldval &lt;- igraph_options(verbose = TRUE, sparsematrices = FALSE)
make_ring(10)[]
igraph_options(oldval)
igraph_opt("verbose")

</code></pre>

<hr>
<h2 id='igraph_test'>Run package tests</h2><span id='topic+igraph_test'></span>

<h3>Description</h3>

<p>Runs all package tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph_test()
</code></pre>


<h3>Details</h3>

<p>The <code>testthat</code> package is needed to run all tests. The location tests
themselves can be extracted from the package via <code>system.file("tests", package="igraph")</code>.
</p>
<p>This function simply calls the <code>test_dir</code> function from the
<code>testthat</code> package on the test directory.
</p>


<h3>Value</h3>

<p>Whatever is returned by <code>test_dir</code> from the <code>testthat</code>
package.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other test: 
<code><a href="#topic+igraph_version">igraph_version</a>()</code>
</p>

<hr>
<h2 id='igraph_version'>Query igraph's version string</h2><span id='topic+igraph_version'></span>

<h3>Description</h3>

<p>Returns the package version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph_version()
</code></pre>


<h3>Details</h3>

<p>The igraph version string is always the same as the version of the R package.
</p>


<h3>Value</h3>

<p>A character scalar, the igraph version string.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other test: 
<code><a href="#topic+igraph_test">igraph_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compare to the package version
packageDescription("igraph")$Version
igraph_version()

</code></pre>

<hr>
<h2 id='igraph-attribute-combination'>How igraph functions handle attributes when the graph changes</h2><span id='topic+igraph-attribute-combination'></span><span id='topic+attribute.combination'></span>

<h3>Description</h3>

<p>Many times, when the structure of a graph is modified, vertices/edges map of
the original graph map to vertices/edges in the newly created (modified)
graph. For example <code><a href="#topic+simplify">simplify()</a></code> maps multiple edges to single
edges. igraph provides a flexible mechanism to specify what to do with the
vertex/edge attributes in these cases.
</p>


<h3>Details</h3>

<p>The functions that support the combination of attributes have one or two
extra arguments called <code>vertex.attr.comb</code> and/or <code>edge.attr.comb</code>
that specify how to perform the mapping of the attributes. E.g.
<code><a href="#topic+contract">contract()</a></code> contracts many vertices into a single one, the
attributes of the vertices can be combined and stores as the vertex
attributes of the new graph.
</p>
<p>The specification of the combination of (vertex or edge) attributes can be
given as </p>

<ol>
<li><p> a character scalar,
</p>
</li>
<li><p> a function object or
</p>
</li>
<li><p> a list of character scalars and/or function objects.
</p>
</li></ol>

<p>If it is a character scalar, then it refers to one of the predefined
combinations, see their list below.
</p>
<p>If it is a function, then the given function is expected to perform the
combination. It will be called once for each new vertex/edge in the graph,
with a single argument: the attribute values of the vertices that map to
that single vertex.
</p>
<p>The third option, a list can be used to specify different combination
methods for different attributes. A named entry of the list corresponds to
the attribute with the same name. An unnamed entry (i.e. if the name is the
empty string) of the list specifies the default combination method. I.e.
</p>
<pre>list(weight="sum", "ignore")</pre><p> specifies that the weight of the
new edge should be sum of the weights of the corresponding edges in the old
graph; and that the rest of the attributes should be ignored (=dropped).
</p>


<h3>Predefined combination functions</h3>

<p>The following combination
behaviors are predefined: </p>
 <dl>
<dt>&quot;ignore&quot;</dt><dd><p>The attribute is
ignored and dropped.</p>
</dd> <dt>&quot;sum&quot;</dt><dd><p>The sum of the attributes is
calculated. This does not work for character attributes and works for
complex attributes only if they have a <code>sum</code> generic defined. (E.g. it
works for sparse matrices from the <code>Matrix</code> package, because they have
a <code>sum</code> method.)</p>
</dd> <dt>&quot;prod&quot;</dt><dd><p>The product of the attributes is
calculated. This does not work for character attributes and works for
complex attributes only if they have a <code>prod</code> function defined.</p>
</dd>
<dt>&quot;min&quot;</dt><dd><p>The minimum of the attributes is calculated and returned.
For character and complex attributes the standard R <code>min</code> function is
used.</p>
</dd> <dt>&quot;max&quot;</dt><dd><p>The maximum of the attributes is calculated and
returned. For character and complex attributes the standard R <code>max</code>
function is used.</p>
</dd> <dt>&quot;random&quot;</dt><dd><p>Chooses one of the supplied
attribute values, uniformly randomly. For character and complex attributes
this is implemented by calling <code>sample</code>.</p>
</dd> <dt>&quot;first&quot;</dt><dd><p>Always
chooses the first attribute value. It is implemented by calling the
<code>head</code> function.</p>
</dd> <dt>&quot;last&quot;</dt><dd><p>Always chooses the last attribute
value. It is implemented by calling the <code>tail</code> function.</p>
</dd>
<dt>&quot;mean&quot;</dt><dd><p>The mean of the attributes is calculated and returned.
For character and complex attributes this simply calls the <code>mean</code>
function.</p>
</dd> <dt>&quot;median&quot;</dt><dd><p>The median of the attributes is selected.
Calls the R <code>median</code> function for all attribute types.</p>
</dd>
<dt>&quot;concat&quot;</dt><dd><p>Concatenate the attributes, using the <code>c</code>
function. This results almost always a complex attribute.</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph_attr">graph_attr()</a></code>, <code><a href="#topic+vertex_attr">vertex_attr()</a></code>,
<code><a href="#topic+edge_attr">edge_attr()</a></code> on how to use graph/vertex/edge attributes in
general. <code><a href="#topic+igraph_options">igraph_options()</a></code> on igraph parameters.
</p>
<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph(c(1, 2, 1, 2, 1, 2, 2, 3, 3, 4))
E(g)$weight &lt;- 1:5

## print attribute values with the graph
igraph_options(print.graph.attributes = TRUE)
igraph_options(print.vertex.attributes = TRUE)
igraph_options(print.edge.attributes = TRUE)

## new attribute is the sum of the old ones
simplify(g, edge.attr.comb = "sum")

## collect attributes into a string
simplify(g, edge.attr.comb = toString)

## concatenate them into a vector, this creates a complex
## attribute
simplify(g, edge.attr.comb = "concat")

E(g)$name &lt;- letters[seq_len(ecount(g))]

## both attributes are collected into strings
simplify(g, edge.attr.comb = toString)

## harmonic average of weights, names are dropped
simplify(g, edge.attr.comb = list(
  weight = function(x) length(x) / sum(1 / x),
  name = "ignore"
))
</code></pre>

<hr>
<h2 id='igraph-dollar'>Getting and setting graph attributes, shortcut</h2><span id='topic+igraph-dollar'></span><span id='topic++24.igraph'></span><span id='topic++24+3C-.igraph'></span>

<h3>Description</h3>

<p>The <code>$</code> operator is a shortcut to get and and set
graph attributes. It is shorter and just as readable as
<code><a href="#topic+graph_attr">graph_attr()</a></code> and <code><a href="#topic+set_graph_attr">set_graph_attr()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
x$name

## S3 replacement method for class 'igraph'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-dollar_+3A_x">x</code></td>
<td>
<p>An igraph graph</p>
</td></tr>
<tr><td><code id="igraph-dollar_+3A_name">name</code></td>
<td>
<p>Name of the attribute to get/set.</p>
</td></tr>
<tr><td><code id="igraph-dollar_+3A_value">value</code></td>
<td>
<p>New value of the graph attribute.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
g$name
g$name &lt;- "10-ring"
g$name
</code></pre>

<hr>
<h2 id='igraph-es-attributes'>Query or set attributes of the edges in an edge sequence</h2><span id='topic+igraph-es-attributes'></span><span id='topic++5B+5B+3C-.igraph.es'></span><span id='topic++5B+3C-.igraph.es'></span><span id='topic++24.igraph.es'></span><span id='topic++24+3C-.igraph.es'></span><span id='topic+E+3C-'></span>

<h3>Description</h3>

<p>The <code>$</code> operator is a syntactic sugar to query and set
edge attributes, for edges in an edge sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'igraph.es'
x[[i]] &lt;- value

## S3 replacement method for class 'igraph.es'
x[i] &lt;- value

## S3 method for class 'igraph.es'
x$name

## S3 replacement method for class 'igraph.es'
x$name &lt;- value

E(x, path = NULL, P = NULL, directed = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-es-attributes_+3A_x">x</code></td>
<td>
<p>An edge sequence. For <code style="white-space: pre;">&#8288;E&lt;-&#8288;</code> it is a graph.</p>
</td></tr>
<tr><td><code id="igraph-es-attributes_+3A_i">i</code></td>
<td>
<p>Index.</p>
</td></tr>
<tr><td><code id="igraph-es-attributes_+3A_value">value</code></td>
<td>
<p>New value of the attribute, for the edges in the edge
sequence.</p>
</td></tr>
<tr><td><code id="igraph-es-attributes_+3A_name">name</code></td>
<td>
<p>Name of the edge attribute to query or set.</p>
</td></tr>
<tr><td><code id="igraph-es-attributes_+3A_path">path</code></td>
<td>
<p>Select edges along a path, given by a vertex sequence See
<code><a href="#topic+E">E()</a></code>.</p>
</td></tr>
<tr><td><code id="igraph-es-attributes_+3A_p">P</code></td>
<td>
<p>Select edges via pairs of vertices. See <code><a href="#topic+E">E()</a></code>.</p>
</td></tr>
<tr><td><code id="igraph-es-attributes_+3A_directed">directed</code></td>
<td>
<p>Whether to use edge directions for the <code>path</code> or
<code>P</code> arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The query form of <code>$</code> is a shortcut for <code><a href="#topic+edge_attr">edge_attr()</a></code>,
e.g. <code>E(g)[idx]$attr</code> is equivalent to <code>edge_attr(g, attr, E(g)[idx])</code>.
</p>
<p>The assignment form of <code>$</code> is a shortcut for
<code><a href="#topic+set_edge_attr">set_edge_attr()</a></code>, e.g. <code>E(g)[idx]$attr &lt;- value</code> is
equivalent to <code>g &lt;- set_edge_attr(g, attr, E(g)[idx], value)</code>.
</p>


<h3>Value</h3>

<p>A vector or list, containing the values of the attribute
<code>name</code> for the edges in the sequence. For numeric, character or
logical attributes, it is a vector of the appropriate type, otherwise
it is a list.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># color edges of the largest component
largest_comp &lt;- function(graph) {
  cl &lt;- components(graph)
  V(graph)[which.max(cl$csize) == cl$membership]
}
g &lt;- sample_(
  gnp(100, 1 / 100),
  with_vertex_(size = 3, label = ""),
  with_graph_(layout = layout_with_fr)
)
giant_v &lt;- largest_comp(g)
E(g)$color &lt;- "orange"
E(g)[giant_v %--% giant_v]$color &lt;- "blue"
plot(g)
</code></pre>

<hr>
<h2 id='igraph-es-indexing'>Indexing edge sequences</h2><span id='topic+igraph-es-indexing'></span><span id='topic++5B.igraph.es'></span><span id='topic++25--+25'></span><span id='topic++25+3C-+25'></span><span id='topic++25-+3E+25'></span>

<h3>Description</h3>

<p>Edge sequences can be indexed very much like a plain numeric R vector,
with some extras.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
x[...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-es-indexing_+3A_x">x</code></td>
<td>
<p>An edge sequence</p>
</td></tr>
<tr><td><code id="igraph-es-indexing_+3A_...">...</code></td>
<td>
<p>Indices, see details below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another edge sequence, referring to the same graph.
</p>


<h3>Multiple indices</h3>

<p>When using multiple indices within the bracket, all of them
are evaluated independently, and then the results are concatenated
using the <code>c()</code> function. E.g. <code>E(g)[1, 2, .inc(1)]</code>
is equivalent to <code>c(E(g)[1], E(g)[2], E(g)[.inc(1)])</code>.
</p>


<h3>Index types</h3>

<p>Edge sequences can be indexed with positive numeric vectors,
negative numeric vectors, logical vectors, character vectors:
</p>

<ul>
<li><p> When indexed with positive numeric vectors, the edges at the
given positions in the sequence are selected. This is the same as
indexing a regular R atomic vector with positive numeric vectors.
</p>
</li>
<li><p> When indexed with negative numeric vectors, the edges at the
given positions in the sequence are omitted. Again, this is the same
as indexing a regular R atomic vector.
</p>
</li>
<li><p> When indexed with a logical vector, the lengths of the edge
sequence and the index must match, and the edges for which the
index is <code>TRUE</code> are selected.
</p>
</li>
<li><p> Named graphs can be indexed with character vectors,
to select edges with the given names. Note that a graph may
have edge names and vertex names, and both can be used to select
edges. Edge names are simply used as names of the numeric
edge id vector. Vertex names effectively only work in graphs without
multiple edges, and must be separated with a <code>|</code> bar character
to select an edges that incident to the two given vertices. See
examples below.
</p>
</li></ul>



<h3>Edge attributes</h3>

<p>When indexing edge sequences, edge attributes can be referred
to simply by using their names. E.g. if a graph has a <code>weight</code> edge
attribute, then <code>E(G)[weight &gt; 1]</code> selects all edges with a weight
larger than one. See more examples below. Note that attribute names mask the
names of variables present in the calling environment; if you need to look up
a variable and you do not want a similarly named edge attribute to mask it,
use the <code>.env</code> pronoun to perform the name lookup in the calling
environment. In other words, use <code>E(g)[.env$weight &gt; 1]</code> to make sure
that <code>weight</code> is looked up from the calling environment even if there is
an edge attribute with the same name. Similarly, you can use <code>.data</code> to
match attribute names only.
</p>


<h3>Special functions</h3>

<p>There are some special igraph functions that can be used
only in expressions indexing edge sequences: </p>

<dl>
<dt><code>.inc</code></dt><dd><p>takes a vertex sequence, and selects
all edges that have at least one incident vertex in the vertex
sequence.</p>
</dd>
<dt><code>.from</code></dt><dd><p>similar to <code>.inc()</code>, but only
the tails of the edges are considered.</p>
</dd>
<dt><code>.to</code></dt><dd><p>is similar to <code>.inc()</code>, but only
the heads of the edges are considered.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;\%--\%&#8288;</code></dt><dd><p>a special operator that can be
used to select all edges between two sets of vertices. It ignores
the edge directions in directed graphs.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;\%-&gt;\%&#8288;</code></dt><dd><p>similar to <code style="white-space: pre;">&#8288;\%--\%&#8288;</code>,
but edges <em>from</em> the left hand side argument, pointing
<em>to</em> the right hand side argument, are selected, in directed
graphs.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;\%&lt;-\%&#8288;</code></dt><dd><p>similar to <code style="white-space: pre;">&#8288;\%--\%&#8288;</code>,
but edges <em>to</em> the left hand side argument, pointing
<em>from</em> the right hand side argument, are selected, in directed
graphs.</p>
</dd>
</dl>

<p>Note that multiple special functions can be used together, or with
regular indices, and then their results are concatenated. See more
examples below.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>
<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -----------------------------------------------------------------
# Special operators for indexing based on graph structure
g &lt;- sample_pa(100, power = 0.3)
E(g)[1:3 %--% 2:6]
E(g)[1:5 %-&gt;% 1:6]
E(g)[1:3 %&lt;-% 2:6]

# -----------------------------------------------------------------
# The edges along the diameter
g &lt;- sample_pa(100, directed = FALSE)
d &lt;- get_diameter(g)
E(g, path = d)

# -----------------------------------------------------------------
# Select edges based on attributes
g &lt;- sample_gnp(20, 3 / 20) %&gt;%
  set_edge_attr("weight", value = rnorm(gsize(.)))
E(g)[[weight &lt; 0]]

# Indexing with a variable whose name matches the name of an attribute
# may fail; use .env to force the name lookup in the parent environment
E(g)$x &lt;- E(g)$weight
x &lt;- 2
E(g)[.env$x]

</code></pre>

<hr>
<h2 id='igraph-es-indexing2'>Select edges and show their metadata</h2><span id='topic+igraph-es-indexing2'></span><span id='topic++5B+5B.igraph.es'></span>

<h3>Description</h3>

<p>The double bracket operator can be used on edge sequences, to print
the meta-data (edge attributes) of the edges in the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
x[[...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-es-indexing2_+3A_x">x</code></td>
<td>
<p>An edge sequence.</p>
</td></tr>
<tr><td><code id="igraph-es-indexing2_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code>[</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technically, when used with edge sequences, the double bracket
operator does exactly the same as the single bracket operator,
but the resulting edge sequence is printed differently: all
attributes of the edges in the sequence are printed as well.
</p>
<p>See <code><a href="#topic++5B.igraph.es">[.igraph.es</a></code> for more about indexing edge sequences.
</p>


<h3>Value</h3>

<p>Another edge sequence, with metadata printing turned on.
See details below.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>
<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(
  ring(10),
  with_vertex_(name = LETTERS[1:10]),
  with_edge_(weight = 1:10, color = "green")
)
E(g)
E(g)[[]]
E(g)[[.inc("A")]]
</code></pre>

<hr>
<h2 id='igraph-minus'>Delete vertices or edges from a graph</h2><span id='topic+igraph-minus'></span><span id='topic+-.igraph'></span>

<h3>Description</h3>

<p>Delete vertices or edges from a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
e1 - e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-minus_+3A_e1">e1</code></td>
<td>
<p>Left argument, see details below.</p>
</td></tr>
<tr><td><code id="igraph-minus_+3A_e2">e2</code></td>
<td>
<p>Right argument, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minus operator (&lsquo;<code>-</code>&rsquo;) can be used to remove vertices
or edges from the graph. The operation performed is selected based on
the type of the right hand side argument:
</p>

<ul>
<li><p> If it is an igraph graph object, then the difference of the
two graphs is calculated, see <code><a href="#topic+difference">difference()</a></code>.
</p>
</li>
<li><p> If it is a numeric or character vector, then it is interpreted
as a vector of vertex ids and the specified vertices will be
deleted from the graph. Example: </p>
<pre>  g &lt;- make_ring(10)
V(g)$name &lt;- letters[1:10]
g &lt;- g - c("a", "b")</pre>
</li>
<li><p> If <code>e2</code> is a vertex sequence (e.g. created by the
<code><a href="#topic+V">V()</a></code> function), then these vertices will be deleted from
the graph.
</p>
</li>
<li><p> If it is an edge sequence (e.g. created by the <code><a href="#topic+E">E()</a></code>
function), then these edges will be deleted from the graph.
</p>
</li>
<li><p> If it is an object created with the <code><a href="#topic+vertex">vertex()</a></code> (or the
<code><a href="#topic+vertices">vertices()</a></code>) function, then all arguments of <code><a href="#topic+vertices">vertices()</a></code> are
concatenated and the result is interpreted as a vector of vertex
ids. These vertices will be removed from the graph.
</p>
</li>
<li><p> If it is an object created with the <code><a href="#topic+edge">edge()</a></code> (or the
<code><a href="#topic+edges">edges()</a></code>) function, then all arguments of <code><a href="#topic+edges">edges()</a></code> are
concatenated and then interpreted as edges to be removed from the
graph.
Example: </p>
<pre>  g &lt;- make_ring(10)
V(g)$name &lt;- letters[1:10]
E(g)$name &lt;- LETTERS[1:10]
g &lt;- g - edge("e|f")
g &lt;- g - edge("H")</pre>
</li>
<li><p> If it is an object created with the <code><a href="#topic+path">path()</a></code> function,
then all <code><a href="#topic+path">path()</a></code> arguments are concatenated and then interpreted
as a path along which edges will be removed from the graph.
Example: </p>
<pre>  g &lt;- make_ring(10)
V(g)$name &lt;- letters[1:10]
g &lt;- g - path("a", "b", "c", "d")</pre>
</li></ul>



<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>

<hr>
<h2 id='igraph-vs-attributes'>Query or set attributes of the vertices in a vertex sequence</h2><span id='topic+igraph-vs-attributes'></span><span id='topic++5B+5B+3C-.igraph.vs'></span><span id='topic++5B+3C-.igraph.vs'></span><span id='topic++24.igraph.vs'></span><span id='topic++24+3C-.igraph.vs'></span><span id='topic+V+3C-'></span>

<h3>Description</h3>

<p>The <code>$</code> operator is a syntactic sugar to query and set the
attributes of the vertices in a vertex sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'igraph.vs'
x[[i]] &lt;- value

## S3 replacement method for class 'igraph.vs'
x[i] &lt;- value

## S3 method for class 'igraph.vs'
x$name

## S3 replacement method for class 'igraph.vs'
x$name &lt;- value

V(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-vs-attributes_+3A_x">x</code></td>
<td>
<p>A vertex sequence. For <code style="white-space: pre;">&#8288;V&lt;-&#8288;</code> it is a graph.</p>
</td></tr>
<tr><td><code id="igraph-vs-attributes_+3A_i">i</code></td>
<td>
<p>Index.</p>
</td></tr>
<tr><td><code id="igraph-vs-attributes_+3A_value">value</code></td>
<td>
<p>New value of the attribute, for the vertices in the
vertex sequence.</p>
</td></tr>
<tr><td><code id="igraph-vs-attributes_+3A_name">name</code></td>
<td>
<p>Name of the vertex attribute to query or set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The query form of <code>$</code> is a shortcut for
<code><a href="#topic+vertex_attr">vertex_attr()</a></code>, e.g. <code>V(g)[idx]$attr</code> is equivalent
to <code>vertex_attr(g, attr, V(g)[idx])</code>.
</p>
<p>The assignment form of <code>$</code> is a shortcut for
<code><a href="#topic+set_vertex_attr">set_vertex_attr()</a></code>, e.g. <code>V(g)[idx]$attr &lt;- value</code> is
equivalent to <code>g &lt;- set_vertex_attr(g, attr, V(g)[idx], value)</code>.
</p>


<h3>Value</h3>

<p>A vector or list, containing the values of
attribute <code>name</code> for the vertices in the vertex sequence.
For numeric, character or logical attributes, it is a vector of the
appropriate type, otherwise it is a list.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>
<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(
  ring(10),
  with_vertex_(
    name = LETTERS[1:10],
    color = sample(1:2, 10, replace = TRUE)
  )
)
V(g)$name
V(g)$color
V(g)$frame.color &lt;- V(g)$color

# color vertices of the largest component
largest_comp &lt;- function(graph) {
  cl &lt;- components(graph)
  V(graph)[which.max(cl$csize) == cl$membership]
}
g &lt;- sample_(
  gnp(100, 2 / 100),
  with_vertex_(size = 3, label = ""),
  with_graph_(layout = layout_with_fr)
)
giant_v &lt;- largest_comp(g)
V(g)$color &lt;- "blue"
V(g)[giant_v]$color &lt;- "orange"
plot(g)
</code></pre>

<hr>
<h2 id='igraph-vs-indexing'>Indexing vertex sequences</h2><span id='topic+igraph-vs-indexing'></span><span id='topic++5B.igraph.vs'></span>

<h3>Description</h3>

<p>Vertex sequences can be indexed very much like a plain numeric R vector,
with some extras.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
x[..., na_ok = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-vs-indexing_+3A_x">x</code></td>
<td>
<p>A vertex sequence.</p>
</td></tr>
<tr><td><code id="igraph-vs-indexing_+3A_...">...</code></td>
<td>
<p>Indices, see details below.</p>
</td></tr>
<tr><td><code id="igraph-vs-indexing_+3A_na_ok">na_ok</code></td>
<td>
<p>Whether it is OK to have <code>NA</code>s in the vertex
sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertex sequences can be indexed using both the single bracket and
the double bracket operators, and they both work the same way.
The only difference between them is that the double bracket operator
marks the result for printing vertex attributes.
</p>


<h3>Value</h3>

<p>Another vertex sequence, referring to the same graph.
</p>


<h3>Multiple indices</h3>

<p>When using multiple indices within the bracket, all of them
are evaluated independently, and then the results are concatenated
using the <code>c()</code> function (except for the <code>na_ok</code> argument,
which is special an must be named. E.g. <code>V(g)[1, 2, .nei(1)]</code>
is equivalent to <code>c(V(g)[1], V(g)[2], V(g)[.nei(1)])</code>.
</p>


<h3>Index types</h3>

<p>Vertex sequences can be indexed with positive numeric vectors,
negative numeric vectors, logical vectors, character vectors:
</p>

<ul>
<li><p> When indexed with positive numeric vectors, the vertices at the
given positions in the sequence are selected. This is the same as
indexing a regular R atomic vector with positive numeric vectors.
</p>
</li>
<li><p> When indexed with negative numeric vectors, the vertices at the
given positions in the sequence are omitted. Again, this is the same
as indexing a regular R atomic vector.
</p>
</li>
<li><p> When indexed with a logical vector, the lengths of the vertex
sequence and the index must match, and the vertices for which the
index is <code>TRUE</code> are selected.
</p>
</li>
<li><p> Named graphs can be indexed with character vectors,
to select vertices with the given names.
</p>
</li></ul>



<h3>Vertex attributes</h3>

<p>When indexing vertex sequences, vertex attributes can be referred
to simply by using their names. E.g. if a graph has a <code>name</code> vertex
attribute, then <code>V(g)[name == "foo"]</code> is equivalent to
<code>V(g)[V(g)$name == "foo"]</code>. See more examples below. Note that attribute
names mask the names of variables present in the calling environment; if
you need to look up a variable and you do not want a similarly named
vertex attribute to mask it, use the <code>.env</code> pronoun to perform the
name lookup in the calling environment. In other words, use
<code>V(g)[.env$name == "foo"]</code> to make sure that <code>name</code> is looked up
from the calling environment even if there is a vertex attribute with the
same name. Similarly, you can use <code>.data</code> to match attribute names only.
</p>


<h3>Special functions</h3>

<p>There are some special igraph functions that can be used only
in expressions indexing vertex sequences: </p>

<dl>
<dt><code>.nei</code></dt><dd><p>takes a vertex sequence as its argument
and selects neighbors of these vertices. An optional <code>mode</code>
argument can be used to select successors (<code>mode="out"</code>), or
predecessors (<code>mode="in"</code>) in directed graphs.</p>
</dd>
<dt><code>.inc</code></dt><dd><p>Takes an edge sequence as an argument, and
selects vertices that have at least one incident edge in this
edge sequence.</p>
</dd>
<dt><code>.from</code></dt><dd><p>Similar to <code>.inc</code>, but only considers the
tails of the edges.</p>
</dd>
<dt><code>.to</code></dt><dd><p>Similar to <code>.inc</code>, but only considers the
heads of the edges.</p>
</dd>
<dt><code>.innei</code>, <code>.outnei</code></dt><dd><p><code>.innei(v)</code> is a shorthand for
<code>.nei(v, mode = "in")</code>, and <code>.outnei(v)</code> is a shorthand for
<code>.nei(v, mode = "out")</code>.
</p>
</dd>
</dl>

<p>Note that multiple special functions can be used together, or with
regular indices, and then their results are concatenated. See more
examples below.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>
<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -----------------------------------------------------------------
# Setting attributes for subsets of vertices
largest_comp &lt;- function(graph) {
  cl &lt;- components(graph)
  V(graph)[which.max(cl$csize) == cl$membership]
}
g &lt;- sample_(
  gnp(100, 2 / 100),
  with_vertex_(size = 3, label = ""),
  with_graph_(layout = layout_with_fr)
)
giant_v &lt;- largest_comp(g)
V(g)$color &lt;- "green"
V(g)[giant_v]$color &lt;- "red"
plot(g)

# -----------------------------------------------------------------
# nei() special function
g &lt;- make_graph(c(1, 2, 2, 3, 2, 4, 4, 2))
V(g)[.nei(c(2, 4))]
V(g)[.nei(c(2, 4), "in")]
V(g)[.nei(c(2, 4), "out")]

# -----------------------------------------------------------------
# The same with vertex names
g &lt;- make_graph(~ A -+ B, B -+ C:D, D -+ B)
V(g)[.nei(c("B", "D"))]
V(g)[.nei(c("B", "D"), "in")]
V(g)[.nei(c("B", "D"), "out")]

# -----------------------------------------------------------------
# Resolving attributes
g &lt;- make_graph(~ A -+ B, B -+ C:D, D -+ B)
V(g)$color &lt;- c("red", "red", "green", "green")
V(g)[color == "red"]

# Indexing with a variable whose name matches the name of an attribute
# may fail; use .env to force the name lookup in the parent environment
V(g)$x &lt;- 10:13
x &lt;- 2
V(g)[.env$x]

</code></pre>

<hr>
<h2 id='igraph-vs-indexing2'>Select vertices and show their metadata</h2><span id='topic+igraph-vs-indexing2'></span><span id='topic++5B+5B.igraph.vs'></span>

<h3>Description</h3>

<p>The double bracket operator can be used on vertex sequences, to print
the meta-data (vertex attributes) of the vertices in the sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
x[[...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph-vs-indexing2_+3A_x">x</code></td>
<td>
<p>A vertex sequence.</p>
</td></tr>
<tr><td><code id="igraph-vs-indexing2_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code>[</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Technically, when used with vertex sequences, the double bracket
operator does exactly the same as the single bracket operator,
but the resulting vertex sequence is printed differently: all
attributes of the vertices in the sequence are printed as well.
</p>
<p>See <code><a href="#topic++5B.igraph.vs">[.igraph.vs</a></code> for more about indexing vertex sequences.
</p>


<h3>Value</h3>

<p>The double bracket operator returns another vertex sequence,
with meta-data (attribute) printing turned on. See details below.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>
<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_vertex_attr("color", value = "red") %&gt;%
  set_vertex_attr("name", value = LETTERS[1:10])
V(g)
V(g)[[]]
V(g)[1:5]
V(g)[[1:5]]
</code></pre>

<hr>
<h2 id='igraph.console'>The igraph console</h2><span id='topic+igraph.console'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraph.console()</code> was renamed to <code>console()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.console()
</code></pre>

<hr>
<h2 id='igraph.from.graphNEL'>Convert graphNEL objects from the graph package to igraph</h2><span id='topic+igraph.from.graphNEL'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraph.from.graphNEL()</code> was renamed to <code>graph_from_graphnel()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.from.graphNEL(graphNEL, name = TRUE, weight = TRUE, unlist.attrs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph.from.graphNEL_+3A_graphnel">graphNEL</code></td>
<td>
<p>The graphNEL graph.</p>
</td></tr>
<tr><td><code id="igraph.from.graphNEL_+3A_name">name</code></td>
<td>
<p>Logical scalar, whether to add graphNEL vertex names as an
igraph vertex attribute called &lsquo;<code>name</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="igraph.from.graphNEL_+3A_weight">weight</code></td>
<td>
<p>Logical scalar, whether to add graphNEL edge weights as an
igraph edge attribute called &lsquo;<code>weight</code>&rsquo;. (graphNEL graphs are
always weighted.)</p>
</td></tr>
<tr><td><code id="igraph.from.graphNEL_+3A_unlist.attrs">unlist.attrs</code></td>
<td>
<p>Logical scalar. graphNEL attribute query functions
return the values of the attributes in R lists, if this argument is
<code>TRUE</code> (the default) these will be converted to atomic vectors,
whenever possible, before adding them to the igraph graph.</p>
</td></tr>
</table>

<hr>
<h2 id='igraph.options'>Parameters for the igraph package</h2><span id='topic+igraph.options'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraph.options()</code> was renamed to <code>igraph_options()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph.options_+3A_...">...</code></td>
<td>
<p>A list may be given as the only argument, or any number of
arguments may be in the <code>name=value</code> form, or no argument at all may be
given. See the Value and Details sections for explanation.</p>
</td></tr>
</table>

<hr>
<h2 id='igraph.sample'>Sampling a random integer sequence</h2><span id='topic+igraph.sample'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraph.sample()</code> was renamed to <code>sample_seq()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.sample(low, high, length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph.sample_+3A_low">low</code></td>
<td>
<p>The lower limit of the interval (inclusive).</p>
</td></tr>
<tr><td><code id="igraph.sample_+3A_high">high</code></td>
<td>
<p>The higher limit of the interval (inclusive).</p>
</td></tr>
<tr><td><code id="igraph.sample_+3A_length">length</code></td>
<td>
<p>The length of the sample.</p>
</td></tr>
</table>

<hr>
<h2 id='igraph.shape.noclip'>Various vertex shapes when plotting igraph graphs</h2><span id='topic+igraph.shape.noclip'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraph.shape.noclip()</code> was renamed to <code>shape_noclip()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.shape.noclip(coords, el, params, end = c("both", "from", "to"))
</code></pre>

<hr>
<h2 id='igraph.shape.noplot'>Various vertex shapes when plotting igraph graphs</h2><span id='topic+igraph.shape.noplot'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraph.shape.noplot()</code> was renamed to <code>shape_noplot()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.shape.noplot(coords, v = NULL, params)
</code></pre>

<hr>
<h2 id='igraph.to.graphNEL'>Convert igraph graphs to graphNEL objects from the graph package</h2><span id='topic+igraph.to.graphNEL'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraph.to.graphNEL()</code> was renamed to <code>as_graphnel()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.to.graphNEL(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraph.to.graphNEL_+3A_graph">graph</code></td>
<td>
<p>An igraph graph object.</p>
</td></tr>
</table>

<hr>
<h2 id='igraph.version'>Query igraph's version string</h2><span id='topic+igraph.version'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraph.version()</code> was renamed to <code>igraph_version()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraph.version()
</code></pre>

<hr>
<h2 id='igraphdemo'>Run igraph demos, step by step</h2><span id='topic+igraphdemo'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraphdemo()</code> was renamed to <code>igraph_demo()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraphdemo(which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igraphdemo_+3A_which">which</code></td>
<td>
<p>If not given, then the names of the available demos are listed.
Otherwise it should be either a filename or the name of an igraph demo.</p>
</td></tr>
</table>

<hr>
<h2 id='igraphtest'>Run package tests</h2><span id='topic+igraphtest'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>igraphtest()</code> was renamed to <code>igraph_test()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>igraphtest()
</code></pre>

<hr>
<h2 id='incident'>Incident edges of a vertex in a graph</h2><span id='topic+incident'></span>

<h3>Description</h3>

<p>Incident edges of a vertex in a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incident(graph, v, mode = c("all", "out", "in", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incident_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="incident_+3A_v">v</code></td>
<td>
<p>The vertex of which the incident edges are queried.</p>
</td></tr>
<tr><td><code id="incident_+3A_mode">mode</code></td>
<td>
<p>Whether to query outgoing (&lsquo;out&rsquo;), incoming
(&lsquo;in&rsquo;) edges, or both types (&lsquo;all&rsquo;). This is
ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge sequence containing the incident edges of
the input vertex.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Zachary")
incident(g, 1)
incident(g, 34)
</code></pre>

<hr>
<h2 id='incident_edges'>Incident edges of multiple vertices in a graph</h2><span id='topic+incident_edges'></span>

<h3>Description</h3>

<p>This function is similar to <code><a href="#topic+incident">incident()</a></code>, but it
queries multiple vertices at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incident_edges(graph, v, mode = c("out", "in", "all", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incident_edges_+3A_graph">graph</code></td>
<td>
<p>Input graph.</p>
</td></tr>
<tr><td><code id="incident_edges_+3A_v">v</code></td>
<td>
<p>The vertices to query</p>
</td></tr>
<tr><td><code id="incident_edges_+3A_mode">mode</code></td>
<td>
<p>Whether to query outgoing (&lsquo;out&rsquo;), incoming
(&lsquo;in&rsquo;) edges, or both types (&lsquo;all&rsquo;). This is
ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of edge sequences.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Zachary")
incident_edges(g, c(1, 34))
</code></pre>

<hr>
<h2 id='indent_print'>Indent a printout</h2><span id='topic+indent_print'></span>

<h3>Description</h3>

<p>Indent a printout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indent_print(..., .indent = " ", .printer = print)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indent_print_+3A_...">...</code></td>
<td>
<p>Passed to the printing function.</p>
</td></tr>
<tr><td><code id="indent_print_+3A_.indent">.indent</code></td>
<td>
<p>Character scalar, indent the printout with this.</p>
</td></tr>
<tr><td><code id="indent_print_+3A_.printer">.printer</code></td>
<td>
<p>The printing function, defaults to <a href="base.html#topic+print">print</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The first element in <code>...</code>, invisibly.
</p>

<hr>
<h2 id='independence.number'>Independent vertex sets</h2><span id='topic+independence.number'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>independence.number()</code> was renamed to <code>ivs_size()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>independence.number(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="independence.number_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs are considered as undirected,
loop edges and multiple edges are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='independent.vertex.sets'>Independent vertex sets</h2><span id='topic+independent.vertex.sets'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>independent.vertex.sets()</code> was renamed to <code>ivs()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>independent.vertex.sets(graph, min = NULL, max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="independent.vertex.sets_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs are considered as undirected,
loop edges and multiple edges are ignored.</p>
</td></tr>
<tr><td><code id="independent.vertex.sets_+3A_min">min</code></td>
<td>
<p>Numeric constant, limit for the minimum size of the independent
vertex sets to find. <code>NULL</code> means no limit.</p>
</td></tr>
<tr><td><code id="independent.vertex.sets_+3A_max">max</code></td>
<td>
<p>Numeric constant, limit for the maximum size of the independent
vertex sets to find. <code>NULL</code> means no limit.</p>
</td></tr>
</table>

<hr>
<h2 id='induced.subgraph'>Subgraph of a graph</h2><span id='topic+induced.subgraph'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>induced.subgraph()</code> was renamed to <code>induced_subgraph()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>induced.subgraph(
  graph,
  vids,
  impl = c("auto", "copy_and_delete", "create_from_scratch")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="induced.subgraph_+3A_graph">graph</code></td>
<td>
<p>The original graph.</p>
</td></tr>
<tr><td><code id="induced.subgraph_+3A_vids">vids</code></td>
<td>
<p>Numeric vector, the vertices of the original graph which will
form the subgraph.</p>
</td></tr>
<tr><td><code id="induced.subgraph_+3A_impl">impl</code></td>
<td>
<p>Character scalar, to choose between two implementation of the
subgraph calculation. &lsquo;<code>copy_and_delete</code>&rsquo; copies the graph
first, and then deletes the vertices and edges that are not included in the
result graph. &lsquo;<code>create_from_scratch</code>&rsquo; searches for all vertices
and edges that must be kept and then uses them to create the graph from
scratch. &lsquo;<code>auto</code>&rsquo; chooses between the two implementations
automatically, using heuristics based on the size of the original and the
result graph.</p>
</td></tr>
</table>

<hr>
<h2 id='infomap.community'>Infomap community finding</h2><span id='topic+infomap.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>infomap.community()</code> was renamed to <code>cluster_infomap()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infomap.community(
  graph,
  e.weights = NULL,
  v.weights = NULL,
  nb.trials = 10,
  modularity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infomap.community_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions will be taken into account.</p>
</td></tr>
<tr><td><code id="infomap.community_+3A_e.weights">e.weights</code></td>
<td>
<p>If not <code>NULL</code>, then a numeric vector of edge weights.
The length must match the number of edges in the graph.  By default the
&lsquo;<code>weight</code>&rsquo; edge attribute is used as weights. If it is not
present, then all edges are considered to have the same weight.
Larger edge weights correspond to stronger connections.</p>
</td></tr>
<tr><td><code id="infomap.community_+3A_v.weights">v.weights</code></td>
<td>
<p>If not <code>NULL</code>, then a numeric vector of vertex
weights. The length must match the number of vertices in the graph.  By
default the &lsquo;<code>weight</code>&rsquo; vertex attribute is used as weights. If
it is not present, then all vertices are considered to have the same weight.
A larger vertex weight means a larger probability that the random surfer
jumps to that vertex.</p>
</td></tr>
<tr><td><code id="infomap.community_+3A_nb.trials">nb.trials</code></td>
<td>
<p>The number of attempts to partition the network (can be any
integer value equal or larger than 1).</p>
</td></tr>
<tr><td><code id="infomap.community_+3A_modularity">modularity</code></td>
<td>
<p>Logical scalar, whether to calculate the modularity score
of the detected community structure.</p>
</td></tr>
</table>

<hr>
<h2 id='interconnected.islands.game'>A graph with subgraphs that are each a random graph.</h2><span id='topic+interconnected.islands.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>interconnected.islands.game()</code> was renamed to <code>sample_islands()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interconnected.islands.game(islands.n, islands.size, islands.pin, n.inter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interconnected.islands.game_+3A_islands.n">islands.n</code></td>
<td>
<p>The number of islands in the graph.</p>
</td></tr>
<tr><td><code id="interconnected.islands.game_+3A_islands.size">islands.size</code></td>
<td>
<p>The size of islands in the graph.</p>
</td></tr>
<tr><td><code id="interconnected.islands.game_+3A_islands.pin">islands.pin</code></td>
<td>
<p>The probability to create each possible edge into each
island.</p>
</td></tr>
<tr><td><code id="interconnected.islands.game_+3A_n.inter">n.inter</code></td>
<td>
<p>The number of edges to create between two islands.</p>
</td></tr>
</table>

<hr>
<h2 id='intersection'>Intersection of two or more sets</h2><span id='topic+intersection'></span>

<h3>Description</h3>

<p>This is an S3 generic function. See <code>methods("intersection")</code>
for the actual implementations for various S3 classes. Initially
it is implemented for igraph graphs and igraph vertex and edge
sequences. See
<code><a href="#topic+intersection.igraph">intersection.igraph()</a></code>, and
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersection(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersection_+3A_...">...</code></td>
<td>
<p>Arguments, their number and interpretation depends on
the function that implements <code>intersection()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the function that implements this method.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>

<hr>
<h2 id='intersection.igraph'>Intersection of graphs</h2><span id='topic+intersection.igraph'></span><span id='topic++25s+25'></span>

<h3>Description</h3>

<p>The intersection of two or more graphs are created.  The graphs may have
identical or overlapping vertex sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
intersection(..., byname = "auto", keep.all.vertices = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersection.igraph_+3A_...">...</code></td>
<td>
<p>Graph objects or lists of graph objects.</p>
</td></tr>
<tr><td><code id="intersection.igraph_+3A_byname">byname</code></td>
<td>
<p>A logical scalar, or the character scalar <code>auto</code>. Whether
to perform the operation based on symbolic vertex names. If it is
<code>auto</code>, that means <code>TRUE</code> if all graphs are named and <code>FALSE</code>
otherwise. A warning is generated if <code>auto</code> and some (but not all)
graphs are named.</p>
</td></tr>
<tr><td><code id="intersection.igraph_+3A_keep.all.vertices">keep.all.vertices</code></td>
<td>
<p>Logical scalar, whether to keep vertices that only
appear in a subset of the input graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>intersection()</code> creates the intersection of two or more graphs:
only edges present in all graphs will be included.  The corresponding
operator is <code style="white-space: pre;">&#8288;%s%&#8288;</code>.
</p>
<p>If the <code>byname</code> argument is <code>TRUE</code> (or <code>auto</code> and all graphs
are named), then the operation is performed on symbolic vertex names instead
of the internal numeric vertex ids.
</p>
<p><code>intersection()</code> keeps the attributes of all graphs. All graph,
vertex and edge attributes are copied to the result. If an attribute is
present in multiple graphs and would result a name clash, then this
attribute is renamed by adding suffixes: _1, _2, etc.
</p>
<p>The <code>name</code> vertex attribute is treated specially if the operation is
performed based on symbolic vertex names. In this case <code>name</code> must be
present in all graphs, and it is not renamed in the result graph.
</p>
<p>An error is generated if some input graphs are directed and others are
undirected.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Common part of two social networks
net1 &lt;- graph_from_literal(
  D - A:B:F:G, A - C - F - A, B - E - G - B, A - B, F - G,
  H - F:G, H - I - J
)
net2 &lt;- graph_from_literal(D - A:F:Y, B - A - X - F - H - Z, F - Y)
print_all(net1 %s% net2)
</code></pre>

<hr>
<h2 id='intersection.igraph.es'>Intersection of edge sequences</h2><span id='topic+intersection.igraph.es'></span>

<h3>Description</h3>

<p>Intersection of edge sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
intersection(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersection.igraph.es_+3A_...">...</code></td>
<td>
<p>The edge sequences to take the intersection of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They must belong to the same graph. Note that this function has
&lsquo;set&rsquo; semantics and the multiplicity of edges is lost in the
result.
</p>


<h3>Value</h3>

<p>An edge sequence that contains edges that appear in all
given sequences, each edge exactly once.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
intersection(E(g)[1:6], E(g)[5:9])
</code></pre>

<hr>
<h2 id='intersection.igraph.vs'>Intersection of vertex sequences</h2><span id='topic+intersection.igraph.vs'></span>

<h3>Description</h3>

<p>Intersection of vertex sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
intersection(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersection.igraph.vs_+3A_...">...</code></td>
<td>
<p>The vertex sequences to take the intersection of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They must belong to the same graph. Note that this function has
&lsquo;set&rsquo; semantics and the multiplicity of vertices is lost in the
result.
</p>


<h3>Value</h3>

<p>A vertex sequence that contains vertices that appear in all
given sequences, each vertex exactly once.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
intersection(E(g)[1:6], E(g)[5:9])
</code></pre>

<hr>
<h2 id='is_acyclic'>Acyclic graphs</h2><span id='topic+is_acyclic'></span>

<h3>Description</h3>

<p>This function tests whether the given graph is free of cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_acyclic(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_acyclic_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function looks for directed cycles in directed graphs and undirected
cycles in undirected graphs.
</p>


<h3>Value</h3>

<p>A logical vector of length one.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_forest">is_forest()</a></code> and <code><a href="#topic+is_dag">is_dag()</a></code> for functions specific to undirected
and directed graphs.
</p>
<p>Graph cycles
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+has_eulerian_path">has_eulerian_path</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph(c(1,2, 1,3, 2,4, 3,4), directed = TRUE)
is_acyclic(g)
is_acyclic(as.undirected(g))
</code></pre>

<hr>
<h2 id='is_biconnected'>Check biconnectedness</h2><span id='topic+is_biconnected'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Tests whether a graph is biconnected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_biconnected(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_biconnected_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graph is biconnected if the removal of any single vertex (and its adjacent
edges) does not disconnect it.
</p>
<p>igraph does not consider single-vertex graphs biconnected.
</p>
<p>Note that some authors do not consider the graph consisting of
two connected vertices as biconnected, however, igraph does.
</p>


<h3>Value</h3>

<p>Logical, <code>TRUE</code> if the graph is biconnected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+articulation_points">articulation_points()</a></code>, <code><a href="#topic+biconnected_components">biconnected_components()</a></code>,
<code><a href="#topic+is_connected">is_connected()</a></code>, <code><a href="#topic+vertex_connectivity">vertex_connectivity()</a></code>
</p>
<p>Connected components
<code><a href="#topic+articulation_points">articulation_points</a>()</code>,
<code><a href="#topic+biconnected_components">biconnected_components</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+decompose">decompose</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_biconnected(make_graph("bull"))
is_biconnected(make_graph("dodecahedron"))
is_biconnected(make_full_graph(1))
is_biconnected(make_full_graph(2))
</code></pre>

<hr>
<h2 id='is_bipartite'>Checks whether the graph has a vertex attribute called <code>type</code>.</h2><span id='topic+is_bipartite'></span>

<h3>Description</h3>

<p>It does not check whether the graph is bipartite in the
mathematical sense.  Use <code><a href="#topic+bipartite_mapping">bipartite_mapping()</a></code> for that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_bipartite(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_bipartite_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Bipartite graphs
<code><a href="#topic+bipartite_mapping">bipartite_mapping</a>()</code>,
<code><a href="#topic+bipartite_projection">bipartite_projection</a>()</code>,
<code><a href="#topic+make_bipartite_graph">make_bipartite_graph</a>()</code>
</p>

<hr>
<h2 id='is_chordal'>Chordality of a graph</h2><span id='topic+is_chordal'></span>

<h3>Description</h3>

<p>A graph is chordal (or triangulated) if each of its cycles of four or more
nodes has a chord, which is an edge joining two nodes that are not adjacent
in the cycle. An equivalent definition is that any chordless cycles have at
most three nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_chordal(
  graph,
  alpha = NULL,
  alpham1 = NULL,
  fillin = FALSE,
  newgraph = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_chordal_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored, as the algorithm is defined for undirected graphs.</p>
</td></tr>
<tr><td><code id="is_chordal_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector, the maximal chardinality ordering of the
vertices. If it is <code>NULL</code>, then it is automatically calculated by
calling <code><a href="#topic+max_cardinality">max_cardinality()</a></code>, or from <code>alpham1</code> if
that is given..</p>
</td></tr>
<tr><td><code id="is_chordal_+3A_alpham1">alpham1</code></td>
<td>
<p>Numeric vector, the inverse of <code>alpha</code>. If it is
<code>NULL</code>, then it is automatically calculated by calling
<code><a href="#topic+max_cardinality">max_cardinality()</a></code>, or from <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="is_chordal_+3A_fillin">fillin</code></td>
<td>
<p>Logical scalar, whether to calculate the fill-in edges.</p>
</td></tr>
<tr><td><code id="is_chordal_+3A_newgraph">newgraph</code></td>
<td>
<p>Logical scalar, whether to calculate the triangulated graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The chordality of the graph is decided by first performing maximum
cardinality search on it (if the <code>alpha</code> and <code>alpham1</code> arguments
are <code>NULL</code>), and then calculating the set of fill-in edges.
</p>
<p>The set of fill-in edges is empty if and only if the graph is chordal.
</p>
<p>It is also true that adding the fill-in edges to the graph makes it chordal.
</p>


<h3>Value</h3>

<p>A list with three members: </p>
<table>
<tr><td><code>chordal</code></td>
<td>
<p>Logical scalar, it is
<code>TRUE</code> iff the input graph is chordal.</p>
</td></tr> <tr><td><code>fillin</code></td>
<td>
<p>If requested,
then a numeric vector giving the fill-in edges. <code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code>newgraph</code></td>
<td>
<p>If requested, then the triangulated graph, an <code>igraph</code>
object. <code>NULL</code> otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Robert E Tarjan and Mihalis Yannakakis. (1984). Simple
linear-time algorithms to test chordality of graphs, test acyclicity of
hypergraphs, and selectively reduce acyclic hypergraphs.  <em>SIAM Journal
of Computation</em> 13, 566&ndash;579.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+max_cardinality">max_cardinality()</a></code>
</p>
<p>Other chordal: 
<code><a href="#topic+max_cardinality">max_cardinality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples from the Tarjan-Yannakakis paper
g1 &lt;- graph_from_literal(
  A - B:C:I, B - A:C:D, C - A:B:E:H, D - B:E:F,
  E - C:D:F:H, F - D:E:G, G - F:H, H - C:E:G:I,
  I - A:H
)
max_cardinality(g1)
is_chordal(g1, fillin = TRUE)

g2 &lt;- graph_from_literal(
  A - B:E, B - A:E:F:D, C - E:D:G, D - B:F:E:C:G,
  E - A:B:C:D:F, F - B:D:E, G - C:D:H:I, H - G:I:J,
  I - G:H:J, J - H:I
)
max_cardinality(g2)
is_chordal(g2, fillin = TRUE)

</code></pre>

<hr>
<h2 id='is_dag'>Directed acyclic graphs</h2><span id='topic+is_dag'></span>

<h3>Description</h3>

<p>This function tests whether the given graph is a DAG, a directed acyclic
graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_dag(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_dag_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be undirected, in which case
<code>FALSE</code> is reported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_dag()</code> checks whether there is a directed cycle in the graph. If not,
the graph is a DAG.
</p>


<h3>Value</h3>

<p>A logical vector of length one.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> for the C code, Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the R interface.
</p>


<h3>See Also</h3>

<p>Graph cycles
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+has_eulerian_path">has_eulerian_path</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_tree(10)
is_dag(g)
g2 &lt;- g + edge(5, 1)
is_dag(g2)
</code></pre>

<hr>
<h2 id='is_degseq'>Check if a degree sequence is valid for a multi-graph</h2><span id='topic+is_degseq'></span>

<h3>Description</h3>

<p><code>is_degseq()</code> checks whether the given vertex degrees (in- and
out-degrees for directed graphs) can be realized by a graph. Note that the
graph does not have to be simple, it may contain loop and multiple edges.
For undirected graphs, it also checks whether the sum of degrees is even.
For directed graphs, the function checks whether the lengths of the two
degree vectors are equal and whether their sums are also equal. These are
known sufficient and necessary conditions for a degree sequence to be valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_degseq(out.deg, in.deg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_degseq_+3A_out.deg">out.deg</code></td>
<td>
<p>Integer vector, the degree sequence for undirected graphs, or
the out-degree sequence for directed graphs.</p>
</td></tr>
<tr><td><code id="is_degseq_+3A_in.deg">in.deg</code></td>
<td>
<p><code>NULL</code> or an integer vector. For undirected graphs, it
should be <code>NULL</code>. For directed graphs it specifies the in-degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar.
</p>


<h3>Author(s)</h3>

<p>Tamás Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Szabolcs Horvát <a href="mailto:szhorvat@gmail.com">szhorvat@gmail.com</a>
</p>


<h3>References</h3>

<p>Z Király, Recognizing graphic degree sequences and generating
all realizations. TR-2011-11, Egerváry Research Group, H-1117, Budapest,
Hungary. ISSN 1587-4451 (2012).
</p>
<p>B. Cloteaux, Is This for Real? Fast Graphicality Testing, <em>Comput. Sci. Eng.</em> 17, 91 (2015).
</p>
<p>A. Berger, A note on the characterization of digraphic sequences, <em>Discrete Math.</em> 314, 38 (2014).
</p>
<p>G. Cairns and S. Mendan, Degree Sequence for Graphs with Loops (2013).
</p>


<h3>See Also</h3>

<p>Other graphical degree sequences: 
<code><a href="#topic+is_graphical">is_graphical</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_gnp(100, 2 / 100)
is_degseq(degree(g))
is_graphical(degree(g))
</code></pre>

<hr>
<h2 id='is_directed'>Check whether a graph is directed</h2><span id='topic+is_directed'></span>

<h3>Description</h3>

<p>Check whether a graph is directed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_directed(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_directed_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical scalar, whether the graph is directed.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
is_directed(g)

g2 &lt;- make_ring(10, directed = TRUE)
is_directed(g2)
</code></pre>

<hr>
<h2 id='is_forest'>Decide whether a graph is a forest.</h2><span id='topic+is_forest'></span>

<h3>Description</h3>

<p><code>is_forest()</code> decides whether a graph is a forest, and optionally returns a
set of possible root vertices for its components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_forest(graph, mode = c("out", "in", "all", "total"), details = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_forest_+3A_graph">graph</code></td>
<td>
<p>An igraph graph object</p>
</td></tr>
<tr><td><code id="is_forest_+3A_mode">mode</code></td>
<td>
<p>Whether to consider edge directions in a directed graph.
&lsquo;all&rsquo; ignores edge directions; &lsquo;out&rsquo; requires edges to be
oriented outwards from the root, &lsquo;in&rsquo; requires edges to be oriented
towards the root.</p>
</td></tr>
<tr><td><code id="is_forest_+3A_details">details</code></td>
<td>
<p>Whether to return only whether the graph is a tree (<code>FALSE</code>)
or also a possible root (<code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An undirected graph is a forest if it has no cycles. In the directed case,
a possible additional requirement is that edges in each tree are oriented
away from the root (out-trees or arborescences) or all edges are oriented
towards the root (in-trees or anti-arborescences). This test can be
controlled using the mode parameter.
</p>
<p>By convention, the null graph (i.e. the graph with no vertices) is considered
to be a forest.
</p>


<h3>Value</h3>

<p>When <code>details</code> is <code>FALSE</code>, a logical value that indicates
whether the graph is a tree. When <code>details</code> is <code>TRUE</code>, a named
list with two entries: </p>
<table>
<tr><td><code>res</code></td>
<td>
<p>Logical value that indicates whether the
graph is a tree.</p>
</td></tr> <tr><td><code>root</code></td>
<td>
<p>The root vertex of the tree; undefined if
the graph is not a tree.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other trees: 
<code><a href="#topic+is_tree">is_tree</a>()</code>,
<code><a href="#topic+make_from_prufer">make_from_prufer</a>()</code>,
<code><a href="#topic+sample_spanning_tree">sample_spanning_tree</a>()</code>,
<code><a href="#topic+to_prufer">to_prufer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_tree(3) + make_tree(5,3)
is_forest(g)
is_forest(g, details = TRUE)

</code></pre>

<hr>
<h2 id='is_graphical'>Is a degree sequence graphical?</h2><span id='topic+is_graphical'></span>

<h3>Description</h3>

<p>Determine whether the given vertex degrees (in- and out-degrees for
directed graphs) can be realized by a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_graphical(
  out.deg,
  in.deg = NULL,
  allowed.edge.types = c("simple", "loops", "multi", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_graphical_+3A_out.deg">out.deg</code></td>
<td>
<p>Integer vector, the degree sequence for undirected graphs, or
the out-degree sequence for directed graphs.</p>
</td></tr>
<tr><td><code id="is_graphical_+3A_in.deg">in.deg</code></td>
<td>
<p><code>NULL</code> or an integer vector. For undirected graphs, it
should be <code>NULL</code>. For directed graphs it specifies the in-degrees.</p>
</td></tr>
<tr><td><code id="is_graphical_+3A_allowed.edge.types">allowed.edge.types</code></td>
<td>
<p>The allowed edge types in the graph. &lsquo;simple&rsquo;
means that neither loop nor multiple edges are allowed (i.e. the graph must be
simple). &lsquo;loops&rsquo; means that loop edges are allowed but mutiple edges
are not. &lsquo;multi&rsquo; means that multiple edges are allowed but loop edges
are not. &lsquo;all&rsquo; means that both loop edges and multiple edges are
allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classical concept of graphicality assumes simple graphs. This function
can perform the check also when self-loops, multi-edges, or both are allowed
in the graph.
</p>


<h3>Value</h3>

<p>A logical scalar.
</p>


<h3>Author(s)</h3>

<p>Tamás Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>Hakimi SL: On the realizability of a set of integers as degrees
of the vertices of a simple graph. <em>J SIAM Appl Math</em> 10:496-506, 1962.
</p>
<p>PL Erdős, I Miklós and Z Toroczkai: A simple Havel-Hakimi type algorithm to
realize graphical degree sequences of directed graphs.  <em>The Electronic
Journal of Combinatorics</em> 17(1):R66, 2010.
</p>


<h3>See Also</h3>

<p>Other graphical degree sequences: 
<code><a href="#topic+is_degseq">is_degseq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_gnp(100, 2 / 100)
is_degseq(degree(g))
is_graphical(degree(g))
</code></pre>

<hr>
<h2 id='is_igraph'>Is this object an igraph graph?</h2><span id='topic+is_igraph'></span>

<h3>Description</h3>

<p>Is this object an igraph graph?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_igraph(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_igraph_+3A_graph">graph</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical constant, <code>TRUE</code> if argument <code>graph</code> is a graph
object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
is_igraph(g)
is_igraph(numeric(10))
</code></pre>

<hr>
<h2 id='is_matching'>Matching</h2><span id='topic+is_matching'></span><span id='topic+max_bipartite_match'></span><span id='topic+is_max_matching'></span>

<h3>Description</h3>

<p>A matching in a graph means the selection of a set of edges that are
pairwise non-adjacent, i.e. they have no common incident vertices. A
matching is maximal if it is not a proper subset of any other matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_matching(graph, matching, types = NULL)

is_max_matching(graph, matching, types = NULL)

max_bipartite_match(
  graph,
  types = NULL,
  weights = NULL,
  eps = .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_matching_+3A_graph">graph</code></td>
<td>
<p>The input graph. It might be directed, but edge directions will
be ignored.</p>
</td></tr>
<tr><td><code id="is_matching_+3A_matching">matching</code></td>
<td>
<p>A potential matching. An integer vector that gives the
pair in the matching for each vertex. For vertices without a pair,
supply <code>NA</code> here.</p>
</td></tr>
<tr><td><code id="is_matching_+3A_types">types</code></td>
<td>
<p>Vertex types, if the graph is bipartite. By default they
are taken from the &lsquo;<code>type</code>&rsquo; vertex attribute, if present.</p>
</td></tr>
<tr><td><code id="is_matching_+3A_weights">weights</code></td>
<td>
<p>Potential edge weights. If the graph has an edge
attribute called &lsquo;<code>weight</code>&rsquo;, and this argument is
<code>NULL</code>, then the edge attribute is used automatically.
In weighted matching, the weights of the edges must match as
much as possible.</p>
</td></tr>
<tr><td><code id="is_matching_+3A_eps">eps</code></td>
<td>
<p>A small real number used in equality tests in the weighted
bipartite matching algorithm. Two real numbers are considered equal in
the algorithm if their difference is smaller than <code>eps</code>. This is
required to avoid the accumulation of numerical errors. By default it is
set to the smallest <code class="reqn">x</code>, such that <code class="reqn">1+x \ne 1</code>
holds. If you are running the algorithm with no weights, this argument
is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_matching()</code> checks a matching vector and verifies whether its
length matches the number of vertices in the given graph, its values are
between zero (inclusive) and the number of vertices (inclusive), and
whether there exists a corresponding edge in the graph for every matched
vertex pair. For bipartite graphs, it also verifies whether the matched
vertices are in different parts of the graph.
</p>
<p><code>is_max_matching()</code> checks whether a matching is maximal.  A matching
is maximal if and only if there exists no unmatched vertex in a graph
such that one of its neighbors is also unmatched.
</p>
<p><code>max_bipartite_match()</code> calculates a maximum matching in a bipartite
graph. A matching in a bipartite graph is a partial assignment of
vertices of the first kind to vertices of the second kind such that each
vertex of the first kind is matched to at most one vertex of the second
kind and vice versa, and matched vertices must be connected by an edge
in the graph. The size (or cardinality) of a matching is the number of
edges. A matching is a maximum matching if there exists no other
matching with larger cardinality.  For weighted graphs, a maximum
matching is a matching whose edges have the largest possible total
weight among all possible matchings.
</p>
<p>Maximum matchings in bipartite graphs are found by the push-relabel
algorithm with greedy initialization and a global relabeling after every
<code class="reqn">n/2</code> steps where <code class="reqn">n</code> is the number of vertices in the graph.
</p>


<h3>Value</h3>

<p><code>is_matching()</code> and <code>is_max_matching()</code> return a logical
scalar.
</p>
<p><code>max_bipartite_match()</code> returns a list with components:
</p>
<table>
<tr><td><code>matching_size</code></td>
<td>
<p>The size of the matching, i.e. the number of edges
connecting the matched vertices.</p>
</td></tr>
<tr><td><code>matching_weight</code></td>
<td>
<p>The weights of the matching, if the graph was
weighted. For unweighted graphs this is the same as the size of the
matching.</p>
</td></tr>
<tr><td><code>matching</code></td>
<td>
<p>The matching itself. Numeric vertex id, or vertex
names if the graph was named. Non-matched vertices are denoted by
<code>NA</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graph_from_literal(a - b - c - d - e - f)
m1 &lt;- c("b", "a", "d", "c", "f", "e") # maximal matching
m2 &lt;- c("b", "a", "d", "c", NA, NA) # non-maximal matching
m3 &lt;- c("b", "c", "d", "c", NA, NA) # not a matching
is_matching(g, m1)
is_matching(g, m2)
is_matching(g, m3)
is_max_matching(g, m1)
is_max_matching(g, m2)
is_max_matching(g, m3)

V(g)$type &lt;- rep(c(FALSE, TRUE), 3)
print_all(g, v = TRUE)
max_bipartite_match(g)

g2 &lt;- graph_from_literal(a - b - c - d - e - f - g)
V(g2)$type &lt;- rep(c(FALSE, TRUE), length.out = vcount(g2))
print_all(g2, v = TRUE)
max_bipartite_match(g2)
#' @keywords graphs
</code></pre>

<hr>
<h2 id='is_min_separator'>Minimal vertex separators</h2><span id='topic+is_min_separator'></span>

<h3>Description</h3>

<p>Check whether a given set of vertices is a minimal vertex separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_min_separator(graph, candidate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_min_separator_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored.</p>
</td></tr>
<tr><td><code id="is_min_separator_+3A_candidate">candidate</code></td>
<td>
<p>A numeric vector giving the vertex ids of the candidate
separator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_min_separator()</code> decides whether the supplied vertex set is a minimal
vertex separator. A minimal vertex separator is a vertex separator, such
that none of its proper subsets are a vertex separator.
</p>


<h3>Value</h3>

<p>A logical scalar, whether the supplied vertex set is a (minimal)
vertex separator or not.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The graph from the Moody-White paper
mw &lt;- graph_from_literal(
  1 - 2:3:4:5:6, 2 - 3:4:5:7, 3 - 4:6:7, 4 - 5:6:7,
  5 - 6:7:21, 6 - 7, 7 - 8:11:14:19, 8 - 9:11:14, 9 - 10,
  10 - 12:13, 11 - 12:14, 12 - 16, 13 - 16, 14 - 15, 15 - 16,
  17 - 18:19:20, 18 - 20:21, 19 - 20:22:23, 20 - 21,
  21 - 22:23, 22 - 23
)

# Cohesive subgraphs
mw1 &lt;- induced_subgraph(mw, as.character(c(1:7, 17:23)))
mw2 &lt;- induced_subgraph(mw, as.character(7:16))
mw3 &lt;- induced_subgraph(mw, as.character(17:23))
mw4 &lt;- induced_subgraph(mw, as.character(c(7, 8, 11, 14)))
mw5 &lt;- induced_subgraph(mw, as.character(1:7))

check.sep &lt;- function(G) {
  sep &lt;- min_separators(G)
  sapply(sep, is_min_separator, graph = G)
}

check.sep(mw)
check.sep(mw1)
check.sep(mw2)
check.sep(mw3)
check.sep(mw4)
check.sep(mw5)

</code></pre>

<hr>
<h2 id='is_named'>Named graphs</h2><span id='topic+is_named'></span>

<h3>Description</h3>

<p>An igraph graph is named, if there is a symbolic name associated with its
vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_named(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_named_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In igraph vertices can always be identified and specified via their numeric
vertex ids. This is, however, not always convenient, and in many cases there
exist symbolic ids that correspond to the vertices. To allow this more
flexible identification of vertices, one can assign a vertex attribute
called &lsquo;name&rsquo; to an igraph graph. After doing this, the symbolic
vertex names can be used in all igraph functions, instead of the numeric
ids.
</p>
<p>Note that the uniqueness of vertex names are currently not enforced in
igraph, you have to check that for yourself, when assigning the vertex
names.
</p>


<h3>Value</h3>

<p>A logical scalar.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
is_named(g)
V(g)$name &lt;- letters[1:10]
is_named(g)
neighbors(g, "a")

</code></pre>

<hr>
<h2 id='is_printer_callback'>Is this a printer callback?</h2><span id='topic+is_printer_callback'></span>

<h3>Description</h3>

<p>Is this a printer callback?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_printer_callback(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_printer_callback_+3A_x">x</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other printer callbacks: 
<code><a href="#topic+printer_callback">printer_callback</a>()</code>
</p>

<hr>
<h2 id='is_separator'>Vertex separators</h2><span id='topic+is_separator'></span>

<h3>Description</h3>

<p>Check whether a given set of vertices is a vertex separator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_separator(graph, candidate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_separator_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored.</p>
</td></tr>
<tr><td><code id="is_separator_+3A_candidate">candidate</code></td>
<td>
<p>A numeric vector giving the vertex ids of the candidate
separator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_separator()</code> decides whether the supplied vertex set is a vertex
separator. A vertex set is a vertex separator if its removal results a
disconnected graph.
</p>


<h3>Value</h3>

<p>A logical scalar, whether the supplied vertex set is a (minimal)
vertex separator or not.
lists all vertex separator of minimum size.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>

<hr>
<h2 id='is_tree'>Decide whether a graph is a tree.</h2><span id='topic+is_tree'></span>

<h3>Description</h3>

<p><code>is_tree()</code> decides whether a graph is a tree, and optionally returns a
possible root vertex if the graph is a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_tree(graph, mode = c("out", "in", "all", "total"), details = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_tree_+3A_graph">graph</code></td>
<td>
<p>An igraph graph object</p>
</td></tr>
<tr><td><code id="is_tree_+3A_mode">mode</code></td>
<td>
<p>Whether to consider edge directions in a directed graph.
&lsquo;all&rsquo; ignores edge directions; &lsquo;out&rsquo; requires edges to be
oriented outwards from the root, &lsquo;in&rsquo; requires edges to be oriented
towards the root.</p>
</td></tr>
<tr><td><code id="is_tree_+3A_details">details</code></td>
<td>
<p>Whether to return only whether the graph is a tree (<code>FALSE</code>)
or also a possible root (<code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An undirected graph is a tree if it is connected and has no cycles.
In the directed case, a possible additional requirement is that all edges
are oriented away from a root (out-tree or arborescence) or all edges are
oriented towards a root (in-tree or anti-arborescence). This test can be
controlled using the mode parameter.
</p>
<p>By convention, the null graph (i.e. the graph with no vertices) is considered
not to be a tree.
</p>


<h3>Value</h3>

<p>When <code>details</code> is <code>FALSE</code>, a logical value that indicates
whether the graph is a tree. When <code>details</code> is <code>TRUE</code>, a named
list with two entries:
</p>
<table>
<tr><td><code>res</code></td>
<td>
<p>Logical value that indicates whether the
graph is a tree.</p>
</td></tr>
<tr><td><code>root</code></td>
<td>
<p>The root vertex of the tree; undefined if
the graph is not a tree.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other trees: 
<code><a href="#topic+is_forest">is_forest</a>()</code>,
<code><a href="#topic+make_from_prufer">make_from_prufer</a>()</code>,
<code><a href="#topic+sample_spanning_tree">sample_spanning_tree</a>()</code>,
<code><a href="#topic+to_prufer">to_prufer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_tree(7, 2)
is_tree(g)
is_tree(g, details = TRUE)

</code></pre>

<hr>
<h2 id='is_weighted'>Weighted graphs</h2><span id='topic+is_weighted'></span>

<h3>Description</h3>

<p>In weighted graphs, a real number is assigned to each (directed or
undirected) edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_weighted(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_weighted_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In igraph edge weights are represented via an edge attribute, called
&lsquo;weight&rsquo;. The <code>is_weighted()</code> function only checks that such an
attribute exists. (It does not even checks that it is a numeric edge
attribute.)
</p>
<p>Edge weights are used for different purposes by the different functions.
E.g. shortest path functions use it as the cost of the path; community
finding methods use it as the strength of the relationship between two
vertices, etc. Check the manual pages of the functions working with weighted
graphs for details.
</p>


<h3>Value</h3>

<p>A logical scalar.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
shortest_paths(g, 8, 2)
E(g)$weight &lt;- seq_len(ecount(g))
shortest_paths(g, 8, 2)

</code></pre>

<hr>
<h2 id='is.bipartite'>Checks whether the graph has a vertex attribute called <code>type</code></h2><span id='topic+is.bipartite'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.bipartite()</code> was renamed to <code>is_bipartite()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bipartite(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.bipartite_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
</table>

<hr>
<h2 id='is.chordal'>Chordality of a graph</h2><span id='topic+is.chordal'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.chordal()</code> was renamed to <code>is_chordal()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.chordal(
  graph,
  alpha = NULL,
  alpham1 = NULL,
  fillin = FALSE,
  newgraph = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.chordal_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored, as the algorithm is defined for undirected graphs.</p>
</td></tr>
<tr><td><code id="is.chordal_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector, the maximal chardinality ordering of the
vertices. If it is <code>NULL</code>, then it is automatically calculated by
calling <code><a href="#topic+max_cardinality">max_cardinality()</a></code>, or from <code>alpham1</code> if
that is given..</p>
</td></tr>
<tr><td><code id="is.chordal_+3A_alpham1">alpham1</code></td>
<td>
<p>Numeric vector, the inverse of <code>alpha</code>. If it is
<code>NULL</code>, then it is automatically calculated by calling
<code><a href="#topic+max_cardinality">max_cardinality()</a></code>, or from <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="is.chordal_+3A_fillin">fillin</code></td>
<td>
<p>Logical scalar, whether to calculate the fill-in edges.</p>
</td></tr>
<tr><td><code id="is.chordal_+3A_newgraph">newgraph</code></td>
<td>
<p>Logical scalar, whether to calculate the triangulated graph.</p>
</td></tr>
</table>

<hr>
<h2 id='is.connected'>Connected components of a graph</h2><span id='topic+is.connected'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.connected()</code> was renamed to <code>is_connected()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.connected(graph, mode = c("weak", "strong"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.connected_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="is.connected_+3A_mode">mode</code></td>
<td>
<p>Character string, either &ldquo;weak&rdquo; or &ldquo;strong&rdquo;.  For
directed graphs &ldquo;weak&rdquo; implies weakly, &ldquo;strong&rdquo; strongly
connected components to search. It is ignored for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='is.dag'>Directed acyclic graphs</h2><span id='topic+is.dag'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.dag()</code> was renamed to <code>is_dag()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dag(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dag_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be undirected, in which case
<code>FALSE</code> is reported.</p>
</td></tr>
</table>

<hr>
<h2 id='is.degree.sequence'>Check if a degree sequence is valid for a multi-graph</h2><span id='topic+is.degree.sequence'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.degree.sequence()</code> was renamed to <code>is_degseq()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.degree.sequence(out.deg, in.deg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.degree.sequence_+3A_out.deg">out.deg</code></td>
<td>
<p>Integer vector, the degree sequence for undirected graphs, or
the out-degree sequence for directed graphs.</p>
</td></tr>
<tr><td><code id="is.degree.sequence_+3A_in.deg">in.deg</code></td>
<td>
<p><code>NULL</code> or an integer vector. For undirected graphs, it
should be <code>NULL</code>. For directed graphs it specifies the in-degrees.</p>
</td></tr>
</table>

<hr>
<h2 id='is.directed'>Check whether a graph is directed</h2><span id='topic+is.directed'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.directed()</code> was renamed to <code>is_directed()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.directed(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.directed_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
</table>

<hr>
<h2 id='is.graphical.degree.sequence'>Is a degree sequence graphical?</h2><span id='topic+is.graphical.degree.sequence'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.graphical.degree.sequence()</code> was renamed to <code>is_graphical()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.graphical.degree.sequence(
  out.deg,
  in.deg = NULL,
  allowed.edge.types = c("simple", "loops", "multi", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.graphical.degree.sequence_+3A_out.deg">out.deg</code></td>
<td>
<p>Integer vector, the degree sequence for undirected graphs, or
the out-degree sequence for directed graphs.</p>
</td></tr>
<tr><td><code id="is.graphical.degree.sequence_+3A_in.deg">in.deg</code></td>
<td>
<p><code>NULL</code> or an integer vector. For undirected graphs, it
should be <code>NULL</code>. For directed graphs it specifies the in-degrees.</p>
</td></tr>
<tr><td><code id="is.graphical.degree.sequence_+3A_allowed.edge.types">allowed.edge.types</code></td>
<td>
<p>The allowed edge types in the graph. &lsquo;simple&rsquo;
means that neither loop nor multiple edges are allowed (i.e. the graph must be
simple). &lsquo;loops&rsquo; means that loop edges are allowed but mutiple edges
are not. &lsquo;multi&rsquo; means that multiple edges are allowed but loop edges
are not. &lsquo;all&rsquo; means that both loop edges and multiple edges are
allowed.</p>
</td></tr>
</table>

<hr>
<h2 id='is.hierarchical'>Functions to deal with the result of network community detection</h2><span id='topic+is.hierarchical'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.hierarchical()</code> was renamed to <code>is_hierarchical()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.hierarchical(communities)
</code></pre>

<hr>
<h2 id='is.igraph'>Is this object an igraph graph?</h2><span id='topic+is.igraph'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.igraph()</code> was renamed to <code>is_igraph()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.igraph(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.igraph_+3A_graph">graph</code></td>
<td>
<p>An R object.</p>
</td></tr>
</table>

<hr>
<h2 id='is.loop'>Find the multiple or loop edges in a graph</h2><span id='topic+is.loop'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.loop()</code> was renamed to <code>which_loop()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.loop(graph, eids = E(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.loop_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="is.loop_+3A_eids">eids</code></td>
<td>
<p>The edges to which the query is restricted. By default this is
all edges in the graph.</p>
</td></tr>
</table>

<hr>
<h2 id='is.matching'>Matching</h2><span id='topic+is.matching'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.matching()</code> was renamed to <code>is_matching()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.matching(graph, matching, types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.matching_+3A_graph">graph</code></td>
<td>
<p>The input graph. It might be directed, but edge directions will
be ignored.</p>
</td></tr>
<tr><td><code id="is.matching_+3A_matching">matching</code></td>
<td>
<p>A potential matching. An integer vector that gives the
pair in the matching for each vertex. For vertices without a pair,
supply <code>NA</code> here.</p>
</td></tr>
<tr><td><code id="is.matching_+3A_types">types</code></td>
<td>
<p>Vertex types, if the graph is bipartite. By default they
are taken from the &lsquo;<code>type</code>&rsquo; vertex attribute, if present.</p>
</td></tr>
</table>

<hr>
<h2 id='is.maximal.matching'>Matching</h2><span id='topic+is.maximal.matching'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.maximal.matching()</code> was renamed to <code>is_max_matching()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.maximal.matching(graph, matching, types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.maximal.matching_+3A_graph">graph</code></td>
<td>
<p>The input graph. It might be directed, but edge directions will
be ignored.</p>
</td></tr>
<tr><td><code id="is.maximal.matching_+3A_matching">matching</code></td>
<td>
<p>A potential matching. An integer vector that gives the
pair in the matching for each vertex. For vertices without a pair,
supply <code>NA</code> here.</p>
</td></tr>
<tr><td><code id="is.maximal.matching_+3A_types">types</code></td>
<td>
<p>Vertex types, if the graph is bipartite. By default they
are taken from the &lsquo;<code>type</code>&rsquo; vertex attribute, if present.</p>
</td></tr>
</table>

<hr>
<h2 id='is.minimal.separator'>Minimal vertex separators</h2><span id='topic+is.minimal.separator'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.minimal.separator()</code> was renamed to <code>is_min_separator()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.minimal.separator(graph, candidate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.minimal.separator_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored.</p>
</td></tr>
<tr><td><code id="is.minimal.separator_+3A_candidate">candidate</code></td>
<td>
<p>A numeric vector giving the vertex ids of the candidate
separator.</p>
</td></tr>
</table>

<hr>
<h2 id='is.multiple'>Find the multiple or loop edges in a graph</h2><span id='topic+is.multiple'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.multiple()</code> was renamed to <code>which_multiple()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.multiple(graph, eids = E(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.multiple_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="is.multiple_+3A_eids">eids</code></td>
<td>
<p>The edges to which the query is restricted. By default this is
all edges in the graph.</p>
</td></tr>
</table>

<hr>
<h2 id='is.mutual'>Find mutual edges in a directed graph</h2><span id='topic+is.mutual'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.mutual()</code> was renamed to <code>which_mutual()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.mutual(graph, eids = E(graph), loops = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.mutual_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="is.mutual_+3A_eids">eids</code></td>
<td>
<p>Edge sequence, the edges that will be probed. By default is
includes all edges in the order of their ids.</p>
</td></tr>
<tr><td><code id="is.mutual_+3A_loops">loops</code></td>
<td>
<p>Logical, whether to consider directed self-loops to be mutual.</p>
</td></tr>
</table>

<hr>
<h2 id='is.named'>Named graphs</h2><span id='topic+is.named'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.named()</code> was renamed to <code>is_named()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.named(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.named_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>

<hr>
<h2 id='is.separator'>Vertex separators</h2><span id='topic+is.separator'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.separator()</code> was renamed to <code>is_separator()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.separator(graph, candidate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.separator_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored.</p>
</td></tr>
<tr><td><code id="is.separator_+3A_candidate">candidate</code></td>
<td>
<p>A numeric vector giving the vertex ids of the candidate
separator.</p>
</td></tr>
</table>

<hr>
<h2 id='is.simple'>Simple graphs</h2><span id='topic+is.simple'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.simple()</code> was renamed to <code>is_simple()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.simple(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.simple_+3A_graph">graph</code></td>
<td>
<p>The graph to work on.</p>
</td></tr>
</table>

<hr>
<h2 id='is.weighted'>Weighted graphs</h2><span id='topic+is.weighted'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>is.weighted()</code> was renamed to <code>is_weighted()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.weighted(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.weighted_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>

<hr>
<h2 id='isomorphic'>Decide if two graphs are isomorphic</h2><span id='topic+isomorphic'></span><span id='topic+graph.isomorphic'></span><span id='topic+graph.isomorphic.34'></span><span id='topic+graph.isomorphic.vf2'></span><span id='topic+graph.isomorphic.bliss'></span><span id='topic+is_isomorphic_to'></span>

<h3>Description</h3>

<p>Decide if two graphs are isomorphic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isomorphic(graph1, graph2, method = c("auto", "direct", "vf2", "bliss"), ...)

is_isomorphic_to(
  graph1,
  graph2,
  method = c("auto", "direct", "vf2", "bliss"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isomorphic_+3A_graph1">graph1</code></td>
<td>
<p>The first graph.</p>
</td></tr>
<tr><td><code id="isomorphic_+3A_graph2">graph2</code></td>
<td>
<p>The second graph.</p>
</td></tr>
<tr><td><code id="isomorphic_+3A_method">method</code></td>
<td>
<p>The method to use. Possible values: &lsquo;auto&rsquo;,
&lsquo;direct&rsquo;, &lsquo;vf2&rsquo;, &lsquo;bliss&rsquo;. See their details
below.</p>
</td></tr>
<tr><td><code id="isomorphic_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the various methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical scalar, <code>TRUE</code> if the graphs are isomorphic.
</p>


<h3>&lsquo;auto&rsquo; method</h3>

<p>It tries to select the appropriate method based on the two graphs.
This is the algorithm it uses:
</p>

<ol>
<li><p> If the two graphs do not agree on their order and size
(i.e. number of vertices and edges), then return <code>FALSE</code>.
</p>
</li>
<li><p> If the graphs have three or four vertices, then the
&lsquo;direct&rsquo; method is used.
</p>
</li>
<li><p> If the graphs are directed, then the &lsquo;vf2&rsquo; method is
used.
</p>
</li>
<li><p> Otherwise the &lsquo;bliss&rsquo; method is used.
</p>
</li></ol>



<h3>&lsquo;direct&rsquo; method</h3>

<p>This method only works on graphs with three or four vertices,
and it is based on a pre-calculated and stored table. It does not
have any extra arguments.
</p>


<h3>&lsquo;vf2&rsquo; method</h3>

<p>This method uses the VF2 algorithm by Cordella, Foggia et al., see
references below. It supports vertex and edge colors and have the
following extra arguments:
</p>

<dl>
<dt>vertex.color1, vertex.color2</dt><dd><p>Optional integer vectors giving the
colors of the vertices for colored graph isomorphism. If they
are not given, but the graph has a &ldquo;color&rdquo; vertex attribute,
then it will be used. If you want to ignore these attributes, then
supply <code>NULL</code> for both of these arguments. See also examples
below.</p>
</dd>
<dt>edge.color1, edge.color2</dt><dd><p>Optional integer vectors giving the
colors of the edges for edge-colored (sub)graph isomorphism. If they
are not given, but the graph has a &ldquo;color&rdquo; edge attribute,
then it will be used. If you want to ignore these attributes, then
supply <code>NULL</code> for both of these arguments.</p>
</dd>
</dl>



<h3>&lsquo;bliss&rsquo; method</h3>

<p>Uses the BLISS algorithm by Junttila and Kaski, and it works for
undirected graphs. For both graphs the
<code><a href="#topic+canonical_permutation">canonical_permutation()</a></code> and then the <code><a href="#topic+permute">permute()</a></code>
function is called to transfer them into canonical form; finally the
canonical forms are compared.
Extra arguments:
</p>

<dl>
<dt>sh</dt><dd><p>Character constant, the heuristics to use in the BLISS
algorithm for <code>graph1</code> and <code>graph2</code>. See the <code>sh</code> argument of
<code><a href="#topic+canonical_permutation">canonical_permutation()</a></code> for possible values.</p>
</dd>
</dl>

<p><code>sh</code> defaults to &lsquo;fm&rsquo;.
</p>


<h3>References</h3>

<p>Tommi Junttila and Petteri Kaski: Engineering an Efficient Canonical
Labeling Tool for Large and Sparse Graphs, <em>Proceedings of the
Ninth Workshop on Algorithm Engineering and Experiments and the Fourth
Workshop on Analytic Algorithms and Combinatorics.</em> 2007.
</p>
<p>LP Cordella,  P Foggia, C Sansone, and M Vento: An improved algorithm
for matching large graphs, <em>Proc. of the 3rd IAPR TC-15 Workshop
on Graphbased Representations in Pattern Recognition</em>, 149&ndash;159, 2001.
</p>


<h3>See Also</h3>

<p>Other graph isomorphism: 
<code><a href="#topic+canonical_permutation">canonical_permutation</a>()</code>,
<code><a href="#topic+count_isomorphisms">count_isomorphisms</a>()</code>,
<code><a href="#topic+count_subgraph_isomorphisms">count_subgraph_isomorphisms</a>()</code>,
<code><a href="#topic+graph_from_isomorphism_class">graph_from_isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphism_class">isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphisms">isomorphisms</a>()</code>,
<code><a href="#topic+subgraph_isomorphic">subgraph_isomorphic</a>()</code>,
<code><a href="#topic+subgraph_isomorphisms">subgraph_isomorphisms</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some non-isomorphic graphs
g1 &lt;- graph_from_isomorphism_class(3, 10)
g2 &lt;- graph_from_isomorphism_class(3, 11)
isomorphic(g1, g2)

# create two isomorphic graphs, by permuting the vertices of the first
g1 &lt;- sample_pa(30, m = 2, directed = FALSE)
g2 &lt;- permute(g1, sample(vcount(g1)))
# should be TRUE
isomorphic(g1, g2)
isomorphic(g1, g2, method = "bliss")
isomorphic(g1, g2, method = "vf2")

# colored graph isomorphism
g1 &lt;- make_ring(10)
g2 &lt;- make_ring(10)
isomorphic(g1, g2)

V(g1)$color &lt;- rep(1:2, length = vcount(g1))
V(g2)$color &lt;- rep(2:1, length = vcount(g2))
# consider colors by default
count_isomorphisms(g1, g2)
# ignore colors
count_isomorphisms(g1, g2,
  vertex.color1 = NULL,
  vertex.color2 = NULL
)
</code></pre>

<hr>
<h2 id='isomorphism_class'>Isomorphism class of a graph</h2><span id='topic+isomorphism_class'></span><span id='topic+graph.isoclass'></span><span id='topic+graph.isoclass.subgraph'></span>

<h3>Description</h3>

<p>The isomorphism class is a non-negative integer number.
Graphs (with the same number of vertices) having the same isomorphism
class are isomorphic and isomorphic graphs always have the same
isomorphism class. Currently it can handle directed graphs with 3 or 4
vertices and undirected graphs with 3 to 6 vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isomorphism_class(graph, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isomorphism_class_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="isomorphism_class_+3A_v">v</code></td>
<td>
<p>Optionally a vertex sequence. If not missing, then an induced
subgraph of the input graph, consisting of this vertices, is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer number.
</p>


<h3>See Also</h3>

<p>Other graph isomorphism: 
<code><a href="#topic+canonical_permutation">canonical_permutation</a>()</code>,
<code><a href="#topic+count_isomorphisms">count_isomorphisms</a>()</code>,
<code><a href="#topic+count_subgraph_isomorphisms">count_subgraph_isomorphisms</a>()</code>,
<code><a href="#topic+graph_from_isomorphism_class">graph_from_isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphic">isomorphic</a>()</code>,
<code><a href="#topic+isomorphisms">isomorphisms</a>()</code>,
<code><a href="#topic+subgraph_isomorphic">subgraph_isomorphic</a>()</code>,
<code><a href="#topic+subgraph_isomorphisms">subgraph_isomorphisms</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some non-isomorphic graphs
g1 &lt;- graph_from_isomorphism_class(3, 10)
g2 &lt;- graph_from_isomorphism_class(3, 11)
isomorphism_class(g1)
isomorphism_class(g2)
isomorphic(g1, g2)
</code></pre>

<hr>
<h2 id='isomorphisms'>Calculate all isomorphic mappings between the vertices of two graphs</h2><span id='topic+isomorphisms'></span><span id='topic+graph.get.isomorphisms.vf2'></span>

<h3>Description</h3>

<p>Calculate all isomorphic mappings between the vertices of two graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isomorphisms(graph1, graph2, method = "vf2", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isomorphisms_+3A_graph1">graph1</code></td>
<td>
<p>The first graph.</p>
</td></tr>
<tr><td><code id="isomorphisms_+3A_graph2">graph2</code></td>
<td>
<p>The second graph.</p>
</td></tr>
<tr><td><code id="isomorphisms_+3A_method">method</code></td>
<td>
<p>Currently only &lsquo;vf2&rsquo; is supported, see
<code><a href="#topic+isomorphic">isomorphic()</a></code> for details about it and extra arguments.</p>
</td></tr>
<tr><td><code id="isomorphisms_+3A_...">...</code></td>
<td>
<p>Extra arguments, passed to the various methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vertex sequences, corresponding to all
mappings from the first graph to the second.
</p>


<h3>See Also</h3>

<p>Other graph isomorphism: 
<code><a href="#topic+canonical_permutation">canonical_permutation</a>()</code>,
<code><a href="#topic+count_isomorphisms">count_isomorphisms</a>()</code>,
<code><a href="#topic+count_subgraph_isomorphisms">count_subgraph_isomorphisms</a>()</code>,
<code><a href="#topic+graph_from_isomorphism_class">graph_from_isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphic">isomorphic</a>()</code>,
<code><a href="#topic+isomorphism_class">isomorphism_class</a>()</code>,
<code><a href="#topic+subgraph_isomorphic">subgraph_isomorphic</a>()</code>,
<code><a href="#topic+subgraph_isomorphisms">subgraph_isomorphisms</a>()</code>
</p>

<hr>
<h2 id='ivs'>Independent vertex sets</h2><span id='topic+ivs'></span><span id='topic+largest_ivs'></span><span id='topic+maximal_ivs'></span><span id='topic+ivs_size'></span>

<h3>Description</h3>

<p>A vertex set is called independent if there no edges between any two
vertices in it. These functions find independent vertex sets in undirected
graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivs(graph, min = NULL, max = NULL)

largest_ivs(graph)

maximal_ivs(graph)

ivs_size(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivs_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs are considered as undirected,
loop edges and multiple edges are ignored.</p>
</td></tr>
<tr><td><code id="ivs_+3A_min">min</code></td>
<td>
<p>Numeric constant, limit for the minimum size of the independent
vertex sets to find. <code>NULL</code> means no limit.</p>
</td></tr>
<tr><td><code id="ivs_+3A_max">max</code></td>
<td>
<p>Numeric constant, limit for the maximum size of the independent
vertex sets to find. <code>NULL</code> means no limit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ivs()</code> finds all independent vertex sets in the
network, obeying the size limitations given in the <code>min</code> and <code>max</code>
arguments.
</p>
<p><code>largest_ivs()</code> finds the largest independent vertex
sets in the graph. An independent vertex set is largest if there is no
independent vertex set with more vertices.
</p>
<p><code>maximal_ivs()</code> finds the maximal independent vertex
sets in the graph. An independent vertex set is maximal if it cannot be
extended to a larger independent vertex set. The largest independent vertex
sets are maximal, but the opposite is not always true.
</p>
<p><code>ivs_size()</code> calculate the size of the largest independent
vertex set(s).
</p>
<p>These functions use the algorithm described by Tsukiyama et al., see
reference below.
</p>


<h3>Value</h3>

<p><code>ivs()</code>,
<code>largest_ivs()</code> and
<code>maximal_ivs()</code> return a list containing numeric
vertex ids, each list element is an independent vertex set.
</p>
<p><code>ivs_size()</code> returns an integer constant.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> ported it from the Very Nauty
Graph Library by Keith Briggs (<a href="http://keithbriggs.info/">http://keithbriggs.info/</a>) and Gabor
Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> wrote the R interface and this manual
page.
</p>


<h3>References</h3>

<p>S. Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new
algorithm for generating all the maximal independent sets. <em>SIAM J
Computing</em>, 6:505&ndash;517, 1977.
</p>


<h3>See Also</h3>

<p>Other cliques: 
<code><a href="#topic+cliques">cliques</a>()</code>,
<code><a href="#topic+weighted_cliques">weighted_cliques</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Do not run, takes a couple of seconds

# A quite dense graph
set.seed(42)
g &lt;- sample_gnp(100, 0.9)
ivs_size(g)
ivs(g, min = ivs_size(g))
largest_ivs(g)
# Empty graph
induced_subgraph(g, largest_ivs(g)[[1]])

length(maximal_ivs(g))
</code></pre>

<hr>
<h2 id='k_shortest_paths'>Find the <code class="reqn">k</code> shortest paths between two vertices</h2><span id='topic+k_shortest_paths'></span>

<h3>Description</h3>

<p>Finds the <code class="reqn">k</code> shortest paths between the given source and target
vertex in order of increasing length. Currently this function uses
Yen's algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_shortest_paths(
  graph,
  from,
  to,
  ...,
  k,
  weights = NULL,
  mode = c("out", "in", "all", "total")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k_shortest_paths_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="k_shortest_paths_+3A_from">from</code></td>
<td>
<p>The source vertex of the shortest paths.</p>
</td></tr>
<tr><td><code id="k_shortest_paths_+3A_to">to</code></td>
<td>
<p>The target vertex of the shortest paths.</p>
</td></tr>
<tr><td><code id="k_shortest_paths_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="k_shortest_paths_+3A_k">k</code></td>
<td>
<p>The number of paths to find. They will be returned in order of
increasing length.</p>
</td></tr>
<tr><td><code id="k_shortest_paths_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then the
attribute is used. If this is <code>NA</code> then no weights are used (even if
the graph has a <code>weight</code> attribute).</p>
</td></tr>
<tr><td><code id="k_shortest_paths_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the corresponding
undirected graph will be used, i.e. not directed paths are searched. This
argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with two components is returned:
</p>
<table>
<tr><td><code>vpaths</code></td>
<td>
<p>The list of <code class="reqn">k</code> shortest paths in terms of vertices</p>
</td></tr>
<tr><td><code>epaths</code></td>
<td>
<p>The list of <code class="reqn">k</code> shortest paths in terms of edges</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yen, Jin Y.:
An algorithm for finding shortest routes from all source nodes to a given
destination in general networks.
Quarterly of Applied Mathematics. 27 (4): 526–530. (1970)
<a href="https://doi.org/10.1090/qam/253822">doi:10.1090/qam/253822</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shortest_paths">shortest_paths()</a></code>, <code><a href="#topic+all_shortest_paths">all_shortest_paths()</a></code>
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>

<hr>
<h2 id='k.regular.game'>Create a random regular graph</h2><span id='topic+k.regular.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>k.regular.game()</code> was renamed to <code>sample_k_regular()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k.regular.game(no.of.nodes, k, directed = FALSE, multiple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k.regular.game_+3A_no.of.nodes">no.of.nodes</code></td>
<td>
<p>Integer scalar, the number of vertices in the generated
graph.</p>
</td></tr>
<tr><td><code id="k.regular.game_+3A_k">k</code></td>
<td>
<p>Integer scalar, the degree of each vertex in the graph, or the
out-degree and in-degree in a directed graph.</p>
</td></tr>
<tr><td><code id="k.regular.game_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="k.regular.game_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether multiple edges are allowed.</p>
</td></tr>
</table>

<hr>
<h2 id='keeping_degseq'>Graph rewiring while preserving the degree distribution</h2><span id='topic+keeping_degseq'></span>

<h3>Description</h3>

<p>This function can be used together with <code><a href="#topic+rewire">rewire()</a></code> to
randomly rewire the edges while preserving the original graph's degree
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keeping_degseq(loops = FALSE, niter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keeping_degseq_+3A_loops">loops</code></td>
<td>
<p>Whether to allow destroying and creating loop edges.</p>
</td></tr>
<tr><td><code id="keeping_degseq_+3A_niter">niter</code></td>
<td>
<p>Number of rewiring trials to perform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rewiring algorithm chooses two arbitrary edges in each step ((a,b)
and (c,d)) and substitutes them with (a,d) and (c,b), if they not
already exists in the graph. The algorithm does not create multiple
edges.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_degseq">sample_degseq()</a></code>
</p>
<p>Other rewiring functions: 
<code><a href="#topic+each_edge">each_edge</a>()</code>,
<code><a href="#topic+rewire">rewire</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
g %&gt;%
  rewire(keeping_degseq(niter = 20)) %&gt;%
  degree()
print_all(rewire(g, with = keeping_degseq(niter = vcount(g) * 10)))
</code></pre>

<hr>
<h2 id='knn'>Average nearest neighbor degree</h2><span id='topic+knn'></span>

<h3>Description</h3>

<p>Calculate the average nearest neighbor degree of the given vertices and the
same quantity in the function of vertex degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn(
  graph,
  vids = V(graph),
  mode = c("all", "out", "in", "total"),
  neighbor.degree.mode = c("all", "out", "in", "total"),
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed.</p>
</td></tr>
<tr><td><code id="knn_+3A_vids">vids</code></td>
<td>
<p>The vertices for which the calculation is performed. Normally it
includes all vertices. Note, that if not all vertices are given here, then
both &lsquo;<code>knn</code>&rsquo; and &lsquo;<code>knnk</code>&rsquo; will be calculated based
on the given vertices only.</p>
</td></tr>
<tr><td><code id="knn_+3A_mode">mode</code></td>
<td>
<p>Character constant to indicate the type of neighbors to consider
in directed graphs. <code>out</code> considers out-neighbors, <code style="white-space: pre;">&#8288;in&#8288;</code> considers
in-neighbors and <code>all</code> ignores edge directions.</p>
</td></tr>
<tr><td><code id="knn_+3A_neighbor.degree.mode">neighbor.degree.mode</code></td>
<td>
<p>The type of degree to average in directed graphs.
<code>out</code> averages out-degrees, <code style="white-space: pre;">&#8288;in&#8288;</code> averages in-degrees and <code>all</code>
ignores edge directions for the degree calculation.</p>
</td></tr>
<tr><td><code id="knn_+3A_weights">weights</code></td>
<td>
<p>Weight vector. If the graph has a <code>weight</code> edge
attribute, then this is used by default. If this argument is given, then
vertex strength (see <code><a href="#topic+strength">strength()</a></code>) is used instead of vertex
degree. But note that <code>knnk</code> is still given in the function of the
normal vertex degree.
Weights are are used to calculate a weighted degree (also called
<code><a href="#topic+strength">strength()</a></code>) instead of the degree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for zero degree vertices the answer in &lsquo;<code>knn</code>&rsquo; is
<code>NaN</code> (zero divided by zero), the same is true for &lsquo;<code>knnk</code>&rsquo;
if a given degree never appears in the network.
</p>
<p>The weighted version computes a weighted average of the neighbor degrees as
</p>
<p style="text-align: center;"><code class="reqn">k_{nn,u} = \frac{1}{s_u} \sum_v w_{uv} k_v,</code>
</p>

<p>where <code class="reqn">s_u = \sum_v w_{uv}</code> is the sum of the incident
edge weights of vertex <code>u</code>, i.e. its strength.
The sum runs over the neighbors <code>v</code> of vertex <code>u</code>
as indicated by <code>mode</code>. <code class="reqn">w_{uv}</code> denotes the weighted adjacency matrix
and <code class="reqn">k_v</code> is the neighbors' degree, specified by <code>neighbor_degree_mode</code>.
</p>


<h3>Value</h3>

<p>A list with two members: </p>
<table>
<tr><td><code>knn</code></td>
<td>
<p>A numeric vector giving the
average nearest neighbor degree for all vertices in <code>vids</code>.</p>
</td></tr>
<tr><td><code>knnk</code></td>
<td>
<p>A numeric vector, its length is the maximum (total) vertex
degree in the graph. The first element is the average nearest neighbor
degree of vertices with degree one, etc.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Alain Barrat, Marc Barthelemy, Romualdo Pastor-Satorras,
Alessandro Vespignani: The architecture of complex weighted networks, Proc.
Natl. Acad. Sci. USA 101, 3747 (2004)
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Some trivial ones
g &lt;- make_ring(10)
knn(g)
g2 &lt;- make_star(10)
knn(g2)

# A scale-free one, try to plot 'knnk'
g3 &lt;- sample_pa(1000, m = 5)
knn(g3)

# A random graph
g4 &lt;- sample_gnp(1000, p = 5 / 1000)
knn(g4)

# A weighted graph
g5 &lt;- make_star(10)
E(g5)$weight &lt;- seq(ecount(g5))
knn(g5)
</code></pre>

<hr>
<h2 id='label.propagation.community'>Finding communities based on propagating labels</h2><span id='topic+label.propagation.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>label.propagation.community()</code> was renamed to <code>cluster_label_prop()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>label.propagation.community(
  graph,
  weights = NULL,
  ...,
  mode = c("out", "in", "all"),
  initial = NULL,
  fixed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="label.propagation.community_+3A_graph">graph</code></td>
<td>
<p>The input graph. Note that the algorithm wsa originally
defined for undirected graphs. You are advised to set &lsquo;mode&rsquo; to
<code>all</code> if you pass a directed graph here to treat it as
undirected.</p>
</td></tr>
<tr><td><code id="label.propagation.community_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="label.propagation.community_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="label.propagation.community_+3A_mode">mode</code></td>
<td>
<p>Logical, whether to consider edge directions for the label propagation,
and if so, in which direction the labels should propagate. Ignored for undirected graphs.
&quot;all&quot; means to ignore edge directions (even in directed graphs).
&quot;out&quot; means to propagate labels along the natural direction of the edges.
&quot;in&quot; means to propagate labels backwards (i.e. from head to tail).</p>
</td></tr>
<tr><td><code id="label.propagation.community_+3A_initial">initial</code></td>
<td>
<p>The initial state. If <code>NULL</code>, every vertex will have a
different label at the beginning. Otherwise it must be a vector with an
entry for each vertex. Non-negative values denote different labels, negative
entries denote vertices without labels.</p>
</td></tr>
<tr><td><code id="label.propagation.community_+3A_fixed">fixed</code></td>
<td>
<p>Logical vector denoting which labels are fixed. Of course this
makes sense only if you provided an initial state, otherwise this element
will be ignored. Also note that vertices without labels cannot be fixed.</p>
</td></tr>
</table>

<hr>
<h2 id='laplacian_matrix'>Graph Laplacian</h2><span id='topic+laplacian_matrix'></span>

<h3>Description</h3>

<p>The Laplacian of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacian_matrix(
  graph,
  normalized = FALSE,
  weights = NULL,
  sparse = igraph_opt("sparsematrices")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laplacian_matrix_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="laplacian_matrix_+3A_normalized">normalized</code></td>
<td>
<p>Whether to calculate the normalized Laplacian. See
definitions below.</p>
</td></tr>
<tr><td><code id="laplacian_matrix_+3A_weights">weights</code></td>
<td>
<p>An optional vector giving edge weights for weighted Laplacian
matrix. If this is <code>NULL</code> and the graph has an edge attribute called
<code>weight</code>, then it will be used automatically. Set this to <code>NA</code> if
you want the unweighted Laplacian on a graph that has a <code>weight</code> edge
attribute.</p>
</td></tr>
<tr><td><code id="laplacian_matrix_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to return the result as a sparse
matrix. The <code>Matrix</code> package is required for sparse matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Laplacian Matrix of a graph is a symmetric matrix having the same number
of rows and columns as the number of vertices in the graph and element (i,j)
is d[i], the degree of vertex i if if i==j, -1 if i!=j and there is an edge
between vertices i and j and 0 otherwise.
</p>
<p>A normalized version of the Laplacian Matrix is similar: element (i,j) is 1
if i==j, -1/sqrt(d[i] d[j]) if i!=j and there is an edge between vertices i
and j and 0 otherwise.
</p>
<p>The weighted version of the Laplacian simply works with the weighted degree
instead of the plain degree. I.e. (i,j) is d[i], the weighted degree of
vertex i if if i==j, -w if i!=j and there is an edge between vertices i and
j with weight w, and 0 otherwise. The weighted degree of a vertex is the sum
of the weights of its adjacent edges.
</p>


<h3>Value</h3>

<p>A numeric matrix.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
laplacian_matrix(g)
laplacian_matrix(g, norm = TRUE)
laplacian_matrix(g, norm = TRUE, sparse = FALSE)

</code></pre>

<hr>
<h2 id='largest.cliques'>Functions to find cliques, i.e. complete subgraphs in a graph</h2><span id='topic+largest.cliques'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>largest.cliques()</code> was renamed to <code>largest_cliques()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>largest.cliques(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="largest.cliques_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs will be considered as
undirected ones, multiple edges and loops are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='largest.independent.vertex.sets'>Independent vertex sets</h2><span id='topic+largest.independent.vertex.sets'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>largest.independent.vertex.sets()</code> was renamed to <code>largest_ivs()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>largest.independent.vertex.sets(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="largest.independent.vertex.sets_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs are considered as undirected,
loop edges and multiple edges are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='lastcit.game'>Random citation graphs</h2><span id='topic+lastcit.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>lastcit.game()</code> was renamed to <code>sample_last_cit()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lastcit.game(
  n,
  edges = 1,
  agebins = n/7100,
  pref = (1:(agebins + 1))^-3,
  directed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lastcit.game_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="lastcit.game_+3A_edges">edges</code></td>
<td>
<p>Number of edges per step.</p>
</td></tr>
<tr><td><code id="lastcit.game_+3A_agebins">agebins</code></td>
<td>
<p>Number of aging bins.</p>
</td></tr>
<tr><td><code id="lastcit.game_+3A_pref">pref</code></td>
<td>
<p>Vector (<code>sample_last_cit()</code> and <code>sample_cit_types()</code> or
matrix (<code>sample_cit_cit_types()</code>) giving the (unnormalized) citation
probabilities for the different vertex types.</p>
</td></tr>
<tr><td><code id="lastcit.game_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to generate directed networks.</p>
</td></tr>
</table>

<hr>
<h2 id='layout_'>Graph layouts</h2><span id='topic+layout_'></span><span id='topic+layout'></span><span id='topic+print.igraph_layout_spec'></span><span id='topic+print.igraph_layout_modifier'></span>

<h3>Description</h3>

<p>This is a generic function to apply a layout function to
a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_(graph, layout, ...)

## S3 method for class 'igraph_layout_spec'
print(x, ...)

## S3 method for class 'igraph_layout_modifier'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout__+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout__+3A_layout">layout</code></td>
<td>
<p>The layout specification. It must be a call
to a layout specification function.</p>
</td></tr>
<tr><td><code id="layout__+3A_...">...</code></td>
<td>
<p>Further modifiers, see a complete list below.
For the <code><a href="base.html#topic+print">print()</a></code> methods, it is ignored.</p>
</td></tr>
<tr><td><code id="layout__+3A_x">x</code></td>
<td>
<p>The layout specification</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to calculate graph layouts in igraph.
The first way is to call a layout function (they all have
prefix <code>layout_()</code> on a graph, to get the vertex coordinates.
</p>
<p>The second way (new in igraph 0.8.0), has two steps, and it
is more flexible. First you call a layout specification
function (the one without the <code>layout_()</code> prefix, and
then <code>layout_()</code> (or <code><a href="#topic+add_layout_">add_layout_()</a></code>) to
perform the layouting.
</p>
<p>The second way is preferred, as it is more flexible. It allows
operations before and after the layouting. E.g. using the
<code>component_wise()</code> argument, the layout can be calculated
separately for each component, and then merged to get the
final results.
</p>


<h3>Value</h3>

<p>The return value of the layout function, usually a
two column matrix. For 3D layouts a three column matrix.
</p>


<h3>Modifiers</h3>

<p>Modifiers modify how a layout calculation is performed.
Currently implemented modifiers: </p>

<ul>
<li> <p><code>component_wise()</code> calculates the layout separately
for each component of the graph, and then merges
them.
</p>
</li>
<li> <p><code>normalize()</code> scales the layout to a square.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+add_layout_">add_layout_()</a></code> to add the layout to the
graph as an attribute.
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) + make_full_graph(5)
coords &lt;- layout_(g, as_star())
plot(g, layout = coords)
</code></pre>

<hr>
<h2 id='layout_as_bipartite'>Simple two-row layout for bipartite graphs</h2><span id='topic+layout_as_bipartite'></span><span id='topic+as_bipartite'></span>

<h3>Description</h3>

<p>Minimize edge-crossings in a simple two-row (or column) layout for bipartite
graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_as_bipartite(graph, types = NULL, hgap = 1, vgap = 1, maxiter = 100)

as_bipartite(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_as_bipartite_+3A_graph">graph</code></td>
<td>
<p>The bipartite input graph. It should have a logical
&lsquo;<code>type</code>&rsquo; vertex attribute, or the <code>types</code> argument must be
given.</p>
</td></tr>
<tr><td><code id="layout_as_bipartite_+3A_types">types</code></td>
<td>
<p>A logical vector, the vertex types. If this argument is
<code>NULL</code> (the default), then the &lsquo;<code>type</code>&rsquo; vertex attribute is
used.</p>
</td></tr>
<tr><td><code id="layout_as_bipartite_+3A_hgap">hgap</code></td>
<td>
<p>Real scalar, the minimum horizontal gap between vertices in the
same layer.</p>
</td></tr>
<tr><td><code id="layout_as_bipartite_+3A_vgap">vgap</code></td>
<td>
<p>Real scalar, the distance between the two layers.</p>
</td></tr>
<tr><td><code id="layout_as_bipartite_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer scalar, the maximum number of iterations in the
crossing minimization stage. 100 is a reasonable default; if you feel that
you have too many edge crossings, increase this.</p>
</td></tr>
<tr><td><code id="layout_as_bipartite_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>layout_as_bipartite()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The layout is created by first placing the vertices in two rows, according
to their types. Then the positions within the rows are optimized to minimize
edge crossings, using the Sugiyama algorithm (see
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama()</a></code>).
</p>


<h3>Value</h3>

<p>A matrix with two columns and as many rows as the number of vertices
in the input graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama()</a></code>
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Random bipartite graph
inc &lt;- matrix(sample(0:1, 50, replace = TRUE, prob = c(2, 1)), 10, 5)
g &lt;- graph_from_biadjacency_matrix(inc)
plot(g,
  layout = layout_as_bipartite,
  vertex.color = c("green", "cyan")[V(g)$type + 1]
)

# Two columns
g %&gt;%
  add_layout_(as_bipartite()) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='layout_as_star'>Generate coordinates to place the vertices of a graph in a star-shape</h2><span id='topic+layout_as_star'></span><span id='topic+as_star'></span>

<h3>Description</h3>

<p>A simple layout generator, that places one vertex in the center of a circle
and the rest of the vertices equidistantly on the perimeter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_as_star(graph, center = V(graph)[1], order = NULL)

as_star(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_as_star_+3A_graph">graph</code></td>
<td>
<p>The graph to layout.</p>
</td></tr>
<tr><td><code id="layout_as_star_+3A_center">center</code></td>
<td>
<p>The id of the vertex to put in the center. By default it is
the first vertex.</p>
</td></tr>
<tr><td><code id="layout_as_star_+3A_order">order</code></td>
<td>
<p>Numeric vector, the order of the vertices along the perimeter.
The default ordering is given by the vertex ids.</p>
</td></tr>
<tr><td><code id="layout_as_star_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>layout_as_star()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to choose the vertex that will be in the center, and the
order of the vertices can be also given.
</p>


<h3>Value</h3>

<p>A matrix with two columns and as many rows as the number of vertices
in the input graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout">layout()</a></code> and <code><a href="#topic+layout.drl">layout.drl()</a></code> for other layout
algorithms, <code><a href="#topic+plot.igraph">plot.igraph()</a></code> and <code><a href="#topic+tkplot">tkplot()</a></code> on how to
plot graphs and <code><a href="#topic+star">star()</a></code> on how to create ring graphs.
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_star(10)
layout_as_star(g)

## Alternative form
layout_(g, as_star())
</code></pre>

<hr>
<h2 id='layout_as_tree'>The Reingold-Tilford graph layout algorithm</h2><span id='topic+layout_as_tree'></span><span id='topic+as_tree'></span>

<h3>Description</h3>

<p>A tree-like layout, it is perfect for trees, acceptable for graphs with not
too many cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_as_tree(
  graph,
  root = numeric(),
  circular = FALSE,
  rootlevel = numeric(),
  mode = c("out", "in", "all"),
  flip.y = TRUE
)

as_tree(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_as_tree_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout_as_tree_+3A_root">root</code></td>
<td>
<p>The index of the root vertex or root vertices.  If this is a
non-empty vector then the supplied vertex ids are used as the roots of the
trees (or a single tree if the graph is connected).  If it is an empty
vector, then the root vertices are automatically calculated based on
topological sorting, performed with the opposite mode than the <code>mode</code>
argument. After the vertices have been sorted, one is selected from each
component.</p>
</td></tr>
<tr><td><code id="layout_as_tree_+3A_circular">circular</code></td>
<td>
<p>Logical scalar, whether to plot the tree in a circular
fashion. Defaults to <code>FALSE</code>, so the tree branches are going bottom-up
(or top-down, see the <code>flip.y</code> argument.</p>
</td></tr>
<tr><td><code id="layout_as_tree_+3A_rootlevel">rootlevel</code></td>
<td>
<p>This argument can be useful when drawing forests which are
not trees (i.e. they are unconnected and have tree components). It specifies
the level of the root vertices for every tree in the forest. It is only
considered if the <code>roots</code> argument is not an empty vector.</p>
</td></tr>
<tr><td><code id="layout_as_tree_+3A_mode">mode</code></td>
<td>
<p>Specifies which edges to consider when building the tree.  If it
is &lsquo;out&rsquo;, then only the outgoing, if it is &lsquo;in&rsquo;, then only the
incoming edges of a parent are considered. If it is &lsquo;all&rsquo; then all
edges are used (this was the behavior in igraph 0.5 and before). This
parameter also influences how the root vertices are calculated, if they are
not given. See the <code>roots</code> parameter.</p>
</td></tr>
<tr><td><code id="layout_as_tree_+3A_flip.y">flip.y</code></td>
<td>
<p>Logical scalar, whether to flip the &lsquo;y&rsquo; coordinates.
The default is flipping because that puts the root vertex on the top.</p>
</td></tr>
<tr><td><code id="layout_as_tree_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_as_tree()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arranges the nodes in a tree where the given node is used as the root.  The
tree is directed downwards and the parents are centered above its children.
For the exact algorithm, the reference below.
</p>
<p>If the given graph is not a tree, a breadth-first search is executed first
to obtain a possible spanning tree.
</p>


<h3>Value</h3>

<p>A numeric matrix with two columns, and one row for each vertex.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Reingold, E and Tilford, J (1981). Tidier drawing of trees.
<em>IEEE Trans. on Softw. Eng.</em>, SE-7(2):223&ndash;228.
</p>


<h3>See Also</h3>

<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tree &lt;- make_tree(20, 3)
plot(tree, layout = layout_as_tree)
plot(tree, layout = layout_as_tree(tree, flip.y = FALSE))
plot(tree, layout = layout_as_tree(tree, circular = TRUE))

tree2 &lt;- make_tree(10, 3) + make_tree(10, 2)
plot(tree2, layout = layout_as_tree)
plot(tree2, layout = layout_as_tree(tree2,
  root = c(1, 11),
  rootlevel = c(2, 1)
))
</code></pre>

<hr>
<h2 id='layout_in_circle'>Graph layout with vertices on a circle.</h2><span id='topic+layout_in_circle'></span><span id='topic+in_circle'></span>

<h3>Description</h3>

<p>Place vertices on a circle, in the order of their vertex ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_in_circle(graph, order = V(graph))

in_circle(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_in_circle_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout_in_circle_+3A_order">order</code></td>
<td>
<p>The vertices to place on the circle, in the order of their
desired placement. Vertices that are not included here will be placed at
(0,0).</p>
</td></tr>
<tr><td><code id="layout_in_circle_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_in_circle()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you want to order the vertices differently, then permute them using the
<code><a href="#topic+permute">permute()</a></code> function.
</p>


<h3>Value</h3>

<p>A numeric matrix with two columns, and one row for each vertex.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Place vertices on a circle, order them according to their
## community
library(igraphdata)
data(karate)
karate_groups &lt;- cluster_optimal(karate)
coords &lt;- layout_in_circle(karate,
  order =
    order(membership(karate_groups))
)
V(karate)$label &lt;- sub("Actor ", "", V(karate)$name)
V(karate)$label.color &lt;- membership(karate_groups)
V(karate)$shape &lt;- "none"
plot(karate, layout = coords)

</code></pre>

<hr>
<h2 id='layout_nicely'>Choose an appropriate graph layout algorithm automatically</h2><span id='topic+layout_nicely'></span><span id='topic+nicely'></span>

<h3>Description</h3>

<p>This function tries to choose an appropriate graph layout algorithm for the
graph, automatically, based on a simple algorithm. See details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_nicely(graph, dim = 2, ...)

nicely(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_nicely_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="layout_nicely_+3A_dim">dim</code></td>
<td>
<p>Dimensions, should be 2 or 3.</p>
</td></tr>
<tr><td><code id="layout_nicely_+3A_...">...</code></td>
<td>
<p>For <code>layout_nicely()</code> the extra arguments are passed to
the real layout function. For <code>nicely()</code> all argument are passed to
<code>layout_nicely()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>layout_nicely()</code> tries to choose an appropriate layout function for the
supplied graph, and uses that to generate the layout. The current
implementation works like this: </p>
 <ol>
<li><p> If the graph has a graph
attribute called &lsquo;layout&rsquo;, then this is used. If this attribute is an
R function, then it is called, with the graph and any other extra arguments.
</p>
</li>
<li><p> Otherwise, if the graph has vertex attributes called &lsquo;x&rsquo; and
&lsquo;y&rsquo;, then these are used as coordinates. If the graph has an
additional &lsquo;z&rsquo; vertex attribute, that is also used.  </p>
</li>
<li><p> Otherwise,
if the graph is connected and has less than 1000 vertices, the
Fruchterman-Reingold layout is used, by calling <code>layout_with_fr()</code>.
</p>
</li>
<li><p> Otherwise the DrL layout is used, <code>layout_with_drl()</code> is called.  </p>
</li></ol>

<p>In layout algorithm implementations, an argument named &lsquo;weights&rsquo; is
typically used to specify the weights of the edges if the layout algorithm
supports them. In this case, omitting &lsquo;weights&rsquo; or setting it to
<code>NULL</code> will make igraph use the 'weight' edge attribute from the graph
if it is present. However, most layout algorithms do not support non-positive
weights, so <code>layout_nicely()</code> would fail if you simply called it on
your graph without specifying explicit weights and the weights happened to
include non-positive numbers. We strive to ensure that <code>layout_nicely()</code>
works out-of-the-box for most graphs, so the rule is that if you omit
&lsquo;weights&rsquo; or set it to <code>NULL</code> and <code>layout_nicely()</code> would
end up calling <code>layout_with_fr()</code> or <code>layout_with_drl()</code>, we do not
forward the weights to these functions and issue a warning about this. You
can use <code>weights = NA</code> to silence the warning.
</p>


<h3>Value</h3>

<p>A numeric matrix with two or three columns.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.igraph">plot.igraph()</a></code>
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>

<hr>
<h2 id='layout_on_grid'>Simple grid layout</h2><span id='topic+layout_on_grid'></span><span id='topic+layout.grid.3d'></span><span id='topic+on_grid'></span>

<h3>Description</h3>

<p>This layout places vertices on a rectangular grid, in two or three
dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_on_grid(graph, width = 0, height = 0, dim = 2)

on_grid(...)

layout.grid.3d(graph, width = 0, height = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_on_grid_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout_on_grid_+3A_width">width</code></td>
<td>
<p>The number of vertices in a single row of the grid. If this is
zero or negative, then for 2d layouts the width of the grid will be the
square root of the number of vertices in the graph, rounded up to the next
integer. Similarly, it will be the cube root for 3d layouts.</p>
</td></tr>
<tr><td><code id="layout_on_grid_+3A_height">height</code></td>
<td>
<p>The number of vertices in a single column of the grid, for
three dimensional layouts. If this is zero or negative, then it is
determinted automatically.</p>
</td></tr>
<tr><td><code id="layout_on_grid_+3A_dim">dim</code></td>
<td>
<p>Two or three. Whether to make 2d or a 3d layout.</p>
</td></tr>
<tr><td><code id="layout_on_grid_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_on_grid()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function places the vertices on a simple rectangular grid, one after the
other. If you want to change the order of the vertices, then see the
<code><a href="#topic+permute">permute()</a></code> function.
</p>


<h3>Value</h3>

<p>A two-column or three-column matrix.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout">layout()</a></code> for other layout generators
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_lattice(c(3, 3))
layout_on_grid(g)

g2 &lt;- make_lattice(c(3, 3, 3))
layout_on_grid(g2, dim = 3)

plot(g, layout = layout_on_grid)
if (interactive() &amp;&amp; requireNamespace("rgl", quietly = TRUE)) {
  rglplot(g, layout = layout_on_grid(g, dim = 3))
}
</code></pre>

<hr>
<h2 id='layout_on_sphere'>Graph layout with vertices on the surface of a sphere</h2><span id='topic+layout_on_sphere'></span><span id='topic+on_sphere'></span>

<h3>Description</h3>

<p>Place vertices on a sphere, approximately uniformly, in the order of their
vertex ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_on_sphere(graph)

on_sphere(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_on_sphere_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout_on_sphere_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_on_sphere()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>layout_on_sphere()</code> places the vertices (approximately) uniformly on the
surface of a sphere, this is thus a 3d layout. It is not clear however what
&ldquo;uniformly on a sphere&rdquo; means.
</p>
<p>If you want to order the vertices differently, then permute them using the
<code><a href="#topic+permute">permute()</a></code> function.
</p>


<h3>Value</h3>

<p>A numeric matrix with three columns, and one row for each vertex.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>

<hr>
<h2 id='layout_randomly'>Randomly place vertices on a plane or in 3d space</h2><span id='topic+layout_randomly'></span><span id='topic+randomly'></span>

<h3>Description</h3>

<p>This function uniformly randomly places the vertices of the graph in two or
three dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_randomly(graph, dim = 2)

randomly(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_randomly_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout_randomly_+3A_dim">dim</code></td>
<td>
<p>Integer scalar, the dimension of the space to use. It must be 2
or 3.</p>
</td></tr>
<tr><td><code id="layout_randomly_+3A_...">...</code></td>
<td>
<p>Parameters to pass to <code>layout_randomly()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Randomly places vertices on a [-1,1] square (in 2d) or in a cube (in 3d). It
is probably a useless layout, but it can use as a starting point for other
layout generators.
</p>


<h3>Value</h3>

<p>A numeric matrix with two or three columns.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>

<hr>
<h2 id='layout_with_dh'>The Davidson-Harel layout algorithm</h2><span id='topic+layout_with_dh'></span><span id='topic+with_dh'></span>

<h3>Description</h3>

<p>Place vertices of a graph on the plane, according to the simulated annealing
algorithm by Davidson and Harel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_dh(
  graph,
  coords = NULL,
  maxiter = 10,
  fineiter = max(10, log2(vcount(graph))),
  cool.fact = 0.75,
  weight.node.dist = 1,
  weight.border = 0,
  weight.edge.lengths = edge_density(graph)/10,
  weight.edge.crossings = 1 - sqrt(edge_density(graph)),
  weight.node.edge.dist = 0.2 * (1 - edge_density(graph))
)

with_dh(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_dh_+3A_graph">graph</code></td>
<td>
<p>The graph to lay out. Edge directions are ignored.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_coords">coords</code></td>
<td>
<p>Optional starting positions for the vertices. If this argument
is not <code>NULL</code> then it should be an appropriate matrix of starting
coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_maxiter">maxiter</code></td>
<td>
<p>Number of iterations to perform in the first phase.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_fineiter">fineiter</code></td>
<td>
<p>Number of iterations in the fine tuning phase.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_cool.fact">cool.fact</code></td>
<td>
<p>Cooling factor.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_weight.node.dist">weight.node.dist</code></td>
<td>
<p>Weight for the node-node distances component of the
energy function.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_weight.border">weight.border</code></td>
<td>
<p>Weight for the distance from the border component of
the energy function. It can be set to zero, if vertices are allowed to sit
on the border.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_weight.edge.lengths">weight.edge.lengths</code></td>
<td>
<p>Weight for the edge length component of the
energy function.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_weight.edge.crossings">weight.edge.crossings</code></td>
<td>
<p>Weight for the edge crossing component of the
energy function.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_weight.node.edge.dist">weight.node.edge.dist</code></td>
<td>
<p>Weight for the node-edge distance component of
the energy function.</p>
</td></tr>
<tr><td><code id="layout_with_dh_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_dh()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the algorithm by Davidson and Harel, see Ron
Davidson, David Harel: Drawing Graphs Nicely Using Simulated Annealing. ACM
Transactions on Graphics 15(4), pp. 301-331, 1996.
</p>
<p>The algorithm uses simulated annealing and a sophisticated energy function,
which is unfortunately hard to parameterize for different graphs. The
original publication did not disclose any parameter values, and the ones
below were determined by experimentation.
</p>
<p>The algorithm consists of two phases, an annealing phase, and a fine-tuning
phase. There is no simulated annealing in the second phase.
</p>
<p>Our implementation tries to follow the original publication, as much as
possible. The only major difference is that coordinates are explicitly kept
within the bounds of the rectangle of the layout.
</p>


<h3>Value</h3>

<p>A two- or three-column matrix, each row giving the coordinates of a
vertex, according to the ids of the vertex ids.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Ron Davidson, David Harel: Drawing Graphs Nicely Using Simulated
Annealing. <em>ACM Transactions on Graphics</em> 15(4), pp. 301-331, 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout_with_fr">layout_with_fr()</a></code>,
<code><a href="#topic+layout_with_kk">layout_with_kk()</a></code> for other layout algorithms.
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
## Figures from the paper
g_1b &lt;- make_star(19, mode = "undirected") + path(c(2:19, 2)) +
  path(c(seq(2, 18, by = 2), 2))
plot(g_1b, layout = layout_with_dh)

g_2 &lt;- make_lattice(c(8, 3)) + edges(1, 8, 9, 16, 17, 24)
plot(g_2, layout = layout_with_dh)

g_3 &lt;- make_empty_graph(n = 70)
plot(g_3, layout = layout_with_dh)

g_4 &lt;- make_empty_graph(n = 70, directed = FALSE) + edges(1:70)
plot(g_4, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)

g_5a &lt;- make_ring(24)
plot(g_5a, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)

g_5b &lt;- make_ring(40)
plot(g_5b, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)

g_6 &lt;- make_lattice(c(2, 2, 2))
plot(g_6, layout = layout_with_dh)

g_7 &lt;- graph_from_literal(1:3:5 -- 2:4:6)
plot(g_7, layout = layout_with_dh, vertex.label = V(g_7)$name)

g_8 &lt;- make_ring(5) + make_ring(10) + make_ring(5) +
  edges(
    1, 6, 2, 8, 3, 10, 4, 12, 5, 14,
    7, 16, 9, 17, 11, 18, 13, 19, 15, 20
  )
plot(g_8, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)

g_9 &lt;- make_lattice(c(3, 2, 2))
plot(g_9, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)

g_10 &lt;- make_lattice(c(6, 6))
plot(g_10, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)

g_11a &lt;- make_tree(31, 2, mode = "undirected")
plot(g_11a, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)

g_11b &lt;- make_tree(21, 4, mode = "undirected")
plot(g_11b, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)

g_12 &lt;- make_empty_graph(n = 37, directed = FALSE) +
  path(1:5, 10, 22, 31, 37:33, 27, 16, 6, 1) + path(6, 7, 11, 9, 10) + path(16:22) +
  path(27:31) + path(2, 7, 18, 28, 34) + path(3, 8, 11, 19, 29, 32, 35) +
  path(4, 9, 20, 30, 36) + path(1, 7, 12, 14, 19, 24, 26, 30, 37) +
  path(5, 9, 13, 15, 19, 23, 25, 28, 33) + path(3, 12, 16, 25, 35, 26, 22, 13, 3)
plot(g_12, layout = layout_with_dh, vertex.size = 5, vertex.label = NA)
</code></pre>

<hr>
<h2 id='layout_with_drl'>The DrL graph layout generator</h2><span id='topic+layout_with_drl'></span><span id='topic+drl_defaults'></span><span id='topic+igraph.drl.coarsen'></span><span id='topic+igraph.drl.coarsest'></span><span id='topic+igraph.drl.default'></span><span id='topic+igraph.drl.final'></span><span id='topic+igraph.drl.refine'></span><span id='topic+with_drl'></span>

<h3>Description</h3>

<p>DrL is a force-directed graph layout toolbox focused on real-world
large-scale graphs, developed by Shawn Martin and colleagues at Sandia
National Laboratories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_drl(
  graph,
  use.seed = FALSE,
  seed = matrix(runif(vcount(graph) * 2), ncol = 2),
  options = drl_defaults$default,
  weights = NULL,
  dim = 2
)

with_drl(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_drl_+3A_graph">graph</code></td>
<td>
<p>The input graph, in can be directed or undirected.</p>
</td></tr>
<tr><td><code id="layout_with_drl_+3A_use.seed">use.seed</code></td>
<td>
<p>Logical scalar, whether to use the coordinates given in the
<code>seed</code> argument as a starting point.</p>
</td></tr>
<tr><td><code id="layout_with_drl_+3A_seed">seed</code></td>
<td>
<p>A matrix with two columns, the starting coordinates for the
vertices is <code>use.seed</code> is <code>TRUE</code>. It is ignored otherwise.</p>
</td></tr>
<tr><td><code id="layout_with_drl_+3A_options">options</code></td>
<td>
<p>Options for the layout generator, a named list. See details
below.</p>
</td></tr>
<tr><td><code id="layout_with_drl_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for the layout. Larger edge weights
correspond to stronger connections.</p>
</td></tr>
<tr><td><code id="layout_with_drl_+3A_dim">dim</code></td>
<td>
<p>Either &lsquo;2&rsquo; or &lsquo;3&rsquo;, it specifies whether we want a
two dimensional or a three dimensional layout. Note that because of the
nature of the DrL algorithm, the three dimensional layout takes
significantly longer to compute.</p>
</td></tr>
<tr><td><code id="layout_with_drl_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_drl()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the force-directed DrL layout generator.
</p>
<p>The generator has the following parameters: </p>
 <dl>
<dt>edge.cut</dt><dd><p>Edge
cutting is done in the late stages of the algorithm in order to achieve less
dense layouts.  Edges are cut if there is a lot of stress on them (a large
value in the objective function sum). The edge cutting parameter is a value
between 0 and 1 with 0 representing no edge cutting and 1 representing
maximal edge cutting. </p>
</dd> <dt>init.iterations</dt><dd><p>Number of iterations in the
first phase.</p>
</dd> <dt>init.temperature</dt><dd><p>Start temperature, first phase.</p>
</dd>
<dt>init.attraction</dt><dd><p>Attraction, first phase.</p>
</dd>
<dt>init.damping.mult</dt><dd><p>Damping, first phase.</p>
</dd>
<dt>liquid.iterations</dt><dd><p>Number of iterations, liquid phase.</p>
</dd>
<dt>liquid.temperature</dt><dd><p>Start temperature, liquid phase.</p>
</dd>
<dt>liquid.attraction</dt><dd><p>Attraction, liquid phase.</p>
</dd>
<dt>liquid.damping.mult</dt><dd><p>Damping, liquid phase.</p>
</dd>
<dt>expansion.iterations</dt><dd><p>Number of iterations, expansion phase.</p>
</dd>
<dt>expansion.temperature</dt><dd><p>Start temperature, expansion phase.</p>
</dd>
<dt>expansion.attraction</dt><dd><p>Attraction, expansion phase.</p>
</dd>
<dt>expansion.damping.mult</dt><dd><p>Damping, expansion phase.</p>
</dd>
<dt>cooldown.iterations</dt><dd><p>Number of iterations, cooldown phase.</p>
</dd>
<dt>cooldown.temperature</dt><dd><p>Start temperature, cooldown phase.</p>
</dd>
<dt>cooldown.attraction</dt><dd><p>Attraction, cooldown phase.</p>
</dd>
<dt>cooldown.damping.mult</dt><dd><p>Damping, cooldown phase.</p>
</dd>
<dt>crunch.iterations</dt><dd><p>Number of iterations, crunch phase.</p>
</dd>
<dt>crunch.temperature</dt><dd><p>Start temperature, crunch phase.</p>
</dd>
<dt>crunch.attraction</dt><dd><p>Attraction, crunch phase.</p>
</dd>
<dt>crunch.damping.mult</dt><dd><p>Damping, crunch phase.</p>
</dd>
<dt>simmer.iterations</dt><dd><p>Number of iterations, simmer phase.</p>
</dd>
<dt>simmer.temperature</dt><dd><p>Start temperature, simmer phase.</p>
</dd>
<dt>simmer.attraction</dt><dd><p>Attraction, simmer phase.</p>
</dd>
<dt>simmer.damping.mult</dt><dd><p>Damping, simmer phase.</p>
</dd>
</dl>
<p>There are five pre-defined parameter settings as well, these are called
<code>drl_defaults$default</code>, <code>drl_defaults$coarsen</code>,
<code>drl_defaults$coarsest</code>, <code>drl_defaults$refine</code> and
<code>drl_defaults$final</code>.  
</p>


<h3>Value</h3>

<p>A numeric matrix with two columns.
</p>


<h3>Author(s)</h3>

<p>Shawn Martin (<a href="http://www.cs.otago.ac.nz/homepages/smartin/">http://www.cs.otago.ac.nz/homepages/smartin/</a>)
and Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the R/igraph interface
and the three dimensional version.
</p>


<h3>References</h3>

<p>See the following technical report: Martin, S., Brown, W.M.,
Klavans, R., Boyack, K.W., DrL: Distributed Recursive (Graph) Layout. SAND
Reports, 2008. 2936: p. 1-10.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout">layout()</a></code> for other layout generators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- as.undirected(sample_pa(100, m = 1))
l &lt;- layout_with_drl(g, options = list(simmer.attraction = 0))
plot(g, layout = l, vertex.size = 3, vertex.label = NA)

</code></pre>

<hr>
<h2 id='layout_with_fr'>The Fruchterman-Reingold layout algorithm</h2><span id='topic+layout_with_fr'></span><span id='topic+with_fr'></span>

<h3>Description</h3>

<p>Place vertices on the plane using the force-directed layout algorithm by
Fruchterman and Reingold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_fr(
  graph,
  coords = NULL,
  dim = 2,
  niter = 500,
  start.temp = sqrt(vcount(graph)),
  grid = c("auto", "grid", "nogrid"),
  weights = NULL,
  minx = NULL,
  maxx = NULL,
  miny = NULL,
  maxy = NULL,
  minz = NULL,
  maxz = NULL,
  coolexp,
  maxdelta,
  area,
  repulserad,
  maxiter
)

with_fr(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_fr_+3A_graph">graph</code></td>
<td>
<p>The graph to lay out. Edge directions are ignored.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_coords">coords</code></td>
<td>
<p>Optional starting positions for the vertices. If this argument
is not <code>NULL</code> then it should be an appropriate matrix of starting
coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_dim">dim</code></td>
<td>
<p>Integer scalar, 2 or 3, the dimension of the layout.  Two
dimensional layouts are places on a plane, three dimensional ones in the 3d
space.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_niter">niter</code></td>
<td>
<p>Integer scalar, the number of iterations to perform.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_start.temp">start.temp</code></td>
<td>
<p>Real scalar, the start temperature. This is the maximum
amount of movement alloved along one axis, within one step, for a vertex.
Currently it is decreased linearly to zero during the iteration.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_grid">grid</code></td>
<td>
<p>Character scalar, whether to use the faster, but less accurate
grid based implementation of the algorithm. By default (&ldquo;auto&rdquo;), the
grid-based implementation is used if the graph has more than one thousand
vertices.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_weights">weights</code></td>
<td>
<p>A vector giving edge weights. The <code>weight</code> edge
attribute is used by default, if present. If weights are given, then the
attraction along the edges will be multiplied by the given edge weights.
This places vertices connected with a highly weighted edge closer to
each other. Weights must be positive.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_minx">minx</code></td>
<td>
<p>If not <code>NULL</code>, then it must be a numeric vector that gives
lower boundaries for the &lsquo;x&rsquo; coordinates of the vertices. The length
of the vector must match the number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_maxx">maxx</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the upper boundaries.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_miny">miny</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the lower boundaries of the
&lsquo;y&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_maxy">maxy</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the upper boundaries of the
&lsquo;y&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_minz">minz</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the lower boundaries of the
&lsquo;z&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_maxz">maxz</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the upper boundaries of the
&lsquo;z&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_coolexp">coolexp</code>, <code id="layout_with_fr_+3A_maxdelta">maxdelta</code>, <code id="layout_with_fr_+3A_area">area</code>, <code id="layout_with_fr_+3A_repulserad">repulserad</code></td>
<td>
<p>These arguments are not supported
from igraph version 0.8.0 and are ignored (with a warning).</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_maxiter">maxiter</code></td>
<td>
<p>A deprecated synonym of <code>niter</code>, for compatibility.</p>
</td></tr>
<tr><td><code id="layout_with_fr_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_fr()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the referenced paper below for the details of the algorithm.
</p>
<p>This function was rewritten from scratch in igraph version 0.8.0.
</p>


<h3>Value</h3>

<p>A two- or three-column matrix, each row giving the coordinates of a
vertex, according to the ids of the vertex ids.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Fruchterman, T.M.J. and Reingold, E.M. (1991). Graph Drawing by
Force-directed Placement. <em>Software - Practice and Experience</em>,
21(11):1129-1164.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout_with_drl">layout_with_drl()</a></code>, <code><a href="#topic+layout_with_kk">layout_with_kk()</a></code> for
other layout algorithms.
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fixing ego
g &lt;- sample_pa(20, m = 2)
minC &lt;- rep(-Inf, vcount(g))
maxC &lt;- rep(Inf, vcount(g))
minC[1] &lt;- maxC[1] &lt;- 0
co &lt;- layout_with_fr(g,
  minx = minC, maxx = maxC,
  miny = minC, maxy = maxC
)
co[1, ]
plot(g,
  layout = co, vertex.size = 30, edge.arrow.size = 0.2,
  vertex.label = c("ego", rep("", vcount(g) - 1)), rescale = FALSE,
  xlim = range(co[, 1]), ylim = range(co[, 2]), vertex.label.dist = 0,
  vertex.label.color = "red"
)
axis(1)
axis(2)

</code></pre>

<hr>
<h2 id='layout_with_gem'>The GEM layout algorithm</h2><span id='topic+layout_with_gem'></span><span id='topic+with_gem'></span>

<h3>Description</h3>

<p>Place vertices on the plane using the GEM force-directed layout algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_gem(
  graph,
  coords = NULL,
  maxiter = 40 * vcount(graph)^2,
  temp.max = max(vcount(graph), 1),
  temp.min = 1/10,
  temp.init = sqrt(max(vcount(graph), 1))
)

with_gem(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_gem_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions are ignored.</p>
</td></tr>
<tr><td><code id="layout_with_gem_+3A_coords">coords</code></td>
<td>
<p>If not <code>NULL</code>, then the starting coordinates should be
given here, in a two or three column matrix, depending on the <code>dim</code>
argument.</p>
</td></tr>
<tr><td><code id="layout_with_gem_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations to perform. Updating a
single vertex counts as an iteration.  A reasonable default is 40 * n * n,
where n is the number of vertices. The original paper suggests 4 * n * n,
but this usually only works if the other parameters are set up carefully.</p>
</td></tr>
<tr><td><code id="layout_with_gem_+3A_temp.max">temp.max</code></td>
<td>
<p>The maximum allowed local temperature. A reasonable default
is the number of vertices.</p>
</td></tr>
<tr><td><code id="layout_with_gem_+3A_temp.min">temp.min</code></td>
<td>
<p>The global temperature at which the algorithm terminates
(even before reaching <code>maxiter</code> iterations). A reasonable default is
1/10.</p>
</td></tr>
<tr><td><code id="layout_with_gem_+3A_temp.init">temp.init</code></td>
<td>
<p>Initial local temperature of all vertices. A reasonable
default is the square root of the number of vertices.</p>
</td></tr>
<tr><td><code id="layout_with_gem_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_gem()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the referenced paper below for the details of the algorithm.
</p>


<h3>Value</h3>

<p>A numeric matrix with two columns, and as many rows as the number of
vertices.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Arne Frick, Andreas Ludwig, Heiko Mehldau: A Fast Adaptive
Layout Algorithm for Undirected Graphs, <em>Proc. Graph Drawing 1994</em>,
LNCS 894, pp. 388-403, 1995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout_with_fr">layout_with_fr()</a></code>,
<code><a href="#topic+plot.igraph">plot.igraph()</a></code>, <code><a href="#topic+tkplot">tkplot()</a></code>
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(42)
g &lt;- make_ring(10)
plot(g, layout = layout_with_gem)

</code></pre>

<hr>
<h2 id='layout_with_graphopt'>The graphopt layout algorithm</h2><span id='topic+layout_with_graphopt'></span><span id='topic+with_graphopt'></span>

<h3>Description</h3>

<p>A force-directed layout algorithm, that scales relatively well to large
graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_graphopt(
  graph,
  start = NULL,
  niter = 500,
  charge = 0.001,
  mass = 30,
  spring.length = 0,
  spring.constant = 1,
  max.sa.movement = 5
)

with_graphopt(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_graphopt_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout_with_graphopt_+3A_start">start</code></td>
<td>
<p>If given, then it should be a matrix with two columns and one
line for each vertex. This matrix will be used as starting positions for the
algorithm. If not given, then a random starting matrix is used.</p>
</td></tr>
<tr><td><code id="layout_with_graphopt_+3A_niter">niter</code></td>
<td>
<p>Integer scalar, the number of iterations to perform.  Should be
a couple of hundred in general. If you have a large graph then you might
want to only do a few iterations and then check the result. If it is not
good enough you can feed it in again in the <code>start</code> argument. The
default value is 500.</p>
</td></tr>
<tr><td><code id="layout_with_graphopt_+3A_charge">charge</code></td>
<td>
<p>The charge of the vertices, used to calculate electric
repulsion. The default is 0.001.</p>
</td></tr>
<tr><td><code id="layout_with_graphopt_+3A_mass">mass</code></td>
<td>
<p>The mass of the vertices, used for the spring forces. The
default is 30.</p>
</td></tr>
<tr><td><code id="layout_with_graphopt_+3A_spring.length">spring.length</code></td>
<td>
<p>The length of the springs, an integer number. The
default value is zero.</p>
</td></tr>
<tr><td><code id="layout_with_graphopt_+3A_spring.constant">spring.constant</code></td>
<td>
<p>The spring constant, the default value is one.</p>
</td></tr>
<tr><td><code id="layout_with_graphopt_+3A_max.sa.movement">max.sa.movement</code></td>
<td>
<p>Real constant, it gives the maximum amount of
movement allowed in a single step along a single axis. The default value is
5.</p>
</td></tr>
<tr><td><code id="layout_with_graphopt_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_graphopt()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>layout_with_graphopt()</code> is a port of the graphopt layout algorithm by Michael
Schmuhl. graphopt version 0.4.1 was rewritten in C and the support for
layers was removed (might be added later) and a code was a bit reorganized
to avoid some unnecessary steps is the node charge (see below) is zero.
</p>
<p>graphopt uses physical analogies for defining attracting and repelling
forces among the vertices and then the physical system is simulated until it
reaches an equilibrium. (There is no simulated annealing or anything like
that, so a stable fixed point is not guaranteed.)
</p>


<h3>Value</h3>

<p>A numeric matrix with two columns, and a row for each vertex.
</p>


<h3>Author(s)</h3>

<p>Michael Schmuhl for the original graphopt code, rewritten and
wrapped by Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>.
</p>


<h3>See Also</h3>

<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>

<hr>
<h2 id='layout_with_kk'>The Kamada-Kawai layout algorithm</h2><span id='topic+layout_with_kk'></span><span id='topic+with_kk'></span>

<h3>Description</h3>

<p>Place the vertices on the plane, or in 3D space, based on a physical
model of springs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_kk(
  graph,
  coords = NULL,
  dim = 2,
  maxiter = 50 * vcount(graph),
  epsilon = 0,
  kkconst = max(vcount(graph), 1),
  weights = NULL,
  minx = NULL,
  maxx = NULL,
  miny = NULL,
  maxy = NULL,
  minz = NULL,
  maxz = NULL,
  niter,
  sigma,
  initemp,
  coolexp,
  start
)

with_kk(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_kk_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions are ignored.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_coords">coords</code></td>
<td>
<p>If not <code>NULL</code>, then the starting coordinates should be
given here, in a two or three column matrix, depending on the <code>dim</code>
argument.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_dim">dim</code></td>
<td>
<p>Integer scalar, 2 or 3, the dimension of the layout.  Two
dimensional layouts are places on a plane, three dimensional ones in the 3d
space.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations to perform. The algorithm
might terminate earlier, see the <code>epsilon</code> argument.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric scalar, the algorithm terminates, if the maximal
delta is less than this. (See the reference below for what delta means.) If
you set this to zero, then the function always performs <code>maxiter</code>
iterations.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_kkconst">kkconst</code></td>
<td>
<p>Numeric scalar, the Kamada-Kawai vertex attraction constant.
Typical (and default) value is the number of vertices.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_weights">weights</code></td>
<td>
<p>Edge weights, larger values will result longer edges.
Note that this is opposite to <code><a href="#topic+layout_with_fr">layout_with_fr()</a></code>. Weights must
be positive.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_minx">minx</code></td>
<td>
<p>If not <code>NULL</code>, then it must be a numeric vector that gives
lower boundaries for the &lsquo;x&rsquo; coordinates of the vertices. The length
of the vector must match the number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_maxx">maxx</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the upper boundaries.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_miny">miny</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the lower boundaries of the
&lsquo;y&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_maxy">maxy</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the upper boundaries of the
&lsquo;y&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_minz">minz</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the lower boundaries of the
&lsquo;z&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_maxz">maxz</code></td>
<td>
<p>Similar to <code>minx</code>, but gives the upper boundaries of the
&lsquo;z&rsquo; coordinates.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_niter">niter</code>, <code id="layout_with_kk_+3A_sigma">sigma</code>, <code id="layout_with_kk_+3A_initemp">initemp</code>, <code id="layout_with_kk_+3A_coolexp">coolexp</code></td>
<td>
<p>These arguments are not supported from
igraph version 0.8.0 and are ignored (with a warning).</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_start">start</code></td>
<td>
<p>Deprecated synonym for <code>coords</code>, for compatibility.</p>
</td></tr>
<tr><td><code id="layout_with_kk_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_kk()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the referenced paper below for the details of the algorithm.
</p>
<p>This function was rewritten from scratch in igraph version 0.8.0 and it
follows truthfully the original publication by Kamada and Kawai now.
</p>


<h3>Value</h3>

<p>A numeric matrix with two (dim=2) or three (dim=3) columns, and as
many rows as the number of vertices, the x, y and potentially z coordinates
of the vertices.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Kamada, T. and Kawai, S.: An Algorithm for Drawing General
Undirected Graphs. <em>Information Processing Letters</em>, 31/1, 7&ndash;15, 1989.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout_with_drl">layout_with_drl()</a></code>, <code><a href="#topic+plot.igraph">plot.igraph()</a></code>,
<code><a href="#topic+tkplot">tkplot()</a></code>
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
E(g)$weight &lt;- rep(1:2, length.out = ecount(g))
plot(g, layout = layout_with_kk, edge.label = E(g)$weight)

</code></pre>

<hr>
<h2 id='layout_with_lgl'>Large Graph Layout</h2><span id='topic+layout_with_lgl'></span><span id='topic+with_lgl'></span>

<h3>Description</h3>

<p>A layout generator for larger graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_lgl(
  graph,
  maxiter = 150,
  maxdelta = vcount(graph),
  area = vcount(graph)^2,
  coolexp = 1.5,
  repulserad = area * vcount(graph),
  cellsize = sqrt(sqrt(area)),
  root = NULL
)

with_lgl(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_lgl_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="layout_with_lgl_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations to perform (150).</p>
</td></tr>
<tr><td><code id="layout_with_lgl_+3A_maxdelta">maxdelta</code></td>
<td>
<p>The maximum change for a vertex during an iteration (the
number of vertices).</p>
</td></tr>
<tr><td><code id="layout_with_lgl_+3A_area">area</code></td>
<td>
<p>The area of the surface on which the vertices are placed (square
of the number of vertices).</p>
</td></tr>
<tr><td><code id="layout_with_lgl_+3A_coolexp">coolexp</code></td>
<td>
<p>The cooling exponent of the simulated annealing (1.5).</p>
</td></tr>
<tr><td><code id="layout_with_lgl_+3A_repulserad">repulserad</code></td>
<td>
<p>Cancellation radius for the repulsion (the <code>area</code>
times the number of vertices).</p>
</td></tr>
<tr><td><code id="layout_with_lgl_+3A_cellsize">cellsize</code></td>
<td>
<p>The size of the cells for the grid. When calculating the
repulsion forces between vertices only vertices in the same or neighboring
grid cells are taken into account (the fourth root of the number of
<code>area</code>.</p>
</td></tr>
<tr><td><code id="layout_with_lgl_+3A_root">root</code></td>
<td>
<p>The id of the vertex to place at the middle of the layout. The
default value is -1 which means that a random vertex is selected.</p>
</td></tr>
<tr><td><code id="layout_with_lgl_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_lgl()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>layout_with_lgl()</code> is for large connected graphs, it is similar to the layout
generator of the Large Graph Layout software
(<a href="https://lgl.sourceforge.net/">https://lgl.sourceforge.net/</a>).
</p>


<h3>Value</h3>

<p>A numeric matrix with two columns and as many rows as vertices.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>

<hr>
<h2 id='layout_with_mds'>Graph layout by multidimensional scaling</h2><span id='topic+layout_with_mds'></span><span id='topic+with_mds'></span>

<h3>Description</h3>

<p>Multidimensional scaling of some distance matrix defined on the vertices of
a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_mds(graph, dist = NULL, dim = 2, options = arpack_defaults())

with_mds(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_mds_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout_with_mds_+3A_dist">dist</code></td>
<td>
<p>The distance matrix for the multidimensional scaling.  If
<code>NULL</code> (the default), then the unweighted shortest path matrix is used.</p>
</td></tr>
<tr><td><code id="layout_with_mds_+3A_dim">dim</code></td>
<td>
<p><code>layout_with_mds()</code> supports dimensions up to the number of nodes
minus one, but only if the graph is connected; for unconnected graphs, the
only possible value is 2. This is because <code>merge_coords()</code> only works in
2D.</p>
</td></tr>
<tr><td><code id="layout_with_mds_+3A_options">options</code></td>
<td>
<p>This is currently ignored, as ARPACK is not used any more for
solving the eigenproblem</p>
</td></tr>
<tr><td><code id="layout_with_mds_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_mds()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>layout_with_mds()</code> uses classical multidimensional scaling (Torgerson scaling)
for generating the coordinates. Multidimensional scaling aims to place points
from a higher dimensional space in a (typically) 2 dimensional plane, so that
the distances between the points are kept as much as this is possible.
</p>
<p>By default igraph uses the shortest path matrix as the distances between the
nodes, but the user can override this via the <code>dist</code> argument.
</p>
<p>Warning: If the graph is symmetric to the exchange of two vertices (as is the
case with leaves of a tree connecting to the same parent), classical
multidimensional scaling may assign the same coordinates to these vertices.
</p>
<p>This function generates the layout separately for each graph component and
then merges them via <code><a href="#topic+merge_coords">merge_coords()</a></code>.
</p>


<h3>Value</h3>

<p>A numeric matrix with <code>dim</code> columns.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Cox, T. F. and Cox, M. A. A. (2001) <em>Multidimensional
Scaling</em>.  Second edition. Chapman and Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout">layout()</a></code>, <code><a href="#topic+plot.igraph">plot.igraph()</a></code>
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(100, 2 / 100)
l &lt;- layout_with_mds(g)
plot(g, layout = l, vertex.label = NA, vertex.size = 3)
</code></pre>

<hr>
<h2 id='layout_with_sugiyama'>The Sugiyama graph layout generator</h2><span id='topic+layout_with_sugiyama'></span><span id='topic+with_sugiyama'></span>

<h3>Description</h3>

<p>Sugiyama layout algorithm for layered directed acyclic graphs. The algorithm
minimized edge crossings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_sugiyama(
  graph,
  layers = NULL,
  hgap = 1,
  vgap = 1,
  maxiter = 100,
  weights = NULL,
  attributes = c("default", "all", "none")
)

with_sugiyama(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_with_sugiyama_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout_with_sugiyama_+3A_layers">layers</code></td>
<td>
<p>A numeric vector or <code>NULL</code>. If not <code>NULL</code>, then it
should specify the layer index of the vertices. Layers are numbered from
one. If <code>NULL</code>, then igraph calculates the layers automatically.</p>
</td></tr>
<tr><td><code id="layout_with_sugiyama_+3A_hgap">hgap</code></td>
<td>
<p>Real scalar, the minimum horizontal gap between vertices in the
same layer.</p>
</td></tr>
<tr><td><code id="layout_with_sugiyama_+3A_vgap">vgap</code></td>
<td>
<p>Real scalar, the distance between layers.</p>
</td></tr>
<tr><td><code id="layout_with_sugiyama_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer scalar, the maximum number of iterations in the
crossing minimization stage. 100 is a reasonable default; if you feel that
you have too many edge crossings, increase this.</p>
</td></tr>
<tr><td><code id="layout_with_sugiyama_+3A_weights">weights</code></td>
<td>
<p>Optional edge weight vector. If <code>NULL</code>, then the
'weight' edge attribute is used, if there is one. Supply <code>NA</code> here and
igraph ignores the edge weights. These are used only if the graph
contains cycles; igraph will tend to reverse edges with smaller weights
when breaking the cycles.</p>
</td></tr>
<tr><td><code id="layout_with_sugiyama_+3A_attributes">attributes</code></td>
<td>
<p>Which graph/vertex/edge attributes to keep in the extended
graph. &lsquo;default&rsquo; keeps the &lsquo;size&rsquo;, &lsquo;size2&rsquo;,
&lsquo;shape&rsquo;, &lsquo;label&rsquo; and &lsquo;color&rsquo; vertex attributes and the
&lsquo;arrow.mode&rsquo; and &lsquo;arrow.size&rsquo; edge attributes. &lsquo;all&rsquo;
keep all graph, vertex and edge attributes, &lsquo;none&rsquo; keeps none of
them.</p>
</td></tr>
<tr><td><code id="layout_with_sugiyama_+3A_...">...</code></td>
<td>
<p>Passed to <code>layout_with_sugiyama()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This layout algorithm is designed for directed acyclic graphs where each
vertex is assigned to a layer. Layers are indexed from zero, and vertices of
the same layer will be placed on the same horizontal line. The X coordinates
of vertices within each layer are decided by the heuristic proposed by
Sugiyama et al. to minimize edge crossings.
</p>
<p>You can also try to lay out undirected graphs, graphs containing cycles, or
graphs without an a priori layered assignment with this algorithm. igraph
will try to eliminate cycles and assign vertices to layers, but there is no
guarantee on the quality of the layout in such cases.
</p>
<p>The Sugiyama layout may introduce &ldquo;bends&rdquo; on the edges in order to
obtain a visually more pleasing layout. This is achieved by adding dummy
nodes to edges spanning more than one layer. The resulting layout assigns
coordinates not only to the nodes of the original graph but also to the
dummy nodes. The layout algorithm will also return the extended graph with
the dummy nodes.
</p>
<p>For more details, see the reference below.
</p>


<h3>Value</h3>

<p>A list with the components: </p>
<table>
<tr><td><code>layout</code></td>
<td>
<p>The layout, a two-column
matrix, for the original graph vertices.</p>
</td></tr> <tr><td><code>layout.dummy</code></td>
<td>
<p>The layout for
the dummy vertices, a two column matrix.</p>
</td></tr> <tr><td><code>extd_graph</code></td>
<td>
<p>The original
graph, extended with dummy vertices.  The &lsquo;dummy&rsquo; vertex attribute is
set on this graph, it is a logical attributes, and it tells you whether the
vertex is a dummy vertex. The &lsquo;layout&rsquo; graph attribute is also set,
and it is the layout matrix for all (original and dummy) vertices.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>K. Sugiyama, S. Tagawa and M. Toda, &quot;Methods for Visual
Understanding of Hierarchical Systems&quot;. IEEE Transactions on Systems, Man
and Cybernetics 11(2):109-125, 1981.
</p>


<h3>See Also</h3>

<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Data taken from http://tehnick-8.narod.ru/dc_clients/
DC &lt;- graph_from_literal(
  "DC++" -+ "LinuxDC++":"BCDC++":"EiskaltDC++":"StrongDC++":"DiCe!++",
  "LinuxDC++" -+ "FreeDC++", "BCDC++" -+ "StrongDC++",
  "FreeDC++" -+ "BMDC++":"EiskaltDC++",
  "StrongDC++" -+ "AirDC++":"zK++":"ApexDC++":"TkDC++",
  "StrongDC++" -+ "StrongDC++ SQLite":"RSX++",
  "ApexDC++" -+ "FlylinkDC++ ver &lt;= 4xx",
  "ApexDC++" -+ "ApexDC++ Speed-Mod":"DiCe!++",
  "StrongDC++ SQLite" -+ "FlylinkDC++ ver &gt;= 5xx",
  "ApexDC++ Speed-Mod" -+ "FlylinkDC++ ver &lt;= 4xx",
  "ApexDC++ Speed-Mod" -+ "GreylinkDC++",
  "FlylinkDC++ ver &lt;= 4xx" -+ "FlylinkDC++ ver &gt;= 5xx",
  "FlylinkDC++ ver &lt;= 4xx" -+ AvaLink,
  "GreylinkDC++" -+ AvaLink:"RayLinkDC++":"SparkDC++":PeLink
)

## Use edge types
E(DC)$lty &lt;- 1
E(DC)["BCDC++" %-&gt;% "StrongDC++"]$lty &lt;- 2
E(DC)["FreeDC++" %-&gt;% "EiskaltDC++"]$lty &lt;- 2
E(DC)["ApexDC++" %-&gt;% "FlylinkDC++ ver &lt;= 4xx"]$lty &lt;- 2
E(DC)["ApexDC++" %-&gt;% "DiCe!++"]$lty &lt;- 2
E(DC)["StrongDC++ SQLite" %-&gt;% "FlylinkDC++ ver &gt;= 5xx"]$lty &lt;- 2
E(DC)["GreylinkDC++" %-&gt;% "AvaLink"]$lty &lt;- 2

## Layers, as on the plot
layers &lt;- list(
  c("DC++"),
  c("LinuxDC++", "BCDC++"),
  c("FreeDC++", "StrongDC++"),
  c(
    "BMDC++", "EiskaltDC++", "AirDC++", "zK++", "ApexDC++",
    "TkDC++", "RSX++"
  ),
  c("StrongDC++ SQLite", "ApexDC++ Speed-Mod", "DiCe!++"),
  c("FlylinkDC++ ver &lt;= 4xx", "GreylinkDC++"),
  c(
    "FlylinkDC++ ver &gt;= 5xx", "AvaLink", "RayLinkDC++",
    "SparkDC++", "PeLink"
  )
)

## Check that we have all nodes
all(sort(unlist(layers)) == sort(V(DC)$name))

## Add some graphical parameters
V(DC)$color &lt;- "white"
V(DC)$shape &lt;- "rectangle"
V(DC)$size &lt;- 20
V(DC)$size2 &lt;- 10
V(DC)$label &lt;- lapply(V(DC)$name, function(x) {
  paste(strwrap(x, 12), collapse = "\n")
})
E(DC)$arrow.size &lt;- 0.5

## Create a similar layout using the predefined layers
lay1 &lt;- layout_with_sugiyama(DC, layers = apply(sapply(
  layers,
  function(x) V(DC)$name %in% x
), 1, which))

## Simple plot, not very nice
par(mar = rep(.1, 4))
plot(DC, layout = lay1$layout, vertex.label.cex = 0.5)

## Sugiyama plot
plot(lay1$extd_graph, vertex.label.cex = 0.5)

## The same with automatic layer calculation
## Keep vertex/edge attributes in the extended graph
lay2 &lt;- layout_with_sugiyama(DC, attributes = "all")
plot(lay2$extd_graph, vertex.label.cex = 0.5)

## Another example, from the following paper:
## Markus Eiglsperger, Martin Siebenhaller, Michael Kaufmann:
## An Efficient Implementation of Sugiyama's Algorithm for
## Layered Graph Drawing, Journal of Graph Algorithms and
## Applications 9, 305--325 (2005).

ex &lt;- graph_from_literal(
  0 -+ 29:6:5:20:4,
  1 -+ 12,
  2 -+ 23:8,
  3 -+ 4,
  4,
  5 -+ 2:10:14:26:4:3,
  6 -+ 9:29:25:21:13,
  7,
  8 -+ 20:16,
  9 -+ 28:4,
  10 -+ 27,
  11 -+ 9:16,
  12 -+ 9:19,
  13 -+ 20,
  14 -+ 10,
  15 -+ 16:27,
  16 -+ 27,
  17 -+ 3,
  18 -+ 13,
  19 -+ 9,
  20 -+ 4,
  21 -+ 22,
  22 -+ 8:9,
  23 -+ 9:24,
  24 -+ 12:15:28,
  25 -+ 11,
  26 -+ 18,
  27 -+ 13:19,
  28 -+ 7,
  29 -+ 25
)

layers &lt;- list(
  0, c(5, 17), c(2, 14, 26, 3), c(23, 10, 18), c(1, 24),
  12, 6, c(29, 21), c(25, 22), c(11, 8, 15), 16, 27, c(13, 19),
  c(9, 20), c(4, 28), 7
)

layex &lt;- layout_with_sugiyama(ex, layers = apply(
  sapply(
    layers,
    function(x) V(ex)$name %in% as.character(x)
  ),
  1, which
))

origvert &lt;- c(rep(TRUE, vcount(ex)), rep(FALSE, nrow(layex$layout.dummy)))
realedge &lt;- as_edgelist(layex$extd_graph)[, 2] &lt;= vcount(ex)
plot(layex$extd_graph,
  vertex.label.cex = 0.5,
  edge.arrow.size = .5,
  vertex.size = ifelse(origvert, 5, 0),
  vertex.shape = ifelse(origvert, "square", "none"),
  vertex.label = ifelse(origvert, V(ex)$name, ""),
  edge.arrow.mode = ifelse(realedge, 2, 0)
)

</code></pre>

<hr>
<h2 id='layout.auto'>Choose an appropriate graph layout algorithm automatically</h2><span id='topic+layout.auto'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.auto()</code> was renamed to <code>layout_nicely()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.auto(graph, dim = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.auto_+3A_graph">graph</code></td>
<td>
<p>The input graph</p>
</td></tr>
<tr><td><code id="layout.auto_+3A_dim">dim</code></td>
<td>
<p>Dimensions, should be 2 or 3.</p>
</td></tr>
<tr><td><code id="layout.auto_+3A_...">...</code></td>
<td>
<p>For <code>layout_nicely()</code> the extra arguments are passed to
the real layout function. For <code>nicely()</code> all argument are passed to
<code>layout_nicely()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.bipartite'>Simple two-row layout for bipartite graphs</h2><span id='topic+layout.bipartite'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.bipartite()</code> was renamed to <code>layout_as_bipartite()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.bipartite(graph, types = NULL, hgap = 1, vgap = 1, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.bipartite_+3A_graph">graph</code></td>
<td>
<p>The bipartite input graph. It should have a logical
&lsquo;<code>type</code>&rsquo; vertex attribute, or the <code>types</code> argument must be
given.</p>
</td></tr>
<tr><td><code id="layout.bipartite_+3A_types">types</code></td>
<td>
<p>A logical vector, the vertex types. If this argument is
<code>NULL</code> (the default), then the &lsquo;<code>type</code>&rsquo; vertex attribute is
used.</p>
</td></tr>
<tr><td><code id="layout.bipartite_+3A_hgap">hgap</code></td>
<td>
<p>Real scalar, the minimum horizontal gap between vertices in the
same layer.</p>
</td></tr>
<tr><td><code id="layout.bipartite_+3A_vgap">vgap</code></td>
<td>
<p>Real scalar, the distance between the two layers.</p>
</td></tr>
<tr><td><code id="layout.bipartite_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer scalar, the maximum number of iterations in the
crossing minimization stage. 100 is a reasonable default; if you feel that
you have too many edge crossings, increase this.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.davidson.harel'>The Davidson-Harel layout algorithm</h2><span id='topic+layout.davidson.harel'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.davidson.harel()</code> was renamed to <code>layout_with_dh()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.davidson.harel(
  graph,
  coords = NULL,
  maxiter = 10,
  fineiter = max(10, log2(vcount(graph))),
  cool.fact = 0.75,
  weight.node.dist = 1,
  weight.border = 0,
  weight.edge.lengths = edge_density(graph)/10,
  weight.edge.crossings = 1 - sqrt(edge_density(graph)),
  weight.node.edge.dist = 0.2 * (1 - edge_density(graph))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.davidson.harel_+3A_graph">graph</code></td>
<td>
<p>The graph to lay out. Edge directions are ignored.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_coords">coords</code></td>
<td>
<p>Optional starting positions for the vertices. If this argument
is not <code>NULL</code> then it should be an appropriate matrix of starting
coordinates.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_maxiter">maxiter</code></td>
<td>
<p>Number of iterations to perform in the first phase.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_fineiter">fineiter</code></td>
<td>
<p>Number of iterations in the fine tuning phase.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_cool.fact">cool.fact</code></td>
<td>
<p>Cooling factor.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_weight.node.dist">weight.node.dist</code></td>
<td>
<p>Weight for the node-node distances component of the
energy function.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_weight.border">weight.border</code></td>
<td>
<p>Weight for the distance from the border component of
the energy function. It can be set to zero, if vertices are allowed to sit
on the border.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_weight.edge.lengths">weight.edge.lengths</code></td>
<td>
<p>Weight for the edge length component of the
energy function.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_weight.edge.crossings">weight.edge.crossings</code></td>
<td>
<p>Weight for the edge crossing component of the
energy function.</p>
</td></tr>
<tr><td><code id="layout.davidson.harel_+3A_weight.node.edge.dist">weight.node.edge.dist</code></td>
<td>
<p>Weight for the node-edge distance component of
the energy function.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.drl'>The DrL graph layout generator</h2><span id='topic+layout.drl'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.drl()</code> was renamed to <code>layout_with_drl()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.drl(
  graph,
  use.seed = FALSE,
  seed = matrix(runif(vcount(graph) * 2), ncol = 2),
  options = drl_defaults$default,
  weights = NULL,
  dim = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.drl_+3A_graph">graph</code></td>
<td>
<p>The input graph, in can be directed or undirected.</p>
</td></tr>
<tr><td><code id="layout.drl_+3A_use.seed">use.seed</code></td>
<td>
<p>Logical scalar, whether to use the coordinates given in the
<code>seed</code> argument as a starting point.</p>
</td></tr>
<tr><td><code id="layout.drl_+3A_seed">seed</code></td>
<td>
<p>A matrix with two columns, the starting coordinates for the
vertices is <code>use.seed</code> is <code>TRUE</code>. It is ignored otherwise.</p>
</td></tr>
<tr><td><code id="layout.drl_+3A_options">options</code></td>
<td>
<p>Options for the layout generator, a named list. See details
below.</p>
</td></tr>
<tr><td><code id="layout.drl_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for the layout. Larger edge weights
correspond to stronger connections.</p>
</td></tr>
<tr><td><code id="layout.drl_+3A_dim">dim</code></td>
<td>
<p>Either &lsquo;2&rsquo; or &lsquo;3&rsquo;, it specifies whether we want a
two dimensional or a three dimensional layout. Note that because of the
nature of the DrL algorithm, the three dimensional layout takes
significantly longer to compute.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.fruchterman.reingold.grid'>Grid Fruchterman-Reingold layout, this was removed from igraph</h2><span id='topic+layout.fruchterman.reingold.grid'></span>

<h3>Description</h3>

<p>Now it calls the Fruchterman-Reingold layout, with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.fruchterman.reingold.grid(graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.fruchterman.reingold.grid_+3A_graph">graph</code></td>
<td>
<p>Input graph.</p>
</td></tr>
<tr><td><code id="layout.fruchterman.reingold.grid_+3A_...">...</code></td>
<td>
<p>Extra arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Layout coordinates, a two column matrix.
</p>

<hr>
<h2 id='layout.gem'>The GEM layout algorithm</h2><span id='topic+layout.gem'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.gem()</code> was renamed to <code>layout_with_gem()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.gem(
  graph,
  coords = NULL,
  maxiter = 40 * vcount(graph)^2,
  temp.max = max(vcount(graph), 1),
  temp.min = 1/10,
  temp.init = sqrt(max(vcount(graph), 1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.gem_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions are ignored.</p>
</td></tr>
<tr><td><code id="layout.gem_+3A_coords">coords</code></td>
<td>
<p>If not <code>NULL</code>, then the starting coordinates should be
given here, in a two or three column matrix, depending on the <code>dim</code>
argument.</p>
</td></tr>
<tr><td><code id="layout.gem_+3A_maxiter">maxiter</code></td>
<td>
<p>The maximum number of iterations to perform. Updating a
single vertex counts as an iteration.  A reasonable default is 40 * n * n,
where n is the number of vertices. The original paper suggests 4 * n * n,
but this usually only works if the other parameters are set up carefully.</p>
</td></tr>
<tr><td><code id="layout.gem_+3A_temp.max">temp.max</code></td>
<td>
<p>The maximum allowed local temperature. A reasonable default
is the number of vertices.</p>
</td></tr>
<tr><td><code id="layout.gem_+3A_temp.min">temp.min</code></td>
<td>
<p>The global temperature at which the algorithm terminates
(even before reaching <code>maxiter</code> iterations). A reasonable default is
1/10.</p>
</td></tr>
<tr><td><code id="layout.gem_+3A_temp.init">temp.init</code></td>
<td>
<p>Initial local temperature of all vertices. A reasonable
default is the square root of the number of vertices.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.graphopt'>The graphopt layout algorithm</h2><span id='topic+layout.graphopt'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.graphopt()</code> was renamed to <code>layout_with_graphopt()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.graphopt(
  graph,
  start = NULL,
  niter = 500,
  charge = 0.001,
  mass = 30,
  spring.length = 0,
  spring.constant = 1,
  max.sa.movement = 5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.graphopt_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout.graphopt_+3A_start">start</code></td>
<td>
<p>If given, then it should be a matrix with two columns and one
line for each vertex. This matrix will be used as starting positions for the
algorithm. If not given, then a random starting matrix is used.</p>
</td></tr>
<tr><td><code id="layout.graphopt_+3A_niter">niter</code></td>
<td>
<p>Integer scalar, the number of iterations to perform.  Should be
a couple of hundred in general. If you have a large graph then you might
want to only do a few iterations and then check the result. If it is not
good enough you can feed it in again in the <code>start</code> argument. The
default value is 500.</p>
</td></tr>
<tr><td><code id="layout.graphopt_+3A_charge">charge</code></td>
<td>
<p>The charge of the vertices, used to calculate electric
repulsion. The default is 0.001.</p>
</td></tr>
<tr><td><code id="layout.graphopt_+3A_mass">mass</code></td>
<td>
<p>The mass of the vertices, used for the spring forces. The
default is 30.</p>
</td></tr>
<tr><td><code id="layout.graphopt_+3A_spring.length">spring.length</code></td>
<td>
<p>The length of the springs, an integer number. The
default value is zero.</p>
</td></tr>
<tr><td><code id="layout.graphopt_+3A_spring.constant">spring.constant</code></td>
<td>
<p>The spring constant, the default value is one.</p>
</td></tr>
<tr><td><code id="layout.graphopt_+3A_max.sa.movement">max.sa.movement</code></td>
<td>
<p>Real constant, it gives the maximum amount of
movement allowed in a single step along a single axis. The default value is
5.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.grid'>Simple grid layout</h2><span id='topic+layout.grid'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.grid()</code> was renamed to <code>layout_on_grid()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.grid(graph, width = 0, height = 0, dim = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.grid_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout.grid_+3A_width">width</code></td>
<td>
<p>The number of vertices in a single row of the grid. If this is
zero or negative, then for 2d layouts the width of the grid will be the
square root of the number of vertices in the graph, rounded up to the next
integer. Similarly, it will be the cube root for 3d layouts.</p>
</td></tr>
<tr><td><code id="layout.grid_+3A_height">height</code></td>
<td>
<p>The number of vertices in a single column of the grid, for
three dimensional layouts. If this is zero or negative, then it is
determinted automatically.</p>
</td></tr>
<tr><td><code id="layout.grid_+3A_dim">dim</code></td>
<td>
<p>Two or three. Whether to make 2d or a 3d layout.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.mds'>Graph layout by multidimensional scaling</h2><span id='topic+layout.mds'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.mds()</code> was renamed to <code>layout_with_mds()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.mds(graph, dist = NULL, dim = 2, options = arpack_defaults())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.mds_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout.mds_+3A_dist">dist</code></td>
<td>
<p>The distance matrix for the multidimensional scaling.  If
<code>NULL</code> (the default), then the unweighted shortest path matrix is used.</p>
</td></tr>
<tr><td><code id="layout.mds_+3A_dim">dim</code></td>
<td>
<p><code>layout_with_mds()</code> supports dimensions up to the number of nodes
minus one, but only if the graph is connected; for unconnected graphs, the
only possible value is 2. This is because <code>merge_coords()</code> only works in
2D.</p>
</td></tr>
<tr><td><code id="layout.mds_+3A_options">options</code></td>
<td>
<p>This is currently ignored, as ARPACK is not used any more for
solving the eigenproblem</p>
</td></tr>
</table>

<hr>
<h2 id='layout.merge'>Merging graph layouts</h2><span id='topic+layout.merge'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.merge()</code> was renamed to <code>merge_coords()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.merge(graphs, layouts, method = "dla")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.merge_+3A_graphs">graphs</code></td>
<td>
<p>A list of graph objects.</p>
</td></tr>
<tr><td><code id="layout.merge_+3A_layouts">layouts</code></td>
<td>
<p>A list of two-column matrices.</p>
</td></tr>
<tr><td><code id="layout.merge_+3A_method">method</code></td>
<td>
<p>Character constant giving the method to use. Right now only
<code>dla</code> is implemented.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.norm'>Normalize coordinates for plotting graphs</h2><span id='topic+layout.norm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.norm()</code> was renamed to <code>norm_coords()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.norm(
  layout,
  xmin = -1,
  xmax = 1,
  ymin = -1,
  ymax = 1,
  zmin = -1,
  zmax = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.norm_+3A_layout">layout</code></td>
<td>
<p>A matrix with two or three columns, the layout to normalize.</p>
</td></tr>
<tr><td><code id="layout.norm_+3A_xmin">xmin</code>, <code id="layout.norm_+3A_xmax">xmax</code></td>
<td>
<p>The limits for the first coordinate, if one of them or both
are <code>NULL</code> then no normalization is performed along this direction.</p>
</td></tr>
<tr><td><code id="layout.norm_+3A_ymin">ymin</code>, <code id="layout.norm_+3A_ymax">ymax</code></td>
<td>
<p>The limits for the second coordinate, if one of them or
both are <code>NULL</code> then no normalization is performed along this
direction.</p>
</td></tr>
<tr><td><code id="layout.norm_+3A_zmin">zmin</code>, <code id="layout.norm_+3A_zmax">zmax</code></td>
<td>
<p>The limits for the third coordinate, if one of them or both
are <code>NULL</code> then no normalization is performed along this direction.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.reingold.tilford'>Deprecated layout functions</h2><span id='topic+layout.reingold.tilford'></span><span id='topic+layout.circle'></span><span id='topic+layout.sphere'></span><span id='topic+layout.random'></span><span id='topic+layout.fruchterman.reingold'></span><span id='topic+layout.kamada.kawai'></span><span id='topic+layout.lgl'></span>

<h3>Description</h3>

<p>Please use the new names, see <code><a href="#topic+layout_">layout_()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.reingold.tilford(..., params = list())

layout.circle(..., params = list())

layout.sphere(..., params = list())

layout.random(..., params = list())

layout.fruchterman.reingold(..., params = list())

layout.kamada.kawai(..., params = list())

layout.lgl(..., params = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.reingold.tilford_+3A_...">...</code></td>
<td>
<p>Passed to the new layout functions.</p>
</td></tr>
<tr><td><code id="layout.reingold.tilford_+3A_params">params</code></td>
<td>
<p>Passed to the new layout functions as arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.spring'>Spring layout, this was removed from igraph</h2><span id='topic+layout.spring'></span>

<h3>Description</h3>

<p>Now it calls the Fruchterman-Reingold layout, with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.spring(graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.spring_+3A_graph">graph</code></td>
<td>
<p>Input graph.</p>
</td></tr>
<tr><td><code id="layout.spring_+3A_...">...</code></td>
<td>
<p>Extra arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Layout coordinates, a two column matrix.
</p>

<hr>
<h2 id='layout.star'>Generate coordinates to place the vertices of a graph in a star-shape</h2><span id='topic+layout.star'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.star()</code> was renamed to <code>layout_as_star()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.star(graph, center = V(graph)[1], order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.star_+3A_graph">graph</code></td>
<td>
<p>The graph to layout.</p>
</td></tr>
<tr><td><code id="layout.star_+3A_center">center</code></td>
<td>
<p>The id of the vertex to put in the center. By default it is
the first vertex.</p>
</td></tr>
<tr><td><code id="layout.star_+3A_order">order</code></td>
<td>
<p>Numeric vector, the order of the vertices along the perimeter.
The default ordering is given by the vertex ids.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.sugiyama'>The Sugiyama graph layout generator</h2><span id='topic+layout.sugiyama'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>layout.sugiyama()</code> was renamed to <code>layout_with_sugiyama()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.sugiyama(
  graph,
  layers = NULL,
  hgap = 1,
  vgap = 1,
  maxiter = 100,
  weights = NULL,
  attributes = c("default", "all", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.sugiyama_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="layout.sugiyama_+3A_layers">layers</code></td>
<td>
<p>A numeric vector or <code>NULL</code>. If not <code>NULL</code>, then it
should specify the layer index of the vertices. Layers are numbered from
one. If <code>NULL</code>, then igraph calculates the layers automatically.</p>
</td></tr>
<tr><td><code id="layout.sugiyama_+3A_hgap">hgap</code></td>
<td>
<p>Real scalar, the minimum horizontal gap between vertices in the
same layer.</p>
</td></tr>
<tr><td><code id="layout.sugiyama_+3A_vgap">vgap</code></td>
<td>
<p>Real scalar, the distance between layers.</p>
</td></tr>
<tr><td><code id="layout.sugiyama_+3A_maxiter">maxiter</code></td>
<td>
<p>Integer scalar, the maximum number of iterations in the
crossing minimization stage. 100 is a reasonable default; if you feel that
you have too many edge crossings, increase this.</p>
</td></tr>
<tr><td><code id="layout.sugiyama_+3A_weights">weights</code></td>
<td>
<p>Optional edge weight vector. If <code>NULL</code>, then the
'weight' edge attribute is used, if there is one. Supply <code>NA</code> here and
igraph ignores the edge weights. These are used only if the graph
contains cycles; igraph will tend to reverse edges with smaller weights
when breaking the cycles.</p>
</td></tr>
<tr><td><code id="layout.sugiyama_+3A_attributes">attributes</code></td>
<td>
<p>Which graph/vertex/edge attributes to keep in the extended
graph. &lsquo;default&rsquo; keeps the &lsquo;size&rsquo;, &lsquo;size2&rsquo;,
&lsquo;shape&rsquo;, &lsquo;label&rsquo; and &lsquo;color&rsquo; vertex attributes and the
&lsquo;arrow.mode&rsquo; and &lsquo;arrow.size&rsquo; edge attributes. &lsquo;all&rsquo;
keep all graph, vertex and edge attributes, &lsquo;none&rsquo; keeps none of
them.</p>
</td></tr>
</table>

<hr>
<h2 id='layout.svd'>SVD layout, this was removed from igraph</h2><span id='topic+layout.svd'></span>

<h3>Description</h3>

<p>Now it calls the Fruchterman-Reingold layout, with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout.svd(graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout.svd_+3A_graph">graph</code></td>
<td>
<p>Input graph.</p>
</td></tr>
<tr><td><code id="layout.svd_+3A_...">...</code></td>
<td>
<p>Extra arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Layout coordinates, a two column matrix.
</p>

<hr>
<h2 id='leading.eigenvector.community'>Community structure detecting based on the leading eigenvector of the community matrix</h2><span id='topic+leading.eigenvector.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>leading.eigenvector.community()</code> was renamed to <code>cluster_leading_eigen()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leading.eigenvector.community(
  graph,
  steps = -1,
  weights = NULL,
  start = NULL,
  options = arpack_defaults(),
  callback = NULL,
  extra = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leading.eigenvector.community_+3A_graph">graph</code></td>
<td>
<p>The input graph. Should be undirected as the method needs a
symmetric matrix.</p>
</td></tr>
<tr><td><code id="leading.eigenvector.community_+3A_steps">steps</code></td>
<td>
<p>The number of steps to take, this is actually the number of
tries to make a step. It is not a particularly useful parameter.</p>
</td></tr>
<tr><td><code id="leading.eigenvector.community_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="leading.eigenvector.community_+3A_start">start</code></td>
<td>
<p><code>NULL</code>, or a numeric membership vector, giving the start
configuration of the algorithm.</p>
</td></tr>
<tr><td><code id="leading.eigenvector.community_+3A_options">options</code></td>
<td>
<p>A named list to override some ARPACK options.</p>
</td></tr>
<tr><td><code id="leading.eigenvector.community_+3A_callback">callback</code></td>
<td>
<p>If not <code>NULL</code>, then it must be callback function. This
is called after each iteration, after calculating the leading eigenvector of
the modularity matrix. See details below.</p>
</td></tr>
<tr><td><code id="leading.eigenvector.community_+3A_extra">extra</code></td>
<td>
<p>Additional argument to supply to the callback function.</p>
</td></tr>
<tr><td><code id="leading.eigenvector.community_+3A_env">env</code></td>
<td>
<p>The environment in which the callback function is evaluated.</p>
</td></tr>
</table>

<hr>
<h2 id='list.edge.attributes'>List names of edge attributes</h2><span id='topic+list.edge.attributes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>list.edge.attributes()</code> was renamed to <code>edge_attr_names()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.edge.attributes(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.edge.attributes_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
</table>

<hr>
<h2 id='list.graph.attributes'>List names of graph attributes</h2><span id='topic+list.graph.attributes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>list.graph.attributes()</code> was renamed to <code>graph_attr_names()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.graph.attributes(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.graph.attributes_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
</table>

<hr>
<h2 id='list.vertex.attributes'>List names of vertex attributes</h2><span id='topic+list.vertex.attributes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>list.vertex.attributes()</code> was renamed to <code>vertex_attr_names()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.vertex.attributes(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.vertex.attributes_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
</table>

<hr>
<h2 id='local_scan'>Compute local scan statistics on graphs</h2><span id='topic+local_scan'></span>

<h3>Description</h3>

<p>The scan statistic is a summary of the locality statistics that is
computed from the local neighborhood of each vertex. The
<code>local_scan()</code> function computes the local statistics for each vertex
for a given neighborhood size and the statistic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_scan(
  graph.us,
  graph.them = NULL,
  k = 1,
  FUN = NULL,
  weighted = FALSE,
  mode = c("out", "in", "all"),
  neighborhoods = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_scan_+3A_graph.us">graph.us</code>, <code id="local_scan_+3A_graph">graph</code></td>
<td>
<p>An igraph object, the graph for which the scan
statistics will be computed</p>
</td></tr>
<tr><td><code id="local_scan_+3A_graph.them">graph.them</code></td>
<td>
<p>An igraph object or <code>NULL</code>, if not <code>NULL</code>,
then the &lsquo;them&rsquo; statistics is computed, i.e. the neighborhoods
calculated from <code>graph.us</code> are evaluated on <code>graph.them</code>.</p>
</td></tr>
<tr><td><code id="local_scan_+3A_k">k</code></td>
<td>
<p>An integer scalar, the size of the local neighborhood for each
vertex. Should be non-negative.</p>
</td></tr>
<tr><td><code id="local_scan_+3A_fun">FUN</code></td>
<td>
<p>Character, a function name, or a function object itself, for
computing the local statistic in each neighborhood. If <code>NULL</code>(the
default value), <code>ecount()</code> is used for unweighted graphs (if
<code>weighted=FALSE</code>) and a function that computes the sum of edge
weights is used for weighted graphs (if <code>weighted=TRUE</code>). This
argument is ignored if <code>k</code> is zero.</p>
</td></tr>
<tr><td><code id="local_scan_+3A_weighted">weighted</code></td>
<td>
<p>Logical scalar, TRUE if the edge weights should be used
for computation of the scan statistic. If TRUE, the graph should be
weighted.  Note that this argument is ignored if <code>FUN</code> is not
<code>NULL</code>, <code>"ecount"</code> and <code>"sumweights"</code>.</p>
</td></tr>
<tr><td><code id="local_scan_+3A_mode">mode</code></td>
<td>
<p>Character scalar, the kind of neighborhoods to use for the
calculation. One of &lsquo;<code>out</code>&rsquo;, &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo;,
&lsquo;<code>all</code>&rsquo; or &lsquo;<code>total</code>&rsquo;. This argument is ignored
for undirected graphs.</p>
</td></tr>
<tr><td><code id="local_scan_+3A_neighborhoods">neighborhoods</code></td>
<td>
<p>A list of neighborhoods, one for each vertex, or
<code>NULL</code>. If it is not <code>NULL</code>, then the function is evaluated on
the induced subgraphs specified by these neighborhoods.
</p>
<p>In theory this could be useful if the same <code>graph.us</code> graph is used
for multiple <code>graph.them</code> arguments. Then the neighborhoods can be
calculated on <code>graph.us</code> and used with multiple graphs. In
practice, this is currently slower than simply using <code>graph.them</code>
multiple times.</p>
</td></tr>
<tr><td><code id="local_scan_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>FUN</code>, the function that computes
the local statistics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the given reference below for the details on the local scan
statistics.
</p>
<p><code>local_scan()</code> calculates exact local scan statistics.
</p>
<p>If <code>graph.them</code> is <code>NULL</code>, then <code>local_scan()</code> computes the
&lsquo;us&rsquo; variant of the scan statistics.  Otherwise,
<code>graph.them</code> should be an igraph object and the &lsquo;them&rsquo;
variant is computed using <code>graph.us</code> to extract the neighborhood
information, and applying <code>FUN</code> on these neighborhoods in
<code>graph.them</code>.
</p>


<h3>Value</h3>

<p>For <code>local_scan()</code> typically a numeric vector containing the
computed local statistics for each vertex. In general a list or vector
of objects, as returned by <code>FUN</code>.
</p>


<h3>References</h3>

<p>Priebe, C. E., Conroy, J. M., Marchette, D. J., Park,
Y. (2005).  Scan Statistics on Enron Graphs. <em>Computational and
Mathematical Organization Theory</em>.
</p>


<h3>See Also</h3>

<p>Other scan statistics: 
<code><a href="#topic+scan_stat">scan_stat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pair &lt;- sample_correlated_gnp_pair(n = 10^3, corr = 0.8, p = 0.1)
local_0_us &lt;- local_scan(graph.us = pair$graph1, k = 0)
local_1_us &lt;- local_scan(graph.us = pair$graph1, k = 1)

local_0_them &lt;- local_scan(
  graph.us = pair$graph1,
  graph.them = pair$graph2, k = 0
)
local_1_them &lt;- local_scan(
  graph.us = pair$graph1,
  graph.them = pair$graph2, k = 1
)

Neigh_1 &lt;- neighborhood(pair$graph1, order = 1)
local_1_them_nhood &lt;- local_scan(
  graph.us = pair$graph1,
  graph.them = pair$graph2,
  neighborhoods = Neigh_1
)
</code></pre>

<hr>
<h2 id='make_'>Make a new graph</h2><span id='topic+make_'></span>

<h3>Description</h3>

<p>This is a generic function for creating graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make__+3A_...">...</code></td>
<td>
<p>Parameters, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_()</code> is a generic function for creating graphs.
For every graph constructor in igraph that has a <code>make_</code> prefix,
there is a corresponding function without the prefix: e.g.
for <code><a href="#topic+make_ring">make_ring()</a></code> there is also <code><a href="#topic+ring">ring()</a></code>, etc.
</p>
<p>The same is true for the random graph samplers, i.e. for each
constructor with a <code>sample_</code> prefix, there is a corresponding
function without that prefix.
</p>
<p>These shorter forms can be used together with <code>make_()</code>.
The advantage of this form is that the user can specify constructor
modifiers which work with all constructors. E.g. the
<code><a href="#topic+with_vertex_">with_vertex_()</a></code> modifier adds vertex attributes
to the newly created graphs.
</p>
<p>See the examples and the various constructor modifiers below.
</p>


<h3>See Also</h3>

<p>simplified with_edge_ with_graph_ with_vertex_
without_loops without_multiples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- make_(ring(10))
l &lt;- make_(lattice(c(3, 3, 3)))

r2 &lt;- make_(ring(10), with_vertex_(color = "red", name = LETTERS[1:10]))
l2 &lt;- make_(lattice(c(3, 3, 3)), with_edge_(weight = 2))

ran &lt;- sample_(degseq(c(3, 3, 3, 3, 3, 3), method = "simple"), simplified())
degree(ran)
is_simple(ran)
</code></pre>

<hr>
<h2 id='make_bipartite_graph'>Create a bipartite graph</h2><span id='topic+make_bipartite_graph'></span><span id='topic+graph.bipartite'></span><span id='topic+bipartite_graph'></span>

<h3>Description</h3>

<p>A bipartite graph has two kinds of vertices and connections are only allowed
between different kinds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_bipartite_graph(types, edges, directed = FALSE)

bipartite_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_bipartite_graph_+3A_types">types</code></td>
<td>
<p>A vector giving the vertex types. It will be coerced into
boolean. The length of the vector gives the number of vertices in the graph.
When the vector is a named vector, the names will be attached to the graph
as the <code>name</code> vertex attribute.</p>
</td></tr>
<tr><td><code id="make_bipartite_graph_+3A_edges">edges</code></td>
<td>
<p>A vector giving the edges of the graph, the same way as for the
regular <code><a href="#topic+graph">graph()</a></code> function. It is checked that the edges indeed
connect vertices of different kind, according to the supplied <code>types</code>
vector. The vector may be a string vector if <code>types</code> is a named vector.</p>
</td></tr>
<tr><td><code id="make_bipartite_graph_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph, boolean constant. Note
that by default undirected graphs are created, as this is more common for
bipartite graphs.</p>
</td></tr>
<tr><td><code id="make_bipartite_graph_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_bipartite_graph()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bipartite graphs have a <code>type</code> vertex attribute in igraph, this is
boolean and <code>FALSE</code> for the vertices of the first kind and <code>TRUE</code>
for vertices of the second kind.
</p>
<p><code>make_bipartite_graph()</code> basically does three things. First it checks the
<code>edges</code> vector against the vertex <code>types</code>. Then it creates a graph
using the <code>edges</code> vector and finally it adds the <code>types</code> vector as
a vertex attribute called <code>type</code>. <code>edges</code> may contain strings as
vertex names; in this case, <code>types</code> must be a named vector that specifies
the type for each vertex name that occurs in <code>edges</code>.
</p>


<h3>Value</h3>

<p><code>make_bipartite_graph()</code> returns a bipartite igraph graph. In other
words, an igraph graph that has a vertex attribute named <code>type</code>.
</p>
<p><code>is_bipartite()</code> returns a logical scalar.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+graph">graph()</a></code> to create one-mode networks
</p>
<p>Bipartite graphs
<code><a href="#topic+bipartite_mapping">bipartite_mapping</a>()</code>,
<code><a href="#topic+bipartite_projection">bipartite_projection</a>()</code>,
<code><a href="#topic+is_bipartite">is_bipartite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_bipartite_graph(rep(0:1, length.out = 10), c(1:10))
print(g, v = TRUE)

</code></pre>

<hr>
<h2 id='make_chordal_ring'>Create an extended chordal ring graph</h2><span id='topic+make_chordal_ring'></span><span id='topic+graph.extended.chordal.ring'></span><span id='topic+chordal_ring'></span>

<h3>Description</h3>

<p><code>make_chordal_ring()</code> creates an extended chordal ring.
An extended chordal ring is regular graph, each node has the same
degree. It can be obtained from a simple ring by adding some extra
edges specified by a matrix. Let p denote the number of columns in
the &lsquo;<code>W</code>&rsquo; matrix. The extra edges of vertex <code>i</code>
are added according to column <code style="white-space: pre;">&#8288;i mod p&#8288;</code> in
&lsquo;<code>W</code>&rsquo;. The number of extra edges is the number
of rows in &lsquo;<code>W</code>&rsquo;: for each row <code>j</code> an edge
<code>i-&gt;i+w[ij]</code> is added if <code>i+w[ij]</code> is less than the number
of total nodes. See also Kotsis, G: Interconnection Topologies for
Parallel Processing Systems, PARS Mitteilungen 11, 1-6, 1993.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_chordal_ring(n, w, directed = FALSE)

chordal_ring(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_chordal_ring_+3A_n">n</code></td>
<td>
<p>The number of vertices.</p>
</td></tr>
<tr><td><code id="make_chordal_ring_+3A_w">w</code></td>
<td>
<p>A matrix which specifies the extended chordal ring. See
details below.</p>
</td></tr>
<tr><td><code id="make_chordal_ring_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether or not to create a directed graph.</p>
</td></tr>
<tr><td><code id="make_chordal_ring_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_chordal_ring()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chord &lt;- make_chordal_ring(
  15,
  matrix(c(3, 12, 4, 7, 8, 11), nr = 2)
)
</code></pre>

<hr>
<h2 id='make_clusters'>Creates a communities object.</h2><span id='topic+make_clusters'></span>

<h3>Description</h3>

<p>This is useful to integrate the results of community finding algorithms
that are not included in igraph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_clusters(
  graph,
  membership = NULL,
  algorithm = NULL,
  merges = NULL,
  modularity = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_clusters_+3A_graph">graph</code></td>
<td>
<p>The graph of the community structure.</p>
</td></tr>
<tr><td><code id="make_clusters_+3A_membership">membership</code></td>
<td>
<p>The membership vector of the community structure, a
numeric vector denoting the id of the community for each vertex. It
might be <code>NULL</code> for hierarchical community structures.</p>
</td></tr>
<tr><td><code id="make_clusters_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string, the algorithm that generated
the community structure, it can be arbitrary.</p>
</td></tr>
<tr><td><code id="make_clusters_+3A_merges">merges</code></td>
<td>
<p>A merge matrix, for hierarchical community structures (or
<code>NULL</code> otherwise.</p>
</td></tr>
<tr><td><code id="make_clusters_+3A_modularity">modularity</code></td>
<td>
<p>Modularity value of the community structure. If this
is <code>TRUE</code> and the membership vector is available, then it the
modularity values is calculated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>communities</code> object.
</p>


<h3>See Also</h3>

<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>

<hr>
<h2 id='make_de_bruijn_graph'>De Bruijn graphs</h2><span id='topic+make_de_bruijn_graph'></span><span id='topic+graph.de.bruijn'></span><span id='topic+de_bruijn_graph'></span>

<h3>Description</h3>

<p>De Bruijn graphs are labeled graphs representing the overlap of strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_de_bruijn_graph(m, n)

de_bruijn_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_de_bruijn_graph_+3A_m">m</code></td>
<td>
<p>Integer scalar, the size of the alphabet. See details below.</p>
</td></tr>
<tr><td><code id="make_de_bruijn_graph_+3A_n">n</code></td>
<td>
<p>Integer scalar, the length of the labels. See details below.</p>
</td></tr>
<tr><td><code id="make_de_bruijn_graph_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_de_bruijn_graph()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A de Bruijn graph represents relationships between strings. An alphabet of
<code>m</code> letters are used and strings of length <code>n</code> are considered.  A
vertex corresponds to every possible string and there is a directed edge
from vertex <code>v</code> to vertex <code>w</code> if the string of <code>v</code> can be
transformed into the string of <code>w</code> by removing its first letter and
appending a letter to it.
</p>
<p>Please note that the graph will have <code>m</code> to the power <code>n</code> vertices
and even more edges, so probably you don't want to supply too big numbers
for <code>m</code> and <code>n</code>.
</p>
<p>De Bruijn graphs have some interesting properties, please see another
source, e.g. Wikipedia for details.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_kautz_graph">make_kautz_graph()</a></code>, <code><a href="#topic+make_line_graph">make_line_graph()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# de Bruijn graphs can be created recursively by line graphs as well
g &lt;- make_de_bruijn_graph(2, 1)
make_de_bruijn_graph(2, 2)
make_line_graph(g)
</code></pre>

<hr>
<h2 id='make_empty_graph'>A graph with no edges</h2><span id='topic+make_empty_graph'></span><span id='topic+graph.empty'></span><span id='topic+empty_graph'></span>

<h3>Description</h3>

<p>A graph with no edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_empty_graph(n = 0, directed = TRUE)

empty_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_empty_graph_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="make_empty_graph_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="make_empty_graph_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_graph_empty</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_empty_graph(n = 10)
make_empty_graph(n = 5, directed = FALSE)
</code></pre>

<hr>
<h2 id='make_from_prufer'>Create an undirected tree graph from its Prüfer sequence</h2><span id='topic+make_from_prufer'></span><span id='topic+from_prufer'></span>

<h3>Description</h3>

<p><code>make_from_prufer()</code> creates an undirected tree graph from its Prüfer
sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_from_prufer(prufer)

from_prufer(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_from_prufer_+3A_prufer">prufer</code></td>
<td>
<p>The Prüfer sequence to convert into a graph</p>
</td></tr>
<tr><td><code id="make_from_prufer_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_from_prufer()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Prüfer sequence of a tree graph with n labeled vertices is a sequence of
n-2 numbers, constructed as follows. If the graph has more than two vertices,
find a vertex with degree one, remove it from the tree and add the label of
the vertex that it was connected to to the sequence. Repeat until there are
only two vertices in the remaining graph.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+to_prufer">to_prufer()</a></code> to convert a graph into its Prüfer sequence
</p>
<p>Other trees: 
<code><a href="#topic+is_forest">is_forest</a>()</code>,
<code><a href="#topic+is_tree">is_tree</a>()</code>,
<code><a href="#topic+sample_spanning_tree">sample_spanning_tree</a>()</code>,
<code><a href="#topic+to_prufer">to_prufer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_tree(13, 3)
to_prufer(g)
</code></pre>

<hr>
<h2 id='make_full_bipartite_graph'>Create a full bipartite graph</h2><span id='topic+make_full_bipartite_graph'></span><span id='topic+graph.full.bipartite'></span><span id='topic+full_bipartite_graph'></span>

<h3>Description</h3>

<p>Bipartite graphs are also called two-mode by some. This function creates a
bipartite graph in which every possible edge is present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_full_bipartite_graph(
  n1,
  n2,
  directed = FALSE,
  mode = c("all", "out", "in")
)

full_bipartite_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_full_bipartite_graph_+3A_n1">n1</code></td>
<td>
<p>The number of vertices of the first kind.</p>
</td></tr>
<tr><td><code id="make_full_bipartite_graph_+3A_n2">n2</code></td>
<td>
<p>The number of vertices of the second kind.</p>
</td></tr>
<tr><td><code id="make_full_bipartite_graph_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether the graphs is directed.</p>
</td></tr>
<tr><td><code id="make_full_bipartite_graph_+3A_mode">mode</code></td>
<td>
<p>Scalar giving the kind of edges to create for directed graphs.
If this is &lsquo;<code>out</code>&rsquo; then all vertices of the first kind are
connected to the others; &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo; specifies the opposite
direction; &lsquo;<code>all</code>&rsquo; creates mutual edges. This argument is
ignored for undirected graphs.x</p>
</td></tr>
<tr><td><code id="make_full_bipartite_graph_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_full_bipartite_graph()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bipartite graphs have a &lsquo;<code>type</code>&rsquo; vertex attribute in igraph,
this is boolean and <code>FALSE</code> for the vertices of the first kind and
<code>TRUE</code> for vertices of the second kind.
</p>


<h3>Value</h3>

<p>An igraph graph, with the &lsquo;<code>type</code>&rsquo; vertex attribute set.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_full_graph">make_full_graph()</a></code> for creating one-mode full graphs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_full_bipartite_graph(2, 3)
g2 &lt;- make_full_bipartite_graph(2, 3, directed = TRUE)
g3 &lt;- make_full_bipartite_graph(2, 3, directed = TRUE, mode = "in")
g4 &lt;- make_full_bipartite_graph(2, 3, directed = TRUE, mode = "all")

</code></pre>

<hr>
<h2 id='make_full_citation_graph'>Create a complete (full) citation graph</h2><span id='topic+make_full_citation_graph'></span><span id='topic+graph.full.citation'></span><span id='topic+full_citation_graph'></span>

<h3>Description</h3>

<p><code>make_full_citation_graph()</code> creates a full citation graph. This is a
directed graph, where every <code>i-&gt;j</code> edge is present if and only if
<code class="reqn">j&lt;i</code>. If <code>directed=FALSE</code> then the graph is just a full graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_full_citation_graph(n, directed = TRUE)

full_citation_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_full_citation_graph_+3A_n">n</code></td>
<td>
<p>The number of vertices.</p>
</td></tr>
<tr><td><code id="make_full_citation_graph_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="make_full_citation_graph_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_full_citation_graph()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print_all(make_full_citation_graph(10))
</code></pre>

<hr>
<h2 id='make_full_graph'>Create a full graph</h2><span id='topic+make_full_graph'></span><span id='topic+graph.full'></span><span id='topic+full_graph'></span>

<h3>Description</h3>

<p>Create a full graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_full_graph(n, directed = FALSE, loops = FALSE)

full_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_full_graph_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="make_full_graph_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="make_full_graph_+3A_loops">loops</code></td>
<td>
<p>Whether to add self-loops to the graph.</p>
</td></tr>
<tr><td><code id="make_full_graph_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_full_graph()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_full_graph(5)
print_all(make_full_graph(4, directed = TRUE))
</code></pre>

<hr>
<h2 id='make_graph'>Create an igraph graph from a list of edges, or a notable graph</h2><span id='topic+make_graph'></span><span id='topic+graph.famous'></span><span id='topic+graph'></span><span id='topic+make_directed_graph'></span><span id='topic+make_undirected_graph'></span><span id='topic+directed_graph'></span><span id='topic+undirected_graph'></span>

<h3>Description</h3>

<p>Create an igraph graph from a list of edges, or a notable graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_graph(
  edges,
  ...,
  n = max(edges),
  isolates = NULL,
  directed = TRUE,
  dir = directed,
  simplify = TRUE
)

make_directed_graph(edges, n = max(edges))

make_undirected_graph(edges, n = max(edges))

directed_graph(...)

undirected_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_graph_+3A_edges">edges</code></td>
<td>
<p>A vector defining the edges, the first edge points
from the first element to the second, the second edge from the third
to the fourth, etc. For a numeric vector, these are interpreted
as internal vertex ids. For character vectors, they are interpreted
as vertex names.
</p>
<p>Alternatively, this can be a character scalar, the name of a
notable graph. See Notable graphs below. The name is case
insensitive.
</p>
<p>Starting from igraph 0.8.0, you can also include literals here,
via igraph's formula notation (see <code><a href="#topic+graph_from_literal">graph_from_literal()</a></code>).
In this case, the first term of the formula has to start with
a &lsquo;<code>~</code>&rsquo; character, just like regular formulae in R.
See examples below.</p>
</td></tr>
<tr><td><code id="make_graph_+3A_...">...</code></td>
<td>
<p>For <code>make_graph()</code>: extra arguments for the case when the
graph is given via a literal, see <code><a href="#topic+graph_from_literal">graph_from_literal()</a></code>.
For <code>directed_graph()</code> and <code>undirected_graph()</code>:
Passed to <code>make_directed_graph()</code> or <code>make_undirected_graph()</code>.</p>
</td></tr>
<tr><td><code id="make_graph_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph. This argument is
ignored (with a warning) if <code>edges</code> are symbolic vertex names. It
is also ignored if there is a bigger vertex id in <code>edges</code>. This
means that for this function it is safe to supply zero here if the
vertex with the largest id is not an isolate.</p>
</td></tr>
<tr><td><code id="make_graph_+3A_isolates">isolates</code></td>
<td>
<p>Character vector, names of isolate vertices,
for symbolic edge lists. It is ignored for numeric edge lists.</p>
</td></tr>
<tr><td><code id="make_graph_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="make_graph_+3A_dir">dir</code></td>
<td>
<p>It is the same as <code>directed</code>, for compatibility.
Do not give both of them.</p>
</td></tr>
<tr><td><code id="make_graph_+3A_simplify">simplify</code></td>
<td>
<p>For graph literals, whether to simplify the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>Notable graphs</h3>

<p><code>make_graph()</code> can create some notable graphs. The name of the
graph (case insensitive), a character scalar must be supplied as
the <code>edges</code> argument, and other arguments are ignored. (A warning
is given is they are specified.)
</p>
<p><code>make_graph()</code> knows the following graphs: </p>

<dl>
<dt>Bull</dt><dd><p>The bull graph, 5 vertices, 5 edges, resembles to the head
of a bull if drawn properly.</p>
</dd>
<dt>Chvatal</dt><dd><p>This is the smallest triangle-free graph that is
both 4-chromatic and 4-regular. According to the Grunbaum conjecture there
exists an m-regular, m-chromatic graph with n vertices for every m&gt;1 and
n&gt;2. The Chvatal graph is an example for m=4 and n=12. It has 24 edges.</p>
</dd>
<dt>Coxeter</dt><dd><p>A non-Hamiltonian cubic symmetric graph with 28 vertices and
42 edges.</p>
</dd>
<dt>Cubical</dt><dd><p>The Platonic graph of the cube. A convex regular
polyhedron with 8 vertices and 12 edges.</p>
</dd>
<dt>Diamond</dt><dd><p>A graph with 4 vertices and 5 edges, resembles to a
schematic diamond if drawn properly.</p>
</dd>
<dt>Dodecahedral, Dodecahedron</dt><dd><p>Another Platonic solid with 20 vertices
and 30 edges.</p>
</dd>
<dt>Folkman</dt><dd><p>The semisymmetric graph with minimum number of
vertices, 20 and 40 edges. A semisymmetric graph is regular, edge transitive
and not vertex transitive.</p>
</dd>
<dt>Franklin</dt><dd><p>This is a graph whose embedding
to the Klein bottle can be colored with six colors, it is a counterexample
to the necessity of the Heawood conjecture on a Klein bottle. It has 12
vertices and 18 edges.</p>
</dd>
<dt>Frucht</dt><dd><p>The Frucht Graph is the smallest
cubical graph whose automorphism group consists only of the identity
element. It has 12 vertices and 18 edges.</p>
</dd>
<dt>Grotzsch</dt><dd><p>The Groetzsch
graph is a triangle-free graph with 11 vertices, 20 edges, and chromatic
number 4. It is named after German mathematician Herbert Groetzsch, and its
existence demonstrates that the assumption of planarity is necessary in
Groetzsch's theorem that every triangle-free planar graph is 3-colorable.</p>
</dd>
<dt>Heawood</dt><dd><p>The Heawood graph is an undirected graph with 14 vertices and
21 edges. The graph is cubic, and all cycles in the graph have six or more
edges. Every smaller cubic graph has shorter cycles, so this graph is the
6-cage, the smallest cubic graph of girth 6.</p>
</dd>
<dt>Herschel</dt><dd><p>The Herschel
graph is the smallest nonhamiltonian polyhedral graph. It is the unique such
graph on 11 nodes, and has 18 edges.</p>
</dd>
<dt>House</dt><dd><p>The house graph is a
5-vertex, 6-edge graph, the schematic draw of a house if drawn properly,
basicly a triangle of the top of a square.</p>
</dd>
<dt>HouseX</dt><dd><p>The same as the
house graph with an X in the square. 5 vertices and 8 edges.</p>
</dd>
<dt>Icosahedral, Icosahedron</dt><dd><p>A Platonic solid with 12 vertices and 30
edges.</p>
</dd>
<dt>Krackhardt kite</dt><dd><p>A social network with 10 vertices and 18
edges.  Krackhardt, D. Assessing the Political Landscape: Structure,
Cognition, and Power in Organizations.  Admin. Sci. Quart. 35, 342-369,
1990.</p>
</dd>
<dt>Levi</dt><dd><p>The graph is a 4-arc transitive cubic graph, it has 30
vertices and 45 edges.</p>
</dd>
<dt>McGee</dt><dd><p>The McGee graph is the unique 3-regular
7-cage graph, it has 24 vertices and 36 edges.</p>
</dd>
<dt>Meredith</dt><dd><p>The Meredith
graph is a quartic graph on 70 nodes and 140 edges that is a counterexample
to the conjecture that every 4-regular 4-connected graph is Hamiltonian.</p>
</dd>
<dt>Noperfectmatching</dt><dd><p>A connected graph with 16 vertices and 27 edges
containing no perfect matching. A matching in a graph is a set of pairwise
non-adjacent edges; that is, no two edges share a common vertex. A perfect
matching is a matching which covers all vertices of the graph.</p>
</dd>
<dt>Nonline</dt><dd><p>A graph whose connected components are the 9 graphs whose
presence as a vertex-induced subgraph in a graph makes a nonline graph. It
has 50 vertices and 72 edges.</p>
</dd>
<dt>Octahedral, Octahedron</dt><dd><p>Platonic solid
with 6 vertices and 12 edges.</p>
</dd>
<dt>Petersen</dt><dd><p>A 3-regular graph with 10
vertices and 15 edges. It is the smallest hypohamiltonian graph, i.e. it is
non-hamiltonian but removing any single vertex from it makes it
Hamiltonian.</p>
</dd>
<dt>Robertson</dt><dd><p>The unique (4,5)-cage graph, i.e. a 4-regular
graph of girth 5. It has 19 vertices and 38 edges.</p>
</dd>
<dt>Smallestcyclicgroup</dt><dd><p>A smallest nontrivial graph whose automorphism
group is cyclic. It has 9 vertices and 15 edges.</p>
</dd>
<dt>Tetrahedral,
Tetrahedron</dt><dd><p>Platonic solid with 4 vertices and 6 edges.</p>
</dd>
<dt>Thomassen</dt><dd><p>The smallest hypotraceable graph, on 34 vertices and 52
edges. A hypotraceable graph does not contain a Hamiltonian path but after
removing any single vertex from it the remainder always contains a
Hamiltonian path. A graph containing a Hamiltonian path is called traceable.</p>
</dd>
<dt>Tutte</dt><dd><p>Tait's Hamiltonian graph conjecture states that every
3-connected 3-regular planar graph is Hamiltonian.  This graph is a
counterexample. It has 46 vertices and 69 edges.</p>
</dd>
<dt>Uniquely3colorable</dt><dd><p>Returns a 12-vertex, triangle-free graph with
chromatic number 3 that is uniquely 3-colorable.</p>
</dd>
<dt>Walther</dt><dd><p>An identity
graph with 25 vertices and 31 edges. An identity graph has a single graph
automorphism, the trivial one.</p>
</dd>
<dt>Zachary</dt><dd><p>Social network of friendships
between 34 members of a karate club at a US university in the 1970s. See W.
W. Zachary, An information flow model for conflict and fission in small
groups, Journal of Anthropological Research 33, 452-473 (1977).  </p>
</dd> </dl>



<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_graph(c(1, 2, 2, 3, 3, 4, 5, 6), directed = FALSE)
make_graph(c("A", "B", "B", "C", "C", "D"), directed = FALSE)

solids &lt;- list(
  make_graph("Tetrahedron"),
  make_graph("Cubical"),
  make_graph("Octahedron"),
  make_graph("Dodecahedron"),
  make_graph("Icosahedron")
)

graph &lt;- make_graph(
  ~ A - B - C - D - A, E - A:B:C:D,
  F - G - H - I - F, J - F:G:H:I,
  K - L - M - N - K, O - K:L:M:N,
  P - Q - R - S - P, T - P:Q:R:S,
  B - F, E - J, C - I, L - T, O - T, M - S,
  C - P, C - L, I - L, I - P
)
</code></pre>

<hr>
<h2 id='make_kautz_graph'>Kautz graphs</h2><span id='topic+make_kautz_graph'></span><span id='topic+graph.kautz'></span><span id='topic+kautz_graph'></span>

<h3>Description</h3>

<p>Kautz graphs are labeled graphs representing the overlap of strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_kautz_graph(m, n)

kautz_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_kautz_graph_+3A_m">m</code></td>
<td>
<p>Integer scalar, the size of the alphabet. See details below.</p>
</td></tr>
<tr><td><code id="make_kautz_graph_+3A_n">n</code></td>
<td>
<p>Integer scalar, the length of the labels. See details below.</p>
</td></tr>
<tr><td><code id="make_kautz_graph_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_kautz_graph()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Kautz graph is a labeled graph, vertices are labeled by strings of length
<code>n+1</code> above an alphabet with <code>m+1</code> letters, with the restriction
that every two consecutive letters in the string must be different. There is
a directed edge from a vertex <code>v</code> to another vertex <code>w</code> if it is
possible to transform the string of <code>v</code> into the string of <code>w</code> by
removing the first letter and appending a letter to it.
</p>
<p>Kautz graphs have some interesting properties, see e.g. Wikipedia for
details.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>, the first version in R was
written by Vincent Matossian.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_de_bruijn_graph">make_de_bruijn_graph()</a></code>, <code><a href="#topic+make_line_graph">make_line_graph()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_line_graph(make_kautz_graph(2, 1))
make_kautz_graph(2, 2)

</code></pre>

<hr>
<h2 id='make_lattice'>Create a lattice graph</h2><span id='topic+make_lattice'></span><span id='topic+graph.lattice'></span><span id='topic+lattice'></span>

<h3>Description</h3>

<p><code>make_lattice()</code> is a flexible function, it can create lattices of
arbitrary dimensions, periodic or aperiodic ones. It has two
forms. In the first form you only supply <code>dimvector</code>, but not
<code>length</code> and <code>dim</code>. In the second form you omit
<code>dimvector</code> and supply <code>length</code> and <code>dim</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_lattice(
  dimvector = NULL,
  length = NULL,
  dim = NULL,
  nei = 1,
  directed = FALSE,
  mutual = FALSE,
  circular = FALSE
)

lattice(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_lattice_+3A_dimvector">dimvector</code></td>
<td>
<p>A vector giving the size of the lattice in each
dimension.</p>
</td></tr>
<tr><td><code id="make_lattice_+3A_length">length</code></td>
<td>
<p>Integer constant, for regular lattices, the size of the
lattice in each dimension.</p>
</td></tr>
<tr><td><code id="make_lattice_+3A_dim">dim</code></td>
<td>
<p>Integer constant, the dimension of the lattice.</p>
</td></tr>
<tr><td><code id="make_lattice_+3A_nei">nei</code></td>
<td>
<p>The distance within which (inclusive) the neighbors on the
lattice will be connected. This parameter is not used right now.</p>
</td></tr>
<tr><td><code id="make_lattice_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed lattice.</p>
</td></tr>
<tr><td><code id="make_lattice_+3A_mutual">mutual</code></td>
<td>
<p>Logical, if <code>TRUE</code> directed lattices will be
mutually connected.</p>
</td></tr>
<tr><td><code id="make_lattice_+3A_circular">circular</code></td>
<td>
<p>Logical, if <code>TRUE</code> the lattice or ring will be
circular.</p>
</td></tr>
<tr><td><code id="make_lattice_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_lattice()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_lattice(c(5, 5, 5))
make_lattice(length = 5, dim = 3)
</code></pre>

<hr>
<h2 id='make_line_graph'>Line graph of a graph</h2><span id='topic+make_line_graph'></span><span id='topic+line.graph'></span><span id='topic+line_graph'></span>

<h3>Description</h3>

<p>This function calculates the line graph of another graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_line_graph(graph)

line_graph(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_line_graph_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected.</p>
</td></tr>
<tr><td><code id="make_line_graph_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_line_graph()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The line graph <code>L(G)</code> of a <code>G</code> undirected graph is defined as
follows. <code>L(G)</code> has one vertex for each edge in <code>G</code> and two
vertices in <code>L(G)</code> are connected by an edge if their corresponding
edges share an end point.
</p>
<p>The line graph <code>L(G)</code> of a <code>G</code> directed graph is slightly
different, <code>L(G)</code> has one vertex for each edge in <code>G</code> and two
vertices in <code>L(G)</code> are connected by a directed edge if the target of
the first vertex's corresponding edge is the same as the source of the
second vertex's corresponding edge.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>, the first version of
the C code was written by Vincent Matossian.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate the first De-Bruijn graphs
g &lt;- make_full_graph(2, directed = TRUE, loops = TRUE)
make_line_graph(g)
make_line_graph(make_line_graph(g))
make_line_graph(make_line_graph(make_line_graph(g)))

</code></pre>

<hr>
<h2 id='make_ring'>Create a ring graph</h2><span id='topic+make_ring'></span><span id='topic+graph.ring'></span><span id='topic+ring'></span>

<h3>Description</h3>

<p>A ring is a one-dimensional lattice and this function is a special case
of <code><a href="#topic+make_lattice">make_lattice()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ring(n, directed = FALSE, mutual = FALSE, circular = TRUE)

ring(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ring_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="make_ring_+3A_directed">directed</code></td>
<td>
<p>Whether the graph is directed.</p>
</td></tr>
<tr><td><code id="make_ring_+3A_mutual">mutual</code></td>
<td>
<p>Whether directed edges are mutual. It is ignored in
undirected graphs.</p>
</td></tr>
<tr><td><code id="make_ring_+3A_circular">circular</code></td>
<td>
<p>Whether to create a circular ring. A non-circular
ring is essentially a &ldquo;line&rdquo;: a tree where every non-leaf
vertex has one child.</p>
</td></tr>
<tr><td><code id="make_ring_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_ring()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print_all(make_ring(10))
print_all(make_ring(10, directed = TRUE, mutual = TRUE))
</code></pre>

<hr>
<h2 id='make_star'>Create a star graph, a tree with n vertices and n - 1 leaves</h2><span id='topic+make_star'></span><span id='topic+graph.star'></span><span id='topic+star'></span>

<h3>Description</h3>

<p><code>star()</code> creates a star graph, in this every single vertex is
connected to the center vertex and nobody else.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_star(n, mode = c("in", "out", "mutual", "undirected"), center = 1)

star(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_star_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="make_star_+3A_mode">mode</code></td>
<td>
<p>It defines the direction of the
edges, <code style="white-space: pre;">&#8288;in&#8288;</code>: the edges point <em>to</em> the center, <code>out</code>:
the edges point <em>from</em> the center, <code>mutual</code>: a directed
star is created with mutual edges, <code>undirected</code>: the edges
are undirected.</p>
</td></tr>
<tr><td><code id="make_star_+3A_center">center</code></td>
<td>
<p>ID of the center vertex.</p>
</td></tr>
<tr><td><code id="make_star_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_star()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_tree">make_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_star(10, mode = "out")
make_star(5, mode = "undirected")
</code></pre>

<hr>
<h2 id='make_tree'>Create tree graphs</h2><span id='topic+make_tree'></span><span id='topic+graph.tree'></span><span id='topic+tree'></span>

<h3>Description</h3>

<p>Create a k-ary tree graph, where almost all vertices other than the leaves
have the same number of children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tree(n, children = 2, mode = c("out", "in", "undirected"))

tree(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tree_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="make_tree_+3A_children">children</code></td>
<td>
<p>Integer scalar, the number of children of a vertex
(except for leafs)</p>
</td></tr>
<tr><td><code id="make_tree_+3A_mode">mode</code></td>
<td>
<p>Defines the direction of the
edges. <code>out</code> indicates that the edges point from the parent to
the children, <code style="white-space: pre;">&#8288;in&#8288;</code> indicates that they point from the children
to their parents, while <code>undirected</code> creates an undirected
graph.</p>
</td></tr>
<tr><td><code id="make_tree_+3A_...">...</code></td>
<td>
<p>Passed to <code>make_tree()</code> or <code>sample_tree()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph
</p>


<h3>See Also</h3>

<p>Other deterministic constructors: 
<code><a href="#topic+graph_from_atlas">graph_from_atlas</a>()</code>,
<code><a href="#topic+graph_from_edgelist">graph_from_edgelist</a>()</code>,
<code><a href="#topic+graph_from_literal">graph_from_literal</a>()</code>,
<code><a href="#topic+make_chordal_ring">make_chordal_ring</a>()</code>,
<code><a href="#topic+make_empty_graph">make_empty_graph</a>()</code>,
<code><a href="#topic+make_full_citation_graph">make_full_citation_graph</a>()</code>,
<code><a href="#topic+make_full_graph">make_full_graph</a>()</code>,
<code><a href="#topic+make_graph">make_graph</a>()</code>,
<code><a href="#topic+make_lattice">make_lattice</a>()</code>,
<code><a href="#topic+make_ring">make_ring</a>()</code>,
<code><a href="#topic+make_star">make_star</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_tree(10, 2)
make_tree(10, 3, mode = "undirected")
</code></pre>

<hr>
<h2 id='match_vertices'>Match Graphs given a seeding of vertex correspondences</h2><span id='topic+match_vertices'></span><span id='topic+seeded.graph.match'></span>

<h3>Description</h3>

<p>Given two adjacency matrices <code>A</code> and <code>B</code> of the same size, match
the two graphs with the help of <code>m</code> seed vertex pairs which correspond
to the first <code>m</code> rows (and columns) of the adjacency matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_vertices(A, B, m, start, iteration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_vertices_+3A_a">A</code></td>
<td>
<p>a numeric matrix, the adjacency matrix of the first graph</p>
</td></tr>
<tr><td><code id="match_vertices_+3A_b">B</code></td>
<td>
<p>a numeric matrix, the adjacency matrix of the second graph</p>
</td></tr>
<tr><td><code id="match_vertices_+3A_m">m</code></td>
<td>
<p>The number of seeds. The first <code>m</code> vertices of both graphs are
matched.</p>
</td></tr>
<tr><td><code id="match_vertices_+3A_start">start</code></td>
<td>
<p>a numeric matrix, the permutation matrix estimate is
initialized with <code>start</code></p>
</td></tr>
<tr><td><code id="match_vertices_+3A_iteration">iteration</code></td>
<td>
<p>The number of iterations for the Frank-Wolfe algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximate graph matching problem is to find a bijection between the
vertices of two graphs , such that the number of edge disagreements between
the corresponding vertex pairs is minimized. For seeded graph matching, part
of the bijection that consist of known correspondences (the seeds) is known
and the problem task is to complete the bijection by estimating the
permutation matrix that permutes the rows and columns of the adjacency
matrix of the second graph.
</p>
<p>It is assumed that for the two supplied adjacency matrices <code>A</code> and
<code>B</code>, both of size <code class="reqn">n\times n</code>, the first <code class="reqn">m</code> rows(and
columns) of <code>A</code> and <code>B</code> correspond to the same vertices in both
graphs. That is, the <code class="reqn">n \times n</code> permutation matrix that defines
the bijection is <code class="reqn">I_{m} \bigoplus P</code> for a <code class="reqn">(n-m)\times
(n-m)</code> permutation matrix <code class="reqn">P</code> and <code class="reqn">m</code> times <code class="reqn">m</code>
identity matrix <code class="reqn">I_{m}</code>. The function <code>match_vertices()</code> estimates
the permutation matrix <code class="reqn">P</code> via an optimization algorithm based on the
Frank-Wolfe algorithm.
</p>
<p>See references for further details.
</p>


<h3>Value</h3>

<p>A numeric matrix which is the permutation matrix that determines the
bijection between the graphs of <code>A</code> and <code>B</code>
</p>


<h3>Author(s)</h3>

<p>Vince Lyzinski <a href="https://www.ams.jhu.edu/~lyzinski/">https://www.ams.jhu.edu/~lyzinski/</a>
</p>


<h3>References</h3>

<p>Vogelstein, J. T., Conroy, J. M., Podrazik, L. J., Kratzer, S.
G., Harley, E. T., Fishkind, D. E.,Vogelstein, R. J., Priebe, C. E. (2011).
Fast Approximate Quadratic Programming for Large (Brain) Graph Matching.
Online: <a href="https://arxiv.org/abs/1112.5507">https://arxiv.org/abs/1112.5507</a>
</p>
<p>Fishkind, D. E., Adali, S., Priebe, C. E. (2012). Seeded Graph Matching
Online: <a href="https://arxiv.org/abs/1209.0367">https://arxiv.org/abs/1209.0367</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp()</a></code>,<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# require(Matrix)
g1 &lt;- sample_gnp(10, 0.1)
randperm &lt;- c(1:3, 3 + sample(7))
g2 &lt;- sample_correlated_gnp(g1, corr = 1, p = g1$p, permutation = randperm)
A &lt;- as_adjacency_matrix(g1)
B &lt;- as_adjacency_matrix(g2)
P &lt;- match_vertices(A, B, m = 3, start = diag(rep(1, nrow(A) - 3)), 20)
P
</code></pre>

<hr>
<h2 id='max_cardinality'>Maximum cardinality search</h2><span id='topic+max_cardinality'></span>

<h3>Description</h3>

<p>Maximum cardinality search is a simple ordering a vertices that is useful in
determining the chordality of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_cardinality(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_cardinality_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored, as the algorithm is defined for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximum cardinality search visits the vertices in such an order that every
time the vertex with the most already visited neighbors is visited. Ties are
broken randomly.
</p>
<p>The algorithm provides a simple basis for deciding whether a graph is
chordal, see References below, and also <code><a href="#topic+is_chordal">is_chordal()</a></code>.
</p>


<h3>Value</h3>

<p>A list with two components: </p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p>Numeric vector. The
1-based rank of each vertex in the graph such that the vertex with rank 1
is visited first, the vertex with rank 2 is visited second and so on.</p>
</td></tr>
<tr><td><code>alpham1</code></td>
<td>
<p>Numeric vector. The inverse of <code>alpha</code>. In other words,
the elements of this vector are the vertices in reverse maximum cardinality
search order.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Robert E Tarjan and Mihalis Yannakakis. (1984). Simple
linear-time algorithms to test chordality of graphs, test acyclicity of
hypergraphs, and selectively reduce acyclic hypergraphs.  <em>SIAM Journal
of Computation</em> 13, 566&ndash;579.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_chordal">is_chordal()</a></code>
</p>
<p>Other chordal: 
<code><a href="#topic+is_chordal">is_chordal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The examples from the Tarjan-Yannakakis paper
g1 &lt;- graph_from_literal(
  A - B:C:I, B - A:C:D, C - A:B:E:H, D - B:E:F,
  E - C:D:F:H, F - D:E:G, G - F:H, H - C:E:G:I,
  I - A:H
)
max_cardinality(g1)
is_chordal(g1, fillin = TRUE)

g2 &lt;- graph_from_literal(
  A - B:E, B - A:E:F:D, C - E:D:G, D - B:F:E:C:G,
  E - A:B:C:D:F, F - B:D:E, G - C:D:H:I, H - G:I:J,
  I - G:H:J, J - H:I
)
max_cardinality(g2)
is_chordal(g2, fillin = TRUE)
</code></pre>

<hr>
<h2 id='max_flow'>Maximum flow in a graph</h2><span id='topic+max_flow'></span>

<h3>Description</h3>

<p>In a graph where each edge has a given flow capacity the maximal flow
between two vertices is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_flow(graph, source, target, capacity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_flow_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="max_flow_+3A_source">source</code></td>
<td>
<p>The id of the source vertex.</p>
</td></tr>
<tr><td><code id="max_flow_+3A_target">target</code></td>
<td>
<p>The id of the target vertex (sometimes also called sink).</p>
</td></tr>
<tr><td><code id="max_flow_+3A_capacity">capacity</code></td>
<td>
<p>Vector giving the capacity of the edges. If this is
<code>NULL</code> (the default) then the <code>capacity</code> edge attribute is used.
Note that the <code>weight</code> edge attribute is not used by this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>max_flow()</code> calculates the maximum flow between two vertices in a
weighted (i.e. valued) graph. A flow from <code>source</code> to <code>target</code> is
an assignment of non-negative real numbers to the edges of the graph,
satisfying two properties: (1) for each edge the flow (i.e. the assigned
number) is not more than the capacity of the edge (the <code>capacity</code>
parameter or edge attribute), (2) for every vertex, except the source and
the target the incoming flow is the same as the outgoing flow. The value of
the flow is the incoming flow of the <code>target</code> vertex. The maximum flow
is the flow of maximum value.
</p>


<h3>Value</h3>

<p>A named list with components:
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>A numeric scalar, the value of the maximum flow.</p>
</td></tr>
<tr><td><code>flow</code></td>
<td>
<p>A numeric vector, the flow itself, one entry for each
edge. For undirected graphs this entry is bit trickier, since for
these the flow direction is not predetermined by the edge
direction. For these graphs the elements of the this vector can be
negative, this means that the flow goes from the bigger vertex id to
the smaller one. Positive values mean that the flow goes from
the smaller vertex id to the bigger one.</p>
</td></tr>
<tr><td><code>cut</code></td>
<td>
<p>A numeric vector of edge ids, the minimum cut corresponding
to the maximum flow.</p>
</td></tr>
<tr><td><code>partition1</code></td>
<td>
<p>A numeric vector of vertex ids, the vertices in the
first partition of the minimum cut corresponding to the maximum
flow.</p>
</td></tr>
<tr><td><code>partition2</code></td>
<td>
<p>A numeric vector of vertex ids, the vertices in the
second partition of the minimum cut corresponding to the maximum
flow.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A list with some statistics from the push-relabel
algorithm. Five integer values currently: <code>nopush</code> is the
number of push operations, <code>norelabel</code> the number of
relabelings, <code>nogap</code> is the number of times the gap heuristics
was used, <code>nogapnodes</code> is the total number of gap nodes omitted
because of the gap heuristics and <code>nobfs</code> is the number of
times a global breadth-first-search update was performed to assign
better height (=distance) values to the vertices.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. V. Goldberg and R. E. Tarjan: A New Approach to the Maximum
Flow Problem <em>Journal of the ACM</em> 35:921-940, 1988.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
E &lt;- rbind(c(1, 3, 3), c(3, 4, 1), c(4, 2, 2), c(1, 5, 1), c(5, 6, 2), c(6, 2, 10))
colnames(E) &lt;- c("from", "to", "capacity")
g1 &lt;- graph_from_data_frame(as.data.frame(E))
max_flow(g1, source = V(g1)["1"], target = V(g1)["2"])
</code></pre>

<hr>
<h2 id='maxcohesion'>Calculate Cohesive Blocks</h2><span id='topic+maxcohesion'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>maxcohesion()</code> was renamed to <code>max_cohesion()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxcohesion(blocks)
</code></pre>

<hr>
<h2 id='maximal.cliques'>Functions to find cliques, i.e. complete subgraphs in a graph</h2><span id='topic+maximal.cliques'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>maximal.cliques()</code> was renamed to <code>max_cliques()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximal.cliques(graph, min = NULL, max = NULL, subset = NULL, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximal.cliques_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs will be considered as
undirected ones, multiple edges and loops are ignored.</p>
</td></tr>
<tr><td><code id="maximal.cliques_+3A_min">min</code></td>
<td>
<p>Numeric constant, lower limit on the size of the cliques to find.
<code>NULL</code> means no limit, i.e. it is the same as 0.</p>
</td></tr>
<tr><td><code id="maximal.cliques_+3A_max">max</code></td>
<td>
<p>Numeric constant, upper limit on the size of the cliques to find.
<code>NULL</code> means no limit.</p>
</td></tr>
<tr><td><code id="maximal.cliques_+3A_subset">subset</code></td>
<td>
<p>If not <code>NULL</code>, then it must be a vector of vertex ids,
numeric or symbolic if the graph is named. The algorithm is run from these
vertices only, so only a subset of all maximal cliques is returned. See the
Eppstein paper for details. This argument makes it possible to easily
parallelize the finding of maximal cliques.</p>
</td></tr>
<tr><td><code id="maximal.cliques_+3A_file">file</code></td>
<td>
<p>If not <code>NULL</code>, then it must be a file name, i.e. a
character scalar. The output of the algorithm is written to this file. (If
it exists, then it will be overwritten.) Each clique will be a separate line
in the file, given with the numeric ids of its vertices, separated by
whitespace.</p>
</td></tr>
</table>

<hr>
<h2 id='maximal.cliques.count'>Functions to find cliques, i.e. complete subgraphs in a graph</h2><span id='topic+maximal.cliques.count'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>maximal.cliques.count()</code> was renamed to <code>count_max_cliques()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximal.cliques.count(graph, min = NULL, max = NULL, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximal.cliques.count_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs will be considered as
undirected ones, multiple edges and loops are ignored.</p>
</td></tr>
<tr><td><code id="maximal.cliques.count_+3A_min">min</code></td>
<td>
<p>Numeric constant, lower limit on the size of the cliques to find.
<code>NULL</code> means no limit, i.e. it is the same as 0.</p>
</td></tr>
<tr><td><code id="maximal.cliques.count_+3A_max">max</code></td>
<td>
<p>Numeric constant, upper limit on the size of the cliques to find.
<code>NULL</code> means no limit.</p>
</td></tr>
<tr><td><code id="maximal.cliques.count_+3A_subset">subset</code></td>
<td>
<p>If not <code>NULL</code>, then it must be a vector of vertex ids,
numeric or symbolic if the graph is named. The algorithm is run from these
vertices only, so only a subset of all maximal cliques is returned. See the
Eppstein paper for details. This argument makes it possible to easily
parallelize the finding of maximal cliques.</p>
</td></tr>
</table>

<hr>
<h2 id='maximal.independent.vertex.sets'>Independent vertex sets</h2><span id='topic+maximal.independent.vertex.sets'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>maximal.independent.vertex.sets()</code> was renamed to <code>maximal_ivs()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximal.independent.vertex.sets(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximal.independent.vertex.sets_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs are considered as undirected,
loop edges and multiple edges are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='maximum.bipartite.matching'>Matching</h2><span id='topic+maximum.bipartite.matching'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>maximum.bipartite.matching()</code> was renamed to <code>max_bipartite_match()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximum.bipartite.matching(
  graph,
  types = NULL,
  weights = NULL,
  eps = .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximum.bipartite.matching_+3A_graph">graph</code></td>
<td>
<p>The input graph. It might be directed, but edge directions will
be ignored.</p>
</td></tr>
<tr><td><code id="maximum.bipartite.matching_+3A_types">types</code></td>
<td>
<p>Vertex types, if the graph is bipartite. By default they
are taken from the &lsquo;<code>type</code>&rsquo; vertex attribute, if present.</p>
</td></tr>
<tr><td><code id="maximum.bipartite.matching_+3A_weights">weights</code></td>
<td>
<p>Potential edge weights. If the graph has an edge
attribute called &lsquo;<code>weight</code>&rsquo;, and this argument is
<code>NULL</code>, then the edge attribute is used automatically.
In weighted matching, the weights of the edges must match as
much as possible.</p>
</td></tr>
<tr><td><code id="maximum.bipartite.matching_+3A_eps">eps</code></td>
<td>
<p>A small real number used in equality tests in the weighted
bipartite matching algorithm. Two real numbers are considered equal in
the algorithm if their difference is smaller than <code>eps</code>. This is
required to avoid the accumulation of numerical errors. By default it is
set to the smallest <code class="reqn">x</code>, such that <code class="reqn">1+x \ne 1</code>
holds. If you are running the algorithm with no weights, this argument
is ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='maximum.cardinality.search'>Maximum cardinality search</h2><span id='topic+maximum.cardinality.search'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>maximum.cardinality.search()</code> was renamed to <code>max_cardinality()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximum.cardinality.search(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximum.cardinality.search_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored, as the algorithm is defined for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='membership'>Functions to deal with the result of network community detection</h2><span id='topic+membership'></span><span id='topic+print.communities'></span><span id='topic+modularity.communities'></span><span id='topic+length.communities'></span><span id='topic+sizes'></span><span id='topic+algorithm'></span><span id='topic+merges'></span><span id='topic+crossing'></span><span id='topic+code_len'></span><span id='topic+is_hierarchical'></span><span id='topic+as.dendrogram.communities'></span><span id='topic+as.hclust.communities'></span><span id='topic+cut_at'></span><span id='topic+show_trace'></span><span id='topic+plot.communities'></span><span id='topic+communities'></span>

<h3>Description</h3>

<p>igraph community detection functions return their results as an object from
the <code>communities</code> class. This manual page describes the operations of
this class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>membership(communities)

## S3 method for class 'communities'
print(x, ...)

## S3 method for class 'communities'
modularity(x, ...)

## S3 method for class 'communities'
length(x)

sizes(communities)

algorithm(communities)

merges(communities)

crossing(communities, graph)

code_len(communities)

is_hierarchical(communities)

## S3 method for class 'communities'
as.dendrogram(object, hang = -1, use.modularity = FALSE, ...)

## S3 method for class 'communities'
as.hclust(x, hang = -1, use.modularity = FALSE, ...)

cut_at(communities, no, steps)

show_trace(communities)

## S3 method for class 'communities'
plot(
  x,
  y,
  col = membership(x),
  mark.groups = communities(x),
  edge.color = c("black", "red")[crossing(x, y) + 1],
  ...
)

communities(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="membership_+3A_communities">communities</code>, <code id="membership_+3A_x">x</code>, <code id="membership_+3A_object">object</code></td>
<td>
<p>A <code>communities</code> object, the result of an
igraph community detection function.</p>
</td></tr>
<tr><td><code id="membership_+3A_...">...</code></td>
<td>
<p>Additional arguments. <code>plot.communities</code> passes these to
<code><a href="#topic+plot.igraph">plot.igraph()</a></code>. The other functions silently ignore
them.</p>
</td></tr>
<tr><td><code id="membership_+3A_graph">graph</code></td>
<td>
<p>An igraph graph object, corresponding to <code>communities</code>.</p>
</td></tr>
<tr><td><code id="membership_+3A_hang">hang</code></td>
<td>
<p>Numeric scalar indicating how the height of leaves should be
computed from the heights of their parents; see <code><a href="stats.html#topic+plot.hclust">plot.hclust()</a></code>.</p>
</td></tr>
<tr><td><code id="membership_+3A_use.modularity">use.modularity</code></td>
<td>
<p>Logical scalar, whether to use the modularity values
to define the height of the branches.</p>
</td></tr>
<tr><td><code id="membership_+3A_no">no</code></td>
<td>
<p>Integer scalar, the desired number of communities. If too low or
two high, then an error message is given. Exactly one of <code>no</code> and
<code>steps</code> must be supplied.</p>
</td></tr>
<tr><td><code id="membership_+3A_steps">steps</code></td>
<td>
<p>The number of merge operations to perform to produce the
communities. Exactly one of <code>no</code> and <code>steps</code> must be supplied.</p>
</td></tr>
<tr><td><code id="membership_+3A_y">y</code></td>
<td>
<p>An igraph graph object, corresponding to the communities in
<code>x</code>.</p>
</td></tr>
<tr><td><code id="membership_+3A_col">col</code></td>
<td>
<p>A vector of colors, in any format that is accepted by the regular
R plotting methods. This vector gives the colors of the vertices explicitly.</p>
</td></tr>
<tr><td><code id="membership_+3A_mark.groups">mark.groups</code></td>
<td>
<p>A list of numeric vectors. The communities can be
highlighted using colored polygons. The groups for which the polygons are
drawn are given here. The default is to use the groups given by the
communities. Supply <code>NULL</code> here if you do not want to highlight any
groups.</p>
</td></tr>
<tr><td><code id="membership_+3A_edge.color">edge.color</code></td>
<td>
<p>The colors of the edges. By default the edges within
communities are colored green and other edges are red.</p>
</td></tr>
<tr><td><code id="membership_+3A_membership">membership</code></td>
<td>
<p>Numeric vector, one value for each vertex, the membership
vector of the community structure. Might also be <code>NULL</code> if the
community structure is given in another way, e.g. by a merge matrix.</p>
</td></tr>
<tr><td><code id="membership_+3A_algorithm">algorithm</code></td>
<td>
<p>If not <code>NULL</code> (meaning an unknown algorithm), then a
character scalar, the name of the algorithm that produced the community
structure.</p>
</td></tr>
<tr><td><code id="membership_+3A_merges">merges</code></td>
<td>
<p>If not <code>NULL</code>, then the merge matrix of the hierarchical
community structure. See <code>merges()</code> below for more information on its
format.</p>
</td></tr>
<tr><td><code id="membership_+3A_modularity">modularity</code></td>
<td>
<p>Numeric scalar or vector, the modularity value of the
community structure. It can also be <code>NULL</code>, if the modularity of the
(best) split is not available.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Community structure detection algorithms try to find dense subgraphs in
directed or undirected graphs, by optimizing some criteria, and usually
using heuristics.
</p>
<p>igraph implements a number of community detection methods (see them below),
all of which return an object of the class <code>communities</code>. Because the
community structure detection algorithms are different, <code>communities</code>
objects do not always have the same structure. Nevertheless, they have some
common operations, these are documented here.
</p>
<p>The <code><a href="base.html#topic+print">print()</a></code> generic function is defined for <code>communities</code>, it
prints a short summary.
</p>
<p>The <code>length</code> generic function call be called on <code>communities</code> and
returns the number of communities.
</p>
<p>The <code>sizes()</code> function returns the community sizes, in the order of their
ids.
</p>
<p><code>membership()</code> gives the division of the vertices, into communities. It
returns a numeric vector, one value for each vertex, the id of its
community. Community ids start from one. Note that some algorithms calculate
the complete (or incomplete) hierarchical structure of the communities, and
not just a single partitioning. For these algorithms typically the
membership for the highest modularity value is returned, but see also the
manual pages of the individual algorithms.
</p>
<p><code>communities()</code> is also the name of a function, that returns a list of
communities, each identified by their vertices. The vertices will have
symbolic names if the <code>add.vertex.names</code> igraph option is set, and the
graph itself was named. Otherwise numeric vertex ids are used.
</p>
<p><code>modularity()</code> gives the modularity score of the partitioning. (See
<code><a href="#topic+modularity.igraph">modularity.igraph()</a></code> for details. For algorithms that do not
result a single partitioning, the highest modularity value is returned.
</p>
<p><code>algorithm()</code> gives the name of the algorithm that was used to calculate
the community structure.
</p>
<p><code>crossing()</code> returns a logical vector, with one value for each edge,
ordered according to the edge ids. The value is <code>TRUE</code> iff the edge
connects two different communities, according to the (best) membership
vector, as returned by <code>membership()</code>.
</p>
<p><code>is_hierarchical()</code> checks whether a hierarchical algorithm was used to
find the community structure. Some functions only make sense for
hierarchical methods (e.g. <code>merges()</code>, <code>cut_at()</code> and
<code><a href="stats.html#topic+as.dendrogram">as.dendrogram()</a></code>).
</p>
<p><code>merges()</code> returns the merge matrix for hierarchical methods. An error
message is given, if a non-hierarchical method was used to find the
community structure. You can check this by calling <code>is_hierarchical()</code> on
the <code>communities</code> object.
</p>
<p><code>cut_at()</code> cuts the merge tree of a hierarchical community finding method,
at the desired place and returns a membership vector. The desired place can
be expressed as the desired number of communities or as the number of merge
steps to make. The function gives an error message, if called with a
non-hierarchical method.
</p>
<p><code><a href="stats.html#topic+as.dendrogram">as.dendrogram()</a></code> converts a hierarchical community structure to a
<code>dendrogram</code> object. It only works for hierarchical methods, and gives
an error message to others. See <code><a href="stats.html#topic+dendrogram">stats::dendrogram()</a></code> for details.
</p>
<p><code><a href="stats.html#topic+as.hclust">stats::as.hclust()</a></code> is similar to <code><a href="stats.html#topic+as.dendrogram">as.dendrogram()</a></code>, but converts a
hierarchical community structure to a <code>hclust</code> object.
</p>
<p><code><a href="ape.html#topic+as.phylo">ape::as.phylo()</a></code> converts a hierarchical community structure to a <code>phylo</code>
object, you will need the <code>ape</code> package for this.
</p>
<p><code>show_trace()</code> works (currently) only for communities found by the leading
eigenvector method (<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen()</a></code>), and
returns a character vector that gives the steps performed by the algorithm
while finding the communities.
</p>
<p><code>code_len()</code> is defined for the InfoMAP method
(<code><a href="#topic+cluster_infomap">cluster_infomap()</a></code> and returns the code length of the
partition.
</p>
<p>It is possibly to call the <code><a href="base.html#topic+plot">plot()</a></code> function on <code>communities</code>
objects. This will plot the graph (and uses <code><a href="#topic+plot.igraph">plot.igraph()</a></code>
internally), with the communities shown. By default it colores the vertices
according to their communities, and also marks the vertex groups
corresponding to the communities. It passes additional arguments to
<code><a href="#topic+plot.igraph">plot.igraph()</a></code>, please see that and also
<a href="#topic+igraph.plotting">igraph.plotting</a> on how to change the plot.
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+print">print()</a></code> returns the <code>communities</code> object itself,
invisibly.
</p>
<p><code>length</code> returns an integer scalar.
</p>
<p><code>sizes()</code> returns a numeric vector.
</p>
<p><code>membership()</code> returns a numeric vector, one number for each vertex in
the graph that was the input of the community detection.
</p>
<p><code>modularity()</code> returns a numeric scalar.
</p>
<p><code>algorithm()</code> returns a character scalar.
</p>
<p><code>crossing()</code> returns a logical vector.
</p>
<p><code>is_hierarchical()</code> returns a logical scalar.
</p>
<p><code>merges()</code> returns a two-column numeric matrix.
</p>
<p><code>cut_at()</code> returns a numeric vector, the membership vector of the
vertices.
</p>
<p><code><a href="stats.html#topic+as.dendrogram">as.dendrogram()</a></code> returns a <a href="stats.html#topic+dendrogram">dendrogram</a> object.
</p>
<p><code>show_trace()</code> returns a character vector.
</p>
<p><code>code_len()</code> returns a numeric scalar for communities found with the
InfoMAP method and <code>NULL</code> for other methods.
</p>
<p><code><a href="base.html#topic+plot">plot()</a></code> for <code>communities</code> objects returns <code>NULL</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+plot_dendrogram">plot_dendrogram()</a></code> for plotting community structure
dendrograms.
</p>
<p>See <code><a href="#topic+compare">compare()</a></code> for comparing two community structures
on the same graph.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
karate &lt;- make_graph("Zachary")
wc &lt;- cluster_walktrap(karate)
modularity(wc)
membership(wc)
plot(wc, karate)

</code></pre>

<hr>
<h2 id='merge_coords'>Merging graph layouts</h2><span id='topic+merge_coords'></span><span id='topic+layout_components'></span>

<h3>Description</h3>

<p>Place several graphs on the same layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_coords(graphs, layouts, method = "dla")

layout_components(graph, layout = layout_with_kk, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_coords_+3A_graphs">graphs</code></td>
<td>
<p>A list of graph objects.</p>
</td></tr>
<tr><td><code id="merge_coords_+3A_layouts">layouts</code></td>
<td>
<p>A list of two-column matrices.</p>
</td></tr>
<tr><td><code id="merge_coords_+3A_method">method</code></td>
<td>
<p>Character constant giving the method to use. Right now only
<code>dla</code> is implemented.</p>
</td></tr>
<tr><td><code id="merge_coords_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="merge_coords_+3A_layout">layout</code></td>
<td>
<p>A function object, the layout function to use.</p>
</td></tr>
<tr><td><code id="merge_coords_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code>layout</code> layout
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>merge_coords()</code> takes a list of graphs and a list of coordinates and
places the graphs in a common layout. The method to use is chosen via the
<code>method</code> parameter, although right now only the <code>dla</code> method is
implemented.
</p>
<p>The <code>dla</code> method covers the graph with circles.  Then it sorts the
graphs based on the number of vertices first and places the largest graph at
the center of the layout. Then the other graphs are placed in decreasing
order via a DLA (diffision limited aggregation) algorithm: the graph is
placed randomly on a circle far away from the center and a random walk is
conducted until the graph walks into the larger graphs already placed or
walks too far from the center of the layout.
</p>
<p>The <code>layout_components()</code> function disassembles the graph first into
maximal connected components and calls the supplied <code>layout</code> function
for each component separately. Finally it merges the layouts via calling
<code>merge_coords()</code>.
</p>


<h3>Value</h3>

<p>A matrix with two columns and as many lines as the total number of
vertices in the graphs.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.igraph">plot.igraph()</a></code>, <code><a href="#topic+tkplot">tkplot()</a></code>,
<code><a href="#topic+layout">layout()</a></code>, <code><a href="#topic+disjoint_union">disjoint_union()</a></code>
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create 20 scale-free graphs and place them in a common layout
graphs &lt;- lapply(sample(5:20, 20, replace = TRUE),
  barabasi.game,
  directed = FALSE
)
layouts &lt;- lapply(graphs, layout_with_kk)
lay &lt;- merge_coords(graphs, layouts)
g &lt;- disjoint_union(graphs)
plot(g, layout = lay, vertex.size = 3, labels = NA, edge.color = "black")
</code></pre>

<hr>
<h2 id='min_cut'>Minimum cut in a graph</h2><span id='topic+min_cut'></span>

<h3>Description</h3>

<p><code>min_cut()</code> calculates the minimum st-cut between two vertices in a graph
(if the <code>source</code> and <code>target</code> arguments are given) or the minimum
cut of the graph (if both <code>source</code> and <code>target</code> are <code>NULL</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_cut(
  graph,
  source = NULL,
  target = NULL,
  capacity = NULL,
  value.only = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_cut_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="min_cut_+3A_source">source</code></td>
<td>
<p>The id of the source vertex.</p>
</td></tr>
<tr><td><code id="min_cut_+3A_target">target</code></td>
<td>
<p>The id of the target vertex (sometimes also called sink).</p>
</td></tr>
<tr><td><code id="min_cut_+3A_capacity">capacity</code></td>
<td>
<p>Vector giving the capacity of the edges. If this is
<code>NULL</code> (the default) then the <code>capacity</code> edge attribute is used.</p>
</td></tr>
<tr><td><code id="min_cut_+3A_value.only">value.only</code></td>
<td>
<p>Logical scalar, if <code>TRUE</code> only the minimum cut value
is returned, if <code>FALSE</code> the edges in the cut and a the two (or more)
partitions are also returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The minimum st-cut between <code>source</code> and <code>target</code> is the minimum
total weight of edges needed to remove to eliminate all paths from
<code>source</code> to <code>target</code>.
</p>
<p>The minimum cut of a graph is the minimum total weight of the edges needed
to remove to separate the graph into (at least) two components. (Which is to
make the graph <em>not</em> strongly connected in the directed case.)
</p>
<p>The maximum flow between two vertices in a graph is the same as the minimum
st-cut, so <code>max_flow()</code> and <code>min_cut()</code> essentially calculate the same
quantity, the only difference is that <code>min_cut()</code> can be invoked without
giving the <code>source</code> and <code>target</code> arguments and then minimum of all
possible minimum cuts is calculated.
</p>
<p>For undirected graphs the Stoer-Wagner algorithm (see reference below) is
used to calculate the minimum cut.
</p>


<h3>Value</h3>

<p>For <code>min_cut()</code> a nuieric constant, the value of the minimum
cut, except if <code>value.only = FALSE</code>. In this case a named list with
components:
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>Numeric scalar, the cut value.</p>
</td></tr>
<tr><td><code>cut</code></td>
<td>
<p>Numeric vector, the edges in the cut.</p>
</td></tr>
<tr><td><code>partition1</code></td>
<td>
<p>The vertices in the first partition after the cut
edges are removed. Note that these vertices might be actually in
different components (after the cut edges are removed), as the graph
may fall apart into more than two components.</p>
</td></tr>
<tr><td><code>partition2</code></td>
<td>
<p>The vertices in the second partition
after the cut edges are removed. Note that these vertices might be
actually in different components (after the cut edges are removed), as
the graph may fall apart into more than two components.</p>
</td></tr>
</table>


<h3>References</h3>

<p>M. Stoer and F. Wagner: A simple min-cut algorithm,
<em>Journal of the ACM</em>, 44 585-591, 1997.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(100)
min_cut(g, capacity = rep(1, vcount(g)))
min_cut(g, value.only = FALSE, capacity = rep(1, vcount(g)))

g2 &lt;- make_graph(c(1, 2, 2, 3, 3, 4, 1, 6, 6, 5, 5, 4, 4, 1))
E(g2)$capacity &lt;- c(3, 1, 2, 10, 1, 3, 2)
min_cut(g2, value.only = FALSE)
</code></pre>

<hr>
<h2 id='min_separators'>Minimum size vertex separators</h2><span id='topic+min_separators'></span>

<h3>Description</h3>

<p>Find all vertex sets of minimal size whose removal separates the graph into
more components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_separators(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_separators_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the Kanevsky algorithm for finding all minimal-size
vertex separators in an undirected graph. See the reference below for the
details.
</p>
<p>In the special case of a fully connected input graph with <code class="reqn">n</code> vertices,
all subsets of size <code class="reqn">n-1</code> are listed as the result.
</p>


<h3>Value</h3>

<p>A list of numeric vectors. Each numeric vector is a vertex
separator.
</p>


<h3>References</h3>

<p>Arkady Kanevsky: Finding all minimum-size separating vertex sets
in a graph. <em>Networks</em> 23 533&ndash;541, 1993.
</p>
<p>JS Provan and DR Shier: A Paradigm for listing (s,t)-cuts in graphs,
<em>Algorithmica</em> 15, 351&ndash;372, 1996.
</p>
<p>J. Moody and D. R. White. Structural cohesion and embeddedness: A
hierarchical concept of social groups. <em>American Sociological Review</em>,
68 103&ndash;127, Feb 2003.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The graph from the Moody-White paper
mw &lt;- graph_from_literal(
  1 - 2:3:4:5:6, 2 - 3:4:5:7, 3 - 4:6:7, 4 - 5:6:7,
  5 - 6:7:21, 6 - 7, 7 - 8:11:14:19, 8 - 9:11:14, 9 - 10,
  10 - 12:13, 11 - 12:14, 12 - 16, 13 - 16, 14 - 15, 15 - 16,
  17 - 18:19:20, 18 - 20:21, 19 - 20:22:23, 20 - 21,
  21 - 22:23, 22 - 23
)

# Cohesive subgraphs
mw1 &lt;- induced_subgraph(mw, as.character(c(1:7, 17:23)))
mw2 &lt;- induced_subgraph(mw, as.character(7:16))
mw3 &lt;- induced_subgraph(mw, as.character(17:23))
mw4 &lt;- induced_subgraph(mw, as.character(c(7, 8, 11, 14)))
mw5 &lt;- induced_subgraph(mw, as.character(1:7))

min_separators(mw)
min_separators(mw1)
min_separators(mw2)
min_separators(mw3)
min_separators(mw4)
min_separators(mw5)

# Another example, the science camp network
camp &lt;- graph_from_literal(
  Harry:Steve:Don:Bert - Harry:Steve:Don:Bert,
  Pam:Brazey:Carol:Pat - Pam:Brazey:Carol:Pat,
  Holly - Carol:Pat:Pam:Jennie:Bill,
  Bill - Pauline:Michael:Lee:Holly,
  Pauline - Bill:Jennie:Ann,
  Jennie - Holly:Michael:Lee:Ann:Pauline,
  Michael - Bill:Jennie:Ann:Lee:John,
  Ann - Michael:Jennie:Pauline,
  Lee - Michael:Bill:Jennie,
  Gery - Pat:Steve:Russ:John,
  Russ - Steve:Bert:Gery:John,
  John - Gery:Russ:Michael
)
min_separators(camp)
</code></pre>

<hr>
<h2 id='min_st_separators'>Minimum size vertex separators</h2><span id='topic+min_st_separators'></span>

<h3>Description</h3>

<p>List all vertex sets that are minimal <code class="reqn">(s,t)</code> separators for some
<code class="reqn">s</code> and <code class="reqn">t</code>, in an undirected graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_st_separators(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_st_separators_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code class="reqn">(s,t)</code> vertex separator is a set of vertices, such that after their
removal from the graph, there is no path between <code class="reqn">s</code> and <code class="reqn">t</code> in the
graph.
</p>
<p>A <code class="reqn">(s,t)</code> vertex separator is minimal if none of its proper subsets is
an <code class="reqn">(s,t)</code> vertex separator for the same <code class="reqn">s</code> and <code class="reqn">t</code>.
</p>


<h3>Value</h3>

<p>A list of numeric vectors. Each vector contains a vertex set
(defined by vertex ids), each vector is an (s,t) separator of the input
graph, for some <code class="reqn">s</code> and <code class="reqn">t</code>.
</p>


<h3>Note</h3>

<p>Note that the code below returns <code style="white-space: pre;">&#8288;{1, 3}&#8288;</code> despite its subset <code>{1}</code> being a
separator as well. This is because <code style="white-space: pre;">&#8288;{1, 3}&#8288;</code> is minimal with respect to
separating vertices 2 and 4.
</p>
<div class="sourceCode r"><pre>g &lt;- make_graph(~ 0-1-2-3-4-1)
min_st_separators(g)
</pre></div>
<div class="sourceCode"><pre>#&gt; [[1]]
#&gt; + 1/5 vertex, named:
#&gt; [1] 1
#&gt; 
#&gt; [[2]]
#&gt; + 2/5 vertices, named:
#&gt; [1] 2 4
#&gt; 
#&gt; [[3]]
#&gt; + 2/5 vertices, named:
#&gt; [1] 1 3
</pre></div>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Anne Berry, Jean-Paul Bordat and Olivier Cogis: Generating All
the Minimal Separators of a Graph, In: Peter Widmayer, Gabriele Neyer and
Stephan Eidenbenz (editors): <em>Graph-theoretic concepts in computer
science</em>, 1665, 167&ndash;172, 1999. Springer.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ring &lt;- make_ring(4)
min_st_separators(ring)

chvatal &lt;- make_graph("chvatal")
min_st_separators(chvatal)
# https://github.com/r-lib/roxygen2/issues/1092
</code></pre>

<hr>
<h2 id='minimal.st.separators'>Minimum size vertex separators</h2><span id='topic+minimal.st.separators'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>minimal.st.separators()</code> was renamed to <code>min_st_separators()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimal.st.separators(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimal.st.separators_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='minimum.size.separators'>Minimum size vertex separators</h2><span id='topic+minimum.size.separators'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>minimum.size.separators()</code> was renamed to <code>min_separators()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimum.size.separators(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimum.size.separators_+3A_graph">graph</code></td>
<td>
<p>The input graph. It may be directed, but edge directions are
ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='minimum.spanning.tree'>Minimum spanning tree</h2><span id='topic+minimum.spanning.tree'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>minimum.spanning.tree()</code> was renamed to <code>mst()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimum.spanning.tree(graph, weights = NULL, algorithm = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimum.spanning.tree_+3A_graph">graph</code></td>
<td>
<p>The graph object to analyze.</p>
</td></tr>
<tr><td><code id="minimum.spanning.tree_+3A_weights">weights</code></td>
<td>
<p>Numeric vector giving the weights of the edges in the
graph. The order is determined by the edge ids. This is ignored if the
<code>unweighted</code> algorithm is chosen. Edge weights are interpreted as
distances.</p>
</td></tr>
<tr><td><code id="minimum.spanning.tree_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use for calculation. <code>unweighted</code> can
be used for unweighted graphs, and <code>prim</code> runs Prim's algorithm for
weighted graphs.  If this is <code>NULL</code> then igraph will select the
algorithm automatically: if the graph has an edge attribute called
<code>weight</code> or the <code>weights</code> argument is not <code>NULL</code> then Prim's
algorithm is chosen, otherwise the unweighted algorithm is used.</p>
</td></tr>
<tr><td><code id="minimum.spanning.tree_+3A_...">...</code></td>
<td>
<p>Additional arguments, unused.</p>
</td></tr>
</table>

<hr>
<h2 id='mod.matrix'>Modularity of a community structure of a graph</h2><span id='topic+mod.matrix'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>mod.matrix()</code> was renamed to <code>modularity_matrix()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod.matrix(graph, membership, weights = NULL, resolution = 1, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod.matrix_+3A_membership">membership</code></td>
<td>
<p>Numeric vector, one value for each vertex, the membership
vector of the community structure.</p>
</td></tr>
<tr><td><code id="mod.matrix_+3A_weights">weights</code></td>
<td>
<p>If not <code>NULL</code> then a numeric vector giving edge weights.</p>
</td></tr>
<tr><td><code id="mod.matrix_+3A_resolution">resolution</code></td>
<td>
<p>The resolution parameter. Must be greater than or equal to
0. Set it to 1 to use the classical definition of modularity.</p>
</td></tr>
<tr><td><code id="mod.matrix_+3A_directed">directed</code></td>
<td>
<p>Whether to use the directed or undirected version of
modularity. Ignored for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='modularity.igraph'>Modularity of a community structure of a graph</h2><span id='topic+modularity.igraph'></span><span id='topic+modularity'></span><span id='topic+modularity_matrix'></span>

<h3>Description</h3>

<p>This function calculates how modular is a given division of a graph into
subgraphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
modularity(x, membership, weights = NULL, resolution = 1, directed = TRUE, ...)

modularity_matrix(
  graph,
  membership,
  weights = NULL,
  resolution = 1,
  directed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modularity.igraph_+3A_x">x</code>, <code id="modularity.igraph_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="modularity.igraph_+3A_membership">membership</code></td>
<td>
<p>Numeric vector, one value for each vertex, the membership
vector of the community structure.</p>
</td></tr>
<tr><td><code id="modularity.igraph_+3A_weights">weights</code></td>
<td>
<p>If not <code>NULL</code> then a numeric vector giving edge weights.</p>
</td></tr>
<tr><td><code id="modularity.igraph_+3A_resolution">resolution</code></td>
<td>
<p>The resolution parameter. Must be greater than or equal to
0. Set it to 1 to use the classical definition of modularity.</p>
</td></tr>
<tr><td><code id="modularity.igraph_+3A_directed">directed</code></td>
<td>
<p>Whether to use the directed or undirected version of
modularity. Ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="modularity.igraph_+3A_...">...</code></td>
<td>
<p>Additional arguments, none currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modularity()</code> calculates the modularity of a graph with respect to the
given <code>membership</code> vector.
</p>
<p>The modularity of a graph with respect to some division (or vertex types)
measures how good the division is, or how separated are the different vertex
types from each other. It defined as </p>
<p style="text-align: center;"><code class="reqn">Q=\frac{1}{2m} \sum_{i,j}
(A_{ij}-\gamma\frac{k_i k_j}{2m})\delta(c_i,c_j),</code>
</p>
<p> here <code class="reqn">m</code> is the number of edges, <code class="reqn">A_{ij}</code>
is the element of the <code class="reqn">A</code> adjacency matrix in row <code class="reqn">i</code> and column
<code class="reqn">j</code>, <code class="reqn">k_i</code> is the degree of <code class="reqn">i</code>, <code class="reqn">k_j</code> is the degree
of <code class="reqn">j</code>, <code class="reqn">c_i</code> is the type (or component) of <code class="reqn">i</code>,
<code class="reqn">c_j</code> that of <code class="reqn">j</code>, the sum goes over all <code class="reqn">i</code> and <code class="reqn">j</code>
pairs of vertices, and <code class="reqn">\delta(x,y)</code> is 1 if <code class="reqn">x=y</code> and 0
otherwise. For directed graphs, it is defined as
</p>
<p style="text-align: center;"><code class="reqn">Q = \frac{1}{m} \sum_{i,j} (A_{ij}-\gamma
\frac{k_i^{out} k_j^{in}}{m})\delta(c_i,c_j).</code>
</p>

<p>The resolution parameter <code class="reqn">\gamma</code> allows weighting the random
null model, which might be useful when finding partitions with a high
modularity. Maximizing modularity with higher values of the resolution
parameter typically results in more, smaller clusters when finding
partitions with a high modularity. Lower values typically results in fewer,
larger clusters. The original definition of modularity is retrieved when
setting <code class="reqn">\gamma</code> to 1.
</p>
<p>If edge weights are given, then these are considered as the element of the
<code class="reqn">A</code> adjacency matrix, and <code class="reqn">k_i</code> is the sum of weights of
adjacent edges for vertex <code class="reqn">i</code>.
</p>
<p><code>modularity_matrix()</code> calculates the modularity matrix. This is a dense matrix,
and it is defined as the difference of the adjacency matrix and the
configuration model null model matrix. In other words element
<code class="reqn">M_{ij}</code> is given as <code class="reqn">A_{ij}-d_i
d_j/(2m)</code>, where <code class="reqn">A_{ij}</code> is the (possibly
weighted) adjacency matrix, <code class="reqn">d_i</code> is the degree of vertex <code class="reqn">i</code>,
and <code class="reqn">m</code> is the number of edges (or the total weights in the graph, if it
is weighed).
</p>


<h3>Value</h3>

<p>For <code>modularity()</code> a numeric scalar, the modularity score of the
given configuration.
</p>
<p>For <code>modularity_matrix()</code> a numeric square matrix, its order is the number of
vertices in the graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Clauset, A.; Newman, M. E. J. &amp; Moore, C. Finding community
structure in very large networks, <em>Physical Review E</em> 2004, 70, 066111
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster_walktrap">cluster_walktrap()</a></code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness()</a></code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy()</a></code>, <code><a href="#topic+cluster_spinglass">cluster_spinglass()</a></code>,
<code><a href="#topic+cluster_louvain">cluster_louvain()</a></code> and <code><a href="#topic+cluster_leiden">cluster_leiden()</a></code> for
various community detection methods.
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_full_graph(5) %du% make_full_graph(5) %du% make_full_graph(5)
g &lt;- add_edges(g, c(1, 6, 1, 11, 6, 11))
wtc &lt;- cluster_walktrap(g)
modularity(wtc)
modularity(g, membership(wtc))

</code></pre>

<hr>
<h2 id='motifs'>Graph motifs</h2><span id='topic+motifs'></span>

<h3>Description</h3>

<p>Graph motifs are small connected induced subgraphs with a well-defined
structure.  These functions search a graph for various motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>motifs(graph, size = 3, cut.prob = rep(0, size))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="motifs_+3A_graph">graph</code></td>
<td>
<p>Graph object, the input graph.</p>
</td></tr>
<tr><td><code id="motifs_+3A_size">size</code></td>
<td>
<p>The size of the motif, currently sizes 3 and 4 are supported in
directed graphs and sizes 3-6 in undirected graphs.</p>
</td></tr>
<tr><td><code id="motifs_+3A_cut.prob">cut.prob</code></td>
<td>
<p>Numeric vector giving the probabilities that the search
graph is cut at a certain level. Its length should be the same as the size
of the motif (the <code>size</code> argument). By default no cuts are made.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>motifs()</code> searches a graph for motifs of a given size and returns a
numeric vector containing the number of different motifs. The order of
the motifs is defined by their isomorphism class, see
<code><a href="#topic+isomorphism_class">isomorphism_class()</a></code>.
</p>


<h3>Value</h3>

<p><code>motifs()</code> returns a numeric vector, the number of occurrences of
each motif in the graph. The motifs are ordered by their isomorphism
classes. Note that for unconnected subgraphs, which are not considered to be
motifs, the result will be <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isomorphism_class">isomorphism_class()</a></code>
</p>
<p>Other graph motifs: 
<code><a href="#topic+count_motifs">count_motifs</a>()</code>,
<code><a href="#topic+dyad_census">dyad_census</a>()</code>,
<code><a href="#topic+sample_motifs">sample_motifs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_pa(100)
motifs(g, 3)
count_motifs(g, 3)
sample_motifs(g, 3)
</code></pre>

<hr>
<h2 id='mst'>Minimum spanning tree</h2><span id='topic+mst'></span>

<h3>Description</h3>

<p>A <em>spanning tree</em> of a connected graph is a connected subgraph with
the smallest number of edges that includes all vertices of the graph.
A graph will have many spanning trees. Among these, the <em>minimum spanning
tree</em> will have the smallest sum of edge weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mst(graph, weights = NULL, algorithm = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mst_+3A_graph">graph</code></td>
<td>
<p>The graph object to analyze.</p>
</td></tr>
<tr><td><code id="mst_+3A_weights">weights</code></td>
<td>
<p>Numeric vector giving the weights of the edges in the
graph. The order is determined by the edge ids. This is ignored if the
<code>unweighted</code> algorithm is chosen. Edge weights are interpreted as
distances.</p>
</td></tr>
<tr><td><code id="mst_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use for calculation. <code>unweighted</code> can
be used for unweighted graphs, and <code>prim</code> runs Prim's algorithm for
weighted graphs.  If this is <code>NULL</code> then igraph will select the
algorithm automatically: if the graph has an edge attribute called
<code>weight</code> or the <code>weights</code> argument is not <code>NULL</code> then Prim's
algorithm is chosen, otherwise the unweighted algorithm is used.</p>
</td></tr>
<tr><td><code id="mst_+3A_...">...</code></td>
<td>
<p>Additional arguments, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>minimum spanning forest</em> of a disconnected graph is the collection
of minimum spanning trees of all of its components.
</p>
<p>If the graph is not connected a minimum spanning forest is returned.
</p>


<h3>Value</h3>

<p>A graph object with the minimum spanning forest. To check whether it
is a tree, check that the number of its edges is <code>vcount(graph)-1</code>.
The edge and vertex attributes of the original graph are preserved in the
result.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Prim, R.C. 1957. Shortest connection networks and some
generalizations <em>Bell System Technical Journal</em>, 37 1389&ndash;1401.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+components">components()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(100, 3 / 100)
g_mst &lt;- mst(g)

</code></pre>

<hr>
<h2 id='multilevel.community'>Finding community structure by multi-level optimization of modularity</h2><span id='topic+multilevel.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>multilevel.community()</code> was renamed to <code>cluster_louvain()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilevel.community(graph, weights = NULL, resolution = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multilevel.community_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="multilevel.community_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="multilevel.community_+3A_resolution">resolution</code></td>
<td>
<p>Optional resolution parameter that allows the user to
adjust the resolution parameter of the modularity function that the algorithm
uses internally. Lower values typically yield fewer, larger clusters. The
original definition of modularity is recovered when the resolution parameter
is set to 1.</p>
</td></tr>
</table>

<hr>
<h2 id='neighborhood.size'>Neighborhood of graph vertices</h2><span id='topic+neighborhood.size'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>neighborhood.size()</code> was renamed to <code>ego_size()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighborhood.size(
  graph,
  order = 1,
  nodes = V(graph),
  mode = c("all", "out", "in"),
  mindist = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighborhood.size_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="neighborhood.size_+3A_order">order</code></td>
<td>
<p>Integer giving the order of the neighborhood.</p>
</td></tr>
<tr><td><code id="neighborhood.size_+3A_nodes">nodes</code></td>
<td>
<p>The vertices for which the calculation is performed.</p>
</td></tr>
<tr><td><code id="neighborhood.size_+3A_mode">mode</code></td>
<td>
<p>Character constant, it specifies how to use the direction of
the edges if a directed graph is analyzed. For &lsquo;out&rsquo; only the
outgoing edges are followed, so all vertices reachable from the source
vertex in at most <code>order</code> steps are counted. For &lsquo;&quot;in&quot;&rsquo; all
vertices from which the source vertex is reachable in at most <code>order</code>
steps are counted. &lsquo;&quot;all&quot;&rsquo; ignores the direction of the edges. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="neighborhood.size_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance to include the vertex in the result.</p>
</td></tr>
</table>

<hr>
<h2 id='neighbors'>Neighboring (adjacent) vertices in a graph</h2><span id='topic+neighbors'></span>

<h3>Description</h3>

<p>A vertex is a neighbor of another one (in other words, the two
vertices are adjacent), if they are incident to the same edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbors(graph, v, mode = c("out", "in", "all", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbors_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="neighbors_+3A_v">v</code></td>
<td>
<p>The vertex of which the adjacent vertices are queried.</p>
</td></tr>
<tr><td><code id="neighbors_+3A_mode">mode</code></td>
<td>
<p>Whether to query outgoing (&lsquo;out&rsquo;), incoming
(&lsquo;in&rsquo;) edges, or both types (&lsquo;all&rsquo;). This is
ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vertex sequence containing the neighbors of the input vertex.
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+tail_of">tail_of</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_graph("Zachary")
n1 &lt;- neighbors(g, 1)
n34 &lt;- neighbors(g, 34)
intersection(n1, n34)
</code></pre>

<hr>
<h2 id='no.clusters'>Connected components of a graph</h2><span id='topic+no.clusters'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>no.clusters()</code> was renamed to <code>count_components()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>no.clusters(graph, mode = c("weak", "strong"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="no.clusters_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="no.clusters_+3A_mode">mode</code></td>
<td>
<p>Character string, either &ldquo;weak&rdquo; or &ldquo;strong&rdquo;.  For
directed graphs &ldquo;weak&rdquo; implies weakly, &ldquo;strong&rdquo; strongly
connected components to search. It is ignored for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='norm_coords'>Normalize coordinates for plotting graphs</h2><span id='topic+norm_coords'></span>

<h3>Description</h3>

<p>Rescale coordinates linearly to be within given bounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_coords(
  layout,
  xmin = -1,
  xmax = 1,
  ymin = -1,
  ymax = 1,
  zmin = -1,
  zmax = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_coords_+3A_layout">layout</code></td>
<td>
<p>A matrix with two or three columns, the layout to normalize.</p>
</td></tr>
<tr><td><code id="norm_coords_+3A_xmin">xmin</code>, <code id="norm_coords_+3A_xmax">xmax</code></td>
<td>
<p>The limits for the first coordinate, if one of them or both
are <code>NULL</code> then no normalization is performed along this direction.</p>
</td></tr>
<tr><td><code id="norm_coords_+3A_ymin">ymin</code>, <code id="norm_coords_+3A_ymax">ymax</code></td>
<td>
<p>The limits for the second coordinate, if one of them or
both are <code>NULL</code> then no normalization is performed along this
direction.</p>
</td></tr>
<tr><td><code id="norm_coords_+3A_zmin">zmin</code>, <code id="norm_coords_+3A_zmax">zmax</code></td>
<td>
<p>The limits for the third coordinate, if one of them or both
are <code>NULL</code> then no normalization is performed along this direction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>norm_coords()</code> normalizes a layout, it linearly transforms each
coordinate separately to fit into the given limits.
</p>


<h3>Value</h3>

<p>A numeric matrix with at the same dimension as <code>layout</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+normalize">normalize</a>()</code>
</p>

<hr>
<h2 id='normalize'>Normalize layout</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Scale coordinates of a layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(
  xmin = -1,
  xmax = 1,
  ymin = xmin,
  ymax = xmax,
  zmin = xmin,
  zmax = xmax
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_xmin">xmin</code>, <code id="normalize_+3A_xmax">xmax</code></td>
<td>
<p>Minimum and maximum for x coordinates.</p>
</td></tr>
<tr><td><code id="normalize_+3A_ymin">ymin</code>, <code id="normalize_+3A_ymax">ymax</code></td>
<td>
<p>Minimum and maximum for y coordinates.</p>
</td></tr>
<tr><td><code id="normalize_+3A_zmin">zmin</code>, <code id="normalize_+3A_zmax">zmax</code></td>
<td>
<p>Minimum and maximum for z coordinates.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+merge_coords">merge_coords()</a></code>, <code><a href="#topic+layout_">layout_()</a></code>.
</p>
<p>Other layout modifiers: 
<code><a href="#topic+component_wise">component_wise</a>()</code>
</p>
<p>Other graph layouts: 
<code><a href="#topic+add_layout_">add_layout_</a>()</code>,
<code><a href="#topic+component_wise">component_wise</a>()</code>,
<code><a href="#topic+layout_">layout_</a>()</code>,
<code><a href="#topic+layout_as_bipartite">layout_as_bipartite</a>()</code>,
<code><a href="#topic+layout_as_star">layout_as_star</a>()</code>,
<code><a href="#topic+layout_as_tree">layout_as_tree</a>()</code>,
<code><a href="#topic+layout_in_circle">layout_in_circle</a>()</code>,
<code><a href="#topic+layout_nicely">layout_nicely</a>()</code>,
<code><a href="#topic+layout_on_grid">layout_on_grid</a>()</code>,
<code><a href="#topic+layout_on_sphere">layout_on_sphere</a>()</code>,
<code><a href="#topic+layout_randomly">layout_randomly</a>()</code>,
<code><a href="#topic+layout_with_dh">layout_with_dh</a>()</code>,
<code><a href="#topic+layout_with_fr">layout_with_fr</a>()</code>,
<code><a href="#topic+layout_with_gem">layout_with_gem</a>()</code>,
<code><a href="#topic+layout_with_graphopt">layout_with_graphopt</a>()</code>,
<code><a href="#topic+layout_with_kk">layout_with_kk</a>()</code>,
<code><a href="#topic+layout_with_lgl">layout_with_lgl</a>()</code>,
<code><a href="#topic+layout_with_mds">layout_with_mds</a>()</code>,
<code><a href="#topic+layout_with_sugiyama">layout_with_sugiyama</a>()</code>,
<code><a href="#topic+merge_coords">merge_coords</a>()</code>,
<code><a href="#topic+norm_coords">norm_coords</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout_(make_ring(10), with_fr(), normalize())
</code></pre>

<hr>
<h2 id='optimal.community'>Optimal community structure</h2><span id='topic+optimal.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>optimal.community()</code> was renamed to <code>cluster_optimal()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal.community(graph, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal.community_+3A_graph">graph</code></td>
<td>
<p>The input graph. Edge directions are ignored for directed
graphs.</p>
</td></tr>
<tr><td><code id="optimal.community_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
</table>

<hr>
<h2 id='page_rank'>The Page Rank algorithm</h2><span id='topic+page_rank'></span>

<h3>Description</h3>

<p>Calculates the Google PageRank for the specified vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>page_rank(
  graph,
  algo = c("prpack", "arpack"),
  vids = V(graph),
  directed = TRUE,
  damping = 0.85,
  personalized = NULL,
  weights = NULL,
  options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="page_rank_+3A_graph">graph</code></td>
<td>
<p>The graph object.</p>
</td></tr>
<tr><td><code id="page_rank_+3A_algo">algo</code></td>
<td>
<p>Character scalar, which implementation to use to carry out the
calculation. The default is <code>"prpack"</code>, which uses the PRPACK library
(<a href="https://github.com/dgleich/prpack">https://github.com/dgleich/prpack</a>) to calculate PageRank scores
by solving a set of linear equations. This is a new implementation in igraph
version 0.7, and the suggested one, as it is the most stable and the fastest
for all but small graphs.  <code>"arpack"</code> uses the ARPACK library, the
default implementation from igraph version 0.5 until version 0.7. It computes
PageRank scores by solving an eingevalue problem.</p>
</td></tr>
<tr><td><code id="page_rank_+3A_vids">vids</code></td>
<td>
<p>The vertices of interest.</p>
</td></tr>
<tr><td><code id="page_rank_+3A_directed">directed</code></td>
<td>
<p>Logical, if true directed paths will be considered for
directed graphs. It is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="page_rank_+3A_damping">damping</code></td>
<td>
<p>The damping factor (&lsquo;d&rsquo; in the original paper).</p>
</td></tr>
<tr><td><code id="page_rank_+3A_personalized">personalized</code></td>
<td>
<p>Optional vector giving a probability distribution to
calculate personalized PageRank. For personalized PageRank, the probability
of jumping to a node when abandoning the random walk is not uniform, but it
is given by this vector. The vector should contains an entry for each vertex
and it will be rescaled to sum up to one.</p>
</td></tr>
<tr><td><code id="page_rank_+3A_weights">weights</code></td>
<td>
<p>A numerical vector or <code>NULL</code>. This argument can be used
to give edge weights for calculating the weighted PageRank of vertices. If
this is <code>NULL</code> and the graph has a <code>weight</code> edge attribute then
that is used. If <code>weights</code> is a numerical vector then it used, even if
the graph has a <code>weights</code> edge attribute. If this is <code>NA</code>, then no
edge weights are used (even if the graph has a <code>weight</code> edge attribute.
This function interprets edge weights as connection strengths. In the
random surfer model, an edge with a larger weight is more likely to be
selected by the surfer.</p>
</td></tr>
<tr><td><code id="page_rank_+3A_options">options</code></td>
<td>
<p>A named list, to override some ARPACK options. See
<code><a href="#topic+arpack">arpack()</a></code> for details. This argument is ignored if the PRPACK
implementation is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the explanation of the PageRank algorithm, see the following webpage:
<a href="http://infolab.stanford.edu/~backrub/google.html">http://infolab.stanford.edu/~backrub/google.html</a>, or the following
reference:
</p>
<p>Sergey Brin and Larry Page: The Anatomy of a Large-Scale Hypertextual Web
Search Engine. Proceedings of the 7th World-Wide Web Conference, Brisbane,
Australia, April 1998.
</p>
<p>The <code>page_rank()</code> function can use either the PRPACK library or ARPACK
(see <code><a href="#topic+arpack">arpack()</a></code>) to perform the calculation.
</p>
<p>Please note that the PageRank of a given vertex depends on the PageRank of
all other vertices, so even if you want to calculate the PageRank for only
some of the vertices, all of them must be calculated. Requesting the
PageRank for only some of the vertices does not result in any performance
increase at all.
</p>


<h3>Value</h3>

<p>A named list with entries: </p>
<table>
<tr><td><code>vector</code></td>
<td>
<p>A
numeric vector with the PageRank scores.</p>
</td></tr> <tr><td><code>value</code></td>
<td>
<p>When using the ARPACK
method, the eigenvalue corresponding to the eigenvector with the PageRank scores
is returned here. It is expected to be exactly one, and can be used to check
that ARPACK has successfully converged to the expected eingevector. When using
the PRPACK method, it is always set to 1.0.</p>
</td></tr> <tr><td><code>options</code></td>
<td>
<p>Some information
about the underlying ARPACK calculation. See <code><a href="#topic+arpack">arpack()</a></code> for details.
This entry is <code>NULL</code> if not the ARPACK implementation was used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Sergey Brin and Larry Page: The Anatomy of a Large-Scale
Hypertextual Web Search Engine. Proceedings of the 7th World-Wide Web
Conference, Brisbane, Australia, April 1998.
</p>


<h3>See Also</h3>

<p>Other centrality scores: <code><a href="#topic+closeness">closeness()</a></code>,
<code><a href="#topic+betweenness">betweenness()</a></code>, <code><a href="#topic+degree">degree()</a></code>
</p>
<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(20, 5 / 20, directed = TRUE)
page_rank(g)$vector

g2 &lt;- make_star(10)
page_rank(g2)$vector

# Personalized PageRank
g3 &lt;- make_ring(10)
page_rank(g3)$vector
reset &lt;- seq(vcount(g3))
page_rank(g3, personalized = reset)$vector
</code></pre>

<hr>
<h2 id='page.rank'>The Page Rank algorithm</h2><span id='topic+page.rank'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>page.rank()</code> was renamed to <code>page_rank()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>page.rank(
  graph,
  algo = c("prpack", "arpack"),
  vids = V(graph),
  directed = TRUE,
  damping = 0.85,
  personalized = NULL,
  weights = NULL,
  options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="page.rank_+3A_graph">graph</code></td>
<td>
<p>The graph object.</p>
</td></tr>
<tr><td><code id="page.rank_+3A_algo">algo</code></td>
<td>
<p>Character scalar, which implementation to use to carry out the
calculation. The default is <code>"prpack"</code>, which uses the PRPACK library
(<a href="https://github.com/dgleich/prpack">https://github.com/dgleich/prpack</a>) to calculate PageRank scores
by solving a set of linear equations. This is a new implementation in igraph
version 0.7, and the suggested one, as it is the most stable and the fastest
for all but small graphs.  <code>"arpack"</code> uses the ARPACK library, the
default implementation from igraph version 0.5 until version 0.7. It computes
PageRank scores by solving an eingevalue problem.</p>
</td></tr>
<tr><td><code id="page.rank_+3A_vids">vids</code></td>
<td>
<p>The vertices of interest.</p>
</td></tr>
<tr><td><code id="page.rank_+3A_directed">directed</code></td>
<td>
<p>Logical, if true directed paths will be considered for
directed graphs. It is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="page.rank_+3A_damping">damping</code></td>
<td>
<p>The damping factor (&lsquo;d&rsquo; in the original paper).</p>
</td></tr>
<tr><td><code id="page.rank_+3A_personalized">personalized</code></td>
<td>
<p>Optional vector giving a probability distribution to
calculate personalized PageRank. For personalized PageRank, the probability
of jumping to a node when abandoning the random walk is not uniform, but it
is given by this vector. The vector should contains an entry for each vertex
and it will be rescaled to sum up to one.</p>
</td></tr>
<tr><td><code id="page.rank_+3A_weights">weights</code></td>
<td>
<p>A numerical vector or <code>NULL</code>. This argument can be used
to give edge weights for calculating the weighted PageRank of vertices. If
this is <code>NULL</code> and the graph has a <code>weight</code> edge attribute then
that is used. If <code>weights</code> is a numerical vector then it used, even if
the graph has a <code>weights</code> edge attribute. If this is <code>NA</code>, then no
edge weights are used (even if the graph has a <code>weight</code> edge attribute.
This function interprets edge weights as connection strengths. In the
random surfer model, an edge with a larger weight is more likely to be
selected by the surfer.</p>
</td></tr>
<tr><td><code id="page.rank_+3A_options">options</code></td>
<td>
<p>A named list, to override some ARPACK options. See
<code><a href="#topic+arpack">arpack()</a></code> for details. This argument is ignored if the PRPACK
implementation is used.</p>
</td></tr>
</table>

<hr>
<h2 id='path'>Helper function to add or delete edges along a path</h2><span id='topic+path'></span>

<h3>Description</h3>

<p>This function can be used to add or delete edges that form a path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_+3A_...">...</code></td>
<td>
<p>See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When adding edges via <code>+</code>, all unnamed arguments are
concatenated, and each element of a final vector is interpreted
as a vertex in the graph. For a vector of length <code class="reqn">n+1</code>, <code class="reqn">n</code>
edges are then added, from vertex 1 to vertex 2, from vertex 2 to vertex
3, etc. Named arguments will be used as edge attributes for the new
edges.
</p>
<p>When deleting edges, all attributes are concatenated and then passed
to <code><a href="#topic+delete_edges">delete_edges()</a></code>.
</p>


<h3>Value</h3>

<p>A special object that can be used together with igraph
graphs and the plus and minus operators.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a (directed) wheel
g &lt;- make_star(11, center = 1) + path(2:11, 2)
plot(g)

g &lt;- make_empty_graph(directed = FALSE, n = 10) %&gt;%
  set_vertex_attr("name", value = letters[1:10])

g2 &lt;- g + path("a", "b", "c", "d")
plot(g2)

g3 &lt;- g2 + path("e", "f", "g", weight = 1:2, color = "red")
E(g3)[[]]

g4 &lt;- g3 + path(c("f", "c", "j", "d"), width = 1:3, color = "green")
E(g4)[[]]
</code></pre>

<hr>
<h2 id='path.length.hist'>Shortest (directed or undirected) paths between vertices</h2><span id='topic+path.length.hist'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>path.length.hist()</code> was renamed to <code>distance_table()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path.length.hist(graph, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path.length.hist_+3A_graph">graph</code></td>
<td>
<p>The graph to work on.</p>
</td></tr>
<tr><td><code id="path.length.hist_+3A_directed">directed</code></td>
<td>
<p>Whether to consider directed paths in directed graphs,
this argument is ignored for undirected graphs.</p>
</td></tr>
</table>

<hr>
<h2 id='permute'>Permute the vertices of a graph</h2><span id='topic+permute'></span>

<h3>Description</h3>

<p>Create a new graph, by permuting vertex ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute(graph, permutation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can directed or undirected.</p>
</td></tr>
<tr><td><code id="permute_+3A_permutation">permutation</code></td>
<td>
<p>A numeric vector giving the permutation to apply. The
first element is the new id of vertex 1, etc. Every number between one and
<code>vcount(graph)</code> must appear exactly once.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a new graph from the input graph by permuting its
vertices according to the specified mapping. Call this function with the
output of <code><a href="#topic+canonical_permutation">canonical_permutation()</a></code> to create the canonical form
of a graph.
</p>
<p><code>permute()</code> keeps all graph, vertex and edge attributes of the graph.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+canonical_permutation">canonical_permutation()</a></code>
</p>
<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Random permutation of a random graph
g &lt;- sample_gnm(20, 50)
g2 &lt;- permute(g, sample(vcount(g)))
graph.isomorphic(g, g2)

# Permutation keeps all attributes
g$name &lt;- "Random graph, Gnm, 20, 50"
V(g)$name &lt;- letters[1:vcount(g)]
E(g)$weight &lt;- sample(1:5, ecount(g), replace = TRUE)
g2 &lt;- permute(g, sample(vcount(g)))
graph.isomorphic(g, g2)
g2$name
V(g2)$name
E(g2)$weight
all(sort(E(g2)$weight) == sort(E(g)$weight))
</code></pre>

<hr>
<h2 id='permute.vertices'>Permute the vertices of a graph</h2><span id='topic+permute.vertices'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>permute.vertices()</code> was renamed to <code>permute()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute.vertices(graph, permutation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute.vertices_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can directed or undirected.</p>
</td></tr>
<tr><td><code id="permute.vertices_+3A_permutation">permutation</code></td>
<td>
<p>A numeric vector giving the permutation to apply. The
first element is the new id of vertex 1, etc. Every number between one and
<code>vcount(graph)</code> must appear exactly once.</p>
</td></tr>
</table>

<hr>
<h2 id='Pie+20charts+20as+20vertices'>Using pie charts as vertices in graph plots</h2><span id='topic+vertex.shape.pie'></span>

<h3>Description</h3>

<p>More complex vertex images can be used to express addtional
information about vertices. E.g. pie charts can be used as vertices,
to denote vertex classes, fuzzy classification of vertices, etc.
</p>


<h3>Details</h3>

<p>The vertex shape &lsquo;pie&rsquo; makes igraph draw a pie chart for every
vertex. There are some extra graphical vertex parameters that specify
how the pie charts will look like:
</p>

<dl>
<dt>pie</dt><dd><p>Numeric vector, gives the sizes of the pie slices.</p>
</dd>
<dt>pie.color</dt><dd><p>A list of color vectors to use for the pies. If it
is a list of a single vector, then this is used for all pies. It
the color vector is shorter than the number of areas in a pie,
then it is recycled.</p>
</dd>
<dt>pie.angle</dt><dd><p>The slope of shading lines, given as an angle in
degrees (counter-clockwise).</p>
</dd>
<dt>pie.density</dt><dd><p>The density of the shading lines, in lines per
inch. Non-positive values inhibit the drawing of shading lines.</p>
</dd>
<dt>pie.lty</dt><dd><p>The line type of the border of the slices.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+igraph.plotting">igraph.plotting</a></code>, <code><a href="#topic+plot.igraph">plot.igraph</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
values &lt;- lapply(1:10, function(x) sample(1:10,3))
if (interactive()) {
  plot(g, vertex.shape="pie", vertex.pie=values,
       vertex.pie.color=list(heat.colors(5)),
       vertex.size=seq(10,30,length.out=10), vertex.label=NA)
}
</code></pre>

<hr>
<h2 id='piecewise.layout'>Merging graph layouts</h2><span id='topic+piecewise.layout'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>piecewise.layout()</code> was renamed to <code>layout_components()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise.layout(graph, layout = layout_with_kk, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise.layout_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="piecewise.layout_+3A_layout">layout</code></td>
<td>
<p>A function object, the layout function to use.</p>
</td></tr>
<tr><td><code id="piecewise.layout_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the <code>layout</code> layout
function.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_dendrogram'>Community structure dendrogram plots</h2><span id='topic+plot_dendrogram'></span><span id='topic+plot_dendrogram.communities'></span>

<h3>Description</h3>

<p>Plot a hierarchical community structure as a dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dendrogram(x, mode = igraph_opt("dend.plot.type"), ...)

## S3 method for class 'communities'
plot_dendrogram(
  x,
  mode = igraph_opt("dend.plot.type"),
  ...,
  use.modularity = FALSE,
  palette = categorical_pal(8)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dendrogram_+3A_x">x</code></td>
<td>
<p>An object containing the community structure of a graph. See
<code><a href="#topic+communities">communities()</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot_dendrogram_+3A_mode">mode</code></td>
<td>
<p>Which dendrogram plotting function to use. See details below.</p>
</td></tr>
<tr><td><code id="plot_dendrogram_+3A_...">...</code></td>
<td>
<p>Additional arguments to supply to the dendrogram plotting
function.</p>
</td></tr>
<tr><td><code id="plot_dendrogram_+3A_use.modularity">use.modularity</code></td>
<td>
<p>Logical scalar, whether to use the modularity values
to define the height of the branches.</p>
</td></tr>
<tr><td><code id="plot_dendrogram_+3A_palette">palette</code></td>
<td>
<p>The color palette to use for colored plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_dendrogram()</code> supports three different plotting functions, selected via
the <code>mode</code> argument. By default the plotting function is taken from the
<code>dend.plot.type</code> igraph option, and it has for possible values:
</p>
 <ul>
<li> <p><code>auto</code> Choose automatically between the plotting
functions. As <code>plot.phylo</code> is the most sophisticated, that is choosen,
whenever the <code>ape</code> package is available. Otherwise <code>plot.hclust</code>
is used.  </p>
</li>
<li> <p><code>phylo</code> Use <code>plot.phylo</code> from the <code>ape</code>
package.  </p>
</li>
<li> <p><code>hclust</code> Use <code>plot.hclust</code> from the <code>stats</code>
package.  </p>
</li>
<li> <p><code>dendrogram</code> Use <code>plot.dendrogram</code> from the
<code>stats</code> package.  </p>
</li></ul>

<p>The different plotting functions take different sets of arguments. When
using <code>plot.phylo</code> (<code>mode="phylo"</code>), we have the following syntax:
</p>
<pre>
    plot_dendrogram(x, mode="phylo", colbar = palette(),
            edge.color = NULL, use.edge.length = FALSE, \dots)
</pre><p> The extra arguments not documented above: </p>

<ul>
<li> <p><code>colbar</code> Color bar for the edges.
</p>
</li>
<li> <p><code>edge.color</code> Edge colors. If <code>NULL</code>, then the
<code>colbar</code> argument is used.
</p>
</li>
<li> <p><code>use.edge.length</code> Passed to <code>plot.phylo</code>.
</p>
</li>
<li> <p><code>dots</code> Attitional arguments to pass to <code>plot.phylo</code>.
</p>
</li></ul>

<p>The syntax for <code>plot.hclust</code> (<code>mode="hclust"</code>): </p>
<pre>
    plot_dendrogram(x, mode="hclust", rect = 0, colbar = palette(),
            hang = 0.01, ann = FALSE, main = "", sub = "", xlab = "",
            ylab = "", \dots)
</pre><p> The extra arguments not documented above: </p>

<ul>
<li> <p><code>rect</code> A numeric scalar, the number of groups to mark on
the dendrogram. The dendrogram is cut into exactly <code>rect</code>
groups and they are marked via the <code>rect.hclust</code> command. Set
this to zero if you don't want to mark any groups.
</p>
</li>
<li> <p><code>colbar</code> The colors of the rectangles that mark the
vertex groups via the <code>rect</code> argument.
</p>
</li>
<li> <p><code>hang</code> Where to put the leaf nodes, this corresponds to the
<code>hang</code> argument of <code>plot.hclust</code>.
</p>
</li>
<li> <p><code>ann</code>  Whether to annotate the plot, the <code>ann</code>
argument of <code>plot.hclust</code>.
</p>
</li>
<li> <p><code>main</code> The main title of the plot, the <code>main</code> argument
of <code>plot.hclust</code>.
</p>
</li>
<li> <p><code>sub</code> The sub-title of the plot, the <code>sub</code> argument of
<code>plot.hclust</code>.
</p>
</li>
<li> <p><code>xlab</code> The label on the horizontal axis, passed to
<code>plot.hclust</code>.
</p>
</li>
<li> <p><code>ylab</code> The label on the vertical axis, passed to
<code>plot.hclust</code>.
</p>
</li>
<li> <p><code>dots</code> Attitional arguments to pass to <code>plot.hclust</code>.
</p>
</li></ul>

<p>The syntax for <code>plot.dendrogram</code> (<code>mode="dendrogram"</code>):
</p>
<pre>
    plot_dendrogram(x, \dots)
</pre><p> The extra arguments are simply passed to <code><a href="stats.html#topic+as.dendrogram">as.dendrogram()</a></code>.
</p>


<h3>Value</h3>

<p>Returns whatever the return value was from the plotting function,
<code>plot.phylo</code>, <code>plot.dendrogram</code> or <code>plot.hclust</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
karate &lt;- make_graph("Zachary")
fc &lt;- cluster_fast_greedy(karate)
plot_dendrogram(fc)

</code></pre>

<hr>
<h2 id='plot_dendrogram.igraphHRG'>HRG dendrogram plot</h2><span id='topic+plot_dendrogram.igraphHRG'></span>

<h3>Description</h3>

<p>Plot a hierarchical random graph as a dendrogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraphHRG'
plot_dendrogram(x, mode = igraph_opt("dend.plot.type"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dendrogram.igraphHRG_+3A_x">x</code></td>
<td>
<p>An <code>igraphHRG</code>, a hierarchical random graph, as returned by
the <code><a href="#topic+fit_hrg">fit_hrg()</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_dendrogram.igraphHRG_+3A_mode">mode</code></td>
<td>
<p>Which dendrogram plotting function to use. See details below.</p>
</td></tr>
<tr><td><code id="plot_dendrogram.igraphHRG_+3A_...">...</code></td>
<td>
<p>Additional arguments to supply to the dendrogram plotting
function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_dendrogram()</code> supports three different plotting functions, selected via
the <code>mode</code> argument. By default the plotting function is taken from the
<code>dend.plot.type</code> igraph option, and it has for possible values:
</p>
 <ul>
<li> <p><code>auto</code> Choose automatically between the plotting
functions. As <code>plot.phylo</code> is the most sophisticated, that is choosen,
whenever the <code>ape</code> package is available. Otherwise <code>plot.hclust</code>
is used.  </p>
</li>
<li> <p><code>phylo</code> Use <code>plot.phylo</code> from the <code>ape</code>
package.  </p>
</li>
<li> <p><code>hclust</code> Use <code>plot.hclust</code> from the <code>stats</code>
package.  </p>
</li>
<li> <p><code>dendrogram</code> Use <code>plot.dendrogram</code> from the
<code>stats</code> package.  </p>
</li></ul>

<p>The different plotting functions take different sets of arguments. When
using <code>plot.phylo</code> (<code>mode="phylo"</code>), we have the following syntax:
</p>
<pre>
    plot_dendrogram(x, mode="phylo", colbar = rainbow(11, start=0.7,
            end=0.1), edge.color = NULL, use.edge.length = FALSE, \dots)
</pre><p> The extra arguments not documented above: </p>

<ul>
<li> <p><code>colbar</code> Color bar for the edges.
</p>
</li>
<li> <p><code>edge.color</code> Edge colors. If <code>NULL</code>, then the
<code>colbar</code> argument is used.
</p>
</li>
<li> <p><code>use.edge.length</code> Passed to <code>plot.phylo</code>.
</p>
</li>
<li> <p><code>dots</code> Attitional arguments to pass to <code>plot.phylo</code>.
</p>
</li></ul>

<p>The syntax for <code>plot.hclust</code> (<code>mode="hclust"</code>): </p>
<pre>
    plot_dendrogram(x, mode="hclust", rect = 0, colbar = rainbow(rect),
            hang = 0.01, ann = FALSE, main = "", sub = "", xlab = "",
            ylab = "", \dots)
</pre><p> The extra arguments not documented above: </p>

<ul>
<li> <p><code>rect</code> A numeric scalar, the number of groups to mark on
the dendrogram. The dendrogram is cut into exactly <code>rect</code>
groups and they are marked via the <code>rect.hclust</code> command. Set
this to zero if you don't want to mark any groups.
</p>
</li>
<li> <p><code>colbar</code> The colors of the rectangles that mark the
vertex groups via the <code>rect</code> argument.
</p>
</li>
<li> <p><code>hang</code> Where to put the leaf nodes, this corresponds to the
<code>hang</code> argument of <code>plot.hclust</code>.
</p>
</li>
<li> <p><code>ann</code> Whether to annotate the plot, the <code>ann</code> argument
of <code>plot.hclust</code>.
</p>
</li>
<li> <p><code>main</code> The main title of the plot, the <code>main</code> argument
of <code>plot.hclust</code>.
</p>
</li>
<li> <p><code>sub</code> The sub-title of the plot, the <code>sub</code> argument of
<code>plot.hclust</code>.
</p>
</li>
<li> <p><code>xlab</code> The label on the horizontal axis, passed to
<code>plot.hclust</code>.
</p>
</li>
<li> <p><code>ylab</code> The label on the vertical axis, passed to
<code>plot.hclust</code>.
</p>
</li>
<li> <p><code>dots</code> Attitional arguments to pass to <code>plot.hclust</code>.
</p>
</li></ul>

<p>The syntax for <code>plot.dendrogram</code> (<code>mode="dendrogram"</code>):
</p>
<pre>
    plot_dendrogram(x, \dots)
</pre><p> The extra arguments are simply passed to <code><a href="stats.html#topic+as.dendrogram">as.dendrogram()</a></code>.
</p>


<h3>Value</h3>

<p>Returns whatever the return value was from the plotting function,
<code>plot.phylo</code>, <code>plot.dendrogram</code> or <code>plot.hclust</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_full_graph(5) + make_full_graph(5)
hrg &lt;- fit_hrg(g)
plot_dendrogram(hrg)

</code></pre>

<hr>
<h2 id='plot.igraph'>Plotting of graphs</h2><span id='topic+plot.igraph'></span><span id='topic+plot.graph'></span>

<h3>Description</h3>

<p><code>plot.igraph()</code> is able to plot graphs to any R device. It is the
non-interactive companion of the <code>tkplot()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
plot(
  x,
  axes = FALSE,
  add = FALSE,
  xlim = c(-1, 1),
  ylim = c(-1, 1),
  mark.groups = list(),
  mark.shape = 1/2,
  mark.col = rainbow(length(mark.groups), alpha = 0.3),
  mark.border = rainbow(length(mark.groups), alpha = 1),
  mark.expand = 15,
  loop.size = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.igraph_+3A_x">x</code></td>
<td>
<p>The graph to plot.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_axes">axes</code></td>
<td>
<p>Logical, whether to plot axes, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_add">add</code></td>
<td>
<p>Logical scalar, whether to add the plot to the current device, or
delete the device's current contents first.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_xlim">xlim</code></td>
<td>
<p>The limits for the horizontal axis, it is unlikely that you want
to modify this.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_ylim">ylim</code></td>
<td>
<p>The limits for the vertical axis, it is unlikely that you want
to modify this.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_mark.groups">mark.groups</code></td>
<td>
<p>A list of vertex id vectors. It is interpreted as a set
of vertex groups. Each vertex group is highlighted, by plotting a colored
smoothed polygon around and &ldquo;under&rdquo; it. See the arguments below to
control the look of the polygons.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_mark.shape">mark.shape</code></td>
<td>
<p>A numeric scalar or vector. Controls the smoothness of the
vertex group marking polygons. This is basically the &lsquo;shape&rsquo;
parameter of the <code><a href="graphics.html#topic+xspline">graphics::xspline()</a></code> function, its possible
values are between -1 and 1. If it is a vector, then a different value is
used for the different vertex groups.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_mark.col">mark.col</code></td>
<td>
<p>A scalar or vector giving the colors of marking the
polygons, in any format accepted by <code><a href="graphics.html#topic+xspline">graphics::xspline()</a></code>; e.g.
numeric color ids, symbolic color names, or colors in RGB.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_mark.border">mark.border</code></td>
<td>
<p>A scalar or vector giving the colors of the borders of
the vertex group marking polygons. If it is <code>NA</code>, then no border is
drawn.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_mark.expand">mark.expand</code></td>
<td>
<p>A numeric scalar or vector, the size of the border around
the marked vertex groups. It is in the same units as the vertex sizes. If a
vector is given, then different values are used for the different vertex
groups.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_loop.size">loop.size</code></td>
<td>
<p>A numeric scalar that allows the user to scale the loop edges
of the network. The default loop size is 1. Larger values will produce larger
loops.</p>
</td></tr>
<tr><td><code id="plot.igraph_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters. See <a href="#topic+igraph.plotting">igraph.plotting</a> for
the complete list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One convenient way to plot graphs is to plot with <code><a href="#topic+tkplot">tkplot()</a></code>
first, handtune the placement of the vertices, query the coordinates by the
<code><a href="#topic+tk_coords">tk_coords()</a></code> function and use them with <code><a href="base.html#topic+plot">plot()</a></code> to
plot the graph to any R device.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+layout">layout()</a></code> for different layouts,
<a href="#topic+igraph.plotting">igraph.plotting</a> for the detailed description of the plotting
parameters and <code><a href="#topic+tkplot">tkplot()</a></code> and <code><a href="#topic+rglplot">rglplot()</a></code> for other
graph plotting functions.
</p>
<p>Other plot: 
<code><a href="#topic+rglplot">rglplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
plot(g, layout = layout_with_kk, vertex.color = "green")

</code></pre>

<hr>
<h2 id='plot.sir'>Plotting the results on multiple SIR model runs</h2><span id='topic+plot.sir'></span>

<h3>Description</h3>

<p>This function can conveniently plot the results of multiple SIR model
simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sir'
plot(
  x,
  comp = c("NI", "NS", "NR"),
  median = TRUE,
  quantiles = c(0.1, 0.9),
  color = NULL,
  median_color = NULL,
  quantile_color = NULL,
  lwd.median = 2,
  lwd.quantile = 2,
  lty.quantile = 3,
  xlim = NULL,
  ylim = NULL,
  xlab = "Time",
  ylab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sir_+3A_x">x</code></td>
<td>
<p>The output of the SIR simulation, coming from the <code><a href="#topic+sir">sir()</a></code>
function.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_comp">comp</code></td>
<td>
<p>Character scalar, which component to plot. Either &lsquo;NI&rsquo;
(infected, default), &lsquo;NS&rsquo; (susceptible) or &lsquo;NR&rsquo; (recovered).</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_median">median</code></td>
<td>
<p>Logical scalar, whether to plot the (binned) median.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_quantiles">quantiles</code></td>
<td>
<p>A vector of (binned) quantiles to plot.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_color">color</code></td>
<td>
<p>Color of the individual simulation curves.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_median_color">median_color</code></td>
<td>
<p>Color of the median curve.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_quantile_color">quantile_color</code></td>
<td>
<p>Color(s) of the quantile curves. (It is recycled if
needed and non-needed entries are ignored if too long.)</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_lwd.median">lwd.median</code></td>
<td>
<p>Line width of the median.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_lwd.quantile">lwd.quantile</code></td>
<td>
<p>Line width of the quantile curves.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_lty.quantile">lty.quantile</code></td>
<td>
<p>Line type of the quantile curves.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_xlim">xlim</code></td>
<td>
<p>The x limits, a two-element numeric vector. If <code>NULL</code>, then
it is calculated from the data.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_ylim">ylim</code></td>
<td>
<p>The y limits, a two-element numeric vector. If <code>NULL</code>, then
it is calculated from the data.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_xlab">xlab</code></td>
<td>
<p>The x label.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_ylab">ylab</code></td>
<td>
<p>The y label. If <code>NULL</code> then it is automatically added based
on the <code>comp</code> argument.</p>
</td></tr>
<tr><td><code id="plot.sir_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to <code><a href="base.html#topic+plot">plot()</a></code>, that is run
before any of the curves are added, to create the figure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of susceptible/infected/recovered individuals is plotted over
time, for multiple simulations.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Author(s)</h3>

<p>Eric Kolaczyk (<a href="http://math.bu.edu/people/kolaczyk/">http://math.bu.edu/people/kolaczyk/</a>) and Gabor
Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>.
</p>


<h3>References</h3>

<p>Bailey, Norman T. J. (1975). The mathematical theory of
infectious diseases and its applications (2nd ed.). London: Griffin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sir">sir()</a></code> for running the actual simulation.
</p>
<p>Processes on graphs
<code><a href="#topic+time_bins">time_bins</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnm(100, 100)
sm &lt;- sir(g, beta = 5, gamma = 1)
plot(sm)

</code></pre>

<hr>
<h2 id='plotHierarchy'>Calculate Cohesive Blocks</h2><span id='topic+plotHierarchy'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>plotHierarchy()</code> was renamed to <code>plot_hierarchy()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHierarchy(
  blocks,
  layout = layout_as_tree(hierarchy(blocks), root = 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHierarchy_+3A_layout">layout</code></td>
<td>
<p>The layout of a plot, it is simply passed on to
<code>plot.igraph()</code>, see the possible formats there. By default the
Reingold-Tilford layout generator is used.</p>
</td></tr>
<tr><td><code id="plotHierarchy_+3A_...">...</code></td>
<td>
<p>Additional arguments. <code>plot_hierarchy()</code> and <code><a href="base.html#topic+plot">plot()</a></code> pass
them to <code>plot.igraph()</code>.  <code><a href="base.html#topic+print">print()</a></code> and <code><a href="base.html#topic+summary">summary()</a></code> ignore them.</p>
</td></tr>
</table>

<hr>
<h2 id='power_centrality'>Find Bonacich Power Centrality Scores of Network Positions</h2><span id='topic+power_centrality'></span>

<h3>Description</h3>

<p><code>power_centrality()</code> takes a graph (<code>dat</code>) and returns the Boncich power
centralities of positions (selected by <code>nodes</code>).  The decay rate for
power contributions is specified by <code>exponent</code> (1 by default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_centrality(
  graph,
  nodes = V(graph),
  loops = FALSE,
  exponent = 1,
  rescale = FALSE,
  tol = 1e-07,
  sparse = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_centrality_+3A_graph">graph</code></td>
<td>
<p>the input graph.</p>
</td></tr>
<tr><td><code id="power_centrality_+3A_nodes">nodes</code></td>
<td>
<p>vertex sequence indicating which vertices are to be included in
the calculation.  By default, all vertices are included.</p>
</td></tr>
<tr><td><code id="power_centrality_+3A_loops">loops</code></td>
<td>
<p>boolean indicating whether or not the diagonal should be
treated as valid data.  Set this true if and only if the data can contain
loops.  <code>loops</code> is <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="power_centrality_+3A_exponent">exponent</code></td>
<td>
<p>exponent (decay rate) for the Bonacich power centrality
score; can be negative</p>
</td></tr>
<tr><td><code id="power_centrality_+3A_rescale">rescale</code></td>
<td>
<p>if true, centrality scores are rescaled such that they sum to
1.</p>
</td></tr>
<tr><td><code id="power_centrality_+3A_tol">tol</code></td>
<td>
<p>tolerance for near-singularities during matrix inversion (see
<code><a href="base.html#topic+solve">solve()</a></code>)</p>
</td></tr>
<tr><td><code id="power_centrality_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to use sparse matrices for the
calculation. The &lsquo;Matrix&rsquo; package is required for sparse matrix
support</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bonacich's power centrality measure is defined by
<code class="reqn">C_{BP}\left(\alpha,\beta\right)=\alpha\left(\mathbf{I}-\beta\mathbf{A}\right)^{-1}\mathbf{A}\mathbf{1}</code>, where <code class="reqn">\beta</code> is an attenuation parameter (set
here by <code>exponent</code>) and <code class="reqn">\mathbf{A}</code> is the graph adjacency
matrix.  (The coefficient <code class="reqn">\alpha</code> acts as a scaling parameter,
and is set here (following Bonacich (1987)) such that the sum of squared
scores is equal to the number of vertices.  This allows 1 to be used as a
reference value for the &ldquo;middle&rdquo; of the centrality range.)  When
<code class="reqn">\beta \rightarrow </code><code class="reqn">
1/\lambda_{\mathbf{A}1}</code> (the reciprocal of the largest
eigenvalue of <code class="reqn">\mathbf{A}</code>), this is to within a constant multiple of
the familiar eigenvector centrality score; for other values of <code class="reqn">\beta</code>,
the behavior of the measure is quite different.  In particular, <code class="reqn">\beta</code>
gives positive and negative weight to even and odd walks, respectively, as
can be seen from the series expansion
<code class="reqn">C_{BP}\left(\alpha,\beta\right)=\alpha \sum_{k=0}^\infty \beta^k
</code><code class="reqn">
\mathbf{A}^{k+1} \mathbf{1}</code> which converges so long as <code class="reqn">|\beta|
</code><code class="reqn"> &lt; 1/\lambda_{\mathbf{A}1}</code>.
The magnitude of <code class="reqn">\beta</code> controls the influence of distant actors
on ego's centrality score, with larger magnitudes indicating slower rates of
decay.  (High rates, hence, imply a greater sensitivity to edge effects.)
</p>
<p>Interpretively, the Bonacich power measure corresponds to the notion that
the power of a vertex is recursively defined by the sum of the power of its
alters.  The nature of the recursion involved is then controlled by the
power exponent: positive values imply that vertices become more powerful as
their alters become more powerful (as occurs in cooperative relations),
while negative values imply that vertices become more powerful only as their
alters become <em>weaker</em> (as occurs in competitive or antagonistic
relations).  The magnitude of the exponent indicates the tendency of the
effect to decay across long walks; higher magnitudes imply slower decay.
One interesting feature of this measure is its relative instability to
changes in exponent magnitude (particularly in the negative case).  If your
theory motivates use of this measure, you should be very careful to choose a
decay parameter on a non-ad hoc basis.
</p>


<h3>Value</h3>

<p>A vector, containing the centrality scores.
</p>


<h3>Warning </h3>

<p>Singular adjacency matrices cause no end of headaches for
this algorithm; thus, the routine may fail in certain cases.  This will be
fixed when I get a better algorithm.  <code>power_centrality()</code> will not symmetrize your
data before extracting eigenvectors; don't send this routine asymmetric
matrices unless you really mean to do so.
</p>


<h3>Note</h3>

<p>This function was ported (i.e. copied) from the SNA package.
</p>


<h3>Author(s)</h3>

<p>Carter T. Butts
(<a href="http://www.faculty.uci.edu/profile.cfm?faculty_id=5057">http://www.faculty.uci.edu/profile.cfm?faculty_id=5057</a>), ported to
igraph by Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Bonacich, P.  (1972).  &ldquo;Factoring and Weighting Approaches to
Status Scores and Clique Identification.&rdquo; <em>Journal of Mathematical
Sociology</em>, 2, 113-120.
</p>
<p>Bonacich, P.  (1987).  &ldquo;Power and Centrality: A Family of Measures.&rdquo;
<em>American Journal of Sociology</em>, 92, 1170-1182.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigen_centrality">eigen_centrality()</a></code> and <code><a href="#topic+alpha_centrality">alpha_centrality()</a></code>
</p>
<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate some test data from Bonacich, 1987:
g.c &lt;- make_graph(c(1, 2, 1, 3, 2, 4, 3, 5), dir = FALSE)
g.d &lt;- make_graph(c(1, 2, 1, 3, 1, 4, 2, 5, 3, 6, 4, 7), dir = FALSE)
g.e &lt;- make_graph(c(1, 2, 1, 3, 1, 4, 2, 5, 2, 6, 3, 7, 3, 8, 4, 9, 4, 10), dir = FALSE)
g.f &lt;- make_graph(
  c(1, 2, 1, 3, 1, 4, 2, 5, 2, 6, 2, 7, 3, 8, 3, 9, 3, 10, 4, 11, 4, 12, 4, 13),
  dir = FALSE
)
# Compute power centrality scores
for (e in seq(-0.5, .5, by = 0.1)) {
  print(round(power_centrality(g.c, exp = e)[c(1, 2, 4)], 2))
}

for (e in seq(-0.4, .4, by = 0.1)) {
  print(round(power_centrality(g.d, exp = e)[c(1, 2, 5)], 2))
}

for (e in seq(-0.4, .4, by = 0.1)) {
  print(round(power_centrality(g.e, exp = e)[c(1, 2, 5)], 2))
}

for (e in seq(-0.4, .4, by = 0.1)) {
  print(round(power_centrality(g.f, exp = e)[c(1, 2, 5)], 2))
}

</code></pre>

<hr>
<h2 id='power.law.fit'>Fitting a power-law distribution function to discrete data</h2><span id='topic+power.law.fit'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>power.law.fit()</code> was renamed to <code>fit_power_law()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.law.fit(
  x,
  xmin = NULL,
  start = 2,
  force.continuous = FALSE,
  implementation = c("plfit", "R.mle"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.law.fit_+3A_x">x</code></td>
<td>
<p>The data to fit, a numeric vector. For implementation
&lsquo;<code>R.mle</code>&rsquo; the data must be integer values. For the
&lsquo;<code>plfit</code>&rsquo; implementation non-integer values might be present and
then a continuous power-law distribution is fitted.</p>
</td></tr>
<tr><td><code id="power.law.fit_+3A_xmin">xmin</code></td>
<td>
<p>Numeric scalar, or <code>NULL</code>. The lower bound for fitting the
power-law. If <code>NULL</code>, the smallest value in <code>x</code> will be used for
the &lsquo;<code>R.mle</code>&rsquo; implementation, and its value will be
automatically determined for the &lsquo;<code>plfit</code>&rsquo; implementation. This
argument makes it possible to fit only the tail of the distribution.</p>
</td></tr>
<tr><td><code id="power.law.fit_+3A_start">start</code></td>
<td>
<p>Numeric scalar. The initial value of the exponent for the
minimizing function, for the &lsquo;<code>R.mle</code>&rsquo; implementation. Usually
it is safe to leave this untouched.</p>
</td></tr>
<tr><td><code id="power.law.fit_+3A_force.continuous">force.continuous</code></td>
<td>
<p>Logical scalar. Whether to force a continuous
distribution for the &lsquo;<code>plfit</code>&rsquo; implementation, even if the
sample vector contains integer values only (by chance). If this argument is
false, igraph will assume a continuous distribution if at least one sample
is non-integer and assume a discrete distribution otherwise.</p>
</td></tr>
<tr><td><code id="power.law.fit_+3A_implementation">implementation</code></td>
<td>
<p>Character scalar. Which implementation to use. See
details below.</p>
</td></tr>
<tr><td><code id="power.law.fit_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the maximum likelihood
optimizing function, <code><a href="stats4.html#topic+mle">stats4::mle()</a></code>, if the &lsquo;<code>R.mle</code>&rsquo;
implementation is chosen. It is ignored by the &lsquo;<code>plfit</code>&rsquo;
implementation.</p>
</td></tr>
</table>

<hr>
<h2 id='predict_edges'>Predict edges based on a hierarchical random graph model</h2><span id='topic+predict_edges'></span>

<h3>Description</h3>

<p><code>predict_edges()</code> uses a hierarchical random graph model to predict
missing edges from a network. This is done by sampling hierarchical models
around the optimum model, proportionally to their likelihood. The MCMC
sampling is stated from <code>hrg()</code>, if it is given and the <code>start</code>
argument is set to <code>TRUE</code>. Otherwise a HRG is fitted to the graph
first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_edges(
  graph,
  hrg = NULL,
  start = FALSE,
  num.samples = 10000,
  num.bins = 25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_edges_+3A_graph">graph</code></td>
<td>
<p>The graph to fit the model to. Edge directions are ignored in
directed graphs.</p>
</td></tr>
<tr><td><code id="predict_edges_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model, in the form of an
<code>igraphHRG</code> object. <code>predict_edges()</code> allow this to be
<code>NULL</code> as well, then a HRG is fitted to the graph first, from a
random starting point.</p>
</td></tr>
<tr><td><code id="predict_edges_+3A_start">start</code></td>
<td>
<p>Logical, whether to start the fitting/sampling from the
supplied <code>igraphHRG</code> object, or from a random starting point.</p>
</td></tr>
<tr><td><code id="predict_edges_+3A_num.samples">num.samples</code></td>
<td>
<p>Number of samples to use for consensus generation or
missing edge prediction.</p>
</td></tr>
<tr><td><code id="predict_edges_+3A_num.bins">num.bins</code></td>
<td>
<p>Number of bins for the edge probabilities. Give a higher
number for a more accurate prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries:
</p>
<table>
<tr><td><code>edges</code></td>
<td>
<p>The predicted edges, in a two-column matrix of vertex
ids.</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>Probabilities of these edges, according to the fitted
model.</p>
</td></tr>
<tr><td><code>hrg</code></td>
<td>
<p>The (supplied or fitted) hierarchical random graph model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Clauset, C. Moore, and M.E.J. Newman. Hierarchical structure
and the prediction of missing links in networks. <em>Nature</em> 453, 98&ndash;101
(2008);
</p>
<p>A. Clauset, C. Moore, and M.E.J. Newman. Structural Inference of Hierarchies
in Networks. In E. M. Airoldi et al. (Eds.): ICML 2006 Ws, <em>Lecture
Notes in Computer Science</em> 4503, 1&ndash;13. Springer-Verlag, Berlin Heidelberg
(2007).
</p>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+consensus_tree">consensus_tree</a>()</code>,
<code><a href="#topic+fit_hrg">fit_hrg</a>()</code>,
<code><a href="#topic+hrg">hrg</a>()</code>,
<code><a href="#topic+hrg-methods">hrg-methods</a></code>,
<code><a href="#topic+hrg_tree">hrg_tree</a>()</code>,
<code><a href="#topic+print.igraphHRG">print.igraphHRG</a>()</code>,
<code><a href="#topic+print.igraphHRGConsensus">print.igraphHRGConsensus</a>()</code>,
<code><a href="#topic+sample_hrg">sample_hrg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## We are not running these examples any more, because they
## take a long time (~15 seconds) to run and this is against the CRAN
## repository policy. Copy and paste them by hand to your R prompt if
## you want to run them.

## A graph with two dense groups
g &lt;- sample_gnp(10, p = 1 / 2) + sample_gnp(10, p = 1 / 2)
hrg &lt;- fit_hrg(g)
hrg

## The consensus tree for it
consensus_tree(g, hrg = hrg, start = TRUE)

## Prediction of missing edges
g2 &lt;- make_full_graph(4) + (make_full_graph(4) - path(1, 2))
predict_edges(g2)

## End(Not run)
</code></pre>

<hr>
<h2 id='preference.game'>Trait-based random generation</h2><span id='topic+preference.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>preference.game()</code> was renamed to <code>sample_pref()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preference.game(
  nodes,
  types,
  type.dist = rep(1, types),
  fixed.sizes = FALSE,
  pref.matrix = matrix(1, types, types),
  directed = FALSE,
  loops = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preference.game_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graphs.</p>
</td></tr>
<tr><td><code id="preference.game_+3A_types">types</code></td>
<td>
<p>The number of different vertex types.</p>
</td></tr>
<tr><td><code id="preference.game_+3A_type.dist">type.dist</code></td>
<td>
<p>The distribution of the vertex types, a numeric vector of
length &lsquo;types&rsquo; containing non-negative numbers. The vector will be
normed to obtain probabilities.</p>
</td></tr>
<tr><td><code id="preference.game_+3A_fixed.sizes">fixed.sizes</code></td>
<td>
<p>Fix the number of vertices with a given vertex type
label. The <code>type.dist</code> argument gives the group sizes (i.e. number of
vertices with the different labels) in this case.</p>
</td></tr>
<tr><td><code id="preference.game_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>A square matrix giving the preferences of the vertex
types. The matrix has &lsquo;types&rsquo; rows and columns. When generating
an undirected graph, it must be symmetric.</p>
</td></tr>
<tr><td><code id="preference.game_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="preference.game_+3A_loops">loops</code></td>
<td>
<p>Logical constant, whether self-loops are allowed in the graph.</p>
</td></tr>
</table>

<hr>
<h2 id='print.igraph'>Print graphs to the terminal</h2><span id='topic+print.igraph'></span><span id='topic+print_all'></span><span id='topic+summary.igraph'></span><span id='topic+str.igraph'></span>

<h3>Description</h3>

<p>These functions attempt to print a graph to the terminal in a human readable
form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
print(
  x,
  full = igraph_opt("print.full"),
  graph.attributes = igraph_opt("print.graph.attributes"),
  vertex.attributes = igraph_opt("print.vertex.attributes"),
  edge.attributes = igraph_opt("print.edge.attributes"),
  names = TRUE,
  max.lines = igraph_opt("auto.print.lines"),
  id = igraph_opt("print.id"),
  ...
)

## S3 method for class 'igraph'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.igraph_+3A_x">x</code></td>
<td>
<p>The graph to print.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_full">full</code></td>
<td>
<p>Logical scalar, whether to print the graph structure itself as
well.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_graph.attributes">graph.attributes</code></td>
<td>
<p>Logical constant, whether to print graph attributes.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_vertex.attributes">vertex.attributes</code></td>
<td>
<p>Logical constant, whether to print vertex
attributes.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_edge.attributes">edge.attributes</code></td>
<td>
<p>Logical constant, whether to print edge attributes.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_names">names</code></td>
<td>
<p>Logical constant, whether to print symbolic vertex names (i.e.
the <code>name</code> vertex attribute) or vertex ids.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_max.lines">max.lines</code></td>
<td>
<p>The maximum number of lines to use. The rest of the
output will be truncated.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_id">id</code></td>
<td>
<p>Whether to print the graph ID.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_...">...</code></td>
<td>
<p>Additional agruments.</p>
</td></tr>
<tr><td><code id="print.igraph_+3A_object">object</code></td>
<td>
<p>The graph of which the summary will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.igraph</code> prints the number of vertices, edges and whether the
graph is directed.
</p>
<p><code>print_all()</code> prints the same information, and also lists the edges, and
optionally graph, vertex and/or edge attributes.
</p>
<p><code>print.igraph()</code> behaves either as <code>summary.igraph</code> or
<code>print_all()</code> depending on the <code>full</code> argument. See also the
&lsquo;print.full&rsquo; igraph option and <code><a href="#topic+igraph_opt">igraph_opt()</a></code>.
</p>
<p>The graph summary printed by <code>summary.igraph</code> (and <code>print.igraph()</code>
and <code>print_all()</code>) consists of one or more lines. The first line contains
the basic properties of the graph, and the rest contains its attributes.
Here is an example, a small star graph with weighted directed edges and named
vertices: </p>
<pre>    IGRAPH badcafe DNW- 10 9 -- In-star
    + attr: name (g/c), mode (g/c), center (g/n), name (v/c),
      weight (e/n) </pre>
<p>The first line always
starts with <code>IGRAPH</code>, showing you that the object is an igraph graph.
Then a seven character code is printed, this the first seven characters
of the unique id of the graph. See <code><a href="#topic+graph_id">graph_id()</a></code> for more.
Then a four letter long code string is printed. The first letter
distinguishes between directed (&lsquo;<code>D</code>&rsquo;) and undirected
(&lsquo;<code>U</code>&rsquo;) graphs. The second letter is &lsquo;<code>N</code>&rsquo; for named
graphs, i.e. graphs with the <code>name</code> vertex attribute set. The third
letter is &lsquo;<code>W</code>&rsquo; for weighted graphs, i.e. graphs with the
<code>weight</code> edge attribute set. The fourth letter is &lsquo;<code>B</code>&rsquo; for
bipartite graphs, i.e. for graphs with the <code>type</code> vertex attribute set.
</p>
<p>This is followed by the number of vertices and edges, then two dashes.
</p>
<p>Finally, after two dashes, the name of the graph is printed, if it has one,
i.e. if the <code>name</code> graph attribute is set.
</p>
<p>From the second line, the attributes of the graph are listed, separated by a
comma. After the attribute names, the kind of the attribute &ndash; graph
(&lsquo;<code>g</code>&rsquo;), vertex (&lsquo;<code>v</code>&rsquo;) or edge (&lsquo;<code>e</code>&rsquo;)
&ndash; is denoted, and the type of the attribute as well, character
(&lsquo;<code>c</code>&rsquo;), numeric (&lsquo;<code>n</code>&rsquo;), logical
(&lsquo;<code>l</code>&rsquo;), or other (&lsquo;<code>x</code>&rsquo;).
</p>
<p>As of igraph 0.4 <code>print_all()</code> and <code>print.igraph()</code> use the
<code>max.print</code> option, see <code><a href="base.html#topic+options">base::options()</a></code> for details.
</p>
<p>As of igraph 1.1.1, the <code>str.igraph</code> function is defunct, use
<code>print_all()</code>.
</p>


<h3>Value</h3>

<p>All these functions return the graph invisibly.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
g
summary(g)

</code></pre>

<hr>
<h2 id='print.igraph.es'>Print an edge sequence to the screen</h2><span id='topic+print.igraph.es'></span>

<h3>Description</h3>

<p>For long edge sequences, the printing is truncated to fit to the
screen. Use <code><a href="base.html#topic+print">print()</a></code> explicitly and the <code>full</code> argument to
see the full sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
print(x, full = igraph_opt("print.full"), id = igraph_opt("print.id"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.igraph.es_+3A_x">x</code></td>
<td>
<p>An edge sequence.</p>
</td></tr>
<tr><td><code id="print.igraph.es_+3A_full">full</code></td>
<td>
<p>Whether to show the full sequence, or truncate the output
to the screen size.</p>
</td></tr>
<tr><td><code id="print.igraph.es_+3A_id">id</code></td>
<td>
<p>Whether to print the graph ID.</p>
</td></tr>
<tr><td><code id="print.igraph.es_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Edge sequences created with the double bracket operator are printed
differently, together with all attributes of the edges in the sequence,
as a table.
</p>


<h3>Value</h3>

<p>The edge sequence, invisibly.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unnamed graphs
g &lt;- make_ring(10)
E(g)

# Named graphs
g2 &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = LETTERS[1:10])
E(g2)

# All edges in a long sequence
g3 &lt;- make_ring(200)
E(g3)
E(g3) %&gt;% print(full = TRUE)

# Metadata
g4 &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = LETTERS[1:10]) %&gt;%
  set_edge_attr("weight", value = 1:10) %&gt;%
  set_edge_attr("color", value = "green")
E(g4)
E(g4)[[]]
E(g4)[[1:5]]
</code></pre>

<hr>
<h2 id='print.igraph.vs'>Show a vertex sequence on the screen</h2><span id='topic+print.igraph.vs'></span>

<h3>Description</h3>

<p>For long vertex sequences, the printing is truncated to fit to the
screen. Use <code><a href="base.html#topic+print">print()</a></code> explicitly and the <code>full</code> argument to
see the full sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
print(x, full = igraph_opt("print.full"), id = igraph_opt("print.id"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.igraph.vs_+3A_x">x</code></td>
<td>
<p>A vertex sequence.</p>
</td></tr>
<tr><td><code id="print.igraph.vs_+3A_full">full</code></td>
<td>
<p>Whether to show the full sequence, or truncate the output
to the screen size.</p>
</td></tr>
<tr><td><code id="print.igraph.vs_+3A_id">id</code></td>
<td>
<p>Whether to print the graph ID.</p>
</td></tr>
<tr><td><code id="print.igraph.vs_+3A_...">...</code></td>
<td>
<p>These arguments are currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vertex sequence created with the double bracket operator are
printed differently, together with all attributes of the vertices
in the sequence, as a table.
</p>


<h3>Value</h3>

<p>The vertex sequence, invisibly.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+V">V</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Unnamed graphs
g &lt;- make_ring(10)
V(g)

# Named graphs
g2 &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = LETTERS[1:10])
V(g2)

# All vertices in the sequence
g3 &lt;- make_ring(1000)
V(g3)
print(V(g3), full = TRUE)

# Metadata
g4 &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = LETTERS[1:10]) %&gt;%
  set_vertex_attr("color", value = "red")
V(g4)[[]]
V(g4)[[2:5, 7:8]]
</code></pre>

<hr>
<h2 id='print.igraphHRG'>Print a hierarchical random graph model to the screen</h2><span id='topic+print.igraphHRG'></span>

<h3>Description</h3>

<p><code>igraphHRG</code> objects can be printed to the screen in two forms: as
a tree or as a list, depending on the <code>type</code> argument of the
print function. By default the <code>auto</code> type is used, which selects
<code>tree</code> for small graphs and <code>simple</code> (=list) for bigger
ones. The <code>tree</code> format looks like
this: </p>
<pre>Hierarchical random graph, at level 3:
g1        p=   0
'- g15    p=0.33  1
   '- g13 p=0.88  6  3  9  4  2  10 7  5  8
'- g8     p= 0.5
   '- g16 p= 0.2  20 14 17 19 11 15 16 13
   '- g5  p=   0  12 18  </pre>
<p>This is a graph with 20 vertices, and the
top three levels of the fitted hierarchical random graph are
printed. The root node of the HRG is always vertex group #1
(&lsquo;<code>g1</code>&rsquo; in the the printout). Vertex pairs in the left
subtree of <code>g1</code> connect to vertices in the right subtree with
probability zero, according to the fitted model. <code>g1</code> has two
subgroups, <code>g15</code> and <code>g8</code>. <code>g15</code> has a subgroup of a
single vertex (vertex 1), and another larger subgroup that contains
vertices 6, 3, etc. on lower levels, etc.
The <code>plain</code> printing is simpler and faster to produce, but less
visual: </p>
<pre>Hierarchical random graph:
g1  p=0.0 -&gt; g12 g10   g2  p=1.0 -&gt; 7 10      g3  p=1.0 -&gt; g18 14
g4  p=1.0 -&gt; g17 15    g5  p=0.4 -&gt; g15 17    g6  p=0.0 -&gt; 1 4
g7  p=1.0 -&gt; 11 16     g8  p=0.1 -&gt; g9 3      g9  p=0.3 -&gt; g11 g16
g10 p=0.2 -&gt; g4 g5     g11 p=1.0 -&gt; g6 5      g12 p=0.8 -&gt; g8 8
g13 p=0.0 -&gt; g14 9     g14 p=1.0 -&gt; 2 6       g15 p=0.2 -&gt; g19 18
g16 p=1.0 -&gt; g13 g2    g17 p=0.5 -&gt; g7 13     g18 p=1.0 -&gt; 12 19
g19 p=0.7 -&gt; g3 20</pre>
<p>It lists the two subgroups of each internal node, in
as many columns as the screen width allows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraphHRG'
print(x, type = c("auto", "tree", "plain"), level = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.igraphHRG_+3A_x">x</code></td>
<td>
<p><code>igraphHRG</code> object to print.</p>
</td></tr>
<tr><td><code id="print.igraphHRG_+3A_type">type</code></td>
<td>
<p>How to print the dendrogram, see details below.</p>
</td></tr>
<tr><td><code id="print.igraphHRG_+3A_level">level</code></td>
<td>
<p>The number of top levels to print from the dendrogram.</p>
</td></tr>
<tr><td><code id="print.igraphHRG_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used currently.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The hierarchical random graph model itself, invisibly.
</p>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+consensus_tree">consensus_tree</a>()</code>,
<code><a href="#topic+fit_hrg">fit_hrg</a>()</code>,
<code><a href="#topic+hrg">hrg</a>()</code>,
<code><a href="#topic+hrg-methods">hrg-methods</a></code>,
<code><a href="#topic+hrg_tree">hrg_tree</a>()</code>,
<code><a href="#topic+predict_edges">predict_edges</a>()</code>,
<code><a href="#topic+print.igraphHRGConsensus">print.igraphHRGConsensus</a>()</code>,
<code><a href="#topic+sample_hrg">sample_hrg</a>()</code>
</p>

<hr>
<h2 id='print.igraphHRGConsensus'>Print a hierarchical random graph consensus tree to the screen</h2><span id='topic+print.igraphHRGConsensus'></span>

<h3>Description</h3>

<p>Consensus dendrograms (<code>igraphHRGConsensus</code> objects) are printed
simply by listing the children of each internal node of the
dendrogram: </p>
<pre>HRG consensus tree:
g1 -&gt; 11 12 13 14 15 16 17 18 19 20
g2 -&gt; 1  2  3  4  5  6  7  8  9  10
g3 -&gt; g1 g2</pre>
<p>The root of the dendrogram is <code>g3</code> (because it has no incoming
edges), and it has two subgroups, <code>g1</code> and <code>g2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraphHRGConsensus'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.igraphHRGConsensus_+3A_x">x</code></td>
<td>
<p><code>igraphHRGConsensus</code> object to print.</p>
</td></tr>
<tr><td><code id="print.igraphHRGConsensus_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object, invisibly, to allow method chaining.
</p>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+consensus_tree">consensus_tree</a>()</code>,
<code><a href="#topic+fit_hrg">fit_hrg</a>()</code>,
<code><a href="#topic+hrg">hrg</a>()</code>,
<code><a href="#topic+hrg-methods">hrg-methods</a></code>,
<code><a href="#topic+hrg_tree">hrg_tree</a>()</code>,
<code><a href="#topic+predict_edges">predict_edges</a>()</code>,
<code><a href="#topic+print.igraphHRG">print.igraphHRG</a>()</code>,
<code><a href="#topic+sample_hrg">sample_hrg</a>()</code>
</p>

<hr>
<h2 id='printer_callback'>Create a printer callback function</h2><span id='topic+printer_callback'></span>

<h3>Description</h3>

<p>A printer callback function is a function can performs the actual
printing. It has a number of subcommands, that are called by
the <code>printer</code> package, in a form </p>
<pre>
    printer_callback("subcommand", argument1, argument2, ...)
</pre><p> See the examples below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printer_callback(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printer_callback_+3A_fun">fun</code></td>
<td>
<p>The function to use as a printer callback function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subcommands:
</p>

<dl>
<dt><code>length</code></dt><dd><p>The length of the data to print, the number of
items, in natural units. E.g. for a list of objects, it is the
number of objects.</p>
</dd>
<dt><code>min_width</code></dt><dd><p>TODO</p>
</dd>
<dt><code>width</code></dt><dd><p>Width of one item, if <code>no</code> items will be
printed. TODO</p>
</dd>
<dt><code>print</code></dt><dd><p>Argument: <code>no</code>. Do the actual printing,
print <code>no</code> items.</p>
</dd>
<dt><code>done</code></dt><dd><p>TODO</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other printer callbacks: 
<code><a href="#topic+is_printer_callback">is_printer_callback</a>()</code>
</p>

<hr>
<h2 id='r_pal'>The default R palette</h2><span id='topic+r_pal'></span>

<h3>Description</h3>

<p>This is the default R palette, to be able to reproduce the
colors of older igraph versions. Its colors are appropriate
for categories, but they are not very attractive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_pal(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_pal_+3A_n">n</code></td>
<td>
<p>The number of colors to use, the maximum is eight.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of color names.
</p>


<h3>See Also</h3>

<p>Other palettes: 
<code><a href="#topic+categorical_pal">categorical_pal</a>()</code>,
<code><a href="#topic+diverging_pal">diverging_pal</a>()</code>,
<code><a href="#topic+sequential_pal">sequential_pal</a>()</code>
</p>

<hr>
<h2 id='radius'>Radius of a graph</h2><span id='topic+radius'></span>

<h3>Description</h3>

<p>The eccentricity of a vertex is its shortest path distance from the
farthest other node in the graph. The smallest eccentricity in a graph
is called its radius
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radius(graph, mode = c("all", "out", "in", "total"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radius_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be directed or undirected.</p>
</td></tr>
<tr><td><code id="radius_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the corresponding
undirected graph will be used, edge directions will be ignored. This
argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The eccentricity of a vertex is calculated by measuring the shortest
distance from (or to) the vertex, to (or from) all vertices in the
graph, and taking the maximum.
</p>
<p>This implementation ignores vertex pairs that are in different
components.  Isolate vertices have eccentricity zero.
</p>


<h3>Value</h3>

<p>A numeric scalar, the radius of the graph.
</p>


<h3>References</h3>

<p>Harary, F. Graph Theory. Reading, MA: Addison-Wesley, p. 35,
1994.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eccentricity">eccentricity()</a></code> for the underlying
calculations, <a href="#topic+distances">distances</a> for general shortest path
calculations.
</p>
<p>Other paths: 
<code><a href="#topic+all_simple_paths">all_simple_paths</a>()</code>,
<code><a href="#topic+diameter">diameter</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+eccentricity">eccentricity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_star(10, mode = "undirected")
eccentricity(g)
radius(g)
</code></pre>

<hr>
<h2 id='random_walk'>Random walk on a graph</h2><span id='topic+random_walk'></span><span id='topic+random_edge_walk'></span>

<h3>Description</h3>

<p><code>random_walk()</code> performs a random walk on the graph and returns the
vertices that the random walk passed through. <code>random_edge_walk()</code>
is the same but returns the edges that that random walk passed through.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_walk(
  graph,
  start,
  steps,
  weights = NULL,
  mode = c("out", "in", "all", "total"),
  stuck = c("return", "error")
)

random_edge_walk(
  graph,
  start,
  steps,
  weights = NULL,
  mode = c("out", "in", "all", "total"),
  stuck = c("return", "error")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_walk_+3A_graph">graph</code></td>
<td>
<p>The input graph, might be undirected or directed.</p>
</td></tr>
<tr><td><code id="random_walk_+3A_start">start</code></td>
<td>
<p>The start vertex.</p>
</td></tr>
<tr><td><code id="random_walk_+3A_steps">steps</code></td>
<td>
<p>The number of steps to make.</p>
</td></tr>
<tr><td><code id="random_walk_+3A_weights">weights</code></td>
<td>
<p>The edge weights. Larger edge weights increase the
probability that an edge is selected by the random walker. In other
words, larger edge weights correspond to stronger connections. The
&lsquo;weight&rsquo; edge attribute is used if present. Supply
&lsquo;<code>NA</code>&rsquo; here if you want to ignore the &lsquo;weight&rsquo; edge
attribute.</p>
</td></tr>
<tr><td><code id="random_walk_+3A_mode">mode</code></td>
<td>
<p>How to follow directed edges. <code>"out"</code> steps along the
edge direction, <code>"in"</code> is opposite to that. <code>"all"</code> ignores
edge directions. This argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="random_walk_+3A_stuck">stuck</code></td>
<td>
<p>What to do if the random walk gets stuck. <code>"return"</code>
returns the partial walk, <code>"error"</code> raises an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Do a random walk. From the given start vertex, take the given number of
steps, choosing an edge from the actual vertex uniformly randomly. Edge
directions are observed in directed graphs (see the <code>mode</code> argument
as well). Multiple and loop edges are also observed.
</p>
<p>For igraph &lt; 1.6.0, <code>random_walk()</code> counted steps differently,
and returned a sequence of length <code>steps</code> instead of <code>steps + 1</code>.
This has changed to improve consistency with the underlying C library.
</p>


<h3>Value</h3>

<p>For <code>random_walk()</code>, a vertex sequence of length <code>steps + 1</code>
containing the vertices along the walk, starting with <code>start</code>.
For <code>random_edge_walk()</code>, an edge sequence of length <code>steps</code> containing
the edges along the walk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Stationary distribution of a Markov chain
g &lt;- make_ring(10, directed = TRUE) %u%
  make_star(11, center = 11) + edge(11, 1)

ec &lt;- eigen_centrality(g, directed = TRUE)$vector
pg &lt;- page_rank(g, damping = 0.999)$vector
w &lt;- random_walk(g, start = 1, steps = 10000)

## These are similar, but not exactly the same
cor(table(w), ec)

## But these are (almost) the same
cor(table(w), pg)
</code></pre>

<hr>
<h2 id='read_graph'>Reading foreign file formats</h2><span id='topic+read_graph'></span><span id='topic+LGL'></span><span id='topic+Pajek'></span><span id='topic+GraphML'></span><span id='topic+GML'></span><span id='topic+DL'></span><span id='topic+UCINET'></span>

<h3>Description</h3>

<p>The <code>read_graph()</code> function is able to read graphs in various
representations from a file, or from a http connection. Various formats
are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_graph(
  file,
  format = c("edgelist", "pajek", "ncol", "lgl", "graphml", "dimacs", "graphdb", "gml",
    "dl"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_graph_+3A_file">file</code></td>
<td>
<p>The connection to read from. This can be a local file, or a
<code>http</code> or <code>ftp</code> connection. It can also be a character string with
the file name or URI.</p>
</td></tr>
<tr><td><code id="read_graph_+3A_format">format</code></td>
<td>
<p>Character constant giving the file format. Right now
<code>edgelist</code>, <code>pajek</code>, <code>ncol</code>, <code>lgl</code>, <code>graphml</code>,
<code>dimacs</code>, <code>graphdb</code>, <code>gml</code> and <code>dl</code> are supported,
the default is <code>edgelist</code>. As of igraph 0.4 this argument is case
insensitive.</p>
</td></tr>
<tr><td><code id="read_graph_+3A_...">...</code></td>
<td>
<p>Additional arguments, see below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>read_graph()</code> function may have additional arguments depending on
the file format (the <code>format</code> argument). See the details separately for
each file format, below.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Edge list format</h3>

<p>This format is a simple text file with numeric
vertex IDs defining the edges. There is no need to have newline characters
between the edges, a simple space will also do. Vertex IDs contained in
the file are assumed to start at zero.
</p>
<p>Additional arguments: </p>
 <dl>
<dt>n</dt><dd><p>The number of vertices in the
graph. If it is smaller than or equal to the largest integer in the file,
then it is ignored; so it is safe to set it to zero (the default).</p>
</dd>
<dt>directed</dt><dd><p>Logical scalar, whether to create a directed graph. The
default value is <code>TRUE</code>.</p>
</dd> </dl>



<h3>Pajek format</h3>

<p>Currently igraph only supports Pajek network
files, with a <code>.net</code> extension, but not Pajek project files with
a <code>.paj</code> extension. Only network data is supported; permutations,
hierarchies, clusters and vectors are not.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write_graph">write_graph()</a></code>
</p>
<p>Foreign format readers
<code><a href="#topic+graph_from_graphdb">graph_from_graphdb</a>()</code>,
<code><a href="#topic+write_graph">write_graph</a>()</code>
</p>

<hr>
<h2 id='read.graph'>Reading foreign file formats</h2><span id='topic+read.graph'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>read.graph()</code> was renamed to <code>read_graph()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.graph(
  file,
  format = c("edgelist", "pajek", "ncol", "lgl", "graphml", "dimacs", "graphdb", "gml",
    "dl"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.graph_+3A_file">file</code></td>
<td>
<p>The connection to read from. This can be a local file, or a
<code>http</code> or <code>ftp</code> connection. It can also be a character string with
the file name or URI.</p>
</td></tr>
<tr><td><code id="read.graph_+3A_format">format</code></td>
<td>
<p>Character constant giving the file format. Right now
<code>edgelist</code>, <code>pajek</code>, <code>ncol</code>, <code>lgl</code>, <code>graphml</code>,
<code>dimacs</code>, <code>graphdb</code>, <code>gml</code> and <code>dl</code> are supported,
the default is <code>edgelist</code>. As of igraph 0.4 this argument is case
insensitive.</p>
</td></tr>
<tr><td><code id="read.graph_+3A_...">...</code></td>
<td>
<p>Additional arguments, see below.</p>
</td></tr>
</table>

<hr>
<h2 id='realize_bipartite_degseq'>Creating a bipartite graph from two degree sequences, deterministically</h2><span id='topic+realize_bipartite_degseq'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Constructs a bipartite graph from the degree sequences of its partitions,
if one exists. This function uses a Havel-Hakimi style construction
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realize_bipartite_degseq(
  degrees1,
  degrees2,
  ...,
  allowed.edge.types = c("simple", "multiple"),
  method = c("smallest", "largest", "index")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="realize_bipartite_degseq_+3A_degrees1">degrees1</code></td>
<td>
<p>The degrees of the first partition.</p>
</td></tr>
<tr><td><code id="realize_bipartite_degseq_+3A_degrees2">degrees2</code></td>
<td>
<p>The degrees of the second partition.</p>
</td></tr>
<tr><td><code id="realize_bipartite_degseq_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="realize_bipartite_degseq_+3A_allowed.edge.types">allowed.edge.types</code></td>
<td>
<p>Character, specifies the types of allowed edges.
&ldquo;simple&rdquo; allows simple graphs only (no multiple edges).
&ldquo;multiple&rdquo; allows multiple edges.</p>
</td></tr>
<tr><td><code id="realize_bipartite_degseq_+3A_method">method</code></td>
<td>
<p>Character, the method for generating the graph; see below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &lsquo;method&rsquo; argument controls in which order the vertices are
selected during the course of the algorithm.
</p>
<p>The &ldquo;smallest&rdquo; method selects the vertex with the smallest remaining
degree, from either partition. The result is usually a graph with high
negative degree assortativity. In the undirected case, this method is
guaranteed to generate a connected graph, regardless of whether multi-edges
are allowed, provided that a connected realization exists. This is the
default method.
</p>
<p>The &ldquo;largest&rdquo; method selects the vertex with the largest remaining
degree. The result is usually a graph with high positive degree
assortativity, and is often disconnected.
</p>
<p>The &ldquo;index&rdquo; method selects the vertices in order of their index.
</p>


<h3>Value</h3>

<p>The new graph object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+realize_degseq">realize_degseq()</a></code> to create a not necessarily bipartite graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- realize_bipartite_degseq(c(3, 3, 2, 1, 1), c(2, 2, 2, 2, 2))
degree(g)
</code></pre>

<hr>
<h2 id='realize_degseq'>Creating a graph from a given degree sequence, deterministically</h2><span id='topic+realize_degseq'></span>

<h3>Description</h3>

<p>It is often useful to create a graph with given vertex degrees. This function
creates such a graph in a deterministic manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>realize_degseq(
  out.deg,
  in.deg = NULL,
  allowed.edge.types = c("simple", "loops", "multi", "all"),
  method = c("smallest", "largest", "index")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="realize_degseq_+3A_out.deg">out.deg</code></td>
<td>
<p>Numeric vector, the sequence of degrees (for undirected
graphs) or out-degrees (for directed graphs). For undirected graphs its sum
should be even. For directed graphs its sum should be the same as the sum of
<code>in.deg</code>.</p>
</td></tr>
<tr><td><code id="realize_degseq_+3A_in.deg">in.deg</code></td>
<td>
<p>For directed graph, the in-degree sequence. By default this is
<code>NULL</code> and an undirected graph is created.</p>
</td></tr>
<tr><td><code id="realize_degseq_+3A_allowed.edge.types">allowed.edge.types</code></td>
<td>
<p>Character, specifies the types of allowed edges.
&ldquo;simple&rdquo; allows simple graphs only (no loops, no multiple edges).
&ldquo;multiple&rdquo; allows multiple edges but disallows loop.
&ldquo;loops&rdquo; allows loop edges but disallows multiple edges (currently
unimplemented). &ldquo;all&rdquo; allows all types of edges. The default is
&ldquo;simple&rdquo;.</p>
</td></tr>
<tr><td><code id="realize_degseq_+3A_method">method</code></td>
<td>
<p>Character, the method for generating the graph; see below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple undirected graphs are constructed using the Havel-Hakimi algorithm
(undirected case), or the analogous Kleitman-Wang algorithm (directed case).
These algorithms work by choosing an arbitrary vertex and connecting all its
stubs to other vertices. This step is repeated until all degrees have been
connected up.
</p>
<p>The &lsquo;method&rsquo; argument controls in which order the vertices are
selected during the course of the algorithm.
</p>
<p>The &ldquo;smallest&rdquo; method selects the vertex with the smallest remaining
degree. The result is usually a graph with high negative degree assortativity.
In the undirected case, this method is guaranteed to generate a connected
graph, regardless of whether multi-edges are allowed, provided that a
connected realization exists. See Horvát and Modes (2021) for details.
In the directed case it tends to generate weakly connected graphs, but this
is not guaranteed. This is the default method.
</p>
<p>The &ldquo;largest&rdquo; method selects the vertex with the largest remaining
degree. The result is usually a graph with high positive degree assortativity,
and is often disconnected.
</p>
<p>The &ldquo;index&rdquo; method selects the vertices in order of their index.
</p>


<h3>Value</h3>

<p>The new graph object.
</p>


<h3>References</h3>

<p>V. Havel,
Poznámka o existenci konečných grafů (A remark on the existence of finite graphs),
Časopis pro pěstování matematiky 80, 477-480 (1955).
https://eudml.org/doc/19050
</p>
<p>S. L. Hakimi,
On Realizability of a Set of Integers as Degrees of the Vertices of a Linear Graph,
Journal of the SIAM 10, 3 (1962).
<a href="https://doi.org/10.1137/0111010">doi:10.1137/0111010</a>
</p>
<p>D. J. Kleitman and D. L. Wang,
Algorithms for Constructing Graphs and Digraphs with Given Valences and Factors,
Discrete Mathematics 6, 1 (1973).
<a href="https://doi.org/10.1016/0012-365X%2873%2990037-X">doi:10.1016/0012-365X(73)90037-X</a>
</p>
<p>Sz. Horvát and C. D. Modes,
Connectedness matters: construction and exact random sampling of connected networks (2021).
<a href="https://doi.org/10.1088/2632-072X/abced5">doi:10.1088/2632-072X/abced5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_degseq">sample_degseq()</a></code> for a randomized variant that samples
from graphs with the given degree sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- realize_degseq(rep(2, 100))
degree(g)
is_simple(g)

## Exponential degree distribution, with high positive assortativity.
## Loop and multiple edges are explicitly allowed.
## Note that we correct the degree sequence if its sum is odd.
degs &lt;- sample(1:100, 100, replace = TRUE, prob = exp(-0.5 * (1:100)))
if (sum(degs) %% 2 != 0) {
  degs[1] &lt;- degs[1] + 1
}
g4 &lt;- realize_degseq(degs, method = "largest", allowed.edge.types = "all")
all(degree(g4) == degs)

## Power-law degree distribution, no loops allowed but multiple edges
## are okay.
## Note that we correct the degree sequence if its sum is odd.
degs &lt;- sample(1:100, 100, replace = TRUE, prob = (1:100)^-2)
if (sum(degs) %% 2 != 0) {
  degs[1] &lt;- degs[1] + 1
}
g5 &lt;- realize_degseq(degs, allowed.edge.types = "multi")
all(degree(g5) == degs)
</code></pre>

<hr>
<h2 id='reciprocity'>Reciprocity of graphs</h2><span id='topic+reciprocity'></span>

<h3>Description</h3>

<p>Calculates the reciprocity of a directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reciprocity(graph, ignore.loops = TRUE, mode = c("default", "ratio"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reciprocity_+3A_graph">graph</code></td>
<td>
<p>The graph object.</p>
</td></tr>
<tr><td><code id="reciprocity_+3A_ignore.loops">ignore.loops</code></td>
<td>
<p>Logical constant, whether to ignore loop edges.</p>
</td></tr>
<tr><td><code id="reciprocity_+3A_mode">mode</code></td>
<td>
<p>See below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure of reciprocity defines the proportion of mutual connections, in
a directed graph. It is most commonly defined as the probability that the
opposite counterpart of a directed edge is also included in the graph. Or in
adjacency matrix notation:
<code class="reqn">1 - \left(\sum_{i,j} |A_{ij} - A_{ji}|\right) / \left(2\sum_{i,j} A_{ij}\right)</code>.
This measure is calculated if the <code>mode</code> argument is <code>default</code>.
</p>
<p>Prior to igraph version 0.6, another measure was implemented, defined as the
probability of mutual connection between a vertex pair, if we know that
there is a (possibly non-mutual) connection between them. In other words,
(unordered) vertex pairs are classified into three groups: (1)
not-connected, (2) non-reciprocally connected, (3) reciprocally connected.
The result is the size of group (3), divided by the sum of group sizes
(2)+(3). This measure is calculated if <code>mode</code> is <code>ratio</code>.
</p>


<h3>Value</h3>

<p>A numeric scalar between zero and one.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(20, 5 / 20, directed = TRUE)
reciprocity(g)

</code></pre>

<hr>
<h2 id='remove.edge.attribute'>Delete an edge attribute</h2><span id='topic+remove.edge.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>remove.edge.attribute()</code> was renamed to <code>delete_edge_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.edge.attribute(graph, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.edge.attribute_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
<tr><td><code id="remove.edge.attribute_+3A_name">name</code></td>
<td>
<p>The name of the edge attribute to delete.</p>
</td></tr>
</table>

<hr>
<h2 id='remove.graph.attribute'>Delete a graph attribute</h2><span id='topic+remove.graph.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>remove.graph.attribute()</code> was renamed to <code>delete_graph_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.graph.attribute(graph, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.graph.attribute_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="remove.graph.attribute_+3A_name">name</code></td>
<td>
<p>Name of the attribute to delete.</p>
</td></tr>
</table>

<hr>
<h2 id='remove.vertex.attribute'>Delete a vertex attribute</h2><span id='topic+remove.vertex.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>remove.vertex.attribute()</code> was renamed to <code>delete_vertex_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.vertex.attribute(graph, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.vertex.attribute_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
<tr><td><code id="remove.vertex.attribute_+3A_name">name</code></td>
<td>
<p>The name of the vertex attribute to delete.</p>
</td></tr>
</table>

<hr>
<h2 id='rep.igraph'>Replicate a graph multiple times</h2><span id='topic+rep.igraph'></span><span id='topic++2A.igraph'></span>

<h3>Description</h3>

<p>The new graph will contain the input graph the given number
of times, as unconnected components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
rep(x, n, mark = TRUE, ...)

## S3 method for class 'igraph'
x * n
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep.igraph_+3A_x">x</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="rep.igraph_+3A_n">n</code></td>
<td>
<p>Number of times to replicate it.</p>
</td></tr>
<tr><td><code id="rep.igraph_+3A_mark">mark</code></td>
<td>
<p>Whether to mark the vertices with a <code>which</code> attribute,
an integer number denoting which replication the vertex is coming
from.</p>
</td></tr>
<tr><td><code id="rep.igraph_+3A_...">...</code></td>
<td>
<p>Additional arguments to satisfy S3 requirements,
currently ignored.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rings &lt;- make_ring(5) * 5
</code></pre>

<hr>
<h2 id='rev.igraph.es'>Reverse the order in an edge sequence</h2><span id='topic+rev.igraph.es'></span>

<h3>Description</h3>

<p>Reverse the order in an edge sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev.igraph.es_+3A_x">x</code></td>
<td>
<p>The edge sequence to reverse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reversed edge sequence.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
E(g)
E(g) %&gt;% rev()
</code></pre>

<hr>
<h2 id='rev.igraph.vs'>Reverse the order in a vertex sequence</h2><span id='topic+rev.igraph.vs'></span>

<h3>Description</h3>

<p>Reverse the order in a vertex sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev.igraph.vs_+3A_x">x</code></td>
<td>
<p>The vertex sequence to reverse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reversed vertex sequence.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
V(g) %&gt;% rev()
</code></pre>

<hr>
<h2 id='reverse_edges'>Reverse edges in a graph</h2><span id='topic+reverse_edges'></span><span id='topic+t.igraph'></span>

<h3>Description</h3>

<p>The new graph will contain the same vertices, edges and attributes as
the original graph, except that the direction of the edges selected by
their edge IDs in the <code>eids</code> argument will be reversed. When reversing
all edges, this operation is also known as graph transpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_edges(graph, eids = E(graph))

## S3 method for class 'igraph'
t(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_edges_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="reverse_edges_+3A_eids">eids</code></td>
<td>
<p>The edge IDs of the edges to reverse.</p>
</td></tr>
<tr><td><code id="reverse_edges_+3A_x">x</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result graph where the direction of the edges with the given
IDs are reversed
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph(~ 1 -+ 2, 2 -+ 3, 3 -+ 4)
reverse_edges(g, 2)
</code></pre>

<hr>
<h2 id='rewire'>Rewiring edges of a graph</h2><span id='topic+rewire'></span>

<h3>Description</h3>

<p>See the links below for the implemented rewiring methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rewire(graph, with)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rewire_+3A_graph">graph</code></td>
<td>
<p>The graph to rewire</p>
</td></tr>
<tr><td><code id="rewire_+3A_with">with</code></td>
<td>
<p>A function call to one of the rewiring methods,
see details below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rewired graph.
</p>


<h3>See Also</h3>

<p>Other rewiring functions: 
<code><a href="#topic+each_edge">each_edge</a>()</code>,
<code><a href="#topic+keeping_degseq">keeping_degseq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
g %&gt;%
  rewire(each_edge(p = .1, loops = FALSE)) %&gt;%
  plot(layout = layout_in_circle)
print_all(rewire(g, with = keeping_degseq(niter = vcount(g) * 10)))
</code></pre>

<hr>
<h2 id='rglplot'>3D plotting of graphs with OpenGL</h2><span id='topic+rglplot'></span><span id='topic+rglplot.igraph'></span>

<h3>Description</h3>

<p>Using the <code>rgl</code> package, <code>rglplot()</code> plots a graph in 3D. The plot
can be zoomed, rotated, shifted, etc. but the coordinates of the vertices is
fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rglplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rglplot_+3A_x">x</code></td>
<td>
<p>The graph to plot.</p>
</td></tr>
<tr><td><code id="rglplot_+3A_...">...</code></td>
<td>
<p>Additional arguments, see <a href="#topic+igraph.plotting">igraph.plotting</a> for the
details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>rglplot()</code> is considered to be highly experimental. It is not
very useful either. See <a href="#topic+igraph.plotting">igraph.plotting</a> for the possible
arguments.
</p>


<h3>Value</h3>

<p><code>NULL</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+igraph.plotting">igraph.plotting</a>, <code><a href="#topic+plot.igraph">plot.igraph()</a></code> for the 2D
version, <code><a href="#topic+tkplot">tkplot()</a></code> for interactive graph drawing in 2D.
</p>
<p>Other plot: 
<code><a href="#topic+plot.igraph">plot.igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_lattice(c(5, 5, 5))
coords &lt;- layout_with_fr(g, dim = 3)
if (interactive() &amp;&amp; requireNamespace("rgl", quietly = TRUE)) {
  rglplot(g, layout = coords)
}

</code></pre>

<hr>
<h2 id='running_mean'>Running mean of a time series</h2><span id='topic+running_mean'></span>

<h3>Description</h3>

<p><code>running_mean()</code> calculates the running mean in a vector with the given
bin width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>running_mean(v, binwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="running_mean_+3A_v">v</code></td>
<td>
<p>The numeric vector.</p>
</td></tr>
<tr><td><code id="running_mean_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric constant, the size of the bin, should be meaningful,
i.e. smaller than the length of <code>v</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The running mean of <code>v</code> is a <code>w</code> vector of length
<code>length(v)-binwidth+1</code>. The first element of <code>w</code> id the average of
the first <code>binwidth</code> elements of <code>v</code>, the second element of
<code>w</code> is the average of elements <code>2:(binwidth+1)</code>, etc.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>length(v)-binwidth+1</code>
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other other: 
<code><a href="#topic+convex_hull">convex_hull</a>()</code>,
<code><a href="#topic+sample_seq">sample_seq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
running_mean(1:100, 10)

</code></pre>

<hr>
<h2 id='running.mean'>Running mean of a time series</h2><span id='topic+running.mean'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>running.mean()</code> was renamed to <code>running_mean()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>running.mean(v, binwidth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="running.mean_+3A_v">v</code></td>
<td>
<p>The numeric vector.</p>
</td></tr>
<tr><td><code id="running.mean_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric constant, the size of the bin, should be meaningful,
i.e. smaller than the length of <code>v</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='sample_'>Sample from a random graph model</h2><span id='topic+sample_'></span>

<h3>Description</h3>

<p>Generic function for sampling from network models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample__+3A_...">...</code></td>
<td>
<p>Parameters, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pref_matrix &lt;- cbind(c(0.8, 0.1), c(0.1, 0.7))
blocky &lt;- sample_(sbm(
  n = 20, pref.matrix = pref_matrix,
  block.sizes = c(10, 10)
))

blocky2 &lt;- pref_matrix %&gt;%
  sample_sbm(n = 20, block.sizes = c(10, 10))

## Arguments are passed on from sample_ to sample_sbm
blocky3 &lt;- pref_matrix %&gt;%
  sample_(sbm(), n = 20, block.sizes = c(10, 10))
</code></pre>

<hr>
<h2 id='sample_bipartite'>Bipartite random graphs</h2><span id='topic+sample_bipartite'></span><span id='topic+bipartite'></span>

<h3>Description</h3>

<p>Generate bipartite graphs using the Erdős-Rényi model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_bipartite(
  n1,
  n2,
  type = c("gnp", "gnm"),
  p,
  m,
  directed = FALSE,
  mode = c("out", "in", "all")
)

bipartite(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_bipartite_+3A_n1">n1</code></td>
<td>
<p>Integer scalar, the number of bottom vertices.</p>
</td></tr>
<tr><td><code id="sample_bipartite_+3A_n2">n2</code></td>
<td>
<p>Integer scalar, the number of top vertices.</p>
</td></tr>
<tr><td><code id="sample_bipartite_+3A_type">type</code></td>
<td>
<p>Character scalar, the type of the graph, &lsquo;gnp&rsquo; creates a
<code class="reqn">G(n,p)</code> graph, &lsquo;gnm&rsquo; creates a <code class="reqn">G(n,m)</code> graph. See details below.</p>
</td></tr>
<tr><td><code id="sample_bipartite_+3A_p">p</code></td>
<td>
<p>Real scalar, connection probability for <code class="reqn">G(n,p)</code> graphs. Should not
be given for <code class="reqn">G(n,m)</code> graphs.</p>
</td></tr>
<tr><td><code id="sample_bipartite_+3A_m">m</code></td>
<td>
<p>Integer scalar, the number of edges for <code class="reqn">G(n,m)</code> graphs. Should not
be given for <code class="reqn">G(n,p)</code> graphs.</p>
</td></tr>
<tr><td><code id="sample_bipartite_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to create a directed graph. See also
the <code>mode</code> argument.</p>
</td></tr>
<tr><td><code id="sample_bipartite_+3A_mode">mode</code></td>
<td>
<p>Character scalar, specifies how to direct the edges in directed
graphs. If it is &lsquo;out&rsquo;, then directed edges point from bottom
vertices to top vertices. If it is &lsquo;in&rsquo;, edges point from top
vertices to bottom vertices. &lsquo;out&rsquo; and &lsquo;in&rsquo; do not generate
mutual edges. If this argument is &lsquo;all&rsquo;, then each edge direction is
considered independently and mutual edges might be generated. This argument
is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="sample_bipartite_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_bipartite()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similarly to unipartite (one-mode) networks, we can define the <code class="reqn">G(n,p)</code>, and
<code class="reqn">G(n,m)</code> graph classes for bipartite graphs, via their generating process.
In <code class="reqn">G(n,p)</code> every possible edge between top and bottom vertices is realized
with probability <code class="reqn">p</code>, independently of the rest of the edges. In <code class="reqn">G(n,m)</code>, we
uniformly choose <code class="reqn">m</code> edges to realize.
</p>


<h3>Value</h3>

<p>A bipartite igraph graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## empty graph
sample_bipartite(10, 5, p = 0)

## full graph
sample_bipartite(10, 5, p = 1)

## random bipartite graph
sample_bipartite(10, 5, p = .1)

## directed bipartite graph, G(n,m)
sample_bipartite(10, 5, type = "Gnm", m = 20, directed = TRUE, mode = "all")

</code></pre>

<hr>
<h2 id='sample_correlated_gnp'>Generate a new random graph from a given graph by randomly
adding/removing edges</h2><span id='topic+sample_correlated_gnp'></span>

<h3>Description</h3>

<p>Sample a new graph by perturbing the adjacency matrix of a given graph
and shuffling its vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_correlated_gnp(
  old.graph,
  corr,
  p = edge_density(old.graph),
  permutation = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_correlated_gnp_+3A_old.graph">old.graph</code></td>
<td>
<p>The original graph.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_+3A_corr">corr</code></td>
<td>
<p>A scalar in the unit interval, the target Pearson
correlation between the adjacency matrices of the original and the generated
graph (the adjacency matrix being used as a vector).</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_+3A_p">p</code></td>
<td>
<p>A numeric scalar, the probability of an edge between two
vertices, it must in the open (0,1) interval. The default is the empirical
edge density of the graph. If you are resampling an Erdős-Rényi graph and
you know the original edge probability of the Erdős-Rényi model, you should
supply that explicitly.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_+3A_permutation">permutation</code></td>
<td>
<p>A numeric vector, a permutation vector that is
applied on the vertices of the first graph, to get the second graph.  If
<code>NULL</code>, the vertices are not permuted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see the reference given below.
</p>


<h3>Value</h3>

<p>An unweighted graph of the same size as <code>old.graph</code> such
that the correlation coefficient between the entries of the two
adjacency matrices is <code>corr</code>.  Note each pair of corresponding
matrix entries is a pair of correlated Bernoulli random variables.
</p>


<h3>References</h3>

<p>Lyzinski, V., Fishkind, D. E., Priebe, C. E. (2013).  Seeded
graph matching for correlated Erdős-Rényi graphs.
<a href="https://arxiv.org/abs/1304.7844">https://arxiv.org/abs/1304.7844</a>
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_gnp(1000, .1)
g2 &lt;- sample_correlated_gnp(g, corr = 0.5)
cor(as.vector(g[]), as.vector(g2[]))
g
g2
</code></pre>

<hr>
<h2 id='sample_correlated_gnp_pair'>Sample a pair of correlated <code class="reqn">G(n,p)</code> random graphs</h2><span id='topic+sample_correlated_gnp_pair'></span>

<h3>Description</h3>

<p>Sample a new graph by perturbing the adjacency matrix of a given graph and
shuffling its vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_correlated_gnp_pair(n, corr, p, directed = FALSE, permutation = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_correlated_gnp_pair_+3A_n">n</code></td>
<td>
<p>Numeric scalar, the number of vertices for the sampled graphs.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_corr">corr</code></td>
<td>
<p>A scalar in the unit interval, the target Pearson correlation
between the adjacency matrices of the original the generated graph (the
adjacency matrix being used as a vector).</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_p">p</code></td>
<td>
<p>A numeric scalar, the probability of an edge between two vertices,
it must in the open (0,1) interval.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to generate directed graphs.</p>
</td></tr>
<tr><td><code id="sample_correlated_gnp_pair_+3A_permutation">permutation</code></td>
<td>
<p>A numeric vector, a permutation vector that is applied on
the vertices of the first graph, to get the second graph.  If <code>NULL</code>,
the vertices are not permuted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see the reference given below.
</p>


<h3>Value</h3>

<p>A list of two igraph objects, named <code>graph1</code> and
<code>graph2</code>, which are two graphs whose adjacency matrix entries are
correlated with <code>corr</code>.
</p>


<h3>References</h3>

<p>Lyzinski, V., Fishkind, D. E., Priebe, C. E. (2013).  Seeded
graph matching for correlated Erdős-Rényi graphs.
<a href="https://arxiv.org/abs/1304.7844">https://arxiv.org/abs/1304.7844</a>
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gg &lt;- sample_correlated_gnp_pair(
  n = 10, corr = .8, p = .5,
  directed = FALSE
)
gg
cor(as.vector(gg[[1]][]), as.vector(gg[[2]][]))
</code></pre>

<hr>
<h2 id='sample_degseq'>Generate random graphs with a given degree sequence</h2><span id='topic+sample_degseq'></span><span id='topic+degseq'></span>

<h3>Description</h3>

<p>It is often useful to create a graph with given vertex degrees. This function
creates such a graph in a randomized manner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_degseq(
  out.deg,
  in.deg = NULL,
  method = c("simple", "vl", "simple.no.multiple", "simple.no.multiple.uniform")
)

degseq(..., deterministic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_degseq_+3A_out.deg">out.deg</code></td>
<td>
<p>Numeric vector, the sequence of degrees (for undirected
graphs) or out-degrees (for directed graphs). For undirected graphs its sum
should be even. For directed graphs its sum should be the same as the sum of
<code>in.deg</code>.</p>
</td></tr>
<tr><td><code id="sample_degseq_+3A_in.deg">in.deg</code></td>
<td>
<p>For directed graph, the in-degree sequence. By default this is
<code>NULL</code> and an undirected graph is created.</p>
</td></tr>
<tr><td><code id="sample_degseq_+3A_method">method</code></td>
<td>
<p>Character, the method for generating the graph. Right now the
&ldquo;simple&rdquo;, &ldquo;simple.no.multiple&rdquo; and &ldquo;vl&rdquo; methods are
implemented.</p>
</td></tr>
<tr><td><code id="sample_degseq_+3A_...">...</code></td>
<td>
<p>Passed to <code>realize_degseq()</code> if &lsquo;deterministic&rsquo; is true,
or to <code>sample_degseq()</code> otherwise.</p>
</td></tr>
<tr><td><code id="sample_degseq_+3A_deterministic">deterministic</code></td>
<td>
<p>Whether the construction should be deterministic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &ldquo;simple&rdquo; method connects the out-stubs of the edges (undirected
graphs) or the out-stubs and in-stubs (directed graphs) together. This way
loop edges and also multiple edges may be generated. This method is not
adequate if one needs to generate simple graphs with a given degree
sequence. The multiple and loop edges can be deleted, but then the degree
sequence is distorted and there is nothing to ensure that the graphs are
sampled uniformly.
</p>
<p>The &ldquo;simple.no.multiple&rdquo; method is similar to &ldquo;simple&rdquo;, but
tries to avoid multiple and loop edges and restarts the generation from
scratch if it gets stuck. It is not guaranteed to sample uniformly from the
space of all possible graphs with the given sequence, but it is relatively
fast and it will eventually succeed if the provided degree sequence is
graphical, but there is no upper bound on the number of iterations.
</p>
<p>The &ldquo;simple.no.multiple.uniform&rdquo; method is a variant of
&ldquo;simple.no.multiple&rdquo; with the added benefit of sampling uniformly
from the set of all possible simple graphs with the given degree sequence.
Ensuring uniformity has some performance implications, though.
</p>
<p>The &ldquo;vl&rdquo; method is a more sophisticated generator. The algorithm and
the implementation was done by Fabien Viger and Matthieu Latapy. This
generator always generates undirected, connected simple graphs, it is an
error to pass the <code>in.deg</code> argument to it.  The algorithm relies on
first creating an initial (possibly unconnected) simple undirected graph
with the given degree sequence (if this is possible at all). Then some
rewiring is done to make the graph connected. Finally a Monte-Carlo
algorithm is used to randomize the graph. The &ldquo;vl&rdquo; samples from the
undirected, connected simple graphs uniformly.
</p>


<h3>Value</h3>

<p>The new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplify">simplify()</a></code> to get rid of the multiple and/or loops edges,
<code><a href="#topic+realize_degseq">realize_degseq()</a></code> for a deterministic variant.
</p>
<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The simple generator
g &lt;- sample_degseq(rep(2, 100))
degree(g)
is_simple(g) # sometimes TRUE, but can be FALSE
g2 &lt;- sample_degseq(1:10, 10:1)
degree(g2, mode = "out")
degree(g2, mode = "in")

## The vl generator
g3 &lt;- sample_degseq(rep(2, 100), method = "vl")
degree(g3)
is_simple(g3) # always TRUE

## Exponential degree distribution
## Note, that we correct the degree sequence if its sum is odd
degs &lt;- sample(1:100, 100, replace = TRUE, prob = exp(-0.5 * (1:100)))
if (sum(degs) %% 2 != 0) {
  degs[1] &lt;- degs[1] + 1
}
g4 &lt;- sample_degseq(degs, method = "vl")
all(degree(g4) == degs)

## Power-law degree distribution
## Note, that we correct the degree sequence if its sum is odd
degs &lt;- sample(1:100, 100, replace = TRUE, prob = (1:100)^-2)
if (sum(degs) %% 2 != 0) {
  degs[1] &lt;- degs[1] + 1
}
g5 &lt;- sample_degseq(degs, method = "vl")
all(degree(g5) == degs)
</code></pre>

<hr>
<h2 id='sample_dirichlet'>Sample from a Dirichlet distribution</h2><span id='topic+sample_dirichlet'></span>

<h3>Description</h3>

<p>Sample finite-dimensional vectors to use as latent position vectors in
random dot product graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dirichlet(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_dirichlet_+3A_n">n</code></td>
<td>
<p>Integer scalar, the sample size.</p>
</td></tr>
<tr><td><code id="sample_dirichlet_+3A_alpha">alpha</code></td>
<td>
<p>Numeric vector, the vector of <code class="reqn">\alpha</code> parameter for
the Dirichlet distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sample_dirichlet()</code> generates samples from the Dirichlet distribution
with given <code class="reqn">\alpha</code> parameter. The sample is drawn from
<code>length(alpha)-1</code>-simplex.
</p>


<h3>Value</h3>

<p>A <code>dim</code> (length of the <code>alpha</code> vector for
<code>sample_dirichlet()</code>) times <code>n</code> matrix, whose columns are the sample
vectors.
</p>


<h3>See Also</h3>

<p>Other latent position vector samplers: 
<code><a href="#topic+sample_sphere_surface">sample_sphere_surface</a>()</code>,
<code><a href="#topic+sample_sphere_volume">sample_sphere_volume</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lpvs.dir &lt;- sample_dirichlet(n = 20, alpha = rep(1, 10))
RDP.graph.2 &lt;- sample_dot_product(lpvs.dir)
colSums(lpvs.dir)
</code></pre>

<hr>
<h2 id='sample_dot_product'>Generate random graphs according to the random dot product graph model</h2><span id='topic+sample_dot_product'></span><span id='topic+dot_product'></span>

<h3>Description</h3>

<p>In this model, each vertex is represented by a latent position vector.
Probability of an edge between two vertices are given by the dot product of
their latent position vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_dot_product(vecs, directed = FALSE)

dot_product(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_dot_product_+3A_vecs">vecs</code></td>
<td>
<p>A numeric matrix in which each latent position vector is a
column.</p>
</td></tr>
<tr><td><code id="sample_dot_product_+3A_directed">directed</code></td>
<td>
<p>A logical scalar, TRUE if the generated graph should be
directed.</p>
</td></tr>
<tr><td><code id="sample_dot_product_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_dot_product()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dot product of the latent position vectors should be in the [0,1]
interval, otherwise a warning is given. For negative dot products, no edges
are added; dot products that are larger than one always add an edge.
</p>


<h3>Value</h3>

<p>An igraph graph object which is the generated random dot product
graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Christine Leigh Myers Nickel: Random dot product graphs, a model
for social networks. Dissertation, Johns Hopkins University, Maryland, USA,
2006.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_dirichlet">sample_dirichlet()</a></code>, <code><a href="#topic+sample_sphere_surface">sample_sphere_surface()</a></code>
and <code><a href="#topic+sample_sphere_volume">sample_sphere_volume()</a></code> for sampling position vectors.
</p>
<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A randomly generated  graph
lpvs &lt;- matrix(rnorm(200), 20, 10)
lpvs &lt;- apply(lpvs, 2, function(x) {
  return(abs(x) / sqrt(sum(x^2)))
})
g &lt;- sample_dot_product(lpvs)
g

## Sample latent vectors from the surface of the unit sphere
lpvs2 &lt;- sample_sphere_surface(dim = 5, n = 20)
g2 &lt;- sample_dot_product(lpvs2)
g2
</code></pre>

<hr>
<h2 id='sample_fitness'>Random graphs from vertex fitness scores</h2><span id='topic+sample_fitness'></span>

<h3>Description</h3>

<p>This function generates a non-growing random graph with edge probabilities
proportional to node fitness scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fitness(
  no.of.edges,
  fitness.out,
  fitness.in = NULL,
  loops = FALSE,
  multiple = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_fitness_+3A_no.of.edges">no.of.edges</code></td>
<td>
<p>The number of edges in the generated graph.</p>
</td></tr>
<tr><td><code id="sample_fitness_+3A_fitness.out">fitness.out</code></td>
<td>
<p>A numeric vector containing the fitness of each vertex.
For directed graphs, this specifies the out-fitness of each vertex.</p>
</td></tr>
<tr><td><code id="sample_fitness_+3A_fitness.in">fitness.in</code></td>
<td>
<p>If <code>NULL</code> (the default), the generated graph will be
undirected. If not <code>NULL</code>, then it should be a numeric vector and it
specifies the in-fitness of each vertex.
</p>
<p>If this argument is not <code>NULL</code>, then a directed graph is generated,
otherwise an undirected one.</p>
</td></tr>
<tr><td><code id="sample_fitness_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether to allow loop edges in the graph.</p>
</td></tr>
<tr><td><code id="sample_fitness_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether to allow multiple edges in the
graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This game generates a directed or undirected random graph where the
probability of an edge between vertices <code class="reqn">i</code> and <code class="reqn">j</code> depends on the
fitness scores of the two vertices involved. For undirected graphs, each
vertex has a single fitness score. For directed graphs, each vertex has an
out- and an in-fitness, and the probability of an edge from <code class="reqn">i</code> to
<code class="reqn">j</code> depends on the out-fitness of vertex <code class="reqn">i</code> and the in-fitness of
vertex <code class="reqn">j</code>.
</p>
<p>The generation process goes as follows. We start from <code class="reqn">N</code> disconnected
nodes (where <code class="reqn">N</code> is given by the length of the fitness vector). Then we
randomly select two vertices <code class="reqn">i</code> and <code class="reqn">j</code>, with probabilities
proportional to their fitnesses. (When the generated graph is directed,
<code class="reqn">i</code> is selected according to the out-fitnesses and <code class="reqn">j</code> is selected
according to the in-fitnesses). If the vertices are not connected yet (or if
multiple edges are allowed), we connect them; otherwise we select a new
pair. This is repeated until the desired number of links are created.
</p>
<p>It can be shown that the <em>expected</em> degree of each vertex will be
proportional to its fitness, although the actual, observed degree will not
be. If you need to generate a graph with an exact degree sequence, consider
<code><a href="#topic+sample_degseq">sample_degseq()</a></code> instead.
</p>
<p>This model is commonly used to generate static scale-free networks. To
achieve this, you have to draw the fitness scores from the desired power-law
distribution. Alternatively, you may use <code><a href="#topic+sample_fitness_pl">sample_fitness_pl()</a></code>
which generates the fitnesses for you with a given exponent.
</p>


<h3>Value</h3>

<p>An igraph graph, directed or undirected.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>Goh K-I, Kahng B, Kim D: Universal behaviour of load
distribution in scale-free networks. <em>Phys Rev Lett</em> 87(27):278701,
2001.
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 10000
g &lt;- sample_fitness(5 * N, sample((1:50)^-2, N, replace = TRUE))
degree_distribution(g)
plot(degree_distribution(g, cumulative = TRUE), log = "xy")
</code></pre>

<hr>
<h2 id='sample_fitness_pl'>Scale-free random graphs, from vertex fitness scores</h2><span id='topic+sample_fitness_pl'></span>

<h3>Description</h3>

<p>This function generates a non-growing random graph with expected power-law
degree distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_fitness_pl(
  no.of.nodes,
  no.of.edges,
  exponent.out,
  exponent.in = -1,
  loops = FALSE,
  multiple = FALSE,
  finite.size.correction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_fitness_pl_+3A_no.of.nodes">no.of.nodes</code></td>
<td>
<p>The number of vertices in the generated graph.</p>
</td></tr>
<tr><td><code id="sample_fitness_pl_+3A_no.of.edges">no.of.edges</code></td>
<td>
<p>The number of edges in the generated graph.</p>
</td></tr>
<tr><td><code id="sample_fitness_pl_+3A_exponent.out">exponent.out</code></td>
<td>
<p>Numeric scalar, the power law exponent of the degree
distribution. For directed graphs, this specifies the exponent of the
out-degree distribution. It must be greater than or equal to 2. If you pass
<code>Inf</code> here, you will get back an Erdős-Rényi random network.</p>
</td></tr>
<tr><td><code id="sample_fitness_pl_+3A_exponent.in">exponent.in</code></td>
<td>
<p>Numeric scalar. If negative, the generated graph will be
undirected. If greater than or equal to 2, this argument specifies the
exponent of the in-degree distribution. If non-negative but less than 2, an
error will be generated.</p>
</td></tr>
<tr><td><code id="sample_fitness_pl_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether to allow loop edges in the generated
graph.</p>
</td></tr>
<tr><td><code id="sample_fitness_pl_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether to allow multiple edges in the
generated graph.</p>
</td></tr>
<tr><td><code id="sample_fitness_pl_+3A_finite.size.correction">finite.size.correction</code></td>
<td>
<p>Logical scalar, whether to use the proposed
finite size correction of Cho et al., see references below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This game generates a directed or undirected random graph where the degrees
of vertices follow power-law distributions with prescribed exponents. For
directed graphs, the exponents of the in- and out-degree distributions may
be specified separately.
</p>
<p>The game simply uses <code><a href="#topic+sample_fitness">sample_fitness()</a></code> with appropriately
constructed fitness vectors. In particular, the fitness of vertex <code class="reqn">i</code> is
<code class="reqn">i^{-\alpha}</code>, where <code class="reqn">\alpha = 1/(\gamma-1)</code>
and <code class="reqn">\gamma</code> is the exponent given in the arguments.
</p>
<p>To remove correlations between in- and out-degrees in case of directed
graphs, the in-fitness vector will be shuffled after it has been set up and
before <code><a href="#topic+sample_fitness">sample_fitness()</a></code> is called.
</p>
<p>Note that significant finite size effects may be observed for exponents
smaller than 3 in the original formulation of the game. This function
provides an argument that lets you remove the finite size effects by
assuming that the fitness of vertex <code class="reqn">i</code> is
<code class="reqn">(i+i_0-1)^{-\alpha}</code> where <code class="reqn">i_0</code> is a
constant chosen appropriately to ensure that the maximum degree is less than
the square root of the number of edges times the average degree; see the
paper of Chung and Lu, and Cho et al for more details.
</p>


<h3>Value</h3>

<p>An igraph graph, directed or undirected.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>References</h3>

<p>Goh K-I, Kahng B, Kim D: Universal behaviour of load
distribution in scale-free networks. <em>Phys Rev Lett</em> 87(27):278701,
2001.
</p>
<p>Chung F and Lu L: Connected components in a random graph with given degree
sequences. <em>Annals of Combinatorics</em> 6, 125-145, 2002.
</p>
<p>Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in
scale-free networks under the Achlioptas process. <em>Phys Rev Lett</em>
103:135702, 2009.
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_fitness_pl(10000, 30000, 2.2, 2.3)
plot(degree_distribution(g, cumulative = TRUE, mode = "out"), log = "xy")
</code></pre>

<hr>
<h2 id='sample_forestfire'>Forest Fire Network Model</h2><span id='topic+sample_forestfire'></span>

<h3>Description</h3>

<p>This is a growing network model, which resembles of how the forest fire
spreads by igniting trees close by.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_forestfire(nodes, fw.prob, bw.factor = 1, ambs = 1, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_forestfire_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_forestfire_+3A_fw.prob">fw.prob</code></td>
<td>
<p>The forward burning probability, see details below.</p>
</td></tr>
<tr><td><code id="sample_forestfire_+3A_bw.factor">bw.factor</code></td>
<td>
<p>The backward burning ratio. The backward burning
probability is calculated as <code>bw.factor*fw.prob</code>.</p>
</td></tr>
<tr><td><code id="sample_forestfire_+3A_ambs">ambs</code></td>
<td>
<p>The number of ambassador vertices.</p>
</td></tr>
<tr><td><code id="sample_forestfire_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to create a directed graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forest fire model intends to reproduce the following network
characteristics, observed in real networks: </p>
 <ul>
<li><p> Heavy-tailed
in-degree distribution.  </p>
</li>
<li><p> Heavy-tailed out-degree distribution.  </p>
</li>
<li>
<p>Communities.  </p>
</li>
<li><p> Densification power-law. The network is densifying in
time, according to a power-law rule.  </p>
</li>
<li><p> Shrinking diameter. The diameter
of the network decreases in time.  </p>
</li></ul>

<p>The network is generated in the following way. One vertex is added at a
time. This vertex connects to (cites) <code>ambs</code> vertices already present
in the network, chosen uniformly random. Now, for each cited vertex <code class="reqn">v</code>
we do the following procedure: </p>
 <ol>
<li><p> We generate two random
number, <code class="reqn">x</code> and <code class="reqn">y</code>, that are geometrically distributed with means
<code class="reqn">p/(1-p)</code> and <code class="reqn">rp(1-rp)</code>. (<code class="reqn">p</code> is <code>fw.prob</code>, <code class="reqn">r</code> is
<code>bw.factor</code>.) The new vertex cites <code class="reqn">x</code> outgoing neighbors and
<code class="reqn">y</code> incoming neighbors of <code class="reqn">v</code>, from those which are not yet cited by
the new vertex. If there are less than <code class="reqn">x</code> or <code class="reqn">y</code> such vertices
available then we cite all of them.  </p>
</li>
<li><p> The same procedure is applied to
all the newly cited vertices.  </p>
</li></ol>



<h3>Value</h3>

<p>A simple graph, possibly directed if the <code>directed</code> argument is
<code>TRUE</code>.
</p>


<h3>Note</h3>

<p>The version of the model in the published paper is incorrect in the
sense that it cannot generate the kind of graphs the authors claim. A
corrected version is available from
<a href="http://www.cs.cmu.edu/~jure/pubs/powergrowth-tkdd.pdf">http://www.cs.cmu.edu/~jure/pubs/powergrowth-tkdd.pdf</a>, our
implementation is based on this.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Jure Leskovec, Jon Kleinberg and Christos Faloutsos. Graphs over
time: densification laws, shrinking diameters and possible explanations.
<em>KDD '05: Proceeding of the eleventh ACM SIGKDD international
conference on Knowledge discovery in data mining</em>, 177&ndash;187, 2005.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+barabasi.game">barabasi.game()</a></code> for the basic preferential attachment
model.
</p>
<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_forestfire(10000, fw.prob = 0.37, bw.factor = 0.32 / 0.37)
dd1 &lt;- degree_distribution(g, mode = "in")
dd2 &lt;- degree_distribution(g, mode = "out")
plot(seq(along.with = dd1) - 1, dd1, log = "xy")
points(seq(along.with = dd2) - 1, dd2, col = 2, pch = 2)
</code></pre>

<hr>
<h2 id='sample_gnm'>Generate random graphs according to the <code class="reqn">G(n,m)</code> Erdős-Rényi model</h2><span id='topic+sample_gnm'></span><span id='topic+gnm'></span>

<h3>Description</h3>

<p>Random graph with a fixed number of edges and vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_gnm(n, m, directed = FALSE, loops = FALSE)

gnm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_gnm_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_gnm_+3A_m">m</code></td>
<td>
<p>The number of edges in the graph.</p>
</td></tr>
<tr><td><code id="sample_gnm_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the graph will be directed, defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sample_gnm_+3A_loops">loops</code></td>
<td>
<p>Logical, whether to add loop edges, defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sample_gnm_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_gnm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph has <code>n</code> vertices and <code>m</code> edges. The edges are chosen uniformly
at random from the set of all vertex pairs. This set includes potential
self-connections as well if the <code>loops</code> parameter is <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Erdős, P. and Rényi, A., On random graphs, <em>Publicationes
Mathematicae</em> 6, 290&ndash;297 (1959).
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnm(1000, 1000)
degree_distribution(g)
</code></pre>

<hr>
<h2 id='sample_gnp'>Generate random graphs according to the <code class="reqn">G(n,p)</code> Erdős-Rényi model</h2><span id='topic+sample_gnp'></span><span id='topic+gnp'></span>

<h3>Description</h3>

<p>Every possible edge is created independently with the same probability <code>p</code>.
This model is also referred to as a Bernoulli random graph since the
connectivity status of vertex pairs follows a Bernoulli distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_gnp(n, p, directed = FALSE, loops = FALSE)

gnp(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_gnp_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_gnp_+3A_p">p</code></td>
<td>
<p>The probability for drawing an edge between two
arbitrary vertices (<code class="reqn">G(n,p)</code> graph).</p>
</td></tr>
<tr><td><code id="sample_gnp_+3A_directed">directed</code></td>
<td>
<p>Logical, whether the graph will be directed, defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sample_gnp_+3A_loops">loops</code></td>
<td>
<p>Logical, whether to add loop edges, defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sample_gnp_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_gnp()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The graph has <code>n</code> vertices and each pair of vertices is connected
with the same probability <code>p</code>. The <code>loops</code> parameter controls whether
self-connections are also considered. This model effectively constrains
the average number of edges, <code class="reqn">p m_\text{max}</code>, where <code class="reqn">m_\text{max}</code>
is the largest possible number of edges, which depends on whether the
graph is directed or undirected and whether self-loops are allowed.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Erdős, P. and Rényi, A., On random graphs, <em>Publicationes
Mathematicae</em> 6, 290&ndash;297 (1959).
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(1000, 1 / 1000)
degree_distribution(g)
</code></pre>

<hr>
<h2 id='sample_grg'>Geometric random graphs</h2><span id='topic+sample_grg'></span><span id='topic+grg'></span>

<h3>Description</h3>

<p>Generate a random graph based on the distance of random point on a unit
square
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_grg(nodes, radius, torus = FALSE, coords = FALSE)

grg(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_grg_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_grg_+3A_radius">radius</code></td>
<td>
<p>The radius within which the vertices will be connected by an
edge.</p>
</td></tr>
<tr><td><code id="sample_grg_+3A_torus">torus</code></td>
<td>
<p>Logical constant, whether to use a torus instead of a square.</p>
</td></tr>
<tr><td><code id="sample_grg_+3A_coords">coords</code></td>
<td>
<p>Logical scalar, whether to add the positions of the vertices
as vertex attributes called &lsquo;<code>x</code>&rsquo; and &lsquo;<code>y</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="sample_grg_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_grg()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First a number of points are dropped on a unit square, these points
correspond to the vertices of the graph to create. Two points will be
connected with an undirected edge if they are closer to each other in
Euclidean norm than a given radius. If the <code>torus</code> argument is
<code>TRUE</code> then a unit area torus is used instead of a square.
</p>


<h3>Value</h3>

<p>A graph object. If <code>coords</code> is <code>TRUE</code> then with vertex
attributes &lsquo;<code>x</code>&rsquo; and &lsquo;<code>y</code>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>, first version was
written by Keith Briggs (<a href="http://keithbriggs.info/">http://keithbriggs.info/</a>).
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_grg(1000, 0.05, torus = FALSE)
g2 &lt;- sample_grg(1000, 0.05, torus = TRUE)

</code></pre>

<hr>
<h2 id='sample_growing'>Growing random graph generation</h2><span id='topic+sample_growing'></span><span id='topic+growing'></span>

<h3>Description</h3>

<p>This function creates a random graph by simulating its stochastic evolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_growing(n, m = 1, directed = TRUE, citation = FALSE)

growing(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_growing_+3A_n">n</code></td>
<td>
<p>Numeric constant, number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_growing_+3A_m">m</code></td>
<td>
<p>Numeric constant, number of edges added in each time step.</p>
</td></tr>
<tr><td><code id="sample_growing_+3A_directed">directed</code></td>
<td>
<p>Logical, whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="sample_growing_+3A_citation">citation</code></td>
<td>
<p>Logical. If <code>TRUE</code> a citation graph is created, i.e. in
each time step the added edges are originating from the new vertex.</p>
</td></tr>
<tr><td><code id="sample_growing_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_growing()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is discrete time step model, in each time step a new vertex is added to
the graph and <code>m</code> new edges are created. If <code>citation</code> is
<code>FALSE</code> these edges are connecting two uniformly randomly chosen
vertices, otherwise the edges are connecting new vertex to uniformly
randomly chosen old vertices.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_growing(500, citation = FALSE)
g2 &lt;- sample_growing(500, citation = TRUE)

</code></pre>

<hr>
<h2 id='sample_hierarchical_sbm'>Sample the hierarchical stochastic block model</h2><span id='topic+sample_hierarchical_sbm'></span><span id='topic+hierarchical_sbm'></span>

<h3>Description</h3>

<p>Sampling from a hierarchical stochastic block model of networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_hierarchical_sbm(n, m, rho, C, p)

hierarchical_sbm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_hierarchical_sbm_+3A_n">n</code></td>
<td>
<p>Integer scalar, the number of vertices.</p>
</td></tr>
<tr><td><code id="sample_hierarchical_sbm_+3A_m">m</code></td>
<td>
<p>Integer scalar, the number of vertices per block. <code>n / m</code> must
be integer. Alternatively, an integer vector of block sizes, if not all the
blocks have equal sizes.</p>
</td></tr>
<tr><td><code id="sample_hierarchical_sbm_+3A_rho">rho</code></td>
<td>
<p>Numeric vector, the fraction of vertices per cluster, within a
block. Must sum up to 1, and <code>rho * m</code> must be integer for all elements
of rho. Alternatively a list of rho vectors, one for each block, if they are
not the same for all blocks.</p>
</td></tr>
<tr><td><code id="sample_hierarchical_sbm_+3A_c">C</code></td>
<td>
<p>A square, symmetric numeric matrix, the Bernoulli rates for the
clusters within a block. Its size must mach the size of the <code>rho</code>
vector. Alternatively, a list of square matrices, if the Bernoulli rates
differ in different blocks.</p>
</td></tr>
<tr><td><code id="sample_hierarchical_sbm_+3A_p">p</code></td>
<td>
<p>Numeric scalar, the Bernoulli rate of connections between vertices
in different blocks.</p>
</td></tr>
<tr><td><code id="sample_hierarchical_sbm_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_hierarchical_sbm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a random graph according to the hierarchical
stochastic block model.
</p>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Ten blocks with three clusters each
C &lt;- matrix(c(
  1, 3 / 4, 0,
  3 / 4, 0, 3 / 4,
  0, 3 / 4, 3 / 4
), nrow = 3)
g &lt;- sample_hierarchical_sbm(100, 10, rho = c(3, 3, 4) / 10, C = C, p = 1 / 20)
g
if (require(Matrix)) {
  image(g[])
}
</code></pre>

<hr>
<h2 id='sample_hrg'>Sample from a hierarchical random graph model</h2><span id='topic+sample_hrg'></span>

<h3>Description</h3>

<p><code>sample_hrg()</code> samples a graph from a given hierarchical random graph
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_hrg(hrg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_hrg_+3A_hrg">hrg</code></td>
<td>
<p>A hierarchical random graph model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>See Also</h3>

<p>Other hierarchical random graph functions: 
<code><a href="#topic+consensus_tree">consensus_tree</a>()</code>,
<code><a href="#topic+fit_hrg">fit_hrg</a>()</code>,
<code><a href="#topic+hrg">hrg</a>()</code>,
<code><a href="#topic+hrg-methods">hrg-methods</a></code>,
<code><a href="#topic+hrg_tree">hrg_tree</a>()</code>,
<code><a href="#topic+predict_edges">predict_edges</a>()</code>,
<code><a href="#topic+print.igraphHRG">print.igraphHRG</a>()</code>,
<code><a href="#topic+print.igraphHRGConsensus">print.igraphHRGConsensus</a>()</code>
</p>

<hr>
<h2 id='sample_islands'>A graph with subgraphs that are each a random graph.</h2><span id='topic+sample_islands'></span>

<h3>Description</h3>

<p>Create a number of Erdős-Rényi random graphs with identical parameters, and
connect them with the specified number of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_islands(islands.n, islands.size, islands.pin, n.inter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_islands_+3A_islands.n">islands.n</code></td>
<td>
<p>The number of islands in the graph.</p>
</td></tr>
<tr><td><code id="sample_islands_+3A_islands.size">islands.size</code></td>
<td>
<p>The size of islands in the graph.</p>
</td></tr>
<tr><td><code id="sample_islands_+3A_islands.pin">islands.pin</code></td>
<td>
<p>The probability to create each possible edge into each
island.</p>
</td></tr>
<tr><td><code id="sample_islands_+3A_n.inter">n.inter</code></td>
<td>
<p>The number of edges to create between two islands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>Examples</h3>

<pre>
g &lt;- sample_islands(3, 10, 5/10, 1)
oc &lt;- cluster_optimal(g)
oc
</pre>


<h3>Author(s)</h3>

<p>Samuel Thiriot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_gnp">sample_gnp()</a></code>
</p>
<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>

<hr>
<h2 id='sample_k_regular'>Create a random regular graph</h2><span id='topic+sample_k_regular'></span>

<h3>Description</h3>

<p>Generate a random graph where each vertex has the same degree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_k_regular(no.of.nodes, k, directed = FALSE, multiple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_k_regular_+3A_no.of.nodes">no.of.nodes</code></td>
<td>
<p>Integer scalar, the number of vertices in the generated
graph.</p>
</td></tr>
<tr><td><code id="sample_k_regular_+3A_k">k</code></td>
<td>
<p>Integer scalar, the degree of each vertex in the graph, or the
out-degree and in-degree in a directed graph.</p>
</td></tr>
<tr><td><code id="sample_k_regular_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="sample_k_regular_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether multiple edges are allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This game generates a directed or undirected random graph where the degrees
of vertices are equal to a predefined constant k. For undirected graphs, at
least one of k and the number of vertices must be even.
</p>
<p>The game simply uses <code><a href="#topic+sample_degseq">sample_degseq()</a></code> with appropriately
constructed degree sequences.
</p>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_degseq">sample_degseq()</a></code> for a generator with prescribed degree
sequence.
</p>
<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A simple ring
ring &lt;- sample_k_regular(10, 2)
plot(ring)

## k-regular graphs on 10 vertices, with k=1:9
k10 &lt;- lapply(1:9, sample_k_regular, no.of.nodes = 10)

layout(matrix(1:9, nrow = 3, byrow = TRUE))
sapply(k10, plot, vertex.label = NA)
</code></pre>

<hr>
<h2 id='sample_last_cit'>Random citation graphs</h2><span id='topic+sample_last_cit'></span><span id='topic+last_cit'></span><span id='topic+sample_cit_types'></span><span id='topic+cit_types'></span><span id='topic+sample_cit_cit_types'></span><span id='topic+cit_cit_types'></span>

<h3>Description</h3>

<p><code>sample_last_cit()</code> creates a graph, where vertices age, and
gain new connections based on how long ago their last citation
happened.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_last_cit(
  n,
  edges = 1,
  agebins = n/7100,
  pref = (1:(agebins + 1))^-3,
  directed = TRUE
)

last_cit(...)

sample_cit_types(
  n,
  edges = 1,
  types = rep(0, n),
  pref = rep(1, length(types)),
  directed = TRUE,
  attr = TRUE
)

cit_types(...)

sample_cit_cit_types(
  n,
  edges = 1,
  types = rep(0, n),
  pref = matrix(1, nrow = length(types), ncol = length(types)),
  directed = TRUE,
  attr = TRUE
)

cit_cit_types(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_last_cit_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="sample_last_cit_+3A_edges">edges</code></td>
<td>
<p>Number of edges per step.</p>
</td></tr>
<tr><td><code id="sample_last_cit_+3A_agebins">agebins</code></td>
<td>
<p>Number of aging bins.</p>
</td></tr>
<tr><td><code id="sample_last_cit_+3A_pref">pref</code></td>
<td>
<p>Vector (<code>sample_last_cit()</code> and <code>sample_cit_types()</code> or
matrix (<code>sample_cit_cit_types()</code>) giving the (unnormalized) citation
probabilities for the different vertex types.</p>
</td></tr>
<tr><td><code id="sample_last_cit_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to generate directed networks.</p>
</td></tr>
<tr><td><code id="sample_last_cit_+3A_...">...</code></td>
<td>
<p>Passed to the actual constructor.</p>
</td></tr>
<tr><td><code id="sample_last_cit_+3A_types">types</code></td>
<td>
<p>Vector of length &lsquo;<code>n</code>&rsquo;, the types of the vertices.
Types are numbered from zero.</p>
</td></tr>
<tr><td><code id="sample_last_cit_+3A_attr">attr</code></td>
<td>
<p>Logical scalar, whether to add the vertex types to the generated
graph as a vertex attribute called &lsquo;<code>type</code>&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sample_cit_cit_types()</code> is a stochastic block model where the
graph is growing.
</p>
<p><code>sample_cit_types()</code> is similarly a growing stochastic block model,
but the probability of an edge depends on the (potentially) cited
vertex only.
</p>


<h3>Value</h3>

<p>A new graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>

<hr>
<h2 id='sample_motifs'>Graph motifs</h2><span id='topic+sample_motifs'></span>

<h3>Description</h3>

<p>Graph motifs are small connected induced subgraphs with a well-defined
structure.  These functions search a graph for various motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_motifs(
  graph,
  size = 3,
  cut.prob = rep(0, size),
  sample.size = vcount(graph)/10,
  sample = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_motifs_+3A_graph">graph</code></td>
<td>
<p>Graph object, the input graph.</p>
</td></tr>
<tr><td><code id="sample_motifs_+3A_size">size</code></td>
<td>
<p>The size of the motif, currently size 3 and 4 are supported
in directed graphs and sizes 3-6 in undirected graphs.</p>
</td></tr>
<tr><td><code id="sample_motifs_+3A_cut.prob">cut.prob</code></td>
<td>
<p>Numeric vector giving the probabilities that the search
graph is cut at a certain level. Its length should be the same as the size
of the motif (the <code>size</code> argument). By default no cuts are made.</p>
</td></tr>
<tr><td><code id="sample_motifs_+3A_sample.size">sample.size</code></td>
<td>
<p>The number of vertices to use as a starting point for
finding motifs. Only used if the <code>sample</code> argument is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sample_motifs_+3A_sample">sample</code></td>
<td>
<p>If not <code>NULL</code> then it specifies the vertices to use as a
starting point for finding motifs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sample_motifs()</code> estimates the total number of motifs of a given
size in a graph based on a sample.
</p>


<h3>Value</h3>

<p>A numeric scalar, an estimate for the total number of motifs in
the graph.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+isomorphism_class">isomorphism_class()</a></code>
</p>
<p>Other graph motifs: 
<code><a href="#topic+count_motifs">count_motifs</a>()</code>,
<code><a href="#topic+dyad_census">dyad_census</a>()</code>,
<code><a href="#topic+motifs">motifs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_pa(100)
motifs(g, 3)
count_motifs(g, 3)
sample_motifs(g, 3)
</code></pre>

<hr>
<h2 id='sample_pa'>Generate random graphs using preferential attachment</h2><span id='topic+sample_pa'></span><span id='topic+pa'></span>

<h3>Description</h3>

<p>Preferential attachment is a family of simple stochastic algorithms for building
a graph. Variants include the Barabási-Abert model and the Price model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_pa(
  n,
  power = 1,
  m = NULL,
  out.dist = NULL,
  out.seq = NULL,
  out.pref = FALSE,
  zero.appeal = 1,
  directed = TRUE,
  algorithm = c("psumtree", "psumtree-multiple", "bag"),
  start.graph = NULL
)

pa(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_pa_+3A_n">n</code></td>
<td>
<p>Number of vertices.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_power">power</code></td>
<td>
<p>The power of the preferential attachment, the default is one,
i.e. linear preferential attachment.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_m">m</code></td>
<td>
<p>Numeric constant, the number of edges to add in each time step This
argument is only used if both <code>out.dist</code> and <code>out.seq</code> are omitted
or NULL.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_out.dist">out.dist</code></td>
<td>
<p>Numeric vector, the distribution of the number of edges to
add in each time step. This argument is only used if the <code>out.seq</code>
argument is omitted or NULL.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_out.seq">out.seq</code></td>
<td>
<p>Numeric vector giving the number of edges to add in each time
step. Its first element is ignored as no edges are added in the first time
step.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_out.pref">out.pref</code></td>
<td>
<p>Logical, if true the total degree is used for calculating
the citation probability, otherwise the in-degree is used.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_zero.appeal">zero.appeal</code></td>
<td>
<p>The &lsquo;attractiveness&rsquo; of the vertices with no
adjacent edges. See details below.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use for the graph generation.
<code>psumtree</code> uses a partial prefix-sum tree to generate the graph, this
algorithm can handle any <code>power</code> and <code>zero.appeal</code> values and
never generates multiple edges.  <code>psumtree-multiple</code> also uses a
partial prefix-sum tree, but the generation of multiple edges is allowed.
Before the 0.6 version igraph used this algorithm if <code>power</code> was not
one, or <code>zero.appeal</code> was not one.  <code>bag</code> is the algorithm that
was previously (before version 0.6) used if <code>power</code> was one and
<code>zero.appeal</code> was one as well. It works by putting the ids of the
vertices into a bag (multiset, really), exactly as many times as their
(in-)degree, plus once more. Then the required number of cited vertices are
drawn from the bag, with replacement. This method might generate multiple
edges. It only works if <code>power</code> and <code>zero.appeal</code> are equal one.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_start.graph">start.graph</code></td>
<td>
<p><code>NULL</code> or an igraph graph. If a graph, then the
supplied graph is used as a starting graph for the preferential attachment
algorithm. The graph should have at least one vertex. If a graph is supplied
here and the <code>out.seq</code> argument is not <code>NULL</code>, then it should
contain the out degrees of the new vertices only, not the ones in the
<code>start.graph</code>.</p>
</td></tr>
<tr><td><code id="sample_pa_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_pa()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple stochastic algorithm to generate a graph. It is a discrete
time step model and in each time step a single vertex is added.
</p>
<p>We start with a single vertex and no edges in the first time step. Then we
add one vertex in each time step and the new vertex initiates some edges to
old vertices. The probability that an old vertex is chosen is given by
</p>
<p style="text-align: center;"><code class="reqn">P[i] \sim k_i^\alpha+a</code>
</p>
<p> where <code class="reqn">k_i</code>
is the in-degree of vertex <code class="reqn">i</code> in the current time step (more precisely
the number of adjacent edges of <code class="reqn">i</code> which were not initiated by <code class="reqn">i</code>
itself) and <code class="reqn">\alpha</code> and <code class="reqn">a</code> are parameters given by the
<code>power</code> and <code>zero.appeal</code> arguments.
</p>
<p>The number of edges initiated in a time step is given by the <code>m</code>,
<code>out.dist</code> and <code>out.seq</code> arguments. If <code>out.seq</code> is given and
not NULL then it gives the number of edges to add in a vector, the first
element is ignored, the second is the number of edges to add in the second
time step and so on. If <code>out.seq</code> is not given or null and
<code>out.dist</code> is given and not NULL then it is used as a discrete
distribution to generate the number of edges in each time step. Its first
element is the probability that no edges will be added, the second is the
probability that one edge is added, etc. (<code>out.dist</code> does not need to
sum up to one, it normalized automatically.) <code>out.dist</code> should contain
non-negative numbers and at east one element should be positive.
</p>
<p>If both <code>out.seq</code> and <code>out.dist</code> are omitted or NULL then <code>m</code>
will be used, it should be a positive integer constant and <code>m</code> edges
will be added in each time step.
</p>
<p><code>sample_pa()</code> generates a directed graph by default, set
<code>directed</code> to <code>FALSE</code> to generate an undirected graph. Note that
even if an undirected graph is generated <code class="reqn">k_i</code> denotes the number
of adjacent edges not initiated by the vertex itself and not the total
(in- + out-) degree of the vertex, unless the <code>out.pref</code> argument is set to
<code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Barabási, A.-L. and Albert R. 1999. Emergence of scaling in
random networks <em>Science</em>, 286 509&ndash;512.
</p>
<p>de Solla Price, D. J. 1965. Networks of Scientific Papers <em>Science</em>,
149 510&ndash;515.
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_pa(10000)
degree_distribution(g)

</code></pre>

<hr>
<h2 id='sample_pa_age'>Generate an evolving random graph with preferential attachment and aging</h2><span id='topic+sample_pa_age'></span><span id='topic+pa_age'></span>

<h3>Description</h3>

<p>This function creates a random graph by simulating its evolution. Each time
a new vertex is added it creates a number of links to old vertices and the
probability that an old vertex is cited depends on its in-degree
(preferential attachment) and age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_pa_age(
  n,
  pa.exp,
  aging.exp,
  m = NULL,
  aging.bin = 300,
  out.dist = NULL,
  out.seq = NULL,
  out.pref = FALSE,
  directed = TRUE,
  zero.deg.appeal = 1,
  zero.age.appeal = 0,
  deg.coef = 1,
  age.coef = 1,
  time.window = NULL
)

pa_age(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_pa_age_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_pa.exp">pa.exp</code></td>
<td>
<p>The preferential attachment exponent, see the details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_aging.exp">aging.exp</code></td>
<td>
<p>The exponent of the aging, usually a non-positive number,
see details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_m">m</code></td>
<td>
<p>The number of edges each new vertex creates (except the very first
vertex). This argument is used only if both the <code>out.dist</code> and
<code>out.seq</code> arguments are NULL.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_aging.bin">aging.bin</code></td>
<td>
<p>The number of bins to use for measuring the age of
vertices, see details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_out.dist">out.dist</code></td>
<td>
<p>The discrete distribution to generate the number of edges to
add in each time step if <code>out.seq</code> is NULL. See details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_out.seq">out.seq</code></td>
<td>
<p>The number of edges to add in each time step, a vector
containing as many elements as the number of vertices. See details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_out.pref">out.pref</code></td>
<td>
<p>Logical constant, whether to include edges not initiated by
the vertex as a basis of preferential attachment. See details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to generate a directed graph. See
details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_zero.deg.appeal">zero.deg.appeal</code></td>
<td>
<p>The degree-dependent part of the
&lsquo;attractiveness&rsquo; of the vertices with no adjacent edges. See also
details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_zero.age.appeal">zero.age.appeal</code></td>
<td>
<p>The age-dependent part of the &lsquo;attrativeness&rsquo;
of the vertices with age zero. It is usually zero, see details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_deg.coef">deg.coef</code></td>
<td>
<p>The coefficient of the degree-dependent
&lsquo;attractiveness&rsquo;. See details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_age.coef">age.coef</code></td>
<td>
<p>The coefficient of the age-dependent part of the
&lsquo;attractiveness&rsquo;. See details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_time.window">time.window</code></td>
<td>
<p>Integer constant, if NULL only adjacent added in the last
<code>time.windows</code> time steps are counted as a basis of the preferential
attachment. See also details below.</p>
</td></tr>
<tr><td><code id="sample_pa_age_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_pa_age()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a discrete time step model of a growing graph. We start with a
network containing a single vertex (and no edges) in the first time step.
Then in each time step (starting with the second) a new vertex is added and
it initiates a number of edges to the old vertices in the network. The
probability that an old vertex is connected to is proportional to
</p>
<p style="text-align: center;"><code class="reqn">P[i] \sim (c\cdot k_i^\alpha+a)(d\cdot l_i^\beta+b)</code>
</p>
<p>.
</p>
<p>Here <code class="reqn">k_i</code> is the in-degree of vertex <code class="reqn">i</code> in the current time
step and <code class="reqn">l_i</code> is the age of vertex <code class="reqn">i</code>. The age is simply
defined as the number of time steps passed since the vertex is added, with
the extension that vertex age is divided to be in <code>aging.bin</code> bins.
</p>
<p><code class="reqn">c</code>, <code class="reqn">\alpha</code>, <code class="reqn">a</code>, <code class="reqn">d</code>, <code class="reqn">\beta</code> and
<code class="reqn">b</code> are parameters and they can be set via the following arguments:
<code>pa.exp</code> (<code class="reqn">\alpha</code>, mandatory argument), <code>aging.exp</code>
(<code class="reqn">\beta</code>, mandatory argument), <code>zero.deg.appeal</code> (<code class="reqn">a</code>,
optional, the default value is 1), <code>zero.age.appeal</code> (<code class="reqn">b</code>,
optional, the default is 0), <code>deg.coef</code> (<code class="reqn">c</code>, optional, the default
is 1), and <code>age.coef</code> (<code class="reqn">d</code>, optional, the default is 1).
</p>
<p>The number of edges initiated in each time step is governed by the <code>m</code>,
<code>out.seq</code> and <code>out.pref</code> parameters. If <code>out.seq</code> is given
then it is interpreted as a vector giving the number of edges to be added in
each time step. It should be of length <code>n</code> (the number of vertices),
and its first element will be ignored. If <code>out.seq</code> is not given (or
NULL) and <code>out.dist</code> is given then it will be used as a discrete
probability distribution to generate the number of edges. Its first element
gives the probability that zero edges are added at a time step, the second
element is the probability that one edge is added, etc. (<code>out.seq</code>
should contain non-negative numbers, but if they don't sum up to 1, they
will be normalized to sum up to 1. This behavior is similar to the
<code>prob</code> argument of the <code>sample</code> command.)
</p>
<p>By default a directed graph is generated, but it <code>directed</code> is set to
<code>FALSE</code> then an undirected is created. Even if an undirected graph is
generated <code class="reqn">k_i</code> denotes only the adjacent edges not initiated by
the vertex itself except if <code>out.pref</code> is set to <code>TRUE</code>.
</p>
<p>If the <code>time.window</code> argument is given (and not NULL) then
<code class="reqn">k_i</code> means only the adjacent edges added in the previous
<code>time.window</code> time steps.
</p>
<p>This function might generate graphs with multiple edges.
</p>


<h3>Value</h3>

<p>A new graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The maximum degree for graph with different aging exponents
g1 &lt;- sample_pa_age(10000, pa.exp = 1, aging.exp = 0, aging.bin = 1000)
g2 &lt;- sample_pa_age(10000, pa.exp = 1, aging.exp = -1, aging.bin = 1000)
g3 &lt;- sample_pa_age(10000, pa.exp = 1, aging.exp = -3, aging.bin = 1000)
max(degree(g1))
max(degree(g2))
max(degree(g3))
</code></pre>

<hr>
<h2 id='sample_pref'>Trait-based random generation</h2><span id='topic+sample_pref'></span><span id='topic+pref'></span><span id='topic+sample_asym_pref'></span><span id='topic+asym_pref'></span>

<h3>Description</h3>

<p>Generation of random graphs based on different vertex types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_pref(
  nodes,
  types,
  type.dist = rep(1, types),
  fixed.sizes = FALSE,
  pref.matrix = matrix(1, types, types),
  directed = FALSE,
  loops = FALSE
)

pref(...)

sample_asym_pref(
  nodes,
  types,
  type.dist.matrix = matrix(1, types, types),
  pref.matrix = matrix(1, types, types),
  loops = FALSE
)

asym_pref(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_pref_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graphs.</p>
</td></tr>
<tr><td><code id="sample_pref_+3A_types">types</code></td>
<td>
<p>The number of different vertex types.</p>
</td></tr>
<tr><td><code id="sample_pref_+3A_type.dist">type.dist</code></td>
<td>
<p>The distribution of the vertex types, a numeric vector of
length &lsquo;types&rsquo; containing non-negative numbers. The vector will be
normed to obtain probabilities.</p>
</td></tr>
<tr><td><code id="sample_pref_+3A_fixed.sizes">fixed.sizes</code></td>
<td>
<p>Fix the number of vertices with a given vertex type
label. The <code>type.dist</code> argument gives the group sizes (i.e. number of
vertices with the different labels) in this case.</p>
</td></tr>
<tr><td><code id="sample_pref_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>A square matrix giving the preferences of the vertex
types. The matrix has &lsquo;types&rsquo; rows and columns. When generating
an undirected graph, it must be symmetric.</p>
</td></tr>
<tr><td><code id="sample_pref_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to create a directed graph.</p>
</td></tr>
<tr><td><code id="sample_pref_+3A_loops">loops</code></td>
<td>
<p>Logical constant, whether self-loops are allowed in the graph.</p>
</td></tr>
<tr><td><code id="sample_pref_+3A_...">...</code></td>
<td>
<p>Passed to the constructor, <code>sample_pref()</code> or
<code>sample_asym_pref()</code>.</p>
</td></tr>
<tr><td><code id="sample_pref_+3A_type.dist.matrix">type.dist.matrix</code></td>
<td>
<p>The joint distribution of the in- and out-vertex
types.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both models generate random graphs with given vertex types. For
<code>sample_pref()</code> the probability that two vertices will be connected
depends on their type and is given by the &lsquo;pref.matrix&rsquo; argument.
This matrix should be symmetric to make sense but this is not checked. The
distribution of the different vertex types is given by the
&lsquo;type.dist&rsquo; vector.
</p>
<p>For <code>sample_asym_pref()</code> each vertex has an in-type and an
out-type and a directed graph is created. The probability that a directed
edge is realized from a vertex with a given out-type to a vertex with a
given in-type is given in the &lsquo;pref.matrix&rsquo; argument, which can be
asymmetric. The joint distribution for the in- and out-types is given in the
&lsquo;type.dist.matrix&rsquo; argument.
</p>
<p>The types of the generated vertices can be retrieved from the
<code>type</code> vertex attribute for <code>sample_pref()</code> and from the
<code>intype</code> and <code>outtype</code> vertex attribute for <code>sample_asym_pref()</code>.
</p>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the R interface
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pf &lt;- matrix(c(1, 0, 0, 1), nrow = 2)
g &lt;- sample_pref(20, 2, pref.matrix = pf)
## Not run: 
tkplot(g, layout = layout_with_fr)

## End(Not run)

pf &lt;- matrix(c(0, 1, 0, 0), nrow = 2)
g &lt;- sample_asym_pref(20, 2, pref.matrix = pf)
## Not run: 
tkplot(g, layout = layout_in_circle)

## End(Not run)

</code></pre>

<hr>
<h2 id='sample_sbm'>Sample stochastic block model</h2><span id='topic+sample_sbm'></span><span id='topic+sbm'></span>

<h3>Description</h3>

<p>Sampling from the stochastic block model of networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_sbm(n, pref.matrix, block.sizes, directed = FALSE, loops = FALSE)

sbm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_sbm_+3A_n">n</code></td>
<td>
<p>Number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_sbm_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>The matrix giving the Bernoulli rates.  This is a
<code class="reqn">K\times K</code> matrix, where <code class="reqn">K</code> is the number of groups. The
probability of creating an edge between vertices from groups <code class="reqn">i</code> and
<code class="reqn">j</code> is given by element <code class="reqn">(i,j)</code>. For undirected graphs, this matrix
must be symmetric.</p>
</td></tr>
<tr><td><code id="sample_sbm_+3A_block.sizes">block.sizes</code></td>
<td>
<p>Numeric vector giving the number of vertices in each
group. The sum of the vector must match the number of vertices.</p>
</td></tr>
<tr><td><code id="sample_sbm_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to generate a directed graph.</p>
</td></tr>
<tr><td><code id="sample_sbm_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether self-loops are allowed in the graph.</p>
</td></tr>
<tr><td><code id="sample_sbm_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_sbm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples graphs from a stochastic block model by (doing the
equivalent of) Bernoulli trials for each potential edge with the
probabilities given by the Bernoulli rate matrix, <code>pref.matrix</code>.
The order of the vertices in the generated graph corresponds to the
<code>block.sizes</code> argument.
</p>


<h3>Value</h3>

<p>An igraph graph.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Faust, K., &amp; Wasserman, S. (1992a). Blockmodels: Interpretation
and evaluation. <em>Social Networks</em>, 14, 5&ndash;61.
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Two groups with not only few connection between groups
pm &lt;- cbind(c(.1, .001), c(.001, .05))
g &lt;- sample_sbm(1000, pref.matrix = pm, block.sizes = c(300, 700))
g
</code></pre>

<hr>
<h2 id='sample_seq'>Sampling a random integer sequence</h2><span id='topic+sample_seq'></span>

<h3>Description</h3>

<p>This function provides a very efficient way to pull an integer random sample
sequence from an integer interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_seq(low, high, length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_seq_+3A_low">low</code></td>
<td>
<p>The lower limit of the interval (inclusive).</p>
</td></tr>
<tr><td><code id="sample_seq_+3A_high">high</code></td>
<td>
<p>The higher limit of the interval (inclusive).</p>
</td></tr>
<tr><td><code id="sample_seq_+3A_length">length</code></td>
<td>
<p>The length of the sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm runs in <code>O(length)</code> expected time, even if
<code>high-low</code> is big. It is much faster (but of course less general) than
the builtin <code>sample</code> function of R.
</p>


<h3>Value</h3>

<p>An increasing numeric vector containing integers, the sample.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Jeffrey Scott Vitter: An Efficient Algorithm for Sequential
Random Sampling, <em>ACM Transactions on Mathematical Software</em>, 13/1,
58&ndash;67.
</p>


<h3>See Also</h3>

<p>Other other: 
<code><a href="#topic+convex_hull">convex_hull</a>()</code>,
<code><a href="#topic+running_mean">running_mean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rs &lt;- sample_seq(1, 100000000, 10)
rs

</code></pre>

<hr>
<h2 id='sample_smallworld'>The Watts-Strogatz small-world model</h2><span id='topic+sample_smallworld'></span><span id='topic+smallworld'></span>

<h3>Description</h3>

<p>This function generates networks with the small-world property
based on a variant of the Watts-Strogatz model. The network is obtained
by first creating a periodic undirected lattice, then rewiring both
endpoints of each edge with probability <code>p</code>, while avoiding the
creation of multi-edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_smallworld(dim, size, nei, p, loops = FALSE, multiple = FALSE)

smallworld(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_smallworld_+3A_dim">dim</code></td>
<td>
<p>Integer constant, the dimension of the starting lattice.</p>
</td></tr>
<tr><td><code id="sample_smallworld_+3A_size">size</code></td>
<td>
<p>Integer constant, the size of the lattice along each dimension.</p>
</td></tr>
<tr><td><code id="sample_smallworld_+3A_nei">nei</code></td>
<td>
<p>Integer constant, the neighborhood within which the vertices of
the lattice will be connected.</p>
</td></tr>
<tr><td><code id="sample_smallworld_+3A_p">p</code></td>
<td>
<p>Real constant between zero and one, the rewiring probability.</p>
</td></tr>
<tr><td><code id="sample_smallworld_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether loops edges are allowed in the
generated graph.</p>
</td></tr>
<tr><td><code id="sample_smallworld_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether multiple edges are allowed int the
generated graph.</p>
</td></tr>
<tr><td><code id="sample_smallworld_+3A_...">...</code></td>
<td>
<p>Passed to <code>sample_smallworld()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function might create graphs with loops and/or multiple
edges. You can use <code><a href="#topic+simplify">simplify()</a></code> to get rid of these.
</p>
<p>This process differs from the original model of Watts and Strogatz
(see reference) in that it rewires <strong>both</strong> endpoints of edges. Thus in
the limit of <code>p=1</code>, we obtain a G(n,m) random graph with the
same number of vertices and edges as the original lattice. In comparison,
the original Watts-Strogatz model only rewires a single endpoint of each edge,
thus the network does not become fully random even for <code>p=1</code>.
For appropriate choices of <code>p</code>, both models exhibit the property of
simultaneously having short path lengths and high clustering.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Duncan J Watts and Steven H Strogatz: Collective dynamics of
&lsquo;small world&rsquo; networks, Nature 393, 440-442, 1998.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_lattice">make_lattice()</a></code>, <code><a href="#topic+rewire">rewire()</a></code>
</p>
<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_smallworld(1, 100, 5, 0.05)
mean_distance(g)
transitivity(g, type = "average")

</code></pre>

<hr>
<h2 id='sample_spanning_tree'>Samples from the spanning trees of a graph randomly and uniformly</h2><span id='topic+sample_spanning_tree'></span>

<h3>Description</h3>

<p><code>sample_spanning_tree()</code> picks a spanning tree of an undirected graph
randomly and uniformly, using loop-erased random walks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_spanning_tree(graph, vid = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_spanning_tree_+3A_graph">graph</code></td>
<td>
<p>The input graph to sample from. Edge directions are ignored if
the graph is directed.</p>
</td></tr>
<tr><td><code id="sample_spanning_tree_+3A_vid">vid</code></td>
<td>
<p>When the graph is disconnected, this argument specifies how to
handle the situation. When the argument is zero (the default), the sampling
will be performed component-wise, and the result will be a spanning forest.
When the argument contains a vertex ID, only the component containing the
given vertex will be processed, and the result will be a spanning tree of the
component of the graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge sequence containing the edges of the spanning tree. Use
<code><a href="#topic+subgraph.edges">subgraph.edges()</a></code> to extract the corresponding subgraph.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subgraph.edges">subgraph.edges()</a></code> to extract the tree itself
</p>
<p>Other trees: 
<code><a href="#topic+is_forest">is_forest</a>()</code>,
<code><a href="#topic+is_tree">is_tree</a>()</code>,
<code><a href="#topic+make_from_prufer">make_from_prufer</a>()</code>,
<code><a href="#topic+to_prufer">to_prufer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_full_graph(10) %du% make_full_graph(5)
edges &lt;- sample_spanning_tree(g)
forest &lt;- subgraph.edges(g, edges)

</code></pre>

<hr>
<h2 id='sample_sphere_surface'>Sample vectors uniformly from the surface of a sphere</h2><span id='topic+sample_sphere_surface'></span>

<h3>Description</h3>

<p>Sample finite-dimensional vectors to use as latent position vectors in
random dot product graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_sphere_surface(dim, n = 1, radius = 1, positive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_sphere_surface_+3A_dim">dim</code></td>
<td>
<p>Integer scalar, the dimension of the random vectors.</p>
</td></tr>
<tr><td><code id="sample_sphere_surface_+3A_n">n</code></td>
<td>
<p>Integer scalar, the sample size.</p>
</td></tr>
<tr><td><code id="sample_sphere_surface_+3A_radius">radius</code></td>
<td>
<p>Numeric scalar, the radius of the sphere to sample.</p>
</td></tr>
<tr><td><code id="sample_sphere_surface_+3A_positive">positive</code></td>
<td>
<p>Logical scalar, whether to sample from the positive orthant
of the sphere.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sample_sphere_surface()</code> generates uniform samples from <code class="reqn">S^{dim-1}</code>
(the <code>(dim-1)</code>-sphere) with radius <code>radius</code>, i.e. the Euclidean
norm of the samples equal <code>radius</code>.
</p>


<h3>Value</h3>

<p>A <code>dim</code> (length of the <code>alpha</code> vector for
<code>sample_dirichlet()</code>) times <code>n</code> matrix, whose columns are the sample
vectors.
</p>


<h3>See Also</h3>

<p>Other latent position vector samplers: 
<code><a href="#topic+sample_dirichlet">sample_dirichlet</a>()</code>,
<code><a href="#topic+sample_sphere_volume">sample_sphere_volume</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lpvs.sph &lt;- sample_sphere_surface(dim = 10, n = 20, radius = 1)
RDP.graph.3 &lt;- sample_dot_product(lpvs.sph)
vec.norm &lt;- apply(lpvs.sph, 2, function(x) {
  sum(x^2)
})
vec.norm
</code></pre>

<hr>
<h2 id='sample_sphere_volume'>Sample vectors uniformly from the volume of a sphere</h2><span id='topic+sample_sphere_volume'></span>

<h3>Description</h3>

<p>Sample finite-dimensional vectors to use as latent position vectors in
random dot product graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_sphere_volume(dim, n = 1, radius = 1, positive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_sphere_volume_+3A_dim">dim</code></td>
<td>
<p>Integer scalar, the dimension of the random vectors.</p>
</td></tr>
<tr><td><code id="sample_sphere_volume_+3A_n">n</code></td>
<td>
<p>Integer scalar, the sample size.</p>
</td></tr>
<tr><td><code id="sample_sphere_volume_+3A_radius">radius</code></td>
<td>
<p>Numeric scalar, the radius of the sphere to sample.</p>
</td></tr>
<tr><td><code id="sample_sphere_volume_+3A_positive">positive</code></td>
<td>
<p>Logical scalar, whether to sample from the positive orthant
of the sphere.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sample_sphere_volume()</code> generates uniform samples from <code class="reqn">S^{dim-1}</code>
(the <code>(dim-1)</code>-sphere) i.e. the Euclidean norm of the samples is
smaller or equal to <code>radius</code>.
</p>


<h3>Value</h3>

<p>A <code>dim</code> (length of the <code>alpha</code> vector for
<code>sample_dirichlet()</code>) times <code>n</code> matrix, whose columns are the sample
vectors.
</p>


<h3>See Also</h3>

<p>Other latent position vector samplers: 
<code><a href="#topic+sample_dirichlet">sample_dirichlet</a>()</code>,
<code><a href="#topic+sample_sphere_surface">sample_sphere_surface</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lpvs.sph.vol &lt;- sample_sphere_volume(dim = 10, n = 20, radius = 1)
RDP.graph.4 &lt;- sample_dot_product(lpvs.sph.vol)
vec.norm &lt;- apply(lpvs.sph.vol, 2, function(x) {
  sum(x^2)
})
vec.norm
</code></pre>

<hr>
<h2 id='sample_traits_callaway'>Graph generation based on different vertex types</h2><span id='topic+sample_traits_callaway'></span><span id='topic+traits_callaway'></span><span id='topic+sample_traits'></span><span id='topic+traits'></span>

<h3>Description</h3>

<p>These functions implement evolving network models based on different vertex
types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_traits_callaway(
  nodes,
  types,
  edge.per.step = 1,
  type.dist = rep(1, types),
  pref.matrix = matrix(1, types, types),
  directed = FALSE
)

traits_callaway(...)

sample_traits(
  nodes,
  types,
  k = 1,
  type.dist = rep(1, types),
  pref.matrix = matrix(1, types, types),
  directed = FALSE
)

traits(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_traits_callaway_+3A_nodes">nodes</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_traits_callaway_+3A_types">types</code></td>
<td>
<p>The number of different vertex types.</p>
</td></tr>
<tr><td><code id="sample_traits_callaway_+3A_edge.per.step">edge.per.step</code></td>
<td>
<p>The number of edges to add to the graph per time step.</p>
</td></tr>
<tr><td><code id="sample_traits_callaway_+3A_type.dist">type.dist</code></td>
<td>
<p>The distribution of the vertex types. This is assumed to be
stationary in time.</p>
</td></tr>
<tr><td><code id="sample_traits_callaway_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>A matrix giving the preferences of the given vertex
types. These should be probabilities, i.e. numbers between zero and one.</p>
</td></tr>
<tr><td><code id="sample_traits_callaway_+3A_directed">directed</code></td>
<td>
<p>Logical constant, whether to generate directed graphs.</p>
</td></tr>
<tr><td><code id="sample_traits_callaway_+3A_...">...</code></td>
<td>
<p>Passed to the constructor, <code>sample_traits()</code> or
<code>sample_traits_callaway()</code>.</p>
</td></tr>
<tr><td><code id="sample_traits_callaway_+3A_k">k</code></td>
<td>
<p>The number of trials per time step, see details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>sample_traits_callaway()</code> the simulation goes like this: in each
discrete time step a new vertex is added to the graph. The type of this
vertex is generated based on <code>type.dist</code>. Then two vertices are
selected uniformly randomly from the graph. The probability that they will
be connected depends on the types of these vertices and is taken from
<code>pref.matrix</code>. Then another two vertices are selected and this is
repeated <code>edges.per.step</code> times in each time step.
</p>
<p>For <code>sample_traits()</code> the simulation goes like this: a single vertex is
added at each time step. This new vertex tries to connect to <code>k</code>
vertices in the graph. The probability that such a connection is realized
depends on the types of the vertices involved and is taken from
<code>pref.matrix</code>.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_tree">sample_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# two types of vertices, they like only themselves
g1 &lt;- sample_traits_callaway(1000, 2, pref.matrix = matrix(c(1, 0, 0, 1), ncol = 2))
g2 &lt;- sample_traits(1000, 2, k = 2, pref.matrix = matrix(c(1, 0, 0, 1), ncol = 2))
</code></pre>

<hr>
<h2 id='sample_tree'>Sample trees randomly and uniformly</h2><span id='topic+sample_tree'></span>

<h3>Description</h3>

<p><code>sample_tree()</code> generates a random with a given number of nodes uniform
at random from the set of labelled trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_tree(n, directed = FALSE, method = c("lerw", "prufer"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_tree_+3A_n">n</code></td>
<td>
<p>The number of nodes in the tree</p>
</td></tr>
<tr><td><code id="sample_tree_+3A_directed">directed</code></td>
<td>
<p>Whether to create a directed tree. The edges of the tree are
oriented away from the root.</p>
</td></tr>
<tr><td><code id="sample_tree_+3A_method">method</code></td>
<td>
<p>The algorithm to use to generate the tree. &lsquo;prufer&rsquo;
samples Prüfer sequences uniformly and then converts the sampled sequence to
a tree. &lsquo;lerw&rsquo; performs a loop-erased random walk on the complete
graph to uniformly sampleits spanning trees. (This is also known as Wilson's
algorithm). The default is &lsquo;lerw&rsquo;. Note that the method based on
Prüfer sequences does not support directed trees at the moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In other words, the function generates each possible labelled tree with the
given number of nodes with the same probability.
</p>


<h3>Value</h3>

<p>A graph object.
</p>


<h3>See Also</h3>

<p>Random graph models (games)
<code><a href="#topic+erdos.renyi.game">erdos.renyi.game</a>()</code>,
<code><a href="#topic+sample_">sample_</a>()</code>,
<code><a href="#topic+sample_bipartite">sample_bipartite</a>()</code>,
<code><a href="#topic+sample_correlated_gnp">sample_correlated_gnp</a>()</code>,
<code><a href="#topic+sample_correlated_gnp_pair">sample_correlated_gnp_pair</a>()</code>,
<code><a href="#topic+sample_degseq">sample_degseq</a>()</code>,
<code><a href="#topic+sample_dot_product">sample_dot_product</a>()</code>,
<code><a href="#topic+sample_fitness">sample_fitness</a>()</code>,
<code><a href="#topic+sample_fitness_pl">sample_fitness_pl</a>()</code>,
<code><a href="#topic+sample_forestfire">sample_forestfire</a>()</code>,
<code><a href="#topic+sample_gnm">sample_gnm</a>()</code>,
<code><a href="#topic+sample_gnp">sample_gnp</a>()</code>,
<code><a href="#topic+sample_grg">sample_grg</a>()</code>,
<code><a href="#topic+sample_growing">sample_growing</a>()</code>,
<code><a href="#topic+sample_hierarchical_sbm">sample_hierarchical_sbm</a>()</code>,
<code><a href="#topic+sample_islands">sample_islands</a>()</code>,
<code><a href="#topic+sample_k_regular">sample_k_regular</a>()</code>,
<code><a href="#topic+sample_last_cit">sample_last_cit</a>()</code>,
<code><a href="#topic+sample_pa">sample_pa</a>()</code>,
<code><a href="#topic+sample_pa_age">sample_pa_age</a>()</code>,
<code><a href="#topic+sample_pref">sample_pref</a>()</code>,
<code><a href="#topic+sample_sbm">sample_sbm</a>()</code>,
<code><a href="#topic+sample_smallworld">sample_smallworld</a>()</code>,
<code><a href="#topic+sample_traits_callaway">sample_traits_callaway</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_tree(100, method = "lerw")

</code></pre>

<hr>
<h2 id='sbm.game'>Sample stochastic block model</h2><span id='topic+sbm.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>sbm.game()</code> was renamed to <code>sample_sbm()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbm.game(n, pref.matrix, block.sizes, directed = FALSE, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbm.game_+3A_n">n</code></td>
<td>
<p>Number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sbm.game_+3A_pref.matrix">pref.matrix</code></td>
<td>
<p>The matrix giving the Bernoulli rates.  This is a
<code class="reqn">K\times K</code> matrix, where <code class="reqn">K</code> is the number of groups. The
probability of creating an edge between vertices from groups <code class="reqn">i</code> and
<code class="reqn">j</code> is given by element <code class="reqn">(i,j)</code>. For undirected graphs, this matrix
must be symmetric.</p>
</td></tr>
<tr><td><code id="sbm.game_+3A_block.sizes">block.sizes</code></td>
<td>
<p>Numeric vector giving the number of vertices in each
group. The sum of the vector must match the number of vertices.</p>
</td></tr>
<tr><td><code id="sbm.game_+3A_directed">directed</code></td>
<td>
<p>Logical scalar, whether to generate a directed graph.</p>
</td></tr>
<tr><td><code id="sbm.game_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether self-loops are allowed in the graph.</p>
</td></tr>
</table>

<hr>
<h2 id='scan_stat'>Scan statistics on a time series of graphs</h2><span id='topic+scan_stat'></span>

<h3>Description</h3>

<p>Calculate scan statistics on a time series of graphs.
This is done by calculating the local scan statistics for
each graph and each vertex, and then normalizing across the
vertices and across the time steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scan_stat(graphs, tau = 1, ell = 0, locality = c("us", "them"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scan_stat_+3A_graphs">graphs</code></td>
<td>
<p>A list of igraph graph objects. They must be all directed
or all undirected and they must have the same number of vertices.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_tau">tau</code></td>
<td>
<p>The number of previous time steps to consider for the
time-dependent normalization for individual vertices.  In other words,
the current locality statistics of each vertex will be compared to this
many previous time steps of the same vertex to decide whether it is
significantly larger.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_ell">ell</code></td>
<td>
<p>The number of previous time steps to consider
for the aggregated scan statistics. This is essentially a smoothing
parameter.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_locality">locality</code></td>
<td>
<p>Whether to calculate the &lsquo;us&rsquo; or &lsquo;them&rsquo;
statistics.</p>
</td></tr>
<tr><td><code id="scan_stat_+3A_...">...</code></td>
<td>
<p>Extra arguments are passed to <code><a href="#topic+local_scan">local_scan()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries:
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>The scan statistics in each time step. It is <code>NA</code>
for the initial <code>tau + ell</code> time steps.</p>
</td></tr>
<tr><td><code>arg_max_v</code></td>
<td>
<p>The (numeric) vertex ids for the vertex with
the largest locality statistics, at each time step. It is <code>NA</code>
for the initial <code>tau + ell</code> time steps.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other scan statistics: 
<code><a href="#topic+local_scan">local_scan</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a bunch of SBMs, with the last one being different
num_t &lt;- 20
block_sizes &lt;- c(10, 5, 5)
p_ij &lt;- list(p = 0.1, h = 0.9, q = 0.9)

P0 &lt;- matrix(p_ij$p, 3, 3)
P0[2, 2] &lt;- p_ij$h
PA &lt;- P0
PA[3, 3] &lt;- p_ij$q
num_v &lt;- sum(block_sizes)

tsg &lt;- replicate(num_t - 1, P0, simplify = FALSE) %&gt;%
  append(list(PA)) %&gt;%
  lapply(sample_sbm, n = num_v, block.sizes = block_sizes, directed = TRUE)

scan_stat(graphs = tsg, k = 1, tau = 4, ell = 2)
scan_stat(graphs = tsg, locality = "them", k = 1, tau = 4, ell = 2)
</code></pre>

<hr>
<h2 id='sequential_pal'>Sequential palette</h2><span id='topic+sequential_pal'></span>

<h3>Description</h3>

<p>This is the &lsquo;OrRd&rsquo; palette from <a href="https://colorbrewer2.org/">https://colorbrewer2.org/</a>.
It has at most nine colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequential_pal(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequential_pal_+3A_n">n</code></td>
<td>
<p>The number of colors in the palette. The maximum is nine
currently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this palette, if vertex colors mark some ordinal quantity, e.g. some
centrality measure, or some ordinal vertex covariate, like the age of
people, or their seniority level.
</p>


<h3>Value</h3>

<p>A character vector of RGB color codes.
</p>


<h3>See Also</h3>

<p>Other palettes: 
<code><a href="#topic+categorical_pal">categorical_pal</a>()</code>,
<code><a href="#topic+diverging_pal">diverging_pal</a>()</code>,
<code><a href="#topic+r_pal">r_pal</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraphdata)
data(karate)
karate &lt;- karate %&gt;%
  add_layout_(with_kk()) %&gt;%
  set_vertex_attr("size", value = 10)

V(karate)$color &lt;- scales::dscale(degree(karate) %&gt;% cut(5), sequential_pal)
plot(karate)
</code></pre>

<hr>
<h2 id='set_edge_attr'>Set edge attributes</h2><span id='topic+set_edge_attr'></span>

<h3>Description</h3>

<p>Set edge attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_edge_attr(graph, name, index = E(graph), value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_edge_attr_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
<tr><td><code id="set_edge_attr_+3A_name">name</code></td>
<td>
<p>The name of the attribute to set.</p>
</td></tr>
<tr><td><code id="set_edge_attr_+3A_index">index</code></td>
<td>
<p>An optional edge sequence to set the attributes of
a subset of edges.</p>
</td></tr>
<tr><td><code id="set_edge_attr_+3A_value">value</code></td>
<td>
<p>The new value of the attribute for all (or <code>index</code>)
edges.
If <code>NULL</code>, the input is returned unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the edge attribute added or set.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_edge_attr("label", value = LETTERS[1:10])
g
plot(g)
</code></pre>

<hr>
<h2 id='set_graph_attr'>Set a graph attribute</h2><span id='topic+set_graph_attr'></span>

<h3>Description</h3>

<p>An existing attribute with the same name is overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_graph_attr(graph, name, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_graph_attr_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="set_graph_attr_+3A_name">name</code></td>
<td>
<p>The name of the attribute to set.</p>
</td></tr>
<tr><td><code id="set_graph_attr_+3A_value">value</code></td>
<td>
<p>New value of the attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph with the new graph attribute added or set.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_graph_attr("layout", layout_with_fr)
g
plot(g)
</code></pre>

<hr>
<h2 id='set_vertex_attr'>Set vertex attributes</h2><span id='topic+set_vertex_attr'></span>

<h3>Description</h3>

<p>Set vertex attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_vertex_attr(graph, name, index = V(graph), value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_vertex_attr_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="set_vertex_attr_+3A_name">name</code></td>
<td>
<p>The name of the attribute to set.</p>
</td></tr>
<tr><td><code id="set_vertex_attr_+3A_index">index</code></td>
<td>
<p>An optional vertex sequence to set the attributes
of a subset of vertices.</p>
</td></tr>
<tr><td><code id="set_vertex_attr_+3A_value">value</code></td>
<td>
<p>The new value of the attribute for all (or <code>index</code>)
vertices.
If <code>NULL</code>, the input is returned unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the vertex attribute added or set.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_vertex_attr("label", value = LETTERS[1:10])
g
plot(g)
</code></pre>

<hr>
<h2 id='set.edge.attribute'>Set edge attributes</h2><span id='topic+set.edge.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>set.edge.attribute()</code> was renamed to <code>set_edge_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.edge.attribute(graph, name, index = E(graph), value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.edge.attribute_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
<tr><td><code id="set.edge.attribute_+3A_name">name</code></td>
<td>
<p>The name of the attribute to set.</p>
</td></tr>
<tr><td><code id="set.edge.attribute_+3A_index">index</code></td>
<td>
<p>An optional edge sequence to set the attributes of
a subset of edges.</p>
</td></tr>
<tr><td><code id="set.edge.attribute_+3A_value">value</code></td>
<td>
<p>The new value of the attribute for all (or <code>index</code>)
edges.
If <code>NULL</code>, the input is returned unchanged.</p>
</td></tr>
</table>

<hr>
<h2 id='set.graph.attribute'>Set a graph attribute</h2><span id='topic+set.graph.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>set.graph.attribute()</code> was renamed to <code>set_graph_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.graph.attribute(graph, name, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.graph.attribute_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="set.graph.attribute_+3A_name">name</code></td>
<td>
<p>The name of the attribute to set.</p>
</td></tr>
<tr><td><code id="set.graph.attribute_+3A_value">value</code></td>
<td>
<p>New value of the attribute.</p>
</td></tr>
</table>

<hr>
<h2 id='set.vertex.attribute'>Set vertex attributes</h2><span id='topic+set.vertex.attribute'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>set.vertex.attribute()</code> was renamed to <code>set_vertex_attr()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.vertex.attribute(graph, name, index = V(graph), value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.vertex.attribute_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="set.vertex.attribute_+3A_name">name</code></td>
<td>
<p>The name of the attribute to set.</p>
</td></tr>
<tr><td><code id="set.vertex.attribute_+3A_index">index</code></td>
<td>
<p>An optional vertex sequence to set the attributes
of a subset of vertices.</p>
</td></tr>
<tr><td><code id="set.vertex.attribute_+3A_value">value</code></td>
<td>
<p>The new value of the attribute for all (or <code>index</code>)
vertices.
If <code>NULL</code>, the input is returned unchanged.</p>
</td></tr>
</table>

<hr>
<h2 id='shapes'>Various vertex shapes when plotting igraph graphs</h2><span id='topic+shapes'></span><span id='topic+igraph.vertex.shapes'></span><span id='topic+shape_noclip'></span><span id='topic+shape_noplot'></span><span id='topic+add_shape'></span>

<h3>Description</h3>

<p>Starting from version 0.5.1 igraph supports different
vertex shapes when plotting graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes(shape = NULL)

shape_noclip(coords, el, params, end = c("both", "from", "to"))

shape_noplot(coords, v = NULL, params)

add_shape(shape, clip = shape_noclip, plot = shape_noplot, parameters = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapes_+3A_shape">shape</code></td>
<td>
<p>Character scalar, name of a vertex shape. If it is
<code>NULL</code> for <code>shapes()</code>, then the names of all defined
vertex shapes are returned.</p>
</td></tr>
<tr><td><code id="shapes_+3A_coords">coords</code>, <code id="shapes_+3A_el">el</code>, <code id="shapes_+3A_params">params</code>, <code id="shapes_+3A_end">end</code>, <code id="shapes_+3A_v">v</code></td>
<td>
<p>See parameters of the clipping/plotting
functions below.</p>
</td></tr>
<tr><td><code id="shapes_+3A_clip">clip</code></td>
<td>
<p>An R function object, the clipping function.</p>
</td></tr>
<tr><td><code id="shapes_+3A_plot">plot</code></td>
<td>
<p>An R function object, the plotting function.</p>
</td></tr>
<tr><td><code id="shapes_+3A_parameters">parameters</code></td>
<td>
<p>Named list, additional plot/vertex/edge
parameters. The element named define the new parameters, and the
elements themselves define their default values.
Vertex parameters should have a prefix
&lsquo;<code>vertex.</code>&rsquo;, edge parameters a prefix
&lsquo;<code>edge.</code>&rsquo;. Other general plotting parameters should have
a prefix &lsquo;<code>plot.</code>&rsquo;. See Details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In igraph a vertex shape is defined by two functions: 1) provides
information about the size of the shape for clipping the edges and 2)
plots the shape if requested. These functions are called &ldquo;shape
functions&rdquo; in the rest of this manual page. The first one is the
clipping function and the second is the plotting function.
</p>
<p>The clipping function has the following arguments:
</p>

<dl>
<dt>coords</dt><dd><p>A matrix with four columns, it contains the
coordinates of the vertices for the edge list supplied in the
<code>el</code> argument.</p>
</dd>
<dt>el</dt><dd><p>A matrix with two columns, the edges of which some end
points will be clipped. It should have the same number of rows as
<code>coords</code>.</p>
</dd>
<dt>params</dt><dd><p>This is a function object that can be called to query
vertex/edge/plot graphical parameters. The first argument of the
function is &ldquo;<code>vertex</code>&rdquo;, &ldquo;<code>edge</code>&rdquo; or
&ldquo;<code>plot</code>&rdquo; to decide the type of the parameter, the
second is a character string giving the name of the
parameter. E.g.
</p>
<pre>
	params("vertex", "size")
    </pre>
</dd>
<dt>end</dt><dd><p>Character string, it gives which end points will be
used. Possible values are &ldquo;<code>both</code>&rdquo;,
&ldquo;<code>from</code>&rdquo; and &ldquo;<code>to</code>&rdquo;. If
&ldquo;<code>from</code>&rdquo; the function is expected to clip the
first column in the <code>el</code> edge list, &ldquo;<code>to</code>&rdquo;
selects the second column, &ldquo;<code>both</code>&rdquo; selects both.</p>
</dd>
</dl>

<p>The clipping function should return a matrix
with the same number of rows as the <code>el</code> arguments.
If <code>end</code> is <code>both</code> then the matrix must have four
columns, otherwise two. The matrix contains the modified coordinates,
with the clipping applied.
</p>
<p>The plotting function has the following arguments:
</p>

<dl>
<dt>coords</dt><dd><p>The coordinates of the vertices, a matrix with two
columns.</p>
</dd>
<dt>v</dt><dd><p>The ids of the vertices to plot. It should match the number
of rows in the <code>coords</code> argument.</p>
</dd>
<dt>params</dt><dd><p>The same as for the clipping function, see above.</p>
</dd>
</dl>

<p>The return value of the plotting function is not used.
</p>
<p><code>shapes()</code> can be used to list the names of all installed
vertex shapes, by calling it without arguments, or setting the
<code>shape</code> argument to <code>NULL</code>. If a shape name is given, then
the clipping and plotting functions of that shape are returned in a
named list.
</p>
<p><code>add_shape()</code> can be used to add new vertex shapes to
igraph. For this one must give the clipping and plotting functions of
the new shape. It is also possible to list the plot/vertex/edge
parameters, in the <code>parameters</code> argument, that the clipping
and/or plotting functions can make use of. An example would be a
generic regular polygon shape, which can have a parameter for the
number of sides.
</p>
<p><code>shape_noclip()</code> is a very simple clipping function that the
user can use in their own shape definitions. It does no clipping, the
edges will be drawn exactly until the listed vertex position
coordinates.
</p>
<p><code>shape_noplot()</code> is a very simple (and probably not very
useful) plotting function, that does not plot anything.
</p>


<h3>Value</h3>

<p><code>shapes()</code> returns a character vector if the
<code>shape</code> argument is <code>NULL</code>. It returns a named list with
entries named &lsquo;clip&rsquo; and &lsquo;plot&rsquo;, both of them R
functions.
</p>
<p><code>add_shape()</code> returns <code>TRUE</code>, invisibly.
</p>
<p><code>shape_noclip()</code> returns the appropriate columns of its
<code>coords</code> argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all vertex shapes, minus "raster", that might not be available
shapes &lt;- setdiff(shapes(), "")
g &lt;- make_ring(length(shapes))
set.seed(42)
plot(g,
  vertex.shape = shapes, vertex.label = shapes, vertex.label.dist = 1,
  vertex.size = 15, vertex.size2 = 15,
  vertex.pie = lapply(shapes, function(x) if (x == "pie") 2:6 else 0),
  vertex.pie.color = list(heat.colors(5))
)

# add new vertex shape, plot nothing with no clipping
add_shape("nil")
plot(g, vertex.shape = "nil")

#################################################################
# triangle vertex shape
mytriangle &lt;- function(coords, v = NULL, params) {
  vertex.color &lt;- params("vertex", "color")
  if (length(vertex.color) != 1 &amp;&amp; !is.null(v)) {
    vertex.color &lt;- vertex.color[v]
  }
  vertex.size &lt;- 1 / 200 * params("vertex", "size")
  if (length(vertex.size) != 1 &amp;&amp; !is.null(v)) {
    vertex.size &lt;- vertex.size[v]
  }

  symbols(
    x = coords[, 1], y = coords[, 2], bg = vertex.color,
    stars = cbind(vertex.size, vertex.size, vertex.size),
    add = TRUE, inches = FALSE
  )
}
# clips as a circle
add_shape("triangle",
  clip = shapes("circle")$clip,
  plot = mytriangle
)
plot(g,
  vertex.shape = "triangle", vertex.color = rainbow(vcount(g)),
  vertex.size = seq(10, 20, length.out = vcount(g))
)

#################################################################
# generic star vertex shape, with a parameter for number of rays
mystar &lt;- function(coords, v = NULL, params) {
  vertex.color &lt;- params("vertex", "color")
  if (length(vertex.color) != 1 &amp;&amp; !is.null(v)) {
    vertex.color &lt;- vertex.color[v]
  }
  vertex.size &lt;- 1 / 200 * params("vertex", "size")
  if (length(vertex.size) != 1 &amp;&amp; !is.null(v)) {
    vertex.size &lt;- vertex.size[v]
  }
  norays &lt;- params("vertex", "norays")
  if (length(norays) != 1 &amp;&amp; !is.null(v)) {
    norays &lt;- norays[v]
  }

  mapply(coords[, 1], coords[, 2], vertex.color, vertex.size, norays,
    FUN = function(x, y, bg, size, nor) {
      symbols(
        x = x, y = y, bg = bg,
        stars = matrix(c(size, size / 2), nrow = 1, ncol = nor * 2),
        add = TRUE, inches = FALSE
      )
    }
  )
}
# no clipping, edges will be below the vertices anyway
add_shape("star",
  clip = shape_noclip,
  plot = mystar, parameters = list(vertex.norays = 5)
)
plot(g,
  vertex.shape = "star", vertex.color = rainbow(vcount(g)),
  vertex.size = seq(10, 20, length.out = vcount(g))
)
plot(g,
  vertex.shape = "star", vertex.color = rainbow(vcount(g)),
  vertex.size = seq(10, 20, length.out = vcount(g)),
  vertex.norays = rep(4:8, length.out = vcount(g))
)
</code></pre>

<hr>
<h2 id='shortest.paths'>Shortest (directed or undirected) paths between vertices</h2><span id='topic+shortest.paths'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>shortest.paths()</code> was renamed to <code>distances()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortest.paths(
  graph,
  v = V(graph),
  to = V(graph),
  mode = c("all", "out", "in"),
  weights = NULL,
  algorithm = c("automatic", "unweighted", "dijkstra", "bellman-ford", "johnson")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortest.paths_+3A_graph">graph</code></td>
<td>
<p>The graph to work on.</p>
</td></tr>
<tr><td><code id="shortest.paths_+3A_v">v</code></td>
<td>
<p>Numeric vector, the vertices from which the shortest paths will be
calculated.</p>
</td></tr>
<tr><td><code id="shortest.paths_+3A_to">to</code></td>
<td>
<p>Numeric vector, the vertices to which the shortest paths will be
calculated. By default it includes all vertices. Note that for
<code>distances()</code> every vertex must be included here at most once. (This
is not required for <code>shortest_paths()</code>.</p>
</td></tr>
<tr><td><code id="shortest.paths_+3A_mode">mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">&#8288;in&#8288;</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the corresponding
undirected graph will be used, i.e. not directed paths are searched. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="shortest.paths_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then the
attribute is used. If this is <code>NA</code> then no weights are used (even if
the graph has a <code>weight</code> attribute).</p>
</td></tr>
<tr><td><code id="shortest.paths_+3A_algorithm">algorithm</code></td>
<td>
<p>Which algorithm to use for the calculation. By default
igraph tries to select the fastest suitable algorithm. If there are no
weights, then an unweighted breadth-first search is used, otherwise if all
weights are positive, then Dijkstra's algorithm is used. If there are
negative weights and we do the calculation for more than 100 sources, then
Johnson's algorithm is used. Otherwise the Bellman-Ford algorithm is used.
You can override igraph's choice by explicitly giving this parameter. Note
that the igraph C core might still override your choice in obvious cases,
i.e. if there are no edge weights, then the unweighted algorithm will be
used, regardless of this argument.</p>
</td></tr>
</table>

<hr>
<h2 id='showtrace'>Functions to deal with the result of network community detection</h2><span id='topic+showtrace'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>showtrace()</code> was renamed to <code>show_trace()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showtrace(communities)
</code></pre>

<hr>
<h2 id='similarity'>Similarity measures of two vertices</h2><span id='topic+similarity'></span><span id='topic+similarity.jaccard'></span><span id='topic+similarity.dice'></span><span id='topic+similarity.invlogweighted'></span>

<h3>Description</h3>

<p>These functions calculates similarity scores for vertices based on their
connection patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>similarity(
  graph,
  vids = V(graph),
  mode = c("all", "out", "in", "total"),
  loops = FALSE,
  method = c("jaccard", "dice", "invlogweighted")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="similarity_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="similarity_+3A_vids">vids</code></td>
<td>
<p>The vertex ids for which the similarity is calculated.</p>
</td></tr>
<tr><td><code id="similarity_+3A_mode">mode</code></td>
<td>
<p>The type of neighboring vertices to use for the calculation,
possible values: &lsquo;<code>out</code>&rsquo;, &lsquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rsquo;,
&lsquo;<code>all</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="similarity_+3A_loops">loops</code></td>
<td>
<p>Whether to include vertices themselves in the neighbor
sets.</p>
</td></tr>
<tr><td><code id="similarity_+3A_method">method</code></td>
<td>
<p>The method to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jaccard similarity coefficient of two vertices is the number of common
neighbors divided by the number of vertices that are neighbors of at least
one of the two vertices being considered. The <code>jaccard</code> method
calculates the pairwise Jaccard similarities for some (or all) of the
vertices.
</p>
<p>The Dice similarity coefficient of two vertices is twice the number of
common neighbors divided by the sum of the degrees of the vertices.
Methof <code>dice</code> calculates the pairwise Dice similarities for some
(or all) of the vertices.
</p>
<p>The inverse log-weighted similarity of two vertices is the number of their
common neighbors, weighted by the inverse logarithm of their degrees.  It is
based on the assumption that two vertices should be considered more similar
if they share a low-degree common neighbor, since high-degree common
neighbors are more likely to appear even by pure chance.  Isolated vertices
will have zero similarity to any other vertex.  Self-similarities are not
calculated.  See the following paper for more details: Lada A. Adamic and
Eytan Adar: Friends and neighbors on the Web. Social Networks,
25(3):211-230, 2003.
</p>


<h3>Value</h3>

<p>A <code>length(vids)</code> by <code>length(vids)</code> numeric matrix
containing the similarity scores. This argument is ignored by the
<code>invlogweighted</code> method.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the manual page.
</p>


<h3>References</h3>

<p>Lada A. Adamic and Eytan Adar: Friends and neighbors on the Web.
<em>Social Networks</em>, 25(3):211-230, 2003.
</p>


<h3>See Also</h3>

<p>Other cocitation: 
<code><a href="#topic+cocitation">cocitation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(5)
similarity(g, method = "dice")
similarity(g, method = "jaccard")
</code></pre>

<hr>
<h2 id='simplified'>Constructor modifier to drop multiple and loop edges</h2><span id='topic+simplified'></span>

<h3>Description</h3>

<p>Constructor modifier to drop multiple and loop edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplified()
</code></pre>


<h3>See Also</h3>

<p>Other constructor modifiers: 
<code><a href="#topic+with_edge_">with_edge_</a>()</code>,
<code><a href="#topic+with_graph_">with_graph_</a>()</code>,
<code><a href="#topic+with_vertex_">with_vertex_</a>()</code>,
<code><a href="#topic+without_attr">without_attr</a>()</code>,
<code><a href="#topic+without_loops">without_loops</a>()</code>,
<code><a href="#topic+without_multiples">without_multiples</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_(pa(10, m = 3, algorithm = "bag"))
sample_(pa(10, m = 3, algorithm = "bag"), simplified())
</code></pre>

<hr>
<h2 id='simplify'>Simple graphs</h2><span id='topic+simplify'></span><span id='topic+is_simple'></span><span id='topic+simplify_and_colorize'></span>

<h3>Description</h3>

<p>Simple graphs are graphs which do not contain loop and multiple edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify(
  graph,
  remove.multiple = TRUE,
  remove.loops = TRUE,
  edge.attr.comb = igraph_opt("edge.attr.comb")
)

is_simple(graph)

simplify_and_colorize(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_+3A_graph">graph</code></td>
<td>
<p>The graph to work on.</p>
</td></tr>
<tr><td><code id="simplify_+3A_remove.multiple">remove.multiple</code></td>
<td>
<p>Logical, whether the multiple edges are to be
removed.</p>
</td></tr>
<tr><td><code id="simplify_+3A_remove.loops">remove.loops</code></td>
<td>
<p>Logical, whether the loop edges are to be removed.</p>
</td></tr>
<tr><td><code id="simplify_+3A_edge.attr.comb">edge.attr.comb</code></td>
<td>
<p>Specifies what to do with edge attributes, if
<code>remove.multiple=TRUE</code>. In this case many edges might be mapped to a
single one in the new graph, and their attributes are combined. Please see
<code><a href="#topic+attribute.combination">attribute.combination()</a></code> for details on this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A loop edge is an edge for which the two endpoints are the same
vertex. Two edges are multiple edges if they have exactly the same two
endpoints (for directed graphs order does matter). A graph is simple is
it does not contain loop edges and multiple edges.
</p>
<p><code>is_simple()</code> checks whether a graph is simple.
</p>
<p><code>simplify()</code> removes the loop and/or multiple edges from a graph.  If
both <code>remove.loops</code> and <code>remove.multiple</code> are <code>TRUE</code> the
function returns a simple graph.
</p>
<p><code>simplify_and_colorize()</code> constructs a new, simple graph from a graph and
also sets a <code>color</code> attribute on both the vertices and the edges.
The colors of the vertices represent the number of self-loops that were
originally incident on them, while the colors of the edges represent the
multiplicities of the same edges in the original graph. This allows one to
take into account the edge multiplicities and the number of loop edges in
the VF2 isomorphism algorithm. Other graph, vertex and edge attributes from
the original graph are discarded as the primary purpose of this function is
to facilitate the usage of multigraphs with the VF2 algorithm.
</p>


<h3>Value</h3>

<p>a new graph object with the edges deleted.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+which_loop">which_loop()</a></code>, <code><a href="#topic+which_multiple">which_multiple()</a></code> and
<code><a href="#topic+count_multiple">count_multiple()</a></code>, <code><a href="#topic+delete_edges">delete_edges()</a></code>,
<code><a href="#topic+delete_vertices">delete_vertices()</a></code>
</p>
<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph(c(1, 2, 1, 2, 3, 3))
is_simple(g)
is_simple(simplify(g, remove.loops = FALSE))
is_simple(simplify(g, remove.multiple = FALSE))
is_simple(simplify(g))
</code></pre>

<hr>
<h2 id='spectrum'>Eigenvalues and eigenvectors of the adjacency matrix of a graph</h2><span id='topic+spectrum'></span><span id='topic+igraph.eigen.default'></span>

<h3>Description</h3>

<p>Calculate selected eigenvalues and eigenvectors of a (supposedly sparse)
graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectrum(
  graph,
  algorithm = c("arpack", "auto", "lapack", "comp_auto", "comp_lapack", "comp_arpack"),
  which = list(),
  options = arpack_defaults()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spectrum_+3A_graph">graph</code></td>
<td>
<p>The input graph, can be directed or undirected.</p>
</td></tr>
<tr><td><code id="spectrum_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use. Currently only <code>arpack</code> is
implemented, which uses the ARPACK solver. See also <code><a href="#topic+arpack">arpack()</a></code>.</p>
</td></tr>
<tr><td><code id="spectrum_+3A_which">which</code></td>
<td>
<p>A list to specify which eigenvalues and eigenvectors to
calculate. By default the leading (i.e. largest magnitude) eigenvalue and
the corresponding eigenvector is calculated.</p>
</td></tr>
<tr><td><code id="spectrum_+3A_options">options</code></td>
<td>
<p>Options for the ARPACK solver. See
<code><a href="#topic+arpack_defaults">arpack_defaults()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>which</code> argument is a list and it specifies which eigenvalues and
corresponding eigenvectors to calculate: There are eight options:
</p>
 <ol>
<li><p> Eigenvalues with the largest magnitude. Set <code>pos</code> to
<code>LM</code>, and <code>howmany</code> to the number of eigenvalues you want.  </p>
</li>
<li>
<p>Eigenvalues with the smallest magnitude. Set <code>pos</code> to <code>SM</code> and
<code>howmany</code> to the number of eigenvalues you want.  </p>
</li>
<li><p> Largest
eigenvalues. Set <code>pos</code> to <code>LA</code> and <code>howmany</code> to the number of
eigenvalues you want.  </p>
</li>
<li><p> Smallest eigenvalues. Set <code>pos</code> to
<code>SA</code> and <code>howmany</code> to the number of eigenvalues you want.  </p>
</li>
<li>
<p>Eigenvalues from both ends of the spectrum. Set <code>pos</code> to <code>BE</code> and
<code>howmany</code> to the number of eigenvalues you want. If <code>howmany</code> is
odd, then one more eigenvalue is returned from the larger end.  </p>
</li>
<li>
<p>Selected eigenvalues. This is not (yet) implemented currently.  </p>
</li>
<li>
<p>Eigenvalues in an interval. This is not (yet) implemented.  </p>
</li>
<li><p> All
eigenvalues. This is not implemented yet. The standard <code>eigen</code> function
does a better job at this, anyway.  </p>
</li></ol>

<p>Note that ARPACK might be unstable for graphs with multiple components, e.g.
graphs with isolate vertices.
</p>


<h3>Value</h3>

<p>Depends on the algorithm used.
</p>
<p>For <code>arpack</code> a list with three entries is returned: </p>
<table>
<tr><td><code>options</code></td>
<td>
<p>See
the return value for <code>arpack()</code> for a complete description.</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>Numeric vector, the eigenvalues.</p>
</td></tr> <tr><td><code>vectors</code></td>
<td>
<p>Numeric
matrix, with the eigenvectors as columns.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_adj">as_adj()</a></code> to create a (sparse) adjacency matrix.
</p>
<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Small example graph, leading eigenvector by default
kite &lt;- make_graph("Krackhardt_kite")
spectrum(kite)[c("values", "vectors")]

## Double check
eigen(as_adj(kite, sparse = FALSE))$vectors[, 1]

## Should be the same as 'eigen_centrality' (but rescaled)
cor(eigen_centrality(kite)$vector, spectrum(kite)$vectors)

## Smallest eigenvalues
spectrum(kite, which = list(pos = "SM", howmany = 2))$values

</code></pre>

<hr>
<h2 id='spinglass.community'>Finding communities in graphs based on statistical meachanics</h2><span id='topic+spinglass.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>spinglass.community()</code> was renamed to <code>cluster_spinglass()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spinglass.community(
  graph,
  weights = NULL,
  vertex = NULL,
  spins = 25,
  parupdate = FALSE,
  start.temp = 1,
  stop.temp = 0.01,
  cool.fact = 0.99,
  update.rule = c("config", "random", "simple"),
  gamma = 1,
  implementation = c("orig", "neg"),
  gamma.minus = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spinglass.community_+3A_graph">graph</code></td>
<td>
<p>The input graph, can be directed but the direction of the edges
is neglected.</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. A larger
edge weight means a stronger connection for this function.</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_vertex">vertex</code></td>
<td>
<p>This parameter can be used to calculate the community of a
given vertex without calculating all communities. Note that if this argument
is present then some other arguments are ignored.</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_spins">spins</code></td>
<td>
<p>Integer constant, the number of spins to use. This is the upper
limit for the number of communities. It is not a problem to supply a
(reasonably) big number here, in which case some spin states will be
unpopulated.</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_parupdate">parupdate</code></td>
<td>
<p>Logical constant, whether to update the spins of the
vertices in parallel (synchronously) or not. This argument is ignored if the
second form of the function is used (i.e. the &lsquo;<code>vertex</code>&rsquo; argument
is present). It is also not implemented in the &ldquo;neg&rdquo; implementation.</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_start.temp">start.temp</code></td>
<td>
<p>Real constant, the start temperature.  This argument is
ignored if the second form of the function is used (i.e. the
&lsquo;<code>vertex</code>&rsquo; argument is present).</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_stop.temp">stop.temp</code></td>
<td>
<p>Real constant, the stop temperature. The simulation
terminates if the temperature lowers below this level.  This argument is
ignored if the second form of the function is used (i.e. the
&lsquo;<code>vertex</code>&rsquo; argument is present).</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_cool.fact">cool.fact</code></td>
<td>
<p>Cooling factor for the simulated annealing.  This argument
is ignored if the second form of the function is used (i.e. the
&lsquo;<code>vertex</code>&rsquo; argument is present).</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_update.rule">update.rule</code></td>
<td>
<p>Character constant giving the &lsquo;null-model&rsquo; of the
simulation. Possible values: &ldquo;simple&rdquo; and &ldquo;config&rdquo;.
&ldquo;simple&rdquo; uses a random graph with the same number of edges as the
baseline probability and &ldquo;config&rdquo; uses a random graph with the same
vertex degrees as the input graph.</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_gamma">gamma</code></td>
<td>
<p>Real constant, the gamma argument of the algorithm. This
specifies the balance between the importance of present and non-present
edges in a community. Roughly, a comunity is a set of vertices having many
edges inside the community and few edges outside the community. The default
1.0 value makes existing and non-existing links equally important. Smaller
values make the existing links, greater values the missing links more
important.</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_implementation">implementation</code></td>
<td>
<p>Character scalar. Currently igraph contains two
implementations for the Spin-glass community finding algorithm. The faster
original implementation is the default. The other implementation, that takes
into account negative weights, can be chosen by supplying &lsquo;neg&rsquo; here.</p>
</td></tr>
<tr><td><code id="spinglass.community_+3A_gamma.minus">gamma.minus</code></td>
<td>
<p>Real constant, the gamma.minus parameter of the
algorithm. This specifies the balance between the importance of present and
non-present negative weighted edges in a community. Smaller values of
gamma.minus, leads to communities with lesser negative intra-connectivity.
If this argument is set to zero, the algorithm reduces to a graph coloring
algorithm, using the number of spins as the number of colors. This argument
is ignored if the &lsquo;orig&rsquo; implementation is chosen.</p>
</td></tr>
</table>

<hr>
<h2 id='split_join_distance'>Split-join distance of two community structures</h2><span id='topic+split_join_distance'></span>

<h3>Description</h3>

<p>The split-join distance between partitions A and B is the sum of the
projection distance of A from B and the projection distance of B from
A. The projection distance is an asymmetric measure and it is defined as
follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_join_distance(comm1, comm2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_join_distance_+3A_comm1">comm1</code></td>
<td>
<p>The first community structure.</p>
</td></tr>
<tr><td><code id="split_join_distance_+3A_comm2">comm2</code></td>
<td>
<p>The second community structure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, each set in partition A is evaluated against all sets in
partition B. For each set in partition A, the best matching set in
partition B is found and the overlap size is calculated. (Matching is
quantified by the size of the overlap between the two sets). Then, the
maximal overlap sizes for each set in A are summed together and
subtracted from the number of elements in A.
</p>
<p>The split-join distance will be returned as two numbers, the first is
the projection distance of the first partition from the
second, while the second number is the projection distance of the second
partition from the first. This makes it easier to detect whether a
partition is a subpartition of the other, since in this case, the
corresponding distance will be zero.
</p>


<h3>Value</h3>

<p>Two integer numbers, see details below.
</p>


<h3>References</h3>

<p>van Dongen S: Performance criteria for graph clustering and Markov
cluster experiments. Technical Report INS-R0012, National Research
Institute for Mathematics and Computer Science in the Netherlands,
Amsterdam, May 2000.
</p>


<h3>See Also</h3>

<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+voronoi_cells">voronoi_cells</a>()</code>
</p>

<hr>
<h2 id='st_cuts'>List all (s,t)-cuts of a graph</h2><span id='topic+st_cuts'></span>

<h3>Description</h3>

<p>List all (s,t)-cuts in a directed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_cuts(graph, source, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_cuts_+3A_graph">graph</code></td>
<td>
<p>The input graph. It must be directed.</p>
</td></tr>
<tr><td><code id="st_cuts_+3A_source">source</code></td>
<td>
<p>The source vertex.</p>
</td></tr>
<tr><td><code id="st_cuts_+3A_target">target</code></td>
<td>
<p>The target vertex.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code class="reqn">G</code> directed graph and two, different and non-ajacent vertices,
<code class="reqn">s</code> and <code class="reqn">t</code>, an <code class="reqn">(s,t)</code>-cut is a set of edges, such that after
removing these edges from <code class="reqn">G</code> there is no directed path from <code class="reqn">s</code> to
<code class="reqn">t</code>.
</p>


<h3>Value</h3>

<p>A list with entries: </p>
<table>
<tr><td><code>cuts</code></td>
<td>
<p>A list of numeric vectors
containing edge ids. Each vector is an <code class="reqn">(s,t)</code>-cut.</p>
</td></tr>
<tr><td><code>partition1s</code></td>
<td>
<p>A list of numeric vectors containing vertex ids, they
correspond to the edge cuts. Each vertex set is a generator of the
corresponding cut, i.e. in the graph <code class="reqn">G=(V,E)</code>, the vertex set <code class="reqn">X</code>
and its complementer <code class="reqn">V-X</code>, generates the cut that contains exactly the
edges that go from <code class="reqn">X</code> to <code class="reqn">V-X</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>JS Provan and DR Shier: A Paradigm for listing (s,t)-cuts in
graphs, <em>Algorithmica</em> 15, 351&ndash;372, 1996.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A very simple graph
g &lt;- graph_from_literal(a -+ b -+ c -+ d -+ e)
st_cuts(g, source = "a", target = "e")

# A somewhat more difficult graph
g2 &lt;- graph_from_literal(
  s --+ a:b, a:b --+ t,
  a --+ 1:2:3, 1:2:3 --+ b
)
st_cuts(g2, source = "s", target = "t")
</code></pre>

<hr>
<h2 id='st_min_cuts'>List all minimum <code class="reqn">(s,t)</code>-cuts of a graph</h2><span id='topic+st_min_cuts'></span>

<h3>Description</h3>

<p>Listing all minimum <code class="reqn">(s,t)</code>-cuts of a directed graph, for given <code class="reqn">s</code>
and <code class="reqn">t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_min_cuts(graph, source, target, capacity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_min_cuts_+3A_graph">graph</code></td>
<td>
<p>The input graph. It must be directed.</p>
</td></tr>
<tr><td><code id="st_min_cuts_+3A_source">source</code></td>
<td>
<p>The id of the source vertex.</p>
</td></tr>
<tr><td><code id="st_min_cuts_+3A_target">target</code></td>
<td>
<p>The id of the target vertex.</p>
</td></tr>
<tr><td><code id="st_min_cuts_+3A_capacity">capacity</code></td>
<td>
<p>Numeric vector giving the edge capacities. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then this
attribute defines the edge capacities. For forcing unit edge capacities,
even for graphs that have a <code>weight</code> edge attribute, supply <code>NA</code>
here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a <code class="reqn">G</code> directed graph and two, different and non-ajacent vertices,
<code class="reqn">s</code> and <code class="reqn">t</code>, an <code class="reqn">(s,t)</code>-cut is a set of edges, such that after
removing these edges from <code class="reqn">G</code> there is no directed path from <code class="reqn">s</code> to
<code class="reqn">t</code>.
</p>
<p>The size of an <code class="reqn">(s,t)</code>-cut is defined as the sum of the capacities (or
weights) in the cut. For unweighted (=equally weighted) graphs, this is
simply the number of edges.
</p>
<p>An <code class="reqn">(s,t)</code>-cut is minimum if it is of the smallest possible size.
</p>


<h3>Value</h3>

<p>A list with entries: </p>
<table>
<tr><td><code>value</code></td>
<td>
<p>Numeric scalar, the size of the
minimum cut(s).</p>
</td></tr> <tr><td><code>cuts</code></td>
<td>
<p>A list of numeric vectors containing edge ids.
Each vector is a minimum <code class="reqn">(s,t)</code>-cut.</p>
</td></tr> <tr><td><code>partition1s</code></td>
<td>
<p>A list of
numeric vectors containing vertex ids, they correspond to the edge cuts.
Each vertex set is a generator of the corresponding cut, i.e. in the graph
<code class="reqn">G=(V,E)</code>, the vertex set <code class="reqn">X</code> and its complementer <code class="reqn">V-X</code>,
generates the cut that contains exactly the edges that go from <code class="reqn">X</code> to
<code class="reqn">V-X</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>JS Provan and DR Shier: A Paradigm for listing (s,t)-cuts in
graphs, <em>Algorithmica</em> 15, 351&ndash;372, 1996.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+vertex_connectivity">vertex_connectivity</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A difficult graph, from the Provan-Shier paper
g &lt;- graph_from_literal(
  s --+ a:b, a:b --+ t,
  a --+ 1:2:3:4:5, 1:2:3:4:5 --+ b
)
st_min_cuts(g, source = "s", target = "t")
</code></pre>

<hr>
<h2 id='static.fitness.game'>Random graphs from vertex fitness scores</h2><span id='topic+static.fitness.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>static.fitness.game()</code> was renamed to <code>sample_fitness()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>static.fitness.game(
  no.of.edges,
  fitness.out,
  fitness.in = NULL,
  loops = FALSE,
  multiple = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="static.fitness.game_+3A_no.of.edges">no.of.edges</code></td>
<td>
<p>The number of edges in the generated graph.</p>
</td></tr>
<tr><td><code id="static.fitness.game_+3A_fitness.out">fitness.out</code></td>
<td>
<p>A numeric vector containing the fitness of each vertex.
For directed graphs, this specifies the out-fitness of each vertex.</p>
</td></tr>
<tr><td><code id="static.fitness.game_+3A_fitness.in">fitness.in</code></td>
<td>
<p>If <code>NULL</code> (the default), the generated graph will be
undirected. If not <code>NULL</code>, then it should be a numeric vector and it
specifies the in-fitness of each vertex.
</p>
<p>If this argument is not <code>NULL</code>, then a directed graph is generated,
otherwise an undirected one.</p>
</td></tr>
<tr><td><code id="static.fitness.game_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether to allow loop edges in the graph.</p>
</td></tr>
<tr><td><code id="static.fitness.game_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether to allow multiple edges in the
graph.</p>
</td></tr>
</table>

<hr>
<h2 id='static.power.law.game'>Scale-free random graphs, from vertex fitness scores</h2><span id='topic+static.power.law.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>static.power.law.game()</code> was renamed to <code>sample_fitness_pl()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>static.power.law.game(
  no.of.nodes,
  no.of.edges,
  exponent.out,
  exponent.in = -1,
  loops = FALSE,
  multiple = FALSE,
  finite.size.correction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="static.power.law.game_+3A_no.of.nodes">no.of.nodes</code></td>
<td>
<p>The number of vertices in the generated graph.</p>
</td></tr>
<tr><td><code id="static.power.law.game_+3A_no.of.edges">no.of.edges</code></td>
<td>
<p>The number of edges in the generated graph.</p>
</td></tr>
<tr><td><code id="static.power.law.game_+3A_exponent.out">exponent.out</code></td>
<td>
<p>Numeric scalar, the power law exponent of the degree
distribution. For directed graphs, this specifies the exponent of the
out-degree distribution. It must be greater than or equal to 2. If you pass
<code>Inf</code> here, you will get back an Erdős-Rényi random network.</p>
</td></tr>
<tr><td><code id="static.power.law.game_+3A_exponent.in">exponent.in</code></td>
<td>
<p>Numeric scalar. If negative, the generated graph will be
undirected. If greater than or equal to 2, this argument specifies the
exponent of the in-degree distribution. If non-negative but less than 2, an
error will be generated.</p>
</td></tr>
<tr><td><code id="static.power.law.game_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether to allow loop edges in the generated
graph.</p>
</td></tr>
<tr><td><code id="static.power.law.game_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether to allow multiple edges in the
generated graph.</p>
</td></tr>
<tr><td><code id="static.power.law.game_+3A_finite.size.correction">finite.size.correction</code></td>
<td>
<p>Logical scalar, whether to use the proposed
finite size correction of Cho et al., see references below.</p>
</td></tr>
</table>

<hr>
<h2 id='stCuts'>List all (s,t)-cuts of a graph</h2><span id='topic+stCuts'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>stCuts()</code> was renamed to <code>st_cuts()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stCuts(graph, source, target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stCuts_+3A_graph">graph</code></td>
<td>
<p>The input graph. It must be directed.</p>
</td></tr>
<tr><td><code id="stCuts_+3A_source">source</code></td>
<td>
<p>The source vertex.</p>
</td></tr>
<tr><td><code id="stCuts_+3A_target">target</code></td>
<td>
<p>The target vertex.</p>
</td></tr>
</table>

<hr>
<h2 id='stMincuts'>List all minimum \((s,t)\)-cuts of a graph</h2><span id='topic+stMincuts'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>stMincuts()</code> was renamed to <code>st_min_cuts()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stMincuts(graph, source, target, capacity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stMincuts_+3A_graph">graph</code></td>
<td>
<p>The input graph. It must be directed.</p>
</td></tr>
<tr><td><code id="stMincuts_+3A_source">source</code></td>
<td>
<p>The id of the source vertex.</p>
</td></tr>
<tr><td><code id="stMincuts_+3A_target">target</code></td>
<td>
<p>The id of the target vertex.</p>
</td></tr>
<tr><td><code id="stMincuts_+3A_capacity">capacity</code></td>
<td>
<p>Numeric vector giving the edge capacities. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then this
attribute defines the edge capacities. For forcing unit edge capacities,
even for graphs that have a <code>weight</code> edge attribute, supply <code>NA</code>
here.</p>
</td></tr>
</table>

<hr>
<h2 id='stochastic_matrix'>Stochastic matrix of a graph</h2><span id='topic+stochastic_matrix'></span>

<h3>Description</h3>

<p>Retrieves the stochastic matrix of a graph of class <code>igraph</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stochastic_matrix(
  graph,
  column.wise = FALSE,
  sparse = igraph_opt("sparsematrices")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stochastic_matrix_+3A_graph">graph</code></td>
<td>
<p>The input graph. Must be of class <code>igraph</code>.</p>
</td></tr>
<tr><td><code id="stochastic_matrix_+3A_column.wise">column.wise</code></td>
<td>
<p>If <code>FALSE</code>, then the rows of the stochastic matrix
sum up to one; otherwise it is the columns.</p>
</td></tr>
<tr><td><code id="stochastic_matrix_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to return a sparse matrix. The
<code>Matrix</code> package is needed for sparse matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">M</code> be an <code class="reqn">n \times n</code> adjacency matrix with real
non-negative entries. Let us define <code class="reqn">D = \textrm{diag}(\sum_{i}M_{1i},
\dots, \sum_{i}M_{ni})</code>
</p>
<p>The (row) stochastic matrix is defined as </p>
<p style="text-align: center;"><code class="reqn">W = D^{-1}M,</code>
</p>

<p>where it is assumed that <code class="reqn">D</code> is non-singular.  Column stochastic
matrices are defined in a symmetric way.
</p>


<h3>Value</h3>

<p>A regular matrix or a matrix of class <code>Matrix</code> if a
<code>sparse</code> argument was <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as_adj">as_adj()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Matrix)
## g is a large sparse graph
g &lt;- sample_pa(n = 10^5, power = 2, directed = FALSE)
W &lt;- stochastic_matrix(g, sparse = TRUE)

## a dense matrix here would probably not fit in the memory
class(W)

## may not be exactly 1, due to numerical errors
max(abs(rowSums(W)) - 1)

</code></pre>

<hr>
<h2 id='strength'>Strength or weighted vertex degree</h2><span id='topic+strength'></span>

<h3>Description</h3>

<p>Summing up the edge weights of the adjacent edges for each vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strength(
  graph,
  vids = V(graph),
  mode = c("all", "out", "in", "total"),
  loops = TRUE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strength_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="strength_+3A_vids">vids</code></td>
<td>
<p>The vertices for which the strength will be calculated.</p>
</td></tr>
<tr><td><code id="strength_+3A_mode">mode</code></td>
<td>
<p>Character string, &ldquo;out&rdquo; for out-degree, &ldquo;in&rdquo; for
in-degree or &ldquo;all&rdquo; for the sum of the two. For undirected graphs this
argument is ignored.</p>
</td></tr>
<tr><td><code id="strength_+3A_loops">loops</code></td>
<td>
<p>Logical; whether the loop edges are also counted.</p>
</td></tr>
<tr><td><code id="strength_+3A_weights">weights</code></td>
<td>
<p>Weight vector. If the graph has a <code>weight</code> edge
attribute, then this is used by default. If the graph does not have a
<code>weight</code> edge attribute and this argument is <code>NULL</code>, then a
<code><a href="#topic+degree">degree()</a></code> is called. If this is <code>NA</code>, then no edge weights are used
(even if the graph has a <code>weight</code> edge attribute).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the strength of the vertices.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Alain Barrat, Marc Barthelemy, Romualdo Pastor-Satorras,
Alessandro Vespignani: The architecture of complex weighted networks, Proc.
Natl. Acad. Sci. USA 101, 3747 (2004)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+degree">degree()</a></code> for the unweighted version.
</p>
<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+subgraph_centrality">subgraph_centrality</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_star(10)
E(g)$weight &lt;- seq(ecount(g))
strength(g)
strength(g, mode = "out")
strength(g, mode = "in")

# No weights
g &lt;- make_ring(10)
strength(g)
</code></pre>

<hr>
<h2 id='subcomponent'>In- or out- component of a vertex</h2><span id='topic+subcomponent'></span>

<h3>Description</h3>

<p>Finds all vertices reachable from a given vertex, or the opposite: all
vertices from which a given vertex is reachable via a directed path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subcomponent(graph, v, mode = c("all", "out", "in"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subcomponent_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="subcomponent_+3A_v">v</code></td>
<td>
<p>The vertex to start the search from.</p>
</td></tr>
<tr><td><code id="subcomponent_+3A_mode">mode</code></td>
<td>
<p>Character string, either &ldquo;in&rdquo;, &ldquo;out&rdquo; or
&ldquo;all&rdquo;. If &ldquo;in&rdquo; all vertices from which <code>v</code> is reachable
are listed. If &ldquo;out&rdquo; all vertices reachable from <code>v</code> are
returned. If &ldquo;all&rdquo; returns the union of these. It is ignored for
undirected graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A breadth-first search is conducted starting from vertex <code>v</code>.
</p>


<h3>Value</h3>

<p>Numeric vector, the ids of the vertices in the same component as
<code>v</code>.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+components">components()</a></code>
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnp(100, 1 / 200)
subcomponent(g, 1, "in")
subcomponent(g, 1, "out")
subcomponent(g, 1, "all")
</code></pre>

<hr>
<h2 id='subgraph'>Subgraph of a graph</h2><span id='topic+subgraph'></span><span id='topic+subgraph.edges'></span><span id='topic+induced_subgraph'></span>

<h3>Description</h3>

<p><code>subgraph()</code> creates a subgraph of a graph, containing only the specified
vertices and all the edges among them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph(graph, vids)

induced_subgraph(
  graph,
  vids,
  impl = c("auto", "copy_and_delete", "create_from_scratch")
)

subgraph.edges(graph, eids, delete.vertices = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph_+3A_graph">graph</code></td>
<td>
<p>The original graph.</p>
</td></tr>
<tr><td><code id="subgraph_+3A_vids">vids</code></td>
<td>
<p>Numeric vector, the vertices of the original graph which will
form the subgraph.</p>
</td></tr>
<tr><td><code id="subgraph_+3A_impl">impl</code></td>
<td>
<p>Character scalar, to choose between two implementation of the
subgraph calculation. &lsquo;<code>copy_and_delete</code>&rsquo; copies the graph
first, and then deletes the vertices and edges that are not included in the
result graph. &lsquo;<code>create_from_scratch</code>&rsquo; searches for all vertices
and edges that must be kept and then uses them to create the graph from
scratch. &lsquo;<code>auto</code>&rsquo; chooses between the two implementations
automatically, using heuristics based on the size of the original and the
result graph.</p>
</td></tr>
<tr><td><code id="subgraph_+3A_eids">eids</code></td>
<td>
<p>The edge ids of the edges that will be kept in the result graph.</p>
</td></tr>
<tr><td><code id="subgraph_+3A_delete.vertices">delete.vertices</code></td>
<td>
<p>Logical scalar, whether to remove vertices that do
not have any adjacent edges in <code>eids</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>induced_subgraph()</code> calculates the induced subgraph of a set of vertices
in a graph. This means that exactly the specified vertices and all the edges
between them will be kept in the result graph.
</p>
<p><code>subgraph.edges()</code> calculates the subgraph of a graph. For this function
one can specify the vertices and edges to keep. This function will be
renamed to <code>subgraph()</code> in the next major version of igraph.
</p>
<p>The <code>subgraph()</code> function currently does the same as <code>induced_subgraph()</code>
(assuming &lsquo;<code>auto</code>&rsquo; as the <code>impl</code> argument), but this behaviour
is deprecated. In the next major version, <code>subgraph()</code> will overtake the
functionality of <code>subgraph.edges()</code>.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
g2 &lt;- induced_subgraph(g, 1:7)
g3 &lt;- subgraph.edges(g, 1:5)

</code></pre>

<hr>
<h2 id='subgraph_centrality'>Find subgraph centrality scores of network positions</h2><span id='topic+subgraph_centrality'></span>

<h3>Description</h3>

<p>Subgraph centrality of a vertex measures the number of subgraphs a vertex
participates in, weighting them according to their size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph_centrality(graph, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph_centrality_+3A_graph">graph</code></td>
<td>
<p>The input graph, it should be undirected, but the
implementation does not check this currently.</p>
</td></tr>
<tr><td><code id="subgraph_centrality_+3A_diag">diag</code></td>
<td>
<p>Boolean scalar, whether to include the diagonal of the adjacency
matrix in the analysis. Giving <code>FALSE</code> here effectively eliminates the
loops edges from the graph before the calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subgraph centrality of a vertex is defined as the number of closed loops
originating at the vertex, where longer loops are exponentially
downweighted.
</p>
<p>Currently the calculation is performed by explicitly calculating all
eigenvalues and eigenvectors of the adjacency matrix of the graph. This
effectively means that the measure can only be calculated for small graphs.
</p>


<h3>Value</h3>

<p>A numeric vector, the subgraph centrality scores of the vertices.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> based on the Matlab
code by Ernesto Estrada
</p>


<h3>References</h3>

<p>Ernesto Estrada, Juan A. Rodriguez-Velazquez: Subgraph
centrality in Complex Networks. <em>Physical Review E</em> 71, 056103 (2005).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eigen_centrality">eigen_centrality()</a></code>, <code><a href="#topic+page_rank">page_rank()</a></code>
</p>
<p>Centrality measures
<code><a href="#topic+alpha_centrality">alpha_centrality</a>()</code>,
<code><a href="#topic+betweenness">betweenness</a>()</code>,
<code><a href="#topic+closeness">closeness</a>()</code>,
<code><a href="#topic+diversity">diversity</a>()</code>,
<code><a href="#topic+eigen_centrality">eigen_centrality</a>()</code>,
<code><a href="#topic+harmonic_centrality">harmonic_centrality</a>()</code>,
<code><a href="#topic+hub_score">hub_score</a>()</code>,
<code><a href="#topic+page_rank">page_rank</a>()</code>,
<code><a href="#topic+power_centrality">power_centrality</a>()</code>,
<code><a href="#topic+spectrum">spectrum</a>()</code>,
<code><a href="#topic+strength">strength</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_pa(100, m = 4, dir = FALSE)
sc &lt;- subgraph_centrality(g)
cor(degree(g), sc)

</code></pre>

<hr>
<h2 id='subgraph_isomorphic'>Decide if a graph is subgraph isomorphic to another one</h2><span id='topic+subgraph_isomorphic'></span><span id='topic+graph.subisomorphic.vf2'></span><span id='topic+graph.subisomorphic.lad'></span><span id='topic+is_subgraph_isomorphic_to'></span>

<h3>Description</h3>

<p>Decide if a graph is subgraph isomorphic to another one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph_isomorphic(pattern, target, method = c("auto", "lad", "vf2"), ...)

is_subgraph_isomorphic_to(
  pattern,
  target,
  method = c("auto", "lad", "vf2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph_isomorphic_+3A_pattern">pattern</code></td>
<td>
<p>The smaller graph, it might be directed or
undirected. Undirected graphs are treated as directed graphs with
mutual edges.</p>
</td></tr>
<tr><td><code id="subgraph_isomorphic_+3A_target">target</code></td>
<td>
<p>The bigger graph, it might be directed or
undirected. Undirected graphs are treated as directed graphs with
mutual edges.</p>
</td></tr>
<tr><td><code id="subgraph_isomorphic_+3A_method">method</code></td>
<td>
<p>The method to use. Possible values: &lsquo;auto&rsquo;,
&lsquo;lad&rsquo;, &lsquo;vf2&rsquo;. See their details below.</p>
</td></tr>
<tr><td><code id="subgraph_isomorphic_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the various methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical scalar, <code>TRUE</code> if the <code>pattern</code> is
isomorphic to a (possibly induced) subgraph of <code>target</code>.
</p>


<h3>&lsquo;auto&rsquo; method</h3>

<p>This method currently selects &lsquo;lad&rsquo;, always, as it seems
to be superior on most graphs.
</p>


<h3>&lsquo;lad&rsquo; method</h3>

<p>This is the LAD algorithm by Solnon, see the reference below. It has
the following extra arguments:
</p>

<dl>
<dt>domains</dt><dd><p>If not <code>NULL</code>, then it specifies matching
restrictions. It must be a list of <code>target</code> vertex sets, given
as numeric vertex ids or symbolic vertex names. The length of the
list must be <code>vcount(pattern)</code> and for each vertex in
<code>pattern</code> it gives the allowed matching vertices in
<code>target</code>. Defaults to <code>NULL</code>.</p>
</dd>
<dt>induced</dt><dd><p>Logical scalar, whether to search for an induced
subgraph. It is <code>FALSE</code> by default.</p>
</dd>
<dt>time.limit</dt><dd><p>The processor time limit for the computation, in
seconds. It defaults to <code>Inf</code>, which means no limit.</p>
</dd>
</dl>



<h3>&lsquo;vf2&rsquo; method</h3>

<p>This method uses the VF2 algorithm by Cordella, Foggia et al., see
references below. It supports vertex and edge colors and have the
following extra arguments:
</p>

<dl>
<dt>vertex.color1, vertex.color2</dt><dd><p>Optional integer vectors giving the
colors of the vertices for colored graph isomorphism. If they
are not given, but the graph has a &ldquo;color&rdquo; vertex attribute,
then it will be used. If you want to ignore these attributes, then
supply <code>NULL</code> for both of these arguments. See also examples
below.</p>
</dd>
<dt>edge.color1, edge.color2</dt><dd><p>Optional integer vectors giving the
colors of the edges for edge-colored (sub)graph isomorphism. If they
are not given, but the graph has a &ldquo;color&rdquo; edge attribute,
then it will be used. If you want to ignore these attributes, then
supply <code>NULL</code> for both of these arguments.</p>
</dd>
</dl>



<h3>References</h3>

<p>LP Cordella,  P Foggia, C Sansone, and M Vento: An improved algorithm
for matching large graphs, <em>Proc. of the 3rd IAPR TC-15 Workshop
on Graphbased Representations in Pattern Recognition</em>, 149&ndash;159, 2001.
</p>
<p>C. Solnon: AllDifferent-based Filtering for Subgraph Isomorphism,
<em>Artificial Intelligence</em> 174(12-13):850&ndash;864, 2010.
</p>


<h3>See Also</h3>

<p>Other graph isomorphism: 
<code><a href="#topic+canonical_permutation">canonical_permutation</a>()</code>,
<code><a href="#topic+count_isomorphisms">count_isomorphisms</a>()</code>,
<code><a href="#topic+count_subgraph_isomorphisms">count_subgraph_isomorphisms</a>()</code>,
<code><a href="#topic+graph_from_isomorphism_class">graph_from_isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphic">isomorphic</a>()</code>,
<code><a href="#topic+isomorphism_class">isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphisms">isomorphisms</a>()</code>,
<code><a href="#topic+subgraph_isomorphisms">subgraph_isomorphisms</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A LAD example
pattern &lt;- make_graph(
  ~ 1:2:3:4:5,
  1 - 2:5, 2 - 1:5:3, 3 - 2:4, 4 - 3:5, 5 - 4:2:1
)
target &lt;- make_graph(
  ~ 1:2:3:4:5:6:7:8:9,
  1 - 2:5:7, 2 - 1:5:3, 3 - 2:4, 4 - 3:5:6:8:9,
  5 - 1:2:4:6:7, 6 - 7:5:4:9, 7 - 1:5:6,
  8 - 4:9, 9 - 6:4:8
)
domains &lt;- list(
  `1` = c(1, 3, 9), `2` = c(5, 6, 7, 8), `3` = c(2, 4, 6, 7, 8, 9),
  `4` = c(1, 3, 9), `5` = c(2, 4, 8, 9)
)
subgraph_isomorphisms(pattern, target)
subgraph_isomorphisms(pattern, target, induced = TRUE)
subgraph_isomorphisms(pattern, target, domains = domains)

# Directed LAD example
pattern &lt;- make_graph(~ 1:2:3, 1 -+ 2:3)
dring &lt;- make_ring(10, directed = TRUE)
subgraph_isomorphic(pattern, dring)
</code></pre>

<hr>
<h2 id='subgraph_isomorphisms'>All isomorphic mappings between a graph and subgraphs of another graph</h2><span id='topic+subgraph_isomorphisms'></span><span id='topic+graph.get.subisomorphisms.vf2'></span>

<h3>Description</h3>

<p>All isomorphic mappings between a graph and subgraphs of another graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph_isomorphisms(pattern, target, method = c("lad", "vf2"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph_isomorphisms_+3A_pattern">pattern</code></td>
<td>
<p>The smaller graph, it might be directed or
undirected. Undirected graphs are treated as directed graphs with
mutual edges.</p>
</td></tr>
<tr><td><code id="subgraph_isomorphisms_+3A_target">target</code></td>
<td>
<p>The bigger graph, it might be directed or
undirected. Undirected graphs are treated as directed graphs with
mutual edges.</p>
</td></tr>
<tr><td><code id="subgraph_isomorphisms_+3A_method">method</code></td>
<td>
<p>The method to use. Possible values: &lsquo;auto&rsquo;,
&lsquo;lad&rsquo;, &lsquo;vf2&rsquo;. See their details below.</p>
</td></tr>
<tr><td><code id="subgraph_isomorphisms_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to the various methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vertex sequences, corresponding to all
mappings from the first graph to the second.
</p>


<h3>&lsquo;lad&rsquo; method</h3>

<p>This is the LAD algorithm by Solnon, see the reference below. It has
the following extra arguments:
</p>

<dl>
<dt>domains</dt><dd><p>If not <code>NULL</code>, then it specifies matching
restrictions. It must be a list of <code>target</code> vertex sets, given
as numeric vertex ids or symbolic vertex names. The length of the
list must be <code>vcount(pattern)</code> and for each vertex in
<code>pattern</code> it gives the allowed matching vertices in
<code>target</code>. Defaults to <code>NULL</code>.</p>
</dd>
<dt>induced</dt><dd><p>Logical scalar, whether to search for an induced
subgraph. It is <code>FALSE</code> by default.</p>
</dd>
<dt>time.limit</dt><dd><p>The processor time limit for the computation, in
seconds. It defaults to <code>Inf</code>, which means no limit.</p>
</dd>
</dl>



<h3>&lsquo;vf2&rsquo; method</h3>

<p>This method uses the VF2 algorithm by Cordella, Foggia et al., see
references below. It supports vertex and edge colors and have the
following extra arguments:
</p>

<dl>
<dt>vertex.color1, vertex.color2</dt><dd><p>Optional integer vectors giving the
colors of the vertices for colored graph isomorphism. If they
are not given, but the graph has a &ldquo;color&rdquo; vertex attribute,
then it will be used. If you want to ignore these attributes, then
supply <code>NULL</code> for both of these arguments. See also examples
below.</p>
</dd>
<dt>edge.color1, edge.color2</dt><dd><p>Optional integer vectors giving the
colors of the edges for edge-colored (sub)graph isomorphism. If they
are not given, but the graph has a &ldquo;color&rdquo; edge attribute,
then it will be used. If you want to ignore these attributes, then
supply <code>NULL</code> for both of these arguments.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>Other graph isomorphism: 
<code><a href="#topic+canonical_permutation">canonical_permutation</a>()</code>,
<code><a href="#topic+count_isomorphisms">count_isomorphisms</a>()</code>,
<code><a href="#topic+count_subgraph_isomorphisms">count_subgraph_isomorphisms</a>()</code>,
<code><a href="#topic+graph_from_isomorphism_class">graph_from_isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphic">isomorphic</a>()</code>,
<code><a href="#topic+isomorphism_class">isomorphism_class</a>()</code>,
<code><a href="#topic+isomorphisms">isomorphisms</a>()</code>,
<code><a href="#topic+subgraph_isomorphic">subgraph_isomorphic</a>()</code>
</p>

<hr>
<h2 id='subgraph.centrality'>Find subgraph centrality scores of network positions</h2><span id='topic+subgraph.centrality'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>subgraph.centrality()</code> was renamed to <code>subgraph_centrality()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subgraph.centrality(graph, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subgraph.centrality_+3A_graph">graph</code></td>
<td>
<p>The input graph, it should be undirected, but the
implementation does not check this currently.</p>
</td></tr>
<tr><td><code id="subgraph.centrality_+3A_diag">diag</code></td>
<td>
<p>Boolean scalar, whether to include the diagonal of the adjacency
matrix in the analysis. Giving <code>FALSE</code> here effectively eliminates the
loops edges from the graph before the calculation.</p>
</td></tr>
</table>

<hr>
<h2 id='tail_of'>Tails of the edge(s) in a graph</h2><span id='topic+tail_of'></span>

<h3>Description</h3>

<p>For undirected graphs, head and tail is not defined.  In this case
<code>tail_of()</code> returns vertices incident to the supplied edges, and
<code>head_of()</code> returns the other end(s) of the edge(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tail_of(graph, es)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tail_of_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="tail_of_+3A_es">es</code></td>
<td>
<p>The edges to query.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vertex sequence with the tail(s) of the edge(s).
</p>


<h3>See Also</h3>

<p>Other structural queries: 
<code><a href="#topic++5B.igraph">[.igraph</a>()</code>,
<code><a href="#topic++5B+5B.igraph">[[.igraph</a>()</code>,
<code><a href="#topic+adjacent_vertices">adjacent_vertices</a>()</code>,
<code><a href="#topic+are_adjacent">are_adjacent</a>()</code>,
<code><a href="#topic+ends">ends</a>()</code>,
<code><a href="#topic+get.edge.ids">get.edge.ids</a>()</code>,
<code><a href="#topic+gorder">gorder</a>()</code>,
<code><a href="#topic+gsize">gsize</a>()</code>,
<code><a href="#topic+head_of">head_of</a>()</code>,
<code><a href="#topic+incident">incident</a>()</code>,
<code><a href="#topic+incident_edges">incident_edges</a>()</code>,
<code><a href="#topic+is_directed">is_directed</a>()</code>,
<code><a href="#topic+neighbors">neighbors</a>()</code>
</p>

<hr>
<h2 id='time_bins'>SIR model on graphs</h2><span id='topic+time_bins'></span><span id='topic+time_bins.sir'></span><span id='topic+median.sir'></span><span id='topic+quantile.sir'></span><span id='topic+sir'></span>

<h3>Description</h3>

<p>Run simulations for an SIR (susceptible-infected-recovered) model, on a
graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_bins(x, middle = TRUE)

## S3 method for class 'sir'
time_bins(x, middle = TRUE)

## S3 method for class 'sir'
median(x, na.rm = FALSE, ...)

## S3 method for class 'sir'
quantile(x, comp = c("NI", "NS", "NR"), prob, ...)

sir(graph, beta, gamma, no.sim = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_bins_+3A_x">x</code></td>
<td>
<p>A <code>sir</code> object, returned by the <code>sir()</code> function.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_middle">middle</code></td>
<td>
<p>Logical scalar, whether to return the middle of the time bins,
or the boundaries.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical scalar, whether to ignore <code>NA</code> values.  <code>sir</code>
objects do not contain any <code>NA</code> values currently, so this argument is
effectively ignored.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_...">...</code></td>
<td>
<p>Additional arguments, ignored currently.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_comp">comp</code></td>
<td>
<p>Character scalar. The component to calculate the quantile of.
<code>NI</code> is infected agents, <code>NS</code> is susceptibles, <code>NR</code> stands
for recovered.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_prob">prob</code></td>
<td>
<p>Numeric vector of probabilities, in [0,1], they specify the
quantiles to calculate.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_graph">graph</code></td>
<td>
<p>The graph to run the model on. If directed, then edge
directions are ignored and a warning is given.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_beta">beta</code></td>
<td>
<p>Non-negative scalar. The rate of infection of an individual that
is susceptible and has a single infected neighbor. The infection rate of a
susceptible individual with n infected neighbors is n times beta. Formally
this is the rate parameter of an exponential distribution.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_gamma">gamma</code></td>
<td>
<p>Positive scalar. The rate of recovery of an infected
individual. Formally, this is the rate parameter of an exponential
distribution.</p>
</td></tr>
<tr><td><code id="time_bins_+3A_no.sim">no.sim</code></td>
<td>
<p>Integer scalar, the number simulation runs to perform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SIR model is a simple model from epidemiology. The individuals of the
population might be in three states: susceptible, infected and recovered.
Recovered people are assumed to be immune to the disease. Susceptibles
become infected with a rate that depends on their number of infected
neighbors. Infected people become recovered with a constant rate.
</p>
<p>The function <code>sir()</code> simulates the model. This function runs multiple
simulations, all starting with a single uniformly randomly chosen infected
individual. A simulation is stopped when no infected individuals are left.
</p>
<p>Function <code>time_bins()</code> bins the simulation steps, using the
Freedman-Diaconis heuristics to determine the bin width.
</p>
<p>Function <code>median</code> and <code>quantile</code> calculate the median and
quantiles of the results, respectively, in bins calculated with
<code>time_bins()</code>.
</p>


<h3>Value</h3>

<p>For <code>sir()</code> the results are returned in an object of class
&lsquo;<code>sir</code>&rsquo;, which is a list, with one element for each simulation.
Each simulation is itself a list with the following elements. They are all
numeric vectors, with equal length: </p>

<dl>
<dt>times</dt><dd><p>The times of the events.</p>
</dd>
<dt>NS</dt><dd><p>The number of susceptibles in the population, over time.</p>
</dd>
<dt>NI</dt><dd><p>The number of infected individuals in the population, over
time.</p>
</dd>
<dt>NR</dt><dd><p>The number of recovered individuals in the population, over
time.</p>
</dd>
</dl>

<p>Function <code>time_bins()</code> returns a numeric vector, the middle or the
boundaries of the time bins, depending on the <code>middle</code> argument.
</p>
<p><code>median</code> returns a list of three named numeric vectors, <code>NS</code>,
<code>NI</code> and <code>NR</code>. The names within the vectors are created from the
time bins.
</p>
<p><code>quantile</code> returns the same vector as <code>median</code> (but only one, the
one requested) if only one quantile is requested. If multiple quantiles are
requested, then a list of these vectors is returned, one for each quantile.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>. Eric Kolaczyk
(<a href="http://math.bu.edu/people/kolaczyk/">http://math.bu.edu/people/kolaczyk/</a>) wrote the initial version in R.
</p>


<h3>References</h3>

<p>Bailey, Norman T. J. (1975). The mathematical theory of
infectious diseases and its applications (2nd ed.). London: Griffin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.sir">plot.sir()</a></code> to conveniently plot the results
</p>
<p>Processes on graphs
<code><a href="#topic+plot.sir">plot.sir</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnm(100, 100)
sm &lt;- sir(g, beta = 5, gamma = 1)
plot(sm)
</code></pre>

<hr>
<h2 id='tkigraph'>Experimental basic igraph GUI</h2><span id='topic+tkigraph'></span>

<h3>Description</h3>

<p>This functions starts an experimental GUI to some igraph functions. The GUI
was written in Tcl/Tk, so it is cross platform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkigraph()
</code></pre>


<h3>Details</h3>

<p><code>tkigraph()</code> has its own online help system, please see that for the
details about how to use it.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code>, invisibly.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tkplot">tkplot()</a></code> for interactive plotting of graphs.
</p>

<hr>
<h2 id='tkplot'>Interactive plotting of graphs</h2><span id='topic+tkplot'></span><span id='topic+tk_close'></span><span id='topic+tk_off'></span><span id='topic+tk_fit'></span><span id='topic+tk_center'></span><span id='topic+tk_reshape'></span><span id='topic+tk_postscript'></span><span id='topic+tk_coords'></span><span id='topic+tk_set_coords'></span><span id='topic+tk_rotate'></span><span id='topic+tk_canvas'></span>

<h3>Description</h3>

<p><code>tkplot()</code> and its companion functions serve as an interactive graph
drawing facility. Not all parameters of the plot can be changed
interactively right now though, e.g. the colors of vertices, edges, and also
others have to be pre-defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot(graph, canvas.width = 450, canvas.height = 450, ...)

tk_close(tkp.id, window.close = TRUE)

tk_off()

tk_fit(tkp.id, width = NULL, height = NULL)

tk_center(tkp.id)

tk_reshape(tkp.id, newlayout, ..., params)

tk_postscript(tkp.id)

tk_coords(tkp.id, norm = FALSE)

tk_set_coords(tkp.id, coords)

tk_rotate(tkp.id, degree = NULL, rad = NULL)

tk_canvas(tkp.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot_+3A_graph">graph</code></td>
<td>
<p>The <code>graph</code> to plot.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_canvas.width">canvas.width</code>, <code id="tkplot_+3A_canvas.height">canvas.height</code></td>
<td>
<p>The size of the tkplot drawing area.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters. See <a href="#topic+igraph.plotting">igraph.plotting</a> for
the complete list.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_window.close">window.close</code></td>
<td>
<p>Leave this on the default value.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_width">width</code></td>
<td>
<p>The width of the rectangle for generating new coordinates.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_height">height</code></td>
<td>
<p>The height of the rectangle for generating new coordinates.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_newlayout">newlayout</code></td>
<td>
<p>The new layout, see the <code>layout</code> parameter of tkplot.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_params">params</code></td>
<td>
<p>Extra parameters in a list, to pass to the layout function.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_norm">norm</code></td>
<td>
<p>Logical, should we norm the coordinates.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_coords">coords</code></td>
<td>
<p>Two-column numeric matrix, the new coordinates of the
vertices, in absolute coordinates.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_degree">degree</code></td>
<td>
<p>The degree to rotate the plot.</p>
</td></tr>
<tr><td><code id="tkplot_+3A_rad">rad</code></td>
<td>
<p>The degree to rotate the plot, in radian.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tkplot()</code> is an interactive graph drawing facility. It is not very well
developed at this stage, but it should be still useful.
</p>
<p>It's handling should be quite straightforward most of the time, here are
some remarks and hints.
</p>
<p>There are different popup menus, activated by the right mouse button, for
vertices and edges. Both operate on the current selection if the vertex/edge
under the cursor is part of the selection and operate on the vertex/edge
under the cursor if it is not.
</p>
<p>One selection can be active at a time, either a vertex or an edge selection.
A vertex/edge can be added to a selection by holding the <code>control</code> key
while clicking on it with the left mouse button. Doing this again deselect
the vertex/edge.
</p>
<p>Selections can be made also from the &quot;Select&quot; menu. The &quot;Select some
vertices&quot; dialog allows to give an expression for the vertices to be
selected: this can be a list of numeric R expessions separated by commas,
like <code style="white-space: pre;">&#8288;1,2:10,12,14,15&#8288;</code> for example. Similarly in the &quot;Select some
edges&quot; dialog two such lists can be given and all edges connecting a vertex
in the first list to one in the second list will be selected.
</p>
<p>In the color dialog a color name like 'orange' or RGB notation can also be
used.
</p>
<p>The <code>tkplot()</code> command creates a new Tk window with the graphical
representation of <code>graph</code>. The command returns an integer number, the
tkplot id. The other commands utilize this id to be able to query or
manipulate the plot.
</p>
<p><code>tk_close()</code> closes the Tk plot with id <code>tkp.id</code>.
</p>
<p><code>tk_off()</code> closes all Tk plots.
</p>
<p><code>tk_fit()</code> fits the plot to the given rectangle
(<code>width</code> and <code>height</code>), if some of these are <code>NULL</code> the
actual physical width od height of the plot window is used.
</p>
<p><code>tk_reshape()</code> applies a new layout to the plot, its optional
parameters will be collected to a list analogous to <code>layout.par</code>.
</p>
<p><code>tk_postscript()</code> creates a dialog window for saving the plot
in postscript format.
</p>
<p><code>tk_canvas()</code> returns the Tk canvas object that belongs to a graph
plot. The canvas can be directly manipulated then, e.g. labels can be added,
it could be saved to a file programmatically, etc. See an example below.
</p>
<p><code>tk_coords()</code> returns the coordinates of the vertices in a matrix.
Each row corresponds to one vertex.
</p>
<p><code>tk_set_coords()</code> sets the coordinates of the vertices. A two-column
matrix specifies the new positions, with each row corresponding to a single
vertex.
</p>
<p><code>tk_center()</code> shifts the figure to the center of its plot window.
</p>
<p><code>tk_rotate()</code> rotates the figure, its parameter can be given either
in degrees or in radians.
</p>
<p>tkplot.center tkplot.rotate
</p>


<h3>Value</h3>

<p><code>tkplot()</code> returns an integer, the id of the plot, this can be
used to manipulate it from the command line.
</p>
<p><code>tk_canvas()</code> returns <code>tkwin</code> object, the Tk canvas.
</p>
<p><code>tk_coords()</code> returns a matrix with the coordinates.
</p>
<p><code>tk_close()</code>, <code>tk_off()</code>, <code>tk_fit()</code>,
<code>tk_reshape()</code>, <code>tk_postscript()</code>, <code>tk_center()</code>
and <code>tk_rotate()</code> return <code>NULL</code> invisibly.
</p>


<h3>Examples</h3>

<pre>
g &lt;- make_ring(10)
tkplot(g)

## Saving a tkplot() to a file programmatically
g &lt;- make_star(10, center=10) 
E(g)$width &lt;- sample(1:10, ecount(g), replace=TRUE)
lay &lt;- layout_nicely(g)

id &lt;- tkplot(g, layout=lay)
canvas &lt;- tk_canvas(id)
tcltk::tkpostscript(canvas, file="/tmp/output.eps")
tk_close(id)

## Setting the coordinates and adding a title label
g &lt;- make_ring(10)
id &lt;- tkplot(make_ring(10), canvas.width=450, canvas.height=500)

canvas &lt;- tk_canvas(id)
padding &lt;- 20
coords &lt;- norm_coords(layout_in_circle(g), 0+padding, 450-padding,
                      50+padding, 500-padding)
tk_set_coords(id, coords)

width &lt;- as.numeric(tkcget(canvas, "-width"))
height &lt;- as.numeric(tkcget(canvas, "-height"))
tkcreate(canvas, "text", width/2, 25, text="My title",
         justify="center", font=tcltk::tkfont.create(family="helvetica",
         size=20,weight="bold"))
</pre>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.igraph">plot.igraph()</a></code>, <code><a href="#topic+layout">layout()</a></code>
</p>

<hr>
<h2 id='tkplot.canvas'>Interactive plotting of graphs</h2><span id='topic+tkplot.canvas'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.canvas()</code> was renamed to <code>tk_canvas()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.canvas(tkp.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.canvas_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
</table>

<hr>
<h2 id='tkplot.center'>Interactive plotting of graphs</h2><span id='topic+tkplot.center'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.center()</code> was renamed to <code>tk_center()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.center(tkp.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.center_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
</table>

<hr>
<h2 id='tkplot.close'>Interactive plotting of graphs</h2><span id='topic+tkplot.close'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.close()</code> was renamed to <code>tk_close()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.close(tkp.id, window.close = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.close_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
<tr><td><code id="tkplot.close_+3A_window.close">window.close</code></td>
<td>
<p>Leave this on the default value.</p>
</td></tr>
</table>

<hr>
<h2 id='tkplot.export.postscript'>Interactive plotting of graphs</h2><span id='topic+tkplot.export.postscript'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.export.postscript()</code> was renamed to <code>tk_postscript()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.export.postscript(tkp.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.export.postscript_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
</table>

<hr>
<h2 id='tkplot.fit.to.screen'>Interactive plotting of graphs</h2><span id='topic+tkplot.fit.to.screen'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.fit.to.screen()</code> was renamed to <code>tk_fit()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.fit.to.screen(tkp.id, width = NULL, height = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.fit.to.screen_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
<tr><td><code id="tkplot.fit.to.screen_+3A_width">width</code></td>
<td>
<p>The width of the rectangle for generating new coordinates.</p>
</td></tr>
<tr><td><code id="tkplot.fit.to.screen_+3A_height">height</code></td>
<td>
<p>The height of the rectangle for generating new coordinates.</p>
</td></tr>
</table>

<hr>
<h2 id='tkplot.getcoords'>Interactive plotting of graphs</h2><span id='topic+tkplot.getcoords'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.getcoords()</code> was renamed to <code>tk_coords()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.getcoords(tkp.id, norm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.getcoords_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
<tr><td><code id="tkplot.getcoords_+3A_norm">norm</code></td>
<td>
<p>Logical, should we norm the coordinates.</p>
</td></tr>
</table>

<hr>
<h2 id='tkplot.off'>Interactive plotting of graphs</h2><span id='topic+tkplot.off'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.off()</code> was renamed to <code>tk_off()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.off()
</code></pre>

<hr>
<h2 id='tkplot.reshape'>Interactive plotting of graphs</h2><span id='topic+tkplot.reshape'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.reshape()</code> was renamed to <code>tk_reshape()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.reshape(tkp.id, newlayout, ..., params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.reshape_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
<tr><td><code id="tkplot.reshape_+3A_newlayout">newlayout</code></td>
<td>
<p>The new layout, see the <code>layout</code> parameter of tkplot.</p>
</td></tr>
<tr><td><code id="tkplot.reshape_+3A_...">...</code></td>
<td>
<p>Additional plotting parameters. See <a href="#topic+igraph.plotting">igraph.plotting</a> for
the complete list.</p>
</td></tr>
<tr><td><code id="tkplot.reshape_+3A_params">params</code></td>
<td>
<p>Extra parameters in a list, to pass to the layout function.</p>
</td></tr>
</table>

<hr>
<h2 id='tkplot.rotate'>Interactive plotting of graphs</h2><span id='topic+tkplot.rotate'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.rotate()</code> was renamed to <code>tk_rotate()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.rotate(tkp.id, degree = NULL, rad = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.rotate_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
<tr><td><code id="tkplot.rotate_+3A_degree">degree</code></td>
<td>
<p>The degree to rotate the plot.</p>
</td></tr>
<tr><td><code id="tkplot.rotate_+3A_rad">rad</code></td>
<td>
<p>The degree to rotate the plot, in radian.</p>
</td></tr>
</table>

<hr>
<h2 id='tkplot.setcoords'>Interactive plotting of graphs</h2><span id='topic+tkplot.setcoords'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>tkplot.setcoords()</code> was renamed to <code>tk_set_coords()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkplot.setcoords(tkp.id, coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkplot.setcoords_+3A_tkp.id">tkp.id</code></td>
<td>
<p>The id of the tkplot window to close/reshape/etc.</p>
</td></tr>
<tr><td><code id="tkplot.setcoords_+3A_coords">coords</code></td>
<td>
<p>Two-column numeric matrix, the new coordinates of the
vertices, in absolute coordinates.</p>
</td></tr>
</table>

<hr>
<h2 id='to_prufer'>Convert a tree graph to its Prüfer sequence</h2><span id='topic+to_prufer'></span>

<h3>Description</h3>

<p><code>to_prufer()</code> converts a tree graph into its Prüfer sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_prufer(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_prufer_+3A_graph">graph</code></td>
<td>
<p>The graph to convert to a Prüfer sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Prüfer sequence of a tree graph with n labeled vertices is a sequence of
n-2 numbers, constructed as follows. If the graph has more than two vertices,
find a vertex with degree one, remove it from the tree and add the label of
the vertex that it was connected to to the sequence. Repeat until there are
only two vertices in the remaining graph.
</p>


<h3>Value</h3>

<p>The Prüfer sequence of the graph, represented as a numeric vector of
vertex IDs in the sequence.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_from_prufer">make_from_prufer()</a></code> to construct a graph from its
Prüfer sequence
</p>
<p>Other trees: 
<code><a href="#topic+is_forest">is_forest</a>()</code>,
<code><a href="#topic+is_tree">is_tree</a>()</code>,
<code><a href="#topic+make_from_prufer">make_from_prufer</a>()</code>,
<code><a href="#topic+sample_spanning_tree">sample_spanning_tree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_tree(13, 3)
to_prufer(g)

</code></pre>

<hr>
<h2 id='topo_sort'>Topological sorting of vertices in a graph</h2><span id='topic+topo_sort'></span>

<h3>Description</h3>

<p>A topological sorting of a directed acyclic graph is a linear ordering of
its nodes where each node comes before all nodes to which it has edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topo_sort(graph, mode = c("out", "all", "in"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topo_sort_+3A_graph">graph</code></td>
<td>
<p>The input graph, should be directed</p>
</td></tr>
<tr><td><code id="topo_sort_+3A_mode">mode</code></td>
<td>
<p>Specifies how to use the direction of the edges.  For
&ldquo;<code>out</code>&rdquo;, the sorting order ensures that each node comes before
all nodes to which it has edges, so nodes with no incoming edges go first.
For &ldquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rdquo;, it is quite the opposite: each node comes before all
nodes from which it receives edges. Nodes with no outgoing edges go first.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every DAG has at least one topological sort, and may have many.  This
function returns a possible topological sort among them. If the graph is not
acyclic (it has at least one cycle), a partial topological sort is returned
and a warning is issued.
</p>


<h3>Value</h3>

<p>A vertex sequence (by default, but see the <code>return.vs.es</code>
option of <code><a href="#topic+igraph_options">igraph_options()</a></code>) containing vertices in
topologically sorted order.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a> for the R interface
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_pa(100)
topo_sort(g)

</code></pre>

<hr>
<h2 id='topological.sort'>Topological sorting of vertices in a graph</h2><span id='topic+topological.sort'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>topological.sort()</code> was renamed to <code>topo_sort()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topological.sort(graph, mode = c("out", "all", "in"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topological.sort_+3A_graph">graph</code></td>
<td>
<p>The input graph, should be directed</p>
</td></tr>
<tr><td><code id="topological.sort_+3A_mode">mode</code></td>
<td>
<p>Specifies how to use the direction of the edges.  For
&ldquo;<code>out</code>&rdquo;, the sorting order ensures that each node comes before
all nodes to which it has edges, so nodes with no incoming edges go first.
For &ldquo;<code style="white-space: pre;">&#8288;in&#8288;</code>&rdquo;, it is quite the opposite: each node comes before all
nodes from which it receives edges. Nodes with no outgoing edges go first.</p>
</td></tr>
</table>

<hr>
<h2 id='transitivity'>Transitivity of a graph</h2><span id='topic+transitivity'></span>

<h3>Description</h3>

<p>Transitivity measures the probability that the adjacent vertices of a vertex
are connected. This is sometimes also called the clustering coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity(
  graph,
  type = c("undirected", "global", "globalundirected", "localundirected", "local",
    "average", "localaverage", "localaverageundirected", "barrat", "weighted"),
  vids = NULL,
  weights = NULL,
  isolates = c("NaN", "zero")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitivity_+3A_graph">graph</code></td>
<td>
<p>The graph to analyze.</p>
</td></tr>
<tr><td><code id="transitivity_+3A_type">type</code></td>
<td>
<p>The type of the transitivity to calculate. Possible values:
</p>
 <dl>
<dt>&quot;global&quot;</dt><dd><p>The global transitivity of an undirected
graph. This is simply the ratio of the count of triangles and connected triples
in the graph. In directed graphs, edge directions are ignored.</p>
</dd>
<dt>&quot;local&quot;</dt><dd><p>The local transitivity of an undirected graph. It is
calculated for each vertex given in the <code>vids</code> argument. The local
transitivity of a vertex is the ratio of the count of triangles connected to the
vertex and the triples centered on the vertex. In directed graphs, edge
directions are ignored.</p>
</dd>
<dt>&quot;undirected&quot;</dt><dd><p>This is the same as <code>global</code>.</p>
</dd>
<dt>&quot;globalundirected&quot;</dt><dd><p>This is the same as <code>global</code>.</p>
</dd>
<dt>&quot;localundirected&quot;</dt><dd><p>This is the same as <code>local</code>.</p>
</dd>
<dt>&quot;barrat&quot;</dt><dd><p>The weighted transitivity as defined by A.
Barrat. See details below.</p>
</dd>
<dt>&quot;weighted&quot;</dt><dd><p>The same as <code>barrat</code>.</p>
</dd> </dl>
</td></tr>
<tr><td><code id="transitivity_+3A_vids">vids</code></td>
<td>
<p>The vertex ids for the local transitivity will be calculated.
This will be ignored for global transitivity types.  The default value is
<code>NULL</code>, in this case all vertices are considered. It is slightly faster
to supply <code>NULL</code> here than <code>V(graph)</code>.</p>
</td></tr>
<tr><td><code id="transitivity_+3A_weights">weights</code></td>
<td>
<p>Optional weights for weighted transitivity. It is ignored for
other transitivity measures. If it is <code>NULL</code> (the default) and the
graph has a <code>weight</code> edge attribute, then it is used automatically.</p>
</td></tr>
<tr><td><code id="transitivity_+3A_isolates">isolates</code></td>
<td>
<p>Character scalar, for local versions of transitivity, it
defines how to treat vertices with degree zero and one.
If it is &lsquo;<code>NaN</code>&rsquo; then their local transitivity is
reported as <code>NaN</code> and they are not included in the averaging, for the
transitivity types that calculate an average. If there are no vertices with
degree two or higher, then the averaging will still result <code>NaN</code>. If it
is &lsquo;<code>zero</code>&rsquo;, then we report 0 transitivity for them, and they
are included in the averaging, if an average is calculated.
For the global transitivity, it controls how to handle graphs with
no connected triplets: <code>NaN</code> or zero will be returned according to
the respective setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that there are essentially two classes of transitivity measures, one is
a vertex-level, the other a graph level property.
</p>
<p>There are several generalizations of transitivity to weighted graphs, here
we use the definition by A. Barrat, this is a local vertex-level quantity,
its formula is
</p>
<p style="text-align: center;"><code class="reqn">C_i^w=\frac{1}{s_i(k_i-1)}\sum_{j,h}\frac{w_{ij}+w_{ih}}{2}a_{ij}a_{ih}a_{jh}</code>
</p>

<p><code class="reqn">s_i</code> is the strength of vertex <code class="reqn">i</code>, see
<code><a href="#topic+strength">strength()</a></code>, <code class="reqn">a_{ij}</code> are elements of the
adjacency matrix, <code class="reqn">k_i</code> is the vertex degree, <code class="reqn">w_{ij}</code>
are the weights.
</p>
<p>This formula gives back the normal not-weighted local transitivity if all
the edge weights are the same.
</p>
<p>The <code>barrat</code> type of transitivity does not work for graphs with
multiple and/or loop edges. If you want to calculate it for a directed
graph, call <code><a href="#topic+as.undirected">as.undirected()</a></code> with the <code>collapse</code> mode first.
</p>


<h3>Value</h3>

<p>For &lsquo;<code>global</code>&rsquo; a single number, or <code>NaN</code> if there
are no connected triples in the graph.
</p>
<p>For &lsquo;<code>local</code>&rsquo; a vector of transitivity scores, one for each
vertex in &lsquo;<code>vids</code>&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Wasserman, S., and Faust, K. (1994). <em>Social Network
Analysis: Methods and Applications.</em> Cambridge: Cambridge University Press.
</p>
<p>Alain Barrat, Marc Barthelemy, Romualdo Pastor-Satorras, Alessandro
Vespignani: The architecture of complex weighted networks, Proc. Natl. Acad.
Sci. USA 101, 3747 (2004)
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
transitivity(g)
g2 &lt;- sample_gnp(1000, 10 / 1000)
transitivity(g2) # this is about 10/1000

# Weighted version, the figure from the Barrat paper
gw &lt;- graph_from_literal(A - B:C:D:E, B - C:D, C - D)
E(gw)$weight &lt;- 1
E(gw)[V(gw)[name == "A"] %--% V(gw)[name == "E"]]$weight &lt;- 5
transitivity(gw, vids = "A", type = "local")
transitivity(gw, vids = "A", type = "weighted")

# Weighted reduces to "local" if weights are the same
gw2 &lt;- sample_gnp(1000, 10 / 1000)
E(gw2)$weight &lt;- 1
t1 &lt;- transitivity(gw2, type = "local")
t2 &lt;- transitivity(gw2, type = "weighted")
all(is.na(t1) == is.na(t2))
all(na.omit(t1 == t2))

</code></pre>

<hr>
<h2 id='triad_census'>Triad census, subgraphs with three vertices</h2><span id='topic+triad_census'></span>

<h3>Description</h3>

<p>This function counts the different induced subgraphs of three vertices in
a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triad_census(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triad_census_+3A_graph">graph</code></td>
<td>
<p>The input graph, it should be directed. An undirected graph
results a warning, and undefined results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Triad census was defined by David and Leinhardt (see References below).
Every triple of vertices (A, B, C) are classified into the 16 possible
states: </p>
 <dl>
<dt>003</dt><dd><p>A,B,C, the empty graph.</p>
</dd> <dt>012</dt><dd><p>A-&gt;B, C,
the graph with a single directed edge.</p>
</dd> <dt>102</dt><dd><p>A&lt;-&gt;B, C, the graph with
a mutual connection between two vertices.</p>
</dd> <dt>021D</dt><dd><p>A&lt;-B-&gt;C, the
out-star.</p>
</dd> <dt>021U</dt><dd><p>A-&gt;B&lt;-C, the in-star.</p>
</dd> <dt>021C</dt><dd><p>A-&gt;B-&gt;C, directed
line.</p>
</dd> <dt>111D</dt><dd><p>A&lt;-&gt;B&lt;-C.</p>
</dd> <dt>111U</dt><dd><p>A&lt;-&gt;B-&gt;C.</p>
</dd> <dt>030T</dt><dd><p>A-&gt;B&lt;-C,
A-&gt;C.</p>
</dd> <dt>030C</dt><dd><p>A&lt;-B&lt;-C, A-&gt;C.</p>
</dd> <dt>201</dt><dd><p>A&lt;-&gt;B&lt;-&gt;C.</p>
</dd>
<dt>120D</dt><dd><p>A&lt;-B-&gt;C, A&lt;-&gt;C.</p>
</dd> <dt>120U</dt><dd><p>A-&gt;B&lt;-C, A&lt;-&gt;C.</p>
</dd>
<dt>120C</dt><dd><p>A-&gt;B-&gt;C, A&lt;-&gt;C.</p>
</dd> <dt>210</dt><dd><p>A-&gt;B&lt;-&gt;C, A&lt;-&gt;C.</p>
</dd>
<dt>300</dt><dd><p>A&lt;-&gt;B&lt;-&gt;C, A&lt;-&gt;C, the complete graph.</p>
</dd> </dl>

<p>This functions uses the RANDESU motif finder algorithm to find and count the
subgraphs, see <code><a href="#topic+motifs">motifs()</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector, the subgraph counts, in the order given in the
above description.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>See also Davis, J.A. and Leinhardt, S.  (1972).  The Structure
of Positive Interpersonal Relations in Small Groups.  In J. Berger (Ed.),
Sociological Theories in Progress, Volume 2, 218-251.  Boston: Houghton
Mifflin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dyad_census">dyad_census()</a></code> for classifying binary relationships,
<code><a href="#topic+motifs">motifs()</a></code> for the underlying implementation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnm(15, 45, directed = TRUE)
triad_census(g)
</code></pre>

<hr>
<h2 id='triad.census'>Triad census, subgraphs with three vertices</h2><span id='topic+triad.census'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>triad.census()</code> was renamed to <code>triad_census()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triad.census(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triad.census_+3A_graph">graph</code></td>
<td>
<p>The input graph, it should be directed. An undirected graph
results a warning, and undefined results.</p>
</td></tr>
</table>

<hr>
<h2 id='triangles'>Find triangles in graphs</h2><span id='topic+triangles'></span><span id='topic+count_triangles'></span>

<h3>Description</h3>

<p>Count how many triangles a vertex is part of, in a graph, or just list the
triangles of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangles(graph)

count_triangles(graph, vids = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangles_+3A_graph">graph</code></td>
<td>
<p>The input graph. It might be directed, but edge directions are
ignored.</p>
</td></tr>
<tr><td><code id="triangles_+3A_vids">vids</code></td>
<td>
<p>The vertices to query, all of them by default. This might be a
vector of numeric ids, or a character vector of symbolic vertex names for
named graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>triangles()</code> lists all triangles of a graph. For efficiency, all
triangles are returned in a single vector. The first three vertices belong
to the first triangle, etc.
</p>
<p><code>count_triangles()</code> counts how many triangles a vertex is part of.
</p>


<h3>Value</h3>

<p>For <code>triangles()</code> a numeric vector of vertex ids, the first three
vertices belong to the first triangle found, etc.
</p>
<p>For <code>count_triangles()</code> a numeric vector, the number of triangles for all
vertices queried.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+transitivity">transitivity()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A small graph
kite &lt;- make_graph("Krackhardt_Kite")
plot(kite)
matrix(triangles(kite), nrow = 3)

## Adjacenct triangles
atri &lt;- count_triangles(kite)
plot(kite, vertex.label = atri)

## Always true
sum(count_triangles(kite)) == length(triangles(kite))

## Should match, local transitivity is the
## number of adjacent triangles divided by the number
## of adjacency triples
transitivity(kite, type = "local")
count_triangles(kite) / (degree(kite) * (degree(kite) - 1) / 2)
</code></pre>

<hr>
<h2 id='unfold_tree'>Convert a general graph into a forest</h2><span id='topic+unfold_tree'></span>

<h3>Description</h3>

<p>Perform a breadth-first search on a graph and convert it into a tree or
forest by replicating vertices that were found more than once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfold_tree(graph, mode = c("all", "out", "in", "total"), roots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfold_tree_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be either directed or undirected.</p>
</td></tr>
<tr><td><code id="unfold_tree_+3A_mode">mode</code></td>
<td>
<p>Character string, defined the types of the paths used for the
breadth-first search. &ldquo;out&rdquo; follows the outgoing, &ldquo;in&rdquo; the
incoming edges, &ldquo;all&rdquo; and &ldquo;total&rdquo; both of them. This argument
is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="unfold_tree_+3A_roots">roots</code></td>
<td>
<p>A vector giving the vertices from which the breadth-first
search is performed. Typically it contains one vertex per component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A forest is a graph, whose components are trees.
</p>
<p>The <code>roots</code> vector can be calculated by simply doing a topological sort
in all components of the graph, see the examples below.
</p>


<h3>Value</h3>

<p>A list with two components: </p>
<table>
<tr><td><code>tree</code></td>
<td>
<p>The result, an <code>igraph</code>
object, a tree or a forest.</p>
</td></tr> <tr><td><code>vertex_index</code></td>
<td>
<p>A numeric vector, it gives
a mapping from the vertices of the new graph to the vertices of the old
graph.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_tree(10) %du% make_tree(10)
V(g)$id &lt;- seq_len(vcount(g)) - 1
roots &lt;- sapply(decompose(g), function(x) {
  V(x)$id[topo_sort(x)[1] + 1]
})
tree &lt;- unfold_tree(g, roots = roots)

</code></pre>

<hr>
<h2 id='unfold.tree'>Convert a general graph into a forest</h2><span id='topic+unfold.tree'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>unfold.tree()</code> was renamed to <code>unfold_tree()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfold.tree(graph, mode = c("all", "out", "in", "total"), roots)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfold.tree_+3A_graph">graph</code></td>
<td>
<p>The input graph, it can be either directed or undirected.</p>
</td></tr>
<tr><td><code id="unfold.tree_+3A_mode">mode</code></td>
<td>
<p>Character string, defined the types of the paths used for the
breadth-first search. &ldquo;out&rdquo; follows the outgoing, &ldquo;in&rdquo; the
incoming edges, &ldquo;all&rdquo; and &ldquo;total&rdquo; both of them. This argument
is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="unfold.tree_+3A_roots">roots</code></td>
<td>
<p>A vector giving the vertices from which the breadth-first
search is performed. Typically it contains one vertex per component.</p>
</td></tr>
</table>

<hr>
<h2 id='union'>Union of two or more sets</h2><span id='topic+union'></span>

<h3>Description</h3>

<p>This is an S3 generic function. See <code>methods("union")</code>
for the actual implementations for various S3 classes. Initially
it is implemented for igraph graphs and igraph vertex and edge
sequences. See
<code><a href="#topic+union.igraph">union.igraph()</a></code>, and
<code><a href="#topic+union.igraph.vs">union.igraph.vs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>union(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union_+3A_...">...</code></td>
<td>
<p>Arguments, their number and interpretation depends on
the function that implements <code>union()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depends on the function that implements this method.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>

<hr>
<h2 id='union.igraph'>Union of graphs</h2><span id='topic+union.igraph'></span><span id='topic++25u+25'></span>

<h3>Description</h3>

<p>The union of two or more graphs are created. The graphs may have identical
or overlapping vertex sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph'
union(..., byname = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union.igraph_+3A_...">...</code></td>
<td>
<p>Graph objects or lists of graph objects.</p>
</td></tr>
<tr><td><code id="union.igraph_+3A_byname">byname</code></td>
<td>
<p>A logical scalar, or the character scalar <code>auto</code>. Whether
to perform the operation based on symbolic vertex names. If it is
<code>auto</code>, that means <code>TRUE</code> if all graphs are named and <code>FALSE</code>
otherwise. A warning is generated if <code>auto</code> and some (but not all)
graphs are named.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>union()</code> creates the union of two or more graphs.  Edges which are
included in at least one graph will be part of the new graph. This function
can be also used via the <code style="white-space: pre;">&#8288;%u%&#8288;</code> operator.
</p>
<p>If the <code>byname</code> argument is <code>TRUE</code> (or <code>auto</code> and all graphs
are named), then the operation is performed on symbolic vertex names instead
of the internal numeric vertex ids.
</p>
<p><code>union()</code> keeps the attributes of all graphs. All graph, vertex and
edge attributes are copied to the result. If an attribute is present in
multiple graphs and would result a name clash, then this attribute is
renamed by adding suffixes: _1, _2, etc.
</p>
<p>The <code>name</code> vertex attribute is treated specially if the operation is
performed based on symbolic vertex names. In this case <code>name</code> must be
present in all graphs, and it is not renamed in the result graph.
</p>
<p>An error is generated if some input graphs are directed and others are
undirected.
</p>


<h3>Value</h3>

<p>A new graph object.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+vertex">vertex</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Union of two social networks with overlapping sets of actors
net1 &lt;- graph_from_literal(
  D - A:B:F:G, A - C - F - A, B - E - G - B, A - B, F - G,
  H - F:G, H - I - J
)
net2 &lt;- graph_from_literal(D - A:F:Y, B - A - X - F - H - Z, F - Y)
print_all(net1 %u% net2)
</code></pre>

<hr>
<h2 id='union.igraph.es'>Union of edge sequences</h2><span id='topic+union.igraph.es'></span>

<h3>Description</h3>

<p>Union of edge sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
union(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union.igraph.es_+3A_...">...</code></td>
<td>
<p>The edge sequences to take the union of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They must belong to the same graph. Note that this function has
&lsquo;set&rsquo; semantics and the multiplicity of edges is lost in the
result. (This is to match the behavior of the based <code>unique</code>
function.)
</p>


<h3>Value</h3>

<p>An edge sequence that contains all edges in the given
sequences, exactly once.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
union(E(g)[1:6], E(g)[5:9], E(g)["A|J"])
</code></pre>

<hr>
<h2 id='union.igraph.vs'>Union of vertex sequences</h2><span id='topic+union.igraph.vs'></span>

<h3>Description</h3>

<p>Union of vertex sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
union(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union.igraph.vs_+3A_...">...</code></td>
<td>
<p>The vertex sequences to take the union of.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They must belong to the same graph. Note that this function has
&lsquo;set&rsquo; semantics and the multiplicity of vertices is lost in the
result. (This is to match the behavior of the based <code>unique</code>
function.)
</p>


<h3>Value</h3>

<p>A vertex sequence that contains all vertices in the given
sequences, exactly once.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
union(V(g)[1:6], V(g)[5:10])
</code></pre>

<hr>
<h2 id='unique.igraph.es'>Remove duplicate edges from an edge sequence</h2><span id='topic+unique.igraph.es'></span>

<h3>Description</h3>

<p>Remove duplicate edges from an edge sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.es'
unique(x, incomparables = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique.igraph.es_+3A_x">x</code></td>
<td>
<p>An edge sequence.</p>
</td></tr>
<tr><td><code id="unique.igraph.es_+3A_incomparables">incomparables</code></td>
<td>
<p>a vector of values that cannot be compared.
Passed to base function <code>duplicated</code>. See details there.</p>
</td></tr>
<tr><td><code id="unique.igraph.es_+3A_...">...</code></td>
<td>
<p>Passed to base function <code>duplicated()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge sequence with the duplicate vertices removed.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.vs">unique.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
E(g)[1, 1:5, 1:10, 5:10]
E(g)[1, 1:5, 1:10, 5:10] %&gt;% unique()
</code></pre>

<hr>
<h2 id='unique.igraph.vs'>Remove duplicate vertices from a vertex sequence</h2><span id='topic+unique.igraph.vs'></span>

<h3>Description</h3>

<p>Remove duplicate vertices from a vertex sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'igraph.vs'
unique(x, incomparables = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique.igraph.vs_+3A_x">x</code></td>
<td>
<p>A vertex sequence.</p>
</td></tr>
<tr><td><code id="unique.igraph.vs_+3A_incomparables">incomparables</code></td>
<td>
<p>a vector of values that cannot be compared.
Passed to base function <code>duplicated</code>. See details there.</p>
</td></tr>
<tr><td><code id="unique.igraph.vs_+3A_...">...</code></td>
<td>
<p>Passed to base function <code>duplicated()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vertex sequence with the duplicate vertices removed.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequence operations: 
<code><a href="#topic+c.igraph.es">c.igraph.es</a>()</code>,
<code><a href="#topic+c.igraph.vs">c.igraph.vs</a>()</code>,
<code><a href="#topic+difference.igraph.es">difference.igraph.es</a>()</code>,
<code><a href="#topic+difference.igraph.vs">difference.igraph.vs</a>()</code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+intersection.igraph.es">intersection.igraph.es</a>()</code>,
<code><a href="#topic+intersection.igraph.vs">intersection.igraph.vs</a>()</code>,
<code><a href="#topic+rev.igraph.es">rev.igraph.es</a>()</code>,
<code><a href="#topic+rev.igraph.vs">rev.igraph.vs</a>()</code>,
<code><a href="#topic+union.igraph.es">union.igraph.es</a>()</code>,
<code><a href="#topic+union.igraph.vs">union.igraph.vs</a>()</code>,
<code><a href="#topic+unique.igraph.es">unique.igraph.es</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10]))
V(g)[1, 1:5, 1:10, 5:10]
V(g)[1, 1:5, 1:10, 5:10] %&gt;% unique()
</code></pre>

<hr>
<h2 id='upgrade_graph'>igraph data structure versions</h2><span id='topic+upgrade_graph'></span>

<h3>Description</h3>

<p>igraph's internal data representation changes sometimes between
versions. This means that it is not possible to use igraph objects
that were created (and possibly saved to a file) with an older
igraph version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upgrade_graph(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upgrade_graph_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+graph_version">graph_version()</a></code> queries the current data format,
or the data format of a possibly older igraph graph.
</p>
<p><code>upgrade_graph()</code> can convert an older data format
to the current one.
</p>


<h3>Value</h3>

<p>The graph in the current format.
</p>


<h3>See Also</h3>

<p>graph_version to check the current data format version
or the version of a graph.
</p>
<p>Other versions: 
<code><a href="#topic+graph_version">graph_version</a>()</code>
</p>

<hr>
<h2 id='V'>Vertices of a graph</h2><span id='topic+V'></span>

<h3>Description</h3>

<p>Create a vertex sequence (vs) containing all vertices of a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>V(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="V_+3A_graph">graph</code></td>
<td>
<p>The graph</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A vertex sequence is just what the name says it is: a sequence of
vertices. Vertex sequences are usually used as igraph function arguments
that refer to vertices of a graph.
</p>
<p>A vertex sequence is tied to the graph it refers to: it really denoted
the specific vertices of that graph, and cannot be used together with
another graph.
</p>
<p>At the implementation level, a vertex sequence is simply a vector
containing numeric vertex ids, but it has a special class attribute
which makes it possible to perform graph specific operations on it, like
selecting a subset of the vertices based on graph structure, or vertex
attributes.
</p>
<p>A vertex sequence is most often created by the <code>V()</code> function. The
result of this includes all vertices in increasing vertex id order. A
vertex sequence can be indexed by a numeric vector, just like a regular
R vector. See <code><a href="#topic++5B.igraph.vs">[.igraph.vs</a></code> and additional links to other
vertex sequence operations below.
</p>


<h3>Value</h3>

<p>A vertex sequence containing all vertices, in the order
of their numeric vertex ids.
</p>


<h3>Indexing vertex sequences</h3>

<p>Vertex sequences mostly behave like regular vectors, but there are some
additional indexing operations that are specific for them;
e.g. selecting vertices based on graph structure, or based on vertex
attributes. See <code><a href="#topic++5B.igraph.vs">[.igraph.vs</a></code> for details.
</p>


<h3>Querying or setting attributes</h3>

<p>Vertex sequences can be used to query or set attributes for the
vertices in the sequence. See <code><a href="#topic++24.igraph.vs">$.igraph.vs()</a></code> for details.
</p>


<h3>See Also</h3>

<p>Other vertex and edge sequences: 
<code><a href="#topic+E">E</a>()</code>,
<code><a href="#topic+as_ids">as_ids</a>()</code>,
<code><a href="#topic+igraph-es-attributes">igraph-es-attributes</a></code>,
<code><a href="#topic+igraph-es-indexing">igraph-es-indexing</a></code>,
<code><a href="#topic+igraph-es-indexing2">igraph-es-indexing2</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+igraph-vs-indexing">igraph-vs-indexing</a></code>,
<code><a href="#topic+igraph-vs-indexing2">igraph-vs-indexing2</a></code>,
<code><a href="#topic+print.igraph.es">print.igraph.es</a>()</code>,
<code><a href="#topic+print.igraph.vs">print.igraph.vs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Vertex ids of an unnamed graph
g &lt;- make_ring(10)
V(g)

# Vertex ids of a named graph
g2 &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = letters[1:10])
V(g2)
</code></pre>

<hr>
<h2 id='vertex'>Helper function for adding and deleting vertices</h2><span id='topic+vertex'></span><span id='topic+vertices'></span>

<h3>Description</h3>

<p>This is a helper function that simplifies adding and deleting
vertices to/from graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex(...)

vertices(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_+3A_...">...</code></td>
<td>
<p>See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vertices()</code> is an alias for <code>vertex()</code>.
</p>
<p>When adding vertices via <code>+</code>, all unnamed arguments are interpreted
as vertex names of the new vertices. Named arguments are interpreted as
vertex attributes for the new vertices.
</p>
<p>When deleting vertices via <code>-</code>, all arguments of <code>vertex()</code> (or
<code>vertices()</code>) are concatenated via <code>c()</code> and passed to
<code><a href="#topic+delete_vertices">delete_vertices()</a></code>.
</p>


<h3>Value</h3>

<p>A special object that can be used with together with
igraph graphs and the plus and minus operators.
</p>


<h3>See Also</h3>

<p>Other functions for manipulating graph structure: 
<code><a href="#topic++2B.igraph">+.igraph</a>()</code>,
<code><a href="#topic+add_edges">add_edges</a>()</code>,
<code><a href="#topic+add_vertices">add_vertices</a>()</code>,
<code><a href="#topic+complementer">complementer</a>()</code>,
<code><a href="#topic+compose">compose</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+contract">contract</a>()</code>,
<code><a href="#topic+delete_edges">delete_edges</a>()</code>,
<code><a href="#topic+delete_vertices">delete_vertices</a>()</code>,
<code><a href="#topic+difference">difference</a>()</code>,
<code><a href="#topic+difference.igraph">difference.igraph</a>()</code>,
<code><a href="#topic+disjoint_union">disjoint_union</a>()</code>,
<code><a href="#topic+edge">edge</a>()</code>,
<code><a href="#topic+igraph-minus">igraph-minus</a></code>,
<code><a href="#topic+intersection">intersection</a>()</code>,
<code><a href="#topic+intersection.igraph">intersection.igraph</a>()</code>,
<code><a href="#topic+path">path</a>()</code>,
<code><a href="#topic+permute">permute</a>()</code>,
<code><a href="#topic+rep.igraph">rep.igraph</a>()</code>,
<code><a href="#topic+reverse_edges">reverse_edges</a>()</code>,
<code><a href="#topic+simplify">simplify</a>()</code>,
<code><a href="#topic+union">union</a>()</code>,
<code><a href="#topic+union.igraph">union.igraph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_(ring(10), with_vertex_(name = LETTERS[1:10])) +
  vertices("X", "Y")
g
plot(g)
</code></pre>

<hr>
<h2 id='vertex_attr'>Query vertex attributes of a graph</h2><span id='topic+vertex_attr'></span><span id='topic+vertex.attributes'></span>

<h3>Description</h3>

<p>Query vertex attributes of a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_attr(graph, name, index = V(graph))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_attr_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="vertex_attr_+3A_name">name</code></td>
<td>
<p>Name of the attribute to query. If missing, then
all vertex attributes are returned in a list.</p>
</td></tr>
<tr><td><code id="vertex_attr_+3A_index">index</code></td>
<td>
<p>An optional vertex sequence to query the attribute only
for these vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the vertex attribute, or the list of
all vertex attributes, if <code>name</code> is missing.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_vertex_attr("color", value = "red") %&gt;%
  set_vertex_attr("label", value = letters[1:10])
vertex_attr(g, "label")
vertex_attr(g)
plot(g)
</code></pre>

<hr>
<h2 id='vertex_attr_names'>List names of vertex attributes</h2><span id='topic+vertex_attr_names'></span>

<h3>Description</h3>

<p>List names of vertex attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_attr_names(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_attr_names_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector, the names of the vertex attributes.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr+3C-">vertex_attr&lt;-</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10) %&gt;%
  set_vertex_attr("name", value = LETTERS[1:10]) %&gt;%
  set_vertex_attr("color", value = rep("green", 10))
vertex_attr_names(g)
plot(g)
</code></pre>

<hr>
<h2 id='vertex_attr+26lt+3B-'>Set one or more vertex attributes</h2><span id='topic+vertex_attr+3C-'></span><span id='topic+vertex.attributes+3C-'></span>

<h3>Description</h3>

<p>Set one or more vertex attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_attr(graph, name, index = V(graph)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_attr+2B26lt+2B3B-_+3A_graph">graph</code></td>
<td>
<p>The graph.</p>
</td></tr>
<tr><td><code id="vertex_attr+2B26lt+2B3B-_+3A_name">name</code></td>
<td>
<p>The name of the vertex attribute to set. If missing,
then <code>value</code> must be a named list, and its entries are
set as vertex attributes.</p>
</td></tr>
<tr><td><code id="vertex_attr+2B26lt+2B3B-_+3A_index">index</code></td>
<td>
<p>An optional vertex sequence to set the attributes
of a subset of vertices.</p>
</td></tr>
<tr><td><code id="vertex_attr+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>The new value of the attribute(s) for all
(or <code>index</code>) vertices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graph, with the vertex attribute(s) added or set.
</p>


<h3>See Also</h3>

<p>Vertex, edge and graph attributes
<code><a href="#topic+delete_edge_attr">delete_edge_attr</a>()</code>,
<code><a href="#topic+delete_graph_attr">delete_graph_attr</a>()</code>,
<code><a href="#topic+delete_vertex_attr">delete_vertex_attr</a>()</code>,
<code><a href="#topic+edge_attr">edge_attr</a>()</code>,
<code><a href="#topic+edge_attr+3C-">edge_attr&lt;-</a>()</code>,
<code><a href="#topic+edge_attr_names">edge_attr_names</a>()</code>,
<code><a href="#topic+graph_attr">graph_attr</a>()</code>,
<code><a href="#topic+graph_attr+3C-">graph_attr&lt;-</a>()</code>,
<code><a href="#topic+graph_attr_names">graph_attr_names</a>()</code>,
<code><a href="#topic+igraph-attribute-combination">igraph-attribute-combination</a></code>,
<code><a href="#topic+igraph-dollar">igraph-dollar</a></code>,
<code><a href="#topic+igraph-vs-attributes">igraph-vs-attributes</a></code>,
<code><a href="#topic+set_edge_attr">set_edge_attr</a>()</code>,
<code><a href="#topic+set_graph_attr">set_graph_attr</a>()</code>,
<code><a href="#topic+set_vertex_attr">set_vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr">vertex_attr</a>()</code>,
<code><a href="#topic+vertex_attr_names">vertex_attr_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- make_ring(10)
vertex_attr(g) &lt;- list(
  name = LETTERS[1:10],
  color = rep("yellow", gorder(g))
)
vertex_attr(g, "label") &lt;- V(g)$name
g
plot(g)
</code></pre>

<hr>
<h2 id='vertex_connectivity'>Vertex connectivity</h2><span id='topic+vertex_connectivity'></span><span id='topic+cohesion'></span><span id='topic+vertex_disjoint_paths'></span><span id='topic+cohesion.igraph'></span>

<h3>Description</h3>

<p>The vertex connectivity of a graph or two vertices, this is recently also
called group cohesion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex_connectivity(graph, source = NULL, target = NULL, checks = TRUE)

vertex_disjoint_paths(graph, source = NULL, target = NULL)

## S3 method for class 'igraph'
cohesion(x, checks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex_connectivity_+3A_graph">graph</code>, <code id="vertex_connectivity_+3A_x">x</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="vertex_connectivity_+3A_source">source</code></td>
<td>
<p>The id of the source vertex, for <code>vertex_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="vertex_connectivity_+3A_target">target</code></td>
<td>
<p>The id of the target vertex, for <code>vertex_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="vertex_connectivity_+3A_checks">checks</code></td>
<td>
<p>Logical constant. Whether to check that the graph is connected
and also the degree of the vertices. If the graph is not (strongly)
connected then the connectivity is obviously zero. Otherwise if the minimum
degree is one then the vertex connectivity is also one. It is a good idea to
perform these checks, as they can be done quickly compared to the
connectivity calculation itself.  They were suggested by Peter McMahan,
thanks Peter.</p>
</td></tr>
<tr><td><code id="vertex_connectivity_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vertex connectivity of two vertices (<code>source</code> and <code>target</code>) in
a graph is the minimum number of vertices that must be deleted to
eliminate all (directed) paths from <code>source</code> to <code>target</code>.
<code>vertex_connectivity()</code> calculates this quantity if both the
<code>source</code> and <code>target</code> arguments are given and they're not
<code>NULL</code>.
</p>
<p>The vertex connectivity of a pair is the same as the number
of different (i.e. node-independent) paths from source to
target, assuming no direct edges between them.
</p>
<p>The vertex connectivity of a graph is the minimum vertex connectivity of all
(ordered) pairs of vertices in the graph. In other words this is the minimum
number of vertices needed to remove to make the graph not strongly
connected. (If the graph is not strongly connected then this is zero.)
<code>vertex_connectivity()</code> calculates this quantity if neither the
<code>source</code> nor <code>target</code> arguments are given. (I.e. they are both
<code>NULL</code>.)
</p>
<p>A set of vertex disjoint directed paths from <code>source</code> to <code>vertex</code>
is a set of directed paths between them whose vertices do not contain common
vertices (apart from <code>source</code> and <code>target</code>). The maximum number of
vertex disjoint paths between two vertices is the same as their vertex
connectivity in most cases (if the two vertices are not connected by an
edge).
</p>
<p>The cohesion of a graph (as defined by White and Harary, see references), is
the vertex connectivity of the graph. This is calculated by
<code>cohesion()</code>.
</p>
<p>These three functions essentially calculate the same measure(s), more
precisely <code>vertex_connectivity()</code> is the most general, the other two are
included only for the ease of using more descriptive function names.
</p>


<h3>Value</h3>

<p>A scalar real value.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>White, Douglas R and Frank Harary 2001. The Cohesiveness of
Blocks In Social Networks: Node Connectivity and Conditional Density.
<em>Sociological Methodology</em> 31 (1) : 305-359.
</p>


<h3>See Also</h3>

<p>Other flow: 
<code><a href="#topic+dominator_tree">dominator_tree</a>()</code>,
<code><a href="#topic+edge_connectivity">edge_connectivity</a>()</code>,
<code><a href="#topic+is_min_separator">is_min_separator</a>()</code>,
<code><a href="#topic+is_separator">is_separator</a>()</code>,
<code><a href="#topic+max_flow">max_flow</a>()</code>,
<code><a href="#topic+min_cut">min_cut</a>()</code>,
<code><a href="#topic+min_separators">min_separators</a>()</code>,
<code><a href="#topic+min_st_separators">min_st_separators</a>()</code>,
<code><a href="#topic+st_cuts">st_cuts</a>()</code>,
<code><a href="#topic+st_min_cuts">st_min_cuts</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_pa(100, m = 1)
g &lt;- delete_edges(g, E(g)[100 %--% 1])
g2 &lt;- sample_pa(100, m = 5)
g2 &lt;- delete_edges(g2, E(g2)[100 %--% 1])
vertex_connectivity(g, 100, 1)
vertex_connectivity(g2, 100, 1)
vertex_disjoint_paths(g2, 100, 1)

g &lt;- sample_gnp(50, 5 / 50)
g &lt;- as.directed(g)
g &lt;- induced_subgraph(g, subcomponent(g, 1))
cohesion(g)

</code></pre>

<hr>
<h2 id='vertex.connectivity'>Vertex connectivity</h2><span id='topic+vertex.connectivity'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>vertex.connectivity()</code> was renamed to <code>vertex_connectivity()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex.connectivity(graph, source = NULL, target = NULL, checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex.connectivity_+3A_source">source</code></td>
<td>
<p>The id of the source vertex, for <code>vertex_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="vertex.connectivity_+3A_target">target</code></td>
<td>
<p>The id of the target vertex, for <code>vertex_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="vertex.connectivity_+3A_checks">checks</code></td>
<td>
<p>Logical constant. Whether to check that the graph is connected
and also the degree of the vertices. If the graph is not (strongly)
connected then the connectivity is obviously zero. Otherwise if the minimum
degree is one then the vertex connectivity is also one. It is a good idea to
perform these checks, as they can be done quickly compared to the
connectivity calculation itself.  They were suggested by Peter McMahan,
thanks Peter.</p>
</td></tr>
</table>

<hr>
<h2 id='vertex.disjoint.paths'>Vertex connectivity</h2><span id='topic+vertex.disjoint.paths'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>vertex.disjoint.paths()</code> was renamed to <code>vertex_disjoint_paths()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex.disjoint.paths(graph, source = NULL, target = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex.disjoint.paths_+3A_source">source</code></td>
<td>
<p>The id of the source vertex, for <code>vertex_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
<tr><td><code id="vertex.disjoint.paths_+3A_target">target</code></td>
<td>
<p>The id of the target vertex, for <code>vertex_connectivity()</code> it
can be <code>NULL</code>, see details below.</p>
</td></tr>
</table>

<hr>
<h2 id='vertex.shapes'>Various vertex shapes when plotting igraph graphs</h2><span id='topic+vertex.shapes'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>vertex.shapes()</code> was renamed to <code>shapes()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertex.shapes(shape = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertex.shapes_+3A_shape">shape</code></td>
<td>
<p>Character scalar, name of a vertex shape. If it is
<code>NULL</code> for <code>shapes()</code>, then the names of all defined
vertex shapes are returned.</p>
</td></tr>
</table>

<hr>
<h2 id='voronoi_cells'>Voronoi partitioning of a graph</h2><span id='topic+voronoi_cells'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This function partitions the vertices of a graph based on a set of generator
vertices. Each vertex is assigned to the generator vertex from (or to) which
it is closest.
</p>
<p><code><a href="#topic+groups">groups()</a></code> may be used on the output of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voronoi_cells(
  graph,
  generators,
  ...,
  weights = NULL,
  mode = c("out", "in", "all", "total"),
  tiebreaker = c("random", "first", "last")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi_cells_+3A_graph">graph</code></td>
<td>
<p>The graph to partition into Voronoi cells.</p>
</td></tr>
<tr><td><code id="voronoi_cells_+3A_generators">generators</code></td>
<td>
<p>The generator vertices of the Voronoi cells.</p>
</td></tr>
<tr><td><code id="voronoi_cells_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="voronoi_cells_+3A_weights">weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then the
attribute is used. If this is <code>NA</code> then no weights are used (even if
the graph has a <code>weight</code> attribute).</p>
</td></tr>
<tr><td><code id="voronoi_cells_+3A_mode">mode</code></td>
<td>
<p>Character string. In directed graphs, whether to compute
distances from generator vertices to other vertices (<code>"out"</code>), to
generator vertices from other vertices (<code>"in"</code>), or ignore edge
directions entirely (<code>"all"</code>). Ignored in undirected graphs.</p>
</td></tr>
<tr><td><code id="voronoi_cells_+3A_tiebreaker">tiebreaker</code></td>
<td>
<p>Character string that specifies what to do when a vertex
is at the same distance from multiple generators. <code>"random"</code> assigns
a minimal-distance generator randomly, <code>"first"</code> takes the first one,
and <code>"last"</code> takes the last one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with two components:
</p>
<table>
<tr><td><code>membership</code></td>
<td>
<p>numeric vector giving the cluster id to which each vertex
belongs.</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>numeric vector giving the distance of each vertex from its
generator</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+distances">distances()</a></code>
</p>
<p>Community detection
<code><a href="#topic+as_membership">as_membership</a>()</code>,
<code><a href="#topic+cluster_edge_betweenness">cluster_edge_betweenness</a>()</code>,
<code><a href="#topic+cluster_fast_greedy">cluster_fast_greedy</a>()</code>,
<code><a href="#topic+cluster_fluid_communities">cluster_fluid_communities</a>()</code>,
<code><a href="#topic+cluster_infomap">cluster_infomap</a>()</code>,
<code><a href="#topic+cluster_label_prop">cluster_label_prop</a>()</code>,
<code><a href="#topic+cluster_leading_eigen">cluster_leading_eigen</a>()</code>,
<code><a href="#topic+cluster_leiden">cluster_leiden</a>()</code>,
<code><a href="#topic+cluster_louvain">cluster_louvain</a>()</code>,
<code><a href="#topic+cluster_optimal">cluster_optimal</a>()</code>,
<code><a href="#topic+cluster_spinglass">cluster_spinglass</a>()</code>,
<code><a href="#topic+cluster_walktrap">cluster_walktrap</a>()</code>,
<code><a href="#topic+compare">compare</a>()</code>,
<code><a href="#topic+groups">groups</a>()</code>,
<code><a href="#topic+make_clusters">make_clusters</a>()</code>,
<code><a href="#topic+membership">membership</a>()</code>,
<code><a href="#topic+modularity.igraph">modularity.igraph</a>()</code>,
<code><a href="#topic+plot_dendrogram">plot_dendrogram</a>()</code>,
<code><a href="#topic+split_join_distance">split_join_distance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_lattice(c(10,10))
clu &lt;- voronoi_cells(g, c(25, 43, 67))
groups(clu)
plot(g, vertex.color=clu$membership)

</code></pre>

<hr>
<h2 id='walktrap.community'>Community structure via short random walks</h2><span id='topic+walktrap.community'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>walktrap.community()</code> was renamed to <code>cluster_walktrap()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walktrap.community(
  graph,
  weights = NULL,
  steps = 4,
  merges = TRUE,
  modularity = TRUE,
  membership = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="walktrap.community_+3A_graph">graph</code></td>
<td>
<p>The input graph, edge directions are ignored in directed
graphs.</p>
</td></tr>
<tr><td><code id="walktrap.community_+3A_weights">weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
&lsquo;weight&rsquo; edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a &lsquo;weight&rsquo; edge
attribute, but you don't want to use it for community detection. Larger edge
weights increase the probability that an edge is selected by the random
walker. In other words, larger edge weights correspond to stronger connections.</p>
</td></tr>
<tr><td><code id="walktrap.community_+3A_steps">steps</code></td>
<td>
<p>The length of the random walks to perform.</p>
</td></tr>
<tr><td><code id="walktrap.community_+3A_merges">merges</code></td>
<td>
<p>Logical scalar, whether to include the merge matrix in the
result.</p>
</td></tr>
<tr><td><code id="walktrap.community_+3A_modularity">modularity</code></td>
<td>
<p>Logical scalar, whether to include the vector of the
modularity scores in the result. If the <code>membership</code> argument is true,
then it will always be calculated.</p>
</td></tr>
<tr><td><code id="walktrap.community_+3A_membership">membership</code></td>
<td>
<p>Logical scalar, whether to calculate the membership vector
for the split corresponding to the highest modularity value.</p>
</td></tr>
</table>

<hr>
<h2 id='watts.strogatz.game'>The Watts-Strogatz small-world model</h2><span id='topic+watts.strogatz.game'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>watts.strogatz.game()</code> was renamed to <code>sample_smallworld()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watts.strogatz.game(dim, size, nei, p, loops = FALSE, multiple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watts.strogatz.game_+3A_dim">dim</code></td>
<td>
<p>Integer constant, the dimension of the starting lattice.</p>
</td></tr>
<tr><td><code id="watts.strogatz.game_+3A_size">size</code></td>
<td>
<p>Integer constant, the size of the lattice along each dimension.</p>
</td></tr>
<tr><td><code id="watts.strogatz.game_+3A_nei">nei</code></td>
<td>
<p>Integer constant, the neighborhood within which the vertices of
the lattice will be connected.</p>
</td></tr>
<tr><td><code id="watts.strogatz.game_+3A_p">p</code></td>
<td>
<p>Real constant between zero and one, the rewiring probability.</p>
</td></tr>
<tr><td><code id="watts.strogatz.game_+3A_loops">loops</code></td>
<td>
<p>Logical scalar, whether loops edges are allowed in the
generated graph.</p>
</td></tr>
<tr><td><code id="watts.strogatz.game_+3A_multiple">multiple</code></td>
<td>
<p>Logical scalar, whether multiple edges are allowed int the
generated graph.</p>
</td></tr>
</table>

<hr>
<h2 id='weighted_cliques'>Functions to find weighted cliques, i.e. vertex-weighted complete subgraphs in a graph</h2><span id='topic+weighted_cliques'></span>

<h3>Description</h3>

<p>These functions find all, the largest or all the maximal weighted cliques in
an undirected graph. The weight of a clique is the sum of the weights of its
vertices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_cliques(
  graph,
  vertex.weights = NULL,
  min.weight = 0,
  max.weight = 0,
  maximal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_cliques_+3A_graph">graph</code></td>
<td>
<p>The input graph, directed graphs will be considered as
undirected ones, multiple edges and loops are ignored.</p>
</td></tr>
<tr><td><code id="weighted_cliques_+3A_vertex.weights">vertex.weights</code></td>
<td>
<p>Vertex weight vector. If the graph has a <code>weight</code>
vertex attribute, then this is used by default. If the graph does not have a
<code>weight</code> vertex attribute and this argument is <code>NULL</code>, then every
vertex is assumed to have a weight of 1. Note that the current implementation
of the weighted clique finder supports positive integer weights only.</p>
</td></tr>
<tr><td><code id="weighted_cliques_+3A_min.weight">min.weight</code></td>
<td>
<p>Numeric constant, lower limit on the weight of the cliques to find.
<code>NULL</code> means no limit, i.e. it is the same as 0.</p>
</td></tr>
<tr><td><code id="weighted_cliques_+3A_max.weight">max.weight</code></td>
<td>
<p>Numeric constant, upper limit on the weight of the cliques to find.
<code>NULL</code> means no limit.</p>
</td></tr>
<tr><td><code id="weighted_cliques_+3A_maximal">maximal</code></td>
<td>
<p>Specifies whether to look for all weighted cliques (<code>FALSE</code>)
or only the maximal ones (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weighted_cliques()</code> finds all complete subgraphs in the input graph,
obeying the weight limitations given in the <code>min</code> and <code>max</code>
arguments.
</p>
<p><code>largest_weighted_cliques()</code> finds all largest weighted cliques in the
input graph. A clique is largest if there is no other clique whose total
weight is larger than the weight of this clique.
</p>
<p><code>weighted_clique_num()</code> calculates the weight of the largest weighted clique(s).
</p>


<h3>Value</h3>

<p><code>weighted_cliques()</code> and <code>largest_weighted_cliques()</code> return a
list containing numeric vectors of vertex IDs. Each list element is a weighted
clique, i.e. a vertex sequence of class <code><a href="#topic+V">igraph.vs()</a></code>.
</p>
<p><code>weighted_clique_num()</code> returns an integer scalar.
</p>


<h3>Author(s)</h3>

<p>Tamas Nepusz <a href="mailto:ntamas@gmail.com">ntamas@gmail.com</a> and Gabor Csardi
<a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other cliques: 
<code><a href="#topic+cliques">cliques</a>()</code>,
<code><a href="#topic+ivs">ivs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_graph("zachary")
V(g)$weight &lt;- 1
V(g)[c(1, 2, 3, 4, 14)]$weight &lt;- 3
weighted_cliques(g)
weighted_cliques(g, maximal = TRUE)
largest_weighted_cliques(g)
weighted_clique_num(g)
</code></pre>

<hr>
<h2 id='which_multiple'>Find the multiple or loop edges in a graph</h2><span id='topic+which_multiple'></span><span id='topic+any_multiple'></span><span id='topic+count_multiple'></span><span id='topic+which_loop'></span><span id='topic+any_loop'></span>

<h3>Description</h3>

<p>A loop edge is an edge from a vertex to itself. An edge is a multiple edge
if it has exactly the same head and tail vertices as another edge. A graph
without multiple and loop edges is called a simple graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_multiple(graph, eids = E(graph))

any_multiple(graph)

count_multiple(graph, eids = E(graph))

which_loop(graph, eids = E(graph))

any_loop(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_multiple_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="which_multiple_+3A_eids">eids</code></td>
<td>
<p>The edges to which the query is restricted. By default this is
all edges in the graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>any_loop()</code> decides whether the graph has any loop edges.
</p>
<p><code>which_loop()</code> decides whether the edges of the graph are loop edges.
</p>
<p><code>any_multiple()</code> decides whether the graph has any multiple edges.
</p>
<p><code>which_multiple()</code> decides whether the edges of the graph are multiple
edges.
</p>
<p><code>count_multiple()</code> counts the multiplicity of each edge of a graph.
</p>
<p>Note that the semantics for <code>which_multiple()</code> and <code>count_multiple()</code> is
different. <code>which_multiple()</code> gives <code>TRUE</code> for all occurrences of a
multiple edge except for one. I.e. if there are three <code>i-j</code> edges in the
graph then <code>which_multiple()</code> returns <code>TRUE</code> for only two of them while
<code>count_multiple()</code> returns &lsquo;3&rsquo; for all three.
</p>
<p>See the examples for getting rid of multiple edges while keeping their
original multiplicity as an edge attribute.
</p>


<h3>Value</h3>

<p><code>any_loop()</code> and <code>any_multiple()</code> return a logical scalar.
<code>which_loop()</code> and <code>which_multiple()</code> return a logical vector.
<code>count_multiple()</code> returns a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplify">simplify()</a></code> to eliminate loop and multiple edges.
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_mutual">which_mutual</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Loops
g &lt;- make_graph(c(1, 1, 2, 2, 3, 3, 4, 5))
any_loop(g)
which_loop(g)

# Multiple edges
g &lt;- sample_pa(10, m = 3, algorithm = "bag")
any_multiple(g)
which_multiple(g)
count_multiple(g)
which_multiple(simplify(g))
all(count_multiple(simplify(g)) == 1)

# Direction of the edge is important
which_multiple(make_graph(c(1, 2, 2, 1)))
which_multiple(make_graph(c(1, 2, 2, 1), dir = FALSE))

# Remove multiple edges but keep multiplicity
g &lt;- sample_pa(10, m = 3, algorithm = "bag")
E(g)$weight &lt;- count_multiple(g)
g &lt;- simplify(g, edge.attr.comb = list(weight = "min"))
any(which_multiple(g))
E(g)$weight

</code></pre>

<hr>
<h2 id='which_mutual'>Find mutual edges in a directed graph</h2><span id='topic+which_mutual'></span>

<h3>Description</h3>

<p>This function checks the reciprocal pair of the supplied edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_mutual(graph, eids = E(graph), loops = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_mutual_+3A_graph">graph</code></td>
<td>
<p>The input graph.</p>
</td></tr>
<tr><td><code id="which_mutual_+3A_eids">eids</code></td>
<td>
<p>Edge sequence, the edges that will be probed. By default is
includes all edges in the order of their ids.</p>
</td></tr>
<tr><td><code id="which_mutual_+3A_loops">loops</code></td>
<td>
<p>Logical, whether to consider directed self-loops to be mutual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In a directed graph an (A,B) edge is mutual if the graph also includes a
(B,A) directed edge.
</p>
<p>Note that multi-graphs are not handled properly, i.e. if the graph contains
two copies of (A,B) and one copy of (B,A), then these three edges are
considered to be mutual.
</p>
<p>Undirected graphs contain only mutual edges by definition.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as the number of edges supplied.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reciprocity">reciprocity()</a></code>, <code><a href="#topic+dyad_census">dyad_census()</a></code> if you just
want some statistics about mutual edges.
</p>
<p>Other structural.properties: 
<code><a href="#topic+bfs">bfs</a>()</code>,
<code><a href="#topic+component_distribution">component_distribution</a>()</code>,
<code><a href="#topic+connect">connect</a>()</code>,
<code><a href="#topic+constraint">constraint</a>()</code>,
<code><a href="#topic+coreness">coreness</a>()</code>,
<code><a href="#topic+degree">degree</a>()</code>,
<code><a href="#topic+dfs">dfs</a>()</code>,
<code><a href="#topic+distance_table">distance_table</a>()</code>,
<code><a href="#topic+edge_density">edge_density</a>()</code>,
<code><a href="#topic+feedback_arc_set">feedback_arc_set</a>()</code>,
<code><a href="#topic+girth">girth</a>()</code>,
<code><a href="#topic+is_acyclic">is_acyclic</a>()</code>,
<code><a href="#topic+is_dag">is_dag</a>()</code>,
<code><a href="#topic+is_matching">is_matching</a>()</code>,
<code><a href="#topic+k_shortest_paths">k_shortest_paths</a>()</code>,
<code><a href="#topic+knn">knn</a>()</code>,
<code><a href="#topic+reciprocity">reciprocity</a>()</code>,
<code><a href="#topic+subcomponent">subcomponent</a>()</code>,
<code><a href="#topic+subgraph">subgraph</a>()</code>,
<code><a href="#topic+topo_sort">topo_sort</a>()</code>,
<code><a href="#topic+transitivity">transitivity</a>()</code>,
<code><a href="#topic+unfold_tree">unfold_tree</a>()</code>,
<code><a href="#topic+which_multiple">which_multiple</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- sample_gnm(10, 50, directed = TRUE)
reciprocity(g)
dyad_census(g)
which_mutual(g)
sum(which_mutual(g)) / 2 == dyad_census(g)$mut
</code></pre>

<hr>
<h2 id='with_edge_'>Constructor modifier to add edge attributes</h2><span id='topic+with_edge_'></span>

<h3>Description</h3>

<p>Constructor modifier to add edge attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_edge_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_edge__+3A_...">...</code></td>
<td>
<p>The attributes to add. They must be named.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other constructor modifiers: 
<code><a href="#topic+simplified">simplified</a>()</code>,
<code><a href="#topic+with_graph_">with_graph_</a>()</code>,
<code><a href="#topic+with_vertex_">with_vertex_</a>()</code>,
<code><a href="#topic+without_attr">without_attr</a>()</code>,
<code><a href="#topic+without_loops">without_loops</a>()</code>,
<code><a href="#topic+without_multiples">without_multiples</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_(
  ring(10),
  with_edge_(
    color = "red",
    weight = rep(1:2, 5)
  )
) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='with_graph_'>Constructor modifier to add graph attributes</h2><span id='topic+with_graph_'></span>

<h3>Description</h3>

<p>Constructor modifier to add graph attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_graph_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_graph__+3A_...">...</code></td>
<td>
<p>The attributes to add. They must be named.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other constructor modifiers: 
<code><a href="#topic+simplified">simplified</a>()</code>,
<code><a href="#topic+with_edge_">with_edge_</a>()</code>,
<code><a href="#topic+with_vertex_">with_vertex_</a>()</code>,
<code><a href="#topic+without_attr">without_attr</a>()</code>,
<code><a href="#topic+without_loops">without_loops</a>()</code>,
<code><a href="#topic+without_multiples">without_multiples</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_(ring(10), with_graph_(name = "10-ring"))
</code></pre>

<hr>
<h2 id='with_igraph_opt'>Run code with a temporary igraph options setting</h2><span id='topic+with_igraph_opt'></span>

<h3>Description</h3>

<p>Run code with a temporary igraph options setting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_igraph_opt(options, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_igraph_opt_+3A_options">options</code></td>
<td>
<p>A named list of the options to change.</p>
</td></tr>
<tr><td><code id="with_igraph_opt_+3A_code">code</code></td>
<td>
<p>The code to run.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the <code>code</code>.
</p>


<h3>See Also</h3>

<p>Other igraph options: 
<code><a href="#topic+igraph_options">igraph_options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with_igraph_opt(
  list(sparsematrices = FALSE),
  make_ring(10)[]
)
igraph_opt("sparsematrices")
</code></pre>

<hr>
<h2 id='with_vertex_'>Constructor modifier to add vertex attributes</h2><span id='topic+with_vertex_'></span>

<h3>Description</h3>

<p>Constructor modifier to add vertex attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_vertex_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_vertex__+3A_...">...</code></td>
<td>
<p>The attributes to add. They must be named.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other constructor modifiers: 
<code><a href="#topic+simplified">simplified</a>()</code>,
<code><a href="#topic+with_edge_">with_edge_</a>()</code>,
<code><a href="#topic+with_graph_">with_graph_</a>()</code>,
<code><a href="#topic+without_attr">without_attr</a>()</code>,
<code><a href="#topic+without_loops">without_loops</a>()</code>,
<code><a href="#topic+without_multiples">without_multiples</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_(
  ring(10),
  with_vertex_(
    color = "#7fcdbb",
    frame.color = "#7fcdbb",
    name = LETTERS[1:10]
  )
) %&gt;%
  plot()
</code></pre>

<hr>
<h2 id='without_attr'>Construtor modifier to remove all attributes from a graph</h2><span id='topic+without_attr'></span>

<h3>Description</h3>

<p>Construtor modifier to remove all attributes from a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>without_attr()
</code></pre>


<h3>See Also</h3>

<p>Other constructor modifiers: 
<code><a href="#topic+simplified">simplified</a>()</code>,
<code><a href="#topic+with_edge_">with_edge_</a>()</code>,
<code><a href="#topic+with_graph_">with_graph_</a>()</code>,
<code><a href="#topic+with_vertex_">with_vertex_</a>()</code>,
<code><a href="#topic+without_loops">without_loops</a>()</code>,
<code><a href="#topic+without_multiples">without_multiples</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- make_ring(10)
g1

g2 &lt;- make_(ring(10), without_attr())
g2
</code></pre>

<hr>
<h2 id='without_loops'>Constructor modifier to drop loop edges</h2><span id='topic+without_loops'></span>

<h3>Description</h3>

<p>Constructor modifier to drop loop edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>without_loops()
</code></pre>


<h3>See Also</h3>

<p>Other constructor modifiers: 
<code><a href="#topic+simplified">simplified</a>()</code>,
<code><a href="#topic+with_edge_">with_edge_</a>()</code>,
<code><a href="#topic+with_graph_">with_graph_</a>()</code>,
<code><a href="#topic+with_vertex_">with_vertex_</a>()</code>,
<code><a href="#topic+without_attr">without_attr</a>()</code>,
<code><a href="#topic+without_multiples">without_multiples</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># An artificial example
make_(full_graph(5, loops = TRUE))
make_(full_graph(5, loops = TRUE), without_loops())
</code></pre>

<hr>
<h2 id='without_multiples'>Constructor modifier to drop multiple edges</h2><span id='topic+without_multiples'></span>

<h3>Description</h3>

<p>Constructor modifier to drop multiple edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>without_multiples()
</code></pre>


<h3>See Also</h3>

<p>Other constructor modifiers: 
<code><a href="#topic+simplified">simplified</a>()</code>,
<code><a href="#topic+with_edge_">with_edge_</a>()</code>,
<code><a href="#topic+with_graph_">with_graph_</a>()</code>,
<code><a href="#topic+with_vertex_">with_vertex_</a>()</code>,
<code><a href="#topic+without_attr">without_attr</a>()</code>,
<code><a href="#topic+without_loops">without_loops</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_(pa(10, m = 3, algorithm = "bag"))
sample_(pa(10, m = 3, algorithm = "bag"), without_multiples())
</code></pre>

<hr>
<h2 id='write_graph'>Writing the graph to a file in some format</h2><span id='topic+write_graph'></span>

<h3>Description</h3>

<p><code>write_graph()</code> is a general function for exporting graphs to foreign
file formats, however not many formats are implemented right now.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_graph(
  graph,
  file,
  format = c("edgelist", "pajek", "ncol", "lgl", "graphml", "dimacs", "gml", "dot",
    "leda"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_graph_+3A_graph">graph</code></td>
<td>
<p>The graph to export.</p>
</td></tr>
<tr><td><code id="write_graph_+3A_file">file</code></td>
<td>
<p>A connection or a string giving the file name to write the graph
to.</p>
</td></tr>
<tr><td><code id="write_graph_+3A_format">format</code></td>
<td>
<p>Character string giving the file format. Right now
<code>pajek</code>, <code>graphml</code>, <code>dot</code>, <code>gml</code>, <code>edgelist</code>,
<code>lgl</code>, <code>ncol</code> and <code>dimacs</code> are implemented. As of igraph 0.4
this argument is case insensitive.</p>
</td></tr>
<tr><td><code id="write_graph_+3A_...">...</code></td>
<td>
<p>Other, format specific arguments, see below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A NULL, invisibly.
</p>


<h3>Edge list format</h3>

<p>The <code>edgelist</code> format is a simple text file,
with one edge in a line, the two vertex ids separated by a space character.
The file is sorted by the first and the second column. This format has no
additional arguments.
</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>References</h3>

<p>Adai AT, Date SV, Wieland S, Marcotte EM. LGL: creating a map of
protein function with an algorithm for visualizing very large biological
networks. <em>J Mol Biol.</em> 2004 Jun 25;340(1):179-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_graph">read_graph()</a></code>
</p>
<p>Foreign format readers
<code><a href="#topic+graph_from_graphdb">graph_from_graphdb</a>()</code>,
<code><a href="#topic+read_graph">read_graph</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- make_ring(10)
file &lt;- tempfile(fileext = ".txt")
write_graph(g, file, "edgelist")
if (!interactive()) {
  unlink(file)
}

</code></pre>

<hr>
<h2 id='write.graph'>Writing the graph to a file in some format</h2><span id='topic+write.graph'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>write.graph()</code> was renamed to <code>write_graph()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.graph(
  graph,
  file,
  format = c("edgelist", "pajek", "ncol", "lgl", "graphml", "dimacs", "gml", "dot",
    "leda"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.graph_+3A_graph">graph</code></td>
<td>
<p>The graph to export.</p>
</td></tr>
<tr><td><code id="write.graph_+3A_file">file</code></td>
<td>
<p>A connection or a string giving the file name to write the graph
to.</p>
</td></tr>
<tr><td><code id="write.graph_+3A_format">format</code></td>
<td>
<p>Character string giving the file format. Right now
<code>pajek</code>, <code>graphml</code>, <code>dot</code>, <code>gml</code>, <code>edgelist</code>,
<code>lgl</code>, <code>ncol</code> and <code>dimacs</code> are implemented. As of igraph 0.4
this argument is case insensitive.</p>
</td></tr>
<tr><td><code id="write.graph_+3A_...">...</code></td>
<td>
<p>Other, format specific arguments, see below.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
