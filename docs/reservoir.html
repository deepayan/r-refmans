<!DOCTYPE html><html><head><title>Help for package reservoir</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reservoir}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dirtyreps'><p>Quick and dirty stochastic generation of seasonal streamflow replicates for a single site.</p></a></li>
<li><a href='#dp'><p>Dynamic Programming (Deprecated function; use 'dp_supply' instead)</p></a></li>
<li><a href='#dp_hydro'><p>Dynamic Programming for hydropower reservoirs</p></a></li>
<li><a href='#dp_multi'><p>Dynamic Programming with multiple objectives (supply, flood control, amenity)</p></a></li>
<li><a href='#dp_supply'><p>Dynamic Programming for water supply reservoirs</p></a></li>
<li><a href='#Hurst'><p>Hurst coefficient estimation</p></a></li>
<li><a href='#reservoir'><p>reservoir: Tools for Analysis, Design, and Operation of Water Supply Storages</p></a></li>
<li><a href='#resX'><p>Reservoir X inflow time series and reservoir detail</p></a></li>
<li><a href='#Rippl'><p>Rippl analysis</p></a></li>
<li><a href='#rrv'><p>Reliability, resilience, and vulnerability analysis for water supply reservoirs</p></a></li>
<li><a href='#sdp'><p>Stochastic Dynamic Programming (Deprecated function; use 'sdp_supply' instead)</p></a></li>
<li><a href='#sdp_hydro'><p>Stochastic Dynamic Programming for hydropower reservoirs</p></a></li>
<li><a href='#sdp_multi'><p>Stochastic Dynamic Programming with multiple objectives (supply, flood control, amenity)</p></a></li>
<li><a href='#sdp_supply'><p>Stochastic Dynamic Programming for water supply reservoirs</p></a></li>
<li><a href='#simRes'><p>Simulate a water supply reservoir with specified operating policy.</p></a></li>
<li><a href='#storage'><p>Storage-Reliability-Yield (SRY) relationships: Storage computation</p></a></li>
<li><a href='#yield'><p>Storage-Reliability-Yield (SRY) relationships: Yield computation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Analysis, Design, and Operation of Water Supply
Storages</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-04-14</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=reservoir">https://cran.r-project.org/package=reservoir</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Measure single-storage water supply system performance using resilience,
    reliability, and vulnerability metrics; assess storage-yield-reliability
    relationships; determine no-fail storage with sequent peak analysis; optimize
    release decisions for water supply, hydropower, and multi-objective reservoirs
    using deterministic and stochastic dynamic programming; generate inflow
    replicates using parametric and non-parametric models; evaluate inflow
    persistence using the Hurst coefficient.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>gtools, stats, graphics</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-14 07:00:41 UTC; sean_turner</td>
</tr>
<tr>
<td>Author:</td>
<td>Sean Turner [aut, cre],
  Jia Yi Ng [aut],
  Stefano Galelli [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sean Turner &lt;swd.turner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-04-14 14:50:03</td>
</tr>
</table>
<hr>
<h2 id='dirtyreps'>Quick and dirty stochastic generation of seasonal streamflow replicates for a single site.</h2><span id='topic+dirtyreps'></span>

<h3>Description</h3>

<p>Generates seasonal time series using either the kNN Bootstrap (non-parametric) or a numerically-fitted PARMA(1,1) (parametric) model. For the parametric model, the function automatically transforms the seasonal sub-series to normal and deseasonalizes prior to model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirtyreps(Q, reps, years, k, d, adjust, parameters, method = "kNNboot")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirtyreps_+3A_q">Q</code></td>
<td>
<p>time series object with seasonal resolution (e.g., frequency = 2, 3, 4, 6 or 12 for monthly data).</p>
</td></tr>
<tr><td><code id="dirtyreps_+3A_reps">reps</code></td>
<td>
<p>integer. The number of replicates to be generated.  The default is 100.</p>
</td></tr>
<tr><td><code id="dirtyreps_+3A_years">years</code></td>
<td>
<p>integer. The length of each replicate in years. The default is equal to the number of complete years given in Q.</p>
</td></tr>
<tr><td><code id="dirtyreps_+3A_k">k</code></td>
<td>
<p>integer. The k parameter of the kNN Bootstrap (i.e., number of nearest neighbors). If left blank k = n ^ 0.5., where n is the number of years in the input data.</p>
</td></tr>
<tr><td><code id="dirtyreps_+3A_d">d</code></td>
<td>
<p>integer. The d parameter of the kNN Bootstrap (i.e., number of previous time periods to inform the model). If left blank d = 1.</p>
</td></tr>
<tr><td><code id="dirtyreps_+3A_adjust">adjust</code></td>
<td>
<p>logical. If TRUE (the default) the final output time series X will be coerced for 0 &lt;= X &lt;= 1.2*max(Q). Applies only if the PARMA method is used.</p>
</td></tr>
<tr><td><code id="dirtyreps_+3A_parameters">parameters</code></td>
<td>
<p>logical. If TRUE the output will be given as a list including the replicate samples and relevant model parameters (k and d for kNNboot and phi, theta and standard deviation of residuals for PARMA). The default is FALSE.</p>
</td></tr>
<tr><td><code id="dirtyreps_+3A_method">method</code></td>
<td>
<p>character string giving the method used to generate the data. Defaults to &quot;kNNboot&quot; - the k Nearest Neighbour Bootstrap. See references for detail on the two methods available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a multi time series object containing synthetic streamflow replicates.
</p>


<h3>References</h3>

<p>kNN Bootstrap method: Lall, U. and Sharma, A., 1996. A nearest neighbor bootstrap for resampling hydrologic time series. Water Resources Research, 32(3), pp.679-693.
</p>
<p>PARMA method: Salas, J.D. and Fernandez, B., 1993. Models for data generation in hydrology: univariate techniques. In Stochastic Hydrology and its Use in Water Resources Systems Simulation and Optimization (pp. 47-73). Springer Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- resX$Q_Mm3
replicates &lt;- dirtyreps(Q, reps = 3)
mean(replicates); mean(Q)
sd(replicates); sd(Q)
plot(replicates)
</code></pre>

<hr>
<h2 id='dp'>Dynamic Programming (Deprecated function; use 'dp_supply' instead)</h2><span id='topic+dp'></span>

<h3>Description</h3>

<p>Determines the optimal sequence of releases from the reservoir to minimise a penalty cost function based on water supply defict.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dp(Q, capacity, target, S_disc = 1000, R_disc = 10, loss_exp = 2,
  S_initial = 1, plot = TRUE, rep_rrv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dp_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflows to the reservoir.</p>
</td></tr>
<tr><td><code id="dp_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir storage capacity (must be the same volumetric unit as Q and the target release).</p>
</td></tr>
<tr><td><code id="dp_+3A_target">target</code></td>
<td>
<p>numerical. The target release constant.</p>
</td></tr>
<tr><td><code id="dp_+3A_s_disc">S_disc</code></td>
<td>
<p>integer. Storage discretization&ndash;the number of equally-sized storage states. Default = 1000.</p>
</td></tr>
<tr><td><code id="dp_+3A_r_disc">R_disc</code></td>
<td>
<p>integer. Release discretization. Default = 10 divisions.</p>
</td></tr>
<tr><td><code id="dp_+3A_loss_exp">loss_exp</code></td>
<td>
<p>numeric. The exponent of the penalty cost function&ndash;i.e., Cost[t] &lt;- ((target - release[t]) / target) ^ **loss_exp**). Default value is 2.</p>
</td></tr>
<tr><td><code id="dp_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="dp_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="dp_+3A_rep_rrv">rep_rrv</code></td>
<td>
<p>logical. If TRUE then reliability, resilience and vulnerability metrics are computed and returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the time series of optimal releases and, if requested, the reliability, resilience and vulnerability of the system.
</p>


<h3>References</h3>

<p>Loucks, D.P., van Beek, E., Stedinger, J.R., Dijkman, J.P.M. and Villars, M.T. (2005) Water resources systems planning and management: An introduction to methods, models and applications. Unesco publishing, Paris, France.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdp">sdp</a></code> for Stochastic Dynamic Programming
</p>

<hr>
<h2 id='dp_hydro'>Dynamic Programming for hydropower reservoirs</h2><span id='topic+dp_hydro'></span>

<h3>Description</h3>

<p>Determines the optimal sequence of turbined releases to maximise the total energy produced by the reservoir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dp_hydro(Q, capacity, capacity_live = capacity, surface_area, evap,
  installed_cap, head, qmax, max_depth, efficiency = 0.9, S_disc = 1000,
  R_disc = 10, S_initial = 1, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dp_hydro_+3A_q">Q</code></td>
<td>
<p>time series object. Net inflows to the reservoir. Must be in volumetric units of Mm^3.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The total reservoir storage capacity (including unusable &quot;dead&quot; storage). Must be in Mm^3.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_capacity_live">capacity_live</code></td>
<td>
<p>numerical. The volume of usable water in the reservoir (&quot;live capacity&quot; or &quot;active storage&quot;). capacity_live &lt;= capacity. Default capacity_live = capacity. Must be in Mm^3.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_surface_area">surface_area</code></td>
<td>
<p>numerical. The reservoir surface area at full capacity. Must be in square kilometers (km^2), or Mm^2.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_evap">evap</code></td>
<td>
<p>vector or time series object of length Q, or a numerical constant, representing evaporation loss potential from reservoir surface. Varies with level if depth and surface_area parameters are specified. Must be in meters, or kg/m2 * 10 ^ -3.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_installed_cap">installed_cap</code></td>
<td>
<p>numerical. The hydropower plant electric capacity (MW).</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_head">head</code></td>
<td>
<p>numerical. The maximum hydraulic head of the hydropower plant (m). Can be omitted and estimated if qmax is supplied.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_qmax">qmax</code></td>
<td>
<p>numerical. The maximum flow into the hydropower plant. Can be omitted and estimated if head is supplied. Must be in volumetric units of Mm^3.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_max_depth">max_depth</code></td>
<td>
<p>numerical. The maximum water depth of the reservoir at maximum capacity. If omitted, the depth-storage-area relationship will be estimated from surface area and capacity only. Recommended units: meters.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_efficiency">efficiency</code></td>
<td>
<p>numerical. The hydropower plant efficiency. Default is 0.9, but, unless user specifies an efficiency, it will be automatically re-estimated if head and qmax are supplied.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_s_disc">S_disc</code></td>
<td>
<p>integer. Storage discretization&ndash;the number of equally-sized storage states. Default = 1000.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_r_disc">R_disc</code></td>
<td>
<p>integer. Release discretization. Default = 10 divisions.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="dp_hydro_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the time series of optimal releases and simulated storage, evaporation, depth, uncontrolled spill, and power generated. Total energy generated is also returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdp_hydro">sdp_hydro</a></code> for Stochastic Dynamic Programming for hydropower reservoirs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(1:4)
dp_hydro(resX$Q_Mm3, resX$cap_Mm3, surface_area = resX$A_km2,
installed_cap = resX$Inst_cap_MW, qmax = mean(resX$Q_Mm3), S_disc = 100)
</code></pre>

<hr>
<h2 id='dp_multi'>Dynamic Programming with multiple objectives (supply, flood control, amenity)</h2><span id='topic+dp_multi'></span>

<h3>Description</h3>

<p>Determines the optimal sequence of releases from the reservoir to minimise a penalty cost function based on water supply, spill, and water level. For water supply: Cost[t] = ((target - release[t]) / target) ^ loss_exp[1]). For flood control: Cost[t] = (Spill[t] / quantile(Q, spill_targ)) ^ loss_exp[2]. For amenity: Cost[t] = abs(((storage[t] - (vol_targ * capacity)) / (vol_targ * capacity))) ^ loss_exp[3].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dp_multi(Q, capacity, target, surface_area, max_depth, evap, R_max = 2 *
  target, spill_targ = 0.95, vol_targ = 0.75, weights = c(0.7, 0.2, 0.1),
  loss_exp = c(2, 2, 2), S_disc = 1000, R_disc = 10, S_initial = 1,
  plot = TRUE, rep_rrv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dp_multi_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflow totals to the reservoir. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir storage capacity (must be the same volumetric unit as Q and the target release).</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_target">target</code></td>
<td>
<p>numerical. The target release constant. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_surface_area">surface_area</code></td>
<td>
<p>numerical. The reservoir water surface area at maximum capacity. Recommended units: km^2 (square kilometers).</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_max_depth">max_depth</code></td>
<td>
<p>numerical. The maximum water depth of the reservoir at maximum capacity. If omitted, the depth-storage-area relationship will be estimated from surface area and capacity only. Recommended units: meters.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_evap">evap</code></td>
<td>
<p>vector or time series object of length Q, or a numerical constant.  Evaporation from losses from reservoir surface. Varies with level if depth and surface_area parameters are specified. Recommended units: meters, or kg/m2 * 10 ^ -3.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_r_max">R_max</code></td>
<td>
<p>numerical. The maximum controlled release, in the same units as target.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_spill_targ">spill_targ</code></td>
<td>
<p>numerical. The quantile of the inflow time series used to standardise the &quot;minimise spill&quot; objective.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_vol_targ">vol_targ</code></td>
<td>
<p>numerical. The target storage volume constant (as proportion of capacity).</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_weights">weights</code></td>
<td>
<p>vector of length 3 indicating weighting to be applied to release, spill and water level objectives respectively.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_loss_exp">loss_exp</code></td>
<td>
<p>vector of length 3 indicating the exponents on release, spill and water level deviations from target. Default exponents are c(2,2,2).</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_s_disc">S_disc</code></td>
<td>
<p>integer. Storage discretization&ndash;the number of equally-sized storage states. Default = 1000.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_r_disc">R_disc</code></td>
<td>
<p>integer. Release discretization. Default = 10 divisions.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="dp_multi_+3A_rep_rrv">rep_rrv</code></td>
<td>
<p>logical. If TRUE then reliability, resilience and vulnerability metrics are computed and returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns reservoir simulation output (storage, release, spill), total penalty cost associated with the objective function, and, if requested, the reliability, resilience and vulnerability of the system.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdp_multi">sdp_multi</a></code> for Stochastic Dynamic Programming
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(1:3)
dp_multi(resX$Q_Mm3, cap = resX$cap_Mm3, target = 0.2 * mean(resX$Q_Mm3), S_disc = 100)
</code></pre>

<hr>
<h2 id='dp_supply'>Dynamic Programming for water supply reservoirs</h2><span id='topic+dp_supply'></span>

<h3>Description</h3>

<p>Determines the optimal sequence of releases from the reservoir to minimise a penalty cost function based on water supply defict.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dp_supply(Q, capacity, target, surface_area, max_depth, evap, S_disc = 1000,
  R_disc = 10, loss_exp = 2, S_initial = 1, plot = TRUE,
  rep_rrv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dp_supply_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflow totals to the reservoir. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir storage capacity. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_target">target</code></td>
<td>
<p>numerical. The target release constant. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_surface_area">surface_area</code></td>
<td>
<p>numerical. The reservoir water surface area at maximum capacity. Recommended units: km^2 (square kilometers).</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_max_depth">max_depth</code></td>
<td>
<p>numerical. The maximum water depth of the reservoir at maximum capacity. If omitted, the depth-storage-area relationship will be estimated from surface area and capacity only. Recommended units: meters.</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_evap">evap</code></td>
<td>
<p>vector or time series object of length Q, or a numerical constant.  Evaporation from losses from reservoir surface. Varies with level if depth and surface_area parameters are specified. Recommended units: meters, or kg/m2 * 10 ^ -3.</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_s_disc">S_disc</code></td>
<td>
<p>integer. Storage discretization&ndash;the number of equally-sized storage states. Default = 1000.</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_r_disc">R_disc</code></td>
<td>
<p>integer. Release discretization. Default = 10 divisions.</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_loss_exp">loss_exp</code></td>
<td>
<p>numeric. The exponent of the penalty cost function&ndash;i.e., Cost[t] &lt;- ((target - release[t]) / target) ^ **loss_exp**). Default value is 2.</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="dp_supply_+3A_rep_rrv">rep_rrv</code></td>
<td>
<p>logical. If TRUE then reliability, resilience and vulnerability metrics are computed and returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the reservoir simulation output (storage, release, spill), total penalty cost associated with the objective function, and, if requested, the reliability, resilience and vulnerability of the system.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdp_supply">sdp_supply</a></code> for Stochastic Dynamic Programming for water supply reservoirs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(1:3)
dp_supply(resX$Q_Mm3, capacity = resX$cap_Mm3, target = 0.3 * mean(resX$Q_Mm3), S_disc = 100)
</code></pre>

<hr>
<h2 id='Hurst'>Hurst coefficient estimation</h2><span id='topic+Hurst'></span>

<h3>Description</h3>

<p>Hurst coefficient estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hurst(Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hurst_+3A_q">Q</code></td>
<td>
<p>vector or annualized time series object. Net inflows or streamflow totals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an estimate of the Hurst coefficient, H (0.5 &lt; H &lt; 1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q_annual &lt;- aggregate(resX$Q_Mm3) #convert monthly to annual data
Hurst(Q_annual)
</code></pre>

<hr>
<h2 id='reservoir'>reservoir: Tools for Analysis, Design, and Operation of Water Supply Storages</h2><span id='topic+reservoir'></span><span id='topic+reservoir-package'></span>

<h3>Description</h3>

<p>Measure single reservoir performance using resilience, reliability, and vulnerability metrics; compute storage-yield-reliability relationships; determine no-fail Rippl storage with sequent peak analysis; optimize release decisions for water supply, hydropower, and multi-objective reservoirs using deterministic and stochastic dynamic programming; evaluate inflow characteristics.
</p>


<h3>Analysis and design functions</h3>

<p>The <code><a href="#topic+Rippl">Rippl</a></code> function executes the sequent peak algorithm [Thomas and Burden, 1963] to determine the no-fail storage [Rippl, 1883] for given inflow and release time series.
The <code><a href="#topic+storage">storage</a></code> function gives the design storage for a specified time-based reliability and yield. Similarly, the <code><a href="#topic+yield">yield</a></code> function computes the reliability yield given the storage capacity.
The <code><a href="#topic+simRes">simRes</a></code> function simulates a reservoir under standard operating policy, or using an optimised policy produced by <code><a href="#topic+sdp_supply">sdp_supply</a></code>.
The <code><a href="#topic+rrv">rrv</a></code> function returns three reliability measures, resilience, and dimensionless vulnerability for given storage, inflow time series, and target release [McMahon et al, 2006]. Users can assume Standard Operating Policy, or can apply the output of <code><a href="#topic+sdp_supply">sdp_supply</a></code> to determine the RRV metrics under different operating objectives.
The <code><a href="#topic+Hurst">Hurst</a></code> function estimates the Hurst coefficient [Hurst, 1951] for an annualized inflow time series, using the method proposed by Pfaff [2008].
</p>


<h3>Optimization functions</h3>

<p>The Dynamic Programming functions find the optimal sequence of releases for a given reservoir. The Stochastic Dynamic Programming functions find the optimal release policy for a given reservoir, based on storage, within-year time period and, optionally, current-period inflow.
For single-objective water supply reservoirs, users may specify a loss exponent parameter for supply deficits and then optimize reservoir release decisions to minimize summed penalty costs over the operating horizon. This can be done using <code><a href="#topic+dp_supply">dp_supply</a></code> or <code><a href="#topic+sdp_supply">sdp_supply</a></code>. There is also an option to simulate the output of <code><a href="#topic+sdp_supply">sdp_supply</a></code> using the <code><a href="#topic+rrv">rrv</a></code> function to validate the policy under alternative inflows or analyze reservoir performance under different operating objectives.
The optimal operating policy for hydropower operations can be found using <code><a href="#topic+dp_hydro">dp_hydro</a></code> or <code><a href="#topic+sdp_hydro">sdp_hydro</a></code>. The operating target is to maximise total energy output over the duration of the input time series of inflows.
The <code><a href="#topic+dp_multi">dp_multi</a></code> and <code><a href="#topic+sdp_multi">sdp_multi</a></code> functions allow users to optimize for three weighted objectives representing water supply deficit, flood control, and amenity.
</p>


<h3>Storage-depth-area relationships</h3>

<p>All reservoir analysis and optimization functions, with the exception of <code><a href="#topic+Rippl">Rippl</a></code>, <code><a href="#topic+storage">storage</a></code>, and <code><a href="#topic+yield">yield</a></code>, allow the user to account for evaporation losses from the reservoir surface. The package incorporates two storage-depth-area relationships for adjusting the surface area (and therefore evaporation potential) with storage.
The simplest is based on the half-pyramid method [Liebe et al, 2005], requiring the user to input the surface area of the reservoir at full capacity via the <code>surface_area</code> parameter.
A more nuanced relationship [Kaveh et al., 2013] is implemeted if the user also provides the maximum depth of the reservoir at full capacity via the <code>max_depth</code> parameter.
Users must use the recommended units when implementing evaporation losses.
</p>


<h3>Stochastic generation of synthetic streamflow replicates</h3>

<p>The <code><a href="#topic+dirtyreps">dirtyreps</a></code> function provides quick and dirty generation of stochastic streamflow replicates (seasonal input data, such as monthly or quarterly, only).
Two methods are available: the non-parametric kNN bootstrap [Lall and Sharma, 1996] and the parametric periodic Autoregressive Moving Average (PARMA).
The PARMA is fitted for p = 1 and q = 1, or PARMA(1,1). Fitting is done numerically by the least-squares method [Salas and Fernandez, 1993].
When using the PARMA model, users do not need to transform or deseasonalize the input data as this is done automatically within the algorithm.
The kNN bootstrap is non-parametric, so no intial data preparation is required here either.
</p>


<h3>References</h3>

<p>Hurst, H.E. (1951) Long-term storage capacity of reservoirs, Transactions of the American Society of Civil Engineers 116, 770-808.
</p>
<p>Kaveh, K., H. Hosseinjanzadeh, and K. Hosseini. (2013) A new equation for calculation of reservoir's area-capacity curves, KSCE Journal of Civil Engineering 17(5), 1149-1156.
</p>
<p>Liebe, J., N. Van De Giesen, and Marc Andreini. (2005) Estimation of small reservoir storage capacities in a semi-arid environment: A case study in the Upper East Region of Ghana, Physics and Chemistry of the Earth, 30(6), 448-454.
</p>
<p>Loucks, D.P., van Beek, E., Stedinger, J.R., Dijkman, J.P.M. and Villars, M.T. (2005) Water resources systems planning and management: An introduction to methods, models and applications. Unesco publishing, Paris, France.
</p>
<p>McMahon, T.A., Adeloye, A.J., Zhou, S.L. (2006) Understanding performance measures of reservoirs, Journal of Hydrology 324 (359-382)
</p>
<p>Nicholas E. Graham and Konstantine P. Georgakakos, 2010: Toward Understanding the Value of Climate Information for Multiobjective Reservoir Management under Present and Future Climate and Demand Scenarios. J. Appl. Meteor. Climatol., 49, 557-573.
</p>
<p>Pfaff, B. (2008) Analysis of integrated and cointegrated time series with R, Springer, New York. [p.68]
</p>
<p>Rippl, W. (1883) The capacity of storage reservoirs for water supply, In Proceedings of the Institute of Civil Engineers, 71, 270-278.
</p>
<p>Thomas H.A., Burden R.P. (1963) Operations research in water quality management. Harvard Water Resources Group, Cambridge
</p>
<p>kNN Bootstrap method: Lall, U. and Sharma, A. (1996). A nearest neighbor bootstrap for resampling hydrologic time series. Water Resources Research, 32(3), pp.679-693.
</p>
<p>PARMA method: Salas, J.D. and Fernandez, B. (1993). Models for data generation in hydrology: univariate techniques. In Stochastic Hydrology and its Use in Water Resources Systems Simulation and Optimization (pp. 47-73). Springer Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Express the distribution of Rippl storage for a known inflow process...
layout(1:4)
# a) Assume the inflow process follows a lognormal distribution
# (meanlog = 0, sdlog = 1):
x &lt;- rlnorm(1200)

# b) Convert to a 100-year, monthly time series object beginning Jan 1900
x &lt;- ts(x, start = c(1900, 1), frequency = 12)

# c) Begin reservoir analysis... e.g., compute the Rippl storage
x_Rippl &lt;- Rippl(x, target = mean(x) * 0.9)
no_fail_storage &lt;- x_Rippl$Rippl_storage

# d) Resample x and loop the procedure multiple times to get the
# distribution of no-failure storage for the inflow process assuming
# constant release (R) equal to 90 percent of the mean inflow.
no_fail_storage &lt;- vector("numeric", 100)
for (i in 1:length(no_fail_storage)){
  x &lt;- ts(rlnorm(1200), start = c(1900, 1), frequency = 12)
  no_fail_storage[i] &lt;- Rippl(x, target = mean(x) * 0.9 ,plot = FALSE)$No_fail_storage
}
hist(no_fail_storage)


# 2. Trade off between annual reliability and vulnerability for a given system...
layout(1:1)
# a) Define the system: inflow time series, storage, and target release.
inflow_ts &lt;- resX$Q_Mm3
storage_cap &lt;- resX$cap_Mm3
demand &lt;- 0.3 * mean(resX$Q_Mm3)

# b) define range of loss exponents to control preference of high reliability
# (low loss exponent) or low vulnerability (high loss exponent).
loss_exponents &lt;- c(1.0, 1.5, 2)

# c) set up results table
pareto_results &lt;- data.frame(matrix(ncol = 2, nrow = length(loss_exponents)))
names(pareto_results) &lt;- c("reliability", "vulnerability")
row.names(pareto_results) &lt;- loss_exponents

# d) loop the sdp function through all loss exponents and plot results
for (loss_f in loss_exponents){
 sdp_temp &lt;- sdp_supply(inflow_ts, capacity = storage_cap, target = demand, rep_rrv = TRUE,
 S_disc = 100, R_disc = 10, plot = FALSE, loss_exp = loss_f, Markov = TRUE)
 pareto_results$reliability[which(row.names(pareto_results)==loss_f)] &lt;- sdp_temp$annual_reliability
 pareto_results$vulnerability[which(row.names(pareto_results)==loss_f)] &lt;- sdp_temp$vulnerability
 }
plot (pareto_results$reliability,pareto_results$vulnerability, type = "b", lty = 3)
</code></pre>

<hr>
<h2 id='resX'>Reservoir X inflow time series and reservoir detail</h2><span id='topic+resX'></span>

<h3>Description</h3>

<p>Reservoir X inflow time series and reservoir detail
</p>


<h3>Format</h3>

<p>list object</p>


<h3>Source</h3>

<p><a href="http://atlas.gwsp.org">http://atlas.gwsp.org</a>
</p>


<h3>References</h3>

<p>Lehner, B., R-Liermann, C., Revenga, C., Vorosmarty, C., Fekete, B., Crouzet, P., Doll, P. et al.: High resolution mapping of the world's reservoirs and dams for sustainable river flow management. Frontiers in Ecology and the Environment. Source: GWSP Digital Water Atlas (2008). Map 81: GRanD Database (V1.0).
</p>

<hr>
<h2 id='Rippl'>Rippl analysis</h2><span id='topic+Rippl'></span>

<h3>Description</h3>

<p>Computes the Rippl no-failure storage for given time series of inflows and releases using the sequent peak algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rippl(Q, target, R, double_cycle = FALSE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rippl_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflow totals to the reservoir.</p>
</td></tr>
<tr><td><code id="Rippl_+3A_target">target</code></td>
<td>
<p>a target release constant in same volumteric units as Q. Can be omitted if R is given.</p>
</td></tr>
<tr><td><code id="Rippl_+3A_r">R</code></td>
<td>
<p>a time series or vector of target releases (volumetric). Must be the same length as Q.</p>
</td></tr>
<tr><td><code id="Rippl_+3A_double_cycle">double_cycle</code></td>
<td>
<p>logical. If TRUE the Q and R time series will be replicated and placed end-to-end to double the simulation. Recommended if the critical period occurs at the end of the sequence.</p>
</td></tr>
<tr><td><code id="Rippl_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram is plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the no-fail storage capacity and corresponding storage behaviour time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a release vector for a constant release equal to 90 % of the mean inflow
no_fail_storage &lt;- Rippl(resX$Q_Mm3, target = 0.9 * mean(resX$Q_Mm3))$No_fail_storage
</code></pre>

<hr>
<h2 id='rrv'>Reliability, resilience, and vulnerability analysis for water supply reservoirs</h2><span id='topic+rrv'></span>

<h3>Description</h3>

<p>Computes time-based, annual, and volumetric reliability, as well as resilience and dimensionless vulnerability for a single reservoir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrv(Q, target, capacity, double_cycle = FALSE, surface_area, max_depth, evap,
  plot = TRUE, S_initial = 1, policy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrv_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflow totals to the reservoir. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="rrv_+3A_target">target</code></td>
<td>
<p>numerical. The target release constant. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="rrv_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir capacity. Should be same volumetric unit as Q and R.</p>
</td></tr>
<tr><td><code id="rrv_+3A_double_cycle">double_cycle</code></td>
<td>
<p>logical. If TRUE the input series will be replicated and placed end-to-end to double the simulation. (Recommended if the critical period occurs at the end of the recorded inflow time series)</p>
</td></tr>
<tr><td><code id="rrv_+3A_surface_area">surface_area</code></td>
<td>
<p>numerical. The reservoir water surface area at maximum capacity. Recommended units: km^2 (square kilometers).</p>
</td></tr>
<tr><td><code id="rrv_+3A_max_depth">max_depth</code></td>
<td>
<p>numerical. The maximum water depth of the reservoir at maximum capacity. If omitted, the depth-storage-area relationship will be estimated from surface area and capacity only. Recommended units: meters.</p>
</td></tr>
<tr><td><code id="rrv_+3A_evap">evap</code></td>
<td>
<p>vector or time series object of length Q, or a numerical constant.  Evaporation from losses from reservoir surface. Varies with level if depth and surface_area parameters are specified. Recommended units: meters, or kg/m2 * 10 ^ -3.</p>
</td></tr>
<tr><td><code id="rrv_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="rrv_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="rrv_+3A_policy">policy</code></td>
<td>
<p>list. The output of the SDP function. If omitted, Standard Operating Policy is assumed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns reliability, resilience and vulnerability metrics based on supply deficits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare reliability, resilience and vulnerability for two operating policies (SOP and SDP).
rrv(resX$Q_Mm3, capacity = 20*resX$cap_Mm3, target = 0.95 * mean(resX$Q_Mm3))
pol_Markov &lt;- sdp_supply(resX$Q_Mm3, capacity = 20 * resX$cap_Mm3,
target = 0.95 * mean(resX$Q_Mm3), Markov = TRUE)
rrv(resX$Q_Mm3, capacity = 20*resX$cap_Mm3, target = 0.95 * mean(resX$Q_Mm3), policy = pol_Markov)
</code></pre>

<hr>
<h2 id='sdp'>Stochastic Dynamic Programming (Deprecated function; use 'sdp_supply' instead)</h2><span id='topic+sdp'></span>

<h3>Description</h3>

<p>Derives the optimal release policy based on storage state, inflow class and within-year period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdp(Q, capacity, target, S_disc = 1000, R_disc = 10, Q_disc = c(0, 0.2375,
  0.475, 0.7125, 0.95, 1), loss_exp = 2, S_initial = 1, plot = TRUE,
  tol = 0.99, rep_rrv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdp_+3A_q">Q</code></td>
<td>
<p>time series object. Net inflows to the reservoir.</p>
</td></tr>
<tr><td><code id="sdp_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir storage capacity (must be the same volumetric unit as Q and the target release).</p>
</td></tr>
<tr><td><code id="sdp_+3A_target">target</code></td>
<td>
<p>numerical. The target release constant.</p>
</td></tr>
<tr><td><code id="sdp_+3A_s_disc">S_disc</code></td>
<td>
<p>integer. Storage discretization&ndash;the number of equally-sized storage states. Default = 1000.</p>
</td></tr>
<tr><td><code id="sdp_+3A_r_disc">R_disc</code></td>
<td>
<p>integer. Release discretization. Default = 10 divisions.</p>
</td></tr>
<tr><td><code id="sdp_+3A_q_disc">Q_disc</code></td>
<td>
<p>vector. Inflow discretization bounding quantiles. Defaults to five inflow classes bounded by quantile vector c(0.0, 0.2375, 0.4750, 0.7125, 0.95, 1.0).</p>
</td></tr>
<tr><td><code id="sdp_+3A_loss_exp">loss_exp</code></td>
<td>
<p>numeric. The exponent of the penalty cost function&ndash;i.e., Cost[t] &lt;- ((target - release[t]) / target) ^ **loss_exp**). Default value is 2.</p>
</td></tr>
<tr><td><code id="sdp_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="sdp_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="sdp_+3A_tol">tol</code></td>
<td>
<p>numerical. The tolerance for policy convergence. The default value is 0.990.</p>
</td></tr>
<tr><td><code id="sdp_+3A_rep_rrv">rep_rrv</code></td>
<td>
<p>logical. If TRUE then reliability, resilience and vulnerability metrics are computed and returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list that includes: the optimal policy as an array of release decisions dependent on storage state, month/season, and current-period inflow class; the Bellman cost function based on storage state, month/season, and inflow class; the optimized release and storage time series through the training inflow data; the flow discretization (which is required if the output is to be implemented in the rrv function); and, if requested, the reliability, resilience, and vulnerability of the system under the optimized policy.
</p>


<h3>References</h3>

<p>Loucks, D.P., van Beek, E., Stedinger, J.R., Dijkman, J.P.M. and Villars, M.T. (2005) Water resources systems planning and management: An introduction to methods, models and applications. Unesco publishing, Paris, France.
</p>
<p>Gregory R. Warnes, Ben Bolker and Thomas Lumley (2014). gtools: Various R programming tools. R package version 3.4.1. http://CRAN.R-project.org/package=gtools
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdp">sdp</a></code> for deterministic Dynamic Programming
</p>

<hr>
<h2 id='sdp_hydro'>Stochastic Dynamic Programming for hydropower reservoirs</h2><span id='topic+sdp_hydro'></span>

<h3>Description</h3>

<p>Determines the optimal policy of turbined releases to maximise the total energy produced by the reservoir. The policy can be based on season and storage level, or season, storage level, and current-period inflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdp_hydro(Q, capacity, capacity_live = capacity, surface_area, max_depth,
  evap, installed_cap, head, qmax, efficiency = 0.9, S_disc = 1000,
  R_disc = 10, Q_disc = c(0, 0.2375, 0.475, 0.7125, 0.95, 1),
  S_initial = 1, plot = TRUE, tol = 0.99, Markov = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdp_hydro_+3A_q">Q</code></td>
<td>
<p>time series object. Net inflows to the reservoir. Must be in volumetric units of Mm^3.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The total reservoir storage capacity (including unusable &quot;dead&quot; storage). Must be in Mm^3.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_capacity_live">capacity_live</code></td>
<td>
<p>numerical. The volume of usable water in the reservoir (&quot;live capacity&quot; or &quot;active storage&quot;). capacity_live &lt;= capacity. Default capacity_live = capacity. Must be in Mm^3.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_surface_area">surface_area</code></td>
<td>
<p>numerical. The reservoir surface area at full capacity. Must be in square kilometers (km^2), or Mm^2.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_max_depth">max_depth</code></td>
<td>
<p>numerical. The maximum water depth of the reservoir at maximum capacity. If omitted, the depth-storage-area relationship will be estimated from surface area and capacity only. Recommended units: meters.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_evap">evap</code></td>
<td>
<p>vector or time series object of length Q, or a numerical constant, representing evaporation loss potential from reservoir surface. Varies with level if depth and surface_area parameters are specified. Must be in meters, or kg/m2 * 10 ^ -3.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_installed_cap">installed_cap</code></td>
<td>
<p>numerical. The hydropower plant electric capacity (MW).</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_head">head</code></td>
<td>
<p>numerical. The maximum hydraulic head of the hydropower plant (m). Can be omitted if qmax is supplied.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_qmax">qmax</code></td>
<td>
<p>numerical. The maximum flow into the hydropower plant. Can be omitted and estimated if head is supplied. Must be in volumetric units of Mm^3.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_efficiency">efficiency</code></td>
<td>
<p>numerical. The hydropower plant efficiency. Default is 0.9, but, unless user specifies an efficiency, it will be automatically re-estimated if head and qmax are supplied.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_s_disc">S_disc</code></td>
<td>
<p>integer. Storage discretization&ndash;the number of equally-sized storage states. Default = 1000.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_r_disc">R_disc</code></td>
<td>
<p>integer. Release discretization. Default = 10 divisions.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_q_disc">Q_disc</code></td>
<td>
<p>vector. Inflow discretization bounding quantiles. Defaults to five inflow classes bounded by quantile vector c(0.0, 0.2375, 0.4750, 0.7125, 0.95, 1.0).</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_tol">tol</code></td>
<td>
<p>numerical. The tolerance for policy convergence. The default value is 0.990.</p>
</td></tr>
<tr><td><code id="sdp_hydro_+3A_markov">Markov</code></td>
<td>
<p>logical. If TRUE the current period inflow is used as a hydrological state variable and inflow persistence is incorporated using a first-order, periodic Markov chain. The default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the optimal release policy, associated Bellman function, simulated storage, release, evaporation, depth, uncontrolled spill, and power generated, and total energy generated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dp_hydro">dp_hydro</a></code> for deterministic Dynamic Programming for hydropower reservoirs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(1:4)
sdp_hydro(resX$Q_Mm3, resX$cap_Mm3, surface_area = resX$A_km2,
installed_cap = resX$Inst_cap_MW, qmax = mean(resX$Q_Mm3))
sdp_hydro(resX$Q_Mm3, resX$cap_Mm3, surface_area = resX$A_km2,
installed_cap = resX$Inst_cap_MW, qmax = mean(resX$Q_Mm3), Markov = TRUE)
</code></pre>

<hr>
<h2 id='sdp_multi'>Stochastic Dynamic Programming with multiple objectives (supply, flood control, amenity)</h2><span id='topic+sdp_multi'></span>

<h3>Description</h3>

<p>Determines the optimal sequence of releases from the reservoir to minimise a penalty cost function based on water supply, spill, and water level. For water supply: Cost[t] = ((target - release[t]) / target) ^ loss_exp[1]). For flood control: Cost[t] = (Spill[t] / quantile(Q, spill_targ)) ^ loss_exp[2]. For amenity: Cost[t] = abs(((storage[t] - (vol_targ * capacity)) / (vol_targ * capacity))) ^ loss_exp[3].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdp_multi(Q, capacity, target, surface_area, max_depth, evap, R_max = 2 *
  target, spill_targ = 0.95, vol_targ = 0.75, Markov = FALSE,
  weights = c(0.7, 0.2, 0.1), S_disc = 1000, R_disc = 10, Q_disc = c(0,
  0.2375, 0.475, 0.7125, 0.95, 1), loss_exp = c(2, 2, 2), S_initial = 1,
  plot = TRUE, tol = 0.99, rep_rrv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdp_multi_+3A_q">Q</code></td>
<td>
<p>time series object. Net inflow to the reservoir.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir storage capacity (must be the same volumetric unit as Q and the target release).</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_target">target</code></td>
<td>
<p>numerical. The target release constant. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_surface_area">surface_area</code></td>
<td>
<p>numerical. The reservoir water surface area at maximum capacity. Recommended units: km^2 (square kilometers).</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_max_depth">max_depth</code></td>
<td>
<p>numerical. The maximum water depth of the reservoir at maximum capacity. If omitted, the depth-storage-area relationship will be estimated from surface area and capacity only. Recommended units: meters.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_evap">evap</code></td>
<td>
<p>vector or time series object of length Q, or a numerical constant.  Evaporation from losses from reservoir surface. Varies with level if depth and surface_area parameters are specified. Recommended units: meters, or kg/m2 * 10 ^ -3.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_r_max">R_max</code></td>
<td>
<p>numerical. The maximum controlled release.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_spill_targ">spill_targ</code></td>
<td>
<p>numerical. The quantile of the inflow time series used to standardise the &quot;minimise spill&quot; objective.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_vol_targ">vol_targ</code></td>
<td>
<p>numerical. The target storage volume constant (as proportion of capacity).</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_markov">Markov</code></td>
<td>
<p>logical. If TRUE the current period inflow is used as a hydrological state variable and inflow persistence is incorporated using a first-order, periodic Markov chain. The default is FALSE.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_weights">weights</code></td>
<td>
<p>vector of length 3 indicating weighting to be applied to release, spill and water level objectives respectively.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_s_disc">S_disc</code></td>
<td>
<p>integer. Storage discretization&ndash;the number of equally-sized storage states. Default = 1000.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_r_disc">R_disc</code></td>
<td>
<p>integer. Release discretization. Default = 10 divisions.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_q_disc">Q_disc</code></td>
<td>
<p>vector. Inflow discretization bounding quantiles. Defaults to five inflow classes bounded by quantile vector c(0.0, 0.2375, 0.4750, 0.7125, 0.95, 1.0).</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_loss_exp">loss_exp</code></td>
<td>
<p>vector of length 3 indicating the exponents on release, spill and water level deviations from target. Default exponents are c(2,2,2).</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_tol">tol</code></td>
<td>
<p>numerical. The tolerance for policy convergence. The default value is 0.990.</p>
</td></tr>
<tr><td><code id="sdp_multi_+3A_rep_rrv">rep_rrv</code></td>
<td>
<p>logical. If TRUE then reliability, resilience and vulnerability metrics are computed and returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list that includes: the optimal policy as an array of release decisions dependent on storage state, month/season, and current-period inflow class; the Bellman cost function based on storage state, month/season, and inflow class; the optimized release and storage time series through the training inflow data; the flow discretization (which is required if the output is to be implemented in the rrv function); and, if requested, the reliability, resilience, and vulnerability of the system under the optimized policy.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dp_multi">dp_multi</a></code> for deterministic Dynamic Programming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(1:3)
sdp_multi(resX$Q_Mm3, cap = resX$cap_Mm3, target = 0.2 * mean(resX$Q_Mm3))
</code></pre>

<hr>
<h2 id='sdp_supply'>Stochastic Dynamic Programming for water supply reservoirs</h2><span id='topic+sdp_supply'></span>

<h3>Description</h3>

<p>Derives the optimal release policy based on storage state and within-year period only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdp_supply(Q, capacity, target, surface_area, max_depth, evap, S_disc = 1000,
  R_disc = 10, Q_disc = c(0, 0.2375, 0.475, 0.7125, 0.95, 1),
  loss_exp = 2, S_initial = 1, plot = TRUE, tol = 0.99,
  Markov = FALSE, rep_rrv = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdp_supply_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflow totals to the reservoir. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir storage capacity. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_target">target</code></td>
<td>
<p>numerical. The target release constant. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_surface_area">surface_area</code></td>
<td>
<p>numerical. The reservoir water surface area at maximum capacity. Recommended units: km^2 (square kilometers).</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_max_depth">max_depth</code></td>
<td>
<p>numerical. The maximum water depth of the reservoir at maximum capacity. If omitted, the depth-storage-area relationship will be estimated from surface area and capacity only. Recommended units: meters.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_evap">evap</code></td>
<td>
<p>vector or time series object of length Q, or a numerical constant.  Evaporation from losses from reservoir surface. Varies with level if depth and surface_area parameters are specified. Recommended units: meters, or kg/m2 * 10 ^ -3.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_s_disc">S_disc</code></td>
<td>
<p>integer. Storage discretization&ndash;the number of equally-sized storage states. Default = 1000.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_r_disc">R_disc</code></td>
<td>
<p>integer. Release discretization. Default = 10 divisions.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_q_disc">Q_disc</code></td>
<td>
<p>vector. Inflow discretization bounding quantiles. Defaults to five inflow classes bounded by quantile vector c(0.0, 0.2375, 0.4750, 0.7125, 0.95, 1.0).</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_loss_exp">loss_exp</code></td>
<td>
<p>numeric. The exponent of the penalty cost function&ndash;i.e., Cost[t] &lt;- ((target - release[t]) / target) ^ **loss_exp**). Default value is 2.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_tol">tol</code></td>
<td>
<p>numerical. The tolerance for policy convergence. The default value is 0.990.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_markov">Markov</code></td>
<td>
<p>logical. If TRUE the current period inflow is used as a hydrological state variable and inflow persistence is incorporated using a first-order, periodic Markov chain. The default is FALSE.</p>
</td></tr>
<tr><td><code id="sdp_supply_+3A_rep_rrv">rep_rrv</code></td>
<td>
<p>logical. If TRUE then reliability, resilience and vulnerability metrics are computed and returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list that includes: the optimal policy as an array of release decisions dependent on storage state, month/season, and current-period inflow class; the Bellman cost function based on storage state, month/season, and inflow class; the optimized release and storage time series through the training inflow data; the flow discretization (which is required if the output is to be implemented in the rrv function); and, if requested, the reliability, resilience, and vulnerability of the system under the optimized policy.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dp_supply">dp_supply</a></code> for deterministic Dynamic Programming for water supply reservoirs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>layout(1:3)
sdp_supply(resX$Q_Mm3, capacity = resX$cap_Mm3, target = 0.3 *mean(resX$Q_Mm3))
sdp_supply(resX$Q_Mm3, capacity = resX$cap_Mm3, target = 0.3 *mean(resX$Q_Mm3), Markov = TRUE)
</code></pre>

<hr>
<h2 id='simRes'>Simulate a water supply reservoir with specified operating policy.</h2><span id='topic+simRes'></span>

<h3>Description</h3>

<p>Simulates a reservoir for a given inflow time series and assuming Standard Operating Policy (meet target at all times, unless constrained by available water in reservoir plus incoming flows) or an optimised policy deived using <code><a href="#topic+sdp_supply">sdp_supply</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simRes(Q, target, capacity, surface_area, max_depth, evap,
  double_cycle = FALSE, plot = TRUE, S_initial = 1, policy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simRes_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflow totals to the reservoir. Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="simRes_+3A_target">target</code></td>
<td>
<p>numerical constant, or a time series or vector of the target releases. Must be the same length as Q is given as a vector or time series. Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="simRes_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir capacity. Should be same volumetric unit as Q. Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="simRes_+3A_surface_area">surface_area</code></td>
<td>
<p>numerical. The reservoir surface area at full capacity. Must be in square kilometers (km^2), or Mm^2.</p>
</td></tr>
<tr><td><code id="simRes_+3A_max_depth">max_depth</code></td>
<td>
<p>numerical. The maximum water depth of the reservoir at maximum capacity. Must be in meters. If omitted, the depth-storage-area relationship will be estimated from surface area and capacity only.</p>
</td></tr>
<tr><td><code id="simRes_+3A_evap">evap</code></td>
<td>
<p>vector or time series object of length Q, or a numerical constant.  Evaporation from losses from reservoir surface. Varies with level if depth and surface_area parameters are specified. Recommended units: meters, or kg/m2 * 10 ^ -3.</p>
</td></tr>
<tr><td><code id="simRes_+3A_double_cycle">double_cycle</code></td>
<td>
<p>logical. If TRUE the Q and R time series will be replicated and placed end-to-end to double the simulation. Recommended if the critical period occurs at the end of the sequence.</p>
</td></tr>
<tr><td><code id="simRes_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage and release time series are plotted.</p>
</td></tr>
<tr><td><code id="simRes_+3A_s_initial">S_initial</code></td>
<td>
<p>numerical. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="simRes_+3A_policy">policy</code></td>
<td>
<p>list. The output of the SDP function. If omitted, Standard Operating Policy is assumed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the no-fail storage capacity and corresponding storage behaviour time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate a reservoir assuming standard operating policy, then compare with SDP-derived policy
#trained on historical flows.

# DEFINE RESERVOIR SPECS AND MODEL INPUTS
res_cap &lt;- 1500 #Mm3
targ &lt;- 150 #Mm3
area &lt;- 40 #km2
max_d &lt;- 40 #m
ev = 0.2 #m
Q_pre1980 &lt;- window(resX$Q_Mm3, end = c(1979, 12), frequency = 12)
Q_post1980 &lt;- window(resX$Q_Mm3, start = c(1980, 1), frequency = 12)

# SIMULATE WITH SOP
layout(1:3)
simSOP &lt;- simRes(Q_post1980, capacity = res_cap, target = targ,
surface_area = area, max_depth = max_d, evap = ev)

# TRAIN SDP POLICY ON HISTORICAL FLOWS
policy_x &lt;- sdp_supply(Q_pre1980, capacity = res_cap, target = targ,
surface_area = area, max_depth = max_d, evap = ev, Markov = TRUE, plot = FALSE, S_disc = 100)

# SIMULATE WITH SDP-DERIVED POLICY
simSDP &lt;- simRes(Q_post1980, capacity = res_cap, target = targ,
surface_area = area, max_depth = max_d, evap = ev, policy = policy_x)
</code></pre>

<hr>
<h2 id='storage'>Storage-Reliability-Yield (SRY) relationships: Storage computation</h2><span id='topic+storage'></span>

<h3>Description</h3>

<p>Returns the required storage for given inflow time series, yield, and target time-based reliability. Assumes standard operating policy. Storage is computed iteratively using the bi-section method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storage(Q, yield, reliability, demand_profile, plot = TRUE, S_initial = 1,
  max_iterations = 50, double_cycle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storage_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflow totals to the reservoir. Recommended units: Mm^3 (Million cubic meters).</p>
</td></tr>
<tr><td><code id="storage_+3A_yield">yield</code></td>
<td>
<p>the required yield. Must be same volumetric units as Q.</p>
</td></tr>
<tr><td><code id="storage_+3A_reliability">reliability</code></td>
<td>
<p>numerical. The required time-based reliability.</p>
</td></tr>
<tr><td><code id="storage_+3A_demand_profile">demand_profile</code></td>
<td>
<p>a vector of factors with length = frequency(Q). Represents within-year demand profile. Defaults to constant release if left blank.</p>
</td></tr>
<tr><td><code id="storage_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="storage_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="storage_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations for yield computation.</p>
</td></tr>
<tr><td><code id="storage_+3A_double_cycle">double_cycle</code></td>
<td>
<p>logical. If TRUE the input series will be replicated and placed end-to-end to double the simulation. (Recommended if the critical period occurs at the end of the recorded inflow time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the required storage capacity necessary to supply specified yield with specified reliability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Determine the required storage for 95 % reliability and yield equal to 80 % of the mean inflow.
layout(1:3)
storage(resX$Q_Mm3 * 20, yield = 0.9 * mean(resX$Q_Mm3), reliability = 0.95)
</code></pre>

<hr>
<h2 id='yield'>Storage-Reliability-Yield (SRY) relationships: Yield computation</h2><span id='topic+yield'></span>

<h3>Description</h3>

<p>Returns the yield for given inflow time series, reservoir capacity, and required time-based reliability. Assumes standard operating policy. Yield is computed iteratively using the bi-section method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yield(Q, capacity, reliability, demand_profile, plot = TRUE, S_initial = 1,
  max_iterations = 50, double_cycle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yield_+3A_q">Q</code></td>
<td>
<p>vector or time series object. Net inflow totals to the reservoir.</p>
</td></tr>
<tr><td><code id="yield_+3A_capacity">capacity</code></td>
<td>
<p>numerical. The reservoir storage capacity. Must be in the same volumetric units as Q.</p>
</td></tr>
<tr><td><code id="yield_+3A_reliability">reliability</code></td>
<td>
<p>numerical. The required time-based reliability.</p>
</td></tr>
<tr><td><code id="yield_+3A_demand_profile">demand_profile</code></td>
<td>
<p>a vector of factors with length = frequency(Q). Represents within-year demand profile. Defaults to constant release if left blank.</p>
</td></tr>
<tr><td><code id="yield_+3A_plot">plot</code></td>
<td>
<p>logical. If TRUE (the default) the storage behavior diagram and release time series are plotted.</p>
</td></tr>
<tr><td><code id="yield_+3A_s_initial">S_initial</code></td>
<td>
<p>numeric. The initial storage as a ratio of capacity (0 &lt;= S_initial &lt;= 1). The default value is 1.</p>
</td></tr>
<tr><td><code id="yield_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Maximum number of iterations for yield computation.</p>
</td></tr>
<tr><td><code id="yield_+3A_double_cycle">double_cycle</code></td>
<td>
<p>logical. If TRUE the input series will be replicated and placed end-to-end to double the simulation. (Recommended if the critical period occurs at the end of the recorded inflow time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns yield of a reservoir with specified storage capacity and time-based reliability.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute yield for 0.95 reliability
layout(1:3)
yield_ResX &lt;- yield(resX$Q_Mm3, capacity = 500, reliability = 0.95)
# Compute yield for quarterly time series with seasonal demand profile

quart_ts &lt;- aggregate(resX$Q_Mm3, nfrequency = 4)
yld &lt;- yield(quart_ts,
capacity = 500, reliability = 0.9, demand_profile = c(0.8, 1.2, 1.2, 0.8))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
