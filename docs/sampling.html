<!DOCTYPE html><html><head><title>Help for package sampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#balancedcluster'><p>Balanced cluster</p></a></li>
<li><a href='#balancedstratification'><p>Balanced stratification</p></a></li>
<li><a href='#balancedtwostage'><p>Balanced two-stage sampling</p></a></li>
<li><a href='#belgianmunicipalities'><p> The Belgian municipalities population</p></a></li>
<li><a href='#calib'><p>g-weights of the calibration estimator</p></a></li>
<li><a href='#calibev'><p>Calibration estimator and its variance estimation</p></a></li>
<li><a href='#checkcalibration'><p>Check calibration</p></a></li>
<li><a href='#cleanstrata'><p> Clean strata</p></a></li>
<li><a href='#cluster'><p>Cluster sampling</p></a></li>
<li><a href='#disjunctive'><p>Disjunctive combination</p></a></li>
<li><a href='#fastflightcube'><p>Fast flight phase for the cube method</p></a></li>
<li><a href='#gencalib'><p>g-weights of the generalized calibration estimator</p></a></li>
<li><a href='#getdata'><p>Get data</p></a></li>
<li><a href='#Hajekestimator'><p>The Hajek estimator</p></a></li>
<li><a href='#Hajekstrata'><p>The Hajek estimator for a stratified design</p></a></li>
<li><a href='#HTestimator'><p>The Horvitz-Thompson estimator</p></a></li>
<li><a href='#HTstrata'><p>The Horvitz-Thompson estimator for a stratified design</p></a></li>
<li><a href='#inclusionprobabilities'><p>Inclusion probabilities</p></a></li>
<li><a href='#inclusionprobastrata'><p>Inclusion probabilities for a stratified design</p></a></li>
<li><a href='#landingcube'><p>Landing phase for the cube method</p></a></li>
<li><a href='#mstage'><p>Multistage sampling</p></a></li>
<li><a href='#MU284'><p> The MU284 population</p></a></li>
<li><a href='#postest'><p>Poststratified estimator</p></a></li>
<li><a href='#poststrata'><p>Postratification</p></a></li>
<li><a href='#ratioest'><p>Ratio estimator</p></a></li>
<li><a href='#ratioest_strata'><p>Ratio estimator for a stratified design</p></a></li>
<li><a href='#rec99'><p> The 1999 census data</p></a></li>
<li><a href='#regest'><p>Regression estimator</p></a></li>
<li><a href='#regest_strata'><p>Regression estimator for a stratified design</p></a></li>
<li><a href='#rhg'><p>Response homogeneity groups</p></a></li>
<li><a href='#rhg_strata'><p>Response homogeneity groups for a stratified sampling</p></a></li>
<li><a href='#rmodel'><p>Response probability using logistic regression</p></a></li>
<li><a href='#samplecube'><p>Sample cube method</p></a></li>
<li><a href='#sampling-internal'><p>Internal sampling Functions</p></a></li>
<li><a href='#srswor'><p>Simple random sampling without replacement</p></a></li>
<li><a href='#srswor1'><p>Selection-rejection method</p></a></li>
<li><a href='#srswr'><p>Simple random sampling with replacement</p></a></li>
<li><a href='#strata'><p>Stratified sampling</p></a></li>
<li><a href='#swissmunicipalities'><p>The Swiss municipalities population</p></a></li>
<li><a href='#UPbrewer'><p>Brewer sampling</p></a></li>
<li><a href='#UPmaxentropy'><p>Maximum entropy sampling</p></a></li>
<li><a href='#UPmidzuno'><p>Midzuno sampling</p></a></li>
<li><a href='#UPmidzunopi2'><p>Joint inclusion probabilities for Midzuno sampling</p></a></li>
<li><a href='#UPminimalsupport'><p>Minimal support sampling</p></a></li>
<li><a href='#UPmultinomial'><p>Multinomial sampling</p></a></li>
<li><a href='#UPopips'><p>Order pips sampling</p></a></li>
<li><a href='#UPpivotal'><p>Pivotal sampling</p></a></li>
<li><a href='#UPpoisson'><p>Poisson sampling</p></a></li>
<li><a href='#UPrandompivotal'><p>Random pivotal sampling</p></a></li>
<li><a href='#UPrandomsystematic'><p>Random systematic sampling</p></a></li>
<li><a href='#UPsampford'><p>Sampford sampling</p></a></li>
<li><a href='#UPsampfordpi2'><p>Joint inclusion probabilities for Sampford sampling</p></a></li>
<li><a href='#UPsystematic'><p>Systematic sampling</p></a></li>
<li><a href='#UPsystematicpi2'><p>Joint inclusion probabilities for systematic sampling</p></a></li>
<li><a href='#UPtille'><p>Tille sampling</p></a></li>
<li><a href='#UPtillepi2'><p>Joint inclusion probabilties for Tille sampling</p></a></li>
<li><a href='#varest'><p>Variance estimation using the Deville's method</p></a></li>
<li><a href='#varHT'><p>Variance estimators of the Horvitz-Thompson estimator</p></a></li>
<li><a href='#vartaylor_ratio'><p>Taylor-series linearization variance estimation of a ratio</p></a></li>
<li><a href='#writesample'><p>All possible samples of fixed size</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Survey Sampling</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Tillé &lt;yves.tille@unine.ch&gt;, Alina Matei &lt;alina.matei@unine.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alina Matei &lt;alina.matei@unine.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to draw random samples using different sampling schemes are available. Functions are also provided to obtain (generalized) calibration weights, different estimators, as well some variance estimators.  </td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, lpSolve</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-29 14:17:06 UTC; MateiA</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-29 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='balancedcluster'>Balanced cluster</h2><span id='topic+balancedcluster'></span>

<h3>Description</h3>

<p>Selects a balanced cluster sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balancedcluster(X,m,cluster,selection=1,comment=TRUE,method=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balancedcluster_+3A_x">X</code></td>
<td>
<p>matrix of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="balancedcluster_+3A_m">m</code></td>
<td>
<p>number of clusters to be selected.</p>
</td></tr>
<tr><td><code id="balancedcluster_+3A_cluster">cluster</code></td>
<td>
<p>vector of integers that defines the clusters.</p>
</td></tr>
<tr><td><code id="balancedcluster_+3A_selection">selection</code></td>
<td>
<p>1, selection of the clusters with probabilities proportional 
to size,<br /> 2, selection of the clusters with equal probabilities.</p>
</td></tr>
<tr><td><code id="balancedcluster_+3A_comment">comment</code></td>
<td>
<p>a comment is written during the execution if <code>comment</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="balancedcluster_+3A_method">method</code></td>
<td>
<p>the used method in the function <code>samplecube</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix containing the vector of inclusion probabilities and
the selected sample.</p>


<h3>See Also</h3>

<p><code><a href="#topic+samplecube">samplecube</a></code>, <code><a href="#topic+fastflightcube">fastflightcube</a></code>, <code><a href="#topic+landingcube">landingcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# definition of the clusters; there are 15 units in 3 clusters
cluster=c(1,1,1,1,1,2,2,2,2,2,3,3,3,3,3)
# matrix of balancing variables
X=cbind(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))
# selection of 2 clusters
s=balancedcluster(X,2,cluster,2,TRUE)
# the sample of clusters with the inclusion probabilities of the clusters
s
# the selected clusters
unique(cluster[s[,1]==1])
# the selected units 
(1:length(cluster))[s[,1]==1]
# with the probabilities
s[s[,1]==1,2]
############
## Example 2
############
data(MU284)
X=cbind(MU284$P75,MU284$CS82,MU284$SS82,MU284$S82,MU284$ME84)
s=balancedcluster(X,10,MU284$CL,1,TRUE)
cluster=MU284$CL
# the selected clusters
unique(cluster[s[,1]==1])
# the selected units 
(1:length(cluster))[s[,1]==1]
# with the probabilities
s[s[,1]==1,2]
</code></pre>

<hr>
<h2 id='balancedstratification'>Balanced stratification</h2><span id='topic+balancedstratification'></span>

<h3>Description</h3>

<p>Selects a stratified balanced sample (a vector of 0 and 1).
Firstly, the flight phase is applied in each stratum. Secondly, the strata
are aggregated and the flight phase is applied on the whole population.
Finally, the landing phase is applied on the whole population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balancedstratification(X,strata,pik,comment=TRUE,method=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balancedstratification_+3A_x">X</code></td>
<td>
<p>matrix of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="balancedstratification_+3A_strata">strata</code></td>
<td>
<p>vector of integers that specifies the stratification.</p>
</td></tr>
<tr><td><code id="balancedstratification_+3A_pik">pik</code></td>
<td>
<p>vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="balancedstratification_+3A_comment">comment</code></td>
<td>
<p>a comment is written during the execution if <code>comment</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="balancedstratification_+3A_method">method</code></td>
<td>
<p>the used method in the function <code>samplecube</code>.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Tillé, Y. (2006), <em>Sampling Algorithms</em>, Springer.<br />
Chauvet, G. and Tillé, Y. (2006). A fast algorithm of balanced sampling. <em>Computational Statistics</em>, 21/1:53&ndash;62. <br />
Chauvet, G. and Tillé, Y. (2005). New SAS macros for balanced sampling. In INSEE, editor, <em>Journées de Méthodologie Statistique</em>, Paris.<br />
Deville, J.-C. and Tillé, Y. (2004). Efficient balanced sampling: the cube method. <em>Biometrika</em>, 91:893&ndash;912.<br />
Deville, J.-C. and Tillé, Y. (2005). Variance approximation under balanced sampling. <em>Journal of Statistical Planning and Inference</em>, 128/2:411&ndash;425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samplecube">samplecube</a></code>, <code><a href="#topic+fastflightcube">fastflightcube</a></code>, <code><a href="#topic+landingcube">landingcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# variable of stratification (3 strata)
strata=c(1,1,1,1,1,2,2,2,2,2,3,3,3,3,3)
# matrix of balancing variables
X=cbind(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))
# Vector of inclusion probabilities.
# the sample has its size equal to 9.
pik=rep(3/5,times=15)
# selection of a stratified sample
s=balancedstratification(X,strata,pik,comment=TRUE)
# the sample is
(1:length(pik))[s==1]
############
## Example 2
############
data(MU284)
X=cbind(MU284$P75,MU284$CS82,MU284$SS82,MU284$S82,MU284$ME84)
strata=MU284$REG
pik=inclusionprobabilities(MU284$P75,80)
s=balancedstratification(X,strata,pik,TRUE)
#the selected units are
MU284$LABEL[s==1]
</code></pre>

<hr>
<h2 id='balancedtwostage'>Balanced two-stage sampling</h2><span id='topic+balancedtwostage'></span>

<h3>Description</h3>

<p>Selects a balanced two-stage sample.</p>


<h3>Usage</h3>

<pre><code class='language-R'>balancedtwostage(X,selection,m,n,PU,comment=TRUE,method=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balancedtwostage_+3A_x">X</code></td>
<td>
<p>matrix of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="balancedtwostage_+3A_selection">selection</code></td>
<td>
<p>1, for simple random sampling without replacement at each stage,<br />
2, for self-weighting two-stage selection.</p>
</td></tr>
<tr><td><code id="balancedtwostage_+3A_m">m</code></td>
<td>
<p>number of primary sampling units to be selected.</p>
</td></tr>
<tr><td><code id="balancedtwostage_+3A_n">n</code></td>
<td>
<p>number of second-stage sampling units to be selected.</p>
</td></tr>
<tr><td><code id="balancedtwostage_+3A_pu">PU</code></td>
<td>
<p>vector of integers that defines the primary sampling units.</p>
</td></tr>
<tr><td><code id="balancedtwostage_+3A_comment">comment</code></td>
<td>
<p>a comment is written during the execution if <code>comment</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="balancedtwostage_+3A_method">method</code></td>
<td>
<p>the used method in the function <code>samplecube</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a matrix whose columns are the following five vectors:
the selected second-stage sampling units (0 - unselected, 1 - selected), 
the final inclusion probabilities,
the selected primary sampling units,
the inclusion probabilities of the first stage,
the inclusion probabilities of the second stage.</p>


<h3>See Also</h3>

<p><code><a href="#topic+samplecube">samplecube</a></code>, <code><a href="#topic+fastflightcube">fastflightcube</a></code>, <code><a href="#topic+landingcube">landingcube</a></code>,
<code><a href="#topic+balancedstratification">balancedstratification</a></code>, <code><a href="#topic+balancedcluster">balancedcluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# definition of the primary units (3 primary units)
PU=c(1,1,1,1,1,2,2,2,2,2,3,3,3,3,3)
# matrix of balancing variables
X=cbind(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))
# selection of 2 primary sampling units and 4 second-stage sampling units
# sample and inclusion probabilities
s=balancedtwostage(X,1,2,4,PU,comment=TRUE)
s
############
## Example 2
############
data(MU284)
X=cbind(MU284$P75,MU284$CS82,MU284$SS82,MU284$ME84)
N=dim(X)[1]
PU=MU284$CL
m=20
n=60
# sample and inclusion probabilities
s=balancedtwostage(X,1,m,n,PU,TRUE)
s
</code></pre>

<hr>
<h2 id='belgianmunicipalities'> The Belgian municipalities population</h2><span id='topic+belgianmunicipalities'></span>

<h3>Description</h3>

<p>This data provides information about
the Belgian population of July 1, 2004 compared to that of July 1,  
2003, and some financial information about the municipality incomes at the end of 2001. </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(belgianmunicipalities)</code></pre>


<h3>Format</h3>

<p>A data frame with 589 observations on the following 17 variables:
</p>

<dl>
<dt>Commune</dt><dd><p>municipality name.</p>
</dd>
<dt>INS</dt><dd><p>&lsquo;Institut National de statistique&rsquo; code.</p>
</dd>
<dt>Province</dt><dd><p>province number.</p>
</dd>
<dt>Arrondiss</dt><dd><p>administrative division number.</p>
</dd>
<dt>Men04</dt><dd><p>number of men on July 1, 2004.</p>
</dd>
<dt>Women04</dt><dd><p>number of women on July 1, 2004.</p>
</dd>
<dt>Tot04</dt><dd><p>total population on July 1, 2004.</p>
</dd>
<dt>Men03</dt><dd><p>number of men on July 1, 2003.</p>
</dd>
<dt>Women03</dt><dd><p>number of women on July 1, 2003.</p>
</dd>
<dt>Tot03</dt><dd><p>total population on July 1, 2003.</p>
</dd>
<dt>Diffmen</dt><dd><p>number of men on July 1, 2004 minus the number of men on July 1, 2003.</p>
</dd>
<dt>Diffwom</dt><dd><p>number of women on July 1, 2004 minus the number of women on July 1, 2003.</p>
</dd>
<dt>DiffTOT</dt><dd><p>difference between the total population on July 1, 2004 and on July 1, 2003.</p>
</dd>
<dt>TaxableIncome</dt><dd><p>total taxable income in euros in 2001.</p>
</dd>
<dt>Totaltaxation</dt><dd><p>total taxation in euros in 2001.</p>
</dd>
<dt>averageincome</dt><dd><p>average of the income-tax return in euros in 2001.</p>
</dd>
<dt>medianincome</dt><dd><p>median of the income-tax return in euros in 2001.</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://https://statbel.fgov.be/fr</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(belgianmunicipalities)
hist(belgianmunicipalities$medianincome)
</code></pre>

<hr>
<h2 id='calib'>g-weights of the calibration estimator</h2><span id='topic+calib'></span>

<h3>Description</h3>

<p>Computes the g-weights of the calibration estimator. The g-weights should lie in the specified bounds for the 
truncated and logit methods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calib(Xs,d,total,q=rep(1,length(d)),method=c("linear","raking","truncated",
"logit"),bounds=c(low=0,upp=10),description=FALSE,max_iter=500)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calib_+3A_xs">Xs</code></td>
<td>
<p>matrix of calibration variables.</p>
</td></tr>
<tr><td><code id="calib_+3A_d">d</code></td>
<td>
<p>vector of initial weights.</p>
</td></tr>
<tr><td><code id="calib_+3A_total">total</code></td>
<td>
<p>vector of population totals.</p>
</td></tr>
<tr><td><code id="calib_+3A_q">q</code></td>
<td>
<p>vector of positive values accounting for heteroscedasticity; the variation of the g-weights is reduced for small values of q.</p>
</td></tr>
<tr><td><code id="calib_+3A_method">method</code></td>
<td>
<p>calibration method (linear, raking, logit, truncated).</p>
</td></tr>
<tr><td><code id="calib_+3A_bounds">bounds</code></td>
<td>
<p>vector of bounds for the g-weights used in the truncated and logit methods; 
'low' is the smallest value and 'upp' is the largest value.</p>
</td></tr>
<tr><td><code id="calib_+3A_description">description</code></td>
<td>
<p>if description=TRUE, summary of initial and final weights are printed, 
and their boxplots and histograms are drawn; by default, its value is FALSE.</p>
</td></tr>
<tr><td><code id="calib_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations in the Newton's method.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The argument <em>method</em> implements the methods given in the paper of Deville and Särndal(1992).</p>


<h3>Value</h3>

<p>Returns the vector of g-weights.</p>


<h3>References</h3>

 
<p>Cassel, C.-M., Särndal, C.-E., and Wretman, J. (1976). Some results on generalized difference estimation and generalized regression estimation for finite population.<em>Biometrika</em>, 63:615&ndash;620. <br />
Deville, J.-C. and Särndal, C.-E. (1992). Calibration estimators in survey sampling. <em>Journal of the American Statistical Association</em>, 87:376&ndash;382.<br />
Deville, J.-C., Särndal, C.-E., and Sautory, O. (1993). Generalized raking procedure in survey sampling. <em>Journal of the American Statistical Association</em>, 88:1013&ndash;1020.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkcalibration">checkcalibration</a></code>, <code><a href="#topic+calibev">calibev</a></code>, <code><a href="#topic+gencalib">gencalib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# matrix of sample calibration variables 
Xs=cbind(
c(1,1,1,1,1,0,0,0,0,0),
c(0,0,0,0,0,1,1,1,1,1),
c(1,2,3,4,5,6,7,8,9,10)
)
# inclusion probabilities
piks=rep(0.2,times=10)
# vector of population totals
total=c(24,26,290)
# the g-weights using the truncated method
g=calib(Xs,d=1/piks,total,method="truncated",bounds=c(0.75,1.2))
# the calibration estimator of X is equal to 'total' vector
t(g/piks)%*%Xs
# the g-weights are between lower and upper bounds
range(g)
############
## Example 2
############
# Example of g-weights (linear, raking, truncated, logit),
# with the data of Belgian municipalities as population.
# Firstly, a sample is selected by means of Poisson sampling.
# Secondly, the g-weights are calculated.
data(belgianmunicipalities)
attach(belgianmunicipalities)
# matrix of calibration variables for the population
X=cbind(
Men03/mean(Men03),
Women03/mean(Women03),
Diffmen,
Diffwom,
TaxableIncome/mean(TaxableIncome),
Totaltaxation/mean(Totaltaxation),
averageincome/mean(averageincome),
medianincome/mean(medianincome))
# selection of a sample with expectation size equal to 200
# by means of Poisson sampling
# the inclusion probabilities are proportional to the average income 
pik=inclusionprobabilities(averageincome,200)
N=length(pik)               # population size
s=UPpoisson(pik)            # sample
Xs=X[s==1,]                 # sample matrix of calibration variables
piks=pik[s==1]              # sample inclusion probabilities
n=length(piks)              # expected sample size
# vector of population totals of the calibration variables
total=c(t(rep(1,times=N))%*%X)  
# computation of the g-weights
# by means of different calibration methods
g1=calib(Xs,d=1/piks,total,method="linear")
g2=calib(Xs,d=1/piks,total,method="raking")
g3=calib(Xs,d=1/piks,total,method="truncated",bounds=c(0.5,1.5))
g4=calib(Xs,d=1/piks,total,method="logit",bounds=c(0.5,1.5))
# in some cases, the calibration is not possible,
# particularly when bounds are used.
# if the calibration is possible, the calibration estimator of X is printed
if(checkcalibration(Xs,d=1/piks,total,g1)$result) 
    print(c((g1/piks) %*% Xs)) else print("error")
if(!is.null(g2))
    if(checkcalibration(Xs,d=1/piks,total,g2)$result) 
if(!is.null(g3))
     if(checkcalibration(Xs,d=1/piks,total,g3)$result &amp; all(g3&lt;=1.5) &amp; all(g3&gt;=0.5))
        print(c((g3/piks) %*% Xs)) else print("error")
if(!is.null(g4))
    if(checkcalibration(Xs,d=1/piks,total,g4)$result &amp; all(g4&lt;=1.5) &amp; all(g4&gt;=0.5)) 
         print(c((g4/piks) %*% Xs)) else print("error")
detach(belgianmunicipalities)
############
## Example 3
############
# Example of calibration and adjustment for nonresponse in the 'calibration' vignette
# vignette("calibration", package="sampling")
</code></pre>

<hr>
<h2 id='calibev'>Calibration estimator and its variance estimation</h2><span id='topic+calibev'></span>

<h3>Description</h3>

<p>Computes the calibration estimator of the population total and its variance estimation using the residuals' method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibev(Ys,Xs,total,pikl,d,g,q=rep(1,length(d)),with=FALSE,EPS=1e-6)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibev_+3A_ys">Ys</code></td>
<td>
<p>vector of interest variable; its size is n, the sample size.</p>
</td></tr>
<tr><td><code id="calibev_+3A_xs">Xs</code></td>
<td>
<p>matrix of sample calibration variables.</p>
</td></tr>
<tr><td><code id="calibev_+3A_total">total</code></td>
<td>
<p>vector of population totals for calibration.</p>
</td></tr>
<tr><td><code id="calibev_+3A_pikl">pikl</code></td>
<td>
<p>matrix of joint inclusion probabilities of the sample units.</p>
</td></tr>
<tr><td><code id="calibev_+3A_d">d</code></td>
<td>
<p>vector of initial weights of the sample units.</p>
</td></tr>
<tr><td><code id="calibev_+3A_g">g</code></td>
<td>
<p>vector of g-weights; its size is n, the sample size.</p>
</td></tr>
<tr><td><code id="calibev_+3A_q">q</code></td>
<td>
<p>vector of positive values accounting for heteroscedasticity; its size is n, the sample size.</p>
</td></tr>
<tr><td><code id="calibev_+3A_with">with</code></td>
<td>
<p>if TRUE, the variance estimation takes into account the initial weights d; otherwise, the final weights w=g*d are taken
into account; by default, its value is FALSE.</p>
</td></tr>
<tr><td><code id="calibev_+3A_eps">EPS</code></td>
<td>
<p>tolerance in checking the calibration; by default, its value is 1e-6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If with is TRUE, the following formula is used
</p>
<p style="text-align: center;"><code class="reqn">\widehat{Var}(\widehat{Ys})=\sum_{k\in s}\sum_{\ell\in s}((\pi_{k\ell}-\pi_k\pi_{\ell})/\pi_{k\ell})(d_ke_k)(d_\ell e_\ell)</code>
</p>

<p>else 
</p>
<p style="text-align: center;"><code class="reqn">\widehat{Var}(\widehat{Ys})=\sum_{k\in s}\sum_{\ell\in s}((\pi_{k\ell}-\pi_k\pi_{\ell})/\pi_{k\ell})(w_ke_k)(w_\ell e_\ell)</code>
</p>

<p>where <code class="reqn">e_k</code> denotes the residual of unit k.
</p>


<h3>Value</h3>

<p>The function returns two values:
</p>
<table>
<tr><td><code>cest</code></td>
<td>
<p>the calibration estimator,</p>
</td></tr> 
<tr><td><code>evar</code></td>
<td>
<p>its estimated variance.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Deville, J.-C. and Särndal, C.-E. (1992). Calibration estimators in survey sampling. <em>Journal of the American Statistical Association</em>, 87:376&ndash;382.<br />
Deville, J.-C., Särndal, C.-E., and Sautory, O. (1993). Generalized raking procedure in survey sampling. <em>Journal of the American Statistical Association</em>, 88:1013&ndash;1020.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calib">calib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example
############
# Example of g-weights (linear, raking, truncated, logit),
# with the data of Belgian municipalities as population.
# Firstly, a sample is selected by means of systematic sampling.
# Secondly, the g-weights are calculated.
data(belgianmunicipalities)
attach(belgianmunicipalities)
# matrix of calibration variables for the population
X=cbind(
Men03/mean(Men03),
Women03/mean(Women03),
Diffmen,
Diffwom,
TaxableIncome/mean(TaxableIncome),
Totaltaxation/mean(Totaltaxation),
averageincome/mean(averageincome),
medianincome/mean(medianincome))
# selection of a sample of size 200
# using systematic sampling
# the inclusion probabilities are proportional to the average income 
pik=inclusionprobabilities(averageincome,200)
N=length(pik)               # population size
s=UPsystematic(pik)         # draws a sample s using systematic sampling    
Xs=X[s==1,]                 # matrix of sample calibration variables
piks=pik[s==1]              # sample inclusion probabilities
n=length(piks)              # sample size
# vector of population totals of the calibration variables
total=c(t(rep(1,times=N))%*%X)  
g1=calib(Xs,d=1/piks,total,method="linear") # computes the g-weights
pikl=UPsystematicpi2(pik)   # computes the matrix of joint inclusion probabilities 
pikls=pikl[s==1,s==1]       # the same matrix for the units in the sample
Ys=Tot04[s==1]          # the variable of interest is Tot04 (sample level)
calibev(Ys,Xs,total,pikls,d=1/piks,g1,with=FALSE,EPS=1e-6)
detach(belgianmunicipalities)
</code></pre>

<hr>
<h2 id='checkcalibration'>Check calibration</h2><span id='topic+checkcalibration'></span>

<h3>Description</h3>

<p>Checks the validity of the calibration. In some cases, the computed g-weights do not allow calibration and the calibration estimators
do not exist.</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkcalibration(Xs, d, total, g, EPS=1e-6)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkcalibration_+3A_xs">Xs</code></td>
<td>
<p>matrix of calibration variables.</p>
</td></tr>
<tr><td><code id="checkcalibration_+3A_d">d</code></td>
<td>
<p>vector of initial weights.</p>
</td></tr>
<tr><td><code id="checkcalibration_+3A_total">total</code></td>
<td>
<p>vector of population totals.</p>
</td></tr>
<tr><td><code id="checkcalibration_+3A_g">g</code></td>
<td>
<p>vector of g-weights.</p>
</td></tr>
<tr><td><code id="checkcalibration_+3A_eps">EPS</code></td>
<td>
<p>control value used to check the calibration, by default equal to 1e-6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case where calibration is not possible, the 'value' indicates the difference
in obtaining the calibration.</p>


<h3>Value</h3>

<p>The function returns the following three objects:
</p>
<table>
<tr><td><code>message</code></td>
<td>
<p>a message concerning the calibration,</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>TRUE if the calibration is possible and FALSE, otherwise.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>value of max(abs(tr-total)/total, which is used as criterium to validate the 
calibration, where tr=crossprod(Xs, g*d). If the <code>total</code> vector contains zeros, the value is max(abs(tr-total)).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+calib">calib</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matrix of auxiliary variables
Xs=cbind(c(1,1,1,1,1,0,0,0,0,0),c(0,0,0,0,0,1,1,1,1,1),c(1,2,3,4,5,6,7,8,9,10))
# inclusion probabilities
pik=rep(0.2,times=10)
# vector of totals
total=c(24,26,280)
# g-weights
g=calib(Xs,d=1/pik,total,method="raking")
# check if the calibration is possible
checkcalibration(Xs,d=1/pik,total,g)
</code></pre>

<hr>
<h2 id='cleanstrata'> Clean strata</h2><span id='topic+cleanstrata'></span>

<h3>Description</h3>

<p>Renumbers a variable of stratification
(categorical variable). The strata receive a number from 1 to the last stratum number. 
The empty strata are suppressed. This function is used in &lsquo;balancedstratification&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanstrata(strata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanstrata_+3A_strata">strata</code></td>
<td>
<p>vector of stratum numbers.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+balancedstratification">balancedstratification</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># definition of the stratification variable
strata=c(-2,3,-2,3,4,4,4,-2,-2,3,4,0,0,0)
# renumber the strata
cleanstrata(strata)
</code></pre>

<hr>
<h2 id='cluster'>Cluster sampling</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>Cluster sampling with equal/unequal probabilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(data, clustername, size, method=c("srswor","srswr","poisson",
"systematic"),pik,description=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_+3A_data">data</code></td>
<td>
<p>data frame or data matrix; its number of rows is N, the population size.</p>
</td></tr>
<tr><td><code id="cluster_+3A_clustername">clustername</code></td>
<td>
<p>the name of the clustering variable.</p>
</td></tr>
<tr><td><code id="cluster_+3A_size">size</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="cluster_+3A_method">method</code></td>
<td>
<p>method to select clusters; the following methods are implemented: simple random 
sampling without replacement (srswor), simple random sampling with replacement (srswr), 
Poisson sampling (poisson), systematic sampling (systematic); if the method is not specified, 
by default the method is &quot;srswor&quot;.</p>
</td></tr>
<tr><td><code id="cluster_+3A_pik">pik</code></td>
<td>
<p>vector of inclusion probabilities or auxiliary information used to compute them; 
this argument is only used for unequal probability sampling (Poisson, systematic). If an
auxiliary information is provided, the function uses the <a href="#topic+inclusionprobabilities">inclusionprobabilities</a> function for
computing these probabilities.</p>
</td></tr>
<tr><td><code id="cluster_+3A_description">description</code></td>
<td>
<p>a message is printed if its value is TRUE; the message gives the number 
of selected clusters, the number of units in the population and the number of selected units. 
By default, the value is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data set with the following information: the selected clusters, the identifier of the units in the selected clusters,
the final inclusion probabilities for these units (they are equal for the units included in the same cluster). If method is &quot;srswr&quot;, the number of replicates is also given. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mstage">mstage</a></code>, <code><a href="#topic+strata">strata</a></code>, <code><a href="#topic+getdata">getdata</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# Uses the swissmunicipalities data to draw a sample of clusters
data(swissmunicipalities)
# the variable 'REG' has 7 categories in the population
# it is used as clustering variable
# the sample size is 3; the method is simple random sampling without replacement
cl=cluster(swissmunicipalities,clustername=c("REG"),size=3,method="srswor")
# extracts the observed data 
# the order of the columns is different from the order in the initial database
getdata(swissmunicipalities, cl)
############
## Example 2
############
# the same data as in Example 1
# the sample size is 3; the method is systematic sampling
# the pik vector is randomly generated using the U(0,1) distribution
cl_sys=cluster(swissmunicipalities,clustername=c("REG"),size=3,method="systematic",
pik=runif(7))
# extracts the observed data
getdata(swissmunicipalities,cl_sys)
</code></pre>

<hr>
<h2 id='disjunctive'>Disjunctive combination</h2><span id='topic+disjunctive'></span>

<h3>Description</h3>

<p>Transforms a categorical variable
into a matrix of indicators. The values of the categorical variable are integer numbers (positive or negative).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disjunctive(strata)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disjunctive_+3A_strata">strata</code></td>
<td>
<p>vector of integer numbers.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>
<a href="#topic+balancedstratification">balancedstratification</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># definition of the variable of stratification
strata=c(-2,3,-2,3,4,4,4,-2,-2,3,4,0,0,0)
# computation of the matrix
disjunctive(strata)
</code></pre>

<hr>
<h2 id='fastflightcube'>Fast flight phase for the cube method</h2><span id='topic+fastflightcube'></span>

<h3>Description</h3>

<p>Executes the fast flight phase 
of the cube method (algorithm of Chauvet and Tillé, 2005, 2006).
The data are sorted following the argument <code>order</code>. Inclusion probabilities equal to
0 or 1 are tolerated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastflightcube(X,pik,order=1,comment=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastflightcube_+3A_x">X</code></td>
<td>
<p>matrix of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="fastflightcube_+3A_pik">pik</code></td>
<td>
<p>vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="fastflightcube_+3A_order">order</code></td>
<td>

<p>1, the data are randomly arranged,<br />
2, no change in data order,<br />
3, the data are sorted in decreasing order.
</p>
</td></tr>
<tr><td><code id="fastflightcube_+3A_comment">comment</code></td>
<td>
<p>a comment is written during the execution if <code>comment</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Tillé, Y. (2006), <em>Sampling Algorithms</em>, Springer.<br />
Chauvet, G. and Tillé, Y. (2006). A fast algorithm of balanced sampling. <em>Computational Statistics</em>, 21/1:53&ndash;62. <br />
Chauvet, G. and Tillé, Y. (2005). New SAS macros for balanced sampling. In INSEE, editor, <em>Journées de Méthodologie Statistique</em>, Paris.<br />
Deville, J.-C. and Tillé, Y. (2004). Efficient balanced sampling: the cube method. <em>Biometrika</em>, 91:893&ndash;912.<br />
Deville, J.-C. and Tillé, Y. (2005). Variance approximation under balanced sampling. <em>Journal of Statistical Planning and Inference</em>, 128/2:411&ndash;425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samplecube">samplecube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Matrix of balancing variables
X=cbind(c(1,1,1,1,1,1,1,1,1),c(1,2,3,4,5,6,7,8,9))
# Vector of inclusion probabilities.
# The sample size is 3.
pik=c(1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3)
# pikstar is almost a balanced sample and is ready for the landing phase
pikstar=fastflightcube(X,pik,order=1,comment=TRUE)
pikstar
</code></pre>

<hr>
<h2 id='gencalib'>g-weights of the generalized calibration estimator</h2><span id='topic+gencalib'></span>

<h3>Description</h3>

<p>Computes the g-weights of the generalized calibration estimator. The g-weights should lie in the specified bounds for the 
truncated and logit methods. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gencalib(Xs,Zs,d,total,q=rep(1,length(d)),method=c("linear","raking","truncated","logit"),
bounds=c(low=0,upp=10),description=FALSE,max_iter=500,C=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gencalib_+3A_xs">Xs</code></td>
<td>
<p>matrix of calibration variables.</p>
</td></tr>
<tr><td><code id="gencalib_+3A_zs">Zs</code></td>
<td>
<p>matrix of instrumental variables with same dimension as Xs.</p>
</td></tr>
<tr><td><code id="gencalib_+3A_d">d</code></td>
<td>
<p>vector of initial weights.</p>
</td></tr>
<tr><td><code id="gencalib_+3A_total">total</code></td>
<td>
<p>vector of population totals.</p>
</td></tr>
<tr><td><code id="gencalib_+3A_q">q</code></td>
<td>
<p>vector of positive values accounting for heteroscedasticity; the variation of the g-weights is reduced for small values of q.</p>
</td></tr>
<tr><td><code id="gencalib_+3A_method">method</code></td>
<td>
<p>calibration method (linear, raking, logit, truncated).</p>
</td></tr>
<tr><td><code id="gencalib_+3A_bounds">bounds</code></td>
<td>
<p>vector of bounds for the g-weights used in the truncated and logit methods; 
'low' is the smallest value and 'upp' is the largest value.</p>
</td></tr>
<tr><td><code id="gencalib_+3A_description">description</code></td>
<td>
<p>if description=TRUE, summary of initial and final weights are printed, 
and their boxplots and histograms are drawn; by default, its value is FALSE.</p>
</td></tr>
<tr><td><code id="gencalib_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations in the Newton's method.</p>
</td></tr> 
<tr><td><code id="gencalib_+3A_c">C</code></td>
<td>
<p>value of the centering constant, by default equals 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generalized calibration or the instrument vector method computes the g-weights 
<code class="reqn">g_k=F(\lambda'z_k),</code> where <code class="reqn">z_k</code> is a vector with values defined for <code class="reqn">k\in s</code> (or <code class="reqn">k\in r</code> where <code class="reqn">r</code> is the set of respondents) and sharing the dimension of the specified auxiliary vector 
<code class="reqn">x_k</code>. The vectors <code class="reqn">z_k</code> and <code class="reqn">x_k</code> have to be stronlgy correlated. The vector <code class="reqn">\lambda</code> is determined from the calibration equation <code class="reqn">\sum_{k\in s} d_kg_k x_k=\sum_{k\in U} x_k</code> or <code class="reqn">\sum_{k\in r} d_kg_k x_k=\sum_{k\in U} x_k</code>. 
The function <code class="reqn">F</code> plays the same role as in the calibration method (see <code><a href="#topic+calib">calib</a></code>). If Xs=Zs the calibration method is obtain. If the method is &quot;logit&quot;
the g-weights will be centered around the constant C, with low&lt;C&lt;upp. In the calibration method C=1 (see <code><a href="#topic+calib">calib</a></code>). 
</p>


<h3>Value</h3>

<p>The function returns the vector of g-weights.</p>


<h3>References</h3>

 
<p>Deville, J.-C. (1998). La correction de la nonréponse par calage ou par échantillonnage équilibré. Paper presented at the <em>Congrès de l'ACFAS, Sherbrooke, Québec</em>.<br />
Deville, J.-C. (2000). Generalized calibration and application for weighting for non-response, <em>COMPSTAT 2000: proceedings in computational statistics</em>, p. 65&ndash;76.<br />
Estevao, V.M., and Särndal, C.E. (2000). A functional form approach to calibration. <em>Journal of Official Statistics</em>, 16, 379&ndash;399.<br />
Kott, P.S. (2006). Using calibration weighting to adjust for nonresponse and coverage errors. <em>Survey Methodology</em>, 32, 133&ndash;142.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkcalibration">checkcalibration</a></code>, <code><a href="#topic+calib">calib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# matrix of sample calibration variables 
Xs=cbind(
c(1,1,1,1,1,0,0,0,0,0),
c(0,0,0,0,0,1,1,1,1,1),
c(1,2,3,4,5,6,7,8,9,10))
# inclusion probabilities
piks=rep(0.2,times=10)
# vector of population totals
total=c(24,26,290)
# matrix of instrumental variables
Zs=Xs+matrix(runif(nrow(Xs)*ncol(Xs)),nrow(Xs),ncol(Xs))
# the g-weights using the truncated method
g=gencalib(Xs,Zs,d=1/piks,total,method="truncated",bounds=c(0.5,1.5))
# the calibration estimator of X is equal to the 'total' vector
t(g/piks)%*%Xs
# the g-weights are between lower and upper bounds
summary(g)
############
## Example 2
############
# Example of generalized g-weights (linear, raking, truncated, logit),
# with the data of Belgian municipalities as population.
# Firstly, a sample is selected by means of Poisson sampling.
# Secondly, the g-weights are calculated.
data(belgianmunicipalities)
attach(belgianmunicipalities)
# matrix of calibration variables for the population
X=cbind(Totaltaxation/mean(Totaltaxation),medianincome/mean(medianincome))
# selection of a sample with expected size equal to 200
# by means of Poisson sampling
# the inclusion probabilities are proportional to the average income 
pik=inclusionprobabilities(averageincome,200)
N=length(pik)               # population size
s=UPpoisson(pik)            # sample
Xs=X[s==1,]                 # sample calibration variable matrix 
piks=pik[s==1]              # sample inclusion probabilities
n=length(piks)              # expected sample size
# vector of population totals of the calibration variables
total=c(t(rep(1,times=N))%*%X)  
Z=cbind(TaxableIncome/mean(TaxableIncome),averageincome/mean(averageincome))
# defines the instrumental variables (sample level)
Zs=Z[s==1,]
# computation of the generalized g-weights
# by means of different generalized calibration methods
g1=gencalib(Xs,Zs,d=1/piks,total,method="linear")
g2=gencalib(Xs,Zs,d=1/piks,total,method="raking")
g3=gencalib(Xs,Zs,d=1/piks,total,method="truncated",bounds=c(0.5,8))
g4=gencalib(Xs,Zs,d=1/piks,total,method="logit",bounds=c(0.5,1.5))
# In some cases, the calibration is not possible
# particularly when bounds are used.
# if the calibration is possible, the calibration estimator of X total is printed
if(checkcalibration(Xs,d=1/piks,total,g1)$result) print(c((g1/piks)%*% Xs)) else print("error")
if(!is.null(g2))
if(checkcalibration(Xs,d=1/piks,total,g2)$result) print(c((g2/piks)%*% Xs)) else print("error")
if(!is.null(g3))
if(checkcalibration(Xs,d=1/piks,total,g3)$result) print(c((g3/piks)%*% Xs)) else print("error")
if(!is.null(g4))
if(checkcalibration(Xs,d=1/piks,total,g4)$result) print(c((g4/piks)%*% Xs)) else print("error")
detach(belgianmunicipalities)
############
## Example 3
############
# Generalized calibration and adjustment for unit nonresponse in the 'calibration' vignette
# vignette("calibration", package="sampling")
</code></pre>

<hr>
<h2 id='getdata'>Get data</h2><span id='topic+getdata'></span>

<h3>Description</h3>

<p>Extracts the observed data from a data frame (a population). 
The function is used after a sample has been drawn from this population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getdata(data, m)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getdata_+3A_data">data</code></td>
<td>
<p>population data frame or data matrix; its number of rows is N, the population size.</p>
</td></tr>
<tr><td><code id="getdata_+3A_m">m</code></td>
<td>
<p>vector of selected units or sample data frame.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+srswor">srswor</a></code>, <code><a href="#topic+UPsystematic">UPsystematic</a></code>, <code><a href="#topic+strata">strata</a></code>, 
<code><a href="#topic+cluster">cluster</a></code>, <code><a href="#topic+mstage">mstage</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# Generates artificial data (a 235X3 matrix with 3 columns: state, region, income).
# The variable 'state' has 2 categories (nc and sc); 
# the variable 'region' has 3 categories (1, 2 and 3);
# the variable 'income' is generated using the U(0,1) distribution.
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),
matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
# the inclusion probabilities are computed using the variable 'income'
pik=inclusionprobabilities(data$income,20)
# draws a sample using systematic sampling (sample size is 20)
s=UPsystematic(pik) 
# extracts the observed data
getdata(data,s)
############
## Example 2
############
# see other examples in 'strata', 'cluster', 'mstage' help files
</code></pre>

<hr>
<h2 id='Hajekestimator'>The Hajek estimator</h2><span id='topic+Hajekestimator'></span>

<h3>Description</h3>

<p>Computes the Hájek estimator of the population total or population mean.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hajekestimator(y,pik,N=NULL,type=c("total","mean"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hajekestimator_+3A_y">y</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="Hajekestimator_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="Hajekestimator_+3A_n">N</code></td>
<td>
<p>population size; N is only used for the total estimator; for the mean estimator its value is NULL.</p>
</td></tr>
<tr><td><code id="Hajekestimator_+3A_type">type</code></td>
<td>
<p>the estimator type: total or mean.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HTestimator">HTestimator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Belgian municipalities data 
data(belgianmunicipalities)
# Computes the inclusion probabilities
pik=inclusionprobabilities(belgianmunicipalities$Tot04,200)
N=length(pik)
n=sum(pik)
# Defines the variable of interest
y=belgianmunicipalities$TaxableIncome
# Draws a Poisson sample of expected size 200
s=UPpoisson(pik)
# Computes the Hajek estimator of the population mean
Hajekestimator(y[s==1],pik[s==1],type="mean")
# Computes the Hajek estimator of the population total
Hajekestimator(y[s==1],pik[s==1],N=N,type="total")
</code></pre>

<hr>
<h2 id='Hajekstrata'>The Hajek estimator for a stratified design</h2><span id='topic+Hajekstrata'></span>

<h3>Description</h3>

<p>Computes the Hájek estimator of the population total or population mean for a stratified design.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hajekstrata(y,pik,strata,N=NULL,type=c("total","mean"),description=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hajekstrata_+3A_y">y</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="Hajekstrata_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities for the sampled units; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="Hajekstrata_+3A_strata">strata</code></td>
<td>
<p>vector of size n, with elements indicating the unit stratum.</p>
</td></tr>
<tr><td><code id="Hajekstrata_+3A_n">N</code></td>
<td>
<p>vector of population sizes of strata; N is only used for the total estimator; for the mean estimator its value is NULL.</p>
</td></tr>
<tr><td><code id="Hajekstrata_+3A_type">type</code></td>
<td>
<p>the estimator type: total or mean.</p>
</td></tr>
<tr><td><code id="Hajekstrata_+3A_description">description</code></td>
<td>
<p>if TRUE, the estimator is printed for each stratum; by default, FALSE.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HTstrata">HTstrata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Swiss municipalities data 
data(swissmunicipalities)
# the variable 'REG' has 7 categories in the population 
# it is used as stratification variable
# computes the population stratum sizes
table(swissmunicipalities$REG)
# do not run
#  1   2   3   4   5   6   7
# 589 913 321 171 471 186 245
# the sample stratum sizes are given by size=c(30,20,45,15,20,11,44)
# the method is simple random sampling without replacement 
# (equal probability, without replacement)
st=strata(swissmunicipalities,stratanames=c("REG"),size=c(30,20,45,15,20,11,44), 
method="srswor")
# extracts the observed data
# the order of the columns is different from the order in the swsissmunicipalities data
x=getdata(swissmunicipalities, st)
# computes the population sizes of strata
N=table(swissmunicipalities$REG)
N=N[unique(x$REG)]
#the strata 1   2   3   4   5   6   7
#corresponds to REG  4   1   3   2   5   6   7 
# computes the Hajek estimator of the total of Pop020 
Hajekstrata(x$Pop020,x$Prob,x$Stratum,N,type="total",description=TRUE)</code></pre>

<hr>
<h2 id='HTestimator'>The Horvitz-Thompson estimator</h2><span id='topic+HTestimator'></span>

<h3>Description</h3>

<p>Computes the Horvitz-Thompson estimator of the population total.</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTestimator(y,pik)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTestimator_+3A_y">y</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="HTestimator_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities; its length is equal to n, the sample size.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+UPtille">UPtille</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(belgianmunicipalities)
attach(belgianmunicipalities)
# inclusion probabilities
pik=inclusionprobabilities(Tot04,200)
N=length(pik)
n=sum(pik)
# draws a Poisson sample of expected size 200
s=UPpoisson(pik)
# Horvitz-Thompson estimator of the total of TaxableIncome
HTestimator(TaxableIncome[s==1],pik[s==1])
detach(belgianmunicipalities)
</code></pre>

<hr>
<h2 id='HTstrata'>The Horvitz-Thompson estimator for a stratified design</h2><span id='topic+HTstrata'></span>

<h3>Description</h3>

<p>Computes the Horvitz-Thompson estimator of the population total for a stratified design.</p>


<h3>Usage</h3>

<pre><code class='language-R'>HTstrata(y,pik,strata,description=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HTstrata_+3A_y">y</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="HTstrata_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities for the sampled units; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="HTstrata_+3A_strata">strata</code></td>
<td>
<p>vector of size n, with elements indicating the unit stratum.</p>
</td></tr>
<tr><td><code id="HTstrata_+3A_description">description</code></td>
<td>
<p>if TRUE, the estimator is printed for each stratum; by default, FALSE.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+HTestimator">HTestimator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Swiss municipalities data base
data(swissmunicipalities)
# the variable 'REG' has 7 categories in the population 
# it is used as stratification variable
# computes the population stratum sizes
table(swissmunicipalities$REG)
# do not run
#  1   2   3   4   5   6   7
# 589 913 321 171 471 186 245
# the sample stratum sizes are given by size=c(30,20,45,15,20,11,44)
# the method is simple random sampling without replacement 
# (equal probability, fixed sample size, without replacement)
st=strata(swissmunicipalities,stratanames=c("REG"),size=c(30,20,45,15,20,11,44), 
method="srswor")
# extracts the observed data
# the order of the columns is different from the order in the initial data
x=getdata(swissmunicipalities, st)
# computes the HT estimator of the total of Pop020 
HTstrata(x$Pop020,x$Prob,x$Stratum,description=TRUE)
</code></pre>

<hr>
<h2 id='inclusionprobabilities'>Inclusion probabilities</h2><span id='topic+inclusionprobabilities'></span>

<h3>Description</h3>

<p>Computes the first-order inclusion probabilities from a vector of positive numbers 
(for a probability proportional-to-size sampling design). Their sum is equal to n, the sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclusionprobabilities(a,n)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inclusionprobabilities_+3A_a">a</code></td>
<td>
<p>vector of positive numbers.</p>
</td></tr>
<tr><td><code id="inclusionprobabilities_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inclusionprobastrata">inclusionprobastrata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# a vector of positive numbers
a=1:20
# inclusion probabilities for a sample size n=12
inclusionprobabilities(a,12)
############
## Example 2
############
# Computation of the inclusion probabilities proportional to the number 
# of inhabitants in each municipality of the Belgian municipalities data.
data(belgianmunicipalities)
pik=inclusionprobabilities(belgianmunicipalities$Tot04,200)
# the first-order inclusion probabilities for each municipality
data.frame(pik=pik,name=belgianmunicipalities$Commune)
# the sum is equal to the sample size
sum(pik)
</code></pre>

<hr>
<h2 id='inclusionprobastrata'>Inclusion probabilities for a stratified design</h2><span id='topic+inclusionprobastrata'></span>

<h3>Description</h3>

<p>Computes the inclusion probabilities for a stratified design. 
The inclusion probabilities are equal in each stratum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>inclusionprobastrata(strata,nh)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inclusionprobastrata_+3A_strata">strata</code></td>
<td>
<p>vector that defines the strata.</p>
</td></tr>
<tr><td><code id="inclusionprobastrata_+3A_nh">nh</code></td>
<td>
<p>vector of the number of selected units in each stratum.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+balancedstratification">balancedstratification</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the strata
strata=c(1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3,3)
# sample size in each stratum
nh=c(2,3,3)
# inclusion probabilities for each stratum
pik=inclusionprobastrata(strata,nh)
#check for each stratum
cbind(strata, pik)
</code></pre>

<hr>
<h2 id='landingcube'>Landing phase for the cube method</h2><span id='topic+landingcube'></span>

<h3>Description</h3>

<p>Landing phase of the cube method using linear programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landingcube(X,pikstar,pik,comment=TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landingcube_+3A_x">X</code></td>
<td>
<p>matrix of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="landingcube_+3A_pikstar">pikstar</code></td>
<td>
<p>vector obtained at the end of the flight phase.</p>
</td></tr>
<tr><td><code id="landingcube_+3A_pik">pik</code></td>
<td>
<p>vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="landingcube_+3A_comment">comment</code></td>
<td>
<p>a comment is written during the execution if <code>comment</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Tillé, Y. (2006), <em>Sampling Algorithms</em>, Springer.<br />
Chauvet, G. and Tillé, Y. (2006). A fast algorithm of balanced sampling. <em>Computational Statistics</em>, 21/1:53&ndash;62. <br />
Chauvet, G. and Tillé, Y. (2005). New SAS macros for balanced sampling. In INSEE, editor, <em>Journées de Méthodologie Statistique</em>, Paris.<br />
Deville, J.-C. and Tillé, Y. (2004). Efficient balanced sampling: the cube method. <em>Biometrika</em>, 91:893&ndash;912.<br />
Deville, J.-C. and Tillé, Y. (2005). Variance approximation under balanced sampling. <em>Journal of Statistical Planning and Inference</em>, 128/2:411&ndash;425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+samplecube">samplecube</a></code>, <code><a href="#topic+fastflightcube">fastflightcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># matrix of balancing variables
X=cbind(c(1,1,1,1,1,1,1,1,1),c(1.1,2.2,3.1,4.2,5.1,6.3,7.1,8.1,9.1))
# the sample size is 3
# vector of inclusion probabilities
pik=c(1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3)
# pikstar is almost a balanced sample and is ready for the landing phase
pikstar=fastflightcube(X,pik,order=1,comment=TRUE)
# selection of the sample 
s=landingcube(X,pikstar,pik,comment=TRUE)
round(s)
</code></pre>

<hr>
<h2 id='mstage'>Multistage sampling</h2><span id='topic+mstage'></span>

<h3>Description</h3>

<p>Implements multistage sampling with equal/unequal probabilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstage(data, stage=c("stratified","cluster",""), varnames, size, 
method=c("srswor","srswr","poisson","systematic"), pik, description=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstage_+3A_data">data</code></td>
<td>
<p>data frame or data matrix; its number of rows is N, the population size.</p>
</td></tr>
<tr><td><code id="mstage_+3A_stage">stage</code></td>
<td>
<p>list of sampling types at each stage; the possible values are: &quot;stratified&quot;, &quot;cluster&quot; 
and &quot;&quot; (without stratification or clustering). For multistage element sampling, this argument is not necessary.</p>
</td></tr>
<tr><td><code id="mstage_+3A_varnames">varnames</code></td>
<td>
<p>list of stratification or clustering variables.</p>
</td></tr>
<tr><td><code id="mstage_+3A_size">size</code></td>
<td>
<p>list of sample sizes (in the order in which the samples appear in the multistage sampling).</p>
</td></tr>
<tr><td><code id="mstage_+3A_method">method</code></td>
<td>
<p>list of methods to select units at each stage; the following methods are implemented: simple random 
sampling without replacement (srswor), simple random sampling with replacement (srswr), 
Poisson sampling (poisson), systematic sampling (systematic); if the method is not specified, 
by default the method is &quot;srswor&quot;. The method can be different at each stage.</p>
</td></tr>
<tr><td><code id="mstage_+3A_pik">pik</code></td>
<td>
<p>list of selection probabilities or auxiliary information used to compute them; 
this argument is only used for unequal probability sampling (Poisson, systematic). If an
auxiliary information is provided, the function uses the <a href="#topic+inclusionprobabilities">inclusionprobabilities</a> function for
computing these probabilities.</p>
</td></tr>
<tr><td><code id="mstage_+3A_description">description</code></td>
<td>
<p>a message is printed if its value is TRUE; the message gives the number 
of selected units and the number of the units in the population. 
By default, its value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data should be sorted in ascending order by the columns given in the varnames argument before applying the function. Use, for example, data[order(data$state,data$region),]. 
</p>


<h3>Value</h3>

<p>The function returns a list, which contains the stages (if m is this list, the stage i is m$'i' etc)
and the following information:
</p>
<table>
<tr><td><code>ID_unit</code></td>
<td>
<p>the identifier of selected units at each stage.</p>
</td></tr>
<tr><td><code>Prob_ number _stage</code></td>
<td>
<p>the inclusion probability at stage 'number'.</p>
</td></tr>
<tr><td><code>Prob</code></td>
<td>
<p>the final unit inclusion probability given in the last stage; it is the product of unit inclusion probabilities at each stage.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cluster">cluster</a></code>, <code><a href="#topic+strata">strata</a></code>, <code><a href="#topic+getdata">getdata</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# Two-stage cluster sampling
# Uses the 'swissmunicipalities' data 
data(swissmunicipalities)
b=swissmunicipalities
b=b[order(b$REG,b$CT),]
attach(b)
# the variable 'REG' (region) has 7 categories;
# it is used as clustering variable in the first-stage sample
# the variable 'CT' (canton) has 26 categories; 
# it is used as clustering variable in the second-stage sample
# 4 clusters (regions) are selected in the first-stage 
# 1 canton is selected in the second-stage from each sampled region 
# the method is simple random sampling without replacement in each stage
# (equal probability, without replacement)
m=mstage(b,stage=list("cluster","cluster"), varnames=list("REG","CT"),
size=list(4,c(1,1,1,1)), method=list("srswor","srswor"))
# the first stage is m[[1]], the second stage is m[[2]]
#the selected regions
unique(m[[1]]$REG)
#the selected cantons
unique(m[[2]]$CT)
# extracts the observed data
x=getdata(b,m)[[2]]
# check the output
table(x$REG,x$CT)
############
## Example 2
############
# Two-stage element sampling
# Generates artificial data (a 235X3 matrix with 3 columns: state, region, income).
# The variable "state" has 2 categories ('n','s'). 
# The variable "region" has 5 categories ('A', 'B', 'C', 'D', 'E').
# The variable "income" is generated using the U(0,1) distribution. 
data=rbind(matrix(rep('n',165),165,1,byrow=TRUE),matrix(rep('s',70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep('A',115),rep('D',10),rep('E',40),rep('B',30),rep('C',40)),
100*runif(235))
names(data)=c("state","region","income")
data=data[order(data$state,data$region),]
table(data$state,data$region)
# the method is simple random sampling without replacement
# 25 units are drawn in the first-stage
# in the second-stage, 10 units are drawn from the already 25 selected units
m=mstage(data,size=list(25,10),method=list("srswor","srswor")) 
# the first stage is m[[1]], the second stage is m[[2]]
# extracts the observed data
xx=getdata(data,m)[[2]]
# check the result 
table(xx$state,xx$region)
############
## Example 3
############
# Stratified one-stage cluster sampling
# The same data as in Example 2
# the variable 'state' is used as stratification variable 
# 165 units are in the first stratum and 70 in the second one
# the variable 'region' is used as clustering variable
# 1 cluster (region) is drawn in each state using "srswor" 
m=mstage(data, stage=list("stratified","cluster"), varnames=list("state","region"), 
size=list(c(165,70),c(1,1)),method=list("","srswor")) 
# check the first stage
table(m[[1]]$state)
# check the second stage
table(m[[2]]$region)
# extracts the observed data
xx=getdata(data,m)[[2]]
# check the result
table(xx$state,xx$region)
############
## Example 4
############
# Two-stage cluster sampling
# The same data as in Example 1
# in the first-stage, the clustering variable is 'REG' (region) with 7 categories
# 4 clusters (regions) are drawn in the first-stage 
# each region is selected with the probability 4/7
# in the second-stage, the clustering variable is 'CT'(canton) with 26 categories
# 1 cluster (canton) is drawn in the second-stage from each selected region 
# in region 1, there are 3 cantons; one canton is selected with prob. 0.2, 0.4, 0.4, resp. 
# in region 2, there are 5 cantons; each canton is selected with the prob. 1/5
# in region 3, there are 3 cantons; each canton is selected with the prob. 1/3
# in region 4, there is 1 canton, which it is selected with the prob. 1
# in region 5, there are 7 cantons; each canton is selected with the prob. 1/7
# in region 6, there are 6 cantons; each canton is selected with the prob. 1/6
# in region 7, there is 1 canton, which it is selected with the prob. 1
# it is necessary to use a list of selection probabilities at each stage
# prob is the list of the selection probabilities
# the method is systematic sampling (unequal probabilities, without replacement)
# ls is the list of sizes
ls=list(4,c(1,1,1,1))
prob=list(rep(4/7,7),list(c(0.2,0.4,0.4),rep(1/5,5),rep(1/3,3),rep(1,1),rep(1/7,7),
rep(1/6,6),rep(1,1)))
m=mstage(b,stage=list("cluster","cluster"),varnames=list("REG","CT"),
size=ls, method=c("systematic","systematic"),pik=prob)
#the selected regions
unique(m[[1]]$REG)
#the selected cantons
unique(m[[2]]$CT)
# extracts the observed data
xx=getdata(b,m)[[2]]
# check the result
table(xx$REG,xx$CT)
############
## Example 5
############
# Stratified two-stage cluster sampling
# The same data as in Example 1
# the variable 'REG' is used as stratification variable
# there are 7 strata  
# the variable 'CT' is used as first clustering variable
# first stage, clusters (cantons) are drawn from each region using "srswor" 
# 3 clusters are drawn from the regions 1,2,3,5, and 6, respectively
# 1 cluster is drawn from the regions 4 and 7, respectively
# the variable 'COM' is used as second clustering variable
# second stage, 2 clusters (municipalities) are drawn from each selected canton using "srswor" 
m=mstage(b,stage=list("stratified","cluster","cluster"), varnames=list("REG","CT","COM"),
size=list(size1=table(b$REG),size2=c(rep(3,3),1,3,3,1), size3=rep(2,17)), 
method=list("","srswor","srswor"))
# extracts the observed data
getdata(b,m)[[3]]
</code></pre>

<hr>
<h2 id='MU284'> The MU284 population </h2><span id='topic+MU284'></span>

<h3>Description</h3>

<p>This data is from Särndal et al (1992), see Appendix B, p. 652.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MU284)</code></pre>


<h3>Format</h3>

<p>A data frame with 284 observations on the following 11 variables.
</p>

<dl>
<dt>LABEL</dt><dd><p>identifier number from 1 to 284.</p>
</dd>
<dt>P85</dt><dd><p>1985 population (in thousands).</p>
</dd>
<dt>P75</dt><dd><p>1975 population (in thousands).</p>
</dd>
<dt>RMT85</dt><dd><p>revenues from 1985 municipal taxation (in millions of kronor).</p>
</dd>
<dt>CS82</dt><dd><p>number of Conservative seats in municipal council.</p>
</dd>
<dt>SS82</dt><dd><p>number of Social-Democratic seats in municipal council.</p>
</dd>
<dt>S82</dt><dd><p>total number of seats in municipal council.</p>
</dd>
<dt>ME84</dt><dd><p>number of municipal employees in 1984.</p>
</dd>
<dt>REV84</dt><dd><p>real estate values according to 1984 assessment (in millions of kronor).</p>
</dd>
<dt>REG</dt><dd><p>geographic region indicator.</p>
</dd>
<dt>CL</dt><dd><p>cluster indicator (a cluster consists of a set of neighboring).</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://lib.stat.cmu.edu/datasets/mu284
</p>


<h3>References</h3>

<p>Särndal, C.-E., Swensson, B., and Wretman, J. (1992), <em>Model Assisted Survey Sampling</em>, Springer Verlag, 
New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MU284)
hist(MU284$RMT85)
</code></pre>

<hr>
<h2 id='postest'>Poststratified estimator</h2><span id='topic+postest'></span>

<h3>Description</h3>

<p>Computes the poststratified estimator of the population total.</p>


<h3>Usage</h3>

<pre><code class='language-R'>postest(data, y, pik, NG, description=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postest_+3A_data">data</code></td>
<td>
<p>data frame or data matrix; its number of rows is n, the sample size.</p>
</td></tr>
<tr><td><code id="postest_+3A_y">y</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="postest_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities for the sampled units; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="postest_+3A_ng">NG</code></td>
<td>
<p>vector of population frequency in each group G; for stratified sampling with poststratification, 
NG is a matrix of population frequency in each cell GH.</p>
</td></tr>
<tr><td><code id="postest_+3A_description">description</code></td>
<td>
<p>if TRUE, the estimator is printed for each poststratum; by default, FALSE.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+poststrata">poststrata</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
#stratified sampling and poststratification
data(swissmunicipalities)
# the variable 'REG' has 7 categories in the population
# it is used as stratification variable
# Computes the population stratum sizes
table(swissmunicipalities$REG)
# do not run
#  1   2   3   4   5   6   7 
# 589 913 321 171 471 186 245 
# the sample stratum sizes are given by size=c(30,20,45,15,20,11,44)
# the method is simple random sampling without replacement 
st=strata(swissmunicipalities,stratanames=c("REG"),
size=c(30,20,45,15,20,11,44), method="srswor")
# extracts the observed data
# the order of the columns is different from the order in the initial data
x=getdata(swissmunicipalities, st)
px=poststrata(x,"REG")
#computes the population frequency in each group
ct=unique(px$data$REG)
yy=table(swissmunicipalities$REG)[ct]
postest(px$data,y=px$data$Pop020,pik=px$data$Prob,NG=diag(yy))
HTstrata(x$Pop020,x$Prob,x$Stratum)
#the two estimators are equal
############
## Example 2
############
# systematic sampling and poststratification
data(belgianmunicipalities)
Tot=belgianmunicipalities$Tot04
name=belgianmunicipalities$Commune
pik=inclusionprobabilities(Tot,200)
#selects a sample
s=UPsystematic(pik)  
#the sample is
which(s==1)
# extracts the observed data
b=getdata(belgianmunicipalities,s)
pb=poststrata(b,"Province") 
#computes the population frequency in each group
ct=unique(pb$data$Province)
yy=table(belgianmunicipalities$Province)[ct]
postest(pb$data,y=pb$data$TaxableIncome,pik=pik[s==1],NG=yy,description=TRUE)
HTestimator(pb$data$TaxableIncome,pik=pik[s==1])
############
## Example 3
############
#cluster sampling and postratification
data(swissmunicipalities)
# the variable 'REG' has 7 categories in the population
# it is used as clustering variable
# the sample size is 3; the method is simple random sampling without replacement
cl=cluster(swissmunicipalities,clustername=c("REG"),size=3,method="srswor")
# extracts the observed data 
# the order of the columns is different from the order in the initial data
c=getdata(swissmunicipalities, cl)
pc=poststrata(c,"CT") 
#computes the population frequency in each group
ct=unique(pc$data$CT)
yy=table(swissmunicipalities$CT)[ct]
postest(pc$data,y=pc$data$Pop020,pik=pc$data$Prob,NG=yy,description=TRUE)
############
## Example 4
############
#postratification with two criteria
#artificial data 
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
# computes the population stratum sizes
table(data$region,data$state)
# not run
#     nc  sc
#  1 100  30
#  2  50  40
#  3  15   0
#selects a sample of size 10
s=srswor(10,nrow(data))  
# postratification using region and state
ps=poststrata(data[s==1,],c("region","state"))
#computes the population frequency in each group
ct=unique(ps$data$poststratum)
yy=numeric(length(ct))
for(i in 1:length(ct))
  {
   xy=ps$data[ps$data$poststratum==ct[i],]
   xstate=unique(xy$state)
   ystate=unique(xy$region)
   xx=data[data$state==xstate &amp; data$region==ystate,]
   yy[i]=nrow(xx)
  }
postest(ps$data,y=ps$data$income,pik=rep(10/nrow(data),10),NG=yy,description=TRUE)
</code></pre>

<hr>
<h2 id='poststrata'>Postratification</h2><span id='topic+poststrata'></span>

<h3>Description</h3>

<p>Poststratification using several criteria.</p>


<h3>Usage</h3>

<pre><code class='language-R'>poststrata(data, postnames = NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poststrata_+3A_data">data</code></td>
<td>
<p>data frame or data matrix; its number of rows is n, the sample size.</p>
</td></tr>
<tr><td><code id="poststrata_+3A_postnames">postnames</code></td>
<td>
<p>vector of poststratification variables.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<table>
<tr><td><code>The function</code></td>
<td>
<p>produces an object, which contains the following information:</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the final data frame with a new column ('poststratum') containg the unit poststratum.</p>
</td></tr>
<tr><td><code>npost</code></td>
<td>
<p>the number of poststrata.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+postest">postest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from An and Watts (New SAS procedures for Analysis of Sample Survey Data)
# generates artificial data (a 235X3 matrix with 3 columns: state, region, income).
# the variable "state" has 2 categories ('nc' and 'sc'). 
# the variable "region" has 3 categories (1, 2 and 3).
# the income variable is randomly generated
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
# computes the population stratum sizes
table(data$region,data$state)
# not run
#     nc  sc
#  1 100  30
#  2  50  40
#  3  15   0
# postratification using two criteria: state and region
poststrata(data,postnames=c("state","region"))     
</code></pre>

<hr>
<h2 id='ratioest'>Ratio estimator</h2><span id='topic+ratioest'></span>

<h3>Description</h3>

<p>Computes the ratio estimator of the population total.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratioest(y,x,Tx,pik)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratioest_+3A_y">y</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="ratioest_+3A_x">x</code></td>
<td>
<p>vector of auxiliary information; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="ratioest_+3A_tx">Tx</code></td>
<td>
<p>population total of x.</p>
</td></tr>
<tr><td><code id="ratioest_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities; its length is equal to n, the sample size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the value of the ratio estimator.</p>


<h3>See Also</h3>

<p><code><a href="#topic+regest">regest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># population
data(MU284)
# there are 3 outliers which are deleted from the population
MU281=MU284[MU284$RMT85&lt;=3000,]
attach(MU281)
# computes the inclusion probabilities using the variable P85; sample size 120
pik=inclusionprobabilities(P85,120)
# defines the variable of interest
y=RMT85
# defines the auxiliary information
x=CS82
# draws a systematic sample of size 120
s=UPsystematic(pik)
# computes the ratio estimator of the total of RMT85
ratioest(y[s==1],x[s==1],sum(x),pik[s==1])
detach(MU281)
</code></pre>

<hr>
<h2 id='ratioest_strata'>Ratio estimator for a stratified design</h2><span id='topic+ratioest_strata'></span>

<h3>Description</h3>

<p>Computes the ratio estimator of the population total for a stratified design. 
The ratio estimator of a total is the sum of ratio estimator in each stratum.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratioest_strata(y,x,TX_strata,pik,strata,description=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratioest_strata_+3A_y">y</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="ratioest_strata_+3A_x">x</code></td>
<td>
<p>vector of auxiliary information; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="ratioest_strata_+3A_tx_strata">TX_strata</code></td>
<td>
<p>vector of population x-total in each stratum; its length is equal to the number of strata.</p>
</td></tr>
<tr><td><code id="ratioest_strata_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="ratioest_strata_+3A_strata">strata</code></td>
<td>
<p>vector of size n, with elements indicating the unit stratum.</p>
</td></tr>
<tr><td><code id="ratioest_strata_+3A_description">description</code></td>
<td>
<p>if TRUE, the ratio estimator in each stratum is printed; by default, it is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the value of the ratio estimator.</p>


<h3>See Also</h3>

<p><code><a href="#topic+ratioest">ratioest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########
# Example 1
###########
# uses MU284 data as population with the 'REG' variable for stratification
data(MU284)
# there are 3 outliers which are deleted from the population
MU281=MU284[MU284$RMT85&lt;=3000,]
attach(MU281)
# computes the inclusion probabilities using the variable P85
# sample size 120
pik=inclusionprobabilities(P85,120)
# defines the variable of interest
y=RMT85
# defines the auxiliary information
x=CS82
# computes the population stratum sizes
table(REG)
# not run
# 1  2  3  4  5  6  7  8 
# 24 48 32 37 55 41 15 29 
# a sample is drawn in each region
# the sample stratum sizes are given by size=c(4,10,8,4,6,4,6,7)
s=strata(MU281,c("REG"),size=c(4,10,8,4,6,4,6,7), method="systematic",pik=P85)
# extracts the observed data
MU281sample=getdata(MU281,s)
# computes the population x-totals in each stratum
TX_strata=as.vector(tapply(CS82,list(REG),FUN=sum))
# computes the ratio estimator
ratioest_strata(MU281sample$RMT85,MU281sample$CS82,TX_strata,
MU281sample$Prob,MU281sample$Stratum)
detach(MU281)
###########
# Example 2
###########
# this is an artificial example (see Example 1 in the 'strata' function)
# there are 4 columns: state, region, income and aux
# 'income' is the variable of interest, and 'aux' is the auxiliary information 
# which is correlated to the income
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
attach(data)
aux=income+rnorm(length(income),0,1)
data=cbind.data.frame(data,aux)
# computes the population stratum sizes
table(data$region,data$state)
# not run
#     nc  sc
#  1 100  30
#  2  50  40
#  3  15   0
# there are 5 cells with non-zero values; one draws 5 samples (1 sample in each stratum)
# the sample stratum sizes are 10,5,10,4,6, respectively
# the method is 'srswor' (equal probability, without replacement)
s=strata(data,c("region","state"),size=c(10,5,10,4,6), method="srswor")
# extracts the observed data
xx=getdata(data,s)
# computes the population x-total for each stratum
TX_strata=na.omit(as.vector(tapply(aux,list(region,state),FUN=sum)))
# computes the ratio estimator 
ratioest_strata(xx$income,xx$aux,TX_strata,xx$Prob,xx$Stratum,description=TRUE)
</code></pre>

<hr>
<h2 id='rec99'> The 1999 census data</h2><span id='topic+rec99'></span>

<h3>Description</h3>

<p>This data provides census information about
the municipalities of the Haute-Garonne department, France, with less than 10000 inhabitants in 1999.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rec99)</code></pre>


<h3>Format</h3>

<p>A data frame with 554 observations on the following 10 variables:
</p>

<dl>
<dt>CODE_N</dt><dd><p>municipality code.</p>
</dd>
<dt>COMMUNE</dt><dd><p>municipality name.</p>
</dd>
<dt>BVQ_N</dt><dd><p>code of the Daily Life Basin to which the municipality belongs.</p>
</dd>
<dt>POPSDC99</dt><dd><p>number of inhabitants.</p>
</dd>
<dt>LOG</dt><dd><p>number of dwellings.</p>
</dd>
<dt>LOGVAC</dt><dd><p>number of vacant dwellings.</p>
</dd>
<dt>STRATLOG</dt><dd><p>a four-modality variable which equals 1 if the municipality has less than 100 dwellings, 2 if it has between 100 and 299 dwellings, 
3 if it has between 300 and 999 dwellings and 4 if it has 1000 dwellings or more.</p>
</dd>
<dt>surf_m2</dt><dd><p>surface in square meters.</p>
</dd>
<dt>lat_centre</dt><dd><p>geographical latitude of the center.</p>
</dd>
<dt>lon_centre</dt><dd><p>geographical longitude of the center.</p>
</dd>
</dl>



<h3>Source</h3>

<p>For the first 8 variables, 'Institut national de la statistique et des études économiques', France (http://www.insee.fr).
The geographical positions are available under the Open Database License (&quot;© OpenStreetMap contributors&quot;). https://www.openstreetmap.org/copyright
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rec99)
hist(rec99$LOG)
</code></pre>

<hr>
<h2 id='regest'>Regression estimator</h2><span id='topic+regest'></span>

<h3>Description</h3>

<p>Computes the regression estimator of the population total, using the 
design-based approach. The underling regression model is a model without intercept.</p>


<h3>Usage</h3>

<pre><code class='language-R'>regest(formula,Tx,weights,pikl,n,sigma=rep(1,length(weights)))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regest_+3A_formula">formula</code></td>
<td>
<p>regression model formula (y~x).</p>
</td></tr>
<tr><td><code id="regest_+3A_tx">Tx</code></td>
<td>
<p>population total of x, the auxiliary variable.</p>
</td></tr>
<tr><td><code id="regest_+3A_weights">weights</code></td>
<td>
<p>vector of the weights; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="regest_+3A_pikl">pikl</code></td>
<td>
<p>matrix of joint inclusion probabilities for the sample.</p>
</td></tr>
<tr><td><code id="regest_+3A_n">n</code></td>
<td>
<p>the sample size.</p>
</td></tr>
<tr><td><code id="regest_+3A_sigma">sigma</code></td>
<td>
<p>vector of positive values accounting for heteroscedasticity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with following components: 
</p>
<table>
<tr><td><code>regest</code></td>
<td>
<p>value of the regression estimator.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>vector of estimated beta coefficients.</p>
</td></tr>
<tr><td><code>std_error</code></td>
<td>
<p>estimated standard error of the estimated coefficients.</p>
</td></tr>
<tr><td><code>t_value</code></td>
<td>
<p>t-values associated to the coefficients.</p>
</td></tr>
<tr><td><code>p_value</code></td>
<td>
<p>p-values associated to the coefficients.</p>
</td></tr>
<tr><td><code>cov_mat</code></td>
<td>
<p>covariance matrix of the estimated coefficients.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>specified weights.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>response variable.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>model matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ratioest">ratioest</a></code>,<code><a href="#topic+regest_strata">regest_strata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># uses the MU284 population to draw a systematic sample
data(MU284)
# there are 3 outliers which are deleted from the population
MU281=MU284[MU284$RMT85&lt;=3000,]
attach(MU281)
# computes the inclusion probabilities using the variable P85; sample size 40
pik=inclusionprobabilities(P85,40)
# joint inclusion probabilities for systematic sampling
pikl=UPsystematicpi2(pik)
# draws a systematic sample of size 40
s=UPsystematic(pik)
# defines the variable of interest for the selected sample
y=RMT85[s==1]
# defines the auxiliary information for the selected sample
x1=CS82[s==1]
x2=SS82[s==1]
# joint inclusion probabilities for the selected sample
pikls=pikl[s==1,s==1]
# first-order inclusion probabilities for the selected sample
piks=pik[s==1]
# computes the regression estimator with the model y~x1+x2-1 
r=regest(formula=y~x1+x2-1,Tx=c(sum(CS82),sum(SS82)),weights=1/piks,pikl=pikls,n=40)
# the regression estimator
r$regest
# the estimated beta coefficients 
r$coefficients
# the regression estimator is the same as the calibration estimator (method="linear") 
Xs=cbind(x1,x2)
total=c(sum(CS82),sum(SS82))
g1=calib(Xs,d=1/piks,total,method="linear")
checkcalibration(Xs,d=1/piks,total,g1)
calibev(y,Xs,total,pikls,d=1/piks,g1,with=TRUE,EPS=1e-6)
detach(MU281)
</code></pre>

<hr>
<h2 id='regest_strata'>Regression estimator for a stratified design</h2><span id='topic+regest_strata'></span>

<h3>Description</h3>

<p>Computes the regression estimator of the population total for a stratified sampling, using the 
design-based approach. The same regression model is used for
all strata. The underling regression model is a model without intercept.</p>


<h3>Usage</h3>

<pre><code class='language-R'>regest_strata(formula,weights,Tx_strata,strata,pikl,
sigma=rep(1,length(weights)),description=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regest_strata_+3A_formula">formula</code></td>
<td>
<p>regression model formula (y~x).</p>
</td></tr>
<tr><td><code id="regest_strata_+3A_weights">weights</code></td>
<td>
<p>vector of the weights; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="regest_strata_+3A_tx_strata">Tx_strata</code></td>
<td>
<p>population total of x, the auxiliary variable.</p>
</td></tr>
<tr><td><code id="regest_strata_+3A_strata">strata</code></td>
<td>
<p>vector of stratum identificator.</p>
</td></tr>
<tr><td><code id="regest_strata_+3A_pikl">pikl</code></td>
<td>
<p>joint inclusion probabilities for the sample.</p>
</td></tr>
<tr><td><code id="regest_strata_+3A_sigma">sigma</code></td>
<td>
<p>vector of positive values accounting for heteroscedasticity.</p>
</td></tr>
<tr><td><code id="regest_strata_+3A_description">description</code></td>
<td>
<p>if TRUE, the following components are printed for each stratum:
the Horvitz-Thompson estimator, the estimated beta coefficients, their estimated standard error, t_values, p_values, 
and the covariance matrix. By default, FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the value of the regression estimator computed as the sum of the
stratum estimators.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regest">regest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generates artificial data
y=rgamma(10,3)
x=y+rnorm(10)
Stratum=c(1,1,2,2,2,3,3,3,3,3)
# population size
N=200
# sample size
n=10
# assume proportional allocation, nh/Nh=n/N 
# joint inclusion probabilities (for the sample)
pikl=matrix(n*(n-1)/(N*(N-1)),n,n)
diag(pikl)=n/N
regest_strata(formula=y~x-1,weights=rep(N/n,n),Tx_strata=c(50,30,40),
strata=Stratum,pikl,description=TRUE)
</code></pre>

<hr>
<h2 id='rhg'>Response homogeneity groups</h2><span id='topic+rhg'></span>

<h3>Description</h3>

<p>Computes the response homogeneity groups and the response probability for each 
unit in these groups. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhg(X,selection)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhg_+3A_x">X</code></td>
<td>
<p>sample data frame; it should contain the columns 'ID_unit' and 'status'; 
'ID_unit' denotes the unit identifier (a number); 'status' is a 1/0 variable denoting the response/non-response of a unit.</p>
</td></tr>
<tr><td><code id="rhg_+3A_selection">selection</code></td>
<td>
<p>vector of variable names in X used to construct the groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Into a response homogeneity group, the reponse probability is the same for
all units. Data are missing at random within groups, conditionally on the selected sample.
</p>


<h3>Value</h3>

<p>The initial sample data frame and also the following components:
</p>
<table>
<tr><td><code>rhgroup</code></td>
<td>
<p>the response homogeneity group for each unit.</p>
</td></tr>
<tr><td><code>prob_response</code></td>
<td>
<p>the response probability for each unit; for the units with status=0, this probability
is 0.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992). Model Assisted Survey Sampling. <em>Springer</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhg_strata">rhg_strata</a></code>, <code><a href="#topic+calib">calib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># defines the inclusion probabilities for the population
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
# X is the population data frame
X=cbind.data.frame(pik,c("A","B","A","A","C","B"))
names(X)=c("Prob","town")
# selects a sample using systematic sampling
s=UPsystematic(pik)
# Xs is the sample data frame
Xs=getdata(X,s)
# adds the status column to Xs (1 - sample respondent, 0 otherwise)
Xs=cbind.data.frame(Xs,status=c(1,0,1))
# creates the response homogeneity groups using the 'town' variable
rhg(Xs,selection="town")
</code></pre>

<hr>
<h2 id='rhg_strata'>Response homogeneity groups for a stratified sampling</h2><span id='topic+rhg_strata'></span>

<h3>Description</h3>

<p>Computes response homogeneity groups and the corresponding response probability for each 
unit into a group, for a stratified sampling. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhg_strata(X,selection)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhg_strata_+3A_x">X</code></td>
<td>
<p>sample data frame; it should contain the columns 'ID_unit','Stratum', and 'status'; 
'ID_unit' denotes the unit identifier (a number); 'Stratum' denotes the unit stratum; 'status' is a 1/0 variable denoting the response/non-response of a unit in the sample.</p>
</td></tr>
<tr><td><code id="rhg_strata_+3A_selection">selection</code></td>
<td>
<p>vector of variable names in X used to construct the groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Into a response homogeneity group, the reponse probability is the same for
all units. Data are missing at random within groups, conditionally on the selected sample.
</p>


<h3>Value</h3>

<p>The initial sample data frame and also the following components:
</p>
<table>
<tr><td><code>rhgroup</code></td>
<td>
<p>response homogeneity group for each unit, conditionally on its stratum.</p>
</td></tr>
<tr><td><code>prob_response</code></td>
<td>
<p>response probability for each unit; for the units with status=0, this probability
is 0.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Särndal, C.-E., Swensson, B. and Wretman, J. (1992). Model Assisted Survey Sampling. <em>Springer</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhg">rhg</a></code>, <code><a href="#topic+calib">calib</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# uses Example 2 from the 'strata' function help file
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
# draws a sample
s1=strata(data,c("region","state"),size=c(10,5,10,4,6), method="systematic",
pik=data$income)
# extracts the observed data
s1=getdata(data,s1)
# randomly generates the 'status' variable (1-sample respondent, 0-otherwise)
status=ifelse(runif(nrow(s1))&lt;0.3,0,1)
# adds the 'status' variable to the sample data frame s1
s1=cbind.data.frame(s1,status)
# creates classes of income using the median of income
# suppose that the income is available for all units in the sample
classincome=ifelse(s1$income&lt;median(s1$income),1,2)
# adds 'classincome' to s1
s1=cbind.data.frame(s1,classincome)
# computes the response homogeneity groups using the 'classincome' variable   
rhg_strata(s1,selection=c("classincome"))
############
## Example 2
############
# the same data as in Example 1
# but we also add the 'sex' column (1-female, 2-male)
# suppose that the sex is available for all units in the sample
sex=c(rep(1,12),rep(2,8),rep(1,10),rep(2,5))
s1=cbind.data.frame(s1,sex)
# computes the response homogeneity groups using the 'classincome' and 'sex' variables   
rhg_strata(s1,selection=c("classincome","sex"))
</code></pre>

<hr>
<h2 id='rmodel'>Response probability using logistic regression</h2><span id='topic+rmodel'></span>

<h3>Description</h3>

<p>Computes the response probabilities using logistic regression for non-response
adjustment. For stratified sampling, the same logistic model is used for all strata.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmodel(formula,weights,X)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmodel_+3A_formula">formula</code></td>
<td>
<p>regression model formula (y~x).</p>
</td></tr>
<tr><td><code id="rmodel_+3A_weights">weights</code></td>
<td>
<p>vector of weights; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="rmodel_+3A_x">X</code></td>
<td>
<p>sample data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the sample data frame with a new column 'prob_resp', which contains 
the response probabilities.</p>


<h3>See Also</h3>

<p><code><a href="#topic+rhg">rhg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from An and Watts (New SAS procedures for Analysis of Sample Survey Data)
# generates artificial data (a 235X3 matrix with 3 columns: state, region, income).
# the variable "state" has 2 categories ('nc' and 'sc'). 
# the variable "region" has 3 categories (1, 2 and 3).
# the sampling frame is stratified by region within state.
# the income variable is randomly generated
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
# computes the population stratum sizes
table(data$region,data$state)
# not run
#     nc  sc
#  1 100  30
#  2  50  40
#  3  15   0
# there are 5 cells with non-zero values; one draws 5 samples (1 sample in each stratum)
# the sample stratum sizes are 10,5,10,4,6, respectively
# the method is 'srswor' (equal probability, without replacement)
s=strata(data,c("region","state"),size=c(10,5,10,4,6), method="srswor")
# extracts the observed data
x=getdata(data,s)
# generates randomly the 'status' column (1 - respondent, 0 - nonrespondent)
status=round(runif(nrow(x)))
x=cbind(x,status)
# computes the response probabilities 
rmodel(x$status~x$income+x$Stratum,weights=1/x$Prob,x)
# the same example without stratification
rmodel(x$status~x$income,weights=1/x$Prob,x)
</code></pre>

<hr>
<h2 id='samplecube'>Sample cube method</h2><span id='topic+samplecube'></span>

<h3>Description</h3>

<p>Selects a balanced sample (a vector of 0 and 1) or an almost balanced sample.
Firstly, the flight phase is applied. Next, if needed, the landing phase is applied
on the result of the flight phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplecube(X,pik,order=1,comment=TRUE,method=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samplecube_+3A_x">X</code></td>
<td>
<p>matrix of auxiliary variables on which the sample must be balanced.</p>
</td></tr>
<tr><td><code id="samplecube_+3A_pik">pik</code></td>
<td>
<p>vector of inclusion probabilities.</p>
</td></tr>
<tr><td><code id="samplecube_+3A_order">order</code></td>
<td>
<p> 1, the data are randomly arranged,<br />
2, no change in data order,<br />
3, the data are sorted in decreasing order.
</p>
</td></tr>
<tr><td><code id="samplecube_+3A_comment">comment</code></td>
<td>
<p>a comment is written during the execution if <code>comment</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="samplecube_+3A_method">method</code></td>
<td>
<p> 1, for a landing phase by linear programming,<br />
2, for a landing phase by suppression of variables.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>Tillé, Y. (2006), <em>Sampling Algorithms</em>, Springer.<br />
Chauvet, G. and Tillé, Y. (2006). A fast algorithm of balanced sampling. <em>Computational Statistics</em>, 21/1:53&ndash;62. <br />
Chauvet, G. and Tillé, Y. (2005). New SAS macros for balanced sampling. In INSEE, editor, <em>Journées de Méthodologie Statistique</em>, Paris.<br />
Deville, J.-C. and Tillé, Y. (2004). Efficient balanced sampling: the cube method. <em>Biometrika</em>, 91:893&ndash;912.<br />
Deville, J.-C. and Tillé, Y. (2005). Variance approximation under balanced sampling. <em>Journal of Statistical Planning and Inference</em>, 128/2:411&ndash;425. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landingcube">landingcube</a></code>, <code><a href="#topic+fastflightcube">fastflightcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# matrix of balancing variables
X=cbind(c(1,1,1,1,1,1,1,1,1),c(1.1,2.2,3.1,4.2,5.1,6.3,7.1,8.1,9.1))
# vector of inclusion probabilities
# the sample size is 3.
pik=c(1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3,1/3)
# selection of the sample
s=samplecube(X,pik,order=1,comment=TRUE)
# The selected sample
(1:length(pik))[s==1]
############
## Example 2
############
# 2 strata and 2 auxiliary variables
# we verify the values of the inclusion probabilities by simulations
X=rbind(c(1,0,1,2),c(1,0,2,5),c(1,0,3,7),c(1,0,4,9),
c(1,0,5,1),c(1,0,6,5),c(1,0,7,7),c(1,0,8,6),c(1,0,9,9),
c(1,0,10,3),c(0,1,11,3),c(0,1,12,2),c(0,1,13,3),
c(0,1,14,6),c(0,1,15,8),c(0,1,16,9),c(0,1,17,1),
c(0,1,18,2),c(0,1,19,3),c(0,1,20,4))
pik=rep(1/2,times=20)
ppp=rep(0,times=20)
sim=10 #for accurate results increase this value
for(i in (1:sim))
	ppp=ppp+samplecube(X,pik,1,FALSE) 
ppp=ppp/sim
print(ppp)
print(pik)
############
## Example 3
############
# unequal probability sampling by cube method
# one auxiliary variable equal to the inclusion probability
N=100
pik=runif(N)
pikfin=samplecube(array(pik,c(N,1)),pik,1,TRUE)
############ 
## Example 4
############
# p auxiliary variables generated randomly
N=100
p=7
x=rnorm(N*p,10,3)
# random inclusion probabilities 
pik= runif(N)
X=array(x,c(N,p))
X=cbind(cbind(X,rep(1,times=N)),pik)
pikfin=samplecube(X,pik,1,TRUE)
############ 
## Example 5
############
# strata and an auxiliary variable
N=100
a=rep(1,times=N)
b=rep(0,times=N)
V1=c(a,b,b)
V2=c(b,a,b)
V3=c(b,b,a)
X=cbind(V1,V2,V3)
pik=rep(2/10,times=3*N)
pikfin=samplecube(X,pik,1,TRUE)
############
## Example 6
############
# Selection of a balanced sample using the MU284 population,
# Monte Carlo simulation and variance comparison with
# unequal probability sampling of fixed sample size.
############
data(MU284)
# inclusion probabilities, sample size 50
pik=inclusionprobabilities(MU284$P75,50)
# matrix of balancing variables
X=cbind(MU284$P75,MU284$CS82,MU284$SS82,MU284$S82,MU284$ME84,MU284$REV84)
# Horvitz-Thompson estimator for a balanced sample
s=samplecube(X,pik,1,FALSE)
HTestimator(MU284$RMT85[s==1],pik[s==1])
# Horvitz-Thompson estimator for an unequal probability sample
s=samplecube(matrix(pik),pik,1,FALSE)
HTestimator(MU284$RMT85[s==1],pik[s==1])
# Monte Carlo simulation; for a better accuracy, increase the value 'sim'
sim=5
res1=rep(0,times=sim)
res2=rep(0,times=sim)
for(i in 1:sim)
{
cat("Simulation number ",i,"\n")
s=samplecube(X,pik,1,FALSE)
res1[i]=HTestimator(MU284$RMT85[s==1],pik[s==1])
s=samplecube(matrix(pik),pik,1,FALSE)
res2[i]=HTestimator(MU284$RMT85[s==1],pik[s==1])
}
# summary and boxplots
summary(res1)
summary(res2)
ss=cbind(res1,res2)
colnames(ss) = c("balanced sampling","uneq prob sampling")
boxplot(data.frame(ss), las=1)
</code></pre>

<hr>
<h2 id='sampling-internal'>Internal sampling Functions</h2><span id='topic+.as_int'></span>

<h3>Description</h3>

<p>Internal sampling function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.as_int(x)
</code></pre>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='srswor'>Simple random sampling without replacement</h2><span id='topic+srswor'></span>

<h3>Description</h3>

<p>Draws a simple random sampling without replacement of size n (equal probabilities, fixed sample size, without replacement).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srswor(n,N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srswor_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="srswor_+3A_n">N</code></td>
<td>
<p>population size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srswr">srswr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
#select a sample
s=srswor(3,10)
#the sample is
which(s==1)
############
## Example 2
############
data(belgianmunicipalities)
Tot=belgianmunicipalities$Tot04
name=belgianmunicipalities$Commune
n=200
#select a sample
s=srswor(n,length(Tot))  
#the sample is 
which(s==1)
#names of the selected units
as.vector(name[s==1])
</code></pre>

<hr>
<h2 id='srswor1'>Selection-rejection method</h2><span id='topic+srswor1'></span>

<h3>Description</h3>

<p>Draws a simple random sampling without replacement of size n using the selection-rejection method (equal probabilities, fixed sample size, without replacement).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srswor1(n,N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srswor1_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="srswor1_+3A_n">N</code></td>
<td>
<p>population size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise).
</p>


<h3>References</h3>

<p>Fan, C.T., Muller, M.E., Rezucha, I. (1962), Development of sampling plans by using sequential (item by item)
selection techniques and digital computer, <em>Journal of the American Statistical Association</em>, 57, 387&ndash;402.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+srswor">srswor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s=srswor1(3,10)
#the sample is
which(s==1)
</code></pre>

<hr>
<h2 id='srswr'>Simple random sampling with replacement</h2><span id='topic+srswr'></span>

<h3>Description</h3>

<p>Draws a simple random sampling with replacement of size n (equal probabilities, fixed sample size, with replacement).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srswr(n,N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srswr_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="srswr_+3A_n">N</code></td>
<td>
<p>population size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of size N, the population size. Each element k of this vector indicates 
the number of replicates of unit k in the sample.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPmultinomial">UPmultinomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s=srswr(3,10)
#the selected units are 
which(s!=0)
#with the number of replicates 
s[s!=0]
</code></pre>

<hr>
<h2 id='strata'>Stratified sampling</h2><span id='topic+strata'></span>

<h3>Description</h3>

<p>Stratified sampling with equal/unequal probabilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata(data, stratanames=NULL, size, method=c("srswor","srswr","poisson",
"systematic"), pik,description=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata_+3A_data">data</code></td>
<td>
<p>data frame or data matrix; its number of rows is N, the population size.</p>
</td></tr>
<tr><td><code id="strata_+3A_stratanames">stratanames</code></td>
<td>
<p>vector of stratification variables.</p>
</td></tr>
<tr><td><code id="strata_+3A_size">size</code></td>
<td>
<p>vector of stratum sample sizes (in the order in which the strata are given in the input
data set).</p>
</td></tr>
<tr><td><code id="strata_+3A_method">method</code></td>
<td>
<p>method to select units; the following methods are implemented: simple random 
sampling without replacement (srswor), simple random sampling with replacement (srswr), 
Poisson sampling (poisson), systematic sampling (systematic); if &quot;method&quot; is missing, 
the default method is &quot;srswor&quot;.</p>
</td></tr>
<tr><td><code id="strata_+3A_pik">pik</code></td>
<td>
<p>vector of inclusion probabilities or auxiliary information used to compute them; 
this argument is only used for unequal probability sampling (Poisson and systematic). If an
auxiliary information is provided, the function uses the <a href="#topic+inclusionprobabilities">inclusionprobabilities</a> function for
computing these probabilities. </p>
</td></tr>
<tr><td><code id="strata_+3A_description">description</code></td>
<td>
<p>a message is printed if its value is TRUE; the message gives the number 
of selected units and the number of the units in the population. 
By default, the value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data should be sorted in ascending order by the columns given in the stratanames argument before applying the function. Use, for example, data[order(data$state,data$region),]. 
</p>


<h3>Value</h3>

 
<p>The function produces an object, which contains the following information:
</p>
<table>
<tr><td><code>ID_unit</code></td>
<td>
<p>the identifier of the selected units.</p>
</td></tr>
<tr><td><code>Stratum</code></td>
<td>
<p>the unit stratum.</p>
</td></tr>
<tr><td><code>Prob</code></td>
<td>
<p>the unit inclusion probability.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getdata">getdata</a></code>, <code><a href="#topic+mstage">mstage</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# Example from An and Watts (New SAS procedures for Analysis of Sample Survey Data)
# generates artificial data (a 235X3 matrix with 3 columns: state, region, income).
# the variable "state" has 2 categories ('nc' and 'sc'). 
# the variable "region" has 3 categories (1, 2 and 3).
# the sampling frame is stratified by region within state.
# the income variable is randomly generated
data=rbind(matrix(rep("nc",165),165,1,byrow=TRUE),matrix(rep("sc",70),70,1,byrow=TRUE))
data=cbind.data.frame(data,c(rep(1,100), rep(2,50), rep(3,15), rep(1,30),rep(2,40)),
1000*runif(235))
names(data)=c("state","region","income")
# computes the population stratum sizes
table(data$region,data$state)
# not run
#     nc  sc
#  1 100  30
#  2  50  40
#  3  15   0
# there are 5 cells with non-zero values
# one draws 5 samples (1 sample in each stratum)
# the sample stratum sizes are 10,5,10,4,6, respectively
# the method is 'srswor' (equal probability, without replacement)
s=strata(data,c("region","state"),size=c(10,5,10,4,6), method="srswor")
# extracts the observed data
getdata(data,s)
# see the result using a contigency table
table(s$region,s$state)
############
## Example 2
############
# The same data as in Example 1
# the method is 'systematic' (unequal probability, without replacement)
# the selection probabilities are computed using the variable 'income'
s=strata(data,c("region","state"),size=c(10,5,10,4,6), method="systematic",pik=data$income)
# extracts the observed data
getdata(data,s)
# see the result using a contigency table
table(s$region,s$state)
############
## Example 3
############
# Uses the 'swissmunicipalities' data as population for drawing a sample of units
data(swissmunicipalities)
# the variable 'REG' has 7 categories in the population
# it is used as stratification variable
# Computes the population stratum sizes
table(swissmunicipalities$REG)
# do not run
#  1   2   3   4   5   6   7 
# 589 913 321 171 471 186 245 
# sort the data to obtain the same order of the regions in the sample
data=swissmunicipalities
data=data[order(data$REG),]
# the sample stratum sizes are given by size=c(30,20,45,15,20,11,44)
# 30 units are drawn in the first stratum, 20 in the second one, etc.
# the method is simple random sampling without replacement 
# (equal probability, without replacement)
st=strata(data,stratanames=c("REG"),size=c(30,20,45,15,20,11,44), method="srswor")
# extracts the observed data
getdata(data, st)
# see the result using a contingency table
table(st$REG)
</code></pre>

<hr>
<h2 id='swissmunicipalities'>The Swiss municipalities population</h2><span id='topic+swissmunicipalities'></span>

<h3>Description</h3>

<p>This population provides information about the Swiss municipalities 
in 2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swissmunicipalities)</code></pre>


<h3>Format</h3>

<p>A data frame with 2896 observations on the following 22 variables:
</p>

<dl>
<dt>CT</dt><dd><p>Swiss canton.</p>
</dd>
<dt>REG</dt><dd><p>Swiss region.</p>
</dd>
<dt>COM</dt><dd><p>municipality number.</p>
</dd>
<dt>Nom</dt><dd><p>municipality name.</p>
</dd>
<dt>HApoly</dt><dd><p>municipality area.</p>
</dd>
<dt>Surfacesbois</dt><dd><p>wood area.</p>
</dd>
<dt>Surfacescult</dt><dd><p>area under cultivation.</p>
</dd>
<dt>Alp</dt><dd><p>mountain pasture area.</p>
</dd>
<dt>Airbat</dt><dd><p>area with buildings.</p>
</dd>
<dt>Airind</dt><dd><p>industrial area.</p>
</dd>
<dt>P00BMTOT</dt><dd><p>number of men.</p>
</dd>
<dt>P00BWTOT</dt><dd><p>number of women.</p>
</dd>
<dt>Pop020</dt><dd><p>number of men and women aged between 0 and 19.</p>
</dd>
<dt>Pop2040</dt><dd><p>number of men and women aged between 20 and 39.</p>
</dd>
<dt>Pop4065</dt><dd><p>number of men and women aged between 40 and 64.</p>
</dd>
<dt>Pop65P</dt><dd><p>number of men and women aged between 65 and over.</p>
</dd>
<dt>H00PTOT</dt><dd><p>number of households.</p>
</dd>
<dt>H00P01</dt><dd><p>number of households with 1 person.</p>
</dd>
<dt>H00P02</dt><dd><p>number of households with 2 persons.</p>
</dd>
<dt>H00P03</dt><dd><p>number of households with 3 persons.</p>
</dd>
<dt>H00P04</dt><dd><p>number of households with 4 persons.</p>
</dd>
<dt>POPTOT</dt><dd><p>total population.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Swiss Federal Statistical Office.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(swissmunicipalities)
hist(swissmunicipalities$POPTOT)
</code></pre>

<hr>
<h2 id='UPbrewer'>Brewer sampling</h2><span id='topic+UPbrewer'></span>

<h3>Description</h3>

<p>Uses the Brewer's method to select a sample of units (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPbrewer(pik,eps=1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPbrewer_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPbrewer_+3A_eps">eps</code></td>
<td>
<p>the control value, by default equal to 1e-06; it is used to
control pik (pik&gt;eps &amp; pik &lt; 1-eps).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise).
</p>


<h3>References</h3>

<p>Brewer, K. (1975), A simple procedure for $pi$pswor, <em>Australian Journal of Statistics</em>, 17:166-172.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPsystematic">UPsystematic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#select a sample
s=UPbrewer(pik)
#the sample is
which(s==1)
</code></pre>

<hr>
<h2 id='UPmaxentropy'>Maximum entropy sampling</h2><span id='topic+UPmaxentropy'></span><span id='topic+UPmaxentropypi2'></span><span id='topic+UPMEqfromw'></span><span id='topic+UPMEpikfromq'></span><span id='topic+UPMEpiktildefrompik'></span><span id='topic+UPMEsfromq'></span><span id='topic+UPMEpik2frompikw'></span>

<h3>Description</h3>

<p>Maximum entropy sampling with fixed sample size and unequal probabilities (or Conditional Poisson sampling) 
is implemented by means of a sequential method (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPmaxentropy(pik) 
UPmaxentropypi2(pik)
UPMEqfromw(w,n)
UPMEpikfromq(q) 
UPMEpiktildefrompik(pik,eps=1e-6)
UPMEsfromq(q)
UPMEpik2frompikw(pik,w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPmaxentropy_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="UPmaxentropy_+3A_pik">pik</code></td>
<td>
<p>vector of prescribed inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPmaxentropy_+3A_eps">eps</code></td>
<td>
<p>tolerance in the Newton's method; by default is 1E-6.</p>
</td></tr>
<tr><td><code id="UPmaxentropy_+3A_q">q</code></td>
<td>
<p>matrix of the conditional selection probabilities for the sequential algorithm.</p>
</td></tr> 
<tr><td><code id="UPmaxentropy_+3A_w">w</code></td>
<td>
<p>parameter vector of the maximum entropy design.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The maximum entropy sampling maximizes the entropy criterion:
</p>
<p style="text-align: center;"><code class="reqn">I(p) = - \sum_s p(s)\log[p(s)]</code>
</p>

<p>The main procedure is <code>UPmaxentropy</code> which selects a sample (a vector of 0 and 1)
from a given vector of inclusion probabilities. The procedure <code>UPmaxentropypi2</code>
returns the matrix of joint inclusion probabilities from the first-order inclusion probability vector.
The other procedures are intermediate steps. They can be useful to run simulations as shown
in the examples below. The procedure <code>UPMEpiktildefrompik</code> computes the vector
of the inclusion probabilities (denoted <code>pikt</code>) of a Poisson sampling from the vector
of the inclusion probabilities of the maximum entropy sampling.  
The maximum entropy sampling is the conditional
design given the fixed sample size. The vector <code>w</code> can be easily obtained by 
<code>w=pikt/(1-pikt)</code>. Once <code>piktilde</code> and <code>w</code> are deduced from <code>pik</code>,
a matrix of selection probabilities <code>q</code> can be derived from the sample size <code>n</code> 
and the vector <code>w</code> via <code>UPMEqfromw</code>. 
Next, a sample can be selected from <code>q</code> using <code>UPMEsfromq</code>.
In order to generate several samples, 
it is more efficient to compute the matrix <code>q</code> (which needs some calculation),
and then to use the procedure <code>UPMEsfromq</code>. The vector of the inclusion probabilities can
be recomputed from <code>q</code> using <code>UPMEpikfromq</code>, which also checks 
the numerical precision  of the algorithm. The procedure <code>UPMEpik2frompikw</code>
computes the matrix of the joint inclusion probabilities from <code>q</code> and <code>w</code>.
</p>


<h3>References</h3>

<p>Chen, S.X., Liu, J.S. (1997).
Statistical applications of the Poisson-binomial and conditional Bernoulli distributions,
<em>Statistica Sinica</em>, 7, 875-892;<br />
Deville, J.-C. (2000).
<em>Note sur l'algorithme de Chen, Dempster et Liu.</em>
Technical report, CREST-ENSAI, Rennes.<br />
Matei, A., Tillé, Y. (2005) Evaluation of variance approximations and estimators in maximum entropy sampling with unequal
probability and fixed sample size, 
<em>Journal of Official Statistics</em>, Vol. 21, No. 4, p. 543-570.<br />
Tillé, Y. (2006), <em>Sampling Algorithms</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# Simple example - sample selection 
pik=c(0.07,0.17,0.41,0.61,0.83,0.91)
# First method
UPmaxentropy(pik)
# Second method by using intermediate procedures
n=sum(pik)
pikt=UPMEpiktildefrompik(pik)
w=pikt/(1-pikt)
q=UPMEqfromw(w,n)
UPMEsfromq(q)
# Matrix of joint inclusion probabilities
# First method: direct computation from pik
UPmaxentropypi2(pik)
# Second method: computation from pik and w
UPMEpik2frompikw(pik,w)
############
## Example 2
############
# other examples in the 'UPexamples' vignette
# vignette("UPexamples", package="sampling")
</code></pre>

<hr>
<h2 id='UPmidzuno'>Midzuno sampling</h2><span id='topic+UPmidzuno'></span>

<h3>Description</h3>

<p>Uses the Midzuno's method to select a sample of units (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPmidzuno(pik,eps=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPmidzuno_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPmidzuno_+3A_eps">eps</code></td>
<td>
<p>control value, by default equal to 1e-6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size. 
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise). The value 'eps' is used to
control pik (pik&gt;eps &amp; pik &lt; 1-eps).  
</p>


<h3>References</h3>

<p>Midzuno, H. (1952), On the sampling system with probability proportional to sum of size.
<em> Annals of the Institute of Statistical Mathematics</em>, 3:99-107.<br />
Deville, J.-C. and Tillé, Y. (1998), 
Unequal probability sampling without replacement through a splitting method, 
<em>Biometrika</em>, 85:89-101.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPtille">UPtille</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#select a sample
s=UPmidzuno(pik)
#the sample is
which(s==1)
</code></pre>

<hr>
<h2 id='UPmidzunopi2'>Joint inclusion probabilities for Midzuno sampling</h2><span id='topic+UPmidzunopi2'></span>

<h3>Description</h3>

<p>Computes the joint (second-order) inclusion probabilities for Midzuno sampling. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPmidzunopi2(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPmidzunopi2_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a NxN matrix of the following form: the main diagonal contains the first-order inclusion 
probabilities for each unit k in the population; elements (k,l) are the joint inclusion
probabilities of units k and l, with k not equal to l. N is the population size. 
</p>


<h3>References</h3>

<p>Midzuno, H. (1952), On the sampling system with probability proportional to sum of size.
<em> Annals of the Institute of Statistical Mathematics</em>, 3:99-107.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPmidzuno">UPmidzuno</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#matrix of joint inclusion probabilities
UPmidzunopi2(pik)
</code></pre>

<hr>
<h2 id='UPminimalsupport'>Minimal support sampling</h2><span id='topic+UPminimalsupport'></span>

<h3>Description</h3>

<p>Uses the minimal support method to select a sample of units (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPminimalsupport(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPminimalsupport_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise). 
</p>


<h3>References</h3>

<p>Deville, J.-C., Tillé, Y. (1998), Unequal probability sampling without replacement 
through a splitting method, <em>Biometrika </em>, 85, 89-101.<br />
Tillé, Y. (2006), <em>Sampling Algorithms</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
#defines the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#selects a sample
s=UPminimalsupport(pik)
#the sample is
which(s==1)
############
## Example 2
############
data(belgianmunicipalities)
Tot=belgianmunicipalities$Tot04
name=belgianmunicipalities$Commune
pik=inclusionprobabilities(Tot,200)
#selects a sample
s=UPminimalsupport(pik)  
#the sample is
which(s==1)
#names of the selected units
as.vector(name[s==1])
</code></pre>

<hr>
<h2 id='UPmultinomial'>Multinomial sampling</h2><span id='topic+UPmultinomial'></span>

<h3>Description</h3>

<p>Uses the Hansen-Hurwitz method to select a sample of units (unequal probabilities, with replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPmultinomial(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPmultinomial_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of size N, the population size. Each element k of this vector indicates 
the number of replicates of unit k in the sample.
</p>


<h3>References</h3>

<p>Hansen, M. and Hurwitz, W. (1943), On the theory of sampling from finite populations.
<em>Annals of Mathematical Statistics</em>, 14:333-362.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#defines the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#selects a sample
s=UPmultinomial(pik)
#the selected units are
which(s!=0)
#with the number of replicates 
s[s!=0]
#or use
rep((1:length(pik))[s!=0],s[s!=0]) 
</code></pre>

<hr>
<h2 id='UPopips'>Order pips sampling</h2><span id='topic+UPopips'></span>

<h3>Description</h3>

<p>Implements order <code class="reqn">\pi ps</code> sampling (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPopips(lambda,type=c("pareto","uniform","exponential"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPopips_+3A_lambda">lambda</code></td>
<td>
<p>vector of working inclusion probabilities or target ones.</p>
</td></tr>
<tr><td><code id="UPopips_+3A_type">type</code></td>
<td>
<p>the type of order sampling (pareto, uniform, exponential).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of the selected units; its length is equal to the sample size.  
</p>


<h3>References</h3>

<p>Rosén, B. (1997), Asymptotic theory for order sampling, <em>Journal of Statistical Planning and Inference</em>, 
62:135-158.<br />
Rosén, B. (1997), On sampling with probability proportional to size, <em>Journal of Statistical Planning and Inference</em>, 
62:159-191.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inclusionprobabilities">inclusionprobabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the working inclusion probabilities
lambda=c(0.2,0.7,0.8,0.5,0.4,0.4)
#draw a Pareto sample
s=UPopips(lambda, type="pareto")
#the sample is
s
</code></pre>

<hr>
<h2 id='UPpivotal'>Pivotal sampling</h2><span id='topic+UPpivotal'></span>

<h3>Description</h3>

<p>Selects an unequal probability sample using 
the pivotal method (unequal probabilities, without replacement, fixed sample size). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPpivotal(pik,eps=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPpivotal_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPpivotal_+3A_eps">eps</code></td>
<td>
<p>control value, by default equal to 1e-6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise).
The value eps is used to control pik (pik&gt;eps &amp; pik &lt; 1-eps).
</p>


<h3>References</h3>

<p>Deville, J.-C. and Tillé, Y. (1998), 
Unequal probability sampling without replacement through a splitting method, 
<em>Biometrika</em>, 85:89-101.<br />
Chauvet, G. and Tillé, Y. (2006). A fast algorithm of balanced sampling. <em>to appear in Computational Statistics</em>.<br />
Tillé, Y. (2006), <em>Sampling Algorithms</em>, Springer. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPrandompivotal">UPrandompivotal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#select a sample
s=UPpivotal(pik)
#the sample is
which(s==1)
</code></pre>

<hr>
<h2 id='UPpoisson'>Poisson sampling</h2><span id='topic+UPpoisson'></span>

<h3>Description</h3>

<p>Draws a Poisson sample using a prescribed vector of first-order inclusion 
probabilities (unequal probabilities, without replacement, random sample size). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPpoisson(pik)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPpoisson_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise). 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inclusionprobabilities">inclusionprobabilities</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
# inclusion probabilities
pik=c(1/3,1/3,1/3)
# selects a sample
s=UPpoisson(pik)
#the sample is
which(s==1)
############
## Example 2
############
data(belgianmunicipalities)
Tot=belgianmunicipalities$Tot04
name=belgianmunicipalities$Commune
n=200
pik=inclusionprobabilities(Tot,n)
# select a sample
s=UPpoisson(pik)  
#the sample is
which(s==1)
# names of the selected units
getdata(name,s)
</code></pre>

<hr>
<h2 id='UPrandompivotal'>Random pivotal sampling</h2><span id='topic+UPrandompivotal'></span>

<h3>Description</h3>

<p>Selects a sample using 
the pivotal method, when the order of the population units is random (unequal probabilities, 
without replacement, fixed sample size). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPrandompivotal(pik,eps=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPrandompivotal_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPrandompivotal_+3A_eps">eps</code></td>
<td>
<p>control value, by default equal to 1e-6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise). The value 'eps' is used to control pik 
(pik&gt;eps and pik&lt;1-eps).
</p>


<h3>References</h3>

<p>Deville, J.-C. and Tillé, Y. (1998), 
Unequal probability sampling without replacement through a splitting method, 
<em>Biometrika</em>, 85:89&ndash;101.<br />
Tillé, Y. (2006), <em>Sampling Algorithms</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPpivotal">UPpivotal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#select a sample
s=UPrandompivotal(pik)
#the sample is
which(s==1)
</code></pre>

<hr>
<h2 id='UPrandomsystematic'>Random systematic sampling</h2><span id='topic+UPrandomsystematic'></span>

<h3>Description</h3>

<p>Selects a sample using the systematic method, 
when the order of the population units
is random (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPrandomsystematic(pik,eps=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPrandomsystematic_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPrandomsystematic_+3A_eps">eps</code></td>
<td>
<p>control value, by default equal to 1e-6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise). The value 'eps' is used to control pik 
(pik&gt;eps and pik&lt;1-eps).
</p>


<h3>References</h3>

<p>Madow, W.G. (1949), On the theory of systematic sampling, II, 
<em>Annals of Mathematical Statistics</em>, 20, 333-354. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPsystematic">UPsystematic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#select a sample
s=UPrandomsystematic(pik)
#the sample is
(1:length(pik))[s==1]
</code></pre>

<hr>
<h2 id='UPsampford'>Sampford sampling</h2><span id='topic+UPsampford'></span>

<h3>Description</h3>

<p>Uses the Sampford's method to select a sample of units (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPsampford(pik,eps=1e-6, max_iter=500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPsampford_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPsampford_+3A_eps">eps</code></td>
<td>
<p>control value, by default equal to 1e-6.</p>
</td></tr>
<tr><td><code id="UPsampford_+3A_max_iter">max_iter</code></td>
<td>
<p>maximum number of iterations in the algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise).
The value eps is used to control pik (pik&gt;eps &amp; pik &lt; 1-eps). 
The sample size must be small with respect to the 
population size; otherwise, the selection time can be very long.
</p>


<h3>References</h3>

<p>Sampford, M. (1967), On sampling without replacement with unequal probabilities of
selection, <em>Biometrika</em>, 54:499-513.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPsampfordpi2">UPsampfordpi2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
s=UPsampford(pik)
#the sample is
which(s==1)
</code></pre>

<hr>
<h2 id='UPsampfordpi2'>Joint inclusion probabilities for Sampford sampling</h2><span id='topic+UPsampfordpi2'></span>

<h3>Description</h3>

<p>Computes the joint (second-order) inclusion probabilities for Sampford sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPsampfordpi2(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPsampfordpi2_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a NxN matrix of the following form: the main diagonal contains the first-order inclusion 
probabilities for each unit k in the population; elements (k,l) are the joint inclusion
probabilities of units k and l, with k not equal to l. N is the population size. 
</p>


<h3>References</h3>

<p>Sampford, M. (1967), On sampling without replacement with unequal probabilities of
selection, <em>Biometrika</em>, 54:499-513.<br />
Wu, C. (2004). R/S-PLUS Implementation of pseudo empirical
likelihood methods under unequal probability sampling. Working
paper 2004-07, Department of Statistics and Actuarial Science,
University of Waterloo.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPsampford">UPsampford</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#matrix of joint inclusion probabilities
UPsampfordpi2(pik)
</code></pre>

<hr>
<h2 id='UPsystematic'>Systematic sampling</h2><span id='topic+UPsystematic'></span>

<h3>Description</h3>

<p>Uses the systematic method to select a sample of units (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPsystematic(pik,eps=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPsystematic_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPsystematic_+3A_eps">eps</code></td>
<td>
<p>control value, by default equal to 1e-6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise).
</p>


<h3>References</h3>

<p>Madow, W.G. (1949), On the theory of systematic sampling, II, 
<em>Annals of Mathematical Statistics</em>, 20, 333-354. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inclusionprobabilities">inclusionprobabilities</a></code>, <code><a href="#topic+UPrandomsystematic">UPrandomsystematic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
#defines the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#selects a sample
s=UPsystematic(pik)
#the sample is
which(s==1)
############
## Example 2
############
data(belgianmunicipalities)
Tot=belgianmunicipalities$Tot04
name=belgianmunicipalities$Commune
pik=inclusionprobabilities(Tot,200)
#selects a sample
s=UPsystematic(pik)  
#the sample is
which(s==1)
# extracts the observed data
getdata(belgianmunicipalities,s)
</code></pre>

<hr>
<h2 id='UPsystematicpi2'>Joint inclusion probabilities for systematic sampling</h2><span id='topic+UPsystematicpi2'></span>

<h3>Description</h3>

<p>Computes the joint (second-order) inclusion probabilities for systematic sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPsystematicpi2(pik)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPsystematicpi2_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a NxN matrix of the following form: the main diagonal contains the first-order inclusion 
probabilities for each unit k in the population; elements (k,l) are the joint inclusion
probabilities of units k and l, with k not equal to l. N is the population size. 
</p>


<h3>References</h3>

<p>Madow, W.G. (1949), On the theory of systematic sampling, II, 
<em>Annals of Mathematical Statistics</em>, 20, 333-354. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPsystematic">UPsystematic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#matrix of joint inclusion probabilities
UPsystematicpi2(pik)
</code></pre>

<hr>
<h2 id='UPtille'>Tille sampling</h2><span id='topic+UPtille'></span>

<h3>Description</h3>

<p>Uses the Tillé's method to select a sample of units (unequal probabilities, without replacement, fixed sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPtille(pik,eps=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPtille_+3A_pik">pik</code></td>
<td>
<p>vector of the inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPtille_+3A_eps">eps</code></td>
<td>
<p>control value, by default equal to 1e-6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector (with elements 0 and 1) of size N, the population size.  
Each element k of this vector indicates the status of unit k 
(1, unit k is selected in the sample; 0, otherwise).
The value eps is used to control pik (pik&gt;eps &amp; pik &lt; 1-eps).
</p>


<h3>References</h3>

<p>Tillé, Y. (1996), An elimination procedure of unequal probability sampling without
replacement, <em>Biometrika</em>, 83:238-241.<br />
Deville, J.-C. and Tillé, Y. (1998), 
Unequal probability sampling without replacement through a splitting method, 
<em>Biometrika</em>, 85:89-101.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPsystematic">UPsystematic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############
## Example 1
############
#defines the prescribed inclusion probabilities
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#selects a sample
s=UPtille(pik)
#the sample is
which(s==1)
############
## Example 2
############
# see in the 'UPexamples' vignette
# vignette("UPexamples", package="sampling")
</code></pre>

<hr>
<h2 id='UPtillepi2'>Joint inclusion probabilties for Tille sampling</h2><span id='topic+UPtillepi2'></span>

<h3>Description</h3>

<p>Computes the joint (second-order) inclusion probabilities for Tillé sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPtillepi2(pik,eps=1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPtillepi2_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities.</p>
</td></tr>
<tr><td><code id="UPtillepi2_+3A_eps">eps</code></td>
<td>
<p>control value, by default equal to 1e-6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a NxN matrix of the following form: the main diagonal contains the first-order inclusion 
probabilities for each unit k in the population; elements (k,l) are the joint inclusion
probabilities of units k and l, with k not equal to l. N is the population size. The value <code>eps</code> is used to
control <code>pik</code> (pik&gt;eps &amp; pik &lt; 1-eps).
</p>


<h3>References</h3>

<p>Tillé, Y. (1996), An elimination procedure of unequal probability sampling without
replacement, <em>Biometrika</em>, 83:238-241.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPtille">UPtille</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#defines the prescribed inclusion probabilities 
pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
#matrix of joint inclusion probabilities  
UPtillepi2(pik)
</code></pre>

<hr>
<h2 id='varest'>Variance estimation using the Deville's method</h2><span id='topic+varest'></span>

<h3>Description</h3>

<p>Computes the variance estimation of an estimator of the population total using the Deville's method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>varest(Ys,Xs=NULL,pik,w=NULL)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varest_+3A_ys">Ys</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="varest_+3A_xs">Xs</code></td>
<td>
<p>matrix of the auxiliary variables; for the calibration estimator, this is the matrix of the sample calibration variables.</p>
</td></tr> 
<tr><td><code id="varest_+3A_pik">pik</code></td>
<td>
<p>vector of the first-order inclusion probabilities; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="varest_+3A_w">w</code></td>
<td>
<p>vector of the calibrated weights (for the calibration estimator); its length is equal to n, the sample size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the following estimator:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{Var}(\widehat{Ys})=\frac{1}{1-\sum_{k\in s} a_k^2}\sum_{k\in s}(1-\pi_k)\left(\frac{y_k}{\pi_k}-\frac{\sum_{l\in s} (1-\pi_{l})y_l/\pi_l}{\sum_{l\in s} (1-\pi_l)}\right)</code>
</p>

<p>where <code class="reqn">a_k=(1-\pi_k)/\sum_{l\in s} (1-\pi_l)</code>.
</p>


<h3>References</h3>

 
<p>Deville, J.-C. (1993). <em>Estimation de la variance pour les enquêtes en deux phases</em>. Manuscript, INSEE, Paris.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calibev">calibev</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Belgian municipalities data base
data(belgianmunicipalities)
attach(belgianmunicipalities)
# Computes the inclusion probabilities
pik=inclusionprobabilities(Tot04,200)
N=length(pik)
n=sum(pik)
# Defines the variable of interest
y=TaxableIncome
# Draws a Tille sample of size 200
s=UPtille(pik)
# Computes the Horvitz-Thompson estimator
HTestimator(y[s==1],pik[s==1])
# Computes the variance estimation of the Horvitz-Thompson estimator
varest(Ys=y[s==1],pik=pik[s==1])
# for an example using calibration estimator, see the 'calibration' vignette 
# vignette("calibration", package="sampling")
</code></pre>

<hr>
<h2 id='varHT'>Variance estimators of the Horvitz-Thompson estimator</h2><span id='topic+varHT'></span>

<h3>Description</h3>

<p>Computes variance estimators of the Horvitz-Thompson estimator of the population total.</p>


<h3>Usage</h3>

<pre><code class='language-R'>varHT(y,pikl,method)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varHT_+3A_y">y</code></td>
<td>
<p>vector of the variable of interest; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="varHT_+3A_pikl">pikl</code></td>
<td>
<p>matrix of joint inclusion probabilities; its dimension is nxn.</p>
</td></tr>
<tr><td><code id="varHT_+3A_method">method</code></td>
<td>
<p>if 1, an unbiased variance estimator is computed; if 2, the Sen-Yates-Grundy variance estimator for fixed sample size is computed; be default, the method is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If method is 1, the following estimator is implemented
</p>
<p style="text-align: center;"><code class="reqn">\widehat{Var}(\widehat{Y}_{HT})_1=\sum_{k\in s}\sum_{\ell\in s}
\frac{y_k y_\ell}{\pi_{k\ell} \pi_k \pi_\ell}(\pi_{k\ell} - \pi_k \pi_\ell)</code>
</p>

<p>If method is 2, the following estimator is implemented
</p>
<p style="text-align: center;"><code class="reqn">\widehat{Var}(\widehat{Y}_{HT})_2=\frac{1}{2}\sum_{k\in s}\sum_{\ell\in s}
\left(\frac{y_k}{\pi_k} - \frac{y_\ell}{\pi_\ell}\right)^2 \frac{\pi_k \pi_\ell-\pi_{k\ell}}{\pi_{k\ell}}</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HTestimator">HTestimator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pik=c(0.2,0.7,0.8,0.5,0.4,0.4)
N=length(pik)
n=sum(pik)
# Defines the variable of interest
y=rnorm(N,10,2)
# Draws a Poisson sample of expected size n
s=UPpoisson(pik)
# Computes the Horvitz-Thompson estimator
HTestimator(y[s==1],pik[s==1])
# Computes the joint inclusion prob. for Poisson sampling
pikl=outer(pik,pik,"*")
diag(pikl)=pik
# Computes the variance estimator (method=1, the sample size is not fixed)
varHT(y[s==1],pikl[s==1,s==1],1)
# Draws a Tille sample of size n
s=UPtille(pik)
# Computes the Horvitz-Thompson estimator
HTestimator(y[s==1],pik[s==1])
# Computes the joint inclusion prob. for Tille sampling
pikl=UPtillepi2(pik)
# Computes the variance estimator (method=2, the sample size is fixed)
varHT(y[s==1],pikl[s==1,s==1],2)
</code></pre>

<hr>
<h2 id='vartaylor_ratio'>Taylor-series linearization variance estimation of a ratio</h2><span id='topic+vartaylor_ratio'></span>

<h3>Description</h3>

<p>Computes the Taylor-series linearization variance estimation of the ratio </p>
<p style="text-align: center;"><code class="reqn">\frac{\widehat{Y}_s}{\widehat{X}_s}.</code>
</p>
 
<p>The estimators in the ratio are Horvitz-Thompson type estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vartaylor_ratio(Ys,Xs,pikls)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vartaylor_ratio_+3A_ys">Ys</code></td>
<td>
<p>vector of the first observed variable; its length is equal to n, the sample size.</p>
</td></tr>
<tr><td><code id="vartaylor_ratio_+3A_xs">Xs</code></td>
<td>
<p>vector of the second observed variable; its length is equal to n, the sample size.</p>
</td></tr> 
<tr><td><code id="vartaylor_ratio_+3A_pikls">pikls</code></td>
<td>
<p>matrix of joint inclusion probabilities of the sample units; its dimension is nxn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the following estimator:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{Var}(\frac{\widehat{Ys}}{\widehat{Xs}})=\sum_{i\in s}\sum_{j\in s}\frac{\pi_{ij}-\pi_i\pi_j}{\pi_{ij}}\frac{\widehat{z_i}\widehat{z_j}}{\pi_i\pi_j}</code>
</p>
 
<p>where <code class="reqn">\widehat{z_i}=(Ys_i-\widehat{r}Xs_i)/\widehat{X}_s, \widehat{r}=\widehat{Y}_s/\widehat{X}_s, \widehat{Y}_s=\sum_{i\in s}{Ys_i/\pi_i}, \widehat{X}_s=\sum_{i\in s}{Xs_i/\pi_i}</code>.
</p>


<h3>References</h3>

 
<p>Woodruff, R. (1971). <em>A Simple Method for Approximating the Variance of a Complicated Estimate</em>, Journal of the American Statistical Association, Vol. 66,  No. 334 , pp. 411&ndash;414.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(belgianmunicipalities)
attach(belgianmunicipalities)
# inclusion probabilities, sample size 200
pik=inclusionprobabilities(Tot04,200)
# the first variable (population level)
Y=Men04
# the second variable (population level)
X=Women04
# population size
N=length(pik)             
# joint inclusion probabilities for Poisson sampling
pikl=outer(pik,pik,"*")
diag(pikl)=pik
# draw a sample using Poisson sampling 
s=UPpoisson(pik)           
# sample inclusion probabilities
piks=pik[s==1]            
# the first observed variable (sample level)  
Ys=Y[s==1]
# the second observed variable (sample level)  
Xs=X[s==1]              
# matrix of joint inclusion prob. (sample level)          
pikls=pikl[s==1,s==1] 
# ratio estimator and its estimated variance
vartaylor_ratio(Ys,Xs,pikls)
</code></pre>

<hr>
<h2 id='writesample'>All possible samples of fixed size</h2><span id='topic+writesample'></span>

<h3>Description</h3>

<p>Gives a matrix whose rows are the vectors (with 0 and 1; 1 - a unit is selected, 0 - otherwise)
of all samples of fixed size.</p>


<h3>Usage</h3>

<pre><code class='language-R'>writesample(n,N)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writesample_+3A_n">n</code></td>
<td>
<p>sample size.</p>
</td></tr>
<tr><td><code id="writesample_+3A_n">N</code></td>
<td>
<p>population size.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+landingcube">landingcube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all samples of size 4
# from a population of size 10
w=writesample(4,10)
# the samples are (read by rows)
t(apply(w,1,function(x) (1:ncol(w))[x==1]))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
