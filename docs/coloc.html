<!DOCTYPE html><html><head><title>Help for package coloc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coloc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annotate_susie'><p>annotate susie_rss output for use with coloc_susie</p></a></li>
<li><a href='#approx.bf.estimates'><p>Internal function, approx.bf.estimates</p></a></li>
<li><a href='#approx.bf.p'><p>Internal function, approx.bf.p</p></a></li>
<li><a href='#bin2lin'><p>binomial to linear regression conversion</p></a></li>
<li><a href='#check_alignment'><p>check alignment</p></a></li>
<li><a href='#check_dataset'><p>check_dataset</p></a></li>
<li><a href='#coloc_test_data'><p>Simulated data to use in testing and vignettes in the coloc package</p></a></li>
<li><a href='#coloc-package'><p>Colocalisation tests of two genetic traits</p></a></li>
<li><a href='#coloc.abf'><p>Fully Bayesian colocalisation analysis using Bayes Factors</p></a></li>
<li><a href='#coloc.bf_bf'><p>Coloc data through Bayes factors</p></a></li>
<li><a href='#coloc.detail'><p>Bayesian colocalisation analysis with detailed output</p></a></li>
<li><a href='#coloc.process'><p>Post process a coloc.details result using masking</p></a></li>
<li><a href='#coloc.signals'><p>Coloc with multiple signals per trait</p></a></li>
<li><a href='#coloc.susie'><p>run coloc using susie to detect separate signals</p></a></li>
<li><a href='#coloc.susie_bf'><p>run coloc using susie to detect separate signals</p></a></li>
<li><a href='#combine.abf'><p>combine.abf</p></a></li>
<li><a href='#est_cond'><p>generate conditional summary stats</p></a></li>
<li><a href='#estgeno.1.ctl'><p>estgeno1</p></a></li>
<li><a href='#find.best.signal'><p>Pick out snp with most extreme Z score</p></a></li>
<li><a href='#findends'><p>trim a dataset to central peak(s)</p></a></li>
<li><a href='#findpeaks'><p>trim a dataset to only peak(s)</p></a></li>
<li><a href='#finemap.abf'><p>Bayesian finemapping analysis</p></a></li>
<li><a href='#finemap.bf'><p>Finemap data through Bayes factors</p></a></li>
<li><a href='#finemap.signals'><p>Finemap multiple signals in a single dataset</p></a></li>
<li><a href='#logbf_to_pp'><p>logbf 2 pp</p></a></li>
<li><a href='#logdiff'><p>logdiff</p></a></li>
<li><a href='#logsum'><p>logsum</p></a></li>
<li><a href='#map_cond'><p>find the next most significant SNP, conditioning on a list</p>
of sigsnps</a></li>
<li><a href='#map_mask'><p>find the next most significant SNP, masking a list of sigsnps</p></a></li>
<li><a href='#plot_dataset'><p>plot a coloc dataset</p></a></li>
<li><a href='#plot.coloc_abf'><p>plot a coloc_abf object</p></a></li>
<li><a href='#print.coloc_abf'><p>print.coloc_abf</p></a></li>
<li><a href='#process.dataset'><p>process.dataset</p></a></li>
<li><a href='#runsusie'><p>Run susie on a single coloc-structured dataset</p></a></li>
<li><a href='#sdY.est'><p>Estimate trait variance, internal function</p></a></li>
<li><a href='#sensitivity'><p>Prior sensitivity for coloc</p></a></li>
<li><a href='#subset_dataset'><p>subset_dataset</p></a></li>
<li><a href='#Var.data'><p>Var.data</p></a></li>
<li><a href='#Var.data.cc'><p>Var.data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, ggplot2, methods, viridis, stats, grDevices,
susieR (&ge; 0.12.06), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, mvtnorm, magrittr, rmarkdown</td>
</tr>
<tr>
<td>Title:</td>
<td>Colocalisation Tests of Two Genetic Traits</td>
</tr>
<tr>
<td>Version:</td>
<td>5.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Wallace &lt;cew54@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs the colocalisation tests described in
    Giambartolomei et al (2013) &lt;<a href="https://doi.org/10.1371%2Fjournal.pgen.1004383">doi:10.1371/journal.pgen.1004383</a>&gt;,
    Wallace (2020) &lt;<a href="https://doi.org/10.1371%2Fjournal.pgen.1008720">doi:10.1371/journal.pgen.1008720</a>&gt;,
    Wallace (2021) &lt;<a href="https://doi.org/10.1371%2Fjournal.pgen.1009440">doi:10.1371/journal.pgen.1009440</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/chr1swallace/coloc">https://github.com/chr1swallace/coloc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chr1swallace/coloc/issues">https://github.com/chr1swallace/coloc/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'coloc-package.R' 'boundaries.R' 'check.R' 'claudia.R'
'plot.R' 'private.R' 'sensitivity.R' 'split.R' 'susie.R'
'testdata.R' 'zzz.R'</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-03 13:14:23 UTC; chrisw</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Wallace [aut, cre],
  Claudia Giambartolomei [aut],
  Vincent Plagnol [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-03 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='annotate_susie'>annotate susie_rss output for use with coloc_susie</h2><span id='topic+annotate_susie'></span>

<h3>Description</h3>

<p>coloc functions need to be able to link summary stats from two
different datasets and they do this through snp identifiers.  This
function takes the output of susie_rss() and adds snp
identifiers. It is entirely the user's responsibility to ensure
snp identifiers are in the correct order, coloc cannot make any
sanity checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_susie(res, snp, LD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_susie_+3A_res">res</code></td>
<td>
<p>output of susie_rss()</p>
</td></tr>
<tr><td><code id="annotate_susie_+3A_snp">snp</code></td>
<td>
<p>vector of snp identifiers</p>
</td></tr>
<tr><td><code id="annotate_susie_+3A_ld">LD</code></td>
<td>
<p>matrix of LD (r) between snps in snp
identifiers. Columns, rows should be named by a string that
exists in the vector snp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: this annotation step is not needed if you use runsusie() -
this is only required if you use the susieR functions directly
</p>


<h3>Value</h3>

<p>res with column names added to some components
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='approx.bf.estimates'>Internal function, approx.bf.estimates</h2><span id='topic+approx.bf.estimates'></span>

<h3>Description</h3>

<p>Internal function, approx.bf.estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx.bf.estimates(z, V, type, suffix = NULL, sdY = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx.bf.estimates_+3A_z">z</code></td>
<td>
<p>normal deviate associated with regression coefficient and its variance</p>
</td></tr>
<tr><td><code id="approx.bf.estimates_+3A_v">V</code></td>
<td>
<p>its variance</p>
</td></tr>
<tr><td><code id="approx.bf.estimates_+3A_type">type</code></td>
<td>
<p>&quot;quant&quot; or &quot;cc&quot;</p>
</td></tr>
<tr><td><code id="approx.bf.estimates_+3A_suffix">suffix</code></td>
<td>
<p>suffix to append to column names of returned data.frame</p>
</td></tr>
<tr><td><code id="approx.bf.estimates_+3A_sdy">sdY</code></td>
<td>
<p>standard deviation of the trait. If not supplied, will be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate approximate Bayes Factors using supplied variance of the regression coefficients
</p>


<h3>Value</h3>

<p>data.frame containing lABF and intermediate calculations
</p>


<h3>Author(s)</h3>

<p>Vincent Plagnol, Chris Wallace
</p>

<hr>
<h2 id='approx.bf.p'>Internal function, approx.bf.p</h2><span id='topic+approx.bf.p'></span>

<h3>Description</h3>

<p>Internal function, approx.bf.p
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx.bf.p(p, f, type, N, s, suffix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approx.bf.p_+3A_p">p</code></td>
<td>
<p>p value</p>
</td></tr>
<tr><td><code id="approx.bf.p_+3A_f">f</code></td>
<td>
<p>MAF</p>
</td></tr>
<tr><td><code id="approx.bf.p_+3A_type">type</code></td>
<td>
<p>&quot;quant&quot; or &quot;cc&quot;</p>
</td></tr>
<tr><td><code id="approx.bf.p_+3A_n">N</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="approx.bf.p_+3A_s">s</code></td>
<td>
<p>proportion of samples that are cases, ignored if type==&quot;quant&quot;</p>
</td></tr>
<tr><td><code id="approx.bf.p_+3A_suffix">suffix</code></td>
<td>
<p>suffix to append to column names of returned data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate approximate Bayes Factors
</p>


<h3>Value</h3>

<p>data.frame containing lABF and intermediate calculations
</p>


<h3>Author(s)</h3>

<p>Claudia Giambartolomei, Chris Wallace
</p>

<hr>
<h2 id='bin2lin'>binomial to linear regression conversion</h2><span id='topic+bin2lin'></span>

<h3>Description</h3>

<p>Convert binomial to linear regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin2lin(D, doplot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin2lin_+3A_d">D</code></td>
<td>
<p>standard format coloc dataset</p>
</td></tr>
<tr><td><code id="bin2lin_+3A_doplot">doplot</code></td>
<td>
<p>plot results if TRUE - useful for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate beta and varbeta if a linear regression had been run on a
binary outcome, given log OR and their variance + MAF in controls
</p>
<p>sets beta = cov(x,y)/var(x) varbeta = (var(y)/var(x) -
cov(x,y)^2/var(x)^2)/N
</p>


<h3>Value</h3>

<p>D, with original beta and varbeta in beta.bin,
varbeta.bin, and beta and varbeta updated to linear estimates
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='check_alignment'>check alignment</h2><span id='topic+check_alignment'></span><span id='topic+check.alignment'></span>

<h3>Description</h3>

<p>check alignment between beta and LD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_alignment(D, thr = 0.2, do_plot = TRUE)

check.alignment(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_alignment_+3A_d">D</code></td>
<td>
<p>a coloc dataset</p>
</td></tr>
<tr><td><code id="check_alignment_+3A_thr">thr</code></td>
<td>
<p>plot SNP pairs in absolute LD &gt; thr</p>
</td></tr>
<tr><td><code id="check_alignment_+3A_do_plot">do_plot</code></td>
<td>
<p>if TRUE (default) plot the diagnostic</p>
</td></tr>
<tr><td><code id="check_alignment_+3A_...">...</code></td>
<td>
<p>arguments passed to check_alignment()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>proportion of pairs that are positive
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='check_dataset'>check_dataset</h2><span id='topic+check_dataset'></span><span id='topic+check.dataset'></span>

<h3>Description</h3>

<p>Check coloc dataset inputs for errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dataset(d, suffix = "", req = c("type", "snp"), warn.minp = 1e-06)

check.dataset(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dataset_+3A_d">d</code></td>
<td>
<p>dataset to check</p>
</td></tr>
<tr><td><code id="check_dataset_+3A_suffix">suffix</code></td>
<td>
<p>string to identify which dataset (1 or 2)</p>
</td></tr>
<tr><td><code id="check_dataset_+3A_req">req</code></td>
<td>
<p>names of elements that must be present</p>
</td></tr>
<tr><td><code id="check_dataset_+3A_warn.minp">warn.minp</code></td>
<td>
<p>print warning if no p value &lt; warn.minp</p>
</td></tr>
<tr><td><code id="check_dataset_+3A_...">...</code></td>
<td>
<p>arguments passed to check_dataset()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coloc dataset is a list, containing a mixture of vectors
capturing quantities that vary between snps (these vectors must
all have equal length) and scalars capturing quantities that
describe the dataset.
</p>
<p>Coloc is flexible, requiring perhaps only p values, or z scores, or effect
estimates and standard errors, but with this flexibility, also comes
difficulties describing exactly the combinations of items required.
</p>
<p>Required vectors are some subset of
</p>

<dl>
<dt>beta</dt><dd><p>regression coefficient for each SNP from dataset 1</p>
</dd>
<dt>varbeta</dt><dd><p>variance of beta</p>
</dd>
<dt>pvalues</dt><dd><p>P-values for each SNP in dataset 1</p>
</dd>
<dt>MAF</dt><dd><p>minor allele frequency of the variants</p>
</dd>
<dt>snp</dt><dd><p>a character vector of snp ids, optional. It will be used to merge dataset1 and dataset2 and will be retained in the results.</p>
</dd>
</dl>

<p>Preferably, give <code>beta</code> and <code>varbeta</code>.  But if these are not available, sufficient statistics can be approximated from <code>pvalues</code> and <code>MAF</code>.
</p>
<p>Required scalars are some subset of
</p>

<dl>
<dt>N</dt><dd><p>Number of samples in dataset 1</p>
</dd>
<dt>type</dt><dd><p>the type of data in dataset 1 - either &quot;quant&quot; or &quot;cc&quot; to denote quantitative or case-control</p>
</dd>
<dt>s</dt><dd><p>for a case control dataset, the proportion of samples in dataset 1 that are cases</p>
</dd>
<dt>sdY</dt><dd><p>for a quantitative trait, the population standard deviation of the trait.  if not given, it can be estimated from the vectors of varbeta and MAF</p>
</dd>
</dl>

<p>You must always give <code>type</code>.  Then,
</p>

<dl>
<dt>if <code>type</code>==&quot;cc&quot;</dt><dd><p><code>s</code></p>
</dd>
<dt>if <code>type</code>==&quot;quant&quot; and <code>sdY</code> known</dt><dd><p><code>sdY</code></p>
</dd>
<dt>if beta, varbeta not known</dt><dd><p><code>N</code></p>
</dd>
</dl>

<p>If <code>sdY</code> is unknown, it will be approximated, and this will require
</p>

<dl>
<dt>summary data to estimate <code>sdY</code></dt><dd><p><code>beta</code>, <code>varbeta</code>, <code>N</code>, <code>MAF</code></p>
</dd>
</dl>

<p>Optional vectors are
</p>

<dl>
<dt>position</dt><dd><p>a vector of snp positions, required for <code>plot_dataset</code></p>
</dd>
</dl>

<p><code>check_dataset</code> calls stop() unless a series of expectations on dataset
input format are met
</p>
<p>This is a helper function for use by other coloc functions, but
you can use it directly to check the format of a dataset to be
supplied to coloc.abf(), coloc.signals(), finemap.abf(), or
finemap.signals().
</p>


<h3>Value</h3>

<p>NULL if no errors found
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='coloc_test_data'>Simulated data to use in testing and vignettes in the coloc package</h2><span id='topic+coloc_test_data'></span>

<h3>Description</h3>

<p>Simulated data to use in testing and vignettes in the coloc package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coloc_test_data)
</code></pre>


<h3>Format</h3>

<p>A four of two coloc-style datasets. Elements D1 and D2 have a single
shared causal variant, and 50 SNPs. Elements D3 and D4 have 100 SNPs, one
shared causal variant, and one variant unique to D3. Use these as examples
of what a coloc-style dataset for a quantitative trait should look like.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coloc_test_data)
names(coloc_test_data)
str(coloc_test_data$D1)
check_dataset(coloc_test_data$D1) # should return NULL if data structure is ok
</code></pre>

<hr>
<h2 id='coloc-package'>Colocalisation tests of two genetic traits</h2><span id='topic+coloc-package'></span>

<h3>Description</h3>

<p>Performs the colocalisation tests described in Plagnol et al (2009) and
Wallace et al (2020) and draws some plots.
</p>


<h3>Author(s)</h3>

<p>Chris Wallace <a href="mailto:cew54@cam.ac.uk">cew54@cam.ac.uk</a>
</p>

<hr>
<h2 id='coloc.abf'>Fully Bayesian colocalisation analysis using Bayes Factors</h2><span id='topic+coloc.abf'></span>

<h3>Description</h3>

<p>Bayesian colocalisation analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloc.abf(dataset1, dataset2, MAF = NULL, p1 = 1e-04, p2 = 1e-04, p12 = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloc.abf_+3A_dataset1">dataset1</code></td>
<td>
<p>a list with specifically named elements defining the dataset
to be analysed. See <code><a href="#topic+check_dataset">check_dataset</a></code> for details.</p>
</td></tr>
<tr><td><code id="coloc.abf_+3A_dataset2">dataset2</code></td>
<td>
<p>as above, for dataset 2</p>
</td></tr>
<tr><td><code id="coloc.abf_+3A_maf">MAF</code></td>
<td>
<p>Common minor allele frequency vector to be used for both dataset1 and dataset2, a shorthand for supplying the same vector as parts of both datasets</p>
</td></tr>
<tr><td><code id="coloc.abf_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with trait 1, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.abf_+3A_p2">p2</code></td>
<td>
<p>prior probability a SNP is associated with trait 2, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.abf_+3A_p12">p12</code></td>
<td>
<p>prior probability a SNP is associated with both traits, default 1e-5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates posterior probabilities of different
causal variant configurations under the assumption of a single
causal variant for each trait.
</p>
<p>If regression coefficients and variances are available, it
calculates Bayes factors for association at each SNP.  If only p
values are available, it uses an approximation that depends on the
SNP's MAF and ignores any uncertainty in imputation.  Regression
coefficients should be used if available.
</p>


<h3>Value</h3>

<p>a list of two <code>data.frame</code>s:
</p>

<ul>
<li><p> summary is a vector giving the number of SNPs analysed, and the posterior probabilities of H0 (no causal variant), H1 (causal variant for trait 1 only), H2 (causal variant for trait 2 only), H3 (two distinct causal variants) and H4 (one common causal variant)
</p>
</li>
<li><p> results is an annotated version of the input data containing log Approximate Bayes Factors and intermediate calculations, and the posterior probability SNP.PP.H4 of the SNP being causal for the shared signal <em>if</em> H4 is true. This is only relevant if the posterior support for H4 in summary is convincing.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Claudia Giambartolomei, Chris Wallace
</p>

<hr>
<h2 id='coloc.bf_bf'>Coloc data through Bayes factors</h2><span id='topic+coloc.bf_bf'></span>

<h3>Description</h3>

<p>Colocalise two datasets represented by Bayes factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloc.bf_bf(
  bf1,
  bf2,
  p1 = 1e-04,
  p2 = 1e-04,
  p12 = 5e-06,
  overlap.min = 0.5,
  trim_by_posterior = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloc.bf_bf_+3A_bf1">bf1</code></td>
<td>
<p>named vector of log BF, or matrix of BF with colnames (cols=snps, rows=signals)</p>
</td></tr>
<tr><td><code id="coloc.bf_bf_+3A_bf2">bf2</code></td>
<td>
<p>named vector of log BF, or matrix of BF with colnames (cols=snps, rows=signals)</p>
</td></tr>
<tr><td><code id="coloc.bf_bf_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with trait 1, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.bf_bf_+3A_p2">p2</code></td>
<td>
<p>prior probability a SNP is associated with trait 2, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.bf_bf_+3A_p12">p12</code></td>
<td>
<p>prior probability a SNP is associated with both traits, default 1e-5</p>
</td></tr>
<tr><td><code id="coloc.bf_bf_+3A_overlap.min">overlap.min</code></td>
<td>
<p>see trim_by_posterior</p>
</td></tr>
<tr><td><code id="coloc.bf_bf_+3A_trim_by_posterior">trim_by_posterior</code></td>
<td>
<p>it is important that the signals to be colocalised
are covered by adequate numbers of snps in both datasets. If TRUE, signals
for which snps in common do not capture least overlap.min proportion of
their posteriors support are dropped and colocalisation not attempted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the workhorse behind many coloc functions
</p>


<h3>Value</h3>

<p>coloc.signals style result
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='coloc.detail'>Bayesian colocalisation analysis with detailed output</h2><span id='topic+coloc.detail'></span>

<h3>Description</h3>

<p>Bayesian colocalisation analysis, detailed output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloc.detail(
  dataset1,
  dataset2,
  MAF = NULL,
  p1 = 1e-04,
  p2 = 1e-04,
  p12 = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloc.detail_+3A_dataset1">dataset1</code></td>
<td>
<p>a list with specifically named elements defining the dataset
to be analysed. See <code><a href="#topic+check_dataset">check_dataset</a></code> for details.</p>
</td></tr>
<tr><td><code id="coloc.detail_+3A_dataset2">dataset2</code></td>
<td>
<p>as above, for dataset 2</p>
</td></tr>
<tr><td><code id="coloc.detail_+3A_maf">MAF</code></td>
<td>
<p>Common minor allele frequency vector to be used for both dataset1 and dataset2, a shorthand for supplying the same vector as parts of both datasets</p>
</td></tr>
<tr><td><code id="coloc.detail_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with trait 1, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.detail_+3A_p2">p2</code></td>
<td>
<p>prior probability a SNP is associated with trait 2, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.detail_+3A_p12">p12</code></td>
<td>
<p>prior probability a SNP is associated with both traits, default 1e-5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function replicates coloc.abf, but outputs more detail for
further processing using coloc.process
</p>
<p>Intended to be called internally by coloc.signals
</p>


<h3>Value</h3>

<p>a list of three <code>data.tables</code>s:
</p>

<ul>
<li><p> summary is a vector giving the number of SNPs analysed, and the posterior probabilities of H0 (no causal variant), H1 (causal variant for trait 1 only), H2 (causal variant for trait 2 only), H3 (two distinct causal variants) and H4 (one common causal variant)
</p>
</li>
<li><p> df is an annotated version of the input data containing log Approximate Bayes Factors and intermediate calculations, and the posterior probability SNP.PP.H4 of the SNP being causal for the shared signal
</p>
</li>
<li><p> df3 is the same for all 2 SNP H3 models
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Chris Wallace
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coloc.process">coloc.process</a></code>, <code><a href="#topic+coloc.abf">coloc.abf</a></code>
</p>

<hr>
<h2 id='coloc.process'>Post process a coloc.details result using masking</h2><span id='topic+coloc.process'></span>

<h3>Description</h3>

<p>Internal helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloc.process(
  obj,
  hits1 = NULL,
  hits2 = NULL,
  LD = NULL,
  r2thr = 0.01,
  p1 = 1e-04,
  p2 = 1e-04,
  p12 = 1e-06,
  LD1 = LD,
  LD2 = LD,
  mode = c("iterative", "allbutone")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloc.process_+3A_obj">obj</code></td>
<td>
<p>object returned by coloc.detail()</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_hits1">hits1</code></td>
<td>
<p>lead snps for trait 1. If length &gt; 1, will use
masking</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_hits2">hits2</code></td>
<td>
<p>lead snps for trait 2. If length &gt; 1, will use
masking</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_ld">LD</code></td>
<td>
<p>named LD matrix (for masking)</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_r2thr">r2thr</code></td>
<td>
<p>r2 threshold at which to mask</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with trait 1, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_p2">p2</code></td>
<td>
<p>prior probability a SNP is associated with trait 2, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_p12">p12</code></td>
<td>
<p>prior probability a SNP is associated with both traits, default 1e-5</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_ld1">LD1</code></td>
<td>
<p>named LD matrix (for masking) for trait 1 only</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_ld2">LD2</code></td>
<td>
<p>named LD matrix (for masking) for trait 2 only</p>
</td></tr>
<tr><td><code id="coloc.process_+3A_mode">mode</code></td>
<td>
<p>either &quot;iterative&quot; (default) - successively condition
on signals or &quot;allbutone&quot; - find all putative signals and
condition on all but one of them in each analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table of coloc results
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='coloc.signals'>Coloc with multiple signals per trait</h2><span id='topic+coloc.signals'></span>

<h3>Description</h3>

<p>New coloc function, builds on coloc.abf() by allowing for multiple
independent causal variants per trait through conditioning or
masking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloc.signals(
  dataset1,
  dataset2,
  MAF = NULL,
  LD = NULL,
  method = c("single", "cond", "mask"),
  mode = c("iterative", "allbutone"),
  p1 = 1e-04,
  p2 = 1e-04,
  p12 = NULL,
  maxhits = 3,
  r2thr = 0.01,
  pthr = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloc.signals_+3A_dataset1">dataset1</code></td>
<td>
<p>a list with specifically named elements defining the dataset
to be analysed. See <code><a href="#topic+check_dataset">check_dataset</a></code> for details.</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_dataset2">dataset2</code></td>
<td>
<p>as above, for dataset 2</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_maf">MAF</code></td>
<td>
<p>Common minor allele frequency vector to be used for both dataset1 and dataset2, a shorthand for supplying the same vector as parts of both datasets</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_ld">LD</code></td>
<td>
<p>required if method=&quot;cond&quot;. matrix of genotype
<em>correlation</em> (ie r, not r^2) between SNPs. If dataset1 and
dataset2 may have different LD, you can instead add LD=LD1 to
the list of dataset1 and a different LD matrix for dataset2</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_method">method</code></td>
<td>
<p>default &quot;&quot; means do no conditioning, should return
similar to coloc.abf.  if method=&quot;cond&quot;, then use conditioning
to coloc multiple signals.  if method=&quot;mask&quot;, use masking to
coloc multiple signals. if different datasets need different
methods (eg LD is only available for one of them) you can set
method on a per-dataset basis by adding method=&quot;...&quot; to the
list for that dataset.</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_mode">mode</code></td>
<td>
<p>&quot;iterative&quot; or &quot;allbutone&quot;.  Easiest understood with
an example.  Suppose there are 3 signal SNPs detected for
trait 1, A, B, C and only one for trait 2, D.
</p>
<div class="sourceCode"><pre>Under "iterative" mode, 3 coloc will be performed:
* trait 1 - trait 2
* trait 1 conditioned on A - trait 2
* trait 1 conditioned on A+B - trait 2

Under "allbutone" mode, they would be
* trait 1 conditioned on B+C - trait 2
* trait 1 conditioned on A+C - trait 2
* trait 1 conditioned on A+B - trait 2

Only iterative mode is supported for method="mask".

The allbutone mode is optimal if the signals are known with
certainty (which they never are), because it allows each
signal to be tested without influence of the others.  When
there is uncertainty, it may make sense to use iterative mode,
because the strongest signals aren't affected by conditioning
incorrectly on weaker secondary and less certain signals.
</pre></div></td></tr>
<tr><td><code id="coloc.signals_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with trait 1, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_p2">p2</code></td>
<td>
<p>prior probability a SNP is associated with trait 2, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_p12">p12</code></td>
<td>
<p>prior probability a SNP is associated with both traits, default 1e-5</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_maxhits">maxhits</code></td>
<td>
<p>maximum number of levels to condition/mask</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_r2thr">r2thr</code></td>
<td>
<p>if masking, the threshold on r2 should be used to
call two signals independent.  our experience is that this
needs to be set low to avoid double calling the same strong
signal.</p>
</td></tr>
<tr><td><code id="coloc.signals_+3A_pthr">pthr</code></td>
<td>
<p>if masking or conditioning, what p value threshold to
call a secondary hit &quot;significant&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table of coloc results, one row per pair of lead snps
detected in each dataset
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='coloc.susie'>run coloc using susie to detect separate signals</h2><span id='topic+coloc.susie'></span>

<h3>Description</h3>

<p>colocalisation with multiple causal variants via SuSiE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloc.susie(
  dataset1,
  dataset2,
  back_calculate_lbf = FALSE,
  susie.args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloc.susie_+3A_dataset1">dataset1</code></td>
<td>
<p><em>either</em> a coloc-style input dataset (see
<a href="#topic+check_dataset">check_dataset</a>), or the result of running <a href="#topic+runsusie">runsusie</a> on such a
dataset</p>
</td></tr>
<tr><td><code id="coloc.susie_+3A_dataset2">dataset2</code></td>
<td>
<p><em>either</em> a coloc-style input dataset (see
<a href="#topic+check_dataset">check_dataset</a>), or the result of running <a href="#topic+runsusie">runsusie</a> on such a
dataset</p>
</td></tr>
<tr><td><code id="coloc.susie_+3A_back_calculate_lbf">back_calculate_lbf</code></td>
<td>
<p>by default, use the log Bayes factors returned by
susie_rss. It is also possible to back-calculate these from the posterior
probabilities. It is not advised to set this to TRUE, the option exists
really for testing purposes only.</p>
</td></tr>
<tr><td><code id="coloc.susie_+3A_susie.args">susie.args</code></td>
<td>
<p>a named list of additional arguments to be passed to
<a href="#topic+runsusie">runsusie</a></p>
</td></tr>
<tr><td><code id="coloc.susie_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="#topic+coloc.bf_bf">coloc.bf_bf</a>, in particular prior
values for causal association with one trait (p1, p2) or both (p12)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list, containing elements * summary a data.table of posterior
probabilities of each global hypothesis, one row per pairwise comparison
of signals from the two traits * results a data.table of detailed results
giving the posterior probability for each snp to be jointly causal for
both traits <em>assuming H4 is true</em>. Please ignore this column if the
corresponding posterior support for H4 is not high. * priors a vector of
the priors used for the analysis
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='coloc.susie_bf'>run coloc using susie to detect separate signals</h2><span id='topic+coloc.susie_bf'></span>

<h3>Description</h3>

<p>coloc for susie output + a separate BF matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coloc.susie_bf(
  dataset1,
  bf2,
  p1 = 1e-04,
  p2 = 1e-04,
  p12 = 5e-06,
  susie.args = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coloc.susie_bf_+3A_dataset1">dataset1</code></td>
<td>
<p>a list with specifically named elements defining the dataset
to be analysed. See <code><a href="#topic+check_dataset">check_dataset</a></code> for details.</p>
</td></tr>
<tr><td><code id="coloc.susie_bf_+3A_bf2">bf2</code></td>
<td>
<p>named vector of log BF, names are snp ids and will be matched to column names of susie object's alpha</p>
</td></tr>
<tr><td><code id="coloc.susie_bf_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with trait 1, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.susie_bf_+3A_p2">p2</code></td>
<td>
<p>prior probability a SNP is associated with trait 2, default 1e-4</p>
</td></tr>
<tr><td><code id="coloc.susie_bf_+3A_p12">p12</code></td>
<td>
<p>prior probability a SNP is associated with both traits, default 1e-5</p>
</td></tr>
<tr><td><code id="coloc.susie_bf_+3A_susie.args">susie.args</code></td>
<td>
<p>named list of arguments to be passed to susieR::susie_rss()</p>
</td></tr>
<tr><td><code id="coloc.susie_bf_+3A_...">...</code></td>
<td>
<p>other arguments passed to <a href="#topic+coloc.bf_bf">coloc.bf_bf</a>, in particular prior
values for causal association with one trait (p1, p2) or both (p12)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coloc.signals style result
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='combine.abf'>combine.abf</h2><span id='topic+combine.abf'></span>

<h3>Description</h3>

<p>Internal function, calculate posterior probabilities for configurations, given logABFs for each SNP and prior probs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine.abf(l1, l2, p1, p2, p12, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.abf_+3A_l1">l1</code></td>
<td>
<p>merged.df$lABF.df1</p>
</td></tr>
<tr><td><code id="combine.abf_+3A_l2">l2</code></td>
<td>
<p>merged.df$lABF.df2</p>
</td></tr>
<tr><td><code id="combine.abf_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with trait 1, default 1e-4</p>
</td></tr>
<tr><td><code id="combine.abf_+3A_p2">p2</code></td>
<td>
<p>prior probability a SNP is associated with trait 2, default 1e-4</p>
</td></tr>
<tr><td><code id="combine.abf_+3A_p12">p12</code></td>
<td>
<p>prior probability a SNP is associated with both traits, default 1e-5</p>
</td></tr>
<tr><td><code id="combine.abf_+3A_quiet">quiet</code></td>
<td>
<p>don't print posterior summary if TRUE. default=FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named numeric vector of posterior probabilities
</p>


<h3>Author(s)</h3>

<p>Claudia Giambartolomei, Chris Wallace
</p>

<hr>
<h2 id='est_cond'>generate conditional summary stats</h2><span id='topic+est_cond'></span>

<h3>Description</h3>

<p>Internal helper function for est_all_cond
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_cond(x, LD, YY, sigsnps, xtx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_cond_+3A_x">x</code></td>
<td>
<p>coloc dataset</p>
</td></tr>
<tr><td><code id="est_cond_+3A_ld">LD</code></td>
<td>
<p>named matrix of r</p>
</td></tr>
<tr><td><code id="est_cond_+3A_yy">YY</code></td>
<td>
<p>sum((Y-Ybar)^2)</p>
</td></tr>
<tr><td><code id="est_cond_+3A_sigsnps">sigsnps</code></td>
<td>
<p>names of snps to jointly condition on</p>
</td></tr>
<tr><td><code id="est_cond_+3A_xtx">xtx</code></td>
<td>
<p>optional, matrix X'X where X is the genotype matrix. If
not available, will be estimated from LD, MAF, beta and sample
size (the last three should be part of the coloc dataset)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table giving snp, beta and varbeta on remaining snps
after conditioning
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='estgeno.1.ctl'>estgeno1</h2><span id='topic+estgeno.1.ctl'></span><span id='topic+estgeno.1.cse'></span>

<h3>Description</h3>

<p>Estimate single snp frequency distibutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estgeno.1.ctl(f)

estgeno.1.cse(G0, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estgeno.1.ctl_+3A_f">f</code></td>
<td>
<p>MAF</p>
</td></tr>
<tr><td><code id="estgeno.1.ctl_+3A_g0">G0</code></td>
<td>
<p>single snp frequency in controls (vector of length 3) -
obtained from estgeno.1.ctl</p>
</td></tr>
<tr><td><code id="estgeno.1.ctl_+3A_b">b</code></td>
<td>
<p>log odds ratio</p>
</td></tr>
</table>


<h3>Value</h3>

<p>relative frequency of genotypes 0, 1, 2
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>


<h3>See Also</h3>

<p>estgeno2
</p>

<hr>
<h2 id='find.best.signal'>Pick out snp with most extreme Z score</h2><span id='topic+find.best.signal'></span>

<h3>Description</h3>

<p>Internal helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.best.signal(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.best.signal_+3A_d">D</code></td>
<td>
<p>standard format coloc dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>z at most significant snp, named by that snp id
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='findends'>trim a dataset to central peak(s)</h2><span id='topic+findends'></span>

<h3>Description</h3>

<p>tries to be smart about detecting the interesting subregion to finemap/coloc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findends(d, maxz = 4, maxr2 = 0.1, do.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findends_+3A_d">d</code></td>
<td>
<p>a coloc dataset</p>
</td></tr>
<tr><td><code id="findends_+3A_maxz">maxz</code></td>
<td>
<p>keep all snps between the leftmost and rightmost snp with |z| &gt;
maxz</p>
</td></tr>
<tr><td><code id="findends_+3A_maxr2">maxr2</code></td>
<td>
<p>expand window to keep all snps between snps with r2 &gt; maxr2
with the left/rightmost snps defined by the maxz threshold</p>
</td></tr>
<tr><td><code id="findends_+3A_do.plot">do.plot</code></td>
<td>
<p>if TRUE, plot dataset + boundaries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector of length d$position indicating which snps to keep
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>


<h3>See Also</h3>

<p>findpeaks
</p>

<hr>
<h2 id='findpeaks'>trim a dataset to only peak(s)</h2><span id='topic+findpeaks'></span>

<h3>Description</h3>

<p>tries to be smart about detecting the interesting subregion to finemap/coloc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findpeaks(d, maxz = 4, maxr2 = 0.1, do.plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findpeaks_+3A_d">d</code></td>
<td>
<p>a coloc dataset</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_maxz">maxz</code></td>
<td>
<p>keep all snps between the leftmost and rightmost snp with |z| &gt;
maxz</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_maxr2">maxr2</code></td>
<td>
<p>expand window to keep all snps between snps with r2 &gt; maxr2
with the left/rightmost snps defined by the maxz threshold</p>
</td></tr>
<tr><td><code id="findpeaks_+3A_do.plot">do.plot</code></td>
<td>
<p>if TRUE, plot dataset + boundaries</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Differs from findends by finding multiple separate regions if there are multiple peaks
</p>


<h3>Value</h3>

<p>logical vector of length d$position indicating which snps to keep
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>


<h3>See Also</h3>

<p>findends
</p>

<hr>
<h2 id='finemap.abf'>Bayesian finemapping analysis</h2><span id='topic+finemap.abf'></span>

<h3>Description</h3>

<p>Bayesian finemapping analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finemap.abf(dataset, p1 = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finemap.abf_+3A_dataset">dataset</code></td>
<td>
<p>a list with specifically named elements defining the dataset
to be analysed. See <code><a href="#topic+check_dataset">check_dataset</a></code> for details.</p>
</td></tr>
<tr><td><code id="finemap.abf_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with the trait 1, default 1e-4</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates posterior probabilities of different
causal variant for a single trait.
</p>
<p>If regression coefficients and variances are available, it
calculates Bayes factors for association at each SNP.  If only p
values are available, it uses an approximation that depends on the
SNP's MAF and ignores any uncertainty in imputation.  Regression
coefficients should be used if available.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code>:
</p>

<ul>
<li><p> an annotated version of the input data containing log Approximate Bayes Factors and intermediate calculations, and the posterior probability of the SNP being causal
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='finemap.bf'>Finemap data through Bayes factors</h2><span id='topic+finemap.bf'></span>

<h3>Description</h3>

<p>Finemap one dataset represented by Bayes factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finemap.bf(bf1, p1 = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finemap.bf_+3A_bf1">bf1</code></td>
<td>
<p>named vector of log BF, or matrix of log BF with colnames (cols=snps, rows=signals)</p>
</td></tr>
<tr><td><code id="finemap.bf_+3A_p1">p1</code></td>
<td>
<p>prior probability a SNP is associated with the trait 1, default 1e-4</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the workhorse behind many finemap functions
</p>


<h3>Value</h3>

<p>finemap.signals style result
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='finemap.signals'>Finemap multiple signals in a single dataset</h2><span id='topic+finemap.signals'></span>

<h3>Description</h3>

<p>This is an analogue to finemap.abf, adapted to find multiple
signals where they exist, via conditioning or masking - ie a
stepwise procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finemap.signals(
  D,
  LD = D$LD,
  method = c("single", "mask", "cond"),
  r2thr = 0.01,
  sigsnps = NULL,
  pthr = 1e-06,
  maxhits = 3,
  return.pp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finemap.signals_+3A_d">D</code></td>
<td>
<p>list of summary stats for a single disease, see
<a href="#topic+check_dataset">check_dataset</a></p>
</td></tr>
<tr><td><code id="finemap.signals_+3A_ld">LD</code></td>
<td>
<p>matrix of signed r values (not rsq!) giving correlation between
SNPs</p>
</td></tr>
<tr><td><code id="finemap.signals_+3A_method">method</code></td>
<td>
<p>if method=&quot;cond&quot;, then use conditioning to coloc multiple
signals. The default is mask - this is less powerful, but safer because it
does not assume that the LD matrix is properly allelically aligned to
estimated effect</p>
</td></tr>
<tr><td><code id="finemap.signals_+3A_r2thr">r2thr</code></td>
<td>
<p>if mask==TRUE, all snps will be masked with r2 &gt; r2thr with any
sigsnps. Otherwise ignored</p>
</td></tr>
<tr><td><code id="finemap.signals_+3A_sigsnps">sigsnps</code></td>
<td>
<p>SNPs already deemed significant, to condition on or mask,
expressed as a numeric vector, whose <em>names</em> are the snp names</p>
</td></tr>
<tr><td><code id="finemap.signals_+3A_pthr">pthr</code></td>
<td>
<p>when p &gt; pthr, stop successive searching</p>
</td></tr>
<tr><td><code id="finemap.signals_+3A_maxhits">maxhits</code></td>
<td>
<p>maximum depth of conditioning. procedure will stop if p &gt;
pthr OR abs(z)&lt;zthr OR maxhits hits have been found.</p>
</td></tr>
<tr><td><code id="finemap.signals_+3A_return.pp">return.pp</code></td>
<td>
<p>if FALSE (default), just return the hits. Otherwise return vectors of PP</p>
</td></tr>
<tr><td><code id="finemap.signals_+3A_mask">mask</code></td>
<td>
<p>use masking if TRUE, otherwise conditioning. defaults to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of successively significant fine mapped SNPs, named by the SNPs
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='logbf_to_pp'>logbf 2 pp</h2><span id='topic+logbf_to_pp'></span>

<h3>Description</h3>

<p>generic convenience function to convert logbf matrix to PP matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logbf_to_pp(bf, pi, last_is_null)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logbf_to_pp_+3A_bf">bf</code></td>
<td>
<p>an L by p or p+1 matrix of log Bayes factors</p>
</td></tr>
<tr><td><code id="logbf_to_pp_+3A_pi">pi</code></td>
<td>
<p><em>either</em> a scalar representing the prior probability for any snp
to be causal, <em>or</em> a full vector of per snp / null prior probabilities</p>
</td></tr>
<tr><td><code id="logbf_to_pp_+3A_last_is_null">last_is_null</code></td>
<td>
<p>TRUE if last value of the bf vector or last column of a
bf matrix relates to the null hypothesis of no association. This is
standard for SuSiE results, but may not be for BF constructed in other
ways.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of posterior probabilities, same dimensions as bf
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='logdiff'>logdiff</h2><span id='topic+logdiff'></span>

<h3>Description</h3>

<p>Internal function, logdiff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logdiff(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logdiff_+3A_x">x</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="logdiff_+3A_y">y</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the log of the difference of the exponentiated
logs taking out the max, i.e. insuring that the difference is not negative
</p>


<h3>Value</h3>

<p>max(x) + log(exp(x - max(x,y)) - exp(y-max(x,y)))
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='logsum'>logsum</h2><span id='topic+logsum'></span>

<h3>Description</h3>

<p>Internal function, logsum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logsum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logsum_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the log of the sum of the exponentiated
logs taking out the max, i.e. insuring that the sum is not Inf
</p>


<h3>Value</h3>

<p>max(x) + log(sum(exp(x - max(x))))
</p>


<h3>Author(s)</h3>

<p>Claudia Giambartolomei
</p>

<hr>
<h2 id='map_cond'>find the next most significant SNP, conditioning on a list
of sigsnps</h2><span id='topic+map_cond'></span>

<h3>Description</h3>

<p>Internal helper function for finemap.signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_cond(D, LD, YY, sigsnps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_cond_+3A_d">D</code></td>
<td>
<p>dataset in standard coloc format</p>
</td></tr>
<tr><td><code id="map_cond_+3A_ld">LD</code></td>
<td>
<p>named matrix of r</p>
</td></tr>
<tr><td><code id="map_cond_+3A_yy">YY</code></td>
<td>
<p>sum(y^2)</p>
</td></tr>
<tr><td><code id="map_cond_+3A_sigsnps">sigsnps</code></td>
<td>
<p>names of snps to mask</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named numeric - Z score named by snp
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='map_mask'>find the next most significant SNP, masking a list of sigsnps</h2><span id='topic+map_mask'></span>

<h3>Description</h3>

<p>Internal helper function for finemap.signals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_mask(D, LD, r2thr = 0.01, sigsnps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_mask_+3A_d">D</code></td>
<td>
<p>dataset in standard coloc format</p>
</td></tr>
<tr><td><code id="map_mask_+3A_ld">LD</code></td>
<td>
<p>named matrix of r</p>
</td></tr>
<tr><td><code id="map_mask_+3A_r2thr">r2thr</code></td>
<td>
<p>mask all snps with r2 &gt; r2thr with any in sigsnps</p>
</td></tr>
<tr><td><code id="map_mask_+3A_sigsnps">sigsnps</code></td>
<td>
<p>names of snps to mask</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named numeric - Z score named by snp
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='plot_dataset'>plot a coloc dataset</h2><span id='topic+plot_dataset'></span>

<h3>Description</h3>

<p>Plot a coloc structured dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_dataset(
  d,
  susie_obj = NULL,
  highlight_list = NULL,
  alty = NULL,
  ylab = "-log10(p)",
  show_legend = TRUE,
  color = c("dodgerblue2", "green4", "#6A3D9A", "#FF7F00", "gold1", "skyblue2",
    "#FB9A99", "palegreen2", "#CAB2D6", "#FDBF6F", "gray70", "khaki2", "maroon",
    "orchid1", "deeppink1", "blue1", "steelblue4", "darkturquoise", "green1", "yellow4",
    "yellow3", "darkorange4", "brown"),
  ...
)

plot_dataset(
  d,
  susie_obj = NULL,
  highlight_list = NULL,
  alty = NULL,
  ylab = "-log10(p)",
  show_legend = TRUE,
  color = c("dodgerblue2", "green4", "#6A3D9A", "#FF7F00", "gold1", "skyblue2",
    "#FB9A99", "palegreen2", "#CAB2D6", "#FDBF6F", "gray70", "khaki2", "maroon",
    "orchid1", "deeppink1", "blue1", "steelblue4", "darkturquoise", "green1", "yellow4",
    "yellow3", "darkorange4", "brown"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_dataset_+3A_d">d</code></td>
<td>
<p>a coloc dataset</p>
</td></tr>
<tr><td><code id="plot_dataset_+3A_susie_obj">susie_obj</code></td>
<td>
<p>optional, the output of a call to runsusie()</p>
</td></tr>
<tr><td><code id="plot_dataset_+3A_highlight_list">highlight_list</code></td>
<td>
<p>optional, a list of character vectors. any snp in the
character vector will be highlighted, using a different colour for each
list.</p>
</td></tr>
<tr><td><code id="plot_dataset_+3A_alty">alty</code></td>
<td>
<p>default is to plot a standard manhattan. If you wish to plot a
different y value, pass it here. You may also want to change ylab to
describe what you are plotting.</p>
</td></tr>
<tr><td><code id="plot_dataset_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis, default is -log10(p) and assumes you are
plotting a manhattan</p>
</td></tr>
<tr><td><code id="plot_dataset_+3A_show_legend">show_legend</code></td>
<td>
<p>optional, show the legend or not. default is TRUE</p>
</td></tr>
<tr><td><code id="plot_dataset_+3A_color">color</code></td>
<td>
<p>optional, specify the colours to use for each credible set when
susie_obj is supplied. Default is shamelessly copied from
susieR::susie_plot() so that colours will match</p>
</td></tr>
<tr><td><code id="plot_dataset_+3A_...">...</code></td>
<td>
<p>other arguments passed to the base graphics plot() function</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='plot.coloc_abf'>plot a coloc_abf object</h2><span id='topic+plot.coloc_abf'></span>

<h3>Description</h3>

<p>plot a coloc_abf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coloc_abf'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.coloc_abf_+3A_x">x</code></td>
<td>
<p>coloc_abf object to be plotted</p>
</td></tr>
<tr><td><code id="plot.coloc_abf_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='print.coloc_abf'>print.coloc_abf</h2><span id='topic+print.coloc_abf'></span>

<h3>Description</h3>

<p>Print summary of a coloc.abf run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coloc_abf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.coloc_abf_+3A_x">x</code></td>
<td>
<p>object of class <code>coloc_abf</code> returned by coloc.abf()
or coloc.signals()</p>
</td></tr>
<tr><td><code id="print.coloc_abf_+3A_...">...</code></td>
<td>
<p>optional arguments: &quot;trait1&quot; name of trait 1, &quot;trait2&quot;
name of trait 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x, invisibly
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='process.dataset'>process.dataset</h2><span id='topic+process.dataset'></span>

<h3>Description</h3>

<p>Internal function, process each dataset list for coloc.abf.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.dataset(d, suffix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process.dataset_+3A_d">d</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code id="process.dataset_+3A_suffix">suffix</code></td>
<td>
<p>&quot;df1&quot; or &quot;df2&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Made public for another package to use, but not intended for users to use.
</p>


<h3>Value</h3>

<p>data.frame with log(abf) or log(bf)
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='runsusie'>Run susie on a single coloc-structured dataset</h2><span id='topic+runsusie'></span>

<h3>Description</h3>

<p>run susie_rss storing some additional information for coloc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runsusie(
  d,
  suffix = 1,
  maxit = 100,
  repeat_until_convergence = TRUE,
  s_init = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runsusie_+3A_d">d</code></td>
<td>
<p>coloc dataset, must include LD (signed correlation matrix) and N
(sample size)</p>
</td></tr>
<tr><td><code id="runsusie_+3A_suffix">suffix</code></td>
<td>
<p>suffix label that will be printed with any error messages</p>
</td></tr>
<tr><td><code id="runsusie_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations for the first run of susie_rss().
If susie_rss() does not report convergence, runs will be extended assuming
repeat_until_convergence=TRUE. Most users will not need to change this
default.</p>
</td></tr>
<tr><td><code id="runsusie_+3A_repeat_until_convergence">repeat_until_convergence</code></td>
<td>
<p>keep running until susie_rss() indicates
convergence. Default TRUE. If FALSE, susie_rss() will run with maxit
iterations, and if not converged, runsusie() will error. Most users will
not need to change this default.</p>
</td></tr>
<tr><td><code id="runsusie_+3A_s_init">s_init</code></td>
<td>
<p>used internally to extend runs that haven't converged. don't
use.</p>
</td></tr>
<tr><td><code id="runsusie_+3A_...">...</code></td>
<td>
<p>arguments passed to susie_rss. In particular, if you want to
match some coloc defaults, set
</p>

<ul>
<li><p> prior_variance=0.2^2 (if a case-control trait) or (0.15/sd(Y))^2 if a
quantitative trait
</p>
</li>
<li><p> estimate_prior_variance=FALSE
</p>
</li></ul>

<p>otherwise susie_rss will estimate the prior variance itself</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results of a susie_rss run, with some added dimnames
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(coloc)
data(coloc_test_data)
result=runsusie(coloc_test_data$D1)
summary(result)
</code></pre>

<hr>
<h2 id='sdY.est'>Estimate trait variance, internal function</h2><span id='topic+sdY.est'></span>

<h3>Description</h3>

<p>Estimate trait standard deviation given vectors of variance of coefficients,  MAF and sample size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdY.est(vbeta, maf, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdY.est_+3A_vbeta">vbeta</code></td>
<td>
<p>vector of variance of coefficients</p>
</td></tr>
<tr><td><code id="sdY.est_+3A_maf">maf</code></td>
<td>
<p>vector of MAF (same length as vbeta)</p>
</td></tr>
<tr><td><code id="sdY.est_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate is based on var(beta-hat) = var(Y) / (n * var(X))
var(X) = 2<em>maf</em>(1-maf)
so we can estimate var(Y) by regressing n*var(X) against 1/var(beta)
</p>


<h3>Value</h3>

<p>estimated standard deviation of Y
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='sensitivity'>Prior sensitivity for coloc</h2><span id='topic+sensitivity'></span>

<h3>Description</h3>

<p>Shows how prior and posterior per-hypothesis probabilities change as a function of p12
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sensitivity(
  obj,
  rule = "",
  dataset1 = NULL,
  dataset2 = NULL,
  npoints = 100,
  doplot = TRUE,
  plot.manhattans = TRUE,
  preserve.par = FALSE,
  row = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sensitivity_+3A_obj">obj</code></td>
<td>
<p>output of coloc.detail or coloc.process</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_rule">rule</code></td>
<td>
<p>a decision rule.  This states what values of posterior probabilities &quot;pass&quot; some threshold.  This is a string which will be parsed and evaluated, better explained by examples.  &quot;H4 &gt; 0.5&quot; says post prob of H4 &gt; 0.5 is a pass.  &quot;H4 &gt; 0.9 &amp; H4/H3 &gt; 3&quot; says post prob of H4 must be &gt; 0.9 AND it must be at least 3 times the post prob of H3.&quot;</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_dataset1">dataset1</code></td>
<td>
<p>optional the dataset1 used to run SuSiE. This will be used to make a Manhattan plot if plot.manhattans=TRUE.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_dataset2">dataset2</code></td>
<td>
<p>optional the dataset2 used to run SuSiE. This will be used to make a Manhattan plot if plot.manhattans=TRUE.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_npoints">npoints</code></td>
<td>
<p>the number of points over which to evaluate the prior values for p12, equally spaced on a log scale between p1*p2 and min(p1,p2) - these are logical limits on p12, but not scientifically sensible values.</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_doplot">doplot</code></td>
<td>
<p>draw the plot. set to FALSE if you want to just evaluate the prior and posterior matrices and work with them yourself</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_plot.manhattans">plot.manhattans</code></td>
<td>
<p>if TRUE, show Manhattans of input data</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_preserve.par">preserve.par</code></td>
<td>
<p>if TRUE, do not change par() of current graphics device - this is to allow sensitivity plots to be incoporated into a larger set of plots, or to be plot one per page on a pdf, for example</p>
</td></tr>
<tr><td><code id="sensitivity_+3A_row">row</code></td>
<td>
<p>when coloc.signals() has been used and multiple rows are returned in the coloc summary, which row to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is called mainly for plotting side effect.  It draws two plots, showing how prior and posterior probabilities of each coloc hypothesis change with changing p12.  A decision rule sets the values of the posterior probabilities considered acceptable, and is used to shade in green the region of the plot for which the p12 prior would give and acceptable result.  The user is encouraged to consider carefully whether some prior values shown within the green shaded region are sensible before accepting the hypothesis.  If no shading is shown, then no priors give rise to an accepted result.
</p>


<h3>Value</h3>

<p>list of 3: prior matrix, posterior matrix, and a pass/fail indicator (returned invisibly)
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='subset_dataset'>subset_dataset</h2><span id='topic+subset_dataset'></span>

<h3>Description</h3>

<p>Subset a coloc dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_dataset(dataset, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_dataset_+3A_dataset">dataset</code></td>
<td>
<p>coloc dataset</p>
</td></tr>
<tr><td><code id="subset_dataset_+3A_index">index</code></td>
<td>
<p>vector of indices of snps to KEEP</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a copy of dataset, with only the data relating to snps in index remaining
</p>


<h3>Author(s)</h3>

<p>Chris Wallace
</p>

<hr>
<h2 id='Var.data'>Var.data</h2><span id='topic+Var.data'></span>

<h3>Description</h3>

<p>variance of MLE of beta for quantitative trait, assuming var(y)=1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Var.data(f, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Var.data_+3A_f">f</code></td>
<td>
<p>minor allele freq</p>
</td></tr>
<tr><td><code id="Var.data_+3A_n">N</code></td>
<td>
<p>sample number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function
</p>


<h3>Value</h3>

<p>variance of MLE beta
</p>


<h3>Author(s)</h3>

<p>Claudia Giambartolomei
</p>

<hr>
<h2 id='Var.data.cc'>Var.data</h2><span id='topic+Var.data.cc'></span>

<h3>Description</h3>

<p>variance of MLE of beta for case-control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Var.data.cc(f, N, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Var.data.cc_+3A_f">f</code></td>
<td>
<p>minor allele freq</p>
</td></tr>
<tr><td><code id="Var.data.cc_+3A_n">N</code></td>
<td>
<p>sample number</p>
</td></tr>
<tr><td><code id="Var.data.cc_+3A_s">s</code></td>
<td>
<p>???</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function
</p>


<h3>Value</h3>

<p>variance of MLE beta
</p>


<h3>Author(s)</h3>

<p>Claudia Giambartolomei
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
