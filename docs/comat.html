<!DOCTYPE html><html><head><title>Help for package comat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {comat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#comat-package'><p>comat: Creates Co-Occurrence Matrices of Spatial Data</p></a></li>
<li><a href='#create_neighborhood'><p>Create neighborhood coordinates</p></a></li>
<li><a href='#get_cocoma'><p>Create a co-located co-occurrence matrix (cocoma)</p></a></li>
<li><a href='#get_cocove'><p>Create a co-located co-occurrence vector (cocove)</p></a></li>
<li><a href='#get_coma'><p>Create a co-occurrence matrix (coma)</p></a></li>
<li><a href='#get_cove'><p>Create a co-occurrence vector (cove)</p></a></li>
<li><a href='#get_incoma'><p>Create an integrated co-occurrence matrix (incoma)</p></a></li>
<li><a href='#get_incove'><p>Create an integrated co-occurrence vector (incove)</p></a></li>
<li><a href='#get_wecoma'><p>Create a weighted co-occurrence matrix (wecoma)</p></a></li>
<li><a href='#get_wecove'><p>Create a weighted co-occurrence vector (wecove)</p></a></li>
<li><a href='#it_metric'><p>Calculates an Information Theory-based metric</p></a></li>
<li><a href='#raster_w'><p>A matrix with weights</p></a></li>
<li><a href='#raster_w_na'><p>A matrix with weights and missing values</p></a></li>
<li><a href='#raster_x'><p>A matrix with categories</p></a></li>
<li><a href='#raster_x_na'><p>A matrix with categories and missing values</p></a></li>
<li><a href='#raster_y'><p>A matrix with categories</p></a></li>
<li><a href='#rcpp_cell_from_xy'><p>Get cell number</p></a></li>
<li><a href='#rcpp_xy_from_matrix'><p>Coordinates from a matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Creates Co-Occurrence Matrices of Spatial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Builds co-occurrence matrices based on spatial raster data.
    It includes creation of weighted co-occurrence matrices (wecoma) and 
    integrated co-occurrence matrices 
    (incoma; Vadivel et al. (2007) &lt;<a href="https://doi.org/10.1016%2Fj.patrec.2007.01.004">doi:10.1016/j.patrec.2007.01.004</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jakubnowosad.com/comat/">https://jakubnowosad.com/comat/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Nowosad/comat/issues">https://github.com/Nowosad/comat/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 13:45:49 UTC; jn</td>
</tr>
<tr>
<td>Author:</td>
<td>Jakub Nowosad <a href="https://orcid.org/0000-0002-1057-3721"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Maximillian H.K. Hesselbarth [ctb] (Co-author of underlying C++ code
    for get_class_index_map(), get_unique_values(), and rcpp_get_coma()
    functions),
  Marco Sciaini [ctb] (Co-author of underlying C++ code for
    get_class_index_map(), get_unique_values(), and rcpp_get_coma()
    functions),
  Sebastian Hanss [ctb] (Co-author of underlying C++ code for
    get_class_index_map(), get_unique_values(), and rcpp_get_coma()
    functions)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jakub Nowosad &lt;nowosad.jakub@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 16:10:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='comat-package'>comat: Creates Co-Occurrence Matrices of Spatial Data</h2><span id='topic+comat'></span><span id='topic+comat-package'></span>

<h3>Description</h3>

<p>Builds co-occurrence matrices based on spatial raster data. It includes creation of weighted co-occurrence matrices (wecoma) and integrated co-occurrence matrices (incoma; Vadivel et al. (2007) <a href="https://doi.org/10.1016/j.patrec.2007.01.004">doi:10.1016/j.patrec.2007.01.004</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jakub Nowosad <a href="mailto:nowosad.jakub@gmail.com">nowosad.jakub@gmail.com</a> (<a href="https://orcid.org/0000-0002-1057-3721">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Maximillian H.K. Hesselbarth <a href="mailto:maximilian.hesselbarth@uni-goettingen.de">maximilian.hesselbarth@uni-goettingen.de</a> (Co-author of underlying C++ code for get_class_index_map(), get_unique_values(), and rcpp_get_coma() functions) [contributor]
</p>
</li>
<li><p> Marco Sciaini <a href="mailto:sciaini.marco@gmail.com">sciaini.marco@gmail.com</a> (Co-author of underlying C++ code for get_class_index_map(), get_unique_values(), and rcpp_get_coma() functions) [contributor]
</p>
</li>
<li><p> Sebastian Hanss (Co-author of underlying C++ code for get_class_index_map(), get_unique_values(), and rcpp_get_coma() functions) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jakubnowosad.com/comat/">https://jakubnowosad.com/comat/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Nowosad/comat/issues">https://github.com/Nowosad/comat/issues</a>
</p>
</li></ul>


<hr>
<h2 id='create_neighborhood'>Create neighborhood coordinates</h2><span id='topic+create_neighborhood'></span>

<h3>Description</h3>

<p>This function creates a neighborhood coordinates matrix based on the directions parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_neighborhood(directions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_neighborhood_+3A_directions">directions</code></td>
<td>
<p>The number of directions in which cells should be connected:
4 (rook's case), 8 (queen's case), or a neighbourhood matrix.
The neighbourhood matrix should have one cell with value 0 (the focal cell),
and at least one cell with value 1 (the adjacent cells).
Cells with other values (e.g. NA) are ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='get_cocoma'>Create a co-located co-occurrence matrix (cocoma)</h2><span id='topic+get_cocoma'></span>

<h3>Description</h3>

<p>Create a co-located co-occurrence matrix (cocoma)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cocoma(x, y, neighbourhood = 4, classes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cocoma_+3A_x">x</code></td>
<td>
<p>A matrix with categories</p>
</td></tr>
<tr><td><code id="get_cocoma_+3A_y">y</code></td>
<td>
<p>A matrix with categories</p>
</td></tr>
<tr><td><code id="get_cocoma_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="get_cocoma_+3A_classes">classes</code></td>
<td>
<p>A list of length 2 with the values of selected classes from the <code>x</code> and <code>y</code> objects.
It is used to calculate cocoma only for selected classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A co-located co-occurrence matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(comat)
data(raster_x, package = "comat")
data(raster_x_na, package = "comat")

coom = get_cocoma(raster_x, raster_x_na)
coom

get_cocoma(raster_x, raster_x_na, classes = list(c(1, 2), 3))
</code></pre>

<hr>
<h2 id='get_cocove'>Create a co-located co-occurrence vector (cocove)</h2><span id='topic+get_cocove'></span>

<h3>Description</h3>

<p>Converts a co-located co-occurrence matrix (cocoma) to
a co-located co-occurrence vector (cocove)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cocove(x, ordered = TRUE, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cocove_+3A_x">x</code></td>
<td>
<p>A matrix - an output of the <code><a href="#topic+get_cocoma">get_cocoma()</a></code> function</p>
</td></tr>
<tr><td><code id="get_cocove_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="get_cocove_+3A_normalization">normalization</code></td>
<td>
<p>Should the output vector be normalized?
Either &quot;none&quot; or &quot;pdf&quot;.
The &quot;pdf&quot; option normalizes a vector to sum to one.
The default is &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A co-located co-occurrence vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(comat)
data(raster_x, package = "comat")
data(raster_x_na, package = "comat")

coom = get_cocoma(raster_x, raster_x_na)
coom

coov = get_cocove(coom)
coov
</code></pre>

<hr>
<h2 id='get_coma'>Create a co-occurrence matrix (coma)</h2><span id='topic+get_coma'></span>

<h3>Description</h3>

<p>Create a co-occurrence matrix (coma)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_coma(x, neighbourhood = 4, classes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_coma_+3A_x">x</code></td>
<td>
<p>A matrix with categories</p>
</td></tr>
<tr><td><code id="get_coma_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="get_coma_+3A_classes">classes</code></td>
<td>
<p>A vector or a list with the values of selected classes from the <code>x</code> object.
It is used to calculate coma only for selected classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A co-occurrence matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(comat)
data(raster_x, package = "comat")

com = get_coma(raster_x)
com

com2 = get_coma(raster_x, classes = c(1, 3))
com2

data(raster_x_na, package = "comat")
com3 = get_coma(raster_x_na, classes = c(0:3, NA))
com3
</code></pre>

<hr>
<h2 id='get_cove'>Create a co-occurrence vector (cove)</h2><span id='topic+get_cove'></span>

<h3>Description</h3>

<p>Converts a co-occurrence matrix (coma) to
a co-occurrence vector (cove)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cove(x, ordered = TRUE, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cove_+3A_x">x</code></td>
<td>
<p>A matrix - an output of the <code><a href="#topic+get_coma">get_coma()</a></code> function</p>
</td></tr>
<tr><td><code id="get_cove_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="get_cove_+3A_normalization">normalization</code></td>
<td>
<p>Should the output vector be normalized?
Either &quot;none&quot; or &quot;pdf&quot;.
The &quot;pdf&quot; option normalizes a vector to sum to one.
The default is &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A co-occurrence vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(comat)
data(raster_x, package = "comat")

com = get_coma(raster_x)
com

cov = get_cove(com)
cov

cov = get_cove(com, normalization = "pdf")
cov
</code></pre>

<hr>
<h2 id='get_incoma'>Create an integrated co-occurrence matrix (incoma)</h2><span id='topic+get_incoma'></span>

<h3>Description</h3>

<p>Create an integrated co-occurrence matrix (incoma)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_incoma(x, neighbourhood = 4, classes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_incoma_+3A_x">x</code></td>
<td>
<p>A list object containing categorical matrices with categories</p>
</td></tr>
<tr><td><code id="get_incoma_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="get_incoma_+3A_classes">classes</code></td>
<td>
<p>A list of the same length as <code>x</code> with the values of selected classes from all of the objects in <code>x</code>.
It is used to calculate incoma only for selected classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integrated co-occurrence matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(raster_x, package = "comat")
data(raster_w, package = "comat")
x = list(raster_x, raster_w, raster_x)

get_incoma(x)

get_incoma(x, classes = list(1:2, 2:4, 1))
</code></pre>

<hr>
<h2 id='get_incove'>Create an integrated co-occurrence vector (incove)</h2><span id='topic+get_incove'></span>

<h3>Description</h3>

<p>Converts an integrated co-occurrence matrix (incoma) to
an integrated co-occurrence vector (incove)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_incove(x, ordered = TRUE, repeated = TRUE, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_incove_+3A_x">x</code></td>
<td>
<p>A matrix - an output of the <code><a href="#topic+get_incoma">get_incoma()</a></code> function</p>
</td></tr>
<tr><td><code id="get_incove_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is TRUE.
See details for more explanation.</p>
</td></tr>
<tr><td><code id="get_incove_+3A_repeated">repeated</code></td>
<td>
<p>Should the repeated co-located co-occurrence matrices be used?
Either &quot;repeated&quot; (TRUE) or &quot;unrepeated&quot; (FALSE).
The default is TRUE.
See details for more explanation.</p>
</td></tr>
<tr><td><code id="get_incove_+3A_normalization">normalization</code></td>
<td>
<p>Should the output vector be normalized?
Either &quot;none&quot; or &quot;pdf&quot;.
The &quot;pdf&quot; option normalizes a vector to sum to one.
The default is &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All values are kept when <code>ordered = TRUE</code> and <code>repeated = TRUE</code>.
When <code>ordered = TRUE</code> and <code>repeated = FALSE</code> all values from cocoma (but only one cocoma for each pair) and all coma values are kept.
<code>ordered = FALSE</code> and <code>repeated = TRUE</code> keeps all values from cocoma, but divides coma values by 2.
<code>ordered = FALSE</code> and <code>repeated = FALSE</code> keeps all values from cocoma (but only one cocoma for each pair), and divides coma values by 2.
</p>


<h3>Value</h3>

<p>An integrated co-occurrence vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(comat)

data(raster_x, package = "comat")
data(raster_w, package = "comat")
x = list(raster_x, raster_w, raster_x)

incom = get_incoma(x)
incom

incov1 = get_incove(incom)
incov1

incov2 = get_incove(incom, ordered = FALSE)
incov2

incov3 = get_incove(incom, ordered = FALSE, normalization = "pdf")
incov3
</code></pre>

<hr>
<h2 id='get_wecoma'>Create a weighted co-occurrence matrix (wecoma)</h2><span id='topic+get_wecoma'></span>

<h3>Description</h3>

<p>Create a weighted co-occurrence matrix (wecoma)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wecoma(
  x,
  w,
  neighbourhood = 4,
  classes = NULL,
  fun = "mean",
  na_action = "replace"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wecoma_+3A_x">x</code></td>
<td>
<p>A matrix with categories</p>
</td></tr>
<tr><td><code id="get_wecoma_+3A_w">w</code></td>
<td>
<p>A matrix with weights</p>
</td></tr>
<tr><td><code id="get_wecoma_+3A_neighbourhood">neighbourhood</code></td>
<td>
<p>The number of directions in which cell adjacencies are considered as neighbours:
4 (rook's case) or 8 (queen's case). The default is 4.</p>
</td></tr>
<tr><td><code id="get_wecoma_+3A_classes">classes</code></td>
<td>
<p>A vector or a list with the values of selected classes from the <code>x</code> object.
It is used to calculate wecoma only for selected classes.</p>
</td></tr>
<tr><td><code id="get_wecoma_+3A_fun">fun</code></td>
<td>
<p>Function to calculate values from adjacent cells to contribute to output matrix, <code>"mean"</code> - calculate average values from adjacent cells of weight matrix, <code>"geometric_mean"</code> - calculate geometric mean values from adjacent cells of weight matrix, or <code>"focal"</code> assign value from the focal cell.</p>
</td></tr>
<tr><td><code id="get_wecoma_+3A_na_action">na_action</code></td>
<td>
<p>Decides on how to behave in the presence of missing values in <code>w</code>. Possible options are <code>"replace"</code>, <code>"omit"</code>, <code>"keep"</code>. The default, <code>"replace"</code>, replaces missing values with 0, <code>"omit"</code> does not use cells with missing values, and <code>"keep"</code> keeps missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted co-occurrence matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(comat)
data(raster_x, package = "comat")
data(raster_w, package = "comat")

wom = get_wecoma(raster_x, raster_w)
wom

get_wecoma(raster_x, raster_w, classes = list(c(1, 3)))
</code></pre>

<hr>
<h2 id='get_wecove'>Create a weighted co-occurrence vector (wecove)</h2><span id='topic+get_wecove'></span>

<h3>Description</h3>

<p>Converts a weighted co-occurrence matrix (wecoma) to
a weighted co-occurrence vector (wecove)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wecove(x, ordered = TRUE, normalization = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wecove_+3A_x">x</code></td>
<td>
<p>A matrix - an output of the <code><a href="#topic+get_wecoma">get_wecoma()</a></code> function</p>
</td></tr>
<tr><td><code id="get_wecove_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is TRUE.</p>
</td></tr>
<tr><td><code id="get_wecove_+3A_normalization">normalization</code></td>
<td>
<p>Should the output vector be normalized?
Either &quot;none&quot; or &quot;pdf&quot;.
The &quot;pdf&quot; option normalizes a vector to sum to one.
The default is &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weighted co-occurrence vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(comat)
data(raster_x, package = "comat")
data(raster_w, package = "comat")

wom = get_wecoma(raster_x, raster_w)
wom

wov = get_wecove(wom)
wov
</code></pre>

<hr>
<h2 id='it_metric'>Calculates an Information Theory-based metric</h2><span id='topic+it_metric'></span>

<h3>Description</h3>

<p>Calculates a selected Information Theory-based metric based on a provided co-occurrence matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>it_metric(x, metric, base = "log2", ordered = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="it_metric_+3A_x">x</code></td>
<td>
<p>A matrix - an output of the <code><a href="#topic+get_coma">get_coma()</a></code> function</p>
</td></tr>
<tr><td><code id="it_metric_+3A_metric">metric</code></td>
<td>
<p>One of the following: &quot;ent&quot; (Marginal entropy), &quot;joinent&quot; (Joint entropy), &quot;condent&quot; (Conditional entropy), &quot;mutinf&quot; (Mutual information), or &quot;relmutinf&quot; (Relative mutual information)</p>
</td></tr>
<tr><td><code id="it_metric_+3A_base">base</code></td>
<td>
<p>The unit in which entropy is measured.
The default is &quot;log2&quot;, which compute entropy in &quot;bits&quot;.
&quot;log&quot; and &quot;log10&quot; can be also used.</p>
</td></tr>
<tr><td><code id="it_metric_+3A_ordered">ordered</code></td>
<td>
<p>The type of pairs considered.
Either &quot;ordered&quot; (TRUE) or &quot;unordered&quot; (FALSE).
The default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value
</p>


<h3>References</h3>

<p>Nowosad J., TF Stepinski. 2019. Information theory as a consistent framework
for quantification and classification of landscape patterns. https://doi.org/10.1007/s10980-019-00830-x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(comat)
data(raster_x, package = "comat")

com = get_coma(raster_x)
com

it_metric(com, metric = "ent")
it_metric(com, metric = "joinent")
it_metric(com, metric = "condent")
it_metric(com, metric = "mutinf")
it_metric(com, metric = "relmutinf")
</code></pre>

<hr>
<h2 id='raster_w'>A matrix with weights</h2><span id='topic+raster_w'></span>

<h3>Description</h3>

<p>A matrix with weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(raster_w)
</code></pre>


<h3>Format</h3>

<p>A matrix
</p>

<hr>
<h2 id='raster_w_na'>A matrix with weights and missing values</h2><span id='topic+raster_w_na'></span>

<h3>Description</h3>

<p>A matrix with weights and missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(raster_w_na)
</code></pre>


<h3>Format</h3>

<p>A matrix
</p>

<hr>
<h2 id='raster_x'>A matrix with categories</h2><span id='topic+raster_x'></span>

<h3>Description</h3>

<p>A matrix with categories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(raster_x)
</code></pre>


<h3>Format</h3>

<p>A matrix
</p>

<hr>
<h2 id='raster_x_na'>A matrix with categories and missing values</h2><span id='topic+raster_x_na'></span>

<h3>Description</h3>

<p>A matrix with categories and missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(raster_x_na)
</code></pre>


<h3>Format</h3>

<p>A matrix
</p>

<hr>
<h2 id='raster_y'>A matrix with categories</h2><span id='topic+raster_y'></span>

<h3>Description</h3>

<p>A matrix with categories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(raster_y)
</code></pre>


<h3>Format</h3>

<p>A matrix
</p>

<hr>
<h2 id='rcpp_cell_from_xy'>Get cell number</h2><span id='topic+rcpp_cell_from_xy'></span>

<h3>Description</h3>

<p>Get cell number(s) of a matrix from row and column numbers.
Cell numbers start at 0 in the upper left corner,
and increase from top to bottom, and then from left to right.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_cell_from_xy(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_cell_from_xy_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="rcpp_cell_from_xy_+3A_y">y</code></td>
<td>
<p>A matrix with two columns (row and column numbers)</p>
</td></tr>
</table>

<hr>
<h2 id='rcpp_xy_from_matrix'>Coordinates from a matrix</h2><span id='topic+rcpp_xy_from_matrix'></span>

<h3>Description</h3>

<p>This function gets coordinates (row and column numbers) of the matrix cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_xy_from_matrix(x, cell = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_xy_from_matrix_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="rcpp_xy_from_matrix_+3A_cell">cell</code></td>
<td>
<p>A vector of cell number.
If NULL, the coordinates will be calculated for the whole matrix</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
