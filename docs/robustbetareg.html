<!DOCTYPE html><html><head><title>Help for package robustbetareg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robustbetareg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EGB'><p>The Exponential Generalized Beta of the Second Type Distribution</p></a></li>
<li><a href='#Firm'><p>Firm Cost</p></a></li>
<li><a href='#HIC'><p>Health Insurance Coverage</p></a></li>
<li><a href='#methodsrobustbetareg'><p>Methods for robustbetareg Objects</p></a></li>
<li><a href='#plot.robustbetareg'><p>Diagnostic Plots for robustbetareg Objects</p></a></li>
<li><a href='#plotenvelope'><p>Normal Probability Plots of Residuals with Simulated Envelope for robustbetareg Objects</p></a></li>
<li><a href='#predict'><p>Prediction Methods for robustbetareg Objects Class</p></a></li>
<li><a href='#residuals.robustbetareg'><p>Residuals Method for robustbetareg Objects</p></a></li>
<li><a href='#robustbetareg'><p>Robust Beta Regression</p></a></li>
<li><a href='#robustbetareg.control'><p>Auxiliary for Controlling robustbetareg Fitting</p></a></li>
<li><a href='#set.link'><p>Link functions for robust beta regression</p></a></li>
<li><a href='#waldtypetest'><p>Robust Wald-type Tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Beta Regression</td>
</tr>
<tr>
<td>Author:</td>
<td>Felipe Queiroz [aut, cre],
  Yuri Maluf [aut],
  Silvia Ferrari [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felipe Queiroz &lt;ffelipeq@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Robust estimators for the beta regression, useful for modeling 
  bounded continuous data. Currently, four types of robust estimators are supported. 
  They depend on a tuning constant which may be fixed or selected by a 
  data-driven algorithm also implemented in the package. Diagnostic tools 
  associated with the fitted model, such as the residuals and goodness-of-fit 
  statistics, are implemented. Robust Wald-type tests are available. More details
  about robust beta regression are described in Maluf et al. (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2209.11315">doi:10.48550/arXiv.2209.11315</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), betareg</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rmpfr, rstudioapi, crayon, pracma, numDeriv, Formula,
robustbase, zoo, methods, graphics, BBmisc, MASS, miscTools,
Matrix</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-27 15:30:32 UTC; franc</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-28 17:14:52 UTC</td>
</tr>
</table>
<hr>
<h2 id='EGB'>The Exponential Generalized Beta of the Second Type Distribution</h2><span id='topic+EGB'></span><span id='topic+dEGB'></span><span id='topic+pEGB'></span><span id='topic+qEGB'></span><span id='topic+rEGB'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation
for exponential generalized beta of the second type distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dEGB(y_star, mu, phi, log = FALSE)

pEGB(q, mu, phi)

qEGB(p, mu, phi)

rEGB(n, mu, phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EGB_+3A_y_star">y_star</code>, <code id="EGB_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="EGB_+3A_mu">mu</code></td>
<td>
<p>mu parameter.</p>
</td></tr>
<tr><td><code id="EGB_+3A_phi">phi</code></td>
<td>
<p>phi parameter.</p>
</td></tr>
<tr><td><code id="EGB_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities p are given as log(p). Default is FALSE.</p>
</td></tr>
<tr><td><code id="EGB_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="EGB_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length is taken
to be the number required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EGB distribution with parameters <code>mu = </code><code class="reqn">\mu</code> and
<code>phi = </code><code class="reqn">\phi</code> has density  </p>
<p style="text-align: center;"><code class="reqn">f(y^\star;\mu,\phi)=
    B^{-1}(\mu\phi,(1-\mu)\phi) \exp\{-y^\star(1-\mu)\phi\}/ (1+\exp\{-y^\star\})^{\phi},</code>
</p>

<p>with <code class="reqn">\mu\in(0,1),\phi&gt;0</code> and <code class="reqn">y^\star \in (-\infty, \infty)</code>. For this
distribution, <code class="reqn">E(y^\star)=\psi(\mu\phi)-\psi((1-\mu)\phi)</code> and
<code class="reqn">Var(y^\star)=\psi'(\mu\phi)+\psi'((1-\mu)\phi)</code>, where <code class="reqn">\psi</code>
is the digamma function. See Kerman and McDonald (2015) for additional
details. If <code class="reqn">y \sim beta(\mu, \phi)</code>, with <code class="reqn">\mu</code> and
<code class="reqn">\phi</code> representing the mean and precision of <code class="reqn">y</code>, then
<code class="reqn">y^\star = \log(y/(1-y)) \sim EGB(\mu, \phi)</code> with the density
given above.
</p>


<h3>Value</h3>

<p><code>dEGB</code> gives the density, <code>pEGB</code> gives the distribution function,
<code>qEGB</code> gives the quantile function, and <code>rEGB</code> generates random
variables.
</p>


<h3>Author(s)</h3>

<p>Yuri S. Maluf (<a href="mailto:yurimaluf@gmail.com">yurimaluf@gmail.com</a>),
Francisco F. Queiroz (<a href="mailto:ffelipeq@outlook.com">ffelipeq@outlook.com</a>) and Silvia L. P. Ferrari.
</p>


<h3>References</h3>

<p>Maluf, Y.S., Ferrari, S.L.P., and Queiroz, F.F. (2022). Robust
beta regression through the logit transformation. <em>arXiv</em>:2209.11315.<br /> <br />
Kerman, S. and McDonald, J.B. (2015). Skewness-kurtosis bounds for EGB1, EGB2,
and special cases. <em>Communications in Statistics - Theory and Methods</em>,
44:3857-3864.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dEGB(0.2, mu = 0.3, phi = 1)
mu = 0.2; phi = 2;
set.seed(1)
EGBsample = rEGB(1000, mu, phi)
hist(EGBsample, prob = TRUE, breaks = 15, main = "", las = 1, ylim = c(0, 0.2),
     xlim = c(-20, 10))
curve(dEGB(x, mu, phi), from = -20, to = 8, add = TRUE, col = "red")


# Showing the P(Y* &lt; -5) = 0.17, where Y* ~ EGB(0.2, 2).
x = seq(-20, 10,0.01)
y = dEGB(x, mu, phi)
plot(x, y, type = "l", lwd = 2, las = 1)
x1 = seq(-20, -5, 0.01)
y1 = dEGB(x1, mu, phi)
polygon(c(x1, -5, -5), c(y1, 0, 0), col = "lightblue")


plot(x, pEGB(x, mu, phi), type = "l", las = 1, lwd = 2,
     ylab = expression(P("Y*"&lt;y)), xlab = "y")
p = pEGB(0, mu, phi)
q = qEGB(p, mu, phi)
points(q, p, pch = 16, col = 2, cex = 1.5)
text(2, 0.83, paste("(", 0, ",", round(p, 2), ")"), font = 2,
     cex = 0.8, col = "red")

</code></pre>

<hr>
<h2 id='Firm'>Firm Cost</h2><span id='topic+Firm'></span>

<h3>Description</h3>

<p>A dataset on risk management practices of 73 firms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Firm", package = "robustbetareg")
</code></pre>


<h3>Format</h3>

<p>A data frame with 73 rows and 7 variables:
</p>

<dl>
<dt>FIRMCOST</dt><dd><p>total property and casualty premiums and uninsured losses
as a percentage of total assets.</p>
</dd>
<dt>ASSUME</dt><dd><p>per occurrence retention amount as a percentage of total
assets.</p>
</dd>
<dt>CAP</dt><dd><p>indicates that the firm owns a captive insurance company; 1 if
the firm uses a captive, 0 otherwise.</p>
</dd>
<dt>SIZELOG</dt><dd><p>logarithm of total assets.</p>
</dd>
<dt>INDCOST</dt><dd><p>a measure of the firm's industry risk.</p>
</dd>
<dt>CENTRAL</dt><dd><p>a measure of the importance of the local managers in
choosing the amount of risk to be retained.</p>
</dd>
<dt>SOPH</dt><dd><p>a measure of the degree of importance in using analytical tools.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset was introduced and analyzed by Schmit and Roth (1990) and
is available in the personal web page of Professor E. Frees (Wisconsin School
of Business Research). The response variable is <code>FIRMCOST</code>, smaller
values of firm cost are attributed to firms that have a good risk management
performance.
</p>


<h3>Source</h3>

<p><a href="https://instruction.bus.wisc.edu/jfrees/jfreesbooks/Regression%20Modeling/BookWebDec2010/CSVData/RiskSurvey.csv">https://instruction.bus.wisc.edu/jfrees/jfreesbooks/Regression%20Modeling/BookWebDec2010/CSVData/RiskSurvey.csv</a>
</p>


<h3>References</h3>

<p>Schmit, J.T. and Roth, K. (1990). Cost effectiveness of risk management
practices. <em>Journal of Risk and Insurance</em>. 57:455-470.
</p>

<hr>
<h2 id='HIC'>Health Insurance Coverage</h2><span id='topic+HIC'></span>

<h3>Description</h3>

<p>A dataset containing the proportion of the population from several cities
of the state of São Paulo, Brazil, in 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HIC", package = "robustbetareg")
</code></pre>


<h3>Format</h3>

<p>A data frame with 80 rows and 4 variables:
</p>

<dl>
<dt>CITY</dt><dd><p>the corresponding city.</p>
</dd>
<dt>URB</dt><dd><p>proportion of the total population living in the
city’s urban zone.</p>
</dd>
<dt>GDP</dt><dd><p>per capita gross domestic product.</p>
</dd>
<dt>HIC</dt><dd><p>the health insurance coverage index.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset was collected by the Institute of Applied Economic
Research (Instituto de Pesquisa Econômica Aplicada, IPEA, Brazil). It
includes information on 80 cities in the state of São Paulo, Brazil,
in 2010.
</p>


<h3>Source</h3>

<p><a href="http://www.ipeadata.gov.br/Default.aspx">http://www.ipeadata.gov.br/Default.aspx</a>
</p>

<hr>
<h2 id='methodsrobustbetareg'>Methods for robustbetareg Objects</h2><span id='topic+methodsrobustbetareg'></span><span id='topic+summary.robustbetareg'></span><span id='topic+coef.robustbetareg'></span><span id='topic+print.summary.robustbetareg'></span>

<h3>Description</h3>

<p>Some S3 methods for objects of class &quot;<code>robustbetareg</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robustbetareg'
summary(object, type = "sweighted2", ...)

## S3 method for class 'robustbetareg'
coef(object, model = c("full", "mean", "precision"), ...)

## S3 method for class 'summary.robustbetareg'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methodsrobustbetareg_+3A_object">object</code>, <code id="methodsrobustbetareg_+3A_x">x</code></td>
<td>
<p>fitted model of class <code>robustbetareg</code>.</p>
</td></tr>
<tr><td><code id="methodsrobustbetareg_+3A_type">type</code></td>
<td>
<p>character specifying the type of residuals to be included in the
summary output, see <code><a href="#topic+residuals.robustbetareg">residuals.robustbetareg</a></code>.</p>
</td></tr>
<tr><td><code id="methodsrobustbetareg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="methodsrobustbetareg_+3A_model">model</code></td>
<td>
<p>character specifying for which component of the model the
coefficients should be extracted.</p>
</td></tr>
<tr><td><code id="methodsrobustbetareg_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of methods for fitted model objects of class <code>robustbetareg</code>,
including methods to the generic functions <code><a href="base.html#topic+print">print</a></code> and
<code><a href="base.html#topic+summary">summary</a></code>, which print the estimated coefficients along with
some further information.
</p>


<h3>Value</h3>

<p><code>methodsrobustbetareg</code> returns different outputs for objects of
class <code>robustbetareg</code>, depending on the used method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robustbetareg">robustbetareg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("HIC", package="robustbetareg")
fit=robustbetareg(HIC~URB+GDP|1,data=HIC,alpha=0.06)
summary(fit)
coef(fit)


</code></pre>

<hr>
<h2 id='plot.robustbetareg'>Diagnostic Plots for robustbetareg Objects</h2><span id='topic+plot.robustbetareg'></span>

<h3>Description</h3>

<p>Several types of standard diagnostic plots can be produced interactively,
involving different types of residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robustbetareg'
plot(x, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.robustbetareg_+3A_x">x</code></td>
<td>
<p>fitted model object of class &quot;<code>robustbetareg</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.robustbetareg_+3A_ask">ask</code></td>
<td>
<p>logical. If &quot;<code>TRUE</code>&quot; the user is asked before each plot.</p>
</td></tr>
<tr><td><code id="plot.robustbetareg_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to the <code><a href="base.html#topic+plot">plot</a></code> function (see
<code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot</code> method for <code><a href="#topic+robustbetareg">robustbetareg</a></code> objects returns
several diagnostic plots.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robustbetareg">robustbetareg</a></code>, <code><a href="#topic+residuals.robustbetareg">residuals.robustbetareg</a></code>,
<code><a href="#topic+plotenvelope">plotenvelope</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get(data("HIC", package = "robustbetareg"))
hic &lt;- robustbetareg(HIC ~ URB + GDP | GDP,
                     data = HIC, alpha = 0.06)

</code></pre>

<hr>
<h2 id='plotenvelope'>Normal Probability Plots of Residuals with Simulated Envelope for robustbetareg Objects</h2><span id='topic+plotenvelope'></span>

<h3>Description</h3>

<p><code>plotenvelope</code> is used to display normal probability plots of residuals
with simulated envelope for the robust beta regression. Currently, eight types of
residuals are supported: sweighted2, pearson, weighted, sweighted,
sweighted.gamma, sweighted2.gamma, combined, and combined.projection residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotenvelope(
  object,
  type = c("sweighted2", "pearson", "weighted", "sweighted", "sweighted.gamma",
    "sweighted2.gamma", "combined", "combined.projection"),
  conf = 0.95,
  n.sim = 100,
  PrgBar = TRUE,
  control = robustbetareg.control(...),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotenvelope_+3A_object">object</code></td>
<td>
<p>fitted model object of class <code>robustbetareg</code>.</p>
</td></tr>
<tr><td><code id="plotenvelope_+3A_type">type</code></td>
<td>
<p>character indicating the type of residuals to be used, see
<code><a href="#topic+residuals.robustbetareg">residuals.robustbetareg</a></code>. Default is <code>type = "sweighted2"</code>.</p>
</td></tr>
<tr><td><code id="plotenvelope_+3A_conf">conf</code></td>
<td>
<p>numeric specifying the confidence level of the simulated
envelopes. Default is <code>conf = 0.95</code>.</p>
</td></tr>
<tr><td><code id="plotenvelope_+3A_n.sim">n.sim</code></td>
<td>
<p>a positive integer representing the number of iterations
to generate the simulated envelopes. Default is <code>n.sim = 100</code>.</p>
</td></tr>
<tr><td><code id="plotenvelope_+3A_prgbar">PrgBar</code></td>
<td>
<p>logical. If <code>PrgBar = TRUE</code> the progress bar will be shown
in the console. Default is <code>PrgBar = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotenvelope_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via
<code><a href="#topic+robustbetareg.control">robustbetareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="plotenvelope_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plotenvelope</code> creates normal probability plots with simulated
envelope (see Atkinson (1985) for details). Under the correct model,
approximately 100*conf of the residuals are expected to be inside the
envelope.
</p>


<h3>Value</h3>

<p><code>plotenvelope</code> returns normal probability plot of residuals with simulated
envelope.
</p>


<h3>Author(s)</h3>

<p>Yuri S. Maluf (<a href="mailto:yurimaluf@gmail.com">yurimaluf@gmail.com</a>),
Francisco F. Queiroz (<a href="mailto:ffelipeq@outlook.com">ffelipeq@outlook.com</a>) and Silvia L. P. Ferrari.
</p>


<h3>References</h3>

<p>Maluf, Y.S., Ferrari, S.L.P., and Queiroz, F.F. (2022). Robust
beta regression through the logit transformation. <em>arXiv</em>:2209.11315.<br /> <br />
Atkinson, A.C. (1985) Plots, transformations and regression: an
introduction to graphical methods of diagnostic regression analysis.
<em>Oxford Science Publications</em>, Oxford.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robustbetareg">robustbetareg</a></code>, <code><a href="#topic+robustbetareg.control">robustbetareg.control</a></code>,
<code><a href="#topic+residuals.robustbetareg">residuals.robustbetareg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get(data("HIC", package = "robustbetareg"))
hic &lt;- robustbetareg(HIC ~ URB + GDP | GDP,
data = HIC, alpha = 0.06)
plotenvelope(hic, n.sim = 50)

get(data("Firm", package = "robustbetareg"))
rmc &lt;- robustbetareg(FIRMCOST ~ INDCOST + SIZELOG | INDCOST + SIZELOG, data = Firm)
plotenvelope(rmc, conf = 0.90)
</code></pre>

<hr>
<h2 id='predict'>Prediction Methods for robustbetareg Objects Class</h2><span id='topic+predict'></span>

<h3>Description</h3>

<p>Extract various types of predictions from beta regression models: either on
the scale of responses in (0, 1) or the scale of the linear predictor,
from <code>robustbetareg</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(
  object,
  newdata = NULL,
  type = c("response", "link", "precision", "variance", "quantile"),
  at = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>fitted model object of class &quot;<code>robustbetareg</code>&quot;.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>optional, a data frame with new predictor values. If omitted,
the original predictors are used.</p>
</td></tr>
<tr><td><code id="predict_+3A_type">type</code></td>
<td>
<p>character indicating type of predictions: fitted means of response
(&quot;<code>response</code>&quot;), corresponding linear predictor (&quot;<code>link</code>&quot;),
fitted precision parameter phi (&quot;<code>precision</code>&quot;), fitted variances
of response (&quot;<code>variance</code>&quot;), or fitted quantile(s) of the response
distribution (&quot;<code>quantile</code>&quot;).</p>
</td></tr>
<tr><td><code id="predict_+3A_at">at</code></td>
<td>
<p>numeric vector indicating the level(s) at which quantiles should be
predicted (only if <code>type = "quantile"</code>). Default is the median
<code>at = 0.5</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector with the predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get(data("HIC", package = "robustbetareg"))
hic &lt;- robustbetareg(HIC ~ URB + GDP | 1, data = HIC, alpha = 0.04)
cbind(predict(hic, type = "response"), predict(hic, type = "quantile", at = c(0.25, 0.5, 0.75)))


</code></pre>

<hr>
<h2 id='residuals.robustbetareg'>Residuals Method for robustbetareg Objects</h2><span id='topic+residuals.robustbetareg'></span><span id='topic+residuals'></span><span id='topic+.robustbetareg'></span>

<h3>Description</h3>

<p>The function provides several types of residuals for the robust beta regression
models: Pearson residuals (raw residuals scaled by square root of variance function)
and different kinds of weighted residuals proposed by Espinheira et al. (2008)
and Espinheira et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'robustbetareg'
residuals(
  object,
  type = c("sweighted2", "pearson", "weighted", "sweighted", "sweighted.gamma",
    "sweighted2.gamma", "combined", "combined.projection"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.robustbetareg_+3A_object">object</code></td>
<td>
<p>fitted model object of class <code>robustbetareg</code>.</p>
</td></tr>
<tr><td><code id="residuals.robustbetareg_+3A_type">type</code></td>
<td>
<p>character indicating type of residuals to be used.</p>
</td></tr>
<tr><td><code id="residuals.robustbetareg_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The definitions of the first four residuals are provided in
Espinheira et al. (2008):  equation (2) for &quot;<code>pearson</code>&quot;,
equation (6) for &quot;<code>weighted</code>&quot;, equation (7) for &quot;<code>sweighted</code>&quot;,
and equation (8) for &quot;<code>sweighted2</code>&quot;. For the last four residuals
the definitions are described in Espinheira et al. (2017): equations (7)
and (10) for the &quot;<code>sweighted.gamma</code>&quot; and &quot;<code>sweighted2.gamma</code>&quot;,
respectively, equation (9) for &quot;<code>combined</code>&quot;, and equation (11)
for &quot;<code>combined.projection</code>&quot;.
</p>


<h3>Value</h3>

<p><code>residuals</code> returns a vector with the residuals of the type
specified in the <code>type</code> argument.
</p>


<h3>References</h3>

<p>Maluf, Y. S., Ferrari, S. L. P., and Queiroz, F. F. (2022). Robust
beta regression through the logit transformation. <em>arXiv</em>:2209.11315.<br /> <br />
Espinheira, P.L., Ferrari, S.L.P., and Cribari-Neto, F. (2008). On Beta
Regression Residuals. <em>Journal of Applied Statistics</em>, 35:407–419.<br /> <br />
Espinheira, P.L., Santos, E.G.and Cribari-Neto, F. (2017). On nonlinear
beta regression residuals. <em>Biometrical Journal</em>, 59:445-461.<br /> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robustbetareg">robustbetareg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get(data("HIC", package = "robustbetareg"))
fit.hic &lt;- robustbetareg(HIC ~ URB + GDP | 1,
                         data = HIC, alpha = 0.04)
res &lt;- residuals(fit.hic, type = "sweighted2")
#plot(res)
#abline(h = 0)


</code></pre>

<hr>
<h2 id='robustbetareg'>Robust Beta Regression</h2><span id='topic+robustbetareg'></span><span id='topic+LMDPDE.fit'></span><span id='topic+LSMLE.fit'></span><span id='topic+MDPDE.fit'></span><span id='topic+SMLE.fit'></span>

<h3>Description</h3>

<p>Fit robust beta regression models for rates and proportions via LSMLE, LMDPDE,
SMLE and MDPDE. Both mean and precision of the response variable are modeled
through parametric functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustbetareg(
  formula,
  data,
  alpha,
  type = c("LSMLE", "LMDPDE", "SMLE", "MDPDE"),
  link = c("logit", "probit", "cloglog", "cauchit", "loglog"),
  link.phi = NULL,
  control = robustbetareg.control(...),
  model = TRUE,
  ...
)

LMDPDE.fit(y, x, z, alpha = NULL, link = "logit",
link.phi = "log", control = robustbetareg.control(...), ...)

LSMLE.fit(y, x, z, alpha = NULL, link = "logit",
link.phi = "log", control = robustbetareg.control(...), ...)

MDPDE.fit(y, x, z, alpha = NULL, link = "logit",
link.phi = "log", control = robustbetareg.control(...), ...)

SMLE.fit(y, x, z, alpha = NULL, link = "logit",
link.phi = "log", control = robustbetareg.control(...), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robustbetareg_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model. See Details for further
information.</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_data">data</code></td>
<td>
<p>dataset to be used.</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_alpha">alpha</code></td>
<td>
<p>numeric in <code class="reqn">[0,1)</code> indicating the value of the tuning constant
alpha. <code>alpha = 0</code> leads to the maximum likelihood estimator.
Robust procedures require <code>alpha</code> greater than zero.
If this argument is suppressed, the tuning constant will be selected
automatically through the data-driven algorithm proposed by Ribeiro and
Ferrari (2022).</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_type">type</code></td>
<td>
<p>character specifying the type of robust estimator to be used in the
estimation process. Supported estimators are &quot;<code>LSMLE</code>&quot; ,
&quot;<code>LMDPDE</code>&quot;,  &quot;<code>SMLE</code>&quot;, and &quot;<code>MDPDE</code>&quot;; for details, see Maluf
et al. (2022). The &quot;<code>LSMLE</code>&quot; is the default.</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_link">link</code></td>
<td>
<p>an optional character that specifies the link function of the
mean submodel (mu). The &quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cloglog</code>&quot;,
&quot;<code>cauchit</code>&quot;, &quot;<code>loglog</code>&quot; functions are supported. The <code>logit</code>
function is the default.</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_link.phi">link.phi</code></td>
<td>
<p>an optional character that specifies the link function of the
precision submodel (phi). The &quot;<code>identity</code>&quot;, &quot;<code>log</code>&quot;, &quot;<code>sqrt</code>&quot;
functions are supported. The default is <code>log</code> unless formula is of type
<code>y ~ x</code> where the default is &quot;<code>identity</code>&quot;.</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_control">control</code></td>
<td>
<p>a list of control arguments specified via
<code><a href="#topic+robustbetareg.control">robustbetareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_model">model</code></td>
<td>
<p>logical. If <code>TRUE</code> the corresponding components of the fit
(model frame, response, model matrix) are returned.</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_...">...</code></td>
<td>
<p>argument to be passed to <code><a href="#topic+robustbetareg.control">robustbetareg.control</a></code>.</p>
</td></tr>
<tr><td><code id="robustbetareg_+3A_y">y</code>, <code id="robustbetareg_+3A_x">x</code>, <code id="robustbetareg_+3A_z">z</code></td>
<td>
<p><code>y</code> must be a numeric response vector (with values in
<code class="reqn">(0,1)</code>), <code>x</code> must be a numeric regressor matrix for the mean
submodel, and <code>z</code> must be a numeric regressor matrix for the precision
submodel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Beta regression models are employed to model continuous response
variables in the unit interval, like rates and proportions. The maximum
likelihood-based inference suffers from
the lack of robustness in the presence of outliers. Based on
the density power divergence, Ghosh (2019) proposed the minimum density
power divergence estimator (MDPDE). Ribeiro and Ferrari (2022) proposed an
estimator based on the maximization of a reparameterized Lq-likelihood;
it is called SMLE. These estimators require suitable restrictions in the
parameter space. Maluf et al. (2022) proposed robust estimators based on
the MDPDE and the SMLE which have the advantage of overcoming this drawback.
These estimators are called LMDPDE and LSMLE. For details, see the
cited works. The four estimators are implemented in the <code>robustbetareg</code>
function. They depend on a tuning constant (called <code class="reqn">\alpha</code>).
When the tuning constant is fixed and equal to 0, all of the estimators
coincide with the maximum likelihood estimator. Ribeiro and Ferrari (2022)
and Maluf et al. (2022) suggest using a data-driven algorithm to select the
optimum value of <code class="reqn">\alpha</code>. This algorithm is implemented in
<code>robustbetareg</code> by default when the argument &quot;<code>alpha</code>&quot; is
suppressed.<br /> <br />
The formulation of the model has the same structure as in the usual functions
<code><a href="stats.html#topic+glm">glm</a></code> and <code><a href="betareg.html#topic+betareg">betareg</a></code>. The argument
<code>formula</code> can comprise of three parts (separated by the symbols
&quot;<code class="reqn">~</code>&quot; and &quot;<code class="reqn">|</code>&quot;), namely: observed response variable in the unit
interval, predictor of the mean submodel, with link function <code>link</code>
and predictor of the precision submodel, with <code>link.phi</code>
link function. If the model has constant precision, the third part may be
omitted and the link function for phi is &quot;<code>identity</code>&quot; by default.
The tuning constant <code>alpha</code> may be treated as fixed or not (chosen
by the data-driven algorithm). If <code>alpha</code> is fixed, its value
must be specified in the <code>alpha</code> argument. <br /> <br />
Some methods are available for objects of class &quot;<code>robustbetareg</code>&quot;,
see <code><a href="#topic+plot.robustbetareg">plot.robustbetareg</a></code>, <code><a href="#topic+summary.robustbetareg">summary.robustbetareg</a></code>,
<code><a href="#topic+coef.robustbetareg">coef.robustbetareg</a></code>, and <code><a href="#topic+residuals.robustbetareg">residuals.robustbetareg</a></code>,
for details and other methods.
</p>


<h3>Value</h3>

<p><code>robustbetareg</code> returns an object of class &quot;<code>robustbetareg</code>&quot; with a list of the following components:</p>

<table>
<tr>
 <td style="text-align: left;">
   <code>coefficients</code> </td><td style="text-align: left;"> a list with the "<code>mean</code>" and "<code>precision</code>"
   coefficients. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>vcov</code> </td><td style="text-align: left;"> covariance matrix. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>converged</code> </td><td style="text-align: left;">  logical indicating successful convergence of the
      iterative process. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>fitted.values</code> </td><td style="text-align: left;"> a vector with the fitted values of the mean submodel. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>start</code> </td><td style="text-align: left;"> a vector with the starting values used in the iterative process. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>weights</code> </td><td style="text-align: left;"> the weights of each observation in the estimation process. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Tuning</code> </td><td style="text-align: left;"> value of the tuning constant (automatically chosen or fixed) used
      in the estimation process. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>residuals</code> </td><td style="text-align: left;"> a vector of standardized weighted residual 2 (see Espinheira et al. (2008)). </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>n</code> </td><td style="text-align: left;"> number of observations. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>link</code> </td><td style="text-align: left;"> link function used in the mean submodel. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>link.phi</code> </td><td style="text-align: left;"> link function used in the precision submodel. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>Optimal.Tuning</code> </td><td style="text-align: left;"> logical indicating whether the data-driven algorithm
      was used. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>pseudo.r.squared</code> </td><td style="text-align: left;"> pseudo R-squared value. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>control</code> </td><td style="text-align: left;"> the control arguments passed to the data-driven algorithm and
     <code>optim</code> call. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>std.error</code> </td><td style="text-align: left;"> the standard errors. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>method</code> </td><td style="text-align: left;"> type of estimator used. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>call</code> </td><td style="text-align: left;"> the original function call. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>formula</code> </td><td style="text-align: left;"> the formula used. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>model</code> </td><td style="text-align: left;"> the full model frame. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>terms</code> </td><td style="text-align: left;"> a list with elements "<code>mean</code>", "<code>precision</code>" and "<code>full</code>"
       containing the term objects for the respective models.  </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>y</code> </td><td style="text-align: left;"> the response variable. </td>
</tr>
<tr>
 <td style="text-align: left;">
   </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>data</code> </td><td style="text-align: left;"> the dataset used. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Yuri S. Maluf (<a href="mailto:yurimaluf@gmail.com">yurimaluf@gmail.com</a>), Francisco F. Queiroz (<a href="mailto:ffelipeq@outlook.com">ffelipeq@outlook.com</a>) and Silvia L. P. Ferrari.
</p>


<h3>References</h3>

<p>Maluf, Y.S., Ferrari, S.L.P., and Queiroz, F.F. (2022). Robust
beta regression through the logit transformation. <em>arXiv</em>:2209.11315.<br /> <br />
Ribeiro, T.K.A. and Ferrari, S.L.P.  (2022). Robust estimation in beta regression
via maximum Lq-likelihood. <em>Statistical Papers</em>. DOI: 10.1007/s00362-022-01320-0. <br /> <br />
Ghosh, A. (2019). Robust inference under the beta regression model with
application to health care studies. <em>Statistical Methods in Medical
Research</em>, 28:271-888.<br /> <br />
Espinheira, P.L., Ferrari, S.L.P., and Cribari-Neto, F. (2008). On beta regression residuals. <em>Journal of Applied Statistics</em>, 35:407–419.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robustbetareg.control">robustbetareg.control</a></code>, <code><a href="#topic+summary.robustbetareg">summary.robustbetareg</a></code>, <code><a href="#topic+residuals.robustbetareg">residuals.robustbetareg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Risk Manager Cost data
data("Firm")

# MLE fit (fixed alpha equal to zero)
fit_MLE &lt;- robustbetareg(FIRMCOST ~ SIZELOG + INDCOST,
                         data = Firm, type = "LMDPDE", alpha = 0)
summary(fit_MLE)

# MDPDE with alpha = 0.04
fit_MDPDE &lt;- robustbetareg(FIRMCOST ~ SIZELOG + INDCOST,
                           data = Firm, type = "MDPDE",
                           alpha = 0.04)
summary(fit_MDPDE)

# Choosing alpha via data-driven algorithm
fit_MDPDE2 &lt;- robustbetareg(FIRMCOST ~ SIZELOG + INDCOST,
                            data = Firm, type = "MDPDE")
summary(fit_MDPDE2)

# Similar result for the LMDPDE fit:
fit_LMDPDE2 &lt;- robustbetareg(FIRMCOST ~ SIZELOG + INDCOST,
                             data = Firm, type = "LMDPDE")
summary(fit_LMDPDE2)

# Diagnostic plots


#### HIC data
data("HIC")

# MLE (fixed alpha equal to zero)
fit_MLE &lt;- robustbetareg(HIC ~ URB + GDP |
                         GDP, data = HIC, type = "LMDPDE",
                         alpha = 0)
summary(fit_MLE)

# SMLE and MDPDE with alpha selected via data-driven algorithm
fit_SMLE &lt;- robustbetareg(HIC ~ URB + GDP |
                          GDP, data = HIC, type = "SMLE")
summary(fit_SMLE)
fit_MDPDE &lt;- robustbetareg(HIC ~ URB + GDP |
                           GDP, data = HIC, type = "MDPDE")
summary(fit_MDPDE)
# SMLE and MDPDE return MLE because of the lack of stability

# LSMLE and LMDPDE with alpha selected via data-driven algorithm
fit_LSMLE &lt;- robustbetareg(HIC ~ URB + GDP |
                           GDP, data = HIC, type = "LSMLE")
summary(fit_LSMLE)
fit_LMDPDE &lt;- robustbetareg(HIC ~ URB + GDP |
                            GDP, data = HIC, type = "LMDPDE")
summary(fit_LMDPDE)
# LSMLE and LMDPDE return robust estimates with alpha = 0.06


# Plotting the weights against the residuals - LSMLE fit.
plot(fit_LSMLE$residuals, fit_LSMLE$weights, pch = "+", xlab = "Residuals",
    ylab = "Weights")

# Excluding outlier observation.
fit_LSMLEwo1 &lt;- robustbetareg(HIC ~ URB + GDP |
                              GDP, data = HIC[-1,], type = "LSMLE")
summary(fit_LSMLEwo1)

# Normal probability plot with simulated envelope
 plotenvelope(fit_LSMLE)

</code></pre>

<hr>
<h2 id='robustbetareg.control'>Auxiliary for Controlling robustbetareg Fitting</h2><span id='topic+robustbetareg.control'></span>

<h3>Description</h3>

<p>Several parameters that control fitting of robust beta regression models using
<code><a href="#topic+robustbetareg">robustbetareg.</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robustbetareg.control(
  start = NULL,
  alpha.optimal = TRUE,
  tolerance = 0.001,
  maxit = 5000,
  L = 0.02,
  M = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robustbetareg.control_+3A_start">start</code></td>
<td>
<p>an optional vector with starting values for the parameter estimates.</p>
</td></tr>
<tr><td><code id="robustbetareg.control_+3A_alpha.optimal">alpha.optimal</code></td>
<td>
<p>a logical value. If <code>TRUE</code> the tuning constant will
be select via the data-driven algorithm.</p>
</td></tr>
<tr><td><code id="robustbetareg.control_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric tolerance for convergence.</p>
</td></tr>
<tr><td><code id="robustbetareg.control_+3A_maxit">maxit</code></td>
<td>
<p>argument passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="robustbetareg.control_+3A_l">L</code></td>
<td>
<p>numeric specifying the threshold for the data-driven algorithm.
Default is <code>L = 0.02</code>.</p>
</td></tr>
<tr><td><code id="robustbetareg.control_+3A_m">M</code></td>
<td>
<p>integer specifying the number of grid spacing for the data-driven
algorithm. Default is <code>M = 3</code>.</p>
</td></tr>
<tr><td><code id="robustbetareg.control_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>robustbetareg.control</code> controls the fitting process of
the robust estimation in beta regression via the LMDPDE, LSMLE, MDPDE, and
SMLE. The arguments <code>L</code> and <code>M</code> are passed to the data-driven
algorithm for selecting the optimum alpha value; details can be found in
Ribeiro and Ferrari (2022). Starting values for the parameters associated
to the mean and precision submodels may be supplied via <code>start</code>. <br />
We do not recommend changing the arguments passed to the data-driven algorithm.
</p>


<h3>Value</h3>

<p>A list with components named as the arguments.
</p>


<h3>Author(s)</h3>

<p>Yuri S. Maluf (<a href="mailto:yurimaluf@gmail.com">yurimaluf@gmail.com</a>),
Francisco F. Queiroz (<a href="mailto:ffelipeq@outlook.com">ffelipeq@outlook.com</a>) and Silvia L. P. Ferrari.
</p>


<h3>References</h3>

<p>Maluf, Y.S., Ferrari, S.L.P., and Queiroz, F.F. (2022). Robust
beta regression through the logit transformation. <em>arXiv</em>:2209.11315.<br /> <br />
Ribeiro, K.A.T. and Ferrari, S.L.P.  (2022). Robust estimation in beta regression
via maximum Lq-likelihood. <em>Statistical Papers</em>. DOI: 10.1007/s00362-022-01320-0. <br /> <br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robustbetareg">robustbetareg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("Firm")

# Using a robust start value for the parameters associated with the
# mean submodel
# using the robustbase package
# robust regression to obtain a starting value for beta
fit_lm_Rob &lt;- robustbase::lmrob(FIRMCOST ~ SIZELOG + INDCOST,
                                data = Firm)
initials_beta_rob &lt;-  as.numeric(coef(fit_lm_Rob))
etarob &lt;- model.matrix(fit_lm_Rob)%*%initials_beta_rob
muhat_Rob &lt;- set.link(link.mu = "logit",
                      link.phi = "log")$linkfun.mu$inv.link(etarob)
T_1_Rob &lt;- 1/set.link(link.mu = "logit",
                      link.phi = "log")$linkfun.mu$d.linkfun(muhat_Rob)
#estimate of variance of y based on robustbase package
sigma2hat_Rob &lt;- ((fit_lm_Rob$scale^2)*(T_1_Rob^2))
#phi estimate from robust method
phihat_Rob &lt;- mean((muhat_Rob*(1-muhat_Rob))/sigma2hat_Rob)
gama1hat_rob &lt;- log(phihat_Rob)
#gamma estimates from robustbase package
initials_gama_rob &lt;-  as.numeric(gama1hat_rob)
#robust starting values for beta and gamma
thetaStart &lt;- c(initials_beta_rob, initials_gama_rob)

fit_LSMLE &lt;- robustbetareg(FIRMCOST ~ SIZELOG + INDCOST,
                           data = Firm,
                           type = "LSMLE", link.phi = "log",
                           control = robustbetareg.control(start = thetaStart))

</code></pre>

<hr>
<h2 id='set.link'>Link functions for robust beta regression</h2><span id='topic+set.link'></span>

<h3>Description</h3>

<p>This function provides several link functions for robust beta regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.link(link.mu = "logit", link.phi = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.link_+3A_link.mu">link.mu</code></td>
<td>
<p>character specifying the mean link function. Currently, the functions
&quot;<code>logit</code>&quot;, &quot;<code>probit</code>&quot;, &quot;<code>cauchit</code>&quot;, &quot;<code>cloglog</code>&quot;,
and &quot;<code>loglog</code>&quot; are supported. Default is &quot;<code>logit</code>&quot;.</p>
</td></tr>
<tr><td><code id="set.link_+3A_link.phi">link.phi</code></td>
<td>
<p>character specifying the precision link function. Currently,
the functions &quot;<code>log</code>&quot;, &quot;<code>identity</code>&quot;, and &quot;<code>sqrt</code>&quot; are supported.
Default is &quot;<code>log</code>&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>set.link</code> provides the link function, inverse link function, first and
second derivatives for both mean and precision submodels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
links = set.link(link.mu = "cauchit", link.phi = "sqrt")
attributes(links)

</code></pre>

<hr>
<h2 id='waldtypetest'>Robust Wald-type Tests</h2><span id='topic+waldtypetest'></span>

<h3>Description</h3>

<p><code>waldtypetest</code> provides Wald-type tests for both simple and composite
hypotheses for beta regression based on the robust estimators
(LSMLE, LMDPDE, SMLE, and MDPDE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waldtypetest(object, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waldtypetest_+3A_object">object</code></td>
<td>
<p>fitted model object of class <code>robustbetareg</code> (see <code><a href="#topic+robustbetareg">robustbetareg</a></code>).</p>
</td></tr>
<tr><td><code id="waldtypetest_+3A_fun">FUN</code></td>
<td>
<p>function representing the null hypothesis to be tested.</p>
</td></tr>
<tr><td><code id="waldtypetest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the <code>FUN</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides a robust Wald-type test for a general hypothesis
<code class="reqn">m(\theta) = \eta_0</code>, for a fixed <code class="reqn">\eta_0 \in R^d</code>, against
a two sided alternative; see Maluf et al. (2022) for details.
The argument <code>FUN</code> specifies the function <code class="reqn">m(\theta) - \eta_0</code>,
which defines the null hypothesis. For instance, consider a model with
<code class="reqn">\theta = (\beta_1, \beta_2, \beta_3, \gamma_1)^\top</code> and let the
null hypothesis be <code class="reqn">\beta_2 + \beta_3 = 4</code>. The <code>FUN</code> argument can be
<code>FUN = function(theta) {theta[2] + theta[3] - 4}</code>. It is also possible to
define the function as <code>FUN = function(theta, B) {theta[2] + theta[3] - B}</code>,
and pass the <code>B</code> argument through the <code>waldtypetest</code> function.
If no function is specified, that is, <code>FUN=NULL</code>, the <code>waldtypetest</code>
returns a test in which the null hypothesis is that all the coefficients are
zero.
</p>


<h3>Value</h3>

<p><code>waldtypetest</code> returns an output for the Wald-type test containing
the value of the test statistic, degrees-of-freedom and p-value.
</p>


<h3>Author(s)</h3>

<p>Yuri S. Maluf (<a href="mailto:yurimaluf@gmail.com">yurimaluf@gmail.com</a>),
Francisco F. Queiroz (<a href="mailto:ffelipeq@outlook.com">ffelipeq@outlook.com</a>) and Silvia L. P. Ferrari.
</p>


<h3>References</h3>

<p>Maluf, Y. S., Ferrari, S. L. P., and Queiroz, F. F. (2022). Robust
beta regression through the logit transformation. <em>arXiv</em>:2209.11315.<br /> <br />
Basu, A., Ghosh, A., Martin, N., and Pardo, L. (2018). Robust Wald-type
tests for  non-homogeneous observations based on the minimum density
power divergence estimator. <em>Metrika</em>, 81:493–522. <br /> <br />
Ribeiro, K. A. T. and Ferrari, S. L. P. (2022). Robust estimation in beta
regression via maximum Lq-likelihood. <em>Statistical Papers</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+robustbetareg">robustbetareg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generating a dataset
set.seed(2022)
n &lt;- 40
beta.coef &lt;- c(-1, -2)
gamma.coef &lt;- c(5)
X &lt;- cbind(rep(1, n), x &lt;- runif(n))
mu &lt;- exp(X%*%beta.coef)/(1 + exp(X%*%beta.coef))
phi &lt;- exp(gamma.coef) #Inverse Log Link Function
y &lt;- rbeta(n, mu*phi, (1 - mu)*phi)
y[26] &lt;- rbeta(1, ((1 + mu[26])/2)*phi, (1 - ((1 + mu[26])/2))*phi)
SimData &lt;- as.data.frame(cbind(y, x))
colnames(SimData) &lt;- c("y", "x")

# Fitting the MLE and the LSMLE
fit.mle &lt;- robustbetareg(y ~ x | 1, data = SimData, alpha = 0)
fit.lsmle &lt;- robustbetareg(y ~ x | 1, data = SimData)

# Hypothesis to be tested: (beta_1, beta_2) = c(-1, -2) against a two
# sided alternative
h0 &lt;- function(theta){theta[1:2] - c(-1, -2)}
waldtypetest(fit.mle, h0)
waldtypetest(fit.lsmle, h0)
# Alternative way:
h0 &lt;- function(theta, B){theta[1:2] - B}
waldtypetest(fit.mle, h0, B = c(-1, -2))
waldtypetest(fit.lsmle, h0, B = c(-1, -2))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
