<!DOCTYPE html><html><head><title>Help for package quadrupen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quadrupen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#quadrupen-package'><p>Sparsity by Worst-Case Quadratic Penalties</p></a></li>
<li><a href='#bounded.reg'><p>Fit a linear model with infinity-norm plus ridge-like regularization</p></a></li>
<li><a href='#crossval'><p>Cross-validation function for quadrupen fitting methods.</p></a></li>
<li><a href='#cvpen-class'><p>Class &quot;cvpen&quot;</p></a></li>
<li><a href='#elastic.net'><p>Fit a linear model with elastic-net regularization</p></a></li>
<li><a href='#plot,cvpen-method'><p>Plot method for cross validated error of a <code>quadrupen</code> model</p></a></li>
<li><a href='#plot,quadrupen-method'><p>Plot method for a quadrupen object</p></a></li>
<li><a href='#plot,stability.path-method'><p>Plot method for <code>stability.path</code>.</p></a></li>
<li><a href='#quadrupen-class'><p>Class &quot;quadrupen&quot;</p></a></li>
<li><a href='#stability'><p>Stability selection for a quadrupen fit.</p></a></li>
<li><a href='#stability.path-class'><p>Class &quot;stability.path&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparsity by Worst-Case Quadratic Penalties</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits classical sparse regression models with
    efficient active set algorithms by solving quadratic problems as described by 
    Grandvalet, Chiquet and Ambroise (2017) &lt;<a href="https://doi.org/10.48550/arXiv.1210.2077">doi:10.48550/arXiv.1210.2077</a>&gt;. Also provides a few 
    methods for model selection purpose (cross-validation, stability selection).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp, ggplot2, Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>reshape2, methods, scales, grid, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, spelling, lars, elasticnet, glmnet</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julien Chiquet &lt;julien.chiquet@inrae.fr&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jchiquet/quadrupenCRAN">https://github.com/jchiquet/quadrupenCRAN</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jchiquet/quadrupenCRAN/issues">https://github.com/jchiquet/quadrupenCRAN/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-18 09:32:19 UTC; jchiquet</td>
</tr>
<tr>
<td>Author:</td>
<td>Julien Chiquet <a href="https://orcid.org/0000-0002-3629-3429"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='quadrupen-package'>Sparsity by Worst-Case Quadratic Penalties</h2><span id='topic+quadrupen-package'></span><span id='topic+quadrupen'></span>

<h3>Description</h3>

<p>This package is designed to fit accurately several popular
penalized linear regression models using the algorithm proposed in
Grandvalet, Chiquet and Ambroise (submitted) by solving quadratic
problems with increasing size.
</p>


<h3>Features</h3>

<p>At the moment, two <code>R</code> fitting functions are available:
</p>

<ol>
<li><p> the <code><a href="#topic+elastic.net">elastic.net</a></code> function, which solves a family of
linear regression problems penalized by a mixture of
<code class="reqn">\ell_1</code> and <code class="reqn">\ell_2</code> norms. It notably includes
the LASSO (Tibshirani, 1996), the adaptive-LASSO (Zou, 2006), the
Elastic-net (Zou and Hastie, 2006) or the Structured Elastic-net
(Slawski et al., 2010). See examples as well as the available
<code>demo(quad_enet)</code>.
</p>
</li>
<li><p> the <code><a href="#topic+bounded.reg">bounded.reg</a></code> function, which fits a linear model
penalized by a mixture of <code class="reqn">\ell_\infty</code> and
<code class="reqn">\ell_2</code> norms. It owns the same versatility as the
<code>elastic.net</code> function regarding the <code class="reqn">\ell_2</code> norm,
yet the <code class="reqn">\ell_1</code>-norm is replaced by the infinity
norm. Check <code>demo(quad_breg)</code> and examples.</p>
</li></ol>

<p>The problem commonly solved for these two functions writes



&beta;<sup>hat</sup><sub>&lambda;<sub>1</sub>,&lambda;<sub>2</sub></sub> = argmin<sub>&beta;</sub> 1/2 RSS(&beta;) + &lambda;<sub>1</sub> &#124; D &beta; &#124;<sub>q</sub> + &lambda;/2 <sub>2</sub>&beta;<sup>T</sup> S &beta;, 

 where
<code class="reqn">q=1</code> for <code>elastic.net</code> and
<code class="reqn">q=\infty</code> for <code>bounded.reg</code>.  The diagonal
matrix <code class="reqn">D</code> allows different weights for the first part of
the penalty. The structuring matrix <code class="reqn">S</code> can be used to
introduce some prior information regarding the predictors. It is
provided via a positive semidefinite matrix.
</p>
<p>The S4 objects produced by the fitting procedures own the
classical methods for linear model in <code>R</code>, as well as methods
for plotting, (double) cross-validation and for the stability
selection procedure of Meinshausen and Buhlmann (2010).
</p>
<p>All the examples of this documentation have been included to the
package source, in the 'examples' directory. Some (too few!)
routine testing scripts using the <span class="pkg">testhat</span> package are also
present in the 'tests' directory, where we check basic
functionalities of the code, especially the reproducibility of the
Lasso/Elastic-net solution path with the <span class="pkg">lars</span>,
<span class="pkg">elasticnet</span> and <span class="pkg">glmnet</span> packages.  We also check the
handling of runtime errors or unstabilities.
</p>


<h3>Algorithm</h3>

<p>The general strategy of the algorithm relies on maintaining an
active set of variables, starting from a vector of zeros. The
underlying optimization problem is solved only on the activated
variables, thus handling with small smooth problems with
increasing size. Hence, by considering a decreasing grid of values
for the penalty <code class="reqn">\lambda_1</code> and fixing
<code class="reqn">\lambda_2</code>, we may explore the whole path of
solutions at a reasonable numerical cost, providing that
<code class="reqn">\lambda_1</code> does not end up too small.
</p>
<p>For the <code class="reqn">\ell_1</code>-based methods (available in the
<code>elastic.net</code> function), the size of the underlying problems
solved is related to the number of nonzero coefficients in the
vector of parameters. With the <code class="reqn">\ell_\infty</code>-norm,
(available in the <code>boundary.reg</code> function), we do not produce
sparse estimator. Nevertheless, the size of the systems solved
along the path deals with the number of unbounded variables for
the current penalty level, which is quite smaller than the number
of predictors for a reasonable <code class="reqn">\lambda_1</code>. The same
kind of proposal was made in Zhao, Rocha and Yu (2009).
</p>
<p>Underlying optimization is performed by direct resolution of
quadratic sub problems, which is the main purpose of this
package. This strategy is thoroughly exposed in Grandvalet,
Chiquet and Ambroise (submitted). Still, we also implemented the
popular and versatile proximal (FISTA) approaches for routine
checks and numerical comparisons. A coordinate descent approach is
also included, yet only for the <code>elastic.net</code> fitting
procedure.
</p>
<p>The default setting uses the quadratic approach that gives its
name to the package. It has been optimized to be the method of
choice for small and medium scale problems, and produce very
accurate solutions. However, the first order methods (coordinate
descent and FISTA) can be interesting in situations where the
problem is close to singular, in which case the Cholesky
decomposition used in the quadratic solver can be computationally
unstable. Though it is extremely unlikely for
<code><a href="#topic+elastic.net">elastic.net</a></code> &ndash; and if so, we encourage the user to
send us back any report of such an event &ndash;, this happens at times
with <code><a href="#topic+bounded.reg">bounded.reg</a></code>. Regarding this issue, we let the
possibility for the user to run the optimization of the
<code><a href="#topic+bounded.reg">bounded.reg</a></code> criterion in a (hopefully) 'bulletproof'
mode: using mainly the fast and accurate quadratic approach, it
switches to the slower but more robust proximal resolution when
unstability is detected.
</p>


<h3>Technical remarks</h3>

<p>Most of the numerical work is done in C++, relying on the
<span class="pkg">RcppArmadillo</span> package. We also provide a (double)
cross-validation procedure and functions for stability selection,
both using the multi-core capability of the computer, through the
<span class="pkg">parallel</span> package. This feature is not available for Windows
user, though. Finally, note that the plot methods enjoy some
(still very few) of the capabilities of the <span class="pkg">ggplot2</span> package.
</p>
<p>We hope to enrich <span class="pkg">quadrupen</span> with other popular fitting
procedures and develop other statistical tools, particularly
towards bootstrapping and model selection purpose. Sparse matrix
encoding is partially supported at the moment, and will hopefully
be thoroughly available in the future, thanks to upcoming updates
of the great <span class="pkg">RcppArmadillo</span> package.
</p>


<h3>Author(s)</h3>

<p>Julien Chiquet <a href="mailto:julien.chiquet@inrae.fr">julien.chiquet@inrae.fr</a>
</p>


<h3>References</h3>

<p>Yves Grandvalet, Julien Chiquet and Christophe Ambroise,
<a href="https://arxiv.org/abs/1210.2077">Sparsity by Worst-case Quadratic
Penalties</a>, arXiv preprint, 2012.
</p>

<ul>
<li><p> Nicolas Meinshausen and Peter Buhlmann. Stability Selection,
JRSS(B), 2010.
</p>
</li>
<li><p>  Martin Slawski, Wolfgang zu Castell, and Gerhard
Tutz. Feature selection guided by structural information, AOAS,
2010.
</p>
</li>
<li><p> Peng Zhao, Guillerme Rocha and Bin Yu. The composite
absolute penalties family for grouped and hierarchical variable
selection, The Annals of Statistics, 2009.
</p>
</li>
<li><p>  Hui Zou. The Adaptive Lasso and Its Oracle Properties,
JASA, 2006.
</p>
</li>
<li><p> Hui Zou and Trevor Hastie. Regularization and variable
selection via the elastic net, JRSS(B), 2006.
</p>
</li>
<li><p>  Robert Tibshirani. Regression Shrinkage and Selection
via the Lasso, JRSS(B), 1996.
</p>
</li></ul>


<hr>
<h2 id='bounded.reg'>Fit a linear model with infinity-norm plus ridge-like regularization</h2><span id='topic+bounded.reg'></span>

<h3>Description</h3>

<p>Adjust a linear model penalized by a mixture of a (possibly
weighted) <code class="reqn">\ell_\infty</code>-norm (bounding the
magnitude of the parameters) and a (possibly structured)
<code class="reqn">\ell_2</code>-norm (ridge-like). The solution path is computed
at a grid of values for the infinity-penalty, fixing the amount of
<code class="reqn">\ell_2</code> regularization. See details for the criterion
optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounded.reg(
  x,
  y,
  lambda1 = NULL,
  lambda2 = 0.01,
  penscale = rep(1, p),
  struct = NULL,
  intercept = TRUE,
  normalize = TRUE,
  naive = FALSE,
  nlambda1 = ifelse(is.null(lambda1), 100, length(lambda1)),
  min.ratio = ifelse(n &lt;= p, 0.01, 0.001),
  max.feat = ifelse(lambda2 &lt; 0.01, min(n, p), min(4 * n, p)),
  control = list(),
  checkargs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounded.reg_+3A_x">x</code></td>
<td>
<p>matrix of features, possibly sparsely encoded
(experimental). Do NOT include intercept. When normalized os
<code>TRUE</code>, coefficients will then be rescaled to the original
scale.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_y">y</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_lambda1">lambda1</code></td>
<td>
<p>sequence of decreasing <code class="reqn">\ell_\infty</code>
penalty levels. If <code>NULL</code> (the default), a vector is
generated with <code>nlambda1</code> entries, starting from a guessed
level <code>lambda1.max</code> where only the intercept is included,
then shrunken to <code>min.ratio*lambda1.max</code>.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_lambda2">lambda2</code></td>
<td>
<p>real scalar; tunes the <code class="reqn">\ell_2</code>-penalty in
the bounded regression. Default is 0.01. Set to 0 to regularize
only by the infinity norm (be careful regarding numerical
stability in that case, particularly in the high dimensional
setting).</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_penscale">penscale</code></td>
<td>
<p>vector with real positive values that weight the
infinity norm of each feature. Default set all weights to 1. See
details below.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_struct">struct</code></td>
<td>
<p>matrix structuring the coefficients.  Must be at
least positive semidefinite (this is checked internally if the
<code>checkarg</code> argument is <code>TRUE</code>). The
default uses the identity matrix. See details below.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_intercept">intercept</code></td>
<td>
<p>logical; indicates if an intercept should be
included in the model. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_normalize">normalize</code></td>
<td>
<p>logical; indicates if variables should be
normalized to have unit L2 norm before fitting.  Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_naive">naive</code></td>
<td>
<p>logical; Compute either 'naive' of 'classic' bounded
regression: mimicking the Elastic-net, the vector of parameters is
rescaled by a coefficient <code>(1+lambda2)</code> when <code>naive</code>
equals <code>FALSE</code>.  No rescaling otherwise. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_nlambda1">nlambda1</code></td>
<td>
<p>integer that indicates the number of values to put
in the <code>lambda1</code> vector.  Ignored if <code>lambda1</code> is
provided.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_min.ratio">min.ratio</code></td>
<td>
<p>minimal value of infinity-part of the penalty
that will be tried, as a fraction of the maximal <code>lambda1</code>
value. A too small value might lead to unstability at the end of
the solution path corresponding to small <code>lambda1</code>.  The
default value tries to avoid this, adapting to the
'<code class="reqn">n&lt;p</code>' context. Ignored if <code>lambda1</code> is provided.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_max.feat">max.feat</code></td>
<td>
<p>integer; limits the number of features ever to
enter the model: in our implementation of the bounded regression,
it corresponds to the variables which have left the boundary along
the path.  The algorithm stops if this number is exceeded and
<code>lambda1</code> is cut at the corresponding level. Default is
<code>min(nrow(x),ncol(x))</code> for small <code>lambda2</code> (&lt;0.01) and
<code>min(4*nrow(x),ncol(x))</code> otherwise. Use with care, as it
considerably changes the computation time.</p>
</td></tr>
<tr><td><code id="bounded.reg_+3A_control">control</code></td>
<td>
<p>list of argument controlling low level options of
the algorithm &ndash;use with care and at your own risk&ndash; :
</p>

<dl>
<dt><code>verbose</code>: </dt><dd><p>integer; activate verbose mode &ndash;this one
is not too much risky!&ndash; set to <code>0</code> for no output; <code>1</code>
for warnings only, and <code>2</code> for tracing the whole
progression. Default is <code>1</code>. Automatically set to <code>0</code>
when the method is embedded within cross-validation or stability
selection.</p>
</dd>
<dt><code>timer</code>: </dt><dd><p>logical; use to record the timing of the
algorithm. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>max.iter</code>: </dt><dd><p>the maximal number of iteration used to
solve the problem for a given value of <code>lambda1</code>. Default is
500.</p>
</dd>
<dt><code>method</code>: </dt><dd><p>a string for the underlying solver
used. Either <code>"quadra"</code> or <code>"fista"</code> are available for
bounded regression. Default is <code>"quadra"</code>.</p>
</dd>
<dt><code>threshold</code>: </dt><dd><p>a threshold for convergence. The
algorithm stops when the optimality conditions are fulfill up to
this threshold. Default is <code>1e-7</code> for <code>"quadra"</code> and
<code>1e-2</code> for <code>"fista"</code>.</p>
</dd>
<dt><code>bulletproof</code>: </dt><dd><p>logical; indicates if the bulletproof
mode should be used while running the <code>"quadra"</code>
method. Default is <code>TRUE</code>. See details below.</p>
</dd></dl>
</td></tr>
<tr><td><code id="bounded.reg_+3A_checkargs">checkargs</code></td>
<td>
<p>logical; should arguments be checked to
(hopefully) avoid internal crashes? Default is
<code>TRUE</code>. Automatically set to <code>FALSE</code> when calls are made
from cross-validation or stability selection procedures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimized criterion is   


&beta;<sup>hat</sup><sub>&lambda;<sub>1</sub>,&lambda;<sub>2</sub></sub> = argmin<sub>&beta;</sub> 1/2 RSS(&beta;) + &lambda;<sub>1</sub> &#124; D &beta; &#124;<sub>&infin;</sub> + &lambda;/2 <sub>2</sub> &beta;<sup>T</sup> S &beta;,

 where
<code class="reqn">D</code> is a diagonal matrix, whose diagonal terms are provided
as a vector by the <code>penscale</code> argument. The <code class="reqn">\ell_2</code>
structuring matrix <code class="reqn">S</code> is provided via the <code>struct</code>
argument, a positive semidefinite matrix (possibly of class
<code>Matrix</code>).
Note that the quadratic algorithm for the bounded regression may
become unstable along the path because of singularity of the
underlying problem, e.g. when there are too much correlation or
when the size of the problem is close to or smaller than the
sample size. In such cases, it might be a good idea to switch to
the proximal solver, slower yet more robust. This is the strategy
adopted by the <code>'bulletproof'</code> mode, that will send a warning
while switching the method to <code>'fista'</code> and keep on
optimizing on the remainder of the path. When <code>bulletproof</code>
is set to <code>FALSE</code>, the algorithm stops at an early stage of
the path of solutions. Hence, users should be careful when
manipulating the resulting <code>'quadrupen'</code> object, as it will
not have the size expected regarding the dimension of the
<code>lambda1</code> argument.
</p>
<p>Singularity of the system can also be avoided with a larger
<code class="reqn">\ell_2</code>-regularization, via <code>lambda2</code>, or a
&quot;not-too-small&quot; <code class="reqn">\ell_\infty</code> regularization, via
a larger <code>'min.ratio'</code> argument.
</p>


<h3>Value</h3>

<p>an object with class <code>quadrupen</code>, see the
documentation page <code><a href="#topic+quadrupen-class">quadrupen</a></code> for details.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+quadrupen-class">quadrupen</a></code>,
<code><a href="#topic+plot+2Cquadrupen-method">plot,quadrupen-method</a></code> and <code><a href="#topic+crossval">crossval</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta &lt;- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor &lt;- 0.75
Soo &lt;- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  &lt;- matrix(cor,10,10) ## bloc correlation between active variables
Sigma &lt;- bdiag(Soo,Sww,Soo,Sww,Soo)
diag(Sigma) &lt;- 1
n &lt;- 50
x &lt;- as.matrix(matrix(rnorm(95*n),n,95) %*% chol(Sigma))
y &lt;- 10 + x %*% beta + rnorm(n,0,10)

## Infinity norm without/with an additional l2 regularization term
## and with structuring prior
labels &lt;- rep("irrelevant", length(beta))
labels[beta != 0] &lt;- "relevant"
plot(bounded.reg(x,y,lambda2=0) , label=labels) ## a mess
plot(bounded.reg(x,y,lambda2=10), label=labels) ## good guys are at the boundaries

</code></pre>

<hr>
<h2 id='crossval'>Cross-validation function for quadrupen fitting methods.</h2><span id='topic+crossval'></span>

<h3>Description</h3>

<p>Function that computes K-fold (double) cross-validated error of a
<code>quadrupen</code> fit. If no <code>lambda2</code> is provided, simple
cross validation on the <code>lambda1</code> parameter is performed. If
a vector <code>lambda2</code> is passed as an argument, double
cross-validation is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossval(
  x,
  y,
  penalty = c("elastic.net", "bounded.reg"),
  K = 10,
  folds = split(sample(1:nrow(x)), rep(1:K, length = nrow(x))),
  lambda2 = 0.01,
  verbose = TRUE,
  mc.cores = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossval_+3A_x">x</code></td>
<td>
<p>matrix of features, possibly sparsely encoded
(experimental). Do NOT include intercept.</p>
</td></tr>
<tr><td><code id="crossval_+3A_y">y</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="crossval_+3A_penalty">penalty</code></td>
<td>
<p>a string for the fitting procedure used for
cross-validation. Either <code>"elastic.net"</code> or
<code>"bounded.reg"</code>, at the moment. Default is <code>elastic.net</code>.</p>
</td></tr>
<tr><td><code id="crossval_+3A_k">K</code></td>
<td>
<p>integer indicating the number of folds. Default is 10.</p>
</td></tr>
<tr><td><code id="crossval_+3A_folds">folds</code></td>
<td>
<p>list of <code>K</code> vectors that describes the folds to
use for the cross-validation. By default, the folds are randomly
sampled with the specified K. The same folds are used for each
values of <code>lambda2</code>.</p>
</td></tr>
<tr><td><code id="crossval_+3A_lambda2">lambda2</code></td>
<td>
<p>tunes the <code class="reqn">\ell_2</code>-penalty (ridge-like) of
the fit. If none is provided, the default scalar value of the
corresponding fitting method is used and a simple CV is
performed. If a vector of values is given, double cross-validation
is performed (both on <code>lambda1</code> and <code>lambda2</code>, using the
same folds for each <code>lambda2</code>).</p>
</td></tr>
<tr><td><code id="crossval_+3A_verbose">verbose</code></td>
<td>
<p>logical; indicates if the progression (the current
lambda2) should be displayed. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="crossval_+3A_mc.cores">mc.cores</code></td>
<td>
<p>the number of cores to use. The default uses 2 cores.</p>
</td></tr>
<tr><td><code id="crossval_+3A_...">...</code></td>
<td>
<p>additional parameters to overwrite the defaults of the
fitting procedure identified by the <code>'penalty'</code> argument. See
the corresponding documentation (<code><a href="#topic+elastic.net">elastic.net</a></code> or
<code><a href="#topic+bounded.reg">bounded.reg</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;cvpen&quot; for which a <code>plot</code> method
is available.
</p>


<h3>Note</h3>

<p>If the user runs the fitting method with option
<code>'bulletproof'</code> set to <code>FALSE</code>, the algorithm may stop
at an early stage of the path. Early stops are handled internally,
in order to provide results on the same grid of penalty tuned by
<code class="reqn">\lambda_1</code>.  This is done by means of <code>NA</code>
values, so as mean and standard error are consistently
evaluated. If, while cross-validating, the procedure experiences
too many early stoppings, a warning is sent to the user, in which
case you should reconsider the grid of <code>lambda1</code> used for the
cross-validation.  If <code>bulletproof</code> is <code>TRUE</code> (the
default), there is nothing to worry about, except a possible slow
down when any switching to the proximal algorithm is required.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadrupen-class">quadrupen</a></code>, <code><a href="#topic+plot+2Ccvpen-method">plot,cvpen-method</a></code>
and <code><a href="#topic+cvpen-class">cvpen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta &lt;- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor  &lt;- 0.75
Soo  &lt;- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variable
Sww  &lt;- matrix(cor,10,10) ## bloc correlation between active variables
Sigma &lt;- bdiag(Soo,Sww,Soo,Sww,Soo) + 0.1
diag(Sigma) &lt;- 1
n &lt;- 100
x &lt;- as.matrix(matrix(rnorm(95*n),n,95) %*% chol(Sigma))
y &lt;- 10 + x %*% beta + rnorm(n,0,10)

## Use fewer lambda1 values by overwritting the default parameters
## and cross-validate over the sequences lambda1 and lambda2

cv.double &lt;- crossval(x,y, lambda2=10^seq(2,-2,len=50), nlambda1=50)

## Rerun simple cross-validation with the appropriate lambda2
cv.10K &lt;- crossval(x,y, lambda2=0.2)
## Try leave one out also
cv.loo &lt;- crossval(x,y, K=n, lambda2=0.2)


plot(cv.double)

plot(cv.10K)
plot(cv.loo)

## Performance for selection purpose
beta.min.10K &lt;- slot(cv.10K, "beta.min")
beta.min.loo &lt;- slot(cv.loo, "beta.min")

cat("\nFalse positives with the minimal 10-CV choice: ", sum(sign(beta) != sign(beta.min.10K)))
cat("\nFalse positives with the minimal LOO-CV choice: ", sum(sign(beta) != sign(beta.min.loo)))

</code></pre>

<hr>
<h2 id='cvpen-class'>Class &quot;cvpen&quot;</h2><span id='topic+cvpen-class'></span>

<h3>Description</h3>

<p>Class of object returned by a cross-validation performed through
the <code>crossval</code> method.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lambda1</code>:</dt><dd><p>vector of <code class="reqn">\lambda_1</code>
(<code class="reqn">\ell_1</code> or <code class="reqn">\ell_\infty</code> penalty levels)
for which each cross-validation has been performed.</p>
</dd>
<dt><code>lambda2</code>:</dt><dd><p>vector (or scalar) of <code class="reqn">\ell_2</code>-penalty levels for
which each cross-validation has been performed.</p>
</dd>
<dt><code>lambda1.min</code>:</dt><dd><p>level of <code class="reqn">\lambda_1</code> that minimizes the
error estimated by cross-validation.</p>
</dd>
<dt><code>lambda1.1se</code>:</dt><dd><p>largest level of <code class="reqn">\lambda_1</code> such as
the cross-validated error is within 1 standard error of the
minimum.</p>
</dd>
<dt><code>lambda2.min</code>:</dt><dd><p>level of <code class="reqn">\lambda_2</code> that minimizes the
error estimated by cross-validation.</p>
</dd>
<dt><code>cv.error</code>:</dt><dd><p>a data frame containing the mean
cross-validated error and its associated standard error for each
values of <code>lambda1</code> and <code>lambda2</code>.</p>
</dd>
<dt><code>folds</code>:</dt><dd><p>list of <code>K</code> vectors indicating the folds
used for cross-validation.</p>
</dd>
<dt><code>beta.min</code>:</dt><dd><p>the vector of parameters obtained by
fitting the problem on the full data set <code>x</code> and <code>y</code> with
<code>lambda1.min</code> and  <code>lambda2.min</code> penalties.</p>
</dd>
<dt><code>beta.1se</code>:</dt><dd><p>the vector of parameters obtained by
fitting the problem on the full data set <code>x</code> and <code>y</code> with
<code>lambda1.1se</code> and <code>lambda2.min</code> penalties.
</p>
</dd>
</dl>

<p>The specific <code><a href="#topic+plot+2Ccvpen-method">plot,cvpen-method</a></code> method is documented.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+plot+2Ccvpen-method">plot,cvpen-method</a></code> and
<code><a href="#topic+crossval">crossval</a></code>.
</p>

<hr>
<h2 id='elastic.net'>Fit a linear model with elastic-net regularization</h2><span id='topic+elastic.net'></span>

<h3>Description</h3>

<p>Adjust a linear model with elastic-net regularization, mixing a
(possibly weighted) <code class="reqn">\ell_1</code>-norm (LASSO) and a
(possibly structured) <code class="reqn">\ell_2</code>-norm (ridge-like). The
solution path is computed at a grid of values for the
<code class="reqn">\ell_1</code>-penalty, fixing the amount of <code class="reqn">\ell_2</code>
regularization. See details for the criterion optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic.net(
  x,
  y,
  lambda1 = NULL,
  lambda2 = 0.01,
  penscale = rep(1, p),
  struct = NULL,
  intercept = TRUE,
  normalize = TRUE,
  naive = FALSE,
  nlambda1 = ifelse(is.null(lambda1), 100, length(lambda1)),
  min.ratio = ifelse(n &lt;= p, 0.01, 1e-04),
  max.feat = ifelse(lambda2 &lt; 0.01, min(n, p), min(4 * n, p)),
  beta0 = NULL,
  control = list(),
  checkargs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic.net_+3A_x">x</code></td>
<td>
<p>matrix of features, possibly sparsely encoded
(experimental). Do NOT include intercept. When normalized os
<code>TRUE</code>, coefficients will then be rescaled to the original
scale.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_y">y</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_lambda1">lambda1</code></td>
<td>
<p>sequence of decreasing <code class="reqn">\ell_1</code>-penalty
levels. If <code>NULL</code> (the default), a vector is generated with
<code>nlambda1</code> entries, starting from a guessed level
<code>lambda1.max</code> where only the intercept is included, then
shrunken to <code>min.ratio*lambda1.max</code>.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_lambda2">lambda2</code></td>
<td>
<p>real scalar; tunes the <code class="reqn">\ell_2</code> penalty in
the Elastic-net. Default is 0.01. Set to 0 to recover the Lasso.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_penscale">penscale</code></td>
<td>
<p>vector with real positive values that weight the
<code class="reqn">\ell_1</code>-penalty of each feature. Default set all weights
to 1.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_struct">struct</code></td>
<td>
<p>matrix structuring the coefficients (preferably
sparse). Must be at least positive semidefinite (this is checked
internally if the <code>checkarg</code> argument is <code>TRUE</code>). The
default uses the identity matrix. See details below.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_intercept">intercept</code></td>
<td>
<p>logical; indicates if an intercept should be
included in the model. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_normalize">normalize</code></td>
<td>
<p>logical; indicates if variables should be
normalized to have unit L2 norm before fitting.  Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_naive">naive</code></td>
<td>
<p>logical; Compute either 'naive' of classic
elastic-net as defined in Zou and Hastie (2006): the vector of
parameters is rescaled by a coefficient <code>(1+lambda2)</code> when
<code>naive</code> equals <code>FALSE</code>.  No rescaling otherwise.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_nlambda1">nlambda1</code></td>
<td>
<p>integer that indicates the number of values to put
in the <code>lambda1</code> vector.  Ignored if <code>lambda1</code> is
provided.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_min.ratio">min.ratio</code></td>
<td>
<p>minimal value of <code class="reqn">\ell_1</code>-part of the
penalty that will be tried, as a fraction of the maximal
<code>lambda1</code> value. A too small value might lead to unstability
at the end of the solution path corresponding to small
<code>lambda1</code> combined with <code class="reqn">\lambda_2=0</code>.  The
default value tries to avoid this, adapting to the
'<code class="reqn">n&lt;p</code>' context. Ignored if <code>lambda1</code> is provided.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_max.feat">max.feat</code></td>
<td>
<p>integer; limits the number of features ever to
enter the model; i.e., non-zero coefficients for the Elastic-net:
the algorithm stops if this number is exceeded and <code>lambda1</code>
is cut at the corresponding level. Default is
<code>min(nrow(x),ncol(x))</code> for small <code>lambda2</code> (&lt;0.01) and
<code>min(4*nrow(x),ncol(x))</code> otherwise. Use with care, as it
considerably changes the computation time.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_beta0">beta0</code></td>
<td>
<p>a starting point for the vector of parameter. When
<code>NULL</code> (the default), will be initialized at zero. May save
time in some situation.</p>
</td></tr>
<tr><td><code id="elastic.net_+3A_control">control</code></td>
<td>
<p>list of argument controlling low level options of
the algorithm &ndash;use with care and at your own risk&ndash; :
</p>

<dl>
<dt><code>verbose</code>: </dt><dd><p>integer; activate verbose mode &ndash;this one
is not too much risky!&ndash; set to <code>0</code> for no output; <code>1</code>
for warnings only, and <code>2</code> for tracing the whole
progression. Default is <code>1</code>. Automatically set to <code>0</code>
when the method is embedded within cross-validation or stability
selection.</p>
</dd>
<dt><code>timer</code>: </dt><dd><p>logical; use to record the timing of the
algorithm. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>max.iter</code>: </dt><dd><p>the maximal number of iteration used to
solve the problem for a given value of lambda1. Default is 500.</p>
</dd>
<dt><code>method</code>: </dt><dd><p>a string for the underlying solver
used. Either <code>"quadra"</code>, <code>"pathwise"</code> or
<code>"fista"</code>. Default is <code>"quadra"</code>.</p>
</dd>
<dt><code>threshold</code>: </dt><dd><p>a threshold for convergence. The
algorithm stops when the optimality conditions are fulfill up to
this threshold. Default is <code>1e-7</code> for <code>"quadra"</code> and
<code>1e-2</code> for the first order methods.</p>
</dd>
<dt><code>monitor</code>: </dt><dd><p>indicates if a monitoring of the
convergence should be recorded, by computing a lower bound between
the current solution and the optimum: when <code>'0'</code> (the
default), no monitoring is provided; when <code>'1'</code>, the bound
derived in Grandvalet et al. is computed; when <code>'&gt;1'</code>, the
Fenchel duality gap is computed along the algorithm.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="elastic.net_+3A_checkargs">checkargs</code></td>
<td>
<p>logical; should arguments be checked to
(hopefully) avoid internal crashes? Default is
<code>TRUE</code>. Automatically set to <code>FALSE</code> when calls are made
from cross-validation or stability selection procedures.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimized criterion is the following:  


&beta;<sup>hat</sup><sub>&lambda;<sub>1</sub>,&lambda;<sub>2</sub></sub> = argmin<sub>&beta;</sub> 1/2 RSS(&beta;) + &lambda;<sub>1</sub> &#124; D &beta; &#124;<sub>1</sub> + &lambda;/2 <sub>2</sub> &beta;<sup>T</sup> S &beta;,

 where
<code class="reqn">D</code> is a diagonal matrix, whose diagonal terms are provided
as a vector by the <code>penscale</code> argument. The <code class="reqn">\ell_2</code>
structuring matrix <code class="reqn">S</code> is provided via the <code>struct</code>
argument, a positive semidefinite matrix (possibly of class
<code>Matrix</code>).
</p>


<h3>Value</h3>

<p>an object with class <code>quadrupen</code>, see the
documentation page <code><a href="#topic+quadrupen-class">quadrupen</a></code> for details.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+quadrupen-class">quadrupen</a></code>,
<code><a href="#topic+plot+2Cquadrupen-method">plot,quadrupen-method</a></code> and <code><a href="#topic+crossval">crossval</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta &lt;- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor &lt;- 0.75
Soo &lt;- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  &lt;- matrix(cor,10,10) ## bloc correlation between active variables
Sigma &lt;- bdiag(Soo,Sww,Soo,Sww,Soo)
diag(Sigma) &lt;- 1
n &lt;- 50
x &lt;- as.matrix(matrix(rnorm(95*n),n,95) %*% chol(Sigma))
y &lt;- 10 + x %*% beta + rnorm(n,0,10)

labels &lt;- rep("irrelevant", length(beta))
labels[beta != 0] &lt;- "relevant"
## Comparing the solution path of the LASSO and the Elastic-net
plot(elastic.net(x,y,lambda2=0), label=labels) ## a mess
plot(elastic.net(x,y,lambda2=10), label=labels) ## a lot better

</code></pre>

<hr>
<h2 id='plot+2Ccvpen-method'>Plot method for cross validated error of a <code>quadrupen</code> model</h2><span id='topic+plot+2Ccvpen-method'></span><span id='topic+plot.cvpen'></span>

<h3>Description</h3>

<p>Produce a plot of the cross validated error of a <code>quadrupen</code>
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>\S4method{plot}{cvpen}(x, y, log.scale=TRUE, reverse=FALSE,
plot=TRUE, main = "Cross-validation error", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Ccvpen-method_+3A_x">x</code></td>
<td>
<p>output of a <code>crossval</code> run (must be of class
<code>cvpen</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2Ccvpen-method_+3A_y">y</code></td>
<td>
<p>used for S4 compatibility.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccvpen-method_+3A_log.scale">log.scale</code></td>
<td>
<p>logical; indicates if a log-scale should be used
when <code>xvar="lambda"</code>. Ignored for 2D cross-validation plot.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccvpen-method_+3A_reverse">reverse</code></td>
<td>
<p>logical; should the X-axis by reversed when <code>xvar=lambda</code>? Default is FALSE.  Ignored for 2D cross-validation plot.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccvpen-method_+3A_plot">plot</code></td>
<td>
<p>logical; indicates if the graph should be plotted. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccvpen-method_+3A_main">main</code></td>
<td>
<p>the main title, with a hopefully appropriate default definition.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccvpen-method_+3A_...">...</code></td>
<td>
<p>used for S4 compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">ggplot2</span> object which can be plotted via the <code>print</code>
method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta &lt;- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor  &lt;- 0.75
Soo  &lt;- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  &lt;- matrix(cor,10,10) ## bloc correlation between active variables
Sigma &lt;- bdiag(Soo,Sww,Soo,Sww,Soo) + 0.1
diag(Sigma) &lt;- 1
n &lt;- 100
x &lt;- as.matrix(matrix(rnorm(95*n),n,95) %*% chol(Sigma))
y &lt;- 10 + x %*% beta + rnorm(n,0,10)

## Use fewer lambda1 values by overwritting the default parameters
## and cross-validate over the sequences lambda1 and lambda2

cv.double &lt;- crossval(x,y, lambda2=10^seq(2,-2,len=50), nlambda1=50)

## Rerun simple cross-validation with the appropriate lambda2
cv.10K &lt;- crossval(x,y, lambda2=.2)
## Try leave one out also
cv.loo &lt;- crossval(x,y, K=n, lambda2=0.2)


plot(cv.double)

plot(cv.10K)
plot(cv.loo)

## Performance for selection purpose
beta.min.10K &lt;- slot(cv.10K, "beta.min")
beta.min.loo &lt;- slot(cv.loo, "beta.min")

cat("\nFalse positives with the minimal 10-CV choice: ", sum(sign(beta) != sign(beta.min.10K)))
cat("\nFalse positives with the minimal LOO-CV choice: ", sum(sign(beta) != sign(beta.min.loo)))

</code></pre>

<hr>
<h2 id='plot+2Cquadrupen-method'>Plot method for a quadrupen object</h2><span id='topic+plot+2Cquadrupen-method'></span><span id='topic+plot.quadrupen'></span>

<h3>Description</h3>

<p>Produce a plot of the solution path of a <code>quadrupen</code> fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>\S4method{plot}{quadrupen}(x, y, xvar = "lambda",
        main = paste(slot(x, "penalty")," path", sep=""),
        log.scale = TRUE, standardize=TRUE, reverse=FALSE,
        labels = NULL, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_x">x</code></td>
<td>
<p>output of a fitting procedure of the <span class="pkg">quadrupen</span>
package (<code><a href="#topic+elastic.net">elastic.net</a></code> or <code><a href="#topic+bounded.reg">bounded.reg</a></code>
for the moment). Must be of class <code>quadrupen</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_y">y</code></td>
<td>
<p>used for S4 compatibility.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_xvar">xvar</code></td>
<td>
<p>variable to plot on the X-axis: either <code>"lambda"</code>
(<code class="reqn">\lambda_1</code> penalty level) or <code>"fraction"</code>
(<code class="reqn">\ell_1</code>-norm of the coefficients). Default is set to
<code>"lambda"</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_main">main</code></td>
<td>
<p>the main title. Default is set to the model name followed
by what is on the Y-axis.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_log.scale">log.scale</code></td>
<td>
<p>logical; indicates if a log-scale should be used
when <code>xvar="lambda"</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_standardize">standardize</code></td>
<td>
<p>logical; standardize the coefficients before
plotting (with the norm of the predictor). Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_reverse">reverse</code></td>
<td>
<p>logical; should the X-axis be reversed when
<code>xvar="lambda"</code>? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_labels">labels</code></td>
<td>
<p>vector indicating the names associated to the plotted
variables. When specified, a legend is drawn in order to identify
each variable. Only relevant when the number of predictor is
small. Remind that the intercept does not count. Default is
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_plot">plot</code></td>
<td>
<p>logical; indicates if the graph should be plotted on
call. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cquadrupen-method_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">ggplot2</span> object which can be plotted via the
<code>print</code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadrupen-class">quadrupen</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta &lt;- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
cor &lt;- 0.75
Soo &lt;- toeplitz(cor^(0:(25-1))) ## Toeplitz correlation for irrelevant variables
Sww  &lt;- matrix(cor,10,10) ## bloc correlation between active variables
Sigma &lt;- bdiag(Soo,Sww,Soo,Sww,Soo)
diag(Sigma) &lt;- 1
n &lt;- 50
x &lt;- as.matrix(matrix(rnorm(95*n),n,95) %*% chol(Sigma))
y &lt;- 10 + x %*% beta + rnorm(n,0,10)

## Plot the Lasso path
plot(elastic.net(x,y, lambda2=0), main="Lasso solution path")
## Plot the Elastic-net path
plot(elastic.net(x,y, lambda2=10), xvar = "lambda")
## Plot the Elastic-net path (fraction on X-axis, unstandardized coefficient)
plot(elastic.net(x,y, lambda2=10), standardize=FALSE, xvar="fraction")
## Plot the Bounded regression path (fraction on X-axis)
plot(bounded.reg(x,y, lambda2=10), xvar="fraction")

</code></pre>

<hr>
<h2 id='plot+2Cstability.path-method'>Plot method for <code>stability.path</code>.</h2><span id='topic+plot+2Cstability.path-method'></span><span id='topic+plot.stability.path'></span>

<h3>Description</h3>

<p>Produce a plot of the stability path obtained by stability
selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>\S4method{plot}{stability.path}(x, y, xvar = "lambda", annot=TRUE,
         main = paste("Stability path for ", slot(x, "penalty")," regularizer", sep=""),
         log.scale = TRUE,  labels = rep("unknown status",p), plot = TRUE,
         sel.mode = c("rank","PFER"), cutoff=0.75, PFER=2, nvar=floor(n/log(p)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_x">x</code></td>
<td>
<p>output of a <code>stability</code> run (must be of class
<code>stability.path</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_y">y</code></td>
<td>
<p>used for S4 compatibility.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_xvar">xvar</code></td>
<td>
<p>variable to plot on the X-axis: either <code>"lambda"</code>
(first penalty level) or <code>"fraction"</code> (fraction of the
penalty level applied tune by <code class="reqn">\lambda_1</code>). Default
is <code>"lambda"</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_annot">annot</code></td>
<td>
<p>logical; should annotation be made on the graph
regarding controlled PFER (only relevant when <code>sel.mode</code>
equals <code>'PFER'</code>)? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_main">main</code></td>
<td>
<p>main title. If none given, a somewhat appropriate
title is automatically generated.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_log.scale">log.scale</code></td>
<td>
<p>logical; indicates if a log-scale should be used
when <code>xvar="lambda"</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_labels">labels</code></td>
<td>
<p>an optional vector of labels for each variable in
the path (e.g., 'relevant'/'irrelevant'). See examples.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_plot">plot</code></td>
<td>
<p>logical; indicates if the graph should be
plotted. Default is <code>TRUE</code>. If <code>FALSE</code>, only the
<span class="pkg">ggplot2</span> object is sent back.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_sel.mode">sel.mode</code></td>
<td>
<p>a character string, either <code>'rank'</code> or
<code>'PFER'</code>. In the first case, the selection is based on the
rank of total probabilities by variables along the path: the first
<code>nvar</code> variables are selected (see below). In the second
case, the PFER control is used as described in Meinshausen and
Buhlmannn's paper. Default is <code>'rank'</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_cutoff">cutoff</code></td>
<td>
<p>value of the cutoff probability (only relevant when
<code>sel.mode</code> equals <code>'PFER'</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_pfer">PFER</code></td>
<td>
<p>value of the per-family error rate to control (only
relevant when <code>sel.mode</code> equals <code>'PFER'</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_nvar">nvar</code></td>
<td>
<p>number of variables selected (only relevant when
<code>sel.mode</code> equals <code>'rank'</code>. Default is <code>floor(n/log(p))</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Cstability.path-method_+3A_...">...</code></td>
<td>
<p>used for S4 compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a <span class="pkg">ggplot2</span> object which can be plotted
via the <code>print</code> method, and a vector of selected variables
corresponding to method of choice (<code>'rank'</code> or
<code>'PFER'</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta &lt;- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
Soo  &lt;- matrix(0.75,25,25) ## bloc correlation between zero variables
Sww  &lt;- matrix(0.75,10,10) ## bloc correlation between active variables
Sigma &lt;- bdiag(Soo,Sww,Soo,Sww,Soo) + 0.2
diag(Sigma) &lt;- 1
n &lt;- 100
x &lt;- as.matrix(matrix(rnorm(95*n),n,95) %*% chol(Sigma))
y &lt;- 10 + x %*% beta + rnorm(n,0,10)

## Build a vector of label for true nonzeros
labels &lt;- rep("irrelevant", length(beta))
labels[beta != 0] &lt;- c("relevant")
labels &lt;- factor(labels, ordered=TRUE, levels=c("relevant","irrelevant"))

## Call to stability selection function, 200 subsampling
stab &lt;- stability(x,y, subsamples=200, lambda2=1, min.ratio=1e-2)

## Build the plot an recover the selected variable
plot(stab, labels=labels)
plot(stab, xvar="fraction", labels=labels, sel.mode="PFER", cutoff=0.75, PFER=2)

</code></pre>

<hr>
<h2 id='quadrupen-class'>Class &quot;quadrupen&quot;</h2><span id='topic+quadrupen-class'></span><span id='topic+fitted+2Cquadrupen-method'></span><span id='topic+predict+2Cquadrupen-method'></span><span id='topic+deviance+2Cquadrupen-method'></span><span id='topic+print+2Cquadrupen-method'></span><span id='topic+show+2Cquadrupen-method'></span><span id='topic+residuals+2Cquadrupen-method'></span>

<h3>Description</h3>

<p>Class of object returned by any fitting function of the
<span class="pkg">quadrupen</span> package (<code>elastic.net</code> or
<code>bounded.reg</code>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>coefficients</code>:</dt><dd><p>Matrix (class <code>"dgCMatrix"</code>) of
coefficients with respect to the original input. The number of
rows corresponds the length of <code>lambda1</code>.</p>
</dd>
<dt><code>active.set</code>:</dt><dd><p>Matrix (class <code>"dgCMatrix"</code>, generally
sparse) indicating the 'active' variables, in the sense that they
activate the constraints. For the <code><a href="#topic+elastic.net">elastic.net</a></code>, it
corresponds to the nonzero variables; for the
<code><a href="#topic+bounded.reg">bounded.reg</a></code> function, it is the set of variables
reaching the boundary along the path of solutions.</p>
</dd>
<dt><code>intercept</code>:</dt><dd><p>logical; indicates if an intercept has
been included to the model.</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>A vector (class <code>"numeric"</code>)
containing the successive values of the (unpenalized) intercept.
Equals to zero if <code>intercept</code> has been set to <code>FALSE</code>.</p>
</dd>
<dt><code>meanx</code>:</dt><dd><p>Vector (class <code>"numeric"</code>) containing
the column means of the predictor matrix.</p>
</dd>
<dt><code>normx</code>:</dt><dd><p>Vector (class <code>"numeric"</code>) containing the
square root of the sum of squares of each column of the design
matrix.</p>
</dd>
<dt><code>penscale</code>:</dt><dd><p>Vector <code>"numeric"</code> with real positive
values that have been used to weight the penalty tuned by
<code class="reqn">\lambda_1</code>.</p>
</dd>
<dt><code>penalty</code>:</dt><dd><p>Object of class <code>"character"</code>
indicating the method used (<code>"elastic-net"</code> or <code>"bounded
regression"</code>).</p>
</dd>
<dt><code>naive</code>:</dt><dd><p>logical; was the <code>naive</code> mode on?</p>
</dd>
<dt><code>lambda1</code>:</dt><dd><p>Vector (class <code>"numeric"</code>) of penalty
levels (either <code class="reqn">\ell_1</code> or <code class="reqn">\ell_\infty</code>)
for which the model has eventually been fitted.</p>
</dd>
<dt><code>lambda2</code>:</dt><dd><p>Scalar (class <code>"numeric"</code>) for the
amount of <code class="reqn">\ell_2</code> (ridge-like) penalty.</p>
</dd>
<dt><code>struct</code>:</dt><dd><p>Object of class <code>"Matrix"</code> used to
structure the coefficients in the <code class="reqn">\ell_2</code> penalty.</p>
</dd>
<dt><code>control</code>:</dt><dd><p>Object of class <code>"list"</code> with low
level options used for optimization.</p>
</dd>
<dt><code>monitoring</code>:</dt><dd><p>List (class <code>"list"</code>) which
contains various indicators dealing with the optimization
process.</p>
</dd>
<dt><code>residuals</code>:</dt><dd><p>Matrix of residuals, each column
corresponding to a value of <code>lambda1</code>.</p>
</dd>
<dt><code>r.squared</code>:</dt><dd><p>Vector (class <code>"numeric"</code>) given the
coefficient of determination as a function of lambda1.</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Matrix of fitted values, each column
corresponding to a value of <code>lambda1</code>.</p>
</dd>  </dl>



<h3>Methods</h3>

<p>This class comes with the usual <code>predict(object, newx, ...)</code>,
<code>fitted(object, ...)</code>, <code>residuals(object, ...)</code>,
<code>print(object, ...)</code>, <code>show(object)</code> and
<code>deviance(object, ...)</code> generic (undocumented) methods.
</p>
<p>A specific plotting method is available and documented
(<code><a href="#topic+plot+2Cquadrupen-method">plot,quadrupen-method</a></code>).
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+plot+2Cquadrupen-method">plot,quadrupen-method</a></code>.
</p>

<hr>
<h2 id='stability'>Stability selection for a quadrupen fit.</h2><span id='topic+stability'></span>

<h3>Description</h3>

<p>Compute the stability path of a (possibly randomized) fitting
procedure as introduced by Meinshausen and Buhlmann (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stability(
  x,
  y,
  penalty = c("elastic.net", "bounded.reg"),
  subsamples = 100,
  sample.size = floor(n/2),
  randomize = TRUE,
  weakness = 0.5,
  verbose = TRUE,
  folds = replicate(subsamples, sample(1:nrow(x), sample.size), simplify = FALSE),
  mc.cores = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stability_+3A_x">x</code></td>
<td>
<p>matrix of features, possibly sparsely encoded
(experimental). Do NOT include intercept.</p>
</td></tr>
<tr><td><code id="stability_+3A_y">y</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="stability_+3A_penalty">penalty</code></td>
<td>
<p>a string for the fitting procedure used for
cross-validation. Either <code><a href="#topic+elastic.net">elastic.net</a></code> or
<code>"bounded.reg"</code>.</p>
</td></tr>
<tr><td><code id="stability_+3A_subsamples">subsamples</code></td>
<td>
<p>integer indicating the number of subsamplings
used to estimate the selection probabilities. Default is 100.</p>
</td></tr>
<tr><td><code id="stability_+3A_sample.size">sample.size</code></td>
<td>
<p>integer indicating the size of each subsamples.
Default is <code>floor(n/2)</code>.</p>
</td></tr>
<tr><td><code id="stability_+3A_randomize">randomize</code></td>
<td>
<p>Should a randomized version of the fitting
procedure by used? Default is <code>TRUE</code>. See details below.</p>
</td></tr>
<tr><td><code id="stability_+3A_weakness">weakness</code></td>
<td>
<p>Coefficient used for randomizing. Default is
<code>0.5</code>. Ignored when <code>randomized</code> is <code>FALSE</code>. See
details below.</p>
</td></tr>
<tr><td><code id="stability_+3A_verbose">verbose</code></td>
<td>
<p>logical; indicates if the progression should be
displayed. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="stability_+3A_folds">folds</code></td>
<td>
<p>list with <code>subsamples</code> entries with vectors
describing the folds to use for the stability procedure. By
default, the folds are randomly sampled with the specified
<code>subsamples</code> argument.</p>
</td></tr>
<tr><td><code id="stability_+3A_mc.cores">mc.cores</code></td>
<td>
<p>the number of cores to use. The default uses 2 cores.</p>
</td></tr>
<tr><td><code id="stability_+3A_...">...</code></td>
<td>
<p>additional parameters to overwrite the defaults of the
fitting procedure. See the corresponding documentation
(<code><a href="#topic+elastic.net">elastic.net</a></code> or <code><a href="#topic+bounded.reg">bounded.reg</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+stability.path-class">stability.path</a></code>.
</p>


<h3>Note</h3>

<p>When <code>randomized = TRUE</code>, the <code>penscale</code> argument
that weights the penalty tuned by <code class="reqn">\lambda_1</code> is
perturbed (divided) for each subsample by a random variable
uniformly distributed on
[&amp;#945;,1],
where
&amp;#945; is
the weakness parameter.
</p>
<p>If the user runs the fitting method with option
<code>'bulletproof'</code> set to <code>FALSE</code>, the algorithm may stop
at an early stage of the path. Early stops of the underlying
fitting function are handled internally, in the following way: we
chose to simply skip the results associated with such runs, in
order not to bias the stability selection procedure. If it occurs
too often, a warning is sent to the user, in which case you should
reconsider the grid of <code>lambda1</code> for stability selection. If
<code>bulletproof</code> is <code>TRUE</code> (the default), there is nothing
to worry about, except a possible slow down when any switching to
the proximal algorithm is required.
</p>


<h3>References</h3>

<p>N. Meinshausen and P. Buhlmann (2010). Stability
Selection, JRSS(B).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stability.path-class">stability.path</a></code> and
<code><a href="#topic+plot+2Cstability.path-method">plot,stability.path-method</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating multivariate Gaussian with blockwise correlation
## and piecewise constant vector of parameters
beta &lt;- rep(c(0,1,0,-1,0), c(25,10,25,10,25))
Soo  &lt;- matrix(0.75,25,25) ## bloc correlation between zero variables
Sww  &lt;- matrix(0.75,10,10) ## bloc correlation between active variables
Sigma &lt;- bdiag(Soo,Sww,Soo,Sww,Soo) + 0.2
diag(Sigma) &lt;- 1
n &lt;- 100
x &lt;- as.matrix(matrix(rnorm(95*n),n,95) %*% chol(Sigma))
y &lt;- 10 + x %*% beta + rnorm(n,0,10)

## Build a vector of label for true nonzeros
labels &lt;- rep("irrelevant", length(beta))
labels[beta != 0] &lt;- c("relevant")
labels &lt;- factor(labels, ordered=TRUE, levels=c("relevant","irrelevant"))

## Call to stability selection function, 200 subsampling
stab &lt;- stability(x,y, subsamples=200, lambda2=1, min.ratio=1e-2)
## Recover the selected variables for a given cutoff
## and per-family error rate, without producing any plot
stabpath &lt;- plot(stab, cutoff=0.75, PFER=1, plot=FALSE)

cat("\nFalse positives for the randomized Elastic-net with stability selection: ",
     sum(labels[stabpath$selected] != "relevant"))
cat("\nDONE.\n")

</code></pre>

<hr>
<h2 id='stability.path-class'>Class &quot;stability.path&quot;</h2><span id='topic+stability.path-class'></span><span id='topic+print+2Cstability.path-method'></span><span id='topic+show+2Cstability.path-method'></span>

<h3>Description</h3>

<p>Class of object returned by the <code>stability</code> function, with
methods <code>print</code>, <code>show</code> and <code>plot</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>probabilities</code>: </dt><dd><p>a <code>Matrix</code> object containing the
estimated probabilities of selection along the path of solutions.</p>
</dd>
<dt><code>penalty</code>: </dt><dd><p>Object of class <code>"character"</code>
indicating the penalizer used.</p>
</dd>
<dt><code>naive</code>: </dt><dd><p>logical indicating whether rescaling of the
coefficients has been performed regarding the <code class="reqn">\ell_2</code>-penalty.</p>
</dd>
<dt><code>lambda1</code>: </dt><dd><p>a vector with the levels of the first penalty.</p>
</dd>
<dt><code>lambda2</code>: </dt><dd><p>a scalar with the <code class="reqn">\ell_2</code>-penalty level.</p>
</dd>
<dt><code>folds</code>: </dt><dd><p>a list that contains the folds used for each subsample.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See also <code><a href="#topic+plot+2Cstability.path-method">plot,stability.path-method</a></code>, and
<code><a href="#topic+stability">stability</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
