<!DOCTYPE html><html><head><title>Help for package recexcavAAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {recexcavAAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cootrans'><p>Tool for transforming local metric coordinates</p></a></li>
<li><a href='#draw_circle'><p>Draws a circular point cloud (3D)</p></a></li>
<li><a href='#draw_sphere'><p>Draws a spherical point cloud (3D)</p></a></li>
<li><a href='#fillhexa'><p>Fills hexahedrons with a regular point raster (3D)</p></a></li>
<li><a href='#kriglist'><p>Apply kriging {kriging} to a list of data.frames</p></a></li>
<li><a href='#KT_spits'><p>KT_data: Niveau measurements from the fictional trench of a excavation KT</p></a></li>
<li><a href='#KT_squarecorners'><p>KT_data: Corner points of a 1m*1m raster within the trench of a fictional excavation KT</p></a></li>
<li><a href='#KT_vessel'><p>KT_data: Information about individual sherds of a reconstructed vessel from the trench</p>
of a fictional excavation KT</a></li>
<li><a href='#pnp'><p>Check if a point is within a polygon (2D)</p></a></li>
<li><a href='#pnpmulti'><p>Check if multiple points are within a polygon (2D)</p></a></li>
<li><a href='#posdec'><p>Multiple point position decision in relation to a set of stacked surfaces (3D)</p></a></li>
<li><a href='#posdeclist'><p>Multiple point position decision in relation to a set of stacked surfaces (3D)</p>
for multiple data.frames in a list</a></li>
<li><a href='#rescale'><p>Scales a point cloud (3D)</p></a></li>
<li><a href='#rotate'><p>Rotate a point cloud around a pivot point (3D)</p></a></li>
<li><a href='#spatiallong'><p>Transformation of numeric matrices from wide to long format</p></a></li>
<li><a href='#spatialwide'><p>Transformation of numeric matrices from long to wide format</p></a></li>
<li><a href='#spitcenter'><p>Center determination for hexahedrons</p></a></li>
<li><a href='#spitcenternat'><p>Center determination for rectangles whose tops and bottoms are defined by irregular surfaces (3D)</p></a></li>
<li><a href='#spitcenternatlist'><p>Center determination for rectangles whose tops and bottoms are defined by irregular</p>
surfaces (3D) for multiple data.frames in a list</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>3D Reconstruction of Archaeological Excavations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clemens Schmid &lt;clemens@nevrome.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolset for 3D reconstruction and analysis of excavations. It provides methods to reconstruct natural and artificial surfaces based on field measurements. This allows to spatially contextualize documented subunits and features. Intended to be part of a 3D visualization workflow.</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-02-15</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ISAAKiel/recexcavAAR">https://github.com/ISAAKiel/recexcavAAR</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.7)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools (&ge; 1.12.0), dplyr (&ge; 0.5.0), knitr (&ge; 1.15.1),
magrittr (&ge; 1.5), rgl (&ge; 0.96.0), rmarkdown (&ge; 1.0),
roxygen2 (&ge; 5.0.1), testthat (&ge; 1.0.2)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.2), kriging (&ge; 1.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-02-25 21:29:06 UTC; clemens</td>
</tr>
<tr>
<td>Author:</td>
<td>Clemens Schmid [cre, cph, aut],
  Benjamin Serbe [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-02-25 23:55:29</td>
</tr>
</table>
<hr>
<h2 id='cootrans'>Tool for transforming local metric coordinates</h2><span id='topic+cootrans'></span>

<h3>Description</h3>

<p>This function transforms local metric coordinates to absolute coordinates of referenced
systems by use of a two dimensional four parameter Helmert transformation. This function does
not cover the transformation of three dimensional points or transformation between two different
datums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cootrans(pair_matrix, pm_column, data_matrix, dm_column, checking = FALSE,
  checkplot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cootrans_+3A_pair_matrix">pair_matrix</code></td>
<td>
<p>data.frame or matrix with pairs of local and corresponding absolute coordinates (Minimum two!)</p>
</td></tr>
<tr><td><code id="cootrans_+3A_pm_column">pm_column</code></td>
<td>
<p>vector with numerical index of the columns in order: local x-value, local y-value, absolute x-value, absolute y-value</p>
</td></tr>
<tr><td><code id="cootrans_+3A_data_matrix">data_matrix</code></td>
<td>
<p>data.frame with local x- and y-values which schould be transformed.</p>
</td></tr>
<tr><td><code id="cootrans_+3A_dm_column">dm_column</code></td>
<td>
<p>vector with numerical index of the columns in order: local x-value, local y-value.</p>
</td></tr>
<tr><td><code id="cootrans_+3A_checking">checking</code></td>
<td>
<p>boolean switch to turn on the checking ability. Default: FALSE. If TRUE showes combined coordinate plots with indexed points and alters return of function.</p>
</td></tr>
<tr><td><code id="cootrans_+3A_checkplot">checkplot</code></td>
<td>
<p>boolean switch to turn off the checking plot. Default: TRUE. Only matters if checking == TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Original data.frame with additional columns containing the absolute x- and y-coordinates. In case of 'checking = TRUE' returns pair_matrix data.frame with additional columns of scale and rotation arc in degrees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coord_data &lt;- data.frame(
 loc_x = c(1,3,1,3),
 loc_y = c(1,1,3,3),
 abs_x = c(107.1,107,104.9,105),
 abs_y = c(105.1,107,105.1,106.9)
)

data_table &lt;- data.frame(
 x = c(1.5,1.2,1.6,2),
 y = c(1,5,2.1,2),
 type = c("flint","flint","pottery","bone")
)

new_frame &lt;- cootrans(coord_data, c(1,2,3,4), data_table, c(1,2))

check_data &lt;- cootrans(coord_data, c(1,2,3,4), data_table, c(1,2), checking = TRUE)

</code></pre>

<hr>
<h2 id='draw_circle'>Draws a circular point cloud (3D)</h2><span id='topic+draw_circle'></span>

<h3>Description</h3>

<p>Draws a 2D circle on x- and y-plane around a center point in 3D space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_circle(centerx, centery, centerz, radius, resolution = 30L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_circle_+3A_centerx">centerx</code></td>
<td>
<p>x axis value of circle center point</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_centery">centery</code></td>
<td>
<p>y axis value of circle center point</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_centerz">centerz</code></td>
<td>
<p>z axis value of circle center point</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_radius">radius</code></td>
<td>
<p>circle radius</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_resolution">resolution</code></td>
<td>
<p>amount of circle points (default = 30)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the spatial coordinates of the resulting points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>draw_circle(
  centerx = 4,
  centery = 5,
  centerz = 1,
  radius = 3,
  resolution = 20
)

circ &lt;- draw_circle(1,2,3,2)

plot(circ$x, circ$y)

</code></pre>

<hr>
<h2 id='draw_sphere'>Draws a spherical point cloud (3D)</h2><span id='topic+draw_sphere'></span>

<h3>Description</h3>

<p>Draws a sphere around a center point in 3D space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_sphere(centerx, centery, centerz, radius, phires = 10L, thetares = 10L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_sphere_+3A_centerx">centerx</code></td>
<td>
<p>x axis value of sphere center point</p>
</td></tr>
<tr><td><code id="draw_sphere_+3A_centery">centery</code></td>
<td>
<p>y axis value of sphere center point</p>
</td></tr>
<tr><td><code id="draw_sphere_+3A_centerz">centerz</code></td>
<td>
<p>z axis value of sphere center point</p>
</td></tr>
<tr><td><code id="draw_sphere_+3A_radius">radius</code></td>
<td>
<p>sphere radius</p>
</td></tr>
<tr><td><code id="draw_sphere_+3A_phires">phires</code></td>
<td>
<p>phi resolution (default = 10)</p>
</td></tr>
<tr><td><code id="draw_sphere_+3A_thetares">thetares</code></td>
<td>
<p>theta resolution (default = 10)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the spatial coordinates of the resulting points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sphere &lt;- draw_sphere(
  centerx = 4,
  centery = 5,
  centerz = 1,
  radius = 3,
  phires = 20,
  thetares = 20
)

#library(rgl)
#plot3d(sphere)

</code></pre>

<hr>
<h2 id='fillhexa'>Fills hexahedrons with a regular point raster (3D)</h2><span id='topic+fillhexa'></span>

<h3>Description</h3>

<p>A hexahedron is a three dimensional shape that is defined by 6 faces and 8 corner points.
<code>fillhexa</code> allows to fill such a shape with a regular point raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillhexa(hex, res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillhexa_+3A_hex">hex</code></td>
<td>
<p>dataframe with three columns and eight rows to define a hexahedron by its corner
point coordinates x, y and z</p>
</td></tr>
<tr><td><code id="fillhexa_+3A_res">res</code></td>
<td>
<p>numeric value &gt; 0 and &lt;= 1 for the resolution of the point raster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://stackoverflow.com/questions/36115215/filling-a-3d-body-with-a-systematic-point-raster">https://stackoverflow.com/questions/36115215/filling-a-3d-body-with-a-systematic-point-raster</a>
for a description of the function and how it was developed.
</p>


<h3>Value</h3>

<p>data.frame with the spatial coordinates of the resulting points of the grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hexatestdf &lt;- data.frame(
  x = c(0,1,0,4,5,5,5,5),
  y = c(1,1,4,4,1,1,4,4),
  z = c(4,8,4,9,4,8,4,6)
)

cx = fillhexa(hexatestdf, 0.1)

#library(rgl)
#plot3d(
# cx[,1], cx[,2], cx[,3],
# type = "p",
# xlab = "x", ylab = "y", zlab = "z"
#)

</code></pre>

<hr>
<h2 id='kriglist'>Apply kriging {kriging} to a list of data.frames</h2><span id='topic+kriglist'></span>

<h3>Description</h3>

<p><code>kriging</code> {kriging} is a simple and highly optimized ordinary kriging algorithm to plot
geographical data. This interface to the method allows to not just apply it to one data.frame but
to a list of data.frames. The result is reduced to the data.frame with the predicted values.
For a more detailed output <code>kriging</code> {kriging} has to be called for the individual input
data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kriglist(plist, x = 1, y = 2, z = 3, rdup = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kriglist_+3A_plist">plist</code></td>
<td>
<p>List of data.frames with point coordinates</p>
</td></tr>
<tr><td><code id="kriglist_+3A_x">x</code></td>
<td>
<p>index of data.frame column with x-axis spatial points. Defaults to 1</p>
</td></tr>
<tr><td><code id="kriglist_+3A_y">y</code></td>
<td>
<p>index of data.frame column with y-axis spatial points. Defaults to 2</p>
</td></tr>
<tr><td><code id="kriglist_+3A_z">z</code></td>
<td>
<p>index of data.frame column with z-axis spatial points. Defaults to 3</p>
</td></tr>
<tr><td><code id="kriglist_+3A_rdup">rdup</code></td>
<td>
<p>switch to activate removal of double values for single horizontal positions in the input
data.frames. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="kriglist_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to method <code>kriging</code> {kriging}</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with data.frames which contains the predicted values along with the coordinate covariates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
 x = rnorm(50),
 y = rnorm(50),
 z = rnorm(50) - 5
)

df2 &lt;- data.frame(
 x = rnorm(50),
 y = rnorm(50),
 z = rnorm(50) + 5
)

lpoints &lt;- list(df1, df2)

surfacelist &lt;- kriglist(lpoints, lags = 3, model = "spherical")

</code></pre>

<hr>
<h2 id='KT_spits'>KT_data: Niveau measurements from the fictional trench of a excavation KT</h2><span id='topic+KT_spits'></span>

<h3>Description</h3>

<p>A dataset containing coordinates of niveau measurements of a fictional excavation KT with
4 spits.
</p>


<h3>Format</h3>

<p>A data frame with 304 rows and 4 variables:
</p>

<ul>
<li><p> id: IDs of individual measurements with the information about to which level
they belong
</p>
</li>
<li><p> x: x axis coordinates of measurements
</p>
</li>
<li><p> y: y axis coordinates of measurements
</p>
</li>
<li><p> z: z axis coordinates of measurements
</p>
</li></ul>


<h3>See Also</h3>

<p>Other KT_data: <code><a href="#topic+KT_squarecorners">KT_squarecorners</a></code>,
<code><a href="#topic+KT_vessel">KT_vessel</a></code>
</p>

<hr>
<h2 id='KT_squarecorners'>KT_data: Corner points of a 1m*1m raster within the trench of a fictional excavation KT</h2><span id='topic+KT_squarecorners'></span>

<h3>Description</h3>

<p>A dataset containing horizontal coordinates of corner points of a 1m*1m raster within
the rectangular trench (corner points of squares).
</p>


<h3>Format</h3>

<p>A data frame with 63 rows and 2 variables:
</p>

<ul>
<li><p> x: x axis coordinates of corner points
</p>
</li>
<li><p> y: y axis coordinates of corner points
</p>
</li></ul>


<h3>See Also</h3>

<p>Other KT_data: <code><a href="#topic+KT_spits">KT_spits</a></code>,
<code><a href="#topic+KT_vessel">KT_vessel</a></code>
</p>

<hr>
<h2 id='KT_vessel'>KT_data: Information about individual sherds of a reconstructed vessel from the trench
of a fictional excavation KT</h2><span id='topic+KT_vessel'></span>

<h3>Description</h3>

<p>A dataset containing spatial and contextual information for individual sherds of a single
vessel. Some sherds were documented in the field with single find measurements. For the
others only spit and square attribution is possible.
</p>


<h3>Format</h3>

<p>A data frame with 7 rows and 7 variables:
</p>

<ul>
<li><p> inv: Inventory numbers of sherds. KTF means single find with individual measurement,
KTM means mass find without this precise information.
</p>
</li>
<li><p> spit: spits where the sherds were found
</p>
</li>
<li><p> square: squares where the sherds were found
</p>
</li>
<li><p> feature: features where the sherds were found
</p>
</li>
<li><p> x: x axis coordinates of sherds
</p>
</li>
<li><p> y: y axis coordinates of sherds
</p>
</li>
<li><p> z: z axis coordinates of sherds
</p>
</li></ul>


<h3>See Also</h3>

<p>Other KT_data: <code><a href="#topic+KT_spits">KT_spits</a></code>,
<code><a href="#topic+KT_squarecorners">KT_squarecorners</a></code>
</p>

<hr>
<h2 id='pnp'>Check if a point is within a polygon (2D)</h2><span id='topic+pnp'></span>

<h3>Description</h3>

<p><code>pnp</code> is able to determine if a point is within a polygon in 2D space.
The polygon is described by its corner points. The points must be in a correct
drawing order.
</p>
<p>Based on this solution:
Copyright (c) 1970-2003, Wm. Randolph Franklin
<a href="http://wrf.ecse.rpi.edu/pmwiki/pmwiki.php/Main/Software#toc24">http://wrf.ecse.rpi.edu/pmwiki/pmwiki.php/Main/Software#toc24</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnp(vertx, verty, testx, testy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnp_+3A_vertx">vertx</code></td>
<td>
<p>vector of x axis values of polygon corner points</p>
</td></tr>
<tr><td><code id="pnp_+3A_verty">verty</code></td>
<td>
<p>vector of y axis values of polygon corner points</p>
</td></tr>
<tr><td><code id="pnp_+3A_testx">testx</code></td>
<td>
<p>x axis value of point of interest</p>
</td></tr>
<tr><td><code id="pnp_+3A_testy">testy</code></td>
<td>
<p>y axis value of point of interest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For discussion see: <a href="http://stackoverflow.com/questions/217578/how-can-i-determine-whether-a-2d-point-is-within-a-polygon/2922778#2922778">http://stackoverflow.com/questions/217578/how-can-i-determine-whether-a-2d-point-is-within-a-polygon/2922778#2922778</a>
</p>


<h3>Value</h3>

<p>boolean value - TRUE, if the point is within the polygon. Otherwise FALSE.
</p>


<h3>See Also</h3>

<p>Other pnpfuncs: <code><a href="#topic+pnpmulti">pnpmulti</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  x = c(1,1,2,2),
  y = c(1,2,1,2)
)

pnp(df$x, df$y, 1.5, 1.5)
pnp(df$x, df$y, 2.5, 2.5)

# caution: false-negatives in edge-cases:
pnp(df$x, df$y, 2, 1.5)

</code></pre>

<hr>
<h2 id='pnpmulti'>Check if multiple points are within a polygon (2D)</h2><span id='topic+pnpmulti'></span>

<h3>Description</h3>

<p><code>pnpmulti</code> works as <code><a href="#topic+pnp">pnp</a></code> but for multiple points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnpmulti(vertx, verty, testx, testy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pnpmulti_+3A_vertx">vertx</code></td>
<td>
<p>vector of x axis values of polygon corner points</p>
</td></tr>
<tr><td><code id="pnpmulti_+3A_verty">verty</code></td>
<td>
<p>vector of y axis values of polygon corner points</p>
</td></tr>
<tr><td><code id="pnpmulti_+3A_testx">testx</code></td>
<td>
<p>vector of x axis values of points of interest</p>
</td></tr>
<tr><td><code id="pnpmulti_+3A_testy">testy</code></td>
<td>
<p>vector of y axis values of points of interest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with boolean values - TRUE, if the respective point is within the polygon.
Otherwise FALSE.
</p>


<h3>See Also</h3>

<p>Other pnpfuncs: <code><a href="#topic+pnp">pnp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>polydf &lt;- data.frame(
  x = c(1,1,2,2),
  y = c(1,2,1,2)
)

testdf &lt;- data.frame(
  x = c(1.5, 2.5),
  y = c(1.5, 2.5)
)

pnpmulti(polydf$x, polydf$y, testdf$x, testdf$y)

</code></pre>

<hr>
<h2 id='posdec'>Multiple point position decision in relation to a set of stacked surfaces (3D)</h2><span id='topic+posdec'></span>

<h3>Description</h3>

<p><code>posdec</code> has the purpose to make a decision about the position of individual points in relation
to a set of stacked surfaces in 3D space. The decision is made by comparing the mean z axis value of
the four horizontally closest points of a surface to the z axis value of the point in question.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posdec(crdf, maplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posdec_+3A_crdf">crdf</code></td>
<td>
<p>data.frame with the spatial coordinates of the points of interest. Must contain three
columns with the x axis values, y axis values and z axis values of the points in the order x, y, z</p>
</td></tr>
<tr><td><code id="posdec_+3A_maplist">maplist</code></td>
<td>
<p>list of data.frames which contain the points that make up the surfaces. The individual
data.frames must have the same structure as <code>crdf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the spatial coordinates of the points of interest and the respective position
information
</p>


<h3>See Also</h3>

<p>Other posdecfuncs: <code><a href="#topic+posdeclist">posdeclist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
  x = rnorm(50),
  y = rnorm(50),
  z = rnorm(50) - 5
)

df2 &lt;- data.frame(
  x = rnorm(50),
  y = rnorm(50),
  z = rnorm(50) + 5
)

lpoints &lt;- list(df1, df2)

maps &lt;- kriglist(lpoints, lags = 3, model = "spherical")

finds &lt;- data.frame(
  x = c(0, 1, 0.5, 0.7),
  y = c(0.5, 0, 1, 0.7),
  z = c(-10, 10, 0, 2)
)

posdec(finds, maps)

</code></pre>

<hr>
<h2 id='posdeclist'>Multiple point position decision in relation to a set of stacked surfaces (3D)
for multiple data.frames in a list</h2><span id='topic+posdeclist'></span>

<h3>Description</h3>

<p><code>posdeclist</code> works as <code><a href="#topic+posdec">posdec</a></code> but not just for a single data.frame
with individual points but for a list of data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posdeclist(crdflist, maplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posdeclist_+3A_crdflist">crdflist</code></td>
<td>
<p>list of data.frames with the spatial coordinates of the points of
interest (for details see <code><a href="#topic+posdec">posdec</a></code>)</p>
</td></tr>
<tr><td><code id="posdeclist_+3A_maplist">maplist</code></td>
<td>
<p>list of data.frames which contain the points that make up the surfaces</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data.frames with the spatial coordinates of the points of interest
and the respective position information
</p>


<h3>See Also</h3>

<p>Other posdecfuncs: <code><a href="#topic+posdec">posdec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
  x = rnorm(50),
  y = rnorm(50),
  z = rnorm(50) - 5
)

df2 &lt;- data.frame(
  x = rnorm(50),
  y = rnorm(50),
  z = rnorm(50) + 5
)

lpoints &lt;- list(df1, df2)

maps &lt;- kriglist(lpoints, lags = 3, model = "spherical")

hexadf1 &lt;- data.frame(
  x = c(0, 1, 0, 4, 5, 5, 5, 5),
  y = c(1, 1, 4, 4, 1, 1, 4, 4),
  z = c(1, 5, 1, 6, 1, 5, 1, 3)
)

hexadf2 &lt;- data.frame(
  x = c(0, 1, 0, 4, 5, 5, 5, 5),
  y = c(1, 1, 4, 4, 1, 1, 4, 4),
  z = c(-1, -5, -1, -6, -1, -5, -1, -3)
)

cx1 &lt;- fillhexa(hexadf1, 0.1)
cx2 &lt;- fillhexa(hexadf2, 0.1)

cubelist &lt;- list(cx1, cx2)

posdeclist(cubelist, maps)

</code></pre>

<hr>
<h2 id='rescale'>Scales a point cloud (3D)</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>Scales a 3D point cloud on every axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(x, y, z, scalex = 1, scaley = 1, scalez = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>
<p>vector of x axis values of scale point cloud</p>
</td></tr>
<tr><td><code id="rescale_+3A_y">y</code></td>
<td>
<p>vector of y axis values of scale point cloud</p>
</td></tr>
<tr><td><code id="rescale_+3A_z">z</code></td>
<td>
<p>vector of z axis values of scale point cloud</p>
</td></tr>
<tr><td><code id="rescale_+3A_scalex">scalex</code></td>
<td>
<p>scaling factor on x axis (default = 1)</p>
</td></tr>
<tr><td><code id="rescale_+3A_scaley">scaley</code></td>
<td>
<p>scaling factor on y axis (default = 1)</p>
</td></tr>
<tr><td><code id="rescale_+3A_scalez">scalez</code></td>
<td>
<p>scaling factor on z axis (default = 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the spatial coordinates of the resulting points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- draw_sphere(1,1,1,3)

#library(rgl)
#plot3d(s)

s2 &lt;- rescale(s$x, s$y, s$z, scalex = 4, scalez = 5)

#library(rgl)
#plot3d(s2)

</code></pre>

<hr>
<h2 id='rotate'>Rotate a point cloud around a pivot point (3D)</h2><span id='topic+rotate'></span>

<h3>Description</h3>

<p>Rotate a point cloud around a defined pivot point by defined angles. The default
rotation angle around each axis is zero and the default pivot point is the center
point of the point cloud (defined by mean())
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate(x, y, z, degrx = 0, degry = 0, degrz = 0, pivotx = NA_real_,
  pivoty = NA_real_, pivotz = NA_real_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_x">x</code></td>
<td>
<p>vector of x axis values of rotation point cloud</p>
</td></tr>
<tr><td><code id="rotate_+3A_y">y</code></td>
<td>
<p>vector of y axis values of rotation point cloud</p>
</td></tr>
<tr><td><code id="rotate_+3A_z">z</code></td>
<td>
<p>vector of z axis values of rotation point cloud</p>
</td></tr>
<tr><td><code id="rotate_+3A_degrx">degrx</code></td>
<td>
<p>rotation angle around x axis in degree (default = 0)</p>
</td></tr>
<tr><td><code id="rotate_+3A_degry">degry</code></td>
<td>
<p>rotation angle around y axis in degree (default = 0)</p>
</td></tr>
<tr><td><code id="rotate_+3A_degrz">degrz</code></td>
<td>
<p>rotation angle around z axis in degree (default = 0)</p>
</td></tr>
<tr><td><code id="rotate_+3A_pivotx">pivotx</code></td>
<td>
<p>x axis value of pivot point (default = mean(x))</p>
</td></tr>
<tr><td><code id="rotate_+3A_pivoty">pivoty</code></td>
<td>
<p>y axis value of pivot point (default = mean(y))</p>
</td></tr>
<tr><td><code id="rotate_+3A_pivotz">pivotz</code></td>
<td>
<p>z axis value of pivot point (default = mean(z))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the spatial coordinates of the resulting points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>circ &lt;- draw_circle(0,0,0,5)

#library(rgl)
#plot3d(
#  circ,
#  xlim = c(-6,6),
#  ylim = c(-6,6),
#  zlim = c(-6,6)
#)

rotcirc &lt;- rotate(circ$x, circ$y, circ$z, degrx = 45)

#plot3d(
#  rotcirc,
#  xlim = c(-6,6),
#  ylim = c(-6,6),
#  zlim = c(-6,6)
#)

</code></pre>

<hr>
<h2 id='spatiallong'>Transformation of numeric matrices from wide to long format</h2><span id='topic+spatiallong'></span>

<h3>Description</h3>

<p><code>spatiallong</code> transforms a set of two independent variables in vectors and a
dependent variable in a wide matrix to a long matrix that combines the information.
The result is exported as a data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatiallong(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatiallong_+3A_x">x</code></td>
<td>
<p>vector of first independent variable. e.g. vector with x axis spatial points</p>
</td></tr>
<tr><td><code id="spatiallong_+3A_y">y</code></td>
<td>
<p>vector of second independent variable. e.g. vector with y axis spatial points</p>
</td></tr>
<tr><td><code id="spatiallong_+3A_z">z</code></td>
<td>
<p>matrix of dependent variable. e.g. matrix with z axis spatial points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with three columns x, y and z
</p>


<h3>See Also</h3>

<p>Other transfuncs: <code><a href="#topic+spatialwide">spatialwide</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 1, 1, 2, 2, 2, 3, 3, 4)
y &lt;- c(1, 2, 3, 1, 2, 3, 1, 2, 3)
z &lt;- c(3, 4, 2, 3, NA, 5, 6, 3, 1)

sw &lt;- spatialwide(x, y, z, digits = 3)

spatiallong(sw$x, sw$y, sw$z)

</code></pre>

<hr>
<h2 id='spatialwide'>Transformation of numeric matrices from long to wide format</h2><span id='topic+spatialwide'></span>

<h3>Description</h3>

<p>Transforms a set of two independent and one dependent variables in vectors from a long
to a wide format and exports this result as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialwide(x, y, z, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatialwide_+3A_x">x</code></td>
<td>
<p>vector of first independent variable. e.g. vector with x-axis spatial points</p>
</td></tr>
<tr><td><code id="spatialwide_+3A_y">y</code></td>
<td>
<p>vector of second independent variable. e.g. vector with y-axis spatial points</p>
</td></tr>
<tr><td><code id="spatialwide_+3A_z">z</code></td>
<td>
<p>vector of dependent variable. e.g. vector with z-axis spatial points</p>
</td></tr>
<tr><td><code id="spatialwide_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places to be used for rounding
the dependent variables <code>x</code> and <code>y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with three elements:
</p>
<p>$x: vector with ascendingly sorted, unique values of the first independent variable <code>x</code>
</p>
<p>$y: vector with ascendingly sorted, unique values of the second independent variable <code>y</code>
</p>
<p>$z: matrix with the values of z for the defined combinations of <code>x</code> (columns) and
<code>y</code> (rows)
</p>


<h3>See Also</h3>

<p>Other transfuncs: <code><a href="#topic+spatiallong">spatiallong</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 1, 1, 2, 2, 2, 3, 3, 4)
y &lt;- c(1, 2, 3, 1, 2, 3, 1, 2, 3)
z &lt;- c(3, 4, 2, 3, NA, 5, 6, 3, 1)

spatialwide(x, y, z, digits = 3)

</code></pre>

<hr>
<h2 id='spitcenter'>Center determination for hexahedrons</h2><span id='topic+spitcenter'></span>

<h3>Description</h3>

<p>A hexahedron is a three dimensional shape that is defined by 6 faces and 8 corner points.
<code>spitcenter</code> determines a center point for an input hexahedron by calculating the mean
of the maximal extent on all three axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spitcenter(hex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spitcenter_+3A_hex">hex</code></td>
<td>
<p>dataframe with three columns and eight rows to define a hexahedron by its corner
point coordinates x, y and z</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with the spatial coordinates of the center point of the input hexahedron
</p>


<h3>See Also</h3>

<p>Other centerdetfuncs: <code><a href="#topic+spitcenternatlist">spitcenternatlist</a></code>,
<code><a href="#topic+spitcenternat">spitcenternat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hexatestdf &lt;- data.frame(
  x = c(0,1,0,4,5,5,5,5),
  y = c(1,1,4,4,1,1,4,4),
  z = c(4,8,4,9,4,8,4,6)
)

center &lt;- spitcenter(hexatestdf)

#library(rgl)
#plot3d(
# hexatestdf$x, hexatestdf$y, hexatestdf$z,
# type = "p",
# xlab = "x", ylab = "y", zlab = "z"
#)
#plot3d(
#  center[1], center[2], center[3],
#  type = "p",
#  col = "red",
#  add = TRUE
#)

</code></pre>

<hr>
<h2 id='spitcenternat'>Center determination for rectangles whose tops and bottoms are defined by irregular surfaces (3D)</h2><span id='topic+spitcenternat'></span>

<h3>Description</h3>

<p><code>spitcenternat</code> first of all calculates the horizontal center of an input rectangle.
Then it determines the vertical positions of the center points in relation to a surface stack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spitcenternat(hex, maplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spitcenternat_+3A_hex">hex</code></td>
<td>
<p>data.frame with the 2D corners of the rectangle defined by four points</p>
</td></tr>
<tr><td><code id="spitcenternat_+3A_maplist">maplist</code></td>
<td>
<p>list of data.frames which contain the points that make up the surfaces</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the spatial coordinates of the center points
</p>


<h3>See Also</h3>

<p>Other centerdetfuncs: <code><a href="#topic+spitcenternatlist">spitcenternatlist</a></code>,
<code><a href="#topic+spitcenter">spitcenter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
  x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
  y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
  z = c(0.9+0.05*rnorm(6), 0.9+0.05*rnorm(14), 1.3+0.05*rnorm(14), 1.2+0.05*rnorm(6))
)

df2 &lt;- data.frame(
    x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
    y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
    z = c(0.6+0.05*rnorm(6), 0.6+0.05*rnorm(14), 1.0+0.05*rnorm(14), 0.9+0.05*rnorm(6))
)

df3 &lt;- data.frame(
    x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
    y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
    z = c(0.3+0.05*rnorm(6), 0.3+0.05*rnorm(14), 0.7+0.05*rnorm(14), 0.6+0.05*rnorm(6))
)

lpoints &lt;- list(df1, df2, df3)

maps &lt;- kriglist(lpoints, lags = 3, model = "spherical")

hexatestdf &lt;- data.frame(
    x = c(1, 1, 1, 1, 2, 2, 2, 2),
    y = c(0, 1, 0, 1, 0, 1, 0, 1)
)

spitcenternat(hexatestdf, maps)

</code></pre>

<hr>
<h2 id='spitcenternatlist'>Center determination for rectangles whose tops and bottoms are defined by irregular
surfaces (3D) for multiple data.frames in a list</h2><span id='topic+spitcenternatlist'></span>

<h3>Description</h3>

<p><code>spitcenternatlist</code> works as <code><a href="#topic+spitcenternat">spitcenternat</a></code> but not just for a
single data.frame but for a list of data.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spitcenternatlist(hexlist, maplist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spitcenternatlist_+3A_hexlist">hexlist</code></td>
<td>
<p>list of data.frames with the 2D corners of the rectangles</p>
</td></tr>
<tr><td><code id="spitcenternatlist_+3A_maplist">maplist</code></td>
<td>
<p>list of data.frames which contain the points that make up the surfaces</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data.frames with the spatial coordinates of the center points
</p>


<h3>See Also</h3>

<p>Other centerdetfuncs: <code><a href="#topic+spitcenternat">spitcenternat</a></code>,
<code><a href="#topic+spitcenter">spitcenter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
  y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
  z = c(0.9+0.05*rnorm(6), 0.9+0.05*rnorm(14), 1.3+0.05*rnorm(14), 1.2+0.05*rnorm(6))
)

df2 &lt;- data.frame(
    x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
    y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
    z = c(0.6+0.05*rnorm(6), 0.6+0.05*rnorm(14), 1.0+0.05*rnorm(14), 0.9+0.05*rnorm(6))
)

df3 &lt;- data.frame(
    x = c(rep(0, 6), seq(0.2, 2.8, 0.2), seq(0.2, 2.8, 0.2), rep(3,6)),
    y = c(seq(0, 1, 0.2), rep(0, 14), rep(1, 14), seq(0, 1, 0.2)),
    z = c(0.3+0.05*rnorm(6), 0.3+0.05*rnorm(14), 0.7+0.05*rnorm(14), 0.6+0.05*rnorm(6))
)

lpoints &lt;- list(df1, df2, df3)

maps &lt;- kriglist(lpoints, lags = 3, model = "spherical")

hexatestdf1 &lt;- data.frame(
  x = c(1, 1, 1, 1, 2, 2, 2, 2),
  y = c(0, 1, 0, 1, 0, 1, 0, 1)
)

hexatestdf2 &lt;- data.frame(
  x = c(0, 0, 0, 0, 1, 1, 1, 1),
  y = c(0, 1, 0, 1, 0, 1, 0, 1)
)

hexs &lt;- list(hexatestdf1, hexatestdf2)

spitcenternatlist(hexs, maps)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
