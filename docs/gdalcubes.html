<!DOCTYPE html><html><head><title>Help for package gdalcubes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gdalcubes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.copy_cube'><p>Create a data cube proxy object copy</p></a></li>
<li><a href='#add_collection_format'><p>Download and install an image collection format from a URL</p></a></li>
<li><a href='#add_images'><p>Add images to an existing image collection</p></a></li>
<li><a href='#aggregate_space'><p>Spatial aggregation of data cubes</p></a></li>
<li><a href='#aggregate_time'><p>Aggregate data cube time series to lower temporal resolution</p></a></li>
<li><a href='#animate'><p>Animate a data cube as an image time series</p></a></li>
<li><a href='#apply_pixel'><p>Apply a function over (multi-band) pixels</p></a></li>
<li><a href='#apply_pixel.array'><p>Apply a function over pixels in a four-dimensional (band, time, y, x) array</p></a></li>
<li><a href='#apply_pixel.cube'><p>Apply arithmetic expressions over all pixels of a data cube</p></a></li>
<li><a href='#apply_time'><p>Apply a function over (multi-band) pixel time series</p></a></li>
<li><a href='#apply_time.array'><p>Apply a function over pixel time series in a four-dimensional (band, time, y, x) array</p></a></li>
<li><a href='#apply_time.cube'><p>Apply a user-defined R function over (multi-band) pixel time series</p></a></li>
<li><a href='#as_array'><p>Convert a data cube to an in-memory R array</p></a></li>
<li><a href='#as_json'><p>Query data cube properties</p></a></li>
<li><a href='#as.data.frame.cube'><p>Convert a data cube to a data.frame</p></a></li>
<li><a href='#bands'><p>Query data cube properties</p></a></li>
<li><a href='#chunk_apply'><p>Apply an R function on chunks of a data cube</p></a></li>
<li><a href='#collection_formats'><p>List predefined image collection formats</p></a></li>
<li><a href='#create_image_collection'><p>Create an image collection from a set of GDAL datasets or files</p></a></li>
<li><a href='#crop'><p>Crop data cube extent by space and/or time</p></a></li>
<li><a href='#cube_view'><p>Create or update a spatiotemporal data cube view</p></a></li>
<li><a href='#dim.cube'><p>Query data cube properties</p></a></li>
<li><a href='#dimension_bounds'><p>Query coordinate bounds for all dimensions of a data cube</p></a></li>
<li><a href='#dimension_values'><p>Query coordinate values for all dimensions of a data cube</p></a></li>
<li><a href='#dimensions'><p>Query data cube properties</p></a></li>
<li><a href='#extent'><p>Derive the spatiotemporal extent of an image collection</p></a></li>
<li><a href='#extract_geom'><p>Extract values from a data cube by spatial or spatiotemporal features</p></a></li>
<li><a href='#fill_time'><p>Fill NA data cube pixels by simple time series interpolation</p></a></li>
<li><a href='#filter_geom'><p>Filter data cube pixels by a polygon</p></a></li>
<li><a href='#filter_pixel'><p>Filter data cube pixels by a user-defined predicate on band values</p></a></li>
<li><a href='#gdalcubes'><p>gdalcubes: Earth Observation Data Cubes from Satellite Image Collections</p></a></li>
<li><a href='#gdalcubes_gdal_has_geos'><p>Check if GDAL was built with GEOS</p></a></li>
<li><a href='#gdalcubes_gdalformats'><p>Get available GDAL drivers</p></a></li>
<li><a href='#gdalcubes_gdalversion'><p>Get the GDAL version used by gdalcubes</p></a></li>
<li><a href='#gdalcubes_options'><p>Set or read global options of the gdalcubes package</p></a></li>
<li><a href='#gdalcubes_selection'><p>Subsetting data cubes</p></a></li>
<li><a href='#gdalcubes_set_gdal_config'><p>Set GDAL config options</p></a></li>
<li><a href='#image_collection'><p>Load an existing image collection from a file</p></a></li>
<li><a href='#image_mask'><p>Create a mask for images in a raster data cube</p></a></li>
<li><a href='#join_bands'><p>Join bands of two identically shaped data cubes</p></a></li>
<li><a href='#json_cube'><p>Read a data cube from a json description file</p></a></li>
<li><a href='#memsize'><p>Query data cube properties</p></a></li>
<li><a href='#names.cube'><p>Query data cube properties</p></a></li>
<li><a href='#nbands'><p>Query data cube properties</p></a></li>
<li><a href='#ncdf_cube'><p>Read a data cube from an existing netCDF file</p></a></li>
<li><a href='#nt'><p>Query data cube properties</p></a></li>
<li><a href='#nx'><p>Query data cube properties</p></a></li>
<li><a href='#ny'><p>Query data cube properties</p></a></li>
<li><a href='#pack_minmax'><p>Helper function to define packed data exports by min / max values</p></a></li>
<li><a href='#plot.cube'><p>Plot a gdalcubes data cube</p></a></li>
<li><a href='#predict.cube'><p>Model prediction</p></a></li>
<li><a href='#print.cube'><p>Print data cube information</p></a></li>
<li><a href='#print.cube_view'><p>Print data cube view information</p></a></li>
<li><a href='#print.image_collection'><p>Print image collection information</p></a></li>
<li><a href='#proj4'><p>Query data cube properties</p></a></li>
<li><a href='#raster_cube'><p>Create a data cube from an image collection</p></a></li>
<li><a href='#read_chunk_as_array'><p>Read chunk data of a data cube from stdin or a file</p></a></li>
<li><a href='#reduce_space'><p>Reduce multidimensional data over space</p></a></li>
<li><a href='#reduce_space.array'><p>Apply a function over space and bands in a four-dimensional (band, time, y, x) array and reduce</p>
spatial dimensions</a></li>
<li><a href='#reduce_space.cube'><p>Reduce a data cube over spatial (x,y or lat,lon) dimensions</p></a></li>
<li><a href='#reduce_time'><p>Reduce multidimensional data over time</p></a></li>
<li><a href='#reduce_time.array'><p>Apply a function over time and bands in a four-dimensional (band, time, y, x) array and reduce time dimension</p></a></li>
<li><a href='#reduce_time.cube'><p>Reduce a data cube over the time dimension</p></a></li>
<li><a href='#rename_bands'><p>Rename bands of a data cube</p></a></li>
<li><a href='#select_bands'><p>Select bands of a data cube</p></a></li>
<li><a href='#select_time'><p>Select time slices of a data cube</p></a></li>
<li><a href='#size'><p>Query data cube properties</p></a></li>
<li><a href='#slice_space'><p>Extract a single time series (spatial slice) from a data cube</p></a></li>
<li><a href='#slice_time'><p>Extract a single time slice from a data cube</p></a></li>
<li><a href='#srs'><p>Query data cube properties</p></a></li>
<li><a href='#st_as_stars.cube'><p>Coerce gdalcubes object into a stars object</p></a></li>
<li><a href='#stac_image_collection'><p>Create an image collection from a STAC feature collection</p></a></li>
<li><a href='#stack_cube'><p>Create a data cube from a set of images with the same spatial extent and spatial reference system</p></a></li>
<li><a href='#window_space'><p>Apply a moving window (focal) operation or a convolution kernel over spatial dimensions of a data cube.</p></a></li>
<li><a href='#window_time'><p>Apply a moving window operation over the time dimension of a data cube</p></a></li>
<li><a href='#write_chunk_from_array'><p>Write chunk data of a cube to stdout or a file</p></a></li>
<li><a href='#write_ncdf'><p>Export a data cube as netCDF file(s)</p></a></li>
<li><a href='#write_tif'><p>Export a data cube as a collection of GeoTIFF files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Earth Observation Data Cubes from Satellite Image Collections</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Processing collections of Earth observation images as on-demand multispectral, multitemporal raster data cubes. Users
    define cubes by spatiotemporal extent, resolution, and spatial reference system and let 'gdalcubes' automatically apply cropping, reprojection, and 
    resampling using the 'Geospatial Data Abstraction Library' ('GDAL'). Implemented functions on data cubes include reduction over space and time, 
    applying arithmetic expressions on pixel band values, moving window aggregates over time, filtering by space, time, bands, and predicates on pixel values, 
    exporting data cubes as 'netCDF' or 'GeoTIFF' files, plotting, and extraction from spatial and or spatiotemporal features.  
    All computational parts are implemented in C++, linking to the 'GDAL', 'netCDF', 'CURL', and 'SQLite' libraries. 
    See Appel and Pebesma (2019) &lt;<a href="https://doi.org/10.3390%2Fdata4030092">doi:10.3390/data4030092</a>&gt; for further details.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, jsonlite, ncdf4</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/appelmar/gdalcubes">https://github.com/appelmar/gdalcubes</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/appelmar/gdalcubes/issues/">https://github.com/appelmar/gdalcubes/issues/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, stars, av, gifski, sf, tinytest, lubridate</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file inst/COPYRIGHTS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GDAL (&gt;= 2.0.1), PROJ (&gt;= 4.8.0), netcdf, sqlite3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 20:35:23 UTC; marius</td>
</tr>
<tr>
<td>Author:</td>
<td>Marius Appel <a href="https://orcid.org/0000-0001-5281-3896"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Roger Bivand [ctb],
  Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Lewis Van Winkle [cph],
  Ole Christian Eidheim [cph],
  Howard Hinnant [cph],
  Adrian Colomitchi [cph],
  Florian Dang [cph],
  Paul Thompson [cph],
  Tomasz Kamiński [cph],
  Dropbox, Inc. [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marius Appel &lt;marius.appel@hs-bochum.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.copy_cube'>Create a data cube proxy object copy</h2><span id='topic+.copy_cube'></span>

<h3>Description</h3>

<p>Copy a data cube proxy object without copying any data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.copy_cube(cube)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".copy_cube_+3A_cube">cube</code></td>
<td>
<p>source data cube proxy object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal function copies the complete processing chain / graph of a data cube but does not copy any data
It is used internally to avoid in-place modification for operations with potential side effects on source data cubes.
</p>


<h3>Value</h3>

<p>copied data cube proxy object
</p>

<hr>
<h2 id='add_collection_format'>Download and install an image collection format from a URL</h2><span id='topic+add_collection_format'></span>

<h3>Description</h3>

<p>Download and install an image collection format from a URL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_collection_format(url, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_collection_format_+3A_url">url</code></td>
<td>
<p>URL pointing to the collection format JSON file</p>
</td></tr>
<tr><td><code id="add_collection_format_+3A_name">name</code></td>
<td>
<p>optional name used to refer to the collection format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the collection format name will be derived from the basename of the URL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
add_collection_format(
   "https://raw.githubusercontent.com/appelmar/gdalcubes_cpp/dev/formats/Sentinel1_IW_GRD.json")

</code></pre>

<hr>
<h2 id='add_images'>Add images to an existing image collection</h2><span id='topic+add_images'></span>

<h3>Description</h3>

<p>This function adds provided files or GDAL dataset identifiers and to an existing image collection by extracting datetime, image identifiers, and band information according to the collection's format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_images(
  image_collection,
  files,
  unroll_archives = TRUE,
  out_file = "",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_images_+3A_image_collection">image_collection</code></td>
<td>
<p>image_collection object or path to an existing collection file</p>
</td></tr>
<tr><td><code id="add_images_+3A_files">files</code></td>
<td>
<p>character vector with paths to image files on disk or any GDAL dataset identifiers (including virtual file systems and higher level drivers or GDAL subdatasets)</p>
</td></tr>
<tr><td><code id="add_images_+3A_unroll_archives">unroll_archives</code></td>
<td>
<p>automatically convert .zip, .tar archives and .gz compressed files to GDAL virtual file system dataset identifiers (e.g. by prepending /vsizip/) and add contained files to the list of considered files</p>
</td></tr>
<tr><td><code id="add_images_+3A_out_file">out_file</code></td>
<td>
<p>path to output file, an empty string (the default) will update the collection in-place, whereas images will be added to a new copy of the image collection at the given location otherwise.</p>
</td></tr>
<tr><td><code id="add_images_+3A_quiet">quiet</code></td>
<td>
<p>logical; if TRUE, do not print resulting image collection if return value is not assigned to a variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>image collection proxy object, which can be used to create a data cube using <code><a href="#topic+raster_cube">raster_cube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
L8_col = create_image_collection(L8_files[1:12], "L8_L1TP") 
add_images(L8_col, L8_files[13:24])
</code></pre>

<hr>
<h2 id='aggregate_space'>Spatial aggregation of data cubes</h2><span id='topic+aggregate_space'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which applies an aggregation function to reduce the spatial resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_space(cube, dx, dy, method = "mean", fact = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_space_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="aggregate_space_+3A_dx">dx</code></td>
<td>
<p>numeric value; new spatial resolution in x direction</p>
</td></tr>
<tr><td><code id="aggregate_space_+3A_dy">dy</code></td>
<td>
<p>numeric value; new spatial resolution in y direction</p>
</td></tr>
<tr><td><code id="aggregate_space_+3A_method">method</code></td>
<td>
<p>aggregation method, one of &quot;mean&quot;, &quot;min&quot;, &quot;max&quot;, &quot;median&quot;, &quot;count&quot;, &quot;sum&quot;, &quot;prod&quot;, &quot;var&quot;, and &quot;sd&quot;</p>
</td></tr>
<tr><td><code id="aggregate_space_+3A_fact">fact</code></td>
<td>
<p>simple integer factor defining how many cells (per axis) become aggregated to a single new cell, can be used instead of dx and dy</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reduces the spatial resolution of a data cube by applying an aggregation function to smaller blocks of pixels.   
</p>
<p>The size of the cube may be expanded automatically in all directions if the original extent is not divisible by the new size of pixels.
</p>
<p>Notice that if boundaries of the target cube do not align with the boundaries of the input cube (for example, if aggregating from 10m to 15m spatial resolution), pixels of
the input cube will contribute to the output pixel that contains its center coordinate. If the center coordinate is exactly on a boundary, the input pixel will contribute to 
the right / bottom pixel of the output cube.
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
                          bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", dx = 500, dy=500, dt="P3M", aggregation = "median")
L8.cube = raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.5km = aggregate_space(L8.rgb, 5000,5000, "mean")
L8.5km


plot(L8.5km, rgb=3:1, zlim=c(5000,12000))


</code></pre>

<hr>
<h2 id='aggregate_time'>Aggregate data cube time series to lower temporal resolution</h2><span id='topic+aggregate_time'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which applies an aggregation function over pixel time series to lower temporal resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_time(cube, dt, method = "mean", fact = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_time_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="aggregate_time_+3A_dt">dt</code></td>
<td>
<p>character; new temporal resolution, datetime period string, e.g. &quot;P1M&quot;</p>
</td></tr>
<tr><td><code id="aggregate_time_+3A_method">method</code></td>
<td>
<p>aggregation method, one of &quot;mean&quot;, &quot;min&quot;, &quot;max&quot;, &quot;median&quot;, &quot;count&quot;, &quot;sum&quot;, &quot;prod&quot;, &quot;var&quot;, and &quot;sd&quot;</p>
</td></tr>
<tr><td><code id="aggregate_time_+3A_fact">fact</code></td>
<td>
<p>simple integer factor defining how many cells become aggregated to a single new cell, can be used instead of dt</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to aggregate time series to lower resolution or to regularize
a data cube with irregular (labeled) time axis. It is possible to change the unit of the temporal resolution (e.g. to create monthly composites from daily images).
The size of the cube may be expanded automatically if the original temporal extent is not divisible by the new temporal size of pixels.
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P3M", aggregation = "median")
L8.cube = raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.two_monthly = aggregate_time(L8.rgb, "P6M", "min")
L8.two_monthly


plot(L8.two_monthly, rgb=3:1, zlim=c(5000,12000))


</code></pre>

<hr>
<h2 id='animate'>Animate a data cube as an image time series</h2><span id='topic+animate'></span>

<h3>Description</h3>

<p>This function can animate data cube time series as mp4 videos or animated GIFs.
Depending on the desired output format, either the <code>av</code> or the <code>gifski</code>
package is needed to create mp4 and GIF animations respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>animate(
  x,
  ...,
  fps = 1,
  loop = TRUE,
  width = 800,
  height = 800,
  save_as = tempfile(fileext = ".gif"),
  preview = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_+3A_x">x</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
<tr><td><code id="animate_+3A_...">...</code></td>
<td>
<p>parameters passed to plot.cube</p>
</td></tr>
<tr><td><code id="animate_+3A_fps">fps</code></td>
<td>
<p>frames per second of the animation</p>
</td></tr>
<tr><td><code id="animate_+3A_loop">loop</code></td>
<td>
<p>how many iterations, TRUE = infinite</p>
</td></tr>
<tr><td><code id="animate_+3A_width">width</code></td>
<td>
<p>width (in pixels) of the animation</p>
</td></tr>
<tr><td><code id="animate_+3A_height">height</code></td>
<td>
<p>height (in pixels) of the animation</p>
</td></tr>
<tr><td><code id="animate_+3A_save_as">save_as</code></td>
<td>
<p>character path where the animation shall be stored, must end with &quot;.mp4&quot; or &quot;.gif&quot;</p>
</td></tr>
<tr><td><code id="animate_+3A_preview">preview</code></td>
<td>
<p>logical; preview the animation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Animations can be created for single band data cubes or RGB plots of multi-band data cubes (by providing the argument rgb) only.
</p>


<h3>Value</h3>

<p>character; path pointing to the the created file
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cube">plot.cube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE)
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4,
                          bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P16D")

animate(select_bands(raster_cube(L8.col, v), c("B02", "B03", "B04")), rgb=3:1,
        zlim=c(0,20000), fps=1, loop=1)

animate(select_bands(raster_cube(L8.col, v), c("B05")), col=terrain.colors, key.pos=1)

</code></pre>

<hr>
<h2 id='apply_pixel'>Apply a function over (multi-band) pixels</h2><span id='topic+apply_pixel'></span>

<h3>Description</h3>

<p>This generic function applies a function on pixels of a data cube, an R array, or other classes if implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_pixel(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_pixel_+3A_x">x</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code id="apply_pixel_+3A_...">...</code></td>
<td>
<p>additional arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value and type depend on the class of x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_pixel.cube">apply_pixel.cube</a></code>
</p>
<p><code><a href="#topic+apply_pixel.array">apply_pixel.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
              
L8.col = image_collection(file.path(tempdir(), "L8.db"))
apply_pixel(raster_cube(L8.col, v), "(B05-B04)/(B05+B04)", "NDVI") 



d &lt;- c(4,16,128,128)
x &lt;- array(rnorm(prod(d)), d)
y &lt;- apply_pixel(x, function(v) {
  v[1] + v[2] + v[3] - v[4]
})

</code></pre>

<hr>
<h2 id='apply_pixel.array'>Apply a function over pixels in a four-dimensional (band, time, y, x) array</h2><span id='topic+apply_pixel.array'></span>

<h3>Description</h3>

<p>Apply a function over pixels in a four-dimensional (band, time, y, x) array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
apply_pixel(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_pixel.array_+3A_x">x</code></td>
<td>
<p>four-dimensional input array with dimensions band, time, y, x (in this order)</p>
</td></tr>
<tr><td><code id="apply_pixel.array_+3A_fun">FUN</code></td>
<td>
<p>function that receives a vector of band values in a one-dimensional array</p>
</td></tr>
<tr><td><code id="apply_pixel.array_+3A_...">...</code></td>
<td>
<p>further arguments passed to FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN is expected to produce a numeric vector (or scalar) where elements are interpreted as new bands in the result.
</p>


<h3>Note</h3>

<p>This is a helper function that uses the same dimension ordering as gdalcubes. It can be used to simplify 
the application of R functions e.g. over time series in a data cube.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(4,16,32,32)
x &lt;- array(rnorm(prod(d)), d)
y &lt;- apply_pixel(x, function(v) {
  v[1] + v[2] + v[3] - v[4]
})
dim(y)
</code></pre>

<hr>
<h2 id='apply_pixel.cube'>Apply arithmetic expressions over all pixels of a data cube</h2><span id='topic+apply_pixel.cube'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which applies arithmetic expressions over all pixels of a data cube. Expressions may access band values by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
apply_pixel(
  x,
  expr,
  names = NULL,
  keep_bands = FALSE,
  ...,
  FUN,
  load_pkgs = FALSE,
  load_env = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_pixel.cube_+3A_x">x</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="apply_pixel.cube_+3A_expr">expr</code></td>
<td>
<p>character vector with one or more arithmetic expressions (see Details)</p>
</td></tr>
<tr><td><code id="apply_pixel.cube_+3A_names">names</code></td>
<td>
<p>optional character vector with the same length as expr to specify band names for the output cube</p>
</td></tr>
<tr><td><code id="apply_pixel.cube_+3A_keep_bands">keep_bands</code></td>
<td>
<p>logical; keep bands of input data cube, defaults to FALSE, i.e. original bands will be dropped</p>
</td></tr>
<tr><td><code id="apply_pixel.cube_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="apply_pixel.cube_+3A_fun">FUN</code></td>
<td>
<p>user-defined R function that is applied on all pixels (see Details)</p>
</td></tr>
<tr><td><code id="apply_pixel.cube_+3A_load_pkgs">load_pkgs</code></td>
<td>
<p>logical or character; if TRUE, all currently attached packages will be attached automatically before executing FUN in spawned R processes, specific packages can alternatively be provided as a character vector.</p>
</td></tr>
<tr><td><code id="apply_pixel.cube_+3A_load_env">load_env</code></td>
<td>
<p>logical or environment; if TRUE, the current global environment will be restored automatically before executing FUN in spawned R processes, can be set to a custom environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can either apply simple arithmetic C expressions given as a character vector (expr argument), or apply a custom R reducer function if FUN is provided.
</p>
<p>In the former case, gdalcubes uses the <a href="https://github.com/codeplea/tinyexpr">tinyexpr library</a> to evaluate expressions in C / C++, you can look at the <a href="https://github.com/codeplea/tinyexpr#functions-supported">library documentation</a>
to see what kind of expressions you can execute. Pixel band values can be accessed by name. Predefined variables that can be used within the expression include integer pixel indexes (<code>ix</code>, <code>iy</code>, <code>it</code>), and 
pixel coordinates (<code>left</code>, <code>right</code>, <code>top</code>, <code>bottom</code>), <code>t0</code>, <code>t1</code>), where the last two values are provided seconds since epoch time.
</p>
<p>FUN receives values of the bands from one pixel as a (named) vector and should return a numeric vector with identical length for all pixels. Elements of the
result vectors will be interpreted as bands in the result data cube. Notice that by default, since FUN is executed in a separate
R process, it cannot access any variables from outside and required packages must be loaded within FUN. To restore the current environment and
automatically load packages, set <code>load_env</code> and/or <code>load_pkgs</code> to <code>TRUE</code>.
</p>
<p>For more details and examples on how to write user-defined functions, please refer to the gdalcubes website 
at <a href="https://gdalcubes.github.io/source/concepts/udfs.html">https://gdalcubes.github.io/source/concepts/udfs.html</a>.
</p>


<h3>Value</h3>

<p>a proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

# 1. Apply a C expression
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.cube = select_bands(L8.cube, c("B04", "B05")) 
L8.ndvi = apply_pixel(L8.cube, "(B05-B04)/(B05+B04)", "NDVI") 
L8.ndvi


plot(L8.ndvi)


# 2. Apply a user defined R function
L8.ndvi.noisy = apply_pixel(L8.cube, names="NDVI_noisy", 
   FUN=function(x) {
       rnorm(1, 0, 0.1) + (x["B05"]-x["B04"])/(x["B05"]+x["B04"])
   })
L8.ndvi.noisy



plot(L8.ndvi.noisy)

 
</code></pre>

<hr>
<h2 id='apply_time'>Apply a function over (multi-band) pixel time series</h2><span id='topic+apply_time'></span>

<h3>Description</h3>

<p>This generic function applies a function on pixel time series of a data cube, an R array, or other classes if implemented.
The resulting object is expected to have the same spatial and temporal shape as the input, i.e., no reduction is performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_time(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_time_+3A_x">x</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code id="apply_time_+3A_...">...</code></td>
<td>
<p>additional arguments passed to method implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value and type depend on the class of x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_time.cube">apply_time.cube</a></code>
</p>
<p><code><a href="#topic+apply_time.array">apply_time.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. input is data cube
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.cube = select_bands(L8.cube, c("B04", "B05")) 
L8.ndvi = apply_pixel(L8.cube, "(B05-B04)/(B05+B04)", "NDVI")

# Apply a user defined R function
apply_time(L8.ndvi, names="NDVI_residuals", 
   FUN=function(x) {
      y = x["NDVI",]
      if (sum(is.finite(y)) &lt; 3) {
         return(rep(NA,ncol(x)))
      }
      t = 1:ncol(x)
      return(predict(lm(y ~ t)) -  x["NDVI",])})

# 2. input is array
d &lt;- c(4,16,32,32)
x &lt;- array(rnorm(prod(d)), d)
z &lt;- apply_time(x, function(v) {
  y = matrix(NA, ncol=ncol(v), nrow=2)
  y[1,] = (v[1,] + v[2,]) / 2
  y[2,] = (v[3,] + v[4,]) / 2
  y
})
dim(z)

</code></pre>

<hr>
<h2 id='apply_time.array'>Apply a function over pixel time series in a four-dimensional (band, time, y, x) array</h2><span id='topic+apply_time.array'></span>

<h3>Description</h3>

<p>Apply a function over pixel time series in a four-dimensional (band, time, y, x) array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
apply_time(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_time.array_+3A_x">x</code></td>
<td>
<p>four-dimensional input array with dimensions band, time, y, x (in this order)</p>
</td></tr>
<tr><td><code id="apply_time.array_+3A_fun">FUN</code></td>
<td>
<p>function that receives a vector of band values in a one-dimensional array</p>
</td></tr>
<tr><td><code id="apply_time.array_+3A_...">...</code></td>
<td>
<p>further arguments passed to FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN is expected to produce a matrix (or vector if result has only one band) where rows are interpreted as new bands and columns represent time.
</p>


<h3>Note</h3>

<p>This is a helper function that uses the same dimension ordering as gdalcubes. It can be used to simplify 
the application of R functions e.g. over time series in a data cube.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(4,16,32,32)
x &lt;- array(rnorm(prod(d)), d)
z &lt;- apply_time(x, function(v) {
  y = matrix(NA, ncol=ncol(v), nrow=2)
  y[1,] = (v[1,] + v[2,]) / 2
  y[2,] = (v[3,] + v[4,]) / 2
  y
})
dim(z)
</code></pre>

<hr>
<h2 id='apply_time.cube'>Apply a user-defined R function over (multi-band) pixel time series</h2><span id='topic+apply_time.cube'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which applies a user-defined R function over all pixel time series of a data cube. 
In contrast to <code><a href="#topic+reduce_time">reduce_time</a></code>, the time dimension is not reduced, i.e., resulting time series
must have identical length as the input data cube but may contain a different number of bands / variables.
Example uses of this function may include time series decompositions, cumulative sums / products, smoothing, sophisticated
NA filling, or similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
apply_time(
  x,
  names = NULL,
  keep_bands = FALSE,
  FUN,
  load_pkgs = FALSE,
  load_env = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_time.cube_+3A_x">x</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="apply_time.cube_+3A_names">names</code></td>
<td>
<p>optional character vector to specify band names for the output cube</p>
</td></tr>
<tr><td><code id="apply_time.cube_+3A_keep_bands">keep_bands</code></td>
<td>
<p>logical; keep bands of input data cube, defaults to FALSE, i.e., original bands will be dropped</p>
</td></tr>
<tr><td><code id="apply_time.cube_+3A_fun">FUN</code></td>
<td>
<p>user-defined R function that is applied on all pixel time series (see Details)</p>
</td></tr>
<tr><td><code id="apply_time.cube_+3A_load_pkgs">load_pkgs</code></td>
<td>
<p>logical or character; if TRUE, all currently attached packages will be attached automatically before executing FUN in spawned R processes, specific packages can alternatively be provided as a character vector.</p>
</td></tr>
<tr><td><code id="apply_time.cube_+3A_load_env">load_env</code></td>
<td>
<p>logical or environment; if TRUE, the current global environment will be restored automatically before executing FUN in spawned R processes, can be set to a custom environment.</p>
</td></tr>
<tr><td><code id="apply_time.cube_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN receives a single (multi-band) pixel time series as a matrix with rows corresponding to bands and columns corresponding to time.
In general, the function must return a matrix with the same number of columns. If the result contains only a single band, it may alternatively return a vector 
with length identical to the length of the input time series (number of columns of the input).
</p>
<p>For more details and examples on how to write user-defined functions, please refer to the gdalcubes website 
at <a href="https://gdalcubes.github.io/source/concepts/udfs.html">https://gdalcubes.github.io/source/concepts/udfs.html</a>.
</p>


<h3>Value</h3>

<p>a proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.cube = select_bands(L8.cube, c("B04", "B05")) 
L8.ndvi = apply_pixel(L8.cube, "(B05-B04)/(B05+B04)", "NDVI")

# Apply a user defined R function
L8.ndvi.resid = apply_time(L8.ndvi, names="NDVI_residuals", 
   FUN=function(x) {
      y = x["NDVI",]
      if (sum(is.finite(y)) &lt; 3) {
         return(rep(NA,ncol(x)))
      }
      t = 1:ncol(x)
      return(predict(lm(y ~ t)) -  x["NDVI",])
   })
L8.ndvi.resid


plot(L8.ndvi.resid)

 
</code></pre>

<hr>
<h2 id='as_array'>Convert a data cube to an in-memory R array</h2><span id='topic+as_array'></span>

<h3>Description</h3>

<p>Convert a data cube to an in-memory R array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_array(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_array_+3A_x">x</code></td>
<td>
<p>data cube</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Four dimensional array with dimensions band, t, y, x
</p>


<h3>Note</h3>

<p>Depending on the data cube size, this function may require substantial amounts of main memory, i.e.
it makes sense for small data cubes only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-05"),
              srs="EPSG:32618", nx = 100, ny=100, dt="P1M")
x = as_array(select_bands(raster_cube(L8.col, v), c("B04", "B05")))
dim(x)
dimnames(x)

</code></pre>

<hr>
<h2 id='as_json'>Query data cube properties</h2><span id='topic+as_json'></span>

<h3>Description</h3>

<p>gdalcubes internally uses a graph to serialize data cubes (including chained operations on cubes). This function derives a JSON
representation, which can be used to save data cube objects without pixel data to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_json(obj, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_json_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
<tr><td><code id="as_json_+3A_file">file</code></td>
<td>
<p>optional output file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If file is NULL, the function returns a JSON string representing a graph that can be used to recreate the same
chain of gdalcubes operations even in a different R sessions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-04"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
cat(as_json(select_bands(raster_cube(L8.col, v), c("B04", "B05"))))
</code></pre>

<hr>
<h2 id='as.data.frame.cube'>Convert a data cube to a data.frame</h2><span id='topic+as.data.frame.cube'></span>

<h3>Description</h3>

<p>Convert a data cube to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
as.data.frame(x, ..., complete_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.cube_+3A_x">x</code></td>
<td>
<p>data cube object</p>
</td></tr>
<tr><td><code id="as.data.frame.cube_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="as.data.frame.cube_+3A_complete_only">complete_only</code></td>
<td>
<p>logical; if TRUE, remove rows with one or more missing values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with bands / variables of the cube as columns and pixels as rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-05"),
              srs="EPSG:32618", nx = 100, ny=100, dt="P1M")
x = select_bands(raster_cube(L8.col, v), c("B04", "B05"))
df = as.data.frame(x, complete_only = TRUE)
head(df)

</code></pre>

<hr>
<h2 id='bands'>Query data cube properties</h2><span id='topic+bands'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bands(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bands_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with rows representing the bands and columns representing properties of a band (name, type, scale, offset, unit)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
bands(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='chunk_apply'>Apply an R function on chunks of a data cube</h2><span id='topic+chunk_apply'></span>

<h3>Description</h3>

<p>Apply an R function on chunks of a data cube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk_apply(cube, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_apply_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="chunk_apply_+3A_f">f</code></td>
<td>
<p>R function to apply over all chunks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function internally creates a gdalcubes stream data cube, which streams
data of a chunk to a new R process. For reading data, the function typically 
calls <code>x &lt;- read_chunk_as_array()</code> which then results in a 4 dimensional (band, time, y, x) array.
Similarly <code>write_chunk_from_array(x)</code> will write a result array as a chunk in the resulting data cube.
The chunk size of the input cube is important to control how the function will be exposed to the data cube. For example,
if you want to apply an R function over complete pixel time series, you must define the chunk size argument in <code><a href="#topic+raster_cube">raster_cube</a></code>
to make sure that chunk contain the correct parts of the data.
</p>


<h3>Value</h3>

<p>a proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4,
                          bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
                          srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v)
L8.cube = select_bands(L8.cube, c("B04", "B05"))
f &lt;- function() {
  x &lt;- read_chunk_as_array()
  out &lt;- reduce_time(x, function(x) {
    cor(x[1,], x[2,], use="na.or.complete", method = "kendall")
  }) 
  write_chunk_from_array(out)
}
L8.cor = chunk_apply(L8.cube, f)

</code></pre>

<hr>
<h2 id='collection_formats'>List predefined image collection formats</h2><span id='topic+collection_formats'></span>

<h3>Description</h3>

<p>gdalcubes comes with some predefined collection formats e.g. to scan Sentinel 2 data. This function lists available formats  including brief descriptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collection_formats(print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collection_formats_+3A_print">print</code></td>
<td>
<p>logical; should available formats and their descriptions be printed nicely, defaults to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Image collection formats define how individual files / GDAL datasets relate to an image collection, i.e., 
which bands they contain, to which image they belong, and how to derive aquisition date/time.
They are described as a set of regular expressions in a JSON file and used by gdalcubes to extract this information 
from the paths and/or filenames.
</p>


<h3>Value</h3>

<p>data.frame with columns <code>name</code> and <code>description</code> where the former describes the unique identifier that can be used in <code>create_image_collection</code> and the
latter gives a brief description of the format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collection_formats()
</code></pre>

<hr>
<h2 id='create_image_collection'>Create an image collection from a set of GDAL datasets or files</h2><span id='topic+create_image_collection'></span>

<h3>Description</h3>

<p>This function iterates over files or GDAL dataset identifiers and extracts datetime, image identifiers, and band information according to a given
collection format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_image_collection(
  files,
  format = NULL,
  out_file = tempfile(fileext = ".sqlite"),
  date_time = NULL,
  band_names = NULL,
  use_subdatasets = FALSE,
  unroll_archives = TRUE,
  quiet = FALSE,
  one_band_per_file = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_image_collection_+3A_files">files</code></td>
<td>
<p>character vector with paths to image files on disk or any GDAL dataset identifiers (including virtual file systems and higher level drivers or GDAL subdatasets)</p>
</td></tr>
<tr><td><code id="create_image_collection_+3A_format">format</code></td>
<td>
<p>collection format, can be either a name to use predefined formats (as output from <code><a href="#topic+collection_formats">collection_formats</a></code>) or a path to a custom JSON format description file</p>
</td></tr>
<tr><td><code id="create_image_collection_+3A_out_file">out_file</code></td>
<td>
<p>optional name of the output SQLite database file, defaults to a temporary file</p>
</td></tr>
<tr><td><code id="create_image_collection_+3A_date_time">date_time</code></td>
<td>
<p>vector with date/ time for files; can be of class character, Date, or POSIXct (argument is only applicable for image collections without collection format)</p>
</td></tr>
<tr><td><code id="create_image_collection_+3A_band_names">band_names</code></td>
<td>
<p>character vector with band names, length must match the number of bands in provided files (argument is only applicable for image collections without collection format)</p>
</td></tr>
<tr><td><code id="create_image_collection_+3A_use_subdatasets">use_subdatasets</code></td>
<td>
<p>logical; use GDAL subdatasets of provided files (argument is only applicable for image collections without collection format)</p>
</td></tr>
<tr><td><code id="create_image_collection_+3A_unroll_archives">unroll_archives</code></td>
<td>
<p>automatically convert .zip, .tar archives and .gz compressed files to GDAL virtual file system dataset identifiers (e.g. by prepending /vsizip/) and add contained files to the list of considered files</p>
</td></tr>
<tr><td><code id="create_image_collection_+3A_quiet">quiet</code></td>
<td>
<p>logical; if TRUE, do not print resulting image collection if return value is not assigned to a variable</p>
</td></tr>
<tr><td><code id="create_image_collection_+3A_one_band_per_file">one_band_per_file</code></td>
<td>
<p>logical; if TRUE, assume that band_names are given for all files (argument is only applicable for image collections without collection format, see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An image collection is a simple index (a SQLite database) containing references to existing image files / GDAL dataset identifiers.
</p>
<p>Collections can be created in two different ways: First, if a collection format is specified (argument <code>format</code>), date/time, bands, 
and metadata are automatically extracted from provided files. This is the most general approach but requires a collection format for
the specific dataset. 
</p>
<p>Second, image collections can sometimes be created without collection format by manually specifying date/time of images 
(argument <code>date_time</code>) and names of bands (argument <code>band_names</code>). This is possible if either each image file contains <em>all</em> 
bands of the collection or only a single band. In the former case <code>band_names</code> simply contains the names of the bands or can be NULL 
to use default names. In the latter case (image files contain a single band only), the lengths of <code>band_names</code> and <code>date_time</code> must be identical.
By default, the function assumes one band per file if <code>length(band_names) == length(files)</code>. In the unlikely situation that this is 
not desired, it can be explicitly set using <code>one_band_per_file</code>.
</p>


<h3>Value</h3>

<p>image collection proxy object, which can be used to create a data cube using <code><a href="#topic+raster_cube">raster_cube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. create image collection using a collection format 
L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                       ".TIF", recursive = TRUE, full.names = TRUE)
x = create_image_collection(L8_files, "L8_L1TP")
x 


# 2. create image collection without format for a single band
L8_files_B4 &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                       "_B4.TIF", recursive = TRUE, full.names = TRUE)
d = as.Date(substr(basename(L8_files_B4), 18, 25), "%Y%m%d")
y = create_image_collection(L8_files_B4, date_time = d, band_names = "B4")
y


# 3. create image collection without format for all bands
d = as.Date(substr(basename(L8_files), 18, 25), "%Y%m%d")
fname = basename(tools::file_path_sans_ext(L8_files))
b = substr(fname, 27, nchar(fname))
z = create_image_collection(L8_files, date_time = d, band_names = b)
z

</code></pre>

<hr>
<h2 id='crop'>Crop data cube extent by space and/or time</h2><span id='topic+crop'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which crops a data cube by a spatial and/or temporal extent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop(cube, extent = NULL, iextent = NULL, snap = "near")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="crop_+3A_extent">extent</code></td>
<td>
<p>list with numeric items left, right, top, bottom, and character items t0 and t1, or a subset thereof, see examples</p>
</td></tr>
<tr><td><code id="crop_+3A_iextent">iextent</code></td>
<td>
<p>list with length-two integer items named x, y, and t, defining the lower and upper boundaries as integer coordinates, see examples</p>
</td></tr>
<tr><td><code id="crop_+3A_snap">snap</code></td>
<td>
<p>one of 'near', 'in', or 'out'; ignored if using <code>iextent</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new extent can be specified by spatial coordinates and datetime values (using the <code>extent</code> argument), or as zero-based integer indexes (using the <code>iextent</code> argument).
In the former case, <code>extent</code> expects a list with numeric items left, right, top, bottom, t0, and t1, or a subset thereof. In the latter case,
<code>iextent</code> is expected as a list with length-two integer vectors x, y, and t as items, defining the lower and upper cell indexes per dimension.
</p>
<p>Notice that it is possible to crop only selected boundaries (e.g., only the right boundary) as missing boundaries in the <code>extent</code> or NA / NULL values in the <code>iextent</code> arguments are considered as &quot;no change&quot;.
It is, however, not possible to mix arguments <code>extent</code> and <code>iextent</code>.
</p>
<p>If <code>extent</code> is given, the <code>snap</code> argument can be used to define what happens if the new boundary falls within a data cube cell.
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P3M", aggregation = "median")
L8.cube = raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))

# crop by integer indexes
L8.cropped = crop(L8.rgb, iextent = list(x=c(0,400), y=c(0,400), t=c(1,1)))

# crop by spatiotemporal coordinates
L8.cropped = crop(L8.rgb, extent = list(left=388941.2, right=766552.4, 
   bottom=4345299, top=4744931, t0="2018-01", t1="2018-06"), snap = "in")
L8.cropped 

L8.cropped = crop(L8.rgb, extent = list(left=388941.2, right=766552.4, 
   bottom=4345299, top=4744931, t0="2018-01", t1="2018-06"), snap = "near")
L8.cropped 


plot(L8.cropped, rgb = 3:1, zlim=c(5000,10000))


</code></pre>

<hr>
<h2 id='cube_view'>Create or update a spatiotemporal data cube view</h2><span id='topic+cube_view'></span>

<h3>Description</h3>

<p>Data cube views define the shape of a cube, i.e., the spatiotemporal extent, resolution, and spatial reference system (srs).
They are used to access image collections as on-demand data cubes. The data cube will filter images based on the view's
extent, read image data at the defined resolution, and warp / reproject images to the target srs automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cube_view(
  view,
  extent,
  srs,
  nx,
  ny,
  nt,
  dx,
  dy,
  dt,
  aggregation,
  resampling,
  keep.asp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cube_view_+3A_view">view</code></td>
<td>
<p>if provided, update this cube_view object instead of creating a new data cube view where fields that are already set will be overwritten</p>
</td></tr>
<tr><td><code id="cube_view_+3A_extent">extent</code></td>
<td>
<p>spatioptemporal extent as a list e.g. from <code><a href="#topic+extent">extent</a></code> or an image collection object, see Details</p>
</td></tr>
<tr><td><code id="cube_view_+3A_srs">srs</code></td>
<td>
<p>target spatial reference system as a string; can be a proj4 definition, WKT, or in the form &quot;EPSG:XXXX&quot;</p>
</td></tr>
<tr><td><code id="cube_view_+3A_nx">nx</code></td>
<td>
<p>number of pixels in x-direction (longitude / easting)</p>
</td></tr>
<tr><td><code id="cube_view_+3A_ny">ny</code></td>
<td>
<p>number of pixels in y-direction (latitude / northing)</p>
</td></tr>
<tr><td><code id="cube_view_+3A_nt">nt</code></td>
<td>
<p>number of pixels in t-direction</p>
</td></tr>
<tr><td><code id="cube_view_+3A_dx">dx</code></td>
<td>
<p>size of pixels in x-direction (longitude / easting)</p>
</td></tr>
<tr><td><code id="cube_view_+3A_dy">dy</code></td>
<td>
<p>size of pixels in y-direction (latitude / northing)</p>
</td></tr>
<tr><td><code id="cube_view_+3A_dt">dt</code></td>
<td>
<p>size of pixels in time-direction, expressed as ISO8601 period string (only 1 number and unit is allowed) such as &quot;P16D&quot;</p>
</td></tr>
<tr><td><code id="cube_view_+3A_aggregation">aggregation</code></td>
<td>
<p>aggregation method as string, defining how to deal with pixels containing data from multiple images, can be &quot;min&quot;, &quot;max&quot;, &quot;mean&quot;, &quot;median&quot;, or &quot;first&quot;</p>
</td></tr>
<tr><td><code id="cube_view_+3A_resampling">resampling</code></td>
<td>
<p>resampling method used in gdalwarp when images are read, can be &quot;near&quot;, &quot;bilinear&quot;, &quot;bicubic&quot; or others as supported by gdalwarp (see <a href="https://gdal.org/programs/gdalwarp.html">https://gdal.org/programs/gdalwarp.html</a>)</p>
</td></tr>
<tr><td><code id="cube_view_+3A_keep.asp">keep.asp</code></td>
<td>
<p>if TRUE, derive ny or dy automatically from nx or dx (or vice versa) based on the aspect ratio of the spatial extent</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>extent</code> argument expects a simple list with elementes <code>left</code>, <code>right</code>, <code>bottom</code>, <code>top</code>, <code>t0</code> (start date/time), <code>t1</code> (end date/time) or an image collection object.
In the latter case, the <code><a href="#topic+extent">extent</a></code> function is automatically called on the image collection object to get the full spatiotemporal extent of the collection. In the former case, datetimes 
are expressed as ISO8601 datetime strings.
</p>
<p>The function can be used in two different ways. First, it can create data cube views from scratch by defining the extent, the spatial reference system, and for each dimension either the cell size (dx, dy, dt) or the total number of cells (nx, ny, nt).
Second, the function can update an existing data cube view by overwriting specific fields. In this case, the extent or some elements of the extent may be missing. 
</p>
<p>In some cases, the extent of the view is automatically extended if the provided resolution would end within a pixel. For example,
if the spatial extent covers an area of 1km x 1km and dx = dy = 300m, the extent would be enlarged to 1.2 km x 1.2km. The alignment will be reported to the user in 
a diagnostic message.
</p>


<h3>Value</h3>

<p>A list with data cube view properties
</p>


<h3>Examples</h3>

<pre><code class='language-R'> L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                        ".TIF", recursive = TRUE, full.names = TRUE)
 L8.col = create_image_collection(L8_files, "L8_L1TP")
 
 # 1. Create a new data cube view specification
 v = cube_view(extent=extent(L8.col,"EPSG:4326"), srs="EPSG:4326", dt="P1M", 
           nx=1000, ny=500, aggregation = "mean", resampling="bilinear")
 v

 # 2. overwrite parts of an existing data cube view
 vnew = cube_view(v, dt="P1M")
</code></pre>

<hr>
<h2 id='dim.cube'>Query data cube properties</h2><span id='topic+dim.cube'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.cube_+3A_x">x</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>size of a data cube (number of cells) as integer vector in the order t, y, x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+size">size</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
dim(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='dimension_bounds'>Query coordinate bounds for all dimensions of a data cube</h2><span id='topic+dimension_bounds'></span>

<h3>Description</h3>

<p>Dimension values give the coordinates bounds the spatial and temporal axes of a data cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimension_bounds(obj, datetime_unit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimension_bounds_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy (class cube)</p>
</td></tr>
<tr><td><code id="dimension_bounds_+3A_datetime_unit">datetime_unit</code></td>
<td>
<p>unit used to format values in the datetime dimension, one of &quot;Y&quot;, &quot;m&quot;, &quot;d&quot;, &quot;H&quot;, &quot;M&quot;, &quot;S&quot;, defaults to the unit of the cube.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements t,y,x, each a list with two elements, start and end
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
dimension_bounds(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='dimension_values'>Query coordinate values for all dimensions of a data cube</h2><span id='topic+dimension_values'></span>

<h3>Description</h3>

<p>Dimension values give the coordinates along the spatial and temporal axes of a data cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimension_values(obj, datetime_unit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimension_values_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy (class cube), or a data cube view object</p>
</td></tr>
<tr><td><code id="dimension_values_+3A_datetime_unit">datetime_unit</code></td>
<td>
<p>unit used to format values in the datetime dimension, one of &quot;Y&quot;, &quot;m&quot;, &quot;d&quot;, &quot;H&quot;, &quot;M&quot;, &quot;S&quot;, defaults to the unit of the cube.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements t,y,x
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
dimension_values(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='dimensions'>Query data cube properties</h2><span id='topic+dimensions'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dimensions(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimensions_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Elements of the returned list represent individual dimensions with properties such as dimension boundaries, names, and chunk size stored as inner lists
</p>


<h3>Value</h3>

<p>Dimension information as a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
dimensions(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='extent'>Derive the spatiotemporal extent of an image collection</h2><span id='topic+extent'></span>

<h3>Description</h3>

<p>Derive the spatiotemporal extent of an image collection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extent(x, srs = "EPSG:4326")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extent_+3A_x">x</code></td>
<td>
<p>image collection proxy object</p>
</td></tr>
<tr><td><code id="extent_+3A_srs">srs</code></td>
<td>
<p>target spatial reference system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements <code>left</code>, <code>right</code>, <code>bottom</code>, <code>top</code>, <code>t0</code> (start date/time), and <code>t1</code> (end date/time)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
extent(L8.col,"EPSG:32618")
cube_view(extent=extent(L8.col,"EPSG:32618"),
          srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
</code></pre>

<hr>
<h2 id='extract_geom'>Extract values from a data cube by spatial or spatiotemporal features</h2><span id='topic+extract_geom'></span>

<h3>Description</h3>

<p>Extract pixel values of a data cube from a set of spatial or spatiotemporal features. 
Applications include the extraction of full time 
series at irregular points, extraction from spatiotemporal points, extraction of
pixel values in polygons, and computing summary statistics over polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_geom(
  cube,
  sf,
  datetime = NULL,
  time_column = NULL,
  FUN = NULL,
  merge = FALSE,
  drop_geom = FALSE,
  ...,
  reduce_time = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_geom_+3A_cube">cube</code></td>
<td>
<p>source data cube to extract values from</p>
</td></tr>
<tr><td><code id="extract_geom_+3A_sf">sf</code></td>
<td>
<p>object of class <code>sf</code>, see <a href="sf.html#topic+st_as_sf">sf package</a></p>
</td></tr>
<tr><td><code id="extract_geom_+3A_datetime">datetime</code></td>
<td>
<p>Date, POSIXt, or character vector containing per feature time information; length must be identical to the number of features in <code>sf</code></p>
</td></tr>
<tr><td><code id="extract_geom_+3A_time_column">time_column</code></td>
<td>
<p>name of the column in <code>sf</code> containing per feature time information</p>
</td></tr>
<tr><td><code id="extract_geom_+3A_fun">FUN</code></td>
<td>
<p>optional function to compute per feature summary statistics</p>
</td></tr>
<tr><td><code id="extract_geom_+3A_merge">merge</code></td>
<td>
<p>logical; return a combined data.frame with data cube values and labels, defaults to FALSE</p>
</td></tr>
<tr><td><code id="extract_geom_+3A_drop_geom">drop_geom</code></td>
<td>
<p>logical; remove geometries from output, only used if merge is TRUE, defaults to FALSE</p>
</td></tr>
<tr><td><code id="extract_geom_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="extract_geom_+3A_reduce_time">reduce_time</code></td>
<td>
<p>logical; if TRUE, time is ignored when <code>FUN</code> is applied</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The geometry in <code>sf</code> can be of any simple feature type supported by GDAL, including 
POINTS, LINES, POLYGONS, MULTI*, and more. If no time information is provided
in one of the arguments <code>datetime</code> or <code>time_column</code>, the full time series
of pixels with regard to the features are returned. 
</p>
<p>Notice that feature identifiers in the <code>FID</code> column typically correspond to the row names / numbers 
of the provided sf object. This can be used to combine the output with the original geometries, e.g., using <code><a href="base.html#topic+merge">merge()</a></code>.
with gdalcubes &gt; 0.6.4, this can be done automatically by setting <code>merge=TRUE</code>. In this case, the <code>FID</code> column is dropped from the result. 
</p>
<p>Pixels with missing values are automatically dropped from the result. It is hence not
guaranteed that the result will contain rows for all input features.
</p>
<p>Features are automatically reprojected if the coordinate reference system differs from the data cube.
</p>
<p>Extracted values can be aggregated by features by providing a summary function. 
If <code>reduce_time</code> is FALSE (the default), the values are grouped 
by feature and time, i.e., the result will contain unique combinations of FID and time.
To ignore time and produce a single value per feature, <code>reduce_time</code> can be set to TRUE.
</p>


<h3>Value</h3>

<p>A data.frame with columns FID, time, and data cube bands / variables, see Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'># if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE)
}
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(srs="EPSG:32618", dy=1000, dx=1000, dt="P1M",
              aggregation = "median", resampling = "bilinear",
              extent=list(left=388941.2, right=766552.4,
                          bottom=4345299, top=4744931,
                          t0="2018-01-01", t1="2018-04-30"))
L8.cube = raster_cube(L8.col, v)
L8.cube = select_bands(L8.cube, c("B04", "B05"))
L8.ndvi = apply_pixel(L8.cube, "(B05-B04)/(B05+B04)", "NDVI")
L8.ndvi

if (gdalcubes_gdal_has_geos()) {
  if (requireNamespace("sf", quietly = TRUE)) {
  
    # create 50 random point locations
    x = runif(50, v$space$left, v$space$right)
    y = runif(50, v$space$bottom, v$space$top)
    t = sample(seq(as.Date("2018-01-01"),as.Date("2018-04-30"), by = 1),50, replace = TRUE)
    df = sf::st_as_sf(data.frame(x = x, y = y), coords = c("x", "y"), crs = v$space$srs)

    # 1. spatiotemporal points
    extract_geom(L8.ndvi, df, datetime = t)

    
    # 2. time series at spatial points
    extract_geom(L8.ndvi, df)
  
    # 3. summary statistics over polygons
    x = sf::st_read(system.file("nycd.gpkg", package = "gdalcubes"))
    zstats = extract_geom(L8.ndvi,x, FUN=median, reduce_time = TRUE, merge = TRUE)
    zstats
    plot(zstats["NDVI"])
    
  }
}
</code></pre>

<hr>
<h2 id='fill_time'>Fill NA data cube pixels by simple time series interpolation</h2><span id='topic+fill_time'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which fills NA pixels of a data cube by nearest neighbor or linear time series interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_time(cube, method = "near")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_time_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="fill_time_+3A_method">method</code></td>
<td>
<p>interpolation method, can be &quot;near&quot; (nearest neighbor), &quot;linear&quot; (linear interpolation), &quot;locf&quot; (last observation carried forward), or &quot;nocb&quot; (next observation carried backward)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please notice that completely empty (NA) time series will not be filled, i.e. the result cube might still contain NA values.
</p>


<h3>Value</h3>

<p>a proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P3M", aggregation = "median")
L8.cube = raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.filled = fill_time(L8.rgb, "linear")
L8.filled


plot(L8.filled, rgb=3:1, zlim=c(5000,12000))


</code></pre>

<hr>
<h2 id='filter_geom'>Filter data cube pixels by a polygon</h2><span id='topic+filter_geom'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which filters pixels by a spatial (multi)polygon For all pixels whose center is within the polygon, the original
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_geom(cube, geom, srs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_geom_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="filter_geom_+3A_geom">geom</code></td>
<td>
<p>either a WKT string, or an sfc or sfg object (sf package)</p>
</td></tr>
<tr><td><code id="filter_geom_+3A_srs">srs</code></td>
<td>
<p>string identifier of the polygon's coordinate reference system understandable for GDAL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting data cube will not be cropped but pixels outside of the 
polygon will be set to NAN. 
</p>
<p>If <code>geom</code> is provided as an sfc object with length &gt; 1, geometries will
be combined with <code>sf::st_combine()</code> before.
</p>
<p>The geometry is automatically transformed to the data cube's spatial reference
system if needed.
</p>


<h3>Value</h3>

<p>a proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.cube = select_bands(L8.cube, c("B04", "B05")) 
L8.ndvi = apply_pixel(L8.cube, "(B05-B04)/(B05+B04)", "NDVI")
WKT = gsub(pattern='\\n',replacement="",x = 
  "Polygon ((-74.3541 40.9254, 
             -73.9813 41.2467, 
             -73.9997 41.4400, 
             -74.5362 41.1795, 
             -74.6286 40.9137, 
             -74.3541 40.9254))")
L8.ndvi.filtered = filter_geom(L8.ndvi, WKT, "EPSG:4326")
L8.ndvi.filtered

plot(L8.ndvi.filtered)

</code></pre>

<hr>
<h2 id='filter_pixel'>Filter data cube pixels by a user-defined predicate on band values</h2><span id='topic+filter_pixel'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which evaluates a predicate over all pixels of a data cube. For all pixels that fulfill the predicate, the original
band values are returned. Other pixels are simply filled with NANs. The predicate may access band values by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_pixel(cube, pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_pixel_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="filter_pixel_+3A_pred">pred</code></td>
<td>
<p>predicate to be evaluated over all pixels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gdalcubes uses and extends the <a href="https://github.com/codeplea/tinyexpr">tinyexpr library</a> to evaluate expressions in C / C++, you can look at the <a href="https://github.com/codeplea/tinyexpr#functions-supported">library documentation</a>
to see what kind of expressions you can execute. Pixel band values can be accessed by name.
</p>


<h3>Value</h3>

<p>a proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.cube = select_bands(L8.cube, c("B04", "B05")) 
L8.ndvi = apply_pixel(L8.cube, "(B05-B04)/(B05+B04)", "NDVI") 
L8.ndvi.filtered = filter_pixel(L8.ndvi, "NDVI &gt; 0.5") 
L8.ndvi.filtered

plot(L8.ndvi.filtered)

</code></pre>

<hr>
<h2 id='gdalcubes'>gdalcubes: Earth Observation Data Cubes from Satellite Image Collections</h2><span id='topic+gdalcubes'></span>

<h3>Description</h3>

<p>Processing collections of Earth observation images as on-demand multispectral, multitemporal raster data cubes. Users
define cubes by spatiotemporal extent, resolution, and spatial reference system and let 'gdalcubes' automatically apply cropping, reprojection, and 
resampling using the 'Geospatial Data Abstraction Library' ('GDAL'). Implemented functions on data cubes include reduction over space and time, 
applying arithmetic expressions on pixel band values, moving window aggregates over time, filtering by space, time, bands, and predicates on pixel values, 
exporting data cubes as 'netCDF' or 'GeoTIFF' files, plotting, and extraction from spatial and or spatiotemporal features.  
All computational parts are implemented in C++, linking to the 'GDAL', 'netCDF', 'CURL', and 'SQLite' libraries. 
See Appel and Pebesma (2019) &lt;doi:10.3390/data4030092&gt; for further details.
</p>

<hr>
<h2 id='gdalcubes_gdal_has_geos'>Check if GDAL was built with GEOS</h2><span id='topic+gdalcubes_gdal_has_geos'></span>

<h3>Description</h3>

<p>Check if GDAL was built with GEOS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdalcubes_gdal_has_geos()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>gdalcubes_gdal_has_geos()
</code></pre>

<hr>
<h2 id='gdalcubes_gdalformats'>Get available GDAL drivers</h2><span id='topic+gdalcubes_gdalformats'></span>

<h3>Description</h3>

<p>Get available GDAL drivers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdalcubes_gdalformats()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>gdalcubes_gdalformats()
</code></pre>

<hr>
<h2 id='gdalcubes_gdalversion'>Get the GDAL version used by gdalcubes</h2><span id='topic+gdalcubes_gdalversion'></span>

<h3>Description</h3>

<p>Get the GDAL version used by gdalcubes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdalcubes_gdalversion()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>gdalcubes_gdalversion()
</code></pre>

<hr>
<h2 id='gdalcubes_options'>Set or read global options of the gdalcubes package</h2><span id='topic+gdalcubes_options'></span>

<h3>Description</h3>

<p>Set global package options to change the default behavior of gdalcubes. These include how many parallel processes are used
to process data cubes, how created netCDF files are compressed, and whether or not debug messages should be printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdalcubes_options(
  ...,
  parallel,
  ncdf_compression_level,
  debug,
  cache,
  ncdf_write_bounds,
  use_overview_images,
  show_progress,
  default_chunksize,
  streaming_dir,
  log_file,
  threads
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdalcubes_options_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_parallel">parallel</code></td>
<td>
<p>number of parallel workers used to process data cubes or TRUE to use the number of available cores automatically</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_ncdf_compression_level">ncdf_compression_level</code></td>
<td>
<p>integer; compression level for created netCDF files, 0=no compression, 1=fast compression, 9=small compression</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_debug">debug</code></td>
<td>
<p>logical;  print debug messages</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_cache">cache</code></td>
<td>
<p>logical; TRUE if temporary data cubes should be cached to support fast reprocessing of the same cubes</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_ncdf_write_bounds">ncdf_write_bounds</code></td>
<td>
<p>logical; write dimension bounds as additional variables in netCDF files</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_use_overview_images">use_overview_images</code></td>
<td>
<p>logical; if FALSE, all images are read on original resolution and existing overviews will be ignored</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_show_progress">show_progress</code></td>
<td>
<p>logical; if TRUE, a progress bar will be shown for actual computations</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_default_chunksize">default_chunksize</code></td>
<td>
<p>length-three vector with chunk size in t, y, x directions or a function taking a data cube size and returning a suggested chunk size</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_streaming_dir">streaming_dir</code></td>
<td>
<p>directory where temporary binary files for process streaming will be written to</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_log_file">log_file</code></td>
<td>
<p>character, if empty string or NULL, diagnostic messages will be printed to the console, otherwise to the provided file</p>
</td></tr>
<tr><td><code id="gdalcubes_options_+3A_threads">threads</code></td>
<td>
<p>number of threads used to process data cubes (deprecated)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data cubes can be processed in parallel where the number of chunks in a cube is distributed among parallel
worker processes. The actual number of used workers can be lower if a data cube as less chunks. If parallel
is TRUE, the number of available cores is used. Setting parallel = FALSE can be used to disable parallel processing.
Notice that since version 0.6.0, separate processes are being used instead of parallel threads to avoid 
possible R session crashes due to some multithreading issues. 
</p>
<p>Caching has no effect on disk or memory consumption, 
it simply tries to reuse existing temporary files where possible.
For example, changing only parameters to <code>plot</code> will void
reprocessing the same data cube if cache is TRUE.
</p>
<p>The streaming directory can be used to control the performance of user-defined functions,
if disk IO is a bottleneck. Ideally, this can be set to a directory on a shared memory device.
</p>
<p>Passing no arguments will return the current options as a list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gdalcubes_options(parallel=4) # set the number 
gdalcubes_options() # print current options
gdalcubes_options(parallel=FALSE) # reset
</code></pre>

<hr>
<h2 id='gdalcubes_selection'>Subsetting data cubes</h2><span id='topic+gdalcubes_selection'></span><span id='topic++24.cube'></span><span id='topic++5B.cube'></span>

<h3>Description</h3>

<p>Subset data cube dimensions and bands / variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
x$name

## S3 method for class 'cube'
x[ib = TRUE, it = TRUE, iy = TRUE, ix = TRUE, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdalcubes_selection_+3A_x">x</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="gdalcubes_selection_+3A_name">name</code></td>
<td>
<p>character; name of selected band</p>
</td></tr>
<tr><td><code id="gdalcubes_selection_+3A_ib">ib</code></td>
<td>
<p>first selector (optional), object of type character, list, Date, POSIXt, numeric, <a href="sf.html#topic+st_bbox">st_bbox</a>, or <a href="sf.html#topic+st_sfc">st_sfc</a>, see Details and examples</p>
</td></tr>
<tr><td><code id="gdalcubes_selection_+3A_it">it</code></td>
<td>
<p>second selector (optional), see <code>ib</code></p>
</td></tr>
<tr><td><code id="gdalcubes_selection_+3A_iy">iy</code></td>
<td>
<p>third selector (optional), see <code>ib</code></p>
</td></tr>
<tr><td><code id="gdalcubes_selection_+3A_ix">ix</code></td>
<td>
<p>fourth selector (optional), see <code>ib</code></p>
</td></tr>
<tr><td><code id="gdalcubes_selection_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>[]</code> operator allows for flexible subsetting of data cubes by date, datetime,  
bounding box, spatial points, and band names. Depending on the arguments, it supports slicing
(selecting one element of a dimension), cropping (selecting a subinterval of a dimension) and combinations
thereof (e.g., selecting a spatial window and a temporal slice). Dimension subsets can 
be specified by integer indexes or coordinates / datetime values. Arguments are matched by type and order.
For example, if the first argument is a length-two vector of type Date, the function will understand to 
subset the time dimension. Otherwise, arguments are treated in the order band, time, y, x.
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P3M", aggregation = "median")
L8.cube = raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))
L8.red = L8.cube$B04


plot(L8.red)


v = cube_view(extent=list(left=388941.2, right=766552.4,
                          bottom=4345299, top=4744931, t0="2018-01-01", t1="2018-12-31"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1D", aggregation = "median")
L8.cube = raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))

L8.cube[c("B05","B04")] # select bands
L8.cube[as.Date(c("2018-01-10", "2018-01-20"))] # crop by time
L8.cube[as.Date("2018-01-10")] # slice by time
L8.cube["B05", "2018-01-10"] # select bands and slice by time
L8.cube["B05", c("2018-01-10","2018-01-17")] # select bands and crop by time
L8.cube[, c("2018-01-10","2018-01-17")] # crop by time

# crop by space (coordinates and integer indexes respectively)
L8.cube[list(left=388941.2 + 1e5, right=766552.4 - 1e5, bottom=4345299 + 1e5, top=4744931 - 1e5)]
L8.cube[,,c(1,100), c(1,100)] 

L8.cube[,c(1,2),,] # crop by time (integer indexes)

# subset by spatial point or bounding box
if (requireNamespace("sf", quietly = TRUE)) {
  s = sf::st_sfc(sf::st_point(c(500000, 4500000)), crs = "EPSG:32618")
  L8.cube[s]

  bbox =  sf::st_bbox(c(xmin = 388941.2 + 1e5, xmax = 766552.4 - 1e5,
                   ymax = 4744931 - 1e5, ymin = 4345299 + 1e5), crs = sf::st_crs(32618))
  L8.cube[bbox]
}

</code></pre>

<hr>
<h2 id='gdalcubes_set_gdal_config'>Set GDAL config options</h2><span id='topic+gdalcubes_set_gdal_config'></span>

<h3>Description</h3>

<p>Set GDAL config options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdalcubes_set_gdal_config(key, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdalcubes_set_gdal_config_+3A_key">key</code></td>
<td>
<p>name of a GDAL config option to be set</p>
</td></tr>
<tr><td><code id="gdalcubes_set_gdal_config_+3A_value">value</code></td>
<td>
<p>value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details and a list of possible options can be found at 
<a href="https://gdal.org/user/configoptions.html">https://gdal.org/user/configoptions.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gdalcubes_set_gdal_config("GDAL_NUM_THREADS", "ALL_CPUS")
</code></pre>

<hr>
<h2 id='image_collection'>Load an existing image collection from a file</h2><span id='topic+image_collection'></span>

<h3>Description</h3>

<p>This function will load an image collection from an SQLite file. Image collection files
index and reference existing imagery. To create a collection from files on disk,
use <code><a href="#topic+create_image_collection">create_image_collection</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_collection(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_collection_+3A_path">path</code></td>
<td>
<p>path to an existing image collection file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image collection proxy object, which can be used to create a data cube using <code><a href="#topic+raster_cube">raster_cube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
L8.col
</code></pre>

<hr>
<h2 id='image_mask'>Create a mask for images in a raster data cube</h2><span id='topic+image_mask'></span>

<h3>Description</h3>

<p>Create an image mask based on a band and provided values to filter pixels of images 
read by <code><a href="#topic+raster_cube">raster_cube</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_mask(
  band,
  min = NULL,
  max = NULL,
  values = NULL,
  bits = NULL,
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_mask_+3A_band">band</code></td>
<td>
<p>name of the mask band</p>
</td></tr>
<tr><td><code id="image_mask_+3A_min">min</code></td>
<td>
<p>minimum value, values between <code>min</code> and <code>max</code> will be masked</p>
</td></tr>
<tr><td><code id="image_mask_+3A_max">max</code></td>
<td>
<p>maximum value, values between <code>min</code> and <code>max</code> will be masked</p>
</td></tr>
<tr><td><code id="image_mask_+3A_values">values</code></td>
<td>
<p>numeric vector; specific values that will be masked.</p>
</td></tr>
<tr><td><code id="image_mask_+3A_bits">bits</code></td>
<td>
<p>for bitmasks, extract the given bits (integer vector) with a bitwise AND before filtering the mask values, bit indexes are zero-based</p>
</td></tr>
<tr><td><code id="image_mask_+3A_invert">invert</code></td>
<td>
<p>logical; invert mask</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values of the selected mask band can be based on a range (by passing <code>min</code> and <code>max</code>) or on a set of values (by passing <code>values</code>). By default
pixels with mask values contained in the range or in the values are masked out, i.e. set to NA. Setting <code>invert = TRUE</code> will invert the masking behavior.
Passing <code>values</code> will override <code>min</code> and <code>max</code>.
</p>


<h3>Note</h3>

<p>Notice that masks are applied per image while reading images as a raster cube. They can be useful to eliminate e.g. cloudy pixels before applying the temporal aggregation to
merge multiple values for the same data cube pixel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image_mask("SCL", values = c(3,8,9)) # Sentinel 2 L2A: mask cloud and cloud shadows
image_mask("BQA", bits=4, values=16) # Landsat 8: mask clouds
image_mask("B10", min = 8000, max=65000) 

</code></pre>

<hr>
<h2 id='join_bands'>Join bands of two identically shaped data cubes</h2><span id='topic+join_bands'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which joins the bands of two identically shaped data cubes. The resulting cube
will have bands from both input cubes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_bands(cube_list, cube_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_bands_+3A_cube_list">cube_list</code></td>
<td>
<p>a list with two or more source data cubes</p>
</td></tr>
<tr><td><code id="join_bands_+3A_cube_names">cube_names</code></td>
<td>
<p>list or character vector with optional name prefixes for bands in the output data cube (see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of provided cube_names must match the number of provided input cubes.
If no cube_names are provided, bands of the output cube will adopt original names from the input cubes (without any prefix). If any two of the input bands have identical names,
prefixes default prefixes (&quot;X1&quot;, &quot;X2&quot;, ...) will be used.
</p>


<h3>Value</h3>

<p>proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4,
                          bottom=4345299, top=4744931, t0="2018-01", t1="2018-05"),
                          srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v)
L8.cube.b04 = select_bands(raster_cube(L8.col, v), c("B04"))
L8.cube.b05 = select_bands(raster_cube(L8.col, v), c("B05"))
join_bands(list(L8.cube.b04,L8.cube.b05))

plot(join_bands(list(L8.cube.b04,L8.cube.b05)))

</code></pre>

<hr>
<h2 id='json_cube'>Read a data cube from a json description file</h2><span id='topic+json_cube'></span>

<h3>Description</h3>

<p>Read a data cube from a json description file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_cube(json, path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_cube_+3A_json">json</code></td>
<td>
<p>length-one character vector with a valid json data cube description</p>
</td></tr>
<tr><td><code id="json_cube_+3A_path">path</code></td>
<td>
<p>source data cube proxy object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data cubes can be stored as JSON description files. These files do not store any data but the recipe
how a data cube is constructed, i.e., the chain (or graph) of processes involved. 
</p>
<p>Since data cube objects (as returned from <code><a href="#topic+raster_cube">raster_cube</a></code>) cannot be saved with normal R methods,
the combination of <code><a href="#topic+as_json">as_json</a></code> and <code><a href="#topic+json_cube">json_cube</a></code> provides a cheap way to save virtual 
data cube objects across several R sessions, as in the examples.
</p>


<h3>Value</h3>

<p>data cube proxy object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
cube = raster_cube(L8.col, v) 

# save
fname = tempfile()
as_json(cube, fname)

# load
json_cube(path = fname)  


</code></pre>

<hr>
<h2 id='memsize'>Query data cube properties</h2><span id='topic+memsize'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memsize(obj, unit = "MiB")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="memsize_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
<tr><td><code id="memsize_+3A_unit">unit</code></td>
<td>
<p>Unit of data size, can be &quot;B&quot;, &quot;KB&quot;, &quot;KiB&quot;, &quot;MB&quot;, &quot;MiB&quot;, &quot;GB&quot;, &quot;GiB&quot;, &quot;TB&quot;, &quot;TiB&quot;, &quot;PB&quot;, &quot;PiB&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Total data size of data cube values expressed in the given unit
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
memsize(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='names.cube'>Query data cube properties</h2><span id='topic+names.cube'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.cube_+3A_x">x</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Band names as character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
names(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='nbands'>Query data cube properties</h2><span id='topic+nbands'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbands(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbands_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of bands
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
nbands(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='ncdf_cube'>Read a data cube from an existing netCDF file</h2><span id='topic+ncdf_cube'></span>

<h3>Description</h3>

<p>Create a proxy data cube from a netCDF file that has been created using <code><a href="#topic+write_ncdf">write_ncdf</a></code>.
This function does not read cubes from arbitrary netCDF files and can be used e.g., to load intermediate results and/or 
plotting existing netCDF cubes on disk without doing the data cube creation from image collections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncdf_cube(path, chunking = NULL, auto_unpack = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncdf_cube_+3A_path">path</code></td>
<td>
<p>path to an existing netCDF file</p>
</td></tr>
<tr><td><code id="ncdf_cube_+3A_chunking">chunking</code></td>
<td>
<p>custom chunk sizes to read form the netCDF file; defaults to using chunk sizes from the netCDF file</p>
</td></tr>
<tr><td><code id="ncdf_cube_+3A_auto_unpack">auto_unpack</code></td>
<td>
<p>logical; automatically apply offset and scale when reading data values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")


ncfile = write_ncdf(select_bands(raster_cube(L8.col, v), c("B02", "B03", "B04")))
ncdf_cube(ncfile)
                           

</code></pre>

<hr>
<h2 id='nt'>Query data cube properties</h2><span id='topic+nt'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nt(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nt_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of pixels in the time dimension
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
nt(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='nx'>Query data cube properties</h2><span id='topic+nx'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nx(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nx_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of pixels in the x dimension
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
nx(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='ny'>Query data cube properties</h2><span id='topic+ny'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ny(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ny_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of pixels in the y dimension
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
ny(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='pack_minmax'>Helper function to define packed data exports by min / max values</h2><span id='topic+pack_minmax'></span>

<h3>Description</h3>

<p>This function can be used to define packed exports in <code><a href="#topic+write_ncdf">write_ncdf</a></code>
and <code><a href="#topic+write_tif">write_tif</a></code>. It will generate scale and offset values with maximum precision (unless simplify=TRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack_minmax(type = "int16", min, max, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pack_minmax_+3A_type">type</code></td>
<td>
<p>target data type of packed values (one of &quot;uint8&quot;, &quot;uint16&quot;, &quot;uint32&quot;, &quot;int16&quot;, or &quot;int32&quot;)</p>
</td></tr>
<tr><td><code id="pack_minmax_+3A_min">min</code></td>
<td>
<p>numeric; minimum value(s) of original values, will be packed to the 2nd lowest value of the target data type</p>
</td></tr>
<tr><td><code id="pack_minmax_+3A_max">max</code></td>
<td>
<p>numeric; maximum value(s) in original scale, will be packed to the highest value of the target data type</p>
</td></tr>
<tr><td><code id="pack_minmax_+3A_simplify">simplify</code></td>
<td>
<p>logical; round resulting scale and offset to power of 10 values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nodata values will be mapped to the lowest value of the target data type.
</p>
<p>Arguments min and max must have length 1 or length equal to the number of bands of the data cube to be exported. In the former
case, the same values are used for all bands of the exported target cube, whereas the latter case allows to use different 
ranges for different bands.
</p>


<h3>Note</h3>

<p>Using simplify=TRUE will round scale values to the next smaller power of 10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ndvi_packing = pack_minmax(type="int16", min=-1, max=1)
ndvi_packing

</code></pre>

<hr>
<h2 id='plot.cube'>Plot a gdalcubes data cube</h2><span id='topic+plot.cube'></span>

<h3>Description</h3>

<p>Plot a gdalcubes data cube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
plot(
  x,
  y,
  ...,
  nbreaks = 11,
  breaks = NULL,
  col = grey(1:(nbreaks - 1)/nbreaks),
  key.pos = NULL,
  bands = NULL,
  t = NULL,
  rgb = NULL,
  zlim = NULL,
  gamma = 1,
  periods.in.title = TRUE,
  join.timeseries = FALSE,
  axes = TRUE,
  ncol = NULL,
  nrow = NULL,
  downsample = TRUE,
  na.color = "#AAAAAA"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cube_+3A_x">x</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_y">y</code></td>
<td>
<p>__not used__</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>image.default</code></p>
</td></tr>
<tr><td><code id="plot.cube_+3A_nbreaks">nbreaks</code></td>
<td>
<p>number of breaks, should be one more than the number of colors given</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_breaks">breaks</code></td>
<td>
<p>actual breaks used to assign colors to values; if missing, the function subsamples values and uses equally sized intervals between min and max or zlim[0] and zlim[1] if defined</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_col">col</code></td>
<td>
<p>color definition, can be a character vector with nbreaks - 1 elements or a function such as <code>heat.colors</code></p>
</td></tr>
<tr><td><code id="plot.cube_+3A_key.pos">key.pos</code></td>
<td>
<p>position for the legend, 1 (bottom), 2 (left), 3 (top), or 4 (right). If NULL (the default), do not plot a legend.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_bands">bands</code></td>
<td>
<p>integer vector with band numbers to plot (this must be band numbers, not band names)</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_t">t</code></td>
<td>
<p>integer vector with time indexes to plot (this must be time indexes, not date / time)</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_rgb">rgb</code></td>
<td>
<p>bands used to assign RGB color channels, vector of length 3 (this must be band numbers, not band names)</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_zlim">zlim</code></td>
<td>
<p>vector of length 2, defining the minimum and maximum values to either derive breaks, or define black and white values in RGB plots</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_gamma">gamma</code></td>
<td>
<p>gamma correction value, used for RGB plots only</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_periods.in.title">periods.in.title</code></td>
<td>
<p>logical value, if TRUE, the title of plots includes the datetime period length as ISO 8601 string</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_join.timeseries">join.timeseries</code></td>
<td>
<p>logical, for pure time-series plots, shall time series of multiple bands be plotted in a single plot (with different colors)?</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_axes">axes</code></td>
<td>
<p>logical, if TRUE, plots include axes</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_ncol">ncol</code></td>
<td>
<p>number of columns for arranging plots with  <code>layout()</code>, see Details</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_nrow">nrow</code></td>
<td>
<p>number of rows for arranging plots with  <code>layout()</code>, see Details</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_downsample">downsample</code></td>
<td>
<p>length-one integer or logical value used to select only every i-th pixel (in space only) for faster plots; by default (TRUE), downsampling will be determined automatically based on the resolution of the graphics device; set to FALSE to avoid downsampling.</p>
</td></tr>
<tr><td><code id="plot.cube_+3A_na.color">na.color</code></td>
<td>
<p>color used to plot NA pixels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The style of the plot depends on provided parameters and on the shape of the cube, i.e., whether it is a pure time series and whether it contains multiple bands or not.
Multi-band, multi-temporal images will be arranged with <code>layout()</code> such that bands are represented by columns and time is represented by rows.
Time series plots can be combined to a single plot by setting <code>join.timeseries = TRUE</code>. The layout can be controlled with <code>ncol</code> and <code>nrow</code>, which define the number of rows and columns in the plot layout. Typically, only one of 
<code>ncol</code> and <code>nrow</code> is provided. For multi-band, multi-temporal plots, the actual number of rows or columns can be less if the input cube has less bands or time slices.
</p>
<p>The <code>downsample</code> argument is used to speed-up plotting if the cube has much more pixels than the graphics device. 
If set to a scalar integer value &gt; 1, the value is used to skip pixels in the spatial dimensions. For example, setting <code>downsample = 4</code> means
that every fourth pixel is used in the spatial dimensions. If TRUE (the default) <code>downsample</code> is derived automatically based on the 
sizes of the cube and the graphics device. If 1 or FALSE, no additional downsampling is performed. Notice that downsampling is only used for plotting.
The size of the data cube (and hence the computation time to process the data cube) is not modified.
</p>


<h3>Note</h3>

<p>If caching is enabled for the package (see <code><a href="#topic+gdalcubes_options">gdalcubes_options</a></code>), repeated calls of plot
for the same data cube will not reevaluate the cube. Instead, the temporary result file will be reused, if possible.
</p>
<p>Some parts of the function have been copied from the stars package (c) Edzer Pebesma
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
              
plot(select_bands(raster_cube(L8.col, v), c("B02", "B03", "B04")), rgb=3:1)
              
L8.cube = select_bands(raster_cube(L8.col, v), c("B04", "B05")) 
L8.ndvi = apply_pixel(L8.cube, "(B05-B04)/(B05+B04)", "NDVI") 
plot(reduce_time(L8.ndvi, "median(NDVI)"), key.pos=1, zlim=c(0,1))

</code></pre>

<hr>
<h2 id='predict.cube'>Model prediction</h2><span id='topic+predict.cube'></span>

<h3>Description</h3>

<p>Apply a trained model on all pixels of a data cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
predict(object, model, ..., output_names = c("pred"), keep_bands = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cube_+3A_object">object</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
<tr><td><code id="predict.cube_+3A_model">model</code></td>
<td>
<p>model used for prediction (e.g. from <code>caret</code> or <code>tidymodels</code>)</p>
</td></tr>
<tr><td><code id="predict.cube_+3A_...">...</code></td>
<td>
<p>further arguments passed to the model-specific predict method</p>
</td></tr>
<tr><td><code id="predict.cube_+3A_output_names">output_names</code></td>
<td>
<p>optional character vector for output variable(s)</p>
</td></tr>
<tr><td><code id="predict.cube_+3A_keep_bands">keep_bands</code></td>
<td>
<p>logical; keep bands of input data cube, defaults to FALSE, i.e. original bands will be dropped</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model-specific predict method will be automatically chosen based on the class of the provided model. It aims at supporting 
models from the packages <code>tidymodels</code>, <code>caret</code>, and simple models as from <code>lm</code> or <code>glm</code>. 
</p>
<p>For multiple output variables or output in form of lists or data.frames, <code>output_names</code> must be provided and match 
names of the columns / items of the result object returned from the underlying predict method. For example, 
predictions using <code>tidymodels</code> return a tibble (data.frame) with columns like <code>.pred_class</code> (classification case).
This must be explicitly provided as <code>output_names</code>. Similarly, <code>predict.lm</code> and the like return lists
if the standard error is requested by the user and <code>output_names</code> hence should be set to <code>c("fit","se.fit")</code>.
</p>
<p>For more complex cases or when predict expects something else than a <code>data.frame</code>, this function may not work at all.
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not immediately start any computations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create image collection from example Landsat data only
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE)
}

v = cube_view(extent=list(left=388941.2, right=766552.4,
                          bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P3M")

L8.col = image_collection(file.path(tempdir(), "L8.db"))

x = sf::st_read(system.file("ny_samples.gpkg", package = "gdalcubes"))

raster_cube(L8.col, v) |&gt;
  select_bands(c("B02","B03","B04","B05")) |&gt;
  extract_geom(x) -&gt; train

x$FID = rownames(x)  
train = merge(train, x, by = "FID")
train$iswater = as.factor(train$class == "water")

log_model &lt;- glm(iswater ~ B02 + B03 + B04 + B05, data = train, family = "binomial")

raster_cube(L8.col, v) |&gt;
  select_bands(c("B02","B03","B04","B05")) |&gt;
  predict(model=log_model, type="response") |&gt;
  plot(key.pos=1)

</code></pre>

<hr>
<h2 id='print.cube'>Print data cube information</h2><span id='topic+print.cube'></span>

<h3>Description</h3>

<p>Prints information about the dimensions and bands of a data cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cube_+3A_x">x</code></td>
<td>
<p>Object of class &quot;cube&quot;</p>
</td></tr>
<tr><td><code id="print.cube_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the generic print function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
print(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='print.cube_view'>Print data cube view information</h2><span id='topic+print.cube_view'></span>

<h3>Description</h3>

<p>Prints information about a data cube view, including its dimensions, spatial reference, aggregation method, and resampling method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube_view'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cube_view_+3A_x">x</code></td>
<td>
<p>Object of class &quot;cube_view&quot;</p>
</td></tr>
<tr><td><code id="print.cube_view_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the generic print function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
print(v)
</code></pre>

<hr>
<h2 id='print.image_collection'>Print image collection information</h2><span id='topic+print.image_collection'></span>

<h3>Description</h3>

<p>Prints information about images in an image collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'image_collection'
print(x, ..., n = 6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.image_collection_+3A_x">x</code></td>
<td>
<p>Object of class &quot;image_collection&quot;</p>
</td></tr>
<tr><td><code id="print.image_collection_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the generic print function</p>
</td></tr>
<tr><td><code id="print.image_collection_+3A_n">n</code></td>
<td>
<p>Number of images for which details are printed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
print(L8.col)
</code></pre>

<hr>
<h2 id='proj4'>Query data cube properties</h2><span id='topic+proj4'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proj4(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proj4_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The spatial reference system expressed as proj4 string
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
proj4(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='raster_cube'>Create a data cube from an image collection</h2><span id='topic+raster_cube'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which loads data from a given image collection according to a data cube view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_cube(
  image_collection,
  view,
  mask = NULL,
  chunking = .pkgenv$default_chunksize,
  incomplete_ok = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="raster_cube_+3A_image_collection">image_collection</code></td>
<td>
<p>Source image collection as from <code>image_collection</code> or <code>create_image_collection</code></p>
</td></tr>
<tr><td><code id="raster_cube_+3A_view">view</code></td>
<td>
<p>A data cube view defining the shape (spatiotemporal extent, resolution, and spatial reference), if missing, a default overview is used</p>
</td></tr>
<tr><td><code id="raster_cube_+3A_mask">mask</code></td>
<td>
<p>mask pixels of images based on band values, see <code><a href="#topic+image_mask">image_mask</a></code></p>
</td></tr>
<tr><td><code id="raster_cube_+3A_chunking">chunking</code></td>
<td>
<p>length-3 vector or a function returning a vector of length 3, defining the size of data cube chunks in the order time, y, x.</p>
</td></tr>
<tr><td><code id="raster_cube_+3A_incomplete_ok">incomplete_ok</code></td>
<td>
<p>logical, if TRUE (the default), chunks will ignore IO failures and simply use as much images as possible, otherwise the result will contain empty chunks if IO errors or similar occur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following steps will be performed when the data cube is requested to read data of a chunk:
</p>
<p>1. Find images from the input collection that intersect with the spatiotemporal extent of the chunk
2. For all resulting images, apply gdalwarp to reproject, resize, and resample to an in-memory GDAL dataset
3. Read the resulting data to the chunk buffer and optionally apply a mask on the result
4. Update pixel-wise aggregator (as defined in the data cube view) to combine values of multiple images within the same data cube pixels
</p>
<p>If chunking is provided as a function, it must accept exactly three arguments for the total size of the cube in t, y, and x axes (in this order).
</p>


<h3>Value</h3>

<p>A proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
raster_cube(L8.col, v)
 
 # using a mask on the Landsat quality bit band to filter out clouds
 raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))
 
</code></pre>

<hr>
<h2 id='read_chunk_as_array'>Read chunk data of a data cube from stdin or a file</h2><span id='topic+read_chunk_as_array'></span>

<h3>Description</h3>

<p>This function can be used within function passed to <code><a href="#topic+chunk_apply">chunk_apply</a></code> in order to read a data cube chunk as a four-dimensional R array.
It works only for R processes, which have been started from the gdalcubes C++ library. 
The resulting array has dimensions band, time, y, x (in this order).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_chunk_as_array(with.dimnames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_chunk_as_array_+3A_with.dimnames">with.dimnames</code></td>
<td>
<p>if TRUE, the resulting array will contain dimnames with coordinates, datetime, and band names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>four-dimensional array
</p>


<h3>Note</h3>

<p>Call this function ONLY from a function passed to <code><a href="#topic+chunk_apply">chunk_apply</a></code>.
</p>
<p>This function only works in R sessions started from gdalcubes streaming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4,
                          bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
                          srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v)
L8.cube = select_bands(L8.cube, c("B04", "B05"))
f &lt;- function() {
  x &lt;- read_chunk_as_array()
  out &lt;- reduce_time(x, function(x) {
    cor(x[1,], x[2,], use="na.or.complete", method = "kendall")
  }) 
  write_chunk_from_array(out)
}
L8.cor = chunk_apply(L8.cube, f)
plot(L8.cor, zlim=c(0,1), key.pos=1)

</code></pre>

<hr>
<h2 id='reduce_space'>Reduce multidimensional data over space</h2><span id='topic+reduce_space'></span>

<h3>Description</h3>

<p>This generic function applies a reducer function over a data cube, an R array, or other classes if implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_space(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_space_+3A_x">x</code></td>
<td>
<p>object to be reduced</p>
</td></tr>
<tr><td><code id="reduce_space_+3A_...">...</code></td>
<td>
<p>further arguments passed to specific implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value and type depend on the class of x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce_space.cube">reduce_space.cube</a></code>
</p>
<p><code><a href="#topic+reduce_space.array">reduce_space.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
reduce_space(raster_cube(L8.col, v) , "median(B02)")  


d &lt;- c(4,16,32,32)
x &lt;- array(rnorm(prod(d)), d)
y &lt;- reduce_space(x, function(v) {
  apply(v, 1, mean)
})
 
</code></pre>

<hr>
<h2 id='reduce_space.array'>Apply a function over space and bands in a four-dimensional (band, time, y, x) array and reduce
spatial dimensions</h2><span id='topic+reduce_space.array'></span>

<h3>Description</h3>

<p>Apply a function over space and bands in a four-dimensional (band, time, y, x) array and reduce
spatial dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
reduce_space(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_space.array_+3A_x">x</code></td>
<td>
<p>four-dimensional input array with dimensions band, time, y, x (in this order)</p>
</td></tr>
<tr><td><code id="reduce_space.array_+3A_fun">FUN</code></td>
<td>
<p>function which receives one spatial slice in a three-dimensional array with dimensions bands, y, x as input</p>
</td></tr>
<tr><td><code id="reduce_space.array_+3A_...">...</code></td>
<td>
<p>further arguments passed to FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN is expected to produce a numeric vector (or scalar) where elements are interpreted as new bands in the result.
</p>


<h3>Note</h3>

<p>This is a helper function that uses the same dimension ordering as gdalcubes streaming. It can be used to simplify 
the application of R functions e.g. over spatial slices in a data cube.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(4,16,32,32)
x &lt;- array(rnorm(prod(d)), d)
# reduce individual bands over spatial slices 
y &lt;- reduce_space(x, function(v) {
  apply(v, 1, mean)
})
dim(y)
</code></pre>

<hr>
<h2 id='reduce_space.cube'>Reduce a data cube over spatial (x,y or lat,lon) dimensions</h2><span id='topic+reduce_space.cube'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which applies one or more reducer functions to selected bands over spatial slices of a data cube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
reduce_space(
  x,
  expr,
  ...,
  FUN,
  names = NULL,
  load_pkgs = FALSE,
  load_env = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_space.cube_+3A_x">x</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="reduce_space.cube_+3A_expr">expr</code></td>
<td>
<p>either a single string, or a vector of strings defining which reducers will be applied over which bands of the input cube</p>
</td></tr>
<tr><td><code id="reduce_space.cube_+3A_...">...</code></td>
<td>
<p>optional additional expressions (if <code>expr</code> is not a vector)</p>
</td></tr>
<tr><td><code id="reduce_space.cube_+3A_fun">FUN</code></td>
<td>
<p>a user-defined R function applied over pixel time series (see Details)</p>
</td></tr>
<tr><td><code id="reduce_space.cube_+3A_names">names</code></td>
<td>
<p>character vector; names of the output bands, if FUN is provided, the length of names is used as the expected number of output bands</p>
</td></tr>
<tr><td><code id="reduce_space.cube_+3A_load_pkgs">load_pkgs</code></td>
<td>
<p>logical or character; if TRUE, all currently attached packages will be attached automatically before executing FUN in spawned R processes, specific packages can alternatively be provided as a character vector.</p>
</td></tr>
<tr><td><code id="reduce_space.cube_+3A_load_env">load_env</code></td>
<td>
<p>logical or environment; if TRUE, the current global environment will be restored automatically before executing FUN in spawned R processes, can be set to a custom environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notice that expressions have a very simple format: the reducer is followed by the name of a band in parentheses. You cannot add
more complex functions or arguments.
</p>
<p>Possible reducers currently include &quot;min&quot;, &quot;max&quot;, &quot;sum&quot;, &quot;prod&quot;, &quot;count&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;var&quot;, and &quot;sd&quot;.
</p>
<p>For more details and examples on how to write user-defined functions, please refer to the gdalcubes website 
at <a href="https://gdalcubes.github.io/source/concepts/udfs.html">https://gdalcubes.github.io/source/concepts/udfs.html</a>.
</p>


<h3>Value</h3>

<p>proxy data cube object
</p>


<h3>Note</h3>

<p>Implemented reducers will ignore any NAN values (as na.rm=TRUE does).
</p>
<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.b02 = select_bands(L8.cube, c("B02"))
L8.b02.median = reduce_space(L8.b02, "median(B02)")  
L8.b02.median

plot(L8.b02.median)


</code></pre>

<hr>
<h2 id='reduce_time'>Reduce multidimensional data over time</h2><span id='topic+reduce_time'></span>

<h3>Description</h3>

<p>This generic function applies a reducer function over a data cube, an R array, or other classes if implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_time(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_time_+3A_x">x</code></td>
<td>
<p>object to be reduced</p>
</td></tr>
<tr><td><code id="reduce_time_+3A_...">...</code></td>
<td>
<p>further arguments passed to specific implementations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value and type depend on the class of x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reduce_time.cube">reduce_time.cube</a></code>
</p>
<p><code><a href="#topic+reduce_time.array">reduce_time.array</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
reduce_time(raster_cube(L8.col, v) , "median(B02)", "median(B03)", "median(B04)")  
 
d &lt;- c(4,16,32,32)
x &lt;- array(rnorm(prod(d)), d)
y &lt;- reduce_time(x, function(v) {
  apply(v, 1, mean)
})
 
</code></pre>

<hr>
<h2 id='reduce_time.array'>Apply a function over time and bands in a four-dimensional (band, time, y, x) array and reduce time dimension</h2><span id='topic+reduce_time.array'></span>

<h3>Description</h3>

<p>Apply a function over time and bands in a four-dimensional (band, time, y, x) array and reduce time dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
reduce_time(x, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_time.array_+3A_x">x</code></td>
<td>
<p>four-dimensional input array with dimensions band, time, y, x (in this order)</p>
</td></tr>
<tr><td><code id="reduce_time.array_+3A_fun">FUN</code></td>
<td>
<p>function which receives one time series in a two-dimensional array with dimensions bands, time as input</p>
</td></tr>
<tr><td><code id="reduce_time.array_+3A_...">...</code></td>
<td>
<p>further arguments passed to FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FUN is expected to produce a numeric vector (or scalar) where elements are interpreted as new bands in the result.
</p>


<h3>Note</h3>

<p>This is a helper function that uses the same dimension ordering as gdalcubes streaming. It can be used to simplify 
the application of R functions e.g. over time series in a data cube.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- c(4,16,32,32)
x &lt;- array(rnorm(prod(d)), d)
# reduce individual bands over pixel time series
y &lt;- reduce_time(x, function(v) {
  apply(v, 1, mean)
})
dim(y)
</code></pre>

<hr>
<h2 id='reduce_time.cube'>Reduce a data cube over the time dimension</h2><span id='topic+reduce_time.cube'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which applies one or more reducer functions to selected bands over pixel time series of a data cube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cube'
reduce_time(
  x,
  expr,
  ...,
  FUN,
  names = NULL,
  load_pkgs = FALSE,
  load_env = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_time.cube_+3A_x">x</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="reduce_time.cube_+3A_expr">expr</code></td>
<td>
<p>either a single string, or a vector of strings defining which reducers will be applied over which bands of the input cube</p>
</td></tr>
<tr><td><code id="reduce_time.cube_+3A_...">...</code></td>
<td>
<p>optional additional expressions (if <code>expr</code> is not a vector)</p>
</td></tr>
<tr><td><code id="reduce_time.cube_+3A_fun">FUN</code></td>
<td>
<p>a user-defined R function applied over pixel time series (see Details)</p>
</td></tr>
<tr><td><code id="reduce_time.cube_+3A_names">names</code></td>
<td>
<p>character vector; names of the output bands, if FUN is provided, the length of names is used as the expected number of output bands</p>
</td></tr>
<tr><td><code id="reduce_time.cube_+3A_load_pkgs">load_pkgs</code></td>
<td>
<p>logical or character; if TRUE, all currently attached packages will be attached automatically before executing FUN in spawned R processes, specific packages can alternatively be provided as a character vector.</p>
</td></tr>
<tr><td><code id="reduce_time.cube_+3A_load_env">load_env</code></td>
<td>
<p>logical or environment; if TRUE, the current global environment will be restored automatically before executing FUN in spawned R processes, can be set to a custom environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can either apply a built-in reducer if expr is given, or apply a custom R reducer function if FUN is provided.
</p>
<p>In the former case, notice that expressions have a very simple format: the reducer is followed by the name of a band in parantheses. You cannot add
more complex functions or arguments. Possible reducers currently are &quot;min&quot;, &quot;max&quot;, &quot;sum&quot;, &quot;prod&quot;, &quot;count&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;var&quot;, &quot;sd&quot;, &quot;which_min&quot;, &quot;which_max&quot;,
&quot;Q1&quot; (1st quartile), and &quot;Q3&quot; (3rd quartile).
</p>
<p>User-defined R reducer functions receive a two-dimensional array as input where rows correspond to the band and columns represent the time dimension. For 
example, one row is the time series of a specific band. FUN should always return a numeric vector with the same number of elements, which will be interpreted
as bands in the result cube. Notice that it is recommended to specify the names of the output bands as a character vector. If names are missing,
the number and names of output bands is tried to be derived automatically, which may fail in some cases. 
</p>
<p>For more details and examples on how to write user-defined functions, please refer to the gdalcubes website 
at <a href="https://gdalcubes.github.io/source/concepts/udfs.html">https://gdalcubes.github.io/source/concepts/udfs.html</a>.
</p>


<h3>Value</h3>

<p>proxy data cube object
</p>


<h3>Note</h3>

<p>Implemented reducers will ignore any NAN values (as na.rm=TRUE does)
</p>
<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.rgb.median = reduce_time(L8.rgb, "median(B02)", "median(B03)", "median(B04)")  
L8.rgb.median


plot(L8.rgb.median, rgb=3:1)


# user defined reducer calculating interquartile ranges
L8.rgb.iqr = reduce_time(L8.rgb, names=c("iqr_R", "iqr_G","iqr_B"), FUN = function(x) {
    c(diff(quantile(x["B04",],c(0.25,0.75), na.rm=TRUE)),
      diff(quantile(x["B03",],c(0.25,0.75), na.rm=TRUE)),
      diff(quantile(x["B02",],c(0.25,0.75), na.rm=TRUE)))
})
L8.rgb.iqr

plot(L8.rgb.iqr, key.pos=1)


</code></pre>

<hr>
<h2 id='rename_bands'>Rename bands of a data cube</h2><span id='topic+rename_bands'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which renames specific bands of a data cube.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rename_bands(cube, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rename_bands_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="rename_bands_+3A_...">...</code></td>
<td>
<p>named arguments with bands that will be renamed, see Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result data cube always contains the same number of bands. No subsetting is 
done if only names for some of the bands are provided. In this case, only 
provided bands are renamed whereas other bands keep their original name. 
Variable arguments must be named by the old band name and the new names must be provided
as simple character values (see example).
</p>


<h3>Value</h3>

<p>proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-07"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.rgb
L8.rgb = rename_bands(L8.cube, B02 = "blue", B03 = "green", B04 = "red")
L8.rgb

</code></pre>

<hr>
<h2 id='select_bands'>Select bands of a data cube</h2><span id='topic+select_bands'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which selects specific bands of a data cube. The resulting cube
will drop any other bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_bands(cube, bands)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_bands_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="select_bands_+3A_bands">bands</code></td>
<td>
<p>character vector with band names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>
<p>For performance reasons, <code>select_bands</code> should always be called directly on a cube created with <code><a href="#topic+raster_cube">raster_cube</a></code> and 
drop all unneded bands. This allows to reduce RasterIO and warp operations in GDAL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-07"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.rgb

plot(L8.rgb, rgb=3:1)


</code></pre>

<hr>
<h2 id='select_time'>Select time slices of a data cube</h2><span id='topic+select_time'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which selects specific time slices of a data cube. The time dimension of the resulting cube
will be irregular / labeled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_time(cube, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_time_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="select_time_+3A_t">t</code></td>
<td>
<p>character vector with date/time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-07"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.rgb = select_time(L8.rgb, c("2018-04", "2018-07"))
L8.rgb

plot(L8.rgb, rgb=3:1)


</code></pre>

<hr>
<h2 id='size'>Query data cube properties</h2><span id='topic+size'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>size of a data cube (number of cells) as integer vector in the order t, y, x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dim.cube">dim.cube</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
size(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='slice_space'>Extract a single time series (spatial slice) from a data cube</h2><span id='topic+slice_space'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which extracts a time series from a data cube defined by spatial coordinates or integer x and y indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_space(cube, loc = NULL, i = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_space_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="slice_space_+3A_loc">loc</code></td>
<td>
<p>numeric length-two vector; spatial coordinates (x, y) of the time series, expressed in the coordinate reference system of the source data cube</p>
</td></tr>
<tr><td><code id="slice_space_+3A_i">i</code></td>
<td>
<p>integer length-2 vector; indexes (x,y) of the time slice (zero-based)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>loc</code> or <code>i</code> must be non-NULL. If both arguments are provided, integer indexes <code>i</code> are ignored.
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P3M", aggregation = "median")
L8.cube = raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.ts = slice_space(L8.rgb, loc = c(5e05, 4400000))
L8.ts


plot(L8.ts, join.timeseries = TRUE)


</code></pre>

<hr>
<h2 id='slice_time'>Extract a single time slice from a data cube</h2><span id='topic+slice_time'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which extracts a time slice from a data cube defined by label (datetime string) or integer index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_time(cube, datetime = NULL, it = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_time_+3A_cube">cube</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="slice_time_+3A_datetime">datetime</code></td>
<td>
<p>character; datetime string of the time slice</p>
</td></tr>
<tr><td><code id="slice_time_+3A_it">it</code></td>
<td>
<p>integer; index of the time slice (zero-based)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>datetime</code> or <code>it</code> must be non-NULL. If both arguments are provided, the integer index <code>it</code> is ignored.
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}
L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M", aggregation = "median")
L8.cube = raster_cube(L8.col, v, mask=image_mask("BQA", bits=4, values=16))
L8.rgb = select_bands(L8.cube, c("B02", "B03", "B04"))
L8.slice = slice_time(L8.rgb, "2018-03")
L8.slice


plot(L8.slice, rgb=3:1, zlim=c(5000,12000))


</code></pre>

<hr>
<h2 id='srs'>Query data cube properties</h2><span id='topic+srs'></span>

<h3>Description</h3>

<p>Query data cube properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srs(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srs_+3A_obj">obj</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The spatial reference system expressed as a string readable by GDAL
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
srs(raster_cube(L8.col, v))
</code></pre>

<hr>
<h2 id='st_as_stars.cube'>Coerce gdalcubes object into a stars object</h2><span id='topic+st_as_stars.cube'></span>

<h3>Description</h3>

<p>The function materializes a data cube as a temporary netCDF file and loads the file 
with the stars package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_as_stars.cube(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_stars.cube_+3A_.x">.x</code></td>
<td>
<p>data cube object to coerce</p>
</td></tr>
<tr><td><code id="st_as_stars.cube_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stars object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-04"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
if(require("stars"))
  st_as_stars(select_bands(raster_cube(L8.col, v), c("B04", "B05")))

</code></pre>

<hr>
<h2 id='stac_image_collection'>Create an image collection from a STAC feature collection</h2><span id='topic+stac_image_collection'></span>

<h3>Description</h3>

<p>This function creates an image collection from a STAC API collection response. It does not
need to read any image data. Additionally, bands can be filtered and asset links can be transformed to make them
readable for GDAL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stac_image_collection(
  s,
  out_file = tempfile(fileext = ".db"),
  asset_names = NULL,
  asset_regex = NULL,
  url_fun = .default_url_fun,
  property_filter = NULL,
  skip_image_metadata = FALSE,
  srs = NULL,
  srs_overwrite = FALSE,
  duration = c("center", "start")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stac_image_collection_+3A_s">s</code></td>
<td>
<p>STAC feature collection</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_out_file">out_file</code></td>
<td>
<p>optional name of the output SQLite database file, defaults to a temporary file</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_asset_names">asset_names</code></td>
<td>
<p>character vector with names of assets (e.g., bands) to be used, other assets will be ignored. By default (NULL), all asset names with &quot;eo:bands&quot; attributes will be used</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_asset_regex">asset_regex</code></td>
<td>
<p>length 1 character defining a regular expression asset names must match to be considered</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_url_fun">url_fun</code></td>
<td>
<p>optional function to modify URLs of assets, e.g, to add /vsicurl/ to URLS (the default)</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_property_filter">property_filter</code></td>
<td>
<p>optional function to filter STAC items (images) by their properties; see Details</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_skip_image_metadata">skip_image_metadata</code></td>
<td>
<p>logical, if TRUE per-image metadata (STAC item properties) will not be added to the image collection</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_srs">srs</code></td>
<td>
<p>character spatial reference system of images used either for images without corresponding STAC property ony or for all images</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_srs_overwrite">srs_overwrite</code></td>
<td>
<p>logical, if FALSE, use srs only for images with unknown srs (missing STAC metadata)</p>
</td></tr>
<tr><td><code id="stac_image_collection_+3A_duration">duration</code></td>
<td>
<p>character, if images represent time intervals, use either the&quot;start&quot; or &quot;center&quot; of time intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The property_filter argument can be used to filter images by metadata such as cloud coverage. 
The functions receives all properties of a STAC item (image) as input list and is expected to produce a single logical value,
where an image will be ignored if the function returns FALSE.
</p>
<p>Some STAC API endpoints may return items with duplicte IDs (image names), pointing to 
identical URLs. Such items are only added once during creation of the image collection.
</p>


<h3>Note</h3>

<p>Currently, bbox results are expected to be WGS84 coordinates, even if bbox-crs is given in the STAC response.
</p>

<hr>
<h2 id='stack_cube'>Create a data cube from a set of images with the same spatial extent and spatial reference system</h2><span id='topic+stack_cube'></span>

<h3>Description</h3>

<p>Create a spatiotemporal data cube directly from images with identical spatial extent and spatial reference system, similar
to a raster stack with an additional dimension supporting both, time and multiple bands / variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stack_cube(
  x,
  datetime_values,
  bands = NULL,
  band_names = NULL,
  chunking = c(1, 256, 256),
  dx = NULL,
  dy = NULL,
  incomplete_ok = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack_cube_+3A_x">x</code></td>
<td>
<p>character vector where items point to image files</p>
</td></tr>
<tr><td><code id="stack_cube_+3A_datetime_values">datetime_values</code></td>
<td>
<p>vector of type character, Date, or POSIXct with recording date of images</p>
</td></tr>
<tr><td><code id="stack_cube_+3A_bands">bands</code></td>
<td>
<p>optional character vector defining the band or spectral band of each item in x, if files relate to different spectral bands or variables</p>
</td></tr>
<tr><td><code id="stack_cube_+3A_band_names">band_names</code></td>
<td>
<p>name of bands, only used if bands is NULL, i.e., if all files contain the same spectral band(s) / variable(s)</p>
</td></tr>
<tr><td><code id="stack_cube_+3A_chunking">chunking</code></td>
<td>
<p>vector of length 3 defining the size of data cube chunks in the order time, y, x.</p>
</td></tr>
<tr><td><code id="stack_cube_+3A_dx">dx</code></td>
<td>
<p>optional target pixel size in x direction, by default (NULL) the original or highest resolution of images is used</p>
</td></tr>
<tr><td><code id="stack_cube_+3A_dy">dy</code></td>
<td>
<p>optional target pixel size in y direction, by default (NULL) the original or highest resolution of images is used</p>
</td></tr>
<tr><td><code id="stack_cube_+3A_incomplete_ok">incomplete_ok</code></td>
<td>
<p>logical, if TRUE (the default), chunks will ignore IO failures and simply use as much images as possible, otherwise the result will contain empty chunks if IO errors or similar occur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a four-dimensional (space, time, bands / variables) raster data cube from a 
set of provided files without the need to create an image collection before. This is  possible if all images
have the same spatial extent and spatial reference system and can be used for two different file organizations:
</p>
<p>1. If all image files share the same bands / variables, the <code>bands</code> argument can be ignored (default NULL) can 
names of the bands can be specified using the <code>band_names</code> argument.
</p>
<p>2. If image files represent different band / variable  (e.g. individual files for red, green, and blue channels), the <code>bands</code>
argument must be used to define the corresponding band / variable. Notice that in this case all files are expected to 
represent exactly one variable / band at one point in datetime. It is not possible to combine files with different
numbers of variables / bands. If image files for different bands have different pixel sizes, the smallest size is used
by default.
</p>
<p>Notice that to avoid opening all image files in advance,no automatic check whether all images share the 
spatial extent and spatial reference system is performed.
</p>


<h3>Value</h3>

<p>A proxy data cube object
</p>


<h3>Note</h3>

<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy example, repeating the same image as a daily time series
L8_file_nir &lt;- 
system.file("L8NY18/LC08_L1TP_014032_20181122_20181129_01_T1/LC08_L1TP_014032_20181122_B5.TIF",
            package = "gdalcubes")
files = rep(L8_file_nir, 10)
datetime = as.Date("2018-11-22") + 1:10
stack_cube(files, datetime, band_names = "B05") 

# using a second band from different files
L8_file_red &lt;- 
system.file("L8NY18/LC08_L1TP_014032_20181122_20181129_01_T1/LC08_L1TP_014032_20181122_B4.TIF",
            package = "gdalcubes")
files = rep(c(L8_file_nir, L8_file_red), each = 10)
datetime = rep(as.Date("2018-11-22") + 1:10, 2)
bands = rep(c("B5","B4"), each = 10)
stack_cube(files, datetime, bands = bands)         

</code></pre>

<hr>
<h2 id='window_space'>Apply a moving window (focal) operation or a convolution kernel over spatial dimensions of a data cube.</h2><span id='topic+window_space'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which applies a convolution kernel or aggregation functions over two-dimensional moving 
windows sliding over spatial slices of a data cube. The function can either execute one or more predefined aggregation functions or 
apply a custom convolution kernel. Among others, use cases include image processing (edge detection, noise reduction, etc.) and
enriching pixel values with local neighborhood properties (e.g. to use as predictor variables in ML models).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_space(x, expr, ..., kernel, window, keep_bands = FALSE, pad = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_space_+3A_x">x</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="window_space_+3A_expr">expr</code></td>
<td>
<p>either a single string, or a vector of strings, defining which reducers will be applied over which bands of the input cube</p>
</td></tr>
<tr><td><code id="window_space_+3A_...">...</code></td>
<td>
<p>optional additional expressions (if expr is not a vector)</p>
</td></tr>
<tr><td><code id="window_space_+3A_kernel">kernel</code></td>
<td>
<p>two dimensional kernel (matrix) applied as convolution (with odd number of rows and columns)</p>
</td></tr>
<tr><td><code id="window_space_+3A_window">window</code></td>
<td>
<p>integer vector with two elements defining the size (number of pixels) of the window in y and x direction, the total size of the window is window[1] *  window[2]</p>
</td></tr>
<tr><td><code id="window_space_+3A_keep_bands">keep_bands</code></td>
<td>
<p>logical; if FALSE (the default), original data cube bands will be dropped.</p>
</td></tr>
<tr><td><code id="window_space_+3A_pad">pad</code></td>
<td>
<p>padding method applied to the borders; use NULL for no padding (NA), a numeric a fill value, or one of &quot;REPLICATE&quot;, &quot;REFLECT&quot;, &quot;REFLECT_PIXEL&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function either applies a kernel convolution (if the <code>kernel</code> argument is provided) or one or more built-in reducer function 
over moving windows. 
</p>
<p>In the former case, the kernel convolution will be applied over all bands of the input 
cube, i.e., the output cube will have the same number of bands as the input cubes.
</p>
<p>To apply one or more aggregation functions over moving windows, the window argument must be provided as a vector with two integer sizes 
in the order y, x. Several string expressions can be provided to create multiple bands in the output cube. 
Notice that expressions have a very simple format: the reducer is followed by the name of a band in parentheses, e.g, &quot;mean(band1)&quot;.
Possible reducers include &quot;min&quot;, &quot;max&quot;, &quot;sum&quot;, &quot;prod&quot;, &quot;count&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;var&quot;, and &quot;sd&quot;.
</p>
<p>Padding methods &quot;REPLICATE&quot;, &quot;REFLECT&quot;, &quot;REFLEX_PIXEL&quot; are defined according to 
<a href="https://openeo.org/documentation/1.0/processes.html#apply_kernel">https://openeo.org/documentation/1.0/processes.html#apply_kernel</a>.
</p>


<h3>Value</h3>

<p>proxy data cube object
</p>


<h3>Note</h3>

<p>Implemented reducers will ignore any NAN values (as <code>na.rm = TRUE</code> does).
</p>
<p>Calling this function consecutively many times may result in long computation times depending on chunk and window sizes due to the need to read adjacent data cube chunks.
</p>
<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
                          bottom=4345299, top=4744931, t0="2018-04", t1="2018-06"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v, chunking = c(1,1000,1000)) 
L8.cube = select_bands(L8.cube, c("B04", "B05")) 
L8.cube.mean5x5 = window_space(L8.cube, kernel = matrix(1/25, 5, 5))
L8.cube.mean5x5


plot(L8.cube.mean5x5, key.pos=1)


L8.cube.med_sd = window_space(L8.cube, "median(B04)" ,"sd(B04)", "median(B05)", "sd(B05)", 
                              window = c(5,5), keep_bands = TRUE)
L8.cube.med_sd

plot(L8.cube.med_sd, key.pos=1)


</code></pre>

<hr>
<h2 id='window_time'>Apply a moving window operation over the time dimension of a data cube</h2><span id='topic+window_time'></span>

<h3>Description</h3>

<p>Create a proxy data cube, which applies one ore more moving window functions to selected bands over pixel time series of a data cube.
The function can either apply a built-in aggregation function or apply a custom one-dimensional 
convolution kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_time(x, expr, ..., kernel, window)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_time_+3A_x">x</code></td>
<td>
<p>source data cube</p>
</td></tr>
<tr><td><code id="window_time_+3A_expr">expr</code></td>
<td>
<p>either a single string, or a vector of strings defining which reducers wlil be applied over which bands of the input cube</p>
</td></tr>
<tr><td><code id="window_time_+3A_...">...</code></td>
<td>
<p>optional additional expressions (if expr is not a vector)</p>
</td></tr>
<tr><td><code id="window_time_+3A_kernel">kernel</code></td>
<td>
<p>numeric vector with elements of the kernel</p>
</td></tr>
<tr><td><code id="window_time_+3A_window">window</code></td>
<td>
<p>integer vector with two elements defining the size of the window before and after a cell, the total size of the window is window[1] + 1 + window[2]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function either applies a kernel convolution (if the <code>kernel</code> argument is provided) or a general reducer function 
over moving temporal windows. In the former case, the kernel convolution will be applied over all bands of the input 
cube, i.e., the output cube will have the same number of bands as the input cubes. If a kernel is given and the <code>window</code> argument is missing, 
the window will be symmetric to the center pixel with the size of the provided kernel. For general reducer functions, the window argument must be provided and
several expressions can be used to create multiple bands in the output cube.
</p>
<p>Notice that expressions have a very simple format: the reducer is followed by the name of a band in parantheses. You cannot add
more complex functions or arguments.
</p>
<p>Possible reducers include &quot;min&quot;, &quot;max&quot;, &quot;sum&quot;, &quot;prod&quot;, &quot;count&quot;, &quot;mean&quot;, and &quot;median&quot;.
</p>


<h3>Value</h3>

<p>proxy data cube object
</p>


<h3>Note</h3>

<p>Implemented reducers will ignore any NAN values (as na.rm=TRUE does).
</p>
<p>This function returns a proxy object, i.e., it will not start any computations besides deriving the shape of the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
                          bottom=4345299, top=4744931, t0="2018-01", t1="2018-07"),
                          srs="EPSG:32618", nx = 400, dt="P1M")
L8.cube = raster_cube(L8.col, v) 
L8.nir = select_bands(L8.cube, c("B05"))
L8.nir.min = window_time(L8.nir, window = c(2,2), "min(B05)")  
L8.nir.min

L8.nir.kernel = window_time(L8.nir, kernel=c(-1,1), window=c(1,0))  
L8.nir.kernel

</code></pre>

<hr>
<h2 id='write_chunk_from_array'>Write chunk data of a cube to stdout or a file</h2><span id='topic+write_chunk_from_array'></span>

<h3>Description</h3>

<p>This function can be used within function passed to <code><a href="#topic+chunk_apply">chunk_apply</a></code> in order to pass four-dimensional R arrays as a
data cube chunk to the gdalcubes C++ library. It works only for R processes, which have been started from the gdalcubes C++ library. 
The input array must have dimensions band, time, y, x (in this order).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_chunk_from_array(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_chunk_from_array_+3A_v">v</code></td>
<td>
<p>four-dimensional array with dimensions band, time, y, and x</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Call this function ONLY from a function passed to <code><a href="#topic+chunk_apply">chunk_apply</a></code>.
</p>
<p>This function only works in R sessions started from gdalcubes streaming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4,
                          bottom=4345299, top=4744931, t0="2018-01", t1="2018-12"),
                          srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
L8.cube = raster_cube(L8.col, v)
L8.cube = select_bands(L8.cube, c("B04", "B05"))
f &lt;- function() {
  x &lt;- read_chunk_as_array()
  out &lt;- reduce_time(x, function(x) {
    cor(x[1,], x[2,], use="na.or.complete", method = "kendall")
  }) 
  write_chunk_from_array(out)
}
L8.cor = chunk_apply(L8.cube, f)
plot(L8.cor, zlim=c(0,1), key.pos=1)

</code></pre>

<hr>
<h2 id='write_ncdf'>Export a data cube as netCDF file(s)</h2><span id='topic+write_ncdf'></span>

<h3>Description</h3>

<p>This function will read chunks of a data cube and write them to a single (the default) or multitple (if <code>chunked = TRUE</code>) netCDF file(s). The resulting
file(s) uses the enhanced netCDF-4 format, supporting chunking and compression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_ncdf(
  x,
  fname = tempfile(pattern = "gdalcubes", fileext = ".nc"),
  overwrite = FALSE,
  write_json_descr = FALSE,
  with_VRT = FALSE,
  pack = NULL,
  chunked = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_ncdf_+3A_x">x</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
<tr><td><code id="write_ncdf_+3A_fname">fname</code></td>
<td>
<p>output file name</p>
</td></tr>
<tr><td><code id="write_ncdf_+3A_overwrite">overwrite</code></td>
<td>
<p>logical; overwrite output file if it already exists</p>
</td></tr>
<tr><td><code id="write_ncdf_+3A_write_json_descr">write_json_descr</code></td>
<td>
<p>logical; write a JSON description of x as additional file</p>
</td></tr>
<tr><td><code id="write_ncdf_+3A_with_vrt">with_VRT</code></td>
<td>
<p>logical; write additional VRT datasets (one per time slice)</p>
</td></tr>
<tr><td><code id="write_ncdf_+3A_pack">pack</code></td>
<td>
<p>reduce output file size by packing values (see Details), defaults to no packing</p>
</td></tr>
<tr><td><code id="write_ncdf_+3A_chunked">chunked</code></td>
<td>
<p>logical; if TRUE, write one netCDF file per chunk; defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting netCDF file(s) contain three dimensions (t, y, x) and bands as variables.
</p>
<p>If <code>write_json_descr</code> is TRUE, the function will write an addition file with the same name as the NetCDF file but 
&quot;.json&quot; suffix. This file includes a serialized description of the input data cube, including all chained data cube operations.
</p>
<p>To reduce the size of created files, values can be packed by applying a scale factor and an offset value and using a smaller
integer data type for storage (only supported if <code>chunked = TRUE</code>). The <code>pack</code> argument can be either NULL (the default), or a list with elements <code>type</code>, <code>scale</code>, <code>offset</code>, 
and <code>nodata</code>. <code>type</code> can be any of &quot;uint8&quot;, &quot;uint16&quot; , &quot;uint32&quot;, &quot;int16&quot;, or &quot;int32&quot;. <code>scale</code>, <code>offset</code>, and 
<code>nodata</code> must be numeric vectors with length one or length equal to the number of data cube bands (to use different values for different bands). 
The helper function  <code><a href="#topic+pack_minmax">pack_minmax</a></code> can be used to derive offset and scale values with maximum precision from minimum and maximum data values on
original scale.
</p>
<p>If <code>chunked = TRUE</code>, names of the produced files will start with <code>name</code> (with removed extension), followed by an underscore and the internal integer chunk number.
</p>


<h3>Value</h3>

<p>returns (invisibly) the path of the created netCDF file(s)
</p>


<h3>Note</h3>

<p>Packing is currently ignored if <code>chunked = TRUE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdalcubes_options">gdalcubes_options</a></code>
</p>
<p><code><a href="#topic+pack_minmax">pack_minmax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-04"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
write_ncdf(select_bands(raster_cube(L8.col, v), c("B04", "B05")), fname=tempfile(fileext = ".nc"))
</code></pre>

<hr>
<h2 id='write_tif'>Export a data cube as a collection of GeoTIFF files</h2><span id='topic+write_tif'></span>

<h3>Description</h3>

<p>This function will time slices of a data cube as GeoTIFF files
in a given directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_tif(
  x,
  dir = tempfile(pattern = ""),
  prefix = basename(tempfile(pattern = "cube_")),
  overviews = FALSE,
  COG = FALSE,
  rsmpl_overview = "nearest",
  creation_options = NULL,
  write_json_descr = FALSE,
  pack = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_tif_+3A_x">x</code></td>
<td>
<p>a data cube proxy object (class cube)</p>
</td></tr>
<tr><td><code id="write_tif_+3A_dir">dir</code></td>
<td>
<p>destination directory</p>
</td></tr>
<tr><td><code id="write_tif_+3A_prefix">prefix</code></td>
<td>
<p>output file name</p>
</td></tr>
<tr><td><code id="write_tif_+3A_overviews">overviews</code></td>
<td>
<p>logical; generate overview images</p>
</td></tr>
<tr><td><code id="write_tif_+3A_cog">COG</code></td>
<td>
<p>logical; create cloud-optimized GeoTIFF files (forces overviews=TRUE)</p>
</td></tr>
<tr><td><code id="write_tif_+3A_rsmpl_overview">rsmpl_overview</code></td>
<td>
<p>resampling method for overviews (image pyramid) generation (see <a href="https://gdal.org/programs/gdaladdo.html">https://gdal.org/programs/gdaladdo.html</a> for available methods)</p>
</td></tr>
<tr><td><code id="write_tif_+3A_creation_options">creation_options</code></td>
<td>
<p>additional creation options for resulting GeoTIFF files, e.g. to define compression (see <a href="https://gdal.org/drivers/raster/gtiff.html#creation-options">https://gdal.org/drivers/raster/gtiff.html#creation-options</a>)</p>
</td></tr>
<tr><td><code id="write_tif_+3A_write_json_descr">write_json_descr</code></td>
<td>
<p>logical; write a JSON description of x as additional file</p>
</td></tr>
<tr><td><code id="write_tif_+3A_pack">pack</code></td>
<td>
<p>reduce output file size by packing values (see Details), defaults to no packing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>write_json_descr</code> is TRUE, the function will write an additional file with name according to prefix (if not missing) or simply cube.json 
This file includes a serialized description of the input data cube, including all chained data cube operations.
</p>
<p>Additional GDAL creation options for resulting GeoTIFF files must be passed as a named list of simple strings, where element names refer to the key. For example,
<code>creation_options = list("COMPRESS" = "DEFLATE", "ZLEVEL" = "5")</code> would enable deflate compression at level 5.
</p>
<p>To reduce the size of created files, values can be packed by applying a scale factor and an offset value and using a smaller
integer data type for storage. The <code>pack</code> argument can be either NULL (the default), or a list with elements <code>type</code>, <code>scale</code>, <code>offset</code>, 
and <code>nodata</code>. <code>type</code> can be any of &quot;uint8&quot;, &quot;uint16&quot; , &quot;uint32&quot;, &quot;int16&quot;, or &quot;int32&quot;. <code>scale</code>, <code>offset</code>, and 
<code>nodata</code> must be numeric vectors with length one or length equal to the number of data cube bands (to use different values for different bands). 
The helper function  <code><a href="#topic+pack_minmax">pack_minmax</a></code> can be used to derive offset and scale values with maximum precision from minimum and maximum data values on
original scale.
</p>
<p>If <code>overviews=TRUE</code>, the numbers of pixels are halved until the longer spatial dimensions counts less than 256 pixels.
Setting <code>COG=TRUE</code> automatically sets <code>overviews=TRUE</code>.
</p>


<h3>Value</h3>

<p>returns (invisibly) a vector of paths pointing to the created GeoTIFF files
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pack_minmax">pack_minmax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create image collection from example Landsat data only 
# if not already done in other examples
if (!file.exists(file.path(tempdir(), "L8.db"))) {
  L8_files &lt;- list.files(system.file("L8NY18", package = "gdalcubes"),
                         ".TIF", recursive = TRUE, full.names = TRUE)
  create_image_collection(L8_files, "L8_L1TP", file.path(tempdir(), "L8.db"), quiet = TRUE) 
}

L8.col = image_collection(file.path(tempdir(), "L8.db"))
v = cube_view(extent=list(left=388941.2, right=766552.4, 
              bottom=4345299, top=4744931, t0="2018-04", t1="2018-04"),
              srs="EPSG:32618", nx = 497, ny=526, dt="P1M")
write_tif(select_bands(raster_cube(L8.col, v), c("B04", "B05")), dir=tempdir())
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
