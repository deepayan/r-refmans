<!DOCTYPE html><html><head><title>Help for package overlapptest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {overlapptest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Astragalus'>
<p>Astragalus and Sesleria Plants</p></a></li>
<li><a href='#centroidiam'>
<p>Compute Centroids and Diameters</p></a></li>
<li><a href='#check.ventana'>
<p>Checks for Anticlockwise Vertices</p></a></li>
<li><a href='#pval'>
<p>P Value for a  Monte Carlo Test of Polygon Overlapping</p></a></li>
<li><a href='#rotawin'>
<p>Rotate Individual Polygons</p></a></li>
<li><a href='#test.intersection'>
<p>Test Overlapping of Polygons Against Random Rotation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Test Overlapping of Polygons Against Random Rotation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcelino de la Cruz Rot</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), spatstat.geom</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcelino de la Cruz &lt;marcelino.delacruz@urjc.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tests the observed overlapping polygon area in a collection of polygons against a null model of random rotation, as explained in De la Cruz et al. (2017) &lt;<a href="https://doi.org/10.13140%2FRG.2.2.12825.72801">doi:10.13140/RG.2.2.12825.72801</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-22 17:17:09 UTC; marcelino</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-22 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Astragalus'>
Astragalus and Sesleria Plants
</h2><span id='topic+Astragalus'></span><span id='topic+Sesleria'></span>

<h3>Description</h3>

<p>Oulines of the individuals of <em>Astragalus sempervirens</em> and <em>Sesleria albicans</em> present in a  2 x 2 m plot in the Pyrenean montains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Astragalus")
data("Sesleria")
</code></pre>


<h3>Format</h3>

<p>Each object is a multiple-polygon window with the format <code><a href="spatstat.geom.html#topic+owin">owin</a></code> of <span class="pkg">spatstat</span>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Astragalus)
Astragalus
plot(Astragalus)
# total area covered by Astragalus
area.owin(Astragalus)
# number of individual polygons
length(Astragalus$bdry)
# area of each individual 
sapply(Astragalus$bdry, function(x) area.owin(owin(poly=x)))
</code></pre>

<hr>
<h2 id='centroidiam'>
Compute Centroids and Diameters
</h2><span id='topic+centroidiam'></span>

<h3>Description</h3>

<p>Computes the centroid and diameter of each individual polygon in a multi-polygon <code><a href="spatstat.geom.html#topic+owin">owin</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroidiam(ventana1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroidiam_+3A_ventana1">ventana1</code></td>
<td>

<p>A multiple-polygon window with the format <code><a href="spatstat.geom.html#topic+owin">owin</a></code> of <span class="pkg">spatstat</span>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iteratively applies the functions <code><a href="spatstat.geom.html#topic+centroid.owin">centroid.owin</a></code> and <code><a href="spatstat.geom.html#topic+diameter">diameter</a></code> of <span class="pkg">spatstat</span> to each polygon in the multipolygon <code><a href="spatstat.geom.html#topic+owin">owin</a></code> and computes its centroid and its diameter.
</p>


<h3>Value</h3>

<table>
<tr><td><code>diams</code></td>
<td>
<p>Vector of diameters</p>
</td></tr>
<tr><td><code>centroids</code></td>
<td>
<p>Matrix with the coordinates of the centroids</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marcelino de la Cruz Rot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Astragalus)
X&lt;-centroidiam(Astragalus)
X$centroids
X$diams
</code></pre>

<hr>
<h2 id='check.ventana'>
Checks for Anticlockwise Vertices
</h2><span id='topic+check.ventana'></span>

<h3>Description</h3>

<p>Checks that the vertices of polygons in a multi-polygon <code><a href="spatstat.geom.html#topic+owin">owin</a></code> object are listed anticlockwise and, if some are not, tries to correct them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.ventana(ventana)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check.ventana_+3A_ventana">ventana</code></td>
<td>

<p>A multiple-polygon window with the format <code><a href="spatstat.geom.html#topic+owin">owin</a></code> of <span class="pkg">spatstat</span>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions should be employed after importing shapefiles into <code><a href="spatstat.geom.html#topic+owin">owin</a></code> objetcs (see vignette). Vertices of the individual polygons in the multiple-polygon  <code><a href="spatstat.geom.html#topic+owin">owin</a></code> objects should be listed anticlockwise to avoid errors in the computations of area overlapp (clockwise listed polygons represent &quot;holes&quot; in <span class="pkg">spatstat</span>). This functions checks this and, in case that the vertices of some polygons are listed clockwise, tries to revert their order. 
</p>


<h3>Value</h3>

<p>A multiple-polygon window with the format <code><a href="spatstat.geom.html#topic+owin">owin</a></code> of <span class="pkg">spatstat</span> with the vertices of all polygons listed anticockwise. The order number of the corrected polygons are included in the attribute &quot;malos1&quot;.  If there has been any polygon whose vertices have not been corrected, their orden number are included in the attribute &quot;malos2&quot;: these polygons should be corrected manually.
</p>


<h3>Author(s)</h3>

<p>Marcelino de la Cruz Rot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Astragalus)
# For illustrative purposes, make the vertices of some individual polygon to be listed clockwise
Astragalus.malo&lt;-Astragalus
Astragalus.malo$bdry[[14]]&lt;-lapply(Astragalus.malo$bdry[[14]], rev)
# check and correct
Astragalus.corrected&lt;-(check.ventana(Astragalus.malo))
attributes(Astragalus.corrected)


</code></pre>

<hr>
<h2 id='pval'>
P Value for a  Monte Carlo Test of Polygon Overlapping
</h2><span id='topic+pval'></span>

<h3>Description</h3>

<p>Computes the p-value and sign of deviation for the hypothesis that  the first value in a vector  is larger or smaller (i.e., a two-sided test)  than the expected value represented by all the other values in the vector, or alternatively, computes a one-sided test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval(x, alternative=c("two.sided", "less", "greater"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pval_+3A_x">x</code></td>
<td>
<p>A vector, usually with some observed statistic in the first position (the observed overlapp) followed by a sequence of the same statistic computed for several realizations of a null model against which we test our hypothesis (i.e., a sequence of simulated, i.e., rotated, overlapps).
</p>
</td></tr>
<tr><td><code id="pval_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative hypothesis, must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;. You can specify just the initial letter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length one whose absolute value represents the p-value and whose sign indicates wether the first value in <code>x</code> is larger (positive) or smaller (negative) than the expected value.
</p>


<h3>Author(s)</h3>

<p>Marcelino de la Cruz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pval(c(0,1:99))
pval(c(100,1:99))
pval(c(100,1:199))
pval(c(200,1:199))
pval(c(0,1:199))
</code></pre>

<hr>
<h2 id='rotawin'>
Rotate Individual Polygons
</h2><span id='topic+rotawin'></span>

<h3>Description</h3>

<p>Randomly rotates individual polygons around their centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotawin(ventana)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotawin_+3A_ventana">ventana</code></td>
<td>

<p>A multiple-polygon window with the format <code><a href="spatstat.geom.html#topic+owin">owin</a></code> of <span class="pkg">spatstat</span>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rotawin</code> applies an independent random rotation to each of the polygons in a multiple-polygon <code><a href="spatstat.geom.html#topic+owin">owin</a></code> object.
</p>


<h3>Value</h3>

<p><code>rotawin</code> returns the original <code><a href="spatstat.geom.html#topic+owin">owin</a></code> object with the individual polygons randomly rotated.
</p>


<h3>Author(s)</h3>

<p>Marcelino de la Cruz Rot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Astragalus)
plot(Astragalus)
plot(rotawin(Astragalus), add=TRUE, border=2)

</code></pre>

<hr>
<h2 id='test.intersection'>
Test Overlapping of Polygons Against Random Rotation
</h2><span id='topic+test.auto.intersection'></span><span id='topic+test.intersection'></span><span id='topic+test.auto.intersection.p'></span><span id='topic+test.intersection.p'></span>

<h3>Description</h3>

<p>These functions test the overlaping surface area of a colection of polygons against a a null model of random rotation. <code>test.auto.intersection</code> test for overlapping between polygons of the same type (i.e., the same species) whereas <code>test.intersection</code> test for overlapping between polygons of different types (i.e., between different species).  <code>test.auto.intersection.p</code> and <code>test.intersection.p</code> functions are parallelized versions which might significantly  reduce computing times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.auto.intersection(ventana1, nsim = 199, win = NULL,
    prop=1, centroides1= NULL,    diametros1 =NULL)
test.intersection(ventana1, ventana2, nsim, prop = 1, win = NULL,
   centroides1 = NULL, diametros1 = NULL, centroides2 = NULL, 
   diametros2 = NULL)
test.auto.intersection.p(ventana1, nsim = 199, win = NULL,
    prop=1, centroides1= NULL,    diametros1 =NULL, ncl=2)
test.intersection.p(ventana1, ventana2, nsim, prop = 1, win = NULL,
   centroides1 = NULL, diametros1 = NULL, centroides2 = NULL, 
   diametros2 = NULL, ncl=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.intersection_+3A_ventana1">ventana1</code></td>
<td>

<p>A multiple-polygon window with the format <code><a href="spatstat.geom.html#topic+owin">owin</a></code> of <span class="pkg">spatstat</span>. The &quot;accessory&quot; species in the case of <code>test.intersection</code>.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_ventana2">ventana2</code></td>
<td>

<p>A multiple-polygon window with the format <code><a href="spatstat.geom.html#topic+owin">owin</a></code> of <span class="pkg">spatstat</span>. The species whose polygons will be rotated (i.e., the &quot;focal&quot; species) in the case of <code>test.intersection</code>.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations for the Monte Carlo test.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_prop">prop</code></td>
<td>

<p>Proportion of the diameter of each polygon which will be employed to select potential close neighbours. See details.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_win">win</code></td>
<td>

<p>Observation window, employed to control for edge effects. An objetct with the format <code><a href="spatstat.geom.html#topic+owin">owin</a></code> of <span class="pkg">spatstat</span>. If not provided, it will be estimated by the <em>x</em> and <em>y</em> ranges from <code>ventana</code>.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_centroides1">centroides1</code></td>
<td>

<p>Matrix or <code>data.frame</code> with the coordinates of the centroids of the polygons of <code>ventana1</code>.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_diametros1">diametros1</code></td>
<td>

<p>Vector with the diameters of the polygons of <code>ventana1</code>.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_centroides2">centroides2</code></td>
<td>

<p>Matrix or <code>data.frame</code> with the coordinates of the centroids of the polygons of <code>ventana2</code>.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_diametros2">diametros2</code></td>
<td>

<p>Vector with the diameters of the polygons of <code>ventana2</code>.
</p>
</td></tr>
<tr><td><code id="test.intersection_+3A_ncl">ncl</code></td>
<td>

<p>Number of clusters for the parallel implementation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary statistic employed in the test is the overall sum of the overlapping areas of intersecting polygons. To reduce the computing burden, area intersections are only computed for polygon pairs for which the distance between their centoids is smaller than the sum of their largest diameters (weighted by the argument <code>prop</code>). To avoid edge effects, the test only considers polygons whose centroids are separated from the border of the observation window by a distance larger than their largest diameter.
In the pairwise tests, the polygons of <code>ventana1</code> are kept fixed in their original positions (i.e., the accessory species) and the polygons of <code>ventana2</code> (i.e., the focal species) are rotated.
</p>


<h3>Value</h3>

<p>Both <code>test.auto.intersection</code> and <code>test.intersection</code> return a vector of length <code>nsim</code>+1, with the sum of observed overlaping areas in the first position and subsequently with the sum of overlapping areas in each the simulated (i.e., randomly rotated) realizations of the null model.
</p>


<h3>Author(s)</h3>

<p>Marcelino de la Cruz Rot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Astragalus)
data(Sesleria)

# Test overlapping between Astragalus individuals
  # Ideally nsim should be at least 199
   Astragalus.test&lt;- test.auto.intersection(Astragalus, nsim=19)
   # Observed overlapping area
   Astragalus.test[1]
   # p-value (negative value indicates that the observed overlapping is smaller 
   # than expected)
   pval(Astragalus.test)


# Test overlapping between Astragalus  and Sesleria individuals.
# Here, Sesleria is the accesory species (its individuals are kept fixed during the
# test) and Astragalus  the focal one (its individuals are rotated)
# Ideally nsim should be at least 199
   Sesleria.Astragalus.test&lt;- test.intersection(ventana1= Sesleria, 
                                                   ventana2= Astragalus, nsim=19)
   # Observed overlapping area
   Sesleria.Astragalus.test[1]
   # p-value (negative value indicates that the observed overlapping is smaller
   # than expected)
   pval(Sesleria.Astragalus.test)
   
 

# Reducing computing burden when making repetitive testing
 

# First, put all the polygonal regions in a list, i.e.
 owins&lt;- list(Astragalus, Sesleria)
 
 # compute diameters and centroids of the individual polygons 
 # in each polygonal region
 
centroids&lt;- list()
diams&lt;- list()
  for ( i in 1: length(owins)){
    cd&lt;- centroidiam(owins[[i]])
    centroids[[i]] &lt;- cd$centroids
    diams[[i]] &lt;- cd$diams
}

# set the number of simulations for each test
# Ideally nsim should be at least 199
online &lt;- interactive()
Nsim &lt;- if(online) 19 else 3

# create an array to store the results
result &lt;- array(NA, dim=c(length(owins),length(owins),Nsim+1))

t0&lt;-Sys.time()
for ( i in 1: length(owins)){
   for ( j in 1: length(owins)){
     cat(i,j,"\n")
       if(j!=i) result[i,j,] &lt;- test.intersection(owins[[i]], owins[[j]], nsim=Nsim,
		centroides1=centroids[[i]], diametros1=diams[[i]],
		centroides2=centroids[[j]], diametros2=diams[[j]]) else
		result[i,j,] &lt;-  test.auto.intersection(owins[[i]], nsim=Nsim,
		centroides1=centroids[[i]], diametros1=diams[[i]])
   }
}
 Sys.time()-t0
 
 # observed values (focal species in columns)
 (observed&lt;-  t(result[,,1]))
 # p-values
 tabla.p&lt;- apply(result,c(1,2),pval)
 (p_values &lt;- t(tabla.p))
 
 # Compare with parallelized versions:
  
# create an array to store the result.ps
result.p&lt;- array(NA, dim=c(length(owins),length(owins),Nsim+1))

t0&lt;-Sys.time()
for ( i in 1: length(owins)){
   for ( j in 1: length(owins)){
     cat(i,j,"\n")
       if(j!=i) result.p[i,j,] &lt;- test.intersection.p(owins[[i]], owins[[j]], nsim=Nsim,
		centroides1=centroids[[i]], diametros1=diams[[i]],
		centroides2=centroids[[j]], diametros2=diams[[j]]) else
		result.p[i,j,] &lt;-  test.auto.intersection.p(owins[[i]], nsim=Nsim,
		centroides1=centroids[[i]], diametros1=diams[[i]])
   }
}
 Sys.time()-t0
 
 # observed values (focal species in columns)
 (observed.p&lt;-  t(result.p[,,1]))
 # p-values
 tabla.p.p&lt;- apply(result.p,c(1,2),pval)
 (p_values.p &lt;- t(tabla.p.p))
 
 

 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
