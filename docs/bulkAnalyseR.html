<!DOCTYPE html><html><head><title>Help for package bulkAnalyseR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bulkAnalyseR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#calculate_condition_mean_sd_per_gene'><p>Calculate statistics for each gene of an expression matrix given a grouping</p></a></li>
<li><a href='#cross_plot'><p>Create a cross plot comparing differential expression (DE) results</p></a></li>
<li><a href='#crossPanel'><p>Generate the cross plot panel of the shiny app</p></a></li>
<li><a href='#DEanalysis'><p>Perform differential expression (DE) analysis on an expression matrix</p></a></li>
<li><a href='#DEpanel'><p>Generate the DE panel of the shiny app</p></a></li>
<li><a href='#DEplotPanel'><p>Generate the DE plot plot panel of the shiny app</p></a></li>
<li><a href='#DEsummaryPanel'><p>Generate the DE summary panel of the shiny app</p></a></li>
<li><a href='#determine_uds'><p>Determine the pattern between two intervals</p></a></li>
<li><a href='#enrichmentPanel'><p>Generate the enrichment panel of the shiny app</p></a></li>
<li><a href='#expression_heatmap'><p>Create heatmap of an expression matrix</p></a></li>
<li><a href='#find_regulators_with_recurring_edges'><p>Find recurring regulators</p></a></li>
<li><a href='#generateShinyApp'><p>Generate all files required for an autonomous shiny app</p></a></li>
<li><a href='#genes_barplot'><p>Create a bar plot of expression for selected genes across samples in an experiment</p></a></li>
<li><a href='#get_link_list_rename'><p>Convert the adjacency matrix to network links</p></a></li>
<li><a href='#GRNCisPanel'><p>Generate the GRN cis integration panel of the shiny app</p></a></li>
<li><a href='#GRNCustomPanel'><p>Generate the GRN custom integration panel of the shiny app</p></a></li>
<li><a href='#GRNpanel'><p>Generate the GRN panel of the shiny app</p></a></li>
<li><a href='#GRNTransPanel'><p>Generate the GRN trans integration panel of the shiny app</p></a></li>
<li><a href='#infer_GRN'><p>Perform GRN inference</p></a></li>
<li><a href='#jaccard_heatmap'><p>Create a heatmap of the Jaccard similarity index (JSI) between samples of</p>
an experiment</a></li>
<li><a href='#jaccard_index'><p>Calculate the Jaccard similarity index (JSI) between two vectors</p></a></li>
<li><a href='#landingPanel'><p>Generate the landing page panel of the shiny app</p></a></li>
<li><a href='#ma_plot'><p>Create an MA plot visualising differential expression (DE) results</p></a></li>
<li><a href='#make_heatmap_matrix'><p>Create a matrix of the average expression of each gene in each condition</p></a></li>
<li><a href='#make_pattern_matrix'><p>Create a matrix of the patterns between conditions</p></a></li>
<li><a href='#modalityPanel'><p>Generate an app panel for a modality</p></a></li>
<li><a href='#noisyr_counts_with_plot'><p>Apply a modified noisyR counts pipeline printing a plot</p></a></li>
<li><a href='#patternPanel'><p>Generate the expression patterns panel of the shiny app</p></a></li>
<li><a href='#plot_GRN'><p>Plot a GRN</p></a></li>
<li><a href='#plot_line_pattern'><p>Create a line plot of average expression across conditions</p></a></li>
<li><a href='#plot_pca'><p>Create a principal component analysis (PCA) plot the samples of an experiment</p></a></li>
<li><a href='#plot_upset'><p>Visualise the overlap of edges between different networks</p></a></li>
<li><a href='#preprocess_miRTarBase'><p>Creates a comparison table for miRTarBase to be used for custom integration</p></a></li>
<li><a href='#preprocessExpressionMatrix'><p>Pre-process the expression matrix before generating the shiny app</p></a></li>
<li><a href='#qc_density_plot'><p>Create a density plot of log2 expression across samples of an experiment</p></a></li>
<li><a href='#qc_violin_plot'><p>Create a violin/box plot of expression across samples of an experiment</p></a></li>
<li><a href='#QCpanel'><p>Generate the QC panel of the shiny app</p></a></li>
<li><a href='#rescale_matrix'><p>Rescale a matrix</p></a></li>
<li><a href='#sampleSelectPanel'><p>Generate the sample select panel of the shiny app</p></a></li>
<li><a href='#scatter_plot'><p>Create a scatter plot of expression between two samples of an experiment</p></a></li>
<li><a href='#volcano_plot'><p>Create a volcano plot visualising differential expression (DE) results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interactive Shiny App for Bulk Sequencing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ilias Moutsopoulos &lt;im383@cam.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Given an expression matrix from a bulk sequencing experiment,
        pre-processes it and creates a shiny app for interactive data 
        analysis and visualisation. The app contains quality checks,
        differential expression analysis, volcano and cross plots,
        enrichment analysis and gene regulatory network inference,
        and can be customised to contain more panels by the user.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Core-Bioinformatics/bulkAnalyseR">https://github.com/Core-Bioinformatics/bulkAnalyseR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Core-Bioinformatics/bulkAnalyseR/issues">https://github.com/Core-Bioinformatics/bulkAnalyseR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, shiny, gprofiler2, edgeR, DESeq2, stats, ggrepel,
utils, RColorBrewer, ComplexHeatmap, circlize, grid,
shinyWidgets, shinyjqui, dplyr, magrittr, ggforce, rlang, glue,
preprocessCore, matrixStats, noisyr, tibble, ggnewscale,
ggrastr, GENIE3, visNetwork, DT, scales, shinyjs, tidyr,
shinyLP, UpSetR, stringr, ggVennDiagram</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, shinythemes, BiocManager, AnnotationDbi,
org.Hs.eg.db, org.Mm.eg.db, readxl, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-15 11:49:47 UTC; emouts</td>
</tr>
<tr>
<td>Author:</td>
<td>Ilias Moutsopoulos [aut, cre],
  Eleanor Williams [aut, ctb],
  Irina Mohorianu [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-15 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='calculate_condition_mean_sd_per_gene'>Calculate statistics for each gene of an expression matrix given a grouping</h2><span id='topic+calculate_condition_mean_sd_per_gene'></span>

<h3>Description</h3>

<p>This function calculates the mean and standard deviation of
the expression of each gene in an expression matrix, grouped by the conditions
supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_condition_mean_sd_per_gene(expression.matrix, condition)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_condition_mean_sd_per_gene_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="calculate_condition_mean_sd_per_gene_+3A_condition">condition</code></td>
<td>
<p>the condition to group the columns of the expression matrix
by; must be a factor of the same length as ncol(expression.matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble in long format, with the mean and standard deviation of
each gene in each condition. The standard deviation is increased to the
minimum value in the expression matrix (the noise threshold) if it is lower,
in order to avoid sensitivity to small changes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

condition &lt;- factor(rep(c("0h", "12h", "36h"), each = 2))
tbl &lt;- calculate_condition_mean_sd_per_gene(expression.matrix.preproc[1:10, ], condition)
tbl
</code></pre>

<hr>
<h2 id='cross_plot'>Create a cross plot comparing differential expression (DE) results</h2><span id='topic+cross_plot'></span>

<h3>Description</h3>

<p>This function creates a cross plot visualising the differences
in log2(fold-change) between two DE analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_plot(
  DEtable1,
  DEtable2,
  DEtable1Subset,
  DEtable2Subset,
  df = NULL,
  lfc.threshold = NULL,
  raster = FALSE,
  mask = FALSE,
  labnames = c("not DE", "DE both", "DE comparison 1", "DE comparison 2"),
  cols.chosen = c("grey", "purple", "dodgerblue", "lightcoral"),
  labels.per.region = 5,
  fix.axis.ratio = TRUE,
  add.guide.lines = TRUE,
  add.labels.custom = FALSE,
  genes.to.label = NULL,
  seed = 0,
  label.force = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_plot_+3A_detable1">DEtable1</code>, <code id="cross_plot_+3A_detable2">DEtable2</code>, <code id="cross_plot_+3A_detable1subset">DEtable1Subset</code>, <code id="cross_plot_+3A_detable2subset">DEtable2Subset</code></td>
<td>
<p>tables of DE results,
usually generated by <code><a href="#topic+DEanalysis_edger">DEanalysis_edger</a></code>; the first two should
contain all genes, while the second two should only contain DE genes</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_df">df</code></td>
<td>
<p>Optionally, pre-computed cross plot table, from cross_plot_prep</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_lfc.threshold">lfc.threshold</code></td>
<td>
<p>the log2(fold-change)
threshold to determine whether a gene is DE</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_raster">raster</code></td>
<td>
<p>whether to rasterize non-DE genes with ggraster to reduce
memory usage; particularly useful when saving plots to files</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_mask">mask</code></td>
<td>
<p>whether to hide genes that were not called DE in either
comparison; default is FALSE</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_labnames">labnames</code>, <code id="cross_plot_+3A_cols.chosen">cols.chosen</code></td>
<td>
<p>the legend labels and colours for the 4
categories of genes (&quot;not DE&quot;, &quot;DE both&quot;, &quot;DE comparison 1&quot;, &quot;DE comparison 2&quot;)</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_labels.per.region">labels.per.region</code></td>
<td>
<p>how many labels to show in each region of the plot;
the plot is split in 8 regions using the axes and major diagonals, and the
points closest to the origin in each region are labelled; default is
5, set to 0 for no labels</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_fix.axis.ratio">fix.axis.ratio</code></td>
<td>
<p>whether to ensure the x and y axes have the same
units, resulting in a square plot; default is TRUE</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_add.guide.lines">add.guide.lines</code></td>
<td>
<p>whether to add vertical and horizontal guide lines
to the plot to highlight the thresholds; default is TRUE</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_add.labels.custom">add.labels.custom</code></td>
<td>
<p>whether to add labels to user-specified genes;
the parameter genes.to.label must also be specified; default is FALSE</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_genes.to.label">genes.to.label</code></td>
<td>
<p>a vector of gene names to be labelled in the
plot; if names are present those are shown as the labels (but the values are
the ones matched - this is to allow custom gene names to be presented)</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_seed">seed</code></td>
<td>
<p>the random seed to be used for reproducibility; only used for
ggrepel::geom_label_repel if labels are present</p>
</td></tr>
<tr><td><code id="cross_plot_+3A_label.force">label.force</code></td>
<td>
<p>passed to the force argument of ggrepel::geom_label_repel;
higher values make labels overlap less (at the cost of them being further
away from the points they are labelling)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cross plot as a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500, 1:4]

anno &lt;- AnnotationDbi::select(
  getExportedValue('org.Mm.eg.db', 'org.Mm.eg.db'),
  keys = rownames(expression.matrix.preproc),
  keytype = 'ENSEMBL',
  columns = 'SYMBOL'
) %&gt;%
  dplyr::distinct(ENSEMBL, .keep_all = TRUE) %&gt;%
  dplyr::mutate(NAME = ifelse(is.na(SYMBOL), ENSEMBL, SYMBOL))
  
edger &lt;- DEanalysis_edger(
  expression.matrix = expression.matrix.preproc,
  condition = rep(c("0h", "12h"), each = 2),
  var1 = "0h",
  var2 = "12h",
  anno = anno
)
deseq &lt;- DEanalysis_edger(
  expression.matrix = expression.matrix.preproc,
  condition = rep(c("0h", "12h"), each = 2),
  var1 = "0h",
  var2 = "12h",
  anno = anno
)
cross_plot(
  DEtable1 = edger, 
  DEtable2 = deseq,
  DEtable1Subset = dplyr::filter(edger, abs(log2FC) &gt; 1, pvalAdj &lt; 0.05),
  DEtable2Subset = dplyr::filter(deseq, abs(log2FC) &gt; 1, pvalAdj &lt; 0.05),
  labels.per.region = 0
)
</code></pre>

<hr>
<h2 id='crossPanel'>Generate the cross plot panel of the shiny app</h2><span id='topic+crossPanel'></span><span id='topic+crossPanelUI'></span><span id='topic+crossPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the cross plot panel of the
shiny app. It is generated by including 'Cross' in the panels.default argument
of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossPanelUI(id, metadata, show = TRUE)

crossPanelServer(id, expression.matrix, metadata, anno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="crossPanel_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="crossPanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="crossPanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="crossPanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='DEanalysis'>Perform differential expression (DE) analysis on an expression matrix</h2><span id='topic+DEanalysis'></span><span id='topic+DEanalysis_edger'></span><span id='topic+DEanalysis_deseq2'></span>

<h3>Description</h3>

<p>This function performs DE analysis on an expression using
edgeR or DESeq2, given a vector of sample conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEanalysis_edger(expression.matrix, condition, var1, var2, anno)

DEanalysis_deseq2(expression.matrix, condition, var1, var2, anno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEanalysis_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="DEanalysis_+3A_condition">condition</code></td>
<td>
<p>a vector of the same length as the number of columns of
expression.matrix, containing the sample conditions; this is usually the
last column of the metadata</p>
</td></tr>
<tr><td><code id="DEanalysis_+3A_var1">var1</code>, <code id="DEanalysis_+3A_var2">var2</code></td>
<td>
<p>conditions (contained in condition) to perform DE between;
note that DESeq2 requires at least two replicates per condition</p>
</td></tr>
<tr><td><code id="DEanalysis_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the differential expression results for all genes.
Columns are
</p>

<ul>
<li><p> gene_id (usually ENSEMBL ID matching one of the rows of the
expression matrix)
</p>
</li>
<li><p> gene_name (name matched through the annotation)
</p>
</li>
<li><p> log2exp (average log2(expression) of the gene across samples)
</p>
</li>
<li><p> log2FC (log2(fold-change) of the gene between conditions)
</p>
</li>
<li><p> pval (p-value of the gene being called DE)
</p>
</li>
<li><p> pvalAdj (adjusted p-value using the Benjamini Hochberg correction)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:100, 1:4]

anno &lt;- AnnotationDbi::select(
  getExportedValue('org.Mm.eg.db', 'org.Mm.eg.db'),
  keys = rownames(expression.matrix.preproc),
  keytype = 'ENSEMBL',
  columns = 'SYMBOL'
) %&gt;%
  dplyr::distinct(ENSEMBL, .keep_all = TRUE) %&gt;%
  dplyr::mutate(NAME = ifelse(is.na(SYMBOL), ENSEMBL, SYMBOL))
  
edger &lt;- DEanalysis_edger(
  expression.matrix = expression.matrix.preproc,
  condition = rep(c("0h", "12h"), each = 2),
  var1 = "0h",
  var2 = "12h",
  anno = anno
)
deseq &lt;- DEanalysis_edger(
  expression.matrix = expression.matrix.preproc,
  condition = rep(c("0h", "12h"), each = 2),
  var1 = "0h",
  var2 = "12h",
  anno = anno
)
# DE genes with log2(fold-change) &gt; 1 in both pipelines
intersect(
  dplyr::filter(edger, abs(log2FC) &gt; 1, pvalAdj &lt; 0.05)$gene_name,
  dplyr::filter(deseq, abs(log2FC) &gt; 1, pvalAdj &lt; 0.05)$gene_name
)
</code></pre>

<hr>
<h2 id='DEpanel'>Generate the DE panel of the shiny app</h2><span id='topic+DEpanel'></span><span id='topic+DEpanelUI'></span><span id='topic+DEpanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the DE panel of the
shiny app. It is generated by including 'DE' in the panels.default argument
of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEpanelUI(id, metadata, show = TRUE)

DEpanelServer(id, expression.matrix, metadata, anno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEpanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="DEpanel_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="DEpanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="DEpanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="DEpanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='DEplotPanel'>Generate the DE plot plot panel of the shiny app</h2><span id='topic+DEplotPanel'></span><span id='topic+DEplotPanelUI'></span><span id='topic+DEplotPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the DE plot panel of the
shiny app. It is generated by including 'DEplot' in the panels.default argument
of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEplotPanelUI(id, show = TRUE)

DEplotPanelServer(id, DEresults, anno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEplotPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="DEplotPanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="DEplotPanel_+3A_deresults">DEresults</code></td>
<td>
<p>differential expression results output from DEpanelServer;
a reactive list with slots 'DEtable' (all genes), 'DEtableSubset' (only DE genes),
'lfcThreshold' and 'pvalThreshold'</p>
</td></tr>
<tr><td><code id="DEplotPanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='DEsummaryPanel'>Generate the DE summary panel of the shiny app</h2><span id='topic+DEsummaryPanel'></span><span id='topic+DEsummaryPanelUI'></span><span id='topic+DEsummaryPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the Heatmap panel of the
shiny app. It is generated by including 'DEsummary' in the panels.default argument
of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEsummaryPanelUI(id, metadata, show = TRUE)

DEsummaryPanelServer(id, expression.matrix, metadata, DEresults, anno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEsummaryPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="DEsummaryPanel_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="DEsummaryPanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="DEsummaryPanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="DEsummaryPanel_+3A_deresults">DEresults</code></td>
<td>
<p>differential expression results output from DEpanelServer;
a reactive list with slots 'DEtable' (all genes), 'DEtableSubset' (only DE genes),
'lfcThreshold' and 'pvalThreshold'</p>
</td></tr>
<tr><td><code id="DEsummaryPanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='determine_uds'>Determine the pattern between two intervals</h2><span id='topic+determine_uds'></span>

<h3>Description</h3>

<p>This function checks if the two input intervals oferlap and
outputs the corresponding pattern (up, down, or straight) based on that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_uds(min1, max1, min2, max2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_uds_+3A_min1">min1</code>, <code id="determine_uds_+3A_max1">max1</code>, <code id="determine_uds_+3A_min2">min2</code>, <code id="determine_uds_+3A_max2">max2</code></td>
<td>
<p>the endpoints of the two intervals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single character (one of &quot;U&quot;, &quot;D&quot;, &quot;S&quot;) representing the pattern
</p>


<h3>Examples</h3>

<pre><code class='language-R'>determine_uds(10, 20, 15, 25) # overlap
determine_uds(10, 20, 25, 35) # no overlap
</code></pre>

<hr>
<h2 id='enrichmentPanel'>Generate the enrichment panel of the shiny app</h2><span id='topic+enrichmentPanel'></span><span id='topic+enrichmentPanelUI'></span><span id='topic+enrichmentPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the enrichment panel of the
shiny app. It is generated by including 'Enrichment' in the panels.default argument
of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enrichmentPanelUI(id, show = TRUE)

enrichmentPanelServer(id, DEresults, organism, seed = 13)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enrichmentPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="enrichmentPanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="enrichmentPanel_+3A_deresults">DEresults</code></td>
<td>
<p>differential expression results output from DEpanelServer;
a reactive list with slots 'DEtable' (all genes), 'DEtableSubset' (only DE genes),
'lfcThreshold' and 'pvalThreshold'</p>
</td></tr>
<tr><td><code id="enrichmentPanel_+3A_organism">organism</code></td>
<td>
<p>organism name to be passed on to <code>gprofiler2::gost</code>;
organism names are constructed by concatenating the first letter of the
name and the family name; default is NA - enrichment is not included
to ensure compatibility with datasets that have non-standard gene names;
a vector (of the same length as modality) can be provided if
<code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="enrichmentPanel_+3A_seed">seed</code></td>
<td>
<p>the random seed to be set for the jitter plot, to avoid
seemingly different plots for the same inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='expression_heatmap'>Create heatmap of an expression matrix</h2><span id='topic+expression_heatmap'></span>

<h3>Description</h3>

<p>This function creates a heatmap to visualise an expression matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expression_heatmap(
  expression.matrix.subset,
  top.annotation.ids = NULL,
  metadata,
  type = c("Z-score", "Log2 Expression", "Expression"),
  show.column.names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expression_heatmap_+3A_expression.matrix.subset">expression.matrix.subset</code></td>
<td>
<p>a subset of rows from the expression matrix;
rows correspond to genes and columns correspond to samples</p>
</td></tr>
<tr><td><code id="expression_heatmap_+3A_top.annotation.ids">top.annotation.ids</code></td>
<td>
<p>a vector of column indices denoting which columns
of the metadata should become heatmap annotations</p>
</td></tr>
<tr><td><code id="expression_heatmap_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="expression_heatmap_+3A_type">type</code></td>
<td>
<p>type of rescaling; one of &quot;Expression&quot; (defautl, does nothing),
&quot;Log2 Expression&quot; (returns log2(x + 1) for every value), &quot;Mean Scaled&quot; (each
row is scaled by its average), &quot;Z-score&quot; (each row is centered and scaled
to mean = 0 and sd = 1)</p>
</td></tr>
<tr><td><code id="expression_heatmap_+3A_show.column.names">show.column.names</code></td>
<td>
<p>whether to show the column names below the heatmap;
default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The heatmap as detailed in the ComplexHeatmap package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

metadata &lt;- data.frame(
  srr = colnames(expression.matrix.preproc), 
  timepoint = rep(c("0h", "12h", "36h"), each = 2)
)
print(expression_heatmap(head(expression.matrix.preproc), NULL, metadata))
</code></pre>

<hr>
<h2 id='find_regulators_with_recurring_edges'>Find recurring regulators</h2><span id='topic+find_regulators_with_recurring_edges'></span>

<h3>Description</h3>

<p>This function finds regulators that appear as the
same network edge in more than one of the input networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_regulators_with_recurring_edges(weightMatList, plotConnections)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_regulators_with_recurring_edges_+3A_weightmatlist">weightMatList</code></td>
<td>
<p>a list of (weighted) adjacency matrices;
each list element must be an adjacency matrix with regulators in rows,
targets in columns</p>
</td></tr>
<tr><td><code id="find_regulators_with_recurring_edges_+3A_plotconnections">plotConnections</code></td>
<td>
<p>the number of connections to subset to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the names of the recurring regulators
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weightMat1 &lt;- matrix(
  c(0.1, 0.4, 0.8, 0.3), nrow = 2, ncol = 2,
  dimnames = list("regulators" = c("r1", "r2"), "targets" = c("t1", "t2"))
)
weightMat2 &lt;- matrix(
  c(0.1, 0.2, 0.8, 0.3), nrow = 2, ncol = 2,
  dimnames = list("regulators" = c("r1", "r2"), "targets" = c("t1", "t2"))
)
find_regulators_with_recurring_edges(list(weightMat1, weightMat2), 2)
</code></pre>

<hr>
<h2 id='generateShinyApp'>Generate all files required for an autonomous shiny app</h2><span id='topic+generateShinyApp'></span>

<h3>Description</h3>

<p>This function creates an app.R file and all required objects
to run the app in .rda format in the target directory. A basic argument
check is performed to avoid input data problems. The app directory
is standalone and can be used on another platform, as long as bulkAnalyseR
is installed there. It is recommended to run
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code> before this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateShinyApp(
  shiny.dir = "shiny_bulkAnalyseR",
  app.title = "Visualisation of RNA-Seq data",
  theme = "flatly",
  modality = "RNA",
  expression.matrix,
  metadata,
  organism = NA,
  org.db = NA,
  panels.default = c("Landing", "SampleSelect", "QC", "GRN", "DE", "DEplot", "DEsummary",
    "Enrichment", "GRNenrichment", "Cross", "Patterns"),
  panels.extra = tibble::tibble(name = NULL, UIfun = NULL, UIvars = NULL, serverFun =
    NULL, serverVars = NULL),
  data.extra = list(),
  packages.extra = c(),
  cis.integration = tibble::tibble(reference.expression.matrix = NULL, reference.org.db =
    NULL, reference.coord = NULL, comparison.coord = NULL, reference.table.name = NULL,
    comparison.table.name = NULL),
  trans.integration = tibble::tibble(reference.expression.matrix = NULL, reference.org.db
    = NULL, comparison.expression.matrix = NULL, comparison.org.db = NULL,
    reference.table.name = NULL, comparison.table.name = NULL),
  custom.integration = tibble::tibble(reference.expression.matrix = NULL,
    reference.org.db = NULL, comparison.table = NULL, reference.table.name = NULL,
    comparison.table.name = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateShinyApp_+3A_shiny.dir">shiny.dir</code></td>
<td>
<p>directory to store the shiny app; if a non-empty
directory with that name already exists an error is generated</p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_app.title">app.title</code></td>
<td>
<p>title to be displayed within the app</p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_theme">theme</code></td>
<td>
<p>shiny theme to be used in the app; default is 'flatly'</p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_modality">modality</code></td>
<td>
<p>name of the modality, or a vector of modalities to be
included in the app</p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_organism">organism</code></td>
<td>
<p>organism name to be passed on to <code>gprofiler2::gost</code>;
organism names are constructed by concatenating the first letter of the
name and the family name; default is NA - enrichment is not included
to ensure compatibility with datasets that have non-standard gene names;
a vector (of the same length as modality) can be provided if
<code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_org.db">org.db</code></td>
<td>
<p>database for annotations to transform ENSEMBL IDs to
gene names; a list of bioconductor packaged databases can be found with
<code>BiocManager::available("^org\.")</code>;
default in NA, in which case the row names of the expression matrix are
used directly - it is recommended to provide ENSEMBL IDs if the database
for your model organism is available;
a vector (of the same length as modality) can be provided if
<code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_panels.default">panels.default</code></td>
<td>
<p>argument to control which of the default panels
will be included in the app; default is all, but the enrichment panel
will not appear unless organism is also supplied; note that the 'DE' panel
is required for 'DEplot', 'DEsummary', 'Enrichment', and 'GRNenrichment'; a list  (of the same
length as modality) can be provided if <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_panels.extra">panels.extra</code>, <code id="generateShinyApp_+3A_data.extra">data.extra</code>, <code id="generateShinyApp_+3A_packages.extra">packages.extra</code></td>
<td>
<p>functionality to add new
user-created panels to the app to extend functionality or change the default
behaviour of existing panels; a data frame of the modality, panel UI and
server names and default parameters should be passed to panels.extra
(see example); the names of any packages required
should be passed to the packages.extra argument; extra data should be a
single list and passed to the data.extra argument</p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_cis.integration">cis.integration</code></td>
<td>
<p>functionality to integrate extra cis-regulatory
information into GRN panel. Tibble containing names of reference expression
matrix, tables of coordinates for elements corresponding to rows of reference
expression matrix (reference.coord), tables of coordinates to compare against
reference.coord (comparison.coord) and names for comparison tables. See
vignettes for more details about inputs.</p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_trans.integration">trans.integration</code></td>
<td>
<p>functionality to integrate extra trans-regulatory
information into GRN panel. Tibble containing names of reference expression
matrix, (reference.expression.matrix), comparison expression matrix
(comparison.expression.matrix). Organism database names for each expression
matrix and names for each table are also required. See vignettes for more
details about inputs.</p>
</td></tr>
<tr><td><code id="generateShinyApp_+3A_custom.integration">custom.integration</code></td>
<td>
<p>functionality to integrate custom information
related to rows of reference expression matrix. Tibble containing names
of reference expression matrix, tables (comparison.table) with Reference_ID
and Reference_Name (matching ENSEMBL and NAME columns of reference organism
database) and Comparison_ID and Comparison_Name plus a Category column
containing extra information. Names for the reference
expression matrix and comparison table (comparison.table.name)
are also required. See vignettes for more details about inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to shiny.dir (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))
metadata &lt;- data.frame(
  srr = colnames(expression.matrix.preproc), 
  timepoint = rep(c("0h", "12h", "36h"), each = 2)
)
app.dir &lt;- generateShinyApp(
  shiny.dir = paste0(tempdir(), "/shiny_Yang2019"),
  app.title = "Shiny app for the Yang 2019 data",
  modality = "RNA",
  expression.matrix = expression.matrix.preproc,
  metadata = metadata,
  organism = "mmusculus",
  org.db = "org.Mm.eg.db"
)
# runApp(app.dir)

# Example of an app with a second copy of the QC panel
app.dir.qc2 &lt;- generateShinyApp(
  shiny.dir = paste0(tempdir(), "/shiny_Yang2019_QC2"),
  app.title = "Shiny app for the Yang 2019 data",
  expression.matrix = expression.matrix.preproc,
  metadata = metadata,
  organism = "mmusculus",
  org.db = "org.Mm.eg.db",
  panels.extra = tibble::tibble(
    name = "RNA2",
    UIfun = "modalityPanelUI", 
    UIvars = "'RNA2', metadata[[1]], NA, 'QC'", 
    serverFun = "modalityPanelServer", 
    serverVars = "'RNA2', expression.matrix[[1]], metadata[[1]], anno[[1]], NA, 'QC'"
  )
)
# runApp(app.dir.qc2)

# clean up tempdir
unlink(paste0(normalizePath(tempdir()), "/", dir(tempdir())), recursive = TRUE)
</code></pre>

<hr>
<h2 id='genes_barplot'>Create a bar plot of expression for selected genes across samples in an experiment</h2><span id='topic+genes_barplot'></span>

<h3>Description</h3>

<p>This function creates a clustered bar plot between all samples in the
expression matrix for the selection of genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genes_barplot(sub.expression.matrix, log.transformation = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genes_barplot_+3A_sub.expression.matrix">sub.expression.matrix</code></td>
<td>
<p>subset of the expression matrix containing only selected
genes</p>
</td></tr>
<tr><td><code id="genes_barplot_+3A_log.transformation">log.transformation</code></td>
<td>
<p>whether expression should be shown on log (default) or
linear scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bar plot as a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

print(genes_barplot(head(expression.matrix.preproc,5)))

</code></pre>

<hr>
<h2 id='get_link_list_rename'>Convert the adjacency matrix to network links</h2><span id='topic+get_link_list_rename'></span>

<h3>Description</h3>

<p>This function converts an adjacency matrix to a data frame
of network links, subset to the most important ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_link_list_rename(weightMat, plotConnections)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_link_list_rename_+3A_weightmat">weightMat</code></td>
<td>
<p>the (weighted) adjacency matrix - regulators in rows,
targets in columns</p>
</td></tr>
<tr><td><code id="get_link_list_rename_+3A_plotconnections">plotConnections</code></td>
<td>
<p>the number of connections to subset to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with fields from, to and value, describing the edges
of the network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weightMat &lt;- matrix(
  c(0.1, 0.4, 0.8, 0.3), nrow = 2, ncol = 2,
  dimnames = list("regulators" = c("r1", "r2"), "targets" = c("t1", "t2"))
)
get_link_list_rename(weightMat, 2)
</code></pre>

<hr>
<h2 id='GRNCisPanel'>Generate the GRN cis integration panel of the shiny app</h2><span id='topic+GRNCisPanel'></span><span id='topic+GRNCisPanelUI'></span><span id='topic+GRNCisPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the GRN cis integration
panel of the shiny app. It is generated by including at least 1 row in the
cis.integration parameter of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRNCisPanelUI(id, reference.table.name, comparison.table.name)

GRNCisPanelServer(
  id,
  expression.matrix,
  anno,
  coord.table.reference,
  coord.table.comparison,
  seed = 13
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRNCisPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="GRNCisPanel_+3A_reference.table.name">reference.table.name</code></td>
<td>
<p>Name for reference expression matrix and coordinate table</p>
</td></tr>
<tr><td><code id="GRNCisPanel_+3A_comparison.table.name">comparison.table.name</code></td>
<td>
<p>Name for comparison coordinate table</p>
</td></tr>
<tr><td><code id="GRNCisPanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="GRNCisPanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
<tr><td><code id="GRNCisPanel_+3A_coord.table.reference">coord.table.reference</code></td>
<td>
<p>Table of coordinates corresponding to rows of
expression.matrix</p>
</td></tr>
<tr><td><code id="GRNCisPanel_+3A_coord.table.comparison">coord.table.comparison</code></td>
<td>
<p>Table of coordinates to compare against coord.table.reference</p>
</td></tr>
<tr><td><code id="GRNCisPanel_+3A_seed">seed</code></td>
<td>
<p>Random seed to create reproducible GRNs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='GRNCustomPanel'>Generate the GRN custom integration panel of the shiny app</h2><span id='topic+GRNCustomPanel'></span><span id='topic+GRNCustomPanelUI'></span><span id='topic+GRNCustomPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the GRN custom integration
panel of the shiny app. It is generated by including at least 1 row in the
custom.integration parameter of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRNCustomPanelUI(id, title = "GRN with custom integration", show = TRUE)

GRNCustomPanelServer(
  id,
  expression.matrix,
  anno,
  comparison.table,
  DEresults = NULL,
  seed = 13
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRNCustomPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="GRNCustomPanel_+3A_title">title</code></td>
<td>
<p>Name for custom panel instance</p>
</td></tr>
<tr><td><code id="GRNCustomPanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="GRNCustomPanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="GRNCustomPanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
<tr><td><code id="GRNCustomPanel_+3A_comparison.table">comparison.table</code></td>
<td>
<p>Table linking rows of expression.matrix to custom information,
for example miRNAs or transcription factors.</p>
</td></tr>
<tr><td><code id="GRNCustomPanel_+3A_deresults">DEresults</code></td>
<td>
<p>differential expression results output from DEpanelServer;
a reactive list with slots 'DEtable' (all genes), 'DEtableSubset' (only DE genes),
'lfcThreshold' and 'pvalThreshold'</p>
</td></tr>
<tr><td><code id="GRNCustomPanel_+3A_seed">seed</code></td>
<td>
<p>Random seed to create reproducible GRNs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='GRNpanel'>Generate the GRN panel of the shiny app</h2><span id='topic+GRNpanel'></span><span id='topic+GRNpanelUI'></span><span id='topic+GRNpanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the GRN panel of the
shiny app. It is generated by including 'GRN' in the panels.default argument
of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRNpanelUI(id, metadata, show = TRUE)

GRNpanelServer(id, expression.matrix, metadata, anno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRNpanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="GRNpanel_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="GRNpanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="GRNpanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="GRNpanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='GRNTransPanel'>Generate the GRN trans integration panel of the shiny app</h2><span id='topic+GRNTransPanel'></span><span id='topic+GRNTransPanelUI'></span><span id='topic+GRNTransPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the GRN trans integration
panel of the shiny app. It is generated by including at least 1 row in the
trans.integration parameter of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GRNTransPanelUI(id, reference.table.name, comparison.table.name)

GRNTransPanelServer(
  id,
  expression.matrix,
  anno,
  anno.comparison,
  expression.matrix.comparison,
  tablenames,
  seed = 13
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GRNTransPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="GRNTransPanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="GRNTransPanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
<tr><td><code id="GRNTransPanel_+3A_anno.comparison">anno.comparison</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the comparison expression matrix and the names that
should be rendered within the app and in output files.
The structure matches the anno table created in
<code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
<tr><td><code id="GRNTransPanel_+3A_expression.matrix.comparison">expression.matrix.comparison</code></td>
<td>
<p>Additional expression matrix to integrate.
Column names must match column names from expression.matrix.</p>
</td></tr>
<tr><td><code id="GRNTransPanel_+3A_tablenames">tablenames</code>, <code id="GRNTransPanel_+3A_reference.table.name">reference.table.name</code>, <code id="GRNTransPanel_+3A_comparison.table.name">comparison.table.name</code></td>
<td>
<p>Names for reference and comparison expression tables.</p>
</td></tr>
<tr><td><code id="GRNTransPanel_+3A_seed">seed</code></td>
<td>
<p>Random seed to create reproducible GRNs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='infer_GRN'>Perform GRN inference</h2><span id='topic+infer_GRN'></span>

<h3>Description</h3>

<p>This function performs Gene Regulatory Network inference on
a subset of the expression matrix, for a set of potential targets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_GRN(
  expression.matrix,
  metadata,
  anno,
  seed = 13,
  targets,
  condition,
  samples,
  inference_method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_GRN_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="infer_GRN_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="infer_GRN_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
<tr><td><code id="infer_GRN_+3A_seed">seed</code></td>
<td>
<p>the random seed to be set when running GRN inference, to ensure
reproducibility of outputs</p>
</td></tr>
<tr><td><code id="infer_GRN_+3A_targets">targets</code></td>
<td>
<p>the target genes of interest around which the GRN is built;
must be row names of the expression matrix</p>
</td></tr>
<tr><td><code id="infer_GRN_+3A_condition">condition</code></td>
<td>
<p>name of the metadata column to select samples from</p>
</td></tr>
<tr><td><code id="infer_GRN_+3A_samples">samples</code></td>
<td>
<p>names of the sample groups to select; must appear in
<code>metadata[[condition]]</code></p>
</td></tr>
<tr><td><code id="infer_GRN_+3A_inference_method">inference_method</code></td>
<td>
<p>method used for GRN inference; only supported method
is currently GENIE3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The adjacency matrix of the inferred network
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500, ]

metadata &lt;- data.frame(
  srr = colnames(expression.matrix.preproc), 
  timepoint = rep(c("0h", "12h", "36h"), each = 2)
)

anno &lt;- AnnotationDbi::select(
  getExportedValue('org.Mm.eg.db', 'org.Mm.eg.db'),
  keys = rownames(expression.matrix.preproc),
  keytype = 'ENSEMBL',
  columns = 'SYMBOL'
) %&gt;%
  dplyr::distinct(ENSEMBL, .keep_all = TRUE) %&gt;%
  dplyr::mutate(NAME = ifelse(is.na(SYMBOL), ENSEMBL, SYMBOL))

res &lt;- infer_GRN(
  expression.matrix = expression.matrix.preproc,
  metadata = metadata,
  anno = anno,
  seed = 13,
  targets = c("Hecw2", "Akr1cl"),
  condition = "timepoint",
  samples = "0h",
  inference_method = "GENIE3"
)
</code></pre>

<hr>
<h2 id='jaccard_heatmap'>Create a heatmap of the Jaccard similarity index (JSI) between samples of
an experiment</h2><span id='topic+jaccard_heatmap'></span>

<h3>Description</h3>

<p>This function creates a JSI heatmap between all samples in the
expression matrix using the specified number of most abundant genes as
input. Metadata columns are used as annotations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard_heatmap(
  expression.matrix,
  metadata,
  top.annotation.ids = NULL,
  n.abundant = NULL,
  show.values = TRUE,
  show.row.column.names = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccard_heatmap_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="jaccard_heatmap_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="jaccard_heatmap_+3A_top.annotation.ids">top.annotation.ids</code></td>
<td>
<p>a vector of column indices denoting which columns
of the metadata should become heatmap annotations</p>
</td></tr>
<tr><td><code id="jaccard_heatmap_+3A_n.abundant">n.abundant</code></td>
<td>
<p>number of most abundant genes to use for the JSI calculation</p>
</td></tr>
<tr><td><code id="jaccard_heatmap_+3A_show.values">show.values</code></td>
<td>
<p>whether to show the JSI values within the heatmap squares</p>
</td></tr>
<tr><td><code id="jaccard_heatmap_+3A_show.row.column.names">show.row.column.names</code></td>
<td>
<p>whether to show the row and column names below
the heatmap; default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The JSI heatmap as detailed in the ComplexHeatmap package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

metadata &lt;- data.frame(
  srr = colnames(expression.matrix.preproc), 
  timepoint = rep(c("0h", "12h", "36h"), each = 2)
)
print(jaccard_heatmap(expression.matrix.preproc, metadata, n.abundant = 100))
</code></pre>

<hr>
<h2 id='jaccard_index'>Calculate the Jaccard similarity index (JSI) between two vectors</h2><span id='topic+jaccard_index'></span>

<h3>Description</h3>

<p>Calculate the Jaccard similarity index (JSI) between two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard_index(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccard_index_+3A_a">a</code>, <code id="jaccard_index_+3A_b">b</code></td>
<td>
<p>two vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The JSI of the two vectors, a single value between 0 and 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jaccard_index(1:4, 2:6)
</code></pre>

<hr>
<h2 id='landingPanel'>Generate the landing page panel of the shiny app</h2><span id='topic+landingPanel'></span><span id='topic+landingPanelUI'></span><span id='topic+landingPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the landing page
panel of the shiny app. It is generated by including 'Landing' in the
panels.default argument of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landingPanelUI(id, show = TRUE)

landingPanelServer(id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landingPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="landingPanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='ma_plot'>Create an MA plot visualising differential expression (DE) results</h2><span id='topic+ma_plot'></span><span id='topic+ma_enhance'></span>

<h3>Description</h3>

<p>This function creates an MA plot to visualise the results
of a DE analysis.
</p>
<p><code><a href="#topic+ma_enhance">ma_enhance</a></code> is called indirectly by
<code><a href="#topic+ma_plot">ma_plot</a></code> to add extra features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma_plot(
  genes.de.results,
  pval.threshold = 0.05,
  lfc.threshold = 1,
  alpha = 0.1,
  ylims = NULL,
  add.colours = TRUE,
  add.expression.colour.gradient = TRUE,
  add.guide.lines = TRUE,
  add.labels.auto = TRUE,
  add.labels.custom = FALSE,
  ...
)

ma_enhance(
  p,
  df,
  pval.threshold,
  lfc.threshold,
  alpha,
  add.colours,
  point.colours = c("#bfbfbf", "orange", "red", "blue"),
  raster = FALSE,
  add.expression.colour.gradient,
  colour.gradient.scale = list(left = c("#99e6ff", "#000066"), right = c("#99e6ff",
    "#000066")),
  colour.gradient.breaks = waiver(),
  colour.gradient.limits = NULL,
  add.guide.lines,
  guide.line.colours = c("green", "blue"),
  add.labels.auto,
  add.labels.custom,
  annotation = NULL,
  n.labels.auto = c(5, 5, 5),
  genes.to.label = NULL,
  seed = 0,
  label.force = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ma_plot_+3A_genes.de.results">genes.de.results</code></td>
<td>
<p>the table of DE genes, usually generated by
<code><a href="#topic+DEanalysis_edger">DEanalysis_edger</a></code></p>
</td></tr>
<tr><td><code id="ma_plot_+3A_pval.threshold">pval.threshold</code>, <code id="ma_plot_+3A_lfc.threshold">lfc.threshold</code></td>
<td>
<p>the p-value and/or log2(fold-change)
thresholds to determine whether a gene is DE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_alpha">alpha</code></td>
<td>
<p>the transparency of points; ignored for DE genes if
add.expression.colour.gradient is TRUE; default is 0.1</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_ylims">ylims</code></td>
<td>
<p>a single value to create (symmetric) y-axis limits; by default
inferred from the data</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_add.colours">add.colours</code></td>
<td>
<p>whether to colour genes based on their log2(fold-change)
and -log10(p-value); default is TRUE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_add.expression.colour.gradient">add.expression.colour.gradient</code></td>
<td>
<p>whether to add a colour gradient
for DE genes to present their log2(expression); default is TRUE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_add.guide.lines">add.guide.lines</code></td>
<td>
<p>whether to add vertical and horizontal guide lines
to the plot to highlight the thresholds; default is TRUE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_add.labels.auto">add.labels.auto</code></td>
<td>
<p>whether to automatically label genes with the
highest |log2(fold-change)| and expression; default is TRUE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_add.labels.custom">add.labels.custom</code></td>
<td>
<p>whether to add labels to user-specified genes;
the parameter genes.to.label must also be specified; default is FALSE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="#topic+ma_enhance">ma_enhance</a></code></p>
</td></tr>
<tr><td><code id="ma_plot_+3A_p">p</code></td>
<td>
<p>MA plot as a ggplot object (usually passed by <code><a href="#topic+ma_plot">ma_plot</a></code>)</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_df">df</code></td>
<td>
<p>data frame of DE results for all genes (usually passed by
<code><a href="#topic+ma_plot">ma_plot</a></code>)</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_point.colours">point.colours</code></td>
<td>
<p>a vector of 4 colours to colour genes with both pval
and lfc under thresholds, just pval under threshold, just lfc under threshold,
both pval and lfc over threshold (DE genes) respectively; only used if
add.colours is TRUE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_raster">raster</code></td>
<td>
<p>whether to rasterize non-DE genes with ggraster to reduce
memory usage; particularly useful when saving plots to files</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_colour.gradient.scale">colour.gradient.scale</code></td>
<td>
<p>a vector of two colours to create a colour
gradient for colouring the DE genes based on expression; a named list with
components left and right can be supplied to use two different colour scales;
only used if add.expression.colour.gradient is TRUE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_colour.gradient.breaks">colour.gradient.breaks</code>, <code id="ma_plot_+3A_colour.gradient.limits">colour.gradient.limits</code></td>
<td>
<p>parameters to customise
the legend of the colour gradient scale; especially useful if creating
multiple plots or a plot with two scales;
only used if add.expression.colour.gradient is TRUE</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_guide.line.colours">guide.line.colours</code></td>
<td>
<p>a vector with two colours to be used to colour
the guide lines; the first colour is used for the p-value and log2(fold-change)
thresholds and the second for double those values</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_annotation">annotation</code></td>
<td>
<p>annotation data frame containing a match between the gene
field of df (usually ENSEMBL IDs) and the gene names that should be shown
in the plot labels; not necessary if df already contains gene names</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_n.labels.auto">n.labels.auto</code></td>
<td>
<p>a integer vector of length 3 denoting the number of
genes that should be automatically labelled; the first entry corresponds to
DE genes with the lowest p-value, the second to those with highest absolute
log2(fold-change) and the third to those with highest expression; a single
integer can also be specified, to be used for all 3 entries; default is 5</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_genes.to.label">genes.to.label</code></td>
<td>
<p>a vector of gene names to be labelled in the
plot; if names are present those are shown as the labels (but the values are
the ones matched - this is to allow custom gene names to be presented)</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_seed">seed</code></td>
<td>
<p>the random seed to be used for reproducibility; only used for
ggrepel::geom_label_repel if labels are present</p>
</td></tr>
<tr><td><code id="ma_plot_+3A_label.force">label.force</code></td>
<td>
<p>passed to the force argument of ggrepel::geom_label_repel;
higher values make labels overlap less (at the cost of them being further
away from the points they are labelling)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MA plot as a ggplot object.
</p>
<p>The enhanced MA plot as a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500, 1:4]

anno &lt;- AnnotationDbi::select(
  getExportedValue('org.Mm.eg.db', 'org.Mm.eg.db'),
  keys = rownames(expression.matrix.preproc),
  keytype = 'ENSEMBL',
  columns = 'SYMBOL'
) %&gt;%
  dplyr::distinct(ENSEMBL, .keep_all = TRUE) %&gt;%
  dplyr::mutate(NAME = ifelse(is.na(SYMBOL), ENSEMBL, SYMBOL))
  
edger &lt;- DEanalysis_edger(
  expression.matrix = expression.matrix.preproc,
  condition = rep(c("0h", "12h"), each = 2),
  var1 = "0h",
  var2 = "12h",
  anno = anno
)
mp &lt;- ma_plot(edger)
print(mp)
</code></pre>

<hr>
<h2 id='make_heatmap_matrix'>Create a matrix of the average expression of each gene in each condition</h2><span id='topic+make_heatmap_matrix'></span>

<h3>Description</h3>

<p>This function reshapes the tibble output of
<code><a href="#topic+calculate_condition_mean_sd_per_gene">calculate_condition_mean_sd_per_gene</a></code> into a matrix of
average expression by condition. Its output can be used by
<code><a href="#topic+expression_heatmap">expression_heatmap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_heatmap_matrix(tbl, genes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_heatmap_matrix_+3A_tbl">tbl</code></td>
<td>
<p>the output of <code><a href="#topic+calculate_condition_mean_sd_per_gene">calculate_condition_mean_sd_per_gene</a></code></p>
</td></tr>
<tr><td><code id="make_heatmap_matrix_+3A_genes">genes</code></td>
<td>
<p>gene names to use for the output; if NULL (the default),
all genes will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of averaged expression per gene in each condition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

condition &lt;- factor(rep(c("0h", "12h", "36h"), each = 2))
tbl &lt;- calculate_condition_mean_sd_per_gene(expression.matrix.preproc[1:10, ], condition)
heatmat &lt;- make_heatmap_matrix(tbl)
heatmat
</code></pre>

<hr>
<h2 id='make_pattern_matrix'>Create a matrix of the patterns between conditions</h2><span id='topic+make_pattern_matrix'></span>

<h3>Description</h3>

<p>This function determines the patterns between different
conditions of each gene. It should be applied to the output of
<code><a href="#topic+calculate_condition_mean_sd_per_gene">calculate_condition_mean_sd_per_gene</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_pattern_matrix(tbl, n_sd = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_pattern_matrix_+3A_tbl">tbl</code></td>
<td>
<p>the output of <code><a href="#topic+calculate_condition_mean_sd_per_gene">calculate_condition_mean_sd_per_gene</a></code></p>
</td></tr>
<tr><td><code id="make_pattern_matrix_+3A_n_sd">n_sd</code></td>
<td>
<p>number of standard deviations from the mean to use to
construct the intervals; default is 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of single character patterns between conditions. The last
column is named pattern and is a concatenation of all other columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

condition &lt;- factor(rep(c("0h", "12h", "36h"), each = 2))
tbl &lt;- calculate_condition_mean_sd_per_gene(expression.matrix.preproc[1:10, ], condition)
patmat &lt;- make_pattern_matrix(tbl)
patmat
</code></pre>

<hr>
<h2 id='modalityPanel'>Generate an app panel for a modality</h2><span id='topic+modalityPanel'></span><span id='topic+modalityPanelUI'></span><span id='topic+modalityPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of a modality
panel of the shiny app. Different modalities can be included by
specifying their inputs in <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modalityPanelUI(id, metadata, organism, panels.default)

modalityPanelServer(
  id,
  expression.matrix,
  metadata,
  anno,
  organism,
  panels.default
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modalityPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="modalityPanel_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="modalityPanel_+3A_organism">organism</code></td>
<td>
<p>organism name to be passed on to <code>gprofiler2::gost</code>;
organism names are constructed by concatenating the first letter of the
name and the family name; default is NA - enrichment is not included
to ensure compatibility with datasets that have non-standard gene names;
a vector (of the same length as modality) can be provided if
<code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="modalityPanel_+3A_panels.default">panels.default</code></td>
<td>
<p>argument to control which of the default panels
will be included in the app; default is all, but the enrichment panel
will not appear unless organism is also supplied; note that the 'DE' panel
is required for 'DEplot', 'DEsummary', 'Enrichment', and 'GRNenrichment'; a list  (of the same
length as modality) can be provided if <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="modalityPanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="modalityPanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='noisyr_counts_with_plot'>Apply a modified noisyR counts pipeline printing a plot</h2><span id='topic+noisyr_counts_with_plot'></span>

<h3>Description</h3>

<p>This function is identical to the noisyr::noisyr_counts
function, with the addition of the option to print a line plot of the
similarity against expression for all samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noisyr_counts_with_plot(
  expression.matrix,
  n.elements.per.window = NULL,
  optimise.window.length.logical = FALSE,
  similarity.threshold = 0.25,
  method.chosen = "Boxplot-IQR",
  ...,
  output.plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noisyr_counts_with_plot_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples</p>
</td></tr>
<tr><td><code id="noisyr_counts_with_plot_+3A_n.elements.per.window">n.elements.per.window</code></td>
<td>
<p>number of elements to have in a window passed to
calculate_expression_similarity_counts(); default 10% of the number of rows</p>
</td></tr>
<tr><td><code id="noisyr_counts_with_plot_+3A_optimise.window.length.logical">optimise.window.length.logical</code></td>
<td>
<p>whether to call optimise_window_length to try and
optimise the value of n.elements.per.window</p>
</td></tr>
<tr><td><code id="noisyr_counts_with_plot_+3A_similarity.threshold">similarity.threshold</code>, <code id="noisyr_counts_with_plot_+3A_method.chosen">method.chosen</code></td>
<td>
<p>parameters passed on to
<code><a href="noisyr.html#topic+calculate_noise_threshold">calculate_noise_threshold</a></code>; they can be single values or vectors;
if they are vectors optimal values are computed by calling
<code><a href="noisyr.html#topic+calculate_noise_threshold_method_statistics">calculate_noise_threshold_method_statistics</a></code> and
minimising the coefficient of variation across samples; all possible values for
method.chosen can be viewed by <code><a href="noisyr.html#topic+get_methods_calculate_noise_threshold">get_methods_calculate_noise_threshold</a></code></p>
</td></tr>
<tr><td><code id="noisyr_counts_with_plot_+3A_...">...</code></td>
<td>
<p>optional arguments passed on to <code>noisyr::noisyr_counts()</code></p>
</td></tr>
<tr><td><code id="noisyr_counts_with_plot_+3A_output.plot">output.plot</code></td>
<td>
<p>whether to create an expression-similarity plot for the
noise analysis (printed to the console); default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The denoised expression matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:10, 1:4]
expression.matrix.denoised &lt;- noisyr_counts_with_plot(expression.matrix)
</code></pre>

<hr>
<h2 id='patternPanel'>Generate the expression patterns panel of the shiny app</h2><span id='topic+patternPanel'></span><span id='topic+patternPanelUI'></span><span id='topic+patternPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the expression patterns
panel of the shiny app. It is generated by including 'Patterns' in the
panels.default argument of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patternPanelUI(id, metadata, show = TRUE)

patternPanelServer(id, expression.matrix, metadata, anno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patternPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="patternPanel_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="patternPanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="patternPanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="patternPanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='plot_GRN'>Plot a GRN</h2><span id='topic+plot_GRN'></span>

<h3>Description</h3>

<p>This function creates a network plot of a GRN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_GRN(
  weightMat,
  anno,
  plotConnections,
  plot_position_grid,
  n_networks,
  recurring_regulators
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_GRN_+3A_weightmat">weightMat</code></td>
<td>
<p>the (weighted) adjacency matrix - regulators in rows,
targets in columns</p>
</td></tr>
<tr><td><code id="plot_GRN_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
<tr><td><code id="plot_GRN_+3A_plotconnections">plotConnections</code></td>
<td>
<p>the number of connections to subset to</p>
</td></tr>
<tr><td><code id="plot_GRN_+3A_plot_position_grid">plot_position_grid</code>, <code id="plot_GRN_+3A_n_networks">n_networks</code></td>
<td>
<p>the position of the plot in
the grid (1-4) and the number of networks shown (1-4); these are
solely used for hiding unwanted plots in the shiny app</p>
</td></tr>
<tr><td><code id="plot_GRN_+3A_recurring_regulators">recurring_regulators</code></td>
<td>
<p>targets to be highlighted; usually the
result of <code><a href="#topic+find_regulators_with_recurring_edges">find_regulators_with_recurring_edges</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network plot. See visNetwork package for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weightMat1 &lt;- matrix(
  c(0.1, 0.4, 0.8, 0.3), nrow = 2, ncol = 2,
  dimnames = list("regulators" = c("r1", "r2"), "targets" = c("t1", "t2"))
)
weightMat2 &lt;- matrix(
  c(0.1, 0.2, 0.8, 0.3), nrow = 2, ncol = 2,
  dimnames = list("regulators" = c("r1", "r2"), "targets" = c("t1", "t2"))
)
anno &lt;- tibble::tibble(ENSEMBL = c("r1", "r2", "t1", "t2"), NAME = ENSEMBL)
recurring_regulators &lt;- find_regulators_with_recurring_edges(list(weightMat1, weightMat2), 2)
plot_GRN(weightMat1, anno, 2, 1, 1, recurring_regulators)
plot_GRN(weightMat2, anno, 2, 1, 1, recurring_regulators)
</code></pre>

<hr>
<h2 id='plot_line_pattern'>Create a line plot of average expression across conditions</h2><span id='topic+plot_line_pattern'></span>

<h3>Description</h3>

<p>This function creates a line plot of average expression
across conditions for a selection of genes, usually to visualise
an expression pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_line_pattern(
  tbl,
  genes = NULL,
  type = c("Mean Scaled", "Log2 Expression", "Expression"),
  show.legend = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_line_pattern_+3A_tbl">tbl</code></td>
<td>
<p>the output of <code><a href="#topic+calculate_condition_mean_sd_per_gene">calculate_condition_mean_sd_per_gene</a></code></p>
</td></tr>
<tr><td><code id="plot_line_pattern_+3A_genes">genes</code></td>
<td>
<p>gene names to use for the output; if NULL (the default),
all genes will be used</p>
</td></tr>
<tr><td><code id="plot_line_pattern_+3A_type">type</code></td>
<td>
<p>whether the expression values should be scaled using their mean
(default), log-transformed, or not adjusted for the plot</p>
</td></tr>
<tr><td><code id="plot_line_pattern_+3A_show.legend">show.legend</code></td>
<td>
<p>whether to show the gene names in the legend;
should be avoided in many genes are plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of average gene expression per gene in each condition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

condition &lt;- factor(rep(c("0h", "12h", "36h"), each = 2))
tbl &lt;- calculate_condition_mean_sd_per_gene(expression.matrix.preproc[1:10, ], condition)
plot_line_pattern(tbl)
</code></pre>

<hr>
<h2 id='plot_pca'>Create a principal component analysis (PCA) plot the samples of an experiment</h2><span id='topic+plot_pca'></span>

<h3>Description</h3>

<p>This function creates a PCA plot between all samples in the
expression matrix using the specified number of most abundant genes as
input. A metadata column is used as annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pca(
  expression.matrix,
  metadata,
  annotation.id,
  n.abundant = NULL,
  show.labels = FALSE,
  show.ellipses = TRUE,
  label.force = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pca_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="plot_pca_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="plot_pca_+3A_annotation.id">annotation.id</code></td>
<td>
<p>a column index denoting which column of the metadata
should be used to colour the points and draw confidence ellipses</p>
</td></tr>
<tr><td><code id="plot_pca_+3A_n.abundant">n.abundant</code></td>
<td>
<p>number of most abundant genes to use for the JSI calculation</p>
</td></tr>
<tr><td><code id="plot_pca_+3A_show.labels">show.labels</code></td>
<td>
<p>whether to label the points with the sample names</p>
</td></tr>
<tr><td><code id="plot_pca_+3A_show.ellipses">show.ellipses</code></td>
<td>
<p>whether to draw confidence ellipses</p>
</td></tr>
<tr><td><code id="plot_pca_+3A_label.force">label.force</code></td>
<td>
<p>passed to the force argument of ggrepel::geom_label_repel;
higher values make labels overlap less (at the cost of them being further
away from the points they are labelling)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The PCA plot as a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

metadata &lt;- data.frame(
  srr = colnames(expression.matrix.preproc), 
  timepoint = rep(c("0h", "12h", "36h"), each = 2)
)
plot_pca(expression.matrix.preproc, metadata, 2)
</code></pre>

<hr>
<h2 id='plot_upset'>Visualise the overlap of edges between different networks</h2><span id='topic+plot_upset'></span>

<h3>Description</h3>

<p>This function creates an UpSet plot of the intersections
and specific differences of the edges in the input networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_upset(weightMatList, plotConnections)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_upset_+3A_weightmatlist">weightMatList</code></td>
<td>
<p>a list of (weighted) adjacency matrices;
each list element must be an adjacency matrix with regulators in rows,
targets in columns</p>
</td></tr>
<tr><td><code id="plot_upset_+3A_plotconnections">plotConnections</code></td>
<td>
<p>the number of connections to subset to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An UpSet plot. See UpSetR package for more details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weightMat1 &lt;- matrix(
  c(0.1, 0.4, 0.8, 0.3), nrow = 2, ncol = 2,
  dimnames = list("regulators" = c("r1", "r2"), "targets" = c("t1", "t2"))
)
weightMat2 &lt;- matrix(
  c(0.1, 0.2, 0.8, 0.3), nrow = 2, ncol = 2,
  dimnames = list("regulators" = c("r1", "r2"), "targets" = c("t1", "t2"))
)
plot_upset(list(weightMat1, weightMat2), 2)
</code></pre>

<hr>
<h2 id='preprocess_miRTarBase'>Creates a comparison table for miRTarBase to be used for custom integration</h2><span id='topic+preprocess_miRTarBase'></span>

<h3>Description</h3>

<p>This function downloads the miRTarBase database for the organism
of choice, filters it according to user-specified values and formats ready for
custom integration in <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocess_miRTarBase(
  download.dir = ".",
  download.method = "auto",
  mirtarbase.file = NULL,
  organism.code,
  org.db,
  support.type = c(),
  validation.method = c(),
  reference = c("mRNA", "miRNA"),
  print.support.types = FALSE,
  print.validation.methods = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_miRTarBase_+3A_download.dir">download.dir</code></td>
<td>
<p>Directory where miRTarBase database will be downloaded.</p>
</td></tr>
<tr><td><code id="preprocess_miRTarBase_+3A_download.method">download.method</code></td>
<td>
<p>Method for downloading miRTarBase file through download.file,
see download.file documentation for options for your operating system.</p>
</td></tr>
<tr><td><code id="preprocess_miRTarBase_+3A_mirtarbase.file">mirtarbase.file</code></td>
<td>
<p>Path to pre-downloaded miRTarBase file for your organism.
If this is left NULL then the file will be downloaded.</p>
</td></tr>
<tr><td><code id="preprocess_miRTarBase_+3A_organism.code">organism.code</code></td>
<td>
<p>Three letter code for the organism of choice. See miRTarBase
website for options. For human, enter 'hsa' and for mouse, 'mmu'.</p>
</td></tr>
<tr><td><code id="preprocess_miRTarBase_+3A_org.db">org.db</code></td>
<td>
<p>database for annotations to transform ENSEMBL IDs to
gene names; a list of bioconductor packaged databases can be found with
<code>BiocManager::available("^org\.")</code>.</p>
</td></tr>
<tr><td><code id="preprocess_miRTarBase_+3A_support.type">support.type</code></td>
<td>
<p>Subset of entries of the 'Support Type' field in miRTarBase.
Only these values will be kept. To find the options available for your organism
of choice, run the function once with <code>print.support.types = TRUE</code>.</p>
</td></tr>
<tr><td><code id="preprocess_miRTarBase_+3A_validation.method">validation.method</code></td>
<td>
<p>Subset of entries of 'Experiments' field in miRTarBase.
Only these values will be kept. To find the options available for your organism
of choice, run the function once with <code>print.validation.methods = TRUE</code>.</p>
</td></tr>
<tr><td><code id="preprocess_miRTarBase_+3A_reference">reference</code></td>
<td>
<p>Should the reference category be mRNA or miRNA? The reference
category chosen here must match the reference category chosen in
<code>custom.integration</code> in <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>. Default in mRNA.</p>
</td></tr>
<tr><td><code id="preprocess_miRTarBase_+3A_print.support.types">print.support.types</code>, <code id="preprocess_miRTarBase_+3A_print.validation.methods">print.validation.methods</code></td>
<td>
<p>Should options for
Support Type and Experiments be displayed? Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with Reference_ID/Name and Comparison_ID/Name columns
which can be supplied to <code>custom.integration</code> in <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comparison.table &lt;- preprocess_miRTarBase(
  mirtarbase.file = system.file("extdata", "mmu_MTI_sub.xls", package = "bulkAnalyseR"),
  organism.code = "mmu",
  org.db = "org.Mm.eg.db",
  support.type = "Functional MTI",
  validation.method = "Luciferase reporter assay",
  reference = "miRNA")
</code></pre>

<hr>
<h2 id='preprocessExpressionMatrix'>Pre-process the expression matrix before generating the shiny app</h2><span id='topic+preprocessExpressionMatrix'></span>

<h3>Description</h3>

<p>This function denoises the expression matrix using the noisyR package
and then normalises it. It is recommended to use this function before using
<code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocessExpressionMatrix(
  expression.matrix,
  denoise = TRUE,
  output.plot = FALSE,
  normalisation.method = c("quantile", "rpm", "tmm", "deseq2", "median"),
  n_million = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocessExpressionMatrix_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples</p>
</td></tr>
<tr><td><code id="preprocessExpressionMatrix_+3A_denoise">denoise</code></td>
<td>
<p>whether to use noisyR to denoise the expression matrix;
proceeding without denoising data is not recommended</p>
</td></tr>
<tr><td><code id="preprocessExpressionMatrix_+3A_output.plot">output.plot</code></td>
<td>
<p>whether to create an expression-similarity plot for the
noise analysis (printed to the console); default is FALSE</p>
</td></tr>
<tr><td><code id="preprocessExpressionMatrix_+3A_normalisation.method">normalisation.method</code></td>
<td>
<p>the normalisation method to be used; default is
quantile; any unrecognised input will result in no normalisation being
applied, but proceeding with un-normalised data is not recommended;
currently supported normalisation methods are:
</p>

<dl>
<dt>quantile</dt><dd><p>Quantile normalisation using the <code>normalize.quantiles</code>
function from the <code>preprocessCore</code> package</p>
</dd>
<dt>rpm</dt><dd><p>RPM (reads per million) normalisation, where each
sample is scaled by 1 (or more using the n_million parameter) million and
divided by the total number of reads in that sample</p>
</dd>
<dt>tmm</dt><dd><p>Trimmed Mean of M values normalisation using the
<code>calcNormFactors</code> function from the <code>edgeR</code> package</p>
</dd>
<dt>deseq2</dt><dd><p>Size factor normalisation using the
<code>estimateSizeFactorsForMatrix</code> function from the <code>DESeq2</code> package</p>
</dd>
<dt>median</dt><dd><p>Normalisation using the median, where each
sample is scaled by the median expression in the sample divided by the
total number of reads in that sample</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="preprocessExpressionMatrix_+3A_n_million">n_million</code></td>
<td>
<p>scaling factor for RPM normalisation; default is 1 million</p>
</td></tr>
<tr><td><code id="preprocessExpressionMatrix_+3A_...">...</code></td>
<td>
<p>optional arguments passed on to <code>noisyr::noisyr_counts()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The denoised, normalised expression matrix; some rows (genes)
may have been removed by noisyR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:10, 1:4]
expression.matrix.preproc &lt;- preprocessExpressionMatrix(expression.matrix)
</code></pre>

<hr>
<h2 id='qc_density_plot'>Create a density plot of log2 expression across samples of an experiment</h2><span id='topic+qc_density_plot'></span>

<h3>Description</h3>

<p>This function creates a density plot between all samples in the
expression matrix. Metadata columns are used to group samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_density_plot(expression.matrix, metadata, annotation.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qc_density_plot_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="qc_density_plot_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="qc_density_plot_+3A_annotation.id">annotation.id</code></td>
<td>
<p>name of metadata column on which to group samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The density plot as a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

metadata &lt;- data.frame(
  srr = colnames(expression.matrix.preproc), 
  timepoint = rep(c("0h", "12h", "36h"), each = 2)
)
print(qc_density_plot(expression.matrix.preproc, metadata, 'timepoint'))

</code></pre>

<hr>
<h2 id='qc_violin_plot'>Create a violin/box plot of expression across samples of an experiment</h2><span id='topic+qc_violin_plot'></span>

<h3>Description</h3>

<p>This function creates a combined violin and box plot between
all samples in the expression matrix. Metadata columns are used to colour samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc_violin_plot(
  expression.matrix,
  metadata,
  annotation.id,
  log.transformation = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qc_violin_plot_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="qc_violin_plot_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="qc_violin_plot_+3A_annotation.id">annotation.id</code></td>
<td>
<p>name of metadata column on which to group samples</p>
</td></tr>
<tr><td><code id="qc_violin_plot_+3A_log.transformation">log.transformation</code></td>
<td>
<p>whether expression should be shown on log (default) or
linear scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The violin/box plot as a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500,]

metadata &lt;- data.frame(
  srr = colnames(expression.matrix.preproc), 
  timepoint = rep(c("0h", "12h", "36h"), each = 2)
)
print(qc_violin_plot(expression.matrix.preproc, metadata, 'timepoint'))

</code></pre>

<hr>
<h2 id='QCpanel'>Generate the QC panel of the shiny app</h2><span id='topic+QCpanel'></span><span id='topic+QCpanelUI'></span><span id='topic+QCpanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the QC panel of the
shiny app. It is generated by including 'QC' in the panels.default argument
of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QCpanelUI(id, metadata, show = TRUE)

QCpanelServer(id, expression.matrix, metadata, anno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QCpanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="QCpanel_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="QCpanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="QCpanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="QCpanel_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='rescale_matrix'>Rescale a matrix</h2><span id='topic+rescale_matrix'></span>

<h3>Description</h3>

<p>This function rescales the rows of a matrix according to the
specified type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_matrix(
  mat,
  type = c("Expression", "Log2 Expression", "Mean Scaled", "Z-score")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_matrix_+3A_mat">mat</code></td>
<td>
<p>the matrix to rescale</p>
</td></tr>
<tr><td><code id="rescale_matrix_+3A_type">type</code></td>
<td>
<p>type of rescaling; one of &quot;Expression&quot; (defautl, does nothing),
&quot;Log2 Expression&quot; (returns log2(x + 1) for every value), &quot;Mean Scaled&quot; (each
row is scaled by its average), &quot;Z-score&quot; (each row is centered and scaled
to mean = 0 and sd = 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rescaled matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat = matrix(1:10, nrow = 2, ncol = 5)
rescale_matrix(mat, type = "Expression")
rescale_matrix(mat, type = "Log2 Expression")
rescale_matrix(mat, type = "Mean Scaled")
rescale_matrix(mat, type = "Z-score")
</code></pre>

<hr>
<h2 id='sampleSelectPanel'>Generate the sample select panel of the shiny app</h2><span id='topic+sampleSelectPanel'></span><span id='topic+sampleSelectPanelUI'></span><span id='topic+sampleSelectPanelServer'></span>

<h3>Description</h3>

<p>These are the UI and server components of the sample selection
panel of the shiny app. It is generated by including 'SampleSelect' in the
panels.default argument of <code><a href="#topic+generateShinyApp">generateShinyApp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleSelectPanelUI(id, metadata, show = TRUE)

sampleSelectPanelServer(id, expression.matrix, metadata, modality = "RNA")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleSelectPanel_+3A_id">id</code></td>
<td>
<p>the input slot that will be used to access the value</p>
</td></tr>
<tr><td><code id="sampleSelectPanel_+3A_metadata">metadata</code></td>
<td>
<p>a data frame containing metadata for the samples contained
in the expression.matrix; must contain at minimum two columns:
the first column must contain the column names of the expression.matrix,
while the last column is assumed to contain the experimental conditions
that will be tested for differential expression; a list  (of the same
length as modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="sampleSelectPanel_+3A_show">show</code></td>
<td>
<p>whether to show the panel or not; default is TRUE; there for
compatibility with specifying panels to show</p>
</td></tr>
<tr><td><code id="sampleSelectPanel_+3A_expression.matrix">expression.matrix</code></td>
<td>
<p>the expression matrix; rows correspond to genes and
columns correspond to samples; usually preprocessed by
<code><a href="#topic+preprocessExpressionMatrix">preprocessExpressionMatrix</a></code>; a list  (of the same length as
modality) can be provided if #' <code>length(modality) &gt; 1</code></p>
</td></tr>
<tr><td><code id="sampleSelectPanel_+3A_modality">modality</code></td>
<td>
<p>the modality, needs to be passed when used within another
shiny module for namespacing reasons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The UI and Server components of the shiny module, that can be used
within the UI and Server definitions of a shiny app.
</p>

<hr>
<h2 id='scatter_plot'>Create a scatter plot of expression between two samples of an experiment</h2><span id='topic+scatter_plot'></span>

<h3>Description</h3>

<p>This function creates a scatter plot between two samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter_plot(
  sub.expression.matrix,
  anno,
  genes.to.highlight = c(),
  log.transformation = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatter_plot_+3A_sub.expression.matrix">sub.expression.matrix</code></td>
<td>
<p>subset of the expression matrix containing only the two
selected samples</p>
</td></tr>
<tr><td><code id="scatter_plot_+3A_anno">anno</code></td>
<td>
<p>annotation data frame containing a match between the row names
of the expression.matrix (usually ENSEMBL IDs) and the gene names that
should be rendered within the app and in output files; this object is
created by <code><a href="#topic+generateShinyApp">generateShinyApp</a></code> using the org.db specified</p>
</td></tr>
<tr><td><code id="scatter_plot_+3A_genes.to.highlight">genes.to.highlight</code></td>
<td>
<p>vector of gene names to highlight.
These should match entries in the anno NAME column.</p>
</td></tr>
<tr><td><code id="scatter_plot_+3A_log.transformation">log.transformation</code></td>
<td>
<p>whether expression should be shown on log (default) or
linear scale</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scatter plot as a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[,1:2]

print(scatter_plot(expression.matrix.preproc, c()))

</code></pre>

<hr>
<h2 id='volcano_plot'>Create a volcano plot visualising differential expression (DE) results</h2><span id='topic+volcano_plot'></span><span id='topic+volcano_enhance'></span>

<h3>Description</h3>

<p>This function creates a volcano plot to visualise the results
of a DE analysis.
</p>
<p><code><a href="#topic+volcano_enhance">volcano_enhance</a></code> is called indirectly by
<code><a href="#topic+volcano_plot">volcano_plot</a></code> to add extra features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>volcano_plot(
  genes.de.results,
  pval.threshold = 0.05,
  lfc.threshold = 1,
  alpha = 0.1,
  xlims = NULL,
  log10pval.cap = TRUE,
  add.colours = TRUE,
  add.expression.colour.gradient = TRUE,
  add.guide.lines = TRUE,
  add.labels.auto = TRUE,
  add.labels.custom = FALSE,
  ...
)

volcano_enhance(
  vp,
  df,
  pval.threshold,
  lfc.threshold,
  alpha,
  add.colours,
  point.colours = c("#bfbfbf", "orange", "red", "blue"),
  raster = FALSE,
  add.expression.colour.gradient,
  colour.gradient.scale = list(left = c("#99e6ff", "#000066"), right = c("#99e6ff",
    "#000066")),
  colour.gradient.breaks = waiver(),
  colour.gradient.limits = NULL,
  add.guide.lines,
  guide.line.colours = c("green", "blue"),
  add.labels.auto,
  add.labels.custom,
  annotation = NULL,
  n.labels.auto = c(5, 5, 5),
  genes.to.label = NULL,
  seed = 0,
  label.force = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="volcano_plot_+3A_genes.de.results">genes.de.results</code></td>
<td>
<p>the table of DE genes, usually generated by
<code><a href="#topic+DEanalysis_edger">DEanalysis_edger</a></code></p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_pval.threshold">pval.threshold</code>, <code id="volcano_plot_+3A_lfc.threshold">lfc.threshold</code></td>
<td>
<p>the p-value and/or log2(fold-change)
thresholds to determine whether a gene is DE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_alpha">alpha</code></td>
<td>
<p>the transparency of points; ignored for DE genes if
add.expression.colour.gradient is TRUE; default is 0.1</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_xlims">xlims</code></td>
<td>
<p>a single value to create (symmetric) x-axis limits; by default
inferred from the data</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_log10pval.cap">log10pval.cap</code></td>
<td>
<p>whether to cap the log10(p-value at -10); any p-values
lower that 10^(-10) are set to the cap for plotting</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_add.colours">add.colours</code></td>
<td>
<p>whether to colour genes based on their log2(fold-change)
and -log10(p-value); default is TRUE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_add.expression.colour.gradient">add.expression.colour.gradient</code></td>
<td>
<p>whether to add a colour gradient
for DE genes to present their log2(expression); default is TRUE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_add.guide.lines">add.guide.lines</code></td>
<td>
<p>whether to add vertical and horizontal guide lines
to the plot to highlight the thresholds; default is TRUE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_add.labels.auto">add.labels.auto</code></td>
<td>
<p>whether to automatically label genes with the
highest |log2(fold-change)| and expression; default is TRUE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_add.labels.custom">add.labels.custom</code></td>
<td>
<p>whether to add labels to user-specified genes;
the parameter genes.to.label must also be specified; default is FALSE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="#topic+volcano_enhance">volcano_enhance</a></code></p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_vp">vp</code></td>
<td>
<p>volcano plot as a ggplot object (usually passed by <code><a href="#topic+volcano_plot">volcano_plot</a></code>)</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_df">df</code></td>
<td>
<p>data frame of DE results for all genes (usually passed by
<code><a href="#topic+volcano_plot">volcano_plot</a></code>)</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_point.colours">point.colours</code></td>
<td>
<p>a vector of 4 colours to colour genes with both pval
and lfc under thresholds, just pval under threshold, just lfc under threshold,
both pval and lfc over threshold (DE genes) respectively; only used if
add.colours is TRUE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_raster">raster</code></td>
<td>
<p>whether to rasterize non-DE genes with ggraster to reduce
memory usage; particularly useful when saving plots to files</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_colour.gradient.scale">colour.gradient.scale</code></td>
<td>
<p>a vector of two colours to create a colour
gradient for colouring the DE genes based on expression; a named list with
components left and right can be supplied to use two different colour scales;
only used if add.expression.colour.gradient is TRUE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_colour.gradient.breaks">colour.gradient.breaks</code>, <code id="volcano_plot_+3A_colour.gradient.limits">colour.gradient.limits</code></td>
<td>
<p>parameters to customise
the legend of the colour gradient scale; especially useful if creating
multiple plots or a plot with two scales;
only used if add.expression.colour.gradient is TRUE</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_guide.line.colours">guide.line.colours</code></td>
<td>
<p>a vector with two colours to be used to colour
the guide lines; the first colour is used for the p-value and log2(fold-change)
thresholds and the second for double those values</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_annotation">annotation</code></td>
<td>
<p>annotation data frame containing a match between the gene
field of df (usually ENSEMBL IDs) and the gene names that should be shown
in the plot labels; not necessary if df already contains gene names</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_n.labels.auto">n.labels.auto</code></td>
<td>
<p>a integer vector of length 3 denoting the number of
genes that should be automatically labelled; the first entry corresponds to
DE genes with the lowest p-value, the second to those with highest absolute
log2(fold-change) and the third to those with highest expression; a single
integer can also be specified, to be used for all 3 entries; default is 5</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_genes.to.label">genes.to.label</code></td>
<td>
<p>a vector of gene names to be labelled in the
plot; if names are present those are shown as the labels (but the values are
the ones matched - this is to allow custom gene names to be presented)</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_seed">seed</code></td>
<td>
<p>the random seed to be used for reproducibility; only used for
ggrepel::geom_label_repel if labels are present</p>
</td></tr>
<tr><td><code id="volcano_plot_+3A_label.force">label.force</code></td>
<td>
<p>passed to the force argument of ggrepel::geom_label_repel;
higher values make labels overlap less (at the cost of them being further
away from the points they are labelling)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The volcano plot as a ggplot object.
</p>
<p>The enhanced volcano plot as a ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expression.matrix.preproc &lt;- as.matrix(read.csv(
  system.file("extdata", "expression_matrix_preprocessed.csv", package = "bulkAnalyseR"), 
  row.names = 1
))[1:500, 1:4]

anno &lt;- AnnotationDbi::select(
  getExportedValue('org.Mm.eg.db', 'org.Mm.eg.db'),
  keys = rownames(expression.matrix.preproc),
  keytype = 'ENSEMBL',
  columns = 'SYMBOL'
) %&gt;%
  dplyr::distinct(ENSEMBL, .keep_all = TRUE) %&gt;%
  dplyr::mutate(NAME = ifelse(is.na(SYMBOL), ENSEMBL, SYMBOL))
  
edger &lt;- DEanalysis_edger(
  expression.matrix = expression.matrix.preproc,
  condition = rep(c("0h", "12h"), each = 2),
  var1 = "0h",
  var2 = "12h",
  anno = anno
)
vp &lt;- volcano_plot(edger)
print(vp)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
