<!DOCTYPE html><html><head><title>Help for package BioCro</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BioCro}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_time_to_weather_data'><p>Add a time component to input</p></a></li>
<li><a href='#annualDB'><p>Miscanthus dry biomass data.</p></a></li>
<li><a href='#catm_data'><p>Global annual mean atmopspheric CO2 levels</p></a></li>
<li><a href='#cmi_soybean_weather_data'><p>Champaign, IL weather data for Soybean-BioCro</p></a></li>
<li><a href='#cmi_weather_data'><p>Champaign, IL weather data</p></a></li>
<li><a href='#crop_model_definitions'><p>Crop model definitions</p></a></li>
<li><a href='#default_ode_solvers'><p>Default ODE solver settings</p></a></li>
<li><a href='#dynamical_system'><p>Validating dynamical system inputs</p></a></li>
<li><a href='#get_all'><p>Get lists of modules, quantities, and solvers</p></a></li>
<li><a href='#get_growing_season_climate'><p>Truncate weather data to one growing season</p></a></li>
<li><a href='#miscanthus_x_giganteus'><p>Miscanthus model definition</p></a></li>
<li><a href='#module_case_files'><p>Define and modify BioCro module test case files</p></a></li>
<li><a href='#module_creators'><p>Create instances of modules</p></a></li>
<li><a href='#module_paste'><p>Prepend library name to module names</p></a></li>
<li><a href='#module_testing'><p>The BioCro module testing system</p></a></li>
<li><a href='#modules'><p>BioCro module functions</p></a></li>
<li><a href='#obsBea'><p>Miscanthus assimilation field data</p></a></li>
<li><a href='#obsBeaC'><p>Complete Miscanthus assimilation field data</p></a></li>
<li><a href='#obsNaid'><p>Miscanthus assimilation data</p></a></li>
<li><a href='#partial_application'><p>Convenience Functions for Partial Application</p></a></li>
<li><a href='#run_biocro'><p>Simulate Crop Growth with BioCro</p></a></li>
<li><a href='#soil_parameters'><p>Soil properties</p></a></li>
<li><a href='#soybean'><p>Soybean-BioCro model definition</p></a></li>
<li><a href='#soybean_clock'><p>Soybean-BioCro circadian clock model definition</p></a></li>
<li><a href='#system_derivatives'><p>Calculate Derivatives for Differential Quantities</p></a></li>
<li><a href='#test_module'><p>Run BioCro module test cases</p></a></li>
<li><a href='#test_module_library'><p>Run module test cases for an entire BioCro module library</p></a></li>
<li><a href='#willow'><p>Willow model definition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Modular Crop Growth Simulations</td>
</tr>
<tr>
<td>Description:</td>
<td>A cross-platform representation of models as sets of equations
    that facilitates modularity in model building and allows users to harness
    modern techniques for numerical integration and data visualization.
    Documentation is provided by several vignettes included in this package;
    also see Lochocki et al. (2022) &lt;<a href="https://doi.org/10.1093%2Finsilicoplants%2Fdiac003">doi:10.1093/insilicoplants/diac003</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.2.0), knitr, rmarkdown, bookdown, lattice,
deSolve</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11, GNU make</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/biocro/biocro">https://github.com/biocro/biocro</a>, <a href="https://biocro.github.io">https://biocro.github.io</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-29 16:32:57 UTC; Justin</td>
</tr>
<tr>
<td>Author:</td>
<td>Justin M. McGrath <a href="https://orcid.org/0000-0002-7025-3906"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Edward B. Lochocki
    <a href="https://orcid.org/0000-0002-4912-9783"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Scott Rohde <a href="https://orcid.org/0000-0001-9030-0936"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Deepak Jaiswal <a href="https://orcid.org/0000-0002-4077-3919"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Megan L. Matthews <a href="https://orcid.org/0000-0002-5513-9320"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Fernando E. Miguez
    <a href="https://orcid.org/0000-0002-4627-8329"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Stephen P. Long <a href="https://orcid.org/0000-0002-8501-7164"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Dan Wang [ctb],
  David LeBauer <a href="https://orcid.org/0000-0001-7228-053X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  BioCro authors [cph],
  Boost Organization [cph] (Copyright holder of included Boost library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Justin M. McGrath &lt;jmcgrath@illinois.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-30 11:42:54 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_time_to_weather_data'>Add a time component to input</h2><span id='topic+add_time_to_weather_data'></span>

<h3>Description</h3>

<p>Ensure, if possible, that input data that varies over time has a &quot;time&quot;
component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  add_time_to_weather_data(drivers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_time_to_weather_data_+3A_drivers">drivers</code></td>
<td>

<p>A list or dataframe representing known system parameters that vary over
time, such as weather data.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If drivers has no time component, then one is added, provided it <em>does</em>
have components for doy and hour. (The time values will be equal to the doy
values plus the fractional portion of a day represented by the hour values.)
Otherwise drivers is returned as is.
</p>


<h3>Note</h3>

<p>Preconditions: If drivers is a list, the values should be vectors of equal
length.  Moreover, if it already contains a time component, then it shouldn't
contain either a doy or an hour component unless it contains both of them and
the values are mutually consistent.  Furthermore, the time represented by
(doy, hour), if given, or by time, if given, should increase as the vector or
row index increases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Add a time column to the buit-in 2002 weather data
  new_weather &lt;- add_time_to_weather_data(weather[['2002']])
</code></pre>

<hr>
<h2 id='annualDB'>Miscanthus dry biomass data.</h2><span id='topic+annualDB'></span><span id='topic+annualDB2'></span>

<h3>Description</h3>

<p>The first column is the thermal time. The second, third, fourth, and fifth
columns are miscanthus stem, leaf, root, and rhizome dry biomass in Mg
ha<sup>-1</sup> (root is missing). The sixth column is the leaf area index.
The <code>annualDB.c</code> version is altered so that root biomass is not
missing and LAI is smaller. The purpose of this last modification is for
testing some functions.
</p>


<h3>Format</h3>

<p>Data frame of dimensions 5 by 6.</p>


<h3>Source</h3>

<p>Clive Beale and Stephen Long. 1997. Seasonal dynamics of nutrient
accumulation and partitioning in the perennial C4 grasses Miscanthus x
giganteus and Spartina cynosuroides. <em>Biomass and Bioenergy</em> 12 (6): 419&ndash;428.
</p>

<hr>
<h2 id='catm_data'>Global annual mean atmopspheric CO2 levels</h2><span id='topic+catm_data'></span>

<h3>Description</h3>

<p>Multiple years of globally averaged annual mean atmospheric CO2 levels and
their uncertainties.
</p>
<p>This data is included in the BioCro package so users can reproduce
calculations in Lochocki <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diac003">doi:10.1093/insilicoplants/diac003</a>] and for exploratory purposes; it is
likely that most BioCro studies will require different data sets, and no
attempt is made here to be exhaustive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catm_data</code></pre>


<h3>Format</h3>

<p>Data frame with 3 columns and 44 rows:
</p>

<ul>
<li> <p><code>year</code>: the year
</p>
</li>
<li> <p><code>Catm</code>: CO2 concentration (micromol / mol)
</p>
</li>
<li> <p><code>unc</code>: the uncertainty associated with the CO2 concentration
(micromol / mol)
</p>
</li></ul>



<h3>Source</h3>

<p>Data were obtained from the National Oceanic and Atmospheric Administration's
Global Monitoring Laboratory (https://gml.noaa.gov/ccgg/trends/data.html) on
2024-02-07.
</p>
<p>The exact link used was
https://gml.noaa.gov/webdata/ccgg/trends/co2/co2_annmean_gl.txt.
</p>
<p>Alternatively, the data can be accessed from
https://gml.noaa.gov/ccgg/trends/gl_data.html by clicking the link to
<code>Globally averaged marine surface annual mean data (CSV)</code>.
</p>
<p>Note: the globally averaged value for 2023 was not yet available, so the
2023 Mauna Loa value was used instead as a temporary fix. This value is likely
to be slightly higher than the global value (by around 1 ppm).
</p>
<p>These data are provided here as a convenience to BioCro users; please visit
the NOAA GML webpage for guidelines regarding the use of this data if you are
intending to include it in a publication.
</p>

<hr>
<h2 id='cmi_soybean_weather_data'>Champaign, IL weather data for Soybean-BioCro</h2><span id='topic+soybean_weather'></span><span id='topic+cmi_soybean_weather_data'></span>

<h3>Description</h3>

<p>Champaign, IL weather data specified at hourly intervals in the CST time zone
for the years 2002, 2004, 2005, and 2006. The data includes typical inputs
required for BioCro simulations, with the addition of <code>day_length</code>, which
is specifically required for soybean simulations. Although this quantity can
be calculated by modules during the course of a simulation, it is included in
this weather data to speed up the simulations. The time range is restricted to
the SoyFACE growing season that was used for each year.
</p>
<p>This weather data is included in the BioCro package so users can reproduce
the calculations of Matthews <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diab032">doi:10.1093/insilicoplants/diab032</a>] and for exploratory purposes; it is
likely that most BioCro studies will require different data sets, and no
attempt is made here to be exhaustive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soybean_weather</code></pre>


<h3>Format</h3>

<p>A list of 4 named elements, where each element is a data frame corresponding
to one year of weather data and the name of each element is a year, for
example <code>'2004'</code>. Each data frame has 2952 - 3384 observations
(representing hourly time points) of 14 variables:
</p>

<ul>
<li> <p><code>year</code>: the year
</p>
</li>
<li> <p><code>doy</code>: the day of year
</p>
</li>
<li> <p><code>hour</code>: the hour
</p>
</li>
<li> <p><code>time_zone_offset</code>: the time zone offset relative to UTC (hr)
</p>
</li>
<li> <p><code>precip</code>: preciptation rate (mm / hr)
</p>
</li>
<li> <p><code>rh</code>: the ambient relative humidity (dimensionless)
</p>
</li>
<li> <p><code>dw_solar</code>: downwelling global solar radiation (J / m^2 / s)
</p>
</li>
<li> <p><code>up_solar</code>: upwelling global solar radiation (J / m^2 / s)
</p>
</li>
<li> <p><code>netsolar</code>: net global solar radiation (downwelling - upwelling)
(J / m^2 /s)
</p>
</li>
<li> <p><code>solar</code>: the incoming photosynthetically active photon flux
density (PPFD) measured on a ground area basis including direct and
diffuse sunlight light just outside the crop canopy
(micromol / m^2 / s)
</p>
</li>
<li> <p><code>temp</code>: the ambient air temperature (degrees Celsius)
</p>
</li>
<li> <p><code>windspeed</code>: the wind speed in the ambient air just outside the
canopy (m / s)
</p>
</li>
<li> <p><code>zen</code>: the solar zenith angle (degrees)
</p>
</li>
<li> <p><code>day_length</code>: the length of the daily photoperiod (hours)
</p>
</li></ul>



<h3>Source</h3>

<p>Weather data were obtained from the public SURFRAD and WARM databases and
processed according to the method described in Matthews <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diab032">doi:10.1093/insilicoplants/diab032</a>]. See that paper for a full description
of the data processing.
</p>
<p>In brief, the columns in the data frames were determined from SURFRAD and WARM
variables as follows:
</p>

<ul>
<li> <p><code>precip</code>: from the <code>precip</code> variable in the WARM data set
</p>
</li>
<li> <p><code>rh</code>: from the <code>rh</code> variable in the SURFRAD data set
</p>
</li>
<li> <p><code>dw_solar</code>: from the <code>dw_solar</code> variable in the SURFRAD data
set
</p>
</li>
<li> <p><code>up_solar</code>: from the <code>uw_solar</code> variable in the SURFRAD data
set
</p>
</li>
<li> <p><code>netsolar</code>: from the <code>netsolar</code> variable in the SURFRAD data
set
</p>
</li>
<li> <p><code>solar</code>: from the <code>par</code> variable in the SURFRAD data set;
when these values are not available, the <code>netsolar</code> and
<code>up_solar</code> variables are used to make an estimate; when these
values are also not available, the <code>dw_solar</code> variable is used to
make an estimate
</p>
</li>
<li> <p><code>temp</code>: from the <code>temp</code> variable in the SURFRAD data set
</p>
</li>
<li> <p><code>windspeed</code>: from the <code>windspd</code> variable in the SURFRAD data
set
</p>
</li>
<li> <p><code>zen</code>: from the <code>zen</code> variable in the SURFRAD data set
</p>
</li>
<li> <p><code>day_length</code>: calculated from <code>solar</code> using an
oscillator-based circadian clock
</p>
</li></ul>

<p>The WARM data set includes daily values. Hourly values for precipitation are
derived from daily totals by assuming a constant rate of precipitation
throughout the day.
</p>
<p>The SURFRAD data set includes values at 1 or 3 minute intervals. Hourly values
are determined by averaging over hourly intervals, where the value at hour
<code>h</code> is the average over that hour. Some values are missing; any missing
entries are filled by interpolating between neighboring hours.
</p>
<p>To create this data frame, hourly values for all columns except
<code>day_length</code> are extracted from the WARM and SURFRAD data. Then, BioCro
is used to run the circadian clock model that determines photoperiod length.
(See this page for additional information about the clock model:
<code><a href="#topic+soybean_clock">soybean_clock</a></code>.) The result from this calculation is then
appended to the weather data frame as a new column.
</p>
<p>The <code>time_zone_offset</code> is set to a constant value of -6 since this data
is specified in the CST time zone (i.e., UTC-6). Since the value of this
quantity does not change, it could in principle be considered a parameter
rather than a driver; however, it is included with the weather data for
convenience.
</p>
<p>To reduce size the in the BioCro repository, the raw data is rounded to three
significant digits. This can be done with the following code: <code>
  soybean_weather &lt;- lapply(raw_soybean_weather, function(wd) { for (cn in colnames(wd)) { wd[[cn]] &lt;- signif(wd[[cn]], digits = 3) }; wd })
  </code>
</p>

<hr>
<h2 id='cmi_weather_data'>Champaign, IL weather data</h2><span id='topic+weather'></span><span id='topic+cmi_weather_data'></span>

<h3>Description</h3>

<p>Champaign, IL weather data specified at hourly intervals in the CST time zone
for the years 1995&ndash;2023. The data includes typical inputs required for BioCro
imulations. Note: some values are missing near the start of 1995 since those
time points are not available from SURFRAD.
</p>
<p>This weather data is included in the BioCro package so users can reproduce
the calculations of Lochocki <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diac003">doi:10.1093/insilicoplants/diac003</a>] and for exploratory purposes; it is
likely that most BioCro studies will require different data sets, and no
attempt is made here to be exhaustive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weather</code></pre>


<h3>Format</h3>

<p>A list of 29 named elements, where each element is a data frame corresponding
to one year of weather data and the name of each element is a year, for
example <code>'2004'</code>. Each data frame has 8760 or 8784 observations
(representing hourly time points) of 9 variables:
</p>

<ul>
<li> <p><code>year</code>: the year
</p>
</li>
<li> <p><code>doy</code>: the day of year
</p>
</li>
<li> <p><code>hour</code>: the hour
</p>
</li>
<li> <p><code>time_zone_offset</code>: the time zone offset relative to UTC (hr)
</p>
</li>
<li> <p><code>precip</code>: preciptation rate (mm / hr)
</p>
</li>
<li> <p><code>rh</code>: the ambient relative humidity (dimensionless)
</p>
</li>
<li> <p><code>solar</code>: the incoming photosynthetically active photon flux
density (PPFD) measured on a ground area basis including direct and
diffuse sunlight light just outside the crop canopy
(micromol / m^2 / s)
</p>
</li>
<li> <p><code>temp</code>: the ambient air temperature (degrees Celsius)
</p>
</li>
<li> <p><code>windspeed</code>: the wind speed in the ambient air just outside the
canopy (m / s)
</p>
</li></ul>



<h3>Source</h3>

<p>Weather data were obtained from the public SURFRAD and WARM databases and
processed according to the method described in Lochocki <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diac003">doi:10.1093/insilicoplants/diac003</a>]. See version 1.2.0 of the
<code>eloch216/oscillator-based-circadian-clock-analysis</code>
<a href="https://github.com/eloch216/oscillator-based-circadian-clock-analysis">GitHub repository</a>
for a full description of the data processing.
</p>
<p>In brief, the columns in the data frames were determined from SURFRAD and WARM
variables as follows:
</p>

<ul>
<li> <p><code>precip</code>: from the <code>precip</code> variable in the WARM data set
</p>
</li>
<li> <p><code>rh</code>: from the <code>rh</code> variable in the SURFRAD data set
</p>
</li>
<li> <p><code>solar</code>: from the <code>par</code> variable in the SURFRAD data set;
when these values are not available, the <code>direct_n</code>,
<code>diffuse</code>, and <code>zen</code> variables are used to make an estimate
</p>
</li>
<li> <p><code>temp</code>: from the <code>temp</code> variable in the SURFRAD data set
</p>
</li>
<li> <p><code>windspeed</code>: from the <code>windspd</code> variable in the SURFRAD data
set
</p>
</li></ul>

<p>The WARM data set includes daily values. Hourly values for precipitation are
derived from daily totals by assuming a constant rate of precipitation
throughout the day.
</p>
<p>The SURFRAD data set includes values at 1 or 3 minute intervals. Hourly values
are determined by averaging over hourly intervals, where the value at hour
<code>h</code> is the average over the hour-long interval centered at <code>h</code>. Some
values are missing; any missing entries are filled via an interpolation
procedure based on the assumption that values at the same hour of sequential
days should be similar.
</p>
<p>The <code>time_zone_offset</code> is set to a constant value of -6 since this data
is specified in the CST time zone (i.e., UTC-6). Since the value of this
quantity does not change, it could in principle be considered a parameter
rather than a driver; however, it is included with the weather data for
convenience.
</p>
<p>To reduce size the in the BioCro repository, the raw data values are rounded.
This was done using the commands in a script that is included with the BioCro
package. This script can be located by typing
<code>system.file('BioCro', 'extdata', 'rounding_weather_values.R')</code>.
</p>

<hr>
<h2 id='crop_model_definitions'>Crop model definitions</h2><span id='topic+crop_model_definitions'></span>

<h3>Description</h3>

<p>In BioCro, a crop model is defined by sets of direct modules, differential
modules, initial values, and parameters, along with an ordinary differential
equation (ODE) solver. To run a model, these values, along with a set of
weather data, are passed to the <code><a href="#topic+run_biocro">run_biocro</a></code> function. For
convenience, several crop model definitions are included in the BioCro R
package. A full list can be obtained by typing <code>??crop_models</code> into the R
terminal.
</p>


<h3>Details</h3>

<p>Each crop model definition is stored as a list with the following named
elements:
</p>

<ul>
<li> <p><code>direct_modules</code>: A list of direct module names; can be passed to
<code><a href="#topic+run_biocro">run_biocro</a></code> as its <code>direct_module_names</code> argument.
</p>
</li>
<li> <p><code>differential_modules</code>: A list of differential module names; can
be passed to <code><a href="#topic+run_biocro">run_biocro</a></code> as its
<code>differential_module_names</code> argument.
</p>
</li>
<li> <p><code>ode_solver</code>: A list specifying details of a numerical ODE
solver; can be passed to <code><a href="#topic+run_biocro">run_biocro</a></code> as its <code>ode_solver</code>
argument.
</p>
</li>
<li> <p><code>initial_values</code>: A list of named quantity values; can be passed
to <code><a href="#topic+run_biocro">run_biocro</a></code> as its <code>initial_values</code> argument.
</p>
</li>
<li> <p><code>parameters</code>: A list of named quantity values; can be passed to
<code><a href="#topic+run_biocro">run_biocro</a></code> as its <code>parameters</code> argument, and also can be
passed to <code><a href="#topic+evaluate_module">evaluate_module</a></code> and
<code><a href="#topic+module_response_curve">module_response_curve</a></code> when investigating the behavior of one
of the crop's modules.
</p>
</li></ul>

<p>These model definitions are not sufficient for running a simulation because
<code><a href="#topic+run_biocro">run_biocro</a></code> also requires drivers; for these crop growth models,
the drivers should be sets of weather data. The <code><a href="#topic+soybean">soybean</a></code> model is
intended to be used along with the specialized soybean weather data
(see <code><a href="#topic+cmi_soybean_weather_data">cmi_soybean_weather_data</a></code>). The other crops should be used
with the other weather data (see <code><a href="#topic+cmi_weather_data">cmi_weather_data</a></code>).
</p>
<p>Some quantities in the crop model definitions, such as the values of
photosynthetic parameters, would remain the same in any location; others, such
as the latitude or longitude, would need to change when simulating crop growth
in different locations. Care must be taken to understand each input quantity
before attempting to run simulations in other places or for other cultivars.
</p>
<p>Typically, the modules in a crop model definition are defined as lists with
some named elements; the names facilitate on-the-fly module swapping via the
<code><a href="base.html#topic+within">within</a></code> function. For example, to change the soybean canopy
photosynthesis module to the <code>BioCro:ten_layer_rue_canopy</code> module, one
could pass <code>within(soybean$direct_modules, {canopy_photosynthesis =
  "BioCro:ten_layer_rue_canopy"})</code> as the <code>direct_module_names</code> argument
when calling <code><a href="#topic+run_biocro">run_biocro</a></code> instead of
<code>soybean$direct_modules</code>.
</p>
<p>Because each crop model definition is stored as a list with named elements,
it is possible to use the <code><a href="base.html#topic+with">with</a></code> function to save some typing when
calling <code><a href="#topic+run_biocro">run_biocro</a></code> or related functions such as
<code><a href="#topic+partial_run_biocro">partial_run_biocro</a></code> or
<code><a href="#topic+validate_dynamical_system_inputs">validate_dynamical_system_inputs</a></code>. For an example, compare
<code style="white-space: pre;">&#8288;Example 1&#8288;</code> and <code style="white-space: pre;">&#8288;Example 2&#8288;</code> below. Besides shortening the code,
using <code>with</code> also makes it easy to modify a command to simulate the
growth of a different crop; if the two models can use the same drivers, this
switch can be accomplished with one small change (<code style="white-space: pre;">&#8288;Example 3&#8288;</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Simulating Miscanthus growth using its model definition list
result1 &lt;- run_biocro(
  miscanthus_x_giganteus$initial_values,
  miscanthus_x_giganteus$parameters,
  get_growing_season_climate(weather$'2002'),
  miscanthus_x_giganteus$direct_modules,
  miscanthus_x_giganteus$differential_modules,
  miscanthus_x_giganteus$ode_solver
)

# Example 2: Performing the same simulation as in Example 1, but making use of
# the `with` command to reduce repeated references to the model definition list
result2 &lt;- with(miscanthus_x_giganteus, {run_biocro(
  initial_values,
  parameters,
  get_growing_season_climate(weather$'2002'),
  direct_modules,
  differential_modules,
  ode_solver
)})

# Example 3: Simulating willow growth using the same weather data as Examples 1
# and 2, which just requires one change relative to Example 2
result3 &lt;- with(willow, {run_biocro(
  initial_values,
  parameters,
  get_growing_season_climate(weather$'2002'),
  direct_modules,
  differential_modules,
  ode_solver
)})
</code></pre>

<hr>
<h2 id='default_ode_solvers'>Default ODE solver settings</h2><span id='topic+default_ode_solvers'></span>

<h3>Description</h3>

<p>A collection of reasonable settings to use with each ODE solver type. Users
may need or wish to modify them for particular applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_ode_solvers</code></pre>


<h3>Format</h3>

<p>A list of 6 named elements, where each name is one of the possible ODE solver
types. Each element is itself a list of 5 named elements that can be passed to
<code><a href="#topic+run_biocro">run_biocro</a></code> as its <code>ode_solver</code> input argument.
</p>


<h3>Details</h3>

<p>A full list of solver types can be obtained with the
<code><a href="#topic+get_all_ode_solvers">get_all_ode_solvers</a></code> function.
</p>

<hr>
<h2 id='dynamical_system'>Validating dynamical system inputs</h2><span id='topic+dynamical_system'></span><span id='topic+validate_dynamical_system_inputs'></span>

<h3>Description</h3>

<p>Utility function for checking inputs to <code>run_biocro</code> without running it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  validate_dynamical_system_inputs(
      initial_values = list(),
      parameters = list(),
      drivers,
      direct_module_names = list(),
      differential_module_names = list(),
      verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynamical_system_+3A_initial_values">initial_values</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="dynamical_system_+3A_parameters">parameters</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="dynamical_system_+3A_drivers">drivers</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="dynamical_system_+3A_direct_module_names">direct_module_names</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="dynamical_system_+3A_differential_module_names">differential_module_names</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="dynamical_system_+3A_verbose">verbose</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>validate_dynamical_system_inputs</code> accepts the same input arguments as
<code><a href="#topic+run_biocro">run_biocro</a></code> with the exception of <code>ode_solver</code> (which is
not required to check the validity of a dynamical system).
</p>
<p><code>validate_dynamical_system_inputs</code> checks a set of parameters, drivers,
modules, and initial values to see if they can properly define a dynamical
system and can therefore be used as inputs to <code><a href="#topic+run_biocro">run_biocro</a></code>.
Although the <code><a href="#topic+run_biocro">run_biocro</a></code> function performs the same validity
checks, the <code>validate_dynamical_system_inputs</code> includes additional
information, such as a list of parameters whose values are not used as inputs
by any modules, since in principle these parameters could be removed for
clarity.
</p>
<p>When using one of the pre-defined crop growth models, it may be helpful to
use the <code>with</code> command to pass arguments to
<code>validate_dynamical_system_inputs</code>; see the documentation for
<code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code> for more information.
</p>


<h3>Value</h3>

<p>A boolean indicating whether or not the inputs are valid.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_biocro">run_biocro</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: missing a parameter and an initial value
validate_dynamical_system_inputs(
  within(soybean$initial_values, rm(Leaf)),         # remove the initial `Leaf` value
  within(soybean$parameters, rm(leaf_reflectance)), # remove `leaf_reflectance`
  soybean_weather$'2002',
  soybean$direct_modules,
  soybean$differential_modules
)

# Example 2: a valid set of input arguments
validate_dynamical_system_inputs(
  soybean$initial_values,
  soybean$parameters,
  soybean_weather$'2002',
  soybean$direct_modules,
  soybean$differential_modules
)
</code></pre>

<hr>
<h2 id='get_all'>Get lists of modules, quantities, and solvers</h2><span id='topic+get_all'></span><span id='topic+get_all_modules'></span><span id='topic+get_all_quantities'></span><span id='topic+get_all_ode_solvers'></span>

<h3>Description</h3>

<p><code>get_all_modules</code> returns the fully-qualified names (of the form
<code>library_name:local_module_name</code>) for all modules available in a BioCro
module library package.
</p>
<p><code>get_all_quantities</code> returns information about all quantities used as
inputs or outputs by modules available in a BioCro module library package.
</p>
<p><code>get_all_ode_solvers</code> returns the names of all ordinary differential
equation (ODE) solvers available in the BioCro framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  get_all_modules(library_name)

  get_all_quantities(library_name)

  get_all_ode_solvers()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_all_+3A_library_name">library_name</code></td>
<td>
<p>The name of a BioCro module library</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These &quot;get_all&quot; functions return the modules, quantities, and ODE solvers
available within the BioCro framework or a BioCro module library package.
</p>
<p><em>Developer details</em>: The <code>get_all_modules</code> and
<code>get_all_quantities</code> expect a module library package to include
unexported functions called <code>get_all_modules_internal</code> and
<code>get_all_quantities_internal</code>, respectively. These functions should not
have any input arguments, and their return values should follow the
requirements described below for <code>get_all_modules</code> and
<code>get_all_quantities</code>. Any module library package created by forking from
the skeleton library will automatically include these functions without any
modifications to the package's R code.
</p>


<h3>Value</h3>

<table>
<tr><td><code>get_all_modules</code></td>
<td>
<p>A character vector of fully-qualified module names</p>
</td></tr>
<tr><td><code>get_all_quantities</code></td>
<td>
<p>A data frame with three columns:
<code>quantity_type</code> (input or output), <code>quantity_name</code>, and
<code>module_name</code>. A quantity will appear multiple times if it is use as
both an input and an output, or if it is used by multiple modules.</p>
</td></tr>
<tr><td><code>get_all_ode_solvers</code></td>
<td>
<p>A character vector of ODE solver names</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_paste">module_paste</a></code>
</p>
</li>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Getting a sorted list of distinct quantities defined by modules in
# the `BioCro` module library. Doing this can be useful when writing a new
# module that is intended to work along with pre-existing modules.
all_quantities &lt;- get_all_quantities('BioCro')
all_quantity_names &lt;- all_quantities$quantity_name
distinct_quantities &lt;- sort(unique(all_quantity_names))

# Example 2: Getting a list of all modules in the `BioCro` module library that
# have "ci" as an input or output, using `tolower()` to account for any possible
# variations in capitalization.
all_quantities &lt;- get_all_quantities('BioCro')
ci_modules &lt;- subset(all_quantities, tolower(quantity_name) == "ci")
</code></pre>

<hr>
<h2 id='get_growing_season_climate'>Truncate weather data to one growing season</h2><span id='topic+get_growing_season_climate'></span>

<h3>Description</h3>

<p>Attempt to restrict a year of weather data to a growing season; not intended
to be a general-use function (see below for a detailed discussion of its
shortcomings).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  get_growing_season_climate(climate, threshold_temperature = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_growing_season_climate_+3A_climate">climate</code></td>
<td>

<p>A data frame representing one year of weather data, typically intended to be
passed to <code><a href="#topic+run_biocro">run_biocro</a></code> as its <code>drivers</code> argument. This data
frame must have columns for the day of year (<code>doy</code>) and the air
temperature in degrees C (<code>temp</code>).
</p>
</td></tr>
<tr><td><code id="get_growing_season_climate_+3A_threshold_temperature">threshold_temperature</code></td>
<td>

<p>The value of air temperature in degrees C to use when locating the beginning
and end of the growing season.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>DISCLAIMER</strong>: This function is included here primarily to reproduce
the output of older BioCro calculations, where it used to be hard-coded into
every simulation. It has several severe limitations which are discussed below,
and is not intended to be a general-use function for subsetting weather data.
</p>
<p>To determine the growing season, this function locates its beginning and end
based on the air temperature data. The start of the growing season is set by
the last day in the first half of the year where the air temperature is below
(or equal to) the threshold temperature, or day 90, whichever is later. The
end of the growing season is set by the first day of the second half of the
year where the air temperature is below (or equal to) the threshold
temperature, or day 330, whichever is earlier.
</p>
<p>This is not a sophisticated function and no attempt is made to ensure that the
output is reasonable. For example, if the air temperature never exceeds the
threshold value, a growing season beginning on day 183 (the last day of the
first half of the year) and ending on day 184 (the first day of the second
half of the year) will be returned. If the air temperature always exceeds the
threshold value, the growing season will go from day 90 to day 330.
</p>
<p>This function also assumes that the air temperature generally increases early
in the year and generally decreases later in the year, and is only applicable
for locations where this is the case. It is therefore unlikely to work
properly in the Southern Hemisphere or the tropics.
</p>
<p>In general, an appropriate threshold temperature would depend on the species
that is being modeled. For a perennial grass, the growth season might be said
to begin after the last freeze, requiring a threshold temperature of 0 degrees
C. Of course, this is an oversimplification of a complicated biological
process, and a plant has no way of knowing when it has experienced the last
freezing day of the year.
</p>
<p>On the other hand, annual crops like maize or soybean are not typically sown
until conditions are warmer and might require a higher threshold. Again, this
is an oversimplification of a complicated process. Farmers typically take
trends in temperature, historical data, soil conditions, and weather
predictions into account when deciding to sow, and they may also be
constrained by external factors like the availability of machinery, seeds, or
labor.
</p>
<p>It should also be noted that as the threshold temperature increases, the
likelihood of that air temperature occurring at night, even in the middle of
summer, also increases. Consequently, if the threshold is set too high, an
unrealistically short growing season may be predicted. For example, calling
<code>get_growing_season_climate(weather$'2005', 15)</code> returns a two-day
growing season (days 183&ndash;184) because the temperatures in the late night of
day 183 and the early morning of day 184 both dip below 15 degrees C.
</p>
<p>Thus, the logic encoded here is an oversimplification in several ways. It is
likely not appropriate in many situations, and more tailored approaches would
be required.
</p>


<h3>Value</h3>

<p>A copy of the <code>climate</code> data frame truncated to the growing season.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Truncate the 2002 Champaign, Illinois weather data to an estimated growing
  # season
  truncated_weather &lt;- get_growing_season_climate(weather[['2002']])

  # We can see which days were included
  list(
    doy_start = min(truncated_weather$doy),
    doy_end = max(truncated_weather$doy)
  )
</code></pre>

<hr>
<h2 id='miscanthus_x_giganteus'>Miscanthus model definition</h2><span id='topic+miscanthus_x_giganteus'></span>

<h3>Description</h3>

<p>Initial values, parameters, direct modules, differential modules, and
a differential equation solver that can be used to run
<em>Miscanthus x giganteus</em> growth simulations in Champaign, Illinois and
other locations.
</p>
<p>To represent <em>Miscanthus</em> growth in Champaign, IL, these values must be
paired with the Champaign weather data (<code><a href="#topic+cmi_weather_data">cmi_weather_data</a></code>). The
parameters already include the <code>clay_loam</code> values from the
<code><a href="#topic+soil_parameters">soil_parameters</a></code> dataset, which is the appropriate soil type for
Champaign.
</p>
<p>Some specifications, such as the values of photosynthetic parameters, would
remain the same in any location; others, such as the latitude or longitude,
would need to change when simulating crop growth in different locations. Care
must be taken to understand each input quantity before attempting to run
simulations in other places or for other cultivars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miscanthus_x_giganteus</code></pre>


<h3>Format</h3>

<p>A list of 5 named elements that are suitable for passing to
<code><a href="#topic+run_biocro">run_biocro</a></code>, as described in the help page for
<code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code>.
</p>


<h3>Source</h3>

<p>This model was originally described in Miguez <em>et al.</em> (2009)
[<a href="https://doi.org/10.1111/j.1757-1707.2009.01019.x">doi:10.1111/j.1757-1707.2009.01019.x</a>] and Miguez <em>et al.</em> (2012)
[<a href="https://doi.org/10.1111/j.1757-1707.2011.01150.x">doi:10.1111/j.1757-1707.2011.01150.x</a>]. Since its original parameterization,
the behavior of several of its core modules has changed as bugs have been
identified and fixed, so this model likely needs to be reparameterized before
it can be used for realistic simulations.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code>
</p>
</li></ul>


<hr>
<h2 id='module_case_files'>Define and modify BioCro module test case files</h2><span id='topic+module_case_files'></span><span id='topic+initialize_csv'></span><span id='topic+add_csv_row'></span><span id='topic+update_csv_cases'></span>

<h3>Description</h3>

<p>Test cases for testing modules can be stored in files. The functions
here provide ways to create and update those files.
</p>
<p><code>initialize_csv</code> helps define test cases for module testing by
initializing the <code>csv</code> file for one module based on either a set of
default input values or user-supplied ones.
</p>
<p><code>add_csv_row</code> helps define test cases for module testing by adding one
test case to a module's <code>csv</code> file based on the user-supplied inputs and
description.
</p>
<p><code>update_csv_cases</code> helps define cases for module testing by updating the
expected output values for each case stored in a module's csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  initialize_csv(
    module_name,
    directory,
    nonstandard_inputs = list(),
    description = "automatically-generated test case",
    overwrite = FALSE
  )

  add_csv_row(module_name, directory, inputs, description)

  update_csv_cases(module_name, directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="module_case_files_+3A_module_name">module_name</code></td>
<td>

<p>A string specifying one BioCro module, formatted like
<code>library_name:local_module_name</code>, where <code>library_name</code> is the name
of a library that contains a module with local name
<code>local_module_name</code>; such fully-qualified module names can be formed
manually or with <code><a href="#topic+module_paste">module_paste</a></code>.
</p>
</td></tr>
<tr><td><code id="module_case_files_+3A_directory">directory</code></td>
<td>

<p>The directory where module test case files are stored, e.g.
<code>file.path('tests', 'module_test_cases')</code>.
</p>
</td></tr>
<tr><td><code id="module_case_files_+3A_inputs">inputs</code></td>
<td>

<p>A list of module inputs, i.e., a list of named numeric elements
corresponding to the module's input quantities.
</p>
</td></tr>
<tr><td><code id="module_case_files_+3A_description">description</code></td>
<td>

<p>A string describing the test case, e.g. <code>"temp above tbase"</code>. The
description should be succinct and not contain any newline characters.
</p>
</td></tr>
<tr><td><code id="module_case_files_+3A_nonstandard_inputs">nonstandard_inputs</code></td>
<td>

<p>An optional list of input quantities whose values will override the default
value of 1.0; see the <code>inputs</code> entry above.
</p>
</td></tr>
<tr><td><code id="module_case_files_+3A_overwrite">overwrite</code></td>
<td>

<p>A logical value indicating whether an existing file should be overwritten.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Module test case files form a critical component of BioCro's regression
testing system. For more details, see the help page for
<code><a href="#topic+module_testing">module_testing</a></code>.
</p>
<p>The <code>initialize_csv</code> function will evaluate the module for a set of input
quantities and store the results as a test case <code>csv</code> file. Typically,
both of its optional arguments can be omitted. However, some modules produce
errors when all inputs are set to 1.0. In this case, it would be necessary to
supply some nonstandard inputs and (possibly) an alternate case description.
</p>
<p>The <code>add_csv_row</code> function will evaluate the module for a set of input
quantities, define a test case from the resulting outputs and the description,
and add it to the module's corresponding <code>csv</code> file. If no <code>csv</code>
file exists, one will be initialized with the new case.
</p>
<p>The <code>update_csv_cases</code> function will evaluate the module for all input
values specified in its <code>csv</code> case file and update the stored values of
the corresponding outputs. Any output columns not present in the file will be
added automatically and filled in with the correct values. Although the output
columns are optional, the description column must exist in the <code>csv</code>
file.
</p>
<p>If a module test fails and <code>update_csv_cases</code> is used to update the test,
care should be taken to ensure that the new outputs are sensible. This
function should not be used to blindly ensure that tests pass, since a test
failure may indicate a real problem with a module.
</p>
<p>Note that <code>update_csv_cases</code> can be used to batch-initialize test cases.
To do this, manually create a test case <code>csv</code> file with the proper name
that only includes columns for the inputs and the description; now, calling
<code>update_csv_cases</code> will automatically fill in the outputs for each case.
With this method, care must be taken when manually specifying the values of
the description column; the descriptions must be double quoted, and if they
contain internal double quotes, those quotes must be doubled. Generally it is
safest to simply avoid double quotes in the descriptions. (See <code>qmethod</code>
in the help file for <code><a href="utils.html#topic+write.csv">write.csv</a></code> for more details about quoting.)
</p>


<h3>Value</h3>

<p>A message indicating whether a file was created, overwritten, or not written.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_paste">module_paste</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_testing">module_testing</a></code>
</p>
</li>
<li> <p><code><a href="#topic+test_module_library">test_module_library</a></code>
</p>
</li>
<li> <p><code><a href="#topic+test_module">test_module</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># First, we will initialize a test case file for the 'BioCro' library's
# 'thermal_time_linear' module, which will be saved in a temporary directory as
# 'BioCro_thermal_time_linear.csv'. Then, we will add a new case to the file.
# Finally, we will update the file. Note that the call to `update_csv_cases`
# will not actually modify the file unless it is manually edited beforehand to
# change an input or output value.

td &lt;- tempdir()

initialize_csv(
  'BioCro:thermal_time_linear',
  td,
  nonstandard_inputs = list(temp = -1),
  overwrite = TRUE
)

writeLines(readLines(file.path(td, 'BioCro_thermal_time_linear.csv')))

add_csv_row(
  'BioCro:thermal_time_linear',
  td,
  list(time = 101, sowing_time = 100, tbase = 20, temp = 44),
  'temp above tbase'
)

writeLines(readLines(file.path(td, 'BioCro_thermal_time_linear.csv')))

update_csv_cases('BioCro:thermal_time_linear', td)
</code></pre>

<hr>
<h2 id='module_creators'>Create instances of modules</h2><span id='topic+module_creators'></span>

<h3>Description</h3>

<p>Creates pointers to module wrapper objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>  module_creators(module_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="module_creators_+3A_module_names">module_names</code></td>
<td>
<p>A vector of module names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used internally by several other BioCro functions, where its
purpose is to create instances of module wrapper pointers using BioCro's
module library and return pointers to those wrappers. In turn, module wrappers
can be used to obtain information about a module's inputs, outputs, and other
properties, and can also be used to create a module instance. The <code>See
  Also</code> section contains a list of functions that directly rely on
<code>module_creators</code>.
</p>
<p>Although the description of <code>externalptr</code> objects is sparse, they are
briefly mentioned in the R documentation: <code><a href="methods.html#topic+externalptr-class">externalptr-class</a></code>.
</p>
<p>This function should not be used directly, and each module library package
must have its own version. For these reasons, this function is not exported to
the package namespace and can only be accessed using the package name via the
<code><a href="base.html#topic++3A+3A+3A">:::</a></code> operator.
</p>


<h3>Value</h3>

<p>A vector of R <code>externalptr</code> objects that each point to a
<code>module_creator</code> C++ object
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_info">module_info</a></code>
</p>
</li>
<li> <p><code><a href="#topic+evaluate_module">evaluate_module</a></code>
</p>
</li></ul>


<hr>
<h2 id='module_paste'>Prepend library name to module names</h2><span id='topic+module_paste'></span>

<h3>Description</h3>

<p>Prepends a library name to a set of module names to create a
suitably-formatted set of fully-qualified module names that can be passed to
<code><a href="#topic+run_biocro">run_biocro</a></code> or other BioCro functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  module_paste(lib_name, local_module_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="module_paste_+3A_lib_name">lib_name</code></td>
<td>
<p>A string specifying a module library name.</p>
</td></tr>
<tr><td><code id="module_paste_+3A_local_module_names">local_module_names</code></td>
<td>
<p>A vector or list of module name strings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>module_paste</code> is a convenience function for specifying multiple modules
from the same library; it prepends the library name to each module name,
preserving the <code>names</code> and <code>class</code> of <code>local_module_names</code>.
</p>
<p>Note that a simple call to <code>paste0(lib_name, ':', local_module_names)</code>
will produce a similar output with two important differences: (1)
<code><a href="base.html#topic+paste0">paste0</a></code> will not preserve names if <code>local_module_names</code> has
any named elements and (2) <code><a href="base.html#topic+paste0">paste0</a></code> will always return a character
vector, even if <code>local_module_names</code> is a list.
</p>


<h3>Value</h3>

<p>A vector or list of fully-qualified module name strings formatted like
<code>lib_name:local_module_name</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: Specifying several modules from the `BioCro` module library.
modules &lt;- module_paste(
  'BioCro',
  list('total_biomass', canopy_photosynthesis = 'c3_canopy')
)

# Compare to the output from `paste0`
modules2 &lt;- paste0(
  'BioCro',
  ':',
  list('total_biomass', canopy_photosynthesis = 'c3_canopy')
)

str(modules)
str(modules2)

</code></pre>

<hr>
<h2 id='module_testing'>The BioCro module testing system</h2><span id='topic+module_testing'></span>

<h3>Description</h3>

<p>BioCro provides several functions for defining, modifying, and running module
test cases. These functions together allow module developers to easily create
regression tests that ensure the modules continue to function correctly.
</p>


<h3>Details</h3>

<p>Together, <code><a href="#topic+test_module_library">test_module_library</a></code>, <code><a href="#topic+test_module">test_module</a></code>,
<code><a href="#topic+case">case</a></code>, <code><a href="#topic+cases_from_csv">cases_from_csv</a></code>,
<code><a href="#topic+initialize_csv">initialize_csv</a></code>, <code><a href="#topic+add_csv_row">add_csv_row</a></code>, and
<code><a href="#topic+update_csv_cases">update_csv_cases</a></code> form a simple and convenient system for
defining and running module test cases. Such tests form a critical component
of BioCro's regression testing system, and test cases should be defined for
all BioCro modules in all BioCro module libraries. These functions are not
required in order to use the BioCro package, but they are critical to
understand when creating or modifying modules.
</p>
<p>A module test case consists of a set of module inputs, a set of module
outputs, and a short description of the case. To run the test, the inputs are
passed to the module, and then the calculated outputs are compared to the
expected ones. If the outputs match, the test is passed; otherwise, it fails.
This operation is handled by the <code><a href="#topic+test_module">test_module</a></code> function.
</p>
<p>For simple on-the-fly testing, it is possible to define a test case using the
<code><a href="#topic+case">case</a></code> function and run it using <code><a href="#topic+test_module">test_module</a></code>.
However, a more robust method is available to facilitate regression testing,
where module test cases are stored in suitably-formatted <code>csv</code> files,
allowing multiple test cases to be defined for each module and easily checked
afterwards. If test case files for each module in a module library are stored
in a single directory, all the test cases can be checked with one call to
<code><a href="#topic+test_module_library">test_module_library</a></code>.
</p>
<p>In this system, test cases for a module with fully-qualified name
<code>module_name</code> must be stored in <code>module_name.csv</code>,
where the colon in the module name has been replaced by an underscore; for
example, the module named <code>BioCro:total_biomass</code> would be associated with
<code>BioCro_total_biomass.csv</code>. The first row of a test case file must be the
quantity types (<code>input</code> or <code>output</code>), the second row must be the
quantity names, and the remaining rows must each specify input quantity values
along with the expected output values they should produce. There must also be
a <code>description</code> column (with <code>description</code> in the first row)
containing short descriptions of the test cases. These formatting requirements
will automatically be satisfied for any test case file produced by
<code><a href="#topic+initialize_csv">initialize_csv</a></code> or modified by <code><a href="#topic+add_csv_row">add_csv_row</a></code> or
<code><a href="#topic+update_csv_cases">update_csv_cases</a></code>. Such files can be read from R using
<code><a href="#topic+cases_from_csv">cases_from_csv</a></code>, and the resulting case objects can be passed to
<code><a href="#topic+test_module">test_module</a></code>.
</p>
<p>Although it is possible, directly editing the case files is not recommended
since <code><a href="#topic+initialize_csv">initialize_csv</a></code>, <code><a href="#topic+add_csv_row">add_csv_row</a></code>, and
<code><a href="#topic+update_csv_cases">update_csv_cases</a></code> are easier to use. There are several exceptions
to this suggestion: (1) when a case must be deleted, (2) when a module input
must be added or removed, and (3) during the initialization of a test file,
where a user may wish to batch-initialize using <code><a href="#topic+update_csv_cases">update_csv_cases</a></code>
(see its documentation for an explanation of batch-initialization).
</p>
<p>Case files can easily be viewed using Excel or other spreadsheet viewers, and
are also nicely formatted when viewed on the GitHub website for the
repository.
</p>
<p>Examples of module test case files can be found in the
<code>tests/module_test_cases</code> directory, while code that uses the
<code><a href="testthat.html#topic+testthat">testthat</a></code> package to automatically run all the defined
test cases for the standard BioCro module library via
<code><a href="#topic+test_module_library">test_module_library</a></code> can be found in the
<code>tests/testthat/test.Modules.R</code> file.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_case_files">module_case_files</a></code>
</p>
</li>
<li> <p><code><a href="#topic+test_module_library">test_module_library</a></code>
</p>
</li>
<li> <p><code><a href="#topic+test_module">test_module</a></code>
</p>
</li></ul>


<hr>
<h2 id='modules'>BioCro module functions</h2><span id='topic+modules'></span><span id='topic+module_info'></span><span id='topic+evaluate_module'></span><span id='topic+module_response_curve'></span><span id='topic+quantity_list_from_names'></span>

<h3>Description</h3>

<p>BioCro modules are named sets of equations, and each module is available from
a BioCro module library. Each module is identified by a
<a href="https://en.wikipedia.org/wiki/Fully_qualified_name">fully-qualified name</a>
that includes the name of its library and its local name within that library.
The functions here provide ways to access information about modules and to
calculate their output values from sets of input values.
</p>
<p><code>module_info</code> returns essential information about a BioCro module.
</p>
<p><code>quantity_list_from_names</code> initializes a list of named numeric elements
from a set of names.
</p>
<p><code>evaluate_module</code> runs a BioCro module using a list of input quantity
values.
</p>
<p><code>module_response_curve</code> runs a BioCro module repeatedly with different
input quantity values to produce a response curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  module_info(module_name, verbose = TRUE)

  quantity_list_from_names(quantity_names)

  evaluate_module(module_name, input_quantities)

  module_response_curve(module_name, fixed_quantities, varying_quantities)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modules_+3A_module_name">module_name</code></td>
<td>

<p>A string specifying one BioCro module, formatted like
<code>library_name:local_module_name</code>, where <code>library_name</code> is the name
of a library that contains a module with local name
<code>local_module_name</code>; such fully-qualified module names can be formed
manually or with <code><a href="#topic+module_paste">module_paste</a></code>.
</p>
</td></tr>
<tr><td><code id="modules_+3A_verbose">verbose</code></td>
<td>

<p>A boolean indicating whether or not to print information to the R console.
</p>
</td></tr>
<tr><td><code id="modules_+3A_input_quantities">input_quantities</code></td>
<td>

<p>A list of named numeric elements representing the input quantities required
by the module; any extraneous quantities will be ignored by the module.
</p>
</td></tr>
<tr><td><code id="modules_+3A_quantity_names">quantity_names</code></td>
<td>

<p>A vector of strings.
</p>
</td></tr>
<tr><td><code id="modules_+3A_fixed_quantities">fixed_quantities</code></td>
<td>

<p>A list of named numeric elements representing input quantities required
by the module whose values should be considered to be constant; any
extraneous quantities will be ignored by the module.
</p>
</td></tr>
<tr><td><code id="modules_+3A_varying_quantities">varying_quantities</code></td>
<td>

<p>A data frame where each column represents an input quantity required by the
module whose value varies across the response curve.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By providing avenues for retrieving information about a module and evaluating
a module's equations, the <code>module_info</code> and <code>evaluate_module</code>
functions form the main interface to individual BioCro modules from within R.
The <code>quantity_list_from_names</code> function is a convenience function for
preparing suitable quantity lists to pass to <code>evaluate_module</code>.
</p>
<p>The <code>module_response_curve</code> function provides a convenient way to
calculate a module response curve. To do this, a user must specify a module to
use, the values of any fixed input quantities (<code>input_quantities</code>), and
a sequence of values for other quantities that vary across the response curve
(<code>varying_quantities</code>). The returned data frame includes all the
information that would be required to reproduce the curve: the full-qualified
module name, all inputs (including ones with constant values), and the
outputs. Note: if one quantity <code>q</code> is both an input and output of the
module, its input value will be stored in the <code>q</code> column of the returned
data frame and its output value will be stored in the <code>q.1</code> column; this
renaming is performed automatically by the <code><a href="base.html#topic+make.unique">make.unique</a></code> function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>module_info</code></td>
<td>

<p>An <code><a href="base.html#topic+invisible">invisible</a></code> list of several named elements containing
essential information about the module:
</p>

<ul>
<li> <p><code>module_name</code>: The module's (not-fully-qualified) name
</p>
</li>
<li> <p><code>inputs</code>: A character vector of the module's inputs
</p>
</li>
<li> <p><code>outputs</code>: A character vector of the module's outputs
</p>
</li>
<li> <p><code>type</code>: The module's type represented as a string (either
'differential' or 'direct')
</p>
</li>
<li> <p><code>euler_requirement</code>: Indicates whether the module requires a
fixed-step Euler ODE solver when used in a BioCro simulation
</p>
</li>
<li> <p><code>creation_error_message</code>: Describes any errors that occurred
while creating an instance of the module
</p>
</li></ul>

</td></tr>
<tr><td><code>quantity_list_from_names</code></td>
<td>

<p>A list of named numeric elements, where the names are set by
<code>quantity_names</code> and each value is set to 1.
</p>
</td></tr>
<tr><td><code>evaluate_module</code></td>
<td>

<p>A list of named numeric elements representing the values of the module's
outputs as calculated from the <code>input_quantities</code> according to the
module's equations.
</p>
</td></tr>
<tr><td><code>module_response_curve</code></td>
<td>

<p>A data frame where the first column is the fully-qualified name of the
module that produced the response curve and the remaining columns are the
module's input and output quantities. Each row corresponds to a row in the
<code>varying_quantities</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_all_modules">get_all_modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_paste">module_paste</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_testing">module_testing</a></code>
</p>
</li>
<li> <p><code><a href="#topic+partial_evaluate_module">partial_evaluate_module</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: printing information about the 'BioCro' module library's
# 'c3_assimilation' module to the R console
module_info('BioCro:c3_assimilation')

# Example 2: getting the inputs to the 'BioCro' module library's
# 'thermal_time_linear' module, generating a default input list, and using it to
# run the module
info &lt;- module_info('BioCro:thermal_time_linear', verbose = FALSE)
inputs &lt;- quantity_list_from_names(info$inputs) # All inputs will be set to 1
outputs &lt;- evaluate_module('BioCro:thermal_time_linear', inputs)

# Example 3: calculating the temperature response of light saturated net
# assimilation at several values of relative humidity in the absence of water
# stress using the 'BioCro' module library's 'c3_assimilation' module and
# the default soybean parameters. Here, the leaf temperature and humidity values
# are independent of each other, so we use the `expand.grid` function to form a
# data frame of all possible combinations of their values. Then we set the
# ambient temperature equal to the leaf temperature.
rc &lt;- module_response_curve(
  'BioCro:c3_assimilation',
  within(soybean$parameters, {Qabs = 2000; StomataWS = 1; gbw = 1.2}),
  within(
    expand.grid(
      Tleaf = seq(from = 0, to = 40, length.out = 201),
      rh = c(0.2, 0.5, 0.8)
    ),
    {temp = Tleaf}
  )
)

caption &lt;- paste(
  "Response curves calculated with several RH\nvalues and Q =",
  unique(rc$Qp),
  "micromol / m^2 / s\nusing the",
  unique(rc$module_name),
  "module"
)

lattice::xyplot(
  Assim ~ Tleaf,
  group = rh,
  data = rc,
  auto = TRUE,
  type = 'l',
  main = caption
)
</code></pre>

<hr>
<h2 id='obsBea'>Miscanthus assimilation field data</h2><span id='topic+obsBea'></span>

<h3>Description</h3>

<p>Assimilation in Miscanthus as measured in Beale, Bint, and Long 1996.  The
first column is the observed net assimilation rate (micromoles m^-2 s^-1).
The second column is the observed quantum flux (micromoles m^-2 s^-1).
The third column is the temperature (degrees Celsius). Relative humidity
was not reported and thus was assumed to be 0.7.
</p>


<h3>Format</h3>

<p>Data frame of dimensions 27 by 4.</p>


<h3>Source</h3>

<p>C. V. Beale, D. A. Bint, S. P. Long. 1996. Leaf photosynthesis in the
C4-grass Miscanthus x giganteus, growing in the cool temperate climate of
southern England. <em>J. Exp. Bot.</em> 47 (2): 267&ndash;273.
</p>

<hr>
<h2 id='obsBeaC'>Complete Miscanthus assimilation field data</h2><span id='topic+obsBeaC'></span>

<h3>Description</h3>

<p>Assimilation and stomatal conductance in Miscanthus as measured in Beale, Bint, and Long
1996.  (Missing data are also included.)  The first column is
the date, the second the hour. Columns 3 and 4 are assimilation and
stomatal conductance respectively.
</p>


<h3>Format</h3>

<p>Data frame of dimensions 35 by 6.</p>


<h3>Details</h3>

<p>The third column is the observed net assimilation rate (micromoles m^-2 s^-1).
</p>
<p>The fifth column is the observed quantum flux (micromoles m^-2 s^-1).
</p>
<p>The sixth column is the temperature (degrees Celsius).
</p>


<h3>Source</h3>

<p>C. V. Beale, D. A. Bint, S. P. Long. 1996. Leaf photosynthesis in the
C4-grass Miscanthus x giganteus, growing in the cool temperate climate of
southern England. <em>J. Exp. Bot.</em> 47 (2): 267&ndash;273.
</p>

<hr>
<h2 id='obsNaid'>Miscanthus assimilation data</h2><span id='topic+obsNaid'></span>

<h3>Description</h3>

<p>Assimilation in Miscanthus as measured in Naidu et al. (2003). The first
column is the observed net assimilation rate (micromoles m^-2 s^-1).
The second column is the observed quantum flux (micromoles m^-2 s^-1).
The third column is the temperature (degrees Celsius).
The fourth column is the observed relative humidity in proportion (e.g. 0.7).
</p>


<h3>Format</h3>

<p>Data frame of dimensions 16 by 4.</p>


<h3>Source</h3>

<p>S. L. Naidu, S. P. Moose, A. K. AL-Shoaibi, C. A. Raines, S. P.
Long.  2003. Cold Tolerance of C4 photosynthesis in Miscanthus x giganteus:
Adaptation in Amounts and Sequence of C4 Photosynthetic Enzymes.
<em>Plant Physiol.</em> 132 (3): 1688&ndash;1697.
</p>

<hr>
<h2 id='partial_application'>Convenience Functions for Partial Application</h2><span id='topic+partial_application'></span><span id='topic+partial_run_biocro'></span><span id='topic+partial_evaluate_module'></span>

<h3>Description</h3>

<p>Convenience functions for using partial application with BioCro</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_run_biocro(
    initial_values = list(),
    parameters = list(),
    drivers,
    direct_module_names = list(),
    differential_module_names = list(),
    ode_solver = BioCro::default_ode_solvers$homemade_euler,
    arg_names,
    verbose = FALSE
)

partial_evaluate_module(module_name, input_quantities, arg_names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_application_+3A_arg_names">arg_names</code></td>
<td>

<p>A vector of strings specifying input quantities whose values should not be
fixed when using partial application.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_initial_values">initial_values</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_parameters">parameters</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_drivers">drivers</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_direct_module_names">direct_module_names</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_differential_module_names">differential_module_names</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_ode_solver">ode_solver</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_verbose">verbose</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_module_name">module_name</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+evaluate_module">evaluate_module</a></code>.
</p>
</td></tr>
<tr><td><code id="partial_application_+3A_input_quantities">input_quantities</code></td>
<td>

<p>A list of named numeric elements representing any input quantities required
by the module that are not included in <code>arg_names</code>; any extraneous
quantities will be ignored by the module.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Partial application</em> is the technique of fixing some of the input
arguments to a function, producing a new function with fewer inputs. In the
context of BioCro, partial application can often be useful while varying some
parameters, initial values, or drivers while performing optimization or
sensitivity analysis. Optimizers (such as <code><a href="stats.html#topic+optim">optim</a></code>)
typically require a function with a single input argument, so the partial
application tools provided here help to create such functions.
</p>
<p>Both <code>partial_run_biocro</code> and <code>partial_evaluate_module</code> accept the
same arguments as their &quot;regular&quot; counterparts (<code><a href="#topic+run_biocro">run_biocro</a></code> and
<code><a href="#topic+evaluate_module">evaluate_module</a></code>) with the addition of <code>arg_names</code>, which
specifies the input quantities that should not be fixed.
</p>
<p>For <code>partial_run_biocro</code>, each element of <code>arg_names</code> must be the
name of a quantity that is one of the <code>initial_values</code>,
<code>parameters</code>, or <code>drivers</code>. For <code>partial_evaluate_module</code>, each
element of <code>arg_names</code> must be the name of one of the module's input
quantities.
</p>
<p>When using one of the pre-defined crop growth models, it may be helpful to
use the <code>with</code> command to pass arguments to <code>partial_run_biocro</code>;
see the documentation for <code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code> for more
information.
</p>


<h3>Value</h3>

<table>
<tr><td><code>partial_run_biocro</code></td>
<td>

<p>A function that calls <code><a href="#topic+run_biocro">run_biocro</a></code> with all of the inputs
(except those specified in <code>arg_names</code>) set to the values specified by
the original call to <code>partial_run_biocro</code>. The new function has one
input (<code>x</code>), which can be a vector or list specifying the values of the
quantities in <code>arg_names</code>. If <code>x</code> has no names, its elements must
be supplied in the same order as in the original <code>arg_names</code>. If
<code>x</code> has names, they must be identical to the elements of
<code>arg_names</code> but can be in any order. Elements of <code>x</code> corresponding
to drivers must be vectors having the same length as the other drivers; they
can be specified as a named element of a list or as sequential elements of
a vector without names. The return value of the new function is a data frame
as would be produced by <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code>partial_evaluate_module</code></td>
<td>

<p>A function that calls <code><a href="#topic+evaluate_module">evaluate_module</a></code> with the input
quantities (except those specified in <code>arg_names</code>) set to the values
specified by the original call to <code>partial_evaluate_module</code>. The new
function has one input (<code>x</code>), which can be a vector or list specifying
the values of the quantities in <code>arg_names</code>. If <code>x</code> has no names,
its elements must be supplied in the same order as in the original
<code>arg_names</code>. If <code>x</code> has names, they must be identical to the
elements of <code>arg_names</code> but can be in any order. The return value of
the new function is a list with two elements (<code>inputs</code> and
<code>outputs</code>), each of which is a list of named numeric elements
representing the module's input and output values. (Note that this differs
from the output of <code>evaluate_module</code>, which only returns the outputs.)
</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li>
<li> <p><code><a href="#topic+evaluate_module">evaluate_module</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Specify weather data to use in these examples
ex_weather &lt;- get_growing_season_climate(weather$'2005')

# Example 1: varying the thermal time values at which senescence starts for
# different organs in a simulation; here we set them to the following values
# instead of the defaults:
#  - seneLeaf: 2000 degrees C * day
#  - seneStem: 2100 degrees C * day
#  - seneRoot: 2200 degrees C * day
#  - seneRhizome: 2300 degrees C * day
senescence_simulation &lt;- partial_run_biocro(
  miscanthus_x_giganteus$initial_values,
  miscanthus_x_giganteus$parameters,
  ex_weather,
  miscanthus_x_giganteus$direct_modules,
  miscanthus_x_giganteus$differential_modules,
  miscanthus_x_giganteus$ode_solver,
  c('seneLeaf', 'seneStem', 'seneRoot', 'seneRhizome')
)
senescence_result &lt;- senescence_simulation(c(2000, 2100, 2200, 2300))

# Example 2: a crude method for simulating the effects of climate change; here
# we increase the atmospheric CO2 concentration to 500 ppm and the temperature
# by 2 degrees C relative to 2005 temperatures. The commands below that call
# `temperature_simulation` all produce the same result.
temperature_simulation &lt;- partial_run_biocro(
  miscanthus_x_giganteus$initial_values,
  miscanthus_x_giganteus$parameters,
  ex_weather,
  miscanthus_x_giganteus$direct_modules,
  miscanthus_x_giganteus$differential_modules,
  miscanthus_x_giganteus$ode_solver,
  c("Catm", "temp")
)
hot_result_1 &lt;- temperature_simulation(c(500, ex_weather$temp + 2.0))
hot_result_2 &lt;- temperature_simulation(list(Catm = 500, temp = ex_weather$temp + 2.0))
hot_result_3 &lt;- temperature_simulation(list(temp = ex_weather$temp + 2.0, Catm = 500))

# Note that these commands will both produce errors:
# hot_result_4 &lt;- temperature_simulation(c(Catm = 500, temp = ex_weather$temp + 2.0))
# hot_result_5 &lt;- temperature_simulation(stats::setNames(
#   c(500, ex_weather$temp + 2.0),
#   c("Catm", rep("temp", length(ex_weather$temp)))
# ))

# Note that this command will produce a strange result where the first
# temperature value will be incorrectly interpreted as a `Catm` value, and the
# `Catm` value will be interpreted as the final temperature value.
# hot_result_6 &lt;- temperature_simulation(c(ex_weather$temp + 2.0, 500))

# Example 3: varying the base and air temperature inputs to the
# 'thermal_time_linear' module from the 'BioCro' module library. The commands
# below that call `thermal_time_rate` all produce the same result.
thermal_time_rate &lt;- partial_evaluate_module(
  'BioCro:thermal_time_linear',
  within(miscanthus_x_giganteus$parameters, {time = 1}),
  c("temp", "tbase")
)
rate_result_1 &lt;- thermal_time_rate(c(25, 10))
rate_result_2 &lt;- thermal_time_rate(c(temp = 25, tbase = 10))
rate_result_3 &lt;- thermal_time_rate(c(tbase = 10, temp = 25))
rate_result_4 &lt;- thermal_time_rate(list(temp = 25, tbase = 10))
rate_result_5 &lt;- thermal_time_rate(list(tbase = 10, temp = 25))
</code></pre>

<hr>
<h2 id='run_biocro'>Simulate Crop Growth with BioCro</h2><span id='topic+run_biocro'></span>

<h3>Description</h3>

<p>Runs a full crop growth simulation using the BioCro framework</p>


<h3>Usage</h3>

<pre><code class='language-R'>  run_biocro(
      initial_values = list(),
      parameters = list(),
      drivers,
      direct_module_names = list(),
      differential_module_names = list(),
      ode_solver = BioCro::default_ode_solvers$homemade_euler,
      verbose = FALSE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_biocro_+3A_initial_values">initial_values</code></td>
<td>

<p>A list of named quantities representing the initial values of the
differential quantities, i.e., the quantities whose derivatives are
calculated by differential modules
</p>
</td></tr>
<tr><td><code id="run_biocro_+3A_parameters">parameters</code></td>
<td>

<p>A list of named quantities that don't change with time; must include a
'timestep' parameter (see 'drivers' for more info)
</p>
</td></tr>
<tr><td><code id="run_biocro_+3A_drivers">drivers</code></td>
<td>

<p>A data frame of quantities defined at equally spaced time intervals. The
time interval should be specified in the 'parameters' as a quantity called
'timestep' having units of hours. The drivers must include columns for
either (1) 'time' (in units of days) or (2) 'doy' and 'hour'.
</p>
</td></tr>
<tr><td><code id="run_biocro_+3A_direct_module_names">direct_module_names</code></td>
<td>

<p>A character vector or list of the fully-qualified names of the direct
modules to use in the system; lists of available modules can be obtained via
the <code><a href="#topic+get_all_modules">get_all_modules</a></code> function.
</p>
</td></tr>
<tr><td><code id="run_biocro_+3A_differential_module_names">differential_module_names</code></td>
<td>

<p>A character vector or list of the fully-qualified names of the differential
modules to use in the system; lists of available modules can be obtained via
the <code><a href="#topic+get_all_modules">get_all_modules</a></code> function.
</p>
</td></tr>
<tr><td><code id="run_biocro_+3A_ode_solver">ode_solver</code></td>
<td>

<p>A list specifying details about the numerical ODE solver. The required
elements are:
</p>

<ul>
<li> <p><code>type</code>: A string specifying the name of the algorithm to use;
a list of available options can be obtained using the
<code><a href="#topic+get_all_ode_solvers">get_all_ode_solvers</a></code> function.
</p>
</li>
<li> <p><code>output_step_size</code>: The output step size. If smaller than 1, it
should equal 1.0 / N for some integer N. If larger than 1, it should
be an integer.
</p>
</li>
<li> <p><code>adaptive_rel_error_tol</code>: used to set the relative error
tolerance for adaptive step size methods
</p>
</li>
<li> <p><code>adaptive_abs_error_tol</code>: used to set the absolute error
tolerance for adaptive step size methods
</p>
</li>
<li> <p><code>adaptive_max_steps</code>: determines how many times an adaptive
step size method will attempt to find a new step size before
indicating failure
</p>
</li></ul>

</td></tr>
<tr><td><code id="run_biocro_+3A_verbose">verbose</code></td>
<td>

<p>A logical variable indicating whether or not to print dynamical system
validation information. (More detailed startup information can be obtained
with the <code><a href="#topic+validate_dynamical_system_inputs">validate_dynamical_system_inputs</a></code> function.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>run_biocro</code> is the most important function in the BioCro package. The
input arguments to this function are used to define a dynamical system and
solve for its time evolution during a desired time period. For more details
about how this function operates, see Lochocki <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diac003">doi:10.1093/insilicoplants/diac003</a>].
</p>
<p>When using one of the pre-defined crop growth models, it may be helpful to
use the <code>with</code> command to pass arguments to <code>run_biocro</code>; see the
documentation for <code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code> for more information.
</p>


<h3>Value</h3>

<p>A data frame where each column represents one of the quantities included in
the simulation (with the exception of the parameters, since their values are
guaranteed to not change with time) and each row represents a time point
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_all_modules">get_all_modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_all_ode_solvers">get_all_ode_solvers</a></code>
</p>
</li>
<li> <p><code><a href="#topic+validate_dynamical_system_inputs">validate_dynamical_system_inputs</a></code>
</p>
</li>
<li> <p><code><a href="#topic+partial_run_biocro">partial_run_biocro</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example: running a miscanthus simulation using weather data from 2005
result &lt;- run_biocro(
  miscanthus_x_giganteus$initial_values,
  miscanthus_x_giganteus$parameters,
  get_growing_season_climate(weather$'2005'),
  miscanthus_x_giganteus$direct_modules,
  miscanthus_x_giganteus$differential_modules,
  miscanthus_x_giganteus$ode_solver
)

lattice::xyplot(
  Leaf + Stem + Root + Grain ~ TTc,
  data=result,
  type='l',
  auto=TRUE
)
</code></pre>

<hr>
<h2 id='soil_parameters'>Soil properties</h2><span id='topic+soil_parameters'></span>

<h3>Description</h3>

<p>A collection of soil property data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soil_parameters</code></pre>


<h3>Format</h3>

<p>A list of named elements, where each element represents the hydraulic
properties of one type of soil. The soil types are defined following the
<a href="https://en.wikipedia.org/wiki/Soil_texture">USDA soil texture classification</a>
scheme, and 11 of the 12 possible types are included (&quot;silt&quot; is not
available). The following names are used to indicate the various soil types:
</p>

<ul>
<li> <p><code>sand</code>
</p>
</li>
<li> <p><code>loamy_sand</code>
</p>
</li>
<li> <p><code>sandy_loam</code>
</p>
</li>
<li> <p><code>loam</code>
</p>
</li>
<li> <p><code>silt_loam</code>
</p>
</li>
<li> <p><code>sandy_clay_loam</code>
</p>
</li>
<li> <p><code>clay_loam</code>
</p>
</li>
<li> <p><code>silty_clay_loam</code>
</p>
</li>
<li> <p><code>sandy_clay</code>
</p>
</li>
<li> <p><code>silty_clay</code>
</p>
</li>
<li> <p><code>clay</code>
</p>
</li></ul>

<p>For each soil type, the following parameter values are provided:
</p>

<ul>
<li> <p><code>soil_silt_content</code> (dimensionless)
</p>
</li>
<li> <p><code>soil_clay_content</code> (dimensionless)
</p>
</li>
<li> <p><code>soil_sand_content</code> (dimensionless)
</p>
</li>
<li> <p><code>soil_air_entry</code> (J / kg)
</p>
</li>
<li> <p><code>soil_b_coefficient</code> (dimensionless)
</p>
</li>
<li> <p><code>soil_saturated_conductivity</code> (J * s / m^3)
</p>
</li>
<li> <p><code>soil_saturation_capacity</code> (dimensionless)
</p>
</li>
<li> <p><code>soil_field_capacity</code> (dimensionless)
</p>
</li>
<li> <p><code>soil_wilting_point</code> (dimensionless)
</p>
</li>
<li> <p><code>soil_bulk_density</code> (Mg / m^3)
</p>
</li></ul>



<h3>Source</h3>

<p>These soil property values are based on Table 9.1 from Campbell and Norman's
textbook <em>An Introduction to Environmental Biophysics</em> (1998). Bulk
density values are taken from function <code>getsoilprop.c</code> from Melanie
(Colorado). The bulk density of sand in <code>getsoilprop.c</code> is 0, which isn't
sensible, and here a value of <code>1.60 Mg / m^3</code> is used instead.
</p>
<p>The wilting point value of 0.21 (corrected from 0.32) for silty clay loam is
based on the list of book corrections available from
<a href="https://web.archive.org/web/20150806180927/http://www.public.iastate.edu/~bkh/teaching/505/norman_book_corrections.pdf">Brian Hornbuckle's teaching website</a>
using the Wayback Machine, since it does not seem to be available on his
<a href="https://faculty.sites.iastate.edu/bkh/teaching">current site</a>.
</p>

<hr>
<h2 id='soybean'>Soybean-BioCro model definition</h2><span id='topic+soybean'></span>

<h3>Description</h3>

<p>Initial values, parameters, direct modules, differential modules, and
a differential equation solver that can be used to run soybean growth
simulations in Champaign, Illinois and other locations. Along with the soybean
circadian clock specifications (<code><a href="#topic+soybean_clock">soybean_clock</a></code>), these values
define the soybean growth model of Matthews <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diab032">doi:10.1093/insilicoplants/diab032</a>], which is commonly referred to as
<em>Soybean-BioCro</em>.
</p>
<p>To represent soybean growth in Champaign, IL, these values must be paired with
the Champaign weather data (<code><a href="#topic+cmi_soybean_weather_data">cmi_soybean_weather_data</a></code>). This
weather data includes the output from the soybean circadian clock model
(<code><a href="#topic+soybean_clock">soybean_clock</a></code>), so the clock components do not need to be
included when running a soybean growth simulation using this weather data.
The parameters already include the <code>clay_loam</code> values from the
<code><a href="#topic+soil_parameters">soil_parameters</a></code> dataset, which is the appropriate soil type for
Champaign.
</p>
<p>Some specifications, such as the values of photosynthetic parameters, would
remain the same in any location; others, such as the latitude or longitude,
would need to change when simulating crop growth in different locations. Care
must be taken to understand each input quantity before attempting to run
simulations in other places or for other cultivars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soybean</code></pre>


<h3>Format</h3>

<p>A list of 5 named elements that are suitable for passing to
<code><a href="#topic+run_biocro">run_biocro</a></code>, as described in the help page for
<code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code>.
</p>


<h3>Details</h3>

<p>As improvements are made to the BioCro modules, their behavior changes, and
the soybean model parameters must be updated. Following significant module
updates, reparameterization is performed using the same method and data as
used in Matthews <em>et al.</em> (2022). The following is a summary of
reparameterizations that have occurred since the original publication of the
Soybean-BioCro model:
</p>

<ul>
<li> <p><em>2023-06-18</em>: Several modules have been updated, and the value of
the atmospheric transmittance has been changed from 0.85 to 0.6 based on
Campbell and Norman, An Introduction to Environmental Biophysics,
2nd Edition, Pg 173. Due to these changes, reparameterization of the
following was required: <code>alphaLeaf</code>, <code>alphaRoot</code>,
<code>alphaStem</code>, <code>alphaShell</code>, <code>betaLeaf</code>, <code>betaRoot</code>,
<code>betaStem</code>, <code>betaShell</code>, <code>rateSeneLeaf</code>, <code>rateSeneStem</code>,
<code>alphaSeneLeaf</code>, <code>betaSeneLeaf</code>, <code>alphaSeneStem</code>, and
<code>betaSeneStem</code>.
</p>
</li>
<li> <p><em>2023-03-15</em>: Several modules have been updated. The most
significant changes are that (1) the
<code>BioCro:no_leaf_resp_neg_assim_partitioning_growth_calculator</code> now
reduces the leaf growth rate in response to water stress and (2) the
partitioning modules now include a new tissue type (<code>shell</code>). The new
component allows us to distinguish between components of the soybean pod,
where <code>shell</code> represents the pericarp and <code>grain</code> represents the
seed. This distinction has been found to be important for accurately
predicting seed biomass, which is more important in agricultural settings
than the entire pod mass, since the pericarp is not included in typical
yield measurements. Due to these changes, reparameterization of the
following was required: <code>alphaLeaf</code>, <code>alphaRoot</code>,
<code>alphaStem</code>, <code>alphaShell</code>, <code>betaLeaf</code>, <code>betaRoot</code>,
<code>betaStem</code>, <code>betaShell</code>, <code>rateSeneLeaf</code>, <code>rateSeneStem</code>,
<code>alphaSeneLeaf</code>, <code>betaSeneLeaf</code>, <code>alphaSeneStem</code>, and
<code>betaSeneStem</code>. It was also necessary to add a new direct module to the
model definition: <code>BioCro:leaf_water_stress_exponential</code>. This module
calculates the fractional reduction in leaf growth rate due to water stress.
</p>
</li></ul>

<p>Whenever a reparameterization is made, this list should be updated, and any
vignettes using the soybean model should be checked to see if any axis limits,
etc., need to change.
</p>


<h3>Source</h3>

<p>This model is described in detail in Matthews <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diab032">doi:10.1093/insilicoplants/diab032</a>]. Here we make a few notes about some of
its components:
</p>

<ul>
<li><p> For this model, the ODE solver type should not be
<code>boost_rosenbrock</code> or <code>auto</code> (which defaults to
<code>boost_rosenbrock</code> when a fixed step size Euler ODE solver is not
required, as in this case) since the integration will fail unless the
tolerances are stringent (e.g., <code>output_step_size = 0.01</code>,
<code>adaptive_rel_error_tol = 1e-9</code>, <code>adaptive_abs_error_tol = 1e-9</code>).
</p>
</li>
<li><p> For the initial total seed mass per land area, we use the following
equation: <code>Number of seeds per meter * weight per seed / row spacing</code>.
The number of seeds per meter is 20 and the row spacing is 0.38 m, as
reported in Morgan <em>et al.</em> (2004) [<a href="https://doi.org/10.1104/pp.104.043968">doi:10.1104/pp.104.043968</a>]. The
weight per seed is based on the average of .12 to .18 grams, as reported by
<a href="https://www.feedipedia.org/node/42">Feedipedia</a>. Thus, we have an
initial biomass of
<code>(20 seeds / m) * (0.15 g / seed) / (0.38 m) = 7.89 g / m^2</code>,
equivalent to <code>0.0789 Mg / ha</code> in the typical BioCro units. Since this
model does not have a seed component, this value is used to determine the
initial <code>Leaf</code>, <code>Stem</code>, and <code>Root</code> biomass, assuming 80%
leaf, 10% stem, and 10% root.
</p>
</li>
<li><p> For historical reasons, the seed tissue in this model is called
<code>Grain</code>. The entire pod biomass can be calculated by adding the
<code>Grain</code> and <code>Shell</code> biomass.
</p>
</li>
<li><p> For historical reasons, this model includes a <code>Rhizome</code> tissue.
Soybean does not have a rhizome, so the rhizome in the model does not grow
or senesce. To achieve this, the <code>kRhizome_emr</code> and
<code>rateSeneRhizome</code> parameters must be set to 0. It is also necessary to
specify values for several other quantities such as <code>alphaSeneRhizome</code>,
<code>betaSeneRhizome</code>, and the initial rhizome mass, although the actual
values of these quantities will have no effect on the simulation output.
</p>
</li>
<li><p> For historical reasons, some of the modules that define Soybean-BioCro
require input quantities that are not actually used for any calculations;
these &quot;extraneous&quot; parameters are identified in <code>data/soybean.R</code>.
</p>
</li>
<li><p> The <code>sowing_time</code> input to the
<code>soybean_development_rate_calculator</code> module is set to 0 because
Soybean-BioCro uses the weather data to set the sowing time. In other words,
the weather data is truncated so it begins at the sowing date.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code>
</p>
</li>
<li> <p><code><a href="#topic+soybean_clock">soybean_clock</a></code>
</p>
</li></ul>


<hr>
<h2 id='soybean_clock'>Soybean-BioCro circadian clock model definition</h2><span id='topic+soybean_clock'></span>

<h3>Description</h3>

<p>Initial values, parameters, direct modules, differential modules, and
a differential equation solver that can be used to run soybean circadian clock
simulations in Champaign, Illinois and other locations. Along with the soybean
growth specifications (<code><a href="#topic+soybean">soybean</a></code>), these values define the soybean
growth model of Matthews <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diab032">doi:10.1093/insilicoplants/diab032</a>], which is commonly referred to as
<em>Soybean-BioCro</em>.
</p>
<p>To represent a soybean circadian clock in Champaign, Illinois, these values
must be paired with the weather data from <code><a href="#topic+cmi_weather_data">cmi_weather_data</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soybean_clock</code></pre>


<h3>Format</h3>

<p>A list of 5 named elements that are suitable for passing to
<code><a href="#topic+run_biocro">run_biocro</a></code>, as described in the help page for
<code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code>.
</p>


<h3>Source</h3>

<p>This model is described in detail in Matthews <em>et al.</em> (2022)
[<a href="https://doi.org/10.1093/insilicoplants/diab032">doi:10.1093/insilicoplants/diab032</a>] and Lochocki &amp; McGrath (2021)
[<a href="https://doi.org/10.1093/insilicoplants/diab016">doi:10.1093/insilicoplants/diab016</a>].
</p>
<p>Here, we use initial phases for the dawn and dusk oscillators of <code>200.0</code>
and <code>80.0</code> radians, respectively. These values are optimized for
simulations beginning at midnight on January 1, and should require minimal
time for transient signals to die down. These values were determined by
running a simulation for one year starting on January 1, and recording the
oscillator states at the end of December 31.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code>
</p>
</li>
<li> <p><code><a href="#topic+soybean">soybean</a></code>
</p>
</li></ul>


<hr>
<h2 id='system_derivatives'>Calculate Derivatives for Differential Quantities</h2><span id='topic+system_derivatives'></span>

<h3>Description</h3>

<p>Solving a BioCro model using one of R's available differential equation
solvers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  system_derivatives(
    parameters = list(),
    drivers,
    direct_module_names = list(),
    differential_module_names = list()
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="system_derivatives_+3A_parameters">parameters</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="system_derivatives_+3A_drivers">drivers</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="system_derivatives_+3A_direct_module_names">direct_module_names</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
<tr><td><code id="system_derivatives_+3A_differential_module_names">differential_module_names</code></td>
<td>

<p>Identical to the corresponding argument from <code><a href="#topic+run_biocro">run_biocro</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>system_derivatives</code> accepts the same input arguments as
<code><a href="#topic+run_biocro">run_biocro</a></code> with the exceptions of <code>ode_solver</code> and
<code>initial_values</code>; this function is intended to be passed to an ODE solver
in R, which will solve for the system's time dependence as its diffferential
quantities evolve from their initial values, so <code>ode_solver</code> and
<code>initial_values</code> are not required here.
</p>
<p>When using one of the pre-defined crop growth models, it may be helpful to
use the <code>with</code> command to pass arguments to <code>system_derivatives</code>;
see the documentation for <code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code> for more
information.
</p>


<h3>Value</h3>

<p>The return value of <code>system_derivatives</code> is a function with three inputs
(<code>t</code>, <code>differential_quantities</code>, and <code>parms</code>) that returns
derivatives for each of the differential quantities in the dynamical system
determined by the original inputs (<code>parameters</code>, <code>drivers</code>,
<code>direct_module_names</code>, and
<code>differential_module_names</code>).
</p>
<p>This function signature and the requirements for its inputs are set by the
<code>LSODES</code> function from the <code>deSolve</code> package. The <code>t</code> input
should be a single time value and the <code>differential_quantities</code> input
should be a vector with the names of the differential quantities defined by
the modules. <code>parms</code> is required by <code>LSODES</code>, but we don't use it
for anything.
</p>
<p>This function can be passed to <code>LSODES</code> as an alternative integration
method, rather than using one of BioCro's built-in solvers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note: Example 3 below may take several minutes to run. Patience is required!

# Example 1: calculating a single derivative using a soybean model

soybean_system &lt;- system_derivatives(
  soybean$parameters,
  soybean_weather$'2002',
  soybean$direct_modules,
  soybean$differential_modules
)

derivs &lt;- soybean_system(0, unlist(soybean$initial_values), NULL)

# Example 2: a simple oscillator with only one module

times = seq(0, 5, length=100)

oscillator_system_derivatives &lt;- system_derivatives(
  list(
    timestep = 1,
    mass = 1,
    spring_constant = 1
  ),
  data.frame(time=times),
  c(),
  'BioCro:harmonic_oscillator'
)

result &lt;- as.data.frame(deSolve::lsodes(
  c(position=0, velocity=1),
  times,
  oscillator_system_derivatives
))

lattice::xyplot(
  position + velocity ~ time,
  type='l',
  auto=TRUE,
  data=result
)

# Example 3: solving 500 hours of a soybean simulation. This will run slowly
# compared to a regular call to `run_biocro`.



soybean_system &lt;- system_derivatives(
  soybean$parameters,
  soybean_weather$'2002',
  soybean$direct_modules,
  soybean$differential_modules
)

times = seq(from=0, to=500, by=1)

result &lt;- as.data.frame(deSolve::lsodes(unlist(soybean$initial_values), times, soybean_system))

lattice::xyplot(Leaf + Stem ~ time, type='l', auto=TRUE, data=result)

</code></pre>

<hr>
<h2 id='test_module'>Run BioCro module test cases</h2><span id='topic+test_module'></span><span id='topic+case'></span><span id='topic+cases_from_csv'></span>

<h3>Description</h3>

<p>Modules can be tested using test cases, which are sets of known outputs that
correspond to particular inputs. The functions here provide ways to create
test cases and test modules.
</p>
<p><code>test_module</code> runs one test case for a module, returning an error message
if its output does not match the expected value.
</p>
<p><code>case</code> helps define test cases for module testing by combining the
required elements into a list with the correct names as required by
<code>test_module</code>.
</p>
<p><code>cases_from_csv</code> helps define test cases for module testing by creating a
list of test cases from a <code>csv</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  test_module(module_name, case_to_test)

  case(inputs, expected_outputs, description)

  cases_from_csv(module_name, directory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_module_+3A_module_name">module_name</code></td>
<td>

<p>A string specifying one BioCro module, formatted like
<code>library_name:local_module_name</code>, where <code>library_name</code> is the name
of a library that contains a module with local name
<code>local_module_name</code>; such fully-qualified module names can be formed
manually or with <code><a href="#topic+module_paste">module_paste</a></code>.
</p>
</td></tr>
<tr><td><code id="test_module_+3A_case_to_test">case_to_test</code></td>
<td>

<p>A list with three named elements that describe a module test case:
</p>

<ul>
<li> <p><code>inputs</code>: A list of module inputs, i.e., a list of named
numeric elements corresponding to the module's input quantities.
</p>
</li>
<li> <p><code>expected_outputs</code>: A list of expected module outputs, i.e., a
list of named numeric elements corresponding to the expected values
of the module's output quantities.
</p>
</li>
<li> <p><code>description</code>: A string describing the test case, e.g.
<code>"temp below tbase"</code>. The description should be succinct and
not contain any newline characters.
</p>
</li></ul>

</td></tr>
<tr><td><code id="test_module_+3A_inputs">inputs</code></td>
<td>

<p>See the corresponding entry in <code>test_case</code> above.
</p>
</td></tr>
<tr><td><code id="test_module_+3A_expected_outputs">expected_outputs</code></td>
<td>

<p>See the corresponding entry in <code>test_case</code> above.
</p>
</td></tr>
<tr><td><code id="test_module_+3A_description">description</code></td>
<td>

<p>See the corresponding entry in <code>test_case</code> above.
</p>
</td></tr>
<tr><td><code id="test_module_+3A_directory">directory</code></td>
<td>

<p>The directory where module test case files are stored, e.g.
<code>file.path('tests', 'module_test_cases')</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>test_module</code> function forms the basis for the BioCro module testing
system. (See <code><a href="#topic+module_testing">module_testing</a></code> for more information.) The functions
<code>case</code> and <code>cases_from_csv</code> are complementary to <code>test_module</code>
because they help to pass suitably-formatted test cases to <code>test_module</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>test_module</code></td>
<td>

<p>If the test passes, an empty string; otherwise, an informative message about
what went wrong.
</p>
</td></tr>
<tr><td><code>case</code></td>
<td>

<p>A list with three named elements (<code>inputs</code>, <code>expected_outputs</code>,
and <code>description</code>) formed from the input arguments.
</p>
</td></tr>
<tr><td><code>cases_from_csv</code></td>
<td>

<p>A list of test cases created by the <code>case</code> function that are each
suitable for passing to the <code>test_module</code> function.
</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_case_files">module_case_files</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_paste">module_paste</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_testing">module_testing</a></code>
</p>
</li>
<li> <p><code><a href="#topic+test_module_library">test_module_library</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1: Defining an individual test case for the 'BioCro' module library's
# 'thermal_time_linear' module and running the test. This test will pass, so the
# return value will be an empty string: `character(0)`
test_module(
  'BioCro:thermal_time_linear',
  case(
    list(time = 101, sowing_time = 100, tbase = 20, temp = 44),
    list(TTc = 1.0),
    'temp above tbase'
  )
)

# Example 2: Defining an individual test case for the 'BioCro' module library's
# 'thermal_time_linear' module and running the test. This test will fail, so the
# return value will be a message indicating the failure.
test_module(
  'BioCro:thermal_time_linear',
  case(
    list(time = 101, sowing_time = 100, tbase = 20, temp = 44),
    list(TTc = 2.0),
    'temp above tbase'
  )
)

# Example 3: Loading a set of test cases from a file and running one of them.
# Note: here we use the `initialize_csv` function first to ensure that there is
# a properly defined test file in a temporary directory.

td &lt;- tempdir()

module_name &lt;- 'BioCro:thermal_time_linear'
initialize_csv(module_name, td)
cases &lt;- cases_from_csv(module_name, td)
test_module(module_name, cases[[1]])
</code></pre>

<hr>
<h2 id='test_module_library'>Run module test cases for an entire BioCro module library</h2><span id='topic+test_module_library'></span>

<h3>Description</h3>

<p>Modules can be tested using test cases, which are sets of known outputs that
correspond to particular inputs. The <code>test_module_library</code> function
provides a way to run all test cases for all modules in a BioCro module
library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  test_module_library(library_name, directory, modules_to_skip = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_module_library_+3A_library_name">library_name</code></td>
<td>
<p>The name of a BioCro module library.</p>
</td></tr>
<tr><td><code id="test_module_library_+3A_directory">directory</code></td>
<td>

<p>The directory where module test case files are stored, e.g.
<code>file.path('tests', 'module_test_cases')</code>
</p>
</td></tr>
<tr><td><code id="test_module_library_+3A_modules_to_skip">modules_to_skip</code></td>
<td>

<p>A vector of local module name strings indicating any modules from the
library that should not be tested. This feature should be used sparingly,
since there are very few legitimate reasons to skip a module test.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each module in the specified library, <code>test_module_library</code> loads
stored test cases from the specified directory and runs each test case,
storing information about any test failures or other issues that may occur.
If any problems are detected, <code>test_module_library</code> throws an error with
a message describing the issues.
</p>
<p>For an example of how this function can be used along with the
<code><a href="testthat.html#topic+testthat">testthat</a></code> package, see
<code>tests/testthat/test.Modules.R</code>.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_case_files">module_case_files</a></code>
</p>
</li>
<li> <p><code><a href="#topic+module_testing">module_testing</a></code>
</p>
</li>
<li> <p><code><a href="#topic+test_module">test_module</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Here we will initialize a module test case file in a temporary directory, and
# then use `test_module_library` to test it. We will need to skip most of the
# modules in the library, since we only have a test case for one of them.

td &lt;- tempdir()

initialize_csv(
  'BioCro:thermal_time_linear',
  td,
  nonstandard_inputs = list(temp = -1),
  overwrite = TRUE
)

# Get a list of local module names, excluding the module that has a test case
all_modules &lt;- get_all_modules('BioCro')
skip &lt;- all_modules[all_modules != 'BioCro:thermal_time_linear']
skip &lt;- gsub('BioCro:', '', skip)

test_module_library('BioCro', td, skip)

# If we attempt to test the entire library, we will get errors since only one
# module actually has an associated case file
tryCatch(
  {
    test_module_library('BioCro', td)
  },
  error = function(e) {print(e)}
)
</code></pre>

<hr>
<h2 id='willow'>Willow model definition</h2><span id='topic+willow'></span>

<h3>Description</h3>

<p>Initial values, parameters, direct modules, differential modules, and
a differential equation solver that can be used to run willow growth
simulations in Champaign, Illinois and other locations.
</p>
<p>To represent willow growth in Champaign, IL, these values must be paired with
the Champaign weather data (<code><a href="#topic+cmi_weather_data">cmi_weather_data</a></code>). The parameters
already include the <code>clay_loam</code> values from the
<code><a href="#topic+soil_parameters">soil_parameters</a></code> dataset, which is the appropriate soil type for
Champaign.
</p>
<p>Some specifications, such as the values of photosynthetic parameters, would
remain the same in any location; others, such as the latitude or longitude,
would need to change when simulating crop growth in different locations. Care
must be taken to understand each input quantity before attempting to run
simulations in other places or for other cultivars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>willow</code></pre>


<h3>Format</h3>

<p>A list of 5 named elements that are suitable for passing to
<code><a href="#topic+run_biocro">run_biocro</a></code>, as described in the help page for
<code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code>.
</p>


<h3>Source</h3>

<p>This model was originally described in Wang <em>et al.</em> (2015)
[<a href="https://doi.org/10.1111/pce.12556">doi:10.1111/pce.12556</a>]. Since its original parameterization, the behavior
of several of its core modules has changed as bugs have been identified and
fixed, so this model likely needs to be reparameterized before it can be used
for realistic simulations.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+run_biocro">run_biocro</a></code>
</p>
</li>
<li> <p><code><a href="#topic+modules">modules</a></code>
</p>
</li>
<li> <p><code><a href="#topic+crop_model_definitions">crop_model_definitions</a></code>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
