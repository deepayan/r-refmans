<!DOCTYPE html><html lang="en-US"><head><title>Help for package genridge</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {genridge}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#genridge-package'><p>Generalized ridge trace plots for ridge regression</p></a></li>
<li><a href='#Acetylene'><p>Acetylene Data</p></a></li>
<li><a href='#biplot.pcaridge'><p>Biplot of Ridge Regression Trace Plot in SVD Space</p></a></li>
<li><a href='#contourf'><p>Enhanced Contour Plots</p></a></li>
<li><a href='#Detroit'><p>Detroit Homicide Data for 1961-1973</p></a></li>
<li><a href='#diab'><p>Diabetes Progression</p></a></li>
<li><a href='#Manpower'><p>Hospital manpower data</p></a></li>
<li><a href='#pairs.ridge'><p>Scatterplot Matrix of Bivariate Ridge Trace Plots</p></a></li>
<li><a href='#pca'><p>Transform Ridge Estimates to PCA Space</p></a></li>
<li><a href='#plot.precision'><p>Plot Shrinkage vs. Variance for Ridge Precision</p></a></li>
<li><a href='#plot.ridge'><p>Bivariate Ridge Trace Plots</p></a></li>
<li><a href='#plot3d'><p>3D Ridge Trace Plots</p></a></li>
<li><a href='#precision'><p>Measures of Precision and Shrinkage for Ridge Regression</p></a></li>
<li><a href='#prostate'><p>Prostate Cancer Data</p></a></li>
<li><a href='#ridge'><p>Ridge Regression Estimates</p></a></li>
<li><a href='#traceplot'><p>Univariate Ridge Trace Plots</p></a></li>
<li><a href='#trans.colors'><p>Make Colors Transparent</p></a></li>
<li><a href='#vif.ridge'><p>Variance Inflation Factors for Ridge Regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Ridge Trace Plots for Ridge Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-30</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Friendly &lt;friendly@yorku.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), car</td>
</tr>
<tr>
<td>Imports:</td>
<td>rgl, colorspace, splines</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, bestglm, vcdExtra</td>
</tr>
<tr>
<td>Description:</td>
<td>The genridge package introduces generalizations of the standard univariate
  ridge trace plot used in ridge regression and related methods.  These graphical methods
  show both bias (actually, shrinkage) and precision, by plotting the covariance ellipsoids of the estimated
  coefficients, rather than just the estimates themselves.  2D and 3D plotting methods are provided,
  both in the space of the predictor variables and in the transformed space of the PCA/SVD of the
  predictors.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/friendly/genridge/issues">https://github.com/friendly/genridge/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/friendly/genridge">https://github.com/friendly/genridge</a>,
<a href="https://friendly.github.io/genridge/">https://friendly.github.io/genridge/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-02 14:41:12 UTC; friendly</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Friendly <a href="https://orcid.org/0000-0002-3237-0941"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-02 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='genridge-package'>Generalized ridge trace plots for ridge regression</h2><span id='topic+genridge-package'></span><span id='topic+genridge'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The genridge package introduces generalizations of the standard univariate
ridge trace plot used in ridge regression and related methods (Friendly,
2012).  These graphical methods show both bias (actually, shrinkage) and
precision, by plotting the covariance ellipsoids of the estimated
coefficients, rather than just the estimates themselves.  2D and 3D plotting
methods are provided, both in the space of the predictor variables and in
the transformed space of the PCA/SVD of the predictors.
</p>


<h3>Details</h3>

<p>This package provides computational support for the
graphical methods described in Friendly (2013). Ridge regression models may
be fit using the function <code><a href="#topic+ridge">ridge</a></code>, which incorporates features
of <code><a href="MASS.html#topic+lm.ridge">lm.ridge</a></code>.  In particular, the shrinkage factors in
ridge regression may be specified either in terms of the constant added to
the diagonal of <code class="reqn">X^T X</code> matrix (<code>lambda</code>), or the equivalent number
of degrees of freedom.
</p>
<p>More importantly, the <code><a href="#topic+ridge">ridge</a></code> function also calculates and
returns the associated covariance matrices of each of the ridge estimates,
allowing precision to be studied and displayed graphically.
</p>
<p>This provides the support for the main plotting functions in the package:
</p>
<p><code><a href="#topic+plot.ridge">plot.ridge</a></code>: Bivariate ridge trace plots
</p>
<p><code><a href="#topic+pairs.ridge">pairs.ridge</a></code>: All pairwise bivariate ridge trace plots
</p>
<p><code><a href="#topic+plot3d.ridge">plot3d.ridge</a></code>: 3D ridge trace plots
</p>
<p><code><a href="#topic+traceplot">traceplot</a></code>: Traditional univariate ridge trace plots
</p>
<p>In addition, the function <code><a href="#topic+pca.ridge">pca.ridge</a></code> transforms the
coefficients and covariance matrices of a <code>ridge</code> object from predictor
space to the equivalent, but more interesting space of the PCA of <code class="reqn">X^T
X</code> or the SVD of <b>X</b>.  The main plotting functions also work for these
objects, of class <code>c("ridge", "pcaridge")</code>.
</p>
<p>Finally, the functions <code><a href="#topic+precision">precision</a></code> and <code><a href="#topic+vif.ridge">vif.ridge</a></code>
provide other useful measures and plots.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>
<p>Maintainer: Michael Friendly &lt;friendly@yorku.ca&gt;
</p>


<h3>References</h3>

<p>Friendly, M. (2013). The Generalized Ridge Trace Plot:
Visualizing Bias <em>and</em> Precision. <em>Journal of Computational and
Graphical Statistics</em>, <b>22</b>(1), 50-68,
doi:10.1080/10618600.2012.681237,
<a href="https://www.datavis.ca/papers/genridge-jcgs.pdf">https://www.datavis.ca/papers/genridge-jcgs.pdf</a>
</p>
<p>Arthur E. Hoerl and Robert W. Kennard (1970). Ridge Regression: Biased
Estimation for Nonorthogonal Problems, <em>Technometrics</em>, 12(1), pp.
55-67.
</p>
<p>Arthur E. Hoerl and Robert W. Kennard (1970). Ridge Regression: Applications
to Nonorthogonal Problems <em>Technometrics</em>, 12(1), pp. 69-82.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+lm.ridge">lm.ridge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see examples for ridge, etc.

</code></pre>

<hr>
<h2 id='Acetylene'>Acetylene Data</h2><span id='topic+Acetylene'></span>

<h3>Description</h3>

<p>The data consist of measures of <code>yield</code> of a chemical manufacturing
process for acetylene in relation to numeric parameters.
</p>


<h3>Format</h3>

<p>A data frame with 16 observations on the following 4 variables.
</p>
 
<dl>
<dt><code>yield</code></dt><dd><p>conversion percentage yield of acetylene</p>
</dd>
<dt><code>temp</code></dt><dd><p>reactor temperature (celsius)</p>
</dd> 
<dt><code>ratio</code></dt><dd><p>H2 to N-heptone ratio</p>
</dd> 
<dt><code>time</code></dt><dd><p>contact time (sec)</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Marquardt and Snee (1975) used these data to illustrate ridge regression in
a model containing quadratic and interaction terms, particularly the need to
center and standardize variables appearing in high-order terms.
</p>
<p>Typical models for these data include the interaction of <code>temp:ratio</code>,
and a squared term in <code>temp</code>
</p>


<h3>Source</h3>

<p>SAS documentation example for <code>PROC REG</code>, <em>Ridge
Regression for Acetylene Data</em>.
</p>


<h3>References</h3>

<p>Marquardt, D.W., and Snee, R.D. (1975), &quot;Ridge Regression in
Practice,&quot; <em>The American Statistician</em>, <b>29</b>, 3-20.
</p>
<p>Marquardt, D.W. (1980), &quot;A Critique of Some Ridge Regression Methods:
Comment,&quot; <em>Journal of the American Statistical Association</em>, Vol. 75,
No. 369 (Mar., 1980), pp. 87-91
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Acetylene)

# naive model, not using centering
amod0 &lt;- lm(yield ~ temp + ratio + time + I(time^2) + temp:time, data=Acetylene)

y &lt;- Acetylene[,"yield"]
X0 &lt;- model.matrix(amod0)[,-1]

lambda &lt;- c(0, 0.0005, 0.001, 0.002, 0.005, 0.01)
aridge0 &lt;- ridge(y, X0, lambda=lambda)

traceplot(aridge0)
traceplot(aridge0, X="df")
pairs(aridge0, radius=0.2)



</code></pre>

<hr>
<h2 id='biplot.pcaridge'>Biplot of Ridge Regression Trace Plot in SVD Space</h2><span id='topic+biplot.pcaridge'></span><span id='topic+biplot.ridge'></span>

<h3>Description</h3>

<p><code>biplot.pcaridge</code> supplements the standard display of the covariance
ellipsoids for a ridge regression problem in PCA/SVD space with labeled
arrows showing the contributions of the original variables to the dimensions
plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pcaridge'
biplot(
  x,
  variables = (p - 1):p,
  labels = NULL,
  asp = 1,
  origin,
  scale,
  var.lab = rownames(V),
  var.lwd = 1,
  var.col = "black",
  var.cex = 1,
  xlab,
  ylab,
  prefix = "Dim ",
  suffix = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biplot.pcaridge_+3A_x">x</code></td>
<td>
<p>A <code>pcaridge</code> object computed by <code><a href="#topic+pca.ridge">pca.ridge</a></code> or a <code>ridge</code> object.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_variables">variables</code></td>
<td>
<p>The dimensions or variables to be shown in the the plot.
By default, the <em>last</em> two dimensions, corresponding to the smallest
singular values, are plotted for <code>class("pcaridge")</code> objects or the
<em>first</em> two variables for <code>class("ridge")</code> objects.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_labels">labels</code></td>
<td>
<p>A vector of character strings or expressions used as labels
for the ellipses. Use <code>labels=NULL</code> to suppress these.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_asp">asp</code></td>
<td>
<p>Aspect ratio for the plot. The default value, <code>asp=1</code> helps
ensure that lengths and angles are preserved in these plots. Use
<code>asp=NA</code> to override this.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_origin">origin</code></td>
<td>
<p>The origin for the variable vectors in this plot, a vector of
length 2. If not specified, the function calculates an origin to make the
variable vectors approximately centered in the plot window.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_scale">scale</code></td>
<td>
<p>The scale factor for variable vectors in this plot. If not
specified, the function calculates a scale factor to make the variable
vectors approximately fill the plot window.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_var.lab">var.lab</code></td>
<td>
<p>Labels for variable vectors. The default is the names of the
predictor variables.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_var.lwd">var.lwd</code>, <code id="biplot.pcaridge_+3A_var.col">var.col</code>, <code id="biplot.pcaridge_+3A_var.cex">var.cex</code></td>
<td>
<p>Line width, color and character size used to
draw and label the arrows representing the variables in this plot.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_xlab">xlab</code>, <code id="biplot.pcaridge_+3A_ylab">ylab</code></td>
<td>
<p>Labels for the plot dimensions.  If not specified,
<code>prefix</code> and <code>suffix</code> are used to construct informative dimension
labels.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_prefix">prefix</code></td>
<td>
<p>Prefix for labels of the plot dimensions.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_suffix">suffix</code></td>
<td>
<p>Suffix for labels of the plot dimensions. If
<code>suffix=TRUE</code> the percent of variance accounted for by each dimension
is added to the axis label.</p>
</td></tr>
<tr><td><code id="biplot.pcaridge_+3A_...">...</code></td>
<td>
<p>Other arguments, passed to <code><a href="#topic+plot.pcaridge">plot.pcaridge</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The biplot view showing the dimensions corresponding to the two
<em>smallest</em> singular values is particularly useful for understanding how
the predictors contribute to shrinkage in ridge regression.
</p>
<p>This is only a biplot in the loose sense that results are shown in two
spaces simultaneously &ndash; the transformed PCA/SVD space of the original
predictors, and vectors representing the predictors projected into this
space.
</p>
<p><code>biplot.ridge</code> is a similar extension of <code><a href="#topic+plot.ridge">plot.ridge</a></code>,
adding vectors showing the relation of the PCA/SVD dimensions to the plotted
variables.
</p>
<p><code>class("ridge")</code> objects use the transpose of the right singular
vectors, <code>t(x$svd.V)</code> for the dimension weights plotted as vectors.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Michael Friendly, with contributions by Uwe Ligges
</p>


<h3>References</h3>

<p>Friendly, M. (2013). The Generalized Ridge Trace Plot:
Visualizing Bias <em>and</em> Precision. 
<em>Journal of Computational and Graphical Statistics</em>, <b>22</b>(1), 50-68,
<a href="https://doi.org/10.1080/10618600.2012.681237">doi:10.1080/10618600.2012.681237</a>,
<a href="https://datavis.ca/papers/genridge-jcgs.pdf">https://datavis.ca/papers/genridge-jcgs.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ridge">plot.ridge</a></code>, <code><a href="#topic+pca.ridge">pca.ridge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
longley.y &lt;- longley[, "Employed"]
longley.X &lt;- data.matrix(longley[, c(2:6,1)])

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lridge &lt;- ridge(longley.y, longley.X, lambda=lambda)

plridge &lt;- pca(lridge)

plot(plridge, radius=0.5)

# same, with variable vectors
biplot(plridge, radius=0.5)
# add some other options
biplot(plridge, radius=0.5, var.col="brown", var.lwd=2, var.cex=1.2, prefix="Dimension ")

# biplots for ridge objects, showing PCA vectors
plot(lridge, radius=0.5)
biplot(lridge, radius=0.5)
biplot(lridge, radius=0.5, asp=NA)


</code></pre>

<hr>
<h2 id='contourf'>Enhanced Contour Plots</h2><span id='topic+contourf'></span>

<h3>Description</h3>

<p>This is an enhancement to <code><a href="graphics.html#topic+contour">contour</a></code>, written as a
wrapper for that function.  It creates a contour plot, or adds contour lines
to an existing plot, allowing the contours to be filled and returning the
list of contour lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contourf(
  x = seq(0, 1, length.out = nrow(z)),
  y = seq(0, 1, length.out = ncol(z)),
  z,
  nlevels = 10,
  levels = pretty(zlim, nlevels),
  zlim = range(z, finite = TRUE),
  col = par("fg"),
  color.palette = colorRampPalette(c("white", col)),
  fill.col = color.palette(nlevels + 1),
  fill.alpha = 0.5,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contourf_+3A_x">x</code>, <code id="contourf_+3A_y">y</code></td>
<td>
<p>locations of grid lines at which the values in <code>z</code> are
measured.  These must be in ascending order.  By default, equally spaced
values from 0 to 1 are used.  If <code>x</code> is a list, its components
<code>x$x</code> and <code>x$y</code> are used for x and y, respectively.  If the list
has component <code>x$z</code> this is used for <code>z</code>.</p>
</td></tr>
<tr><td><code id="contourf_+3A_z">z</code></td>
<td>
<p>a matrix containing the values to be plotted (NAs are allowed).
Note that <code>x</code> can be used instead of <code>z</code> for convenience.</p>
</td></tr>
<tr><td><code id="contourf_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contour levels desired <b>iff</b> levels is not
supplied</p>
</td></tr>
<tr><td><code id="contourf_+3A_levels">levels</code></td>
<td>
<p>numeric vector of levels at which to draw contour lines</p>
</td></tr>
<tr><td><code id="contourf_+3A_zlim">zlim</code></td>
<td>
<p>z-limits for the plot. x-limits and y-limits can be passed
through ...</p>
</td></tr>
<tr><td><code id="contourf_+3A_col">col</code></td>
<td>
<p>color for the lines drawn</p>
</td></tr>
<tr><td><code id="contourf_+3A_color.palette">color.palette</code></td>
<td>
<p>a color palette function to be used to assign fill
colors in the plot</p>
</td></tr>
<tr><td><code id="contourf_+3A_fill.col">fill.col</code></td>
<td>
<p>a call to the <code>color.palette</code> function or an an
explicit set of colors to be used in the plot. Use <code>fill.col=NULL</code> to
suppress the filled polygons.  a vector of fill colors corresponding to
levels.  By default, a set of possibly transparent colors is calculated
ranging from white to <code>col</code>, using transparency given by
<code>fill.alpha</code></p>
</td></tr>
<tr><td><code id="contourf_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>transparency value for <code>fill.col</code>, either a hex
character string, or a numeric value between 0 and 1.  Use
<code>fill.alpha=NA</code> to suppress transparency.</p>
</td></tr>
<tr><td><code id="contourf_+3A_add">add</code></td>
<td>
<p>logical. If <code>TRUE</code>, add to a current plot.</p>
</td></tr>
<tr><td><code id="contourf_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+contour">contour</a></code>,
including all arguments of <code><a href="graphics.html#topic+contour.default">contour.default</a></code> not
mentioned above, as well as additional graphical parameters passed by
<code><a href="graphics.html#topic+contour.default">contour.default</a></code> to more basic functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly the list of contours lines, with components
<code>levels</code>, <code>x</code>, <code>y</code>. See
<code><a href="grDevices.html#topic+contourLines">contourLines</a></code>.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+contour">contour</a></code>,
<code><a href="grDevices.html#topic+contourLines">contourLines</a></code>
</p>
<p><code><a href="lattice.html#topic+contourplot">contourplot</a></code> from package lattice.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 10*1:nrow(volcano)
y &lt;- 10*1:ncol(volcano)
contourf(x,y,volcano, col="blue")
contourf(x,y,volcano, col="blue", nlevels=6)

# return value, unfilled, other graphic parameters
res &lt;- contourf(x,y,volcano, col="blue", fill.col=NULL, lwd=2)
# levels used in the plot
sapply(res, function(x) x[[1]])


</code></pre>

<hr>
<h2 id='Detroit'>Detroit Homicide Data for 1961-1973</h2><span id='topic+Detroit'></span>

<h3>Description</h3>

<p>The data set <code>Detroit</code> was used extensively in the book by Miller
(2002) on subset regression. The data are unusual in that a subset of three
predictors can be found which gives a very much better fit to the data than
the subsets found from the Efroymson stepwise algorithm, or from forward
selection or backward elimination. They are also unusual in that, as time
series data, the assumption of independence is patently violated, and the
data suffer from problems of high collinearity.
</p>
<p>As well, ridge regression reveals somewhat paradoxical paths of shrinkage in
univariate ridge trace plots, that are more comprehensible in multivariate
views.
</p>


<h3>Format</h3>

<p>A data frame with 13 observations on the following 14 variables.
</p>
 
<dl>
<dt><code>Police</code></dt><dd><p>Full-time police per 100,000 population</p>
</dd>
<dt><code>Unemp</code></dt><dd><p>Percent unemployed in the population</p>
</dd>
<dt><code>MfgWrk</code></dt><dd><p>Number of manufacturing workers in thousands</p>
</dd>
<dt><code>GunLic</code></dt><dd><p>Number of handgun licences per 100,000 population</p>
</dd>
<dt><code>GunReg</code></dt><dd><p>Number of handgun registrations per 100,000 population</p>
</dd> 
<dt><code>HClear</code></dt><dd><p>Percent of homicides cleared by arrests</p>
</dd>
<dt><code>WhMale</code></dt><dd><p>Number of white males in the population</p>
</dd>
<dt><code>NmfgWrk</code></dt><dd><p>Number of non-manufacturing workers in thousands</p>
</dd>
<dt><code>GovWrk</code></dt><dd><p>Number of government workers in thousands</p>
</dd>
<dt><code>HrEarn</code></dt><dd><p>Average hourly earnings</p>
</dd> 
<dt><code>WkEarn</code></dt><dd><p>Average weekly earnings</p>
</dd> 
<dt><code>Accident</code></dt><dd><p>Death rate in accidents per 100,000 population</p>
</dd> 
<dt><code>Assaults</code></dt><dd><p>Number of assaults per 100,000 population</p>
</dd> 
<dt><code>Homicide</code></dt><dd><p>Number of homicides per 100,000 of population</p>
</dd> 
</dl>



<h3>Details</h3>

<p>The data were originally collected and discussed by Fisher (1976) but the
complete dataset first appeared in Gunst and Mason (1980, Appendix A).
Miller (2002) discusses this dataset throughout his book, but doesn't state
clearly which variables he used as predictors and which is the dependent
variable.  (<code>Homicide</code> was the dependent variable, and the predictors
were <code>Police</code> ... <code>WkEarn</code>.)  The data were obtained from
StatLib.
</p>
<p>A similar version of this data set, with different variable names appears in
the <code>bestglm</code> package.
</p>


<h3>Source</h3>

<p><a href="https://lib.stat.cmu.edu/datasets/detroit">https://lib.stat.cmu.edu/datasets/detroit</a>
</p>


<h3>References</h3>

<p>Fisher, J.C. (1976). Homicide in Detroit: The Role of Firearms.
<em>Criminology</em>, <b>14</b>, 387&ndash;400.
</p>
<p>Gunst, R.F. and Mason, R.L. (1980). <em>Regression analysis and its
application: A data-oriented approach</em>.  Marcel Dekker.
</p>
<p>Miller, A. J. (2002). <em>Subset Selection in Regression</em>. 2nd Ed. Chapman
&amp; Hall/CRC. Boca Raton.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Detroit)

# Work with a subset of predictors, from Miller (2002, Table 3.14),
# the "best" 6 variable model
#    Variables: Police, Unemp, GunLic, HClear, WhMale, WkEarn
# Scale these for comparison with other methods

Det &lt;- as.data.frame(scale(Detroit[,c(1,2,4,6,7,11)]))
Det &lt;- cbind(Det, Homicide=Detroit[,"Homicide"])

# use the formula interface; specify ridge constants in terms
# of equivalent degrees of freedom
dridge &lt;- ridge(Homicide ~ ., data=Det, df=seq(6,4,-.5))

# univariate trace plots are seemingly paradoxical in that
# some coefficients "shrink" *away* from 0
traceplot(dridge, X="df")
vif(dridge)
pairs(dridge, radius=0.5)


plot3d(dridge, radius=0.5, labels=dridge$df)

# transform to PCA/SVD space
dpridge &lt;- pca(dridge)

# not so paradoxical in PCA space
traceplot(dpridge, X="df")
biplot(dpridge, radius=0.5, labels=dpridge$df)

# show PCA vectors in variable space
biplot(dridge, radius=0.5, labels=dridge$df)



</code></pre>

<hr>
<h2 id='diab'>Diabetes Progression</h2><span id='topic+diab'></span>

<h3>Description</h3>

<p>These data consist of observations on 442 patients, with the response of interest being 
a quantitative measure of disease progression one year after baseline.
</p>
<p>There are ten baseline variables: age, sex, body-mass index (<code>bmi</code>), average blood pressure (<code>map</code>)
and six blood serum measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("diab")
</code></pre>


<h3>Format</h3>

<p>A data frame with 442 observations on the following 11 variables.
</p>

<dl>
<dt><code>prog</code></dt><dd><p>disease progression, a numeric vector</p>
</dd>
<dt><code>age</code></dt><dd><p>age, a numeric vector</p>
</dd>
<dt><code>sex</code></dt><dd><p>integer, a numeric vector</p>
</dd>
<dt><code>bmi</code></dt><dd><p>body mass index, a numeric vector</p>
</dd>
<dt><code>map</code></dt><dd><p>mean arterial blood pressure, a numeric vector</p>
</dd>
<dt><code>tc</code></dt><dd><p>blood serum TC, a numeric vector</p>
</dd>
<dt><code>ldl</code></dt><dd><p>blood serum low-density lipoprotein (&quot;bad cholersterol&quot;), a numeric vector</p>
</dd>
<dt><code>hdl</code></dt><dd><p>blood serum high-density lipoprotein (&quot;good cholersterol&quot;), a numeric vector</p>
</dd>
<dt><code>tch</code></dt><dd><p>blood serum TCH, a numeric vector</p>
</dd>
<dt><code>ltg</code></dt><dd><p>blood serum lamotrigine, a numeric vector</p>
</dd>
<dt><code>glu</code></dt><dd><p>blood serum glucose, a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Efron &amp; Hastie describe their analysis using the centered predictor variables standardized to unit L2 norm.
<code><a href="#topic+ridge">ridge</a></code> does not (yet) provide this scaling.
</p>


<h3>Source</h3>

<p>The dataset was taken from the web site for Efron &amp; Hastie (2021), <em>Computer Age Statistical Inference</em>,
<a href="https://hastie.su.domains/CASI_files/DATA/diabetes.csv">https://hastie.su.domains/CASI_files/DATA/diabetes.csv</a>.
</p>


<h3>References</h3>

<p>Efron, B., Hastie, T., Johnstone, I., &amp; Tibshirani, R. (2004). Least Angle Regression. 
<em>The Annals of Statistics</em>, <b>32</b>(2), 407-499. 
<a href="https://doi.org/10.1214/009053604000000067">doi:10.1214/009053604000000067</a>
</p>
<p>Efron, B., &amp; Hastie, T. (2021). <em>Computer Age Statistical Inference, Student Edition: Algorithms, Evidence, and Data Science</em>,
Cambridge University Press. <a href="https://doi.org/10.1017/9781108914062">doi:10.1017/9781108914062</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(diab)
## maybe str(diab) ; plot(diab) ...

</code></pre>

<hr>
<h2 id='Manpower'>Hospital manpower data</h2><span id='topic+Manpower'></span>

<h3>Description</h3>

<p>The hospital manpower data, taken from Myers (1990), table 3.8, are a
well-known example of highly collinear data to which ridge regression and
various shrinkage and selection methods are often applied.
</p>
<p>The data consist of measures taken at 17 U.S. Naval Hospitals and the goal
is to predict the required monthly man hours for staffing purposes.
</p>


<h3>Format</h3>

<p>A data frame with 17 observations on the following 6 variables.
</p>
 
<dl>
<dt><code>Hours</code></dt><dd><p>monthly man hours (response variable)</p>
</dd>
<dt><code>Load</code></dt><dd><p>average daily patient load</p>
</dd> 
<dt><code>Xray</code></dt><dd><p>monthly X-ray exposures</p>
</dd> 
<dt><code>BedDays</code></dt><dd><p>monthly occupied bed days</p>
</dd>
<dt><code>AreaPop</code></dt><dd><p>eligible population in the area in thousands</p>
</dd>
<dt><code>Stay</code></dt><dd><p>average length of patient's stay in days</p>
</dd> 
</dl>



<h3>Details</h3>

<p>Myers (1990) indicates his source was &quot;Procedures and Analysis for Staffing
Standards Development: Data/Regression Analysis Handbook&quot;, Navy Manpower and
Material Analysis Center, San Diego, 1979.
</p>


<h3>Source</h3>

<p>Raymond H. Myers (1990). <em>Classical and Modern Regression with
Applications</em>, 2nd ed., PWS-Kent, pp. 130-133.
</p>


<h3>References</h3>

<p>Donald R. Jensen and Donald E. Ramirez (2012). Variations on
Ridge Traces in Regression, <em>Communications in Statistics - Simulation
and Computation</em>, 41 (2), 265-278.
</p>


<h3>See Also</h3>

<p><code><a href="bestglm.html#topic+manpower">manpower</a></code> for the same data, and other
analyses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Manpower)
mmod &lt;- lm(Hours ~ ., data=Manpower)
vif(mmod)
# ridge regression models, specified in terms of equivalent df
mridge &lt;- ridge(Hours ~ ., data=Manpower, df=seq(5, 3.75, -.25))
vif(mridge)

# univariate ridge trace plots
traceplot(mridge)
traceplot(mridge, X="df")

# bivariate ridge trace plots
plot(mridge, radius=0.25, labels=mridge$df)
pairs(mridge, radius=0.25)


# 3D views
# ellipsoids for Load, Xray &amp; BedDays are nearly 2D
plot3d(mridge, radius=0.2, labels=mridge$df)
# variables in model selected by AIC &amp; BIC
plot3d(mridge, variables=c(2,3,5), radius=0.2, labels=mridge$df)

# plots in PCA/SVD space
mpridge &lt;- pca(mridge)
traceplot(mpridge, X="df")
biplot(mpridge, radius=0.25)



</code></pre>

<hr>
<h2 id='pairs.ridge'>Scatterplot Matrix of Bivariate Ridge Trace Plots</h2><span id='topic+pairs.ridge'></span>

<h3>Description</h3>

<p>Displays all possible pairs of bivariate ridge trace plots for a given set
of predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ridge'
pairs(
  x,
  variables,
  radius = 1,
  lwd = 1,
  lty = 1,
  col = c("black", "red", "darkgreen", "blue", "darkcyan", "magenta", "brown",
    "darkgray"),
  center.pch = 16,
  center.cex = 1.25,
  digits = getOption("digits") - 3,
  diag.cex = 2,
  diag.panel = panel.label,
  fill = FALSE,
  fill.alpha = 0.3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairs.ridge_+3A_x">x</code></td>
<td>
<p>A <code>ridge</code> object, as fit by <code><a href="#topic+ridge">ridge</a></code></p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_variables">variables</code></td>
<td>
<p>Predictors in the model to be displayed in the plot: an
integer or character vector, giving the indices or names of the variables.</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_radius">radius</code></td>
<td>
<p>Radius of the ellipse-generating circle for the covariance
ellipsoids.</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_lwd">lwd</code>, <code id="pairs.ridge_+3A_lty">lty</code></td>
<td>
<p>Line width and line type for the covariance ellipsoids.
Recycled as necessary.</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_col">col</code></td>
<td>
<p>A numeric or character vector giving the colors used to plot the
covariance ellipsoids.  Recycled as necessary.</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_center.pch">center.pch</code></td>
<td>
<p>Plotting character used to show the bivariate ridge
estimates. Recycled as necessary.</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_center.cex">center.cex</code></td>
<td>
<p>Size of the plotting character for the bivariate ridge
estimates</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_digits">digits</code></td>
<td>
<p>Number of digits to be displayed as the (min, max) values in
the diagonal panels</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_diag.cex">diag.cex</code></td>
<td>
<p>Character size for predictor labels in diagonal panels</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_diag.panel">diag.panel</code></td>
<td>
<p>Function to draw diagonal panels.  Not yet implemented:
just uses internal <code>panel.label</code> to write the variable name and ranges.</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_fill">fill</code></td>
<td>
<p>Logical vector: Should the covariance ellipsoids be filled?
Recycled as necessary.</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>Numeric vector: alpha transparency value(s) for filled
ellipsoids. Recycled as necessary.</p>
</td></tr>
<tr><td><code id="pairs.ridge_+3A_...">...</code></td>
<td>
<p>Other arguments passed down</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of plotting.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Friendly, M. (2013). The Generalized Ridge Trace Plot:
Visualizing Bias <em>and</em> Precision. <em>Journal of Computational and
Graphical Statistics</em>, <b>22</b>(1), 50-68,
doi:10.1080/10618600.2012.681237,
<a href="https://www.datavis.ca/papers/genridge-jcgs.pdf">https://www.datavis.ca/papers/genridge-jcgs.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ridge">ridge</a></code> for details on ridge regression as implemented here
</p>
<p><code><a href="#topic+plot.ridge">plot.ridge</a></code>, <code><a href="#topic+traceplot">traceplot</a></code> for other plotting methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
longley.y &lt;- longley[, "Employed"]
longley.X &lt;- data.matrix(longley[, c(2:6,1)])

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lridge &lt;- ridge(longley.y, longley.X, lambda=lambda)

pairs(lridge, radius=0.5, diag.cex=1.75)

data(prostate)
py &lt;- prostate[, "lpsa"]
pX &lt;- data.matrix(prostate[, 1:8])
pridge &lt;- ridge(py, pX, df=8:1)

pairs(pridge)

</code></pre>

<hr>
<h2 id='pca'>Transform Ridge Estimates to PCA Space</h2><span id='topic+pca'></span><span id='topic+pca.ridge'></span>

<h3>Description</h3>

<p>The function <code>pca.ridge</code> transforms a <code>ridge</code> object from
parameter space, where the estimated coefficients are <code class="reqn">\beta_k</code> with
covariance matrices <code class="reqn">\Sigma_k</code>, to the principal component space defined
by the right singular vectors, <code class="reqn">V</code>, of the singular value decomposition
of the scaled predictor matrix, <code class="reqn">X</code>.
</p>
<p>In this space, the transformed coefficients are <code class="reqn">V \beta_k</code>, with
covariance matrices </p>
<p style="text-align: center;"><code class="reqn">V \Sigma_k V^T</code>
</p>
<p>.
</p>
<p>This transformation provides alternative views of ridge estimates in
low-rank approximations. In particular, it allows one to see where the
effects of collinearity typically reside &mdash; in the smallest PCA dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pca_+3A_x">x</code></td>
<td>
<p>A <code>ridge</code> object, as fit by <code><a href="#topic+ridge">ridge</a></code></p>
</td></tr>
<tr><td><code id="pca_+3A_...">...</code></td>
<td>
<p>Other arguments passed down. Not presently used in this
implementation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("ridge", "pcaridge")</code>, with the same
components as the original <code>ridge</code> object.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Friendly, M. (2013). The Generalized Ridge Trace Plot:
Visualizing Bias <em>and</em> Precision. <em>Journal of Computational and
Graphical Statistics</em>, <b>22</b>(1), 50-68,
doi:10.1080/10618600.2012.681237,
<a href="https://www.datavis.ca/papers/genridge-jcgs.pdf">https://www.datavis.ca/papers/genridge-jcgs.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ridge">ridge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
longley.y &lt;- longley[, "Employed"]
longley.X &lt;- data.matrix(longley[, c(2:6,1)])

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lridge &lt;- ridge(longley.y, longley.X, lambda=lambda)

plridge &lt;- pca(lridge)
traceplot(plridge)
pairs(plridge)
# view in space of smallest singular values
plot(plridge, variables=5:6)


</code></pre>

<hr>
<h2 id='plot.precision'>Plot Shrinkage vs. Variance for Ridge Precision</h2><span id='topic+plot.precision'></span>

<h3>Description</h3>

<p>This function uses the results of <code><a href="#topic+precision">precision</a></code> to
plot a measure of shrinkage of the coefficients in ridge regression against a selected measure
of their estimated sampling variance, so as to provide a direct visualization of the tradeoff
between bias and precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'precision'
plot(
  x,
  xvar = "norm.beta",
  yvar = c("det", "trace", "max.eig"),
  labels = c("lambda", "df"),
  label.cex = 1.25,
  label.prefix,
  criteria = NULL,
  pch = 16,
  cex = 1.5,
  col,
  main = NULL,
  xlab,
  ylab,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.precision_+3A_x">x</code></td>
<td>
<p>A data frame of class <code>"precision"</code> resulting from <code><a href="#topic+precision">precision</a></code> called
on a <code>"ridge"</code> object. Named <code>x</code> only to conform with the <code><a href="base.html#topic+plot">plot</a></code> generic.</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_xvar">xvar</code></td>
<td>
<p>The character name of the column to be used for the horizontal axis. Typically, this is the normalized sum 
of squares of the coefficients (<code>"norm.beta"</code>) used as a measure of shrinkage / bias.</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_yvar">yvar</code></td>
<td>
<p>The character name of the column to be used for the vertical axis. One of 
<code>c("det", "trace", "max.eig")</code>. See <code><a href="#topic+precision">precision</a></code> for definitions of these measures.</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_labels">labels</code></td>
<td>
<p>The character name of the column to be used for point labels. One of <code>c("lambda", "df")</code>.</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_label.cex">label.cex</code></td>
<td>
<p>Character size for point labels.</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_label.prefix">label.prefix</code></td>
<td>
<p>Character or expression prefix for the point labels.</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_criteria">criteria</code></td>
<td>
<p>The vector of optimal shrinkage criteria from the <code><a href="#topic+ridge">ridge</a></code> call to be added
as points in the plot.</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_pch">pch</code></td>
<td>
<p>Plotting character for points</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_cex">cex</code></td>
<td>
<p>Character size for points</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_col">col</code></td>
<td>
<p>Point colors</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_xlab">xlab</code></td>
<td>
<p>Label for horizontal axis</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_ylab">ylab</code></td>
<td>
<p>Label for vertical axis</p>
</td></tr>
<tr><td><code id="plot.precision_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing. Used for the side effect of plotting.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ridge">ridge</a></code> for details on ridge regression as implemented here.
<code><a href="#topic+precision">precision</a></code> for definitions of the measures
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- c(0, 0.001, 0.005, 0.01, 0.02, 0.04, 0.08)
lridge &lt;- ridge(Employed ~ GNP + Unemployed + Armed.Forces + 
                  Population + Year + GNP.deflator, 
                data=longley, lambda=lambda)

criteria &lt;- lridge$criteria |&gt; print()

pridge &lt;- precision(lridge) |&gt; print()

plot(pridge)
# also show optimal criteria
plot(pridge, criteria = criteria)

# use degrees of freedom as point labels 
plot(pridge, labels = "df")
plot(pridge, labels = "df", label.prefix="df:")
# show the trace measure
plot(pridge, yvar="trace")
</code></pre>

<hr>
<h2 id='plot.ridge'>Bivariate Ridge Trace Plots</h2><span id='topic+plot.ridge'></span><span id='topic+plot.pcaridge'></span>

<h3>Description</h3>

<p>The bivariate ridge trace plot displays 2D projections of the covariance
ellipsoids for a set of ridge regression estimates indexed by a ridge tuning
constant.
</p>
<p>The centers of these ellipses show the bias induced for each parameter, and
also how the change in the ridge estimate for one parameter is related to
changes for other parameters.
</p>
<p>The size and shapes of the covariance ellipses show directly the effect on
precision of the estimates as a function of the ridge tuning constant.
</p>
<p><code>plot.pcaridge</code> does these bivariate ridge trace plots for <code>"pcaridge"</code> objects, defaulting to plotting the
two smallest components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ridge'
plot(
  x,
  variables = 1:2,
  radius = 1,
  which.lambda = 1:length(x$lambda),
  labels = lambda,
  pos = 3,
  cex = 1.2,
  lwd = 2,
  lty = 1,
  xlim,
  ylim,
  col = c("black", "red", "darkgreen", "blue", "darkcyan", "magenta", "brown",
    "darkgray"),
  center.pch = 16,
  center.cex = 1.5,
  fill = FALSE,
  fill.alpha = 0.3,
  ref = TRUE,
  ref.col = gray(0.7),
  ...
)

## S3 method for class 'pcaridge'
plot(x, variables = (p - 1):p, labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ridge_+3A_x">x</code></td>
<td>
<p>A <code>ridge</code> object, as fit by <code><a href="#topic+ridge">ridge</a></code></p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_variables">variables</code></td>
<td>
<p>Predictors in the model to be displayed in the plot: an
integer or character vector of length 2, giving the indices or names of the
variables. Defaults to the first two predictors for <code>ridge</code> objects or
the <em>last</em> two dimensions for <code>pcaridge</code> objects.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_radius">radius</code></td>
<td>
<p>Radius of the ellipse-generating circle for the covariance
ellipsoids. The default, <code>radius=1</code> gives a standard &ldquo;unit&rdquo;
ellipsoid. Typically, values <code>radius&lt;1</code> gives less cluttered displays.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_which.lambda">which.lambda</code></td>
<td>
<p>A vector of indices used to select the values of
<code>lambda</code> for which ellipses are plotted. The default is to plot
ellipses for all values of <code>lambda</code> in the <code>ridge</code> object.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_labels">labels</code></td>
<td>
<p>A vector of character strings or expressions used as labels
for the ellipses. Use <code>labels=NULL</code> to suppress these.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_pos">pos</code>, <code id="plot.ridge_+3A_cex">cex</code></td>
<td>
<p>Scalars or vectors of positions (relative to the ellipse
centers) and character size used to label the ellipses</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_lwd">lwd</code>, <code id="plot.ridge_+3A_lty">lty</code></td>
<td>
<p>Line width and line type for the covariance ellipsoids.
Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_xlim">xlim</code>, <code id="plot.ridge_+3A_ylim">ylim</code></td>
<td>
<p>X, Y limits for the plot, each a vector of length 2.  If
missing, the range of the covariance ellipsoids is used.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_col">col</code></td>
<td>
<p>A numeric or character vector giving the colors used to plot the
covariance ellipsoids.  Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_center.pch">center.pch</code></td>
<td>
<p>Plotting character used to show the bivariate ridge
estimates. Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_center.cex">center.cex</code></td>
<td>
<p>Size of the plotting character for the bivariate ridge
estimates</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_fill">fill</code></td>
<td>
<p>Logical vector: Should the covariance ellipsoids be filled?
Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_fill.alpha">fill.alpha</code></td>
<td>
<p>Numeric vector: alpha transparency value(s) in the range
(0, 1) for filled ellipsoids. Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_ref">ref</code></td>
<td>
<p>Logical: whether to draw horizontal and vertical reference lines
at 0.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_ref.col">ref.col</code></td>
<td>
<p>Color of reference lines.</p>
</td></tr>
<tr><td><code id="plot.ridge_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to
<code><a href="graphics.html#topic+plot.default">plot.default</a></code>, e.g., <code>xlab</code>, <code>ylab</code>, and
other graphic parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side effect of plotting.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Friendly, M. (2013). The Generalized Ridge Trace Plot:
Visualizing Bias <em>and</em> Precision. <em>Journal of Computational and
Graphical Statistics</em>, <b>22</b>(1), 50-68,
doi:10.1080/10618600.2012.681237,
<a href="https://www.datavis.ca/papers/genridge-jcgs.pdf">https://www.datavis.ca/papers/genridge-jcgs.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ridge">ridge</a></code> for details on ridge regression as implemented
here; <code><a href="#topic+pairs.ridge">pairs.ridge</a></code>, <code><a href="#topic+traceplot">traceplot</a></code>, for basic plots.
</p>
<p><code><a href="#topic+pca.ridge">pca.ridge</a></code> for transformation of ridge regression estimates to PCA space.
<code><a href="#topic+biplot.pcaridge">biplot.pcaridge</a></code> and <code><a href="#topic+plot3d.ridge">plot3d.ridge</a></code> for other
plotting methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
longley.y &lt;- longley[, "Employed"]
longley.X &lt;- data.matrix(longley[, c(2:6,1)])

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lambdaf &lt;- c("", ".005", ".01", ".02", ".04", ".08")
lridge &lt;- ridge(longley.y, longley.X, lambda=lambda)

op &lt;- par(mfrow=c(2,2), mar=c(4, 4, 1, 1)+ 0.1)
for (i in 2:5) {
	plot(lridge, variables=c(1,i), radius=0.5, cex.lab=1.5)
	text(lridge$coef[1,1], lridge$coef[1,i], expression(~widehat(beta)^OLS), 
	     cex=1.5, pos=4, offset=.1)
	if (i==2) text(lridge$coef[-1,1:2], lambdaf[-1], pos=3, cex=1.25)
}
par(op)

data(prostate)
py &lt;- prostate[, "lpsa"]
pX &lt;- data.matrix(prostate[, 1:8])
pridge &lt;- ridge(py, pX, df=8:1)

plot(pridge)
plot(pridge, fill=c(TRUE, rep(FALSE,7)))


</code></pre>

<hr>
<h2 id='plot3d'>3D Ridge Trace Plots</h2><span id='topic+plot3d'></span><span id='topic+plot3d.ridge'></span><span id='topic+plot3d.pcaridge'></span>

<h3>Description</h3>

<p>The 3D ridge trace plot displays 3D projections of the covariance ellipsoids
for a set of ridge regression estimates indexed by a ridge tuning constant.
</p>
<p>The centers of these ellipses show the bias induced for each parameter, and
also how the change in the ridge estimate for one parameter is related to
changes for other parameters.
</p>
<p>The size and shapes of the covariance ellipsoids show directly the effect on
precision of the estimates as a function of the ridge tuning constant.
</p>
<p><code>plot3d.ridge</code> and <code>plot3d.pcaridge</code> differ only in the defaults
for the variables plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d(x, ...)

## S3 method for class 'pcaridge'
plot3d(x, variables = (p - 2):p, ...)

## S3 method for class 'ridge'
plot3d(
  x,
  variables = 1:3,
  radius = 1,
  which.lambda = 1:length(x$lambda),
  lwd = 1,
  lty = 1,
  xlim,
  ylim,
  zlim,
  xlab,
  ylab,
  zlab,
  col = c("black", "red", "darkgreen", "blue", "darkcyan", "magenta", "brown",
    "darkgray"),
  labels = lambda,
  ref = TRUE,
  ref.col = gray(0.7),
  segments = 40,
  shade = TRUE,
  shade.alpha = 0.1,
  wire = FALSE,
  aspect = 1,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot3d_+3A_x">x</code></td>
<td>
<p>A <code>ridge</code> object, as fit by <code><a href="#topic+ridge">ridge</a></code> or a
<code>pcaridge</code> object as transformed by <code><a href="#topic+pca.ridge">pca.ridge</a></code></p>
</td></tr>
<tr><td><code id="plot3d_+3A_...">...</code></td>
<td>
<p>Other arguments passed down</p>
</td></tr>
<tr><td><code id="plot3d_+3A_variables">variables</code></td>
<td>
<p>Predictors in the model to be displayed in the plot: an
integer or character vector of length 3, giving the indices or names of the
variables. Defaults to the first three predictors for <code>ridge</code> objects
or the <em>last</em> three dimensions for <code>pcaridge</code> objects.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_radius">radius</code></td>
<td>
<p>Radius of the ellipse-generating circle for the covariance
ellipsoids.  The default, <code>radius=1</code> gives a standard &ldquo;unit&rdquo;
ellipsoid. Typically, <code>radius&lt;1</code> gives less cluttered displays.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_which.lambda">which.lambda</code></td>
<td>
<p>A vector of indices used to select the values of
<code>lambda</code> for which ellipsoids are plotted. The default is to plot
ellipsoids for all values of <code>lambda</code> in the <code>ridge</code> object.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_lwd">lwd</code>, <code id="plot3d_+3A_lty">lty</code></td>
<td>
<p>Line width and line type for the covariance ellipsoids.
Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_xlim">xlim</code>, <code id="plot3d_+3A_ylim">ylim</code>, <code id="plot3d_+3A_zlim">zlim</code></td>
<td>
<p>X, Y, Z limits for the plot, each a vector of length
2.  If missing, the range of the covariance ellipsoids is used.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_xlab">xlab</code>, <code id="plot3d_+3A_ylab">ylab</code>, <code id="plot3d_+3A_zlab">zlab</code></td>
<td>
<p>Labels for the X, Y, Z variables in the plot. If
missing, the names of the predictors given in <code>variables</code> is used.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_col">col</code></td>
<td>
<p>A numeric or character vector giving the colors used to plot the
covariance ellipsoids.  Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_labels">labels</code></td>
<td>
<p>A numeric or character vector giving the labels to be drawn at
the centers of the covariance ellipsoids.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_ref">ref</code></td>
<td>
<p>Logical: whether to draw horizontal and vertical reference lines
at 0. This is not yet implemented.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_ref.col">ref.col</code></td>
<td>
<p>Color of reference lines.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_segments">segments</code></td>
<td>
<p>Number of line segments used in drawing each dimension of a
covariance ellipsoid.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_shade">shade</code></td>
<td>
<p>a logical scalar or vector, indicating whether the ellipsoids
should be rendered with <code><a href="rgl.html#topic+shade3d">shade3d</a></code>. Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_shade.alpha">shade.alpha</code></td>
<td>
<p>a numeric value in the range [0,1], or a vector of such
values, giving the alpha transparency for ellipsoids rendered with
<code>shade=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_wire">wire</code></td>
<td>
<p>a logical scalar or vector, indicating whether the ellipsoids
should be rendered with <code><a href="rgl.html#topic+wire3d">wire3d</a></code>. Recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_aspect">aspect</code></td>
<td>
<p>a scalar or vector of length 3, or the character string &quot;iso&quot;,
indicating the ratios of the x, y, and z axes of the bounding box.  The
default, <code>aspect=1</code> makes the bounding box display as a cube
approximately filling the display. See <code><a href="rgl.html#topic+aspect3d">aspect3d</a></code> for
details.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, add to the current <code>rgl</code> plot; the default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. Used for its side-effect of plotting
</p>


<h3>Note</h3>

<p>This is an initial implementation.  The details and arguments are
subject to change.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Friendly, M. (2013). The Generalized Ridge Trace Plot:
Visualizing Bias <em>and</em> Precision. <em>Journal of Computational and
Graphical Statistics</em>, <b>22</b>(1), 50-68,
doi:10.1080/10618600.2012.681237,
<a href="https://www.datavis.ca/papers/genridge-jcgs.pdf">https://www.datavis.ca/papers/genridge-jcgs.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.ridge">plot.ridge</a></code>, <code><a href="#topic+pairs.ridge">pairs.ridge</a></code>,
<code><a href="#topic+pca.ridge">pca.ridge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lmod &lt;- lm(Employed ~ GNP + Unemployed + Armed.Forces + Population + 
                      Year + GNP.deflator, data=longley)
longley.y &lt;- longley[, "Employed"]
longley.X &lt;- model.matrix(lmod)[,-1]

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lambdaf &lt;- c("0", ".005", ".01", ".02", ".04", ".08")
lridge &lt;- ridge(longley.y, longley.X, lambda=lambda)


plot3d(lridge, var=c(1,4,5), radius=0.5)

# view in SVD/PCA space
plridge &lt;- pca(lridge)
plot3d(plridge, radius=0.5)




</code></pre>

<hr>
<h2 id='precision'>Measures of Precision and Shrinkage for Ridge Regression</h2><span id='topic+precision'></span><span id='topic+precision.ridge'></span><span id='topic+precision.lm'></span>

<h3>Description</h3>

<p>The goal of <code>precision</code> is to allow you to study the relationship between shrinkage of ridge
regression coefficients and their precision directly by calculating measures of each.
</p>
<p>Three measures of (inverse) precision based on the &ldquo;size&rdquo; of the
covariance matrix of the parameters are calculated. Let <code class="reqn">V_k \equiv \text{Var}(\mathbf{\beta}_k)</code> 
be the covariance matrix for a given ridge constant, and let <code class="reqn">\lambda_i , i= 1,
\dots p</code> be its eigenvalues. Then the variance (= 1/precision) measures are: 
</p>
 
<ol>
<li> <p><code>"det"</code>: <code class="reqn">\log | V_k | = \log \prod \lambda</code> (with <code>det.fun = "log"</code>, the default)
or <code class="reqn">|V_k|^{1/p} =(\prod \lambda)^{1/p}</code> (with <code>det.fun = "root"</code>)
measures the linearized volume of the covariance ellipsoid and corresponds conceptually to Wilks'
Lambda criterion 
</p>
</li>
<li> <p><code>"trace"</code>: <code class="reqn"> \text{trace}( V_k ) = \sum \lambda</code> corresponds conceptually to Pillai's trace criterion 
</p>
</li>
<li> <p><code>"max.eig"</code>: <code class="reqn"> \lambda_1 = \max (\lambda)</code> corresponds to Roy's largest root criterion.  
</p>
</li></ol>

<p>Two measures of shrinkage are also calculated:
</p>

<ul>
<li> <p><code>norm.beta</code>: the root mean square of the coefficient vector <code class="reqn">\lVert\mathbf{\beta}_k \rVert</code>,
normalized to a maximum of 1.0 if <code>normalize == TRUE</code> (the default).
</p>
</li>
<li> <p><code>norm.diff</code>: the root mean square of the difference from the OLS estimate
<code class="reqn">\lVert \mathbf{\beta}_{\text{OLS}} - \mathbf{\beta}_k \rVert</code>. This measure is inversely related to <code>norm.beta</code>
</p>
</li></ul>

<p>A plot method, <code><a href="#topic+plot.precision">plot.precision</a></code> facilitates making graphs of these quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision(object, det.fun, normalize, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision_+3A_object">object</code></td>
<td>
<p>An object of class <code>ridge</code> or <code>lm</code></p>
</td></tr>
<tr><td><code id="precision_+3A_det.fun">det.fun</code></td>
<td>
<p>Function to be applied to the determinants of the covariance
matrices, one of <code>c("log","root")</code>.</p>
</td></tr>
<tr><td><code id="precision_+3A_normalize">normalize</code></td>
<td>
<p>If <code>TRUE</code> the length of the coefficient vector <code class="reqn">\mathbf{\beta}_k</code> is
normalized to a maximum of 1.0.</p>
</td></tr>
<tr><td><code id="precision_+3A_...">...</code></td>
<td>
<p>Other arguments (currently unused)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>c("precision", "data.frame")</code> with the following columns: 
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>The ridge constant</p>
</td></tr> 
<tr><td><code>df</code></td>
<td>
<p>The equivalent effective degrees of freedom</p>
</td></tr> 
<tr><td><code>det</code></td>
<td>
<p>The <code>det.fun</code> function of the determinant of the covariance matrix</p>
</td></tr> 
<tr><td><code>trace</code></td>
<td>
<p>The trace of the covariance matrix</p>
</td></tr>
<tr><td><code>max.eig</code></td>
<td>
<p>Maximum eigen value of the covariance matrix</p>
</td></tr>
<tr><td><code>norm.beta</code></td>
<td>
<p>The root mean square of the estimated coefficients, possibly normalized</p>
</td></tr> 
<tr><td><code>norm.diff</code></td>
<td>
<p>The root mean square of the difference between the OLS solution 
(<code>lambda = 0</code>) and ridge solutions</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Models fit by <code>lm</code> and <code>ridge</code> use a different scaling for
the predictors, so the results of <code>precision</code> for an <code>lm</code> model
will not correspond to those for <code>ridge</code> with ridge constant = 0.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ridge">ridge</a></code>, <code><a href="#topic+plot.precision">plot.precision</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
longley.y &lt;- longley[, "Employed"]
longley.X &lt;- data.matrix(longley[, c(2:6,1)])

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lridge &lt;- ridge(longley.y, longley.X, lambda=lambda)

# same, using formula interface
lridge &lt;- ridge(Employed ~ GNP + Unemployed + Armed.Forces + Population + Year + GNP.deflator, 
		data=longley, lambda=lambda)

clr &lt;- c("black", rainbow(length(lambda)-1, start=.6, end=.1))
coef(lridge)

(pdat &lt;- precision(lridge))
# plot log |Var(b)| vs. length(beta)
with(pdat, {
	plot(norm.beta, det, type="b", 
	cex.lab=1.25, pch=16, cex=1.5, col=clr, lwd=2,
	xlab='shrinkage: ||b|| / max(||b||)',
	ylab='variance: log |Var(b)|')
	text(norm.beta, det, lambda, cex=1.25, pos=c(rep(2,length(lambda)-1),4))
	text(min(norm.beta), max(det), "Variance vs. Shrinkage", cex=1.5, pos=4)
	})

# plot trace[Var(b)] vs. length(beta)
with(pdat, {
	plot(norm.beta, trace, type="b",
	cex.lab=1.25, pch=16, cex=1.5, col=clr, lwd=2,
	xlab='shrinkage: ||b|| / max(||b||)',
	ylab='variance: trace [Var(b)]')
	text(norm.beta, trace, lambda, cex=1.25, pos=c(2, rep(4,length(lambda)-1)))
#	text(min(norm.beta), max(det), "Variance vs. Shrinkage", cex=1.5, pos=4)
	})


</code></pre>

<hr>
<h2 id='prostate'>Prostate Cancer Data</h2><span id='topic+prostate'></span>

<h3>Description</h3>

<p>Data to examine the correlation between the level of prostate-specific
antigen and a number of clinical measures in men who were about to receive a
radical prostatectomy.
</p>


<h3>Format</h3>

<p>A data frame with 97 observations on the following 10 variables.
</p>
 
<dl>
<dt>lcavol</dt><dd><p>log cancer volume</p>
</dd> 
<dt>lweight</dt><dd><p>log prostate weight</p>
</dd> 
<dt>age</dt><dd><p>in years</p>
</dd> 
<dt>lbph</dt><dd><p>log of the amount of benign prostatic hyperplasia</p>
</dd> 
<dt>svi</dt><dd><p>seminal vesicle invasion</p>
</dd> 
<dt>lcp</dt><dd><p>log of capsular penetration</p>
</dd> 
<dt>gleason</dt><dd><p>a numeric vector</p>
</dd>
<dt>pgg45</dt><dd><p>percent of Gleason score 4 or 5</p>
</dd> 
<dt>lpsa</dt><dd><p>response</p>
</dd>
<dt>train</dt><dd><p>a logical vector</p>
</dd> 
</dl>



<h3>Details</h3>

<p>This data set came originally from the (now defunct) ElemStatLearn package.
</p>
<p>The last column indicates which 67 observations were used as the &quot;training
set&quot; and which 30 as the test set, as described on page 48 in the book.
</p>


<h3>Note</h3>

<p>There was an error in this dataset in earlier versions of the package,
as indicated in a footnote on page 3 of the second edition of the book. As
of version 2012.04-0 this was corrected.
</p>


<h3>Source</h3>

<p>Stamey, T., Kabalin, J., McNeal, J., Johnstone, I., Freiha, F.,
Redwine, E. and Yang, N (1989) Prostate specific antigen in the diagnosis
and treatment of adenocarcinoma of the prostate II. Radical prostatectomy
treated patients, <em>Journal of Urology</em>, <b>16</b>: 1076&ndash;1083.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(prostate)
str( prostate )
cor( prostate[,1:8] )
prostate &lt;- prostate[, -10]

prostate.mod &lt;- lm(lpsa ~ ., data=prostate)
vif(prostate.mod)

py &lt;- prostate[, "lpsa"]
pX &lt;- data.matrix(prostate[, 1:8])
pridge &lt;- ridge(py, pX, df=8:1)
pridge

# univariate ridge trace plots
traceplot(pridge)
traceplot(pridge, X="df")

# bivariate ridge trace plots
plot(pridge)
pairs(pridge)



</code></pre>

<hr>
<h2 id='ridge'>Ridge Regression Estimates</h2><span id='topic+ridge'></span><span id='topic+ridge.default'></span><span id='topic+ridge.formula'></span><span id='topic+coef.ridge'></span><span id='topic+print.ridge'></span><span id='topic+vcov.ridge'></span><span id='topic+best'></span><span id='topic+best.ridge'></span>

<h3>Description</h3>

<p>The function <code>ridge</code> fits linear models by ridge regression, returning
an object of class <code>ridge</code> designed to be used with the plotting
methods in this package. 
</p>
<p>It is also designed to facilitate an alternative representation
of the effects of shrinkage in the space of uncorrelated (PCA/SVD) components of the predictors.
</p>
<p>The standard formulation of ridge regression is that it regularizes the estimates of coefficients
by adding small positive constants <code class="reqn">\lambda</code> to the diagonal elements of <code class="reqn">\mathbf{X}^\top\mathbf{X}</code> in
the least squares solution to achieve a more favorable tradeoff between bias and variance (inverse of precision)
of the coefficients.
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\mathbf{\beta}}^{\text{RR}}_k  = (\mathbf{X}^\top \mathbf{X} + \lambda \mathbf{I})^{-1} \mathbf{X}^\top \mathbf{y}  </code>
</p>

<p>Ridge regression shrinkage can be parameterized in several ways.
</p>

<ul>
<li><p> If a vector of <code>lambda</code> values is supplied, these are used directly in the ridge regression computations. 
</p>
</li>
<li><p> Otherwise, if a vector <code>df</code> can be supplied the equivalent values for effective degrees of freedom corresponding to shrinkage,
going down from the number of predictors in the model.
</p>
</li></ul>

<p>In either case, both <code>lambda</code> and
<code>df</code> are returned in the <code>ridge</code> object, but the <code>rownames</code> of the
coefficients are given in terms of <code>lambda</code>.
</p>
<p><code>coef</code> extracts the estimated coefficients for each value of the shrinkage factor
</p>
<p><code>vcov</code> extracts the estimated <code class="reqn">p \times p</code> covariance matrices of the coefficients for each value of the shrinkage factor.
</p>
<p><code>best</code> extracts the optimal shrinkage values according to several criteria: 
HKB: Hoerl et al. (1975); LW: Lawless &amp; Wang (1976); GCV: Golub et al. (1975)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridge(y, ...)

## S3 method for class 'formula'
ridge(formula, data, lambda = 0, df, svd = TRUE, contrasts = NULL, ...)

## Default S3 method:
ridge(y, X, lambda = 0, df, svd = TRUE, ...)

## S3 method for class 'ridge'
coef(object, ...)

## S3 method for class 'ridge'
print(x, digits = max(5, getOption("digits") - 5), ...)

## S3 method for class 'ridge'
vcov(object, ...)

best(object, ...)

## S3 method for class 'ridge'
best(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ridge_+3A_y">y</code></td>
<td>
<p>A numeric vector containing the response variable. NAs not allowed.</p>
</td></tr>
<tr><td><code id="ridge_+3A_...">...</code></td>
<td>
<p>Other arguments, passed down to methods</p>
</td></tr>
<tr><td><code id="ridge_+3A_formula">formula</code></td>
<td>
<p>For the <code>formula</code> method, a two-sided formula.</p>
</td></tr>
<tr><td><code id="ridge_+3A_data">data</code></td>
<td>
<p>For the <code>formula</code> method, data frame within which to
evaluate the formula.</p>
</td></tr>
<tr><td><code id="ridge_+3A_lambda">lambda</code></td>
<td>
<p>A scalar or vector of ridge constants. A value of 0
corresponds to ordinary least squares.</p>
</td></tr>
<tr><td><code id="ridge_+3A_df">df</code></td>
<td>
<p>A scalar or vector of effective degrees of freedom corresponding
to <code>lambda</code></p>
</td></tr>
<tr><td><code id="ridge_+3A_svd">svd</code></td>
<td>
<p>If <code>TRUE</code> the SVD of the centered and scaled <code>X</code> matrix
is returned in the <code>ridge</code> object.</p>
</td></tr>
<tr><td><code id="ridge_+3A_contrasts">contrasts</code></td>
<td>
<p>a list of contrasts to be used for some or all of factor terms in the formula. 
See the <code>contrasts.arg</code> of <code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="ridge_+3A_x">X</code></td>
<td>
<p>A matrix of predictor variables. NA's not allowed. Should not
include a column of 1's for the intercept.</p>
</td></tr>
<tr><td><code id="ridge_+3A_x">x</code>, <code id="ridge_+3A_object">object</code></td>
<td>
<p>An object of class <code>ridge</code></p>
</td></tr>
<tr><td><code id="ridge_+3A_digits">digits</code></td>
<td>
<p>For the <code>print</code> method, the number of digits to print.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an intercept is present in the model, its coefficient is not penalized. (If you want to penalize 
an intercept, put in your own constant term and remove the intercept.)
</p>
<p>The predictors are centered, but not (yet) scaled in this implementation. 
</p>
<p>A number of the methods in the package assume that <code>lambda</code> is a vector of shrinkage constants
increasing from <code>lambda[1] = 0</code>, or equivalently, a vector of <code>df</code> decreasing from <code class="reqn">p</code>.
</p>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>The vector of ridge constants</p>
</td></tr> 
<tr><td><code>df</code></td>
<td>
<p>The vector of effective degrees of freedom corresponding to <code>lambda</code></p>
</td></tr> 
<tr><td><code>coef</code></td>
<td>
<p>The matrix of estimated ridge regression coefficients</p>
</td></tr> 
<tr><td><code>scales</code></td>
<td>
<p>scalings used on the X matrix</p>
</td></tr> 
<tr><td><code>kHKB</code></td>
<td>
<p>HKB estimate of the ridge constant</p>
</td></tr>
<tr><td><code>kLW</code></td>
<td>
<p>L-W estimate of the ridge constant</p>
</td></tr> 
<tr><td><code>GCV</code></td>
<td>
<p>vector of GCV values</p>
</td></tr> 
<tr><td><code>kGCV</code></td>
<td>
<p>value of <code>lambda</code> with the minimum GCV</p>
</td></tr>
<tr><td><code>criteria</code></td>
<td>
<p>Collects the criteria <code>kHKB</code>, <code>kLW</code>, and <code>kGCV</code> in a named vector</p>
</td></tr>
</table>
<p>If <code>svd==TRUE</code> (the default), the following are also included:
</p>
<table role = "presentation">
<tr><td><code>svd.D</code></td>
<td>
<p>Singular values of the <code>svd</code> of the scaled X matrix</p>
</td></tr>
<tr><td><code>svd.U</code></td>
<td>
<p>Left singular vectors of the <code>svd</code> of the scaled X matrix.
Rows correspond to observations and columns to dimensions.</p>
</td></tr>
<tr><td><code>svd.V</code></td>
<td>
<p>Right singular vectors of the <code>svd</code> of the scaled X
matrix. Rows correspond to variables and columns to dimensions.</p>
</td></tr> 
</table>
<p>A data.frame with one row for each of the HKB, LW, and GCV criteria
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Hoerl, A. E., Kennard, R. W., and Baldwin, K. F. (1975), &quot;Ridge
Regression: Some Simulations,&quot; <em>Communications in Statistics</em>, 4,
105-123.
</p>
<p>Lawless, J.F., and Wang, P. (1976), &quot;A Simulation Study of Ridge and Other
Regression Estimators,&quot; <em>Communications in Statistics</em>, 5, 307-323.
</p>
<p>Golub G.H., Heath M., Wahba G. (1979) Generalized cross-validation as a method for choosing a good ridge parameter. 
<em>Technometrics</em>, <b>21</b>:215–223. <a href="https://doi.org/10.2307/1268518">doi:10.2307/1268518</a>
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+lm.ridge">lm.ridge</a></code> for other implementations of ridge regression
</p>
<p><code><a href="#topic+traceplot">traceplot</a></code>, <code><a href="#topic+plot.ridge">plot.ridge</a></code>,
<code><a href="#topic+pairs.ridge">pairs.ridge</a></code>, <code><a href="#topic+plot3d.ridge">plot3d.ridge</a></code>, for 1D, 2D, 3D plotting methods
</p>
<p><code><a href="#topic+pca.ridge">pca.ridge</a></code>, <code><a href="#topic+biplot.ridge">biplot.ridge</a></code>,
<code><a href="#topic+biplot.pcaridge">biplot.pcaridge</a></code> for views in PCA/SVD space
</p>
<p><code><a href="#topic+precision.ridge">precision.ridge</a></code> for measures of shrinkage and precision
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#\donttest{
# Longley data, using number Employed as response
longley.y &lt;- longley[, "Employed"]
longley.X &lt;- data.matrix(longley[, c(2:6,1)])

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lridge &lt;- ridge(longley.y, longley.X, lambda=lambda)

# same, using formula interface
lridge &lt;- ridge(Employed ~ GNP + Unemployed + Armed.Forces + Population + Year + GNP.deflator, 
		data=longley, lambda=lambda)


coef(lridge)

# standard trace plot
traceplot(lridge)
# plot vs. equivalent df
traceplot(lridge, X="df")
pairs(lridge, radius=0.5)
#}


data(prostate)
py &lt;- prostate[, "lpsa"]
pX &lt;- data.matrix(prostate[, 1:8])
pridge &lt;- ridge(py, pX, df=8:1)
pridge

plot(pridge)
pairs(pridge)
traceplot(pridge)
traceplot(pridge, X="df")


# Hospital manpower data from Table 3.8 of Myers (1990) 
data(Manpower)
str(Manpower)

mmod &lt;- lm(Hours ~ ., data=Manpower)
vif(mmod)
# ridge regression models, specified in terms of equivalent df
mridge &lt;- ridge(Hours ~ ., data=Manpower, df=seq(5, 3.75, -.25))
vif(mridge)

# univariate ridge trace plots
traceplot(mridge)
traceplot(mridge, X="df")


# bivariate ridge trace plots
plot(mridge, radius=0.25, labels=mridge$df)
pairs(mridge, radius=0.25)

# 3D views
# ellipsoids for Load, Xray &amp; BedDays are nearly 2D
plot3d(mridge, radius=0.2, labels=mridge$df)
# variables in model selected by AIC &amp; BIC
plot3d(mridge, variables=c(2,3,5), radius=0.2, labels=mridge$df)

# plots in PCA/SVD space
mpridge &lt;- pca(mridge)
traceplot(mpridge, X="df")
biplot(mpridge, radius=0.25)



</code></pre>

<hr>
<h2 id='traceplot'>Univariate Ridge Trace Plots</h2><span id='topic+traceplot'></span>

<h3>Description</h3>

<p>The <code>traceplot</code> function extends and simplifies the univariate ridge
trace plots for ridge regression provided in the <code>plot</code> method for
<code><a href="MASS.html#topic+lm.ridge">lm.ridge</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(
  x,
  X = c("lambda", "df"),
  col = c("black", "red", "darkgreen", "blue", "darkcyan", "magenta", "brown",
    "darkgray"),
  pch = c(15:18, 7, 9, 12, 13),
  xlab,
  ylab = "Coefficient",
  xlim,
  ylim,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traceplot_+3A_x">x</code></td>
<td>
<p>A <code>ridge</code> object, as fit by <code><a href="#topic+ridge">ridge</a></code></p>
</td></tr>
<tr><td><code id="traceplot_+3A_x">X</code></td>
<td>
<p>What to plot as the horizontal coordinate, one of <code>c("lambda", "df")</code></p>
</td></tr>
<tr><td><code id="traceplot_+3A_col">col</code></td>
<td>
<p>A numeric or character vector giving the colors used to plot the
ridge trace curves.  Recycled as necessary.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_pch">pch</code></td>
<td>
<p>Vector of plotting characters used to plot the ridge trace
curves.  Recycled as necessary.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_xlab">xlab</code></td>
<td>
<p>Label for horizontal axis</p>
</td></tr>
<tr><td><code id="traceplot_+3A_ylab">ylab</code></td>
<td>
<p>Label for vertical axis</p>
</td></tr>
<tr><td><code id="traceplot_+3A_xlim">xlim</code>, <code id="traceplot_+3A_ylim">ylim</code></td>
<td>
<p>x, y limits for the plot. You may need to adjust these to allow for the variable labels.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="graphics.html#topic+matplot">matplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For ease of interpretation, the variables are labeled at the side of the
plot (left, right) where the coefficient estimates are expected to be most
widely spread.  If <code>xlim</code> is not specified, the range of the <code>X</code>
variable is extended slightly to accommodate the variable names.
</p>


<h3>Value</h3>

<p>None. Used for its side effect of plotting.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Friendly, M. (2013). The Generalized Ridge Trace Plot:
Visualizing Bias <em>and</em> Precision. <em>Journal of Computational and
Graphical Statistics</em>, <b>22</b>(1), 50-68,
doi:10.1080/10618600.2012.681237,
<a href="https://www.datavis.ca/papers/genridge-jcgs.pdf">https://www.datavis.ca/papers/genridge-jcgs.pdf</a>
</p>
<p>Hoerl, A. E.  and Kennard R. W. (1970). &quot;Ridge Regression: Applications to
Nonorthogonal Problems&quot;, <em>Technometrics</em>, 12(1), 69-82.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ridge">ridge</a></code> for details on ridge regression as implemented here
</p>
<p><code><a href="#topic+plot.ridge">plot.ridge</a></code>, <code><a href="#topic+pairs.ridge">pairs.ridge</a></code> for other plotting
methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
longley.y &lt;- longley[, "Employed"]
longley.X &lt;- data.matrix(longley[, c(2:6,1)])

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lridge &lt;- ridge(longley.y, longley.X, lambda=lambda)

traceplot(lridge)
#abline(v=lridge$kLW, lty=3)
#abline(v=lridge$kHKB, lty=3)
#text(lridge$kLW, -3, "LW")
#text(lridge$kHKB, -3, "HKB")

traceplot(lridge, X="df")


</code></pre>

<hr>
<h2 id='trans.colors'>Make Colors Transparent</h2><span id='topic+trans.colors'></span>

<h3>Description</h3>

<p>Takes a vector of colors (as color names or rgb hex values) and adds a
specified alpha transparency to each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans.colors(col, alpha = 0.5, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trans.colors_+3A_col">col</code></td>
<td>
<p>A character vector of colors, either as color names or rgb hex values</p>
</td></tr>
<tr><td><code id="trans.colors_+3A_alpha">alpha</code></td>
<td>
<p>alpha transparency value(s) to apply to each color (0 means fully transparent and 1 means opaque)</p>
</td></tr>
<tr><td><code id="trans.colors_+3A_names">names</code></td>
<td>
<p>optional character vector of names for the colors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colors (<code>col</code>) and <code>alpha</code> need not be of the same length. The
shorter one is replicated to make them of the same length.
</p>


<h3>Value</h3>

<p>A vector of color values of the form <code>"#rrggbbaa"</code>
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code>, <code><a href="grDevices.html#topic+rgb">rgb</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
trans.colors(palette(), alpha=0.5)

# alpha can be vectorized
trans.colors(palette(), alpha=seq(0, 1, length=length(palette())))

# lengths need not match: shorter one is repeated as necessary
trans.colors(palette(), alpha=c(.1, .2))

trans.colors(colors()[1:20])

# single color, with various alphas
trans.colors("red", alpha=seq(0,1, length=5))
# assign names
trans.colors("red", alpha=seq(0,1, length=5), names=paste("red", 1:5, sep=""))


</code></pre>

<hr>
<h2 id='vif.ridge'>Variance Inflation Factors for Ridge Regression</h2><span id='topic+vif.ridge'></span><span id='topic+print.vif.ridge'></span><span id='topic+plot.vif.ridge'></span>

<h3>Description</h3>

<p>The function <code>vif.ridge</code> calculates variance inflation factors for the
predictors in a set of ridge regression models indexed by the
tuning/shrinkage factor, returning one row for each value of the <code class="reqn">\lambda</code> parameter.
</p>
<p>Variance inflation factors are calculated using the simplified formulation
in Fox &amp; Monette (1992).
</p>
<p>The <code>plot.vif.ridge</code> method plots variance inflation factors for a <code>"vif.ridge"</code> object
in a similar style to what is provided by <code><a href="#topic+traceplot">traceplot</a></code>. That is, it plots the VIF for each
coefficient in the model against either the ridge <code class="reqn">\lambda</code> tuning constant or it's equivalent
effective degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ridge'
vif(mod, ...)

## S3 method for class 'vif.ridge'
print(x, digits = max(4, getOption("digits") - 5), ...)

## S3 method for class 'vif.ridge'
plot(
  x,
  X = c("lambda", "df"),
  Y = c("vif", "sqrt"),
  col = c("black", "red", "darkgreen", "blue", "darkcyan", "magenta", "brown",
    "darkgray"),
  pch = c(15:18, 7, 9, 12, 13),
  xlab,
  ylab,
  xlim,
  ylim,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vif.ridge_+3A_mod">mod</code></td>
<td>
<p>A <code>"ridge"</code> object computed by <code><a href="#topic+ridge">ridge</a></code></p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods</p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_x">x</code></td>
<td>
<p>A <code>ridge</code> object, as fit by <code><a href="#topic+ridge">ridge</a></code></p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_digits">digits</code></td>
<td>
<p>Number of digits to display in the <code>print</code> method</p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_x">X</code></td>
<td>
<p>What to plot as the horizontal coordinate, one of <code>c("lambda", "df")</code></p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_y">Y</code></td>
<td>
<p>What to plot as the vertical coordinate, one of <code>c("vif", "sqrt")</code>, where the latter plots <code class="reqn">\sqrt{VIF}</code>.</p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_col">col</code></td>
<td>
<p>A numeric or character vector giving the colors used to plot the
ridge trace curves.  Recycled as necessary.</p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_pch">pch</code></td>
<td>
<p>Vector of plotting characters used to plot the ridge trace
curves.  Recycled as necessary.</p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_xlab">xlab</code></td>
<td>
<p>Label for horizontal axis</p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_ylab">ylab</code></td>
<td>
<p>Label for vertical axis</p>
</td></tr>
<tr><td><code id="vif.ridge_+3A_xlim">xlim</code>, <code id="vif.ridge_+3A_ylim">ylim</code></td>
<td>
<p>x, y limits for the plot. You may need to adjust these to allow for the variable labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vif</code> returns a <code>"vif.ridge"</code> object, which is a list of four components
</p>
<table role = "presentation">
<tr><td><code>vif</code></td>
<td>
<p>a data frame of the same size and
shape as <code>coef{mod}</code>. The columns correspond to the predictors in the
model and the rows correspond to the values of <code>lambda</code> in ridge
estimation.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the vector of ridge constants from the original call to <code><a href="#topic+ridge">ridge</a></code> </p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the vector of effective degrees of freedom corresponding to <code>lambda</code></p>
</td></tr>
<tr><td><code>criteria</code></td>
<td>
<p>the optimal values of <code>lambda</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Fox, J. and Monette, G. (1992). Generalized collinearity
diagnostics. <em>JASA</em>, <b>87</b>, 178-183, <a href="https://doi.org/10.1080/01621459.1992.10475190">doi:10.1080/01621459.1992.10475190</a>.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+vif">vif</a></code>, <code><a href="#topic+precision">precision</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(longley)
lmod &lt;- lm(Employed ~ GNP + Unemployed + Armed.Forces + Population + 
                      Year + GNP.deflator, data=longley)
vif(lmod)

lambda &lt;- c(0, 0.005, 0.01, 0.02, 0.04, 0.08)
lridge &lt;- ridge(Employed ~ GNP + Unemployed + Armed.Forces + 
                           Population + Year + GNP.deflator, 
		             data=longley, lambda=lambda)

coef(lridge)

# get VIFs for the shrunk estimates
vridge &lt;- vif(lridge)
vridge
names(vridge)



# plot VIFs
pch &lt;- c(15:18, 7, 9)
clr &lt;- c("black", rainbow(5, start=.6, end=.1))

plot(vridge, 
     col=clr, pch=pch, cex = 1.2,
     xlim = c(-0.02, 0.08))

plot(vridge, X = "df",
     col=clr, pch=pch, cex = 1.2,
     xlim = c(4, 6.5))

# Better to plot sqrt(VIF). Plot against degrees of freedom
plot(vridge, X = "df", Y="sqrt",
     col=clr, pch=pch, cex = 1.2,
     xlim = c(4, 6.5))



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
