<!DOCTYPE html><html><head><title>Help for package ffmanova</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ffmanova}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjust'><p>Adjust a predictor matrix for the presence of another matrix</p></a></li>
<li><a href='#c2df'><p>Conversion between matrices and partitioned matrices</p></a></li>
<li><a href='#dressing'><p>Dressing data</p></a></li>
<li><a href='#ffAnova'><p>Type II* Anova</p></a></li>
<li><a href='#ffmanova'><p>Fifty-fifty MANOVA</p></a></li>
<li><a href='#ffmanovatest'><p>50-50 MANOVA testing</p></a></li>
<li><a href='#fixModelMatrix'><p>Fix the &quot;factor&quot; matrix of a terms object.</p></a></li>
<li><a href='#linregEst'><p>Linear regression estimation</p></a></li>
<li><a href='#manova5050'><p>Computation of 50-50 MANOVA results</p></a></li>
<li><a href='#matlabColon'><p>Simulate Matlab's &lsquo;:&rsquo;</p></a></li>
<li><a href='#multiPvalues'><p>p-values from MANOVA test statistics</p></a></li>
<li><a href='#multiStatistics'><p>MANOVA test statistics</p></a></li>
<li><a href='#my_pValueF'><p>F-test p-values</p></a></li>
<li><a href='#myorth'><p>Rank and orthonormal basis</p></a></li>
<li><a href='#norm'><p>Matrix norm.</p></a></li>
<li><a href='#orth_D'><p>Making adjusted design matrix data</p></a></li>
<li><a href='#predict.ffmanova'><p>Predictions, mean predictions, adjusted means and linear combinations</p></a></li>
<li><a href='#print.ffmanova'><p>Print method for ffmanova</p></a></li>
<li><a href='#rotationtests'><p>Rotation testing</p></a></li>
<li><a href='#stdize'><p>Centering and scaling of matrices</p></a></li>
<li><a href='#unitests'><p>Univariate F or t testing</p></a></li>
<li><a href='#x_Obj'><p>Creation of a design matrix object</p></a></li>
<li><a href='#xy_Obj'><p>Creation of a design-with-responses object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fifty-Fifty MANOVA</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Øyvind Langsrud [aut, cre],
  Bjørn-Helge Mevik [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Øyvind Langsrud &lt;oyl@ssb.no&gt;</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>General linear modeling with multiple responses (MANCOVA). An overall p-value for each model term is calculated by the 50-50 MANOVA method by Langsrud (2002) &lt;<a href="https://doi.org/10.1111%2F1467-9884.00320">doi:10.1111/1467-9884.00320</a>&gt;, which handles collinear responses. Rotation testing, described by Langsrud (2005) &lt;<a href="https://doi.org/10.1007%2Fs11222-005-4789-5">doi:10.1007/s11222-005-4789-5</a>&gt;, is used to compute adjusted single response p-values according to familywise error rates and false discovery rates (FDR). The approach to FDR is described in the appendix of Moen et al. (2005) &lt;<a href="https://doi.org/10.1128%2FAEM.71.4.2086-2094.2005">doi:10.1128/AEM.71.4.2086-2094.2005</a>&gt;. Unbalanced designs are handled by Type II sums of squares as argued in Langsrud (2003) &lt;<a href="https://doi.org/10.1023%2FA%3A1023260610025">doi:10.1023/A:1023260610025</a>&gt;. Furthermore, the Type II philosophy is extended to continuous design variables as described in Langsrud et al. (2007) &lt;<a href="https://doi.org/10.1080%2F02664760701594246">doi:10.1080/02664760701594246</a>&gt;. This means that the method is invariant to scale changes and that common pitfalls are avoided.</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>car, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/olangsrud/ffmanova">https://github.com/olangsrud/ffmanova</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/olangsrud/ffmanova/issues">https://github.com/olangsrud/ffmanova/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-18 13:13:06 UTC; oyl</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-18 15:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjust'>Adjust a predictor matrix for the presence of another matrix</h2><span id='topic+adjust'></span>

<h3>Description</h3>

<p><code>adjust</code> adjusts a predictor matrix <code class="reqn">X</code> for the presence of another
predictor matrix <code class="reqn">Y</code>, by orthogonalizing <code class="reqn">X</code> against <code class="reqn">Y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_+3A_x">X</code></td>
<td>
<p>matrix.  The matrix to be adjusted.</p>
</td></tr>
<tr><td><code id="adjust_+3A_y">Y</code></td>
<td>
<p>matrix.  The matrix to be adjusted for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can handle rank deficient matrices.
</p>


<h3>Value</h3>

<p>A matrix with an orthogonal basis for the adjusted predictor matrix.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='c2df'>Conversion between matrices and partitioned matrices</h2><span id='topic+c2df'></span><span id='topic+c2m'></span><span id='topic+m2c'></span>

<h3>Description</h3>

<p>Functions to convert a matrix to a list of partitioned matrices, and back
again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2df(CC)

c2m(CC)

m2c(M, df = rep(1, dim(M)[2]))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c2df_+3A_cc">CC</code></td>
<td>
<p>list of matrices, typically the output of <code>m2c</code></p>
</td></tr>
<tr><td><code id="c2df_+3A_m">M</code></td>
<td>
<p>matrix to be partitioned according to <code>df</code></p>
</td></tr>
<tr><td><code id="c2df_+3A_df">df</code></td>
<td>
<p>integer vector.  See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>m2c</code> partitions a matrix into a list of matrices, by putting the first
<code>df[1]</code> coloumns into the first matrix, the next <code>df[2]</code> coloumns
into the second, etc.
</p>
<p><code>c2m</code> joins a partitioned matrix back into a single matrix.
<code>c2m(m2c(X, df))</code> equals <code>X</code>.
</p>
<p><code>c2df</code> takes a list of matrices and returns a vector with the number of
coloumns of the matrices.
</p>


<h3>Value</h3>

<p><code>m2c</code> returns a list of matrices.
</p>
<p><code>c2m</code> returns a matrix.
</p>
<p><code>c2df</code> returns a numeric vector.
</p>


<h3>Note</h3>

<p><code>sum(df)</code> must equal <code>ncol(X)</code>.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffmanova">ffmanova</a></code>
</p>

<hr>
<h2 id='dressing'>Dressing data</h2><span id='topic+dressing'></span>

<h3>Description</h3>

<p>A dataset from an experiment studying structural and rheological properties
of a full fat dressing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dressing)
</code></pre>


<h3>Format</h3>

<p>A data frame with 29 observations on the following 7 variables.
</p>
 
<dl>
<dt>press</dt><dd><p>a numeric vector with values 75, 125 and
225.  The homogenisation pressure.</p>
</dd> 
<dt>stab</dt><dd><p>a numeric vector
with values 0.3, 0.4 and 0.5.  Amount of stabiliser.</p>
</dd> 
<dt>emul</dt><dd><p>a
numeric vector with values 0.1, 0.2 and 0.35.  Amount of emulsifier.</p>
</dd>
<dt>day</dt><dd><p>a factor with levels <code>1</code>, ..., <code>5</code>.  The
day the experimental run was performed on.</p>
</dd> 
<dt>visc</dt><dd><p>a numeric
vector.  The measured viscosity of the dressing.</p>
</dd> 
<dt>rheo</dt><dd><p>a
matrix with 9 columns.  Nine different response-parameters derived from
rheological measuring.  These parameters contain information about the
physics of the dression (more general that viscosity).</p>
</dd>
<dt>pvol</dt><dd><p>a matrix with 241 columns.  Particle-volume curves.
Using a coulter-counter instrument fat particles were counted and their
volumes were registered.  These data are presented as smoothed histograms
(equally spaced bins on log-scale).  The total area under the curve
represents the total volume of the counted fat particles. The shape of the
curve reflects how the total fat volume is distributed among the different
particle sizes.</p>
</dd> </dl>



<h3>Details</h3>

<p>The data comes from an experiment in which full fat dressings were produced
with different amount of stabiliser and emulsifier, and with different
homogenisation pressure (se above).
</p>
<p>A full factorial <code class="reqn">3^3</code> design with two additional center points was
used.  The experiment was run over five days.  It was unknown up front how
many experimental runs could be performed each day, so the order of the runs
was randomised.
</p>
<p>For each dressing, viscosity, rheology and particle volume measurements were
taken (se above).
</p>
<p>The day is stored as a factor.  The other design variables are stored as
numerical variables.  If one wants to use them as factors, one can use e.g.
<code>factor(press)</code> in the model formula, or 
<code>dressing$press &lt;- factor(dressing$press)</code> 
prior to calling the modelling function.
</p>


<h3>Source</h3>

<p>The data is taken from a research project financed by a grant
(131472/112) from the Norwegian Research Council.  The project was managed
by Stabburet, which is a major manufacturer of dressing in Norway.
</p>

<hr>
<h2 id='ffAnova'>Type II* Anova</h2><span id='topic+ffAnova'></span>

<h3>Description</h3>

<p>Analysis of variance table for a linear model using type <code>II</code>* sums of squares,
which are described in Langsrud et al. (2007).
Type <code>II</code>* extends the type <code>II</code> philosophy to continuous variables. 
The results are invariant to scale changes and pitfalls are avoided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffAnova(formula, data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffAnova_+3A_formula">formula</code></td>
<td>
<p>A model <code><a href="stats.html#topic+formula">formula</a></code> or an <code>R</code> object 
(preferably an <code><a href="stats.html#topic+lm">lm</a></code> object).</p>
</td></tr>
<tr><td><code id="ffAnova_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a variant of <code><a href="#topic+ffmanova">ffmanova</a></code> for the univariate special case.
The two input parameters will be interpreted by <code><a href="stats.html#topic+model.frame">model.frame</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> (see <code><a href="stats.html#topic+anova">anova</a></code>).
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>References</h3>

<p>Langsrud, Ø., Jørgensen, K., Ofstad, R. and Næs, T. (2007):
&ldquo;Analyzing Designed Experiments with Multiple Responses&rdquo;,
<em>Journal of Applied Statistics</em>, <b>34</b>, 1275-1296.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate example data
set.seed(123)
a &lt;- c(0, 0, 0, 10, 10, 10, 1, 1, 1)
A &lt;- as.character(a)  # A is categorical
b &lt;- 1:9
y &lt;- rnorm(9)/10 + a  # y depends strongly on a (and A)
a100 &lt;- a + 100  # change of scale (origin)
b100 &lt;- b + 100  # change of scale (origin)

# Four ways of obtaining the same results
ffAnova(y ~ A * b)
ffAnova(y ~ A * b100)
ffAnova(lm(y ~ A * b))
ffAnova(y ~ A * b, data.frame(A = A, y = y, b = 1:9))

# Second order continuous variable
ffAnova(y ~ a + I(a^2))

# Model equivalent to 'y ~ A * b'
ffAnova(y ~ (a + I(a^2)) * b)

# Demonstrating similarities and differences using package car
if (!require(car))        # Package car is loaded if available 
  Anova &lt;- function(...) {  # Replacement function if car not available
    warning("No results since package car is not available")}

lm_Ab &lt;- lm(y ~ A * b)
lm_Ab100 &lt;- lm(y ~ A * b100)

# Type II same as type II* in this case
Anova(lm_Ab)      # Type II
Anova(lm_Ab100)   # Type II
ffAnova(lm_Ab)    # Type II*
ffAnova(lm_Ab100) # Type II*

# Type III depends on scale
Anova(lm_Ab, type = 3)
Anova(lm_Ab100, type = 3)

lm_a &lt;- lm(y ~ a + I(a^2))
lm_a100 &lt;- lm(y ~ a100 + I(a100^2))

# Now Type II depends on scale
Anova(lm_a)      # Type II
Anova(lm_a100)   # Type II
ffAnova(lm_a)    # Type II*
ffAnova(lm_a100) # Type II*
</code></pre>

<hr>
<h2 id='ffmanova'>Fifty-fifty MANOVA</h2><span id='topic+ffmanova'></span>

<h3>Description</h3>

<p>General linear modeling of fixed-effects models with multiple responses is
performed. The function calculates 50-50 MANOVA <code class="reqn">p</code>-values, ordinary
univariate <code class="reqn">p</code>-values and adjusted <code class="reqn">p</code>-values using rotation
testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffmanova(
  formula,
  data = NULL,
  stand = TRUE,
  nSim = 0,
  verbose = TRUE,
  returnModel = TRUE,
  returnY = FALSE,
  returnYhat = FALSE,
  returnYhatStd = FALSE,
  newdata = NULL,
  linComb = NULL,
  nonEstimableAsNA = TRUE,
  outputClass = "ffmanova"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffmanova_+3A_formula">formula</code></td>
<td>
<p>Model formula.  See &quot;Note&quot; below.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_data">data</code></td>
<td>
<p>An optional data frame or list.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_stand">stand</code></td>
<td>
<p>Logical. Standardization of responses. This option has effect
on the 50-50 MANOVA testing and the calculation of <code>exVarSS</code>.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_nsim">nSim</code></td>
<td>
<p>nonnegative integer. The number of simulations to use in the
rotation tests. Can be a single nonnegative integer or a list of values for
each term.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_verbose">verbose</code></td>
<td>
<p>Logical.  If <code>TRUE</code>, the rotation tests print trace information.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_returnmodel">returnModel</code></td>
<td>
<p>When <code>TRUE</code>, and object, <code>ffModel</code>, with output from <code><a href="#topic+ffModelObj">ffModelObj</a></code> is included in output. 
Must be <code>TRUE</code> to enable predictions by <code><a href="#topic+predict.ffmanova">predict.ffmanova</a></code>.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_returny">returnY</code></td>
<td>
<p>Response matrix, <code>Y</code>, in output when <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_returnyhat">returnYhat</code></td>
<td>
<p>Matrix <code>Yhat</code> of fitted values corresponding to <code>Y</code> in output when <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_returnyhatstd">returnYhatStd</code></td>
<td>
<p>Standard errors, <code>YhatStd</code>, in output when <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_newdata">newdata</code></td>
<td>
<p>Possible input to <code><a href="#topic+predict.ffmanova">predict.ffmanova</a></code>. When non-NULL, prediction results will be included output.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_lincomb">linComb</code></td>
<td>
<p>Possible input to <code><a href="#topic+predict.ffmanova">predict.ffmanova</a></code> in addition to <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_nonestimableasna">nonEstimableAsNA</code></td>
<td>
<p>Will be used as input to <code><a href="#topic+predict.ffmanova">predict.ffmanova</a></code> when <code>newdata</code> and/or <code>linComb</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="ffmanova_+3A_outputclass">outputClass</code></td>
<td>
<p>When set to, <code>"anova"</code>, <code><a href="#topic+ffAnova">ffAnova</a></code> results will be produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An overall <code class="reqn">p</code>-value for all responses is calculated for each model
term. This is done using the 50-50 MANOVA method, which is a modified
variant of classical MANOVA made to handle several highly correlated
responses.
</p>
<p>Ordinary single response <code class="reqn">p</code>-values are produced. By using rotation
testing these can be adjusted for multiplicity according to familywise error
rates or false discovery rates. Rotation testing is a Monte Carlo simulation
framework for doing exact significance testing under multivariate normality.
The number of simulation repetitions (<code>nSim</code>) must be chosen.
</p>
<p>Unbalance is handled by a variant of Type II sums of squares, which has
several nice properties: </p>
 <ol>
<li><p> Invariant to ordering of the
model terms.  </p>
</li>
<li><p> Invariant to scale changes.  </p>
</li>
<li><p> Invariant to how the
overparameterization problem of categorical variable models is solved (how
constraints are defined).  </p>
</li>
<li><p> Whether two-level factors are defined to be
continuos or categorical does not influence the results.  </p>
</li>
<li><p> Analysis of
a polynomial model with a single experimental variable produce results
equivalent to the results using an orthogonal polynomial.  </p>
</li></ol>
<p> In addition to
significance testing an explained variance measure, which is based on sums
of sums of squares, is computed for each model term.
</p>


<h3>Value</h3>

<p>An object of class <code>"ffmanova"</code>, which consists of the
concatenated results from the underlying functions <code><a href="#topic+manova5050">manova5050</a></code>,
<code><a href="#topic+rotationtests">rotationtests</a></code> and <code><a href="#topic+unitests">unitests</a></code>:
</p>
<table>
<tr><td><code>termNames</code></td>
<td>
<p>model term names</p>
</td></tr> <tr><td><code>exVarSS</code></td>
<td>
<p>explained variances
calculated from sums of squares summed over all responses</p>
</td></tr> <tr><td><code>df</code></td>
<td>
<p>degrees
of freedom - adjusted for other terms in model</p>
</td></tr> <tr><td><code>df_om</code></td>
<td>
<p>degrees of
freedom - adjusted for terms contained in actual term</p>
</td></tr> <tr><td><code>nPC</code></td>
<td>
<p>number of
principal components used for testing</p>
</td></tr> <tr><td><code>nBU</code></td>
<td>
<p>number of principal
components used as buffer components</p>
</td></tr> <tr><td><code>exVarPC</code></td>
<td>
<p>variance explained by
<code>nPC</code> components</p>
</td></tr> <tr><td><code>exVarBU</code></td>
<td>
<p>variance explained by <code>(nPC+nBU)</code>
components</p>
</td></tr> <tr><td><code>pValues</code></td>
<td>
<p>50-50 MANOVA <code class="reqn">p</code>-values</p>
</td></tr>
<tr><td><code>stand</code></td>
<td>
<p>logical.  Whether the responses are standardised.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>The test statistics as <code class="reqn">t</code>-statistics (when single degree of
freedom) or <code class="reqn">F</code>-statistics </p>
</td></tr> <tr><td><code>pRaw</code></td>
<td>
<p>matrix of ordinary
<code class="reqn">p</code>-values from F- or t-testing</p>
</td></tr> <tr><td><code>pAdjusted</code></td>
<td>
<p>matrix of adjusted
<code class="reqn">p</code>-values according to familywise error rates</p>
</td></tr> <tr><td><code>pAdjFDR</code></td>
<td>
<p>matrix of
adjusted <code class="reqn">p</code>-values according to false discovery rates</p>
</td></tr>
<tr><td><code>simN</code></td>
<td>
<p>number of simulations performed for each term (same as input)</p>
</td></tr>
</table>
<p>The matrices <code>stat</code>, <code>pRaw</code>, <code>pAdjusted</code> and <code>pAdjFDR</code>
have one row for each model term and one column for each response.
</p>
<p>According to the input parameters, additional elements can be included in output.
</p>


<h3>Note</h3>

<p>The model is specified with <code>formula</code>, in the same way as in <code>lm</code>
(except that offsets are not supported).  See <code><a href="stats.html#topic+lm">lm</a></code> for details.
Input parameters <code>formula</code> and <code>data</code> will be interpreted by <code><a href="stats.html#topic+model.frame">model.frame</a></code>.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>References</h3>

<p>Langsrud, Ø. (2002) 50-50 Multivariate Analysis of Variance for
Collinear Responses. <em>The Statistician</em>, <b>51</b>, 305&ndash;317.
</p>
<p>Langsrud, Ø. (2003) ANOVA for Unbalanced Data: Use Type II Instead of Type
III Sums of Squares. <em>Statistics and Computing</em>, <b>13</b>, 163&ndash;167.
</p>
<p>Langsrud, Ø. (2005) Rotation Tests. <em>Statistics and Computing</em>,
<b>15</b>, 53&ndash;60.
</p>
<p>Moen, B., Oust, A., Langsrud, Ø., Dorrell, N., Gemma, L., Marsden, G.L.,
Hinds, J., Kohler, A., Wren, B.W. and Rudi, K. (2005) An explorative
multifactor approach for investigating global survival mechanisms of
Campylobacter jejuni under environmental conditions.  <em>Applied and
Environmental Microbiology</em>, <b>71</b>, 2086-2094.
</p>
<p>See also <a href="https://www.langsrud.com/stat/program.htm">https://www.langsrud.com/stat/program.htm</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffAnova">ffAnova</a></code> and <code><a href="#topic+predict.ffmanova">predict.ffmanova</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dressing)

# An ANOVA model with all design variables as factors 
# and with visc as the only response variable.
# Classical univariate Type II test results are produced.
ffmanova(visc ~ (factor(press) + factor(stab) + factor(emul))^2 + day,
         data = dressing) 

# A second order response surface model with day as a block factor. 
# The properties of the extended Type II approach is utilized. 
ffmanova(visc ~ (press + stab + emul)^2 + I(press^2)+ I(stab^2)+ I(emul^2)+ day,
         data = dressing)

# 50-50 MANOVA results with the particle-volume curves as 
# multivariate responses. The responses are not standardized.
ffmanova(pvol ~ (press + stab + emul)^2 + I(press^2)+ I(stab^2)+ I(emul^2)+ day,
         stand = FALSE, data = dressing)

# 50-50 MANOVA results with 9 rheological responses (standardized).
# 99 rotation simulation repetitions are performed. 
res &lt;- ffmanova(rheo ~ (press + stab + emul)^2 + I(press^2)+ I(stab^2)+ I(emul^2)+ day,
                nSim = 99, data = dressing)
res$pRaw      #  Unadjusted single responses p-values 
res$pAdjusted #  Familywise error rate adjusted p-values 
res$pAdjFDR   #  False discovery rate adjusted p-values

# As above, but this time 9999 rotation simulation repetitions 
# are performed, but only for the model term stab^2. 
res &lt;- ffmanova(rheo ~ (press + stab + emul)^2 + I(press^2)+ I(stab^2)+ I(emul^2)+ day,
                nSim = c(0,0,0,0,0,9999,0,0,0,0,0), data = dressing)
res$pAdjusted[6,] # Familywise error rate adjusted p-values for stab^2
res$pAdjFDR[6,]   # False discovery rate adjusted p-values for stab^2

# Note that the results of the first example above can also be 
# obtained by using the car package.
## Not run: 
   require(car)
   Anova(lm(visc ~ (factor(press) + factor(stab) + factor(emul))^2 + day,
         data = dressing), type = "II")
## End(Not run)

# The results of the second example differ because Anova does not recognise 
# linear terms (emul) as being contained in quadratic terms (I(emul^2)).
# A consequence here is that the clear significance of emul disappears.
## Not run: 
   require(car)
   Anova(lm(visc ~ (press + stab + emul)^2 + I(press^2)+ I(stab^2)+ I(emul^2)+ day,
         data = dressing), type="II")
## End(Not run)

</code></pre>

<hr>
<h2 id='ffmanovatest'>50-50 MANOVA testing</h2><span id='topic+ffmanovatest'></span>

<h3>Description</h3>

<p>The function performs 50-50 MANOVA testing based on a matrix of hypothesis
observations and a matrix of error observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffmanovatest(
  modelData,
  errorData,
  stand = 0,
  part = c(0.9, 0.5),
  partBufDim = 0.5,
  minBufDim = 0,
  maxBufDim = 1e+08,
  minErrDf = 3,
  cp = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ffmanovatest_+3A_modeldata">modelData</code></td>
<td>
<p>matrix of hypothesis observations</p>
</td></tr>
<tr><td><code id="ffmanovatest_+3A_errordata">errorData</code></td>
<td>
<p>matrix of error observations</p>
</td></tr>
<tr><td><code id="ffmanovatest_+3A_stand">stand</code></td>
<td>
<p>Standardisation (0 or 1) of responses</p>
</td></tr>
<tr><td><code id="ffmanovatest_+3A_part">part</code></td>
<td>
<p>The variance explained required when choosing the number of
components for testing. The default value is 0.5, but to choose a single
component 0.9 is required.</p>
</td></tr>
<tr><td><code id="ffmanovatest_+3A_partbufdim">partBufDim</code></td>
<td>
<p>tuning parameter for the number of buffer components</p>
</td></tr>
<tr><td><code id="ffmanovatest_+3A_minbufdim">minBufDim</code></td>
<td>
<p>minimum (if possible) number of buffer components</p>
</td></tr>
<tr><td><code id="ffmanovatest_+3A_maxbufdim">maxBufDim</code></td>
<td>
<p>maximum number of buffer components</p>
</td></tr>
<tr><td><code id="ffmanovatest_+3A_minerrdf">minErrDf</code></td>
<td>
<p>minimum number of &quot;free dimensions&quot;</p>
</td></tr>
<tr><td><code id="ffmanovatest_+3A_cp">cp</code></td>
<td>
<p>correction parameter when &quot;few&quot; responses</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modelData</code> and <code>errorObs</code> correspond to <code>hypObs</code> and
<code>errorObs</code> calculated by <code>xy_Obj</code>.
</p>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>exVar1</code></td>
<td>
<p>variance explained by
<code>dimY</code> components</p>
</td></tr> <tr><td><code>exVar2</code></td>
<td>
<p>variance explained by
<code>dimY+bufferDim</code> components</p>
</td></tr> <tr><td><code>dim</code></td>
<td>
<p>dimension of final
&quot;MANOVA-space&quot;</p>
</td></tr> <tr><td><code>dimX</code></td>
<td>
<p>the ordinary degrees of freedom for the test</p>
</td></tr>
<tr><td><code>dimY</code></td>
<td>
<p>number of components for testing</p>
</td></tr> <tr><td><code>bufferDim</code></td>
<td>
<p>number of
buffer components</p>
</td></tr> <tr><td><code>D</code></td>
<td>
<p>test statistic: Wilks' Lambda</p>
</td></tr> <tr><td><code>E</code></td>
<td>
<p>test
statistic: Roy's Largest Root</p>
</td></tr> <tr><td><code>A</code></td>
<td>
<p>test statistic: Hotelling-Lawley
Trace Statistic</p>
</td></tr> <tr><td><code>M</code></td>
<td>
<p>test statistic: Pillay-Bartlett Trace Statistic</p>
</td></tr>
<tr><td><code>pD</code></td>
<td>
<p><code class="reqn">p</code>-value: Wilks' Lambda</p>
</td></tr> <tr><td><code>pE</code></td>
<td>
<p><code class="reqn">p</code>-value: LOWER BOUND
for Roy's Largest Root</p>
</td></tr> <tr><td><code>pA</code></td>
<td>
<p><code class="reqn">p</code>-value: Hotelling-Lawley Trace
Statistic</p>
</td></tr> <tr><td><code>pM</code></td>
<td>
<p><code class="reqn">p</code>-value: Pillay-Bartlett Trace Statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffmanova">ffmanova</a></code>
</p>

<hr>
<h2 id='fixModelMatrix'>Fix the &quot;factor&quot; matrix of a terms object.</h2><span id='topic+fixModelMatrix'></span>

<h3>Description</h3>

<p>The function takes the factor matrix of the terms object corresponding to a
model formula and changes it so that model hierarchy is preserved also for
powers of terms (e.g., <code>I(a^2)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixModelMatrix(mOld)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixModelMatrix_+3A_mold">mOld</code></td>
<td>
<p>The factor matrix (i.e. the <code>"factor"</code> attribute) of a
terms object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ordinary model handling functions in do not treat powers of terms
(<code class="reqn">a^n</code>) as being higher order terms (like interaction terms).
<code>fixModelMatrix</code> takes the <code>"factor"</code> attribute of a terms object
(usually created from a model formula) and changes it such that power terms
can be treated hierarchically just like interaction terms.
</p>
<p>The factor matrix has one row for each variable and one coloumn for each
term.  Originally, an entry is 0 if the term does not contain the variable.
If it contains the variable, the entry is 1 if the variable should be coded
with contrasts, and 2 if it should be coded with dummy variables.  See
<code><a href="stats.html#topic+terms.object">terms.object</a></code> for details.
</p>
<p>The changes performed by <code>fixModelMatrix</code> are:
</p>
 <ul>
<li><p> Any 2's are changed to 1.
</p>
</li>
<li><p> In any coloumn corresponding to a term that contains <code>I(a^n)</code>,
where <code>a</code> is the name of a variable and <code>n</code> is a positive integer,
the element in the row corresponding to <code>a</code> is set to <code class="reqn">n</code>.  For
instance, the entry of row <code>D</code> and coloumn <code>C:I(D^2)</code> is set to 2.
</p>
</li>
<li><p> Rows corresponding to <code>I(a^n)</code> are deleted.  </p>
</li></ul>

<p>Note that this changes the semantics of the factor matrix: <code>2</code> no
longer means &lsquo;code via dummy variables&rsquo;.
</p>


<h3>Value</h3>

<p>A factor matrix.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+terms">terms</a></code>, <code><a href="stats.html#topic+terms.object">terms.object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mt &lt;- terms(y ~ a + b + a:b + a:c + I(a^2) + I(a^3) + I(a^2):b)
print(mOld &lt;- attr(mt, "factor"))
fixModelMatrix(mOld)

</code></pre>

<hr>
<h2 id='linregEst'>Linear regression estimation</h2><span id='topic+linregEst'></span><span id='topic+linregEnd'></span><span id='topic+linregStart'></span>

<h3>Description</h3>

<p>Function that performs multivariate multiple linear regression modelling
(<code class="reqn">Y = XB + E</code>) according to a principal component regression (PCR)
approach where the number of components equals the number of nonzero
eigenvalues (generalised inverse).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linregEnd(Umodel, Y)

linregEst(X, Y)

linregStart(X, rank_lim = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linregEst_+3A_umodel">Umodel</code></td>
<td>
<p>this matrix is returned by <code>linregStart</code></p>
</td></tr>
<tr><td><code id="linregEst_+3A_y">Y</code></td>
<td>
<p>response matrix</p>
</td></tr>
<tr><td><code id="linregEst_+3A_x">X</code></td>
<td>
<p>regressor matrix</p>
</td></tr>
<tr><td><code id="linregEst_+3A_rank_lim">rank_lim</code></td>
<td>
<p>tuning parameter for the rank. The default value corresponds
to the rank function in Matlab.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>linregEst</code> performs the calculations in two steps by
calling <code>linregStart</code> and <code>linregEnd</code>. The former functions
function makes all calculations that can be done without knowing <code class="reqn">Y</code>.
The singular value decomposition (SVD) is an essential part of the
calculations and some of the output variables are named according to SVD
(&lsquo;<span class="samp">&#8288;U&#8288;</span>&rsquo;, &lsquo;<span class="samp">&#8288;S&#8288;</span>&rsquo; and &lsquo;<span class="samp">&#8288;V&#8288;</span>&rsquo;).
</p>


<h3>Value</h3>

<p><code>linregEst</code> returns a list with seven components. The first
three components is returned by <code>linregStart</code> - the rest by
<code>linregEnd</code>.
</p>
<table>
<tr><td><code>Umodel</code></td>
<td>
<p>Matrix of score values according to the PCR model.</p>
</td></tr>
<tr><td><code>VmodelDivS</code></td>
<td>
<p>Matrix that can be used to calculate <code>Umodel</code> from
<code>X</code>. That is, <code>Umodel</code> equals <code>X %*% VmodelDivS</code>.</p>
</td></tr>
<tr><td><code>VextraDivS1</code></td>
<td>
<p>Matrix that can be used to check estimability. That is,
predictions for a new X cannot be made if <code>Xnew %*% VextraDivS1</code> is
(close to) zero.</p>
</td></tr> <tr><td><code>BetaU</code></td>
<td>
<p>Matrix of regression parameters according to
the PCR model.</p>
</td></tr> <tr><td><code>msError</code></td>
<td>
<p>Mean square error of each response</p>
</td></tr>
<tr><td><code>errorObs</code></td>
<td>
<p>Error observations that can be used in multivariate testing</p>
</td></tr>
<tr><td><code>Yhat</code></td>
<td>
<p>Fitted values. Equals <code>Umodel %*% BetaU</code> </p>
</td></tr>
</table>


<h3>Note</h3>

<p>When the number of error degrees of freedom exceeds the number of
linearly independent responses, then the matrix of error observations is
made so that several rows are zero. In this case the zero rows are omitted
and a list with components <code>errorObs</code> and <code>df_error</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffmanova">ffmanova</a></code>
</p>

<hr>
<h2 id='manova5050'>Computation of 50-50 MANOVA results</h2><span id='topic+manova5050'></span>

<h3>Description</h3>

<p>The function takes a design-with-responses object created by <code>xy_Obj</code>
and produces 50-50 MANOVA output. Results are produced for each term in the
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manova5050(xyObj, stand)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manova5050_+3A_xyobj">xyObj</code></td>
<td>
<p>design-with-responses object</p>
</td></tr>
<tr><td><code id="manova5050_+3A_stand">stand</code></td>
<td>
<p>standardisation of responses (0 or 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Classical multivariate ANOVA (MANOVA) are useless in many practical cases.
The tests perform poorly in cases with several highly correlated responses
and the method collapses when the number of responses exceeds the number of
observations. 50-50 MANOVA is made to handle this problem. Principal
component analysis (PCA) is an important part of this methodology. Each test
is based on a separate PCA.
</p>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>termNames</code></td>
<td>
<p>model term names</p>
</td></tr>
<tr><td><code>exVarSS</code></td>
<td>
<p>explained variances calculated from sums of squares summed
over all responses</p>
</td></tr> <tr><td><code>df</code></td>
<td>
<p>degrees of freedom - adjusted for other terms
in model</p>
</td></tr> <tr><td><code>df_om</code></td>
<td>
<p>degrees of freedom - adjusted for terms contained in
actual term</p>
</td></tr> <tr><td><code>nPC</code></td>
<td>
<p>number of principal components used for testing</p>
</td></tr>
<tr><td><code>nBU</code></td>
<td>
<p>number of principal components used as buffer components</p>
</td></tr>
<tr><td><code>exVarPC</code></td>
<td>
<p>variance explained by <code>nPC</code> components</p>
</td></tr>
<tr><td><code>exVarBU</code></td>
<td>
<p>variance explained by <code>(nPC+nBU)</code> components</p>
</td></tr>
<tr><td><code>pValues</code></td>
<td>
<p>50-50 MANOVA p-values</p>
</td></tr> <tr><td><code>stand</code></td>
<td>
<p>logical.  Whether the
responses are standardised.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The 50-50 MANOVA <code class="reqn">p</code>-values are based on the Hotelling-Lawley
Trace Statistic. The number of components for testing and the number of
buffer components are chosen according to default rules.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>References</h3>

<p>Langsrud, Ø. (2002) Rotation Tests. <em>The Statistician</em>,
<b>51</b>, 305&ndash;317.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffmanova">ffmanova</a></code>
</p>

<hr>
<h2 id='matlabColon'>Simulate Matlab's &lsquo;:&rsquo;</h2><span id='topic+matlabColon'></span>

<h3>Description</h3>

<p>A function to simulate Matlab's &lsquo;:&rsquo; operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matlabColon(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matlabColon_+3A_from">from</code></td>
<td>
<p>numeric.  The start value.</p>
</td></tr>
<tr><td><code id="matlabColon_+3A_to">to</code></td>
<td>
<p>numeric.  The end value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>matlabCode(a,b)</code> returns <code>a:b</code> ('s version) unless <code>a &gt; b</code>,
in which case it returns <code>integer(0)</code>.
</p>


<h3>Value</h3>

<p>A numeric vector, possibly empty.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+seq">seq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
identical(3:5, matlabColon(3, 5)) ## =&gt; TRUE
3:1 ## =&gt; 3 2 1
matlabColon(3, 1) ## =&gt; integer(0)

</code></pre>

<hr>
<h2 id='multiPvalues'>p-values from MANOVA test statistics</h2><span id='topic+multiPvalues'></span>

<h3>Description</h3>

<p><code class="reqn">p</code>-values from the four MANOVA test statistics are calculated according
to the traditional F-distribution approximations (exact in some cases).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiPvalues(D, E, A, M, dim, dimX, dimY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiPvalues_+3A_d">D</code></td>
<td>
<p>Wilks' Lambda</p>
</td></tr>
<tr><td><code id="multiPvalues_+3A_e">E</code></td>
<td>
<p>Roy's Largest Root</p>
</td></tr>
<tr><td><code id="multiPvalues_+3A_a">A</code></td>
<td>
<p>Hotelling-Lawley Trace Statistic</p>
</td></tr>
<tr><td><code id="multiPvalues_+3A_m">M</code></td>
<td>
<p>Pillay-Bartlett Trace Statistic</p>
</td></tr>
<tr><td><code id="multiPvalues_+3A_dim">dim</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="multiPvalues_+3A_dimx">dimX</code></td>
<td>
<p>Number of x-variables</p>
</td></tr>
<tr><td><code id="multiPvalues_+3A_dimy">dimY</code></td>
<td>
<p>Number of y-variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code>dim</code>, <code>dimX</code> and <code>dimY</code> corresponds to a
situation where the test statistics are calculated from two data matrices
with zero mean (test of independence).
</p>


<h3>Value</h3>

<table>
<tr><td><code>pD</code></td>
<td>
<p><code class="reqn">p</code>-value: Wilks' Lambda</p>
</td></tr> <tr><td><code>pE</code></td>
<td>
<p><code class="reqn">p</code>-value:
LOWER BOUND for Roy's Largest Root</p>
</td></tr> <tr><td><code>pA</code></td>
<td>
<p><code class="reqn">p</code>-value:
Hotelling-Lawley Trace Statistic</p>
</td></tr> <tr><td><code>pM</code></td>
<td>
<p><code class="reqn">p</code>-value: Pillay-Bartlett
Trace Statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffmanova">ffmanova</a></code>
</p>

<hr>
<h2 id='multiStatistics'>MANOVA test statistics</h2><span id='topic+multiStatistics'></span>

<h3>Description</h3>

<p>The four classical MANOVA test statistics are calculated from a set of
eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiStatistics(ss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiStatistics_+3A_ss">ss</code></td>
<td>
<p>A list of eigenvalues</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These eigenvalues are also known as the squared canonical correlation
coefficients.
</p>


<h3>Value</h3>

<p>A list with elements </p>
<table>
<tr><td><code>D</code></td>
<td>
<p>Wilks' Lambda</p>
</td></tr> <tr><td><code>E</code></td>
<td>
<p>Roy's Largest
Root</p>
</td></tr> <tr><td><code>A</code></td>
<td>
<p>Hotelling-Lawley Trace Statistic</p>
</td></tr> <tr><td><code>M</code></td>
<td>
<p>Pillay-Bartlett
Trace Statistic</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>

<hr>
<h2 id='my_pValueF'>F-test p-values</h2><span id='topic+my_pValueF'></span>

<h3>Description</h3>

<p>This is simply a wrapper around <code><a href="stats.html#topic+pf">pf</a></code>: <code>my_pValueF(f, ny1,
ny2)</code> is equivalent to <code>pf(f, ny1, ny2, lower.tail = FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my_pValueF(f, ny1, ny2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my_pValueF_+3A_f">f</code></td>
<td>
<p>The <code class="reqn">F</code> value</p>
</td></tr>
<tr><td><code id="my_pValueF_+3A_ny1">ny1</code></td>
<td>
<p>The numerator df's</p>
</td></tr>
<tr><td><code id="my_pValueF_+3A_ny2">ny2</code></td>
<td>
<p>The denominator df's</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code class="reqn">p</code>-value.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+pf">pf</a></code>
</p>

<hr>
<h2 id='myorth'>Rank and orthonormal basis</h2><span id='topic+myorth'></span><span id='topic+myrank'></span>

<h3>Description</h3>

<p><code>myorth(X)</code> makes an orthonormal basis for the space spanned by the
columns of <code>X</code>. The number of columns returned equals <code>myrank(X)</code>,
which is the rank of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myorth(X, tol_ = 1e-09)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myorth_+3A_x">X</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="myorth_+3A_tol_">tol_</code></td>
<td>
<p>tuning parameter for the rank.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculations are based on the singular value decomposition
(<code><a href="base.html#topic+svd">svd</a></code>). And <code>myrank(X)</code> is the number of singular values
of <code>X</code> that are larger than <code>max(dim(X))*svd(x)$d[1]*tol_</code>.
</p>


<h3>Value</h3>

<p><code>myorth</code> returns a matrix, whose columns form an orthonormal
basis.
</p>
<p><code>myrank</code> returns a single number, which is the rank of <code>X</code>.
</p>


<h3>Note</h3>

<p>In the special case where <code>X</code> has a single column,
<code>myorth(X)</code> returns <code>c*X</code> where <code>c</code> is a positive constant.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+svd">svd</a></code>
</p>

<hr>
<h2 id='norm'>Matrix norm.</h2><span id='topic+norm'></span>

<h3>Description</h3>

<p><code>norm(X)</code> returns the largest singular value of <code>X</code>; it is
equivalent to <code>svd(X, nu = 0, nv = 0)$d[1]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_+3A_x">X</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The largest singular value of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+svd">svd</a></code>
</p>

<hr>
<h2 id='orth_D'>Making adjusted design matrix data</h2><span id='topic+orth_D'></span>

<h3>Description</h3>

<p>The function takes the output from <code>modelData</code> as input and calculates
adjusted data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orth_D(D, model, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orth_D_+3A_d">D</code></td>
<td>
<p>A list containing a regressor matrix for each model term</p>
</td></tr>
<tr><td><code id="orth_D_+3A_model">model</code></td>
<td>
<p>The model coded as a matrix</p>
</td></tr>
<tr><td><code id="orth_D_+3A_method">method</code></td>
<td>
<p>Either <code>"test"</code> or <code>"om"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"test"</code> method adjusts data according to Type II* sums of squares.
This is an extension of the traditional Type II method. The <code>"om"</code>
method orthogonalises terms according to the model hierarchy. The result is
a non-overparameterised representation of the model.
</p>


<h3>Value</h3>

<p>An adjusted version of <code>D</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>

<hr>
<h2 id='predict.ffmanova'>Predictions, mean predictions, adjusted means and linear combinations</h2><span id='topic+predict.ffmanova'></span>

<h3>Description</h3>

<p>The same predictions as <code><a href="stats.html#topic+lm">lm</a></code> can be obtained. With some variables missing in input, 
adjusted means or mean predictions are computed (Langsrud et al., 2007). 
Linear combinations of such predictions, with standard errors, 
can also be obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ffmanova'
predict(object, newdata = NULL, linComb = NULL, nonEstimableAsNA = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ffmanova_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+ffmanova">ffmanova</a></code>.</p>
</td></tr>
<tr><td><code id="predict.ffmanova_+3A_newdata">newdata</code></td>
<td>
<p>Data frame or list. Missing values and missing variables are possible.</p>
</td></tr>
<tr><td><code id="predict.ffmanova_+3A_lincomb">linComb</code></td>
<td>
<p>A matrix defining linear combinations.</p>
</td></tr>
<tr><td><code id="predict.ffmanova_+3A_nonestimableasna">nonEstimableAsNA</code></td>
<td>
<p>When TRUE missing values are retuned when predictions cannot be made.
When FALSE predictions are made anyway, but the logical vector, <code>estimable</code>, 
is added to output in cases of non-estimable results.</p>
</td></tr>
<tr><td><code id="predict.ffmanova_+3A_...">...</code></td>
<td>
<p>further arguments (not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two matrices:
</p>
<table>
<tr><td><code>YnewPred</code></td>
<td>
<p>Predictions, mean predictions, adjusted means or linear combinations of such predictions.</p>
</td></tr>
<tr><td><code>YnewStd</code></td>
<td>
<p>Corresponding standard errors.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Langsrud, Ø., Jørgensen, K., Ofstad, R. and Næs, T. (2007):
&ldquo;Analyzing Designed Experiments with Multiple Responses&rdquo;,
<em>Journal of Applied Statistics</em>, <b>34</b>, 1275-1296.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data
x1 &lt;- 1:6
x2 &lt;- rep(c(100, 200), each = 3)
y1 &lt;- x1 + rnorm(6)/10
y2 &lt;- y1 + x2 + rnorm(6)/10

# Create ffmanova object
ff &lt;- ffmanova(cbind(y1, y2) ~ x1 + x2)

# Predictions from the input data
predict(ff)

# Rows 1 and 5 from above predictions
predict(ff, data.frame(x1 = c(1, 5), x2 = c(100, 200)))

# Rows 1 as above and row 2 different
predict(ff, data.frame(x1 = c(1, 5), x2 = 100))

# Three ways of making the same mean predictions
predict(ff, data.frame(x1 = c(1, 5), x2 = 150))
predict(ff, data.frame(x1 = c(1, 5), x2 = NA))
predict(ff, data.frame(x1 = c(1, 5)))

# Using linComb input specified to produce regression coefficients 
# with std. As produced by summary(lm(cbind(y1, y2) ~ x1 + x2))
predict(ff, data.frame(x1 = c(1, 2)), matrix(c(-1, 1), 1, 2))
predict(ff, data.frame(x2 = c(101, 102)), matrix(c(-1, 1), 1, 2))

# Above results by a 2*4 linComb matrix and with rownames
lC &lt;- t(matrix(c(-1, 1, 0, 0, 0, 0, -1, 1), 4, 2))
rownames(lC) &lt;- c("x1", "x2")
predict(ff, data.frame(x1 = c(1, 2, 1, 1), x2 = c(100, 100, 101, 102)), lC)
</code></pre>

<hr>
<h2 id='print.ffmanova'>Print method for ffmanova</h2><span id='topic+print.ffmanova'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>"ffmanova"</code>.  It prints an ANOVA
table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ffmanova'
print(x, digits = max(getOption("digits") - 3, 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ffmanova_+3A_x">x</code></td>
<td>
<p><code>"ffmanova"</code> object.  Typically created by
<code><a href="#topic+ffmanova">ffmanova</a></code>.</p>
</td></tr>
<tr><td><code id="print.ffmanova_+3A_digits">digits</code></td>
<td>
<p>positive integer.  Minimum number of significant digits to be
used for printing most numbers.</p>
</td></tr>
<tr><td><code id="print.ffmanova_+3A_...">...</code></td>
<td>
<p>further arguments sent to the underlying
<code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function constructs an anova table, and prints it using
<code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code> with tailored arguments.
</p>


<h3>Value</h3>

<p>Invisibly returns the original object.
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ffmanova">ffmanova</a></code>, <code><a href="stats.html#topic+printCoefmat">printCoefmat</a></code>
</p>

<hr>
<h2 id='rotationtests'>Rotation testing</h2><span id='topic+rotationtests'></span><span id='topic+rotationtest'></span>

<h3>Description</h3>

<p>The functions perform rotation testing based on a matrix of hypothesis
observations and a matrix of error observations. Adjusted <code class="reqn">p</code>-values
according to familywise error rates and false discovery rates are
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotationtests(xyObj, nSim, verbose = TRUE)

rotationtest(modelData, errorData, simN = 999, dfE = -1, dispsim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotationtests_+3A_xyobj">xyObj</code></td>
<td>
<p>a design-with-responses object created by <code><a href="#topic+xy_Obj">xy_Obj</a></code></p>
</td></tr>
<tr><td><code id="rotationtests_+3A_nsim">nSim</code></td>
<td>
<p>vector of nonnegative integers.  The number of simulations to
use for each term.</p>
</td></tr>
<tr><td><code id="rotationtests_+3A_verbose">verbose</code></td>
<td>
<p>logical.  Whether <code>rotationtests</code> (and
<code>rotationtest</code>) should be verbose.</p>
</td></tr>
<tr><td><code id="rotationtests_+3A_modeldata">modelData</code></td>
<td>
<p>matrix of hypothesis observations</p>
</td></tr>
<tr><td><code id="rotationtests_+3A_errordata">errorData</code></td>
<td>
<p>matrix of error observations</p>
</td></tr>
<tr><td><code id="rotationtests_+3A_simn">simN</code></td>
<td>
<p>Number of simulations for each test. Can be a single value or a
list of values for each term.</p>
</td></tr>
<tr><td><code id="rotationtests_+3A_dfe">dfE</code></td>
<td>
<p>Degrees of freedom for error needs to be specified if
<code>errorData</code> is incomplete</p>
</td></tr>
<tr><td><code id="rotationtests_+3A_dispsim">dispsim</code></td>
<td>
<p>When <code>TRUE</code>, dots are displayed to illustrate simulation
progress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modelData</code> and <code>errorObs</code> correspond to <code>hypObs</code> and
<code>errorObs</code> calculated by <code>xy_Obj</code>. These matrices are efficient
representations of sums of squares and cross-products (see
<code><a href="#topic+xy_Obj">xy_Obj</a></code> for details). This means that <code>rotationtest</code> can
be viewed as a generalised <code class="reqn">F</code>-test function.
</p>
<p><code>rotationtests</code> is a wrapper function that calls <code>rotationtest</code>
for each term in the <code>xyObj</code> and collects the results.
</p>


<h3>Value</h3>

<p>Both functions return a list with components
</p>
<table>
<tr><td><code>pAdjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values according to familywise error
rates</p>
</td></tr> <tr><td><code>pAdjFDR</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values according to false discovery
rates</p>
</td></tr> <tr><td><code>simN</code></td>
<td>
<p>number of simulations performed for each term</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>References</h3>

<p>Langsrud, Ø. (2005) Rotation Tests. <em>Statistics and
Computing</em>, <b>15</b>, 53&ndash;60.
</p>
<p>Moen, B., Oust, A., Langsrud, Ø., Dorrell, N., Gemma, L., Marsden, G.L.,
Hinds, J., Kohler, A., Wren, B.W. and Rudi, K. (2005) An explorative
multifactor approach for investigating global survival mechanisms of
Campylobacter jejuni under environmental conditions.  <em>Applied and
Environmental Microbiology</em>, <b>71</b>, 2086-2094.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitest">unitest</a></code>, <code><a href="#topic+unitests">unitests</a></code>
</p>

<hr>
<h2 id='stdize'>Centering and scaling of matrices</h2><span id='topic+stdize'></span><span id='topic+stdize3'></span>

<h3>Description</h3>

<p>Function to center and/or scale the coloumns of a matrix in various ways.
The coloumns can be centered with their means or with supplied values, and
they can be scaled with their standard deviations or with supplied values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stdize(x, center = TRUE, scale = TRUE, avoid.zero.divisor = FALSE)

stdize3(x, center = TRUE, scale = TRUE, avoid.zero.divisor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stdize_+3A_x">x</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="stdize_+3A_center">center</code></td>
<td>
<p>A logical, or a numeric vector.  The values to subtract from
each column. If <code>center</code> is <code>TRUE</code>, the mean values are used.</p>
</td></tr>
<tr><td><code id="stdize_+3A_scale">scale</code></td>
<td>
<p>A lgical, or a numeric vector.  The values to divide each
column with.  If <code>scale</code> is <code>TRUE</code>, the standard deviations are
used.</p>
</td></tr>
<tr><td><code id="stdize_+3A_avoid.zero.divisor">avoid.zero.divisor</code></td>
<td>
<p>A logical.  If <code>TRUE</code>, each occurence of
<code class="reqn">0</code> in <code>scale</code> is replaced with a <code class="reqn">1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stdize</code> standardizes the coloumns of a matrix by subtracting their
means (or the supplied values) and dividing by their standard deviations (or
the supplied values).
</p>
<p>If <code>avoid.zero.divisor</code> is <code>TRUE</code>, division-by-zero is guarded
against by substituting any <code class="reqn">0</code> in <code>center</code> (either calculated or
supplied) with <code class="reqn">1</code> prior to division.
</p>
<p>The main difference between <code>stdize</code> and <code><a href="base.html#topic+scale">scale</a></code> is that
<code>stdize</code> divides by the standard deviations even when <code>center</code> is
not <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Note</h3>

<p><code>stdize3</code> is a variant with a three-element list as output (<code>x, center, scale</code>) and where <code>avoid.zero.divisor</code> 
is also used to avoid centring (constant term in model matrix is unchanged).
</p>


<h3>Author(s)</h3>

<p>Bjørn-Helge Mevik and Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- matrix(rnorm(15, mean = 1), ncol = 3)
stopifnot(all.equal(stdize(A), scale(A), check.attributes = FALSE))

## These are different:
stdize(A, center = FALSE)
scale(A, center = FALSE)

</code></pre>

<hr>
<h2 id='unitests'>Univariate F or t testing</h2><span id='topic+unitests'></span><span id='topic+unitest'></span>

<h3>Description</h3>

<p>The functions perform <code class="reqn">F</code> or <code class="reqn">t</code> testing for several responses based
on a matrix of hypothesis observations and a matrix of error observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitests(xyObj)

unitest(modelData, errorData, dfError = dim(errorData)[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitests_+3A_xyobj">xyObj</code></td>
<td>
<p>a design-with-responses object created by <code><a href="#topic+xy_Obj">xy_Obj</a></code></p>
</td></tr>
<tr><td><code id="unitests_+3A_modeldata">modelData</code></td>
<td>
<p>matrix of hypothesis observations</p>
</td></tr>
<tr><td><code id="unitests_+3A_errordata">errorData</code></td>
<td>
<p>matrix of error observations</p>
</td></tr>
<tr><td><code id="unitests_+3A_dferror">dfError</code></td>
<td>
<p>Degrees of freedom for error needs to be specified if
<code>errorData</code> is incomplete</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>modelData</code> and <code>errorObs</code> correspond to <code>hypObs</code> and
<code>errorObs</code> calculated by <code>xy_Obj</code>. These matrices are efficient
representations of sums of squares and cross-products (see
<code><a href="#topic+xy_Obj">xy_Obj</a></code> for details).  This means the univariate
<code class="reqn">F</code>-statistics can be calculated straightforwardly from these input
matrices. Furthermore, in the single-degree-of-freedom case,
<code class="reqn">t</code>-statistics with correct sign can be obtained.
</p>
<p><code>unitests</code> is a wrapper function that calls <code>unitest</code> for each
term in the <code>xyObj</code> (see <code><a href="#topic+xy_Obj">xy_Obj</a></code> for details) and collects
the results.
</p>


<h3>Value</h3>

<p><code>unitest</code> returns a list with components
</p>
<table>
<tr><td><code>pValues</code></td>
<td>
<p><code class="reqn">p</code>-values</p>
</td></tr> <tr><td><code>stat</code></td>
<td>
<p>The test statistics as
<code class="reqn">t</code>-statistics (when single degree of freedom) or <code class="reqn">F</code>-statistics </p>
</td></tr>
</table>
<p><code>unitests</code> returns a list with components </p>
<table>
<tr><td><code>pRaw</code></td>
<td>
<p>Matrix of
<code class="reqn">p</code>-values from <code>unitest</code>, one row for each term.</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>Matrix of test statistics from <code>unitest</code>, one row for each
term.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function calculates the <code class="reqn">p</code>-values by making a call to
<code>pf</code>.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rotationtest">rotationtest</a></code>, <code><a href="#topic+rotationtests">rotationtests</a></code>
</p>

<hr>
<h2 id='x_Obj'>Creation of a design matrix object</h2><span id='topic+x_Obj'></span>

<h3>Description</h3>

<p>The function takes design/model information as input and performs initial
computations for prediction and testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x_Obj(D, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_Obj_+3A_d">D</code></td>
<td>
<p>A list containing a regressor matrix for each model term</p>
</td></tr>
<tr><td><code id="x_Obj_+3A_model">model</code></td>
<td>
<p>The model coded as a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the source code of <code>ffmanova</code> to see how <code>D</code> and <code>model</code>
are created.
</p>


<h3>Value</h3>

<table>
<tr><td><code>df_error</code></td>
<td>
<p>degrees of freedom for error</p>
</td></tr> <tr><td><code>D</code></td>
<td>
<p>same as
input</p>
</td></tr> <tr><td><code>D_test</code></td>
<td>
<p>as <code>D</code>, but with Type II* adjusted model terms.
Will be used for testing.</p>
</td></tr> <tr><td><code>D_om</code></td>
<td>
<p>as <code>D</code>, but with OM-adjusted
model terms. This is a non-overparameterised representation of the model.
Will be used for prediction.</p>
</td></tr> <tr><td><code>df_D_om</code></td>
<td>
<p>degrees of freedom according to
<code>D_om</code></p>
</td></tr> <tr><td><code>df_D_test</code></td>
<td>
<p>degrees of freedom according to <code>D_test</code></p>
</td></tr>
<tr><td><code>Beta_D</code></td>
<td>
<p>output from <code>linregEst</code> where <code>D_om</code> is response and
where <code>D</code> is regressor</p>
</td></tr> <tr><td><code>VmodelDivS_D</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code>VextraDivS1_D</code></td>
<td>
<p>as above</p>
</td></tr> <tr><td><code>Umodel</code></td>
<td>
<p>output from <code>linregStart</code>
where <code>D_om</code> is regressor</p>
</td></tr> <tr><td><code>VmodelDivS</code></td>
<td>
<p>as above</p>
</td></tr>
<tr><td><code>VextraDivS1</code></td>
<td>
<p>as above</p>
</td></tr> <tr><td><code>termNames</code></td>
<td>
<p>model term names</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linregEst">linregEst</a></code>, <code><a href="#topic+xy_Obj">xy_Obj</a></code>.
</p>

<hr>
<h2 id='xy_Obj'>Creation of a design-with-responses object</h2><span id='topic+xy_Obj'></span><span id='topic+ffModelObj'></span>

<h3>Description</h3>

<p>The function takes an object created by <code>x_Obj</code> as input and add
response values. Further initial computations for prediction and testing is
made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xy_Obj(xObj, Y)

ffModelObj(
  xObj,
  Y,
  modelMatrix,
  modelTerms,
  model,
  xlev,
  scaleY,
  scaleX,
  centerX,
  isIntercept,
  returnY = FALSE,
  returnYhat = FALSE,
  returnYhatStd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xy_Obj_+3A_xobj">xObj</code></td>
<td>
<p>object created by <code><a href="#topic+x_Obj">x_Obj</a></code></p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_y">Y</code></td>
<td>
<p>response matrix</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_modelmatrix">modelMatrix</code></td>
<td>
<p>Model matrix (output from <code>model.matrix</code>) to be included in output.</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_modelterms">modelTerms</code></td>
<td>
<p>Model terms (model frame attribute) to be included in output.</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_scaley">scaleY</code></td>
<td>
<p>Values used to scale Y (see <code><a href="#topic+stdize">stdize</a></code>) to be included in output.</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_scalex">scaleX</code></td>
<td>
<p>Values used to scale the model matrix (see <code><a href="#topic+stdize">stdize</a></code>) to be included in output.</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_centerx">centerX</code></td>
<td>
<p>Values used to center the model matrix (see <code><a href="#topic+stdize">stdize</a></code>) to be included in output.</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_isintercept">isIntercept</code></td>
<td>
<p>A logical (whether model has intercept) to be included in output.</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_returny">returnY</code></td>
<td>
<p>Matrix <code>Y</code> (as input) in output when TRUE.</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_returnyhat">returnYhat</code></td>
<td>
<p>Matrix <code>Yhat</code> of fitted values corresponding to <code>Y</code> in output when TRUE.</p>
</td></tr>
<tr><td><code id="xy_Obj_+3A_returnyhatstd">returnYhatStd</code></td>
<td>
<p>Standard errors, <code>YhatStd</code>, in output when TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Traditionally, sums of squares and cross-products (SSC) is the multivariate
generalisation of sums of squares. When there is a large number of responses
this representation is inefficient and therefore linear combinations of
observations (Langsrud, 2002) is stored instead, such as <code>errorObs</code>.
The corresponding SSC matrix can be obtained by
<code>t(errorObs)%*%errorObs</code>. When there is a large number of observations
the errorObs representation is also inefficient, but it these cases it is
possible to chose a representation with several zero rows. Then, errorObs is
stored as a two-component list: A matrix containing the nonzero rows of
errorObs and an integer representing the degrees of freedom for error
(number of rows in the full errorObs matrix).
</p>


<h3>Value</h3>

<p>A list with components </p>
<table>
<tr><td><code>xObj</code></td>
<td>
<p>same as input</p>
</td></tr> <tr><td><code>Y</code></td>
<td>
<p>same as
input</p>
</td></tr> <tr><td><code>ssTotFull</code></td>
<td>
<p>equals <code>sum(Y^2)</code></p>
</td></tr> <tr><td><code>ssTot</code></td>
<td>
<p>equals
<code>sum((center(Y))^2)</code>. That is, the total sum of squares summed over all
responses.</p>
</td></tr> <tr><td><code>ss</code></td>
<td>
<p>Sums of squares summed over all responses.</p>
</td></tr>
<tr><td><code>Beta</code></td>
<td>
<p>Output from <code>linregEst</code> where <code>xObj$D_om</code> is the
regressor matrix.</p>
</td></tr> <tr><td><code>Yhat</code></td>
<td>
<p>fitted values</p>
</td></tr> <tr><td><code>YhatStd</code></td>
<td>
<p>standard
deviations of fitted values</p>
</td></tr> <tr><td><code>msError</code></td>
<td>
<p>mean square error of each
response</p>
</td></tr> <tr><td><code>errorObs</code></td>
<td>
<p>Error observations that can be used in
multivariate testing</p>
</td></tr> <tr><td><code>hypObs</code></td>
<td>
<p>Hypothesis observations that can be used
in multivariate testing</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>ffModelObj</code> is a rewrite of <code>xy_Obj</code> with additional elements in output corresponding 
to the additional parameters in input. Furthermore, <code>Y</code> and <code>YhatStd</code> is by default not included in output.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Bjørn-Helge Mevik
</p>


<h3>References</h3>

<p>Langsrud, Ø. (2002) 50-50 Multivariate Analysis of Variance for
Collinear Responses.  <em>The Statistician</em>, <b>51</b>, 305&ndash;317.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
