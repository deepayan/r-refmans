<!DOCTYPE html><html><head><title>Help for package NNS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NNS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NNS'><p>NNS: Nonlinear Nonparametric Statistics</p></a></li>
<li><a href='#Co.LPM'><p>Co-Lower Partial Moment</p>
(Lower Left Quadrant 4)</a></li>
<li><a href='#Co.UPM'><p>Co-Upper Partial Moment</p>
(Upper Right Quadrant 1)</a></li>
<li><a href='#D.LPM'><p>Divergent-Lower Partial Moment</p>
(Lower Right Quadrant 3)</a></li>
<li><a href='#D.UPM'><p>Divergent-Upper Partial Moment</p>
(Upper Left Quadrant 2)</a></li>
<li><a href='#dy.d_'><p>Partial Derivative dy/d_[wrt]</p></a></li>
<li><a href='#dy.dx'><p>Partial Derivative dy/dx</p></a></li>
<li><a href='#LPM'><p>Lower Partial Moment</p></a></li>
<li><a href='#LPM.ratio'><p>Lower Partial Moment RATIO</p></a></li>
<li><a href='#LPM.VaR'><p>LPM VaR</p></a></li>
<li><a href='#NNS_bin'><p>Fast binning of numeric vector into equidistant bins</p></a></li>
<li><a href='#NNS.ANOVA'><p>NNS ANOVA</p></a></li>
<li><a href='#NNS.ARMA'><p>NNS ARMA</p></a></li>
<li><a href='#NNS.ARMA.optim'><p>NNS ARMA Optimizer</p></a></li>
<li><a href='#NNS.boost'><p>NNS Boost</p></a></li>
<li><a href='#NNS.caus'><p>NNS Causation</p></a></li>
<li><a href='#NNS.CDF'><p>NNS CDF</p></a></li>
<li><a href='#NNS.copula'><p>NNS Co-Partial Moments Higher Dimension Dependence</p></a></li>
<li><a href='#NNS.dep'><p>NNS Dependence</p></a></li>
<li><a href='#NNS.diff'><p>NNS Numerical Differentiation</p></a></li>
<li><a href='#NNS.distance'><p>NNS Distance</p></a></li>
<li><a href='#NNS.FSD'><p>NNS FSD Test</p></a></li>
<li><a href='#NNS.FSD.uni'><p>NNS FSD Test uni-directional</p></a></li>
<li><a href='#NNS.gravity'><p>NNS gravity</p></a></li>
<li><a href='#NNS.MC'><p>NNS Monte Carlo Sampling</p></a></li>
<li><a href='#NNS.meboot'><p>NNS meboot</p></a></li>
<li><a href='#NNS.mode'><p>NNS mode</p></a></li>
<li><a href='#NNS.moments'><p>NNS moments</p></a></li>
<li><a href='#NNS.norm'><p>NNS Normalization</p></a></li>
<li><a href='#NNS.nowcast'><p>NNS Nowcast</p></a></li>
<li><a href='#NNS.part'><p>NNS Partition Map</p></a></li>
<li><a href='#NNS.reg'><p>NNS Regression</p></a></li>
<li><a href='#NNS.rescale'><p>NNS rescale</p></a></li>
<li><a href='#NNS.SD.efficient.set'><p>NNS SD Efficient Set</p></a></li>
<li><a href='#NNS.seas'><p>NNS Seasonality Test</p></a></li>
<li><a href='#NNS.SSD'><p>NNS SSD Test</p></a></li>
<li><a href='#NNS.SSD.uni'><p>NNS SSD Test uni-directional</p></a></li>
<li><a href='#NNS.stack'><p>NNS Stack</p></a></li>
<li><a href='#NNS.term.matrix'><p>NNS Term Matrix</p></a></li>
<li><a href='#NNS.TSD'><p>NNS TSD Test</p></a></li>
<li><a href='#NNS.TSD.uni'><p>NNS TSD Test uni-directional</p></a></li>
<li><a href='#NNS.VAR'><p>NNS VAR</p></a></li>
<li><a href='#PM.matrix'><p>Partial Moment Matrix</p></a></li>
<li><a href='#UPM'><p>Upper Partial Moment</p></a></li>
<li><a href='#UPM.ratio'><p>Upper Partial Moment RATIO</p></a></li>
<li><a href='#UPM.VaR'><p>UPM VaR</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonlinear Nonparametric Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>10.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fred Viole &lt;ovvo.financial.systems@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Nonlinear nonparametric statistics using partial moments.  Partial moments are the elements of variance and asymptotically approximate the area of f(x).  These robust statistics provide the basis for nonlinear analysis while retaining linear equivalences.  NNS offers: Numerical integration, Numerical differentiation, Clustering, Correlation, Dependence, Causal analysis, ANOVA, Regression, Classification, Seasonality, Autoregressive modeling, Normalization, Stochastic dominance and Advanced Monte Carlo sampling.  All routines based on: Viole, F. and Nawrocki, D. (2013), Nonlinear Nonparametric Statistics: Using Partial Moments (ISBN: 1490523995).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OVVO-Financial/NNS/issues">https://github.com/OVVO-Financial/NNS/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), doParallel</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, data.table, foreach, meboot, quantmod, Rcpp,
RcppParallel, Rfast, rgl, stringr, xts, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-06 05:19:07 UTC; fredv</td>
</tr>
<tr>
<td>Author:</td>
<td>Fred Viole [aut, cre],
  Roberto Spadim [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 00:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='NNS'>NNS: Nonlinear Nonparametric Statistics</h2><span id='topic+NNS'></span><span id='topic+_PACKAGE'></span><span id='topic+NNS-package'></span>

<h3>Description</h3>

<p>Nonlinear nonparametric statistics using partial moments.  Partial moments are the elements of variance and asymptotically approximate the area of f(x).  These robust statistics provide the basis for nonlinear analysis while retaining linear equivalences.  NNS offers: Numerical integration, Numerical differentiation, Clustering, Correlation, Dependence, Causal analysis, ANOVA, Regression, Classification, Seasonality, Autoregressive modeling, Normalization and Stochastic dominance.  All routines based on: Viole, F. and Nawrocki, D. (2013), Nonlinear Nonparametric Statistics: Using Partial Moments (ISBN: 1490523995).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Fred Viole <a href="mailto:ovvo.financial.systems@gmail.com">ovvo.financial.systems@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Roberto Spadim [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/OVVO-Financial/NNS/issues">https://github.com/OVVO-Financial/NNS/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Co.LPM'>Co-Lower Partial Moment
(Lower Left Quadrant 4)</h2><span id='topic+Co.LPM'></span>

<h3>Description</h3>

<p>This function generates a co-lower partial moment for between two equal length variables for any degree or target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Co.LPM(degree_lpm, x, y, target_x, target_y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Co.LPM_+3A_degree_lpm">degree_lpm</code></td>
<td>
<p>integer; Degree for lower deviations of both variable X and Y.  <code>(degree_lpm = 0)</code> is frequency, <code>(degree_lpm = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="Co.LPM_+3A_x">x</code></td>
<td>
<p>a numeric vector.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
<tr><td><code id="Co.LPM_+3A_y">y</code></td>
<td>
<p>a numeric vector of equal length to <code>x</code>.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
<tr><td><code id="Co.LPM_+3A_target_x">target_x</code></td>
<td>
<p>numeric; Target for lower deviations of variable X.  Typically the mean of Variable X for classical statistics equivalences, but does not have to be.</p>
</td></tr>
<tr><td><code id="Co.LPM_+3A_target_y">target_y</code></td>
<td>
<p>numeric; Target for lower deviations of variable Y.  Typically the mean of Variable Y for classical statistics equivalences, but does not have to be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Co-LPM of two variables
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
Co.LPM(0, x, y, mean(x), mean(y))
</code></pre>

<hr>
<h2 id='Co.UPM'>Co-Upper Partial Moment
(Upper Right Quadrant 1)</h2><span id='topic+Co.UPM'></span>

<h3>Description</h3>

<p>This function generates a co-upper partial moment between two equal length variables for any degree or target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Co.UPM(degree_upm, x, y, target_x, target_y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Co.UPM_+3A_degree_upm">degree_upm</code></td>
<td>
<p>integer; Degree for upper variations of both variable X and Y.  <code>(degree_upm = 0)</code> is frequency, <code>(degree_upm = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="Co.UPM_+3A_x">x</code></td>
<td>
<p>a numeric vector.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
<tr><td><code id="Co.UPM_+3A_y">y</code></td>
<td>
<p>a numeric vector of equal length to <code>x</code>.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
<tr><td><code id="Co.UPM_+3A_target_x">target_x</code></td>
<td>
<p>numeric; Target for upside deviations of variable X.  Typically the mean of Variable X for classical statistics equivalences, but does not have to be.</p>
</td></tr>
<tr><td><code id="Co.UPM_+3A_target_y">target_y</code></td>
<td>
<p>numeric; Target for upside deviations of variable Y.  Typically the mean of Variable Y for classical statistics equivalences, but does not have to be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Co-UPM of two variables
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
Co.UPM(0, x, y, mean(x), mean(y))
</code></pre>

<hr>
<h2 id='D.LPM'>Divergent-Lower Partial Moment
(Lower Right Quadrant 3)</h2><span id='topic+D.LPM'></span>

<h3>Description</h3>

<p>This function generates a divergent lower partial moment between two equal length variables for any degree or target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D.LPM(degree_lpm, degree_upm, x, y, target_x, target_y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D.LPM_+3A_degree_lpm">degree_lpm</code></td>
<td>
<p>integer; Degree for lower deviations of variable Y.  <code>(degree_lpm = 0)</code> is frequency, <code>(degree_lpm = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="D.LPM_+3A_degree_upm">degree_upm</code></td>
<td>
<p>integer; Degree for upper deviations of variable X.  <code>(degree_upm = 0)</code> is frequency, <code>(degree_upm = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="D.LPM_+3A_x">x</code></td>
<td>
<p>a numeric vector.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
<tr><td><code id="D.LPM_+3A_y">y</code></td>
<td>
<p>a numeric vector of equal length to <code>x</code>.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
<tr><td><code id="D.LPM_+3A_target_x">target_x</code></td>
<td>
<p>numeric; Target for upside deviations of variable X.  Typically the mean of Variable X for classical statistics equivalences, but does not have to be.</p>
</td></tr>
<tr><td><code id="D.LPM_+3A_target_y">target_y</code></td>
<td>
<p>numeric; Target for lower deviations of variable Y.  Typically the mean of Variable Y for classical statistics equivalences, but does not have to be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Divergent LPM of two variables
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
D.LPM(0, 0, x, y, mean(x), mean(y))
</code></pre>

<hr>
<h2 id='D.UPM'>Divergent-Upper Partial Moment
(Upper Left Quadrant 2)</h2><span id='topic+D.UPM'></span>

<h3>Description</h3>

<p>This function generates a divergent upper partial moment between two equal length variables for any degree or target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D.UPM(degree_lpm, degree_upm, x, y, target_x, target_y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D.UPM_+3A_degree_lpm">degree_lpm</code></td>
<td>
<p>integer; Degree for lower deviations of variable X.  <code>(degree_lpm = 0)</code> is frequency, <code>(degree_lpm = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="D.UPM_+3A_degree_upm">degree_upm</code></td>
<td>
<p>integer; Degree for upper deviations of variable Y.  <code>(degree_upm = 0)</code> is frequency, <code>(degree_upm = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="D.UPM_+3A_x">x</code></td>
<td>
<p>a numeric vector.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
<tr><td><code id="D.UPM_+3A_y">y</code></td>
<td>
<p>a numeric vector of equal length to <code>x</code>.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
<tr><td><code id="D.UPM_+3A_target_x">target_x</code></td>
<td>
<p>numeric; Target for lower deviations of variable X.  Typically the mean of Variable X for classical statistics equivalences, but does not have to be.</p>
</td></tr>
<tr><td><code id="D.UPM_+3A_target_y">target_y</code></td>
<td>
<p>numeric; Target for upper deviations of variable Y.  Typically the mean of Variable Y for classical statistics equivalences, but does not have to be.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Divergent UPM of two variables
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
D.UPM(0, 0, x, y, mean(x), mean(y))
</code></pre>

<hr>
<h2 id='dy.d_'>Partial Derivative dy/d_[wrt]</h2><span id='topic+dy.d_'></span>

<h3>Description</h3>

<p>Returns the numerical partial derivative of <code>y</code> with respect to [wrt] any regressor for a point of interest.  Finite difference method is used with <a href="#topic+NNS.reg">NNS.reg</a> estimates as <code>f(x + h)</code> and <code>f(x - h)</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dy.d_(x, y, wrt, eval.points = "obs", mixed = FALSE, messages = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dy.d__+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="dy.d__+3A_y">y</code></td>
<td>
<p>a numeric vector with compatible dimensions to <code>x</code>.</p>
</td></tr>
<tr><td><code id="dy.d__+3A_wrt">wrt</code></td>
<td>
<p>integer; Selects the regressor to differentiate with respect to (vectorized).</p>
</td></tr>
<tr><td><code id="dy.d__+3A_eval.points">eval.points</code></td>
<td>
<p>numeric or options: (&quot;obs&quot;, &quot;apd&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;last&quot;); Regressor points to be evaluated.
</p>

<ul>
<li><p> Numeric values must be in matrix or data.frame form to be evaluated for each regressor, otherwise, a vector of points will evaluate only at the <code>wrt</code> regressor.  See examples for use cases.
</p>
</li>
<li><p> Set to <code>(eval.points = "obs")</code> (default) to find the average partial derivative at every observation of the variable with respect to <em>for specific tuples of given observations.</em>
</p>
</li>
<li><p> Set to <code>(eval.points = "apd")</code> to find the average partial derivative at every observation of the variable with respect to <em>over the entire distribution of other regressors.</em>
</p>
</li>
<li><p> Set to <code>(eval.points = "mean")</code> to find the partial derivative at the mean of value of every variable.
</p>
</li>
<li><p> Set to <code>(eval.points = "median")</code> to find the partial derivative at the median value of every variable.
</p>
</li>
<li><p> Set to <code>(eval.points = "last")</code> to find the partial derivative at the last observation of every value (relevant for time-series data).
</p>
</li></ul>
</td></tr>
<tr><td><code id="dy.d__+3A_mixed">mixed</code></td>
<td>
<p>logical; <code>FALSE</code> (default) If mixed derivative is to be evaluated, set <code>(mixed = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="dy.d__+3A_messages">messages</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Prints status messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns column-wise matrix of wrt regressors:
</p>

<ul>
<li><p><code>dy.d_(...)[, wrt]$First</code> the 1st derivative
</p>
</li>
<li><p><code>dy.d_(...)[, wrt]$Second</code> the 2nd derivative
</p>
</li>
<li><p><code>dy.d_(...)[, wrt]$Mixed</code> the mixed derivative (for two independent variables only).
</p>
</li></ul>



<h3>Note</h3>

<p>For binary regressors, it is suggested to use <code>eval.points = seq(0, 1, .05)</code> for a better resolution around the midpoint.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Vinod, H. and Viole, F. (2020) &quot;Comparing Old and New Partial Derivative Estimates from Nonlinear Nonparametric Regressions&quot;
<a href="https://www.ssrn.com/abstract=3681104">https://www.ssrn.com/abstract=3681104</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123) ; x_1 &lt;- runif(1000) ; x_2 &lt;- runif(1000) ; y &lt;- x_1 ^ 2 * x_2 ^ 2
B &lt;- cbind(x_1, x_2)

## To find derivatives of y wrt 1st regressor for specific points of both regressors
dy.d_(B, y, wrt = 1, eval.points = t(c(.5, 1)))

## To find average partial derivative of y wrt 1st regressor,
only supply 1 value in [eval.points], or a vector of [eval.points]:
dy.d_(B, y, wrt = 1, eval.points = .5)

dy.d_(B, y, wrt = 1, eval.points = fivenum(B[,1]))


## To find average partial derivative of y wrt 1st regressor,
for every observation of 1st regressor:
apd &lt;- dy.d_(B, y, wrt = 1, eval.points = "apd")
plot(B[,1], apd[,1]$First)

## 95% Confidence Interval to test if 0 is within
### Lower CI
LPM.VaR(.025, 0, apd[,1]$First)

### Upper CI
UPM.VaR(.025, 0, apd[,1]$First)

## End(Not run)
</code></pre>

<hr>
<h2 id='dy.dx'>Partial Derivative dy/dx</h2><span id='topic+dy.dx'></span>

<h3>Description</h3>

<p>Returns the numerical partial derivative of <code>y</code> wrt <code>x</code> for a point of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dy.dx(x, y, eval.point = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dy.dx_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="dy.dx_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="dy.dx_+3A_eval.point">eval.point</code></td>
<td>
<p>numeric or (&quot;overall&quot;); <code>x</code> point to be evaluated, must be provided.  Defaults to <code>(eval.point = NULL)</code>.  Set to <code>(eval.point = "overall")</code> to find an overall partial derivative estimate (1st derivative only).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.table</code> of eval.point along with both 1st and 2nd derivative.
</p>


<h3>Note</h3>

<p>If a vector of derivatives is required, ensure <code>(deriv.method = "FD")</code>.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Vinod, H. and Viole, F. (2017) &quot;Nonparametric Regression Using Clusters&quot;
<a href="https://link.springer.com/article/10.1007/s10614-017-9713-5">https://link.springer.com/article/10.1007/s10614-017-9713-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- seq(0, 2 * pi, pi / 100) ; y &lt;- sin(x)
dy.dx(x, y, eval.point = 1.75)

# First derivative
dy.dx(x, y, eval.point = 1.75)[ , first.derivative]

# Second derivative
dy.dx(x, y, eval.point = 1.75)[ , second.derivative]

# Vector of derivatives
dy.dx(x, y, eval.point = c(1.75, 2.5))

## End(Not run)
</code></pre>

<hr>
<h2 id='LPM'>Lower Partial Moment</h2><span id='topic+LPM'></span>

<h3>Description</h3>

<p>This function generates a univariate lower partial moment for any degree or target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPM(degree, target, variable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPM_+3A_degree">degree</code></td>
<td>
<p>integer; <code>(degree = 0)</code> is frequency, <code>(degree = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="LPM_+3A_target">target</code></td>
<td>
<p>numeric; Typically set to mean, but does not have to be. (Vectorized)</p>
</td></tr>
<tr><td><code id="LPM_+3A_variable">variable</code></td>
<td>
<p>a numeric vector.  <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LPM of variable
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100)
LPM(0, mean(x), x)
</code></pre>

<hr>
<h2 id='LPM.ratio'>Lower Partial Moment RATIO</h2><span id='topic+LPM.ratio'></span>

<h3>Description</h3>

<p>This function generates a standardized univariate lower partial moment for any degree or target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPM.ratio(degree, target, variable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPM.ratio_+3A_degree">degree</code></td>
<td>
<p>integer; <code>(degree = 0)</code> is frequency, <code>(degree = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="LPM.ratio_+3A_target">target</code></td>
<td>
<p>numeric; Typically set to mean, but does not have to be. (Vectorized)</p>
</td></tr>
<tr><td><code id="LPM.ratio_+3A_variable">variable</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standardized LPM of variable
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Viole, F. (2017) &quot;Continuous CDFs and ANOVA with NNS&quot;
<a href="https://www.ssrn.com/abstract=3007373">https://www.ssrn.com/abstract=3007373</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100)
LPM.ratio(0, mean(x), x)

## Not run: 
## Empirical CDF (degree = 0)
lpm_cdf &lt;- LPM.ratio(0, sort(x), x)
plot(sort(x), lpm_cdf)

## Continuous CDF (degree = 1)
lpm_cdf_1 &lt;- LPM.ratio(1, sort(x), x)
plot(sort(x), lpm_cdf_1)

## Joint CDF
x &lt;- rnorm(5000) ; y &lt;- rnorm(5000)
plot3d(x, y, Co.LPM(0, sort(x), sort(y), x, y), col = "blue", xlab = "X", ylab = "Y",
zlab = "Probability", box = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='LPM.VaR'>LPM VaR</h2><span id='topic+LPM.VaR'></span>

<h3>Description</h3>

<p>Generates a value at risk (VaR) quantile based on the Lower Partial Moment ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LPM.VaR(percentile, degree, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LPM.VaR_+3A_percentile">percentile</code></td>
<td>
<p>numeric [0, 1]; The percentile for left-tail VaR (vectorized).</p>
</td></tr>
<tr><td><code id="LPM.VaR_+3A_degree">degree</code></td>
<td>
<p>integer; <code>(degree = 0)</code> for discrete distributions, <code>(degree = 1)</code> for continuous distributions.</p>
</td></tr>
<tr><td><code id="LPM.VaR_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value representing the point at which <code>"percentile"</code> of the area of <code>x</code> is below.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100)

## For 5th percentile, left-tail
LPM.VaR(0.05, 0, x)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS_bin'>Fast binning of numeric vector into equidistant bins</h2><span id='topic+NNS_bin'></span>

<h3>Description</h3>

<p>Missing values (NA, Inf, NaN) are added at the end of the vector as the last bin returned if missinglast is set to TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS_bin(x, width, origin = 0, missinglast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS_bin_+3A_x">x</code></td>
<td>
<p>A matrix of regressor variables. Must have the same number of rows as the length of y.</p>
</td></tr>
<tr><td><code id="NNS_bin_+3A_width">width</code></td>
<td>
<p>The width of the bins</p>
</td></tr>
<tr><td><code id="NNS_bin_+3A_origin">origin</code></td>
<td>
<p>The starting point for the bins. Any number smaller than origin will be disregarded</p>
</td></tr>
<tr><td><code id="NNS_bin_+3A_missinglast">missinglast</code></td>
<td>
<p>Boolean. Should the missing observations be added as a separate element at the end of the returned count vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list with elements counts (the frequencies), origin (the origin), width (the width), missing (the number of missings), and last_bin_is_missing (boolean) telling whether the missinglast is true or not.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1)
x &lt;- sample(10, 20, replace = TRUE)
NNS_bin(x, 15)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.ANOVA'>NNS ANOVA</h2><span id='topic+NNS.ANOVA'></span>

<h3>Description</h3>

<p>Analysis of variance (ANOVA) based on lower partial moment CDFs for multiple variables, evaluated at multiple quantiles (or means only).  Returns a degree of certainty to whether the population distributions (or sample means) are identical, not a p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.ANOVA(
  control,
  treatment,
  means.only = FALSE,
  confidence.interval = 0.95,
  tails = "Both",
  pairwise = FALSE,
  plot = TRUE,
  robust = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.ANOVA_+3A_control">control</code></td>
<td>
<p>a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="NNS.ANOVA_+3A_treatment">treatment</code></td>
<td>
<p><code>NULL</code> (default) a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="NNS.ANOVA_+3A_means.only">means.only</code></td>
<td>
<p>logical; <code>FALSE</code> (default) test whether difference in sample means only is zero.</p>
</td></tr>
<tr><td><code id="NNS.ANOVA_+3A_confidence.interval">confidence.interval</code></td>
<td>
<p>numeric [0, 1]; The confidence interval surrounding the <code>control</code> mean, defaults to <code>(confidence.interval = 0.95)</code>.</p>
</td></tr>
<tr><td><code id="NNS.ANOVA_+3A_tails">tails</code></td>
<td>
<p>options: (&quot;Left&quot;, &quot;Right&quot;, &quot;Both&quot;).  <code>tails = "Both"</code>(Default) Selects the tail of the distribution to determine effect size.</p>
</td></tr>
<tr><td><code id="NNS.ANOVA_+3A_pairwise">pairwise</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Returns pairwise certainty tests when set to <code>pairwise = TRUE</code>.</p>
</td></tr>
<tr><td><code id="NNS.ANOVA_+3A_plot">plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Returns the boxplot of all variables along with grand mean identification and confidence interval thereof.</p>
</td></tr>
<tr><td><code id="NNS.ANOVA_+3A_robust">robust</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Generates 100 independent random permutations to test results, and returns / plots 95 percent confidence intervals along with robust central tendency of all results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the following:
</p>

<ul>
<li><p><code>"Control Mean"</code> <code>control</code> mean.
</p>
</li>
<li><p><code>"Treatment Mean"</code> <code>treatment</code> mean.
</p>
</li>
<li><p><code>"Grand Mean"</code> mean of means.
</p>
</li>
<li><p><code>"Control CDF"</code> CDF of the <code>control</code> from the grand mean.
</p>
</li>
<li><p><code>"Treatment CDF"</code> CDF of the <code>treatment</code> from the grand mean.
</p>
</li>
<li><p><code>"Certainty"</code> the certainty of the same population statistic.
</p>
</li>
<li><p><code>"Lower Bound Effect"</code> and <code>"Upper Bound Effect"</code> the effect size of the <code>treatment</code> for the specified confidence interval.
</p>
</li>
<li><p><code>"Robust Certainty Estimate"</code> and <code>"Lower 95 CI"</code>, <code>"Upper 95 CI"</code> are the robust certainty estimate and its 95 percent confidence interval after permutations if <code>robust = TRUE</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Viole, F. (2017) &quot;Continuous CDFs and ANOVA with NNS&quot;
<a href="https://www.ssrn.com/abstract=3007373">https://www.ssrn.com/abstract=3007373</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
### Binary analysis and effect size
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.ANOVA(control = x, treatment = y)

### Two variable analysis with no control variable
A &lt;- cbind(x, y)
NNS.ANOVA(A)

### Multiple variable analysis with no control variable
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100) ; z &lt;- rnorm(100)
A &lt;- cbind(x, y, z)
NNS.ANOVA(A)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.ARMA'>NNS ARMA</h2><span id='topic+NNS.ARMA'></span>

<h3>Description</h3>

<p>Autoregressive model incorporating nonlinear regressions of component series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.ARMA(
  variable,
  h = 1,
  training.set = NULL,
  seasonal.factor = TRUE,
  weights = NULL,
  best.periods = 1,
  modulo = NULL,
  mod.only = TRUE,
  negative.values = FALSE,
  method = "nonlin",
  dynamic = FALSE,
  shrink = FALSE,
  plot = TRUE,
  seasonal.plot = TRUE,
  pred.int = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.ARMA_+3A_variable">variable</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_h">h</code></td>
<td>
<p>integer; 1 (default) Number of periods to forecast.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_training.set">training.set</code></td>
<td>
<p>numeric; <code>NULL</code> (default) Sets the number of variable observations
</p>
<p><code>(variable[1 : training.set])</code> to monitor performance of forecast over in-sample range.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_seasonal.factor">seasonal.factor</code></td>
<td>
<p>logical or integer(s); <code>TRUE</code> (default) Automatically selects the best seasonal lag from the seasonality test.  To use weighted average of all seasonal lags set to <code>(seasonal.factor = FALSE)</code>.  Otherwise, directly input known frequency integer lag to use, i.e. <code>(seasonal.factor = 12)</code> for monthly data.  Multiple frequency integers can also be used, i.e. <code>(seasonal.factor = c(12, 24, 36))</code></p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_weights">weights</code></td>
<td>
<p>numeric or <code>"equal"</code>; <code>NULL</code> (default) sets the weights of the <code>seasonal.factor</code> vector when specified as integers.  If <code>(weights = NULL)</code> each <code>seasonal.factor</code> is weighted on its <a href="#topic+NNS.seas">NNS.seas</a> result and number of observations it contains, else an <code>"equal"</code> weight is used.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_best.periods">best.periods</code></td>
<td>
<p>integer; [2] (default) used in conjunction with <code>(seasonal.factor = FALSE)</code>, uses the <code>best.periods</code> number of detected seasonal lags instead of <code>ALL</code> lags when
<code>(seasonal.factor = FALSE, best.periods = NULL)</code>.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_modulo">modulo</code></td>
<td>
<p>integer(s); NULL (default) Used to find the nearest multiple(s) in the reported seasonal period.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_mod.only">mod.only</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Limits the number of seasonal periods returned to the specified <code>modulo</code>.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_negative.values">negative.values</code></td>
<td>
<p>logical; <code>FALSE</code> (default) If the variable can be negative, set to
<code>(negative.values = TRUE)</code>.  If there are negative values within the variable, <code>negative.values</code> will automatically be detected.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_method">method</code></td>
<td>
<p>options: (&quot;lin&quot;, &quot;nonlin&quot;, &quot;both&quot;, &quot;means&quot;); <code>"nonlin"</code> (default)  To select the regression type of the component series, select <code>(method = "both")</code> where both linear and nonlinear estimates are generated.  To use a nonlinear regression, set to
<code>(method = "nonlin")</code>; to use a linear regression set to <code>(method = "lin")</code>.  Means for each subset are returned with <code>(method = "means")</code>.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_dynamic">dynamic</code></td>
<td>
<p>logical; <code>FALSE</code> (default) To update the seasonal factor with each forecast point, set to <code>(dynamic = TRUE)</code>.  The default is <code>(dynamic = FALSE)</code> to retain the original seasonal factor from the inputted variable for all ensuing <code>h</code>.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_shrink">shrink</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Ensembles forecasts with <code>method = "means"</code>.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_plot">plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Returns the plot of all periods exhibiting seasonality and the <code>variable</code> level reference in upper panel.  Lower panel returns original data and forecast.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_seasonal.plot">seasonal.plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Adds the seasonality plot above the forecast.  Will be set to <code>FALSE</code> if no seasonality is detected or <code>seasonal.factor</code> is set to an integer value.</p>
</td></tr>
<tr><td><code id="NNS.ARMA_+3A_pred.int">pred.int</code></td>
<td>
<p>numeric [0, 1]; <code>NULL</code> (default) Plots and returns the associated prediction intervals for the final estimate.  Constructed using the maximum entropy bootstrap <a href="meboot.html#topic+meboot">meboot</a> on the final estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of forecasts of length <code>(h)</code> if no <code>pred.int</code> specified.  Else, returns a <a href="data.table.html#topic+data.table">data.table</a> with the forecasts as well as lower and upper prediction intervals per forecast point.
</p>


<h3>Note</h3>

<p>For monthly data series, increased accuracy may be realized from forcing seasonal factors to multiples of 12.  For example, if the best periods reported are: {37, 47, 71, 73}  use
<code>(seasonal.factor = c(36, 48, 72))</code>.
</p>
<p><code>(seasonal.factor = FALSE)</code> can be a very computationally expensive exercise due to the number of seasonal periods detected.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Viole, F. (2019) &quot;Forecasting Using NNS&quot;
<a href="https://www.ssrn.com/abstract=3382300">https://www.ssrn.com/abstract=3382300</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Nonlinear NNS.ARMA using AirPassengers monthly data and 12 period lag
## Not run: 
NNS.ARMA(AirPassengers, h = 45, training.set = 100, seasonal.factor = 12, method = "nonlin")

## Linear NNS.ARMA using AirPassengers monthly data and 12, 24, and 36 period lags
NNS.ARMA(AirPassengers, h = 45, training.set = 120, seasonal.factor = c(12, 24, 36), method = "lin")

## Nonlinear NNS.ARMA using AirPassengers monthly data and 2 best periods lag
NNS.ARMA(AirPassengers, h = 45, training.set = 120, seasonal.factor = FALSE, best.periods = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.ARMA.optim'>NNS ARMA Optimizer</h2><span id='topic+NNS.ARMA.optim'></span>

<h3>Description</h3>

<p>Wrapper function for optimizing any combination of a given <code>seasonal.factor</code> vector in <a href="#topic+NNS.ARMA">NNS.ARMA</a>.  Minimum sum of squared errors (forecast-actual) is used to determine optimum across all <a href="#topic+NNS.ARMA">NNS.ARMA</a> methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.ARMA.optim(
  variable,
  h = NULL,
  training.set = NULL,
  seasonal.factor,
  negative.values = FALSE,
  obj.fn = expression(mean((predicted - actual)^2)/(NNS::Co.LPM(1, predicted, actual,
    target_x = mean(predicted), target_y = mean(actual)) + NNS::Co.UPM(1, predicted,
    actual, target_x = mean(predicted), target_y = mean(actual)))),
  objective = "min",
  linear.approximation = TRUE,
  pred.int = 0.95,
  print.trace = TRUE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.ARMA.optim_+3A_variable">variable</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_h">h</code></td>
<td>
<p>integer; <code>NULL</code> (default) Number of periods to forecast out of sample.  If <code>NULL</code>, <code>h = length(variable) - training.set</code>.</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_training.set">training.set</code></td>
<td>
<p>integer; <code>NULL</code> (default) Sets the number of variable observations as the training set.  See <code>Note</code> below for recommended uses.</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_seasonal.factor">seasonal.factor</code></td>
<td>
<p>integers; Multiple frequency integers considered for <a href="#topic+NNS.ARMA">NNS.ARMA</a> model, i.e. <code>(seasonal.factor = c(12, 24, 36))</code></p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_negative.values">negative.values</code></td>
<td>
<p>logical; <code>FALSE</code> (default) If the variable can be negative, set to
<code>(negative.values = TRUE)</code>.  It will automatically select <code>(negative.values = TRUE)</code> if the minimum value of the <code>variable</code> is negative.</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_obj.fn">obj.fn</code></td>
<td>
<p>expression;
<code>expression(cor(predicted, actual, method = "spearman") / sum((predicted - actual)^2))</code> (default) Rank correlation / sum of squared errors is the default objective function.  Any <code>expression(...)</code> using the specific terms <code>predicted</code> and <code>actual</code> can be used.</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_objective">objective</code></td>
<td>
<p>options: (&quot;min&quot;, &quot;max&quot;) <code>"max"</code> (default) Select whether to minimize or maximize the objective function <code>obj.fn</code>.</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_linear.approximation">linear.approximation</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Uses the best linear output from <code>NNS.reg</code> to generate a nonlinear and mixture regression for comparison.  <code>FALSE</code> is a more exhaustive search over the objective space.</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_pred.int">pred.int</code></td>
<td>
<p>numeric [0, 1]; 0.95 (default) Returns the associated prediction intervals for the final estimate.  Constructed using the maximum entropy bootstrap <a href="meboot.html#topic+meboot">meboot</a> on the final estimates.</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_print.trace">print.trace</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Prints current iteration information.  Suggested as backup in case of error, best parameters to that point still known and copyable!</p>
</td></tr>
<tr><td><code id="NNS.ARMA.optim_+3A_plot">plot</code></td>
<td>
<p>logical; <code>FALSE</code> (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing:
</p>

<ul>
<li><p><code>$period</code> a vector of optimal seasonal periods
</p>
</li>
<li><p><code>$weights</code> the optimal weights of each seasonal period between an equal weight or NULL weighting
</p>
</li>
<li><p><code>$obj.fn</code> the objective function value
</p>
</li>
<li><p><code>$method</code> the method identifying which <a href="#topic+NNS.ARMA">NNS.ARMA</a> method was used.
</p>
</li>
<li><p><code>$shrink</code> whether to use the <code>shrink</code> parameter in <a href="#topic+NNS.ARMA">NNS.ARMA</a>.
</p>
</li>
<li><p><code>$nns.regress</code> whether to smooth the variable via <a href="#topic+NNS.reg">NNS.reg</a> before forecasting.
</p>
</li>
<li><p><code>$bias.shift</code> a numerical result of the overall bias of the optimum objective function result.  To be added to the final result when using the <a href="#topic+NNS.ARMA">NNS.ARMA</a> with the derived parameters.
</p>
</li>
<li><p><code>$errors</code> a vector of model errors from internal calibration.
</p>
</li>
<li><p><code>$results</code> a vector of length <code>h</code>.
</p>
</li>
<li><p><code>$lower.pred.int</code> a vector of lower prediction intervals per forecast point.
</p>
</li>
<li><p><code>$upper.pred.int</code> a vector of upper prediction intervals per forecast point.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> Typically, <code>(training.set = 0.8 * length(variable)</code> is used for optimization.  Smaller samples could use <code>(training.set = 0.9 * length(variable))</code> (or larger) in order to preserve information.
</p>
</li>
<li><p> The number of combinations will grow prohibitively large, they should be kept as small as possible.  <code>seasonal.factor</code> containing an element too large will result in an error.  Please reduce the maximum <code>seasonal.factor</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Nonlinear NNS.ARMA period optimization using 2 yearly lags on AirPassengers monthly data
## Not run: 
nns.optims &lt;- NNS.ARMA.optim(AirPassengers[1:132], training.set = 120,
seasonal.factor = seq(12, 24, 6))

## To predict out of sample using best parameters:
NNS.ARMA.optim(AirPassengers[1:132], h = 12, seasonal.factor = seq(12, 24, 6))

## Incorporate any objective function from external packages (such as \code{Metrics::mape})
NNS.ARMA.optim(AirPassengers[1:132], h = 12, seasonal.factor = seq(12, 24, 6),
obj.fn = expression(Metrics::mape(actual, predicted)), objective = "min")

## End(Not run)

</code></pre>

<hr>
<h2 id='NNS.boost'>NNS Boost</h2><span id='topic+NNS.boost'></span>

<h3>Description</h3>

<p>Ensemble method for classification using the NNS multivariate regression <a href="#topic+NNS.reg">NNS.reg</a> as the base learner instead of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.boost(
  IVs.train,
  DV.train,
  IVs.test = NULL,
  type = NULL,
  depth = NULL,
  learner.trials = 100,
  epochs = NULL,
  CV.size = NULL,
  balance = FALSE,
  ts.test = NULL,
  folds = 5,
  threshold = NULL,
  obj.fn = expression(sum((predicted - actual)^2)),
  objective = "min",
  extreme = FALSE,
  features.only = FALSE,
  feature.importance = TRUE,
  pred.int = NULL,
  status = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.boost_+3A_ivs.train">IVs.train</code></td>
<td>
<p>a matrix or data frame of variables of numeric or factor data types.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_dv.train">DV.train</code></td>
<td>
<p>a numeric or factor vector with compatible dimensions to <code>(IVs.train)</code>.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_ivs.test">IVs.test</code></td>
<td>
<p>a matrix or data frame of variables of numeric or factor data types with compatible dimensions to <code>(IVs.train)</code>.  If NULL, will use <code>(IVs.train)</code> as default.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_type">type</code></td>
<td>
<p><code>NULL</code> (default).  To perform a classification of discrete integer classes from factor target variable <code>(DV.train)</code> with a base category of 1, set to <code>(type = "CLASS")</code>, else for continuous <code>(DV.train)</code> set to <code>(type = NULL)</code>.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_depth">depth</code></td>
<td>
<p>options: (integer, NULL, &quot;max&quot;); <code>(depth = NULL)</code>(default) Specifies the <code>order</code> parameter in the <a href="#topic+NNS.reg">NNS.reg</a> routine, assigning a number of splits in the regressors, analogous to tree depth.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_learner.trials">learner.trials</code></td>
<td>
<p>integer; 100 (default) Sets the number of trials to obtain an accuracy <code>threshold</code> level.  If the number of all possible feature combinations is less than selected value, the minimum of the two values will be used.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_epochs">epochs</code></td>
<td>
<p>integer; <code>2*length(DV.train)</code> (default) Total number of feature combinations to run.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_cv.size">CV.size</code></td>
<td>
<p>numeric [0, 1]; <code>NULL</code> (default) Sets the cross-validation size.  Defaults to a random value between 0.2 and 0.33 for a random sampling of the training set.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_balance">balance</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Uses both up and down sampling from <code>caret</code> to balance the classes.  <code>type="CLASS"</code> required.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_ts.test">ts.test</code></td>
<td>
<p>integer; NULL (default) Sets the length of the test set for time-series data; typically <code>2*h</code> parameter value from <a href="#topic+NNS.ARMA">NNS.ARMA</a> or double known periods to forecast.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_folds">folds</code></td>
<td>
<p>integer; 5 (default) Sets the number of <code>folds</code> in the <a href="#topic+NNS.stack">NNS.stack</a> procedure for optimal <code>n.best</code> parameter.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_threshold">threshold</code></td>
<td>
<p>numeric; <code>NULL</code> (default) Sets the <code>obj.fn</code> threshold to keep feature combinations.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_obj.fn">obj.fn</code></td>
<td>
<p>expression;
<code>expression( sum((predicted - actual)^2) )</code> (default) Sum of squared errors is the default objective function.  Any <code>expression(...)</code> using the specific terms <code>predicted</code> and <code>actual</code> can be used.  Automatically selects an accuracy measure when <code>(type = "CLASS")</code>.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_objective">objective</code></td>
<td>
<p>options: (&quot;min&quot;, &quot;max&quot;) <code>"max"</code> (default) Select whether to minimize or maximize the objective function <code>obj.fn</code>.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_extreme">extreme</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Uses the maximum (minimum) <code>threshold</code> obtained from the <code>learner.trials</code>, rather than the upper (lower) quintile level for maximization (minimization) <code>objective</code>.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_features.only">features.only</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Returns only the final feature loadings along with the final feature frequencies.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_feature.importance">feature.importance</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Plots the frequency of features used in the final estimate.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_pred.int">pred.int</code></td>
<td>
<p>numeric [0,1]; <code>NULL</code> (default) Returns the associated prediction intervals for the final estimate.</p>
</td></tr>
<tr><td><code id="NNS.boost_+3A_status">status</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Prints status update message in console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of fitted values for the dependent variable test set <code>$results</code>, prediction intervals <code>$pred.int</code>, and the final feature loadings <code>$feature.weights</code>, along with final feature frequencies <code>$feature.frequency</code>.
</p>


<h3>Note</h3>


<ul>
<li><p> Like a logistic regression, the <code>(type = "CLASS")</code> setting is not necessary for target variable of two classes e.g. [0, 1].  The response variable base category should be 1 for classification problems.
</p>
</li>
<li><p> Incorporate any objective function from external packages (such as <code>Metrics::mape</code>) via <code>NNS.boost(..., obj.fn = expression(Metrics::mape(actual, predicted)), objective = "min")</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. (2016) &quot;Classification Using NNS Clustering Analysis&quot;
<a href="https://www.ssrn.com/abstract=2864711">https://www.ssrn.com/abstract=2864711</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Using 'iris' dataset where test set [IVs.test] is 'iris' rows 141:150.
 ## Not run: 
 a &lt;- NNS.boost(iris[1:140, 1:4], iris[1:140, 5],
 IVs.test = iris[141:150, 1:4],
 epochs = 100, learner.trials = 100,
 type = "CLASS", depth = NULL)

 ## Test accuracy
 mean(a$results == as.numeric(iris[141:150, 5]))
 
## End(Not run)

</code></pre>

<hr>
<h2 id='NNS.caus'>NNS Causation</h2><span id='topic+NNS.caus'></span>

<h3>Description</h3>

<p>Returns the causality from observational data between two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.caus(x, y = NULL, factor.2.dummy = FALSE, tau = 0, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.caus_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="NNS.caus_+3A_y">y</code></td>
<td>
<p><code>NULL</code> (default) or a numeric vector with compatible dimensions to <code>x</code>.</p>
</td></tr>
<tr><td><code id="NNS.caus_+3A_factor.2.dummy">factor.2.dummy</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Automatically augments variable matrix with numerical dummy variables based on the levels of factors.  Includes dependent variable <code>y</code>.</p>
</td></tr>
<tr><td><code id="NNS.caus_+3A_tau">tau</code></td>
<td>
<p>options: (&quot;cs&quot;, &quot;ts&quot;, integer); 0 (default) Number of lagged observations to consider (for time series data).  Otherwise, set <code>(tau = "cs")</code> for cross-sectional data.  <code>(tau = "ts")</code> automatically selects the lag of the time series data, while <code>(tau = [integer])</code> specifies a time series lag.</p>
</td></tr>
<tr><td><code id="NNS.caus_+3A_plot">plot</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Plots the raw variables, tau normalized, and cross-normalized variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the directional causation (x &mdash;&gt; y) or (y &mdash;&gt; x) and net quantity of association.  For causal matrix, directional causation is returned as ([column variable] &mdash;&gt; [row variable]).  Negative numbers represent causal direction attributed to [row variable].
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## x causes y...
set.seed(123)
x &lt;- rnorm(1000) ; y &lt;- x ^ 2
NNS.caus(x, y, tau = "cs")

## Causal matrix without per factor causation
NNS.caus(iris, tau = 0)

## Causal matrix with per factor causation
NNS.caus(iris, factor.2.dummy = TRUE, tau = 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.CDF'>NNS CDF</h2><span id='topic+NNS.CDF'></span>

<h3>Description</h3>

<p>This function generates an empirical CDF using partial moment ratios <a href="#topic+LPM.ratio">LPM.ratio</a>, and resulting survival, hazard and cumulative hazard functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.CDF(variable, degree = 0, target = NULL, type = "CDF", plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.CDF_+3A_variable">variable</code></td>
<td>
<p>a numeric vector or data.frame of 2 variables for joint CDF.</p>
</td></tr>
<tr><td><code id="NNS.CDF_+3A_degree">degree</code></td>
<td>
<p>integer; <code>(degree = 0)</code> (default) is frequency, <code>(degree = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="NNS.CDF_+3A_target">target</code></td>
<td>
<p>numeric; <code>NULL</code> (default) Must lie within support of each variable.</p>
</td></tr>
<tr><td><code id="NNS.CDF_+3A_type">type</code></td>
<td>
<p>options(&quot;CDF&quot;, &quot;survival&quot;, &quot;hazard&quot;, &quot;cumulative hazard&quot;); <code>"CDF"</code> (default) Selects type of function to return for bi-variate analysis.  Multivariate analysis is restricted to <code>"CDF"</code>.</p>
</td></tr>
<tr><td><code id="NNS.CDF_+3A_plot">plot</code></td>
<td>
<p>logical; plots CDF.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns:
</p>

<ul>
<li><p><code>"Function"</code> a data.table containing the observations and resulting CDF of the variable.
</p>
</li>
<li><p><code>"target.value"</code> value from the <code>target</code> argument.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Viole, F. (2017) &quot;Continuous CDFs and ANOVA with NNS&quot;
<a href="https://www.ssrn.com/abstract=3007373">https://www.ssrn.com/abstract=3007373</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100)
NNS.CDF(x)

## Empirical CDF (degree = 0)
NNS.CDF(x)

## Continuous CDF (degree = 1)
NNS.CDF(x, 1)

## Joint CDF
x &lt;- rnorm(5000) ; y &lt;- rnorm(5000)
A &lt;- cbind(x,y)

NNS.CDF(A, 0)

## Joint CDF with target
NNS.CDF(A, 0, target = c(0,0))

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.copula'>NNS Co-Partial Moments Higher Dimension Dependence</h2><span id='topic+NNS.copula'></span>

<h3>Description</h3>

<p>Determines higher dimension dependence coefficients based on co-partial moment matrices ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.copula(
  X,
  target = NULL,
  continuous = TRUE,
  plot = FALSE,
  independence.overlay = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.copula_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="NNS.copula_+3A_target">target</code></td>
<td>
<p>numeric; Typically the mean of Variable X for classical statistics equivalences, but does not have to be. (Vectorized)  <code>(target = NULL)</code> (default) will set the target as the mean of every variable.</p>
</td></tr>
<tr><td><code id="NNS.copula_+3A_continuous">continuous</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Generates a continuous measure using degree 1 <a href="#topic+PM.matrix">PM.matrix</a>, while discrete <code>FALSE</code> uses degree 0 <a href="#topic+PM.matrix">PM.matrix</a>.</p>
</td></tr>
<tr><td><code id="NNS.copula_+3A_plot">plot</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Generates a 3d scatter plot with regression points using <a href="rgl.html#topic+plot3d">plot3d</a>.</p>
</td></tr>
<tr><td><code id="NNS.copula_+3A_independence.overlay">independence.overlay</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Creates and overlays independent <a href="#topic+Co.LPM">Co.LPM</a> and <a href="#topic+Co.UPM">Co.UPM</a> regions to visually reference the difference in dependence from the data.frame of variables being analyzed.  Under independence, the light green and red shaded areas would be occupied by green and red data points respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a multivariate dependence value [0,1].
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. (2016) &quot;Beyond Correlation: Using the Elements of Variance for Conditional Means and Probabilities&quot;  <a href="https://www.ssrn.com/abstract=2745308">https://www.ssrn.com/abstract=2745308</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(1000) ; y &lt;- rnorm(1000) ; z &lt;- rnorm(1000)
A &lt;- data.frame(x, y, z)
NNS.copula(A, target = colMeans(A), plot = TRUE, independence.overlay = TRUE)

### Target 0
NNS.copula(A, target = rep(0, ncol(A)), plot = TRUE, independence.overlay = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.dep'>NNS Dependence</h2><span id='topic+NNS.dep'></span>

<h3>Description</h3>

<p>Returns the dependence and nonlinear correlation between two variables based on higher order partial moment matrices measured by frequency or area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.dep(x, y = NULL, asym = FALSE, p.value = FALSE, print.map = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.dep_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="NNS.dep_+3A_y">y</code></td>
<td>
<p><code>NULL</code> (default) or a numeric vector with compatible dimensions to <code>x</code>.</p>
</td></tr>
<tr><td><code id="NNS.dep_+3A_asym">asym</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Allows for asymmetrical dependencies.</p>
</td></tr>
<tr><td><code id="NNS.dep_+3A_p.value">p.value</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Generates 100 independent random permutations to test results against and plots 95 percent confidence intervals along with all results.</p>
</td></tr>
<tr><td><code id="NNS.dep_+3A_print.map">print.map</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Plots quadrant means, or p-value replicates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the bi-variate <code>"Correlation"</code> and <code>"Dependence"</code> or correlation / dependence matrix for matrix input.
</p>


<h3>Note</h3>

<p>For asymmetrical <code>(asym = TRUE)</code> matrices, directional dependence is returned as ([column variable] &mdash;&gt; [row variable]).
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.dep(x, y)

## Correlation / Dependence Matrix
x &lt;- rnorm(100) ; y &lt;- rnorm(100) ; z &lt;- rnorm(100)
B &lt;- cbind(x, y, z)
NNS.dep(B)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.diff'>NNS Numerical Differentiation</h2><span id='topic+NNS.diff'></span>

<h3>Description</h3>

<p>Determines numerical derivative of a given univariate function using projected secant lines on the y-axis.  These projected points infer finite steps <code>h</code>, in the finite step method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.diff(f, point, h = 0.1, tol = 1e-10, digits = 12, print.trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.diff_+3A_f">f</code></td>
<td>
<p>an expression or call or a formula with no lhs.</p>
</td></tr>
<tr><td><code id="NNS.diff_+3A_point">point</code></td>
<td>
<p>numeric; Point to be evaluated for derivative of a given function <code>f</code>.</p>
</td></tr>
<tr><td><code id="NNS.diff_+3A_h">h</code></td>
<td>
<p>numeric [0, ...]; Initial step for secant projection.  Defaults to <code>(h = 0.1)</code>.</p>
</td></tr>
<tr><td><code id="NNS.diff_+3A_tol">tol</code></td>
<td>
<p>numeric; Sets the tolerance for the stopping condition of the inferred <code>h</code>.  Defaults to <code>(tol = 1e-10)</code>.</p>
</td></tr>
<tr><td><code id="NNS.diff_+3A_digits">digits</code></td>
<td>
<p>numeric; Sets the number of digits specification of the output.  Defaults to <code>(digits = 12)</code>.</p>
</td></tr>
<tr><td><code id="NNS.diff_+3A_print.trace">print.trace</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Displays each iteration, lower y-intercept, upper y-intercept and inferred <code>h</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of values, intercepts, derivatives, inferred step sizes for multiple methods of estimation.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
f &lt;- function(x) sin(x) / x
NNS.diff(f, 4.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.distance'>NNS Distance</h2><span id='topic+NNS.distance'></span>

<h3>Description</h3>

<p>Internal kernel function for NNS multivariate regression <a href="#topic+NNS.reg">NNS.reg</a> parallel instances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.distance(rpm, dist.estimate, k, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.distance_+3A_rpm">rpm</code></td>
<td>
<p>REGRESSION.POINT.MATRIX from <a href="#topic+NNS.reg">NNS.reg</a></p>
</td></tr>
<tr><td><code id="NNS.distance_+3A_dist.estimate">dist.estimate</code></td>
<td>
<p>Vector to generate distances from.</p>
</td></tr>
<tr><td><code id="NNS.distance_+3A_k">k</code></td>
<td>
<p><code>n.best</code> from <a href="#topic+NNS.reg">NNS.reg</a></p>
</td></tr>
<tr><td><code id="NNS.distance_+3A_class">class</code></td>
<td>
<p>if classification problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns sum of weighted distances.
</p>

<hr>
<h2 id='NNS.FSD'>NNS FSD Test</h2><span id='topic+NNS.FSD'></span>

<h3>Description</h3>

<p>Bi-directional test of first degree stochastic dominance using lower partial moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.FSD(x, y, type = "discrete", plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.FSD_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.FSD_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.FSD_+3A_type">type</code></td>
<td>
<p>options: (&quot;discrete&quot;, &quot;continuous&quot;); <code>"discrete"</code> (default) selects the type of CDF.</p>
</td></tr>
<tr><td><code id="NNS.FSD_+3A_plot">plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) plots the FSD test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns one of the following FSD results: <code>"X FSD Y"</code>, <code>"Y FSD X"</code>, or <code>"NO FSD EXISTS"</code>.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2016) &quot;LPM Density Functions for the Computation of the SD Efficient Set.&quot; Journal of Mathematical Finance, 6, 105-126.  DOI: <a href="https://doi.org/10.4236/jmf.2016.61012">doi:10.4236/jmf.2016.61012</a>.
</p>
<p>Viole, F. (2017) &quot;A Note on Stochastic Dominance.&quot; <a href="https://www.ssrn.com/abstract=3002675">https://www.ssrn.com/abstract=3002675</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.FSD(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.FSD.uni'>NNS FSD Test uni-directional</h2><span id='topic+NNS.FSD.uni'></span>

<h3>Description</h3>

<p>Uni-directional test of first degree stochastic dominance using lower partial moments used in SD Efficient Set routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.FSD.uni(x, y, type = "discrete")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.FSD.uni_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.FSD.uni_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.FSD.uni_+3A_type">type</code></td>
<td>
<p>options: (&quot;discrete&quot;, &quot;continuous&quot;); <code>"discrete"</code> (default) selects the type of CDF.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (1) if <code>"X FSD Y"</code>, else (0).
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2016) &quot;LPM Density Functions for the Computation of the SD Efficient Set.&quot; Journal of Mathematical Finance, 6, 105-126.  DOI: <a href="https://doi.org/10.4236/jmf.2016.61012">doi:10.4236/jmf.2016.61012</a>.
</p>
<p>Viole, F. (2017) &quot;A Note on Stochastic Dominance.&quot; <a href="https://www.ssrn.com/abstract=3002675">https://www.ssrn.com/abstract=3002675</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.FSD.uni(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.gravity'>NNS gravity</h2><span id='topic+NNS.gravity'></span>

<h3>Description</h3>

<p>Alternative central tendency measure more robust to outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.gravity(x, discrete = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.gravity_+3A_x">x</code></td>
<td>
<p>vector of data.</p>
</td></tr>
<tr><td><code id="NNS.gravity_+3A_discrete">discrete</code></td>
<td>
<p>logical; <code>FALSE</code> (default) for discrete distributions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value representing the central tendency of the distribution.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100)
NNS.gravity(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.MC'>NNS Monte Carlo Sampling</h2><span id='topic+NNS.MC'></span>

<h3>Description</h3>

<p>Monte Carlo sampling from the maximum entropy bootstrap routine <a href="#topic+NNS.meboot">NNS.meboot</a>, ensuring the replicates are sampled from the full [-1,1] correlation space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.MC(
  x,
  reps = 30,
  lower_rho = -1,
  upper_rho = 1,
  by = 0.01,
  exp = 1,
  type = "spearman",
  drift = TRUE,
  xmin = NULL,
  xmax = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.MC_+3A_x">x</code></td>
<td>
<p>vector of data.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_reps">reps</code></td>
<td>
<p>numeric; number of replicates to generate, <code>30</code> default.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_lower_rho">lower_rho</code></td>
<td>
<p>numeric <code>[-1,1]</code>; <code>.01</code> default will set the <code>from</code> argument in <code>seq(from, to, by)</code>.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_upper_rho">upper_rho</code></td>
<td>
<p>numeric <code>[-1,1]</code>; <code>.01</code> default will set the <code>to</code> argument in <code>seq(from, to, by)</code>.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_by">by</code></td>
<td>
<p>numeric; <code>.01</code> default will set the <code>by</code> argument in <code>seq(-1, 1, step)</code>.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_exp">exp</code></td>
<td>
<p>numeric; <code>1</code> default will exponentially weight maximum rho value if <code>exp &gt; 1</code>.  Shrinks values towards <code>upper_rho</code>.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_type">type</code></td>
<td>
<p>options(&quot;spearman&quot;, &quot;pearson&quot;, &quot;NNScor&quot;, &quot;NNSdep&quot;); <code>type = "spearman"</code>(default) dependence metric desired.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_drift">drift</code></td>
<td>
<p>logical; <code>TRUE</code> default preserves the drift of the original series.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_xmin">xmin</code></td>
<td>
<p>numeric; the lower limit for the left tail.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_xmax">xmax</code></td>
<td>
<p>numeric; the upper limit for the right tail.</p>
</td></tr>
<tr><td><code id="NNS.MC_+3A_...">...</code></td>
<td>
<p>possible additional arguments to be passed to <a href="#topic+NNS.meboot">NNS.meboot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>ensemble average observation over all replicates as a vector.
</p>
</li>
<li><p>replicates maximum entropy bootstrap replicates as a list for each <code>rho</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Vinod, H.D. and Viole, F. (2020) Arbitrary Spearman's Rank Correlations in Maximum Entropy Bootstrap and Improved Monte Carlo Simulations
<a href="https://www.ssrn.com/abstract=3621614">https://www.ssrn.com/abstract=3621614</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To generate a set of MC sampled time-series to AirPassengers
MC_samples &lt;- NNS.MC(AirPassengers, xmin = 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.meboot'>NNS meboot</h2><span id='topic+NNS.meboot'></span>

<h3>Description</h3>

<p>Adapted maximum entropy bootstrap routine from <code>meboot</code> <a href="https://cran.r-project.org/package=meboot">https://cran.r-project.org/package=meboot</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.meboot(
  x,
  reps = 999,
  rho = NULL,
  type = "spearman",
  drift = TRUE,
  trim = 0.1,
  xmin = NULL,
  xmax = NULL,
  reachbnd = TRUE,
  expand.sd = TRUE,
  force.clt = TRUE,
  scl.adjustment = FALSE,
  sym = FALSE,
  elaps = FALSE,
  digits = 6,
  colsubj,
  coldata,
  coltimes,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.meboot_+3A_x">x</code></td>
<td>
<p>vector of data.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_reps">reps</code></td>
<td>
<p>numeric; number of replicates to generate.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_rho">rho</code></td>
<td>
<p>numeric [-1,1] (vectorized); A <code>rho</code> must be provided, otherwise a blank list will be returned.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_type">type</code></td>
<td>
<p>options(&quot;spearman&quot;, &quot;pearson&quot;, &quot;NNScor&quot;, &quot;NNSdep&quot;); <code>type = "spearman"</code>(default) dependence metric desired.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_drift">drift</code></td>
<td>
<p>logical; <code>TRUE</code> default preserves the drift of the original series.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_trim">trim</code></td>
<td>
<p>numeric [0,1]; The mean trimming proportion, defaults to <code>trim=0.1</code>.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_xmin">xmin</code></td>
<td>
<p>numeric; the lower limit for the left tail.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_xmax">xmax</code></td>
<td>
<p>numeric; the upper limit for the right tail.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_reachbnd">reachbnd</code></td>
<td>
<p>logical; If <code>TRUE</code> potentially reached bounds (xmin = smallest value - trimmed mean and
xmax = largest value + trimmed mean) are given when the random draw happens to be equal to 0 and 1, respectively.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_expand.sd">expand.sd</code></td>
<td>
<p>logical; If <code>TRUE</code> the standard deviation in the ensemble is expanded. See <code>expand.sd</code> in <code>meboot::meboot</code>.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_force.clt">force.clt</code></td>
<td>
<p>logical; If <code>TRUE</code> the ensemble is forced to satisfy the central limit theorem. See <code>force.clt</code> in <code>meboot::meboot</code>.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_scl.adjustment">scl.adjustment</code></td>
<td>
<p>logical; If <code>TRUE</code> scale adjustment is performed to ensure that the population variance of the transformed series equals the variance of the data.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_sym">sym</code></td>
<td>
<p>logical; If <code>TRUE</code> an adjustment is performed to ensure that the ME density is symmetric.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_elaps">elaps</code></td>
<td>
<p>logical; If <code>TRUE</code> elapsed time during computations is displayed.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_digits">digits</code></td>
<td>
<p>integer; 6 (default) number of digits to round output to.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_colsubj">colsubj</code></td>
<td>
<p>numeric; the column in <code>x</code> that contains the individual index. It is ignored if the input data <code>x</code> is not a <code>pdata.frame</code> object.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_coldata">coldata</code></td>
<td>
<p>numeric; the column in <code>x</code> that contains the data of the variable to create the ensemble. It is ignored if the input data <code>x</code> is not a <code>pdata.frame</code> object.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_coltimes">coltimes</code></td>
<td>
<p>numeric; an optional argument indicating the column that contains the times at which the observations for each individual are observed. It is ignored if the input data <code>x</code>
is not a <code>pdata.frame</code> object.</p>
</td></tr>
<tr><td><code id="NNS.meboot_+3A_...">...</code></td>
<td>
<p>possible argument <code>fiv</code> to be passed to <code>expand.sd</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the following row names in a matrix:
</p>

<ul>
<li><p>x original data provided as input.
</p>
</li>
<li><p>replicates maximum entropy bootstrap replicates.
</p>
</li>
<li><p>ensemble average observation over all replicates.
</p>
</li>
<li><p>xx sorted order stats (xx[1] is minimum value).
</p>
</li>
<li><p>z class intervals limits.
</p>
</li>
<li><p>dv deviations of consecutive data values.
</p>
</li>
<li><p>dvtrim trimmed mean of dv.
</p>
</li>
<li><p>xmin data minimum for ensemble=xx[1]-dvtrim.
</p>
</li>
<li><p>xmax data x maximum for ensemble=xx[n]+dvtrim.
</p>
</li>
<li><p>desintxb desired interval means.
</p>
</li>
<li><p>ordxx ordered x values.
</p>
</li>
<li><p>kappa scale adjustment to the variance of ME density.
</p>
</li>
<li><p>elaps elapsed time.
</p>
</li></ul>



<h3>References</h3>


<ul>
<li><p> Vinod, H.D. and Viole, F. (2020) Arbitrary Spearman's Rank Correlations in Maximum Entropy Bootstrap and Improved Monte Carlo Simulations
<a href="https://www.ssrn.com/abstract=3621614">https://www.ssrn.com/abstract=3621614</a>
</p>
</li>
<li><p> Vinod, H.D. (2013), Maximum Entropy Bootstrap Algorithm Enhancements.
<a href="https://www.ssrn.com/abstract=2285041">https://www.ssrn.com/abstract=2285041</a>.
</p>
</li>
<li><p> Vinod, H.D. (2006), Maximum Entropy Ensembles for Time Series Inference in Economics,
<em>Journal of Asian Economics</em>, <b>17</b>(6), pp. 955-978.
</p>
</li>
<li><p> Vinod, H.D. (2004), Ranking mutual funds using unconventional utility theory and stochastic dominance, <em>Journal of Empirical Finance</em>, <b>11</b>(3), pp. 353-377.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# To generate an orthogonal rank correlated time-series to AirPassengers
boots &lt;- NNS.meboot(AirPassengers, reps=100, rho = 0, xmin = 0)

# Verify correlation of replicates ensemble to original
cor(boots["ensemble",], AirPassengers, method = "spearman")

# Plot all replicates
matplot(boots["replicates",] , type = 'l')

# Plot ensemble
lines(boots["ensemble",], lwd = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.mode'>NNS mode</h2><span id='topic+NNS.mode'></span>

<h3>Description</h3>

<p>Mode of a distribution, either continuous or discrete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.mode(x, discrete = FALSE, multi = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.mode_+3A_x">x</code></td>
<td>
<p>vector of data.</p>
</td></tr>
<tr><td><code id="NNS.mode_+3A_discrete">discrete</code></td>
<td>
<p>logical; <code>FALSE</code> (default) for discrete distributions.</p>
</td></tr>
<tr><td><code id="NNS.mode_+3A_multi">multi</code></td>
<td>
<p>logical; <code>TRUE</code> (default) returns multiple mode values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value representing the mode of the distribution.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100)
NNS.mode(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.moments'>NNS moments</h2><span id='topic+NNS.moments'></span>

<h3>Description</h3>

<p>This function returns the first 4 moments of the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.moments(x, population = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.moments_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.moments_+3A_population">population</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Performs the population adjustment.  Otherwise returns the sample statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns:
</p>

<ul>
<li><p><code>"$mean"</code> mean of the distribution.
</p>
</li>
<li><p><code>"$variance"</code> variance of the distribution.
</p>
</li>
<li><p><code>"$skewness"</code> skewness of the distribution.
</p>
</li>
<li><p><code>"$kurtosis"</code> excess kurtosis of the distribution.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100)
NNS.moments(x)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.norm'>NNS Normalization</h2><span id='topic+NNS.norm'></span>

<h3>Description</h3>

<p>Normalizes a matrix of variables based on nonlinear scaling normalization method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.norm(X, linear = FALSE, chart.type = NULL, location = "topleft")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.norm_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame, or a list.</p>
</td></tr>
<tr><td><code id="NNS.norm_+3A_linear">linear</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Performs a linear scaling normalization, resulting in equal means for all variables.</p>
</td></tr>
<tr><td><code id="NNS.norm_+3A_chart.type">chart.type</code></td>
<td>
<p>options: (&quot;l&quot;, &quot;b&quot;); <code>NULL</code> (default).  Set <code>(chart.type = "l")</code> for line,
<code>(chart.type = "b")</code> for boxplot.</p>
</td></tr>
<tr><td><code id="NNS.norm_+3A_location">location</code></td>
<td>
<p>Sets the legend location within the plot, per the <code>x</code> and <code>y</code> co-ordinates used in base graphics <a href="graphics.html#topic+legend">legend</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <a href="base.html#topic+data.frame">data.frame</a> of normalized values.
</p>


<h3>Note</h3>

<p>Unequal vectors provided in a list will only generate <code>linear=TRUE</code> normalized values.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y&lt;-rnorm(100)
A &lt;- cbind(x, y)
NNS.norm(A)

### Normalize list of unequal vector lengths

vec1 &lt;- c(1, 2, 3, 4, 5, 6, 7)
vec2 &lt;- c(10, 20, 30, 40, 50, 60)
vec3 &lt;- c(0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3)

vec_list &lt;- list(vec1, vec2, vec3)
NNS.norm(vec_list)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.nowcast'>NNS Nowcast</h2><span id='topic+NNS.nowcast'></span>

<h3>Description</h3>

<p>Wrapper function for NNS nowcasting method using the nonparametric vector autoregression <a href="#topic+NNS.VAR">NNS.VAR</a>, and Federal Reserve Nowcasting variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.nowcast(
  h = 1,
  additional.regressors = NULL,
  additional.sources = NULL,
  naive.weights = FALSE,
  specific.regressors = NULL,
  start.date = "2000-01-03",
  keep.data = FALSE,
  status = TRUE,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.nowcast_+3A_h">h</code></td>
<td>
<p>integer; <code>(h = 1)</code> (default) Number of periods to forecast. <code>(h = 0)</code> will return just the interpolated and extrapolated values up to the current month.</p>
</td></tr>
<tr><td><code id="NNS.nowcast_+3A_additional.regressors">additional.regressors</code></td>
<td>
<p>character; <code>NULL</code> (default) add more regressors to the base model.  The format must utilize the <code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> format for FRED data, else specify the source.</p>
</td></tr>
<tr><td><code id="NNS.nowcast_+3A_additional.sources">additional.sources</code></td>
<td>
<p>character; <code>NULL</code> (default) specify the <code>source</code> argument per <code><a href="quantmod.html#topic+getSymbols">getSymbols</a></code> for each <code>additional.regressors</code> specified.</p>
</td></tr>
<tr><td><code id="NNS.nowcast_+3A_naive.weights">naive.weights</code></td>
<td>
<p>logical; <code>TRUE</code> Equal weights applied to univariate and multivariate outputs in ensemble.  <code>FALSE</code> (default) will apply weights based on the number of relevant variables detected.</p>
</td></tr>
<tr><td><code id="NNS.nowcast_+3A_specific.regressors">specific.regressors</code></td>
<td>
<p>integer; <code>NULL</code> (default) Select individual regressors from the base model per Viole (2020) listed in the <code>Note</code> below.</p>
</td></tr>
<tr><td><code id="NNS.nowcast_+3A_start.date">start.date</code></td>
<td>
<p>character; <code>"2000-01-03"</code> (default) Starting date for all data series download.</p>
</td></tr>
<tr><td><code id="NNS.nowcast_+3A_keep.data">keep.data</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Keeps downloaded variables in a new environment <code>NNSdata</code>.</p>
</td></tr>
<tr><td><code id="NNS.nowcast_+3A_status">status</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Prints status update message in console.</p>
</td></tr>
<tr><td><code id="NNS.nowcast_+3A_ncores">ncores</code></td>
<td>
<p>integer; value specifying the number of cores to be used in the parallelized subroutine <a href="#topic+NNS.ARMA.optim">NNS.ARMA.optim</a>. If NULL (default), the number of cores to be used is equal to the number of cores of the machine - 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the following matrices of forecasted variables:
</p>

<ul>
<li><p><code>"interpolated_and_extrapolated"</code> Returns a <code>data.frame</code> of the linear interpolated and <a href="#topic+NNS.ARMA">NNS.ARMA</a> extrapolated values to replace <code>NA</code> values in the original <code>variables</code> argument.  This is required for working with variables containing different frequencies, e.g. where <code>NA</code> would be reported for intra-quarterly data when indexed with monthly periods.
</p>
</li>
<li><p><code>"relevant_variables"</code> Returns the relevant variables from the dimension reduction step.
</p>
</li>
<li><p><code>"univariate"</code> Returns the univariate <a href="#topic+NNS.ARMA">NNS.ARMA</a> forecasts.
</p>
</li>
<li><p><code>"multivariate"</code> Returns the multi-variate <a href="#topic+NNS.reg">NNS.reg</a> forecasts.
</p>
</li>
<li><p><code>"ensemble"</code> Returns the ensemble of both <code>"univariate"</code> and <code>"multivariate"</code> forecasts.
</p>
</li></ul>



<h3>Note</h3>

<p>Specific regressors include:
</p>

<ol>
<li> <p><code>PAYEMS</code> &ndash; Payroll Employment
</p>
</li>
<li> <p><code>JTSJOL</code> &ndash; Job Openings
</p>
</li>
<li> <p><code>CPIAUCSL</code> &ndash; Consumer Price Index
</p>
</li>
<li> <p><code>DGORDER</code> &ndash; Durable Goods Orders
</p>
</li>
<li> <p><code>RSAFS</code> &ndash; Retail Sales
</p>
</li>
<li> <p><code>UNRATE</code> &ndash; Unemployment Rate
</p>
</li>
<li> <p><code>HOUST</code> &ndash; Housing Starts
</p>
</li>
<li> <p><code>INDPRO</code> &ndash; Industrial Production
</p>
</li>
<li> <p><code>DSPIC96</code> &ndash; Personal Income
</p>
</li>
<li> <p><code>BOPTEXP</code> &ndash; Exports
</p>
</li>
<li> <p><code>BOPTIMP</code> &ndash; Imports
</p>
</li>
<li> <p><code>TTLCONS</code> &ndash; Construction Spending
</p>
</li>
<li> <p><code>IR</code> &ndash; Import Price Index
</p>
</li>
<li> <p><code>CPILFESL</code> &ndash; Core Consumer Price Index
</p>
</li>
<li> <p><code>PCEPILFE</code> &ndash; Core PCE Price Index
</p>
</li>
<li> <p><code>PCEPI</code> &ndash; PCE Price Index
</p>
</li>
<li> <p><code>PERMIT</code> &ndash; Building Permits
</p>
</li>
<li> <p><code>TCU</code> &ndash; Capacity Utilization Rate
</p>
</li>
<li> <p><code>BUSINV</code> &ndash; Business Inventories
</p>
</li>
<li> <p><code>ULCNFB</code> &ndash; Unit Labor Cost
</p>
</li>
<li> <p><code>IQ</code> &ndash; Export Price Index
</p>
</li>
<li> <p><code>GACDISA066MSFRBNY</code> &ndash; Empire State Mfg Index
</p>
</li>
<li> <p><code>GACDFSA066MSFRBPHI</code> &ndash; Philadelphia Fed Mfg Index
</p>
</li>
<li> <p><code>PCEC96</code> &ndash; Real Consumption Spending
</p>
</li>
<li> <p><code>GDPC1</code> &ndash; Real Gross Domestic Product
</p>
</li>
<li> <p><code>ICSA</code> &ndash; Weekly Unemployment Claims
</p>
</li>
<li> <p><code>DGS10</code> &ndash; 10-year Treasury rates
</p>
</li>
<li> <p><code>T10Y2Y</code> &ndash; 2-10 year Treasury rate spread
</p>
</li>
<li> <p><code>WALCL</code> &ndash; Total Assets
</p>
</li>
<li> <p><code>PALLFNFINDEXM</code> &ndash; Global Price Index of All Commodities
</p>
</li>
<li> <p><code>FEDFUNDS</code> &ndash; Federal Funds Effective Rate
</p>
</li>
<li> <p><code>PPIACO</code> &ndash; Producer Price Index All Commodities
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Viole, F. (2019) &quot;Multi-variate Time-Series Forecasting: Nonparametric Vector Autoregression Using NNS&quot;
<a href="https://www.ssrn.com/abstract=3489550">https://www.ssrn.com/abstract=3489550</a>
</p>
<p>Viole, F. (2020) &quot;NOWCASTING with NNS&quot;
<a href="https://www.ssrn.com/abstract=3589816">https://www.ssrn.com/abstract=3589816</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 ## Interpolates / Extrapolates all variables to current month
 NNS.nowcast(h = 0)
 
 ## Additional regressors and sources specified
 NNS.nowcast(h = 0, additional.regressors = c("SPY", "USO"), 
             additional.sources = c("yahoo", "yahoo"))
             
              
 ### PREDICTION INTERVALS 
 ## Store NNS.nowcast output
 nns_estimates &lt;- NNS.nowcast(h = 12)           
 
 # Create bootstrap replicates using NNS.meboot (GDP Variable)
 gdp_replicates &lt;- NNS.meboot(nns_estimates$ensemble$GDPC1, 
                              rho = seq(0,1,.25), 
                              reps = 100)["replicates",]
                              
 replicates &lt;- do.call(cbind, gdp_replicates)
 
 # Apply UPM.VaR and LPM.VaR for desired prediction interval...95 percent illustrated
 # Tail percentage used in first argument per {LPM.VaR} and {UPM.VaR} functions
 lower_GDP_CIs &lt;- apply(replicates, 1, function(z) LPM.VaR(0.025, 0, z))
 upper_GDP_CIs &lt;- apply(replicates, 1, function(z) UPM.VaR(0.025, 0, z))
 
 # View results
 cbind(nns_estimates$ensemble$GDPC1, lower_GDP_CIs, upper_GDP_CIs)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='NNS.part'>NNS Partition Map</h2><span id='topic+NNS.part'></span>

<h3>Description</h3>

<p>Creates partitions based on partial moment quadrant centroids, iteratively assigning identifications to observations based on those quadrants (unsupervised partitional and hierarchial clustering method).  Basis for correlation, dependence <a href="#topic+NNS.dep">NNS.dep</a>, regression <a href="#topic+NNS.reg">NNS.reg</a> routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.part(
  x,
  y,
  Voronoi = FALSE,
  type = NULL,
  order = NULL,
  obs.req = 8,
  min.obs.stop = TRUE,
  noise.reduction = "off"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.part_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.part_+3A_y">y</code></td>
<td>
<p>a numeric vector with compatible dimensions to <code>x</code>.</p>
</td></tr>
<tr><td><code id="NNS.part_+3A_voronoi">Voronoi</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Displays a Voronoi type diagram using partial moment quadrants.</p>
</td></tr>
<tr><td><code id="NNS.part_+3A_type">type</code></td>
<td>
<p><code>NULL</code> (default) Controls the partitioning basis.  Set to <code>(type = "XONLY")</code> for X-axis based partitioning.  Defaults to <code>NULL</code> for both X and Y-axis partitioning.</p>
</td></tr>
<tr><td><code id="NNS.part_+3A_order">order</code></td>
<td>
<p>integer; Number of partial moment quadrants to be generated.  <code>(order = "max")</code> will institute a perfect fit.</p>
</td></tr>
<tr><td><code id="NNS.part_+3A_obs.req">obs.req</code></td>
<td>
<p>integer; (8 default) Required observations per cluster where quadrants will not be further partitioned if observations are not greater than the entered value.  Reduces minimum number of necessary observations in a quadrant to 1 when <code>(obs.req = 1)</code>.</p>
</td></tr>
<tr><td><code id="NNS.part_+3A_min.obs.stop">min.obs.stop</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Stopping condition where quadrants will not be further partitioned if a single cluster contains less than the entered value of <code>obs.req</code>.</p>
</td></tr>
<tr><td><code id="NNS.part_+3A_noise.reduction">noise.reduction</code></td>
<td>
<p>the method of determining regression points options for the dependent variable <code>y</code>: (&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, &quot;off&quot;); <code>(noise.reduction = "mean")</code> uses means for partitions.  <code>(noise.reduction = "median")</code> uses medians instead of means for partitions, while <code>(noise.reduction = "mode")</code> uses modes instead of means for partitions.  Defaults to <code>(noise.reduction = "off")</code> where an overall central tendency measure is used, which is the default for the independent variable <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns:
</p>

<ul>
<li><p><code>"dt"</code> a <a href="data.table.html#topic+data.table">data.table</a> of <code>x</code> and <code>y</code> observations with their partition assignment <code>"quadrant"</code> in the 3rd column and their prior partition assignment <code>"prior.quadrant"</code> in the 4th column.
</p>
</li>
<li><p><code>"regression.points"</code> the <a href="data.table.html#topic+data.table">data.table</a> of regression points for that given <code>(order = ...)</code>.
</p>
</li>
<li><p><code>"order"</code>  the <code>order</code> of the final partition given <code>"min.obs.stop"</code> stopping condition.
</p>
</li></ul>



<h3>Note</h3>

<p><code>min.obs.stop = FALSE</code> will not generate regression points due to unequal partitioning of quadrants from individual cluster observations.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.part(x, y)

## Data.table of observations and partitions
NNS.part(x, y, order = 1)$dt

## Regression points
NNS.part(x, y, order = 1)$regression.points

## Voronoi style plot
NNS.part(x, y, Voronoi = TRUE)

## Examine final counts by quadrant
DT &lt;- NNS.part(x, y)$dt
DT[ , counts := .N, by = quadrant]
DT

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.reg'>NNS Regression</h2><span id='topic+NNS.reg'></span>

<h3>Description</h3>

<p>Generates a nonlinear regression based on partial moment quadrant means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.reg(
  x,
  y,
  factor.2.dummy = TRUE,
  order = NULL,
  stn = 0.95,
  dim.red.method = NULL,
  tau = NULL,
  type = NULL,
  point.est = NULL,
  location = "top",
  return.values = TRUE,
  plot = TRUE,
  plot.regions = FALSE,
  residual.plot = TRUE,
  confidence.interval = NULL,
  threshold = 0,
  n.best = NULL,
  noise.reduction = "off",
  dist = "L2",
  ncores = NULL,
  point.only = FALSE,
  multivariate.call = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.reg_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data frame of variables of numeric or factor data types.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_y">y</code></td>
<td>
<p>a numeric or factor vector with compatible dimensions to <code>x</code>.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_factor.2.dummy">factor.2.dummy</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Automatically augments variable matrix with numerical dummy variables based on the levels of factors.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_order">order</code></td>
<td>
<p>integer; Controls the number of partial moment quadrant means.  Users are encouraged to try different <code>(order = ...)</code> integer settings with <code>(noise.reduction = "off")</code>.  <code>(order = "max")</code> will force a limit condition perfect fit.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_stn">stn</code></td>
<td>
<p>numeric [0, 1]; Signal to noise parameter, sets the threshold of <code>(NNS.dep)</code> which reduces <code>("order")</code> when <code>(order = NULL)</code>.  Defaults to 0.95 to ensure high dependence for higher <code>("order")</code> and endpoint determination.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_dim.red.method">dim.red.method</code></td>
<td>
<p>options: (&quot;cor&quot;, &quot;NNS.dep&quot;, &quot;NNS.caus&quot;, &quot;all&quot;, &quot;equal&quot;, <code>numeric vector</code>, NULL) method for determining synthetic X* coefficients.  Selection of a method automatically engages the dimension reduction regression.  The default is <code>NULL</code> for full multivariate regression.  <code>(dim.red.method = "NNS.dep")</code> uses <a href="#topic+NNS.dep">NNS.dep</a> for nonlinear dependence weights, while <code>(dim.red.method = "NNS.caus")</code> uses <a href="#topic+NNS.caus">NNS.caus</a> for causal weights.  <code>(dim.red.method = "cor")</code> uses standard linear correlation for weights.  <code>(dim.red.method = "all")</code> averages all methods for further feature engineering.  <code>(dim.red.method = "equal")</code> uses unit weights.  Alternatively, user can specify a numeric vector of coefficients.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_tau">tau</code></td>
<td>
<p>options(&quot;ts&quot;, NULL); <code>NULL</code>(default) To be used in conjunction with <code>(dim.red.method = "NNS.caus")</code> or <code>(dim.red.method = "all")</code>.  If the regression is using time-series data, set <code>(tau = "ts")</code> for more accurate causal analysis.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_type">type</code></td>
<td>
<p><code>NULL</code> (default).  To perform a classification, set to <code>(type = "CLASS")</code>.  Like a logistic regression, it is not necessary for target variable of two classes e.g. [0, 1].</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_point.est">point.est</code></td>
<td>
<p>a numeric or factor vector with compatible dimensions to <code>x</code>.  Returns the fitted value <code>y.hat</code> for any value of <code>x</code>.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_location">location</code></td>
<td>
<p>Sets the legend location within the plot, per the <code>x</code> and <code>y</code> co-ordinates used in base graphics <a href="graphics.html#topic+legend">legend</a>.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_return.values">return.values</code></td>
<td>
<p>logical; <code>TRUE</code> (default), set to <code>FALSE</code> in order to only display a regression plot and call values as needed.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_plot">plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) To plot regression.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_plot.regions">plot.regions</code></td>
<td>
<p>logical; <code>FALSE</code> (default).  Generates 3d regions associated with each regression point for multivariate regressions.  Note, adds significant time to routine.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_residual.plot">residual.plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) To plot <code>y.hat</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_confidence.interval">confidence.interval</code></td>
<td>
<p>numeric [0, 1]; <code>NULL</code> (default) Plots the associated confidence interval with the estimate and reports the standard error for each individual segment.  Also applies the same level for the prediction intervals.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_threshold">threshold</code></td>
<td>
<p>numeric [0, 1]; <code>(threshold = 0)</code> (default) Sets the threshold for dimension reduction of independent variables when <code>(dim.red.method)</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_n.best">n.best</code></td>
<td>
<p>integer; <code>NULL</code> (default) Sets the number of nearest regression points to use in weighting for multivariate regression at <code>sqrt(# of regressors)</code>.  <code>(n.best = "all")</code> will select and weight all generated regression points.  Analogous to <code>k</code> in a
<code>k Nearest Neighbors</code> algorithm.  Different values of <code>n.best</code> are tested using cross-validation in <a href="#topic+NNS.stack">NNS.stack</a>.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_noise.reduction">noise.reduction</code></td>
<td>
<p>the method of determining regression points options: (&quot;mean&quot;, &quot;median&quot;, &quot;mode&quot;, &quot;off&quot;); In low signal:noise situations,<code>(noise.reduction = "mean")</code>  uses means for <a href="#topic+NNS.dep">NNS.dep</a> restricted partitions, <code>(noise.reduction = "median")</code> uses medians instead of means for <a href="#topic+NNS.dep">NNS.dep</a> restricted partitions, while <code>(noise.reduction = "mode")</code>  uses modes instead of means for <a href="#topic+NNS.dep">NNS.dep</a> restricted partitions.  <code>(noise.reduction = "off")</code> uses an overall central tendency measure for partitions.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_dist">dist</code></td>
<td>
<p>options:(&quot;L1&quot;, &quot;L2&quot;, &quot;FACTOR&quot;) the method of distance calculation; Selects the distance calculation used. <code>dist = "L2"</code> (default) selects the Euclidean distance and <code>(dist = "L1")</code> selects the Manhattan distance; <code>(dist = "FACTOR")</code> uses a frequency.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_ncores">ncores</code></td>
<td>
<p>integer; value specifying the number of cores to be used in the parallelized  procedure. If NULL (default), the number of cores to be used is equal to the number of cores of the machine - 1.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_point.only">point.only</code></td>
<td>
<p>Internal argument for abbreviated output.</p>
</td></tr>
<tr><td><code id="NNS.reg_+3A_multivariate.call">multivariate.call</code></td>
<td>
<p>Internal argument for multivariate regressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>UNIVARIATE REGRESSION RETURNS THE FOLLOWING VALUES:
</p>

<ul>
<li><p><code>"R2"</code> provides the goodness of fit;
</p>
</li>
<li><p><code>"SE"</code> returns the overall standard error of the estimate between <code>y</code> and <code>y.hat</code>;
</p>
</li>
<li><p><code>"Prediction.Accuracy"</code> returns the correct rounded <code>"Point.est"</code> used in classifications versus the categorical <code>y</code>;
</p>
</li>
<li><p><code>"derivative"</code> for the coefficient of the <code>x</code> and its applicable range;
</p>
</li>
<li><p><code>"Point.est"</code> for the predicted value generated;
</p>
</li>
<li><p><code>"pred.int"</code> lower and upper prediction intervals for the <code>"Point.est"</code> returned using the <code>"confidence.interval"</code> provided;
</p>
</li>
<li><p><code>"regression.points"</code> provides the points used in the regression equation for the given order of partitions;
</p>
</li>
<li><p><code>"Fitted.xy"</code> returns a <a href="data.table.html#topic+data.table">data.table</a> of <code>x</code>, <code>y</code>, <code>y.hat</code>, <code>resid</code>, <code>NNS.ID</code>, <code>gradient</code>;
</p>
</li></ul>

<p>MULTIVARIATE REGRESSION RETURNS THE FOLLOWING VALUES:
</p>

<ul>
<li><p><code>"R2"</code> provides the goodness of fit;
</p>
</li>
<li><p><code>"equation"</code> returns the numerator of the synthetic X* dimension reduction equation as a <a href="data.table.html#topic+data.table">data.table</a> consisting of regressor and its coefficient.  Denominator is simply the length of all coefficients &gt; 0, returned in last row of <code>equation</code> data.table.
</p>
</li>
<li><p><code>"x.star"</code> returns the synthetic X* as a vector;
</p>
</li>
<li><p><code>"rhs.partitions"</code> returns the partition points for each regressor <code>x</code>;
</p>
</li>
<li><p><code>"RPM"</code> provides the Regression Point Matrix, the points for each <code>x</code> used in the regression equation for the given order of partitions;
</p>
</li>
<li><p><code>"Point.est"</code> returns the predicted value generated;
</p>
</li>
<li><p><code>"pred.int"</code> lower and upper prediction intervals for the <code>"Point.est"</code> returned using the <code>"confidence.interval"</code> provided;
</p>
</li>
<li><p><code>"Fitted.xy"</code> returns a <a href="data.table.html#topic+data.table">data.table</a> of <code>x</code>,<code>y</code>, <code>y.hat</code>, <code>gradient</code>, and <code>NNS.ID</code>.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> Please ensure <code>point.est</code> is of compatible dimensions to <code>x</code>, error message will ensue if not compatible.
</p>
</li>
<li><p> Like a logistic regression, the <code>(type = "CLASS")</code> setting is not necessary for target variable of two classes e.g. [0, 1].  The response variable base category should be 1 for classification problems.
</p>
</li>
<li><p> For low signal:noise instances, increasing the dimension may yield better results using <code>NNS.stack(cbind(x,x), y, method = 1, ...)</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Vinod, H. and Viole, F. (2017) &quot;Nonparametric Regression Using Clusters&quot;
<a href="https://link.springer.com/article/10.1007/s10614-017-9713-5">https://link.springer.com/article/10.1007/s10614-017-9713-5</a>
</p>
<p>Vinod, H. and Viole, F. (2018) &quot;Clustering and Curve Fitting by Line Segments&quot;
<a href="https://www.preprints.org/manuscript/201801.0090/v1">https://www.preprints.org/manuscript/201801.0090/v1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.reg(x, y)

## Manual {order} selection
NNS.reg(x, y, order = 2)

## Maximum {order} selection
NNS.reg(x, y, order = "max")

## x-only paritioning (Univariate only)
NNS.reg(x, y, type = "XONLY")

## For Multiple Regression:
x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100)) ; y &lt;- rnorm(100)
NNS.reg(x, y, point.est = c(.25, .5, .75))

## For Multiple Regression based on Synthetic X* (Dimension Reduction):
x &lt;- cbind(rnorm(100), rnorm(100), rnorm(100)) ; y &lt;- rnorm(100)
NNS.reg(x, y, point.est = c(.25, .5, .75), dim.red.method = "cor", ncores = 1)

## IRIS dataset examples:
# Dimension Reduction:
NNS.reg(iris[,1:4], iris[,5], dim.red.method = "cor", order = 5, ncores = 1)

# Dimension Reduction using causal weights:
NNS.reg(iris[,1:4], iris[,5], dim.red.method = "NNS.caus", order = 5, ncores = 1)

# Multiple Regression:
NNS.reg(iris[,1:4], iris[,5], order = 2, noise.reduction = "off")

# Classification:
NNS.reg(iris[,1:4], iris[,5], point.est = iris[1:10, 1:4], type = "CLASS")$Point.est

## To call fitted values:
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.reg(x, y)$Fitted

## To call partial derivative (univariate regression only):
NNS.reg(x, y)$derivative

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.rescale'>NNS rescale</h2><span id='topic+NNS.rescale'></span>

<h3>Description</h3>

<p>Rescale min-max scaling output between two numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.rescale(x, a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.rescale_+3A_x">x</code></td>
<td>
<p>vector of data.</p>
</td></tr>
<tr><td><code id="NNS.rescale_+3A_a">a</code></td>
<td>
<p>numeric; lower limit.</p>
</td></tr>
<tr><td><code id="NNS.rescale_+3A_b">b</code></td>
<td>
<p>numeric; upper limit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a rescaled distribution within provided limits.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100)
NNS.rescale(x, 5, 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.SD.efficient.set'>NNS SD Efficient Set</h2><span id='topic+NNS.SD.efficient.set'></span>

<h3>Description</h3>

<p>Determines the set of stochastic dominant variables for various degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.SD.efficient.set(x, degree, type = "discrete", status = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.SD.efficient.set_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="NNS.SD.efficient.set_+3A_degree">degree</code></td>
<td>
<p>numeric options: (1, 2, 3); Degree of stochastic dominance test from (1, 2 or 3).</p>
</td></tr>
<tr><td><code id="NNS.SD.efficient.set_+3A_type">type</code></td>
<td>
<p>options: (&quot;discrete&quot;, &quot;continuous&quot;); <code>"discrete"</code> (default) selects the type of CDF.</p>
</td></tr>
<tr><td><code id="NNS.SD.efficient.set_+3A_status">status</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Prints status update message in console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns set of stochastic dominant variable names.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2016) &quot;LPM Density Functions for the Computation of the SD Efficient Set.&quot; Journal of Mathematical Finance, 6, 105-126.  DOI: <a href="https://doi.org/10.4236/jmf.2016.61012">doi:10.4236/jmf.2016.61012</a>.
</p>
<p>Viole, F. (2017) &quot;A Note on Stochastic Dominance.&quot; <a href="https://www.ssrn.com/abstract=3002675">https://www.ssrn.com/abstract=3002675</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y&lt;-rnorm(100) ; z&lt;-rnorm(100)
A &lt;- cbind(x, y, z)
NNS.SD.efficient.set(A, 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.seas'>NNS Seasonality Test</h2><span id='topic+NNS.seas'></span>

<h3>Description</h3>

<p>Seasonality test based on the coefficient of variation for the variable and lagged component series.  A result of 1 signifies no seasonality present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.seas(variable, modulo = NULL, mod.only = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.seas_+3A_variable">variable</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.seas_+3A_modulo">modulo</code></td>
<td>
<p>integer(s); NULL (default) Used to find the nearest multiple(s) in the reported seasonal period.</p>
</td></tr>
<tr><td><code id="NNS.seas_+3A_mod.only">mod.only</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Limits the number of seasonal periods returned to the specified <code>modulo</code>.</p>
</td></tr>
<tr><td><code id="NNS.seas_+3A_plot">plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Returns the plot of all periods exhibiting seasonality and the variable level reference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of all periods exhibiting less coefficient of variation than the variable with <code>"all.periods"</code>; and the single period exhibiting the least coefficient of variation versus the variable with <code>"best.period"</code>; as well as a vector of <code>"periods"</code> for easy call into <a href="#topic+NNS.ARMA.optim">NNS.ARMA.optim</a>.  If no seasonality is detected, <code>NNS.seas</code> will return (&quot;No Seasonality Detected&quot;).
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100)

## To call strongest period based on coefficient of variation:
NNS.seas(x, plot = FALSE)$best.period

## Using modulos for logical seasonal inference:
NNS.seas(x, modulo = c(2,3,5,7), plot = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.SSD'>NNS SSD Test</h2><span id='topic+NNS.SSD'></span>

<h3>Description</h3>

<p>Bi-directional test of second degree stochastic dominance using lower partial moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.SSD(x, y, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.SSD_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.SSD_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.SSD_+3A_plot">plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) plots the SSD test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns one of the following SSD results: <code>"X SSD Y"</code>, <code>"Y SSD X"</code>, or <code>"NO SSD EXISTS"</code>.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2016) &quot;LPM Density Functions for the Computation of the SD Efficient Set.&quot; Journal of Mathematical Finance, 6, 105-126. DOI: <a href="https://doi.org/10.4236/jmf.2016.61012">doi:10.4236/jmf.2016.61012</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.SSD(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.SSD.uni'>NNS SSD Test uni-directional</h2><span id='topic+NNS.SSD.uni'></span>

<h3>Description</h3>

<p>Uni-directional test of second degree stochastic dominance using lower partial moments used in SD Efficient Set routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.SSD.uni(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.SSD.uni_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.SSD.uni_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (1) if <code>"X SSD Y"</code>, else (0).
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2016) &quot;LPM Density Functions for the Computation of the SD Efficient Set.&quot; Journal of Mathematical Finance, 6, 105-126.  DOI: <a href="https://doi.org/10.4236/jmf.2016.61012">doi:10.4236/jmf.2016.61012</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.SSD.uni(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.stack'>NNS Stack</h2><span id='topic+NNS.stack'></span>

<h3>Description</h3>

<p>Prediction model using the predictions of the NNS base models <a href="#topic+NNS.reg">NNS.reg</a> as features (i.e. meta-features) for the stacked model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.stack(
  IVs.train,
  DV.train,
  IVs.test = NULL,
  type = NULL,
  obj.fn = expression(sum((predicted - actual)^2)),
  objective = "min",
  optimize.threshold = TRUE,
  dist = "L2",
  CV.size = NULL,
  balance = FALSE,
  ts.test = NULL,
  folds = 5,
  order = NULL,
  norm = NULL,
  method = c(1, 2),
  stack = TRUE,
  dim.red.method = "cor",
  pred.int = NULL,
  status = TRUE,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.stack_+3A_ivs.train">IVs.train</code></td>
<td>
<p>a vector, matrix or data frame of variables of numeric or factor data types.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_dv.train">DV.train</code></td>
<td>
<p>a numeric or factor vector with compatible dimensions to <code>(IVs.train)</code>.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_ivs.test">IVs.test</code></td>
<td>
<p>a vector, matrix or data frame of variables of numeric or factor data types with compatible dimensions to <code>(IVs.train)</code>.  If NULL, will use <code>(IVs.train)</code> as default.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_type">type</code></td>
<td>
<p><code>NULL</code> (default).  To perform a classification of discrete integer classes from factor target variable <code>(DV.train)</code> with a base category of 1, set to <code>(type = "CLASS")</code>, else for continuous <code>(DV.train)</code> set to <code>(type = NULL)</code>.   Like a logistic regression, this setting is not necessary for target variable of two classes e.g. [0, 1].</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_obj.fn">obj.fn</code></td>
<td>
<p>expression; <code>expression(sum((predicted - actual)^2))</code> (default) Sum of squared errors is the default objective function.  Any <code>expression()</code> using the specific terms <code>predicted</code> and <code>actual</code> can be used.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_objective">objective</code></td>
<td>
<p>options: (&quot;min&quot;, &quot;max&quot;) <code>"min"</code> (default) Select whether to minimize or maximize the objective function <code>obj.fn</code>.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_optimize.threshold">optimize.threshold</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Will optimize the probability threshold value for rounding in classification problems.  If <code>FALSE</code>, returns 0.5.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_dist">dist</code></td>
<td>
<p>options:(&quot;L1&quot;, &quot;L2&quot;, &quot;DTW&quot;, &quot;FACTOR&quot;) the method of distance calculation; Selects the distance calculation used. <code>dist = "L2"</code> (default) selects the Euclidean distance and <code>(dist = "L1")</code> selects the Manhattan distance; <code>(dist = "DTW")</code> selects the dynamic time warping distance; <code>(dist = "FACTOR")</code> uses a frequency.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_cv.size">CV.size</code></td>
<td>
<p>numeric [0, 1]; <code>NULL</code> (default) Sets the cross-validation size if <code>(IVs.test = NULL)</code>.  Defaults to a random value between 0.2 and 0.33 for a random sampling of the training set.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_balance">balance</code></td>
<td>
<p>logical; <code>FALSE</code> (default) Uses both up and down sampling from <code>caret</code> to balance the classes.  <code>type="CLASS"</code> required.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_ts.test">ts.test</code></td>
<td>
<p>integer; NULL (default) Sets the length of the test set for time-series data; typically <code>2*h</code> parameter value from <a href="#topic+NNS.ARMA">NNS.ARMA</a> or double known periods to forecast.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_folds">folds</code></td>
<td>
<p>integer; <code>folds = 5</code> (default) Select the number of cross-validation folds.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_order">order</code></td>
<td>
<p>options: (integer, &quot;max&quot;, NULL); <code>NULL</code> (default) Sets the order for <a href="#topic+NNS.reg">NNS.reg</a>, where <code>(order = "max")</code> is the k-nearest neighbors equivalent, which is suggested for mixed continuous and discrete (unordered, ordered) data.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_norm">norm</code></td>
<td>
<p>options: (&quot;std&quot;, &quot;NNS&quot;, NULL); <code>NULL</code> (default) 3 settings offered: <code>NULL</code>, <code>"std"</code>, and <code>"NNS"</code>.  Selects the <code>norm</code> parameter in <a href="#topic+NNS.reg">NNS.reg</a>.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_method">method</code></td>
<td>
<p>numeric options: (1, 2); Select the NNS method to include in stack.  <code>(method = 1)</code> selects <a href="#topic+NNS.reg">NNS.reg</a>; <code>(method = 2)</code> selects <a href="#topic+NNS.reg">NNS.reg</a> dimension reduction regression.  Defaults to <code>method = c(1, 2)</code>, which will reduce the dimension first, then find the optimal <code>n.best</code>.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_stack">stack</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Uses dimension reduction output in <code>n.best</code> optimization, otherwise performs both analyses independently.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_dim.red.method">dim.red.method</code></td>
<td>
<p>options: (&quot;cor&quot;, &quot;NNS.dep&quot;, &quot;NNS.caus&quot;, &quot;equal&quot;, &quot;all&quot;) method for determining synthetic X* coefficients.  <code>(dim.red.method = "cor")</code> uses standard linear correlation for weights.  <code>(dim.red.method = "NNS.dep")</code> (default) uses <a href="#topic+NNS.dep">NNS.dep</a> for nonlinear dependence weights, while <code>(dim.red.method = "NNS.caus")</code> uses <a href="#topic+NNS.caus">NNS.caus</a> for causal weights.  <code>(dim.red.method = "all")</code> averages all methods for further feature engineering.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_pred.int">pred.int</code></td>
<td>
<p>numeric [0,1]; <code>NULL</code> (default) Returns the associated prediction intervals with each <code>method</code>.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_status">status</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Prints status update message in console.</p>
</td></tr>
<tr><td><code id="NNS.stack_+3A_ncores">ncores</code></td>
<td>
<p>integer; value specifying the number of cores to be used in the parallelized subroutine <a href="#topic+NNS.reg">NNS.reg</a>. If NULL (default), the number of cores to be used is equal to the number of cores of the machine - 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of fitted values for the dependent variable test set for all models.
</p>

<ul>
<li><p><code>"NNS.reg.n.best"</code> returns the optimum <code>"n.best"</code> parameter for the <a href="#topic+NNS.reg">NNS.reg</a> multivariate regression.  <code>"SSE.reg"</code> returns the SSE for the <a href="#topic+NNS.reg">NNS.reg</a> multivariate regression.
</p>
</li>
<li><p><code>"OBJfn.reg"</code> returns the <code>obj.fn</code> for the <a href="#topic+NNS.reg">NNS.reg</a> regression.
</p>
</li>
<li><p><code>"NNS.dim.red.threshold"</code> returns the optimum <code>"threshold"</code> from the <a href="#topic+NNS.reg">NNS.reg</a> dimension reduction regression.
</p>
</li>
<li><p><code>"OBJfn.dim.red"</code> returns the <code>obj.fn</code> for the <a href="#topic+NNS.reg">NNS.reg</a> dimension reduction regression.
</p>
</li>
<li><p><code>"probability.threshold"</code> returns the optimum probability threshold for classification, else 0.5 when set to <code>FALSE</code>.
</p>
</li>
<li><p><code>"reg"</code> returns <a href="#topic+NNS.reg">NNS.reg</a> output.
</p>
</li>
<li><p><code>"reg.pred.int"</code> returns the prediction intervals for the regression output.
</p>
</li>
<li><p><code>"dim.red"</code> returns <a href="#topic+NNS.reg">NNS.reg</a> dimension reduction regression output.
</p>
</li>
<li><p><code>"dim.red.pred.int"</code> returns the prediction intervals for the dimension reduction regression output.
</p>
</li>
<li><p><code>"stack"</code> returns the output of the stacked model.
</p>
</li>
<li><p><code>"pred.int"</code> returns the prediction intervals for the stacked model.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li><p> Incorporate any objective function from external packages (such as <code>Metrics::mape</code>) via <code>NNS.stack(..., obj.fn = expression(Metrics::mape(actual, predicted)), objective = "min")</code>
</p>
</li>
<li><p> Like a logistic regression, the <code>(type = "CLASS")</code> setting is not necessary for target variable of two classes e.g. [0, 1].  The response variable base category should be 1 for multiple class problems.
</p>
</li>
<li><p> Missing data should be handled prior as well using <a href="stats.html#topic+na.omit">na.omit</a> or <a href="stats.html#topic+complete.cases">complete.cases</a> on the full dataset.
</p>
</li></ul>

<p>If error received:
</p>
<p><code>"Error in is.data.frame(x) : object 'RP' not found"</code>
</p>
<p>reduce the <code>CV.size</code>.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. (2016) &quot;Classification Using NNS Clustering Analysis&quot;
<a href="https://www.ssrn.com/abstract=2864711">https://www.ssrn.com/abstract=2864711</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Using 'iris' dataset where test set [IVs.test] is 'iris' rows 141:150.
 ## Not run: 
 NNS.stack(iris[1:140, 1:4], iris[1:140, 5], IVs.test = iris[141:150, 1:4], type = "CLASS")

 ## Using 'iris' dataset to determine [n.best] and [threshold] with no test set.
 NNS.stack(iris[ , 1:4], iris[ , 5], type = "CLASS")

 ## Selecting NNS.reg and dimension reduction techniques.
 NNS.stack(iris[1:140, 1:4], iris[1:140, 5], iris[141:150, 1:4], method = c(1, 2), type = "CLASS")
 
## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.term.matrix'>NNS Term Matrix</h2><span id='topic+NNS.term.matrix'></span>

<h3>Description</h3>

<p>Generates a term matrix for text classification use in <a href="#topic+NNS.reg">NNS.reg</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.term.matrix(x, oos = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.term.matrix_+3A_x">x</code></td>
<td>
<p>mixed data.frame; character/numeric; A two column dataset should be used.  Concatenate text from original sources to comply with format.  Also note the possibility of factors in <code>"DV"</code>, so <code>"as.numeric(as.character(...))"</code> is used to avoid issues.</p>
</td></tr>
<tr><td><code id="NNS.term.matrix_+3A_oos">oos</code></td>
<td>
<p>mixed data.frame; character/numeric; Out-of-sample text dataset to be classified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the text as independent variables <code>"IV"</code> and the classification as the dependent variable <code>"DV"</code>.  Out-of-sample independent variables are returned with <code>"OOS"</code>.
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- data.frame(cbind(c("sunny", "rainy"), c(1, -1)))
NNS.term.matrix(x)

### Concatenate Text with space separator, cbind with "DV"
x &lt;- data.frame(cbind(c("sunny", "rainy"), c("windy", "cloudy"), c(1, -1)))
x &lt;- data.frame(cbind(paste(x[ , 1], x[ , 2], sep = " "), as.numeric(as.character(x[ , 3]))))
NNS.term.matrix(x)

### NYT Example
require(RTextTools)
data(NYTimes)

### Concatenate Columns 3 and 4 containing text, with column 5 as DV
NYT &lt;- data.frame(cbind(paste(NYTimes[ , 3], NYTimes[ , 4], sep = " "),
                     as.numeric(as.character(NYTimes[ , 5]))))
NNS.term.matrix(NYT)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.TSD'>NNS TSD Test</h2><span id='topic+NNS.TSD'></span>

<h3>Description</h3>

<p>Bi-directional test of third degree stochastic dominance using lower partial moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.TSD(x, y, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.TSD_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.TSD_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.TSD_+3A_plot">plot</code></td>
<td>
<p>logical; <code>TRUE</code> (default) plots the TSD test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns one of the following TSD results: <code>"X TSD Y"</code>, <code>"Y TSD X"</code>, or <code>"NO TSD EXISTS"</code>.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2016) &quot;LPM Density Functions for the Computation of the SD Efficient Set.&quot; Journal of Mathematical Finance, 6, 105-126.  DOI: <a href="https://doi.org/10.4236/jmf.2016.61012">doi:10.4236/jmf.2016.61012</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.TSD(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.TSD.uni'>NNS TSD Test uni-directional</h2><span id='topic+NNS.TSD.uni'></span>

<h3>Description</h3>

<p>Uni-directional test of third degree stochastic dominance using lower partial moments used in SD Efficient Set routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.TSD.uni(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.TSD.uni_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="NNS.TSD.uni_+3A_y">y</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (1) if <code>"X TSD Y"</code>, else (0).
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2016) &quot;LPM Density Functions for the Computation of the SD Efficient Set.&quot; Journal of Mathematical Finance, 6, 105-126.  DOI: <a href="https://doi.org/10.4236/jmf.2016.61012">doi:10.4236/jmf.2016.61012</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100)
NNS.TSD.uni(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='NNS.VAR'>NNS VAR</h2><span id='topic+NNS.VAR'></span>

<h3>Description</h3>

<p>Nonparametric vector autoregressive model incorporating <a href="#topic+NNS.ARMA">NNS.ARMA</a> estimates of variables into <a href="#topic+NNS.reg">NNS.reg</a> for a multi-variate time-series forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNS.VAR(
  variables,
  h,
  tau = 1,
  dim.red.method = "cor",
  naive.weights = TRUE,
  obj.fn = expression(mean((predicted - actual)^2)/(NNS::Co.LPM(1, predicted, actual,
    target_x = mean(predicted), target_y = mean(actual)) + NNS::Co.UPM(1, predicted,
    actual, target_x = mean(predicted), target_y = mean(actual)))),
  objective = "min",
  status = TRUE,
  ncores = NULL,
  nowcast = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNS.VAR_+3A_variables">variables</code></td>
<td>
<p>a numeric matrix or data.frame of contemporaneous time-series to forecast.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_h">h</code></td>
<td>
<p>integer; 1 (default) Number of periods to forecast. <code>(h = 0)</code> will return just the interpolated and extrapolated values.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_tau">tau</code></td>
<td>
<p>positive integer [ &gt; 0]; 1 (default) Number of lagged observations to consider for the time-series data.  Vector for single lag for each respective variable or list for multiple lags per each variable.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_dim.red.method">dim.red.method</code></td>
<td>
<p>options: (&quot;cor&quot;, &quot;NNS.dep&quot;, &quot;NNS.caus&quot;, &quot;all&quot;) method for reducing regressors via <a href="#topic+NNS.stack">NNS.stack</a>.  <code>(dim.red.method = "cor")</code> (default) uses standard linear correlation for dimension reduction in the lagged variable matrix.  <code>(dim.red.method = "NNS.dep")</code> uses <a href="#topic+NNS.dep">NNS.dep</a> for nonlinear dependence weights, while <code>(dim.red.method = "NNS.caus")</code> uses <a href="#topic+NNS.caus">NNS.caus</a> for causal weights.  <code>(dim.red.method = "all")</code> averages all methods for further feature engineering.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_naive.weights">naive.weights</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Equal weights applied to univariate and multivariate outputs in ensemble.  <code>FALSE</code> will apply weights based on the number of relevant variables detected.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_obj.fn">obj.fn</code></td>
<td>
<p>expression;
<code>expression(mean((predicted - actual)^2)) / (Sum of NNS Co-partial moments)</code> (default) MSE / co-movements is the default objective function.  Any <code>expression(...)</code> using the specific terms <code>predicted</code> and <code>actual</code> can be used.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_objective">objective</code></td>
<td>
<p>options: (&quot;min&quot;, &quot;max&quot;) <code>"min"</code> (default) Select whether to minimize or maximize the objective function <code>obj.fn</code>.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_status">status</code></td>
<td>
<p>logical; <code>TRUE</code> (default) Prints status update message in console.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_ncores">ncores</code></td>
<td>
<p>integer; value specifying the number of cores to be used in the parallelized subroutine <a href="#topic+NNS.ARMA.optim">NNS.ARMA.optim</a>. If NULL (default), the number of cores to be used is equal to the number of cores of the machine - 1.</p>
</td></tr>
<tr><td><code id="NNS.VAR_+3A_nowcast">nowcast</code></td>
<td>
<p>logical; <code>FALSE</code> (default) internal call for <a href="#topic+NNS.nowcast">NNS.nowcast</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the following matrices of forecasted variables:
</p>

<ul>
<li><p><code>"interpolated_and_extrapolated"</code> Returns a <code>data.frame</code> of the linear interpolated and <a href="#topic+NNS.ARMA">NNS.ARMA</a> extrapolated values to replace <code>NA</code> values in the original <code>variables</code> argument.  This is required for working with variables containing different frequencies, e.g. where <code>NA</code> would be reported for intra-quarterly data when indexed with monthly periods.
</p>
</li>
<li><p><code>"relevant_variables"</code> Returns the relevant variables from the dimension reduction step.
</p>
</li>
<li><p><code>"univariate"</code> Returns the univariate <a href="#topic+NNS.ARMA">NNS.ARMA</a> forecasts.
</p>
</li>
<li><p><code>"multivariate"</code> Returns the multi-variate <a href="#topic+NNS.reg">NNS.reg</a> forecasts.
</p>
</li>
<li><p><code>"ensemble"</code> Returns the ensemble of both <code>"univariate"</code> and <code>"multivariate"</code> forecasts.
</p>
</li></ul>



<h3>Note</h3>


<ul>
<li> <p><code>"Error in { : task xx failed -}"</code> should be re-run with <code>NNS.VAR(..., ncores = 1)</code>.
</p>
</li>
<li><p> Not recommended for factor variables, even after transformed to numeric.  <a href="#topic+NNS.reg">NNS.reg</a> is better suited for factor or binary regressor extrapolation.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Viole, F. (2019) &quot;Multi-variate Time-Series Forecasting: Nonparametric Vector Autoregression Using NNS&quot;
<a href="https://www.ssrn.com/abstract=3489550">https://www.ssrn.com/abstract=3489550</a>
</p>
<p>Viole, F. (2020) &quot;NOWCASTING with NNS&quot;
<a href="https://www.ssrn.com/abstract=3589816">https://www.ssrn.com/abstract=3589816</a>
</p>
<p>Viole, F. (2019) &quot;Forecasting Using NNS&quot;
<a href="https://www.ssrn.com/abstract=3382300">https://www.ssrn.com/abstract=3382300</a>
</p>
<p>Vinod, H. and Viole, F. (2017) &quot;Nonparametric Regression Using Clusters&quot;
<a href="https://link.springer.com/article/10.1007/s10614-017-9713-5">https://link.springer.com/article/10.1007/s10614-017-9713-5</a>
</p>
<p>Vinod, H. and Viole, F. (2018) &quot;Clustering and Curve Fitting by Line Segments&quot;
<a href="https://www.preprints.org/manuscript/201801.0090/v1">https://www.preprints.org/manuscript/201801.0090/v1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 
 ####################################################
 ### Standard Nonparametric Vector Autoregression ###
 ####################################################

 set.seed(123)
 x &lt;- rnorm(100) ; y &lt;- rnorm(100) ; z &lt;- rnorm(100)
 A &lt;- cbind(x = x, y = y, z = z)

 ### Using lags 1:4 for each variable
 NNS.VAR(A, h = 12, tau = 4, status = TRUE)

 ### Using lag 1 for variable 1, lag 3 for variable 2 and lag 3 for variable 3
 NNS.VAR(A, h = 12, tau = c(1,3,3), status = TRUE)

 ### Using lags c(1,2,3) for variables 1 and 3, while using lags c(4,5,6) for variable 2
 NNS.VAR(A, h = 12, tau = list(c(1,2,3), c(4,5,6), c(1,2,3)), status = TRUE)

 ### PREDICTION INTERVALS
 # Store NNS.VAR output
 nns_estimate &lt;- NNS.VAR(A, h = 12, tau = 4, status = TRUE)

 # Create bootstrap replicates using NNS.meboot
 replicates &lt;- NNS.meboot(nns_estimate$ensemble[,1], rho = seq(-1,1,.25))["replicates",]
 replicates &lt;- do.call(cbind, replicates)

 # Apply UPM.VaR and LPM.VaR for desired prediction interval...95 percent illustrated
 # Tail percentage used in first argument per {LPM.VaR} and {UPM.VaR} functions
 lower_CIs &lt;- apply(replicates, 1, function(z) LPM.VaR(0.025, 0, z))
 upper_CIs &lt;- apply(replicates, 1, function(z) UPM.VaR(0.025, 0, z))

 # View results
 cbind(nns_estimate$ensemble[,1], lower_CIs, upper_CIs)


 #########################################
 ### NOWCASTING with Mixed Frequencies ###
 #########################################

 library(Quandl)
 econ_variables &lt;- Quandl(c("FRED/GDPC1", "FRED/UNRATE", "FRED/CPIAUCSL"),type = 'ts',
                          order = "asc", collapse = "monthly", start_date = "2000-01-01")

 ### Note the missing values that need to be imputed
 head(econ_variables)
 tail(econ_variables)


 NNS.VAR(econ_variables, h = 12, tau = 12, status = TRUE)
 
## End(Not run)

</code></pre>

<hr>
<h2 id='PM.matrix'>Partial Moment Matrix</h2><span id='topic+PM.matrix'></span>

<h3>Description</h3>

<p>This function generates a co-partial moment matrix for the specified co-partial moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PM.matrix(LPM_degree, UPM_degree, target, variable, pop_adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PM.matrix_+3A_lpm_degree">LPM_degree</code></td>
<td>
<p>integer; Degree for <code>variable</code> below <code>target</code> deviations.  <code>(LPM_degree = 0)</code> is frequency, <code>(LPM_degree = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="PM.matrix_+3A_upm_degree">UPM_degree</code></td>
<td>
<p>integer; Degree for <code>variable</code> above <code>target</code> deviations.  <code>(UPM_degree = 0)</code> is frequency, <code>(UPM_degree = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="PM.matrix_+3A_target">target</code></td>
<td>
<p>numeric; Typically the mean of Variable X for classical statistics equivalences, but does not have to be. (Vectorized)  <code>(target = NULL)</code> (default) will set the target as the mean of every variable.</p>
</td></tr>
<tr><td><code id="PM.matrix_+3A_variable">variable</code></td>
<td>
<p>a numeric matrix or data.frame.</p>
</td></tr>
<tr><td><code id="PM.matrix_+3A_pop_adj">pop_adj</code></td>
<td>
<p>logical; <code>TRUE</code> Adjusts the sample co-partial moment matrices for population statistics.  Use <code>FALSE</code> for degree 0 frequency matrices.  Must be provided by user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of partial moment quadrant values (CUPM, DUPM, DLPM, CLPM), and overall covariance matrix.  Uncalled quadrants will return a matrix of zeros.
</p>


<h3>Note</h3>

<p>For divergent asymmetical <code>"D.LPM" and "D.UPM"</code> matrices, matrix is <code>D.LPM(column,row,...)</code>.
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>
<p>Viole, F. (2017) &quot;Bayes' Theorem From Partial Moments&quot;
<a href="https://www.ssrn.com/abstract=3457377">https://www.ssrn.com/abstract=3457377</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100) ; y &lt;- rnorm(100) ; z &lt;- rnorm(100)
A &lt;- cbind(x,y,z)
PM.matrix(LPM_degree = 1, UPM_degree = 1, variable = A, target = colMeans(A), pop_adj = TRUE)

## Use of vectorized numeric targets (target_x, target_y, target_z)
PM.matrix(LPM_degree = 1, UPM_degree = 1, target = c(0, 0.15, .25), variable = A, pop_adj = TRUE)

## Calling Individual Partial Moment Quadrants
cov.mtx &lt;- PM.matrix(LPM_degree = 1, UPM_degree = 1, variable = A, target = colMeans(A), 
                     pop_adj = TRUE)
cov.mtx$cupm

## Full covariance matrix
cov.mtx$cov.matrix
</code></pre>

<hr>
<h2 id='UPM'>Upper Partial Moment</h2><span id='topic+UPM'></span>

<h3>Description</h3>

<p>This function generates a univariate upper partial moment for any degree or target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPM(degree, target, variable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPM_+3A_degree">degree</code></td>
<td>
<p>integer; <code>(degree = 0)</code> is frequency, <code>(degree = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="UPM_+3A_target">target</code></td>
<td>
<p>numeric; Typically set to mean, but does not have to be. (Vectorized)</p>
</td></tr>
<tr><td><code id="UPM_+3A_variable">variable</code></td>
<td>
<p>a numeric vector.   <a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+list">list</a> type objects are not permissible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>UPM of variable
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100)
UPM(0, mean(x), x)
</code></pre>

<hr>
<h2 id='UPM.ratio'>Upper Partial Moment RATIO</h2><span id='topic+UPM.ratio'></span>

<h3>Description</h3>

<p>This function generates a standardized univariate upper partial moment for any degree or target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPM.ratio(degree, target, variable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPM.ratio_+3A_degree">degree</code></td>
<td>
<p>integer; <code>(degree = 0)</code> is frequency, <code>(degree = 1)</code> is area.</p>
</td></tr>
<tr><td><code id="UPM.ratio_+3A_target">target</code></td>
<td>
<p>numeric; Typically set to mean, but does not have to be. (Vectorized)</p>
</td></tr>
<tr><td><code id="UPM.ratio_+3A_variable">variable</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standardized UPM of variable
</p>


<h3>Author(s)</h3>

<p>Fred Viole, OVVO Financial Systems
</p>


<h3>References</h3>

<p>Viole, F. and Nawrocki, D. (2013) &quot;Nonlinear Nonparametric Statistics: Using Partial Moments&quot;
<a href="https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp">https://www.amazon.com/dp/1490523995/ref=cm_sw_su_dp</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100)
UPM.ratio(0, mean(x), x)

## Joint Upper CDF
## Not run: 
x &lt;- rnorm(5000) ; y &lt;- rnorm(5000)
plot3d(x, y, Co.UPM(0, sort(x), sort(y), x, y), col = "blue", xlab = "X", ylab = "Y",
zlab = "Probability", box = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='UPM.VaR'>UPM VaR</h2><span id='topic+UPM.VaR'></span>

<h3>Description</h3>

<p>Generates an upside value at risk (VaR) quantile based on the Upper Partial Moment ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPM.VaR(percentile, degree, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPM.VaR_+3A_percentile">percentile</code></td>
<td>
<p>numeric [0, 1]; The percentile for right-tail VaR (vectorized).</p>
</td></tr>
<tr><td><code id="UPM.VaR_+3A_degree">degree</code></td>
<td>
<p>integer; <code>(degree = 0)</code> for discrete distributions, <code>(degree = 1)</code> for continuous distributions.</p>
</td></tr>
<tr><td><code id="UPM.VaR_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value representing the point at which <code>"percentile"</code> of the area of <code>x</code> is above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- rnorm(100)

## For 5th percentile, right-tail
UPM.VaR(0.05, 0, x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
