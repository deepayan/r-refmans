<!DOCTYPE html><html><head><title>Help for package rriskDistributions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rriskDistributions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rriskDistributions-package'><p>Fitting distributions to given data or known quantiles</p></a></li>
<li><a href='#fit.cont'><p>GUI for fitting continuous distributions to given data</p></a></li>
<li><a href='#fit.perc'><p>Choosing distribution by given quantiles</p></a></li>
<li><a href='#get.beta.par'><p>Fitting parameters of a Beta distribution from two or more quantiles</p></a></li>
<li><a href='#get.cauchy.par'><p>Fitting parameters of a Cauchy distribution from two or more quantiles</p></a></li>
<li><a href='#get.chisq.par'><p>Fitting parameter of a chi-square distribution from one or more quantiles</p></a></li>
<li><a href='#get.chisqnc.par'><p>Fitting parameters of a non-central chi-square distribution from one or more quantiles</p></a></li>
<li><a href='#get.exp.par'><p>Fitting parameters of an exponential distribution from one or more quantiles</p></a></li>
<li><a href='#get.f.par'><p>Fitting parameters of a F distribution from two or more quantiles</p></a></li>
<li><a href='#get.gamma.par'><p>Fitting parameters of a gamma distribution from two or more quantiles</p></a></li>
<li><a href='#get.gompertz.par'><p>Fitting parameters of a Gompertz distribution from two or more quantiles</p></a></li>
<li><a href='#get.hyper.par'><p>Fitting parameters of a hypergeometric  distribution from three or more quantiles</p></a></li>
<li><a href='#get.lnorm.par'><p>Fitting parameters of a lognormal distribution from two or more quantiles</p></a></li>
<li><a href='#get.logis.par'><p>Fitting parameters of a logistic distribution from two or more quantiles</p></a></li>
<li><a href='#get.nbinom.par'><p>Fitting parameters of a negative binomial distribution from two or more quantiles</p></a></li>
<li><a href='#get.norm.par'><p>Fitting parameters of normal distribution from two or more quantiles</p></a></li>
<li><a href='#get.norm.sd'><p>Fitting standard deviation of a normal distribution from one or more quantiles and known mean</p></a></li>
<li><a href='#get.pert.par'><p>Fitting parameters of a pert distribution from four or more quantiles</p></a></li>
<li><a href='#get.pois.par'><p>Fitting parameter of Poisson distribution from one or more quantiles</p></a></li>
<li><a href='#get.t.par'><p>Fitting parameter of a Student's t distribution from one or more quantiles</p></a></li>
<li><a href='#get.tnorm.par'><p>Fitting parameters of truncated normal distribution from four or more quantiles</p></a></li>
<li><a href='#get.triang.par'><p>Fitting parameters of a triangular distribution from three or more quantiles</p></a></li>
<li><a href='#get.unif.par'><p>Fitting parameters of a uniform distribution from two or more quantiles</p></a></li>
<li><a href='#get.weibull.par'><p>Fitting parameters of a Weibull distribution from two or more quantiles</p></a></li>
<li><a href='#plotDiagnostics.perc'><p>Graphical tools for choosing distribution by given quantiles</p></a></li>
<li><a href='#rriskFitdist.cont'><p>Fitting univariate distributions by maximum likelihood or by matching moments</p></a></li>
<li><a href='#rriskFitdist.perc'><p>Fitting an amount of distribution families by given quantiles</p></a></li>
<li><a href='#rriskMLEdist'><p>Maximum likelihood fitting of univariate distributions</p></a></li>
<li><a href='#rriskMMEdist'><p>Fitting univariate distributions by matching moments</p></a></li>
<li><a href='#useFitdist'><p>Fitting amount continuous distributions to given univariate data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Distributions to Given Data or Known Quantiles</td>
</tr>
<tr>
<td>Description:</td>
<td>Collection of functions for fitting distributions to given data or
    by known quantiles. Two main functions fit.perc() and fit.cont() provide
    users a GUI that allows to choose a most appropriate distribution without
    any knowledge of the R syntax. Note, this package is a part of the 'rrisk'
    project.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.bfr.bund.de/cd/52158">http://www.bfr.bund.de/cd/52158</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.11.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, mc2d, eha, msm, tcltk, tkrplot</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Tcl/Tk (&gt;= 8.5), Tktable (&gt;= 2.9)</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-03-22</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'rriskDistributions-package.R'
'rriskDistributions_functions.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-03-23 12:39:48 UTC; mattflor</td>
</tr>
<tr>
<td>Author:</td>
<td>Natalia Belgorodski [aut] (STAT-UP Statistical Consulting),
  Matthias Greiner [aut, cre] (Federal Institute for Risk Assessment,
    Germany),
  Kristin Tolksdorf [aut] (Federal Institute for Risk Assessment,
    Germany),
  Katharina Schueller [aut] (STAT-UP Statistical Consulting),
  Matthias Flor [ctb] (Federal Institute for Risk Assessment, Germany),
  Lutz Göhring [ctb] (Lutz Göhring Consulting)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Greiner &lt;matthias.greiner@bfr.bund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-03-24 13:17:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='rriskDistributions-package'>Fitting distributions to given data or known quantiles</h2><span id='topic+rriskDistributions-package'></span><span id='topic+rriskDistributions'></span>

<h3>Description</h3>

<p>This packages provides a collection of functions for estimation parameters of
continuous or discrete distributions (related to the <code>rrisk</code> project)
to given data or to known quantiles.
</p>


<h3>Details</h3>

<p>This package is a part of the <code>rrisk</code> project and contains functions for
fitting distributions to given data or by known quantiles. This package does
not depend on the whole <code>rrisk</code> project and can be used separately. The
<code>rrisk</code> project can be downloaded from <a href="http://www.bfr.bund.de/cd/52158">http://www.bfr.bund.de/cd/52158</a>.
<br /> <br />
The main functions <code>fit.perc</code> and <code>fit.cont</code> call a GUI that allows users
to choose an appropriate distribution family to given data or to known quantiles
without any knowledge of the <abbr><span class="acronym">R</span></abbr> syntax.
</p>


<h3>Note</h3>

<p>Fitting by given quantiles: a typical application is the definition of a distribution based on expert
opinion on some quantiles (e.g., the 2.5th, median and 97.5th) of the trial
to be modelled. <code>rrisk</code> has a functionality, to fit all continuous or
discrete distributions simultaneously without urging the user to specify the
distribution family in advance.
</p>


<h3>Author(s)</h3>

<p>Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (Federal Institute for Risk Assessment, Germany), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (Federal Institute for Risk Assessment, Germany), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qweibull(p = c(0.025, 0.5, 0.975), shape = 2, scale = 3)
get.weibull.par(q = q)
q &lt;- stats::qweibull(p = c(0.025, 0.5, 0.975), shape = 0.01, scale = 1)
get.weibull.par(q = q)

p &lt;- c(0.025, 0.50, 0.975)
q &lt;- c(9.68, 29.2, 50.98)
fit.results &lt;- rriskFitdist.perc(p, q, show.output = FALSE)
plotDiagnostics.perc(fit.results)

p &lt;- c(0.25, 0.50, 0.75)
q &lt;- c(9.68, 29.2, 50.98)
fit.results &lt;- rriskFitdist.perc(p, q, show.output = FALSE)
plotDiagnostics.perc(fit.results)
plotDiagnostics.perc(fit.results, tolPlot = 2)

## Not run: 
  if( class(tcltk::tclRequire("Tktable")) == "tclObj" ) {
    res.fitcont &lt;- fit.cont(data2fit = rnorm(100))
    res.fitcont
  }
  if( class(tcltk::tclRequire("Tktable")) == "tclObj" ) {
    res.fitperc &lt;- fit.perc()
    res.fitperc
  }

## End(Not run)

</code></pre>

<hr>
<h2 id='fit.cont'>GUI for fitting continuous distributions to given data</h2><span id='topic+fit.cont'></span>

<h3>Description</h3>

<p>This function provides a GUI for choosing a most appropriate continuous
distribution fitted to given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.cont(data2fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.cont_+3A_data2fit">data2fit</code></td>
<td>
<p>numerical vector, data to be fitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns chosen continuous distribution, estimated parameters and data,
on which the fitting is based.
</p>


<h3>Note</h3>

<p>This function is used for defining a Monte-Carlo random variate item
(<code>mcrv</code>) in the <code>rrisk</code> project.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  if ( class(tcltk::tclRequire("Tktable")) == "tclObj" ) {
    res1 &lt;- fit.cont(data2fit = rgamma(374, 4, 0.08))
    res1

    res2 &lt;- fit.cont(data2fit = rbeta(300, shape1 = 1, shape2 = 2))
    res2

    res3 &lt;- fit.cont(data2fit = mc2d::rtriang(300, min = 1, mode = 3, max = 10))
    res3

    res4 &lt;- fit.cont(data2fit = stats::rnorm(300))
    res4
  }

## End(Not run)

</code></pre>

<hr>
<h2 id='fit.perc'>Choosing distribution by given quantiles</h2><span id='topic+fit.perc'></span>

<h3>Description</h3>

<p>This function provides a GUI for choosing a most appropriate continuous
distribution for known quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.perc(p = c(0.025, 0.5, 0.975), q = stats::qnorm(p), show.output = FALSE,
  tolPlot = 0.1, tolConv = 0.001, fit.weights = rep(1, length(p)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.perc_+3A_p">p</code></td>
<td>
<p>numerical vector of probabilities.</p>
</td></tr>
<tr><td><code id="fit.perc_+3A_q">q</code></td>
<td>
<p>numerical vector of quantiles.</p>
</td></tr>
<tr><td><code id="fit.perc_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the output of the fitting functions <code>get.distribution.par</code> will be shown.</p>
</td></tr>
<tr><td><code id="fit.perc_+3A_tolplot">tolPlot</code></td>
<td>
<p>single positive numerical value giving a tolerance for plotting graphical diagnostics. 
If the sums of the differences between the distribution percentiles and
the given percentiles are smaller than this value, the distribution will be plotted.</p>
</td></tr>
<tr><td><code id="fit.perc_+3A_tolconv">tolConv</code></td>
<td>
<p>positive numerical value, the absolute convergence tolerance for reaching zero.</p>
</td></tr>
<tr><td><code id="fit.perc_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>tolPlot</code> defines a tolerance for plotting graphical diagnostics.
If the sums of the differences between the percentiles of the estimated distribution
and the given percentiles are smaller than this value, the distribution will be plotted.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
</p>


<h3>Value</h3>

<p>Returns a named list containing a chosen distribution, its estimated parameters
and the data on which the estimation is based.
</p>


<h3>Note</h3>

<p>This function is used for defining a Monte-Carlo random variate item
(<code>mcrv</code>) in the <code>rrisk</code> project.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    chosenDistr1 &lt;- fit.perc()
    chosenDistr1
    
    chosenDistr2 &lt;- fit.perc(tolPlot = 5)
    chosenDistr2
    
    chosenDistr3 &lt;- fit.perc(p = c(0.3, 0.8, 0.9), q = c(10, 20, 40))
    chosenDistr3
    
    chosenDistr4 &lt;- fit.perc(p = c(0.3, 0.8, 0.9), q = c(10, 30, 40))
    chosenDistr4
    
    chosenDistr5 &lt;- fit.perc(p = c(0.3, 0.8, 0.9), q = c(10, 30, 40), tolPlot = 10)
    chosenDistr5

    ## Fitting a PERT distribution
    p &lt;- c(0.025, 0.5, 0.6, 0.975)
    q &lt;- round(mc2d::qpert(p = p, min = 0, mode = 3, max = 10, shape = 5), digits = 2)
    chosenDistr6 &lt;- fit.perc(p = p, q = q, tolPlot = 10)
    chosenDistr6

## End(Not run)
</code></pre>

<hr>
<h2 id='get.beta.par'>Fitting parameters of a Beta distribution from two or more quantiles</h2><span id='topic+get.beta.par'></span>

<h3>Description</h3>

<p><code>get.beta.par</code> returns the parameters of estimated beta distribution where the
<code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.beta.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE, plot = TRUE,
     tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.beta.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.beta.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.beta.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.beta.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.beta.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.beta.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.beta.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.beta.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the numbers of weightings
must be identical and should be at least two. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.beta.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>CG</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a Beta distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the eror massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good til very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pbeta</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qbeta(p = c(0.025, 0.5, 0.975), shape1 = 2, shape2 = 3)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.beta.par(q = q)
get.beta.par(q = q, scaleX = c(0.001, 0.999))
get.beta.par(q = q, fit.weights = c(10, 1, 10))
get.beta.par(q = q, fit.weights = c(1, 10, 1))
get.beta.par(q = q, fit.weights = c(100, 1, 100))
get.beta.par(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

q &lt;- stats::qbeta(p = c(0.025, 0.5, 0.975), shape1 = 1, shape2 = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.beta.par(q = q)
get.beta.par(q = q, fit.weights = c(10, 1, 10))
get.beta.par(q = q, fit.weights = c(1, 10, 1))
get.beta.par(q = q, fit.weights = c(100, 1, 100))
get.beta.par(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

q &lt;- stats::qbeta(p = c(0.025, 0.5, 0.975), shape1 = 0.3, shape2 = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.beta.par(q = q)
get.beta.par(q = q, fit.weights = c(10, 1, 10))
get.beta.par(q = q, fit.weights = c(1, 10, 1))
get.beta.par(q = q, fit.weights = c(100, 1, 100))
get.beta.par(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qbeta(p = c(0.025, 0.975), shape1 = 2, shape2 = 3)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.beta.par(p = c(0.025, 0.975), q = q)
get.beta.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
get.beta.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 10))
get.beta.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1))
get.beta.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 100))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.cauchy.par'>Fitting parameters of a Cauchy distribution from two or more quantiles</h2><span id='topic+get.cauchy.par'></span>

<h3>Description</h3>

<p><code>get.cauchy.par</code> returns the parameters of a Cauchy distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.cauchy.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
   plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.cauchy.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.cauchy.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.cauchy.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.cauchy.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.cauchy.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.cauchy.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.cauchy.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.cauchy.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least two. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the
97.5th percentile, respectively. <code>get.cauchy.par</code> uses the R function
<code>optim</code> with the method <code>L-BFGS-B</code>.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a Cauchy distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the eror massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good til very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pcauchy</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qcauchy(p = c(0.025, 0.5, 0.975), location = 0, scale = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.cauchy.par(q = q)
get.cauchy.par(q = q, scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.5, 0.5))
graphics::par(old.par)

q &lt;- stats::qcauchy(p = c(0.025, 0.5, 0.975), location = 3, scale = 5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.cauchy.par(q = q, scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.5, 0.5))
graphics::par(old.par)

q &lt;- stats::qcauchy(p = c(0.025, 0.5, 0.975), location = 0.1, scale = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.cauchy.par(q = q, scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.5, 0.5))
get.cauchy.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.5, 0.5))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qcauchy(p = c(0.025, 0.975), location = 0.1, scale = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.cauchy.par(p = c(0.025, 0.975), q = q, scaleX = c(0.5, 0.5))
get.cauchy.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1), scaleX = c(0.5, 0.5))
get.cauchy.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1), scaleX = c(0.5, 0.5))
get.cauchy.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 10), scaleX = c(0.5, 0.5))
get.cauchy.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 100), scaleX = c(0.5, 0.5))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.chisq.par'>Fitting parameter of a chi-square distribution from one or more quantiles</h2><span id='topic+get.chisq.par'></span>

<h3>Description</h3>

<p><code>get.chisq.par</code> returns the parameters of a chi-square distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.chisq.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
   plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.chisq.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.chisq.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.chisq.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.chisq.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.chisq.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.chisq.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.chisq.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1)).
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.chisq.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least one. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the
97.5th percentile, respectively. <code>get.chisq.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted, if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a chi-square distribution or missing
values (<code>NA</code>'s), if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pchisq</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qchisq(p = c(0.025, 0.5, 0.975), df = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.chisq.par(q = q)
get.chisq.par(q = q, fit.weights = c(10, 1, 10))
get.chisq.par(q = q, fit.weights = c(100, 1, 100))
get.chisq.par(q = q, fit.weights = c(1, 10, 1))
get.chisq.par(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

q &lt;- stats::qchisq(p = c(0.025, 0.5, 0.975), df = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.chisq.par(q = q, scaleX = c(0.1, 0.1))
get.chisq.par(q = q, fit.weights = c(10, 1, 10))
get.chisq.par(q = q, fit.weights = c(100, 1, 100))
get.chisq.par(q = q, fit.weights = c(1, 10, 1))
get.chisq.par(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

q &lt;- stats::qchisq(p = c(0.025, 0.5, 0.975), df = 20)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.chisq.par(q = q)
get.chisq.par(q = q, fit.weights = c(10, 1, 10))
get.chisq.par(q = q, fit.weights = c(100, 1, 100))
get.chisq.par(q = q, fit.weights =c(1, 10, 1))
get.chisq.par(q = q, fit.weights =c(1, 100, 1))
graphics::par(old.par)

## example with only one quantile
q &lt;- stats::qchisq(p = c(0.025), df = 20)
old.par &lt;- graphics::par(mfrow = c(1, 3))
get.chisq.par(p = c(0.025), q = q)
get.chisq.par(p = c(0.025), q = q, fit.weights = 10)
get.chisq.par(p = c(0.025), q = q, fit.weights = 100)
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.chisqnc.par'>Fitting parameters of a non-central chi-square distribution from one or more quantiles</h2><span id='topic+get.chisqnc.par'></span>

<h3>Description</h3>

<p><code>get.chisqnc.par</code> returns the parameters of a non-central chi-square
distribution where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.chisqnc.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
   plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.chisqnc.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.chisqnc.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.chisqnc.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.chisqnc.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.chisqnc.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.chisqnc.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.chisqnc.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.chisqnc.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weights
must be identical and should be at least one. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.chisqnc.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a non-central chi-square distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the eror massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pchisq</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qchisq(p = c(0.025, 0.5, 0.975), df = 2, ncp = 4)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.chisqnc.par(q = q)
get.chisqnc.par(q = q, scaleX = c(0.1, 0.9999999))
get.chisqnc.par(q = q, fit.weights = c(100, 1, 100))
get.chisqnc.par(q = q, fit.weights = c(10, 1, 10))
get.chisqnc.par(q = q, fit.weights = c(1, 100, 1))
get.chisqnc.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qchisq(p = c(0.025, 0.5, 0.975), df = 0.1, ncp = 0.4)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.chisqnc.par(q = q)
get.chisqnc.par(q = q, fit.weights = c(100, 1, 100))
get.chisqnc.par(q = q, fit.weights = c(10, 1, 10))
get.chisqnc.par(q = q, fit.weights = c(1, 100, 1))
get.chisqnc.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qchisq(p = c(0.025, 0.5, 0.975), df = 1, ncp = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.chisqnc.par(q = q)
get.chisqnc.par(q = q, fit.weights = c(100, 1, 100))
get.chisqnc.par(q = q, fit.weights = c(10, 1, 10))
get.chisqnc.par(q = q, fit.weights = c(1, 100, 1))
get.chisqnc.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## example with only two quantile
q &lt;- stats::qchisq(p = c(0.025, 0.95), df = 20, ncp = 20)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.chisqnc.par(p = c(0.025, 0.975), q = q)
get.chisqnc.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1))
get.chisqnc.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 100))
get.chisqnc.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
get.chisqnc.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 10))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.exp.par'>Fitting parameters of an exponential distribution from one or more quantiles</h2><span id='topic+get.exp.par'></span>

<h3>Description</h3>

<p><code>get.exp.par</code> returns the parameters of an exponential distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.exp.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.exp.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.exp.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.exp.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.exp.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.exp.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.exp.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.exp.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.exp.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least one. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the
97.5th percentile, respectively. <code>get.exp.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method <code>BFGS</code>
will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of an exponential distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the eror massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good til very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR),  <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pexp</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qexp(p = c(0.025, 0.5, 0.975), rate = 2)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.exp.par(q = q)
get.exp.par(q = q, fit.weights = c(100, 1, 100))
get.exp.par(q = q, fit.weights = c(10, 1, 10))
get.exp.par(q = q, fit.weights = c(1, 100, 1))
get.exp.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qexp(p = c(0.025, 0.5, 0.975), rate = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.exp.par(q = q)
get.exp.par(q = q, fit.weights = c(100, 1, 100))
get.exp.par(q = q, fit.weights = c(10, 1, 10))
get.exp.par(q = q, fit.weights = c(1, 100, 1))
get.exp.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qexp(p = c(0.025, 0.5, 0.975), rate = 0.001)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.exp.par(q = q)
get.exp.par(q = q, fit.weights = c(100, 1, 100))
get.exp.par(q = q, fit.weights = c(10, 1, 10))
get.exp.par(q = q, fit.weights = c(1, 100, 1))
get.exp.par(q = q, tol = 0.2, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qexp(p = c(0.025, 0.5, 0.975), rate = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.exp.par(q = q)
get.exp.par(q = q, fit.weights = c(100, 1, 100))
get.exp.par(q = q, fit.weights = c(10, 1, 10))
get.exp.par(q = q, fit.weights = c(1, 100, 1))
get.exp.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## example with only one quantile
q &lt;- stats::qexp(p = c(0.025), rate = 2)
old.par &lt;- graphics::par(mfrow = c(1, 3))
get.exp.par(p = c(0.025), q = q)
get.exp.par(p = c(0.025), q = q, fit.weights = 10)
get.exp.par(p = c(0.025), q = q, fit.weights = 100)
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.f.par'>Fitting parameters of a F distribution from two or more quantiles</h2><span id='topic+get.f.par'></span>

<h3>Description</h3>

<p><code>get.f.par</code> returns the parameters of a F distribution where the
<code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.f.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
   plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.f.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.f.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.f.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.f.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.f.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.f.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.f.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.f.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least two. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.f.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>BFGS</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a F distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>stats::pf</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qf(p = c(0.025, 0.5, 0.975), df1 = 2, df2 = 10)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.f.par(q = q, scaleX = c(0.1, 0.5))
get.f.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.1, 0.5))
get.f.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.1, 0.5))
get.f.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.1, 0.5))
get.f.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.1, 0.5))
graphics::par(old.par)

q &lt;- stats::qf(p = c(0.025, 0.5, 0.975), df1 = 0.2, df2 = 0.3)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.f.par(q = q, scaleX = c(0.1, 0.2))
get.f.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.1, 0.999))
get.f.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.1, 0.2))
get.f.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.1, 0.9999))
get.f.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.1, 0.9999))
graphics::par(old.par)

q &lt;- stats::qf(p = c(0.025, 0.5, 0.975), df1 = 1, df2 = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.f.par(q = q, scaleX = c(0.1, 0.2))
get.f.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.1, 0.2))
get.f.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.1, 0.2))
get.f.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.1, 0.2))
get.f.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.1, 0.2))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qf(p = c(0.025, 0.975), df1 = 2, df2 = 3)
old.par &lt;- graphics::par(mfrow = c(1, 3))
get.f.par(p = c(0.025, 0.975), q = q)
get.f.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1))
get.f.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.gamma.par'>Fitting parameters of a gamma distribution from two or more quantiles</h2><span id='topic+get.gamma.par'></span>

<h3>Description</h3>

<p><code>get.gamma.par</code> returns the parameters of a gamma distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.gamma.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.gamma.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.gamma.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.gamma.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.gamma.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.gamma.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.gamma.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.gamma.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1)).
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.gamma.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least two. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.gamma.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>BFGS</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a gamma distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting),  <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pgamma</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qgamma(p = c(0.025, 0.5, 0.975), shape = 10, rate = 10)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.gamma.par(q = q)
get.gamma.par(q = q, scaleX = c(0.00001, 0.9999))
get.gamma.par(q = q, fit.weights = c(100, 1, 100))
get.gamma.par(q = q, fit.weights = c(10, 1, 10))
get.gamma.par(q = q, fit.weights = c(1, 100, 1))
get.gamma.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qgamma(p = c(0.025, 0.5, 0.975), shape = 0.1, rate = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.gamma.par(q = q)
get.gamma.par(q = q, fit.weights = c(100, 1, 100))
get.gamma.par(q = q, fit.weights = c(10, 1, 10))
get.gamma.par(q = q, fit.weights = c(1, 100, 1))
get.gamma.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qgamma(p = c(0.025, 0.5, 0.975), shape = 1, rate = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.gamma.par(q = q)
get.gamma.par(q = q, fit.weights = c(100, 1, 100))
get.gamma.par(q = q, fit.weights = c(10, 1, 10))
get.gamma.par(q = q, fit.weights = c(1, 100, 1))
get.gamma.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qgamma(p = c(0.025, 0.975), shape = 10, rate = 10)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.gamma.par(p = c(0.025, 0.975), q = q)
get.gamma.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1))
get.gamma.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 100))
get.gamma.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
get.gamma.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 10))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.gompertz.par'>Fitting parameters of a Gompertz distribution from two or more quantiles</h2><span id='topic+get.gompertz.par'></span>

<h3>Description</h3>

<p><code>get.gompertz.par</code> returns the parameters of a Gompertz distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.gompertz.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.gompertz.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.gompertz.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.gompertz.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.gompertz.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.gompertz.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.gompertz.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.gompertz.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.gompertz.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least two. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.gompertz.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>BFGS</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a Gompertz distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>Comply with a parametrization of this distribution. The definition of this
distribution in the literature is not unique.
<br /> <br />
</p>
<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code><a href="eha.html#topic+pgompertz">pgompertz</a></code> from the package <span class="pkg">eha</span> for distribution 
implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- eha::qgompertz(p = c(0.025, 0.5, 0.975), shape = 2, scale = 5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.gompertz.par(q = q)
get.gompertz.par(q = q, fit.weights = c(100, 1, 100))
get.gompertz.par(q = q, fit.weights = c(10, 1, 10))
get.gompertz.par(q = q, fit.weights = c(1, 100, 1))
get.gompertz.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- eha::qgompertz(p = c(0.025, 0.5, 0.975), shape = 0.2, scale = 0.5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.gompertz.par(q = q)
get.gompertz.par(q = q, fit.weights = c(100, 1, 100))
get.gompertz.par(q = q, fit.weights = c(10, 1, 10))
get.gompertz.par(q = q, fit.weights = c(1, 100, 1))
get.gompertz.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- eha::qgompertz(p = c(0.025, 0.5, 0.975), shape = 1, scale = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.gompertz.par(q = q)
get.gompertz.par(q = q, fit.weights = c(100, 1, 100))
get.gompertz.par(q = q, fit.weights = c(10, 1, 10))
get.gompertz.par(q = q, fit.weights = c(1, 100, 1))
get.gompertz.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## example with only two quantiles
q &lt;- eha::qgompertz(p = c(0.025, 0.975), shape = 2, scale = 5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.gompertz.par(p = c(0.025, 0.975), q = q)
get.gompertz.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1), scaleX = c(0.0001, 0.9999))
get.gompertz.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 100))
get.gompertz.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
get.gompertz.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 10))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.hyper.par'>Fitting parameters of a hypergeometric  distribution from three or more quantiles</h2><span id='topic+get.hyper.par'></span>

<h3>Description</h3>

<p><code>get.hyper.par</code> returns the parameters of a hypergeometric distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.hyper.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.hyper.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.hyper.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.hyper.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.hyper.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.hyper.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.hyper.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.hyper.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.hyper.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least three. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.hyper.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a hypergeometric distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>phyper</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qhyper(p = c(0.025, 0.5, 0.975), m = 5, n = 3, k = 3)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.hyper.par(q = q)
get.hyper.par(q = q, tol = 1)
get.hyper.par(q = q, fit.weights = c(100, 1, 100))
get.hyper.par(q = q, fit.weights = c(10, 1, 10))
get.hyper.par(q = q, fit.weights = c(1, 100, 1))
get.hyper.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qhyper(p = c(0.025, 0.5, 0.975), m = 10, n = 5, k = 4)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.hyper.par(q = q)
get.hyper.par(q = q, fit.weights = c(100, 1, 100))
get.hyper.par(q = q, fit.weights = c(10, 1, 10))
get.hyper.par(q = q, fit.weights = c(1, 100, 1))
get.hyper.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.lnorm.par'>Fitting parameters of a lognormal distribution from two or more quantiles</h2><span id='topic+get.lnorm.par'></span>

<h3>Description</h3>

<p><code>get.lnorm.par</code> returns the parameters of a lognormal distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.lnorm.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.lnorm.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.lnorm.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.lnorm.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.lnorm.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.lnorm.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.lnorm.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.lnorm.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.lnorm.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least two. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.lnorm.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>Nelder-Mead</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a lognormal distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>Comply with a parametrization of this distribution. The definition of this
distribution in the literature is not unique.
<br /> <br />
</p>
<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>plnorm</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qlnorm(p = c(0.025, 0.5, 0.975), meanlog = 4, sdlog = 0.8)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.lnorm.par(q = q)
get.lnorm.par(q = q, fit.weights = c(100, 1, 100))
get.lnorm.par(q = q, fit.weights = c(10, 1, 10))
get.lnorm.par(q = q, fit.weights = c(1, 100, 1))
get.lnorm.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qlnorm(p = c(0.025, 0.5, 0.975), meanlog=-4, sdlog = 0.8)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.lnorm.par(q = q)
get.lnorm.par(q = q, fit.weights = c(100, 1, 100))
get.lnorm.par(q = q, fit.weights = c(10, 1, 10))
get.lnorm.par(q = q, fit.weights = c(1, 100, 1))
get.lnorm.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qlnorm(p = c(0.025, 0.5, 0.975), meanlog = 1, sdlog = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.lnorm.par(q = q)
get.lnorm.par(q = q, fit.weights = c(100, 1, 100))
get.lnorm.par(q = q, fit.weights = c(10, 1, 10))
get.lnorm.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.000001, 0.99999999))
get.lnorm.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qlnorm(p = c(0.025, 0.5, 0.975), meanlog = 0.1, sdlog = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.lnorm.par(q = q)
get.lnorm.par(q = q, fit.weights = c(100, 1, 100))
get.lnorm.par(q = q, fit.weights = c(10, 1, 10))
get.lnorm.par(q = q, fit.weights = c(1, 100, 1))
get.lnorm.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qlnorm(p = c(0.025, 0.975), meanlog = 4, sdlog = 0.8)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.lnorm.par(p = c(0.025, 0.975), q = q)
get.lnorm.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1), scaleX = c(0.1, 0.001))
get.lnorm.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 100), scaleX = c(0.1, 0.001))
get.lnorm.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
get.lnorm.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 10))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.logis.par'>Fitting parameters of a logistic distribution from two or more quantiles</h2><span id='topic+get.logis.par'></span>

<h3>Description</h3>

<p><code>get.logis.par</code> returns the parameters of a logistic distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.logis.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
   plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.logis.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.logis.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.logis.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.logis.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.logis.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.logis.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.logis.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.logis.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least two. Using the default <code>p</code>,
the three corresponding quantiles are the 2.5th percentile, the median and the
97.5th percentile, respectively. <code>get.logis.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>BFGS</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a logistic distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>plogis</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qlogis(p = c(0.025, 0.5, 0.975), location = 0, scale = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.logis.par(q = q)
get.logis.par(q = q, scaleX = c(0.5, 0.5))
get.logis.par(q = q, fit.weights = c(100, 1, 100))
get.logis.par(q = q, fit.weights = c(10, 1, 10))
get.logis.par(q = q, fit.weights = c(1, 100, 1))
get.logis.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qlogis(p = c(0.025, 0.5, 0.975), location = 0, scale = 3)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.logis.par(q = q)
get.logis.par(q = q, fit.weights = c(100, 1, 100))
get.logis.par(q = q, fit.weights = c(10, 1, 10))
get.logis.par(q = q, fit.weights = c(1, 100, 1))
get.logis.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qlogis(p = c(0.025, 0.975), location = 0, scale = 3)
old.par &lt;- graphics::par(mfrow = c(1, 3))
get.logis.par(p = c(0.025, 0.975), q = q)
get.logis.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1))
get.logis.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.nbinom.par'>Fitting parameters of a negative binomial distribution from two or more quantiles</h2><span id='topic+get.nbinom.par'></span>

<h3>Description</h3>

<p><code>get.nbinom.par</code> returns the parameters of a negative binomial distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.nbinom.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.nbinom.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.nbinom.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.nbinom.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.nbinom.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.nbinom.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.nbinom.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.nbinom.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.nbinom.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least two. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.nbinom.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a negative binomial distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pnbinom</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qnbinom(p = c(0.025, 0.5, 0.975), size = 10, prob = 0.5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.nbinom.par(q = q)
get.nbinom.par(q = q, fit.weights = c(100, 1, 100))
get.nbinom.par(q = q, fit.weights = c(1, 100, 1))
get.nbinom.par(q = q, fit.weights = c(10, 1, 10))
get.nbinom.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qnbinom(p = c(0.025, 0.5, 0.975), size = 1, prob = 0.5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.nbinom.par(q = q, tol = 0.01)
get.nbinom.par(q = q, fit.weights = c(100, 1, 100))
get.nbinom.par(q = q, fit.weights = c(1, 100, 1), tol = 0.01)
get.nbinom.par(q = q, fit.weights = c(10, 1, 10), tol = 0.01)
get.nbinom.par(q = q, fit.weights = c(1, 10, 1), tol = 0.01)
graphics::par(old.par)

q &lt;- stats::qnbinom(p = c(0.025, 0.5, 0.975), size = 1, prob = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.nbinom.par(q = q)
get.nbinom.par(q = q, fit.weights = c(100, 1, 100))
get.nbinom.par(q = q, fit.weights = c(1, 100, 1))
get.nbinom.par(q = q, fit.weights = c(10, 1, 10))
get.nbinom.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qnbinom(p = c(0.025, 0.975), size = 10, prob = 0.5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.nbinom.par(p = c(0.025, 0.975), q = q,)
get.nbinom.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1))
get.nbinom.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 100))
get.nbinom.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
get.nbinom.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 10))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.norm.par'>Fitting parameters of normal distribution from two or more quantiles</h2><span id='topic+get.norm.par'></span>

<h3>Description</h3>

<p><code>get.norm.par</code> returns the parameters of a normal distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.norm.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE, 
   plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.norm.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.norm.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.norm.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.norm.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.norm.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.norm.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.norm.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.norm.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings 
must be identical and should be at least two. Using the default <code>p</code>, the 
three corresponding quantiles are the 2.5th percentile, the median and the 
97.5th percentile, respectively. <code>get.norm.par</code> uses the R function <code>optim</code> with the
method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>BFGS</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item 
<code>value</code> displays the achieved minimal value of the functions that were minimized. 
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component 
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1. 
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a normal distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated 
and the theoretical distribution parameters in certain circumstances. This is 
because the estimation of the parameters is based on a numerical optimization 
method and depends strongly on the initial values. In addition, one must always 
keep in mind that a distribution for different combinations of parameters may 
look very similar. Therefore, the optimization method cannot always find the 
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or 
specified tolerance not achieved&quot;, one may try to set the convergence tolerance 
to a higher value. It is yet to be noted, that good till very good fits of parameters 
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting),  <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pnorm</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 12, sd = 34)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.par(q = q)
get.norm.par(q = q, scaleX = c(0.00001, 0.99999))
get.norm.par(q = q, fit.weights = c(10, 1, 10))
get.norm.par(q = q, fit.weights = c(1, 10, 1))
get.norm.par(q = q, fit.weights = c(100, 1, 100))
get.norm.par(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 0, sd = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.par(q = q)
get.norm.par(q = q, fit.weights = c(10, 1, 10))
get.norm.par(q = q, fit.weights = c(1, 10, 1))
get.norm.par(q = q, fit.weights = c(100, 1, 100))
get.norm.par(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 0.1, sd = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.par(q = q)
get.norm.par(q = q, fit.weights = c(10, 1, 10))
get.norm.par(q = q, fit.weights = c(1, 10, 1))
get.norm.par(q = q, fit.weights = c(100, 1, 100))
get.norm.par(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qnorm(p = c(0.025, 0.975), mean = 12, sd = 34)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.par(p = c(0.025, 0.975), q = q)
get.norm.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
get.norm.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1))
get.norm.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 10))
get.norm.par(p = c(0.025, 0.975), q = q, fit.weights = c(1, 100))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.norm.sd'>Fitting standard deviation of a normal distribution from one or more quantiles and known mean</h2><span id='topic+get.norm.sd'></span>

<h3>Description</h3>

<p><code>get.norm.sd</code> returns the standard deviation of a normal distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.norm.sd(p = c(0.025, 0.5, 0.975), q, show.output = TRUE, plot = TRUE,
                   fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.norm.sd_+3A_p">p</code></td>
<td>
<p>numeric, vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.norm.sd_+3A_q">q</code></td>
<td>
<p>numeric, vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.norm.sd_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default vaule is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.norm.sd_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.norm.sd_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.norm.sd_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.norm.sd_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities and the number of quantiles must be identical and
should be at least two. <code>get.norm.sd</code> uses the central limit theorem and
the linear regression.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>lm</code> will be shown.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function will be meaningful only if the quantile comes from a normal distribution.
</p>


<h3>Value</h3>

<p>Returns an estimated standard deviation or missing value
</p>


<h3>Note</h3>

<p>It should be noted that the data must be normally distributed, or the 
central limt theorem must hold for large (enough) samples sizes.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pnorm</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 0, sd = 2)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.sd(q = q)
get.norm.sd(q = q, scaleX = c(0.0001, 0.9999))
get.norm.sd(q = q, fit.weights = c(10, 1, 10))
get.norm.sd(q = q, fit.weights = c(1, 10, 1))
get.norm.sd(q = q, fit.weights = c(100, 1, 100))
get.norm.sd(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 176, sd = 15)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.sd(q = q)
get.norm.sd(q = q, fit.weights = c(10, 1, 10))
get.norm.sd(q = q, fit.weights = c(1, 10, 1))
get.norm.sd(q = q, fit.weights = c(100, 1, 100))
get.norm.sd(q = q, fit.weights = c(1, 100, 1))
graphics::par(old.par)

## The estimation model is not suitable for the following quantiles.
## Because the quantile is unsymmetrical, which could not be from a normally distributed data.
q &lt;- c(-2, 30, 31)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.sd(q = q)
get.norm.sd(q = q, fit.weights = c(10, 1, 10))
get.norm.sd(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.0001, 0.9999))
get.norm.sd(q = q, fit.weights = c(100, 1, 100))
get.norm.sd(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.0001, 0.9999))
graphics::par(old.par)

## Estimating from actually exponentially distributed data
x.exp &lt;- rexp(n = 10, rate = 5)
mean(x.exp)
stats::sd(x.exp)
q &lt;- quantile(x.exp, c(0.025, 0.5, 0.975))
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.norm.sd(q = q)
get.norm.sd(q = q, fit.weights = c(1, 10, 1))
get.norm.sd(q = q, fit.weights = c(10, 1, 10))
get.norm.sd(q = q, fit.weights = c(1, 100, 1))
get.norm.sd(q = q, fit.weights = c(100, 1, 100))
graphics::par(old.par)

## other examples
q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 1, sd = 1)
get.norm.sd(q = q)

q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 1, sd = 0.5)
get.norm.sd(q = q)

q &lt;- stats::qnorm(p = c(0.025, 0.5, 0.975), mean = 0.01, sd = 0.1)
get.norm.sd(q = q)

</code></pre>

<hr>
<h2 id='get.pert.par'>Fitting parameters of a pert distribution from four or more quantiles</h2><span id='topic+get.pert.par'></span>

<h3>Description</h3>

<p><code>get.pert.par</code> returns the parameters of a pert distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pert.par(p = c(0.025, 0.5, 0.6, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pert.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.pert.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.pert.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.pert.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.pert.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.pert.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.pert.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.pert.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least three. Using the default <code>p</code>,
the three corresponding quantiles are the 2.5th percentile, the median and the
97.5th percentile, respectively. <code>get.pert.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>BFGS</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a pert distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code><a href="mc2d.html#topic+ppert">ppert</a></code> from the package <span class="pkg">mc2d</span> for distribution 
implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- mc2d::qpert(p = c(0.025, 0.5, 0.6, 0.975), min = 0, mode = 3, max = 10, shape = 5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.pert.par(q = q)
get.pert.par(q = q, fit.weights = c(100, 1, 1, 100))
get.pert.par(q = q, fit.weights = c(10, 1, 1, 10))
get.pert.par(q = q, fit.weights = c(1, 100, 1, 1))
get.pert.par(q = q, fit.weights = c(1, 10, 1, 1))
graphics::par(old.par)

q &lt;- mc2d::qpert(p = c(0.025, 0.5, 0.6, 0.975), min = 1, mode = 5, max = 10, shape = 4)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.pert.par(q = q)
get.pert.par(q = q, scaleX = c(0.0001, 0.999999))
get.pert.par(q = q, fit.weights = c(100, 1, 1, 100))
get.pert.par(q = q, fit.weights = c(10, 1, 1, 10))
get.pert.par(q = q, fit.weights = c(1, 100, 1, 1))
get.pert.par(q = q, fit.weights = c(1, 10, 1, 1))
graphics::par(old.par)

q &lt;- mc2d::qpert(p = c(0.025, 0.5, 0.6, 0.975), min=-10, mode = 5, max = 10, shape = 4)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.pert.par(q = q)
get.pert.par(q = q, fit.weights = c(100, 1, 1, 100))
get.pert.par(q = q, fit.weights = c(10, 1, 1, 10))
get.pert.par(q = q, fit.weights = c(1, 100, 1, 1))
get.pert.par(q = q, fit.weights = c(1, 10, 1, 1))
graphics::par(old.par)

q &lt;- mc2d::qpert(p = c(0.025, 0.5, 0.6, 0.975), min=-10, mode = 5, max = 10, shape = 0.4)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.pert.par(q = q)
get.pert.par(q = q, fit.weights = c(100, 1, 1, 100))
get.pert.par(q = q, fit.weights = c(10, 1, 1, 10))
get.pert.par(q = q, fit.weights = c(1, 100, 1, 1))
get.pert.par(q = q, fit.weights = c(1, 10, 1, 1))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.pois.par'>Fitting parameter of Poisson distribution from one or more quantiles</h2><span id='topic+get.pois.par'></span>

<h3>Description</h3>

<p><code>get.pois.par</code> returns the parameters of a Poisson distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pois.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.pois.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities</p>
</td></tr>
<tr><td><code id="get.pois.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p</p>
</td></tr>
<tr><td><code id="get.pois.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="get.pois.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="get.pois.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>)</p>
</td></tr>
<tr><td><code id="get.pois.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.pois.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.pois.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least one. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.pois.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a Poisson distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because it is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>ppois</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qpois(p = c(0.025, 0.5, 0.975), lambda = 3)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.pois.par(q = q)
get.pois.par(q = q, fit.weights = c(100, 1, 100))
get.pois.par(q = q, fit.weights = c(10, 1, 10))
get.pois.par(q = q, fit.weights = c(1, 100, 1))
get.pois.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qpois(p = c(0.025, 0.5, 0.975), lambda = 4)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.pois.par(q = q)
get.pois.par(q = q, fit.weights = c(100, 1, 100))
get.pois.par(q = q, fit.weights = c(10, 1, 10))
get.pois.par(q = q, fit.weights = c(1, 100, 1))
get.pois.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qpois(p = c(0.025, 0.5, 0.975), lambda = 0.5)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.pois.par(q = q, tol = 1)
get.pois.par(q = q, fit.weights = c(100, 1, 100), tol = 1)
get.pois.par(q = q, fit.weights = c(10, 1, 10), tol = 1)
get.pois.par(q = q, fit.weights = c(1, 100, 1))
get.pois.par(q = q, fit.weights = c(1, 10, 1), tol = 0.01)
graphics::par(old.par)

q &lt;- stats::qpois(p = c(0.025, 0.5, 0.975), lambda = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.pois.par(q = q, tol = 0.01)
get.pois.par(q = q, fit.weights = c(100, 1, 100), tol = 0.01)
get.pois.par(q = q, fit.weights = c(10, 1, 10), tol = 0.01)
get.pois.par(q = q, fit.weights = c(1, 100, 1))
get.pois.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.t.par'>Fitting parameter of a Student's t distribution from one or more quantiles</h2><span id='topic+get.t.par'></span>

<h3>Description</h3>

<p><code>get.t.par</code> returns the parameters of a Student's t distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.t.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.t.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.t.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.t.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.t.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.t.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.t.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.t.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.t.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities and the number of quantiles must be identical
and should be at least one. Using the default <code>p</code>, the three corresponding
quantiles are the 2.5th percentile, the median and the 97.5th percentile,
respectively. <code>get.t.par</code> uses the R function <code>optim</code> with the
method <code>L-BFGS-B</code>. If this method fails the optimization method <code>BFGS</code>
will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a Student's t distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>stats::pt</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qt(p = c(0.025, 0.5, 0.975), df = 10)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.t.par(q = q)
get.t.par(q = q, fit.weights = c(100, 1, 100))
get.t.par(q = q, fit.weights = c(10, 1, 10))
get.t.par(q = q, fit.weights = c(1, 100, 1))
get.t.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qt(p = c(0.025, 0.5, 0.975), df = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.t.par(q = q, scaleX = c(0.5, 0.5))
get.t.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.5, 0.5))
get.t.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.5, 0.5))
get.t.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.5, 0.5))
get.t.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.5, 0.5))
graphics::par(old.par)

q &lt;- stats::qt(p = c(0.025, 0.5, 0.975), df = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.t.par(q = q, scaleX = c(0.5, 0.5))
get.t.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.5, 0.5))
get.t.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.5, 0.5))
get.t.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.5, 0.5))
get.t.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.5, 0.5))
graphics::par(old.par)

## example with only one quantile
q &lt;- stats::qt(p = c(0.025), df = 3)
old.par &lt;- graphics::par(mfrow = c(1, 3))
get.t.par(p = c(0.025), q = q)
get.t.par(p = c(0.025), q = q, fit.weights = 10)
get.t.par(p = c(0.025), q = q, fit.weights = 100)
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.tnorm.par'>Fitting parameters of truncated normal distribution from four or more quantiles</h2><span id='topic+get.tnorm.par'></span>

<h3>Description</h3>

<p><code>get.tnorm.par</code> returns the parameters of a truncated normal distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tnorm.par(p = c(0.025, 0.5, 0.75, 0.975), q, show.output = TRUE,
   plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.tnorm.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.tnorm.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.tnorm.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.tnorm.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.tnorm.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.tnorm.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.tnorm.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.tnorm.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least four. Using the default <code>p</code>, the
four corresponding quantiles are the 2.5th percentile, the median, the 75th
percentile and the 97.5th percentile, respectively. <code>get.tnorm.par</code> uses
the R function <code>optim</code> with the method <code>L-BFGS-B</code>. If this method
fails the optimization method <code>Nelder-Mead</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a truncated normal distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting),  <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code><a href="msm.html#topic+ptnorm">ptnomr</a></code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- msm::qtnorm(p = c(0.025, 0.5, 0.75, 0.975), mean = 3, sd = 3, lower = 0, upper = 10)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.tnorm.par(q = q)
get.tnorm.par(q = q, scaleX = c(0.1, 0.999999))
get.tnorm.par(q = q, fit.weights = c(100, 1, 1, 100))
get.tnorm.par(q = q, fit.weights = c(10, 1, 1, 10))
get.tnorm.par(q = q, fit.weights = c(1, 100, 1, 1))
get.tnorm.par(q = q, fit.weights = c(1, 10, 1, 1))
graphics::par(old.par)

q &lt;- msm::qtnorm(p = c(0.025, 0.5, 0.75, 0.975), mean = 3, sd = 0.1, lower=-1, upper = 4)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.tnorm.par(q = q)
get.tnorm.par(q = q, fit.weights = c(100, 1, 1, 100))
get.tnorm.par(q = q, fit.weights = c(10, 1, 1, 10))
get.tnorm.par(q = q, fit.weights = c(1, 100, 1, 1))
get.tnorm.par(q = q, fit.weights = c(1, 10, 1, 1))
graphics::par(old.par)

q &lt;- msm::qtnorm(p = c(0.025, 0.5, 0.75, 0.975), mean = 0, sd = 1, lower=-2, upper = 2)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.tnorm.par(q = q)
get.tnorm.par(q = q, fit.weights = c(100, 1, 1, 100))
get.tnorm.par(q = q, fit.weights = c(10, 1, 1, 10))
get.tnorm.par(q = q, fit.weights = c(1, 100, 1, 1))
get.tnorm.par(q = q, fit.weights = c(1, 10, 1, 1))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='get.triang.par'>Fitting parameters of a triangular distribution from three or more quantiles</h2><span id='topic+get.triang.par'></span>

<h3>Description</h3>

<p><code>get.triang.par</code> returns the parameters of a triangular distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.triang.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
    plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.triang.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.triang.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.triang.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.triang.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.triang.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.triang.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.triang.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.triang.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least three. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.triang.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>. If this method fails the optimization method
<code>BFGS</code> will be invoked.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a triangular distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code><a href="mc2d.html#topic+ptriang">ptriang</a></code> from the package <span class="pkg">mc2d</span> for distribution 
implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- mc2d::qtriang(p = c(0.025, 0.5, 0.975), min = 0, mode = 3, max = 10)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.triang.par(q = q)
get.triang.par(q = q, fit.weights = c(100, 1, 100))
get.triang.par(q = q, fit.weights = c(10, 1, 10))
get.triang.par(q = q, fit.weights = c(1, 100, 1))
get.triang.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- mc2d::qtriang(p = c(0.025, 0.5, 0.975), min = 1, mode = 5, max = 10)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.triang.par(q = q)
get.triang.par(q = q, scaleX = c(0.00001, 0.99999))
get.triang.par(q = q, fit.weights = c(100, 1, 100))
get.triang.par(q = q, fit.weights = c(10, 1, 10))
get.triang.par(q = q, fit.weights = c(1, 100, 1))
get.triang.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## bad fit for negative values
q &lt;- mc2d::qtriang(p = c(0.025, 0.5, 0.975), min=-20, mode = 5, max = 10)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.triang.par(q = q, tol = 0.1)
get.triang.par(q = q)
get.triang.par(q = q, fit.weights = c(100, 1, 100))
get.triang.par(q = q, fit.weights = c(10, 1, 10))
get.triang.par(q = q, fit.weights = c(1, 100, 1), tol = 1)
get.triang.par(q = q, fit.weights = c(1, 10, 1), tol = 1)
graphics::par(old.par)

## other examples
q &lt;- mc2d::qtriang(p = c(0.025, 0.5, 0.975), min=-20, mode = 5, max = 10)
get.triang.par(q = q, tol = 0.3)

</code></pre>

<hr>
<h2 id='get.unif.par'>Fitting parameters of a uniform distribution from two or more quantiles</h2><span id='topic+get.unif.par'></span>

<h3>Description</h3>

<p><code>get.unif.par</code> returns the parameters of a uniform distribution
where the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.unif.par(p = c(0.025, 0.975), q, plot = TRUE, scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.unif.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.unif.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.unif.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="get.unif.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.unif.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities and the number of quantiles must be identical
and should be at least two. Using the default <code>p</code>, the three corresponding
quantiles are the 2.5th percentile, the median and the 97.5th percentile,
respectively.
<br /> <br />
Parameters of the uniform distribution are estimated exactly.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a uniform distribution.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qunif(p = c(0.025, 0.975), min = 0, max = 5)
get.unif.par(q = q)
get.unif.par(q = q, scaleX = c(0.001, 0.999))

q &lt;- stats::qunif(p = c(0.025, 0.975), min=-6, max = 5)
get.unif.par(q = q)

</code></pre>

<hr>
<h2 id='get.weibull.par'>Fitting parameters of a Weibull distribution from two or more quantiles</h2><span id='topic+get.weibull.par'></span>

<h3>Description</h3>

<p><code>get.weibull.par</code> returns the parameters of a Weibull distribution where
the <code>p</code>th percentiles match with the quantiles <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.weibull.par(p = c(0.025, 0.5, 0.975), q, show.output = TRUE,
   plot = TRUE, tol = 0.001, fit.weights = rep(1, length(p)), scaleX = c(0.1, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.weibull.par_+3A_p">p</code></td>
<td>
<p>numeric, single value or vector of probabilities.</p>
</td></tr>
<tr><td><code id="get.weibull.par_+3A_q">q</code></td>
<td>
<p>numeric, single value or vector of quantiles corresponding to p.</p>
</td></tr>
<tr><td><code id="get.weibull.par_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.weibull.par_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the graphical diagnostics will be plotted (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="get.weibull.par_+3A_tol">tol</code></td>
<td>
<p>numeric, single positive value giving the absolute convergence tolerance for reaching zero (default value is <code>0.001</code>).</p>
</td></tr>
<tr><td><code id="get.weibull.par_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="get.weibull.par_+3A_scalex">scaleX</code></td>
<td>
<p>numerical vector of the length 2 containing values (from the open interval (0, 1))
for scaling quantile-axis (relevant only if <code>plot = TRUE</code>). The smaller the left value,
the further the graph is extrapolated within the lower percentile, the greater the right
value, the further it goes within the upper percentile.</p>
</td></tr>
<tr><td><code id="get.weibull.par_+3A_...">...</code></td>
<td>
<p>further arguments passed to the functions <code>plot</code> and <code>points</code> (relevant only if <code>plot = TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of probabilities, the number of quantiles and the number of weightings
must be identical and should be at least two. Using the default <code>p</code>, the
three corresponding quantiles are the 2.5th percentile, the median and the 97.5th
percentile, respectively. <code>get.weibull.par</code> uses the R function <code>optim</code>
with the method <code>L-BFGS-B</code>.
<br /> <br />
If <code>show.output = TRUE</code> the output of the function <code>optim</code> will be shown.
The item <code>convergence</code> equal to 0 means the successful completion of the
optimization procedure, otherwise it indicates a convergence error. The item
<code>value</code> displays the achieved minimal value of the functions that were minimized.
<br /> <br />
The estimated distribution parameters returned by the function <code>optim</code> are
accepted if the achieved value of the minimized function (output component
<code>value</code> of <code>optim</code>) is smaller than the argument <code>tol</code>.
<br /> <br />
The items of the probability vector <code>p</code> should lie between 0 and 1.
<br /> <br />
The items of the weighting vector <code>fit.weights</code> should be positive values.
<br /> <br />
The function which will be minimized is defined as a sum of squared differences
between the given probabilities and the theoretical probabilities of the specified
distribution evaluated at the given quantile points (least squares estimation).
</p>


<h3>Value</h3>

<p>Returns fitted parameters of a Weibull distribution or missing
values (<code>NA</code>'s) if the distribution cannot fit the specified quantiles.
</p>


<h3>Note</h3>

<p>It should be noted that there might be deviations between the estimated
and the theoretical distribution parameters in certain circumstances. This is
because the estimation of the parameters is based on a numerical optimization
method and depends strongly on the initial values. In addition, one must always
keep in mind that a distribution for different combinations of parameters may
look very similar. Therefore, the optimization method cannot always find the
&quot;right&quot; distribution, but a &quot;similar&quot; one.
<br /> <br />
If the function terminates with the error massage &quot;convergence error occurred or
specified tolerance not achieved&quot;, one may try to set the convergence tolerance
to a higher value. It is yet to be noted, that good till very good fits of parameters
could only be obtained for tolerance values that are smaller than 0.001.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR),  <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting),  <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>See Also</h3>

<p>See <code>pweibull</code> for distribution implementation details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- stats::qweibull(p = c(0.025, 0.5, 0.975), shape = 0.01, scale = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.weibull.par(q = q, scaleX = c(0.1, 0.03))
get.weibull.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.1, 0.99))
get.weibull.par(q = q, fit.weights = c(10, 1, 10))
get.weibull.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.1, 0.03))
get.weibull.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.1, 0.03))
graphics::par(old.par)

q &lt;- stats::qweibull(p = c(0.025, 0.5, 0.975), shape = 0.1, scale = 0.1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.weibull.par(q = q, scaleX = c(0.1, 0.05))
get.weibull.par(q = q, fit.weights = c(100, 1, 100), scaleX = c(0.00000001, 0.99999999999))
get.weibull.par(q = q, fit.weights = c(10, 1, 10), scaleX = c(0.00000001, 0.99999999999))
get.weibull.par(q = q, fit.weights = c(1, 100, 1), scaleX = c(0.00000001, 0.01))
get.weibull.par(q = q, fit.weights = c(1, 10, 1), scaleX = c(0.00000001, 0.1))
graphics::par(old.par)

q &lt;- stats::qweibull(p = c(0.025, 0.5, 0.975), shape = 2, scale = 3)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.weibull.par(q = q)
get.weibull.par(q = q, fit.weights = c(100, 1, 100))
get.weibull.par(q = q, fit.weights = c(10, 1, 10))
get.weibull.par(q = q, fit.weights = c(1, 100, 1))
get.weibull.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

q &lt;- stats::qweibull(p = c(0.025, 0.5, 0.975), shape = 1, scale = 1)
old.par &lt;- graphics::par(mfrow = c(2, 3))
get.weibull.par(q = q)
get.weibull.par(q = q, fit.weights = c(100, 1, 100))
get.weibull.par(q = q, fit.weights = c(10, 1, 10))
get.weibull.par(q = q, fit.weights = c(1, 100, 1))
get.weibull.par(q = q, fit.weights = c(1, 10, 1))
graphics::par(old.par)

## example with only two quantiles
q &lt;- stats::qweibull(p = c(0.025, 0.975), shape = 2, scale = 1)
old.par &lt;- graphics::par(mfrow = c(1, 3))
get.weibull.par(p = c(0.025, 0.975), q = q)
get.weibull.par(p = c(0.025, 0.975), q = q, fit.weights = c(100, 1))
get.weibull.par(p = c(0.025, 0.975), q = q, fit.weights = c(10, 1))
graphics::par(old.par)

</code></pre>

<hr>
<h2 id='plotDiagnostics.perc'>Graphical tools for choosing distribution by given quantiles</h2><span id='topic+plotDiagnostics.perc'></span>

<h3>Description</h3>

<p>Diagnostic plot for choosing a most appropriate continuous probability for known quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiagnostics.perc(fit.results, tolPlot = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiagnostics.perc_+3A_fit.results">fit.results</code></td>
<td>
<p>a list containing fitting results as an output of the function <code>rriskFitdist.perc</code>.</p>
</td></tr>
<tr><td><code id="plotDiagnostics.perc_+3A_tolplot">tolPlot</code></td>
<td>
<p>numerical value, if the sums of the differences between the distribution
percentiles and the given percentiles are smaller than this value, the distribution
will be plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots distribution whose percentiles go through the given percentiles
<code>q</code>. The argument <code>tolPlot</code> controls this match.
</p>


<h3>Value</h3>

<p>Only graphical output.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(0.025, 0.5, 0.975)
q &lt;- c(9.68, 29.20, 50.98)
fit.results1 &lt;- rriskFitdist.perc(p = p, q = q, show.output = FALSE, tolConv = 0.5)
old.par &lt;- graphics::par(mfrow = c(1, 2))
plotDiagnostics.perc(fit.results1)
plotDiagnostics.perc(fit.results1, tolPlot = 5)
graphics::par(old.par)

p &lt;- c(0.2, 0.7)
q &lt;- c(2.6, 19.1)
fit.results2 &lt;- rriskFitdist.perc(p = p, q = q, show.output = FALSE)
plotDiagnostics.perc(fit.results2)

p &lt;- c(0.3, 0.8, 0.9)
q &lt;- c(10, 20, 40)
fit.results3 &lt;- rriskFitdist.perc(p = p, q = q, show.output = FALSE)
plotDiagnostics.perc(fit.results3)

p &lt;- c(0.3, 0.8, 0.9)
q &lt;- c(10, 30, 40)
fit.results4 &lt;- rriskFitdist.perc(p = p, q = q, show.output = FALSE)
plotDiagnostics.perc(fit.results4)

## Example with fitted beta pert distribution
p &lt;- c(0.025, 0.5, 0.6, 0.975)
q &lt;- mc2d::qpert(p = p, min = 0, mode = 3, max = 10, shape = 5)
fit.results5 &lt;- rriskFitdist.perc(p = p, q = q, show.output = FALSE)
plotDiagnostics.perc(fit.results5)

</code></pre>

<hr>
<h2 id='rriskFitdist.cont'>Fitting univariate distributions by maximum likelihood or by matching moments</h2><span id='topic+rriskFitdist.cont'></span>

<h3>Description</h3>

<p>Fits a univariate distribution by maximum likelihood or by matching moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rriskFitdist.cont(data, distr, method = c("mle", "mme"), start,
   chisqbreaks, meancount, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rriskFitdist.cont_+3A_data">data</code></td>
<td>
<p>A numerical vector, data to be fitted.</p>
</td></tr>
<tr><td><code id="rriskFitdist.cont_+3A_distr">distr</code></td>
<td>
<p>A character string <code>name</code> naming a distribution for which the corresponding
density function <code>dname</code>, the corresponding distribution function
<code>pname</code> and the corresponding quantile function must be defined, or
directly the density function.</p>
</td></tr>
<tr><td><code id="rriskFitdist.cont_+3A_method">method</code></td>
<td>
<p>A character string coding for the fitting method: &quot;mle&quot; for the
maximum likelihood estimation and &quot;mme&quot; for the matching moment estimation.</p>
</td></tr>
<tr><td><code id="rriskFitdist.cont_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values of parameters of the named
distribution. This argument will not be taken into account if <code>method = "mme"</code>,
and may be omitted for some distributions for which reasonable starting values
are computed if <code>method = "mle"</code>.</p>
</td></tr>
<tr><td><code id="rriskFitdist.cont_+3A_chisqbreaks">chisqbreaks</code></td>
<td>
<p>A numerical vector defining the breaks of the cell used to
compute the chi-square statistic. If omitted, these breaks are automatically
computed from the data in order to reach roughly the same number of observations
per cell, roughly equal to the argument <code>meancount</code>, or slightly more if
there are some ties.</p>
</td></tr>
<tr><td><code id="rriskFitdist.cont_+3A_meancount">meancount</code></td>
<td>
<p>The mean number of observations per cell expected for the
definition of the breaks of the cells used to compute the chi-squared statistic.</p>
</td></tr>
<tr><td><code id="rriskFitdist.cont_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to generic function, or to the
function <code>rriskMLEdist</code>, in order to control the optimization method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an alias of the function <code>fitdist</code> from the package
<span class="pkg">fitdistrplus</span> (Version 0.1-2). The original function was extended to
fitting additional distributions. The following continuous distributions can
be fitted by this function: normal, lognormal, logistic, exponential, F,
Student's t, Beta, Cauchy, Weibull, Gamma.
<br /> <br /> For more details see the assistance page of the function
<code>fitdist</code> from the package <span class="pkg">fitdistrplus</span>.
<br /> <br /> This function is not intended to be called directly but is internally
called in <code>useFitdist</code>.
</p>


<h3>Value</h3>

<p><code>rriskFitdist.cont</code> returns a list containing 19 items with following fitting results:
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>numeric, a single value or a vector containing estimated parameters.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the character string representing the used fitting method (&quot;mle&quot; or &quot;mme&quot;).</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>the estimated standard errors or <code>NULL</code> in case of the &quot;mme&quot; method.</p>
</td></tr>
<tr><td><code>cor</code></td>
<td>
<p>the estimated correlation matrix or <code>NULL</code> in case of the &quot;mme&quot; method.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the log-likelihood or <code>NULL</code> in case of the &quot;mme&quot; method.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the Akaike information criterion or <code>NULL</code> in case of the &quot;mme&quot; method.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>the BIC or SBC (Schwarz Bayesian criterion) or <code>NULL</code> in case of the &quot;mme&quot; method.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the length of the data set.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the data set.</p>
</td></tr>
<tr><td><code>distname</code></td>
<td>
<p>the name of the estimated distribution.</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>the Chi-squared statistic or <code>NULL</code>, if not computed.</p>
</td></tr>
<tr><td><code>chisqbreaks</code></td>
<td>
<p>breaks used to define cells in the chi-square statistic.</p>
</td></tr>
<tr><td><code>chisqpvalue</code></td>
<td>
<p>p-value of the chi-square statistic or <code>NULL</code>, if not computed.</p>
</td></tr>
<tr><td><code>chisqdf</code></td>
<td>
<p>degree of freedom of the chi-square distribution or <code>NULL</code>, if not computed.</p>
</td></tr>
<tr><td><code>chisqtable</code></td>
<td>
<p>a table with observed and theoretical counts used for the Chi-squared calculations.</p>
</td></tr>
<tr><td><code>ad</code></td>
<td>
<p>the Anderson-Darling statistic or <code>NULL</code>, if not computed.</p>
</td></tr>
<tr><td><code>adtest</code></td>
<td>
<p>the decision of the Anderson-Darling test or <code>NULL</code>, if not computed.</p>
</td></tr>
<tr><td><code>ks</code></td>
<td>
<p>the Kolmogorov-Smirnov statistic or <code>NULL</code>, if not computed.</p>
</td></tr>
<tr><td><code>kstest</code></td>
<td>
<p>the decision of the Kolmogorov-Smirnov test or <code>NULL</code>, if not computed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting) <br />
Marie-Laure Delignette-Muller (coauthor of the package <span class="pkg">fitdistrplus</span>) <br />
Christophe Dutang (coauthor of the package <span class="pkg">fitdistrplus</span>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- stats::rnorm(5000, mean = 10, sd = 5)
rriskFitdist.cont(x, "norm")
rriskFitdist.cont(x, "t")

</code></pre>

<hr>
<h2 id='rriskFitdist.perc'>Fitting an amount of distribution families by given quantiles</h2><span id='topic+rriskFitdist.perc'></span>

<h3>Description</h3>

<p>This function fits the amount of distribution families to given quantiles and returns
diagnostics that allow user to choose a most appropriate probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rriskFitdist.perc(p = c(0.025, 0.5, 0.975), q = c(9.68, 29.20, 50.98),
   show.output = TRUE, tolConv = 0.001, fit.weights = rep(1, length(p)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rriskFitdist.perc_+3A_p">p</code></td>
<td>
<p>numerical vector giving probabilities.</p>
</td></tr>
<tr><td><code id="rriskFitdist.perc_+3A_q">q</code></td>
<td>
<p>numerical vector giving percentiles.</p>
</td></tr>
<tr><td><code id="rriskFitdist.perc_+3A_show.output">show.output</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>optim</code> result will be printed (default value is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="rriskFitdist.perc_+3A_tolconv">tolConv</code></td>
<td>
<p>positive numerical value, the absolute convergence tolerance for reaching zero by fitting distributions
<code>get.norm.par</code> will be shown.</p>
</td></tr>
<tr><td><code id="rriskFitdist.perc_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both inputs <code>p</code> and <code>q</code> should be of the same length. The items of
the probability vector <code>p</code> should lie between 0 and 1.
</p>


<h3>Value</h3>

<p>Returns a list containing the data frame with the input vectors <code>p</code>
and <code>q</code> and the results matrix giving fitted distributions, estimated
parameters and a vector of theoretical percentiles calculated based on the
estimated parameters. If the consistency check of input parameters fails
the function returns <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit.results1 &lt;- rriskFitdist.perc(show.output = FALSE)
fit.results1

fit.results2 &lt;- rriskFitdist.perc(show.output = FALSE, tolConv = 0.6)
fit.results2

p &lt;- c(0.2, 0.7)
q &lt;- c(2.6, 19.1)
fit.results3 &lt;- rriskFitdist.perc(p = p, q = q, show.output = FALSE)
fit.results3

p &lt;- c(0.3, 0.8, 0.9)
q &lt;- c(10, 20, 40)
fit.results4 &lt;- rriskFitdist.perc(p = p, q = q, show.output = FALSE)
fit.results4

## Example with fitted pert distribution
p &lt;- c(0.025, 0.5, 0.6, 0.975)
q &lt;- mc2d::qpert(p = p, min = 0, mode = 3, max = 10, shape = 5)
fit.results5 &lt;- rriskFitdist.perc(p = p, q = q, show.output = FALSE)
fit.results5

</code></pre>

<hr>
<h2 id='rriskMLEdist'>Maximum likelihood fitting of univariate distributions</h2><span id='topic+rriskMLEdist'></span>

<h3>Description</h3>

<p>Fits a univariate distribution by maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rriskMLEdist(data, distr, start = NULL, optim.method = "default",
   lower = -Inf, upper = Inf, custom.optim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rriskMLEdist_+3A_data">data</code></td>
<td>
<p>A numerical vector for non censored data or a dataframe of two
columns respectively named left and right, describing each observed value as
an interval for censored data. In that case the left column contains either
NA for left censored observations, the left bound of the interval for interval
censored observations, or the observed value for non-censored observations.
The right column contains either NA for right censored observations, the right
bound of the interval for interval censored observations, or the observed value
for non-censored observations.</p>
</td></tr>
<tr><td><code id="rriskMLEdist_+3A_distr">distr</code></td>
<td>
<p>A character string &quot;name&quot; naming a distribution (or directly the
density function) for which the corresponding density function dname and the
corresponding distribution pname must be classically defined. The possible values are:
&quot;norm&quot;, &quot;exp&quot;, &quot;lnorm&quot;, &quot;logis&quot;, &quot;gamma&quot;, &quot;weibull&quot;, &quot;beta&quot;, &quot;chisq&quot;, &quot;t&quot;, &quot;f&quot;,
&quot;cauchy&quot;, &quot;gompertz&quot;.</p>
</td></tr>
<tr><td><code id="rriskMLEdist_+3A_start">start</code></td>
<td>
<p>A named list giving the initial values of parameters of the named
distribution. This argument may be omitted for some distributions for which
reasonable starting values are computed (see details).</p>
</td></tr>
<tr><td><code id="rriskMLEdist_+3A_optim.method">optim.method</code></td>
<td>
<p>&quot;default&quot; (see details) or optimization method to pass to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="rriskMLEdist_+3A_lower">lower</code></td>
<td>
<p>Left bounds on the parameters for the &quot;L-BFGS-B&quot; method (see <code>optim</code>).</p>
</td></tr>
<tr><td><code id="rriskMLEdist_+3A_upper">upper</code></td>
<td>
<p>Right bounds on the parameters for the &quot;L-BFGS-B&quot; method (see <code>optim</code>).</p>
</td></tr>
<tr><td><code id="rriskMLEdist_+3A_custom.optim">custom.optim</code></td>
<td>
<p>a function carrying the MLE optimization (see details).</p>
</td></tr>
<tr><td><code id="rriskMLEdist_+3A_...">...</code></td>
<td>
<p>further arguments passed to the <code>optim</code> or <code>custom.optim</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an alias of the function <code>mledist</code> from the package
<span class="pkg">fitdistrplus</span> (Version 0.1-2). The original function was extended to
fitting additional distributions. The following continuous distributions can
be fitted by this function: normal, exponential, lognormal, logistic, gamma,
Weibull, Beta, chi-square, Student's t, F, Cauchy, Gompertz and triangular.
And the following discrete distributions can be fitted: (wird ergaenzt).
<br /> <br /> For more details see the assistance page of the function
<code>mledist</code> from the package <span class="pkg">fitdistrplus</span>.
<br /> <br /> This function is not intended to be called directly but is internally
called in <code>rriskFitdist.cont</code>.
</p>


<h3>Value</h3>

<p><code>rriskMLEdist</code> returns a list with fitting results containing following informations
</p>
<table>
<tr><td><code>estimate</code></td>
<td>
<p>numeric, a single value or a vector containing estimated parameters.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>an integer code for the convergence of <code>optim</code>.
The value <code>0</code> indicates a successful convergence.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the log-likelihood</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>a symmetric matrix computed by <code>optim</code> as an estimate of the Hessian
at the solution found or computed in the user-supplied optimization function.
It is used in <code>rriskFitdist.cont</code> to estimate standard errors.</p>
</td></tr>
<tr><td><code>optim.function</code></td>
<td>
<p>the name of the optimization function used for maximum likelihood.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Marie-Laure Delignette-Muller (coauthor of the package <span class="pkg">fitdistrplus</span>), <br />
Christophe Dutang (coauthor of the package <span class="pkg">fitdistrplus</span>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a basic fit of some distribution with maximum likelihood estimation
set.seed(1)
x2 &lt;- rchisq(500, 4)
rriskMLEdist(x2, "norm")
rriskMLEdist(x2, "exp")
rriskMLEdist(x2, "lnorm")
rriskMLEdist(x2, "logis")
rriskMLEdist(x2, "gamma")
rriskMLEdist(x2, "weibull")
#rriskMLEdist(x2, "beta")
rriskMLEdist(x2, "chisq")
rriskMLEdist(x2, "t")
rriskMLEdist(x2, "f")
rriskMLEdist(x2, "cauchy")
rriskMLEdist(x2, "gompertz")

## produces an error:
# rriskMLEdist(x2, "triang")

</code></pre>

<hr>
<h2 id='rriskMMEdist'>Fitting univariate distributions by matching moments</h2><span id='topic+rriskMMEdist'></span>

<h3>Description</h3>

<p>Fits a univariate distribution by matching moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rriskMMEdist(data, distr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rriskMMEdist_+3A_data">data</code></td>
<td>
<p>a numerical vector.</p>
</td></tr>
<tr><td><code id="rriskMMEdist_+3A_distr">distr</code></td>
<td>
<p>A character string &quot;name&quot; naming a distribution or directly the
density function <code>dname</code>. The estimated values of the distribution parameters
are provided only for the following distributions : &quot;norm&quot;, &quot;lnorm&quot;, &quot;exp&quot;,
&quot;pois&quot;, &quot;gamma&quot;, &quot;logis&quot;, &quot;nbinom&quot; , &quot;geom&quot;, &quot;beta&quot; and &quot;unif&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an alias of the function <code>mmedist</code> from the package
<span class="pkg">fitdistrplus</span> (Version 0.1-2). The original function was extended to
fitting additional distributions. Parameter of the following distribution
families can be estimated in this function: normal, lognormal, exponential,
Poisson, gamma, logistic, negative binomial, geometric, Beta and continuous
univariate.
<br /> <br /> For more details see the assistance page of the function
<code>mmedist</code> from the package <span class="pkg">fitdistrplus</span>.
<br /> <br /> This function is not intended to be called directly but is internally
called in <code>rriskFitdist.cont</code>.
</p>


<h3>Value</h3>

<p><code>rriskMMEdist</code> returns the named parameter or a named vector of parameters.
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Marie-Laure Delignette-Muller (coauthor of the package <span class="pkg">fitdistrplus</span>), <br />
Christophe Dutang (coauthor of the package <span class="pkg">fitdistrplus</span>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Continuous distributions
set.seed(1)
x1 &lt;- stats::rnorm(500, mean = 2, sd = 0.7)
rriskMMEdist(x1, "norm")
rriskMMEdist(x1, "exp")
rriskMMEdist(x1, "gamma")
rriskMMEdist(x1, "logis")
rriskMMEdist(x1, "unif")

## produces an error:
# rriskMMEdist(x1, "lnorm")
# rriskMMEdist(x1, "beta")

## Discrete distributions
set.seed(2)
x2 &lt;- rpois(500, lambda = 3)
rriskMMEdist(x2, "pois")
rriskMMEdist(x2, "nbinom")
rriskMMEdist(x2, "geom")

</code></pre>

<hr>
<h2 id='useFitdist'>Fitting amount continuous distributions to given univariate data.</h2><span id='topic+useFitdist'></span>

<h3>Description</h3>

<p>Fitting amount continuous distributions to given univariate data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>useFitdist(data2fit, show.output = TRUE, distributions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="useFitdist_+3A_data2fit">data2fit</code></td>
<td>
<p>numerical vector, data to be fitted.</p>
</td></tr>
<tr><td><code id="useFitdist_+3A_show.output">show.output</code></td>
<td>
<p>logical value, if <code>TRUE</code> the output will be printed.</p>
</td></tr>
<tr><td><code id="useFitdist_+3A_distributions">distributions</code></td>
<td>
<p>simple character or character vector giving the names of
distribution families, that should be fitted to the data. The possible values
are: <code>norm</code>, <code>cauchy</code>, <code>logis</code>, <code>beta</code>, <code>exp</code>,
<code>chisq</code>, <code>unif</code>, <code>gamma</code>, <code>lnorm</code>, <code>weibull</code>,
<code>f</code>, <code>t</code>, <code>gompertz</code>, <code>triang</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended to be called directly but is internally called
in <code>fit.cont</code>.
</p>


<h3>Value</h3>

<p>Returns matrix with fitting results. More information...
</p>


<h3>Author(s)</h3>

<p>Matthias Greiner <a href="mailto:matthias.greiner@bfr.bund.de">matthias.greiner@bfr.bund.de</a> (BfR), <br />
Kristin Tolksdorf <a href="mailto:kristin.tolksdorf@bfr.bund.de">kristin.tolksdorf@bfr.bund.de</a> (BfR), <br />
Katharina Schueller <a href="mailto:schueller@stat-up.de">schueller@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting), <br />
Natalia Belgorodski <a href="mailto:belgorodski@stat-up.de">belgorodski@stat-up.de</a> (<abbr><span class="acronym">STAT-UP</span></abbr> Statistical Consulting)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rgamma(374, 4,0.08)
res1 &lt;- useFitdist(data2fit = x1)
res1

x2 &lt;- rbeta(300, shape1 = 1, shape2 = 2)
res2 &lt;- useFitdist(data2fit = x2)
res2

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
