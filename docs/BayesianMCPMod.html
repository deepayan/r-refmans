<!DOCTYPE html><html lang="en-US"><head><title>Help for package BayesianMCPMod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesianMCPMod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assessDesign'><p>assessDesign</p></a></li>
<li><a href='#getBootstrapQuantiles'><p>getBootstrapQuantiles</p></a></li>
<li><a href='#getBootstrapSamples'><p>getBootstrapSamples</p></a></li>
<li><a href='#getContr'><p>getContr</p></a></li>
<li><a href='#getCritProb'><p>getCritProb</p></a></li>
<li><a href='#getESS'><p>getESS</p></a></li>
<li><a href='#getMED'><p>getMED</p></a></li>
<li><a href='#getModelFits'><p>getModelFits</p></a></li>
<li><a href='#getPosterior'><p>getPosterior</p></a></li>
<li><a href='#performBayesianMCP'><p>performBayesianMCP</p></a></li>
<li><a href='#performBayesianMCPMod'><p>performBayesianMCPMod</p></a></li>
<li><a href='#plot.modelFits'><p>plot.modelFits</p></a></li>
<li><a href='#predict.modelFits'><p>predict.modelFits</p></a></li>
<li><a href='#simulateData'><p>simulateData</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Simulate, Evaluate, and Analyze Dose Finding Trials with
Bayesian MCPMod</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian MCPMod (Fleischer et al. (2022)
    &lt;<a href="https://doi.org/10.1002%2Fpst.2193">doi:10.1002/pst.2193</a>&gt;) is an innovative method that improves the
    traditional MCPMod by systematically incorporating historical data,
    such as previous placebo group data. This R package offers functions
    for simulating, analyzing, and evaluating Bayesian MCPMod trials with
    normally distributed endpoints.  It enables the assessment of trial
    designs incorporating historical data across various true
    dose-response relationships and sample sizes. Robust mixture prior
    distributions, such as those derived with the Meta-Analytic-Predictive
    approach (Schmidli et al. (2014) &lt;<a href="https://doi.org/10.1111%2Fbiom.12242">doi:10.1111/biom.12242</a>&gt;), can be
    specified for each dose group.  Resulting mixture posterior
    distributions are used in the Bayesian Multiple Comparison Procedure
    and modeling steps.  The modeling step also includes a weighted model
    averaging approach (Pinheiro et al. (2014) &lt;<a href="https://doi.org/10.1002%2Fsim.6052">doi:10.1002/sim.6052</a>&gt;).
    Estimated dose-response relationships can be bootstrapped and
    visualized.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://boehringer-ingelheim.github.io/BayesianMCPMod/">https://boehringer-ingelheim.github.io/BayesianMCPMod/</a>,
<a href="https://github.com/Boehringer-Ingelheim/BayesianMCPMod">https://github.com/Boehringer-Ingelheim/BayesianMCPMod</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Boehringer-Ingelheim/BayesianMCPMod/issues">https://github.com/Boehringer-Ingelheim/BayesianMCPMod/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, DoseFinding (&ge; 1.1-1), future.apply, ggplot2,
methods, nloptr, RBesT, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>clinDR, data.table, doFuture, doRNG, dplyr, future,
kableExtra, knitr, MCPModPack, reactable, rmarkdown, spelling,
testthat (&ge; 3.0.0), tibble, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 18:32:49 UTC; wojcie</td>
</tr>
<tr>
<td>Author:</td>
<td>Boehringer Ingelheim Pharma GmbH &amp; Co. KG [cph, fnd],
  Stephan Wojciekowski [aut, cre],
  Lars Andersen [aut],
  Jonas Schick [ctb],
  Sebastian Bossert [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephan Wojciekowski &lt;stephan.wojciekowski@boehringer-ingelheim.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-07 19:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='assessDesign'>assessDesign</h2><span id='topic+assessDesign'></span>

<h3>Description</h3>

<p>This function performs simulation based trial design evaluations for a set of specified dose-response models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assessDesign(
  n_patients,
  mods,
  prior_list,
  sd,
  n_sim = 1000,
  alpha_crit_val = 0.05,
  modeling = FALSE,
  simple = TRUE,
  avg_fit = TRUE,
  reestimate = FALSE,
  contr = NULL,
  dr_means = NULL,
  delta = NULL,
  evidence_level = NULL,
  med_selection = c("avgFit", "bestFit")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assessDesign_+3A_n_patients">n_patients</code></td>
<td>
<p>Vector specifying the planned number of patients per dose group. A minimum of 2 patients are required in each group.</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_mods">mods</code></td>
<td>
<p>An object of class &quot;Mods&quot; as specified in the DoseFinding package.</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_prior_list">prior_list</code></td>
<td>
<p>A prior_list object specifying the utilized prior for the different dose groups</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_sd">sd</code></td>
<td>
<p>A positive value, specification of assumed sd</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_n_sim">n_sim</code></td>
<td>
<p>Number of simulations to be performed</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_alpha_crit_val">alpha_crit_val</code></td>
<td>
<p>(Un-adjusted) Critical value to be used for the MCP testing step. Passed to the getCritProb() function for the calculation of adjusted critical values (on the probability scale). Default is 0.05.</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_modeling">modeling</code></td>
<td>
<p>Boolean variable defining whether the Mod part of Bayesian MCP-Mod will be performed in the assessment. More heavy on resources. Default FALSE.</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_simple">simple</code></td>
<td>
<p>Boolean variable defining whether simplified fit will be applied. Passed to the getModelFits function. Default FALSE.</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_avg_fit">avg_fit</code></td>
<td>
<p>Boolean variable, defining whether an average fit (based on generalized AIC weights) should be performed in addition to the individual models. Default TRUE.</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_reestimate">reestimate</code></td>
<td>
<p>Boolean variable defining whether critical value should be calculated with re-estimated contrasts (see getCritProb function for more details). Default FALSE</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_contr">contr</code></td>
<td>
<p>An object of class 'optContr' as created by the getContr() function. Allows specification of a fixed contrasts matrix. Default NULL</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_dr_means">dr_means</code></td>
<td>
<p>A vector, allows specification of  individual (not model based) assumed effects per dose group. Default NULL</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_delta">delta</code></td>
<td>
<p>A numeric value for the threshold Delta for the MED assessment. If NULL, no MED assessment is performed. Default NULL.</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_evidence_level">evidence_level</code></td>
<td>
<p>A numeric value between 0 and 1 for the evidence level gamma for the MED assessment. Only required for Bayesian MED assessment, see ?getMED for details. Default NULL.</p>
</td></tr>
<tr><td><code id="assessDesign_+3A_med_selection">med_selection</code></td>
<td>
<p>A string, either &quot;avgFit&quot; or &quot;bestFit&quot;, for the method of MED selection. Default &quot;avgFit&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns success probabilities for the different assumed dose-response shapes, attributes also includes information around average success rate (across all assumed models) and prior Effective sample size
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mods &lt;- DoseFinding::Mods(linear      = NULL,
                          emax        = c(0.5, 1.2),
                          exponential = 2,
                          doses       = c(0, 0.5, 2,4, 8),
                          maxEff      = 6)
sd &lt;- 12
prior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 12), sigma = 2),
                   DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),
                   DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,
                   DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,
                   DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2))
n_patients &lt;- c(40, 60, 60, 60, 60)

success_probabilities &lt;- assessDesign(
  n_patients  = n_patients,
  mods        = mods,
  prior_list  = prior_list,
  sd          = sd,
  n_sim       = 1e2) # speed up example run time

success_probabilities

if (interactive()) { # takes typically &gt; 5 seconds

# with MED estimation without bootstrapping
# see ?getMED for details

success_probabilities &lt;- assessDesign(
  n_patients     = n_patients,
  mods           = mods,
  prior_list     = prior_list,
  sd             = sd,
  modeling       = TRUE,
  n_sim          = 10, # speed up example run time
  delta          = 7)
  
  success_probabilities
  
# with MED estimation with bootstrapping

success_probabilities &lt;- assessDesign(
  n_patients     = n_patients,
  mods           = mods,
  prior_list     = prior_list,
  sd             = sd,
  modeling       = TRUE,
  n_sim          = 10, # speed up example run time
  delta          = 7,
  evidence_level = 0.8)
  
  success_probabilities

}

</code></pre>

<hr>
<h2 id='getBootstrapQuantiles'>getBootstrapQuantiles</h2><span id='topic+getBootstrapQuantiles'></span>

<h3>Description</h3>

<p>A function for the calculation of bootstrapped model predictions.
Samples from the posterior distribution are drawn (via the RBesT function rmix()) and for every sample the simplified fitting step (see getModelFits() function) and a prediction is performed.
These fits are then used to identify the specified quantiles.
This approach can be considered as the Bayesian equivalent of the frequentist bootstrap approach described in O'Quigley et al. (2017).
Instead of drawing n bootstrap samples from the sampling distribution of the trial dose-response estimates, here the samples are directly taken from the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBootstrapQuantiles(model_fits, quantiles, n_samples = 1000, doses = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBootstrapQuantiles_+3A_model_fits">model_fits</code></td>
<td>
<p>An object of class modelFits, i.e. information about fitted models &amp; corresponding model coefficients as well as the posterior distribution that was the basis for the model fitting</p>
</td></tr>
<tr><td><code id="getBootstrapQuantiles_+3A_quantiles">quantiles</code></td>
<td>
<p>A vector of quantiles that should be evaluated</p>
</td></tr>
<tr><td><code id="getBootstrapQuantiles_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples that should be drawn as basis for the bootstrapped quantiles</p>
</td></tr>
<tr><td><code id="getBootstrapQuantiles_+3A_doses">doses</code></td>
<td>
<p>A vector of doses for which a prediction should be performed. If NULL, the dose levels of the model_fits will be used. Default NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns for model, dose, and bootstrapped samples
</p>


<h3>References</h3>

<p>O'Quigley J, Iasonos A, Bornkamp B. 2017. Handbook of Methods for Designing, Monitoring, and Analyzing Dose-Finding Trials (1st ed.). Chapman and Hall/CRC. doi:10.1201/9781315151984
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),
                       DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),
                       DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,
                       DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,
                       DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2))
models         &lt;- c("exponential", "linear")
dose_levels    &lt;- c(0, 1, 2, 4, 8)
model_fits     &lt;- getModelFits(models      = models,
                               posterior   = posterior_list,
                               dose_levels = dose_levels,
                               simple      = TRUE)

bs_quantiles &lt;- getBootstrapQuantiles(model_fits = model_fits,
                                      quantiles  = c(0.025, 0.5, 0.8, 0.975),
                                      n_samples  = 10, # speeding up example run time
                                      doses      = c(0, 6, 8))
                      
bs_quantiles
</code></pre>

<hr>
<h2 id='getBootstrapSamples'>getBootstrapSamples</h2><span id='topic+getBootstrapSamples'></span>

<h3>Description</h3>

<p>A function to return bootstrap samples from the fitted dose-response models.
Samples from the posterior distribution are drawn (via the RBesT function rmix()) and for every sample the simplified fitting step (see getModelFits() function) and a prediction is performed.
These samples are returned by this function.
This approach can be considered as the Bayesian equivalent of the frequentist bootstrap approach described in O'Quigley et al. (2017).
Instead of drawing n bootstrap samples from the sampling distribution of the trial dose-response estimates, here the samples are directly taken from the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBootstrapSamples(model_fits, n_samples = 1000, doses = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBootstrapSamples_+3A_model_fits">model_fits</code></td>
<td>
<p>An object of class modelFits, i.e. information about fitted models &amp; corresponding model coefficients as well as the posterior distribution that was the basis for the model fitting</p>
</td></tr>
<tr><td><code id="getBootstrapSamples_+3A_n_samples">n_samples</code></td>
<td>
<p>Number of samples that should be drawn</p>
</td></tr>
<tr><td><code id="getBootstrapSamples_+3A_doses">doses</code></td>
<td>
<p>A vector of doses for which a prediction should be performed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with entries model, dose, and sample
</p>


<h3>References</h3>

<p>O'Quigley J, Iasonos A, Bornkamp B. 2017. Handbook of Methods for Designing, Monitoring, and Analyzing Dose-Finding Trials (1st ed.). Chapman and Hall/CRC. doi:10.1201/9781315151984
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),
                       DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),
                       DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,  
                       DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,
                       DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2))
models         &lt;- c("exponential", "linear")
dose_levels    &lt;- c(0, 1, 2, 4, 8)
model_fits     &lt;- getModelFits(models      = models,
                               posterior   = posterior_list,
                               dose_levels = dose_levels,
                               simple      = TRUE)
                           
bs_samples &lt;- getBootstrapSamples(model_fits = model_fits,
                                  n_samples  = 10, # speeding up example run time
                                  doses      = c(0, 6, 8))
                      
bs_samples
</code></pre>

<hr>
<h2 id='getContr'>getContr</h2><span id='topic+getContr'></span>

<h3>Description</h3>

<p>This function calculates contrast vectors that are optimal for detecting certain alternatives via applying the function optContr() of the DoseFinding package.
Hereby, 4 different options can be distinguished that are automatically executed based on the input that is provided
</p>

<ol>
<li><p> Bayesian approach: If dose_weights and a prior_list are provided an optimized contrasts for the posterior sample size is calculated.
In detail,  in a first step the dose_weights (typically the number of patients per dose group) and the prior information is combined by calculating for
each dose group a posterior effective sample. Based on this posterior effective sample sizes the allocation ratio is derived, which allows for a calculation on
pseudo-optimal contrasts via regular MCPMod are calculated from the
regular MCPMod for these specific weights
</p>
</li>
<li><p> Frequentist approach: If only dose_weights are provided optimal contrast vectors are calculated from the
regular MCPMod for these specific weights
</p>
</li>
<li><p> Bayesian approach + re-estimation: If only a sd_posterior (i.e. variability of the posterior distribution) is provided, pseudo-optimal contrasts based on these posterior weights will be calculated
</p>
</li>
<li><p> Frequentist approach+re-estimation: If only a se_new_trial (i.e. the estimated variability per dose group of a new trial) is provided, optimal contrast vectors are calculated from the
regular MCPMod for this specific vector of standard errors. For the actual evaluation this vector of standard errors is translated into a (diagonal) matrix of variances
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>getContr(
  mods,
  dose_levels,
  dose_weights = NULL,
  prior_list = NULL,
  sd_posterior = NULL,
  se_new_trial = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getContr_+3A_mods">mods</code></td>
<td>
<p>An object of class 'Mods' as created by the function 'DoseFinding::Mods()'</p>
</td></tr>
<tr><td><code id="getContr_+3A_dose_levels">dose_levels</code></td>
<td>
<p>Vector containing the different dosage levels.</p>
</td></tr>
<tr><td><code id="getContr_+3A_dose_weights">dose_weights</code></td>
<td>
<p>Vector specifying weights for the different doses. Please note that in case this information is provided together with a prior (i.e. Option 1) is planned these two inputs should be provided on the same scale (e.g. patient numbers).  Default NULL</p>
</td></tr>
<tr><td><code id="getContr_+3A_prior_list">prior_list</code></td>
<td>
<p>A list of objects of class 'normMix' as created with 'RBesT::mixnorm()'. Only required as input for Option 1. Default NULL</p>
</td></tr>
<tr><td><code id="getContr_+3A_sd_posterior">sd_posterior</code></td>
<td>
<p>A vector of positive values with information about the variability of the posterior distribution, only required for Option 3. Default NULL</p>
</td></tr>
<tr><td><code id="getContr_+3A_se_new_trial">se_new_trial</code></td>
<td>
<p>A vector of positive values with information about the observed variability, only required for Option 4. Default NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'optContr' as provided by the function 'DoseFinding::optContr()'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dose_levels  &lt;- c(0, 0.5, 2, 4, 8)
mods &lt;- DoseFinding::Mods(
  linear      = NULL,
  emax        = c(0.5, 1.2),
  exponential = 2,
  doses       = dose_levels,
  maxEff      = 6)
sd_posterior &lt;- c(2.8, 3, 2.5, 3.5, 4)

contr_mat &lt;- getContr(
  mods         = mods,
  dose_levels  = dose_levels,
  sd_posterior = sd_posterior)

</code></pre>

<hr>
<h2 id='getCritProb'>getCritProb</h2><span id='topic+getCritProb'></span>

<h3>Description</h3>

<p>This function calculates multiplicity adjusted critical values. The critical values are calculated in such a way that
when using non-informative priors the actual error level for falsely declaring a significant trial in the Bayesian MCPMod is controlled (by the specified alpha level).
Hereby optimal contrasts of the frequentist MCPMod are applied and two options can be distinguished
</p>

<ol>
<li><p> Frequentist approach: If only dose_weights are provided optimal contrast vectors are calculated from the
regular MCPMod for these specific weights and the corresponding critical value for this set of contrasts is calculated via the critVal() function of the DoseFinding package.
</p>
</li>
<li><p> Frequentist approach + re-estimation: If only a se_new_trial (i.e. the estimated variability per dose group of a new trial) is provided, optimal contrast vectors are calculated from the
regular MCPMod for this specific vector of standard errors. Here as well the critical value for this set of contrasts is calculated via the critVal() function of the DoseFinding package.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>getCritProb(
  mods,
  dose_levels,
  dose_weights = NULL,
  se_new_trial = NULL,
  alpha_crit_val = 0.025
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCritProb_+3A_mods">mods</code></td>
<td>
<p>An object of class &quot;Mods&quot; as specified in the DoseFinding package.</p>
</td></tr>
<tr><td><code id="getCritProb_+3A_dose_levels">dose_levels</code></td>
<td>
<p>Vector containing the different dosage levels.</p>
</td></tr>
<tr><td><code id="getCritProb_+3A_dose_weights">dose_weights</code></td>
<td>
<p>Vector specifying weights for the different doses, only required for Option i). Default NULL</p>
</td></tr>
<tr><td><code id="getCritProb_+3A_se_new_trial">se_new_trial</code></td>
<td>
<p>A vector of positive values, only required for Option ii). Default NULL</p>
</td></tr>
<tr><td><code id="getCritProb_+3A_alpha_crit_val">alpha_crit_val</code></td>
<td>
<p>Significance level. Default set to 0.025.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Multiplicity adjusted critical value on the probability scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mods &lt;- DoseFinding::Mods(linear      = NULL,
                          emax        = c(0.5, 1.2),
                          exponential = 2,
                          doses       = c(0, 0.5, 2,4, 8))
dose_levels &lt;- c(0, 0.5, 2, 4, 8)
critVal &lt;- getCritProb(
  mods           = mods,
  dose_weights   = c(50,50,50,50,50), #reflecting the planned sample size
  dose_levels    = dose_levels,
  alpha_crit_val = 0.05)
</code></pre>

<hr>
<h2 id='getESS'>getESS</h2><span id='topic+getESS'></span>

<h3>Description</h3>

<p>This function calculates the effective sample size for every dose group via the RBesT function ess().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getESS(post_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getESS_+3A_post_list">post_list</code></td>
<td>
<p>A posterior list object, for which the effective sample size for each dose group should be calculated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the effective sample sizes for each dose group
</p>

<hr>
<h2 id='getMED'>getMED</h2><span id='topic+getMED'></span>

<h3>Description</h3>

<p>This function provides information on the minimally efficacious dose (MED).
The MED evaluation can either be based on the fitted model shapes (model_fits) or on bootstrapped quantiles (bs_quantiles).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMED(
  delta,
  evidence_level = 0.5,
  dose_levels = NULL,
  model_fits = NULL,
  bs_quantiles = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMED_+3A_delta">delta</code></td>
<td>
<p>A numeric value for the threshold Delta.</p>
</td></tr>
<tr><td><code id="getMED_+3A_evidence_level">evidence_level</code></td>
<td>
<p>A numeric value between 0 and 1 for the evidence level gamma. Used for the bs_quantiles-based evaluation and not used for the model_fits-based evaluation. Default 0.5.</p>
</td></tr>
<tr><td><code id="getMED_+3A_dose_levels">dose_levels</code></td>
<td>
<p>A vector of numerics containing the different dosage levels. Default NULL.</p>
</td></tr>
<tr><td><code id="getMED_+3A_model_fits">model_fits</code></td>
<td>
<p>An object of class modelFits as created with getModelFits(). Default NULL.</p>
</td></tr>
<tr><td><code id="getMED_+3A_bs_quantiles">bs_quantiles</code></td>
<td>
<p>A dataframe created with getBootstrapQuantiles(). Default NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function assumes that the 1st dose group is the control dose group.
</p>
<p>The bootstrap approach allows for an MED based on decision rules of the form
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\text{MED}} = \text{arg min}_{d\in\{d_1, \dots, d_k\}} \left\{ \text{Pr}\left(f(d, \hat\theta) - f(d_1, \hat\theta) &gt; \Delta\right) &gt; \gamma \right\} .</code>
</p>

<p>The model-shape approach takes the point estimate of the model into account.
</p>


<h3>Value</h3>

<p>A matrix with rows for MED reached, MED, and MED index in the vector of dose levels and columns for the dose-response shapes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),
                       DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),
                       DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,
                       DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,
                       DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2))
models         &lt;- c("exponential", "linear")
dose_levels    &lt;- c(0, 1, 2, 4, 8)
model_fits     &lt;- getModelFits(models      = models,
                               posterior   = posterior_list,
                               dose_levels = dose_levels,
                               simple      = TRUE)

# MED based on the model_fit:
getMED(delta = 5, model_fits = model_fits)
                               
# MED based on bootstrapped quantiles
bs_quantiles &lt;- getBootstrapQuantiles(model_fits = model_fits,
                                      quantiles  = c(0.025, 0.2, 0.5),
                                      n_samples  = 100) # speeding up example run time
                                      
getMED(delta          = 5,
       evidence_level = 0.8,
       bs_quantiles   = bs_quantiles)

</code></pre>

<hr>
<h2 id='getModelFits'>getModelFits</h2><span id='topic+getModelFits'></span>

<h3>Description</h3>

<p>Fits dose-response curves for the specified dose-response models, based on the posterior distributions.
For the simplified fit, multivariate normal distributions will be approximated and reduced by one-dimensional normal distributions.
For the default case, the Nelder-Mead algorithm is used.
In detail, for both approaches the mean vector <code class="reqn">\theta^{Y}</code> and the covariance <code class="reqn">\Sigma</code> of the (mixture) posterior distributions and the corresponding posterior weights <code class="reqn">\tilde{\omega}_{l}</code> for <code class="reqn">l \in {1,...,L}</code> are used as basis
For the full fit a GLS estimator is used to minimize the following expression for the respective dose-response models <code class="reqn">m</code>
</p>
<p style="text-align: center;"><code class="reqn"> \hat{\theta}_{m}=\text{arg min}_{\theta_{m}} \sum_{l=1}^{L} \tilde{\omega}_{l}(\theta_{l_{i}}^{Y}-f(dose_{i},\hat{\theta}_{m}))'\Sigma_{l}^{-1}(\theta_{l_{i}}^{Y}-f(dose_{i},\hat{\theta}_{m}))</code>
</p>

<p>Therefore the function nloptr of the nloptr package is utilized.
In the simplified case <code class="reqn">L=1</code>, as the dimension of the posterior is reduced to 1 first.
The generalized AIC values are calculated via the formula
</p>
<p style="text-align: center;"><code class="reqn">gAIC_{m} = \sum_{l=1}^{L} \tilde{\omega}_{l} \sum_{i=0}^{K} \frac{1}{\Sigma_{l_{i,i}}} (\theta_{l_i}^Y - f(dose_{i},\hat{\theta}_{m}))^2 + 2p </code>
</p>

<p>where <code class="reqn">p</code> denotes the number of estimated parameters and <code class="reqn">K</code> the number of active dose levels.
Here as well for the simplified case the formula reduces to one summand as <code class="reqn">L=1</code>.
Corresponding gAIC based weights for model <code class="reqn">M</code> are calculated as outlined in Schorning et al. (2016)
</p>
<p style="text-align: center;"><code class="reqn">
\Omega_I (M) = \frac{\exp(-0.5 gAIC_{M})}{\sum_{m=1}^{Q} \exp(-0.5 gAIC_{m})}
</code>
</p>

<p>where <code class="reqn">Q</code> denotes the number of models included in the averaging procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModelFits(models, dose_levels, posterior, avg_fit = TRUE, simple = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getModelFits_+3A_models">models</code></td>
<td>
<p>List (or vector) of model names for which a fit will be performed.</p>
</td></tr>
<tr><td><code id="getModelFits_+3A_dose_levels">dose_levels</code></td>
<td>
<p>A vector containing the different dosage levels.</p>
</td></tr>
<tr><td><code id="getModelFits_+3A_posterior">posterior</code></td>
<td>
<p>A getPosterior object, containing the (multivariate) posterior distribution per dosage level.</p>
</td></tr>
<tr><td><code id="getModelFits_+3A_avg_fit">avg_fit</code></td>
<td>
<p>Boolean variable, defining whether an average fit (based on generalized AIC weights) should be performed in addition to the individual models. Default TRUE.</p>
</td></tr>
<tr><td><code id="getModelFits_+3A_simple">simple</code></td>
<td>
<p>Boolean variable, defining whether simplified fit will be applied. Default FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class modelFits. A list containing information about the fitted model coefficients, the prediction per dose group as well as maximum effect and generalized AIC (and corresponding weight) per model.
</p>


<h3>References</h3>

<p>Schorning K, Bornkamp B, Bretz F, Dette H. 2016. Model selection versus model averaging in dose finding studies. Stat Med; 35; 4021-4040.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),
                       DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),
                       DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,
                       DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,
                       DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2))
models         &lt;- c("emax", "exponential", "sigEmax", "linear")
dose_levels    &lt;- c(0, 1, 2, 4, 8)

fit        &lt;- getModelFits(models      = models,
                           posterior   = posterior_list,
                           dose_levels = dose_levels)
                           
fit
                           
fit_simple &lt;- getModelFits(models      = models,
                           posterior   = posterior_list,
                           dose_levels = dose_levels,
                           simple      = TRUE)
                           
fit_simple

</code></pre>

<hr>
<h2 id='getPosterior'>getPosterior</h2><span id='topic+getPosterior'></span>

<h3>Description</h3>

<p>Either the patient level data or both mu_hat as well as S_hat must to be provided.
If patient level data is provided mu_hat and S_hat are calculated within the function using a linear model.
This function calculates the posterior distribution. Depending on the input for S_hat this step is either performed for every dose group independently via the RBesT function postmix() or the mvpostmix() function of the DoseFinding package is utilized.
In the latter case conjugate posterior mixture of multivariate normals are calculated (DeGroot 1970, Bernardo and Smith 1994)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPosterior(
  prior_list,
  data = NULL,
  mu_hat = NULL,
  S_hat = NULL,
  calc_ess = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPosterior_+3A_prior_list">prior_list</code></td>
<td>
<p>a prior list with information about the prior to be used for every dose group</p>
</td></tr>
<tr><td><code id="getPosterior_+3A_data">data</code></td>
<td>
<p>dataframe containing the information of dose and response. Default NULL
Also a simulateData object can be provided.</p>
</td></tr>
<tr><td><code id="getPosterior_+3A_mu_hat">mu_hat</code></td>
<td>
<p>vector of estimated mean values (per dose group).</p>
</td></tr>
<tr><td><code id="getPosterior_+3A_s_hat">S_hat</code></td>
<td>
<p>Either a vector or a covariance matrix specifying the (estimated) variability can be specified. The length of the vector (resp. the dimension of the matrix) needs to match the number of dose groups. Please note that for a vector input the numbers should reflect the standard error per dose group (i.e. square root of variance), while for a matrix input the variance-covariance matrix should be provided.</p>
</td></tr>
<tr><td><code id="getPosterior_+3A_calc_ess">calc_ess</code></td>
<td>
<p>boolean variable, indicating whether effective sample size should be calculated. Default FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Kindly note that one can sample from the <code>posterior_list</code> with <code>lapply(posterior_list, RBesT::rmix, n = 10)</code>.
</p>


<h3>Value</h3>

<p>posterior_list, a posterior list object is returned with information about (mixture) posterior distribution per dose group (more detailed information about the conjugate posterior in case of covariance input for S_hat is provided in the attributes)
</p>


<h3>References</h3>

<p>BERNARDO, Jl. M., and Smith, AFM (1994). Bayesian Theory. 81.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),
                   DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),
                   DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,
                   DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,
                   DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2))
mu &lt;- c(0, 1, 1.5, 2, 2.5)
S_hat &lt;- c(5, 4, 6, 7, 8)

posterior_list &lt;- getPosterior(
   prior_list = prior_list,
   mu_hat     = mu,
   S_hat     = S_hat)

summary(posterior_list)

</code></pre>

<hr>
<h2 id='performBayesianMCP'>performBayesianMCP</h2><span id='topic+performBayesianMCP'></span>

<h3>Description</h3>

<p>Performs Bayesian MCP Test step, as described in Fleischer et al. (2022).
Tests for a dose-response effect using a model-based multiple contrast test based on the (provided) posterior distribution. In particular for every dose-response candidate the posterior probability is calculated that the contrast is bigger than 0 (based on the posterior distribution of the dose groups).
In order to obtain significant test decision we consider the maximum of the posterior probabilities across the different models. This maximum is compared with a (multiplicity adjusted) critical value (on the probability scale).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performBayesianMCP(posterior_list, contr, crit_prob_adj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performBayesianMCP_+3A_posterior_list">posterior_list</code></td>
<td>
<p>An object derived with getPosterior with information about the (mixture) posterior distribution per dose group</p>
</td></tr>
<tr><td><code id="performBayesianMCP_+3A_contr">contr</code></td>
<td>
<p>An object of class 'optContr' as created by the getContr() function. It contains the contrast matrix to be used for the testing step.</p>
</td></tr>
<tr><td><code id="performBayesianMCP_+3A_crit_prob_adj">crit_prob_adj</code></td>
<td>
<p>A getCritProb object, specifying the critical value to be used for the testing (on the probability scale)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bayesian MCP test result, with information about p-values for the individual dose-response shapes and overall significance
</p>


<h3>References</h3>

<p>Fleischer F, Bossert S, Deng Q, Loley C, Gierse J. 2022. Bayesian MCPMod. Pharmaceutical Statistics. 21(3): 654-670. doi:10.1002/pst.2193
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mods &lt;- DoseFinding::Mods(linear      = NULL,
                          emax        = c(0.5, 1.2),
                          exponential = 2,
                          doses       = c(0, 0.5, 2,4, 8))
dose_levels  &lt;- c(0, 0.5, 2, 4, 8)
sd_posterior &lt;- c(2.8,3,2.5,3.5,4)
contr_mat &lt;- getContr(
  mods         = mods,
  dose_levels  = dose_levels,
  sd_posterior = sd_posterior)
critVal &lt;- getCritProb(
  mods           = mods,
  dose_weights   = c(50, 50, 50, 50, 50), #reflecting the planned sample size
  dose_levels    = dose_levels,
  alpha_crit_val = 0.05)
prior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),
                   DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),
                   DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,
                   DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,
                   DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2))
mu &lt;- c(0, 1, 1.5, 2, 2.5)
S_hat &lt;- c(5, 4, 6, 7, 8)
posterior_list &lt;- getPosterior(
  prior_list = prior_list,
  mu_hat     = mu,
  S_hat      = S_hat,
  calc_ess   = TRUE)

performBayesianMCP(posterior_list = posterior_list,
                   contr          = contr_mat,
                   crit_prob_adj  = critVal)

</code></pre>

<hr>
<h2 id='performBayesianMCPMod'>performBayesianMCPMod</h2><span id='topic+performBayesianMCPMod'></span>

<h3>Description</h3>

<p>Performs Bayesian MCP Test step and modeling in a combined fashion. See performBayesianMCP() function for MCP Test step and getModelFits() for the modeling step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performBayesianMCPMod(
  posterior_list,
  contr,
  crit_prob_adj,
  simple = FALSE,
  avg_fit = TRUE,
  delta = NULL,
  evidence_level = NULL,
  med_selection = c("avgFit", "bestFit"),
  n_samples = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performBayesianMCPMod_+3A_posterior_list">posterior_list</code></td>
<td>
<p>An object of class 'postList' as created by getPosterior() containing information about the (mixture) posterior distribution per dose group</p>
</td></tr>
<tr><td><code id="performBayesianMCPMod_+3A_contr">contr</code></td>
<td>
<p>An object of class 'optContr' as created by the getContr() function. It contains the contrast matrix to be used for the testing step.</p>
</td></tr>
<tr><td><code id="performBayesianMCPMod_+3A_crit_prob_adj">crit_prob_adj</code></td>
<td>
<p>A getCritProb object, specifying the critical value to be used for the testing (on the probability scale).</p>
</td></tr>
<tr><td><code id="performBayesianMCPMod_+3A_simple">simple</code></td>
<td>
<p>Boolean variable, defining whether simplified fit will be applied. Passed to the getModelFits() function. Default FALSE.</p>
</td></tr>
<tr><td><code id="performBayesianMCPMod_+3A_avg_fit">avg_fit</code></td>
<td>
<p>Boolean variable, defining whether an average fit (based on generalized AIC weights) should be performed in addition to the individual models. Default TRUE.</p>
</td></tr>
<tr><td><code id="performBayesianMCPMod_+3A_delta">delta</code></td>
<td>
<p>A numeric value for the threshold Delta for the MED assessment. If NULL, no MED assessment is performed. Default NULL.</p>
</td></tr>
<tr><td><code id="performBayesianMCPMod_+3A_evidence_level">evidence_level</code></td>
<td>
<p>A numeric value between 0 and 1 for the evidence level gamma for the MED assessment. Only required for Bayesian MED assessment, see ?getMED for details. Default NULL.</p>
</td></tr>
<tr><td><code id="performBayesianMCPMod_+3A_med_selection">med_selection</code></td>
<td>
<p>A string, either &quot;avgFit&quot; or &quot;bestFit&quot; based on the lowest gAIC, for the method of MED selection. Default &quot;avgFit&quot;.</p>
</td></tr>
<tr><td><code id="performBayesianMCPMod_+3A_n_samples">n_samples</code></td>
<td>
<p>A numerical for the number of bootstrapped samples in case the Bayesian MED assessment is performed. Default 1e3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bayesian MCP test result as well as modeling result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mods &lt;- DoseFinding::Mods(linear      = NULL,
                          emax        = c(0.5, 1.2),
                          exponential = 2,
                          doses       = c(0, 0.5, 2,4, 8))
dose_levels  &lt;- c(0, 0.5, 2, 4, 8)
sd_posterior &lt;- c(2.8, 3, 2.5, 3.5, 4)
contr_mat &lt;- getContr(
  mods         = mods,
  dose_levels  = dose_levels,
  sd_posterior = sd_posterior)
critVal &lt;- getCritProb(
  mods           = mods,
  dose_weights   = c(50, 50, 50, 50, 50), #reflecting the planned sample size
  dose_levels    = dose_levels,
  alpha_crit_val = 0.6) # unreasonable alpha for this example, rather choose 0.05
prior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 5), sigma = 2),
                   DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 1, s = 12), sigma = 2),
                   DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.2, s = 11), sigma = 2) ,
                   DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 1.3, s = 11), sigma = 2) ,
                   DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 2, s = 13), sigma = 2))
mu &lt;- c(0, 1, 1.5, 2, 2.5)
S_hat &lt;- c(5, 4, 6, 7, 8)
posterior_list &lt;- getPosterior(
  prior_list = prior_list,
  mu_hat     = mu,
  S_hat      = S_hat,
  calc_ess   = TRUE)
                      
performBayesianMCPMod(posterior_list = posterior_list,
                      contr          = contr_mat,
                      crit_prob_adj  = critVal,
                      simple         = FALSE,
                      delta          = 1)

</code></pre>

<hr>
<h2 id='plot.modelFits'>plot.modelFits</h2><span id='topic+plot.modelFits'></span>

<h3>Description</h3>

<p>Plot function based on the ggplot2 package. Providing visualizations for each model and a average Fit.
Black lines show the fitted dose response models and an AIC based average model.
Dots indicate the posterior median and vertical lines show corresponding credible intervals (i.e. the variability of the posterior distribution of the respective dose group).
To assess the uncertainty of the model fit one can in addition visualize credible bands (default coloring as orange shaded areas).
The calculation of these bands is performed via the getBootstrapQuantiles() function.
The default setting is that these credible bands are not calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelFits'
plot(
  x,
  gAIC = TRUE,
  cr_intv = TRUE,
  alpha_CrI = 0.05,
  cr_bands = FALSE,
  alpha_CrB = c(0.05, 0.2),
  n_bs_smpl = 1000,
  acc_color = "orange",
  plot_res = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.modelFits_+3A_x">x</code></td>
<td>
<p>An object of type modelFits</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_gaic">gAIC</code></td>
<td>
<p>Logical value indicating whether gAIC values are shown in the plot. Default TRUE</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_cr_intv">cr_intv</code></td>
<td>
<p>Logical value indicating whether credible intervals are included in the plot. Default TRUE</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_alpha_cri">alpha_CrI</code></td>
<td>
<p>Numerical value of the width of the credible intervals. Default is set to 0.05 (i.e 95% CI are shown).</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_cr_bands">cr_bands</code></td>
<td>
<p>Logical value indicating whether bootstrapped based credible bands are shown in the plot. Default FALSE</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_alpha_crb">alpha_CrB</code></td>
<td>
<p>Numerical vector of the width of the credible bands. Default is set to 0.05 and 0.5 (i.e 95% CB and 50% CB  are shown).</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_n_bs_smpl">n_bs_smpl</code></td>
<td>
<p>Number of bootstrap samples being used. Default 1000.</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_acc_color">acc_color</code></td>
<td>
<p>Color of the credible bands. Default &quot;orange&quot;.</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_plot_res">plot_res</code></td>
<td>
<p>Number of plotted doses within the range of the dose levels, i.e., the resolution of the plot. Default 100.</p>
</td></tr>
<tr><td><code id="plot.modelFits_+3A_...">...</code></td>
<td>
<p>optional parameter to be passed to plot().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),
                       DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),
                       DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,
                       DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,
                       DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2))
models &lt;- c("exponential", "linear", "emax")
dose_levels &lt;- c(0, 1, 2, 4, 8)
model_fits &lt;- getModelFits(models      = models,
                           posterior   = posterior_list,
                           dose_levels = dose_levels,
                           simple       = TRUE)

plot(model_fits)

# plot with credible bands

plot(model_fits,
     cr_bands  = TRUE,
     n_bs_smpl = 1e2) 

</code></pre>

<hr>
<h2 id='predict.modelFits'>predict.modelFits</h2><span id='topic+predict.modelFits'></span>

<h3>Description</h3>

<p>This function performs model predictions based on the provided
model and dose specifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelFits'
predict(object, doses = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.modelFits_+3A_object">object</code></td>
<td>
<p>A modelFits object containing information about the fitted
model coefficients</p>
</td></tr>
<tr><td><code id="predict.modelFits_+3A_doses">doses</code></td>
<td>
<p>A vector specifying the doses for which a prediction should be
done</p>
</td></tr>
<tr><td><code id="predict.modelFits_+3A_...">...</code></td>
<td>
<p>Currently without function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the model predictions for the specified models and doses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior_list &lt;- list(Ctrl = RBesT::mixnorm(comp1 = c(w = 1, m = 0, s = 1), sigma = 2),
                       DG_1 = RBesT::mixnorm(comp1 = c(w = 1, m = 3, s = 1.2), sigma = 2),
                       DG_2 = RBesT::mixnorm(comp1 = c(w = 1, m = 4, s = 1.5), sigma = 2) ,
                       DG_3 = RBesT::mixnorm(comp1 = c(w = 1, m = 6, s = 1.2), sigma = 2) ,
                       DG_4 = RBesT::mixnorm(comp1 = c(w = 1, m = 6.5, s = 1.1), sigma = 2))
models         &lt;- c("emax", "exponential", "sigEmax", "linear")
dose_levels    &lt;- c(0, 1, 2, 4, 8)
fit            &lt;- getModelFits(models      = models,
                               posterior   = posterior_list,
                               dose_levels = dose_levels)

predict(fit, doses = c(0, 1, 3, 4, 6, 8))

</code></pre>

<hr>
<h2 id='simulateData'>simulateData</h2><span id='topic+simulateData'></span>

<h3>Description</h3>

<p>Function to simulate patient level data for a normally distributed endpoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateData(
  n_patients,
  dose_levels,
  sd,
  mods,
  n_sim = 1000,
  true_model = NULL,
  dr_means = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateData_+3A_n_patients">n_patients</code></td>
<td>
<p>Vector containing number of patients as a numerical
value per dose-group.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_dose_levels">dose_levels</code></td>
<td>
<p>Vector containing the different dosage levels.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_sd">sd</code></td>
<td>
<p>Standard deviation on patient level.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_mods">mods</code></td>
<td>
<p>An object of class &quot;Mods&quot; as specified in the DoseFinding package.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_n_sim">n_sim</code></td>
<td>
<p>Number of simulations to be performed,
Default is 1000</p>
</td></tr>
<tr><td><code id="simulateData_+3A_true_model">true_model</code></td>
<td>
<p>Default value is NULL.
Assumed true underlying model. Provided via a String. e.g. &quot;emax&quot;.
In case of NULL, all dose-response models, included in the mods input parameter will be used.</p>
</td></tr>
<tr><td><code id="simulateData_+3A_dr_means">dr_means</code></td>
<td>
<p>a vector, with information about assumed effects per dose group. Default NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object, containing patient level simulated data for all assumed true models.
Also providing information about simulation iteration, patient number as well as dosage levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>models &lt;- DoseFinding::Mods(linear      = NULL,
                            linlog      = NULL,
                            emax        = c(0.5, 1.2),
                            exponential = 2, 
                            doses       = c(0, 0.5, 2,4, 8),
                            maxEff      = 6)
dose_levels &lt;- c(0, 0.5, 2,4, 8)
sd          &lt;- 12
n_patients  &lt;- c(40, 60, 60, 60, 60)

sim_data &lt;- simulateData(n_patients  = n_patients,
                         dose_levels = dose_levels,
                         sd          = sd,
                         mods        = models,
                         n_sim       = 100)

head(sim_data)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
