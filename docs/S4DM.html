<!DOCTYPE html><html lang="en"><head><title>Help for package S4DM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {S4DM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#descale_w_objects'><p>Return scaled variables to the original scale using means and SDs</p></a></li>
<li><a href='#dr_maxnet'><p>Density-ratio SDM estimation with Maxnet</p></a></li>
<li><a href='#dr_rulsif'><p>Density-ratio SDM estimation with RuLSIF</p></a></li>
<li><a href='#dr_ulsif'><p>Density-ratio SDM estimation with uLSIF</p></a></li>
<li><a href='#ensemble_range_map'><p>Generate ensemble predictions from S4DM range maps</p></a></li>
<li><a href='#evaluate_range_map'><p>Evaluate S4DM range map quality</p></a></li>
<li><a href='#fit_density_ratio'><p>Fit density-ratio distribution models in a plug-and-play framework.</p></a></li>
<li><a href='#fit_plug_and_play'><p>Fit presence-background distribution models in a plug-and-play framework.</p></a></li>
<li><a href='#get_env_bg'><p>Extract background data for SDM fitting.</p></a></li>
<li><a href='#get_env_pres'><p>Extract presence data for SDM fitting.</p></a></li>
<li><a href='#get_functions'><p>Internal function for getting available function names.</p></a></li>
<li><a href='#get_response_curves'><p>Generate Response Curves</p></a></li>
<li><a href='#make_range_map'><p>Make a range map using plug-and-play modeling.</p></a></li>
<li><a href='#pnp_gaussian'><p>Internal function for fitting gaussian distributions in plug-and-play SDMs.</p></a></li>
<li><a href='#pnp_kde'><p>Internal function for fitting KDE distributions in plug-and-play SDMs.</p></a></li>
<li><a href='#pnp_lobagoc'><p>Internal function for fitting lobagoc distributions in plug-and-play SDMs.</p></a></li>
<li><a href='#pnp_none'><p>Internal function for returning empty pnp_estimate class models</p></a></li>
<li><a href='#pnp_rangebagging'><p>Internal function for rangebagging in plug-and-play SDMs.</p></a></li>
<li><a href='#pnp_vine'><p>Internal function for fitting vine copula distributions in plug-and-play SDMs.</p></a></li>
<li><a href='#project_density_ratio'><p>Projects fitted density-ratio distribution models onto new covariates.</p></a></li>
<li><a href='#project_plug_and_play'><p>Projects fitted plug-and-play distribution models onto new covariates.</p></a></li>
<li><a href='#rescale_w_objects'><p>Rescale a dataset using vectors of means and SDs</p></a></li>
<li><a href='#sample_points'><p>Example S4DM occurrence data</p></a></li>
<li><a href='#sdm_threshold'><p>Thresholds a continuous relative occurrence rate raster to create a binary raster.</p></a></li>
<li><a href='#stratify_random'><p>Split data for k-fold spatially stratified cross validation</p></a></li>
<li><a href='#stratify_spatial'><p>Split data for k-fold spatially stratified cross validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Small Sample Size Species Distribution Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a set of distribution modeling methods that are suited to species with small sample sizes (e.g., poorly sampled species or rare species). While these methods can also be used on well-sampled taxa, they are united by the fact that they can be utilized with relatively few data points. More details on the currently implemented methodologies can be found in Drake and Richards (2018) &lt;<a href="https://doi.org/10.1002%2Fecs2.2373">doi:10.1002/ecs2.2373</a>&gt;, Drake (2015) &lt;<a href="https://doi.org/10.1098%2Frsif.2015.0086">doi:10.1098/rsif.2015.0086</a>&gt;, and Drake (2014) &lt;<a href="https://doi.org/10.1890%2FES13-00202.1">doi:10.1890/ES13-00202.1</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>corpcor, densratio, flexclust, geometry, kernlab, maxnet,
mvtnorm, np, pROC, robust, rvinecopulib, sf, terra, dplyr,
Rdpack</td>
</tr>
<tr>
<td>Suggests:</td>
<td>geodata, BIEN, ggplot2, tidyterra, knitr, testthat, rmarkdown</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 00:20:14 UTC; Brian Maitner</td>
</tr>
<tr>
<td>Author:</td>
<td>Brian S. Maitner <a href="https://orcid.org/0000-0002-2118-9880"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Robert L. Richards [aut],
  Ben S. Carlson [aut],
  John M. Drake [aut],
  Cory Merow [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brian S. Maitner &lt;bmaitner@usf.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-10 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='descale_w_objects'>Return scaled variables to the original scale using means and SDs</h2><span id='topic+descale_w_objects'></span>

<h3>Description</h3>

<p>A little function to rescale data using vectors of means and sds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descale_w_objects(data, mean_vector, sd_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="descale_w_objects_+3A_data">data</code></td>
<td>
<p>dataframe or matrix for rescaling</p>
</td></tr>
<tr><td><code id="descale_w_objects_+3A_mean_vector">mean_vector</code></td>
<td>
<p>vector of means to use for rescaling.  Should be one value for each column in the data</p>
</td></tr>
<tr><td><code id="descale_w_objects_+3A_sd_vector">sd_vector</code></td>
<td>
<p>vector of sds to use for rescaling.  Should be one value for each column in the data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Maitner
</p>

<hr>
<h2 id='dr_maxnet'>Density-ratio SDM estimation with Maxnet</h2><span id='topic+dr_maxnet'></span>

<h3>Description</h3>

<p>dr_maxnet is an internal function for density-ratio estimation with Maxnet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr_maxnet(
  presence_data = NULL,
  background_data = NULL,
  projection_data = NULL,
  formula = NULL,
  regmult = 1,
  regfun = maxnet.default.regularization,
  addsamplestobackground = TRUE,
  clamp = TRUE,
  verbose = FALSE,
  method,
  type = c("link", "exponential", "cloglog", "logistic"),
  object = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dr_maxnet_+3A_presence_data">presence_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_background_data">background_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_projection_data">projection_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_formula">formula</code></td>
<td>
<p>Maxnet formula to use. Default (NULL) will use the Maxnet default. This parameter is called &quot;f&quot; in the maxnet function, but is renamed here as using &quot;t&quot; and &quot;f&quot; as object names is frowned upon.</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_regmult">regmult</code></td>
<td>
<p>Maxnet regularization multiplier. Default is 1.</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_regfun">regfun</code></td>
<td>
<p>Maxnet regularization function. Default is the Maxnet default.</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_addsamplestobackground">addsamplestobackground</code></td>
<td>
<p>If TRUE (the default), any presences that aren't in the background will be added.</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_clamp">clamp</code></td>
<td>
<p>If TRUE (the default), predictions will be limited to ranges seen in the training dataset.</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_type">type</code></td>
<td>
<p>Type of response required.  Defaults to link, exponential, cloglog, and logistic.</p>
</td></tr>
<tr><td><code id="dr_maxnet_+3A_object">object</code></td>
<td>
<p>fitted object returned by a dr_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The options f, regmult, regfun, and addSamplestobackground are only used when method == &quot;predict&quot;,
the options clamp and type are only used when method == &quot;predict&quot;. See the much better documentation for maxnet for more details.
</p>

<hr>
<h2 id='dr_rulsif'>Density-ratio SDM estimation with RuLSIF</h2><span id='topic+dr_rulsif'></span>

<h3>Description</h3>

<p>dr_rulsif is an internal function for density-ratio estimation with RuLSIF (Kanamori et al. 2009; Yamada et al. 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr_rulsif(
  presence_data = NULL,
  background_data = NULL,
  projection_data = NULL,
  sigma = 10^seq(-3, 1, length.out = 9),
  lambda = 10^seq(-3, 1, length.out = 9),
  alpha = 0.1,
  kernel_num = 100,
  verbose = FALSE,
  method,
  object = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dr_rulsif_+3A_presence_data">presence_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_rulsif_+3A_background_data">background_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_rulsif_+3A_projection_data">projection_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_rulsif_+3A_sigma">sigma</code></td>
<td>
<p>Sigma parameter for RuLSIF. Default is the RuLSIF default.</p>
</td></tr>
<tr><td><code id="dr_rulsif_+3A_lambda">lambda</code></td>
<td>
<p>Lambda parameter for RuLSIF. Default is the RuLSIF default.</p>
</td></tr>
<tr><td><code id="dr_rulsif_+3A_alpha">alpha</code></td>
<td>
<p>Relative parameter.  Defaults to RuLSIF default.</p>
</td></tr>
<tr><td><code id="dr_rulsif_+3A_kernel_num">kernel_num</code></td>
<td>
<p>kernel_number for RuLSIF. Default is the RuLSIF default.</p>
</td></tr>
<tr><td><code id="dr_rulsif_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="dr_rulsif_+3A_object">object</code></td>
<td>
<p>fitted object returned by a dr_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kanamori T, Hido S, Sugiyama M (2009).
&ldquo;A least-squares approach to direct importance estimation.&rdquo;
<em>J. Mach. Learn. Res.</em>, <b>10</b>, 1391&ndash;1445.
<a href="https://www.jmlr.org/papers/volume10/kanamori09a/kanamori09a.pdf">https://www.jmlr.org/papers/volume10/kanamori09a/kanamori09a.pdf</a>.<br /><br /> Yamada M, Suzuki T, Kanamori T, Hachiya H, Sugiyama M (2013).
&ldquo;Relative Density-Ratio Estimation for Robust Distribution Comparison.&rdquo;
<em>Neural Computation</em>, <b>25</b>(5), 1324&ndash;1370.
<a href="http://dx.doi.org/10.1162/neco_a_00442">http://dx.doi.org/10.1162/neco_a_00442</a>.
</p>

<hr>
<h2 id='dr_ulsif'>Density-ratio SDM estimation with uLSIF</h2><span id='topic+dr_ulsif'></span>

<h3>Description</h3>

<p>dr_ulsif is an internal function for density-ratio estimation with uLSIF (Kanamori et al. 2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr_ulsif(
  presence_data = NULL,
  background_data = NULL,
  projection_data = NULL,
  sigma = 10^seq(-3, 1, length.out = 9),
  lambda = 10^seq(-3, 1, length.out = 9),
  kernel_num = 100,
  verbose = FALSE,
  method,
  object = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dr_ulsif_+3A_presence_data">presence_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_ulsif_+3A_background_data">background_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_ulsif_+3A_projection_data">projection_data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="dr_ulsif_+3A_sigma">sigma</code></td>
<td>
<p>Sigma parameter for uLSIF. Default is the uLSIF default.</p>
</td></tr>
<tr><td><code id="dr_ulsif_+3A_lambda">lambda</code></td>
<td>
<p>Lambda parameter for uLSIF. Default is the uLSIF default.</p>
</td></tr>
<tr><td><code id="dr_ulsif_+3A_kernel_num">kernel_num</code></td>
<td>
<p>kernel_number for uLSIF. Default is the uLSIF default.</p>
</td></tr>
<tr><td><code id="dr_ulsif_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="dr_ulsif_+3A_object">object</code></td>
<td>
<p>fitted object returned by a dr_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kanamori T, Hido S, Sugiyama M (2009).
&ldquo;A least-squares approach to direct importance estimation.&rdquo;
<em>J. Mach. Learn. Res.</em>, <b>10</b>, 1391&ndash;1445.
<a href="https://www.jmlr.org/papers/volume10/kanamori09a/kanamori09a.pdf">https://www.jmlr.org/papers/volume10/kanamori09a/kanamori09a.pdf</a>.
</p>

<hr>
<h2 id='ensemble_range_map'>Generate ensemble predictions from S4DM range maps</h2><span id='topic+ensemble_range_map'></span>

<h3>Description</h3>

<p>This function evaluates model quality and creates an ensemble of the model outputs.
This function uses 5-fold, spatially stratified, cross-validation to evaluate distribution model quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble_range_map(
  occurrences,
  env,
  method = NULL,
  presence_method = NULL,
  background_method = NULL,
  bootstrap = "none",
  bootstrap_reps = 100,
  quantile = 0.05,
  constraint_regions = NULL,
  background_buffer_width = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble_range_map_+3A_occurrences">occurrences</code></td>
<td>
<p>Presence coordinates in long,lat format.</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_env">env</code></td>
<td>
<p>Environmental SpatRaster(s)</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_method">method</code></td>
<td>
<p>Optional. If supplied, both presence and background density estimation will use this method.</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_presence_method">presence_method</code></td>
<td>
<p>Optional. Method for estimation of presence density.</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_background_method">background_method</code></td>
<td>
<p>Optional. Method for estimation of background density.</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Character.  One of &quot;none&quot; (the default, no bootstrapping),
&quot;numbag&quot; (presence function is bootstrapped),
or &quot;doublebag&quot; (presence and background functions are bootstrapped).</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_bootstrap_reps">bootstrap_reps</code></td>
<td>
<p>Integer.  Number of bootstrap replicates to use (default is 100)</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_quantile">quantile</code></td>
<td>
<p>Quantile to use for thresholding.  Default is 0.05 (5 pct training presence). Set to 0 for minimum training presence (MTP).</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_constraint_regions">constraint_regions</code></td>
<td>
<p>See get_env_bg documentation</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_background_buffer_width">background_buffer_width</code></td>
<td>
<p>Numeric or NULL.  Width (meters or map units) of buffer to use to select background environment. If NULL, uses max dist between nearest occurrences.</p>
</td></tr>
<tr><td><code id="ensemble_range_map_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current plug-and-play methods include: &quot;gaussian&quot;, &quot;kde&quot;,&quot;vine&quot;,&quot;rangebagging&quot;, &quot;lobagoc&quot;, and &quot;none&quot;.
Current density ratio methods include: &quot;ulsif&quot;, &quot;rulsif&quot;.
</p>


<h3>Value</h3>

<p>List object containing elements (1) spatRaster ensemble layer showing the proportion of maps that are included in the range across the ensemble,
(2) spatRasters for individual models, and (3) model quality information.
</p>


<h3>Note</h3>

<p>Either <code>method</code> or both <code>presence_method</code> and <code>background_method</code> must be supplied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# load in sample data

 library(S4DM)
 library(terra)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points

 # environmental data
   env &lt;- rast(system.file('ex/sample_env.tif', package="S4DM"))

 # rescale the environmental data

   env &lt;- scale(env)

ensemble &lt;- ensemble_range_map(occurrences = occurrences,
                               env = env,
                               method = NULL,
                               presence_method = c("gaussian", "kde"),
                               background_method = "gaussian",
                               quantile = 0.05,
                               background_buffer_width = 100000  )

</code></pre>

<hr>
<h2 id='evaluate_range_map'>Evaluate S4DM range map quality</h2><span id='topic+evaluate_range_map'></span>

<h3>Description</h3>

<p>This function uses 5-fold, spatially stratified, cross-validation to evaluate distribution model quality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_range_map(
  occurrences,
  env,
  method = NULL,
  presence_method = NULL,
  background_method = NULL,
  bootstrap = "none",
  bootstrap_reps = 100,
  quantile = 0.05,
  constraint_regions = NULL,
  background_buffer_width = NULL,
  standardize_preds = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_range_map_+3A_occurrences">occurrences</code></td>
<td>
<p>Presence coordinates in long,lat format.</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_env">env</code></td>
<td>
<p>Environmental SpatRaster(s)</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_method">method</code></td>
<td>
<p>Optional. If supplied, both presence and background density estimation will use this method.</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_presence_method">presence_method</code></td>
<td>
<p>Optional. Method for estimation of presence density.</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_background_method">background_method</code></td>
<td>
<p>Optional. Method for estimation of background density.</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Character.  One of &quot;none&quot; (the default, no bootstrapping),
&quot;numbag&quot; (presence function is bootstrapped),
or &quot;doublebag&quot; (presence and background functions are bootstrapped).</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_bootstrap_reps">bootstrap_reps</code></td>
<td>
<p>Integer.  Number of bootstrap replicates to use (default is 100)</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_quantile">quantile</code></td>
<td>
<p>Quantile to use for thresholding.  Default is 0.05 (5 pct training presence). Set to 0 for minimum training presence (MTP).</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_constraint_regions">constraint_regions</code></td>
<td>
<p>See get_env_bg documentation</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_background_buffer_width">background_buffer_width</code></td>
<td>
<p>Numeric or NULL.  Width (meters or map units) of buffer to use to select background environment. If NULL, uses max dist between nearest occurrences.</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_standardize_preds">standardize_preds</code></td>
<td>
<p>Logical. Should environmental layers be scaled? Default is TRUE.</p>
</td></tr>
<tr><td><code id="evaluate_range_map_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current plug-and-play methods include: &quot;gaussian&quot;, &quot;kde&quot;,&quot;vine&quot;,&quot;rangebagging&quot;, &quot;lobagoc&quot;, and &quot;none&quot;.
Current density ratio methods include: &quot;ulsif&quot;, &quot;rulsif&quot;.
</p>


<h3>Value</h3>

<p>A list containing 1) a data.frame containing cross-validated model performance statistics (fold_results), and 2) a data.frame containing model performance statistics evaluated on the full dataset (overall_results).
</p>


<h3>Note</h3>

<p>Either <code>method</code> or both <code>presence_method</code> and <code>background_method</code> must be supplied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{

# load in sample data

 library(S4DM)
 library(terra)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points

 # environmental data
   env &lt;- rast(system.file('ex/sample_env.tif', package="S4DM"))

 # rescale the environmental data

   env &lt;- scale(env)

# Evaluate a gaussian/gaussian model calculated with the numbag approach
# using 10 bootstrap replicates.

 evaluate_range_map(occurrences = occurrences,
                    env = env,
                    method = NULL,
                    presence_method = "gaussian",
                    background_method = "gaussian",
                    bootstrap = "numbag",
                    bootstrap_reps = 10,
                    quantile = 0.05,
                    constraint_regions = NULL,
                    background_buffer_width = 100000)



}
</code></pre>

<hr>
<h2 id='fit_density_ratio'>Fit density-ratio distribution models in a plug-and-play framework.</h2><span id='topic+fit_density_ratio'></span>

<h3>Description</h3>

<p>This function fits density-ratio species distribution models for
the specified density-ratio method (Drake and Richards 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_density_ratio(presence = NULL, background = NULL, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_density_ratio_+3A_presence">presence</code></td>
<td>
<p>dataframe of covariates at presence points</p>
</td></tr>
<tr><td><code id="fit_density_ratio_+3A_background">background</code></td>
<td>
<p>Dataframe of covariates at background points</p>
</td></tr>
<tr><td><code id="fit_density_ratio_+3A_method">method</code></td>
<td>
<p>Character. See &quot;notes&quot; for options.</p>
</td></tr>
<tr><td><code id="fit_density_ratio_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current methods include: &quot;ulsif&quot;, &quot;rulsif&quot;, &quot;maxnet&quot;
</p>


<h3>Value</h3>

<p>List of class &quot;dr_model&quot; containing model objects and metadata needed for projecting the fitted models.
</p>


<h3>References</h3>

<p>Drake JM, Richards RL (2018).
&ldquo;Estimating environmental suitability.&rdquo;
<em>Ecosphere</em>, <b>9</b>(9), e02373.
<a href="https://onlinelibrary.wiley.com/doi/10.1002/ecs2.2373">https://onlinelibrary.wiley.com/doi/10.1002/ecs2.2373</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load in sample data

 library(S4DM)
 library(terra)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points

 # environmental data
   env &lt;- rast(system.file('ex/sample_env.tif', package="S4DM"))

 # rescale the environmental data

   env &lt;- scale(env)

 # Get presence environmental data

  pres_env &lt;- get_env_pres(coords = occurrences,
                           env = env)

# Get background environmental data

 bg_env &lt;- get_env_bg(coords = occurrences,
                      env = env,width = 100000)


# Note that the functions to get the environmental data return lists,
# and only the "env" element of these is used in the fit function

rulsif_fit &lt;- fit_density_ratio(presence = pres_env$env,
                               background = bg_env$env,
                               method = "rulsif")


</code></pre>

<hr>
<h2 id='fit_plug_and_play'>Fit presence-background distribution models in a plug-and-play framework.</h2><span id='topic+fit_plug_and_play'></span>

<h3>Description</h3>

<p>This function fits presence-background species distribution models for the specified plug-and-play methods (Drake and Richards 2018; Drake 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_plug_and_play(
  presence = NULL,
  background = NULL,
  method = NULL,
  presence_method = NULL,
  background_method = NULL,
  bootstrap = "none",
  bootstrap_reps = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_plug_and_play_+3A_presence">presence</code></td>
<td>
<p>dataframe of covariates at presence points</p>
</td></tr>
<tr><td><code id="fit_plug_and_play_+3A_background">background</code></td>
<td>
<p>Optional. Dataframe of covariates at background points</p>
</td></tr>
<tr><td><code id="fit_plug_and_play_+3A_method">method</code></td>
<td>
<p>Optional. If supplied, both presence and background density estimation will use this method.</p>
</td></tr>
<tr><td><code id="fit_plug_and_play_+3A_presence_method">presence_method</code></td>
<td>
<p>Optional. Method for estimation of presence density.</p>
</td></tr>
<tr><td><code id="fit_plug_and_play_+3A_background_method">background_method</code></td>
<td>
<p>Optional. Method for estimation of background density.</p>
</td></tr>
<tr><td><code id="fit_plug_and_play_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Character.  One of &quot;none&quot; (the default, no bootstrapping),
&quot;numbag&quot; (presence function is bootstrapped),
or &quot;doublebag&quot; (presence and background functions are bootstrapped).</p>
</td></tr>
<tr><td><code id="fit_plug_and_play_+3A_bootstrap_reps">bootstrap_reps</code></td>
<td>
<p>Integer.  Number of bootstrap replicates to use (default is 100)</p>
</td></tr>
<tr><td><code id="fit_plug_and_play_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current methods include: &quot;gaussian&quot;, &quot;kde&quot;,&quot;vine&quot;,&quot;rangebagging&quot;, &quot;lobagoc&quot;, and &quot;none&quot;.
</p>


<h3>Value</h3>

<p>List of class &quot;pnp_model&quot; containing model objects and metadata needed for projecting the fitted models.
</p>


<h3>Note</h3>

<p>Either <code>method</code> or both <code>presence_method</code> and <code>background_method</code> must be supplied.
</p>


<h3>References</h3>

<p>Drake JM (2015).
&ldquo;Range bagging: a new method for ecological niche modelling from presence-only data.&rdquo;
<em>J. R. Soc. Interface</em>, <b>12</b>(107).
<a href="http://dx.doi.org/10.1098/rsif.2015.0086">http://dx.doi.org/10.1098/rsif.2015.0086</a>.<br /><br /> Drake JM, Richards RL (2018).
&ldquo;Estimating environmental suitability.&rdquo;
<em>Ecosphere</em>, <b>9</b>(9), e02373.
<a href="https://onlinelibrary.wiley.com/doi/10.1002/ecs2.2373">https://onlinelibrary.wiley.com/doi/10.1002/ecs2.2373</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# load in sample data

 library(S4DM)
 library(terra)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points

 # environmental data
   env &lt;- rast(system.file('ex/sample_env.tif', package="S4DM"))

 # rescale the environmental data

   env &lt;- scale(env)

 # Get presence environmental data

  pres_env &lt;- get_env_pres(coords = occurrences,
                           env = env)

# Get background environmental data

 bg_env &lt;- get_env_bg(coords = occurrences,
                      env = env,width = 100000)


# Note that the functions to get the environmental data return lists,
# and only the "env" element of these is used in the fit function

  kde_fit &lt;- fit_plug_and_play (presence = pres_env$env,
                                background = bg_env$env,
                                method = "kde")


</code></pre>

<hr>
<h2 id='get_env_bg'>Extract background data for SDM fitting.</h2><span id='topic+get_env_bg'></span>

<h3>Description</h3>

<p>This function extracts background data around known presence records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_env_bg(
  coords,
  env,
  method = "buffer",
  width = NULL,
  constraint_regions = NULL,
  standardize = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_env_bg_+3A_coords">coords</code></td>
<td>
<p>Coordinates (long,lat) to extract values for</p>
</td></tr>
<tr><td><code id="get_env_bg_+3A_env">env</code></td>
<td>
<p>Environmental SpatRaster(s) in any projection</p>
</td></tr>
<tr><td><code id="get_env_bg_+3A_method">method</code></td>
<td>
<p>Methods for getting bg points. Current option is buffer</p>
</td></tr>
<tr><td><code id="get_env_bg_+3A_width">width</code></td>
<td>
<p>Numeric or NULL.  Width (meters or map units) of buffer. If NULL, uses max dist between nearest occurrences.</p>
</td></tr>
<tr><td><code id="get_env_bg_+3A_constraint_regions">constraint_regions</code></td>
<td>
<p>An optional spatialpolygons* object that can be used to limit the selection of background points.</p>
</td></tr>
<tr><td><code id="get_env_bg_+3A_standardize">standardize</code></td>
<td>
<p>Logical. If TRUE, the variables will be scaled and centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 1) the background data (env), 2) the cell indices for which the background was taken (buffer_cells), 3) the environmental means (env_mean; NA if standardization not done), and 4) the environmental standard deviations (env_sds; NA if standardization not done).
</p>


<h3>Note</h3>

<p>If supplying constraint_regions, any polygons in which the occurrences fall are considered fair game for background selection.
This background selection is, however, still limited by the buffer as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{

# load in sample data

 library(S4DM)
 library(terra)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points

 # environmental data
   env &lt;- rast(system.file('ex/sample_env.tif', package="S4DM"))

 # rescale the environmental data

   env &lt;- scale(env)

bg_data &lt;- get_env_bg(coords = occurrences,
                      env = env,
                      method = "buffer",
                      width = 100000)


}
</code></pre>

<hr>
<h2 id='get_env_pres'>Extract presence data for SDM fitting.</h2><span id='topic+get_env_pres'></span>

<h3>Description</h3>

<p>This function extracts presence data at known presence records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_env_pres(coords, env, env_bg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_env_pres_+3A_coords">coords</code></td>
<td>
<p>Coordinates (long,lat) to extract values for</p>
</td></tr>
<tr><td><code id="get_env_pres_+3A_env">env</code></td>
<td>
<p>Environmental SpatRaster(s) in any projection</p>
</td></tr>
<tr><td><code id="get_env_pres_+3A_env_bg">env_bg</code></td>
<td>
<p>Background data produced by <code>get_env_bg</code>, used for re-scaling</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 1) the environmental data at the presence locations (env), and 2) an sf data.frame containing the occurrence records(occurrence_sf).
</p>


<h3>Examples</h3>

<pre><code class='language-R'> {

# load in sample data

 library(S4DM)
 library(terra)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points

 # environmental data
   env &lt;- rast(system.file('ex/sample_env.tif', package="S4DM"))

 # rescale the environmental data

   env &lt;- scale(env)

env_pres &lt;- get_env_pres(coords = occurrences,
                        env = env)

}
</code></pre>

<hr>
<h2 id='get_functions'>Internal function for getting available function names.</h2><span id='topic+get_functions'></span>

<h3>Description</h3>

<p>This function checks the available functions in the package to extract current options for dr and pnp fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_functions(type = "pnp")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_functions_+3A_type">type</code></td>
<td>
<p>Type of function to get. Options are &quot;pnp&quot; for presence/background functions and &quot;dr&quot; for ratio functions.</p>
</td></tr>
</table>

<hr>
<h2 id='get_response_curves'>Generate Response Curves</h2><span id='topic+get_response_curves'></span>

<h3>Description</h3>

<p>Given an environmental data set, fitted models, and a directory to output plots, this function generates response curves for each predictor in the model. The response curves depict the predicted change in probability of presence as a function of the environmental predictor while holding all other predictors constant at their mean values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_response_curves(
  env_bg,
  env_pres,
  pnp_model,
  n.int = 1000,
  envMeans = NULL,
  envSDs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_response_curves_+3A_env_bg">env_bg</code></td>
<td>
<p>Object returned by get_env_bg</p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_env_pres">env_pres</code></td>
<td>
<p>Object returned by get_env_pres</p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_pnp_model">pnp_model</code></td>
<td>
<p>Object returned  by <code>fit_plug_and_play</code> or <code>fit_density_ratio</code></p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_n.int">n.int</code></td>
<td>
<p>Number of points along which to calculate the response curve</p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_envmeans">envMeans</code></td>
<td>
<p>A vector of means for each environmental predictor in the dataset. (not used)</p>
</td></tr>
<tr><td><code id="get_response_curves_+3A_envsds">envSDs</code></td>
<td>
<p>A vector of standard deviations for each environmental predictor in the dataset.(not used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function generates a set of marginal predictions for each environmental variable, holding other variables constant
</p>


<h3>Author(s)</h3>

<p>Cory Merow, modified by Brian Maitner
</p>

<hr>
<h2 id='make_range_map'>Make a range map using plug-and-play modeling.</h2><span id='topic+make_range_map'></span>

<h3>Description</h3>

<p>This function produces range maps using plug-and-play modeling with either presence-background or density-ratio approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_range_map(
  occurrences,
  env,
  method = NULL,
  presence_method = NULL,
  background_method = NULL,
  bootstrap = "none",
  bootstrap_reps = 100,
  quantile = 0.05,
  background_buffer_width = NULL,
  constraint_regions = NULL,
  verbose = FALSE,
  standardize_preds = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_range_map_+3A_occurrences">occurrences</code></td>
<td>
<p>Presence coordinates in long,lat format.</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_env">env</code></td>
<td>
<p>Environmental rasters</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_method">method</code></td>
<td>
<p>Optional. If supplied, both presence and background density estimation will use this method.</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_presence_method">presence_method</code></td>
<td>
<p>Optional. Method for estimation of presence density.</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_background_method">background_method</code></td>
<td>
<p>Optional. Method for estimation of background density.</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_bootstrap">bootstrap</code></td>
<td>
<p>Character.  One of &quot;none&quot; (the default, no bootstrapping),
&quot;numbag&quot; (presence function is bootstrapped),
or &quot;doublebag&quot; (presence and background functions are bootstrapped).</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_bootstrap_reps">bootstrap_reps</code></td>
<td>
<p>Integer.  Number of bootstrap replicates to use (default is 100)</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_quantile">quantile</code></td>
<td>
<p>Quantile to use for thresholding.  Default is 0.05 (5 pct training presence). Set to 0 for minimum training presence (MTP), set to NULL to return continuous raster.</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_background_buffer_width">background_buffer_width</code></td>
<td>
<p>The width (in m for unprojected rasters and map units for projected rasters) of the buffer to use for background data.
Defaults to NULL, which will take the maximum distance between occurrence records.</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_constraint_regions">constraint_regions</code></td>
<td>
<p>See get_env_bg documentation</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, prints progress messages.</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_standardize_preds">standardize_preds</code></td>
<td>
<p>Logical. Should environmental layers be scaled? Default is TRUE.</p>
</td></tr>
<tr><td><code id="make_range_map_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current plug-and-play methods include: &quot;gaussian&quot;, &quot;kde&quot;,&quot;vine&quot;,&quot;rangebagging&quot;, &quot;lobagoc&quot;, and &quot;none&quot;.
Current density ratio methods include: &quot;ulsif&quot;, &quot;rulsif&quot;,and &quot;maxnet&quot;.
</p>


<h3>Value</h3>

<p>A SpatRaster object containing a range map. Maps may be either binary or continuous, depending upon the <code>quantile</code> argument.
</p>


<h3>Note</h3>

<p>Either <code>method</code> or both <code>presence_method</code> and <code>background_method</code> must be supplied.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{

# load in sample data

 library(S4DM)
 library(terra)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points

 # environmental data
   env &lt;- rast(system.file('ex/sample_env.tif', package="S4DM"))

 # rescale the environmental data

   env &lt;- scale(env)

   map &lt;- make_range_map(occurrences = occurrences,
                         env = env,
                         method = "gaussian",
                         presence_method = NULL,
                         background_method = NULL,
                         bootstrap = "none",
                         bootstrap_reps = 100,
                         quantile = 0.05,
                         background_buffer_width = 100000)

   plot(map)


}
</code></pre>

<hr>
<h2 id='pnp_gaussian'>Internal function for fitting gaussian distributions in plug-and-play SDMs.</h2><span id='topic+pnp_gaussian'></span>

<h3>Description</h3>

<p>This function both fits distributions and projects those distributions to new covariates..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnp_gaussian(data, method, type = "regularized", object = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnp_gaussian_+3A_data">data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="pnp_gaussian_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="pnp_gaussian_+3A_type">type</code></td>
<td>
<p>one of either &quot;classical&quot;, &quot;robust&quot;, or &quot;regularized&quot; (the default)</p>
</td></tr>
<tr><td><code id="pnp_gaussian_+3A_object">object</code></td>
<td>
<p>fitted object returned by a pnp_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='pnp_kde'>Internal function for fitting KDE distributions in plug-and-play SDMs.</h2><span id='topic+pnp_kde'></span>

<h3>Description</h3>

<p>This function both fits Kernel Density Estimation (KDE) distributions and projects those distributions to new covariates..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnp_kde(data, method, bwmethod = "normal-reference", object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnp_kde_+3A_data">data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="pnp_kde_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="pnp_kde_+3A_bwmethod">bwmethod</code></td>
<td>
<p>Bandwidth method to use.  One of 'normal-reference' (the default),'cv.ml', or 'cv.ls'</p>
</td></tr>
<tr><td><code id="pnp_kde_+3A_object">object</code></td>
<td>
<p>fitted object returned by a pnp_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='pnp_lobagoc'>Internal function for fitting lobagoc distributions in plug-and-play SDMs.</h2><span id='topic+pnp_lobagoc'></span>

<h3>Description</h3>

<p>This function both fits lobagoc distributions (Drake 2014) and projects those distributions to new covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnp_lobagoc(data, method, object = NULL, v = 100, nu = 0.01, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnp_lobagoc_+3A_data">data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="pnp_lobagoc_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="pnp_lobagoc_+3A_object">object</code></td>
<td>
<p>fitted object returned by a pnp_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="pnp_lobagoc_+3A_v">v</code></td>
<td>
<p>Positive integer. The Number of votes to use (default is 100)</p>
</td></tr>
<tr><td><code id="pnp_lobagoc_+3A_nu">nu</code></td>
<td>
<p>Numeric. Tuning parameter for nu-svm</p>
</td></tr>
<tr><td><code id="pnp_lobagoc_+3A_sigma">sigma</code></td>
<td>
<p>NULL or Numeric.  Tuning parameter of rbf kernel, will estimate if left NULL (default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For fitting, an object is not required (and will be ignored). For prediction, parameters v,nu,and sigma are not needed and will be ignored.
</p>


<h3>References</h3>

<p>Drake JM (2014).
&ldquo;Ensemble algorithms for ecological niche modeling from presence‐background and presence‐only data.&rdquo;
<em>Ecosphere</em>, <b>5</b>(6), 1&ndash;16.
<a href="https://doi.org/10.1890/es13-00202.1">doi:10.1890/es13-00202.1</a>, <a href="https://esajournals.onlinelibrary.wiley.com/doi/abs/10.1890/ES13-00202.1">https://esajournals.onlinelibrary.wiley.com/doi/abs/10.1890/ES13-00202.1</a>.
</p>

<hr>
<h2 id='pnp_none'>Internal function for returning empty pnp_estimate class models</h2><span id='topic+pnp_none'></span>

<h3>Description</h3>

<p>This function is used internally to transform presence-background models into presence-only models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnp_none(method, object = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnp_none_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="pnp_none_+3A_object">object</code></td>
<td>
<p>fitted object returned by a pnp_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='pnp_rangebagging'>Internal function for rangebagging in plug-and-play SDMs.</h2><span id='topic+pnp_rangebagging'></span>

<h3>Description</h3>

<p>This function both fits rangebagging models (Drake 2015) and projects those distributions to new covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnp_rangebagging(data, method, object = NULL, v = 100, d = 2, p = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnp_rangebagging_+3A_data">data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="pnp_rangebagging_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="pnp_rangebagging_+3A_object">object</code></td>
<td>
<p>fitted object returned by a pnp_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="pnp_rangebagging_+3A_v">v</code></td>
<td>
<p>Integer. Number of votes to use in the aggregation, default is 100.</p>
</td></tr>
<tr><td><code id="pnp_rangebagging_+3A_d">d</code></td>
<td>
<p>Integer. Number of dimensions (i.e. covariates) to use in aggregations, default is 2.</p>
</td></tr>
<tr><td><code id="pnp_rangebagging_+3A_p">p</code></td>
<td>
<p>Numeric.  Fraction of observations (i.e. occurrences) to use in each replicate aggregation. Default is 0.5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For fitting, an object is not required (and will be ignored). For prediction, parameters v,p,and d are not needed and will be ignored.
</p>


<h3>References</h3>

<p>Drake JM (2015).
&ldquo;Range bagging: a new method for ecological niche modelling from presence-only data.&rdquo;
<em>J. R. Soc. Interface</em>, <b>12</b>(107).
<a href="http://dx.doi.org/10.1098/rsif.2015.0086">http://dx.doi.org/10.1098/rsif.2015.0086</a>.
</p>

<hr>
<h2 id='pnp_vine'>Internal function for fitting vine copula distributions in plug-and-play SDMs.</h2><span id='topic+pnp_vine'></span>

<h3>Description</h3>

<p>This function both fits distributions and projects those distributions to new covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pnp_vine(data, method, object = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pnp_vine_+3A_data">data</code></td>
<td>
<p>dataframe of covariates</p>
</td></tr>
<tr><td><code id="pnp_vine_+3A_method">method</code></td>
<td>
<p>one of either &quot;fit&quot; or &quot;predict&quot;</p>
</td></tr>
<tr><td><code id="pnp_vine_+3A_object">object</code></td>
<td>
<p>fitted object returned by a pnp_... function. Only needed when method = &quot;predict&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='project_density_ratio'>Projects fitted density-ratio distribution models onto new covariates.</h2><span id='topic+project_density_ratio'></span>

<h3>Description</h3>

<p>This function projects fitted density-ratio species distribution models onto new covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_density_ratio(dr_model, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project_density_ratio_+3A_dr_model">dr_model</code></td>
<td>
<p>A fitted density ratio model produced by <code>fit_density_ratio</code></p>
</td></tr>
<tr><td><code id="project_density_ratio_+3A_data">data</code></td>
<td>
<p>covariate data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of relative occurrence rates evaluated at the covariates supplied in the data object.
</p>

<hr>
<h2 id='project_plug_and_play'>Projects fitted plug-and-play distribution models onto new covariates.</h2><span id='topic+project_plug_and_play'></span>

<h3>Description</h3>

<p>This function projects fitted plug-and-play species distribution models onto new covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project_plug_and_play(pnp_model, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project_plug_and_play_+3A_pnp_model">pnp_model</code></td>
<td>
<p>A fitted plug-and-play model produced by <code>fit_plug_and_play</code></p>
</td></tr>
<tr><td><code id="project_plug_and_play_+3A_data">data</code></td>
<td>
<p>covariate data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of relative occurrence rates evaluated at the covariates supplied in the data object.
</p>


<h3>Note</h3>

<p>The tsearchn function underlying rangebagging seems to fail sometimes with very uneven predictors. Rescaling helps.
</p>

<hr>
<h2 id='rescale_w_objects'>Rescale a dataset using vectors of means and SDs</h2><span id='topic+rescale_w_objects'></span>

<h3>Description</h3>

<p>A little function to rescale data using vectors of means and sds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale_w_objects(data, mean_vector, sd_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescale_w_objects_+3A_data">data</code></td>
<td>
<p>dataframe or matrix for rescaling</p>
</td></tr>
<tr><td><code id="rescale_w_objects_+3A_mean_vector">mean_vector</code></td>
<td>
<p>vector of means to use for rescaling.  Should be one value for each column in the data</p>
</td></tr>
<tr><td><code id="rescale_w_objects_+3A_sd_vector">sd_vector</code></td>
<td>
<p>vector of sds to use for rescaling.  Should be one value for each column in the data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Brian Maitner
</p>

<hr>
<h2 id='sample_points'>Example S4DM occurrence data</h2><span id='topic+sample_points'></span>

<h3>Description</h3>

<p>A sample dataset containing occurrence records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_points
</code></pre>


<h3>Format</h3>

<p>A data.frame with 65 observations of 2 variables:
</p>

<dl>
<dt>Longitude</dt><dd><p>Longitude, in decimal degrees</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude, in decimal degrees</p>
</dd>
</dl>
<p>...

</p>


<h3>Source</h3>

<p><a href="https://biendata.org">https://biendata.org</a>
</p>

<hr>
<h2 id='sdm_threshold'>Thresholds a continuous relative occurrence rate raster to create a binary raster.</h2><span id='topic+sdm_threshold'></span>

<h3>Description</h3>

<p>This function thresholds a continuous relative occurrence rate raster to produce a binary presence/absence raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdm_threshold(
  prediction_raster,
  occurrence_sf,
  quantile = 0.05,
  return_binary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sdm_threshold_+3A_prediction_raster">prediction_raster</code></td>
<td>
<p>Raster containing continuous predictions of relative occurrence rate to be thresholded.</p>
</td></tr>
<tr><td><code id="sdm_threshold_+3A_occurrence_sf">occurrence_sf</code></td>
<td>
<p>An sf object containing presence locations. Should be in the projection of the prediction raster</p>
</td></tr>
<tr><td><code id="sdm_threshold_+3A_quantile">quantile</code></td>
<td>
<p>Numeric between 0 and 1. Quantile to use for thresholding (defaults to 0.05).  Set to 0 for minimum training presence.</p>
</td></tr>
<tr><td><code id="sdm_threshold_+3A_return_binary">return_binary</code></td>
<td>
<p>LOGICAL. Should the raster returned be binary (presence/absence)?  If FALSE, predicted presences will retain their 'suitability&quot; scores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object containing a range map. Maps may be either binary or continuous, depending upon the <code>return_binary</code> argument.
</p>


<h3>Author(s)</h3>

<p>Cecina Babich Morrow (modified by Brian Maitner)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{

# load in sample data

library(S4DM)
library(terra)

# occurrence points
  data("sample_points")
  occurrences &lt;- sample_points

# environmental data
  env &lt;- rast(system.file('ex/sample_env.tif', package="S4DM"))

# rescale the environmental data

  env &lt;- scale(env)

 bg_data &lt;- get_env_bg(coords = occurrences,
                       env = env,
                       method = "buffer",
                       width = 100000)

 pres_data &lt;- get_env_pres(coords = occurrences,
                           env = env)

 pnp_model &lt;-fit_plug_and_play(presence = pres_data$env,
                   background = bg_data$env,
                   method = "gaussian")

 pnp_continuous &lt;- project_plug_and_play(pnp_model = pnp_model,
                                         data = bg_data$env)

 #Make an empty raster to populate
 out_raster &lt;- env[[1]]
 values(out_raster) &lt;- NA

 # use the bg_data for indexing
 out_raster[bg_data$bg_cells] &lt;- pnp_continuous

 plot(out_raster)

 #convert to a binary raster

 out_raster_binary &lt;-
   sdm_threshold(prediction_raster = out_raster,
               occurrence_sf = pres_data$occurrence_sf,
               quantile = 0.05,
               return_binary = TRUE)

 plot(out_raster_binary)

}
</code></pre>

<hr>
<h2 id='stratify_random'>Split data for k-fold spatially stratified cross validation</h2><span id='topic+stratify_random'></span>

<h3>Description</h3>

<p>Splitting tool for cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratify_random(occurrence_sf, nfolds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stratify_random_+3A_occurrence_sf">occurrence_sf</code></td>
<td>
<p>a sf object containing occurrence records</p>
</td></tr>
<tr><td><code id="stratify_random_+3A_nfolds">nfolds</code></td>
<td>
<p>number of desired output folds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Examples.
</p>


<h3>Value</h3>

<p>Returns a sf dataframe containing fold designation for each point.
</p>


<h3>Author(s)</h3>

<p>Cory Merow <a href="mailto:cory.merow@gmail.com">cory.merow@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{

# load in sample data

 library(S4DM)
 library(terra)
 library(sf)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points


 occurrences &lt;- st_as_sf(x = occurrences,coords = c(1,2))


random_folds &lt;- stratify_random(occurrence_sf = occurrences,
                               nfolds = 5)


}
</code></pre>

<hr>
<h2 id='stratify_spatial'>Split data for k-fold spatially stratified cross validation</h2><span id='topic+stratify_spatial'></span>

<h3>Description</h3>

<p>Splitting tool for cross-validation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratify_spatial(occurrence_sf, nfolds = NULL, nsubclusters = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stratify_spatial_+3A_occurrence_sf">occurrence_sf</code></td>
<td>
<p>a sf object containing occurrence points</p>
</td></tr>
<tr><td><code id="stratify_spatial_+3A_nfolds">nfolds</code></td>
<td>
<p>number of desired output folds. Default value of NULL makes a reasonable guess based on sample size.</p>
</td></tr>
<tr><td><code id="stratify_spatial_+3A_nsubclusters">nsubclusters</code></td>
<td>
<p>intermediate number of clusters randomly split into nfolds. Default value of NULL makes a reasonable guess based on sample size.
If you specify this manually, it should be an integer multiple of nfolds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Examples.
</p>


<h3>Value</h3>

<p>Returns a SpatialPoints dataframe with the data.frame containing fold designation for each point.
</p>


<h3>Author(s)</h3>

<p>Cory Merow <a href="mailto:cory.merow@gmail.com">cory.merow@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{

# load in sample data

 library(S4DM)
 library(terra)
 library(sf)

 # occurrence points
   data("sample_points")
   occurrences &lt;- sample_points


 occurrences &lt;- st_as_sf(x = occurrences,coords = c(1,2))

manual &lt;- stratify_spatial(occurrence_sf = occurrences,nfolds = 5,nsubclusters = 5)
default &lt;- stratify_spatial(occurrence_sf = occurrences)


}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
