<!DOCTYPE html><html lang="en"><head><title>Help for package esemifar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {esemifar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#esemifar'><p>esemifar: A package for data-driven nonparametric estimation of the trend and</p>
its derivatives in equidistant time series.</a></li>
<li><a href='#airLDN'><p>Daily Observations of the Air Quality Index of London (Britain)</p></a></li>
<li><a href='#arma_to_ar'><p>AR Representation of an ARMA Model</p></a></li>
<li><a href='#arma_to_ma'><p>MA Representation of an ARMA Model</p></a></li>
<li><a href='#critMatlm'><p>FARIMA Order Selection Matrix</p></a></li>
<li><a href='#d_to_coef'><p>Filter Coefficients of the Fractional Differencing Operator</p></a></li>
<li><a href='#dsmoothlm'><p>Data-driven Local Polynomial for the Trend's Derivatives in Equidistant Time</p>
Series</a></li>
<li><a href='#farima_to_ar'><p>AR Representation of a FARIMA Model</p></a></li>
<li><a href='#farima_to_ma'><p>MA Representation of a FARIMA Model</p></a></li>
<li><a href='#fitted.esemifar'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#gdpG7'><p>Quarterly G7 GDP, Q1 1962 to Q4 2019</p></a></li>
<li><a href='#gsmooth'><p>Estimation of Trends and their Derivatives via Local Polynomial Regression</p></a></li>
<li><a href='#plot.esemifar'><p>Plot Method for the Package 'esemifar'</p></a></li>
<li><a href='#plot.esemifar_fc'><p>Plot Method for Class <code>"esemifar_fc"</code></p></a></li>
<li><a href='#predict.esemifar'><p>ESEMIFAR Prediction Method</p></a></li>
<li><a href='#print.esemifar'><p>Print Method for the Package 'esemifar'</p></a></li>
<li><a href='#residuals.esemifar'><p>Extract Model Residuals</p></a></li>
<li><a href='#tsmoothlm'><p>Advanced Data-driven Nonparametric Regression for the Trend in Equidistant</p>
Time Series</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Smoothing Long-Memory Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The nonparametric trend and its derivatives in equidistant time 
    series (TS) with long-memory errors can be estimated. The 
    estimation is conducted via local polynomial regression using an 
    automatically selected bandwidth obtained by a built-in iterative plug-in 
    algorithm or a bandwidth fixed by the user.
    The smoothing methods of the package are described in Letmathe, S., Beran,
    J. and Feng, Y., (2023) &lt;<a href="https://doi.org/10.1080%2F03610926.2023.2276049">doi:10.1080/03610926.2023.2276049</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>fracdiff, stats, utils, smoots, graphics, grDevices, Rcpp,
future, furrr, ggplot2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a></td>
</tr>
<tr>
<td>Acknowledgments:</td>
<td>This work was supported by the German DFG project
GZ-FE-1500-2-1.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-07 10:12:01 UTC; Dominik Schulz</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuanhua Feng [aut] (Paderborn University, Germany),
  Jan Beran [aut] (University of Konstanz, Germany),
  Sebastian Letmathe [aut] (Paderborn University, Germany),
  Dominik Schulz [aut, cre] (Paderborn University, Germany)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominik Schulz &lt;dominik.schulz@uni-paderborn.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-07 10:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='esemifar'>esemifar: A package for data-driven nonparametric estimation of the trend and
its derivatives in equidistant time series.</h2><span id='topic+esemifar'></span><span id='topic+esemifar-package'></span>

<h3>Description</h3>

<p>The <code>esemifar</code> package provides different applicable functions for the
estimation of the trend or its derivatives in equidistant time series.
The main functions include an automated bandwidth selection method for time
series with long-memory errors.
</p>
<p>An alternative method to create an ESEMIFAR estimation object
stitched together from a nonparametric and a parametric part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esemifar(nonpar_model, par_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="esemifar_+3A_nonpar_model">nonpar_model</code></td>
<td>
<p>an estimation object returned by <code><a href="#topic+gsmooth">gsmooth</a></code>.</p>
</td></tr>
<tr><td><code id="esemifar_+3A_par_model">par_model</code></td>
<td>
<p>an estimation object returned by <code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code> fitted
to the residuals of <code>nonpar_model</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main function <code><a href="#topic+tsmoothlm">tsmoothlm</a></code> already returns a fully estimated
ESEMIFAR model. In some instances, alternative specifications of the
nonparametric and parametric model parts are needed, for which
<code><a href="#topic+tsmoothlm">tsmoothlm</a></code> with its automated estimation algorithm does not
provide sufficient flexibility. Therefore, this function allows to stitch
together a nonparametric model part returned by <code><a href="#topic+gsmooth">gsmooth</a></code> and
a FARIMA part for the residuals obtained via <code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code>.
The resulting object can then be used for forecasting.
</p>


<h3>Value</h3>

<p>The function returns a list of class <code>"esemifar"</code> with elements
<code>nonpar_model</code> and <code>par_model</code>.
</p>


<h3>Functions (version 1.0.0)</h3>

<p>The <code>esemifar</code> functions are either meant for calculating nonparametric
estimates of the trend of a time series or its derivatives.
</p>
<p><code>dsmoothlm</code> is a function that calculates the derivatives of the
trend after obtaining the optimal bandwidth by an iterative plug-in
algorithm.
</p>
<p><code>tsmoothlm</code> is the central function of the package. It allows
the user to conduct a local polynomial regression of the trend based on
an optimal bandwidth that is obtained by an iterative plug-in algorithm.
Inflation rate (and other factors) can be manually
and individually adjusted as arguments in the function
(see also: <code><a href="#topic+tsmoothlm">tsmoothlm</a></code>).
</p>
<p><code>critMatlm</code> is a quick tool for the calculation of information criteria
for FARIMA(<code class="reqn">p,d,q</code>) models with different order combinations <code class="reqn">p</code> and
<code class="reqn">q</code>. The function returns a matrix with the obtained values of the
selected criterion for the different combinations of <code class="reqn">p</code> and <code class="reqn">q</code>
(see also: <code><a href="#topic+critMatlm">critMatlm</a></code>).
</p>


<h3>Datasets</h3>

<p>The package includes two datasets: <code>airLDN</code> (see also:
<code><a href="#topic+airLDN">airLDN</a></code>) with daily observations of individual air pollutants
from 2014 to 2020 and <code>gdpG7</code> (see also: <code><a href="#topic+gdpG7">gdpG7</a></code>) that has
data concerning the quarterly G7 GDP between Q1 1962 and Q4 2019.
</p>


<h3>License</h3>

<p>The package is distributed under the General Public License v3
([GPL-3](https://tldrlegal.com/license/gnu-general-public-license-v3-(gpl-3))).
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Yuanhua Feng (Department of Economics, Paderborn University), <br />
Author of the Algorithms <br />
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li><p> Sebastian Letmathe, <br />
Author (and Original Package Creator and Maintainer)
</p>
</li>
<li><p> Dominik Schulz, <br />
Author and Current Package Creator and Maintainer
</p>
</li></ul>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>References</h3>

<p>Beran, J. and Y. Feng (2002a). Iterative plug-in algorithms for SEMIFAR
models - definition, convergence, and asymptotic properties. Journal of
Computational and Graphical Statistics 11(3), 690-713.
</p>
<p>Beran, J. and Feng, Y. (2002b). Local polynomial fitting with long-memory,
short-memory and antipersistent errors. Annals of the Institute of
Statistical Mathematics, 54(2), 291-311.
</p>
<p>Beran, J. and Feng, Y. (2002c). SEMIFAR models - a semiparametric approach
to modelling trends, longrange dependence and nonstationarity. Computational
Statistics &amp; Data Analysis 40(2), 393-419.
</p>
<p>Letmathe, S., Beran, J. and Feng, Y. (2023). An extended exponential SEMIFAR
model with application in R. Communications in Statistics - Theory and Methods:
1-13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lgdp &lt;- log(esemifar::gdpG7$gdp)
nonpar &lt;- gsmooth(lgdp, b = 0.15)
res &lt;- nonpar$res
par &lt;- fracdiff::fracdiff(res, nar = 1, nma = 1)
model &lt;- esemifar(nonpar_model = nonpar, par_model = par)
model

</code></pre>

<hr>
<h2 id='airLDN'>Daily Observations of the Air Quality Index of London (Britain)</h2><span id='topic+airLDN'></span>

<h3>Description</h3>

<p>A dataset that contains daily observations of individual air pollutants
from 2014 to 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airLDN
</code></pre>


<h3>Format</h3>

<p>A data frame with 2552 rows and 8 variables:
</p>

<dl>
<dt>date</dt><dd><p>the observation date</p>
</dd>
<dt>pm25</dt><dd><p>particle matter with an aerodynamic diameter smaller than 2.5
<code class="reqn">\mu</code>m</p>
</dd>
<dt>pm10</dt><dd><p>particle matter with an aerodynamic diameter smaller than 10
<code class="reqn">\mu</code>m</p>
</dd>
<dt>o3</dt><dd><p>ozone or trioxygen</p>
</dd>
<dt>no2</dt><dd><p>nitrogen dioxide</p>
</dd>
<dt>so2</dt><dd><p>sulphur dioxide</p>
</dd>
<dt>co</dt><dd><p>carbon monoxide</p>
</dd>
<dt>AQI</dt><dd><p>composite air quality index</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data can be obtained from the World Air Quality Project.
</p>
<p><a href="https://aqicn.org/city/london">https://aqicn.org/city/london</a>
</p>

<hr>
<h2 id='arma_to_ar'>AR Representation of an ARMA Model</h2><span id='topic+arma_to_ar'></span>

<h3>Description</h3>

<p>Output has representation with positive signs (on the right-hand side of the equation); inputs are both with positive signs (on right-hand side of equation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_to_ar(ar = numeric(0), ma = numeric(0), max_i = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_to_ar_+3A_ar">ar</code></td>
<td>
<p>the AR-coefficient series ordered by lag.</p>
</td></tr>
<tr><td><code id="arma_to_ar_+3A_ma">ma</code></td>
<td>
<p>the MA-coefficient series ordered by lag.</p>
</td></tr>
<tr><td><code id="arma_to_ar_+3A_max_i">max_i</code></td>
<td>
<p>the maximum index up until which to return the coefficient series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the ARMA model
</p>
<p style="text-align: center;"><code class="reqn">X_t = ar_1 X_{t-1} + ... + ar_p X_{t-p}+ma_1 e_{t-1}+...+ma_q e_{t-q}+e_t,</code>
</p>

<p>where <code class="reqn">e_t</code> are the innovations. <code class="reqn">ar_i</code>, <code class="reqn">i=1, ..., p</code>, are the AR-coefficients to pass to the
argument <code>ar</code>, <code class="reqn">ma_j</code>, <code class="reqn">j = 1, ..., q</code>, are the MA-coefficients
to pass to the argument <code>ma</code>.The function then returns the coefficients
from the corresponding infinite-order AR-representation
</p>
<p style="text-align: center;"><code class="reqn">-e_t = c_0 X_t + c_1 X_{t-1}+c_2 X_{t-2} + c_3 X_{t-3} + ...,</code>
</p>

<p>where <code class="reqn">c_l</code>, <code class="reqn">l = 0, 1, 2, ...</code>, are the coefficients. Following this
notation, <code class="reqn">c_0 = -1</code> by definition.
</p>


<h3>Value</h3>

<p>A numeric vector is returned.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>arma_to_ar(ar = 0.75, ma = 0.5, max_i = 100)

</code></pre>

<hr>
<h2 id='arma_to_ma'>MA Representation of an ARMA Model</h2><span id='topic+arma_to_ma'></span>

<h3>Description</h3>

<p>Output has representation with positive signs (on the right-hand side of the equation); inputs are both with positive signs (on right-hand side of equation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_to_ma(ar = numeric(0), ma = numeric(0), max_i = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_to_ma_+3A_ar">ar</code></td>
<td>
<p>the AR-coefficient series ordered by lag.</p>
</td></tr>
<tr><td><code id="arma_to_ma_+3A_ma">ma</code></td>
<td>
<p>the MA-coefficient series ordered by lag.</p>
</td></tr>
<tr><td><code id="arma_to_ma_+3A_max_i">max_i</code></td>
<td>
<p>the maximum index up until which to return the coefficient series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the ARMA model
</p>
<p style="text-align: center;"><code class="reqn">X_t = ar_1 X_{t-1} + ... + ar_p X_{t-p}+ma_1 e_{t-1}+...+ma_q e_{t-q}+e_t,</code>
</p>

<p>where <code class="reqn">e_t</code> are the innovations. <code class="reqn">ar_i</code>, <code class="reqn">i=1, ..., p</code>, are the AR-coefficients to pass to the
argument <code>ar</code>, <code class="reqn">ma_j</code>, <code class="reqn">j = 1, ..., q</code>, are the MA-coefficients
to pass to the argument <code>ma</code>.The function then returns the coefficients
from the corresponding infinite-order MA-representation
</p>
<p style="text-align: center;"><code class="reqn">X_t = c_0 e_t + c_1 e_{t-1}+c_2 e_{t-2} + c_3 e_{t-3} + ...,</code>
</p>

<p>where <code class="reqn">c_l</code>, <code class="reqn">l = 0, 1, 2, ...</code>, are the coefficients. Following this
notation, <code class="reqn">c_0 = 1</code> by definition.
</p>


<h3>Value</h3>

<p>A numeric vector is returned.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>arma_to_ma(ar = 0.75, ma = 0.5, max_i = 100)

</code></pre>

<hr>
<h2 id='critMatlm'>FARIMA Order Selection Matrix</h2><span id='topic+critMatlm'></span>

<h3>Description</h3>

<p>An information criterion is calculated for different orders of a fractionally
integrated autoregressive-moving-average (FARIMA) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critMatlm(X, p.max = 5, q.max = 5, criterion = c("bic", "aic"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="critMatlm_+3A_x">X</code></td>
<td>
<p>a numeric vector that contains the observed time series ordered
from past to present; the series is assumed to follow an FARIMA process.</p>
</td></tr>
<tr><td><code id="critMatlm_+3A_p.max">p.max</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
autoregressive order to calculate the criterion for; is set to <code>5</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="critMatlm_+3A_q.max">q.max</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
moving-average order to to calculate the criterion for; is set to <code>5</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="critMatlm_+3A_criterion">criterion</code></td>
<td>
<p>a character value that defines the information criterion
that will be calculated; the Bayesian Information Criterion (<code>"bic"</code>)
and Akaike Information Criterion (<code>"aic"</code>) are the supported choices;
is set to <code>"bic"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The series passed to <code>X</code> is assumed to follow an
FARIMA(<code class="reqn">p,d,q</code>) model. A <code>p.max + 1</code> by <code>q.max + 1</code> matrix is
calculated for this series. More precisely, the criterion chosen via the
argument <code>criterion</code> is calculated for all combinations of orders
<code class="reqn">p = 0, 1, ..., p_{max}</code> and
<code class="reqn">q = 0, 1, ..., q_{max}</code>.
</p>
<p>Within the function, two information criteria are supported: the Bayesian
Information Criterion (BIC) and Akaike's Information Criterion (AIC). The AIC
is given by
</p>
<p style="text-align: center;"><code class="reqn">AIC_{p,q} := \ln(\hat{\sigma}_{p,q}^{2}) + \frac{2(p+q)}{n},</code>
</p>

<p>where <code class="reqn">\hat{\sigma}_{p,q}^{2}</code> is the estimated
innovation variance, <code class="reqn">p</code> and <code class="reqn">q</code> are the ARMA orders and <code class="reqn">n</code> is
the number of observations.
</p>
<p>The BIC, on the other hand, is defined by
</p>
<p style="text-align: center;"><code class="reqn">BIC_{p,q} := k \ln(n) - 2\ln(\hat{L})</code>
</p>

<p>with <code class="reqn">k</code> being the number of estimated parameters and
<code class="reqn">\hat{L}</code> being the estimated Log-Likelihood. Since the parameter
<code class="reqn">k</code> only differs with respect to the orders <code class="reqn">p</code> and <code class="reqn">q</code> for all
estimated models, the term <code class="reqn">k \ln(n)</code> is reduced to
<code class="reqn">(p + q) \ln(n)</code> within the function. Exemplary,
if the mean of the series is estimated as well, it is usually considered
within the parameter <code class="reqn">k</code> when calculating the BIC.
However, since the mean is estimated for all models, not considering this
estimated parameter within the calculation of the BIC will reduce all BIC
values by the same amount of <code class="reqn">\ln(n)</code>. Therefore, the selection
via this simplified criterion is still valid, if the number of the estimated
parameters only differs with respect to <code class="reqn">p</code> and <code class="reqn">q</code> between the
models that the BIC is obtained for.
</p>
<p>The optimal orders are considered to be the ones which minimize either the
BIC or the AIC. The use of the BIC is however recommended, because the BIC
is consistent, whereas the AIC is not.
</p>
<p>NOTE:
</p>
<p>Within this function, the <code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code> function of the
<code>fracdiff</code> package is used throughout for
the estimation of FARIMA models.
</p>


<h3>Value</h3>

<p>The function returns a <code>p.max + 1</code> by <code>q.max + 1</code> matrix, where the
rows represent the AR orders from <code class="reqn">p = 0</code> to <code class="reqn">p = p_{max}</code>
and the columns represent the MA orders from <code class="reqn">q = 0</code> to
<code class="reqn">q = q_{max}</code>. The values within the matrix are the values of
the previously selected information criterion for the different combinations
of <code class="reqn">p</code> and <code class="reqn">q</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics, Paderborn
University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Simulate a FARIMA(2, 0.3 ,1) process
set.seed(1)
X.sim &lt;- fracdiff::fracdiff.sim(n = 1000, ar = c(1.2, -0.71), ma = -0.46,
                               d = 0.3)$series
# Application of the function with BIC-criterion
BIC_mat &lt;- critMatlm(X.sim)
BIC_mat
# determining the optimal order
smoots::optOrd(BIC_mat)
</code></pre>

<hr>
<h2 id='d_to_coef'>Filter Coefficients of the Fractional Differencing Operator</h2><span id='topic+d_to_coef'></span>

<h3>Description</h3>

<p>Output is with positive signs on the left-hand side of the equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d_to_coef(d, max_i = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d_to_coef_+3A_d">d</code></td>
<td>
<p>the fractional differencing coefficient.</p>
</td></tr>
<tr><td><code id="d_to_coef_+3A_max_i">max_i</code></td>
<td>
<p>the maximum index up until which to return the coefficient series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the FARIMA model
</p>
<p style="text-align: center;"><code class="reqn">(1-B)^d Y_t = ar_1 X_{t-1} + ... + ar_p X_{t-p}+ma_1 e_{t-1}+...+ma_q e_{t-q}+e_t,</code>
</p>

<p>where <code class="reqn">e_t</code> are the innovations and where <code class="reqn">X_t=(1-B)^d Y_t</code>.
<code class="reqn">d</code> is the fractional differencing
coefficient.
</p>
<p>The fractional differencing operator <code class="reqn">(1-B)^d</code> can alternatively be expressed
as an infinite coefficient series, so that
</p>
<p style="text-align: center;"><code class="reqn">(1-B)^d=\sum_{l=0}^{\infty}b_l B^k,</code>
</p>

<p>where <code class="reqn">B</code> is the backshift operator and where <code class="reqn">b_l</code>, <code class="reqn">l=0,1,2,...</code>,
are the coefficients. Note that <code class="reqn">b_0=1</code> by definition.
</p>
<p>The function returns the series of coefficients <code class="reqn">\{b_l, l =0,1,2,...\}</code>.
</p>


<h3>Value</h3>

<p>A numeric vector is returned.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>d_to_coef(d = 0.3, max_i = 100)

</code></pre>

<hr>
<h2 id='dsmoothlm'>Data-driven Local Polynomial for the Trend's Derivatives in Equidistant Time
Series</h2><span id='topic+dsmoothlm'></span>

<h3>Description</h3>

<p>This function runs through an iterative process in order to find the
optimal bandwidth for the nonparametric estimation of the first or second
derivative of the trend in an equidistant time series (with long-memory
errors) and subsequently employs the obtained bandwidth via local
polynomial regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsmoothlm(
  y,
  d = c(1, 2),
  pmin = c(0, 1, 2, 3, 4, 5),
  pmax = c(0, 1, 2, 3, 4, 5),
  qmin = c(0, 1, 2, 3, 4, 5),
  qmax = c(0, 1, 2, 3, 4, 5),
  mu = c(0, 1, 2, 3),
  mu.p = c(0, 1, 2, 3),
  pp = c(1, 3),
  bStart.p = 0.15,
  InfR.p = c("Opt", "Nai", "Var")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsmoothlm_+3A_y">y</code></td>
<td>
<p>a numeric vector that contains the time series ordered from past to
present.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_d">d</code></td>
<td>
<p>an integer <code>1</code> or <code>2</code> that defines the order of
derivative; the default is <code>d = 1</code>.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_pmin">pmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_pmax">pmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_qmin">qmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_qmax">qmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_mu">mu</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function and thus defines the kernel
function that will be used within the local polynomial regression; is set to
<code>1</code> by default.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_mu.p">mu.p</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function for the iterative process to
obtain initial estimates for <code class="reqn">c_f</code>, <code class="reqn">d</code> and <code class="reqn">b_0</code>; is set to
<code>1</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number</strong> </td><td style="text-align: left;"> <strong>Kernel</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>2</code> </td><td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>3</code> </td><td style="text-align: left;"> Triweight Kernel
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_pp">pp</code></td>
<td>
<p>an integer <code>1</code> (local linear regression) or <code>3</code> (local
cubic regression) that indicates the order of polynomial upon which
<code class="reqn">c_f</code>, <code class="reqn">d</code> and <code class="reqn">b_0</code> will be calculated by
<code><a href="#topic+tsmoothlm">tsmoothlm</a></code>; the default is <code>pp = 1</code>.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_bstart.p">bStart.p</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process to obtain initial estimates for <code class="reqn">c_f</code>,
<code class="reqn">d</code> and <code class="reqn">b_0</code>; should be <code class="reqn">&gt; 0</code>; is set to <code>0.15</code> by default.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_infr.p">InfR.p</code></td>
<td>
<p>a character object that represents the inflation
rate in the form <code class="reqn">h_d = h^a</code> of the bandwidth for the iterative process
to obtain initial estimates for <code class="reqn">c_f</code>,
<code class="reqn">d</code> and <code class="reqn">b_0</code>; is set to <code>"Opt"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trend is estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> and is assumed to follow a FARIMA(<code class="reqn">p, d, q</code>)
model (see also Beran and Feng, 2002).
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
Asymptotic Mean Squared Error (AMISE), is based on the proposal of Beran
and Feng (2002a).
</p>
<p>The variance factor <code class="reqn">c_f</code>, the long memory parameter <code class="reqn">d</code> and the
starting bandwidth <code class="reqn">b0</code> are first obtained from a pilot-estimation of
the time series' nonparametric trend (<code class="reqn">\nu = 0</code>) with polynomial order
<code class="reqn">p_p</code>. The estimate is then plugged into the iterative procedure for
estimating the first or second derivative (<code class="reqn">\nu = 1</code> or <code class="reqn">\nu = 2</code>).
For further details on the asymptotic theory or the algorithm, we refer the
user to Letmathe, Beran and Feng (2023).
</p>
<p>The function itself is applicable in the following way: Based on a data input
<code>y</code>, an order of polynomial <code>pp</code> for the variance factor estimation
procedure, a starting value for the relative bandwidth <code>bStart.p</code> in the
variance factor estimation procedure and a kernel function defined by the
smoothness parameter <code>mu</code>, an optimal bandwidth is numerically calculated
for the trend's derivative of order <code>d</code>. In fact, aside from the input
vector <code>y</code>, every argument has a default setting that can be adjusted for
the individual case. However, it is recommended to initially use the default
values for the estimation of the
first derivative and adjust the argument <code>d</code> to <code>d = 2</code> for the
estimation of the second derivative.
The initial bandwidth does not affect the resulting optimal bandwidth in
theory. However in practice, local minima of the AMISE can influence the
results. For more specific information on the input arguments consult the
section <em>Arguments</em>.
</p>
<p>After the bandwidth estimation, the nonparametric derivative of the series
is calculated with respect to the obtained optimal bandwidth by means of a
local polynomial regression. The output object is then a list that contains,
among other components, the original time series, the estimates of the
derivative and the estimated optimal bandwidth.
</p>
<p>The default print method for this function delivers key numbers such as
the iteration steps and the generated optimal bandwidth rounded to the fourth
decimal. The exact numbers and results such as the estimated nonparametric
trend series are saved within the output object and can be addressed via the
<code>$</code> sign.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt>b0</dt><dd><p>the optimal bandwidth chosen by the IPI-algorithm.</p>
</dd>
<dt>bStart.p</dt><dd><p>the starting bandwidth for the nonparametric trend estimation
that leads to the initial estimates; input argument.</p>
</dd>
<dt>cf0</dt><dd><p>the estimated variance factor.</p>
</dd>
<dt>InfR.p</dt><dd><p>the inflation rate setting.</p>
</dd>
<dt>iterations</dt><dd><p>the bandwidths of the single iterations steps</p>
</dd>
<dt>mu.p</dt><dd><p>the smoothness parameter of the second order kernel; input
argument.</p>
</dd>
<dt>n</dt><dd><p>the number of observations.</p>
</dd>
<dt>niterations</dt><dd><p>the total number of iterations until convergence.</p>
</dd>
<dt>orig</dt><dd><p>the original input series; input argument.</p>
</dd>
<dt>p</dt><dd><p>the order of polynomial for the local polynomial
regression used within derivative estimation procedure.</p>
</dd>
<dt>pp</dt><dd><p>the order of polynomial for the local polynomial
regression used in the pilot estimation; input argument.</p>
</dd>
<dt>v</dt><dd><p>the considered order of the trend's derivative; input argument
<code>d</code>.</p>
</dd>
<dt>ws</dt><dd><p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt><dd><p>the nonparametric estimates of the derivative.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Yuanhua Feng (Department of Economics, Paderborn University), <br />
Author of the Algorithms <br />
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li><p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn
University), <br />
Package Creator and Maintainer
</p>
</li>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics, Paderborn
University), <br />
Author
</p>
</li></ul>



<h3>References</h3>

<p>Letmathe, S., Beran, J. and Feng, Y. (2023). An extended exponential SEMIFAR
model with application in R. Communications in Statistics - Theory and Methods:
1-13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Logarithm of test data
test_data &lt;- gdpG7
y &lt;- log(test_data$gdp)
n &lt;- length(y)
t &lt;- seq(from = 1962, to = 2020, length.out = n)

# Applied dsmooth function for the trend's first derivative
result_d &lt;- dsmoothlm(y, d = 1, pp = 1, pmax = 1, qmax = 1, InfR.p = "Opt")
estim &lt;- result_d$ye

# Plot of the results
plot(t, estim, xlab = "Year", ylab = "First derivative", type = "l",
 main = paste0("Estimated first derivative of the trend for log-quarterly ",
 "G7-GDP, Q1 1962 - Q4 2019"), cex.axis = 0.8, cex.main = 0.8,
 cex.lab = 0.8, bty = "n")

# Print result
result_d

# The main function "dsmoothlm"------------------------------------------
</code></pre>

<hr>
<h2 id='farima_to_ar'>AR Representation of a FARIMA Model</h2><span id='topic+farima_to_ar'></span>

<h3>Description</h3>

<p>Output has representation with positive signs (on the right-hand side of the equation); inputs are both with positive signs (on right-hand side of equation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>farima_to_ar(ar = numeric(0), ma = numeric(0), d = 0, max_i = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="farima_to_ar_+3A_ar">ar</code></td>
<td>
<p>the AR-coefficient series ordered by lag.</p>
</td></tr>
<tr><td><code id="farima_to_ar_+3A_ma">ma</code></td>
<td>
<p>the MA-coefficient series ordered by lag.</p>
</td></tr>
<tr><td><code id="farima_to_ar_+3A_d">d</code></td>
<td>
<p>the fractional differencing coefficient.</p>
</td></tr>
<tr><td><code id="farima_to_ar_+3A_max_i">max_i</code></td>
<td>
<p>the maximum index up until which to return the coefficient series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the FARIMA model
</p>
<p style="text-align: center;"><code class="reqn">(1-B)^d Y_t = ar_1 X_{t-1} + ... + ar_p X_{t-p}+ma_1 e_{t-1}+...+ma_q e_{t-q}+e_t,</code>
</p>

<p>where <code class="reqn">e_t</code> are the innovations and where <code class="reqn">X_t=(1-B)^d Y_t</code>.
<code class="reqn">ar_i</code>, <code class="reqn">i=1, ..., p</code>, are the AR-coefficients to pass to the
argument <code>ar</code>, <code class="reqn">ma_j</code>, <code class="reqn">j = 1, ..., q</code>, are the MA-coefficients
to pass to the argument <code>ma</code>. <code class="reqn">d</code> is the fractional differencing
coefficient. The function then returns the coefficients
from the corresponding infinite-order AR-representation
</p>
<p style="text-align: center;"><code class="reqn">-e_t = c_0 Y_t + c_1 Y_{t-1}+c_2 Y_{t-2} + c_3 Y_{t-3} + ...,</code>
</p>

<p>where <code class="reqn">c_l</code>, <code class="reqn">l = 0, 1, 2, ...</code>, are the coefficients. Following this
notation, <code class="reqn">c_0 = -1</code> by definition.
</p>


<h3>Value</h3>

<p>A numeric vector is returned.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>farima_to_ar(ar = 0.75, ma = 0.5, d = 0.3, max_i = 100)

</code></pre>

<hr>
<h2 id='farima_to_ma'>MA Representation of a FARIMA Model</h2><span id='topic+farima_to_ma'></span>

<h3>Description</h3>

<p>Output has representation with positive signs (on the right-hand side of the equation); inputs are both with positive signs (on right-hand side of equation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>farima_to_ma(ar = numeric(0), ma = numeric(0), d = 0, max_i = 1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="farima_to_ma_+3A_ar">ar</code></td>
<td>
<p>the AR-coefficient series ordered by lag.</p>
</td></tr>
<tr><td><code id="farima_to_ma_+3A_ma">ma</code></td>
<td>
<p>the MA-coefficient series ordered by lag.</p>
</td></tr>
<tr><td><code id="farima_to_ma_+3A_d">d</code></td>
<td>
<p>the fractional differencing coefficient.</p>
</td></tr>
<tr><td><code id="farima_to_ma_+3A_max_i">max_i</code></td>
<td>
<p>the maximum index up until which to return the coefficient series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the FARIMA model
</p>
<p style="text-align: center;"><code class="reqn">(1-B)^d Y_t = ar_1 X_{t-1} + ... + ar_p X_{t-p}+ma_1 e_{t-1}+...+ma_q e_{t-q}+e_t,</code>
</p>

<p>where <code class="reqn">e_t</code> are the innovations and where <code class="reqn">X_t=(1-B)^d Y_t</code>.
<code class="reqn">ar_i</code>, <code class="reqn">i=1, ..., p</code>, are the AR-coefficients to pass to the
argument <code>ar</code>, <code class="reqn">ma_j</code>, <code class="reqn">j = 1, ..., q</code>, are the MA-coefficients
to pass to the argument <code>ma</code>. <code class="reqn">d</code> is the fractional differencing coefficient.
The function then returns the coefficients
from the corresponding infinite-order AR-representation
</p>
<p style="text-align: center;"><code class="reqn">Y_t = c_0 e_t + c_1 e_{t-1}+c_2 e_{t-2} + c_3 e_{t-3} + ...,</code>
</p>

<p>where <code class="reqn">c_l</code>, <code class="reqn">l = 0, 1, 2, ...</code>, are the coefficients. Following this
notation, <code class="reqn">c_0 = 1</code> by definition.
</p>


<h3>Value</h3>

<p>A numeric vector is returned.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>farima_to_ma(ar = 0.75, ma = 0.5, d = 0.3, max_i = 100)

</code></pre>

<hr>
<h2 id='fitted.esemifar'>Extract Model Fitted Values</h2><span id='topic+fitted.esemifar'></span>

<h3>Description</h3>

<p>Generic function which extracts fitted values from a <code>esemifar</code> class
object. Both <code>fitted</code> and <code>fitted.values</code> can be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.esemifar_+3A_object">object</code></td>
<td>
<p>an object from the <code>esemifar</code> class.</p>
</td></tr>
<tr><td><code id="fitted.esemifar_+3A_...">...</code></td>
<td>
<p>included for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted values extracted from a <code>esemifar</code> class object.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn University), <br />
</p>
</li></ul>


<hr>
<h2 id='gdpG7'>Quarterly G7 GDP, Q1 1962 to Q4 2019</h2><span id='topic+gdpG7'></span>

<h3>Description</h3>

<p>A dataset that contains the (seasonally adjusted) Gross
Domestic Product of the G7 nations from the first quarter of 1962 to the
fourth quarter of 2019
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdpG7
</code></pre>


<h3>Format</h3>

<p>A data frame with 232 rows and 3 variables:
</p>

<dl>
<dt>year</dt><dd><p>the observation year</p>
</dd>
<dt>quarter</dt><dd><p>the observation quarter in the given year</p>
</dd>
<dt>gdp</dt><dd><p>the volume Index of the Gross Domestic Product of the G7 nations</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was obtained from the Organization for Economic Co-operation
and Development (OECD)
</p>
<p><a href="https://data.oecd.org/gdp/quarterly-gdp.htm#indicator-chart">https://data.oecd.org/gdp/quarterly-gdp.htm#indicator-chart</a>
</p>

<hr>
<h2 id='gsmooth'>Estimation of Trends and their Derivatives via Local Polynomial Regression</h2><span id='topic+gsmooth'></span>

<h3>Description</h3>

<p>This function is an R function for estimating the trend function
and its derivatives in an equidistant time series with local polynomial
regression and a fixed bandwidth given beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsmooth(y, v = 0, p = v + 1, mu = 1, b = 0.15, bb = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gsmooth_+3A_y">y</code></td>
<td>
<p>a numeric vector that contains the time series data ordered from
past to present.</p>
</td></tr>
<tr><td><code id="gsmooth_+3A_v">v</code></td>
<td>
<p>an integer <code>0</code>, <code>1</code>, ... that represents the order of
derivative that will be estimated; is set to <code>v = 0</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number (<code>v</code>)</strong> </td><td style="text-align: left;"> <strong>Degree of derivative</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> The function <em>f(x)</em> itself</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> The first derivative <em>f'(x)</em></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>2</code> </td><td style="text-align: left;"> The second derivative <em>f&rdquo;(x)</em></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>...</code> </td><td style="text-align: left;"> ...
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="gsmooth_+3A_p">p</code></td>
<td>
<p>an integer <code class="reqn">&gt;= (</code> <code>v</code> <code class="reqn">+ 1)</code> that represents the order
of polynomial; <code>p - v</code> must be an odd number; is set to <code>v + 1</code>
by default.
</p>
<p>Exemplary for <code>v = 0</code>:
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number (<code>p</code>)</strong> </td><td style="text-align: left;"> <strong>Polynomial</strong> </td><td style="text-align: center;">
<strong><code>p - v</code></strong> </td><td style="text-align: left;"> <strong><code>p - v</code> odd?</strong> </td><td style="text-align: left;">
<strong><code>p</code> usable?</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> Linear </td><td style="text-align: center;"> 1 </td><td style="text-align: left;"> Yes
</td><td style="text-align: left;"> Yes</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>2</code> </td><td style="text-align: left;"> Quadratic </td><td style="text-align: center;"> 2 </td><td style="text-align: left;"> No
</td><td style="text-align: left;"> No</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>3</code> </td><td style="text-align: left;"> Cubic </td><td style="text-align: center;"> 3 </td><td style="text-align: left;"> Yes
</td><td style="text-align: left;"> Yes</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>...</code> </td><td style="text-align: left;"> ... </td><td style="text-align: center;"> ... </td><td style="text-align: left;"> ...
</td><td style="text-align: left;"> ...
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="gsmooth_+3A_mu">mu</code></td>
<td>
<p>an integer <code>0</code>, <code>1</code>, <code>2</code>, ... that represents the
smoothness parameter of the kernel weighting function that will be used; is
set to <code>1</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number (<code>mu</code>)</strong> </td><td style="text-align: left;"> <strong>Kernel</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>2</code> </td><td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>3</code> </td><td style="text-align: left;"> Triweight Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>...</code> </td><td style="text-align: left;"> ...
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="gsmooth_+3A_b">b</code></td>
<td>
<p>a real number <code class="reqn">0 &lt;</code> <code>b</code> <code class="reqn">&lt; 0.5</code>; represents the
relative bandwidth that will be used for the smoothing process; is set to
<code>0.15</code> by default.</p>
</td></tr>
<tr><td><code id="gsmooth_+3A_bb">bb</code></td>
<td>
<p>can be set to <code>0</code> or <code>1</code>; the parameter controlling the
bandwidth used at the boundary; is set to <code>1</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number (<code>bb</code>)</strong> </td><td style="text-align: left;"> <strong>Estimation procedure at boundary
points</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> Fixed bandwidth on one side with possible large
bandwidth on the other side at the boundary</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> The k-nearest neighbor method will be used
</td>
</tr>

</table>
</td></tr>
</table>


<h3>Details</h3>

<p>The trend or its derivatives are estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> (see also Beran and Feng, 2002).
</p>
<p>This function is part of the package <code>smoots</code> and is used in
the field of analyzing equidistant time series data. It applies the local
polynomial regression method to the input data with an arbitrarily
selectable bandwidth. By these means, the trend as well as its derivatives
can be estimated nonparametrically, even though the result will strongly
depend on the bandwidth given beforehand as an input.
</p>
<p>NOTE:
</p>
<p>The estimates are obtained with regard to the rescaled time points on the
interval <code class="reqn">[0, 1]</code>. Thus, if <code class="reqn">\nu &gt; 0</code>, the estimates might not
reflect the values for the actual time points. To rescale the estimates, we
refer the user to the <code>rescale</code> function of the <code>smoots</code>
package.
</p>
<p>With package version 1.1.0, this function implements C++ code by means
of the <code><a href="Rcpp.html#topic+Rcpp-package">Rcpp</a></code> and
<code>RcppArmadillo</code> packages for
better performance.
</p>


<h3>Value</h3>

<p>The output object is a list with different components:
</p>

<dl>
<dt>b</dt><dd><p>the chosen (relative) bandwidth; input argument.</p>
</dd>
<dt>bb</dt><dd><p>the chosen bandwidth option at the boundaries; input argument.</p>
</dd>
<dt>mu</dt><dd><p>the chosen smoothness parameter for the second order kernel; input
argument.</p>
</dd>
<dt>n</dt><dd><p>the number of observations.</p>
</dd>
<dt>orig</dt><dd><p>the original input series; input argument.</p>
</dd>
<dt>p</dt><dd><p>the chosen order of polynomial; input argument.</p>
</dd>
<dt>res</dt><dd><p>a vector with the estimated residual series; is set to <code>NULL</code>
for <code>v &gt; 0</code>.</p>
</dd>
<dt>v</dt><dd><p>the order of derivative; input argument.</p>
</dd>
<dt>ws</dt><dd><p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt><dd><p>a vector with the estimates of the selected nonparametric order of
derivative on the rescaled time interval <code class="reqn">[0, 1]</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Yuanhua Feng (Department of Economics, Paderborn University), <br />
Author of the Algorithms <br />
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Package Creator and Maintainer
</p>
</li></ul>



<h3>References</h3>

<p>Beran, J. and Feng, Y. (2002). Local polynomial fitting with long-memory,
short-memory and antipersistent errors. Annals of the Institute of
Statistical Mathematics, 54(2), 291-311.
</p>
<p>Feng, Y., Gries, T. and Fritz, M. (2020). Data-driven
local polynomial for the trend and its derivatives in economic time
series. Journal of Nonparametric Statistics, 32:2, 510-533.
</p>
<p>Feng, Y., Gries, T., Letmathe, S. and Schulz, D. (2019). The smoots package
in R for semiparametric modeling of trend stationary time series. Discussion
Paper. Paderborn University. Unpublished.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Logarithm of test data
y &lt;- log(esemifar::gdpG7$gdp)

# Applied gsmooth function for the trend with two different bandwidths
results1 &lt;- gsmooth(y, v = 0, p = 1, mu = 1, b = 0.28, bb = 1)
results2 &lt;- gsmooth(y, v = 0, p = 1, mu = 1, b = 0.11, bb = 1)
trend1 &lt;- results1$ye
trend2 &lt;- results2$ye

# Plot of the results
t &lt;- seq(from = 1962, to = 2019.75, by = 0.25)
plot(t, y, type = "l", xlab = "Year", ylab = "log(US-GDP)", bty = "n",
 lwd = 2,
 main = "Estimated trend for log-quarterly US-GDP, Q1 1947 - Q2 2019")
points(t, trend1, type = "l", col = "red", lwd = 1)
points(t, trend2, type = "l", col = "blue", lwd = 1)
legend("bottomright", legend = c("Trend (b = 0.28)", "Trend (b = 0.11)"),
 fill = c("red", "blue"), cex = 0.6)
title(sub = expression(italic("Figure 1")), col.sub = "gray47",
 cex.sub = 0.6, adj = 0)


</code></pre>

<hr>
<h2 id='plot.esemifar'>Plot Method for the Package 'esemifar'</h2><span id='topic+plot.esemifar'></span>

<h3>Description</h3>

<p>This function regulates how objects created by the package <code>esemifar</code> are
plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
plot(x, t = NULL, rescale = TRUE, which = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.esemifar_+3A_x">x</code></td>
<td>
<p>an input object of class <code>esemifar</code>.</p>
</td></tr>
<tr><td><code id="plot.esemifar_+3A_t">t</code></td>
<td>
<p>an optional vector with time points that will be considered for
the x-axis within the plot; is set to NULL by default and uses a vector
<code>1:length(x$ye)</code> for time points.</p>
</td></tr>
<tr><td><code id="plot.esemifar_+3A_rescale">rescale</code></td>
<td>
<p>a single logical value; is set to <code>TRUE</code> by default;
if the output of a derivative estimation process is passed to <code>x</code> and if
<code>rescale = TRUE</code>, the estimates will be rescaled according to <code>t</code>.</p>
</td></tr>
<tr><td><code id="plot.esemifar_+3A_which">which</code></td>
<td>
<p>one of 1 (observations), 2 (trend), 3 (residuals) or 4
(observations with trend); the default <code>NULL</code> starts an interactive
selection via the console.</p>
</td></tr>
<tr><td><code id="plot.esemifar_+3A_...">...</code></td>
<td>
<p>additional arguments of the standard plot method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
</p>
</li></ul>


<hr>
<h2 id='plot.esemifar_fc'>Plot Method for Class <code>"esemifar_fc"</code></h2><span id='topic+plot.esemifar_fc'></span>

<h3>Description</h3>

<p>Create basic R plots for forecasting objects of class <code>"esemifar_fc"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar_fc'
plot(x, y = NULL, t = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.esemifar_fc_+3A_x">x</code></td>
<td>
<p>an object of class <code>"esemifar_fc"</code>, for example generated by a
call to <code><a href="#topic+predict.esemifar">predict.esemifar</a></code>.</p>
</td></tr>
<tr><td><code id="plot.esemifar_fc_+3A_y">y</code></td>
<td>
<p>currently without use; for compatibility only.</p>
</td></tr>
<tr><td><code id="plot.esemifar_fc_+3A_t">t</code></td>
<td>
<p>a numeric vector with series of time points for observations and
forecasts.</p>
</td></tr>
<tr><td><code id="plot.esemifar_fc_+3A_...">...</code></td>
<td>
<p>further arguments of <code><a href="stats.html#topic+plot.ts">plot.ts</a></code> to adjust
for example the axis limits via <code>xlim</code> and <code>ylim</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a plot method to visualize the forecasting results for an ESEMIFAR
model. Common plot arguments can be implemented to change the
appearance.
</p>


<h3>Value</h3>

<p>This method returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
Author and Package Creator
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>lgdp &lt;- log(esemifar::gdpG7$gdp)
est &lt;- tsmoothlm(lgdp, pmax = 1, qmax = 1)
# Under normality
fc &lt;- predict(est, n.ahead = 10, method = "norm", expo = TRUE)
plot(fc)

</code></pre>

<hr>
<h2 id='predict.esemifar'>ESEMIFAR Prediction Method</h2><span id='topic+predict.esemifar'></span>

<h3>Description</h3>

<p>Point and interval forecasts (under the normality assumption or via a
bootstrap) for fitted ESEMIFAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
predict(
  object,
  n.ahead = 5,
  alpha = c(0.95, 0.99),
  method = c("norm", "boot"),
  bootMethod = c("simple", "advanced"),
  npaths = 5000,
  quant.type = 8,
  boot_progress = TRUE,
  expo = FALSE,
  trend_extrap = c("linear", "constant"),
  future = TRUE,
  num_cores = future::availableCores() - 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.esemifar_+3A_object">object</code></td>
<td>
<p>an object returned by either <code><a href="#topic+tsmoothlm">tsmoothlm</a></code> or
<code><a href="#topic+esemifar">esemifar</a></code>.</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_n.ahead">n.ahead</code></td>
<td>
<p>a single numeric value that represents the forecasting horizon.</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_alpha">alpha</code></td>
<td>
<p>a numeric vector with confidence levels for the forecasting
intervals; the default <code>c(0.95, 0.99)</code> represents 95-percent and
99-percent forecasting interval bounds that will be computed.</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_method">method</code></td>
<td>
<p>whether to obtain the forecasting intervals under the
normality assumption (<code>"norm"</code>) or via a bootstrap (<code>"boot"</code>).</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_bootmethod">bootMethod</code></td>
<td>
<p>only for <code>method = "boot"</code>: whether to simulate
future paths only (<code>"simple"</code>) or whether to
re-estimate the FARIMA model for the re-sampled series and to then obtain
simulated predictive roots (<code>"advanced"</code>).</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_npaths">npaths</code></td>
<td>
<p>only for <code>method = "boot"</code>: the number of bootstrap
iterations.</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_quant.type">quant.type</code></td>
<td>
<p>only for <code>method = "boot"</code>: the quantile type as
in the argument <code>type</code> of the function <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_boot_progress">boot_progress</code></td>
<td>
<p>only for <code>method = "boot"</code>: whether to show a
progress bar in the console.</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_expo">expo</code></td>
<td>
<p>whether to exponentiate all results at the end.</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_trend_extrap">trend_extrap</code></td>
<td>
<p>how to extrapolate the estimated trend into the future:
linearly (<code>"linear"</code>) or constantly (<code>"constant"</code>).</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_future">future</code></td>
<td>
<p>only for <code>method = "boot"</code>: use parallel programming
for the bootstrap via the <code>future</code> framework?</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_num_cores">num_cores</code></td>
<td>
<p>only for <code>method = "boot"</code> and <code>future = TRUE</code>:
how many cores to use in the parallel programming.</p>
</td></tr>
<tr><td><code id="predict.esemifar_+3A_...">...</code></td>
<td>
<p>no purpose; for compatibility only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produce point and interval forecasts based on ESEMIFAR models. Throughout,
the infinite-order AR-representation of the parametric FARIMA part is considered
to produce point forecasts and future paths of the series. The trend is usually
extrapolated linearly (or constantly as an alternative).
</p>


<h3>Value</h3>

<p>The function returns a list of class <code>"esemifar"</code> with elements
<code>nonpar_model</code> and <code>par_model</code>.
</p>
<p>A list with various elements is returned.
</p>

<dl>
<dt>obs</dt><dd><p>the observed series.</p>
</dd>
<dt>mean</dt><dd><p>the point forecasts.</p>
</dd>
<dt>lower</dt><dd><p>the lower bounds of the forecasting intervals.</p>
</dd>
<dt>upper</dt><dd><p>the upper bounds of the forecasting intervals.</p>
</dd>
<dt>model</dt><dd><p>the fitted ESEMIFAR model object.</p>
</dd>
<dt>level</dt><dd><p>the confidence levels for the forecasting intervals.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>lgdp &lt;- log(esemifar::gdpG7$gdp)
est &lt;- tsmoothlm(lgdp, pmax = 1, qmax = 1)
# Under normality
fc &lt;- predict(est, n.ahead = 10, method = "norm", expo = TRUE)
fc$mean
fc$lower
fc$upper

</code></pre>

<hr>
<h2 id='print.esemifar'>Print Method for the Package 'esemifar'</h2><span id='topic+print.esemifar'></span>

<h3>Description</h3>

<p>This function regulates how objects created by the package <code>esemifar</code> are
printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.esemifar_+3A_x">x</code></td>
<td>
<p>an input object of class <code>esemifar</code>.</p>
</td></tr>
<tr><td><code id="print.esemifar_+3A_...">...</code></td>
<td>
<p>included for compatibility; additional arguments will however
not affect the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific employee) (Department of Economics, Paderborn
University), <br />
</p>
</li></ul>


<hr>
<h2 id='residuals.esemifar'>Extract Model Residuals</h2><span id='topic+residuals.esemifar'></span>

<h3>Description</h3>

<p>Generic function which extracts model residuals from a <code>esemifar</code> class
object. Both <code>residuals</code> and its abbreviated form <code>resid</code> can be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.esemifar_+3A_object">object</code></td>
<td>
<p>an object from the <code>esemifar</code> class.</p>
</td></tr>
<tr><td><code id="residuals.esemifar_+3A_...">...</code></td>
<td>
<p>included for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Residuals extracted from a <code>esemifar</code> class object.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn University), <br />
</p>
</li></ul>


<hr>
<h2 id='tsmoothlm'>Advanced Data-driven Nonparametric Regression for the Trend in Equidistant
Time Series</h2><span id='topic+tsmoothlm'></span>

<h3>Description</h3>

<p>This function runs an iterative plug-in algorithm to find the optimal
bandwidth for the estimation of the nonparametric trend in equidistant
time series (with long-memory errors) and then employs the resulting
bandwidth via either local polynomial or kernel regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsmoothlm(
  y,
  pmin = c(0, 1, 2, 3, 4, 5),
  pmax = c(0, 1, 2, 3, 4, 5),
  qmin = c(0, 1, 2, 3, 4, 5),
  qmax = c(0, 1, 2, 3, 4, 5),
  p = c(1, 3),
  mu = c(0, 1, 2, 3),
  InfR = c("Opt", "Nai", "Var"),
  bStart = 0.15,
  bb = c(0, 1),
  cb = 0.05,
  method = c("lpr", "kr")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsmoothlm_+3A_y">y</code></td>
<td>
<p>a numeric vector that contains the time series ordered from past to
present.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_pmin">pmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_pmax">pmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_qmin">qmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_qmax">qmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_p">p</code></td>
<td>
<p>an integer <code>1</code> (local linear regression) or <code>3</code> (local
cubic regression); represents the order of polynomial within the local
polynomial regression (see also the 'Details' section); is set to <code>1</code> by
default; is automatically set to <code>1</code> if <code>method = "kr"</code>.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_mu">mu</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function and thus defines the kernel
function that will be used within the local polynomial regression; is set to
<code>1</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number</strong> </td><td style="text-align: left;"> <strong>Kernel</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>2</code> </td><td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>3</code> </td><td style="text-align: left;"> Triweight Kernel
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_infr">InfR</code></td>
<td>
<p>a character object that represents the inflation
rate in the form <code class="reqn">h_d = h^a</code> for the bandwidth in the estimation of
<code class="reqn">I[m^{(k)}]</code> (see also the 'Details' section); is set to
<code>"Opt"</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Inflation rate</strong> </td><td style="text-align: left;"> <strong>Description</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>"Opt"</code> </td><td style="text-align: left;"> Optimal inflation rate <code class="reqn">a_{p,O}</code>
(<code class="reqn">(5-2d)/(7-2d)</code> for <code>p = 1</code>; <code class="reqn">(9-2d)/(11-2d)</code> for
<code>p = 3</code>)</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>"Nai"</code> </td><td style="text-align: left;"> Naive inflation rate <code class="reqn">a_{p,N}</code>
(<code class="reqn">(5-2d)/(9-2d)</code> for <code>p = 1</code>; <code class="reqn">(9-2d)/(13-2d)</code> for
<code>p = 3</code>)</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>"Var"</code> </td><td style="text-align: left;"> Stable inflation rate <code class="reqn">a_{p,S}</code> (<code class="reqn">1/2</code> for
<code>p = 1</code> and <code>p = 3</code>)
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_bstart">bStart</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process; should be <code class="reqn">&gt; 0</code>; is set to
<code>0.15</code> by default.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_bb">bb</code></td>
<td>
<p>can be set to <code>0</code> or <code>1</code>; the parameter controlling the
bandwidth used at the boundary; is set to <code>1</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number (<code>bb</code>)</strong> </td><td style="text-align: left;"> <strong>Estimation procedure at boundary
points</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> Fixed bandwidth on one side with possible large
bandwidth on the other side at the boundary</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> The <code class="reqn">k</code>-nearest neighbor method will be used
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_cb">cb</code></td>
<td>
<p>a numeric value that indicates the percentage of omitted
observations on each side of the observation period for the automated
bandwidth selection; is set to <code>0.05</code> by default.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_method">method</code></td>
<td>
<p>the final smoothing approach; <code>"lpr"</code> represents the local
polynomial regression, whereas <code>"kr"</code> implements a kernel regression;
is set to <code>"lpr"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trend is estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> and is assumed to follow a FARIMA(<code class="reqn">p, d, q</code>)
model (see also Beran and Feng, 2002a, Beran and Feng, 2002b and Beran
and Feng, 2002c).
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
Asymptotic Mean Squared Error (AMISE), is based on the proposal of Beran
and Feng (2002a).
</p>
<p>The function calculates suitable estimates for <code class="reqn">c_f</code>, the variance
factor, and <code class="reqn">I[m^{(k)}]</code> over different iterations. In each
iteration, a bandwidth is obtained in accordance with the AMISE that once
more serves as an input for the following iteration. The process repeats
until either convergence or the 40th iteration is reached. For further
details on the asymptotic theory or the algorithm, please see Letmathe et
al., 2023.
</p>
<p>To apply the function, the following arguments are needed: a data input
<code>y</code>, an order of polynomial <code>p</code>, a kernel weighting function
defined by the smoothness parameter <code>mu</code>, an inflation rate setting
<code>InfR</code> (see also Beran and Feng, 2002b), a starting value for the
relative bandwidth <code>bStart</code>, a
boundary method <code>bb</code>, a boundary cut-off percentage <code>cb</code> and a
final smoothing method <code>method</code>. In fact, aside from the input vector
<code>y</code>, every argument has a default setting that can be adjusted for the
individual case. Theoretically, the initial bandwidth does not affect the
selected optimal bandwidth. However, in practice local minima of the AMISE
might exist and influence the selected bandwidth. Therefore, the default
setting is <code>bStart = 0.15</code>. In the rare
case of a clearly unsuitable optimal bandwidth, a starting bandwidth that
differs from the default value is a first possible approach to obtain a
better result. Other argument adjustments can be tried as well. For more
specific information on the input arguments consult the section
<em>Arguments</em>.
</p>
<p>When applying the function, an optimal bandwidth is obtained based on a
strongly modified version of the IPI algorithm of Beran and Feng (2002a). In
a second step, the nonparametric trend of the series is calculated with
respect to the chosen bandwidth and the selected regression method (<code>lpf</code>
or <code>kr</code>). Please note that <code>method = "lpf"</code> is strongly recommended
by the authors. Moreover, it is notable that <code>p</code> is automatically set to
<code>1</code> for <code>method = "kr"</code>. The output object is then a list that
contains, among other components, the original time series, the estimated
trend values and the series without the trend.
</p>
<p>The default print method for this function delivers only key numbers such as
the iteration steps and the generated optimal bandwidth rounded to the fourth
decimal. The exact numbers and results such as the estimated nonparametric
trend series are saved within the output object and can be addressed via the
<code>$</code> sign.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt>FARIMA.BIC</dt><dd><p>the Bayesian Information Criterion of the optimal
FARIMA(<code class="reqn">p,d,q</code>) model.</p>
</dd>
<dt>cb</dt><dd><p>the percentage of omitted observations on each side of the
observation period.</p>
</dd>
<dt>b0</dt><dd><p>the optimal bandwidth chosen by the IPI-algorithm.</p>
</dd>
<dt>bb</dt><dd><p>the boundary bandwidth method used within the IPI; always equal to
1.</p>
</dd>
<dt>bStart</dt><dd><p>the starting value of the (relative) bandwidth; input
argument.</p>
</dd>
<dt>cf0</dt><dd><p>the estimated variance factor; in contrast to the definitions
given in the <em>Details</em> section, this object actually contains an
estimated value of <code class="reqn">2\pi c_f</code>, i.e. it corresponds to the estimated sum
of autocovariances.</p>
</dd>
<dt>d.BIC</dt><dd><p>the long-memory parameter of the optimal FARIMA(<code class="reqn">p,d,q</code>)
model.</p>
</dd>
<dt>FARMA.BIC</dt><dd><p>the model fit of the selected FARIMA(<code class="reqn">p,d,q</code> model.</p>
</dd>
<dt>I2</dt><dd><p>the estimated value of <code class="reqn">I[m^{(k)}]</code>.</p>
</dd>
<dt>InfR</dt><dd><p>the setting for the inflation rate according to the chosen
algorithm.</p>
</dd>
<dt>iterations</dt><dd><p>the bandwidths of the single iterations steps</p>
</dd>
<dt>mu</dt><dd><p>the smoothness parameter of the second order kernel; input
argument.</p>
</dd>
<dt>n</dt><dd><p>the number of observations.</p>
</dd>
<dt>niterations</dt><dd><p>the total number of iterations until convergence.</p>
</dd>
<dt>orig</dt><dd><p>the original input series; input argument.</p>
</dd>
<dt>p.BIC</dt><dd><p>the order p of the optimal FARIMA(<code class="reqn">p,d,q</code>) model.</p>
</dd>
<dt>p</dt><dd><p>the order of polynomial used in the IPI-algorithm; also used for the
final smoothing, if <code>method = "lpr"</code>; input argument.</p>
</dd>
<dt>q.BIC</dt><dd><p>the order <code class="reqn">q</code> of the optimal FARIMA(<code class="reqn">p,d,q</code>)
model.</p>
</dd>
<dt>res</dt><dd><p>the estimated residual series.</p>
</dd>
<dt>v</dt><dd><p>the considered order of derivative of the trend; is always zero for
this function.</p>
</dd>
<dt>ws</dt><dd><p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt><dd><p>the nonparametric estimates of the trend.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Yuanhua Feng (Department of Economics, Paderborn University), <br />
Author of the Algorithms <br />
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li><p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Package Creator and Maintainer
</p>
</li>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>References</h3>

<p>Beran, J. and Y. Feng (2002a). Iterative plug-in algorithms for SEMIFAR
models - definition, convergence, and asymptotic properties. Journal of
Computational and Graphical Statistics 11(3), 690-713.
</p>
<p>Beran, J. and Feng, Y. (2002b). Local polynomial fitting with long-memory,
short-memory and antipersistent errors. Annals of the Institute of
Statistical Mathematics, 54(2), 291-311.
</p>
<p>Beran, J. and Feng, Y. (2002c). SEMIFAR models - a semiparametric approach
to modelling trends, longrange dependence and nonstationarity. Computational
Statistics &amp; Data Analysis 40(2), 393-419.
</p>
<p>Letmathe, S., Beran, J. and Feng, Y. (2023). An extended exponential SEMIFAR
model with application in R. Communications in Statistics - Theory and Methods:
1-13.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### Example 1: G7-GDP ###

# Logarithm of test data
# -&gt; the logarithm of the data is assumed to follow the additive model
test_data &lt;- gdpG7
y &lt;- log(test_data$gdp)
n &lt;- length(y)

# Applied tsmooth function for the trend
result &lt;- tsmoothlm(y, p = 1, pmax = 1, qmax = 1, InfR = "Opt")
trend1 &lt;- result$ye

# Plot of the results
t &lt;- seq(from = 1962, to = 2020, length.out = n)
plot(t, y, type = "l", xlab = "Year", ylab = "log(G7-GDP)", bty = "n",
 lwd = 1, lty = 3,
 main = "Estimated trend for log-quarterly G7-GDP, Q1 1962 - Q4 2019")
points(t, trend1, type = "l", col = "red", lwd = 1)
title(sub = expression(italic("Figure 1")), col.sub = "gray47",
 cex.sub = 0.6, adj = 0)
result



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
