<!DOCTYPE html><html><head><title>Help for package esemifar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {esemifar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#esemifar'><p>esemifar: A package for data-driven nonparametric estimation of the trend and</p>
its derivatives in equidistant time series.</a></li>
<li><a href='#airLDN'><p>Daily Observations of the Air Quality Index of London (Britain)</p></a></li>
<li><a href='#critMatlm'><p>FARIMA Order Selection Matrix</p></a></li>
<li><a href='#dsmoothlm'><p>Data-driven Local Polynomial for the Trend's Derivatives in Equidistant Time</p>
Series</a></li>
<li><a href='#fitted.esemifar'><p>Extract Model Fitted Values</p></a></li>
<li><a href='#gdpG7'><p>Quarterly G7 GDP, Q1 1962 to Q4 2019</p></a></li>
<li><a href='#plot.esemifar'><p>Plot Method for the Package 'esemifar'</p></a></li>
<li><a href='#print.esemifar'><p>Print Method for the Package 'esemifar'</p></a></li>
<li><a href='#residuals.esemifar'><p>Extract Model Residuals</p></a></li>
<li><a href='#tsmoothlm'><p>Advanced Data-driven Nonparametric Regression for the Trend in Equidistant</p>
Time Series</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Smoothing Long-Memory Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The nonparametric trend and its derivatives in equidistant time 
    series (TS) with long-memory errors can be estimated. The 
    estimation is conducted via local polynomial regression using an 
    automatically selected bandwidth obtained by a built-in iterative plug-in 
    algorithm or a bandwidth fixed by the user.
    The smoothing methods of the package are described in Letmathe, S., Beran,
    J. and Feng, Y., (2021) <a href="https://ideas.repec.org/p/pdn/ciepap/145.html">https://ideas.repec.org/p/pdn/ciepap/145.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>fracdiff, stats, smoots, graphics, grDevices</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a></td>
</tr>
<tr>
<td>Acknowledgments:</td>
<td>This work was supported by the German DFG project
GZ-FE-1500-2-1.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-22 07:44:32 UTC; Letmode</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuanhua Feng [aut] (Paderborn University, Germany),
  Jan Beran [aut] (University of Konstanz, Germany),
  Sebastian Letmathe [aut, cre] (Paderborn University, Germany),
  Dominik Schulz [aut] (Paderborn University, Germany)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Letmathe &lt;sebastian.letmathe@uni-paderborn.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-22 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='esemifar'>esemifar: A package for data-driven nonparametric estimation of the trend and
its derivatives in equidistant time series.</h2><span id='topic+esemifar'></span><span id='topic+esemifar-package'></span>

<h3>Description</h3>

<p>The <code>esemifar</code> package provides different applicable functions for the
estimation of the trend or its derivatives in equidistant time series.
The main functions include an automated bandwidth selection method for time
series with long-memory errors.
</p>


<h3>Functions (version 1.0.0)</h3>

<p>The <code>esemifar</code> functions are either meant for calculating nonparametric
estimates of the trend of a time series or its derivatives.
</p>
<p><code>dsmoothlm</code> is a function that calculates the derivatives of the
trend after obtaining the optimal bandwidth by an iterative plug-in
algorithm.
</p>
<p><code>tsmoothlm</code> is the central function of the package. It allows
the user to conduct a local polynomial regression of the trend based on
an optimal bandwidth that is obtained by an iterative plug-in algorithm.
Inflation rate (and other factors) can be manually
and individually adjusted as arguments in the function
(see also: <code><a href="#topic+tsmoothlm">tsmoothlm</a></code>).
</p>
<p><code>critMatlm</code> is a quick tool for the calculation of information criteria
for FARIMA(<code class="reqn">p,d,q</code>) models with different order combinations <code class="reqn">p</code> and
<code class="reqn">q</code>. The function returns a matrix with the obtained values of the
selected criterion for the different combinations of <code class="reqn">p</code> and <code class="reqn">q</code>
(see also: <code><a href="#topic+critMatlm">critMatlm</a></code>).
</p>


<h3>Datasets</h3>

<p>The package includes two datasets: <code>airLDN</code> (see also:
<code><a href="#topic+airLDN">airLDN</a></code>) with daily observations of individual air pollutants
from 2014 to 2020 and <code>gdpG7</code> (see also: <code><a href="#topic+gdpG7">gdpG7</a></code>) that has
data concerning the quarterly G7 GDP between Q1 1962 and Q4 2019.
</p>


<h3>License</h3>

<p>The package is distributed under the General Public License v3
([GPL-3](https://tldrlegal.com/license/gnu-general-public-license-v3-(gpl-3))).
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Yuanhua Feng (Department of Economics, Paderborn University), <br />
Author of the Algorithms <br />
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li><p> Sebastian Letmathe, <br />
Package Creator and Maintainer
</p>
</li></ul>



<h3>References</h3>

<p>Beran, J. and Y. Feng (2002a). Iterative plug-in algorithms for SEMIFAR
models - definition, convergence, and asymptotic properties. Journal of
Computational and Graphical Statistics 11(3), 690-713.
</p>
<p>Beran, J. and Feng, Y. (2002b). Local polynomial fitting with long-memory,
short-memory and antipersistent errors. Annals of the Institute of
Statistical Mathematics, 54(2), 291-311.
</p>
<p>Beran, J. and Feng, Y. (2002c). SEMIFAR models - a semiparametric approach
to modelling trends, longrange dependence and nonstationarity. Computational
Statistics &amp; Data Analysis 40(2), 393-419.
</p>
<p>Letmathe, S., Beran, J. and Feng, Y. (2021). An extended exponential SEMIFAR
model with application in R. Discussion Paper. Paderborn University.
</p>

<hr>
<h2 id='airLDN'>Daily Observations of the Air Quality Index of London (Britain)</h2><span id='topic+airLDN'></span>

<h3>Description</h3>

<p>A dataset that contains daily observations of individual air pollutants
from 2014 to 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airLDN
</code></pre>


<h3>Format</h3>

<p>A data frame with 2552 rows and 8 variables:
</p>

<dl>
<dt>date</dt><dd><p>the observation date</p>
</dd>
<dt>pm25</dt><dd><p>particle matter with an aerodynamic diameter smaller than 2.5
<code class="reqn">\mu</code>m</p>
</dd>
<dt>pm10</dt><dd><p>particle matter with an aerodynamic diameter smaller than 10
<code class="reqn">\mu</code>m</p>
</dd>
<dt>o3</dt><dd><p>ozone or trioxygen</p>
</dd>
<dt>no2</dt><dd><p>nitrogen dioxide</p>
</dd>
<dt>so2</dt><dd><p>sulphur dioxide</p>
</dd>
<dt>co</dt><dd><p>carbon monoxide</p>
</dd>
<dt>AQI</dt><dd><p>composite air quality index</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data can be obtained from the World Air Quality Project.
</p>
<p><a href="https://aqicn.org/city/london">https://aqicn.org/city/london</a>
</p>

<hr>
<h2 id='critMatlm'>FARIMA Order Selection Matrix</h2><span id='topic+critMatlm'></span>

<h3>Description</h3>

<p>An information criterion is calculated for different orders of a fractionally
integrated autoregressive-moving-average (FARIMA) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critMatlm(X, p.max = 5, q.max = 5, criterion = c("bic", "aic"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="critMatlm_+3A_x">X</code></td>
<td>
<p>a numeric vector that contains the observed time series ordered
from past to present; the series is assumed to follow an FARIMA process.</p>
</td></tr>
<tr><td><code id="critMatlm_+3A_p.max">p.max</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
autoregressive order to calculate the criterion for; is set to <code>5</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="critMatlm_+3A_q.max">q.max</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
moving-average order to to calculate the criterion for; is set to <code>5</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="critMatlm_+3A_criterion">criterion</code></td>
<td>
<p>a character value that defines the information criterion
that will be calculated; the Bayesian Information Criterion (<code>"bic"</code>)
and Akaike Information Criterion (<code>"aic"</code>) are the supported choices;
is set to <code>"bic"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The series passed to <code>X</code> is assumed to follow an
FARIMA(<code class="reqn">p,d,q</code>) model. A <code>p.max + 1</code> by <code>q.max + 1</code> matrix is
calculated for this series. More precisely, the criterion chosen via the
argument <code>criterion</code> is calculated for all combinations of orders
<code class="reqn">p = 0, 1, ..., p_{max}</code> and
<code class="reqn">q = 0, 1, ..., q_{max}</code>.
</p>
<p>Within the function, two information criteria are supported: the Bayesian
Information Criterion (BIC) and Akaike's Information Criterion (AIC). The AIC
is given by
</p>
<p style="text-align: center;"><code class="reqn">AIC_{p,q} := \ln(\hat{\sigma}_{p,q}^{2}) + \frac{2(p+q)}{n},</code>
</p>

<p>where <code class="reqn">\hat{\sigma}_{p,q}^{2}</code> is the estimated
innovation variance, <code class="reqn">p</code> and <code class="reqn">q</code> are the ARMA orders and <code class="reqn">n</code> is
the number of observations.
</p>
<p>The BIC, on the other hand, is defined by
</p>
<p style="text-align: center;"><code class="reqn">BIC_{p,q} := k \ln(n) - 2\ln(\hat{L})</code>
</p>

<p>with <code class="reqn">k</code> being the number of estimated parameters and
<code class="reqn">\hat{L}</code> being the estimated Log-Likelihood. Since the parameter
<code class="reqn">k</code> only differs with respect to the orders <code class="reqn">p</code> and <code class="reqn">q</code> for all
estimated models, the term <code class="reqn">k \ln(n)</code> is reduced to
<code class="reqn">(p + q) \ln(n)</code> within the function. Exemplary,
if the mean of the series is estimated as well, it is usually considered
within the parameter <code class="reqn">k</code> when calculating the BIC.
However, since the mean is estimated for all models, not considering this
estimated parameter within the calculation of the BIC will reduce all BIC
values by the same amount of <code class="reqn">\ln(n)</code>. Therefore, the selection
via this simplified criterion is still valid, if the number of the estimated
parameters only differs with respect to <code class="reqn">p</code> and <code class="reqn">q</code> between the
models that the BIC is obtained for.
</p>
<p>The optimal orders are considered to be the ones which minimize either the
BIC or the AIC. The use of the BIC is however recommended, because the BIC
is consistent, whereas the AIC is not.
</p>
<p>NOTE:
</p>
<p>Within this function, the <code><a href="fracdiff.html#topic+fracdiff">fracdiff</a></code> function of the
<code>fracdiff</code> package is used throughout for
the estimation of FARIMA models.
</p>


<h3>Value</h3>

<p>The function returns a <code>p.max + 1</code> by <code>q.max + 1</code> matrix, where the
rows represent the AR orders from <code class="reqn">p = 0</code> to <code class="reqn">p = p_{max}</code>
and the columns represent the MA orders from <code class="reqn">q = 0</code> to
<code class="reqn">q = q_{max}</code>. The values within the matrix are the values of
the previously selected information criterion for the different combinations
of <code class="reqn">p</code> and <code class="reqn">q</code>.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics, Paderborn
University), <br />
Author
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Simulate a FARIMA(2, 0.3 ,1) process
set.seed(1)
X.sim &lt;- fracdiff::fracdiff.sim(n = 1000, ar = c(1.2, -0.71), ma = -0.46,
                               d = 0.3)$series
# Application of the function with BIC-criterion
BIC_mat &lt;- critMatlm(X.sim)
BIC_mat
# determining the optimal order
smoots::optOrd(BIC_mat)
</code></pre>

<hr>
<h2 id='dsmoothlm'>Data-driven Local Polynomial for the Trend's Derivatives in Equidistant Time
Series</h2><span id='topic+dsmoothlm'></span>

<h3>Description</h3>

<p>This function runs through an iterative process in order to find the
optimal bandwidth for the nonparametric estimation of the first or second
derivative of the trend in an equidistant time series (with long-memory
errors) and subsequently employs the obtained bandwidth via local
polynomial regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsmoothlm(
  y,
  d = c(1, 2),
  pmin = c(0, 1, 2, 3, 4, 5),
  pmax = c(0, 1, 2, 3, 4, 5),
  qmin = c(0, 1, 2, 3, 4, 5),
  qmax = c(0, 1, 2, 3, 4, 5),
  mu = c(0, 1, 2, 3),
  mu.p = c(0, 1, 2, 3),
  pp = c(1, 3),
  bStart.p = 0.15,
  InfR.p = c("Opt", "Nai", "Var")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsmoothlm_+3A_y">y</code></td>
<td>
<p>a numeric vector that contains the time series ordered from past to
present.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_d">d</code></td>
<td>
<p>an integer <code>1</code> or <code>2</code> that defines the order of
derivative; the default is <code>d = 1</code>.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_pmin">pmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_pmax">pmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_qmin">qmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_qmax">qmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_mu">mu</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function and thus defines the kernel
function that will be used within the local polynomial regression; is set to
<code>1</code> by default.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_mu.p">mu.p</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function for the iterative process to
obtain initial estimates for <code class="reqn">c_f</code>, <code class="reqn">d</code> and <code class="reqn">b_0</code>; is set to
<code>1</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number</strong> </td><td style="text-align: left;"> <strong>Kernel</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>2</code> </td><td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>3</code> </td><td style="text-align: left;"> Triweight Kernel
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_pp">pp</code></td>
<td>
<p>an integer <code>1</code> (local linear regression) or <code>3</code> (local
cubic regression) that indicates the order of polynomial upon which
<code class="reqn">c_f</code>, <code class="reqn">d</code> and <code class="reqn">b_0</code> will be calculated by
<code><a href="#topic+tsmoothlm">tsmoothlm</a></code>; the default is <code>pp = 1</code>.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_bstart.p">bStart.p</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process to obtain initial estimates for <code class="reqn">c_f</code>,
<code class="reqn">d</code> and <code class="reqn">b_0</code>; should be <code class="reqn">&gt; 0</code>; is set to <code>0.15</code> by default.</p>
</td></tr>
<tr><td><code id="dsmoothlm_+3A_infr.p">InfR.p</code></td>
<td>
<p>a character object that represents the inflation
rate in the form <code class="reqn">h_d = h^a</code> of the bandwidth for the iterative process
to obtain initial estimates for <code class="reqn">c_f</code>,
<code class="reqn">d</code> and <code class="reqn">b_0</code>; is set to <code>"Opt"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trend is estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> and is assumed to follow a FARIMA(<code class="reqn">p, d, q</code>)
model (see also Beran and Feng, 2002).
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
Asymptotic Mean Squared Error (AMISE), is based on the proposal of Beran
and Feng (2002a).
</p>
<p>The variance factor <code class="reqn">c_f</code>, the long memory parameter <code class="reqn">d</code> and the
starting bandwidth <code class="reqn">b0</code> are first obtained from a pilot-estimation of
the time series' nonparametric trend (<code class="reqn">\nu = 0</code>) with polynomial order
<code class="reqn">p_p</code>. The estimate is then plugged into the iterative procedure for
estimating the first or second derivative (<code class="reqn">\nu = 1</code> or <code class="reqn">\nu = 2</code>).
For further details on the asymptotic theory or the algorithm, we refer the
user to Letmathe, Beran and Feng (2021).
</p>
<p>The function itself is applicable in the following way: Based on a data input
<code>y</code>, an order of polynomial <code>pp</code> for the variance factor estimation
procedure, a starting value for the relative bandwidth <code>bStart.p</code> in the
variance factor estimation procedure and a kernel function defined by the
smoothness parameter <code>mu</code>, an optimal bandwidth is numerically calculated
for the trend's derivative of order <code>d</code>. In fact, aside from the input
vector <code>y</code>, every argument has a default setting that can be adjusted for
the individual case. However, it is recommended to initially use the default
values for the estimation of the
first derivative and adjust the argument <code>d</code> to <code>d = 2</code> for the
estimation of the second derivative.
The initial bandwidth does not affect the resulting optimal bandwidth in
theory. However in practice, local minima of the AMISE can influence the
results. For more specific information on the input arguments consult the
section <em>Arguments</em>.
</p>
<p>After the bandwidth estimation, the nonparametric derivative of the series
is calculated with respect to the obtained optimal bandwidth by means of a
local polynomial regression. The output object is then a list that contains,
among other components, the original time series, the estimates of the
derivative and the estimated optimal bandwidth.
</p>
<p>The default print method for this function delivers key numbers such as
the iteration steps and the generated optimal bandwidth rounded to the fourth
decimal. The exact numbers and results such as the estimated nonparametric
trend series are saved within the output object and can be addressed via the
<code>$</code> sign.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt>b0</dt><dd><p>the optimal bandwidth chosen by the IPI-algorithm.</p>
</dd>
<dt>bStart.p</dt><dd><p>the starting bandwidth for the nonparametric trend estimation
that leads to the initial estimates; input argument.</p>
</dd>
<dt>cf0</dt><dd><p>the estimated variance factor.</p>
</dd>
<dt>InfR.p</dt><dd><p>the inflation rate setting.</p>
</dd>
<dt>iterations</dt><dd><p>the bandwidths of the single iterations steps</p>
</dd>
<dt>mu.p</dt><dd><p>the smoothness parameter of the second order kernel; input
argument.</p>
</dd>
<dt>n</dt><dd><p>the number of observations.</p>
</dd>
<dt>niterations</dt><dd><p>the total number of iterations until convergence.</p>
</dd>
<dt>orig</dt><dd><p>the original input series; input argument.</p>
</dd>
<dt>p</dt><dd><p>the order of polynomial for the local polynomial
regression used within derivative estimation procedure.</p>
</dd>
<dt>pp</dt><dd><p>the order of polynomial for the local polynomial
regression used in the pilot estimation; input argument.</p>
</dd>
<dt>v</dt><dd><p>the considered order of the trend's derivative; input argument
<code>d</code>.</p>
</dd>
<dt>ws</dt><dd><p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt><dd><p>the nonparametric estimates of the derivative.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Yuanhua Feng (Department of Economics, Paderborn University), <br />
Author of the Algorithms <br />
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li><p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn
University), <br />
Package Creator and Maintainer
</p>
</li>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics, Paderborn
University), <br />
Author
</p>
</li></ul>



<h3>References</h3>

<p>Letmathe, S., Beran, J. and Feng, Y. (2021). An extended exponential SEMIFAR
model with application in R. Discussion Paper. Paderborn University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Logarithm of test data
test_data &lt;- gdpG7
y &lt;- log(test_data$gdp)
n &lt;- length(y)
t &lt;- seq(from = 1962, to = 2020, length.out = n)

# Applied dsmooth function for the trend's first derivative
result_d &lt;- dsmoothlm(y, d = 1, pp = 1, pmax = 1, qmax = 1, InfR.p = "Opt")
estim &lt;- result_d$ye

# Plot of the results
plot(t, estim, xlab = "Year", ylab = "First derivative", type = "l",
 main = paste0("Estimated first derivative of the trend for log-quarterly ",
 "G7-GDP, Q1 1962 - Q4 2019"), cex.axis = 0.8, cex.main = 0.8,
 cex.lab = 0.8, bty = "n")

# Print result
result_d

# The main function "dsmoothlm"------------------------------------------
</code></pre>

<hr>
<h2 id='fitted.esemifar'>Extract Model Fitted Values</h2><span id='topic+fitted.esemifar'></span>

<h3>Description</h3>

<p>Generic function which extracts fitted values from a <code>esemifar</code> class
object. Both <code>fitted</code> and <code>fitted.values</code> can be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.esemifar_+3A_object">object</code></td>
<td>
<p>an object from the <code>esemifar</code> class.</p>
</td></tr>
<tr><td><code id="fitted.esemifar_+3A_...">...</code></td>
<td>
<p>included for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted values extracted from a <code>esemifar</code> class object.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn University), <br />
</p>
</li></ul>


<hr>
<h2 id='gdpG7'>Quarterly G7 GDP, Q1 1962 to Q4 2019</h2><span id='topic+gdpG7'></span>

<h3>Description</h3>

<p>A dataset that contains the (seasonally adjusted) Gross
Domestic Product of the G7 nations from the first quarter of 1962 to the
fourth quarter of 2019
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdpG7
</code></pre>


<h3>Format</h3>

<p>A data frame with 232 rows and 3 variables:
</p>

<dl>
<dt>year</dt><dd><p>the observation year</p>
</dd>
<dt>quarter</dt><dd><p>the observation quarter in the given year</p>
</dd>
<dt>gdp</dt><dd><p>the volume Index of the Gross Domestic Product of the G7 nations</p>
</dd>
</dl>



<h3>Source</h3>

<p>The data was obtained from the Organization for Economic Co-operation
and Development (OECD)
</p>
<p><a href="https://data.oecd.org/gdp/quarterly-gdp.htm#indicator-chart">https://data.oecd.org/gdp/quarterly-gdp.htm#indicator-chart</a>
</p>

<hr>
<h2 id='plot.esemifar'>Plot Method for the Package 'esemifar'</h2><span id='topic+plot.esemifar'></span>

<h3>Description</h3>

<p>This function regulates how objects created by the package <code>esemifar</code> are
plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
plot(x, t = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.esemifar_+3A_x">x</code></td>
<td>
<p>an input object of class <code>esemifar</code>.</p>
</td></tr>
<tr><td><code id="plot.esemifar_+3A_t">t</code></td>
<td>
<p>an optional vector with time points that will be considered for
the x-axis within the plot; is set to NULL by default and uses a vector
<code>1:length(x$ye)</code> for time points.</p>
</td></tr>
<tr><td><code id="plot.esemifar_+3A_...">...</code></td>
<td>
<p>additional arguments of the standard plot method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Research Assistant) (Department of Economics, Paderborn
University), <br />
</p>
</li></ul>


<hr>
<h2 id='print.esemifar'>Print Method for the Package 'esemifar'</h2><span id='topic+print.esemifar'></span>

<h3>Description</h3>

<p>This function regulates how objects created by the package <code>esemifar</code> are
printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.esemifar_+3A_x">x</code></td>
<td>
<p>an input object of class <code>esemifar</code>.</p>
</td></tr>
<tr><td><code id="print.esemifar_+3A_...">...</code></td>
<td>
<p>included for compatibility; additional arguments will however
not affect the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Dominik Schulz (Scientific employee) (Department of Economics, Paderborn
University), <br />
</p>
</li></ul>


<hr>
<h2 id='residuals.esemifar'>Extract Model Residuals</h2><span id='topic+residuals.esemifar'></span>

<h3>Description</h3>

<p>Generic function which extracts model residuals from a <code>esemifar</code> class
object. Both <code>residuals</code> and its abbreviated form <code>resid</code> can be called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'esemifar'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.esemifar_+3A_object">object</code></td>
<td>
<p>an object from the <code>esemifar</code> class.</p>
</td></tr>
<tr><td><code id="residuals.esemifar_+3A_...">...</code></td>
<td>
<p>included for consistency with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Residuals extracted from a <code>esemifar</code> class object.
</p>


<h3>Author(s)</h3>


<ul>
<li><p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn University), <br />
</p>
</li></ul>


<hr>
<h2 id='tsmoothlm'>Advanced Data-driven Nonparametric Regression for the Trend in Equidistant
Time Series</h2><span id='topic+tsmoothlm'></span>

<h3>Description</h3>

<p>This function runs an iterative plug-in algorithm to find the optimal
bandwidth for the estimation of the nonparametric trend in equidistant
time series (with long-memory errors) and then employs the resulting
bandwidth via either local polynomial or kernel regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsmoothlm(
  y,
  pmin = c(0, 1, 2, 3, 4, 5),
  pmax = c(0, 1, 2, 3, 4, 5),
  qmin = c(0, 1, 2, 3, 4, 5),
  qmax = c(0, 1, 2, 3, 4, 5),
  p = c(1, 3),
  mu = c(0, 1, 2, 3),
  InfR = c("Opt", "Nai", "Var"),
  bStart = 0.15,
  bb = c(0, 1),
  cb = 0.05,
  method = c("lpr", "kr")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsmoothlm_+3A_y">y</code></td>
<td>
<p>a numeric vector that contains the time series ordered from past to
present.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_pmin">pmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_pmax">pmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
autoregressive order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_qmin">qmin</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the minimum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_qmax">qmax</code></td>
<td>
<p>an integer value <code class="reqn">&gt;= 0</code> that defines the maximum
moving-average order to calculate the BIC-criterion for; is set to <code>0</code>
by default; decimal numbers will be rounded off to integers.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_p">p</code></td>
<td>
<p>an integer <code>1</code> (local linear regression) or <code>3</code> (local
cubic regression); represents the order of polynomial within the local
polynomial regression (see also the 'Details' section); is set to <code>1</code> by
default; is automatically set to <code>1</code> if <code>method = "kr"</code>.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_mu">mu</code></td>
<td>
<p>an integer <code>0</code>, ..., <code>3</code> that represents the smoothness
parameter of the kernel weighting function and thus defines the kernel
function that will be used within the local polynomial regression; is set to
<code>1</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number</strong> </td><td style="text-align: left;"> <strong>Kernel</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> Uniform Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> Epanechnikov Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>2</code> </td><td style="text-align: left;"> Bisquare Kernel</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>3</code> </td><td style="text-align: left;"> Triweight Kernel
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_infr">InfR</code></td>
<td>
<p>a character object that represents the inflation
rate in the form <code class="reqn">h_d = h^a</code> for the bandwidth in the estimation of
<code class="reqn">I[m^{(k)}]</code> (see also the 'Details' section); is set to
<code>"Opt"</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Inflation rate</strong> </td><td style="text-align: left;"> <strong>Description</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>"Opt"</code> </td><td style="text-align: left;"> Optimal inflation rate <code class="reqn">a_{p,O}</code>
(<code class="reqn">(5-2d)/(7-2d)</code> for <code>p = 1</code>; <code class="reqn">(9-2d)/(11-2d)</code> for
<code>p = 3</code>)</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>"Nai"</code> </td><td style="text-align: left;"> Naive inflation rate <code class="reqn">a_{p,N}</code>
(<code class="reqn">(5-2d)/(9-2d)</code> for <code>p = 1</code>; <code class="reqn">(9-2d)/(13-2d)</code> for
<code>p = 3</code>)</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>"Var"</code> </td><td style="text-align: left;"> Stable inflation rate <code class="reqn">a_{p,S}</code> (<code class="reqn">1/2</code> for
<code>p = 1</code> and <code>p = 3</code>)
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_bstart">bStart</code></td>
<td>
<p>a numeric object that indicates the starting value of the
bandwidth for the iterative process; should be <code class="reqn">&gt; 0</code>; is set to
<code>0.15</code> by default.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_bb">bb</code></td>
<td>
<p>can be set to <code>0</code> or <code>1</code>; the parameter controlling the
bandwidth used at the boundary; is set to <code>1</code> by default.
</p>

<table>
<tr>
 <td style="text-align: center;">
<strong>Number (<code>bb</code>)</strong> </td><td style="text-align: left;"> <strong>Estimation procedure at boundary
points</strong></td>
</tr>
<tr>
 <td style="text-align: center;">
<code>0</code> </td><td style="text-align: left;"> Fixed bandwidth on one side with possible large
bandwidth on the other side at the boundary</td>
</tr>
<tr>
 <td style="text-align: center;">
<code>1</code> </td><td style="text-align: left;"> The <code class="reqn">k</code>-nearest neighbor method will be used
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_cb">cb</code></td>
<td>
<p>a numeric value that indicates the percentage of omitted
observations on each side of the observation period for the automated
bandwidth selection; is set to <code>0.05</code> by default.</p>
</td></tr>
<tr><td><code id="tsmoothlm_+3A_method">method</code></td>
<td>
<p>the final smoothing approach; <code>"lpr"</code> represents the local
polynomial regression, whereas <code>"kr"</code> implements a kernel regression;
is set to <code>"lpr"</code> by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trend is estimated based on the additive
nonparametric regression model for an equidistant time series
</p>
<p style="text-align: center;"><code class="reqn">y_t = m(x_t) + \epsilon_t,</code>
</p>

<p>where <code class="reqn">y_t</code> is the observed time series, <code class="reqn">x_t</code> is the rescaled time
on the interval <code class="reqn">[0, 1]</code>, <code class="reqn">m(x_t)</code> is a smooth and deterministic
trend function and <code class="reqn">\epsilon_t</code> are stationary errors with
<code class="reqn">E(\epsilon_t) = 0</code> and is assumed to follow a FARIMA(<code class="reqn">p, d, q</code>)
model (see also Beran and Feng, 2002a, Beran and Feng, 2002b and Beran
and Feng, 2002c).
</p>
<p>The iterative-plug-in (IPI) algorithm, which numerically minimizes the
Asymptotic Mean Squared Error (AMISE), is based on the proposal of Beran
and Feng (2002a).
</p>
<p>The function calculates suitable estimates for <code class="reqn">c_f</code>, the variance
factor, and <code class="reqn">I[m^{(k)}]</code> over different iterations. In each
iteration, a bandwidth is obtained in accordance with the AMISE that once
more serves as an input for the following iteration. The process repeats
until either convergence or the 40th iteration is reached. For further
details on the asymptotic theory or the algorithm, please see Letmathe et
al., 2021.
</p>
<p>To apply the function, the following arguments are needed: a data input
<code>y</code>, an order of polynomial <code>p</code>, a kernel weighting function
defined by the smoothness parameter <code>mu</code>, an inflation rate setting
<code>InfR</code> (see also Beran and Feng, 2002b), a starting value for the
relative bandwidth <code>bStart</code>, a
boundary method <code>bb</code>, a boundary cut-off percentage <code>cb</code> and a
final smoothing method <code>method</code>. In fact, aside from the input vector
<code>y</code>, every argument has a default setting that can be adjusted for the
individual case. Theoretically, the initial bandwidth does not affect the
selected optimal bandwidth. However, in practice local minima of the AMISE
might exist and influence the selected bandwidth. Therefore, the default
setting is <code>bStart = 0.15</code>. In the rare
case of a clearly unsuitable optimal bandwidth, a starting bandwidth that
differs from the default value is a first possible approach to obtain a
better result. Other argument adjustments can be tried as well. For more
specific information on the input arguments consult the section
<em>Arguments</em>.
</p>
<p>When applying the function, an optimal bandwidth is obtained based on a
strongly modified version of the IPI algorithm of Beran and Feng (2002a). In
a second step, the nonparametric trend of the series is calculated with
respect to the chosen bandwidth and the selected regression method (<code>lpf</code>
or <code>kr</code>). Please note that <code>method = "lpf"</code> is strongly recommended
by the authors. Moreover, it is notable that <code>p</code> is automatically set to
<code>1</code> for <code>method = "kr"</code>. The output object is then a list that
contains, among other components, the original time series, the estimated
trend values and the series without the trend.
</p>
<p>The default print method for this function delivers only key numbers such as
the iteration steps and the generated optimal bandwidth rounded to the fourth
decimal. The exact numbers and results such as the estimated nonparametric
trend series are saved within the output object and can be addressed via the
<code>$</code> sign.
</p>


<h3>Value</h3>

<p>The function returns a list with different components:
</p>

<dl>
<dt>FARIMA.BIC</dt><dd><p>the Bayesian Information Criterion of the optimal
FARIMA(<code class="reqn">p,d,q</code>) model.</p>
</dd>
<dt>cb</dt><dd><p>the percentage of omitted observations on each side of the
observation period; always equal to 0.05.</p>
</dd>
<dt>b0</dt><dd><p>the optimal bandwidth chosen by the IPI-algorithm.</p>
</dd>
<dt>bb</dt><dd><p>the boundary bandwidth method used within the IPI; always equal to
1.</p>
</dd>
<dt>bStart</dt><dd><p>the starting value of the (relative) bandwidth; input
argument.</p>
</dd>
<dt>cf0</dt><dd><p>the estimated variance factor; in contrast to the definitions
given in the <em>Details</em> section, this object actually contains an
estimated value of <code class="reqn">2\pi c_f</code>, i.e. it corresponds to the estimated sum
of autocovariances.</p>
</dd>
<dt>d.BIC</dt><dd><p>the long-memory parameter of the optimal FARIMA(<code class="reqn">p,d,q</code>)
model.</p>
</dd>
<dt>FARMA.BIC</dt><dd><p>the model fit of the selected FARIMA(<code class="reqn">p,d,q</code> model.</p>
</dd>
<dt>I2</dt><dd><p>the estimated value of <code class="reqn">I[m^{(k)}]</code>.</p>
</dd>
<dt>InfR</dt><dd><p>the setting for the inflation rate according to the chosen
algorithm.</p>
</dd>
<dt>iterations</dt><dd><p>the bandwidths of the single iterations steps</p>
</dd>
<dt>mu</dt><dd><p>the smoothness parameter of the second order kernel; input
argument.</p>
</dd>
<dt>n</dt><dd><p>the number of observations.</p>
</dd>
<dt>niterations</dt><dd><p>the total number of iterations until convergence.</p>
</dd>
<dt>orig</dt><dd><p>the original input series; input argument.</p>
</dd>
<dt>p.BIC</dt><dd><p>the order p of the optimal FARIMA(<code class="reqn">p,d,q</code>) model.</p>
</dd>
<dt>p</dt><dd><p>the order of polynomial used in the IPI-algorithm; also used for the
final smoothing, if <code>method = "lpr"</code>; input argument.</p>
</dd>
<dt>q.BIC</dt><dd><p>the order <code class="reqn">q</code> of the optimal FARIMA(<code class="reqn">p,d,q</code>)
model.</p>
</dd>
<dt>res</dt><dd><p>the estimated residual series.</p>
</dd>
<dt>v</dt><dd><p>the considered order of derivative of the trend; is always zero for
this function.</p>
</dd>
<dt>ws</dt><dd><p>the weighting system matrix used within the local polynomial
regression; this matrix is a condensed version of a complete weighting system
matrix; in each row of <code>ws</code>, the weights for conducting the smoothing
procedure at a specific observation time point can be found; the first
<code class="reqn">[nb + 0.5]</code> rows, where <code class="reqn">n</code> corresponds to the number of
observations, <code class="reqn">b</code> is the bandwidth considered for smoothing and
<code class="reqn">[.]</code> denotes the integer part, contain the weights at the
<code class="reqn">[nb + 0.5]</code> left-hand boundary points; the weights in row
<code class="reqn">[nb + 0.5] + 1</code> are representative for the estimation at all
interior points and the remaining rows contain the weights for the right-hand
boundary points; each row has exactly <code class="reqn">2[nb + 0.5] + 1</code> elements,
more specifically the weights for observations of the nearest
<code class="reqn">2[nb + 0.5] + 1</code> time points; moreover, the weights are normalized,
i.e. the weights are obtained under consideration of the time points
<code class="reqn">x_t = t/n</code>, where <code class="reqn">t = 1, 2, ..., n</code>.</p>
</dd>
<dt>ye</dt><dd><p>the nonparametric estimates of the trend.</p>
</dd>
</dl>



<h3>Author(s)</h3>


<ul>
<li><p> Yuanhua Feng (Department of Economics, Paderborn University), <br />
Author of the Algorithms <br />
Website: <a href="https://wiwi.uni-paderborn.de/en/dep4/feng/">https://wiwi.uni-paderborn.de/en/dep4/feng/</a>
</p>
</li>
<li><p> Sebastian Letmathe (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Package Creator and Maintainer
</p>
</li>
<li><p> Dominik Schulz (Scientific Employee) (Department of Economics,
Paderborn University), <br />
Author
</p>
</li></ul>



<h3>References</h3>

<p>Beran, J. and Y. Feng (2002a). Iterative plug-in algorithms for SEMIFAR
models - definition, convergence, and asymptotic properties. Journal of
Computational and Graphical Statistics 11(3), 690-713.
</p>
<p>Beran, J. and Feng, Y. (2002b). Local polynomial fitting with long-memory,
short-memory and antipersistent errors. Annals of the Institute of
Statistical Mathematics, 54(2), 291-311.
</p>
<p>Beran, J. and Feng, Y. (2002c). SEMIFAR models - a semiparametric approach
to modelling trends, longrange dependence and nonstationarity. Computational
Statistics &amp; Data Analysis 40(2), 393-419.
</p>
<p>Letmathe, S., Beran, J. and Feng, Y. (2021). An extended exponential SEMIFAR
model with application in R. Discussion Paper. Paderborn University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### Example 1: G7-GDP ###

# Logarithm of test data
# -&gt; the logarithm of the data is assumed to follow the additive model
test_data &lt;- gdpG7
y &lt;- log(test_data$gdp)
n &lt;- length(y)

# Applied tsmooth function for the trend
result &lt;- tsmoothlm(y, p = 1, pmax = 1, qmax = 1, InfR = "Opt")
trend1 &lt;- result$ye

# Plot of the results
t &lt;- seq(from = 1962, to = 2020, length.out = n)
plot(t, y, type = "l", xlab = "Year", ylab = "log(G7-GDP)", bty = "n",
 lwd = 1, lty = 3,
 main = "Estimated trend for log-quarterly G7-GDP, Q1 1962 - Q4 2019")
points(t, trend1, type = "l", col = "red", lwd = 1)
title(sub = expression(italic("Figure 1")), col.sub = "gray47",
 cex.sub = 0.6, adj = 0)
result



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
