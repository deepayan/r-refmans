<!DOCTYPE html><html><head><title>Help for package MSCquartets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MSCquartets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BQinference'><p>Main loop of B-quartet inference</p></a></li>
<li><a href='#collapseEdges'><p>Collapse short tree edges</p></a></li>
<li><a href='#compatibleSplits'><p>Extract compatible splits</p></a></li>
<li><a href='#cutDensity'><p>Probability density function for Cut Model</p></a></li>
<li><a href='#dataGeneTreeSample'><p>Simulated gene tree dataset from species tree</p></a></li>
<li><a href='#dataHeliconiusMartin'><p>Heliconius gene tree dataset</p></a></li>
<li><a href='#dataYeastRokas'><p>Yeast gene tree dataset</p></a></li>
<li><a href='#estimateEdgeLengths'><p>Estimate edge lengths on a species tree from gene tree quartet counts</p></a></li>
<li><a href='#expectedCFs'><p>Produce table of expected quartet concordance factors for a species tree</p></a></li>
<li><a href='#HolmBonferroni'><p>Apply Holm-Bonferroni method to adjust for multiple tests</p></a></li>
<li><a href='#initBquartets'><p>Initialize vector of B quartets</p></a></li>
<li><a href='#M0'><p>Modified Struve function</p></a></li>
<li><a href='#MSCquartets-package'><p>Multispecies Coalescent Model Quartet Package</p></a></li>
<li><a href='#NANUQ'><p>Apply NANUQ network inference algorithm to gene tree data</p></a></li>
<li><a href='#NANUQdist'><p>Compute NANUQ distance and write to file</p></a></li>
<li><a href='#nexusDist'><p>Write a distance table to a file in nexus format</p></a></li>
<li><a href='#nodeGroups'><p>Groups taxa by deleting a node in a tree</p></a></li>
<li><a href='#powerDivStat'><p>Power divergence statistic of Cressie &amp; Read</p></a></li>
<li><a href='#pTableYeastRokas'><p>pTable for Yeast dataset</p></a></li>
<li><a href='#pvalHist'><p>Plot histogram of log p-values in table</p></a></li>
<li><a href='#QDC'><p>Compute Quartet Distance Consensus tree from gene tree data</p></a></li>
<li><a href='#QDS'><p>Compute Quartet Distance Supertree</p></a></li>
<li><a href='#quartetBTinferencePlot'><p>Produce simplex plot with  results of B/T-quartet inference</p></a></li>
<li><a href='#quartetCutMLE'><p>Maximum likelihood estimate of quartet tree of blobs topology and CF under Cut model</p></a></li>
<li><a href='#quartetCutTest'><p>Hypothesis test for quartet counts fitting a resolved quartet tree of blobs under NMSC</p></a></li>
<li><a href='#quartetCutTestInd'><p>Multiple independent hypothesis tests for quartet counts fitting the Cut model under the NMSC</p></a></li>
<li><a href='#quartetDist'><p>Compute quartet distance between taxa</p></a></li>
<li><a href='#quartetNetworkDist'><p>Compute network quartet distance between taxa</p></a></li>
<li><a href='#quartetStarTest'><p>Hypothesis test for quartet counts fitting a star tree under the MSC</p></a></li>
<li><a href='#quartetStarTestInd'><p>Multiple independent hypothesis tests for gene quartet counts fitting</p>
a species quartet star tree under the MSC</a></li>
<li><a href='#quartetTable'><p>Produce table of counts of quartets displayed on trees</p></a></li>
<li><a href='#quartetTableCollapse'><p>Reduce quartet table by combining some taxa</p></a></li>
<li><a href='#quartetTableDominant'><p>Produce table of dominant quartets, with estimates of internal edge lengths</p></a></li>
<li><a href='#quartetTableParallel'><p>Produce table of counts of quartets displayed on trees, in parallel for large data sets</p></a></li>
<li><a href='#quartetTablePrint'><p>Print a quartet table with nice formatting</p></a></li>
<li><a href='#quartetTableResolved'><p>Modify quartet table to show only resolved quartets</p></a></li>
<li><a href='#quartetTallyCpp'><p>Build quartet table from distances</p></a></li>
<li><a href='#quartetTestPlot'><p>Produce simplex plot with  results of quartet hypothesis tests</p></a></li>
<li><a href='#quartetTreeErrorProb'><p>Bayesian posterior probability of error in 4-taxon unrooted species tree topology estimate</p></a></li>
<li><a href='#quartetTreeTest'><p>Hypothesis test for quartet counts fitting a tree under the MSC</p></a></li>
<li><a href='#quartetTreeTestInd'><p>Multiple independent hypothesis tests for quartet counts fitting a species tree under the MSC</p></a></li>
<li><a href='#quartetWeightedDist'><p>Compute the Weighted Quartet Distance between taxa</p></a></li>
<li><a href='#simplexCoords'><p>Convert 3-d coordinates to 2-d probability simplex coordinates</p></a></li>
<li><a href='#simplexLabels'><p>Label vertices of 2-d probability simplex</p></a></li>
<li><a href='#simplexPoint'><p>Plot point in 2-d probability simplex</p></a></li>
<li><a href='#simplexPrepare'><p>Draw 2-d probability simplex, with model lines for T3 or T1 model</p></a></li>
<li><a href='#simplexSegment'><p>Plot line segment in 2-d probability simplex</p></a></li>
<li><a href='#simplexText'><p>Add text at a point in 2-d probability simplex</p></a></li>
<li><a href='#sortQuartetTableRows'><p>Sort quartet table rows by lex order</p></a></li>
<li><a href='#T1density'><p>Probability density function for Model T1</p></a></li>
<li><a href='#T3density'><p>Probability density function for Model T3</p></a></li>
<li><a href='#taxonNames'><p>Get all taxon names from a collection of trees</p></a></li>
<li><a href='#TINNIK'><p>TINNIK algorithm to infer species tree of blobs</p></a></li>
<li><a href='#TINNIKdist'><p>Compute TINNIK distance from quartets and hypothesis test p-values</p></a></li>
<li><a href='#topDist'><p>Topological distances on a tree</p></a></li>
<li><a href='#treeFromSplits'><p>Produce tree from compatible splits</p></a></li>
<li><a href='#treeOfBlobs'><p>Tree of blobs for a network</p></a></li>
<li><a href='#WQDC'><p>Compute Weighted Quartet Distance Consensus tree from gene tree data</p></a></li>
<li><a href='#WQDCrecursive'><p>Compute the Recursive Weighted Quartet Distance Consensus tree from gene tree data</p></a></li>
<li><a href='#WQDS'><p>Compute the Weighted Quartet Distance Supertree</p></a></li>
<li><a href='#WQDSAdjustLengths'><p>Adjust edge lengths on tree built from Weighted Quartet distance</p>
to estimate metric tree</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyzing Gene Tree Quartets under the Multi-Species Coalescent</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for analyzing and using quartets displayed on a collection 
 of gene trees, primarily to make inferences about the species tree or network 
 under the multi-species coalescent model. These include quartet hypothesis tests
 for the model, as developed by Mitchell et al. (2019) &lt;<a href="https://doi.org/10.1214%2F19-EJS1576">doi:10.1214/19-EJS1576</a>&gt;, 
 simplex plots of quartet concordance factors as presented by Allman et al. (2020) 
 &lt;<a href="https://doi.org/10.1101%2F2020.02.13.948083">doi:10.1101/2020.02.13.948083</a>&gt;, species tree inference methods based on quartet 
 distances of Rhodes (2019) &lt;<a href="https://doi.org/10.1109%2FTCBB.2019.2917204">doi:10.1109/TCBB.2019.2917204</a>&gt; and Yourdkhani and 
 Rhodes (2019) &lt;<a href="https://doi.org/10.1007%2Fs11538-020-00773-4">doi:10.1007/s11538-020-00773-4</a>&gt;, the NANUQ algorithm for inference 
 of level-1 species networks of Allman et al. (2019) &lt;<a href="https://doi.org/10.1186%2Fs13015-019-0159-2">doi:10.1186/s13015-019-0159-2</a>&gt;, 
 and the TINNIK algorithm for inference of the tree of blobs of an arbitrary 
 network of Allman et al.(2022) &lt;<a href="https://doi.org/10.1007%2Fs00285-022-01838-9">doi:10.1007/s00285-022-01838-9</a>&gt;. Software 
 announcement by Rhodes et al. (2020) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa868">doi:10.1093/bioinformatics/btaa868</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>zipfR, graphics, stats, Rdpack, foreach, doParallel, methods,
Rcpp (&ge; 1.0.10), igraph (&ge; 2.0.0)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ape (&ge; 5.0), phangorn</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-23 00:42:33 UTC; jarhodes2</td>
</tr>
<tr>
<td>Author:</td>
<td>Elizabeth Allman [aut],
  Hector Banos [aut],
  Jonathan Mitchell [aut],
  John Rhodes <a href="https://orcid.org/0000-0001-9921-1091"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Rhodes &lt;j.rhodes@alaska.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-23 21:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='BQinference'>Main loop of B-quartet inference</h2><span id='topic+BQinference'></span>

<h3>Description</h3>

<p>This is a C++ function, used in <code>TINNIKdist</code>, to
infer B and T quartets. Doucumentation if for internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BQinference(pTable, C, Cn4, n, Bquartets, L1, lenL1, Nrule1, Nrule2, cuttops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BQinference_+3A_ptable">pTable</code></td>
<td>
<p>a quartet table with p-values</p>
</td></tr>
<tr><td><code id="BQinference_+3A_c">C</code></td>
<td>
<p>precomputed binomial coefficients</p>
</td></tr>
<tr><td><code id="BQinference_+3A_cn4">Cn4</code></td>
<td>
<p>precomputed binomial coefficient</p>
</td></tr>
<tr><td><code id="BQinference_+3A_n">n</code></td>
<td>
<p>number of taxa</p>
</td></tr>
<tr><td><code id="BQinference_+3A_bquartets">Bquartets</code></td>
<td>
<p>0/1 vector of initial Bquartets</p>
</td></tr>
<tr><td><code id="BQinference_+3A_l1">L1</code></td>
<td>
<p>vector of recently inferred B quartets</p>
</td></tr>
<tr><td><code id="BQinference_+3A_lenl1">lenL1</code></td>
<td>
<p>lnegth of L1</p>
</td></tr>
<tr><td><code id="BQinference_+3A_nrule1">Nrule1</code></td>
<td>
<p>count of inference from rule 1</p>
</td></tr>
<tr><td><code id="BQinference_+3A_nrule2">Nrule2</code></td>
<td>
<p>count of inference from rule 2</p>
</td></tr>
<tr><td><code id="BQinference_+3A_cuttops">cuttops</code></td>
<td>
<p>inferred cut topologies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 0/1 vector indicating which sets of 4-taxa are B-quartets
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableParallel">quartetTableParallel</a></code>
</p>

<hr>
<h2 id='collapseEdges'>Collapse short tree edges</h2><span id='topic+collapseEdges'></span>

<h3>Description</h3>

<p>Set all edges of a tree with short lengths to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseEdges(tree, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseEdges_+3A_tree">tree</code></td>
<td>
<p>a phylo object</p>
</td></tr>
<tr><td><code id="collapseEdges_+3A_delta">delta</code></td>
<td>
<p>minimum edge length to retain</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a phylo object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tree=read.tree(text="((a:1,b:1):.5,(c:.5,d:2):1);")
newtree=collapseEdges(tree,delta=1)
write.tree(newtree)
</code></pre>

<hr>
<h2 id='compatibleSplits'>Extract compatible splits</h2><span id='topic+compatibleSplits'></span>

<h3>Description</h3>

<p>Given an object of class splits, first discards any with weight less than a tolerance, and
then further removes all remaining splits that are incompatible with any other remaining one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compatibleSplits(sp, tol = 0, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compatibleSplits_+3A_sp">sp</code></td>
<td>
<p>an object of class splits</p>
</td></tr>
<tr><td><code id="compatibleSplits_+3A_tol">tol</code></td>
<td>
<p>splits with weights below tol are dropped</p>
</td></tr>
<tr><td><code id="compatibleSplits_+3A_plot">plot</code></td>
<td>
<p>a logical; if TRUE plots tree displaying remaining spilts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>splits objects containing only those that are compatible and high weight
</p>


<h3>See Also</h3>

<p><code><a href="#topic+treeFromSplits">treeFromSplits</a>, <a href="#topic+TINNIK">TINNIK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
dist=NANUQdist(pTableYeastRokas, alpha=.05, beta=.95,outfile=NULL)
nn=neighborNet(dist)
plot(nn,"2D")
tob=treeFromSplits(compatibleSplits(nn$splits),plot=TRUE) #produce tree of blobs of splits graph

</code></pre>

<hr>
<h2 id='cutDensity'>Probability density function for Cut Model</h2><span id='topic+cutDensity'></span>

<h3>Description</h3>

<p>Value of probability density function for Cut Model of Allman et al. (2024), Section 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutDensity(lambda, mu0, alpha0, beta0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutDensity_+3A_lambda">lambda</code></td>
<td>
<p>statistic value (e.g., likelihood ratio statistic, or other power divergence statistic)</p>
</td></tr>
<tr><td><code id="cutDensity_+3A_mu0">mu0</code></td>
<td>
<p>parameter of density function</p>
</td></tr>
<tr><td><code id="cutDensity_+3A_alpha0">alpha0</code></td>
<td>
<p>parameter of density function</p>
</td></tr>
<tr><td><code id="cutDensity_+3A_beta0">beta0</code></td>
<td>
<p>parameter of density function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of density function
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2024).
&ldquo;TINNIK: Inference of the Tree of Blobs of Species Networks Under the Coalescent.&rdquo;
draft.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+T1density">T1density</a>,<a href="#topic+T3density">T3density</a></code>
</p>

<hr>
<h2 id='dataGeneTreeSample'>Simulated gene tree dataset from species tree</h2><span id='topic+dataGeneTreeSample'></span>

<h3>Description</h3>

<p>A text file dataset containing 1000 gene trees on 9 taxa simulated under the MSC on a species tree
</p>


<h3>Format</h3>

<p>A text file with 1000 metric Newick gene trees on the taxa t1-t9
</p>


<h3>Details</h3>

<p>This simulated dataset was produced by SimPhy (Mallo et al. 2016), using the species tree
</p>
<p>((((t5:5000,t6:5000):5000,t4:10000):2500,t7:12500):7500,((t8:3000,t9:3000):5000,<br />
((t1:4000,t2:4000):2500,t3:6500):1500):12000);
</p>
<p>with a population size of 10,000 throughout the tree.
</p>
<p>File is accessed as  <code>system.file("extdata","dataGeneTreeSample",package="MSCquartets")</code>, for example
via the ape command:
</p>
<p><code>gts=read.tree(file = system.file("extdata","dataGeneTreeSample",package="MSCquartets") )</code>
</p>


<h3>References</h3>

<p>Mallo D, De Oliveira Martins L, Posada D (2016).
&ldquo;SimPhy: Phylogenomic Simulation of Gene, Locus, and Species Trees.&rdquo;
<em>Syst. Biol.</em>, <b>65</b>(2), 334-344.
<a href="https://doi.org/10.1093/sysbio/syv082">doi:10.1093/sysbio/syv082</a>, <a href="http://dx.doi.org/10.1093/sysbio/syv082">http://dx.doi.org/10.1093/sysbio/syv082</a>.
</p>

<hr>
<h2 id='dataHeliconiusMartin'>Heliconius gene tree dataset</h2><span id='topic+dataHeliconiusMartin'></span>

<h3>Description</h3>

<p>A text file dataset for Heliconius butterflies containing 2909 gene trees on 7 taxa, with 4 individuals sampled for each of 3 of the taxa, for a total of 16
leaves per gene tree. This is a subset of the data of Martin et al. (2013).
</p>


<h3>Format</h3>

<p>A text file with 2909 metric Newick gene trees each with 16 leaves labelled:<br />
chioneus.553, chioneus.560, chioneus.564, chioneus.565, <br />
ethilla.67, hecale.273, melpomeneFG.13435, melpomeneFG.9315, <br />
melpomeneFG.9316, melpomeneFG.9317, pardalinus.371, rosina.2071, <br />
rosina.531, rosina.533, rosina.546, sergestus.202
</p>


<h3>Details</h3>

<p>File is accessed as <code>system.file("extdata","dataHeliconiusMartin",package="MSCquartets")</code>, for
example via the <code>ape</code> command:
</p>
<p><code>gts = read.tree(file=system.file("extdata","dataHeliconiusMartin",package="MSCquartets"))</code>
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.5061/dryad.dk712">doi:10.5061/dryad.dk712</a>
</p>


<h3>References</h3>

<p>Martin SH, K.K. D, Nadeau NJ, Salazar C, Walters JR, Simpson F, Blaxter M, Manica A, Mallet J, Jiggins CD (2013).
&ldquo;Genome-wide evidence for speciation with gene flow in Heliconius butterflies.&rdquo;
<em>Genome Res</em>, <b>23</b>, 1817-1828.
</p>

<hr>
<h2 id='dataYeastRokas'>Yeast gene tree dataset</h2><span id='topic+dataYeastRokas'></span>

<h3>Description</h3>

<p>A text file dataset for Yeast containing 106 gene trees on 8 taxa  (7 Saccharomyces and 1 Candida outgroup). This is a subset of the data
of Rokas et al. (2003).
</p>


<h3>Format</h3>

<p>A text file with 106 topological Newick gene trees on the taxa:
Sbay, Scas, Scer, Sklu, Skud, Smik, Spar, and Calb (outgroup).
</p>


<h3>Details</h3>

<p>File is accessed as <code>system.file("extdata","dataYeastRokas",package="MSCquartets")</code>, for example
via the <code>ape</code> command:
</p>
<p><code> gts=read.tree(file = system.file("extdata","dataYeastRokas",package="MSCquartets"))</code>
</p>


<h3>Source</h3>

<p><a href="https://wiki.rice.edu/confluence/download/attachments/8898533/yeast.trees?version=1&amp;modificationDate=1360603275797&amp;api=v2">https://wiki.rice.edu/confluence/download/attachments/8898533/yeast.trees?version=1&amp;modificationDate=1360603275797&amp;api=v2</a>
</p>


<h3>References</h3>

<p>Rokas A, Williams B, Carrol S (2003).
&ldquo;Genome-scale approaches to resolving incongruence in molecular phylogenies.&rdquo;
<em>Nature</em>, <b>425</b>, 798&ndash;804.
</p>

<hr>
<h2 id='estimateEdgeLengths'>Estimate edge lengths on a species tree from gene tree quartet counts</h2><span id='topic+estimateEdgeLengths'></span>

<h3>Description</h3>

<p>Estimate edge lengths, in coalescent units, on an unrooted species tree 
from a table of resolved quartet counts from a collection of gene trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateEdgeLengths(tree, rqt, terminal = 1, method = "simpleML", lambda = 1/2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateEdgeLengths_+3A_tree">tree</code></td>
<td>
<p>a phylo object, giving a resolved tree on which to estimate edge lengths</p>
</td></tr>
<tr><td><code id="estimateEdgeLengths_+3A_rqt">rqt</code></td>
<td>
<p>a resolved quartet table, as from <code>quartetTableResolved</code>,
in which all taxa on <code>tree</code> appear</p>
</td></tr>
<tr><td><code id="estimateEdgeLengths_+3A_terminal">terminal</code></td>
<td>
<p>an edge length to assign to terminal edges, whose lengths cannot be estimated</p>
</td></tr>
<tr><td><code id="estimateEdgeLengths_+3A_method">method</code></td>
<td>
<p><code>"simpleML"</code> or <code>"simpleBayes"</code></p>
</td></tr>
<tr><td><code id="estimateEdgeLengths_+3A_lambda">lambda</code></td>
<td>
<p>a positive parameter for the <code>"simpleBayes"</code> method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the argument <code>tree</code> may be supplied as rooted or unrooted, metric or topological,
only its unrooted topology will be used for determining new metric estimates.
</p>
<p>Counts of quartets for all those quartets which define a single edge
on the tree (i.e., whose internal edge is the
single edge on the unrooted input tree) are summed, and from this an
estimate of the branch length is computed. If <code>method= "simpleML"</code> this is the maximum likelihood estimate.
If <code>method="simpleBayes"</code> this is the Bayesian estimate of Theorem 2
of Sayyari and Mirarab (2016), using parameter <code>lambda</code>.
Using <code>lambda=1/2</code>
gives a flat prior on [1/3,1] for the probability of the quartet displayed on the species tree.
</p>
<p>These methods are referred to as &lsquo;simple&rsquo; since they use only the quartets defining a single edge of the species tree.
Quartets with central edges composed of several edges in the species tree are ignored.
</p>
<p>Note that branch length estimates may be 0 (if the count for the quartet
displayed on the input tree is not dominant),
positive, or <code>Inf</code> (if
the counts for quartet topologies not displayed on the input tree are all 0, and <code>method="simpleML"</code>).
</p>


<h3>Value</h3>

<p>an unrooted metric tree with the same topology as <code>tree</code>, of type phylo
</p>


<h3>References</h3>

<p>Sayyari E, Mirarab S (2016).
&ldquo;Fast Coalescent-Based Computation of Local Branch Support from Quartet Frequencies.&rdquo;
<em>Mol. Biol. Evol.</em>, <b>33</b>(7), 1654-1668.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
taxanames=taxonNames(gtrees)
QT=quartetTable(gtrees,taxanames[1:6])
RQT=quartetTableResolved(QT)
DQT=quartetTableDominant(RQT)
tree=QDS(DQT)
write.tree(tree)
plot(tree)
metricMTree=estimateEdgeLengths(tree,RQT,method="simpleML")
write.tree(metricMTree)
plot(metricMTree)
metricBTree=estimateEdgeLengths(tree,RQT,method="simpleBayes")
write.tree(metricBTree)
plot(metricBTree)

</code></pre>

<hr>
<h2 id='expectedCFs'>Produce table of expected quartet concordance factors for a species tree</h2><span id='topic+expectedCFs'></span>

<h3>Description</h3>

<p>Compiles table of expected quartet concordance factors (CFs) for gene trees under the MSC model 
on a metric species tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedCFs(speciestree, plot = TRUE, model = "T1", cex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedCFs_+3A_speciestree">speciestree</code></td>
<td>
<p>phylo or character object specifying un/rooted metric species tree</p>
</td></tr>
<tr><td><code id="expectedCFs_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> (default) to produce simplex plot of CFs, or <code>FALSE</code> to omit plot</p>
</td></tr>
<tr><td><code id="expectedCFs_+3A_model">model</code></td>
<td>
<p>&quot;T1&quot; or &quot;T3&quot; specifying model for plot</p>
</td></tr>
<tr><td><code id="expectedCFs_+3A_cex">cex</code></td>
<td>
<p>scaling factor for size of plotted symbols</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The species tree may be rooted or unrooted, but must have edge lengths given in coalescent units. Note that while the MSC
requires a rooted metric species tree parameter, as shown in (Allman et al. 2011) the quartet CFs are independent 
of the root.
</p>
<p>In the returned table, columns are labeled by taxon names and quartet names (&quot;12|34&quot;, etc.).
1s and 0s in taxon columns indicate the taxa in a quartet. Quartet 12|34 means the first and second 
indicated taxa form a cherry, 13|24 means the first and third form a cherry, and 14|23 means
the first and fourth form a cherry. Unresolved quartets always have expectation 0 under the MSC.
</p>
<p>If a simplex plot is produced, for the <code>T1</code> model all CFs will lie on the vertical model line, 
and many choices of 4 taxa will give the same CFs. For model <code>T3</code> the model lines the CFs are 
plotted on depend on taxon names and are essentially arbitrary.
</p>


<h3>Value</h3>

<p>an (<code>n</code> choose 4)x(<code>n</code>+3) matrix encoding
4 taxon subsets of taxa and expectation of each of the
quartets 12|34, 13|24, 14|23 across gene trees
</p>


<h3>References</h3>

<p>Allman ES, Degnan JH, Rhodes JA (2011).
&ldquo;Identifying the rooted species tree from the distribution of unrooted gene trees under the coalescent.&rdquo;
<em>Journal of Mathematical Biology</em>, <b>62</b>(6), 833&ndash;862.
<a href="https://doi.org/10.1007/s00285-010-0355-7">doi:10.1007/s00285-010-0355-7</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stree="((((t5:5000,t6:5000):5000,t4:10000):2500,t7:12500):7500,((t8:3000,t9:3000):5000,
((t1:4000,t2:4000):2500,t3:6500):1500):12000);"
st=read.tree(text=stree)
st$edge.length=st$edge.length/10000
expectedCFs(st)

</code></pre>

<hr>
<h2 id='HolmBonferroni'>Apply Holm-Bonferroni method to adjust for multiple tests</h2><span id='topic+HolmBonferroni'></span>

<h3>Description</h3>

<p>Apply the Holm-Bonferroni method to
adjust for multiple hypothesis tests performed on quartets from a data set of gene trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HolmBonferroni(pTable, model, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HolmBonferroni_+3A_ptable">pTable</code></td>
<td>
<p>a table of quartets with p-values, as computed by
<code>quartetTreeTestInd</code> or <code>quartetStarTestInd</code></p>
</td></tr>
<tr><td><code id="HolmBonferroni_+3A_model">model</code></td>
<td>
<p>one of <code>"T1"</code>, <code>"T3"</code>, or <code>"star"</code>, where <code>pTable</code> contains a column <code>p_model</code> of p-values</p>
</td></tr>
<tr><td><code id="HolmBonferroni_+3A_alpha">alpha</code></td>
<td>
<p>a critical value, for rejection of adjusted p-values less than or equal to <code>alpha</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When p-values are computed for each quartet using
<code>quartetTreeTestInd</code> or <code>quartetStarTestInd</code>,
multiple comparisons are being done for one dataset. The
Holm-Bonferroni method (Holm 1979) adjusts these p-values upward,
controlling the familywise error rate. The probability
of at least one false discovery (rejection of the null hypothesis)
is no more than the significance level.
</p>
<p>The Holm-Bonferroni method does not require that test hypotheses are independent, which
is important for its application to quartet counts presumed to have arisen on a single
species tree.
</p>
<p>This can be a low power test (often failing to reject when the null hypothesis is false).
In particular for the T1 and T3 tests, it does not consider the relationships between edge
lengths for different sets of four taxa.
</p>
<p>Warning: Output of this function should not be used as input for other
MSCquartets functions, as it reorders the quartets in the table.
</p>


<h3>Value</h3>

<p>the same table, with rows reordered, and 2 new columns of 1) adjusted p-values,
and 2) &quot;Y&quot; or &quot;N&quot; for indicating &quot;reject&quot; or &quot;fail to reject&quot;
</p>


<h3>References</h3>

<p>Holm S (1979).
&ldquo;A simple sequentially rejective multiple test procedure.&rdquo;
<em>Scand. J. Statist.</em>, <b>6</b>(2), 65-70.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTreeTestInd">quartetTreeTestInd</a></code>, <code><a href="#topic+quartetStarTestInd">quartetStarTestInd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
taxanames=taxonNames(gtrees)
QT=quartetTable(gtrees,taxanames[1:6])
RQT=quartetTableResolved(QT)
pTable=quartetTreeTestInd(RQT,"T3")
pTable[1:10,]
HBpTable=HolmBonferroni(pTable,"T3",.05)
HBpTable[1:10,]

</code></pre>

<hr>
<h2 id='initBquartets'>Initialize vector of B quartets</h2><span id='topic+initBquartets'></span>

<h3>Description</h3>

<p>This is a C++ function, used in <code>TINNIKdist</code>, to initialize for
inference of B and T quartets. Doucumentation if for internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initBquartets(pTable, m, alpha, beta, colptest, colpstar, Bquartets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initBquartets_+3A_ptable">pTable</code></td>
<td>
<p>a quartet table with p-values</p>
</td></tr>
<tr><td><code id="initBquartets_+3A_m">m</code></td>
<td>
<p>number of rows in pTable</p>
</td></tr>
<tr><td><code id="initBquartets_+3A_alpha">alpha</code></td>
<td>
<p>critical value for tree test</p>
</td></tr>
<tr><td><code id="initBquartets_+3A_beta">beta</code></td>
<td>
<p>critical value for star tree test</p>
</td></tr>
<tr><td><code id="initBquartets_+3A_colptest">colptest</code></td>
<td>
<p>column with p value for tree test</p>
</td></tr>
<tr><td><code id="initBquartets_+3A_colpstar">colpstar</code></td>
<td>
<p>column with p value for star tree test</p>
</td></tr>
<tr><td><code id="initBquartets_+3A_bquartets">Bquartets</code></td>
<td>
<p>0/1 vector encoding initial B quartets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two lists, &quot;Lout&quot; with indices of initial B-quartets, &quot;Bout&quot; with TRUE/FALSE for all sets
of 4 taxa indicating which are B-quartets
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableParallel">quartetTableParallel</a></code>
</p>

<hr>
<h2 id='M0'>Modified Struve function</h2><span id='topic+M0'></span>

<h3>Description</h3>

<p>This function is used in computing the probability density for
Model T1. The code is closely based on the <code>I0L0</code> function implemented in Python for the package
RandomFieldUtils, which was previously on CRAN up to 12/2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M0(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M0_+3A_x">x</code></td>
<td>
<p>function argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of negative modified Struve function function
</p>

<hr>
<h2 id='MSCquartets-package'>Multispecies Coalescent Model Quartet Package</h2><span id='topic+MSCquartets'></span><span id='topic+MSCquartets-package'></span>

<h3>Description</h3>

<p>A package for analyzing quartets displayed on gene trees, under the
multispecies coalescent (MSC) model and network multispecies coalescet model (NMSC).
</p>


<h3>Details</h3>

<p>This package contains routines to analyze a collection of gene trees through the displayed
quartets on them.
</p>
<p>A quartet count concordance factor (qcCF) for a set of 4 taxa is the triple of counts of the three
possible resolved quartet trees on those taxa across some set of gene trees. The major routines in this package can:
</p>

<ol>
<li><p> Tabulate all qcCFs for a collection of gene trees.
</p>
</li>
<li><p> Perform hypothesis tests of whether one or more qcCFs are consistent with the MSC model on
a species tree (Mitchell et al. 2019).
</p>
</li>
<li><p> Produce simplex plots showing all estimated CFs as well as results of hypothesis tests (Allman et al. 2020).
</p>
</li>
<li><p> Infer a species tree using the qcCFs via the QDC and WQDC methods (Rhodes 2020; Yourdkhani and Rhodes 2020).
</p>
</li>
<li><p> Infer a level-1 species network via the NANUQ method (Allman et al. 2019).
</p>
</li>
<li><p> Infer the tree of blobs for a species network via the TINNiK method (Allman et al. 2022),(Allman et al. 2024).
</p>
</li></ol>

<p>As discussed in the cited works, the inference methods for species trees and networks are
statistically consistent under the MSC and Network MSC respectively.
</p>
<p>This package, and the theory on which it is based, allows gene trees to have
missing taxa (i.e., not all gene trees display all the taxa). It does require
that each subset of 4 taxa is displayed on at least one of the gene trees.
</p>
<p>Several gene tree data sets, simulated and empirical, are included.
</p>
<p>In publications please cite the software announcement (Rhodes et al. 2020), as well as the
appropriate paper(s) above developing the theory behind the routines you used.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Rhodes <a href="mailto:j.rhodes@alaska.edu">j.rhodes@alaska.edu</a> (<a href="https://orcid.org/0000-0001-9921-1091">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Elizabeth Allman <a href="mailto:esallman@alaska.edu">esallman@alaska.edu</a>
</p>
</li>
<li><p> Hector Banos <a href="mailto:hbassnos@gmail.com">hbassnos@gmail.com</a>
</p>
</li>
<li><p> Jonathan Mitchell <a href="mailto:jonathanmitchell88@gmail.com">jonathanmitchell88@gmail.com</a>
</p>
</li></ul>



<h3>References</h3>

<p>Rhodes JA, Baños H, Mitchell JD, Allman ES (2020).
&ldquo;MSCquartets 1.0: Quartet methods for species trees and networks under the multispecies coalescent model in R.&rdquo;
<em>Bioinformatics</em>.
<a href="https://doi.org/10.1093/bioinformatics/btaa868">doi:10.1093/bioinformatics/btaa868</a>.
</p>
<p>Mitchell J, Allman ES, Rhodes JA (2019).
&ldquo;Hypothesis testing near singularities and boundaries.&rdquo;
<em>Electron. J. Statist.</em>, <b>13</b>(1), 2150-2193.
<a href="https://doi.org/10.1214/19-EJS1576">doi:10.1214/19-EJS1576</a>.
</p>
<p>Allman ES, Mitchell JD, Rhodes JA (2020).
&ldquo;Gene tree discord, simplex plots, and statistical tests under the coalescent.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/2020.02.13.948083">doi:10.1101/2020.02.13.948083</a>.
</p>
<p>Rhodes JA (2020).
&ldquo;Topological metrizations of trees, and new quartet methods of tree inference.&rdquo;
<em>IEEE/ACM Trans. Comput. Biol. Bioinform.</em>, <b>17</b>(6), 2107-2118.
<a href="https://doi.org/10.1109/TCBB.2019.2917204">doi:10.1109/TCBB.2019.2917204</a>.
</p>
<p>Yourdkhani S, Rhodes JA (2020).
&ldquo;Inferring metric trees from weighted quartets via an intertaxon distance.&rdquo;
<em>Bul. Math. Biol.</em>, <b>82</b>(97).
<a href="https://doi.org/10.1007/s11538-020-00773-4">doi:10.1007/s11538-020-00773-4</a>.
</p>
<p>Allman ES, Baños H, Rhodes JA (2019).
&ldquo;NANUQ: A method for inferring species networks from gene trees under the coalescent model.&rdquo;
<em>Algorithms Mol. Biol.</em>, <b>14</b>(24), 1-25.
<a href="https://doi.org/10.1186/s13015-019-0159-2">doi:10.1186/s13015-019-0159-2</a>.
</p>
<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2022).
&ldquo;The tree of blobs of a species network: identifiability under the coalescent.&rdquo;
<em>Journal of Mathematical Biology</em>, <b>86</b>(1), 10.
<a href="https://doi.org/10.1007/s00285-022-01838-9">doi:10.1007/s00285-022-01838-9</a>.
</p>
<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2024).
&ldquo;TINNIK: Inference of the Tree of Blobs of Species Networks Under the Coalescent.&rdquo;
draft.
</p>

<hr>
<h2 id='NANUQ'>Apply NANUQ network inference algorithm to gene tree data</h2><span id='topic+NANUQ'></span>

<h3>Description</h3>

<p>Apply the NANUQ algorithm of Allman et al. (2019) to infer a hybridization network from a collection of gene trees,
under the level-1 network multispecies coalescent (NMSC) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NANUQ(
  genedata,
  outfile = "NANUQdist",
  omit = FALSE,
  epsilon = 0,
  alpha = 0.05,
  beta = 0.95,
  taxanames = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NANUQ_+3A_genedata">genedata</code></td>
<td>
<p>gene tree data that may be supplied in any of 3 forms:
</p>

<ol>
<li><p> as a character string giving the name of a file containing Newick gene trees,
</p>
</li>
<li><p> as a multiPhylo object containing the gene trees, or
</p>
</li>
<li><p> as a table of quartets on the gene trees, as produced by a previous call to
<code>NANUQ</code> or <code>quartetTableResolved</code>, which has columns only for taxa, resolved quartet counts,
and possibly p_T3 and p_star
</p>
</li></ol>
</td></tr>
<tr><td><code id="NANUQ_+3A_outfile">outfile</code></td>
<td>
<p>a character string giving an output file name stub for
saving a <code>NANUQ</code> distance matrix in nexus format; to the stub <code>outfile</code>
will be appended an <code>alpha</code> and <code>beta</code> value and &quot;.nex&quot;;
if <code>NULL</code> then then no file is written</p>
</td></tr>
<tr><td><code id="NANUQ_+3A_omit">omit</code></td>
<td>
<p><code>FALSE</code> to treat unresolved quartets as 1/3 of each resolution;
<code>TRUE</code> to discard unresolved quartet data; ignored if gene tree data given as quartet table</p>
</td></tr>
<tr><td><code id="NANUQ_+3A_epsilon">epsilon</code></td>
<td>
<p>minimum for branch lengths to be treated as non-zero; ignored if gene tree data given as quartet table</p>
</td></tr>
<tr><td><code id="NANUQ_+3A_alpha">alpha</code></td>
<td>
<p>a value or vector of significance levels for judging p-values
testing a null hypothesis of no hybridization vs. an alternative of hybridization, for each quartet;  a smaller value applies
a less conservative test for a tree (more trees), hence a stricter requirement for desciding in favor of hybridization (fewer reticulations)</p>
</td></tr>
<tr><td><code id="NANUQ_+3A_beta">beta</code></td>
<td>
<p>a value or vector of significance levels for judging p-values testing
a null hypothesis of a star tree (polytomy) for each quartet vs. an alternative of anything else; a smaller value applies a less conservative
test for a star tree (more polytomies), hence a stricter requirement for deciding in favor of a resolved tree or network;
if vectors, <code>alpha</code> and <code>beta</code> must have the same length</p>
</td></tr>
<tr><td><code id="NANUQ_+3A_taxanames">taxanames</code></td>
<td>
<p>if <code>genedata</code> is a file or a multiPhylo object, a vector of a subset
of the taxa names on the gene trees
to be analyzed, if <code>NULL</code> all taxa on the first gene tree are used; if <code>genedata</code>
is a quartet table, this argument is ignored and all taxa in the table are used</p>
</td></tr>
<tr><td><code id="NANUQ_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> produces simplex plots of hypothesis test results, <code>FALSE</code> omits plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function
</p>

<ol>
<li><p> counts displayed quartets across gene trees to form quartet count concordance factors (qcCFs),
</p>
</li>
<li><p> applies appropriate hypothesis tests to judge qcCFs as representing putative hybridization,
resolved trees, or unresolved (star) trees using <code>alpha</code> and <code>beta</code> as significance levels,
</p>
</li>
<li><p> produces a simplex plot showing results of the hypothesis tests for all qcCFs
</p>
</li>
<li><p> computes the appropriate NANUQ distance table, writing it to a file.
</p>
</li></ol>

<p>The distance table file
can then be opened in the external software SplitsTree (Huson and Bryant 2006) (recommended) or within R using the package <code>phangorn</code> to
obtain a circular split system under the Neighbor-Net algorithm, which is then depicted as a splits graph.
The splits graph should be interpreted via
the theory of Allman et al. (2019) to infer the level-1 species network, or to conclude the data does
not arise from the NMSC on such a network.
</p>
<p>If <code>alpha</code> and <code>beta</code> are vectors, they must have the same length k. Then the i-th entries are paired to
produce k plots and k output files. This is equivalent to k calls to <code>NANUQ</code> with scalar values of <code>alpha</code> and <code>beta</code>.
</p>
<p>A call of <code>NANUQ</code> with <code>genedata</code> given as a table previously output from <code>NANUQ</code> is
equivalent to a call of <code>NANUQdist</code>. If <code>genedata</code> is a table previously output from <code>quartetTableResolved</code>
which lacks columns of p-values for hypothesis tests, these will be appended to the table output by <code>NANUQ</code>.
</p>
<p>If plots are produced, each point represents an empirical quartet concordance factor,
color-coded to represent test results.
</p>
<p>In general, <code>alpha</code> should be chosen to be small and <code>beta</code>
to be large so that most quartets are interpreted as resolved trees.
</p>
<p>Usually, an initial call to <code>NANUQ</code> will not give a good analysis, as values
of <code>alpha</code> and <code>beta</code> are likely to need some adjustment based on inspecting the data. Saving the returned
table from <code>NANUQ</code> will allow for the results of the time-consuming computation of qcCFs to be
saved, along with p-values,
for input to further calls of <code>NANUQ</code> with new choices of <code>alpha</code> and <code>beta</code>.
</p>
<p>See the documentation for <code><a href="#topic+quartetNetworkDist">quartetNetworkDist</a></code> for an explanation of a small, rarely noticeable,
stochastic element of the algorithm.
</p>
<p>For data sets of many gene trees, user time may be reduced by using parallel code for
counting displayed quartets. See <code><a href="#topic+quartetTableParallel">quartetTableParallel</a></code>, where example commands are given.
</p>


<h3>Value</h3>

<p>a table <code>$pTable</code> of quartets and p-values for judging fit to the MSC on quartet
trees, and a distance table <code>$dist</code>, or list of distance tables, giving NANUQ distance (returned invisibly);
the table can be used as input to <code>NANUQ</code> or <code>NANUQdist</code> with new choices of alpha and beta, without re-tallying quartets on
gene trees; the distance table is to be used as input to NeighborNet.
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Rhodes JA (2019).
&ldquo;NANUQ: A method for inferring species networks from gene trees under the coalescent model.&rdquo;
<em>Algorithms Mol. Biol.</em>, <b>14</b>(24), 1-25.
<a href="https://doi.org/10.1186/s13015-019-0159-2">doi:10.1186/s13015-019-0159-2</a>.
</p>
<p>Huson DH, Bryant D (2006).
&ldquo;Application of Phylogenetic Networks in Evolutionary Studies.&rdquo;
<em>Molecular Biology and Evolution</em>, <b>23</b>(2), 254-267.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableParallel">quartetTableParallel</a></code>, <code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>, <code><a href="#topic+quartetTreeTestInd">quartetTreeTestInd</a></code>,
<code><a href="#topic+quartetStarTestInd">quartetStarTestInd</a></code>, <code><a href="#topic+NANUQdist">NANUQdist</a></code>, <code><a href="#topic+quartetTestPlot">quartetTestPlot</a></code>, <code><a href="#topic+pvalHist">pvalHist</a></code>,
<code><a href="#topic+quartetNetworkDist">quartetNetworkDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
out=NANUQ(pTableYeastRokas, alpha=.05, beta=.95, outfile = NULL)
# Specifying an outfile would write the distance table to it for opening in SplitsTree.
# Alternately, to use the phangorn implementation of NeighborNet
# within R, enter the following additional lines:
nn=neighborNet(out$dist)
plot(nn,"2D")

</code></pre>

<hr>
<h2 id='NANUQdist'>Compute NANUQ distance and write to file</h2><span id='topic+NANUQdist'></span>

<h3>Description</h3>

<p>Computes the quartet distance tables for the NANUQ algorithm of Allman et al. (2019), using precomputed p-values for quartets,
for each of several levels specified. Distance tables are written to files, in nexus format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NANUQdist(
  pTable,
  outfile = "NANUQdist",
  alpha = 0.05,
  beta = 0.95,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NANUQdist_+3A_ptable">pTable</code></td>
<td>
<p>a table of resolved quartets and p-values, as previously computed by <code>NANUQ</code>, or by both <code>quartetTreeTestInd</code> and
<code>quartetStarTestInd</code>, with columns <code>"p_T3"</code> and <code>"p_star"</code></p>
</td></tr>
<tr><td><code id="NANUQdist_+3A_outfile">outfile</code></td>
<td>
<p>a character string giving an output file name stub for
saving a <code>NANUQ</code> distance matrix in nexus format; to the stub <code>outfile</code>
will be appended an <code>alpha</code> and <code>beta</code> value and &quot;.nex&quot;;
if <code>NULL</code> then not written to file</p>
</td></tr>
<tr><td><code id="NANUQdist_+3A_alpha">alpha</code></td>
<td>
<p>a value or vector of significance levels for judging p-values
testing a null hypothesis of no hybridization for each quartet;  a smaller value applies
a more liberal test for a tree (more trees), hence a stricter requirement for suspecting hybridization (fewer reticulations)</p>
</td></tr>
<tr><td><code id="NANUQdist_+3A_beta">beta</code></td>
<td>
<p>a value or vector of significance levels for judging p-values testing
a null hypothesis of a star tree for each quartet; a smaller value applies a more liberal
test for a star tree (more polytomies), hence a stricter requirment for suspecting a resolved tree;
if vectors, <code>alpha</code> and <code>beta</code> must have the same length</p>
</td></tr>
<tr><td><code id="NANUQdist_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> produces simplex plots of hypothesis tests, <code>FALSE</code> omits plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If plots are produced, each point represents an empirical quartet concordance factor,
color-coded to represent test results giving interpretation as network, resolved tree, or star tree.
</p>
<p>If <code>alpha</code> and <code>beta</code> are vectors, they must be of the same length k. Then the i-th entries are
paired to produce k plots and k distance tables/output files. This is equivalent to k
calls to <code>NANUQdist</code> with paired scalar values from the vectors of <code>alpha</code> and <code>beta</code>.
</p>
<p>See the documentation for <code><a href="#topic+quartetNetworkDist">quartetNetworkDist</a></code> for an explanation of a small, rarely noticeable,
stochastic element of the algorithm.
</p>


<h3>Value</h3>

<p>a NANUQ distance table, or a list of such tables if <code>alpha</code> and <code>beta</code>
are vectors (returned invisibly)
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Rhodes JA (2019).
&ldquo;NANUQ: A method for inferring species networks from gene trees under the coalescent model.&rdquo;
<em>Algorithms Mol. Biol.</em>, <b>14</b>(24), 1-25.
<a href="https://doi.org/10.1186/s13015-019-0159-2">doi:10.1186/s13015-019-0159-2</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NANUQ">NANUQ</a></code>, <code><a href="#topic+quartetTreeTestInd">quartetTreeTestInd</a></code>, <code><a href="#topic+quartetStarTestInd">quartetStarTestInd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
dist=NANUQdist(pTableYeastRokas, alpha=.05, beta=.95, outfile = NULL)

</code></pre>

<hr>
<h2 id='nexusDist'>Write a distance table to a file in nexus format</h2><span id='topic+nexusDist'></span>

<h3>Description</h3>

<p>Write a distance table to a file in nexus format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nexusDist(distMatrix, outfilename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nexusDist_+3A_distmatrix">distMatrix</code></td>
<td>
<p>a square matrix giving a distance table, with rows and columns labeled by taxon names</p>
</td></tr>
<tr><td><code id="nexusDist_+3A_outfilename">outfilename</code></td>
<td>
<p>the name of an output file</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
DQT=quartetTableDominant(RQT)
Dist=quartetDist(DQT)
nexusDist(Dist,outfile = file.path(tempdir(), "NANUQdist"))

</code></pre>

<hr>
<h2 id='nodeGroups'>Groups taxa by deleting a node in a tree</h2><span id='topic+nodeGroups'></span>

<h3>Description</h3>

<p>Finds groups of taxa determined by the connected components of the graph resulting from deleting an internal node in a tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodeGroups(tree, nodeNum)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodeGroups_+3A_tree">tree</code></td>
<td>
<p>a tree, of class &quot;phylo&quot;</p>
</td></tr>
<tr><td><code id="nodeGroups_+3A_nodenum">nodeNum</code></td>
<td>
<p>a node number, representing an internal node in the phylo representation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When applied to a rooted tree, the last group returned is the set of tips that are
non-descendants of the node (provided any exist).
</p>


<h3>Value</h3>

<p>a list of lists of tree tip numbers for each group.
The union of the groups is the set of all tips.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> tree=read.tree(text="((a,b),((c,d,e),(f,g)));")
 nodeGroups(tree,8)
 nodeGroups(tree,10)
 nodeGroups(tree,11)

</code></pre>

<hr>
<h2 id='powerDivStat'>Power divergence statistic of Cressie &amp; Read</h2><span id='topic+powerDivStat'></span>

<h3>Description</h3>

<p>Computes any of the family of power-divergence statistics for multinomial data of Cressie and Read (1984),
to compare observed and expected counts. Includes Likelihood Ratio and Chi-squared statistics as special cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerDivStat(obs, expd, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerDivStat_+3A_obs">obs</code></td>
<td>
<p>observation vector</p>
</td></tr>
<tr><td><code id="powerDivStat_+3A_expd">expd</code></td>
<td>
<p>expected vector</p>
</td></tr>
<tr><td><code id="powerDivStat_+3A_lambda">lambda</code></td>
<td>
<p>statistic parameter (e.g., 0=Likelihood Ratio, 1=Chi-squared)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of statistic
</p>


<h3>References</h3>

<p>Cressie N, Read TRC (1984).
&ldquo;Multinomial Goodness-Of-Fit Tests.&rdquo;
<em>J. Royal Stat. Soc. B</em>, <b>46</b>(3), 440-464.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs=c(10,20,30)
expd=c(20,20,20)
powerDivStat(obs,expd,0)

</code></pre>

<hr>
<h2 id='pTableYeastRokas'>pTable for Yeast dataset</h2><span id='topic+pTableYeastRokas'></span>

<h3>Description</h3>

<p>An .rda file dataset for the &quot;dataYeastRokas&quot; dataset. This is a subset of the data
of Rokas et al. (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
</code></pre>


<h3>Format</h3>

<p>an R data file
</p>


<h3>Details</h3>

<p>This is provided primarily so that examples of other functions run more quickly. It can be reproduced by the following
example code below.
</p>


<h3>Source</h3>

<p><a href="https://wiki.rice.edu/confluence/download/attachments/8898533/yeast.trees?version=1&amp;modificationDate=1360603275797&amp;api=v2">https://wiki.rice.edu/confluence/download/attachments/8898533/yeast.trees?version=1&amp;modificationDate=1360603275797&amp;api=v2</a>
</p>


<h3>References</h3>

<p>Rokas A, Williams B, Carrol S (2003).
&ldquo;Genome-scale approaches to resolving incongruence in molecular phylogenies.&rdquo;
<em>Nature</em>, <b>425</b>, 798&ndash;804.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gtrees=read.tree(file = system.file("extdata","dataYeastRokas",package="MSCquartets"))
QT=quartetTable(gtrees)
RQT=quartetTableResolved(QT)
pTable=quartetCutTestInd(RQT)
pTable=quartetTreeTestInd(pTable)
pTableYeastRokas=quartetStarTestInd(pTable)

</code></pre>

<hr>
<h2 id='pvalHist'>Plot histogram of log p-values in table</h2><span id='topic+pvalHist'></span>

<h3>Description</h3>

<p>Graphical exploration of extreme p-values from quartet hypothesis tests, to aid in choosing critical values
for hypothesis tests. Log base 10 of p-values exceeding some minimum are plotted, to explore gaps in
the tail of the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvalHist(pTable, model, pmin = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvalHist_+3A_ptable">pTable</code></td>
<td>
<p>a quartet table with p-values, such as from <code>NANUQ</code>, <code>quartetTreeTestInd</code>,
or <code>quartetStarTestInd</code></p>
</td></tr>
<tr><td><code id="pvalHist_+3A_model">model</code></td>
<td>
<p>one of <code>"T1"</code>, <code>"T3"</code>, or <code>"star"</code>, where <code>pTable</code>
contains a column <code>p_model</code> of p-values</p>
</td></tr>
<tr><td><code id="pvalHist_+3A_pmin">pmin</code></td>
<td>
<p>include only p-values above <code>pmin</code> in the histogram</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since logarithms are plotted, p-values close to 0 will appear as negative numbers of large magnitude, putting the tail of the distribution
to the left in the histogram.
</p>
<p>When exploring possible critical values for the hypothesis tests in the NANUQ algorithm, use <code>model= "T3"</code> to
choose values for <code>alpha</code> which distinguish treelikeness from hybridization, and <code>model= "star"</code> to
choose values for <code>beta</code> which distinguish polytomies from resolved trees.
In general, <code>alpha</code> should be chosen to be small and <code>beta</code>
to be large so that most quartets are interpreted as resolved trees.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NANUQ">NANUQ</a></code>, <code><a href="#topic+NANUQdist">NANUQdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
pvalHist(pTableYeastRokas,"T3")

</code></pre>

<hr>
<h2 id='QDC'>Compute Quartet Distance Consensus tree from gene tree data</h2><span id='topic+QDC'></span>

<h3>Description</h3>

<p>Compute the Quartet Distance Consensus (Rhodes 2020) estimate of an unrooted 
topological species tree from gene tree data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDC(
  genetreedata,
  taxanames = NULL,
  method = fastme.bal,
  omit = FALSE,
  metric = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDC_+3A_genetreedata">genetreedata</code></td>
<td>
<p>gene tree data that may be supplied in any of 3 forms: 
</p>

<ol>
<li><p> a character string giving the name of a file containing gene trees in Newick,
</p>
</li>
<li><p> a multiPhylo object containing gene trees, or
</p>
</li>
<li><p> a resolved quartet table, such as produced by <code>quartetTableResolved</code>
</p>
</li></ol>
</td></tr>
<tr><td><code id="QDC_+3A_taxanames">taxanames</code></td>
<td>
<p>if <code>genetreedata</code> is a file or a multiPhylo object, a vector of a subset
of the taxa names on the gene trees 
to be analyzed, if <code>NULL</code> all taxa on the first gene tree are used; if <code>genetreedata</code> 
is a quartet table, this argument is ignored and all taxa in the table are used</p>
</td></tr>
<tr><td><code id="QDC_+3A_method">method</code></td>
<td>
<p>a distance-based tree building function, such as <code>fastme.bal</code> or <code>nj</code></p>
</td></tr>
<tr><td><code id="QDC_+3A_omit">omit</code></td>
<td>
<p><code>TRUE</code> ignores unresolved quartets; <code>FALSE</code> treats them as 1/3 of each resolution; 
ignored if <code>genetreedata</code> is supplied as a quartet table</p>
</td></tr>
<tr><td><code id="QDC_+3A_metric">metric</code></td>
<td>
<p>if <code>FALSE</code> return topological tree; if <code>TRUE</code> return metric tree with
internal edge lengths estimated by <code>estimateEdgeLengths</code> with <code>lambda=0</code>, and terminal branches of length 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper which performs the steps of reading in a collection
of gene trees, tallying quartets, computing the quartet distance between taxa, building
a tree which consistently estimates the unrooted species tree topology under the MSC, and then possibly estimating edge
lengths using the &quot;simpleML&quot; method.
</p>


<h3>Value</h3>

<p>an unrooted tree of type phylo
</p>


<h3>References</h3>

<p>Rhodes JA (2020).
&ldquo;Topological metrizations of trees, and new quartet methods of tree inference.&rdquo;
<em>IEEE/ACM Trans. Comput. Biol. Bioinform.</em>, <b>17</b>(6), 2107-2118.
<a href="https://doi.org/10.1109/TCBB.2019.2917204">doi:10.1109/TCBB.2019.2917204</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>,
<code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>,
<code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>,
<code><a href="#topic+quartetDist">quartetDist</a></code>,
<code><a href="#topic+QDS">QDS</a></code>,
<code><a href="#topic+WQDC">WQDC</a></code>, 
<code><a href="#topic+WQDCrecursive">WQDCrecursive</a></code>
<code><a href="#topic+estimateEdgeLengths">estimateEdgeLengths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
stree=QDC(gtrees,tnames[1:6])
write.tree(stree)
plot(stree)
streeMetric=QDC(gtrees, tnames[1:6],metric=TRUE)
write.tree(streeMetric)
plot(streeMetric)

</code></pre>

<hr>
<h2 id='QDS'>Compute Quartet Distance Supertree</h2><span id='topic+QDS'></span>

<h3>Description</h3>

<p>Apply the Quartet Distance Supertree method of Rhodes (2020) to a table specifying a
collection of quartets on <code>n</code> taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QDS(dqt, method = fastme.bal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QDS_+3A_dqt">dqt</code></td>
<td>
<p>an (<code>n</code> choose 4) x <code>n</code> (or <code>n+1</code>) matrix of form output by <code>quartetTableDominant</code>;
(Note: If present, the <code>n+1</code>th column of <code>dqt</code> is ignored)</p>
</td></tr>
<tr><td><code id="QDS_+3A_method">method</code></td>
<td>
<p>tree building function (e.g., fastme.bal, nj)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper which runs <code>quartetDist</code> and then builds a tree.
</p>


<h3>Value</h3>

<p>an unrooted metric tree of type phylo. Edge lengths are not in interpretable units
</p>


<h3>References</h3>

<p>Rhodes JA (2020).
&ldquo;Topological metrizations of trees, and new quartet methods of tree inference.&rdquo;
<em>IEEE/ACM Trans. Comput. Biol. Bioinform.</em>, <b>17</b>(6), 2107-2118.
<a href="https://doi.org/10.1109/TCBB.2019.2917204">doi:10.1109/TCBB.2019.2917204</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>,
<code><a href="#topic+quartetDist">quartetDist</a></code>,
<code><a href="#topic+QDC">QDC</a></code>,
<code><a href="#topic+WQDS">WQDS</a></code>, 
<code><a href="#topic+WQDC">WQDC</a></code>, 
<code><a href="#topic+WQDCrecursive">WQDCrecursive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
DQT=quartetTableDominant(RQT)
tree=QDS(DQT)
write.tree(tree)
plot(tree)

</code></pre>

<hr>
<h2 id='quartetBTinferencePlot'>Produce simplex plot with  results of B/T-quartet inference</h2><span id='topic+quartetBTinferencePlot'></span>

<h3>Description</h3>

<p>Plot a 2-d probability simplex, with points for all normalized quartet count
vectors. Colors indicate B- or T-quartets from TINNIK algorithm, at specified
test levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetBTinferencePlot(pTable, Bquartets, test, alpha, beta, cex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetBTinferencePlot_+3A_ptable">pTable</code></td>
<td>
<p>table of quartets and p-values</p>
</td></tr>
<tr><td><code id="quartetBTinferencePlot_+3A_bquartets">Bquartets</code></td>
<td>
<p>indicator vector for B-quartets (1=B, 0=T), ordered as in pTable</p>
</td></tr>
<tr><td><code id="quartetBTinferencePlot_+3A_test">test</code></td>
<td>
<p>test model used for tree null hypothesis; options are <code>"cut"</code>, <code>"T3"</code></p>
</td></tr>
<tr><td><code id="quartetBTinferencePlot_+3A_alpha">alpha</code></td>
<td>
<p>significance level used by TINNIK for test <code>test</code></p>
</td></tr>
<tr><td><code id="quartetBTinferencePlot_+3A_beta">beta</code></td>
<td>
<p>significance level used by TINNIK for star tree test</p>
</td></tr>
<tr><td><code id="quartetBTinferencePlot_+3A_cex">cex</code></td>
<td>
<p>scaling factor for size of plotted symbols</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument of this function is a table of quartets and p-values. The
plot may show results using either the T3, or 2-cut
test, and a star tree test.
The p-values must be computed by or before previous calls to
<code>TINNIK</code>. The second argument is the indicator vector for B/T quartets produced by <code>TINNIK</code>.
</p>


<h3>See Also</h3>

<p><code>TINNIK</code>, <code><a href="#topic+quartetTestPlot">quartetTestPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
out=TINNIKdist(pTableYeastRokas,test="T3",alpha=.05,beta=.05)
quartetBTinferencePlot(pTableYeastRokas,out$B,test="T3",alpha=.05,beta=.05)

</code></pre>

<hr>
<h2 id='quartetCutMLE'>Maximum likelihood estimate of quartet tree of blobs topology and CF under Cut model</h2><span id='topic+quartetCutMLE'></span>

<h3>Description</h3>

<p>Computes Maximum likelihood estimate of quartet tree of blobs topology and CF under the Cut model of
Allman et al. (2024), Section 3. In case of ties, the topology and CF estimate are chosen randomly among those maximizing
the likelihood. In particular, a resolved tree of blobs is always returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetCutMLE(qcCF)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetCutMLE_+3A_qccf">qcCF</code></td>
<td>
<p>a quartet count Concordance Factor (a 3-element vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output with <code>output$topology</code> = 1, 2, or 3 indicating topology of
tree of blobs in accord with ordering of qcCF entries,
and <code>output$CFhat</code> the ML estimate for the CF
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2024).
&ldquo;TINNIK: Inference of the Tree of Blobs of Species Networks Under the Coalescent.&rdquo;
draft.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> quartetCutMLE(c(17,72,11))
 quartetCutMLE(c(48,11,41))
 quartetCutMLE(c(11,48,41))
 quartetCutMLE(c(48,41,11))

</code></pre>

<hr>
<h2 id='quartetCutTest'>Hypothesis test for quartet counts fitting a resolved quartet tree of blobs under NMSC</h2><span id='topic+quartetCutTest'></span>

<h3>Description</h3>

<p>Test the hypothesis H_0=Cut model of Allman et al. (2024),
Section 3., vs. H_1= everything else.
Returns p-value and estimate of tree of blobs topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetCutTest(
  obs,
  lambda = 0,
  method = "MLest",
  smallcounts = "approximate",
  bootstraps = 10^4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetCutTest_+3A_obs">obs</code></td>
<td>
<p>vector of 3 counts of resolved quartet frequencies</p>
</td></tr>
<tr><td><code id="quartetCutTest_+3A_lambda">lambda</code></td>
<td>
<p>parameter for power-divergence statistic (e.g., 0 for likelihood ratio statistic, 1 for Chi-squared statistic)</p>
</td></tr>
<tr><td><code id="quartetCutTest_+3A_method">method</code></td>
<td>
<p><code>"MLtest"</code>,<code>"conservative"</code>, or <code>"bootstrap"</code></p>
</td></tr>
<tr><td><code id="quartetCutTest_+3A_smallcounts">smallcounts</code></td>
<td>
<p><code>"bootstrap"</code> or <code>"approximate"</code>, method of obtaining p-value when some counts are small</p>
</td></tr>
<tr><td><code id="quartetCutTest_+3A_bootstraps">bootstraps</code></td>
<td>
<p>number of samples for bootstrapping</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cut model for quartet CFs is the NMSC combined with the quartet species network having
a cut edge separating two of the taxa from the other two.
</p>
<p>This function implements the test described in Allman et al. (2024)
as well as parametric bootstrapping,
with other procedures for when some expected counts are small.
These are more accurate tests than, say, a Chi-square with one degree of freedom,
which is not theoretically
justified near the singularity of the model, nor for small counts.
</p>
<p>If <code>method="MLtest"</code>, this uses the test for the Cut model described
in Section 3 of Allman et al. (2024), using the ML
estimate of the generating parameter.
As shown in simulations in that paper, the test is conservative when small
critical values are used for rejection.
Although the test generally performs well in practice, it lacks a uniform
asymptotic guarantee over the full parameter space.
</p>
<p>If <code>method="conservative"</code>, the test uses the Chi-square distribution with 1 degree of freedom
(the &quot;least favorable&quot; approach). This is asymptotically guaranteed to reject the null
hypothesis at most at a specified level, but at the expense of increased type II errors.
</p>
<p>If <code>method="bootstrap"</code>, then parametric bootstrapping is performed,
based on ML estimates of the CF. The bootstrap sample size is given by the <code>bootstrap</code> argument.
</p>
<p>When some expected topology counts are small, the methods <code>"MLest"</code> and <code>"conservative"</code>
are not appropriate.
The argument <code>smallcounts</code> determines whether bootstrapping or a faster approximate method is used.
These use ML estimates of the CF under the Cut model.
</p>
<p>If two of the three counts are small (so the estimated CF is near a vertex of the simplex),
The approximate approach
returns a precomputed p-value, found by replacing the largest observed count
with 1e+6 and performing 1e+8 bootstraps. When n is sufficiently large (at least 30) and
some expected counts are small, the probability of topological error  is small and the bootstrap p-value is
approximately independent of the largest observed count.
</p>
<p>If one of the three counts is small (so the estimated CF is near an edge of the simplex),
a chi-squared test using the binomial model for the larger counts is used, as described
by Allman et al. (2024).
</p>
<p>The returned p-value should be taken with caution when there is a small sample size, e.g. less than 30 gene trees.
</p>


<h3>Value</h3>

<p>output where <code>output$p.value</code> is a p-value and <code>output$topology</code> = 1, 2, or 3
indicates the ML estimate of the topology of the quartet tree of blobs in accord with ordering of qcCF entries.
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2022).
&ldquo;The tree of blobs of a species network: identifiability under the coalescent.&rdquo;
<em>Journal of Mathematical Biology</em>, <b>86</b>(1), 10.
<a href="https://doi.org/10.1007/s00285-022-01838-9">doi:10.1007/s00285-022-01838-9</a>.
</p>
<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2024).
&ldquo;TINNIK: Inference of the Tree of Blobs of Species Networks Under the Coalescent.&rdquo;
draft.
</p>
<p>Mitchell J, Allman ES, Rhodes JA (2019).
&ldquo;Hypothesis testing near singularities and boundaries.&rdquo;
<em>Electron. J. Statist.</em>, <b>13</b>(1), 2150-2193.
<a href="https://doi.org/10.1214/19-EJS1576">doi:10.1214/19-EJS1576</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetCutTestInd">quartetCutTestInd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> quartetCutTest(c(17,72,11))
 quartetCutTest(c(48,11,41))
 quartetCutTest(c(11,48,41))
 quartetCutTest(c(48,41,11))

</code></pre>

<hr>
<h2 id='quartetCutTestInd'>Multiple independent hypothesis tests for quartet counts fitting the Cut model under the NMSC</h2><span id='topic+quartetCutTestInd'></span>

<h3>Description</h3>

<p>Perform a hypothesis test for all quartet counts in an input table, as if the counts for different choices of 4 taxa
are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetCutTestInd(
  rqt,
  lambda = 0,
  method = "MLest",
  smallcounts = "approximate",
  bootstraps = 10^4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetCutTestInd_+3A_rqt">rqt</code></td>
<td>
<p>table of resolved quartet counts, as produced by <code>quartetTableResolved</code>, or <code>quartetStarTestInd</code></p>
</td></tr>
<tr><td><code id="quartetCutTestInd_+3A_lambda">lambda</code></td>
<td>
<p>power divergence statistic parameter (e.g., 0 for likelihood ratio statistic, 1 for Chi-squared statistic)</p>
</td></tr>
<tr><td><code id="quartetCutTestInd_+3A_method">method</code></td>
<td>
<p><code>"MLest"</code>, <code>"conservative"</code>, or <code>"bootstrap"</code>; see <code>quartetCutTest</code> for explanation</p>
</td></tr>
<tr><td><code id="quartetCutTestInd_+3A_smallcounts">smallcounts</code></td>
<td>
<p><code>"bootstrap"</code> or <code>"approximate"</code>, method of obtaining p-value when some counts are small, so
the chosen <code>method</code> is inappropriate</p>
</td></tr>
<tr><td><code id="quartetCutTestInd_+3A_bootstraps">bootstraps</code></td>
<td>
<p>number of samples for bootstrapping</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes all quartets are resolved.  The test performed and the arguments
are described more fully in <code>quartetCutTest</code>.
</p>


<h3>Value</h3>

<p>a copy of <code>rqt</code> with two columns appended: <code>"p_cut"</code> with p-values and <code>"cutindex"</code>
giving index 1,2, or 3 of ML estimate of quartet tree of blobs (1 if 12|34, 2 if 13|24, 3 if 14|23)
under Cut model.
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2024).
&ldquo;TINNIK: Inference of the Tree of Blobs of Species Networks Under the Coalescent.&rdquo;
draft.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetCutTest">quartetCutTest</a></code>, <code><a href="#topic+quartetTestPlot">quartetTestPlot</a></code>, <code><a href="#topic+quartetStarTestInd">quartetStarTestInd</a></code>, <code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
pT=pTableYeastRokas[1:10,1:11]
pTable=quartetCutTestInd(pT)

</code></pre>

<hr>
<h2 id='quartetDist'>Compute quartet distance between taxa</h2><span id='topic+quartetDist'></span>

<h3>Description</h3>

<p>Compute the Quartet Distance of Rhodes (2020) from a table specifying a collection of quartets on
<code>n</code> taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetDist(dqt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetDist_+3A_dqt">dqt</code></td>
<td>
<p>an (<code>n</code> choose 4) x <code>n</code> (or <code>n+1</code>) matrix of form output by <code>quartetTableDominant</code>;
(Note: If present, the <code>n+1</code>th column of <code>dqt</code> is ignored.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pairwise distance matrix on <code>n</code> taxa
</p>


<h3>References</h3>

<p>Rhodes JA (2020).
&ldquo;Topological metrizations of trees, and new quartet methods of tree inference.&rdquo;
<em>IEEE/ACM Trans. Comput. Biol. Bioinform.</em>, <b>17</b>(6), 2107-2118.
<a href="https://doi.org/10.1109/TCBB.2019.2917204">doi:10.1109/TCBB.2019.2917204</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>,
<code><a href="#topic+QDS">QDS</a></code>,
<code><a href="#topic+QDC">QDC</a></code>,
<code><a href="#topic+quartetWeightedDist">quartetWeightedDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
DQT=quartetTableDominant(RQT)
Dist=quartetDist(DQT)
tree=NJ(Dist)
write.tree(tree)
plot(tree)

</code></pre>

<hr>
<h2 id='quartetNetworkDist'>Compute network quartet distance between taxa</h2><span id='topic+quartetNetworkDist'></span>

<h3>Description</h3>

<p>Produce network quartet distance table for the NANUQ algorithm, from a table of quartets and p-values,
and specified levels of quartet hypothesis tests. The network quartet distance, which
is described more fully by Allman et al. (2019), generalizes
the quartet distance of Rhodes (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetNetworkDist(pTable, alpha, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetNetworkDist_+3A_ptable">pTable</code></td>
<td>
<p>a table of quartets and p-values, as computed by NANUQ, or
<code>quartetTreeTestInd</code> and <code>quartetStarTestInd</code></p>
</td></tr>
<tr><td><code id="quartetNetworkDist_+3A_alpha">alpha</code></td>
<td>
<p>a scalar significance level for judging p-values <code>p_T3</code> indicating hybridization on quartet;
smaller value gives fewer hybridization decisions</p>
</td></tr>
<tr><td><code id="quartetNetworkDist_+3A_beta">beta</code></td>
<td>
<p>a scalar significance level for judging p-values <code>p_star</code> indicating quartet star tree;
smaller value gives fewer resolved tree decisions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of a triple of quartet counts with the two largest equal and the third slighltly smaller,
along with <code>alpha</code> and <code>beta</code> leading to a star quartet being rejected and a tree not being rejected,
this function chooses a resolved quartet topology uniformly at random from the two largest counts. This is the only
stochastic element of the code, and its impact is usually negligible.
</p>


<h3>Value</h3>

<p>a distance table
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Rhodes JA (2019).
&ldquo;NANUQ: A method for inferring species networks from gene trees under the coalescent model.&rdquo;
<em>Algorithms Mol. Biol.</em>, <b>14</b>(24), 1-25.
<a href="https://doi.org/10.1186/s13015-019-0159-2">doi:10.1186/s13015-019-0159-2</a>.
</p>
<p>Rhodes JA (2020).
&ldquo;Topological metrizations of trees, and new quartet methods of tree inference.&rdquo;
<em>IEEE/ACM Trans. Comput. Biol. Bioinform.</em>, <b>17</b>(6), 2107-2118.
<a href="https://doi.org/10.1109/TCBB.2019.2917204">doi:10.1109/TCBB.2019.2917204</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NANUQ">NANUQ</a></code>, <code><a href="#topic+NANUQdist">NANUQdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
dist=quartetNetworkDist(pTableYeastRokas, alpha=.05, beta=.95)

</code></pre>

<hr>
<h2 id='quartetStarTest'>Hypothesis test for quartet counts fitting a star tree under the MSC</h2><span id='topic+quartetStarTest'></span>

<h3>Description</h3>

<p>Perform hypothesis test for star tree for a vector of  quartet counts to fit expected frequencies of (1/3,1/3,1/3).
The test performed is a standard Chi-square with 2 degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetStarTest(obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetStarTest_+3A_obs">obs</code></td>
<td>
<p>vector of 3 counts of resolved quartet frequencies</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs=c(16,72,12)
quartetStarTest(obs)

</code></pre>

<hr>
<h2 id='quartetStarTestInd'>Multiple independent hypothesis tests for gene quartet counts fitting 
a species quartet star tree under the MSC</h2><span id='topic+quartetStarTestInd'></span>

<h3>Description</h3>

<p>Perform hypothesis tests for a species quartet star tree vs. any alternative for all quartet counts in an input table, 
as if the quartets are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetStarTestInd(rqt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetStarTestInd_+3A_rqt">rqt</code></td>
<td>
<p>Table of resolved quartet counts, as produced by <code>quartetTableResolved</code>, or <code>quartetTreeTestInd</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes all quartets are resolved. 
The test performed is described in <code>quartetStarTest</code>.
</p>


<h3>Value</h3>

<p>the same table as the input <code>rqt</code> with column <code>"p_star"</code> appended, containing p-values for 
judging fit to MSC on a star tree
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetStarTest">quartetStarTest</a></code>, <code><a href="#topic+quartetTreeTest">quartetTreeTest</a></code>, <code><a href="#topic+quartetTreeTestInd">quartetTreeTestInd</a></code>,
<code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>, <code><a href="#topic+quartetTestPlot">quartetTestPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
pTable=quartetStarTestInd(RQT)
quartetTablePrint(pTable[1:6,])

</code></pre>

<hr>
<h2 id='quartetTable'>Produce table of counts of quartets displayed on trees</h2><span id='topic+quartetTable'></span>

<h3>Description</h3>

<p>Compiles table of quartet count concordance factors (qcCFs) for topological quartets displayed on a
collection of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTable(
  trees,
  taxonnames = NULL,
  epsilon = 0,
  random = 0,
  progressbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTable_+3A_trees">trees</code></td>
<td>
<p>multiphylo object containing un/rooted metric/topological trees</p>
</td></tr>
<tr><td><code id="quartetTable_+3A_taxonnames">taxonnames</code></td>
<td>
<p>vector of <code>n</code> names of taxa of interest; if <code>NULL</code> then taken from taxa on <code>trees[[1]]</code></p>
</td></tr>
<tr><td><code id="quartetTable_+3A_epsilon">epsilon</code></td>
<td>
<p>minimum for branch lengths to be treated as non-zero (default 0)</p>
</td></tr>
<tr><td><code id="quartetTable_+3A_random">random</code></td>
<td>
<p>number of random subsets of 4 taxa to consider; if 0, use all <code>n</code> choose 4 subsets</p>
</td></tr>
<tr><td><code id="quartetTable_+3A_progressbar">progressbar</code></td>
<td>
<p>FALSE, set to TRUE if want to see tally progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names in <code>taxonnames</code> may be any subset of those on the trees.
Branch lengths of non-negative size less than or equal to <code>epsilon</code>
are treated as zero, giving polytomies.
</p>
<p>In the returned table, columns are labeled by taxon names and quartet names (&quot;12|34&quot;, etc.).
1s and 0s in taxon columns indicate the taxa in a quartet. Quartet 12|34
means the first and second indicated taxa form a cherry, 13|24 means the first and third form a cherry, 14|23 means
the first and fourth form a cherry, and 1234 means the quartet is unresolved.
</p>
<p>An error occurs if any branch length is negative.
Warnings are given if some of <code>taxonnames</code> are missing on some trees, or
if some 4-taxon set is not on any tree.
</p>
<p>If <code>random</code>&gt;0, then for efficiency <code>random</code> should be much smaller then
the number of possible 4 taxon subsets.
</p>
<p>This function calls an Rcpp function for tallying quartets, for much shorter computational
time than can be achieved in R alone.
</p>


<h3>Value</h3>

<p>an (<code>n</code> choose 4)x(<code>n</code>+4) matrix (or (<code>random</code>)x(<code>n</code>+4) matrix) encoding
4 taxon subsets of <code>taxonnames</code> and counts of each of the
quartets 12|34, 13|24, 14|23, 1234 across the trees
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTableParallel">quartetTableParallel</a></code>, <code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>, <code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>, <code><a href="#topic+taxonNames">taxonNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
DQT=quartetTableDominant(RQT)

</code></pre>

<hr>
<h2 id='quartetTableCollapse'>Reduce quartet table by combining some taxa</h2><span id='topic+quartetTableCollapse'></span>

<h3>Description</h3>

<p>Form a smaller resolved quartet table by lumping some taxa into a composite taxon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTableCollapse(rqt, taxaA, taxaB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTableCollapse_+3A_rqt">rqt</code></td>
<td>
<p>a resolved quartet table, as from <code>quartetTableResolved</code></p>
</td></tr>
<tr><td><code id="quartetTableCollapse_+3A_taxaa">taxaA</code></td>
<td>
<p>a vector of taxon names in <code>rqt</code> to be included in the output table</p>
</td></tr>
<tr><td><code id="quartetTableCollapse_+3A_taxab">taxaB</code></td>
<td>
<p>a vector of taxon names in <code>rqt</code> to form new composite taxon in the output table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is needed for the recursive calls in <code>WQDSrec</code>.
It should only be applied to a resolved quartet table which includes counts
for all possible quartets on the taxa (though counts can be zero).
</p>
<p>The sets <code>taxaA</code> and <code>taxaB</code> must be disjoint. Their union need not be all taxa in <code>rqt</code>.
</p>


<h3>Value</h3>

<p>a resolved quartet table with <code>length(taxaA)+1</code> taxa; the
composite taxon is named as the concatenation of the sorted
names in <code>taxaB</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WQDCrecursive">WQDCrecursive</a></code>
</p>

<hr>
<h2 id='quartetTableDominant'>Produce table of dominant quartets, with estimates of internal edge lengths</h2><span id='topic+quartetTableDominant'></span>

<h3>Description</h3>

<p>Converts table of counts of resolved quartets on <code>n</code> taxa to show only dominant one, with
maximum likelihood estimate of internal edge weight under the MSC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTableDominant(rqt, bigweights = "infinite")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTableDominant_+3A_rqt">rqt</code></td>
<td>
<p>a table, as produced by <code>quartetTableResolved</code> of size (n choose 4)x(n+3);</p>
</td></tr>
<tr><td><code id="quartetTableDominant_+3A_bigweights">bigweights</code></td>
<td>
<p><code>"infinite"</code> or <code>"finite"</code>, to indicate whether the weight (internal edge length)
of a quartet for which only one
topology appears is given as <code>Inf</code> or a finite, but large, numerical value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>bigweights="finite"</code>, when for a set of 4 taxa the quartet counts are (m,0,0) then
the edge weight is computed as if the relative frequency of the dominant topology were m/(m+1).
</p>


<h3>Value</h3>

<p>an (n choose 4)x(n+1) array with dominant quartet topology encoded by 1,1,-1,-1 in
taxon columns, with signs indicating cherries; the (n+1)th column <code>"weight"</code> contains the maximum likelihood estimates,
under MSC on a 4-taxon tree, of the quartets' central edge lengths, in coalescent units
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
RQT[1:6,]
DQT=quartetTableDominant(RQT)
DQT[1:6,]

</code></pre>

<hr>
<h2 id='quartetTableParallel'>Produce table of counts of quartets displayed on trees, in parallel for large data sets</h2><span id='topic+quartetTableParallel'></span>

<h3>Description</h3>

<p>Compiles table of quartet count concordance factors (qcCFs) for topological quartets displayed on a
collection of trees. Gives the same output as <code>quartetTable</code>, but operates in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTableParallel(trees, taxonnames = NULL, epsilon = 0, numCores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTableParallel_+3A_trees">trees</code></td>
<td>
<p>multiphylo object containing un/rooted metric/topological trees</p>
</td></tr>
<tr><td><code id="quartetTableParallel_+3A_taxonnames">taxonnames</code></td>
<td>
<p>vector of <code>n</code> names of taxa of interest; if <code>NULL</code> then taken from taxa on <code>trees[[1]]</code></p>
</td></tr>
<tr><td><code id="quartetTableParallel_+3A_epsilon">epsilon</code></td>
<td>
<p>minimum for branch lengths to be treated as non-zero</p>
</td></tr>
<tr><td><code id="quartetTableParallel_+3A_numcores">numCores</code></td>
<td>
<p>number of cores to use for parallel calls</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of available cores can be determined by <code>parallel::detectCores()</code>.
With overhead, tabulating quartets for a large data set (many taxa and/or many gene trees) on a 4-core
computer using <code>numCores=4</code> may require less than half the elapsed time of the sequential <code>quartetTable</code>.
</p>
<p>The names in <code>taxonnames</code> may be any subset of those on the trees.
Branch lengths of non-negative size less than or equal to <code>epsilon</code>
are treated as zero, giving polytomies.
</p>
<p>In the returned table, columns are labeled by taxon names and quartet names (&quot;12|34&quot;, etc.).
1s and 0s in taxon columns indicate the taxa in a quartet. Quartet 12|34
means the first and second indicated taxa form a cherry, 13|24 means the first and third form a cherry, 14|23 means
the first and fourth form a cherry, and 1234 means the quartet is unresolved.
</p>
<p>An error occurs if any branch length is negative.
Warnings are given if some of <code>taxonnames</code> are missing on some trees, or
if some 4-taxon set is not on any tree.
</p>
<p>If <code>random</code>&gt;0, then for efficiency <code>random</code> should be much smaller then
the number of possible 4 taxon subsets.
</p>
<p>If the quartet counts are to be used for NANUQ, or any other routines requiring resolved quartet counts,
<code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code> must be run following <code>quartetTableParallel</code>. See example below.
</p>


<h3>Value</h3>

<p>an (<code>n</code> choose 4)x(<code>n</code>+4) matrix (or (<code>random</code>)x(<code>n</code>+4) matrix) encoding
4 taxon subsets of <code>taxonnames</code> and counts of each of the
quartets 12|34, 13|24, 14|23, 1234 across the trees
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>, <code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>, <code><a href="#topic+taxonNames">taxonNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gtrees=read.tree(file=system.file("extdata","dataHeliconiusMartin",package="MSCquartets"))
QT=quartetTableParallel(gtrees,numCores=2)
RQT=quartetTableResolved(QT)
pTable=NANUQ(RQT,alpha=1e-40, beta=1e-30, outfile = file.path(tempdir(), "NANUQdist"))

</code></pre>

<hr>
<h2 id='quartetTablePrint'>Print a quartet table with nice formatting</h2><span id='topic+quartetTablePrint'></span>

<h3>Description</h3>

<p>Print a quartet table with the taxa in each quartet shown by name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTablePrint(qt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTablePrint_+3A_qt">qt</code></td>
<td>
<p>a table such as returned by <code>quartetTable</code>, <code>quartetTableResolved</code>,
or <code>quartetTableDominant</code>, possibly with extra columns added by other functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
 tnames=taxonNames(gtrees)
 QT=quartetTable(gtrees,tnames[1:6])
 QT[1:6,]
 quartetTablePrint(QT[1:6,])
 RQT=quartetTableResolved(QT)
 RQT[1:6,]
 quartetTablePrint(RQT[1:6,])
 pTable=quartetTreeTestInd(RQT,"T3")
 pTable[1:6,]
 quartetTablePrint(pTable[1:6,])
 DQT=quartetTableDominant(RQT)
 DQT[1:6,]
 quartetTablePrint(DQT[1:6,])

</code></pre>

<hr>
<h2 id='quartetTableResolved'>Modify quartet table to show only resolved quartets</h2><span id='topic+quartetTableResolved'></span>

<h3>Description</h3>

<p>Converts table of all quartet counts, including unresolved ones,
by either dropping unresolved ones, or distributing them uniformly
among the three resolved counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTableResolved(qt, omit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTableResolved_+3A_qt">qt</code></td>
<td>
<p>table, as produced by <code>quartetTable</code> for <code>n</code> taxa, with <code>n+4</code> columns</p>
</td></tr>
<tr><td><code id="quartetTableResolved_+3A_omit">omit</code></td>
<td>
<p><code>TRUE</code> deletes unresolved quartets column;
<code>FALSE</code> deletes the column but redistributes unresolved counts as (1/3,1/3,1/3) to resolved counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table of quartet counts similar to <code>qt</code>, but with columns showing only resolved quartet counts
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
QT[1:6,]
RQT=quartetTableResolved(QT)
RQT[1:6,]

</code></pre>

<hr>
<h2 id='quartetTallyCpp'>Build quartet table from distances</h2><span id='topic+quartetTallyCpp'></span>

<h3>Description</h3>

<p>This is a C++ function, called from quartetTable, to fill in the quartet counts.
From a list of topological distance matrices (1 for each gene tree) it determines all
gene quartets. The faster looping in C++ gives substantial time improvements
over R code. Doucumentation if for internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTallyCpp(dList, M, nt, Q, random, progressbar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTallyCpp_+3A_dlist">dList</code></td>
<td>
<p>a list of distance matrices</p>
</td></tr>
<tr><td><code id="quartetTallyCpp_+3A_m">M</code></td>
<td>
<p>number of sets of 4 taxa</p>
</td></tr>
<tr><td><code id="quartetTallyCpp_+3A_nt">nt</code></td>
<td>
<p>number of gene trees/distance matrices</p>
</td></tr>
<tr><td><code id="quartetTallyCpp_+3A_q">Q</code></td>
<td>
<p>matrix to fill out as table of quartet counts</p>
</td></tr>
<tr><td><code id="quartetTallyCpp_+3A_random">random</code></td>
<td>
<p>if 0 compute for all sets of 4 taxa, otherwise for M random ones</p>
</td></tr>
<tr><td><code id="quartetTallyCpp_+3A_progressbar">progressbar</code></td>
<td>
<p>if TRUE, display progress bar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Q with quartet counts filled in, and a flag indicating whether any
taxa were missing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableParallel">quartetTableParallel</a></code>
</p>

<hr>
<h2 id='quartetTestPlot'>Produce simplex plot with  results of quartet hypothesis tests</h2><span id='topic+quartetTestPlot'></span>

<h3>Description</h3>

<p>Plot a 2-d probability simplex, with points for all quartet count vectors. Colors
indicate rejection or failure to reject for tests at specified levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTestPlot(pTable, test, alpha = 0.05, beta = 1, cex = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTestPlot_+3A_ptable">pTable</code></td>
<td>
<p>table of quartets and p-values, as produced by <code>quartetTreeTestInd</code>,
<code>quartetStarTestInd</code>, or <code>NANUQ</code></p>
</td></tr>
<tr><td><code id="quartetTestPlot_+3A_test">test</code></td>
<td>
<p>model to use, for tree null hypothesis; options are <code>"T1"</code>, <code>"T3"</code>, <code>"cut"</code>, <code>"NANUQ"</code></p>
</td></tr>
<tr><td><code id="quartetTestPlot_+3A_alpha">alpha</code></td>
<td>
<p>significance level  for tree test with null hypothesis given by <code>test</code></p>
</td></tr>
<tr><td><code id="quartetTestPlot_+3A_beta">beta</code></td>
<td>
<p>significance level for test with null hypothesis star tree;
test results plotted only if <code>beta&lt;1</code> and <code>"p_star"</code> column present in <code>pTable</code></p>
</td></tr>
<tr><td><code id="quartetTestPlot_+3A_cex">cex</code></td>
<td>
<p>scaling factor for size of plotted symbols</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument of this function is a table of quartets and p-values. The
plot may show results of either the T1, T3, or 2-cut
test, with or without a star tree test (depending on whether a <code>"p_star"</code> column is in the table and/or <code>beta =1</code>).
The p-values must be computed by previous calls to
<code>quartetTreeTestInd</code> (for <code>"T1"</code> or <code>"T3"</code> p-values)
and <code>quartetStarTestInd</code> (for <code>"star"</code> p-values). The <code>NANUQ</code> and <code>NANUQdist</code>
functions include calls to these tree test functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTreeTestInd">quartetTreeTestInd</a></code>, <code><a href="#topic+quartetStarTestInd">quartetStarTestInd</a></code>,
<code><a href="#topic+NANUQ">NANUQ</a></code>, <code><a href="#topic+NANUQdist">NANUQdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=c("t1","t2","t3","t4","t5","t6")
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
stree="(((t5,t6),t4),((t1,t2),t3));"
pTable=quartetTreeTestInd(RQT,"T1",speciestree=stree)
pTable=quartetStarTestInd(pTable)
quartetTestPlot(pTable, "T1", alpha=.05, beta=.95)

</code></pre>

<hr>
<h2 id='quartetTreeErrorProb'>Bayesian posterior probability of error in 4-taxon unrooted species tree topology estimate</h2><span id='topic+quartetTreeErrorProb'></span>

<h3>Description</h3>

<p>From a gene quartet count concordance factor (qcCF), computes Bayesian posterior probabilities
of the three 4-taxon species tree topologies and the Bayesian posterior probability that the
assumed topology is incorrect, under the assumption that the counts arise from the MSC on some species tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTreeErrorProb(obs, model = "T3")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTreeErrorProb_+3A_obs">obs</code></td>
<td>
<p>vector of counts for 3 topologies</p>
</td></tr>
<tr><td><code id="quartetTreeErrorProb_+3A_model">model</code></td>
<td>
<p><code>"T3"</code> or <code>"T1"</code>, for the models of Mitchell et al. (2019) describing an unspecified species
tree topology (<code>"T3"</code>), or the topology whose count is the first entry of <code>obs</code> (<code>"T1"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jeffreys prior is used for internal branch length, along with the uniform prior
on the resolved topology.
</p>


<h3>Value</h3>

<p><code>(error.prob, top.probs)</code> where <code>error.prob</code> is the species tree error probability
and <code>top.probs</code> is a vector of the three species tree topology probabilities in the order of <code>obs</code>;
for model <code>"T1"</code> the species tree used is the one
corresponding to the first count; for model <code>"T3"</code> the species
tree is the one corresponding to the largest count
</p>


<h3>References</h3>

<p>Mitchell J, Allman ES, Rhodes JA (2019).
&ldquo;Hypothesis testing near singularities and boundaries.&rdquo;
<em>Electron. J. Statist.</em>, <b>13</b>(1), 2150-2193.
<a href="https://doi.org/10.1214/19-EJS1576">doi:10.1214/19-EJS1576</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obs &lt;- c(28,32,30)
quartetTreeErrorProb(obs,model="T1")
quartetTreeErrorProb(obs,model="T3")

</code></pre>

<hr>
<h2 id='quartetTreeTest'>Hypothesis test for quartet counts fitting a tree under the MSC</h2><span id='topic+quartetTreeTest'></span>

<h3>Description</h3>

<p>Test the hypothesis H_0= T1 or T3 model of Mitchell et al. (2019), vs. H_1 = everything else.
T1 is for a specific species quartet topology, and T3 for any species quartet topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTreeTest(
  obs,
  model = "T3",
  lambda = 0,
  method = "MLest",
  smallcounts = "approximate",
  bootstraps = 10^4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTreeTest_+3A_obs">obs</code></td>
<td>
<p>vector of 3 counts of resolved quartet frequencies</p>
</td></tr>
<tr><td><code id="quartetTreeTest_+3A_model">model</code></td>
<td>
<p><code>"T1"</code> or <code>"T3"</code>, for the models of Mitchell et al. (2019)</p>
</td></tr>
<tr><td><code id="quartetTreeTest_+3A_lambda">lambda</code></td>
<td>
<p>parameter for power-divergence statistic (e.g., 0 for likelihood ratio statistic, 1 for Chi-squared statistic)</p>
</td></tr>
<tr><td><code id="quartetTreeTest_+3A_method">method</code></td>
<td>
<p><code>"MLtest"</code>,<code>"conservative"</code>, or <code>"bootstrap"</code></p>
</td></tr>
<tr><td><code id="quartetTreeTest_+3A_smallcounts">smallcounts</code></td>
<td>
<p><code>"bootstrap"</code> or <code>"approximate"</code>, method of obtaining p-value when some counts are small</p>
</td></tr>
<tr><td><code id="quartetTreeTest_+3A_bootstraps">bootstraps</code></td>
<td>
<p>number of samples for bootstrapping</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements two of
the versions of the test given by Mitchell et al. (2019) as well as parametric boostrapping,
with other procedures for when some expected counts are small.
When the topology and/or the internal
quartet branch length is not specified by the null hypothesis these are more accurate tests than,
say, a Chi-square with one degree of freedom, which is not theoretically
justified near the singularities and boundaries of the models.
</p>
<p>If <code>method="MLtest"</code>, this uses the test by that name described in Section 7 of Mitchell et al. (2019).
For both the T1 and T3 models the test is slightly anticonservative over a small range of true internal edges of the quartet species tree.
Although the test generally performs well in practice, it lacks a uniform asymptotic guarantee over
the full parameter space for either T1 or T3.
</p>
<p>If <code>method="conservative"</code>, a conservative test described by Mitchell et al. (2019) is used. For model T3 this
uses the Chi-square distribution with 1 degree of freedom
(the &quot;least favorable&quot; approach), while for model T1
it uses the Minimum Adjusted Bonferroni, based on precomputed values from simulations with n=1e+6.
These conservative tests are asymptotically guaranteed to reject the null
hypothesis at most at a specified level, but at the expense of increased type II errors.
</p>
<p>If <code>method="bootstrap"</code>, then parametric bootstrapping is performed, based on parameter estimates of the quartet topology
and internal edge length. The bootstrap sample size is given by the <code>bootstrap</code> argument.
</p>
<p>When some expected topology counts are small, the methods <code>"MLest"</code> and <code>"conservative"</code> are not appropriate.
The argument <code>smallcounts</code> determines whether bootstrapping or a faster approximate method is used.
These both involve estimates of the quartet topology and internal edge length. The approximate approach
returns a precomputed p-value, found by replacing the largest observed count
with 1e+6 and performing 1e+8 bootstraps for the model T3. When n is sufficiently large (at least 30) and
some expected counts are small, the quartet tree error probability is small and the bootstrap p-value is
approximately independent of the choice of T3 or T1 and of the largest observed count.
</p>
<p>For model T1, the first entry of <code>obs</code> is treated as the count of gene quartets concordant with the species tree.
</p>
<p>The returned p-value should be taken with caution when there is a small sample size, e.g. less than 30 gene trees.
The returned value of <code>bl</code> is a consistent estimator, but not the MLE, of the internal
edge length in coalescent units. Although consistent, the MLE for t is biased.
Our consistent estimator is still biased, but with less bias than the MLE. See Mitchell et al. (2019)
for more discussion on dealing with the bias of parameter estimates in the
presence of boundaries and/or singularities of parameter spaces.
</p>


<h3>Value</h3>

<p><code>output</code> where <code>output$p.value</code> is the p-value and <code>output$edgelength</code> is a consistent estimator of the
internal edge length in coalescent units, possibly <code>Inf</code>.
</p>


<h3>References</h3>

<p>Mitchell J, Allman ES, Rhodes JA (2019).
&ldquo;Hypothesis testing near singularities and boundaries.&rdquo;
<em>Electron. J. Statist.</em>, <b>13</b>(1), 2150-2193.
<a href="https://doi.org/10.1214/19-EJS1576">doi:10.1214/19-EJS1576</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTreeTestInd">quartetTreeTestInd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> quartetTreeTest(c(17,72,11),"T3")
 quartetTreeTest(c(17,72,11),"T1")
 quartetTreeTest(c(72,11,17),"T1")
 quartetTreeTest(c(11,17,72),"T1")

</code></pre>

<hr>
<h2 id='quartetTreeTestInd'>Multiple independent hypothesis tests for quartet counts fitting a species tree under the MSC</h2><span id='topic+quartetTreeTestInd'></span>

<h3>Description</h3>

<p>Perform a tree hypothesis test for all quartet counts in an input table, as if the counts for different choices of 4 taxa
are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetTreeTestInd(
  rqt,
  model = "T3",
  lambda = 0,
  method = "MLest",
  smallcounts = "approximate",
  bootstraps = 10^4,
  speciestree = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetTreeTestInd_+3A_rqt">rqt</code></td>
<td>
<p>table of resolved quartet counts, as produced by <code>quartetTableResolved</code>, or <code>quartetStarTestInd</code></p>
</td></tr>
<tr><td><code id="quartetTreeTestInd_+3A_model">model</code></td>
<td>
<p><code>"T1"</code> for a specific species tree topology, or <code>"T3"</code> for any species tree topology, with these
models explained more fully by Mitchell et al. (2019)</p>
</td></tr>
<tr><td><code id="quartetTreeTestInd_+3A_lambda">lambda</code></td>
<td>
<p>power divergence statistic parameter (e.g., 0 for likelihood ratio statistic, 1 for Chi-squared statistic)</p>
</td></tr>
<tr><td><code id="quartetTreeTestInd_+3A_method">method</code></td>
<td>
<p><code>"MLest"</code>, <code>"conservative"</code>, or <code>"bootstrap"</code>; see <code>quartetTreeTest</code> for explanation</p>
</td></tr>
<tr><td><code id="quartetTreeTestInd_+3A_smallcounts">smallcounts</code></td>
<td>
<p><code>"bootstrap"</code> or <code>"approximate"</code>, method of obtaining p-value when some counts are small, so
the chosen <code>method</code> is inappropriate</p>
</td></tr>
<tr><td><code id="quartetTreeTestInd_+3A_bootstraps">bootstraps</code></td>
<td>
<p>number of samples for bootstrapping</p>
</td></tr>
<tr><td><code id="quartetTreeTestInd_+3A_speciestree">speciestree</code></td>
<td>
<p>species tree, in Newick as text, to determine quartet for T1 test; required for <code>model="T1"</code>,
ignored for <code>model="T3"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes all quartets are resolved.  The test performed and the arguments
are described more fully in <code>quartetTreeTest</code>.
</p>


<h3>Value</h3>

<p>if <code>model="T3"</code>, a copy of <code>rqt</code> with a new column <code>"p_T3"</code> appended with p-values for each quartet;
if <code>model="T1"</code>, a copy of <code>rqt</code> with 2 columns appended: <code>"p_T1"</code> with p-values, and <code>"qindex"</code>
giving index of quartet consistent with specified species tree,
i.e., 1 if 12|34 on species tree, 2 if 13|24, 3 if 14|23
</p>


<h3>References</h3>

<p>Mitchell J, Allman ES, Rhodes JA (2019).
&ldquo;Hypothesis testing near singularities and boundaries.&rdquo;
<em>Electron. J. Statist.</em>, <b>13</b>(1), 2150-2193.
<a href="https://doi.org/10.1214/19-EJS1576">doi:10.1214/19-EJS1576</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTreeTest">quartetTreeTest</a></code>, <code><a href="#topic+quartetTestPlot">quartetTestPlot</a></code>, <code><a href="#topic+quartetStarTestInd">quartetStarTestInd</a></code>, <code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=c("t1","t2","t3","t4","t5","t6")
QT=quartetTable(gtrees,tnames)
RQT=quartetTableResolved(QT)
stree="(((t5,t6),t4),((t1,t2),t3));"
pTable3=quartetTreeTestInd(RQT,"T3")
quartetTablePrint(pTable3[1:6,])
stree="((((t5,t6),t4),t7),((t8,t9),((t1,t2),t3)));"
pTable1=quartetTreeTestInd(RQT,"T1",speciestree=stree)
quartetTablePrint(pTable1[1:6,])

</code></pre>

<hr>
<h2 id='quartetWeightedDist'>Compute the Weighted Quartet Distance between taxa</h2><span id='topic+quartetWeightedDist'></span>

<h3>Description</h3>

<p>Compute the Weighted Quartet Distance between taxa of Yourdkhani and Rhodes (2020) from a table specifying a collection of quartets on
<code>n</code> taxa and the quartets' internal branch lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartetWeightedDist(dqt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartetWeightedDist_+3A_dqt">dqt</code></td>
<td>
<p>an (<code>n</code> choose 4) x (<code>n+1</code>) matrix of the form output by <code>quartetTableDominant</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pairwise distance matrix on <code>n</code> taxa
</p>


<h3>References</h3>

<p>Yourdkhani S, Rhodes JA (2020).
&ldquo;Inferring metric trees from weighted quartets via an intertaxon distance.&rdquo;
<em>Bul. Math. Biol.</em>, <b>82</b>(97).
<a href="https://doi.org/10.1007/s11538-020-00773-4">doi:10.1007/s11538-020-00773-4</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>,
<code><a href="#topic+WQDSAdjustLengths">WQDSAdjustLengths</a></code>,
<code><a href="#topic+WQDS">WQDS</a></code>,
<code><a href="#topic+WQDC">WQDC</a></code>, 
<code><a href="#topic+WQDCrecursive">WQDCrecursive</a></code>,
<code><a href="#topic+quartetWeightedDist">quartetWeightedDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
DQT=quartetTableDominant(RQT,bigweights="finite")
D=quartetWeightedDist(DQT)
tree=NJ(D)
stree=WQDSAdjustLengths(tree)
write.tree(stree)

</code></pre>

<hr>
<h2 id='simplexCoords'>Convert 3-d coordinates to 2-d probability simplex coordinates</h2><span id='topic+simplexCoords'></span>

<h3>Description</h3>

<p>Convert from 3-d Cartesian coordinates to 2-d coordinates suitable for plotting in the probability simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplexCoords(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplexCoords_+3A_v">v</code></td>
<td>
<p>vector of 3 non-negative numbers, not summing to 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies an affine coordinate trandformation that maps the centroid (1/3,1/3,1/3) to the origin (0,0), and 
rescales so that the line segments between (1,0,0), (0,1,0), and (0,0,1) are mapped to segments of length 1.
</p>
<p>An input vector <code>v</code> is first normalized so its component sum to 1 before the map is applied.
</p>


<h3>Value</h3>

<p>2-d coordinates to plot normalized point in simplex
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplexLabels">simplexLabels</a></code>,
<code><a href="#topic+simplexPoint">simplexPoint</a></code>,
<code><a href="#topic+simplexPrepare">simplexPrepare</a></code>,
<code><a href="#topic+simplexSegment">simplexSegment</a></code>,
<code><a href="#topic+simplexText">simplexText</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     simplexCoords(c(15,65,20))

</code></pre>

<hr>
<h2 id='simplexLabels'>Label vertices of 2-d probability simplex</h2><span id='topic+simplexLabels'></span>

<h3>Description</h3>

<p>Add labels to vertices of the probability simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplexLabels(top = "", left = "", right = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplexLabels_+3A_top">top</code></td>
<td>
<p>label for top</p>
</td></tr>
<tr><td><code id="simplexLabels_+3A_left">left</code></td>
<td>
<p>label for left bottom</p>
</td></tr>
<tr><td><code id="simplexLabels_+3A_right">right</code></td>
<td>
<p>label for right bottom</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simplexPoint">simplexPoint</a></code>,
<code><a href="#topic+simplexPrepare">simplexPrepare</a></code>,
<code><a href="#topic+simplexSegment">simplexSegment</a></code>,
<code><a href="#topic+simplexText">simplexText</a></code>,
<code><a href="#topic+simplexCoords">simplexCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   simplexPrepare("T3","Example Plot")
   simplexLabels("ab|cd","ac|bd","ad|bc")

</code></pre>

<hr>
<h2 id='simplexPoint'>Plot point in 2-d probability simplex</h2><span id='topic+simplexPoint'></span>

<h3>Description</h3>

<p>Normalizes a point given in 3-d non-normalized coordinates, then plots it in 
the 2-d probability simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplexPoint(v, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplexPoint_+3A_v">v</code></td>
<td>
<p>a 3-d point in non-negative orthant, coordinates not summing to 0</p>
</td></tr>
<tr><td><code id="simplexPoint_+3A_...">...</code></td>
<td>
<p>other options to pass to graphics::points function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simplexLabels">simplexLabels</a></code>,
<code><a href="#topic+simplexPrepare">simplexPrepare</a></code>,
<code><a href="#topic+simplexSegment">simplexSegment</a></code>,
<code><a href="#topic+simplexText">simplexText</a></code>,
<code><a href="#topic+simplexCoords">simplexCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   simplexPrepare("T3","Example Plot")
   simplexPoint(c(15,65,20),pch=3,col="blue")

</code></pre>

<hr>
<h2 id='simplexPrepare'>Draw 2-d probability simplex, with model lines for T3 or T1 model</h2><span id='topic+simplexPrepare'></span>

<h3>Description</h3>

<p>Outline the 2-d probability simplex, and draw the T1 or T3 model points for quartet frequencies.
The models &quot;T1&quot; and &quot;T3&quot; are described more fully by Mitchell et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplexPrepare(model = "T3", maintitle = NULL, titletext = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplexPrepare_+3A_model">model</code></td>
<td>
<p><code>"T1"</code> or <code>"T3"</code>, for 1-tree or 3-tree model</p>
</td></tr>
<tr><td><code id="simplexPrepare_+3A_maintitle">maintitle</code></td>
<td>
<p>main title for plot</p>
</td></tr>
<tr><td><code id="simplexPrepare_+3A_titletext">titletext</code></td>
<td>
<p>additional text for title</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mitchell J, Allman ES, Rhodes JA (2019).
&ldquo;Hypothesis testing near singularities and boundaries.&rdquo;
<em>Electron. J. Statist.</em>, <b>13</b>(1), 2150-2193.
<a href="https://doi.org/10.1214/19-EJS1576">doi:10.1214/19-EJS1576</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simplexLabels">simplexLabels</a></code>,
<code><a href="#topic+simplexPoint">simplexPoint</a></code>,
<code><a href="#topic+simplexSegment">simplexSegment</a></code>,
<code><a href="#topic+simplexText">simplexText</a></code>,
<code><a href="#topic+simplexCoords">simplexCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   simplexPrepare("T3",maintitle="Main title",titletext="further text")

</code></pre>

<hr>
<h2 id='simplexSegment'>Plot line segment in 2-d probability simplex</h2><span id='topic+simplexSegment'></span>

<h3>Description</h3>

<p>Normalizes two points in 3-d, and draws line segment between them in 2-d probability simplex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplexSegment(v, w, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplexSegment_+3A_v">v</code>, <code id="simplexSegment_+3A_w">w</code></td>
<td>
<p>3-d endpoints of line segment in non-negative orthant, coords not summing to 0</p>
</td></tr>
<tr><td><code id="simplexSegment_+3A_...">...</code></td>
<td>
<p>other options to pass to graphics::segments function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simplexLabels">simplexLabels</a></code>,
<code><a href="#topic+simplexPoint">simplexPoint</a></code>,
<code><a href="#topic+simplexPrepare">simplexPrepare</a></code>,
<code><a href="#topic+simplexText">simplexText</a></code>,
<code><a href="#topic+simplexCoords">simplexCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   simplexPrepare("T3","Example Plot")
   simplexSegment(c(15,65,20),c(15,70, 15),col="green")

</code></pre>

<hr>
<h2 id='simplexText'>Add text at a point in 2-d probability simplex</h2><span id='topic+simplexText'></span>

<h3>Description</h3>

<p>Add text to a 2-d probability simplex plot, at specified location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplexText(v, label = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplexText_+3A_v">v</code></td>
<td>
<p>a 3-d point in non-negative orthant, coordinates not summing to 0</p>
</td></tr>
<tr><td><code id="simplexText_+3A_label">label</code></td>
<td>
<p>text to add to plot</p>
</td></tr>
<tr><td><code id="simplexText_+3A_...">...</code></td>
<td>
<p>other options to pass to graphics::text function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simplexLabels">simplexLabels</a></code>,
<code><a href="#topic+simplexPoint">simplexPoint</a></code>,
<code><a href="#topic+simplexPrepare">simplexPrepare</a></code>,
<code><a href="#topic+simplexSegment">simplexSegment</a></code>,
<code><a href="#topic+simplexCoords">simplexCoords</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   simplexPrepare("T3","Example Plot")
   simplexText(c(15,65,20),"tree ac|bd")

</code></pre>

<hr>
<h2 id='sortQuartetTableRows'>Sort quartet table rows by lex order</h2><span id='topic+sortQuartetTableRows'></span>

<h3>Description</h3>

<p>Sort the rows of a quartet table so they are in MSCquartet's standard lex order.
This is the order produced by the <code>quartetTable</code> function. The only exceptions
to this order produced in the package are when <code>quartetTable</code> is called with the
<code>random</code> argument non-zero, or when the <code>HolmBonferoni</code> function is called.
However, for tables made outside this package, it can be useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortQuartetTableRows(qT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortQuartetTableRows_+3A_qt">qT</code></td>
<td>
<p>a quartet Table to be sorted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+HolmBonferroni">HolmBonferroni</a></code>
</p>

<hr>
<h2 id='T1density'>Probability density function for Model T1</h2><span id='topic+T1density'></span>

<h3>Description</h3>

<p>Value of probability density function for Model T1 of Mitchell et al. (2019), Proposition 5.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T1density(x, mu0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T1density_+3A_x">x</code></td>
<td>
<p>statistic value (e.g., likelihood ratio statistic, or other power divergence statistic)</p>
</td></tr>
<tr><td><code id="T1density_+3A_mu0">mu0</code></td>
<td>
<p>parameter of density function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of density function
</p>


<h3>References</h3>

<p>Mitchell J, Allman ES, Rhodes JA (2019).
&ldquo;Hypothesis testing near singularities and boundaries.&rdquo;
<em>Electron. J. Statist.</em>, <b>13</b>(1), 2150-2193.
<a href="https://doi.org/10.1214/19-EJS1576">doi:10.1214/19-EJS1576</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+T3density">T3density</a></code>
</p>

<hr>
<h2 id='T3density'>Probability density function for Model T3</h2><span id='topic+T3density'></span>

<h3>Description</h3>

<p>Value of probability density function for Model T3 of Mitchell et al. (2019), Proposition 4.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T3density(x, mu0, alpha0, beta0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T3density_+3A_x">x</code></td>
<td>
<p>statistic value (e.g., likelihood ratio statistic, or other power divergence statistic)</p>
</td></tr>
<tr><td><code id="T3density_+3A_mu0">mu0</code></td>
<td>
<p>parameter of density function</p>
</td></tr>
<tr><td><code id="T3density_+3A_alpha0">alpha0</code></td>
<td>
<p>parameter of density function</p>
</td></tr>
<tr><td><code id="T3density_+3A_beta0">beta0</code></td>
<td>
<p>parameter of density function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of density function
</p>


<h3>References</h3>

<p>Mitchell J, Allman ES, Rhodes JA (2019).
&ldquo;Hypothesis testing near singularities and boundaries.&rdquo;
<em>Electron. J. Statist.</em>, <b>13</b>(1), 2150-2193.
<a href="https://doi.org/10.1214/19-EJS1576">doi:10.1214/19-EJS1576</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+T1density">T1density</a></code>
</p>

<hr>
<h2 id='taxonNames'>Get all taxon names from a collection of trees</h2><span id='topic+taxonNames'></span>

<h3>Description</h3>

<p>Create a vector of all taxon names appearing on a collection of trees, with no repeats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taxonNames(trees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="taxonNames_+3A_trees">trees</code></td>
<td>
<p>a multiPhylo object containing a collection of trees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of unique names of taxa appearing on the trees
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)

</code></pre>

<hr>
<h2 id='TINNIK'>TINNIK algorithm to infer species tree of blobs</h2><span id='topic+TINNIK'></span>

<h3>Description</h3>

<p>Apply the TINNIK algorithm of Allman et al. (2024) (see also Allman et al. (2022))
to infer a tree of blobs for the species network from a collection of gene trees,
under the network multispecies coalescent (NMSC) model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TINNIK(
  genedata,
  omit = FALSE,
  epsilon = 0,
  test = "T3",
  alpha = 0.05,
  beta = 0.95,
  treemethod = fastme.bal,
  delta = 0,
  taxanames = NULL,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TINNIK_+3A_genedata">genedata</code></td>
<td>
<p>gene tree data that may be supplied in any of 3 forms:
</p>

<ol>
<li><p> as a character string giving the name of a file containing Newick gene trees,
</p>
</li>
<li><p> as a multiPhylo object containing the gene trees, or
</p>
</li>
<li><p> as a table of quartets on the gene trees, as produced by a previous call to
<code>TINNIK</code> or <code>quartetTableResolved</code>, which has columns only for taxa, resolved quartet counts,
and possibly p_T3, p_cut, and p_star
</p>
</li></ol>
</td></tr>
<tr><td><code id="TINNIK_+3A_omit">omit</code></td>
<td>
<p><code>FALSE</code> to treat unresolved quartets as 1/3 of each resolution;
<code>TRUE</code> to discard unresolved quartet data; ignored if gene tree data given as quartet table</p>
</td></tr>
<tr><td><code id="TINNIK_+3A_epsilon">epsilon</code></td>
<td>
<p>minimum for branch lengths to be treated as non-zero; ignored if gene tree data given as quartet table</p>
</td></tr>
<tr><td><code id="TINNIK_+3A_test">test</code></td>
<td>
<p>a hypothesis test to perform, either &quot;cut&quot; or &quot;T3&quot; (default)</p>
</td></tr>
<tr><td><code id="TINNIK_+3A_alpha">alpha</code></td>
<td>
<p>a value or vector of significance levels for judging p-values for test specified by &quot;test&quot;;
testing a null hypothesis of no hybridization vs. an alternative of hybridization, for each quartet;  a smaller value applies
a less conservative test for a tree (more trees), hence a stricter requirement for deciding in favor of hybridization (fewer reticulations)</p>
</td></tr>
<tr><td><code id="TINNIK_+3A_beta">beta</code></td>
<td>
<p>a value or vector of significance levels for judging p-values testing
a null hypothesis of a star tree (polytomy) for each quartet vs. an alternative of anything else; a smaller value applies a less conservative
test for a star tree (more polytomies), hence a stricter requirement for deciding in favor of a resolved tree or network;
if vectors, <code>alpha</code> and <code>beta</code> must have the same length</p>
</td></tr>
<tr><td><code id="TINNIK_+3A_treemethod">treemethod</code></td>
<td>
<p>a function implementing a method of tree inference from a distance table,
e.g. the ape package's fastme.bal or nj</p>
</td></tr>
<tr><td><code id="TINNIK_+3A_delta">delta</code></td>
<td>
<p>a minimum edge length to retain in tree of blobs (see (Allman et al. 2024) for related theory); shorter edges are collapsed</p>
</td></tr>
<tr><td><code id="TINNIK_+3A_taxanames">taxanames</code></td>
<td>
<p>if <code>genedata</code> is a file or a multiPhylo object, a vector of a subset
of the taxa names on the gene trees
to be analyzed, if <code>NULL</code> all taxa on the first gene tree are used; if <code>genedata</code>
is a quartet table, this argument is ignored and all taxa in the table are used</p>
</td></tr>
<tr><td><code id="TINNIK_+3A_plot">plot</code></td>
<td>
<p><code>TRUE</code> produces simplex plots of hypothesis test results and plots the tree of blobs <code>FALSE</code> omits plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function
</p>

<ol>
<li><p> counts displayed quartets across gene trees to form quartet count concordance factors (qcCFs),
</p>
</li>
<li><p> applies appropriate hypothesis tests to judge qcCFs as representing putative hybridization,
resolved trees, or unresolved (star) trees using <code>alpha</code> and <code>beta</code> as significance levels,
</p>
</li>
<li><p> produces a simplex plot showing results of the hypothesis tests for all qcCFs
</p>
</li>
<li><p> computes the appropriate TINNIK distance table, and infers the tree of blobs from the distance.
</p>
</li></ol>

<p>A call of <code>TINNIK</code> with <code>genedata</code> given as a table previously output from <code>TINNIK</code> is
equivalent to a call of <code>TINNIKdist</code> followed by tree construction from the distance table.
If <code>genedata</code> is a
table previously output from <code>quartetTableResolved</code>
which lacks columns of p-values for hypothesis tests, these will be appended to the table output by <code>TINNIK</code>.
This table must contain a row with quartet counts for every 4 taxon set.
</p>
<p>If plots are produced, there are 2 simplex plots: The first shows the hypothesis test results,
and the second shows
inferred B-quartets and T-quartets. In both,
each point in the simplex plot corresponds to an empirical quartet concordance factor,
color-coded to represent test or inference results.
</p>
<p>In general, <code>alpha</code> should be chosen to be small and <code>beta</code>
to be large so that most quartets are interpreted as resolved trees. More quartets judges to have
either blob or unresolved relationships will lead to a less resolved blob tree.
</p>
<p>Usually, an initial call to <code>TINNIK</code> will not give a good analysis, as values
of <code>alpha</code> and <code>beta</code> are likely to need some adjustment based on inspecting the data. Saving the returned
table of test results from <code>TINNIK</code> will allow for the results of the time-consuming computation of qcCFs to be
saved, along with p-values,
for input to further calls of <code>TINNIK</code> with new choices of <code>alpha</code> and <code>beta</code>.
</p>
<p>See the documentation for <code><a href="#topic+TINNIKdist">TINNIKdist</a></code> for an explanation of a small, rarely noticeable,
stochastic element of the algorithm.
</p>
<p>For data sets of many gene trees, user time may be reduced by using parallel code for
counting displayed quartets. See <code><a href="#topic+quartetTableParallel">quartetTableParallel</a></code>.
</p>


<h3>Value</h3>

<p><code>output</code> (returned invisibly), with <code>output$ToB</code> the TINNIK tree of blobs, <code>output$pTable</code>
the table of quartets and p-values for judging fit to the MSC on quartet
trees, and <code>output$Bquartets</code> a TRUE/FALSE indicator vector of B-quartets; if <code>alpha, beta</code> are vectors, <code>output$ToB</code> is a vector of trees;
the table can be used as input to <code>TINNIK</code> or <code>TINNIKdist</code> with new choices of <code>alpha, beta</code>, without re-tallying quartets on
gene trees
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2022).
&ldquo;The tree of blobs of a species network: identifiability under the coalescent.&rdquo;
<em>Journal of Mathematical Biology</em>, <b>86</b>(1), 10.
<a href="https://doi.org/10.1007/s00285-022-01838-9">doi:10.1007/s00285-022-01838-9</a>.
</p>
<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2024).
&ldquo;TINNIK: Inference of the Tree of Blobs of Species Networks Under the Coalescent.&rdquo;
draft.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, <code><a href="#topic+quartetTableParallel">quartetTableParallel</a></code>, <code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>, <code><a href="#topic+quartetCutTestInd">quartetCutTestInd</a></code>,<code><a href="#topic+quartetTreeTestInd">quartetTreeTestInd</a></code>,
<code><a href="#topic+quartetStarTestInd">quartetStarTestInd</a></code>, <code><a href="#topic+TINNIKdist">TINNIKdist</a></code>, <code><a href="#topic+quartetTestPlot">quartetTestPlot</a></code>, <code><a href="#topic+pvalHist">pvalHist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
out=TINNIK(pTableYeastRokas,test="T3",alpha=.01, beta=.05)

</code></pre>

<hr>
<h2 id='TINNIKdist'>Compute TINNIK distance from quartets and hypothesis test p-values</h2><span id='topic+TINNIKdist'></span>

<h3>Description</h3>

<p>Apply the B-quartet inference algorithm of Allman et al. (2022), Allman et al. (2024) to
infer all B-quartets from results of hypothesis tests, and then compute an estimate of an intertaxon distance
fitting the topological tree of blobs of the species network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TINNIKdist(pTable, test = "T3", alpha = 0.05, beta = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TINNIKdist_+3A_ptable">pTable</code></td>
<td>
<p>table of resolved quartet counts, as produced by
<code>quartetTableResolved</code>, with extra columns from
both star hypothesis test, and either cut or T3 hypothesis tests</p>
</td></tr>
<tr><td><code id="TINNIKdist_+3A_test">test</code></td>
<td>
<p>either &quot;cut&quot; or &quot;T3&quot;</p>
</td></tr>
<tr><td><code id="TINNIKdist_+3A_alpha">alpha</code></td>
<td>
<p>critical value for cut or T3 test</p>
</td></tr>
<tr><td><code id="TINNIKdist_+3A_beta">beta</code></td>
<td>
<p>critical value for star test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes <code>pTable</code> has columns for taxa and resolved
quartet counts as originally produced by <code>quartetTable</code>,
and hypothesis test results as produced by
<code>quartetStarTestInd</code>, and either <code>quartetTreeTestInd</code> for the <code>T3</code> test or <code>quartetCutTestInd</code>.
Rows must be present for every 4-taxon subset.
(Note: Of functions in this package, only <code>HolmBonferroni</code> might modify the row order from the required one.)
</p>
<p>This function uses the Rcpp package for significant speed up in computation time.
</p>


<h3>Value</h3>

<p>a distance table <code>output$dist</code> and
a vector <code>output$Bquartets</code> with TRUE/FALSE entries indicating B-quartets
ordered as rows of <code>pTable</code>.
</p>


<h3>References</h3>

<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2022).
&ldquo;The tree of blobs of a species network: identifiability under the coalescent.&rdquo;
<em>Journal of Mathematical Biology</em>, <b>86</b>(1), 10.
<a href="https://doi.org/10.1007/s00285-022-01838-9">doi:10.1007/s00285-022-01838-9</a>.
</p>
<p>Allman ES, Baños H, Mitchell JD, Rhodes JA (2024).
&ldquo;TINNIK: Inference of the Tree of Blobs of Species Networks Under the Coalescent.&rdquo;
draft.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a>,<a href="#topic+quartetTableResolved">quartetTableResolved</a>,<a href="#topic+quartetStarTest">quartetStarTest</a></code>,
<code><a href="#topic+quartetCutTest">quartetCutTest</a></code>, <code><a href="#topic+quartetStarTestInd">quartetStarTestInd</a></code>, <code><a href="#topic+quartetCutTestInd">quartetCutTestInd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
out=TINNIKdist(pTableYeastRokas,test="T3",alpha=.05,beta=.05)

</code></pre>

<hr>
<h2 id='topDist'>Topological distances on a tree</h2><span id='topic+topDist'></span>

<h3>Description</h3>

<p>Compute a pairwise table of topological distances from a tree, after contracting short edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topDist(tree, epsilon = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topDist_+3A_tree">tree</code></td>
<td>
<p>a phylo object, with or without edge lengths</p>
</td></tr>
<tr><td><code id="topDist_+3A_epsilon">epsilon</code></td>
<td>
<p>a tolerance, so all edges shorter than epsilon are contracted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance table, with rows and columns named by taxa
</p>

<hr>
<h2 id='treeFromSplits'>Produce tree from compatible splits</h2><span id='topic+treeFromSplits'></span>

<h3>Description</h3>

<p>Produce tree from compatible splits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeFromSplits(sp, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeFromSplits_+3A_sp">sp</code></td>
<td>
<p>a compatible split system, as produced by compatibleSplits</p>
</td></tr>
<tr><td><code id="treeFromSplits_+3A_plot">plot</code></td>
<td>
<p>a logical, if TRUE, plot tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a phylo object for tree displaying splits
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compatibleSplits">compatibleSplits</a>, <a href="#topic+TINNIK">TINNIK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pTableYeastRokas)
dist=NANUQdist(pTableYeastRokas, alpha=.05, beta=.95,outfile=NULL)
nn=neighborNet(dist)
plot(nn,"2D")
tob=treeFromSplits(compatibleSplits(nn$splits),plot=TRUE) #produce tree of blobs of splits graph

</code></pre>

<hr>
<h2 id='treeOfBlobs'>Tree of blobs for a network</h2><span id='topic+treeOfBlobs'></span>

<h3>Description</h3>

<p>Given extended newick, an evonet object, or an igraph object for a network, return its reduced, unrooted
tree of blobs. Here 'reduced' means all nodes resulting from 2-blobs are suppressed, as are edges above
the network's LSA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeOfBlobs(net, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeOfBlobs_+3A_net">net</code></td>
<td>
<p>A network, supplied as an extended Newick string, an evonet object, or an igraph object</p>
</td></tr>
<tr><td><code id="treeOfBlobs_+3A_plot">plot</code></td>
<td>
<p>if TRUE (default), plot the tree of blobs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>phylo</code> containing the unrooted topological tree
derived from the network by contracting all blobs.  All edge lengths are 1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TINNIK">TINNIK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>network = "(((a:1,d:1):1,(b:1)#H1:1):1,(#H1,c:1):2);"
plot(read.evonet(text=network))
treeOfBlobs(network, plot=TRUE)

</code></pre>

<hr>
<h2 id='WQDC'>Compute Weighted Quartet Distance Consensus tree from gene tree data</h2><span id='topic+WQDC'></span>

<h3>Description</h3>

<p>Compute the Weighted Quartet Distance Consensus (Yourdkhani and Rhodes 2020) estimate of a 
species tree from gene tree data. This is a consistent estimator of the unrooted 
species tree topology and all internal branch lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WQDC(
  genetreedata,
  taxanames = NULL,
  method = fastme.bal,
  omit = FALSE,
  terminal = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WQDC_+3A_genetreedata">genetreedata</code></td>
<td>
<p>gene tree data that may be supplied in any of 3 forms:
</p>

<ol>
<li><p> a character string giving the name of a file containing gene trees in Newick
</p>
</li>
<li><p> a multiPhylo object containing gene trees
</p>
</li>
<li><p> a resolved quartet table, as produced by <code>quartetTableResolved</code>
</p>
</li></ol>
</td></tr>
<tr><td><code id="WQDC_+3A_taxanames">taxanames</code></td>
<td>
<p>if <code>genetreedata</code> is a file or a multiPhylo object, a vector of a subset
of the taxa names on the gene trees 
to be analyzed, if <code>NULL</code> all taxa on the first gene tree are used; if <code>genetreedata</code> 
is a quartet table, this argument is ignored and all taxa in the table are used</p>
</td></tr>
<tr><td><code id="WQDC_+3A_method">method</code></td>
<td>
<p>a distance-based tree building function, such as <code>fastme.bal</code> or <code>nj</code></p>
</td></tr>
<tr><td><code id="WQDC_+3A_omit">omit</code></td>
<td>
<p><code>TRUE</code> leaves out unresolved quartets, <code>FALSE</code> treats them as 1/3 of each resolution; ignored if 
<code>genetreedata</code> is given as  a resolved quartet table</p>
</td></tr>
<tr><td><code id="WQDC_+3A_terminal">terminal</code></td>
<td>
<p>non-negative branch length to supply for terminal branches 
whose length cannot be inferred by <code>WQDC</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper which performs the steps of reading in a collection
of gene trees, tallying quartets, estimating quartet internal branch lengths, computing the weighted
quartet distance between taxa, building
a tree, and adjusting edge lengths, to give a consistent estimate of the metric species tree in coalescent units
under the MSC.
</p>
<p>If the gene tree data indicates some quartets experienced little to no incomplete lineage 
sorting, this algorithm tends to be less topologically accurate than <code>QDC</code> 
(which infers no metric information) or <code>WQDCrecursive</code> (which gives better topologies,
and reasonably accurate lengths for short edges, though long edge lengths may still be unreliable).
</p>


<h3>Value</h3>

<p>an unrooted metric tree of type phylo
</p>


<h3>References</h3>

<p>Yourdkhani S, Rhodes JA (2020).
&ldquo;Inferring metric trees from weighted quartets via an intertaxon distance.&rdquo;
<em>Bul. Math. Biol.</em>, <b>82</b>(97).
<a href="https://doi.org/10.1007/s11538-020-00773-4">doi:10.1007/s11538-020-00773-4</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTable">quartetTable</a></code>, 
<code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>, 
<code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>, 
<code><a href="#topic+quartetWeightedDist">quartetWeightedDist</a></code>, 
<code><a href="#topic+WQDCrecursive">WQDCrecursive</a></code>, 
<code><a href="#topic+WQDS">WQDS</a></code>, 
<code><a href="#topic+QDC">QDC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
stree=WQDC(gtrees,tnames[1:6])
write.tree(stree)
plot(stree)

</code></pre>

<hr>
<h2 id='WQDCrecursive'>Compute the Recursive Weighted Quartet Distance Consensus tree from gene tree data</h2><span id='topic+WQDCrecursive'></span>

<h3>Description</h3>

<p>Infer a metric species tree from counts
of quartets displayed on a collection of gene trees, as described by 
Yourdkhani and Rhodes (2020). Edge lengths are in coalescent units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WQDCrecursive(rqt, method = fastme.bal, stopAt = 2, terminal = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WQDCrecursive_+3A_rqt">rqt</code></td>
<td>
<p>a resolved quartet table as produced by <code>quartetTableResolved</code></p>
</td></tr>
<tr><td><code id="WQDCrecursive_+3A_method">method</code></td>
<td>
<p>a distance-based tree building function, such as <code>fastme.bal</code> or <code>nj</code></p>
</td></tr>
<tr><td><code id="WQDCrecursive_+3A_stopat">stopAt</code></td>
<td>
<p>a non-negative branch length in coalescent units; recursive calls stop when the longest 
branch in a recursively examined subtree is smaller than this value</p>
</td></tr>
<tr><td><code id="WQDCrecursive_+3A_terminal">terminal</code></td>
<td>
<p>non-negative branch length to supply for terminal branches,
whose lengths cannot be inferred by <code>WQDCrecursive</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm counts quartets displayed on the gene trees, builds a tree using <code>WQDS</code>,
determines the split corresponding to the longest edge in that tree,
and then recursively builds trees
on the taxa in each split set together with a &lsquo;composite taxon&rsquo; formed by all
taxa in the other split set.
This approach is slower than non-recursive <code>WQDC</code>, but increases topological accuracy. Shorter branch 
lengths tend to be more accurately estimated.
</p>
<p>This function must be called with its argument a resolved quartet
table of size (n choose 4)x(n+3). Its recursive nature
requires building smaller resolved quartet tables on split sets with an additional
composite taxon.
</p>


<h3>Value</h3>

<p>an unrooted metric tree, of type phylo
</p>


<h3>References</h3>

<p>Yourdkhani S, Rhodes JA (2020).
&ldquo;Inferring metric trees from weighted quartets via an intertaxon distance.&rdquo;
<em>Bul. Math. Biol.</em>, <b>82</b>(97).
<a href="https://doi.org/10.1007/s11538-020-00773-4">doi:10.1007/s11538-020-00773-4</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTableResolved">quartetTableResolved</a></code>,<code><a href="#topic+quartetTable">quartetTable</a></code>,
<code><a href="#topic+QDC">QDC</a></code>, <code><a href="#topic+QDS">QDS</a></code>, <code><a href="#topic+quartetTableCollapse">quartetTableCollapse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
stree=WQDCrecursive(RQT)
write.tree(stree)
plot(stree)

</code></pre>

<hr>
<h2 id='WQDS'>Compute the Weighted Quartet Distance Supertree</h2><span id='topic+WQDS'></span>

<h3>Description</h3>

<p>Apply the Weighted Quartet Distance Supertree method of Yourdkhani and Rhodes (2020) to
a collection of quartets on <code>n</code> taxa together with internal 
quartet branch lengths, specified by a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WQDS(dqt, method = fastme.bal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WQDS_+3A_dqt">dqt</code></td>
<td>
<p>an (<code>n</code> choose 4) x <code>n+1</code>) matrix of form output by <code>quartetTableDominant</code></p>
</td></tr>
<tr><td><code id="WQDS_+3A_method">method</code></td>
<td>
<p>a distance-based tree building function (e.g., fastme.bal, NJ, etc.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper which runs <code>quartetWeightedDist</code>, builds a tree, and then adjusts edge lengths
with <code>WQDSAdjustLengths</code>.
</p>


<h3>Value</h3>

<p>an unrooted metric tree, of type phylo
</p>


<h3>References</h3>

<p>Yourdkhani S, Rhodes JA (2020).
&ldquo;Inferring metric trees from weighted quartets via an intertaxon distance.&rdquo;
<em>Bul. Math. Biol.</em>, <b>82</b>(97).
<a href="https://doi.org/10.1007/s11538-020-00773-4">doi:10.1007/s11538-020-00773-4</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quartetTableDominant">quartetTableDominant</a></code>, 
<code><a href="#topic+quartetWeightedDist">quartetWeightedDist</a></code>,
<code><a href="#topic+WQDSAdjustLengths">WQDSAdjustLengths</a></code>,
<code><a href="#topic+WQDC">WQDC</a></code>, 
<code><a href="#topic+WQDCrecursive">WQDCrecursive</a></code>,
<code><a href="#topic+QDS">QDS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
DQT=quartetTableDominant(RQT,bigweights= "finite")
tree=WQDS(DQT)
write.tree(tree)
plot(tree)

</code></pre>

<hr>
<h2 id='WQDSAdjustLengths'>Adjust edge lengths on tree built from Weighted Quartet distance 
to estimate metric tree</h2><span id='topic+WQDSAdjustLengths'></span>

<h3>Description</h3>

<p>Modify edge lengths of a tree built from a distance table produced by <code>quartetWeightedDist</code>,
to remove scaling factors related to the size of the split associated to the edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WQDSAdjustLengths(tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WQDSAdjustLengths_+3A_tree">tree</code></td>
<td>
<p>an unrooted metric tree, of type phylo</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As explained by Yourdkhani and Rhodes (2020), a metric tree produced from
the weighted quartet distance has edge lengths
inflated by a factor dependent on the associated split size. Removing these
factors 
yields a consistent estimate of the metric species tree displaying the weighted
quartets, if such a tree exists.
</p>
<p>This function should not be used on trees output from <code>WQDS</code>, <code>WQDC</code>,
or <code>WQDCrecursive</code>, as 
their edges are already adjusted. It can be used on trees built from the distance
computed by <code>quartetWeightedDist</code>.
</p>


<h3>Value</h3>

<p>an unrooted metric tree, of type phylo
</p>


<h3>References</h3>

<p>Yourdkhani S, Rhodes JA (2020).
&ldquo;Inferring metric trees from weighted quartets via an intertaxon distance.&rdquo;
<em>Bul. Math. Biol.</em>, <b>82</b>(97).
<a href="https://doi.org/10.1007/s11538-020-00773-4">doi:10.1007/s11538-020-00773-4</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WQDS">WQDS</a></code>,
<code><a href="#topic+WQDC">WQDC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gtrees=read.tree(file=system.file("extdata","dataGeneTreeSample",package="MSCquartets"))
tnames=taxonNames(gtrees)
QT=quartetTable(gtrees,tnames[1:6])
RQT=quartetTableResolved(QT)
DQT=quartetTableDominant(RQT,bigweights="finite")
D=quartetWeightedDist(DQT)
tree=NJ(D)
write.tree(tree)
plot(tree)
stree=WQDSAdjustLengths(tree)
write.tree(stree)
plot(stree)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
