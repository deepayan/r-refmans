<!DOCTYPE html><html><head><title>Help for package sft</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sft}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assessment'>
<p>Workload Assessment Functions</p></a></li>
<li><a href='#assessmentGroup'>
<p>Assessment Functions</p></a></li>
<li><a href='#capacity.and'>
<p>Capacity Coefficient for Exhaustive (AND) Processing</p></a></li>
<li><a href='#capacity.or'>
<p>Capacity Coefficient for First-Terminating (OR) Processing</p></a></li>
<li><a href='#capacity.stst'>
<p>Capacity Coefficient for Single-Target Self-Terminating (STST) Processing</p></a></li>
<li><a href='#capacityGroup'>
<p>Capacity Analysis</p></a></li>
<li><a href='#dots'><p>RT and and Accuracy from a Simple Detection Task</p></a></li>
<li><a href='#estimate.bounds'>
<p>Bounds on Response Time Cumulative Distribution Functions for Parallel Processing Models</p></a></li>
<li><a href='#estimateNAH'><p>Neslon-Aalen Estimator of the Cumulative Hazard Function</p></a></li>
<li><a href='#estimateNAK'><p>Neslon-Aalen Estimator of the Reverse Cumulative Hazard Function</p></a></li>
<li><a href='#estimateUCIPand'>
<p>UCIP Performance on AND Tasks</p></a></li>
<li><a href='#estimateUCIPor'>
<p>UCIP Performance on OR Tasks</p></a></li>
<li><a href='#fPCAassessment'><p>Functional Principal Components Analysis for the Assessment Functions</p></a></li>
<li><a href='#fPCAcapacity'><p>Functional Principal Components Analysis for the Capacity Coefficient</p></a></li>
<li><a href='#mic.test'>
<p>Test of the Mean Interaction Contrast</p></a></li>
<li><a href='#sic'>
<p>Calculate the Survivor Interaction Contrast</p></a></li>
<li><a href='#sic.test'>
<p>Statistical test of the SIC.</p></a></li>
<li><a href='#sicGroup'>
<p>SIC Analysis for a Group</p></a></li>
<li><a href='#siDominance'>
<p>Dominance Test for Selective Influence</p></a></li>
<li><a href='#ucip.test'>
<p>A Statistical Test for Super or Limited Capacity</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.2-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Systems Factorial Technology Analysis of Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Joe Houpt &lt;joseph.houpt@wright.edu&gt;, Leslie Blaha &lt;Leslie.Blaha@wpafb.af.mil&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joe Houpt &lt;joseph.houpt@wright.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 1.8.0), methods, fda, SuppDists</td>
</tr>
<tr>
<td>Description:</td>
<td>A series of tools for analyzing Systems Factorial Technology data.  This includes functions for plotting and statistically testing capacity coefficient functions and survivor interaction contrast functions.  Houpt, Blaha, McIntire, Havig, and Townsend (2013) &lt;<a href="https://doi.org/10.3758%2Fs13428-013-0377-3">doi:10.3758/s13428-013-0377-3</a>&gt; provide a basic introduction to Systems Factorial Technology along with examples using the sft R package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-08 14:56:40 UTC; jhoupt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-08 15:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='assessment'>
Workload Assessment Functions
</h2><span id='topic+assessment'></span>

<h3>Description</h3>

<p>Calculates the Workload Assessment Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assessment(RT, CR, OR=NULL, stopping.rule=c("OR","AND"), correct=c(TRUE, FALSE), 
  fast=c(TRUE, FALSE), detection=TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assessment_+3A_rt">RT</code></td>
<td>
<p>A list of response time arrays.  The first array in the list is assumed to be the exhaustive condition.</p>
</td></tr>
<tr><td><code id="assessment_+3A_cr">CR</code></td>
<td>
<p>A list of correct/incorrect indicator arrays.  If NULL, assumes all are correct.</p>
</td></tr>
<tr><td><code id="assessment_+3A_or">OR</code></td>
<td>
<p>Indicates whether to compare performance to an OR or AND processing baseline.  Provided for backwards compatibility for package version &lt; 2. </p>
</td></tr>
<tr><td><code id="assessment_+3A_stopping.rule">stopping.rule</code></td>
<td>
<p>Indicates whether to compare performance to an OR or AND processing baseline.</p>
</td></tr>
<tr><td><code id="assessment_+3A_correct">correct</code></td>
<td>
<p>Indicates whether to assess performance on correct trials.</p>
</td></tr>
<tr><td><code id="assessment_+3A_fast">fast</code></td>
<td>
<p>Indicates whether to use cumulative distribution functions or survivor functions to assess performance.</p>
</td></tr>
<tr><td><code id="assessment_+3A_detection">detection</code></td>
<td>
<p>Indicates whether to use a detection task baseline or a discrimination task baseline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assessment functions are a generalization of the workload capacity functions that account for incorrect responses. Townsend &amp; Altieri (2012) derived four different assessment functions each for AND and OR tasks to compare performance with two targets with the performance of an unlimited-capacity, independent, parallel (UCIP) model.  The correct assessment functions assess performance on correct trials and the incorrect assessment functions assess performance on the trials with incorrect responses.  The fast assessment functions use the cumulative distribution functions, similar to the AND capacity coefficient, and the slow assessment functions use the survivor functions, similar to the OR capacity coefficient.
</p>
<p>In an OR task, the detection model assumes that the response will be correct if it is correct on either source, i.e., if either source is detected.  In discrimination OR tasks, a participant may respond based on whichever source finishes first.  Hence, the response will be incorrect if the first to finish is incorrect even if the second source would have been correct.  This results in a slightly different baseline for performance assessment.  See Donkin, Little and Houpt (2013) for details.
</p>


<h3>Value</h3>

<table>
<tr><td><code>A</code></td>
<td>
<p>An object of class stepfun representing the estimated assessment function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. and Altieri, N. (2012).  An accuracy-response time capacity assessment function that measures performance against standard parallel predictions. <em>Psychological Review, 3</em>, 500-516.
</p>
<p>Donkin, C, Little, D.R. and Houpt (2013). Assessing the effects of caution on the capacity of information processing.  <em>Manuscript submitted for publication.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity.or">capacity.or</a></code>
<code><a href="#topic+capacity.and">capacity.and</a></code>
<code><a href="stats.html#topic+stepfun">stepfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c1c.12 &lt;- rexp(10000, .015)
c1i.12 &lt;- rexp(10000, .01)
c1c    &lt;- rexp(10000, .015)
c1i    &lt;- rexp(10000, .01)

c2c.12 &lt;- rexp(10000, .014)
c2i.12 &lt;- rexp(10000, .01)
c2c    &lt;- rexp(10000, .014)
c2i    &lt;- rexp(10000, .01)

RT.1 &lt;- pmin(c1c, c1i)
CR.1 &lt;- c1c &lt; c1i
RT.2 &lt;- pmin(c2c, c2i)
CR.2 &lt;- c2c &lt; c2i

c1Correct &lt;- c1c.12 &lt; c1i.12
c2Correct &lt;- c2c.12 &lt; c2i.12

# OR Detection
CR.12 &lt;- c1Correct | c2Correct
RT.12 &lt;- rep(NA, 10000)
RT.12[c1Correct &amp; c2Correct] &lt;- pmin(c1c.12, c2c.12)[c1Correct &amp; c2Correct]
RT.12[c1Correct &amp; !c2Correct] &lt;- c1c.12[c1Correct &amp; !c2Correct]
RT.12[!c1Correct &amp; c2Correct] &lt;- c2c.12[!c1Correct &amp; c2Correct]
RT.12[!c1Correct &amp; !c2Correct] &lt;- pmax(c1i.12, c2i.12)[!c1Correct &amp; !c2Correct]

RT &lt;- list(RT.12, RT.1, RT.2)
CR &lt;- list(CR.12, CR.1, CR.2)
a.or.cf &lt;- assessment(RT, CR, stopping.rule="OR", correct=TRUE, fast=TRUE, detection=TRUE)
a.or.cs &lt;- assessment(RT, CR, stopping.rule="OR", correct=TRUE, fast=FALSE, detection=TRUE)
a.or.if &lt;- assessment(RT, CR, stopping.rule="OR", correct=FALSE, fast=TRUE, detection=TRUE)
a.or.is &lt;- assessment(RT, CR, stopping.rule="OR", correct=FALSE, fast=FALSE, detection=TRUE)

par(mfrow=c(2,2))
plot(a.or.cf, ylim=c(0,2))
plot(a.or.cs, ylim=c(0,2))
plot(a.or.if, ylim=c(0,2))
plot(a.or.is, ylim=c(0,2))


# AND 
CR.12 &lt;- c1Correct &amp; c2Correct
RT.12 &lt;- rep(NA, 10000)
RT.12[CR.12] &lt;- pmax(c1c.12, c2c.12)[CR.12]
RT.12[c1Correct &amp; !c2Correct] &lt;- c2i.12[c1Correct &amp; !c2Correct]
RT.12[!c1Correct &amp; c2Correct] &lt;- c1i.12[!c1Correct &amp; c2Correct]
RT.12[!c1Correct &amp; !c2Correct] &lt;- pmin(c1i.12, c2i.12)[!c1Correct &amp; !c2Correct]

RT &lt;- list(RT.12, RT.1, RT.2)
CR &lt;- list(CR.12, CR.1, CR.2)
a.and.cf &lt;- assessment(RT, CR, stopping.rule="AND", correct=TRUE, fast=TRUE, detection=TRUE)
a.and.cs &lt;- assessment(RT, CR, stopping.rule="AND", correct=TRUE, fast=FALSE, detection=TRUE)
a.and.if &lt;- assessment(RT, CR, stopping.rule="AND", correct=FALSE, fast=TRUE, detection=TRUE)
a.and.is &lt;- assessment(RT, CR, stopping.rule="AND", correct=FALSE, fast=FALSE, detection=TRUE)

par(mfrow=c(2,2))
plot(a.and.cf, ylim=c(0,2))
plot(a.and.cs, ylim=c(0,2))
plot(a.and.if, ylim=c(0,2))
plot(a.and.is, ylim=c(0,2))
</code></pre>

<hr>
<h2 id='assessmentGroup'>
Assessment Functions
</h2><span id='topic+assessmentGroup'></span>

<h3>Description</h3>

<p>Calculates the specified assessment function for each participant and each condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assessmentGroup(inData, stopping.rule=c("OR", "AND"), correct=c(TRUE, FALSE), 
  fast=c(TRUE, FALSE), detection=TRUE, plotAt=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assessmentGroup_+3A_indata">inData</code></td>
<td>
<p>Data collected from a Double Factorial Paradigm experiment in standard form.</p>
</td></tr>
<tr><td><code id="assessmentGroup_+3A_or">OR</code></td>
<td>
<p>Indicates whether to compare performance to an OR or AND processing baseline.  Provided for backwards compatibility for package version &lt; 2. </p>
</td></tr>
<tr><td><code id="assessmentGroup_+3A_stopping.rule">stopping.rule</code></td>
<td>
<p>Indicates whether to use OR or AND processing baseline to calculate individual assessment functions.</p>
</td></tr>
<tr><td><code id="assessmentGroup_+3A_plotat">plotAt</code></td>
<td>
<p>Indicates whether or not to generate plots of the assessment functions.</p>
</td></tr>
<tr><td><code id="assessmentGroup_+3A_correct">correct</code></td>
<td>
<p>Indicates whether to assess performance on correct trials.</p>
</td></tr>
<tr><td><code id="assessmentGroup_+3A_fast">fast</code></td>
<td>
<p>Indicates whether to use cumulative distribution functions or survivor functions to assess performance.</p>
</td></tr>
<tr><td><code id="assessmentGroup_+3A_detection">detection</code></td>
<td>
<p>Indicates whether to use a detection task baseline or a discrimination task baseline.</p>
</td></tr>
<tr><td><code id="assessmentGroup_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the details of the assessment functions, see <code><a href="#topic+assessment">assessment</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>overview</code></td>
<td>
<p>A data frame indicating whether the OR and AND capacity coefficients significantly above baseline (super), below baseline (limited) or neither (unlimited) both at the individual level and at the group level in each condition.  NA is returned for any participant that had performance below the accuracy cutoff in a condition.</p>
</td></tr>
<tr><td><code>Ct.fn</code></td>
<td>
<p>Matrix with each row giving the values of the of the estimated capacity coefficient for one participant in one condition for values of times.  The rows match the ordering of statistic.</p>
</td></tr>
<tr><td><code>Ct.var</code></td>
<td>
<p>Matrix with each row giving the values of the of the variance of the estimated capacity coefficient for one participant in one condition for values of times.  Only returned if ratio=FALSE.</p>
</td></tr>
<tr><td><code>capacity</code></td>
<td>
<p>A list with the returned values from the capacity function for each participant and each condition.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>Times at which the matrix capacity coefficients are calculated in Ct.fn matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. and Altieri, N. (2012).  An accuracy-response time capacity assessment function that measures performance against standard parallel predictions. <em>Psychological Review, 3</em>, 500-516.
</p>
<p>Donkin, C, Little, D.R. and Houpt (2013). Assessing the effects of caution on the capacity of information processing.  <em>Manuscript submitted for publication.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assessment">assessment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dots)
assessmentGroup(subset(dots, Condition=="OR"), 
  stopping.rule="OR", correct=TRUE, fast=TRUE, 
  detection=TRUE)
capacityGroup(subset(dots, Condition=="AND"), 
  stopping.rule="AND")

## End(Not run)
</code></pre>

<hr>
<h2 id='capacity.and'>
Capacity Coefficient for Exhaustive (AND) Processing
</h2><span id='topic+capacity.and'></span>

<h3>Description</h3>

<p>Calculates the Capacity Coefficient for Exhaustive (AND) Processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capacity.and(RT, CR=NULL, ratio=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capacity.and_+3A_rt">RT</code></td>
<td>
<p>A list of response time arrays.  The first array in the list is assumed to be the exhaustive condition.</p>
</td></tr>
<tr><td><code id="capacity.and_+3A_cr">CR</code></td>
<td>
<p>A list of correct/incorrect indicator arrays.  If NULL, assumes all are correct.</p>
</td></tr>
<tr><td><code id="capacity.and_+3A_ratio">ratio</code></td>
<td>
<p>Indicates whether to return the standard ratio capacity coefficient or, if FALSE, the difference form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The AND capacity coefficient compares performance on task to an unlimited-capacity, independent, parallel (UCIP) model using cumulative reverse hazard functions.  Suppose <code class="reqn">K_i(t)</code> is the cumulative reverse hazard function for response times when process <code class="reqn">i</code> is completed in isolation and <code class="reqn">K_i(t)</code> is the cumulative reverse hazard function for response times when all processes must completed together.  Then the AND capacity coefficient is given by, 
</p>
<p style="text-align: center;"><code class="reqn">C_{\rm AND}(t)=\frac{\sum_i K_i(t)}{K_{\rm AND}(t)}.</code>
</p>

<p>The numerator is the estimated cumulative reverse hazard function for the UCIP model, based on the response times for each process in isolation and the denominator is the actual performance. 
</p>
<p><code class="reqn">C_{\rm AND}(t) &lt;1</code> implies worse performance than the UCIP model.  This indicates that either there are limited processing resources, there is inhibition among the subprocesses, or the items are not processed in parallel (e.g., the items may be processed serially).
</p>
<p><code class="reqn">C_{\rm AND}(t) &gt;1</code> implies better performance than the UCIP model.  This indicates that either there are more processing resources available per process when there are more processes, that there is facilitation among the subprocesses, or the items are not processed in parallel (e.g., the items may be processed coactively).
</p>
<p>The difference form of the capacity coefficient (returned if ratio=FALSE) is given by,
</p>
<p style="text-align: center;"><code class="reqn">C_{\rm AND}(t)=K_{\rm AND}(t) - \sum_i K_i(t).</code>
</p>
<p>  Negative values indicate worse than UCIP performance and positive values indicate better than UCIP performance.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Ct</code></td>
<td>
<p>An object of class approxfun representing the estimated AND capacity coefficient.</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>An object of class approxfun representing the variance of the estimated AND capacity coefficient.  Only returned if ratio=FALSE.</p>
</td></tr>
<tr><td><code>Ctest</code></td>
<td>
<p>A list with class &quot;htest&quot; that is returned from <code><a href="#topic+ucip.test">ucip.test</a></code> and contains the statistic and p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Wenger, M.J. (2004). A theory of interactive parallel processing: New capacity measures and predictions for a response time inequality series. <em>Psychological Review, 111</em>, 1003&ndash;1035.
</p>
<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical Measures for Workload Capacity Analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>
<p>Houpt, J.W., Blaha, L.M., McIntire, J.P., Havig, P.R. and Townsend, J.T. (2013). Systems Factorial Technology with R. <em>Behavior Research Methods</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ucip.test">ucip.test</a></code>
<code><a href="#topic+capacityGroup">capacityGroup</a></code>
<code><a href="#topic+capacity.or">capacity.or</a></code>
<code><a href="#topic+estimateUCIPand">estimateUCIPand</a></code>
<code><a href="#topic+estimateNAK">estimateNAK</a></code>
<code><a href="stats.html#topic+approxfun">approxfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate1 &lt;- .35
rate2 &lt;- .3
RT.pa &lt;- rexp(100, rate1)
RT.ap &lt;- rexp(100, rate2)
RT.pp.limited &lt;- pmax( rexp(100, .5*rate1), rexp(100, .5*rate2))
RT.pp.unlimited &lt;- pmax( rexp(100, rate1), rexp(100, rate2))
RT.pp.super &lt;- pmax( rexp(100, 2*rate1), rexp(100, 2*rate2))
tvec &lt;- sort(unique(c(RT.pa, RT.ap, RT.pp.limited, RT.pp.unlimited, RT.pp.super)))

cap.limited &lt;- capacity.and(RT=list(RT.pp.limited, RT.pa, RT.ap))
print(cap.limited$Ctest)
cap.unlimited &lt;- capacity.and(RT=list(RT.pp.unlimited, RT.pa, RT.ap))
cap.super &lt;- capacity.and(RT=list(RT.pp.super, RT.pa, RT.ap))

matplot(tvec, cbind(cap.limited$Ct(tvec), cap.unlimited$Ct(tvec), cap.super$Ct(tvec)),
  type='l', lty=1, ylim=c(0,3), col=2:4, main="Example Capacity Functions", xlab="Time", 
  ylab="C(t)")
abline(1,0)
legend('topright', c("Limited", "Unlimited", "Super"), lty=1, col=2:4)

</code></pre>

<hr>
<h2 id='capacity.or'>
Capacity Coefficient for First-Terminating (OR) Processing
</h2><span id='topic+capacity.or'></span>

<h3>Description</h3>

<p>Calculates the Capacity Coefficient for First-Terminating (OR) Processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capacity.or(RT, CR=NULL, ratio=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capacity.or_+3A_rt">RT</code></td>
<td>
<p>A list of response time arrays.  The first array in the list is assumed to be the exhaustive condition.</p>
</td></tr>
<tr><td><code id="capacity.or_+3A_cr">CR</code></td>
<td>
<p>A list of correct/incorrect indicator arrays.  If NULL, assumes all are correct.</p>
</td></tr>
<tr><td><code id="capacity.or_+3A_ratio">ratio</code></td>
<td>
<p>Indicates whether to return the standard ratio capacity coefficient or, if FALSE, the difference form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The OR capacity coefficient compares performance on task to an unlimited-capacity, independent, parallel (UCIP) model using cumulative hazard functions.  Suppose <code class="reqn">H_i(t)</code> is the cumulative hazard function for response times when process <code class="reqn">i</code> is completed in isolation and <code class="reqn">H_i(t)</code> is the cumulative hazard function for response times when all processes occur together and a response is made as soon as any of the processes finish.  Then the OR capacity coefficient is given by, 
</p>
<p style="text-align: center;"><code class="reqn">C_{\rm OR}(t)=\frac{H_{\rm AND}(t)}{\sum_i H_i(t)}.</code>
</p>

<p>The denominator is the estimated cumulative hazard function for the UCIP model, based on the response times for each process in isolation and the numerator is the actual performance. 
</p>
<p><code class="reqn">C_{\rm OR}(t) &lt;1</code> implies worse performance than the UCIP model.  This indicates that either there are limited processing resources, there is inhibition among the subprocesses, or the items are not processed in parallel (e.g., the items may be processed serially).
</p>
<p><code class="reqn">C_{\rm OR}(t) &gt;1</code> implies better performance than the UCIP model.  This indicates that either there are more processing resources available per process when there are more processes, that there is facilitation among the subprocesses, or the items are not processed in parallel (e.g., the items may be processed coactively).
</p>
<p>The difference form of the capacity coefficient is given by,
</p>
<p style="text-align: center;"><code class="reqn">C_{\rm OR}(t)=H_{\rm OR}(t) - \sum_i H_i(t).</code>
</p>
<p>  Negative values indicate worse than UCIP performance and positive values indicate better than UCIP performance.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Ct</code></td>
<td>
<p>An object of class approxfun representing the OR capacity coefficient.</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>An object of class approxfun representing the variance of the estimated AND capacity coefficient.  Only returned if ratio=FALSE.</p>
</td></tr>
<tr><td><code>Ctest</code></td>
<td>
<p>A list with class &quot;htest&quot; that is returned from <code><a href="#topic+ucip.test">ucip.test</a></code> and contains the statistic and p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical Measures for Workload Capacity Analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>
<p>Houpt, J.W., Blaha, L.M., McIntire, J.P., Havig, P.R. and Townsend, J.T. (2013). Systems Factorial Technology with R. <em>Behavior Research Methods</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ucip.test">ucip.test</a></code>
<code><a href="#topic+capacityGroup">capacityGroup</a></code>
<code><a href="#topic+capacity.and">capacity.and</a></code>
<code><a href="#topic+estimateUCIPor">estimateUCIPor</a></code>
<code><a href="#topic+estimateNAH">estimateNAH</a></code>
<code><a href="stats.html#topic+approxfun">approxfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate1 &lt;- .35
rate2 &lt;- .3
RT.pa &lt;- rexp(100, rate1)
RT.ap &lt;- rexp(100, rate2)
RT.pp.limited &lt;- pmin( rexp(100, .5*rate1), rexp(100, .5*rate2))
RT.pp.unlimited &lt;- pmin( rexp(100, rate1), rexp(100, rate2))
RT.pp.super &lt;- pmin( rexp(100, 2*rate1), rexp(100, 2*rate2))
tvec &lt;- sort(unique(c(RT.pa, RT.ap, RT.pp.limited, RT.pp.unlimited, RT.pp.super)))

cap.limited &lt;- capacity.or(RT=list(RT.pp.limited, RT.pa, RT.ap))
print(cap.limited$Ctest)
cap.unlimited &lt;- capacity.or(RT=list(RT.pp.unlimited, RT.pa, RT.ap))
cap.super &lt;- capacity.or(list(RT=RT.pp.super, RT.pa, RT.ap))

matplot(tvec, cbind(cap.limited$Ct(tvec), cap.unlimited$Ct(tvec), cap.super$Ct(tvec)),
  type='l', lty=1, ylim=c(0,3), col=2:4, main="Example Capacity Functions", xlab="Time", 
  ylab="C(t)")
abline(1,0)
legend('topright', c("Limited", "Unlimited", "Super"), lty=1, col=2:4)
</code></pre>

<hr>
<h2 id='capacity.stst'>
Capacity Coefficient for Single-Target Self-Terminating (STST) Processing
</h2><span id='topic+capacity.stst'></span>

<h3>Description</h3>

<p>Calculates the Capacity Coefficient for Single-Target Self-Terminating (STST) Processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capacity.stst(RT, CR=NULL, ratio=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capacity.stst_+3A_rt">RT</code></td>
<td>
<p>A list of response time arrays.  The first array in the list is assumed to be the single-target among N distractors condition.</p>
</td></tr>
<tr><td><code id="capacity.stst_+3A_cr">CR</code></td>
<td>
<p>A list of correct/incorrect indicator arrays.  If NULL, assumes all are correct.</p>
</td></tr>
<tr><td><code id="capacity.stst_+3A_ratio">ratio</code></td>
<td>
<p>Indicates whether to return the standard ratio capacity coefficient or, if FALSE, the difference form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The STST capacity coefficient compares performance on task to an unlimited-capacity, independent, parallel (UCIP) model using cumulative reverse hazard functions.  Suppose <code class="reqn">K_{i,1}(t)</code> is the cumulative reverse hazard function for response times when single-target process <code class="reqn">i</code> is completed in isolation and <code class="reqn">K_{i,n}(t)</code> is the cumulative reverse hazard function for response times when the single-target <code class="reqn">i</code> is processed among <code class="reqn">n</code> other processes, all completed together.  Then the STST capacity coefficient is given by, 
</p>
<p style="text-align: center;"><code class="reqn">C_{\rm STST}(t)=\frac{K_{i,1}(t)}{K_{i,n}(t)}.</code>
</p>

<p>The numerator is the estimated cumulative reverse hazard function for the UCIP model, based on the response times for the <code class="reqn">i</code> process in isolation and the denominator is the actual performance on the <code class="reqn">i</code> process among <code class="reqn">n</code> distractors or other active channels. 
</p>
<p><code class="reqn">C_{\rm STST}(t) &lt;1</code> implies worse performance than the UCIP model.  This indicates that either there are limited processing resources, there is inhibition among the subprocesses, or the items are not processed in parallel (e.g., the items may be processed serially).
</p>
<p><code class="reqn">C_{\rm STST}(t) &gt;1</code> implies better performance than the UCIP model.  This indicates that either there are more processing resources available per process when there are more processes, that there is facilitation among the subprocesses, or the items are not processed in parallel (e.g., the items may be processed coactively).
</p>
<p>The difference form of the capacity coefficient (returned if ratio=FALSE) is given by,
</p>
<p style="text-align: center;"><code class="reqn">C_{\rm STST}(t)=K_{i,n}(t) - K_{i,1}(t).</code>
</p>
<p>  Negative values indicate worse than UCIP performance and positive values indicate better than UCIP performance.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Ct</code></td>
<td>
<p>An object of class approxfun representing the estimated STST capacity coefficient.</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>An object of class approxfun representing the variance of the estimated STST capacity coefficient.  Only returned if ratio=FALSE.</p>
</td></tr>
<tr><td><code>Ctest</code></td>
<td>
<p>A list with class &quot;htest&quot; that is returned from <code><a href="#topic+ucip.test">ucip.test</a></code> and contains the statistic and p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leslie Blaha &lt;leslie.blaha@us.af.mil&gt;
</p>
<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Blaha, L.M. &amp; Townsend, J.T. (under review). On the capacity of single-target self-terminating processes.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical measures for workload capacity analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>
<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Townsend, J.T. &amp; Wenger, M.J. (2004). A theory of interactive parallel processing: New capacity measures and predictions for a response time inequality series. <em>Psychological Review, 111</em>, 1003&ndash;1035.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ucip.test">ucip.test</a></code>
<code><a href="#topic+capacityGroup">capacityGroup</a></code>
<code><a href="#topic+capacity.or">capacity.or</a></code>
<code><a href="#topic+capacity.and">capacity.and</a></code>
<code><a href="#topic+estimateNAK">estimateNAK</a></code>
<code><a href="stats.html#topic+approxfun">approxfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate1 &lt;- .35
RT.pa &lt;- rexp(100, rate1)
RT.pp.limited &lt;- rexp(100, .5*rate1)
RT.pp.unlimited &lt;- rexp(100, rate1)
RT.pp.super &lt;- rexp(100, 2*rate1)
tvec &lt;- sort(unique(c(RT.pa, RT.pp.limited, RT.pp.unlimited, RT.pp.super)))

cap.limited &lt;- capacity.stst(RT=list(RT.pp.limited, RT.pa))
print(cap.limited$Ctest)
cap.unlimited &lt;- capacity.stst(RT=list(RT.pp.unlimited, RT.pa))
cap.super &lt;- capacity.stst(RT=list(RT.pp.super, RT.pa))

matplot(tvec, cbind(cap.limited$Ct(tvec), cap.unlimited$Ct(tvec), cap.super$Ct(tvec)),
  type='l', lty=1, ylim=c(0,5), col=2:4, main="Example Capacity Functions", xlab="Time", 
  ylab="C(t)")
abline(1,0)
legend('topright', c("Limited", "Unlimited", "Super"), lty=1, col=2:4, bty="n")

</code></pre>

<hr>
<h2 id='capacityGroup'>
Capacity Analysis
</h2><span id='topic+capacityGroup'></span>

<h3>Description</h3>

<p>Performs workload capacity analysis on each participant and each condition.  Plots each capacity coefficient individually and returns the results of the nonparametric null-hypothesis test for unlimited capacity independent parallel performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capacityGroup(inData, acc.cutoff=.9, ratio=TRUE, OR=NULL, 
  stopping.rule=c("OR", "AND", "STST"), plotCt=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capacityGroup_+3A_indata">inData</code></td>
<td>
<p>Data collected from a Double Factorial Paradigm experiment in standard form.</p>
</td></tr>
<tr><td><code id="capacityGroup_+3A_acc.cutoff">acc.cutoff</code></td>
<td>
<p>Minimum accuracy for each stimulus category used in calculating the capacity coefficient.</p>
</td></tr>
<tr><td><code id="capacityGroup_+3A_or">OR</code></td>
<td>
<p>Indicates whether to compare performance to an OR or AND processing baseline.  Provided for backwards compatibility for package version &lt; 2. </p>
</td></tr>
<tr><td><code id="capacityGroup_+3A_stopping.rule">stopping.rule</code></td>
<td>
<p>Indicates whether to use OR, AND or Single Target Self Terminating (STST) processing baseline to calculate individual capacity functions.</p>
</td></tr>
<tr><td><code id="capacityGroup_+3A_ratio">ratio</code></td>
<td>
<p>Indicates whether to return the standard ratio capacity coefficient or, if FALSE, the difference form.</p>
</td></tr>
<tr><td><code id="capacityGroup_+3A_plotct">plotCt</code></td>
<td>
<p>Indicates whether or not to generate plots of the capacity coefficients.</p>
</td></tr>
<tr><td><code id="capacityGroup_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the details of the capacity coefficients, see <code><a href="#topic+capacity.or">capacity.or</a></code>, <code><a href="#topic+capacity.and">capacity.and</a></code> and <code><a href="#topic+capacity.stst">capacity.stst</a></code>.  If accuracy in any of the stimulus categories used to calculate a capacity coefficient falls below the cutoff, NA is retuned for that value in both the statistic and the Ct matrix.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>overview</code></td>
<td>
<p>A data frame indicating whether the OR and AND capacity coefficients significantly above baseline (super), below baseline (limited) or neither (unlimited) both at the individual level and at the group level in each condition.  NA is returned for any participant that had performance below the accuracy cutoff in a condition.</p>
</td></tr>
<tr><td><code>Ct.fn</code></td>
<td>
<p>Matrix with each row giving the values of the of the estimated capacity coefficient for one participant in one condition for values of times.  The rows match the ordering of statistic.</p>
</td></tr>
<tr><td><code>Ct.var</code></td>
<td>
<p>Matrix with each row giving the values of the of the variance of the estimated capacity coefficient for one participant in one condition for values of times.  Only returned if ratio=FALSE.</p>
</td></tr>
<tr><td><code>capacity</code></td>
<td>
<p>A list with the returned values from the capacity function for each participant and each condition.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>Times at which the matrix capacity coefficients are calculated in Ct.fn matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Wenger, M.J. (2004). A theory of interactive parallel processing: New capacity measures and predictions for a response time inequality series. <em>Psychological Review, 111</em>, 1003&ndash;1035.
</p>
<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical Measures for Workload Capacity Analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>
<p>Houpt, J.W., Blaha, L.M., McIntire, J.P., Havig, P.R. and Townsend, J.T. (2013). Systems Factorial Technology with R. <em>Behavior Research Methods</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity.and">capacity.and</a></code>
<code><a href="#topic+capacity.or">capacity.or</a></code>
<code><a href="#topic+capacity.stst">capacity.stst</a></code>
<code><a href="#topic+ucip.test">ucip.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dots)
capacityGroup(subset(dots, Condition=="OR"), 
  stopping.rule="OR")
capacityGroup(subset(dots, Condition=="AND"), 
  stopping.rule="AND")

## End(Not run)
</code></pre>

<hr>
<h2 id='dots'>RT and and Accuracy from a Simple Detection Task</h2><span id='topic+dots'></span>

<h3>Description</h3>

<p>Data from a simple Double Factorial Paradigm task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dots)</code></pre>


<h3>Format</h3>

<p>A data frame with 57600 observations on the following 6 variables.
</p>

<dl>
<dt><code>Subject</code></dt><dd><p>A character vector indicating the participant ID.</p>
</dd>
<dt><code>Condition</code></dt><dd><p>A character vector indicating whether participants could respond as soon as they detected either dot (OR) or both dots (AND).</p>
</dd>
<dt><code>Correct</code></dt><dd><p>A logical vector indicating whether or not the participant responded correctly.</p>
</dd>
<dt><code>RT</code></dt><dd><p>A numeric vector indicating the response time on a given trial.</p>
</dd>
<dt><code>Channel1</code></dt><dd><p>A numeric vector indicating the stimulus level for the upper dot.  0:  Absent; 1:  Low contrast (slow); 2:  High contrast (fast).</p>
</dd>
<dt><code>Channel2</code></dt><dd><p>A numeric vector indicating the stimulus level for the lower dot.  0:  Absent; 1:  Low contrast (slow); 2:  High contrast (fast).</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data include response time and accuracy from nine participants that completed two versions of a Double Factorial Paradigm task.  Stimuli were either two dots, one above fixation and one below, a single dot above fixation, a single dot below fixation, or a blank screen.  Each dot could be presented either high or low contrast when present.  In the OR task, participants were instructed to  respond 'yes' whenever they saw either dot and 'no' otherwise.  In the AND task, participants were instructed to respond 'yes' only when both dots were present and 'no' otherwise.  See Eidels et al. (2012) or Houpt &amp; Townsend (2010) for a more thorough description of the task.
</p>


<h3>Source</h3>

<p>Eidels, A., Townsend, J. T., Hughes, H. C., &amp; Perry, L. A. (2012). Complementary relationship between response times, response accuracy, and task requirements in a parallel processing system. <em>Journal Cognitive Psychology</em>. Manuscript
(submitted for publication).
</p>


<h3>References</h3>

<p>Houpt, J.W. &amp; Townsend, J.T. (2010). The statistical properties of the survivor interaction contrast. <em>Journal of Mathematical Psychology, 54</em>, 446-453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dots)
summary(dots)
## Not run: 
sicGroup(dots)
capacityGroup(dots)

## End(Not run)
</code></pre>

<hr>
<h2 id='estimate.bounds'>
Bounds on Response Time Cumulative Distribution Functions for Parallel Processing Models
</h2><span id='topic+estimate.bounds'></span>

<h3>Description</h3>

<p>Calculates the bounds on the range of cumulative distribution functions for response time data for parallel processing models under specified stopping rules (OR, AND, or Single-Target Self-Terminating).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.bounds(RT, CR = NULL, stopping.rule = c("OR","AND","STST"), 
  assume.ID=FALSE, numchannels=NULL, unified.space=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.bounds_+3A_rt">RT</code></td>
<td>
<p>A list of numeric response time arrays for the individual processing channels</p>
</td></tr>
<tr><td><code id="estimate.bounds_+3A_cr">CR</code></td>
<td>
<p>A list of correct/incorrect indicator arrays.  If NULL, assumes all are correct.</p>
</td></tr>
<tr><td><code id="estimate.bounds_+3A_stopping.rule">stopping.rule</code></td>
<td>
<p>A character string specifying the stopping rule for the parallel processing model; must be one of &quot;OR&quot;, &quot;AND&quot;, &quot;STST&quot;. If NULL, then &quot;OR&quot; is the default model.</p>
</td></tr>
<tr><td><code id="estimate.bounds_+3A_assume.id">assume.ID</code></td>
<td>
<p>A logical indicating whether the individual channel distributions are assumed to be Identically Distributed (ID). If FALSE, non-ID distributions are estimated from the RT data. If TRUE, only the first array in RT is used, together with numchannels, to estimate the distributions.</p>
</td></tr>
<tr><td><code id="estimate.bounds_+3A_numchannels">numchannels</code></td>
<td>
<p>Number of channels in the parallel processing model when all channels are active. If NULL,number channels will be estimated equal to length of RT.</p>
</td></tr>
<tr><td><code id="estimate.bounds_+3A_unified.space">unified.space</code></td>
<td>
<p>A logical indicating whether the unified capacity space version of the bounds should be estimated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>estimate.bounds</em> function uses the response times from individual channels processing in isolation to estimae the response time distributions for an <code class="reqn">n</code>-channel parallel model. The input argument RT must be a list of numeric arrays, containing either one array for each of the <code class="reqn">n</code> channels to be estimated (so length(RT)=n), or it can have length(RT)=1 and the bounds can be found under an assumption that the <code class="reqn">n</code> channels are identically distributed to the data in RT. For this latter case, assume.ID=TRUE and numchannels=n (where <code class="reqn">n \ge 2</code>) must be specified.
</p>
<p>Standard unlimited capacity parallel processing models for <code class="reqn">n</code> simultaneously operating channels can produce a range of behavior, which is bounded by various functions derived from the probability distributions on each of the <code class="reqn">i</code>, for <code class="reqn">i=1,\ldots,n</code>, channels operating in isolation. These bounds depend on the stopping rule under which is the parallel model is assumed to be operating (OR, AND, or STST).
</p>
<p><em>stopping.rule=&quot;OR&quot;</em>
</p>
<p>Let <code class="reqn">F_{n}(t)=P[RT \le t]=P[min(T_{i}) \le t]</code> for <code class="reqn">i=1,...,n</code>, denote the cumulative distribution of response times under a minimum time (logical OR) stopping rule.
The general bounds for n-channel parallel processing under an OR stopping rule are:
</p>
<p style="text-align: center;"><code class="reqn">max_{i}F^{i}_{n-1}(t) \le F_{n}(t) \le min_{i,j}[F^{i}_{n-1}(t) + F^{j}_{n-1}(t) - F^{ij}_{n-2}(t)]</code>
</p>

<p>Under the assumption or conditions that the individual channels are identically distributed, this inequality chain simplifies to
</p>
<p style="text-align: center;"><code class="reqn">F_{n-1}(t) \le F_{n}(t) \le [2*F_{n-1}(t) - F_{n-2}(t)]</code>
</p>

<p>When the model under scrutiny has only <code class="reqn">n=2</code> channels, the inequality chain takes the form:
</p>
<p style="text-align: center;"><code class="reqn">F^{i}_{1}(t) \le F_{2}(t) \le [F^{i}_{1}(t) + F^{j}_{1}(t)]</code>
</p>

<p><em>stopping.rule=&quot;AND&quot;</em>
</p>
<p>Let <code class="reqn">G_{n}(t)=P[RT \le t]=P[max(T_i) \le t]</code>, for <code class="reqn">i=1,...,n</code>, denote the cumulative distribution of repsonse times under a maximum time (logical AND, ehxaustive) stopping rule.
The general bounds for n-channel parallel processing under an AND stopping rule are:
</p>
<p style="text-align: center;"><code class="reqn">max_{i,j}[G^{i}_{n-1}(t) + G^{j}_{n-1}(t) - G^{ij}_{n-2}(t)] \le G_{n}(t) \le min_{i}G^{i}_{n-1}(t)</code>
</p>

<p>Under the assumption or conditions that the individual channels are identically distributed, this inequality chain simplifies to
</p>
<p style="text-align: center;"><code class="reqn">[2*G_{n-1}(t) - G_{n-2}(t)] \le G_{n}(t) \le G_{n-1}(t)</code>
</p>

<p>When the model under scrutiny has only <code class="reqn">n=2</code> channels, the inequality chain takes the form:
</p>
<p style="text-align: center;"><code class="reqn">[G^{i}_{1}(t) + G^{j}_{1}(t) - 1] \le G_{2}(t) \le G^{i}_{1}(t)</code>
</p>

<p><em>stopping.rule=&quot;STST&quot;</em>
</p>
<p>Let <code class="reqn">F_{k}(t)=P[RT \le t]</code> denote the cumulative distribution of repsonse times under a single-target self-terminating (STST) stopping rule, where the target of interest is on processing channel <code class="reqn">k</code> among <code class="reqn">n</code> active channels.
The general bounds for n-channel parallel processing under an STST stopping rule are:
</p>
<p style="text-align: center;"><code class="reqn">\prod_{i=1}^{n} F_{1}(t) \le F_{k}(t) \le \sum_{i=1}^{n} F_{1}(t)</code>
</p>

<p>Under the assumption or conditions that the individual channels are identically distributed, this inequality chain simplifies to
</p>
<p style="text-align: center;"><code class="reqn">[F_{1}(t)]^{n} \le F_{k}(t) \le n*F_{1}(t)</code>
</p>

<p>When the model under scrutiny has only <code class="reqn">n=2</code> channels, the inequality chain takes the form:
</p>
<p style="text-align: center;"><code class="reqn">[F^{i}_{1}(t) * F^{j}_{1}(t)] \le F_{k}(t) \le [F^{i}_{1}(t) + F^{j}_{1}(t)]</code>
</p>

<p>Note that in this case, <code class="reqn">k=i</code> or <code class="reqn">k=j</code>, but this may not be specifiable <em>a priori</em> depending on experimental design.
</p>
<p>Across all stopping rule conditions, violation of the upper bound indicates performance that is faster than can be predicted by an unlimited capacity parallel model. This may arise from positive (facilitatory) crosstalk between parallel channels, super capacity parallel processing, or some form of co-active architecture in the measured human response time data.
</p>
<p>Violation of the lower bound indicates performance that is slower than predictd by an unlimited capacity parallel model. This may arise from negative (inhibitory) crosstalk between parallel channels, fixed capacity or limited capacity processing, or some form of serial architecture in the measured human response time data.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table>
<tr><td><code>Upper.Bound</code></td>
<td>
<p>An object of class &quot;approxfun&quot;&quot; representing the estimated upper bound on the cumulative distribution function for an unlimited capacity parallel model.</p>
</td></tr>
<tr><td><code>Lower.Bound</code></td>
<td>
<p>A object of class &quot;approxfun&quot; representing the estimated lower bound on the cumulative distribution function for an unlimited capacity parallel model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Leslie Blaha &lt;leslie.blaha@us.af.mil&gt;
</p>
<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Blaha, L.M. &amp; Townsend, J.T. (under review). On the capacity of single-target self-terminating processes.
</p>
<p>Colonius, H. &amp; Vorberg, D. (1994). Distribution inequalities for parallel models with unlimited capacity. <em>Journal of Mathematical Psychology, 38</em>, 35-58. 
</p>
<p>Grice, G.R., Canham, L., &amp; Gwynne, J.W. (1984). Absense of a redundant-signals effect in a raction time task with divided attention. <em>Perception &amp; Psychophysics, 36</em>, 565-570.
</p>
<p>Miller, J. (1982). Divided attention: Evidence for coactivation with redundant signals. <em>Cognitive Psychology, 14</em>, 247-279.
</p>
<p>Townsend, J.T. &amp; Eidels, A. (2011). Workload capacity spaces: a unified methodology for response time measures of efficiency as workload is varied. <em>Psychonomic Bulletin &amp; Review, 18</em>, 659-681.
</p>
<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Townsend, J.T. &amp; Wenger, M.J. (2004). A theory of interactive parallel processing: New capacity measures and predictions for a response time inequality series. <em>Psychological Review, 111</em>, 1003&ndash;1035.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ucip.test">ucip.test</a></code>
<code><a href="#topic+capacity.or">capacity.or</a></code>
<code><a href="#topic+capacity.and">capacity.and</a></code>
<code><a href="#topic+capacity.stst">capacity.stst</a></code>
<code><a href="stats.html#topic+approxfun">approxfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#randomly generated data
rate1 &lt;- .35
rate2 &lt;- .3
rate3 &lt;- .4
RT.paa &lt;- rexp(100, rate1)
RT.apa &lt;- rexp(100, rate2)
RT.aap &lt;- rexp(100, rate3)
RT.or &lt;- pmin(rexp(100, rate1), rexp(100, rate2), rexp(100, rate3))
RT.and &lt;- pmax(rexp(100, rate1), rexp(100, rate2), rexp(100, rate3))
tvec &lt;- sort(unique(c(RT.paa, RT.apa, RT.aap, RT.or, RT.and)))

or.bounds &lt;- estimate.bounds(RT=list(RT.paa, RT.apa, RT.aap), CR=NULL, assume.ID=FALSE, 
  unified.space=FALSE)
and.bounds &lt;- estimate.bounds(RT=list(RT.paa, RT.apa, RT.aap))

## Not run: 
#plot the or bounds together with a parallel OR model
matplot(tvec, 
  cbind(or.bounds$Upper.Bound(tvec), or.bounds$Lower.Bound(tvec), ecdf(RT.or)(tvec)),
  type='l', lty=1, ylim=c(0,1), col=2:4, main="Example OR Bounds", xlab="Time", 
  ylab="P(T&lt;t)")
abline(1,0)
legend('topright', c("Upper Bound", "Lower Bound", "Parallel OR Model"), 
  lty=1, col=2:4, bty="n")

#using the dots data set in sft package
data(dots)
attach(dots)
RT.A &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==2 &amp; Channel2==0, 'RT']
RT.B &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==0 &amp; Channel2==2, 'RT']
RT.AB &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==2 &amp; Channel2==2, 'RT']
tvec &lt;- sort(unique(c(RT.A, RT.B, RT.AB)))
Cor.A &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==2 &amp; Channel2==0, 'Correct']
Cor.B &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==0 &amp; Channel2==2, 'Correct']
Cor.AB &lt;- dots[Subject=='S1' &amp; Condition=='OR' &amp; Channel1==2 &amp; Channel2==2, 'Correct']
capacity &lt;- capacity.or(list(RT.AB,RT.A,RT.B), list(Cor.AB,Cor.A,Cor.B), ratio=TRUE)
bounds &lt;- estimate.bounds(list(RT.A,RT.B), list(Cor.A,Cor.B), unified.space=TRUE)

#plot unified capacity coefficient space
plot(tvec, capacity$Ct(tvec), type="l", lty=1, col="red", lwd=2)
lines(tvec, bounds$Upper.Bound(tvec), lty=2, col="blue", lwd=2)
lines(tvec, bounds$Lower.Bound(tvec), lty=4, col="blue", lwd=2)
abline(h=1, col="black", lty=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='estimateNAH'>Neslon-Aalen Estimator of the Cumulative Hazard Function</h2><span id='topic+estimateNAH'></span>

<h3>Description</h3>

<p>Computes the Nelson-Aalen estimator of a cumulative hazard function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateNAH(RT, CR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateNAH_+3A_rt">RT</code></td>
<td>
<p>A vector of times at which an event occurs (e.g., a vector of response times).</p>
</td></tr>
<tr><td><code id="estimateNAH_+3A_cr">CR</code></td>
<td>
<p>A vector of status indicators, 1=normal, 0=censored.  For response time data, this corresponds to 1=correct, 0=incorrect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Nelson-Aalen estimator of the cumulative hazard function is a step function with jumps at each event time.  The jump size is given by the number at risk up until immediately before the event.  If Y(t) is the number at risk immediately before t, then the N-A estimator is given by:
</p>
<p style="text-align: center;"><code class="reqn">H(t) = \sum_{s \in \{{\rm Event Times} &lt; t\}} \frac{1}{Y(s)}</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>H</code></td>
<td>
<p>A function of class &quot;stepfun&quot; that returns the Nelson-Aalen estimator of the cumulative hazard function.</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>A function of class &quot;stepfun&quot; that returns the estimated variance of the Nelson-Aalen estimator of the cumulative hazard function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Aalen, O. O., Borgan, O., &amp; Gjessing, H. K. (2008). <em>Survival and event history analysis: A process point of view</em>. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateNAK">estimateNAK</a></code>
<code><a href="stats.html#topic+stepfun">stepfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rexp(50, rate=.5)
censoring &lt;- runif(50) &lt; .90
H.NA &lt;- estimateNAH(x, censoring)

# Plot the estimated cumulative hazard function
plot(H.NA$H, 
  main="Cumulative Hazard Function\n X ~ Exp(.5)    n=50", 
  xlab="X", ylab="H(x)")

# Plot 95% Confidence intervals
times &lt;- seq(0,10, length.out=100)
lines(times, H.NA$H(times) + sqrt(H.NA$Var(times))*qnorm(1-.05/2), lty=2)
lines(times, H.NA$H(times) - sqrt(H.NA$Var(times))*qnorm(1-.05/2), lty=2)

# Plot the true cumulative hazard function
abline(0,.5, col='red')
</code></pre>

<hr>
<h2 id='estimateNAK'>Neslon-Aalen Estimator of the Reverse Cumulative Hazard Function</h2><span id='topic+estimateNAK'></span>

<h3>Description</h3>

<p>Computes the Nelson-Aalen estimator of a reverse cumulative hazard function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateNAK(RT, CR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateNAK_+3A_rt">RT</code></td>
<td>
<p>A vector of times at which an event occurs (e.g., a vector of response times).</p>
</td></tr>
<tr><td><code id="estimateNAK_+3A_cr">CR</code></td>
<td>
<p>A vector of status indicators, 1=normal, 0=censored.  For response time data, this corresponds to 1=correct, 0=incorrect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Nelson-Aalen estimator of the cumulative reverse hazard function is a step function with jumps at each event time.  The jump size is given by the number of events that have occurred up to and including the event.  If G(t) is the number events that have occurred up to and including t, then the N-A estimator of the cumulative reverse hazard function is given by:
</p>
<p style="text-align: center;"><code class="reqn">K(t) = -\sum_{s \in \{{\rm Event Times} &gt; t\}} \frac{1}{G(s)}</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>H</code></td>
<td>
<p>A function of class &quot;stepfun&quot; that returns the Nelson-Aalen estimator of the cumulative hazard function.</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>A function of class &quot;stepfun&quot; that returns estimated variance of the Nelson-Aalen estimator of the cumulative hazard function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Aalen, O. O., Borgan, O., &amp; Gjessing, H. K. (2008). <em>Survival and event history analysis: A process point of view</em>. New York: Springer.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical Measures for Workload Capacity Analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateNAH">estimateNAH</a></code>
<code><a href="stats.html#topic+stepfun">stepfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rexp(50, rate=.5)
censoring &lt;- runif(50) &lt; .90
K.NA &lt;- estimateNAK(x, censoring)

# Plot the estimated cumulative reverse hazard function
plot(K.NA$K, 
  main="Cumulative Reverse Hazard Function\n X ~ Exp(.5)    n=50", 
  xlab="X", ylab="K(x)")

# Plot 95% Confidence intervals
times &lt;- seq(0,10, length.out=100)
lines(times, K.NA$K(times) + sqrt(K.NA$Var(times))*qnorm(1-.05/2), lty=2)
lines(times, K.NA$K(times) - sqrt(K.NA$Var(times))*qnorm(1-.05/2), lty=2)

# Plot the true cumulative reverse hazard function
lines(times, log(pexp(times, .5)), col='red')
</code></pre>

<hr>
<h2 id='estimateUCIPand'>
UCIP Performance on AND Tasks
</h2><span id='topic+estimateUCIPand'></span>

<h3>Description</h3>

<p>Estimates the reverse cumulative hazard function of an unlimited capacity, independent, parallel process on an AND task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateUCIPand(RT, CR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateUCIPand_+3A_rt">RT</code></td>
<td>
<p>A list of arrays of response times.  Each list is used to estimate the response time distribution of a separate channel.</p>
</td></tr>
<tr><td><code id="estimateUCIPand_+3A_cr">CR</code></td>
<td>
<p>A list of arrays of correct (1) or incorrect (0) indicators corresponding to each element of the list RT.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function concerns the processing time of an unlimited capacity, independent, parallel (UCIP) system.  This means that the completion time for each processing channel does not vary based on the presence of other processes.  Thus, the performance on tasks with a single process can be used to estimate performance of the UCIP model with multiple processes occurring. 
</p>
<p>For example, in a two channel UCIP system the probability that both processes have finished (AND processing) is the product of the probabilities of that each channel has finished.  
</p>
<p style="text-align: center;"><code class="reqn">P(T_{ab} \le t) = P(T_a \le t)P(T_b \le t)</code>
</p>

<p>We are interested in the cumulative reverse hazard function, which is the natural log of the cumulative distribution function.  Because the log of a product is the sum of the logs, this gives us the following equality for the two channel AND process. 
</p>
<p style="text-align: center;"><code class="reqn">K_{ab}(t) = K_a(t) + K_b(t)</code>
</p>

<p>In general, the cumulative reverse hazard function of a UCIP AND process is estimated by the sum of the cumulative reverse hazard functions of each sub-process.
</p>
<p style="text-align: center;"><code class="reqn">K_{\rm UCIP}(t) = \sum_{i=1}^n K_i(t)</code>
</p>

<p>The cumulative reverse hazard functions of the sub-processes are estimated using the Nelson-Aalen estimator.  The Nelson-Aalen estimator is a Gaussian martingale, so the estimate of the UCIP performance is also a Gaussian martingale and the variance of the estimator can be estimated with the sum of variance estimates for each sub-process.
</p>


<h3>Value</h3>

<table>
<tr><td><code>K</code></td>
<td>
<p>A function of class &quot;stepfun&quot; that returns the Nelson-Aalen estimator of the cumulative reverse hazard function of a UCIP model on an exhaustive (AND) task.</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>A function of class &quot;stepfun&quot; that returns the estimated variance of the Nelson-Aalen estimator of the cumulative reverse hazard function of a UCIP model on an exhaustive (AND) task.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Wenger, M.J. (2004). A theory of interactive parallel processing: New capacity measures and predictions for a response time inequality series. <em>Psychological Review, 111</em>, 1003-1035.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical Measures for Workload Capacity Analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateNAK">estimateNAK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Channel completion times and accuracy
rt1 &lt;- rexp(100, rate=.5)
cr1 &lt;- runif(100) &lt; .90
rt2 &lt;- rexp(100, rate=.4)
cr2 &lt;- runif(100) &lt; .95
Kucip = estimateUCIPand(list(rt1, rt2), list(cr1, cr2))


# Plot the estimated UCIP cumulative reverse hazard function
plot(Kucip$K, do.p=FALSE, 
  main="Estimated UCIP Cumulative Reverse Hazard Function\n
    X~max(X1,X2)    X1~Exp(.5)    X2~Exp(.4)", 
  xlab="X", ylab="K_UCIP(x)")
# Plot 95% Confidence intervals
times &lt;- seq(0,10, length.out=100)
lines(times, Kucip$K(times) + sqrt(Kucip$Var(times))*qnorm(1-.05/2), lty=2)
lines(times, Kucip$K(times) - sqrt(Kucip$Var(times))*qnorm(1-.05/2), lty=2)
# Plot true UCIP cumulative reverse hazard function
lines(times[-1], log(pexp(times[-1], .5)) + log(pexp(times[-1], .4)), col='red')

</code></pre>

<hr>
<h2 id='estimateUCIPor'>
UCIP Performance on OR Tasks
</h2><span id='topic+estimateUCIPor'></span>

<h3>Description</h3>

<p>Estimates the cumulative hazard function of an unlimited capacity, independent, parallel process on an OR task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateUCIPor(RT, CR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateUCIPor_+3A_rt">RT</code></td>
<td>
<p>A list of arrays of response times.  Each list is used to estimate the response time distribution of a separate channel.</p>
</td></tr>
<tr><td><code id="estimateUCIPor_+3A_cr">CR</code></td>
<td>
<p>A list of arrays of correct (1) or incorrect (0) indicators corresponding to each element of the list RT.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function concerns the processing time of an unlimited capacity, independent, parallel (UCIP) system.  This means that the completion time for each processing channel does not vary based on the presence of other processes.  Thus, the performance on tasks with a single process can be used to estimate performance of the UCIP model with multiple processes occurring. 
</p>
<p>For example, in a two channel UCIP system the probability that no process has finished (OR processing) is the product of the probabilities of that each channel has not finished.  
</p>
<p style="text-align: center;"><code class="reqn">P(T_{ab} &gt; t) = P(T_a &gt; t)P(T_b &gt; t)</code>
</p>

<p>We are interested in the cumulative hazard function, which is the natural log of the suvivor function (which is one minus the cumulative distribution function).  Because the log of a product is the sum of the logs, this gives us the following equality for the two channel OR process.
</p>
<p style="text-align: center;"><code class="reqn">H_{ab}(t) = H_a(t) + H_b(t)</code>
</p>

<p>In general, the cumulative hazard function of a UCIP OR process is estimated by the sum of the cumulative hazard functions of each sub-process.
</p>
<p style="text-align: center;"><code class="reqn">H_{\rm UCIP}(t) = \sum_{i=1}^n H_i(t)</code>
</p>

<p>The cumulative hazard functions of the sub-processes are estimated using the Nelson-Aalen estimator.  The Nelson-Aalen estimator is a Gaussian martingale, so the estimate of the UCIP performance is also a Gaussian martingale and the variance of the estimator can be estimated with the sum of variance estimates for each sub-process.
</p>


<h3>Value</h3>

<table>
<tr><td><code>H</code></td>
<td>
<p>A function of class &quot;stepfun&quot; that returns the Nelson-Aalen estimator of the cumulative hazard function of a UCIP model on a first-terminating (OR) task.</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>A function of class &quot;stepfun&quot; that returns the estimated variance of the Nelson-Aalen estimator of the cumulative reverse hazard function of a UCIP model on a first-terminating (OR) task.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical Measures for Workload Capacity Analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateNAH">estimateNAH</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Channel completion times and accuracy
rt1 &lt;- rexp(100, rate=.5)
cr1 &lt;- runif(100) &lt; .90
rt2 &lt;- rexp(100, rate=.4)
cr2 &lt;- runif(100) &lt; .95
Hucip = estimateUCIPor(list(rt1, rt2), list(cr1, cr2))


# Plot the estimated UCIP cumulative hazard function
plot(Hucip$H, do.p=FALSE, 
  main="Estimated UCIP Cumulative Hazard Function\n
    X~min(X1,X2)    X1~Exp(.5)    X2~Exp(.4)", 
  xlab="X", ylab="H_UCIP(t)")
# Plot 95% Confidence intervals
times &lt;- seq(0,10, length.out=100)
lines(times, Hucip$H(times) + sqrt(Hucip$Var(times))*qnorm(1-.05/2), lty=2)
lines(times, Hucip$H(times) - sqrt(Hucip$Var(times))*qnorm(1-.05/2), lty=2)
#Plot true UCIP cumulative hazard function
abline(0,.9, col='red')
</code></pre>

<hr>
<h2 id='fPCAassessment'>Functional Principal Components Analysis for the Assessment Functions</h2><span id='topic+fPCAassessment'></span>

<h3>Description</h3>

<p>Calculates the principle functions and scores for the workload assessment measure of performance by each individual in each condition.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fPCAassessment(sftData, dimensions, stopping.rule=c("OR", "AND", "STST"), 
               correct=c(TRUE,FALSE), fast=c(TRUE,FALSE), detection=TRUE, 
               register=c("median","mean","none"), plotPCs=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fPCAassessment_+3A_sftdata">sftData</code></td>
<td>
<p>Data collected from a Double Factorial Paradigm experiment in standard form.</p>
</td></tr>
<tr><td><code id="fPCAassessment_+3A_dimensions">dimensions</code></td>
<td>
<p>The number of principal functions with which to represent the data.</p>
</td></tr>
<tr><td><code id="fPCAassessment_+3A_stopping.rule">stopping.rule</code></td>
<td>
<p>Indicates whether to use OR, AND or Single Target Self Terminating (STST) processing baseline to calculate individual assessment functions.</p>
</td></tr>
<tr><td><code id="fPCAassessment_+3A_correct">correct</code></td>
<td>
<p>Indicates whether to assess performance on correct trials.</p>
</td></tr>
<tr><td><code id="fPCAassessment_+3A_fast">fast</code></td>
<td>
<p>Indicates whether to use cumulative distribution functions or survivor functions to assess performance.</p>
</td></tr>
<tr><td><code id="fPCAassessment_+3A_detection">detection</code></td>
<td>
<p>Indicates whether to use a detection task baseline or a discrimination task baseline.</p>
</td></tr>
<tr><td><code id="fPCAassessment_+3A_register">register</code></td>
<td>
<p>Indicates value to use for registering the assessment data.</p>
</td></tr>
<tr><td><code id="fPCAassessment_+3A_plotpcs">plotPCs</code></td>
<td>
<p>Indicates whether or not to generate plots of the principal functions.</p>
</td></tr>
<tr><td><code id="fPCAassessment_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional principal components analysis (fPCA) is an extension of standard principal components analysis to infinite dimensional (function) spaces.  Just as in standard principal components analysis, fPCA is a method for finding a basis set of lower dimensionality than the original space to represent the data.  However, in place of basis vectors, fPCA has basis functions.  Each function in the original dataset can then be represented by a linear combination of those bases, so that given the bases, the each datum is represented by a vector of its coefficients (or scores) in that linear combination.  
</p>
<p>The assessment coefficient is a function across time, so the differences among assessment coefficients from different participants and/or conditions may be quite informative.  fPCA gives a well motivated method for representing those differences in a concise way.  The factor scores can be used to examine differences among assessment coefficients, accounting for variation across the entire function.
</p>
<p>This function implements the steps outlines in Burns, Houpt, Townsend and Endres (2013) applied to the assessment functions defined in Townsend and Altieri (2012) and Donkin, Little, and Houpt (2013).  First, the data are shifted by subtracting the median response time within each condition for each participant, but across both single target and multiple target trials, so that the assessment curves will be registered. Second, each assessment coefficient is calculated with the shifted response times.  Next, the mean assessment coefficient is subtracted from each assessment coefficient, then the representation of the resulting assessment coefficients are translated to a b-spline basis.  The fPCA procedure extracts the basis function from the bspline space that accounts for the largest variation across the assessment coefficients, then the next basis function which must be orthogonal to the first but explains the most amount of variation in the assessment coefficients given that constraint and so on until the indicated number of basis have been extracted.  Once the assessment functions are represented in the reduced space, a varimax rotation is applied.
</p>
<p>The assessment functions can be registered to the mean or median response time across all levels of workload but within each participant and condition, or the analyses can be performed without registration. 
</p>
<p>For details on fPCA for the assessment coefficient, see Burns, Houpt, Townsend and Endres (2013).  For details on fPCA in general using R, see Ramsay, Hooker and Graves (2009).
</p>


<h3>Value</h3>

<table>
<tr><td><code>Scores</code></td>
<td>
<p>Data frame containing the Loading values for each participant and condition.</p>
</td></tr>
<tr><td><code>MeanAT</code></td>
<td>
<p>Object of class approxfun representing the mean At function.</p>
</td></tr>
<tr><td><code>PF</code></td>
<td>
<p>List of objects of class approxfun representing the principal functions.</p>
</td></tr>
<tr><td><code>medianRT</code></td>
<td>
<p>Size of shift used to register each assessment curve (median RT).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Burns, D.M., Houpt, J.W., Townsend, J.T. &amp; Endres, M.J. (2013).  Functional principal components analysis of workload assessment functions.  <em>Behavior Research Methods</em>
</p>
<p>Donkin, C, Little, D.R. and Houpt (2013). Assessing the effects of caution on the capacity of information processing.  <em>Manuscript submitted for publication.</em>
</p>
<p>Ramsay, J., Hooker, J. &amp; Graves, S. (2009).  Functional Data Analysis with R and MATLAB.  New York, NY:  Springer.
</p>
<p>Townsend, J.T. and Altieri, N. (2012).  An accuracy-response time capacity assessment function that measures performance against standard parallel predictions. <em>Psychological Review, 3</em>, 500-516.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+assessment">assessment</a></code>
<code><a href="fda.html#topic+fda">fda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dots)
fPCAassessment(dots, dimensions=2, stopping.rule="OR", correct=TRUE, fast=FALSE, 
               detection=TRUE, plotPCs=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='fPCAcapacity'>Functional Principal Components Analysis for the Capacity Coefficient</h2><span id='topic+fPCAcapacity'></span>

<h3>Description</h3>

<p>Calculates the principle functions and scores for the workload capacity measure of performance by each individual in each condition.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fPCAcapacity(sftData, dimensions, acc.cutoff=.75, OR=NULL, 
  stopping.rule=c("OR","AND","STST"), ratio=TRUE, 
  register=c("median","mean","none"), plotPCs=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fPCAcapacity_+3A_sftdata">sftData</code></td>
<td>
<p>Data collected from a Double Factorial Paradigm experiment in standard form.</p>
</td></tr>
<tr><td><code id="fPCAcapacity_+3A_dimensions">dimensions</code></td>
<td>
<p>The number of principal functions with which to represent the data.</p>
</td></tr>
<tr><td><code id="fPCAcapacity_+3A_acc.cutoff">acc.cutoff</code></td>
<td>
<p>Minimum accuracy needed to be included in the analysis.</p>
</td></tr>
<tr><td><code id="fPCAcapacity_+3A_or">OR</code></td>
<td>
<p>Indicates whether to compare performance to an OR or AND processing baseline.  Provided for backwards compatibility for package version &lt; 2. </p>
</td></tr>
<tr><td><code id="fPCAcapacity_+3A_stopping.rule">stopping.rule</code></td>
<td>
<p>Indicates whether to use OR, AND or Single Target Self Terminating (STST) processing baseline to calculate individual capacity functions.</p>
</td></tr>
<tr><td><code id="fPCAcapacity_+3A_ratio">ratio</code></td>
<td>
<p>Whether to use ratio Ct or difference Ct.</p>
</td></tr>
<tr><td><code id="fPCAcapacity_+3A_register">register</code></td>
<td>
<p>Indicates value to use for registering the capacity data.</p>
</td></tr>
<tr><td><code id="fPCAcapacity_+3A_plotpcs">plotPCs</code></td>
<td>
<p>Indicates whether or not to generate plots of the principal functions.</p>
</td></tr>
<tr><td><code id="fPCAcapacity_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to plot function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional principal components analysis (fPCA) is an extension of standard principal components analysis to infinite dimensional (function) spaces.  Just as in standard principal components analysis, fPCA is a method for finding a basis set of lower dimensionality than the original space to represent the data.  However, in place of basis vectors, fPCA has basis functions.  Each function in the original dataset can then be represented by a linear combination of those bases, so that given the bases, the each datum is represented by a vector of its coefficients (or scores) in that linear combination.  
</p>
<p>The capacity coefficient is a function across time, so the differences among capacity coefficients from different participants and/or conditions may be quite informative.  fPCA gives a well motivated method for representing those differences in a concise way.  The factor scores can be used to examine differences among capacity coefficients, accounting for variation across the entire function.
</p>
<p>This function implements the steps outlines in Burns, Houpt, Townsend and Endres (2013).  First, the data are shifted by subtracting the median response time within each condition for each participant, but across both single target and multiple target trials, so that the capacity curves will be registered. Second, each capacity coefficient is calculated with the shifted response times.  Next, the mean capacity coefficient is subtracted from each capacity coefficient, then the representation of the resulting capacity coefficients are translated to a b-spline basis.  The fPCA proceedure extracts the basis function from the bspline space that accounts for the largest variation across the capacity coefficients, then the next basis function which must be orthogonal to the first but explains the most amount of variation in the capacity coefficients given that constraint and so on until the indicated number of basis have been extracted.  Once the capacity functions are represented in the reduced space, a varimax rotation is applied.
</p>
<p>The capacity functions can be registered to the mean or median response time across all levels of workload but within each participant and condition, or the analyses can be performed without registration. 
</p>
<p>For details on fPCA for the capacity coefficient, see Burns, Houpt, Townsend and Endres (2013).  For details on fPCA in general using R, see Ramsay, Hooker and Graves (2009).
</p>


<h3>Value</h3>

<table>
<tr><td><code>Scores</code></td>
<td>
<p>Data frame containing the Loading values for each participant and condition.</p>
</td></tr>
<tr><td><code>MeanCT</code></td>
<td>
<p>Object of class approxfun representing the mean Ct function.</p>
</td></tr>
<tr><td><code>PF</code></td>
<td>
<p>List of objects of class approxfun representing the principal functions.</p>
</td></tr>
<tr><td><code>medianRT</code></td>
<td>
<p>Size of shift used to register each capacity curve (median RT).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
Devin Burns &lt;devburns@indiana.edu&gt;
</p>


<h3>References</h3>

<p>Burns, D.M., Houpt, J.W., Townsend, J.T. &amp; Endres, M.J. (2013).  Functional principal components analysis of workload capacity functions.  <em>Behavior Research Methods</em>
</p>
<p>Ramsay, J., Hooker, J. &amp; Graves, S. (2009).  Functional Data Analysis with R and MATLAB.  New York, NY:  Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity.and">capacity.and</a></code>
<code><a href="#topic+capacity.or">capacity.or</a></code>
<code><a href="fda.html#topic+fda">fda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dots)
fPCAcapacity(dots, dimensions=2,stopping.rule="OR", 
  plotPCs=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='mic.test'>
Test of the Mean Interaction Contrast
</h2><span id='topic+mic.test'></span>

<h3>Description</h3>

<p>Performs either an Adjusted Rank Transform or ANOVA test for an interaction at the mean level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mic.test(HH, HL, LH, LL, method=c("art", "anova"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mic.test_+3A_hh">HH</code></td>
<td>
<p>Response times from the High&ndash;High condition.</p>
</td></tr>
<tr><td><code id="mic.test_+3A_hl">HL</code></td>
<td>
<p>Response times from the High&ndash;Low condition.</p>
</td></tr>
<tr><td><code id="mic.test_+3A_lh">LH</code></td>
<td>
<p>Response times from the Low&ndash;High condition.</p>
</td></tr>
<tr><td><code id="mic.test_+3A_ll">LL</code></td>
<td>
<p>Response times from the Low&ndash;Low condition.</p>
</td></tr>
<tr><td><code id="mic.test_+3A_method">method</code></td>
<td>
<p>If &quot;art&quot;, use the adjusted rank transform test.  If &quot;anova&quot; use ANOVA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean interaction contrast (MIC) indicates the architecture of a process.  Serial processes result in MIC equal to zero.  Parallel-OR and Coactive process have a positive MIC.  Parallel-AND process have a negative MIC.  A test for a significant MIC can be done with a nonparametric adjusted rank transform test (described below) or an ANOVA.
</p>
<p>The Adjusted Rank Transform is a nonparametric test for an interaction between two discrete variables.  The test is carried out by first subtracting the mean effect of the salience level on each channel.  Suppose, 
<code class="reqn">m_{H,\cdot} =</code> E[RT; Level of Channel 1 is Fast],
<code class="reqn">m_{L,\cdot} =</code> E[RT; Level of Channel 1 is Slow],
<code class="reqn">m_{\cdot, H} =</code> E[RT; Level of Channel 2 is Fast],
<code class="reqn">m_{\cdot, L} =</code> E[RT; Level of Channel 2 is Slow].
Then for each response time from the fast&ndash;fast condition, <code class="reqn">m_{H, \cdot}</code> and <code class="reqn">m_{\cdot,H}</code> are subtracted.  Likewise, for each of the other conditions, the appropriate <code class="reqn">m</code> is subtracted.  Next, each mean subtracted response time is replaced with its rank across all conditions (e.g., the fastest time of all conditions would be replaced with a 1).  In this implementation, tied response times are assigned using the average rank.  Finally, a standard ANOVA on the ranks is done on the ranks and the <code class="reqn">p</code>-value of that test is returned.  This test was recommended by Sawilowsky (1990) based on a survey of a number of nonparametric tests for interactions.  He credits Reinach (1965) for first developing the test.
</p>


<h3>Value</h3>

<p>A list of class &quot;htest&quot; containing:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>The value of the MIC.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>The <code class="reqn">p</code>-value of the ART or ANOVA test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A description of the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating that the Houpt-Townsend statistic was used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A string indicating which data were used for which input.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Reinach, S.G. (1965).  A nonparametric analysis for a multiway classification with one element per cell.  <em>South African Journal of Agricultural Science, 8</em>, 941&ndash;960.
</p>
<p>Sawilowsky, S.S. (1990).  Nonparametric tests of interaction in experimental design.  <em>Review of Educational Research, 60</em>, 91&ndash;126.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2010). The statistical properties of the survivor interaction contrast. <em>Journal of Mathematical Psychology, 54</em>, 446-453.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T1.h &lt;- rweibull(300, shape=2 , scale=400 )
T1.l &lt;- rweibull(300, shape=2 , scale=800 )
T2.h &lt;- rweibull(300, shape=2 , scale=400 )
T2.l &lt;- rweibull(300, shape=2 , scale=800 )

Serial.hh &lt;- T1.h + T2.h
Serial.hl &lt;- T1.h + T2.l
Serial.lh &lt;- T1.l + T2.h
Serial.ll &lt;- T1.l + T2.l
mic.test(HH=Serial.hh, HL=Serial.hl, LH=Serial.lh, LL=Serial.ll)

Parallel.hh &lt;- pmax(T1.h, T2.h)
Parallel.hl &lt;- pmax(T1.h, T2.l)
Parallel.lh &lt;- pmax(T1.l, T2.h)
Parallel.ll &lt;- pmax(T1.l, T2.l)
mic.test(HH=Parallel.hh, HL=Parallel.hl, LH=Parallel.lh, LL=Parallel.ll, method="art")

</code></pre>

<hr>
<h2 id='sic'>
Calculate the Survivor Interaction Contrast
</h2><span id='topic+sic'></span>

<h3>Description</h3>

<p>Function to calculate survivor interaction contrast and associated measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sic(HH, HL, LH, LL, domtest="ks", sictest="ks", mictest=c("art", "anova"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sic_+3A_hh">HH</code></td>
<td>
<p>Response times from the High&ndash;High condition.</p>
</td></tr>
<tr><td><code id="sic_+3A_hl">HL</code></td>
<td>
<p>Response times from the High&ndash;Low condition.</p>
</td></tr>
<tr><td><code id="sic_+3A_lh">LH</code></td>
<td>
<p>Response times from the Low&ndash;High condition.</p>
</td></tr>
<tr><td><code id="sic_+3A_ll">LL</code></td>
<td>
<p>Response times from the Low&ndash;Low condition.</p>
</td></tr>
<tr><td><code id="sic_+3A_sictest">sictest</code></td>
<td>
<p>Which type of hypothesis test to use for SIC form.</p>
</td></tr>
<tr><td><code id="sic_+3A_domtest">domtest</code></td>
<td>
<p>Which type of hypothesis test to use for testing stochastic dominance relations, either as series of KS tests (&quot;ks&quot;) or the dominance test based on Dirichlet process priors (&quot;dp&quot;). DP not yet implemented.</p>
</td></tr>
<tr><td><code id="sic_+3A_mictest">mictest</code></td>
<td>
<p>Which type of hypothesis test to use for the MIC, either adjusted rank transform or ANOVA. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>SIC(t) = (S_LL - S_LH) - (S_HL - S_HH)
</p>
<p>This function calculates the Survivor Interaction Contrast (SIC; Townsend &amp; Nozawa, 1995).  The SIC indicates the architecture and stopping-rule of the underlying information processing system.  An entirely positive SIC indicates parallel first-terminating processing.  An entirely negative SIC indicates parallel exhaustive processing.  An SIC that is always zero indicates serial first-terminating processing.  An SIC that is first positive then negative indicates either serial exhaustive or coactive processing.  To distinguish between these two possibilities, an additional test of the mean interaction contrast (MIC) is used; coactive processing leads to a positive MIC while serial processing leads to an MIC of zero.
</p>
<p>For the SIC function to distinguish among the processing types, the salience manipulation on each channel must selectively influence its respective channel (although see Eidels, Houpt, Altieri, Pei &amp; Townsend, 2010 for SIC prediction from interactive parallel models).  Although the selective influence assumption cannot be directly tested, one implication is that the distribution the HH response times stochastically dominates the HL and LH distributions which each in turn stochastically dominate the LL response time distribution.  This implication is automatically tested in this function.  The KS dominance test uses eight two-sample Kolmogorov-Smirnov tests:  HH &lt; HL, HH &lt; LH, HL &lt; LL, LH &lt; LL should be significant while HH &gt; HL, HH &gt; LH, HL &gt; LL, LH &gt; LL should not.  The DP uses four tests to determine which relation has the highest Bayes factor assuming a Dirichlet process prior for each of (HH, HL), (HH, LH), (HL, LL) and (LH, LL).  See Heathcote, Brown, Wagenmakers &amp; Eidels, 2010, for more details.
</p>
<p>This function also performs a statistical analysis to determine whether the positive and negative parts of the SIC are significantly different from zero. Currently the only statistical test is based on the generalization of the two-sample Kolmogorov-Smirnov test described in Houpt &amp; Townsend, 2010.  This test performs two separate null-hypothesis tests:  One test for whether the largest positive value of the SIC is significantly different from zero and one test for whether the largest negative value is significantly different from zero.
</p>


<h3>Value</h3>

<table>
<tr><td><code>SIC</code></td>
<td>
<p>An object of class stepfun representing the SIC.</p>
</td></tr>
<tr><td><code>Dominance</code></td>
<td>
<p>A data frame with the first column indicating which ordering was tested, the second column indicating the test statistic and the third indicating the <code class="reqn">p</code>-value for that value of the statistic.</p>
</td></tr>
<tr><td><code>Dvals</code></td>
<td>
<p>A Matrix containing the values of the test statistic and the associated <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>MIC</code></td>
<td>
<p>Results of an adjusted rank transform test of the mean interaction contrast.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>The scaling factor used for the KS test of the SIC form.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2010). The statistical properties of the survivor interaction contrast. <em>Journal of Mathematical Psychology, 54</em>, 446-453.
</p>
<p>Houpt, J.W., Blaha, L.M., McIntire, J.P., Havig, P.R. and Townsend, J.T. (2013). Systems Factorial Technology with R. <em>Behavior Research Methods</em>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stepfun">stepfun</a></code>
<code><a href="#topic+sicGroup">sicGroup</a></code>
<code><a href="#topic+mic.test">mic.test</a></code>
<code><a href="#topic+sic.test">sic.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T1.h &lt;- rexp(50, .2)
T1.l &lt;- rexp(50, .1)
T2.h &lt;- rexp(50, .21)
T2.l &lt;- rexp(50, .11)

SerialAND.hh &lt;- T1.h + T2.h
SerialAND.hl &lt;- T1.h + T2.l
SerialAND.lh &lt;- T1.l + T2.h
SerialAND.ll &lt;- T1.l + T2.l
SerialAND.sic &lt;- sic(HH=SerialAND.hh, HL=SerialAND.hl, LH=SerialAND.lh, 
  LL=SerialAND.ll)
print(SerialAND.sic$Dvals)
plot(SerialAND.sic$SIC, do.p=FALSE, ylim=c(-1,1))

p1 &lt;- runif(200) &lt; .3
SerialOR.hh &lt;- p1[1:50]    * T1.h + (1-p1[1:50]   )*T2.h
SerialOR.hl &lt;- p1[51:100]  * T1.h + (1-p1[51:100] )*T2.l
SerialOR.lh &lt;- p1[101:150] * T1.l + (1-p1[101:150])*T2.h
SerialOR.ll &lt;- p1[151:200] * T1.l + (1-p1[151:200])*T2.l
SerialOR.sic &lt;- sic(HH=SerialOR.hh, HL=SerialOR.hl, LH=SerialOR.lh, LL=SerialOR.ll)
print(SerialOR.sic$Dvals)
plot(SerialOR.sic$SIC, do.p=FALSE, ylim=c(-1,1))

ParallelAND.hh &lt;- pmax(T1.h, T2.h)
ParallelAND.hl &lt;- pmax(T1.h, T2.l)
ParallelAND.lh &lt;- pmax(T1.l, T2.h)
ParallelAND.ll &lt;- pmax(T1.l, T2.l)
ParallelAND.sic &lt;- sic(HH=ParallelAND.hh, HL=ParallelAND.hl, LH=ParallelAND.lh, 
  LL=ParallelAND.ll)
print(ParallelAND.sic$Dvals)
plot(ParallelAND.sic$SIC, do.p=FALSE, ylim=c(-1,1))

ParallelOR.hh &lt;- pmin(T1.h, T2.h)
ParallelOR.hl &lt;- pmin(T1.h, T2.l)
ParallelOR.lh &lt;- pmin(T1.l, T2.h)
ParallelOR.ll &lt;- pmin(T1.l, T2.l)
ParallelOR.sic &lt;- sic(HH=ParallelOR.hh, HL=ParallelOR.hl, LH=ParallelOR.lh, 
  LL=ParallelOR.ll)
print(ParallelOR.sic$Dvals)
plot(ParallelOR.sic$SIC, do.p=FALSE, ylim=c(-1,1))
</code></pre>

<hr>
<h2 id='sic.test'>
Statistical test of the SIC.
</h2><span id='topic+sic.test'></span>

<h3>Description</h3>

<p>Function to test for statistical significance of the positive and negative parts of a SIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sic.test(HH, HL, LH, LL, method="ks")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sic.test_+3A_hh">HH</code></td>
<td>
<p>Response times from the High&ndash;High condition.</p>
</td></tr>
<tr><td><code id="sic.test_+3A_hl">HL</code></td>
<td>
<p>Response times from the High&ndash;Low condition.</p>
</td></tr>
<tr><td><code id="sic.test_+3A_lh">LH</code></td>
<td>
<p>Response times from the Low&ndash;High condition.</p>
</td></tr>
<tr><td><code id="sic.test_+3A_ll">LL</code></td>
<td>
<p>Response times from the Low&ndash;Low condition.</p>
</td></tr>
<tr><td><code id="sic.test_+3A_method">method</code></td>
<td>
<p>Which type of hypothesis test to use for SIC form.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SIC(t) = (S_LL - S_LH) - (S_HL - S_HH)
</p>
<p>This function performs a statistical analysis to determine whether the positive and negative parts of the SIC are significantly different from zero. Currently the only statistical test is based on the generalization of the two-sample Kolmogorov-Smirnov test described in Houpt &amp; Townsend, 2010.  This test performs two separate null-hypothesis tests:  One test for whether the largest positive value of the SIC is significantly different from zero and one test for whether the largest negative value is significantly different from zero.
</p>


<h3>Value</h3>

<table>
<tr><td><code>positive</code></td>
<td>
<p>A list of class &quot;htest&quot; containing the statistic and <code class="reqn">p</code>-value along with descriptions of the alternative hypothesis, method and data names for the test of a significant positive portion of the SIC.</p>
</td></tr>
<tr><td><code>negative</code></td>
<td>
<p>A list of class &quot;htest&quot; containing the statistic and <code class="reqn">p</code>-value along with descriptions of the alternative hypothesis, method and data names for the test of a significant negative portion of the SIC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2010). The statistical properties of the survivor interaction contrast. <em>Journal of Mathematical Psychology, 54</em>, 446-453.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stepfun">stepfun</a></code>
<code><a href="#topic+sicGroup">sicGroup</a></code>
<code><a href="#topic+sic">sic</a></code>
<code><a href="#topic+mic.test">mic.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T1.h &lt;- rexp(50, .2)
T1.l &lt;- rexp(50, .1)
T2.h &lt;- rexp(50, .21)
T2.l &lt;- rexp(50, .11)

SerialAND.hh &lt;- T1.h + T2.h
SerialAND.hl &lt;- T1.h + T2.l
SerialAND.lh &lt;- T1.l + T2.h
SerialAND.ll &lt;- T1.l + T2.l
sic.test(HH=SerialAND.hh, HL=SerialAND.hl, LH=SerialAND.lh, LL=SerialAND.ll)

p1 &lt;- runif(200) &lt; .3
SerialOR.hh &lt;- p1[1:50]    * T1.h + (1-p1[1:50]   )*T2.h
SerialOR.hl &lt;- p1[51:100]  * T1.h + (1-p1[51:100] )*T2.l
SerialOR.lh &lt;- p1[101:150] * T1.l + (1-p1[101:150])*T2.h
SerialOR.ll &lt;- p1[151:200] * T1.l + (1-p1[151:200])*T2.l
sic.test(HH=SerialOR.hh, HL=SerialOR.hl, LH=SerialOR.lh, LL=SerialOR.ll)

ParallelAND.hh &lt;- pmax(T1.h, T2.h)
ParallelAND.hl &lt;- pmax(T1.h, T2.l)
ParallelAND.lh &lt;- pmax(T1.l, T2.h)
ParallelAND.ll &lt;- pmax(T1.l, T2.l)
sic.test(HH=ParallelAND.hh, HL=ParallelAND.hl, LH=ParallelAND.lh, LL=ParallelAND.ll)

ParallelOR.hh &lt;- pmin(T1.h, T2.h)
ParallelOR.hl &lt;- pmin(T1.h, T2.l)
ParallelOR.lh &lt;- pmin(T1.l, T2.h)
ParallelOR.ll &lt;- pmin(T1.l, T2.l)
sic.test(HH=ParallelOR.hh, HL=ParallelOR.hl, LH=ParallelOR.lh, LL=ParallelOR.ll)
</code></pre>

<hr>
<h2 id='sicGroup'>
SIC Analysis for a Group
</h2><span id='topic+sicGroup'></span>

<h3>Description</h3>

<p>Calculates the SIC for each individual in each condition of a DFP experiment.  The function will plot each individuals SIC and return the results of the test for stochastic dominance and the statistical test of SIC form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sicGroup(inData, sictest="ks", mictest=c("art", "anova"), domtest="ks", 
         alpha.sic=.05, plotSIC=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sicGroup_+3A_indata">inData</code></td>
<td>
<p>Data collected from a Double Factorial Paradigm experiment in standard form.</p>
</td></tr>
<tr><td><code id="sicGroup_+3A_sictest">sictest</code></td>
<td>
<p>Which type of hypothesis test to use for SIC form. &quot;ks&quot; is the only test currently implemented.</p>
</td></tr>
<tr><td><code id="sicGroup_+3A_mictest">mictest</code></td>
<td>
<p>Which type of hypothesis test to use for the MIC. The adjusted rank transform (art) and analysis of variance (anova) are the only tests currently implemented.</p>
</td></tr>
<tr><td><code id="sicGroup_+3A_domtest">domtest</code></td>
<td>
<p>Which type of hypothesis test to use for testing stochastic dominance relations, either as series of KS tests (&quot;ks&quot;) or the dominance test based on Dirichlet process priors (&quot;dp&quot;).  DP not yet implemented.</p>
</td></tr>
<tr><td><code id="sicGroup_+3A_alpha.sic">alpha.sic</code></td>
<td>
<p>Alpha level for determining a difference from zero used by the SIC overview.</p>
</td></tr>
<tr><td><code id="sicGroup_+3A_plotsic">plotSIC</code></td>
<td>
<p>Indicates whether or not to generate plots of the survivor interaction contrasts.</p>
</td></tr>
<tr><td><code id="sicGroup_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to plot function.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>See the help page for the <code><a href="#topic+sic">sic</a></code> function for details of the survivor interaction contrast.
</p>


<h3>Value</h3>

<table>
<tr><td><code>overview</code></td>
<td>
<p>Data frame summarizing the test outcomes for each participant and condition.</p>
</td></tr>
<tr><td><code>Subject</code></td>
<td>
<p>The participant identifier from inData.</p>
</td></tr>
<tr><td><code>Condition</code></td>
<td>
<p>The condition identifier from inData.</p>
</td></tr>
<tr><td><code>Selective.Influence</code></td>
<td>
<p>The results of the survivor function dominance test for selective influence.  Pass indicates HH &lt; HL, LH and LL &gt; LH, HL, but not HL, LH &lt; HH and not LH, HL &gt; LL,  where A &lt; B indicates that A is significantly faster than B at the level of the distribution.  Ambiguous means neither HL, LH &lt; HH, nor LH, HL &gt; LL, but at least one of HH &lt; HL, LH or LL &gt;HL, LH did not hold.  Fail means that at least one of HL, LH &lt; HH or HL, LH &gt; LL.</p>
</td></tr>
<tr><td><code>Positive.SIC</code></td>
<td>
<p>Indicates whehter the SIC is significantly positive at any time.</p>
</td></tr>
<tr><td><code>Negative.SIC</code></td>
<td>
<p>Indicates whehter the SIC is significantly negative at any time.</p>
</td></tr>
<tr><td><code>MIC</code></td>
<td>
<p>Indicates whether or not the MIC is significantly non-zero.</p>
</td></tr>
<tr><td><code>Model</code></td>
<td>
<p>Indicates which model would predict the pattern of data, assuming selective influence.</p>
</td></tr>
<tr><td><code>SICfn</code></td>
<td>
<p>Matrix with each row giving the values of the of the estimated SIC for one participant in one condition for values of times.  The rows match the ordering of statistic.</p>
</td></tr>
<tr><td><code>sic</code></td>
<td>
<p>List with each element giving the result applying sic() to an individual in a condition.  sic has the same ordering as overview.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>Times at which the SICs in SICfn are calculated.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2010). The statistical properties of the survivor interaction contrast. <em>Journal of Mathematical Psychology, 54</em>, 446-453.
</p>
<p>Heathcote, A., Brown, S.D., Wagenmakers, E-J. &amp; Eidels, A. (2010) Distribution-free tests of stochastic dominance for small samples. <em>Journal of Mathematical Psychology, 54</em>, 454-463. 
</p>
<p>Houpt, J.W., Blaha, L.M., McIntire, J.P., Havig, P.R. and Townsend, J.T. (2013). Systems Factorial Technology with R. <em>Behavior Research Methods</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sic">sic</a></code>
<code><a href="#topic+capacityGroup">capacityGroup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(dots)
sicGroup(dots)

## End(Not run)
</code></pre>

<hr>
<h2 id='siDominance'>
Dominance Test for Selective Influence
</h2><span id='topic+siDominance'></span>

<h3>Description</h3>

<p>Function to test for the survivor function ordering predicted by the selective influence of the salience manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siDominance(HH, HL, LH, LL, method="ks")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siDominance_+3A_hh">HH</code></td>
<td>
<p>Response times from the High&ndash;High condition.</p>
</td></tr>
<tr><td><code id="siDominance_+3A_hl">HL</code></td>
<td>
<p>Response times from the High&ndash;Low condition.</p>
</td></tr>
<tr><td><code id="siDominance_+3A_lh">LH</code></td>
<td>
<p>Response times from the Low&ndash;High condition.</p>
</td></tr>
<tr><td><code id="siDominance_+3A_ll">LL</code></td>
<td>
<p>Response times from the Low&ndash;Low condition.</p>
</td></tr>
<tr><td><code id="siDominance_+3A_method">method</code></td>
<td>
<p>Which type of hypothesis test to use for testing stochastic dominance relations, either as series of KS tests (&quot;ks&quot;) or the dominance test based on Dirichlet process priors (&quot;dp&quot;). DP not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an SIC function to distinguish among the processing types, the salience manipulation on each channel must selectively influence its respective channel (although see Eidels, Houpt, Altieri, Pei &amp; Townsend, 2010 for SIC prediction from interactive parallel models).  Although the selective influence assumption cannot be directly tested, one implication is that the distribution the HH response times stochastically dominates the HL and LH distributions which each in turn stochastically dominate the LL response time distribution.  This implication is automatically tested in this function.  The KS dominance test uses eight two-sample Kolmogorov-Smirnov tests:  HH &lt; HL, HH &lt; LH, HL &lt; LL, LH &lt; LL should be significant while HH &gt; HL, HH &gt; LH, HL &gt; LL, LH &gt; LL should not.  The DP uses four tests to determine which relation has the highest Bayes factor assuming a Dirichlet process prior for each of (HH, HL), (HH, LH), (HL, LL) and (LH, LL).  See Heathcote, Brown, Wagenmakers &amp; Eidels, 2010, for more details.
</p>


<h3>Value</h3>

<p>A data frame with the first column indicating which ordering was tested, the second column indicating the test statistic and the third indicating the p-value for that value of the statistic.
</p>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Townsend, J.T. &amp; Nozawa, G. (1995). Spatio-temporal properties of elementary perception: An investigation of parallel, serial and coactive theories. <em>Journal of Mathematical Psychology, 39</em>, 321-360.
</p>
<p>Houpt, J.W. &amp; Townsend, J.T. (2010). The statistical properties of the survivor interaction contrast. <em>Journal of Mathematical Psychology, 54</em>, 446-453.
</p>
<p>Dzhafarov, E.N., Schweickert, R., &amp; Sung, K. (2004). Mental architectures with selectively influenced but stochastically interdependent components. <em>Journal of Mathematical Psychology</em>, 48, 51-64.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ks.test">ks.test</a></code>
<code><a href="#topic+sic">sic</a></code>
<code><a href="#topic+sicGroup">sicGroup</a></code>
<code><a href="#topic+mic.test">mic.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>T1.h &lt;- rexp(50, .2)
T1.l &lt;- rexp(50, .1)
T2.h &lt;- rexp(50, .21)
T2.l &lt;- rexp(50, .11)

HH &lt;- T1.h + T2.h
HL &lt;- T1.h + T2.l
LH &lt;- T1.l + T2.h
LL &lt;- T1.l + T2.l
siDominance(HH, HL, LH, LL)
</code></pre>

<hr>
<h2 id='ucip.test'>
A Statistical Test for Super or Limited Capacity
</h2><span id='topic+ucip.test'></span>

<h3>Description</h3>

<p>A nonparametric test for capacity values significantly different than those predicted by the estimated unlimited capacity, independent parallel model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ucip.test(RT, CR=NULL, OR=NULL, stopping.rule=c("OR","AND","STST"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ucip.test_+3A_rt">RT</code></td>
<td>
<p>A list of response time arrays.  The first array in the list is assumed to be the exhaustive condition.</p>
</td></tr>
<tr><td><code id="ucip.test_+3A_cr">CR</code></td>
<td>
<p>A list of correct/incorrect indicator arrays.  If NULL, assumes all are correct.</p>
</td></tr>
<tr><td><code id="ucip.test_+3A_or">OR</code></td>
<td>
<p>Indicates whether to compare performance to an OR or AND processing baseline.  Provided for backwards compatibility for package version &lt; 2. </p>
</td></tr>
<tr><td><code id="ucip.test_+3A_stopping.rule">stopping.rule</code></td>
<td>
<p>Indicates whether to compare performance to an OR, AND or Single Target Self Terminating (STST) processing baseline.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is based on the Nelson-Aalen formulation of the log-rank test.  The function takes a weighted difference between estimated unlimited capacity, independent parallel performance, based on a participants single source response times, and the participants true performance when all sources are present.
</p>


<h3>Value</h3>

<p>A list of class &quot;htest&quot; containing:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>Z-score of a null-hypothesis test for UCIP performance.</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>p-value of a two-tailed null-hypothesis test for UCIP performance.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>A description of the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>A string indicating whether the ART or ANOVA was used.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>A string indicating which data were used for which input.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joe Houpt &lt;joseph.houpt@wright.edu&gt;
</p>


<h3>References</h3>

<p>Houpt, J.W. &amp; Townsend, J.T. (2012). Statistical Measures for Workload Capacity Analysis.  <em>Journal of Mathematical Psychology, 56</em>, 341-355.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capacity.or">capacity.or</a></code>
<code><a href="#topic+capacity.and">capacity.and</a></code>
<code><a href="#topic+estimateUCIPor">estimateUCIPor</a></code>
<code><a href="#topic+estimateUCIPand">estimateUCIPand</a></code>
<code><a href="#topic+estimateNAH">estimateNAH</a></code>
<code><a href="#topic+estimateNAK">estimateNAK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rate1 &lt;- .35
rate2 &lt;- .3
RT.pa &lt;- rexp(100, rate1)
RT.ap &lt;- rexp(100, rate2)

CR.pa &lt;- runif(100) &lt; .98
CR.ap &lt;- runif(100) &lt; .98
CR.pp &lt;- runif(100) &lt; .96
CRlist &lt;- list(CR.pp, CR.pa, CR.ap)

#  OR Processing
RT.pp.limited &lt;- pmin( rexp(100, .5*rate1), rexp(100, .5*rate2))
RT.pp.unlimited &lt;- pmin( rexp(100, rate1), rexp(100, rate2))
RT.pp.super &lt;- pmin( rexp(100, 2*rate1), rexp(100, 2*rate2))
z.limited   &lt;- ucip.test(RT=list(RT.pp.limited, RT.pa, RT.ap), CR=CRlist, stopping.rule="OR")
z.unlimited &lt;- ucip.test(RT=list(RT.pp.unlimited, RT.pa, RT.ap), CR=CRlist, stopping.rule="OR")
z.super     &lt;- ucip.test(RT=list(RT.pp.super, RT.pa, RT.ap), CR=CRlist, stopping.rule="OR")

#  AND Processing
RT.pp.limited &lt;- pmax( rexp(100, .5*rate1), rexp(100, .5*rate2))
RT.pp.unlimited &lt;- pmax( rexp(100, rate1), rexp(100, rate2))
RT.pp.super &lt;- pmax( rexp(100, 2*rate1), rexp(100, 2*rate2))
z.limited   &lt;- ucip.test(RT=list(RT.pp.limited, RT.pa, RT.ap), CR=CRlist, stopping.rule="AND")
z.unlimited &lt;- ucip.test(RT=list(RT.pp.unlimited, RT.pa, RT.ap), CR=CRlist, stopping.rule="AND")
z.super     &lt;- ucip.test(RT=list(RT.pp.super, RT.pa, RT.ap), CR=CRlist, stopping.rule="AND")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
