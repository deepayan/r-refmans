<!DOCTYPE html><html><head><title>Help for package dwp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dwp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.ddArray'><p>Subset a Set of Fitted Dispersion Models (<code>ddArray</code>)</p></a></li>
<li><a href='#[.ddSim'><p>Subset Simulated Dispersion Parameters while Preserving Attributes</p></a></li>
<li><a href='#Acins'><p>Calculate Area of Intersection inside Circle and Square with Common Center</p></a></li>
<li><a href='#addCarcass'><p>Add Carcasses to a Site Layout</p></a></li>
<li><a href='#aic'><p>Calculate Akaike Information Criterion (AICc) for Distance Distributions</p></a></li>
<li><a href='#alt_names'><p>Names of the Named Distributions</p></a></li>
<li><a href='#carcass_polygon'><p>Example Carcass Distances to Accompany the Polygon Layout Data Set</p></a></li>
<li><a href='#carcass_simple'><p>Carcass Data to Accompany the Simple Geometry Data Format</p></a></li>
<li><a href='#carcass_simple0'><p>Full, Simulated carcass_simple Data Set (Including Locations and Missed Carcasses)</p></a></li>
<li><a href='#cof_name'><p>Names of the GLM Coefficients for Each Distribution</p></a></li>
<li><a href='#cof2parms'><p>Convert GLM Coefficients into Named Distribution Parameters</p></a></li>
<li><a href='#cofOK'><p>Check Whether GLM Coefficients Give Proper Distribution</p></a></li>
<li><a href='#constraints'><p>Constraints on GLM Coefficients for Extensibility to a Distribution</p></a></li>
<li><a href='#constraints_par'><p>Constraints on Parameters to Assure Extensibility</p></a></li>
<li><a href='#dd2ddSim'><p>Extract Parameters from a Distance Model (<code>dd</code>) and Format as <code>ddSim</code> Object</p></a></li>
<li><a href='#ddCI'><p>Calculate CI for CDF, PDF, or quantile</p></a></li>
<li><a href='#ddd'><p>Calculate Probability Functions for Distance Distributions</p></a></li>
<li><a href='#ddFit'><p>Fit Distance Distribution Model(s)</p></a></li>
<li><a href='#ddPrint'><p>Print S3 Objects in <code>dwp</code> Package</p></a></li>
<li><a href='#ddSim'><p>Simulation of Dispersion Parameters</p></a></li>
<li><a href='#degOrder'><p>An Ordering of the Models by Degree of the Polynomial</p></a></li>
<li><a href='#distr_names'><p>Full List of Names of Distributions</p></a></li>
<li><a href='#Distributions'><p>Probability Distributions for Carcasses Versus Distance from Turbine</p></a></li>
<li><a href='#dwp'><p>Density-Weighted Proportion</p></a></li>
<li><a href='#estdwp'><p>Estimate DWP</p></a></li>
<li><a href='#estpsi'><p>Estimate Probability Carcass lands in Searched Area</p></a></li>
<li><a href='#exclude'><p>Remove Particular Names from a Longer List</p></a></li>
<li><a href='#exportGenEst'><p>Export Estimated Density-Weighted Proportion to File in Proper GenEst Format</p></a></li>
<li><a href='#fmmax'><p>Find suitable mmax for clipping improper priors for M</p></a></li>
<li><a href='#formatGenEst'><p>Format DWP Estimate for Use in GenEst</p></a></li>
<li><a href='#getncarc'><p>Simple Function to Extract Carcass Counts</p></a></li>
<li><a href='#incGamma'><p>Incomplete Gamma Function</p></a></li>
<li><a href='#initLayout'><p>Create a Data Structure or Map for the Site Layout</p></a></li>
<li><a href='#layout_eagle'><p>Example Bare Vector Format for Eagle Data</p></a></li>
<li><a href='#layout_polygon'><p>Example Polygon Data for Site Layout</p></a></li>
<li><a href='#layout_simple'><p>Example Simple Geometry Data Format for Site Layout</p></a></li>
<li><a href='#layout_xy'><p>Example Data for Site Layout on an (x, y) Grid</p></a></li>
<li><a href='#mod_all'><p>Names of All the Available Models</p></a></li>
<li><a href='#mod_color'><p>Vector of Colors Used in Graphs of Fitted Models</p></a></li>
<li><a href='#mod_lty'><p>Vector of Line Types Used in Graphs of Fitted Models</p></a></li>
<li><a href='#mod_offset'><p>Vector of GLM Offsets for Available Models</p></a></li>
<li><a href='#mod_standard'><p>Vector of Names of Standard Models</p></a></li>
<li><a href='#mod_xy'><p>Vector of Names of Models Available for Grid Layout</p></a></li>
<li><a href='#modelFilter'><p>Run Models through a Sieve to Filter out Dubious Fits</p></a></li>
<li><a href='#mpp2ddSim'><p>Convert Distribution Name + Parameters to <code>ddSim</code> Object</p></a></li>
<li><a href='#MpriorOK'><p>Check validity of format of custom prior for M</p></a></li>
<li><a href='#natural'><p>Vector of Names of Models with Natural Offset</p></a></li>
<li><a href='#off'><p>Utility Function for Constructing Offsets for GLMs</p></a></li>
<li><a href='#par_default'><p>Default Graphics Parameters</p></a></li>
<li><a href='#parm_name'><p>List of Names of the Distribution Parameters Associated with Respective Models</p></a></li>
<li><a href='#parOK'><p>Check Parameter Value Validity the Distribution</p></a></li>
<li><a href='#Plot'><p>Plot dd and ddArray Objects</p></a></li>
<li><a href='#postM'><p>Calculate posterior distribution of M and extract statistics (M* and CI)</p></a></li>
<li><a href='#prepmod'><p>Internal Utility Function to Parse and Format Model for Calculating Psihat</p></a></li>
<li><a href='#prepRing'><p>Format a Search Layout into Rings for Analysis</p></a></li>
<li><a href='#psi_extend'><p>Simple Extension of a <code>dd</code> Model beyond the Search Radius</p></a></li>
<li><a href='#readCarcass'><p>Import Carcass Observations Locations from Shape Files</p></a></li>
<li><a href='#rmat'><p>Simple Utility Function Used in Optimizing the GLM</p></a></li>
<li><a href='#sieve_default'><p>Test Criteria for Model Selection</p></a></li>
<li><a href='#sieve_win'><p>Test Criteria for Model Selection within Search Area</p></a></li>
<li><a href='#stats'><p>Display a Tables of Summary Statistics for Distance Distributions</p></a></li>
<li><a href='#subset.shapeCarcass'><p>Subset Data from an Imported and Formatted Shape File</p></a></li>
<li><a href='#xyr'><p>Locations of All Carcasses in Grid Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Density-Weighted Proportion</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit a Poisson regression to carcass distance data and integrate over the searched area at a wind farm to estimate the fraction of carcasses falling in the searched area and format the output for use as the dwp parameter in the 'GenEst' or 'eoa' package for estimating bird and bat mortality, following Dalthorp, et al. (2022) &lt;<a href="https://arxiv.org/abs/2201.10064">arXiv:2201.10064</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, expint, GenEst, gtools, invgamma, magrittr, MASS,
matrixStats, methods, mvtnorm, numDeriv, plotrix, pracma, sf,
statmod, VGAM</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-30 19:36:40 UTC; ddalt</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Dalthorp [aut, cre],
  Manuela Huso [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Dalthorp &lt;ddalthorp@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-01 07:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.ddArray'>Subset a Set of Fitted Dispersion Models (<code>ddArray</code>)</h2><span id='topic++5B.ddArray'></span>

<h3>Description</h3>

<p>Subset a Set of Fitted Dispersion Models (<code>ddArray</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddArray'
x[distr]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.ddArray_+3A_x">x</code></td>
<td>
<p>object to subset</p>
</td></tr>
<tr><td><code id="+2B5B.ddArray_+3A_distr">distr</code></td>
<td>
<p>vector of names or integer indices of distributions to extract 
from fitted models</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subset the ddArray object as if it were a simple vector
</p>


<h3>Value</h3>

<p>list of selected models with crucial statistics
</p>

<hr>
<h2 id='+5B.ddSim'>Subset Simulated Dispersion Parameters while Preserving Attributes</h2><span id='topic++5B.ddSim'></span>

<h3>Description</h3>

<p>Subset Simulated Dispersion Parameters while Preserving Attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddSim'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.ddSim_+3A_x">x</code></td>
<td>
<p>object to subset</p>
</td></tr>
<tr><td><code id="+2B5B.ddSim_+3A_i">i</code>, <code id="+2B5B.ddSim_+3A_j">j</code></td>
<td>
<p>row and column indices to subset</p>
</td></tr>
<tr><td><code id="+2B5B.ddSim_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subset the ddSim object as if it were a simple matrix or array
</p>


<h3>Value</h3>

<p>array with simulated beta parameters from the glm model, their
conversion to distribution parameters. NOTE: subsetting to a column or a row
returns a matrix rather than a vector. This simplifies the coding and makes
it easier to maintain integrity of data structures, but behavior differs from
what is done when subsetting standard R matrices and arrays to a single column
or row. Also unlike with standard R arrays and matrices, the class structure
and attributes are preserved upon subsetting.
</p>

<hr>
<h2 id='Acins'>Calculate Area of Intersection inside Circle and Square with Common Center</h2><span id='topic+Acins'></span>

<h3>Description</h3>

<p>Calculate Area of Intersection inside Circle and Square with Common Center
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Acins(r, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Acins_+3A_r">r</code></td>
<td>
<p>radius of the circle (vector or scalar)</p>
</td></tr>
<tr><td><code id="Acins_+3A_s">s</code></td>
<td>
<p>half-width of the square (scalar)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of intersections of interiors of circles with squaure
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # calculate area in annulus intersecting square
s &lt;- 10 # radius or half-width of square
r &lt;- c(11, 12) # inner and outer radii of circle
diff(Acins(r, s)) # intersection of square and annulus
# figure to illustrate the calculated area:
theta &lt;- seq(0, 2 * pi, length = 1500)
plot(0, xlim = max(r) * c(-1, 1), ylim = max(r) * c(-1, 1),
  xlab = "x", ylab = "y", asp = 1, bty = "n", type = "n")
xi &lt;- r[1] * cos(theta)
yi &lt;- r[1] * sin(theta)
xo &lt;- r[2] * cos(theta)
yo &lt;- r[2] * sin(theta)
i1 &lt;- which(abs(xi) &lt;= s &amp; abs(yi) &lt;= s)
i2 &lt;- which(abs(xo) &lt;= s &amp; abs(yo) &lt;= s)
i2 &lt;- sort(i2, decreasing = TRUE)
xi &lt;- xi[i1]
yi &lt;- yi[i1]
xo &lt;- xo[i2]
yo &lt;- yo[i2]
polygon(col = 8, border = NA,
  x = c(xi[xi &gt;= 0 &amp; yi &gt;= 0], xo[xo &gt;= 0 &amp; yo &gt;= 0]), 
  y = c(yi[xi &gt;= 0 &amp; yi &gt;= 0], yo[xo &gt;= 0 &amp; yo &gt;= 0]))
polygon(col = 8, border = NA, 
  x = c(xi[xi &lt;= 0 &amp; yi &gt;= 0], xo[xo &lt;= 0 &amp; yo &gt;= 0]), 
  y = c(yi[xi &lt;= 0 &amp; yi &gt;= 0], yo[xo &lt;= 0 &amp; yo &gt;= 0]))
polygon(col = 8, border = NA,
  x = c(xi[xi &lt;= 0 &amp; yi &lt;= 0], xo[xo &lt;= 0 &amp; yo &lt;= 0]), 
 y = c(yi[xi &lt;= 0 &amp; yi &lt;= 0], yo[xo &lt;= 0 &amp; yo &lt;= 0]))
polygon(col = 8, border = NA,
 x = c(xi[xi &gt;= 0 &amp; yi &lt;= 0], xo[xo &gt;= 0 &amp; yo &lt;= 0]), 
 y = c(yi[xi &gt;= 0 &amp; yi &lt;= 0], yo[xo &gt;= 0 &amp; yo &lt;= 0]))
lines(r[1] * cos(theta), r[1]* sin(theta))
lines(r[2]* cos(theta), r[2] * sin(theta))
rect(-s, -s, s, s)
 # calculate areas in series of 1 m annuli extending to corner of square
 s &lt;- 10.5 # radius of square (center to side)
 diff(Acins(r = 0:ceiling(sqrt(2) * s), s))
</code></pre>

<hr>
<h2 id='addCarcass'>Add Carcasses to a Site Layout</h2><span id='topic+addCarcass'></span><span id='topic+addCarcass.shapeCarcass'></span><span id='topic+addCarcass.data.frame'></span>

<h3>Description</h3>

<p>After the site layout is analyzed and structured by rings for analysis,
carcass data may still need to be added to the site data. <code>addCarcass</code>
grabs carcass location data from a shape file or data frame and formats it
into ring data, with carcass tallies in every 1m ring from the turbine to
the maximum search distance away from any turbine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCarcass(x, ...)

## S3 method for class 'shapeCarcass'
addCarcass(
  x,
  data_ring,
  plotLayout = NULL,
  ncarcReset = TRUE,
  ccCol = NULL,
  ...
)

## S3 method for class 'data.frame'
addCarcass(
  x,
  data_ring,
  ccCol = NULL,
  ncarcReset = TRUE,
  unitCol = "turbine",
  rCol = "r",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCarcass_+3A_x">x</code></td>
<td>
<p>carcass data to insert into <code>data_ring</code></p>
</td></tr>
<tr><td><code id="addCarcass_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="addCarcass_+3A_data_ring">data_ring</code></td>
<td>
<p>ring data for receiving carcass data from <code>x</code></p>
</td></tr>
<tr><td><code id="addCarcass_+3A_plotlayout">plotLayout</code></td>
<td>
<p>(optional) <code>shapeLayout</code> object to facilitate proper
insertion of carcass data into ring structure.</p>
</td></tr>
<tr><td><code id="addCarcass_+3A_ncarcreset">ncarcReset</code></td>
<td>
<p>boolean to direct the function to set the carcass counts
in all the rings to 0 before adding the new carcasses (default) or to add the
new carcasses to the old totals (<code>ncarcReset = FALSE</code>).</p>
</td></tr>
<tr><td><code id="addCarcass_+3A_cccol">ccCol</code></td>
<td>
<p>name of carcass class column (optional). Typically, the &quot;carcass 
class&quot; would be for carcass characteristics that would be expected to affect
distances that carcasses would fall from the turbine. For example, distances 
would not be expected to be the same for large and small carcasses, and bats
may have significantly different distance distributions than small birds. The ccCol
could also be used for subsetting by any covariate that would be expected 
to interact with carcass distance distributions, like season (if winds vary 
by season) or turbine type (if the site has a diverse mix of turbines of 
different sizes or types). Additionally, ccCol can be used to subset the data by area 
(for example, NW, NE, SW, SE; or hilltop, river bank) or any other discrete 
covariate that the user may be interested in.</p>
</td></tr>
<tr><td><code id="addCarcass_+3A_unitcol">unitCol</code></td>
<td>
<p>name of unit column</p>
</td></tr>
<tr><td><code id="addCarcass_+3A_rcol">rCol</code></td>
<td>
<p>name of column with carcass distances</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rings</code> with a tally of the number of
of carcasses discovered in each concentric 1m ring from the turbine to the 
most distant point searched.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(layout_simple)
 data(carcass_simple)
 sitedata &lt;- initLayout(layout_simple)
 ringdata &lt;- prepRing(sitedata)
 ringsWithCarcasses &lt;- addCarcass(carcass_simple, data_ring = ringdata)
</code></pre>

<hr>
<h2 id='aic'>Calculate Akaike Information Criterion (AICc) for Distance Distributions</h2><span id='topic+aic'></span><span id='topic+aic.ddArray'></span><span id='topic+aic.ddArraycc'></span><span id='topic+aic.dd'></span>

<h3>Description</h3>

<p>functions for calculating AICc for carcass dispersion
models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic(x, ...)

## S3 method for class 'ddArray'
aic(x, extent = "full", ...)

## S3 method for class 'ddArraycc'
aic(x, extent = "full", ...)

## S3 method for class 'dd'
aic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic_+3A_x">x</code></td>
<td>
<p>list of models (<code><a href="#topic+ddFit">ddArray</a></code>) or single model 
(<code><a href="#topic+ddFit">dd</a></code>) to calculate AICs for</p>
</td></tr>
<tr><td><code id="aic_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="aic_+3A_extent">extent</code></td>
<td>
<p>Include only the extensible models (<code>extent = "full"</code>) or
all models (<code>extent = "win"</code>), whether or not they can be extended 
beyond the search radius.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with AICc and deltaAICc for all models in <code>x</code>
</p>

<hr>
<h2 id='alt_names'>Names of the Named Distributions</h2><span id='topic+alt_names'></span>

<h3>Description</h3>

<p>Names of the Named Distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alt_names
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 10.
</p>

<hr>
<h2 id='carcass_polygon'>Example Carcass Distances to Accompany the Polygon Layout Data Set</h2><span id='topic+carcass_polygon'></span>

<h3>Description</h3>

<p>Example Carcass Distances to Accompany the Polygon Layout Data Set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carcass_polygon
</code></pre>


<h3>Format</h3>

<p>A data frame illustrating an import format for carcass distances.
There are columns with turbine IDs (<code>turbine</code>) and carcass distances
from turbine (<code>r</code>). Distances (<code>r</code>) are in meters from the nearest
turbine. The data set is used in the &quot;polygon&quot; example in the User Guide.
</p>

<hr>
<h2 id='carcass_simple'>Carcass Data to Accompany the Simple Geometry Data Format</h2><span id='topic+carcass_simple'></span>

<h3>Description</h3>

<p>Carcass Data to Accompany the Simple Geometry Data Format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carcass_simple
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 55 rows and 2 columns.
</p>

<hr>
<h2 id='carcass_simple0'>Full, Simulated carcass_simple Data Set (Including Locations and Missed Carcasses)</h2><span id='topic+carcass_simple0'></span>

<h3>Description</h3>

<p>Full, Simulated carcass_simple Data Set (Including Locations and Missed Carcasses)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carcass_simple0
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 100 rows and 6 columns.
</p>

<hr>
<h2 id='cof_name'>Names of the GLM Coefficients for Each Distribution</h2><span id='topic+cof_name'></span>

<h3>Description</h3>

<p>Names of the GLM Coefficients for Each Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cof_name
</code></pre>


<h3>Format</h3>

<p>A list with the names of the coefficients (vector of character strings)
as they appear in the <code>$coefficients</code> value returned from <code>glm</code> for
each model.
</p>

<hr>
<h2 id='cof2parms'>Convert GLM Coefficients into Named Distribution Parameters</h2><span id='topic+cof2parms'></span><span id='topic+cof2parms.matrix'></span><span id='topic+cof2parms.numeric'></span><span id='topic+cof2parms.dd'></span><span id='topic+parms2cof.matrix'></span>

<h3>Description</h3>

<p>Convert GLM Coefficients into Named Distribution Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cof2parms(x, ...)

## S3 method for class 'matrix'
cof2parms(x, distr, ...)

## S3 method for class 'numeric'
cof2parms(x, distr, ...)

## S3 method for class 'dd'
cof2parms(x, ...)

## S3 method for class 'matrix'
parms2cof(x, distr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cof2parms_+3A_x">x</code></td>
<td>
<p>object (vector or matrix of parameters, dd, or glm)
with named glm parameters (<code>"r"</code>, <code>"I(r^2)"</code>, <code>"I(r^3)"</code>, 
<code>"log(r)"</code>, or <code>"I(1/r)"</code>). NOTE: This function has minimal 
error-checking.</p>
</td></tr>
<tr><td><code id="cof2parms_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="cof2parms_+3A_distr">distr</code></td>
<td>
<p>name of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of parameters
</p>

<hr>
<h2 id='cofOK'>Check Whether GLM Coefficients Give Proper Distribution</h2><span id='topic+cofOK'></span><span id='topic+cofOK0'></span><span id='topic+cofOKInf'></span>

<h3>Description</h3>

<p>In order for a fitted GLM to convert to a proper distance distribution, its
integral from 0 to Inf must be finite. As a rule, when the leading coefficient 
is positive, the integral diverges as the upper bound of integration approaches
infinity, and <code>cofOK</code> would return <code>FALSE</code>. Likewise, in some cases,
the GLM coefficients yield an integral that diverges as the lower bound 
approaches 0, in which case <code>cofOK</code> returns <code>FALSE</code> as well. 
<code>cofOK0</code> and <code>cofOKInf</code> check the left and right tails of the 
candidate distribution, repectively, for convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cofOK(cof, distr)

cofOK0(cof, distr)

cofOKInf(cof, distr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cofOK_+3A_cof">cof</code></td>
<td>
<p>vector or matrix of named glm parameters (with <code>"r"</code> as the
distance variable)</p>
</td></tr>
<tr><td><code id="cofOK_+3A_distr">distr</code></td>
<td>
<p>name of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean vector (or scalar)
</p>

<hr>
<h2 id='constraints'>Constraints on GLM Coefficients for Extensibility to a Distribution</h2><span id='topic+constraints'></span>

<h3>Description</h3>

<p>Constraints on GLM Coefficients for Extensibility to a Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints
</code></pre>


<h3>Format</h3>

<p>A list of matrices giving the upper and lower bounds that each
model's coefficients must meet for the model to be extensible to a
distribution. The <code>parscale</code> column may be used in <code>optim</code> for
fitting a truncated weighted likelihood model.
</p>

<hr>
<h2 id='constraints_par'>Constraints on Parameters to Assure Extensibility</h2><span id='topic+constraints_par'></span>

<h3>Description</h3>

<p>Constraints on Parameters to Assure Extensibility
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints_par
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 17.
</p>

<hr>
<h2 id='dd2ddSim'>Extract Parameters from a Distance Model (<code>dd</code>) and Format as <code>ddSim</code> Object</h2><span id='topic+dd2ddSim'></span>

<h3>Description</h3>

<p>This is a utility function called internally by <code>dwp</code> functions
to extract parameters from a fitted <code><a href="#topic+ddFit">dd</a></code> model and 
formats them for analysis and calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dd2ddSim(dd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dd2ddSim_+3A_dd">dd</code></td>
<td>
<p><code>dd</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ddSim</code> object with 1 row
</p>

<hr>
<h2 id='ddCI'>Calculate CI for CDF, PDF, or quantile</h2><span id='topic+ddCI'></span>

<h3>Description</h3>

<p>Calculate a confidence interval for the CDF, PDF, or quantile of a carcass
distance distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddCI(
  mod,
  x,
  type = "CDF",
  CL = 0.9,
  nsim = 1000,
  extent = "full",
  zrad = 200,
  na.tol = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddCI_+3A_mod">mod</code></td>
<td>
<p>a <code><a href="#topic+ddFit">dd</a></code> object</p>
</td></tr>
<tr><td><code id="ddCI_+3A_x">x</code></td>
<td>
<p>distance from turbine (scalar or vector) or probability (for quantile)</p>
</td></tr>
<tr><td><code id="ddCI_+3A_type">type</code></td>
<td>
<p><code>"CDF"</code>, <code>"PDF"</code>, or <code>"quantile"</code></p>
</td></tr>
<tr><td><code id="ddCI_+3A_cl">CL</code></td>
<td>
<p>confidence level for the confidence interval(s)</p>
</td></tr>
<tr><td><code id="ddCI_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation draws to base the estimate of <code>CI</code> on</p>
</td></tr>
<tr><td><code id="ddCI_+3A_extent">extent</code></td>
<td>
<p>whether to calculate <code>CI</code> based on the full range of
possible data and extrapolating beyond the search radius
(<code>extent = "full"</code>) or restricting the distribution to the area within
the search radius (<code>extent = "win"</code>).</p>
</td></tr>
<tr><td><code id="ddCI_+3A_zrad">zrad</code></td>
<td>
<p>an ad hoc radius to integrate to when the (uncommon) simulated
parameter estimates do not result in an extensible distribution. In effect,
This replaces NAs with 1s in CDFs and with 0s in PDFs.</p>
</td></tr>
<tr><td><code id="ddCI_+3A_na.tol">na.tol</code></td>
<td>
<p>maximum fraction of invalid parameter sets to discard when
constructing CIs; abort if <code>mean(mod[, "extensible"]) &gt; na.tol</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>array (<code>ddCI</code> class) with columns for distance and the CI bounds
</p>

<hr>
<h2 id='ddd'>Calculate Probability Functions for Distance Distributions</h2><span id='topic+ddd'></span><span id='topic+pdd'></span><span id='topic+qdd'></span><span id='topic+rdd'></span><span id='topic+rcd'></span>

<h3>Description</h3>

<p>Calculate the standard d/p/q/r family of R probability functions for distance
distributions (<code><a href="#topic+ddFit">dd</a></code>) as well as the relative carcass 
density (<code>rcd</code>). Usage broadly parallels that of the d/p/q/r probability 
functions like <code><a href="#topic+stats">dnorm</a></code>, <code>pnorm</code>, <code>qnorm</code>, and 
<code>rnorm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddd(x, model, parms = NULL, extent = "full", zrad = 200)

pdd(q, model, parms = NULL, extent = "full", zrad = 200, silent = FALSE)

qdd(p, model, parms = NULL, extent = "full", zrad = 200, subdiv = 1000)

rdd(n, model, parms = NULL, extent = "full", zrad = 200, subdiv = 1000)

rcd(x, model, parms = NULL, extent = "full", zrad = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddd_+3A_x">x</code>, <code id="ddd_+3A_q">q</code>, <code id="ddd_+3A_p">p</code>, <code id="ddd_+3A_n">n</code></td>
<td>
<p>numeric, <code class="reqn">x \ge 0</code></p>
</td></tr>
<tr><td><code id="ddd_+3A_model">model</code></td>
<td>
<p>either a <code>dd</code> object or a <code>ddSim</code> object</p>
</td></tr>
<tr><td><code id="ddd_+3A_parms">parms</code></td>
<td>
<p>model parameters; required if model is specified as a character 
string rather than a <code>dd</code> or <code>ddSim</code> object (otherwise optional and ignored)</p>
</td></tr>
<tr><td><code id="ddd_+3A_extent">extent</code></td>
<td>
<p>for a full distribution extrapolated beyond the search radius
to account for all carcasses, use <code>extent = "full"</code>; for a distribution
restricted solely to carcasses falling within the search radius, use
<code>extent = "win"</code>.</p>
</td></tr>
<tr><td><code id="ddd_+3A_zrad">zrad</code></td>
<td>
<p>the distance at which carcass density is assumed to be zero; to
be used only in simulation reps in which simulated parameters do not yield
extensible distributions, essentially returning 0 rather than NA for those
pathological cases.</p>
</td></tr>
<tr><td><code id="ddd_+3A_silent">silent</code></td>
<td>
<p>If <code>TRUE</code>, then console messages are suppressed.</p>
</td></tr>
<tr><td><code id="ddd_+3A_subdiv">subdiv</code></td>
<td>
<p>if the number of values to calculate with <code>rdd</code> or <code>qdd</code>
is &gt;1, the function uses breaks the PDF into <code>subdiv</code> subdivisions and
interpolates to solve the inverse. More subdivisions gives greater accuracy
but is slower.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability density function (PDF(<em>x</em>) = <em>f</em>(<em>x</em>) = <code>ddd(x, ...)</code>) 
gives the probability that a carcass falls in a 1 meter ring centered at the 
turbine and with an outer radius of <code>x</code> meters. The cumulative distribution 
function [CDF(<em>x</em>) = <em>F</em>(<em>x</em>) = <code>pdd(x, ...)</code>] gives the 
probability that a carcass falls within <code>x</code> meters from the turbine. For 
a given probability, <code>p</code>, the inverse CDF [<code>qdd(p,...)</code>] gives the 
<code>p</code> quantile of carcass distances. For example, <code>qdd(0.5,...)</code> 
gives the median carcass distance, and <code>qdd(0.9, ...)</code> gives the radius 
that 90% of the carcasses are expected to fall in. Random carcass distances 
can be generated using <code>rdd</code>.
</p>
<p>The relative carcass density function(<code>rcd</code>) gives relative carcass 
densities at a point <code>x</code> meters from a turbine. In general, rcd is 
proportional to PDF(x)/x, normalized so that the surface of rotation of rcd(x) 
has total volume of 1. There are more stringent contstraints on the allowable 
parameters in the fitted (or simulated) glm's because the integral of PDF(x)/x 
must converge.
</p>
<p>Distributions may be extrapolated beyond the search radius to account for all
carcasses, including those that land beyond the search radius 
(<code>extent = "full"</code>), or may be restricted to carcasses falling within the
searched area (<code>extent = "win"</code>). Typically, in estimating <code>dwp</code> for
a fatality estimator like <code>eoa</code> or <code>GenEst</code>, the full distributions
would be used.
</p>
<p>The probability functions have a number of purposes. A few of the more commonly
used are listed below.
</p>

<dl>
<dt>PDF and CDF (<code>ddd</code> and <code>pdd</code>):</dt><dd>

<ul>
<li><p>to calculate the probability that carcass lands at a distance
<code>x</code> meters from the turbine (or, more precisely, within 0.5 meters of 
<code>x</code>) or within <code>x</code> meters from the turbine, use a scalar value
of <code>x</code> and a single model (<code><a href="#topic+ddFit">dd</a></code> or <code><a href="#topic+ddSim">ddSim</a></code>)
with <code>ddd</code> or <code>pdd</code>, repspectively;
</p>
</li>
<li><p>to account for uncertainty in the probabilities at <code>x</code>, use 
<code>ddd</code> or <code>pdd</code> for with scalar <code>x</code> and a simulated set of
parameters from the fitted model (<code><a href="#topic+ddSim">ddSim</a></code> object). This would 
be useful for calculating confidence intervals for the probabilities;
</p>
</li>
<li><p>to calculate probabilities for a range of <code>x</code> values according 
to a single model, use a vector <code>x</code> with a <code><a href="#topic+ddFit">dd</a></code> object or 
a <code><a href="#topic+ddSim">ddSim</a></code> object with one row. This would be useful for 
drawing graphs of PDFs or CDFs;
</p>
</li>
<li><p>to calculate simulated probabilites for a range of <code>x</code> values,
use a vector <code>x</code> and a <code>ddSim</code> object of simulated parameter sets.
This would be useful for drawing confidence regions around a fitted PDF or
CDF.
</p>
</li></ul>
</dd>
<dt>Inverse CDF (<code>qdd</code>):</dt><dd>

<ul>
<li><p>to calculate the distance that 100<code>p</code>% of the carcasses are 
expected to fall, use a scalar <code>p</code> in the interval (0, 1) and a 
single model (<code><a href="#topic+ddFit">dd</a></code>) or parameter set (<code><a href="#topic+ddSim">ddSim</a></code> with
one row);
</p>
</li>
<li><p>to calculate account for the uncertainty in estimating the inverse 
CDF for a given <code>p</code>, use a scalar <code>p</code> and a <code><a href="#topic+ddSim">ddSim</a></code>
object. This would be useful for calculating a confidence interval for,
say, the median or the expected 90th percentile of carcass distances;
</p>
</li>
<li><p>to calculate the inverse CDF for a range of probabilities for a single
model, use a vector <code>p</code> and a single model (<code><a href="#topic+ddFit">dd</a></code> or 
<code><a href="#topic+ddSim">ddSim</a></code> object with one row.
</p>
</li></ul>
  
</dd>
<dt>Random Carcasses Distances (<code>rdd</code>):</dt><dd>

<ul>
<li><p>to generate <code>n</code> random carcass distances for a given (fixed)
model, use a <code><a href="#topic+ddFit">dd</a></code> object or a <code><a href="#topic+ddSim">ddSim</a></code> object with
a single row;
</p>
</li>
<li><p>to generate <code>n</code> random carcass distances for a model and account
for the uncertainty in estimating the model, use a <code><a href="#topic+ddSim">ddSim</a></code> 
object with <code>n</code> rows, where <code>n</code> is also used as the <code>n</code>
argument in the call to <code>rdd</code>.
</p>
</li></ul>

</dd>
<dt>Relative Carcass Density (per m^2):</dt><dd>

<ul>
<li><p>to calculate the relative carcass density at a number of distances,
use a vector <code>x</code>. This would be useful in generating maps of carcass
density at a site.
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>vector or matrix of values; a vector is returned unless <code>model</code> 
is a <code>ddSim</code> object with more than one row and is to be calculated for
more than one value (<code>x</code>, <code>q</code>, <code>p</code>), in which case an array 
with dimensions <code>length(x)</code> by <code>nrow(model)</code> is returned (where 
&quot;<code>x</code>&quot; is <code>x</code>, <code>q</code>, or <code>p</code>, depending on whether <code>ddd</code>,
<code>pdd</code>, or <code>qdd</code> is called).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(layout_simple)
data(carcass_simple)
sitedata &lt;- initLayout(layout_simple)
ringdata &lt;- prepRing(sitedata)
ringsWithCarcasses &lt;- addCarcass(carcass_simple, data_ring = ringdata)
distanceModels &lt;- ddFit(ringsWithCarcasses)
modelEvaluations &lt;- modelFilter(distanceModels)
bestModel &lt;- modelEvaluations$filtered
pdd(100, model = bestModel) # estimated fraction of carcasses within 100m
ddd(1:150, model = bestModel) # estimated PDF of the carcass distances
qdd(0.9, model = bestModel) # estimated 0.9 quantile of carcass distances
rdd(1000, model = bestModel) # 1000 random draws from estimated carcass distribution
</code></pre>

<hr>
<h2 id='ddFit'>Fit Distance Distribution Model(s)</h2><span id='topic+ddFit'></span><span id='topic+ddFit.data.frame'></span><span id='topic+ddFit.rings'></span><span id='topic+ddFit.list'></span><span id='topic+ddFit.xyLayout'></span><span id='topic+ddFit.ringscc'></span>

<h3>Description</h3>

<p>Fit generalized linear models (glm) for distance distribution 
models corresponding to standard forms [xep1, xep01 (gamma), xep2 (Rayleigh), 
xep02, xep12, xep012, xep123, xep0123 (normal-gamma with x = tau), lognormal,  
truncated normal, Maxwell Boltzmann, and constant] and supplentary forms 
[exponential, chi-squared, inverse gamma, and inverse Gaussian].
</p>
<p>The glm is converted to a probability distribution by dividing by a
normalizing constant, namely the integral of the glm evaluated from 0 to
infinity. In some cases (most notably when the leading coefficient of the
glm is positive so the fitted curve does not converge to zero as x increases),
converted to a probability distribution. In these cases, the distribution
parameters are given as <code>NA</code>, but the fitted model itself is saved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddFit(x, ...)

## S3 method for class 'data.frame'
ddFit(
  x,
  distr = "standard",
  scVar = NULL,
  rCol = "r",
  expoCol = "exposure",
  ncarcCol = "ncarc",
  silent = FALSE,
  ...
)

## S3 method for class 'rings'
ddFit(
  x,
  distr = "standard",
  scVar = NULL,
  rCol = "r",
  expoCol = "exposure",
  ncarcCol = "ncarc",
  silent = FALSE,
  ...
)

## S3 method for class 'list'
ddFit(
  x,
  distr = "standard",
  scVar = NULL,
  rCol = "r",
  expoCol = "exposure",
  ncarcCol = "ncarc",
  silent = FALSE,
  ...
)

## S3 method for class 'xyLayout'
ddFit(
  x,
  distr = "standard",
  scVar = NULL,
  notSearched = NULL,
  rCol = "r",
  ncarcCol = "ncarc",
  unitCol = "turbine",
  silent = FALSE,
  ...
)

## S3 method for class 'ringscc'
ddFit(
  x,
  distr = "standard",
  scVar = NULL,
  rCol = "r",
  expoCol = "exposure",
  ncarcCol = "ncarc",
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddFit_+3A_x">x</code></td>
<td>
<p>a search plot layout object to fit carcass distribution models to. The
layout may be a data frame with columns for ring radii, exposure (or searched
area in each ring), search class variable (optional), and number of carcasses
in each ring;</p>
</td></tr>
<tr><td><code id="ddFit_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="ddFit_+3A_distr">distr</code></td>
<td>
<p>names (vector of character strings) of glm distribution templates
to fit. Default is <code>distr = "standard"</code> to fit the standard models listed in the
description above. Setting <code>distr = "all"</code> will fit both the standard
models and the supplementary models. Also, any subset of the models may be fit
by using, for example, <code>distr = c("xep01", "lognormal")</code> to fit only
the <code>"xep01"</code> and <code>"lognormal"</code> models, or
<code>distr = exclude(c("xep123", "constant"))</code> to fit all standard models except
<code>"xep123"</code> and <code>"constant"</code>, or <code>distr = exclude("lognormal", 
mod_all)</code> to fit all the models except the lognormal.</p>
</td></tr>
<tr><td><code id="ddFit_+3A_scvar">scVar</code></td>
<td>
<p>Search class variable to include in the model (optional). <code>scVar</code>
is ignored if <code>x</code> is not a <code>shapeLayout</code> or <code>xyLayout</code> object.
If <code>x</code> is a <code>shapeLayout</code> object, <code>scVar</code> may be either <code>NULL</code>
or the name of a single column with search class data. If <code>x</code> is an <code>xyLayout</code>
object, <code>scVar</code> may be either NULL or a vector of names of search class
variables to include in the models.</p>
</td></tr>
<tr><td><code id="ddFit_+3A_rcol">rCol</code></td>
<td>
<p>name of the distance column (which gives the outer radii of the rings).
This will be correct by default for objects coming from <code><a href="#topic+prepRing">prepRing</a></code> 
and will rarely need to be explicitly specified.</p>
</td></tr>
<tr><td><code id="ddFit_+3A_expocol">expoCol</code></td>
<td>
<p>name of the column with the exposure, which is the area in the ring
with outer radius <code>rCol</code>. This will be correct by default for objects
coming from <code><a href="#topic+prepRing">prepRing</a></code> and will rarely need to be 
explicitly specified.</p>
</td></tr>
<tr><td><code id="ddFit_+3A_ncarccol">ncarcCol</code></td>
<td>
<p>name of the column with tallies of carcasses by ring. This
will be correct by default for objects coming from <code><a href="#topic+prepRing">prepRing</a></code> 
and will rarely need to be explicitly specified.</p>
</td></tr>
<tr><td><code id="ddFit_+3A_silent">silent</code></td>
<td>
<p>set <code>silent = TRUE</code> to suppress information printed to the
console as the calculations proceed, which may be useful when running 
simulations.</p>
</td></tr>
<tr><td><code id="ddFit_+3A_notsearched">notSearched</code></td>
<td>
<p>the name of the level (if any) in <code>scVar</code> that
indicates an unsearched area</p>
</td></tr>
<tr><td><code id="ddFit_+3A_unitcol">unitCol</code></td>
<td>
<p>name of the column with turbine IDs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of fitted glm models as <code><a href="#topic+ddFit">dd</a></code> objects in a 
<code><a href="#topic+ddFit">ddArray</a></code>
object if a vector of distributions is fit, or a single <code><a href="#topic+ddFit">dd</a></code> 
object if a single model is fit. The <code><a href="#topic+ddFit">dd</a></code> objects are 
lists that include the following elements:
</p>

<dl>
<dt><code><a href="stats.html#topic+glm">glm</a></code></dt><dd><p>the fitted model</p>
</dd>
<dt><code>$distr</code></dt><dd><p>name of the distribution (<code>"xep01"</code>, etc.)</p>
</dd>
<dt><code>$parms</code></dt><dd><p>vector of distribution parameter estimates (or <code>NA</code>
if the model based on the MLE is not extensible)</p>
</dd>
<dt><code>$varbeta</code></dt><dd><p>the variance-covariance matrix of the glm parameter
estimates. NOTE: This is identical to the covariance matrix from the glm,
which can be extracted via <code>summary(x)$cov.unscaled</code></p>
</dd>
<dt><code>$scVar</code></dt><dd><p>name of the (optional) search class variable (or <code>NULL</code>)</p>
</dd>
<dt><code>$ncarc</code></dt><dd><p>number of carcasses</p>
</dd>
<dt><code>$aicc</code></dt><dd><p>the AICc value of the fit</p>
</dd>
<dt><code>$n</code></dt><dd><p>number of rings</p>
</dd>
<dt><code>$k</code></dt><dd><p>number of parameters</p>
</dd>
<dt><code>$srad</code></dt><dd><p>search radius</p>
</dd>
</dl>

<p>When a <code>dd</code> object is printed, only a small subset of the elements are
shown. To see a full list of the objects, use <code>names(x)</code>. The elements
can be extracted in the usual R way via <code>$</code> or <code>[[x]]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(layout_simple) 
 data(carcass_simple)
 sitedata &lt;- initLayout(layout_simple) # initialize
 ringdata &lt;- prepRing(sitedata) # format site layout data for modeling
 ringsWithCarcasses &lt;- addCarcass(carcass_simple, data_ring = ringdata) # add carcasses to site
 distanceModels &lt;- ddFit(ringsWithCarcasses) # fit distance models
</code></pre>

<hr>
<h2 id='ddPrint'>Print S3 Objects in <code>dwp</code> Package</h2><span id='topic+ddPrint'></span><span id='topic+print.dd'></span><span id='topic+print.ddArray'></span><span id='topic+print.fmod'></span>

<h3>Description</h3>

<p><code><a href="#topic+ddFit">dd</a></code>, <code><a href="#topic+ddFit">ddArray</a></code>, and 
<code><a href="#topic+modelFilter">fmod</a></code> objects are lists consisting of a great
amount of data. Only a few of the elements are printed automatically. Other 
elements of object <code>x</code> can be viewed and extracted as with other lists 
in R, namely, by using the <code>x$element</code> or <code>x[[element]]</code> operator, 
where <code>element</code> is the name of one of the elements of <code>x</code>, all of
which can be viewed via <code>names(x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dd'
print(x, ...)

## S3 method for class 'ddArray'
print(x, ...)

## S3 method for class 'fmod'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddPrint_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+ddFit">ddArray</a></code> or <code><a href="#topic+ddFit">ddArray</a></code> object</p>
</td></tr>
<tr><td><code id="ddPrint_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value; output printed to the console
</p>

<hr>
<h2 id='ddSim'>Simulation of Dispersion Parameters</h2><span id='topic+ddSim'></span><span id='topic+ddSim.dd'></span>

<h3>Description</h3>

<p>Simulation of Dispersion Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddSim(x, ...)

## S3 method for class 'dd'
ddSim(x, nsim = 1000, extent = "full", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddSim_+3A_x">x</code></td>
<td>
<p>object to simulate from</p>
</td></tr>
<tr><td><code id="ddSim_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="ddSim_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation draws</p>
</td></tr>
<tr><td><code id="ddSim_+3A_extent">extent</code></td>
<td>
<p>simulate according to full distribution, including extrapolation
beyond the search radius (<code>extent = "full"</code>); or restrict the
distribution to the area within the search radius (<code>extent = "win"</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with simulated beta parameters from the glm model, and their
conversion to distribution parameters
</p>

<hr>
<h2 id='degOrder'>An Ordering of the Models by Degree of the Polynomial</h2><span id='topic+degOrder'></span>

<h3>Description</h3>

<p>An Ordering of the Models by Degree of the Polynomial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degOrder
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 17.
</p>

<hr>
<h2 id='distr_names'>Full List of Names of Distributions</h2><span id='topic+distr_names'></span>

<h3>Description</h3>

<p>Full List of Names of Distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distr_names
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 17.
</p>

<hr>
<h2 id='Distributions'>Probability Distributions for Carcasses Versus Distance from Turbine</h2><span id='topic+Distributions'></span><span id='topic+dmb'></span><span id='topic+pmb'></span><span id='topic+dxep1'></span><span id='topic+pxep1'></span><span id='topic+pxep02'></span><span id='topic+dxep02'></span><span id='topic+dxep12'></span><span id='topic+pxep12'></span><span id='topic+dxep123'></span><span id='topic+pxep123'></span><span id='topic+dxepi0'></span><span id='topic+pxepi0'></span><span id='topic+dxep0123'></span><span id='topic+pxep0123'></span><span id='topic+dxep012'></span><span id='topic+pxep012'></span><span id='topic+dxep2'></span><span id='topic+pxep2'></span><span id='topic+dxep0'></span><span id='topic+pxep0'></span>

<h3>Description</h3>

<p>PDFs and CDFs that are required by <code>ddd</code>, <code>pdd</code> and 
<code>qdd</code> but are not included among the standard R distributions. Relying on
custom code and included here are the Maxwell-Boltzmann (<code>pmb</code> and 
<code>dmb</code>), xep0 (Pareto), xep1, xepi0 (inverse gamma), xep2 (Rayleigh), 
xep02, xep12, xep012, xep123, and xep0123. Not included here are the 
distributions that can be calculated using standard probability functions from
base R, namely the exponential, truncated normal, lognormal, gamma (xep01), and 
chisquared distributions and the inverse gaussian, which is calculated using 
<code>statmod::dinvgauss</code> and <code>statmod::dinvgauss</code>. The functions are 
designed for vector <code>x</code> or <code>q</code> and scalar parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmb(x, a)

pmb(q, a)

dxep1(x, b1)

pxep1(q, b1)

pxep02(q, b0, b2)

dxep02(x, b0, b2)

dxep12(x, b1, b2)

pxep12(x, b1, b2)

dxep123(x, b1, b2, b3, const = NULL)

pxep123(x, b1, b2, b3, const = NULL)

dxepi0(x, shape, scale)

pxepi0(x, shape, scale)

dxep0123(x, b0, b1, b2, b3, const = NULL)

pxep0123(x, b0, b1, b2, b3, const = NULL)

dxep012(x, b0, b1, b2, const = NULL)

pxep012(x, b0, b1, b2, const = NULL)

dxep2(x, s2)

pxep2(x, s2)

dxep0(x, a)

pxep0(x, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Distributions_+3A_x">x</code>, <code id="Distributions_+3A_q">q</code></td>
<td>
<p>vector of distances</p>
</td></tr>
<tr><td><code id="Distributions_+3A_a">a</code>, <code id="Distributions_+3A_b0">b0</code>, <code id="Distributions_+3A_b1">b1</code>, <code id="Distributions_+3A_b2">b2</code>, <code id="Distributions_+3A_b3">b3</code>, <code id="Distributions_+3A_shape">shape</code>, <code id="Distributions_+3A_scale">scale</code>, <code id="Distributions_+3A_s2">s2</code></td>
<td>
<p>parameters used in the respective
distributions.</p>
</td></tr>
<tr><td><code id="Distributions_+3A_const">const</code></td>
<td>
<p>(optional) scalar normalizing constant for distributions that are
numerically integrated using <code>integrate</code>, namely. Providing a <code>const</code> is
not necessary but will improve the speed of calculation under certain
conditions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An xep distribution is calculated by dividing its kernel (for the 
densities) or the integral of its kernel (for the cumulative distributions) 
by the normalizing constant, which is the integral of the kernel from 0 to Inf. 
The kernel of an xep distribution is defined as <code class="reqn">x e^{P(x)}</code>, 
where <code class="reqn">P(x)</code> is a polynomial with terms defined by the suffix on xep. For 
example, the kernel of xep12 would be <code class="reqn">x e^{b_1*x + b_2*x^2}</code>. A <code>0</code> in the suffix indicates a <code>log(X)</code> 
term and an <code>i</code> indicates a <code>1/x</code> term. The parameters of the xep 
distributions are some combination of <code class="reqn">b_0, b_1, b_2, b_3</code>. The parameterizations of the
inverse gamma (xepi0), Rayleigh (xep2), and Pareto (xep0) follow the standard
conventions of <code>shape</code> and <code>scale</code> for the inverse gamma, <code>s2</code> = 
<code class="reqn">s^2</code> for the Rayleigh, and <code>a</code> = <code class="reqn">a</code> for the Pareto (with
a scale or location parameter of 1 and PDF = <code class="reqn">a/x^(x + 1)</code> 
with support (1, Inf).
</p>
<p>The Maxwell-Boltzmann is a one-parameter family with parameter <code>a</code> and PDF 
<code class="reqn">f(a) = \sqrt{2/\pi}\frac{x^2 e^{-x^2/(2a^2)}}{a^3}</code>. The kernel is
<code class="reqn">f(a) = x^2 e^{-x^2}</code>, which has a simple closed-form 
integral that involves the error function (<code>pracma::erf</code>).
</p>


<h3>Value</h3>

<p>vector of probability densities or cumulative probabilities
</p>

<hr>
<h2 id='dwp'>Density-Weighted Proportion</h2><span id='topic+dwp'></span>

<h3>Description</h3>

<p>This package is designed to analyze carcass dispersion data and
fit models of carcass density as function of distance from turbine.
</p>


<h3>Data sets</h3>

<p><code><a href="#topic+carcass_polygon">carcass_polygon</a></code><br />
<code><a href="#topic+carcass_simple">carcass_simple</a></code><br />
<code><a href="#topic+layout_eagle">layout_eagle</a></code><br />
<code><a href="#topic+layout_polygon">layout_polygon</a></code><br />
<code><a href="#topic+layout_simple">layout_simple</a></code><br />
<code><a href="#topic+layout_xy">layout_xy</a></code><br />
<code><a href="#topic+xyr">xyr</a></code><br />
<code><a href="#topic+sieve_default">sieve_default</a></code><br />
</p>


<h3>Main Command-Line Functions</h3>


<dl>
<dt><code><a href="#topic+initLayout">initLayout</a>, <a href="#topic+prepRing">prepRing</a>, <a href="#topic+readCarcass">readCarcass</a>, <a href="#topic+addCarcass">addCarcass</a></code></dt><dd><p>import and format data</p>
</dd>
<dt><code><a href="#topic+ddFit">ddFit</a></code></dt><dd><p>fit carcass distribution models</p>
</dd>
<dt><code><a href="#topic+estpsi">estpsi</a>, <a href="#topic+estdwp">estdwp</a></code></dt><dd><p>estimate probability that carcass 
will lie in the searched area (psi) and the fraction of carcasses
lying in the searched area ('dwp')</p>
</dd>
<dt><code><a href="#topic+formatGenEst">formatGenEst</a>, <a href="#topic+exportGenEst">exportGenEst</a></code></dt><dd><p>format and export
'dwphat' objects for use with GenEst</p>
</dd>
<dt><code><a href="#topic+aic">aic</a>, <a href="#topic+modelFilter">modelFilter</a>, <a href="#topic+stats">stats</a>, <a href="#topic+ddCI">ddCI</a></code></dt><dd><p>statistics 
for fitted models</p>
</dd>
<dt><code>plot</code></dt><dd><p>S3 function for <code><a href="#topic+Plot">ddArray</a></code>,
<code><a href="#topic+Plot">dd</a></code>, <code><a href="#topic+Plot">fmod</a></code>,
<code><a href="#topic+Plot">polygonLayout</a></code>, 
<code><a href="#topic+Plot">psiHat</a></code>,
<code><a href="#topic+Plot">dwpHat</a></code> objects.</p>
</dd>
<dt><code><a href="#topic+ddd">ddd</a>, <a href="#topic+ddd">pdd</a>, <a href="#topic+ddd">qdd</a>, <a href="#topic+ddd">rdd</a>, <a href="#topic+ddd">rcd</a></code></dt><dd><p>probability 
functions for distance distributions</p>
</dd>
</dl>



<h3>Potentially Useful Calculation and Editing Functions</h3>

 
<dl>
<dt><code><a href="#topic+ddSim">ddSim</a>, <a href="#topic+dd2ddSim">dd2ddSim</a></code></dt><dd><p>functions for simulating <code>dd</code> models</p>
</dd></dl>
<p>,
</p>
<dl>
<dt><code><a href="#topic+getncarc">getncarc</a></code></dt><dd><p>extract the number of carcasses per turbine from a data set; 
method for many types of objects</p>
</dd></dl>
<p>,
</p>
<dl>
<dt><code><a href="#topic+cof2parms">cof2parms</a>, <a href="#topic+cofOK">cofOK</a>, <a href="#topic+cofOK">cofOK0</a>, <a href="#topic+cofOK">cofOKInf</a>, 
     <a href="#topic+constraints">constraints</a></code></dt><dd><p>functions for manipulating and checking model coefficients</p>
</dd>
<dt><code><a href="#topic+Acins">Acins</a></code></dt><dd><p>calculate the area of the intersection of a circle
and square sharing a common center</p>
</dd>
<dt><code><a href="#topic+rmat">rmat</a>, <a href="#topic+off">off</a></code></dt><dd><p>functions for constructing functions
out of distribution information</p>
</dd>
<dt><code><a href="#topic+exclude">exclude</a></code></dt><dd><p>simple function for excluding items from a 
superset</p>
</dd>
</dl>


<hr>
<h2 id='estdwp'>Estimate DWP</h2><span id='topic+estdwp'></span><span id='topic+estdwp.psiHat'></span><span id='topic+estdwp.psiHatcc'></span>

<h3>Description</h3>

<p>Estimate the density-weighted proportion (DWP) of carcasses lying in the
searched area at each turbine at a site. The calculation requires prior
estimation of the expected proportion (<code><a href="#topic+estpsi">psi</a></code>) and the
number of carcasses found (<code><a href="#topic+getncarc">ncarc</a></code>). NOTE: The 
carcass counts affect the uncertainty in the estimate of the fraction
of carcasses in the searched area (DWP), and <code>ncarc</code> is required for
accounting for uncertainty in estimates of DWP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estdwp(x, ...)

## S3 method for class 'psiHat'
estdwp(x, ncarc, nboot = NULL, forGenEst = FALSE, silent = TRUE, ...)

## S3 method for class 'psiHatcc'
estdwp(x, ncarc, nboot = NULL, forGenEst = FALSE, silent = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estdwp_+3A_x">x</code></td>
<td>
<p>Either (1) <code><a href="#topic+estpsi">psiHat</a></code> object, which is an 
<code>nsim</code> by <code>nturbine</code> matrix that gives the estimated probability 
of that a given carcass will land in the searched area at each turbine, with 
turbine IDs as column names; or (2) a <code><a href="#topic+estpsi">psiHatcc</a></code> 
object, which is a list of <code>psiHat</code> objects, one for each carcass class.</p>
</td></tr>
<tr><td><code id="estdwp_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="estdwp_+3A_ncarc">ncarc</code></td>
<td>
<p>vector of total carcass count at each turbine represented in x.</p>
</td></tr>
<tr><td><code id="estdwp_+3A_nboot">nboot</code></td>
<td>
<p>number of parametric bootstrap iterations for estimating CIs</p>
</td></tr>
<tr><td><code id="estdwp_+3A_forgenest">forGenEst</code></td>
<td>
<p>format the results for importing into GenEst (boolean)</p>
</td></tr>
<tr><td><code id="estdwp_+3A_silent">silent</code></td>
<td>
<p>suppress messages from the fitting of a beta distribution in
internal calculations that, if successful, increase the speed of the 
calculations by 20-200x. The message would signal that this acceleration 
cannot be applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='estpsi'>Estimate Probability Carcass lands in Searched Area</h2><span id='topic+estpsi'></span><span id='topic+estpsi.rings'></span><span id='topic+estpsi.ringscc'></span><span id='topic+estpsi.xyLayout'></span><span id='topic+estpsi.rpA'></span><span id='topic+estpsi.rdat'></span><span id='topic+estpsi.data.frame'></span>

<h3>Description</h3>

<p>Estimated probability that carcass lands in searched area. This
is an intermediate step in estimating dwp but is also interesting in its own
right. The estimation involves integrating the modeled carcass distribution 
(<code>model</code>) over the  search plots at the turbines. Data for the search 
plots is stored in the generic argument, <code>x</code>, which can take any of a
number of different forms, as described in the <code>Arguments</code> section (below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estpsi(x, ...)

## S3 method for class 'rings'
estpsi(x, model, extent = "full", nsim = 1000, zrad = 200, ...)

## S3 method for class 'ringscc'
estpsi(
  x,
  model,
  modnames = NULL,
  extent = "full",
  nsim = 1000,
  zrad = 200,
  ...
)

## S3 method for class 'xyLayout'
estpsi(x, model, extent = "full", nsim = 1000, zrad = 200, ...)

## S3 method for class 'rpA'
estpsi(x, model, extent = "full", nsim = 1000, zrad = 200, ...)

## S3 method for class 'rdat'
estpsi(x, model, extent = "full", nsim = 1000, zrad = 200, ...)

## S3 method for class 'data.frame'
estpsi(x, model, extent = "full", nsim = 1000, zrad = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estpsi_+3A_x">x</code></td>
<td>
<p>data </p>

<dl>
<dt><code>rings</code></dt><dd><p>a formatted site map created from raw data via function
<code><a href="#topic+prepRing">prepRing</a></code> (or as a component of a list returned by 
<code><a href="#topic+addCarcass">addCarcass</a></code>).</p>
</dd>
<dt><code>ringscc</code></dt><dd><p>a list of <code>rings</code> objects, one for each carcass
class; created from raw data via function <code><a href="#topic+prepRing">prepRing</a></code> (or as a 
component of a list returned by <code><a href="#topic+addCarcass">addCarcass</a></code>).</p>
</dd>
<dt><code>xyLayout</code></dt><dd><p>formatted site map data derived from (x, y) coordinates
covering every square meter of searched areas at each turbine; derived from
the function <code><a href="#topic+initLayout">initLayout</a></code>, when called with <code>xy</code> data.</p>
</dd>
<dt><code>rpA</code></dt><dd><p>(intended as an internal function that would rarely be 
called directly by users) a list of data frames (one for each turbine) 
giving the fraction of area searched (<code>pinc</code> at  each distance 
(<code>r</code>). <code>rpA</code> data are embedded in <code><a href="#topic+prepRing">rings</a></code> 
objects that are created from site &quot;maps&quot; via <code><a href="#topic+prepRing">prepRing</a></code>.</p>
</dd>
<dt><code>rdat</code></dt><dd><p>(intended as an internal function that would rarely be 
called directly by users) list of data frames giving the area searched 
(<code>"exposure"</code>), in a 1 meter ring with outer radius <code>"r"</code> and the 
number of carcasses found <code>"ncarc"</code> in each ring, with search class 
<code>scVar</code> optional. There is also a summary data frame 
<code>$rdat[["total"]]</code> that sums the exposures and carcass counts for all 
turbines across the site. The <code>$rdat[["total"]]</code> is the data frame 
used in fitting the GLMs. <code>rdat</code> objects are components of the return
value of <code><a href="#topic+prepRing">prepRing</a></code></p>
</dd>
<dt><code>data.frame</code></dt><dd><p>(intended as an internal function that would rarely be 
called directly by users) a data frame giving the fraction of area searched 
(<code>pinc</code> at  each distance (<code>r</code>).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="estpsi_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="estpsi_+3A_model">model</code></td>
<td>
<p>A fitted <code>dd</code> model or an array of estimated parameters
(<code>ddSim</code> object); or, if <code>x</code> is a <code>ringscc</code> object, a list
of <code>dd</code> models (one for each carcass class), or a <code>ddArraycc</code>
accompanied by a vector of model names to use (one for each carcass class).</p>
</td></tr>
<tr><td><code id="estpsi_+3A_extent">extent</code></td>
<td>
<p>calculate dwp within searched radius only (<code>"win"</code>) or
for full complement of carcasses (<code>"full"</code>), including those that fall
outside the search radius.</p>
</td></tr>
<tr><td><code id="estpsi_+3A_nsim">nsim</code></td>
<td>
<p>number of parametric bootstrap iterations for accounting for
uncertainty in the estimator. Default is <code>nsim = 1000</code>. Use 
<code>nsim = 0</code> for the estimate of <code>psi</code> based on the  MLE of
the given model without accounting for uncertainty.</p>
</td></tr>
<tr><td><code id="estpsi_+3A_zrad">zrad</code></td>
<td>
<p>radius</p>
</td></tr>
<tr><td><code id="estpsi_+3A_modnames">modnames</code></td>
<td>
<p>if <code>x</code> is a <code>ringscc</code> object, a vector of names of 
model to use for each carcass class; otherwise, <code>modnames</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>psiHat</code> object, which is either 1) an array giving the 
expected fraction  of carcasses lying in the searched area at each turbine 
with <code>nsim</code> rows and one column for each turbine + one row for the 
total; or 2) a list of such arrays, one for each carcass class if <code>x</code> 
is a <code>ringscc</code> object. The uncertainty in the expected fractions is
characterized by simulation and reflected in the variation in <code>psi</code>
values within each column.
</p>

<hr>
<h2 id='exclude'>Remove Particular Names from a Longer List</h2><span id='topic+exclude'></span>

<h3>Description</h3>

<p>Removes specific values (<code>what</code>) from a longer vector of values (<code>from</code>).
By default, <code>from = mod_standard</code>, and the intent is to simplify the
subsetting of <code>ddArray</code> objects created with the default standard models.
For example, <code>dmod2 &lt;- dmod[exclude("lognormal")]</code> would subset the list
of models in <code>mod_standard</code> to exclude <code>"lognomal"</code>. The default can
be overridden by providing a specific vector for <code>from</code> (for example,
<code>dmod[exclude("lognormal", from = names(dmod)])</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclude(what, from = mod_standard)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exclude_+3A_what">what</code></td>
<td>
<p>vector of distribution names to exclude</p>
</td></tr>
<tr><td><code id="exclude_+3A_from">from</code></td>
<td>
<p>vector of distribution names to be excluded from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of names from &quot;from&quot; after excluding &quot;what&quot;
</p>

<hr>
<h2 id='exportGenEst'>Export Estimated Density-Weighted Proportion to File in Proper GenEst Format</h2><span id='topic+exportGenEst'></span>

<h3>Description</h3>

<p>GenEst imports DWP from files with comma-separated values (.csv), with a 
column giving turbine ID and a column of DWP values for each carcass class.
Column lengths are equal to the number of turbines times the number of 
simulation reps (typically, <code>nsim = 1000</code>), giving <code>nsim</code> copies of 
DWP values for each turbine in a single column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportGenEst(dwp, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportGenEst_+3A_dwp">dwp</code></td>
<td>
<p>a <code>dwphat</code> object</p>
</td></tr>
<tr><td><code id="exportGenEst_+3A_file">file</code></td>
<td>
<p>name of file to export the <code>dwp</code> estimates to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: The <code>.csv</code> file uses the English convention (used in USA, UK, 
Mexico, China, India, Australia, Japan, Korea, and others) with the comma ( , ) 
and not the  semi-colon ( ; ) to separate values among different columns and 
uses the period ( . ) as the decimal mark. Although GenEst can seamlessly
accommodate either format, users in countries where the comma or other 
character is used as a decimal mark may need to adjust their software settings
or edit the data to be able to view it in a spreadsheet program (such 
as Excel).
</p>


<h3>Value</h3>

<p>The function writes the formatted data to a <code>.csv</code> file and 
returns NULL.
</p>

<hr>
<h2 id='fmmax'>Find suitable mmax for clipping improper priors for M</h2><span id='topic+fmmax'></span><span id='topic+fmmax.ab'></span>

<h3>Description</h3>

<p>Improper priors need to be clipped in order to be usable.
<code>fmmax</code> and <code>fmmax.ab</code> find values of <code class="reqn">m</code> that are large enough
that the probability of exceeding is less than 0.0001 (depends on <code class="reqn">g</code> and
<code class="reqn">X</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmmax(x, g)

fmmax.ab(x, pBa, pBb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmmax_+3A_x">x</code></td>
<td>
<p>carcass count</p>
</td></tr>
<tr><td><code id="fmmax_+3A_g">g</code></td>
<td>
<p>overall carcass detection probability</p>
</td></tr>
<tr><td><code id="fmmax_+3A_pba">pBa</code>, <code id="fmmax_+3A_pbb">pBb</code></td>
<td>
<p>parameters for beta distribution characterizing estimated <code class="reqn">g</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer <code class="reqn">m</code> such that <code class="reqn">Pr(M &gt;= m) &lt; 0.0001</code>
</p>

<hr>
<h2 id='formatGenEst'>Format DWP Estimate for Use in GenEst</h2><span id='topic+formatGenEst'></span>

<h3>Description</h3>

<p>GenEst requires <code>dwp</code> data to be formatted as a data frame with columns
for turbine ID and for estimated <code>dwp</code> for each carcass class. To
incorporate uncertainty in the estimates, <code>nsim</code> simulated copies of
the basic format are appended to the columns in the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatGenEst(dwphat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatGenEst_+3A_dwphat">dwphat</code></td>
<td>
<p>a <code>dwphat</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>nsim*nturbine</code> by <code>nclass + 1</code> data frame, with columns
for the turbine ID and for estimated <code>dwp</code> for each carcass class (e.g.,
<code>large</code>, <code>medium</code>, <code>small</code>, <code>bat</code>).
</p>

<hr>
<h2 id='getncarc'>Simple Function to Extract Carcass Counts</h2><span id='topic+getncarc'></span><span id='topic+getncarc.ringscc'></span><span id='topic+getncarc.rings'></span><span id='topic+getncarc.xyLayout'></span><span id='topic+getncarc.ddArray'></span><span id='topic+getncarc.ddArraycc'></span><span id='topic+getncarc.dd'></span>

<h3>Description</h3>

<p>Carcass counts are easy to extract from any of the data structures, but it
may be difficult to remember where to retrieve the data from for any particular
structure. <code>getncarc</code> simplifies the task by having the same usage for
all data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getncarc(x, ...)

## S3 method for class 'ringscc'
getncarc(x, ...)

## S3 method for class 'rings'
getncarc(x, ...)

## S3 method for class 'xyLayout'
getncarc(x, ...)

## S3 method for class 'ddArray'
getncarc(x, ...)

## S3 method for class 'ddArraycc'
getncarc(x, ...)

## S3 method for class 'dd'
getncarc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getncarc_+3A_x">x</code></td>
<td>
<p>a data structure with <code>ncarc</code> buried in it somewhere</p>
</td></tr>
<tr><td><code id="getncarc_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>scalar number of carcasses used in the fitted model 
(<code>dd</code> and <code>ddArray</code> objects
</p>
</li>
<li><p>vector of numbers of carcasses of each size used in the fitted models 
(<code>ddArraycc</code> objects)
</p>
</li>
<li><p>vector of carcass counts at each turbine and total at the site 
(<code>xyLayout</code> and <code>rings</code> objects
</p>
</li>
<li><p>list of vectors of carcass counts at each turbine for each carcass class
</p>
</li></ul>


<hr>
<h2 id='incGamma'>Incomplete Gamma Function</h2><span id='topic+incGamma'></span>

<h3>Description</h3>

<p>Incomplete Gamma Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incGamma(a, x, lower = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incGamma_+3A_a">a</code></td>
<td>
<p>positive numeric vector</p>
</td></tr>
<tr><td><code id="incGamma_+3A_x">x</code></td>
<td>
<p>non-negative numeric vector</p>
</td></tr>
<tr><td><code id="incGamma_+3A_lower">lower</code></td>
<td>
<p>boolean for calculating lower or upper incomplete gamma function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The upper incomplete gamma function, following Wolfram Alpha, namely,
incGamma(a, x) = <code class="reqn">\int_x^\infty e^{-t} * t^{a - 1}dt</code>,
calculated using pgamma. Within the <code>dwp</code> package, <code>incGamma</code> is 
used in the calculation of the cumulative distribution function (CDF) of the
xep02 distribution (<code>pxep02</code>). NOTE: The function <code>pracma::incgam</code> also
calculates incomplete gamma with <code>pracma::incgam(x, a) = incGamma(a, x)</code>,
but <code>pracma::incgam</code> is not vectorized and not used here.
</p>


<h3>Value</h3>

<p>scalar or vector of length = max(length(x), length(a)), with values
of the shorter recycled to match the length of the longer a la pnorm etc.
</p>

<hr>
<h2 id='initLayout'>Create a Data Structure or Map for the Site Layout</h2><span id='topic+initLayout'></span>

<h3>Description</h3>

<p>Read plot layout data and perform premliminary error-checking 
and formatting. Search plot layout data can come in any of several different
formats, including shape files for search area polygons and turbine locations,
R polygons, (x, y) coordinates, or simple description of search plot type for
each turbine (square, circular, road &amp; pad). A vector of distances along with
a search radius is also accommodated by <code>dwp</code>, but these can be directly
processed in <code><a href="#topic+prepRing">prepRing</a></code> without preprocessing in <code>initLayout</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initLayout(
  data_layout,
  dataType = "simple",
  unitCol = "turbine",
  file_turbine = NULL,
  radCol = "radius",
  shapeCol = "shape",
  padCol = "padrad",
  roadwidCol = "roadwidth",
  nRoadCol = "n_road",
  xCol = "x",
  yCol = "y",
  ncarcCol = "ncarc",
  scCol = NULL,
  notSearched = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initLayout_+3A_data_layout">data_layout</code></td>
<td>
<p>Either the name of a shape file (polygons or multipolygons)
that delineates areas searched at each turbine; a .csv file with R polygons,
(x, y) coordinates, or simple descriptions of search parameters at each turbine;
or a data frame with r polygons, (x, y) coordinates, or simple plot layout
descriptions. See &quot;Details&quot; for details.</p>
</td></tr>
<tr><td><code id="initLayout_+3A_datatype">dataType</code></td>
<td>
<p>An identifier for the type of data to be imported: <code>"shape"</code>,
<code>"polygon"</code>, <code>"xy"</code>, or <code>"simple"</code>. If <code>data_layout</code> is
the name of a shape file, the <code>dataType = "shape"</code> identifier is optional.</p>
</td></tr>
<tr><td><code id="initLayout_+3A_unitcol">unitCol</code></td>
<td>
<p>Column name for turbine IDs. If <code>data_layout</code> is the name
of a shape file, then <code>file_turbine</code> must also be provided, giving
turbine locations. The <code>unitCol</code> must be present in <code>data_layout</code>
and in <code>file_turbine</code> (if provided). Turbine IDs in the <code>unitCol</code>
must be syntactically valid R names (see Details below).</p>
</td></tr>
<tr><td><code id="initLayout_+3A_file_turbine">file_turbine</code></td>
<td>
<p>The name of a shape file (points) giving the turbine
locations for turbines listed in the <code>unitCol</code> column in the
<code>data_layout</code> if <code>data_layout</code> is a shape file. If 
<code>dataType = "xy"</code> and the grids in <code>data_layout</code> are all centered
at (0, 0) with their turbines at the center, then <code>file_turbine</code> is not
necessary and is ignored. Otherwise, if the grid coordinates are UTMs, 
<code>file_turbine</code> is either (1) a data frame with turbine names (in 'unitCol')
and the location of turbines in 'x' and 'y', or (2) the name of a .csv file 
with turbine locations ('unitCol', 'x', and 'y'). <code>file_turbine</code> is not 
required (and is ignored) for other data types.</p>
</td></tr>
<tr><td><code id="initLayout_+3A_radcol">radCol</code></td>
<td>
<p>for <code>dataType = "simple"</code> layouts: the name of the column in
<code>data_layout</code> that gives the search radius for each turbine</p>
</td></tr>
<tr><td><code id="initLayout_+3A_shapecol">shapeCol</code></td>
<td>
<p>for <code>dataType = "simple"</code> layouts: the name of the column in
<code>data_layout</code> that gives the plot shape for each turbine.</p>
</td></tr>
<tr><td><code id="initLayout_+3A_padcol">padCol</code></td>
<td>
<p>for <code>dataType = "simple"</code> layouts: the name of the column in
<code>data_layout</code> that gives the radius of the turbine pad</p>
</td></tr>
<tr><td><code id="initLayout_+3A_roadwidcol">roadwidCol</code></td>
<td>
<p>for <code>dataType = "simple"</code> layouts: the name of the column in
<code>data_layout</code> that gives the width of the turbine access road(s)</p>
</td></tr>
<tr><td><code id="initLayout_+3A_nroadcol">nRoadCol</code></td>
<td>
<p>for <code>dataType = "simple"</code> layouts: the name of the column in
<code>data_layout</code> that gives the number of turbine access roads at each turbine</p>
</td></tr>
<tr><td><code id="initLayout_+3A_xcol">xCol</code></td>
<td>
<p>for <code>dataType = "xy"</code> or <code>dataType = "polygon"</code> layouts: 
the name of the column in <code>data_layout</code> that gives <code>x</code> coordinates 
on the grid (for <code>dataType = "xy"</code>) or <code>x</code> coordinates of search area
polygon (for <code>dataType = "polygon"</code>)</p>
</td></tr>
<tr><td><code id="initLayout_+3A_ycol">yCol</code></td>
<td>
<p>for <code>dataType = "xy"</code> or <code>dataType = "polygon"</code> layouts: 
the name of the column in <code>data_layout</code> that gives <code>y</code> coordinates 
on the grid (for <code>dataType = "yy"</code>) or <code>y</code> coordinates of search area
polygon (for <code>dataType = "polygon"</code>)</p>
</td></tr>
<tr><td><code id="initLayout_+3A_ncarccol">ncarcCol</code></td>
<td>
<p>for <code>dataType = "xy"</code> layouts: the name of the column with
carcass counts in each grid cell. The column is required but may be all zeros
with carcasses added from a matrix of carcass locations later</p>
</td></tr>
<tr><td><code id="initLayout_+3A_sccol">scCol</code></td>
<td>
<p>for <code>dataType = "xy"</code> layouts: the name of column in data_layout
with names of search classes. This is used for excluding unsearched areas
from the grid data (x, y). It is used ONLY with <code>dataType = "xy"</code> and
used to remove rows with <code>x[, scCol] == notSearched</code>, where <code>x</code>
is the search grid data frame.</p>
</td></tr>
<tr><td><code id="initLayout_+3A_notsearched">notSearched</code></td>
<td>
<p>for <code>dataType = "xy"</code> layouts: the name(s) of search 
class(es) in <code>scCol</code> that are not searched (optional). Ignored for data 
types other than <code>xy</code>.</p>
</td></tr>
<tr><td><code id="initLayout_+3A_quiet">quiet</code></td>
<td>
<p>boolean for controlling whether progress of calculations and other
notes are printed to the console as the function runs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the layout types (except for vector, which is addressed elsewhere)
can accommodate patterns of seached and not searched areas. If the searched
areas are subdivided into different search classes with different detection
probabilities, then search plot layout data must be input either from shape files
with non-intersecting polgons delineating the search classes or from x-y grid
data. If there is more than one search class variable (for example, ground
cover and search schedule), then the covariates may be entered in separate
columns if the layout files give grid coordinates or may be combined into
one column in the shape files. For example, ground visibility may be easy or
difficult and search schedule may be 1-day or 14-day. These can be combined
into a single column with values of, say, <code>easy1</code>, <code>easy14</code>,
<code>difficult1</code>, and <code>difficult14</code>.
</p>
<p>There must be a turbine ID column (<code>unitCol</code>) in each of the files. The 
individual turbine ID's must be syntactically valid R names, i.e., contain 
combinations of letters, numbers, dot ( . ), and underscores ( _ ) only and 
not begin with a number or a dot followed by a number. Other characters are 
not allowed: no spaces, hyphens, parentheses, etc.
</p>
<p>If shape files are to be imported, both shape files (search area polygons and
turbine locations) must have their three standard, mandatory component files
(.shp, .shx, .dbf) stored in the same folder. Only the name of the .shp should
be entered in the function call. Other components are automatically searched
for and processed if available.
</p>


<h3>Value</h3>

<p>A list or data frame with components appropriate to the type of data
imported. The data structure is returned as an S3 class object, which other
functions in <code>dwp</code> can recognize and properly process. There is minimal
processing on the data after importing, but the structures are lightly error-checked
and formatted for more thorough processing, depending on data type and analysis
objectives. Typically, the layout data will be later processed by a call to
<code><a href="#topic+prepRing">prepRing</a></code> to create a characterization of the searched area at 
the site by &quot;rings&quot;, with tallies of searched area, search classes, and 
fraction of area searched in concentric, 1 meter rings around each turbine. 
The format of the output depends on the format of the input. There are 
several possibilities, including, each of which is an S3 object with 
characteristics specific to the imported data:
</p>

<dl>
<dt><code>shapeLayout</code></dt><dd><p>List with elements:
</p>

<ul>
<li> <p><code>$layout</code> = turbine search area configurations (polygons 
and multipolygons) from <code>data_layout</code> shape file as an 
<code><a href="sf.html#topic+sf">sf</a></code> object.
</p>
</li>
<li> <p><code>$layoutAdj</code> = polygons from <code>$layout</code> but recentered at (0, 0)
</p>
</li>
<li> <p><code>$turbines</code> = turbine data (as <code><a href="sf.html#topic+sf">sf</a></code> object)
</p>
</li>
<li> <p><code>$unitCol</code> = name of the column with turbine IDs (character string)
</p>
</li>
<li> <p><code>$tset</code> = turbine names (vector of character strings)
</p>
</li>
<li> <p><code>$tcenter</code> = locations of turbine centers (nturb by 2 array)
with UTMs of turbine locations, extracted and simplified from
<code>$turbines</code>. Column names are <code>X</code> and <code>Y</code>, measuring
meters from a reference point. Row names are the names of the turbines.
</p>
</li></ul>

</dd>
<dt><code>simpleLayout</code></dt><dd><p>Data frame with columns:
</p>

<ul>
<li> <p><code>turbine</code> = turbine IDs (syntactically valid R names)
</p>
</li>
<li> <p><code>radius</code> = search radius. If <code>shape = "square"</code>, then
radius is 1/2 the width of the square.
</p>
</li>
<li> <p><code>shape</code> = general descriptor of the shape of the search plot as
<code>"square"</code>, <code>"circular"</code>, or <code>"RP"</code> (for roads and pads search).
</p>
</li>
<li> <p><code>padrad</code> = radius of the turbine pad (assumed circular)
</p>
</li>
<li> <p><code>roadwidth</code> = width of the access road(s)
</p>
</li>
<li> <p><code>n_road</code> = number of access roads
</p>
</li></ul>

</dd>
<dt><code>polygonLayout</code></dt><dd>
<p>List of polygons, one for each turbine. The maximum search
radius at any turbine is assigned as an attribute (<code>attr(, "rad")</code>).
</p>
</dd>
<dt><code>xyLayout</code></dt><dd><p>List with elements:
</p>

<ul>
<li> <p><code>xydat</code> = data frame with columns for turbine names, x and y
coordinates of 1m grid centers spanning the searched area, number of
carcasses found in each grid cell, and optional covariates.
</p>
</li>
<li> <p><code>tcenter</code> = matrix giving turbine locations (<code>x, y</code>), with
row names = turbine names.
</p>
</li>
<li> <p><code>ncarc</code> = vector giving the number of carcasses found at each
turbine.
</p>
</li>
<li> <p><code>unitCol</code> = name of the column where turbine IDs are stored in
<code>xydat</code>.
</p>
</li>
<li> <p><code>tset</code> = names of the searched turbines
</p>
</li></ul>

</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(layout_simple)
# converts properly formatted dataframe to 'simpleLayout' object
initLayout(layout_simple) 

data(layout_xy)
initLayout(layout_xy, dataType = "xy")

data(layout_polygon)
initLayout(layout_polygon, dataType = "polygon", unitCol = "turbine")

</code></pre>

<hr>
<h2 id='layout_eagle'>Example Bare Vector Format for Eagle Data</h2><span id='topic+layout_eagle'></span>

<h3>Description</h3>

<p>Example Bare Vector Format for Eagle Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_eagle
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 60 rows and 3 columns.
</p>

<hr>
<h2 id='layout_polygon'>Example Polygon Data for Site Layout</h2><span id='topic+layout_polygon'></span>

<h3>Description</h3>

<p>Example Polygon Data for Site Layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_polygon
</code></pre>


<h3>Format</h3>

<p>A data frame illustrating the required raw data format for using
standard R polygons to characterize a site layout. There must be three
columns: one giving turbine IDs (<code>turbine</code>) and columns for the <code>x</code>
and <code>y</code> coordinates that delineate the plot layouts. Turbine IDs must be
syntactitally valid R names, that is, combinations of letters, numbers,
underscores ( _ ) and periods ( . ) and no spaces, hyphens, or other special
characters. Names must not begin with a number, so <code>1, 2, 3, ...</code>,
<code>3B1</code>, and <code>.72S</code> are NOT valid names. Coordinates shoud be in
meters relative to a turbine at (0, 0).
</p>

<hr>
<h2 id='layout_simple'>Example Simple Geometry Data Format for Site Layout</h2><span id='topic+layout_simple'></span>

<h3>Description</h3>

<p>Example Simple Geometry Data Format for Site Layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_simple
</code></pre>


<h3>Format</h3>

<p>A data frame illustrating an import format for a simple description of a
site layout by turbine. Each turbine (<code>turbine</code>) is classed according to
the shape of its search plot, either <code>circular</code>, <code>square</code>, or
<code>RP</code> (search on the roads and turbine pad only). For <code>circular</code>
plots, all ground within <code>radius</code> meters of the turbine is searched.
For <code>square</code> plots, the <code>radius</code> is half the width of the square
along the x-axis, NOT the distance to the corner. For <code>RP</code> plots, the
<code>radius</code> is the maximum distance searched on the roads. The geometry of
the <code>RP</code> also includes a circular turbine pad with radius <code>padrad</code>,
a road width of <code>roadwidth</code> meters, and the number of roads
(<code>n_road</code>) searched out to <code>radius</code> meters from the turbine.
</p>

<hr>
<h2 id='layout_xy'>Example Data for Site Layout on an (x, y) Grid</h2><span id='topic+layout_xy'></span>

<h3>Description</h3>

<p>Example Data for Site Layout on an (x, y) Grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_xy
</code></pre>


<h3>Format</h3>

<p>A data frame illustrating the required raw data format for using
a grid format to characterize a site layout. There are five
columns: one giving turbine IDs (<code>turbine</code>), columns for the <code>x</code>
and <code>y</code> coordinates on 1 m. grids that overlay the search plot, a
column giving the carcass count in each grid cell, and a column giving the
distance of each cell from the turbine. There is only one turbine, searched
on road and pad out. Coordinates are in meters relative to the turbine at 
(0, 0).
</p>

<hr>
<h2 id='mod_all'>Names of All the Available Models</h2><span id='topic+mod_all'></span>

<h3>Description</h3>

<p>Names of All the Available Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_all
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 17.
</p>

<hr>
<h2 id='mod_color'>Vector of Colors Used in Graphs of Fitted Models</h2><span id='topic+mod_color'></span>

<h3>Description</h3>

<p>Vector of Colors Used in Graphs of Fitted Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_color
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 17.
</p>

<hr>
<h2 id='mod_lty'>Vector of Line Types Used in Graphs of Fitted Models</h2><span id='topic+mod_lty'></span>

<h3>Description</h3>

<p>Vector of Line Types Used in Graphs of Fitted Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_lty
</code></pre>


<h3>Format</h3>

<p>An object of class <code>numeric</code> of length 17.
</p>

<hr>
<h2 id='mod_offset'>Vector of GLM Offsets for Available Models</h2><span id='topic+mod_offset'></span>

<h3>Description</h3>

<p>Vector of GLM Offsets for Available Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_offset
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 17.
</p>

<hr>
<h2 id='mod_standard'>Vector of Names of Standard Models</h2><span id='topic+mod_standard'></span>

<h3>Description</h3>

<p>Vector of Names of Standard Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_standard
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 12.
</p>

<hr>
<h2 id='mod_xy'>Vector of Names of Models Available for Grid Layout</h2><span id='topic+mod_xy'></span>

<h3>Description</h3>

<p>Vector of Names of Models Available for Grid Layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_xy
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 8.
</p>

<hr>
<h2 id='modelFilter'>Run Models through a Sieve to Filter out Dubious Fits</h2><span id='topic+modelFilter'></span>

<h3>Description</h3>

<p>A set of fitted models (<code><a href="#topic+ddFit">ddArray</a></code>) is filtered according 
to a set of criteria that test for high AIC, high-influence points, and
plausibility of the tail probabilities of each fitted distribution.
<code>modelFilter</code> will either auto-select the best model according to a set
of pre-defined, objective criteria or will will return all models that meet
a set of user-defined, or default criteria. A table of how the models
score according to each criterion is printed to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelFilter(dmod, sieve = "default", quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelFilter_+3A_dmod">dmod</code></td>
<td>
<p>a <code><a href="#topic+ddFit">ddArray</a></code> object</p>
</td></tr>
<tr><td><code id="modelFilter_+3A_sieve">sieve</code></td>
<td>
<p>a list of criteria for ordering models</p>
</td></tr>
<tr><td><code id="modelFilter_+3A_quiet">quiet</code></td>
<td>
<p>boolean to suppress (<code>quiet = TRUE</code>) or allow 
(<code>quiet = FALSE</code>) messages from <code>modelFilter</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The criteria to test are entered in a list (<code>sieve</code>) with components:
</p>

<ol>
<li> <p><code>$rtail</code> = vector of probabilities that define a checkpoints on distributions
to avoid situations where a model that may fit well within the range of data
is nonetheless implausible because it predicts a significant or substantial 
probability of carcasses falling great distances from the nearest turbine. 
The default is to check whether or not a distribution predicts that less than 
50% of carcasses fall within 80 meters, 90% within 120 meters, 95% within 
150 meters, or 99% within 200 meters. Distributions that fall below any of 
these points (for example predicting only 42% within 80 meters or only 74% 
within 120 meters) fail the default <code>rtail</code> test. The format of the 
default for  the test is <code>$rtail = c(p80 = 0.5, p120 = 0.90, 
  p150 = 0.95, p200 = 0.99)</code>. Users may override the default by using, for example, 
<code>sieve = list(rtail = c(p80 = 0.8, p120 = 0.99, p150 = 0.99, p200 = 0.999))</code>
in the argument list for a more stringent test or for a situation where
turbines are small or winds are light. Alternatively, users may forego the
test altogether by entering <code>sieve = list(rtail = FALSE)</code>. If specific
probabilities are provided, they must be in a vector of length 4 with names
&quot;<code>p80</code>&quot; etc. as in the examples above.
</p>
</li>
<li> <p><code>$ltail</code> = vector of probabilities that define checkpoints on distributions
to avoid situations where the search radius is short and a distribution that
fits the limited data set well but crashes to zero just outside the search
radius. The default is to check whether or not a distribution predicts that
greater than 50% of carcasses fall with 20 meters or 90% within 50 meters.
Distributions that pass above either of these checkpoints (for example
predicting 61% of carcasses within 20 meters or 93% within 50 meters)
are eliminated by the default <code>ltail</code> test. The format of the default for
the test is <code>$ltail = c(p20 = 0.5, p50 = 0.90)</code>. Users may override the
default by using, for example, <code>sieve = list(rtail = c(p20 = 0.6, p50 = 0.8))</code>
in the argument list for a situation where it is known that carcasses beyond
50 meters are common.
</p>
</li>
<li> <p><code>$aic</code> = a numeric scalar cutoff value for model's delta AICc
scores. Models with AICc scores exceeding the minimum AICc among all the 
fitted models by <code>sieve$aic</code> or more fail the test. The default value 
is 10. Users may override the default by using, for example, 
<code>sieve = list(aic = 7)</code> in the argument list to use a delta AIC score 
of 7 as the cutoff or may forego the test altogether by setting 
<code>sieve = list(aic = FALSE)</code>
</p>
</li>
<li> <p><code>$hin</code> = <code>TRUE</code> or <code>FALSE</code> to test for high influence points,
the presence of which cast doubt on the reliability of the model. The function
defines &quot;high influence&quot; as models with high leverage points, namely, points
with <code class="reqn">\frac{h}{1 - h} &gt;  \frac{2p}{n - 2p}</code> 
(where <code class="reqn">h</code> is leverage, <code class="reqn">p</code> is the number of parameters in the model, 
and <code class="reqn">n</code> is the search radius) with Cook's distance <code>&gt; 8/(n - 2*p)</code>. 
The criteria for high influence points were adapted from Brian Ripley's GLM 
diagnostics package <code>boot</code> (<code><a href="boot.html#topic+glm.diag">glm.diag</a></code>). The test is 
perhaps most valuable in identifying distributions with high probability of 
carcasses landing well beyond what could reasonably be expected.
</p>
</li></ol>

<p>Several choices of pre-defined <code>sieve</code>s are available (or, as described 
above, users may define their own criteria):
</p>

<dl>
<dt><code>sieve = "default"</code></dt><dd><p>The models are ordered by the following
criteria: 
</p>

<ol>
<li><p> extensibility
</p>
</li>
<li><p> weight of right tail (discounting models that predict implausibly 
high proportions of carcasses beyond the search radius)
</p>
</li>
<li><p> weight of the left tail (discounting models that predict implausibly 
high proportions of carcasses near the turbines)
</p>
</li>
<li><p> AICc test (discounting models with delta AICc &gt; 10)
</p>
</li>
<li><p> high influence points (discounting models in which one or more of the
data points exert a high influence on the fitted model, according to 
Ripley's GLM  diagnostics package <code>boot</code> (<code><a href="boot.html#topic+glm.diag">glm.diag</a></code>))
</p>
</li>
<li><p> ranking by AICc
</p>
</li></ol>

<p>Precise definitions of the default sieve parameters are given in 
<code>sieve_default</code>.</p>
</dd>
<dt><code>sieve = NULL</code></dt><dd><p>Returns a list of the extensible models without
scoring them by other model selection criteria.</p>
</dd>
<dt><code>sieve = "win"</code></dt><dd><p>Sorts models by high-influence points and AICc</p>
</dd>
<dt><code>sieve = list(&lt;custom&gt;)</code></dt><dd><p>User provides a custom sieve, which may
be a modification of the default sieve or de novo. To modify the default,
use, for example, <code>sieve = list(hin = FALSE)</code> to disable the <code>hin</code>
test but keep the other default tests, or <code>sieve = list(aic = 7)</code> to
use 7 rather than 10 as the AIC cutoff, or 
<code>sieve = list(ltail = c(p20 = 0.3, p50 = 0.8))</code> to use a more stringent 
left tail test that requires CDF graphs to pass below the points (20, 0.3) 
and (50, 0.8). Custom <code>ltail</code> and <code>rtail</code> parameters must match the 
formats of the default tests, but their probabilities may vary. To turn off
the <code>aic</code> filter, use <code>sieve = list(aic = Inf)</code>. To turn off the
<code>ltail</code> filter, use  <code>sieve = list(ltail = c(p20 = 1, p50 = 1))</code>.
To turn off the <code>rtail</code> filter, use 
<code>sieve = list(rtail = c(p80 = 0, p120 = 0, p150 = 0, p200 = 0))</code>. These
custom components may be mixed and matched as desired.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An <code>fmod</code> object, which is an unordered list of extensible models if
<code>sieve = NULL</code>; otherwise, a list of class <code>fmod</code> with following 
components:
</p>

<dl>
<dt><code>$filtered</code></dt><dd><p>the selected <code>dd</code> object or a <code>ddArray</code> list of
models that passed the tests</p>
</dd>
<dt><code>$scores</code></dt><dd><p>a matrix with all models tested (rownames = model names) and 
the results of each test (columns <code>aic_test</code>, <code>rtail</code>, 
<code>ltail</code>, <code>hin</code>, <code>aic</code>)</p>
</dd>
<dt><code>$sieve</code></dt><dd><p>the test criteria, stored in a list with
</p>
 
<ul>
<li> <p><code>$aic_test</code> = cutoff for AIC
</p>
</li>
<li> <p><code>$hin</code> = boolean to indicate whether high influence points were
considered
</p>
</li>
<li> <p><code>$rtail</code> = numeric vector giving the probabilities that the
right tail of the distribution must exceed at distances of 80, 120, 
150, and 200 meters in order to pass
</p>
</li>
<li> <p><code>$ltail</code> = numeric vector giving the probabilities that the 
left tail of the distribution must NOT exceed at distances of 20 and 
50 meters in order to pass
</p>
</li></ul>

</dd>
<dt><code>models</code></dt><dd><p>a list (<code>ddArray</code> object) of all models tested</p>
</dd>
<dt><code>note</code></dt><dd><p>notes on the tests</p>
</dd>
</dl>

<p>When a <code>fmod</code> object is printed, only a small subset of the elements are
shown. To see a full list of the objects, use <code>names(x)</code>, where <code>x</code>
is the name of the <code>fmod</code> return value. The elements
can be extracted in the usual R way via, for example, <code>x$sieve</code> or 
<code>x[["sieve"]]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(layout_simple)
 data(carcass_simple)
 sitedata &lt;- initLayout(layout_simple)
 ringdata &lt;- prepRing(sitedata)
 ringsWithCarcasses &lt;- addCarcass(carcass_simple, data_ring = ringdata)
 distanceModels &lt;- ddFit(ringsWithCarcasses)
 stats(distanceModels)
 stats(distanceModels[["tnormal"]])
 stats(distanceModels[["lognormal"]])
 
</code></pre>

<hr>
<h2 id='mpp2ddSim'>Convert Distribution Name + Parameters to <code>ddSim</code> Object</h2><span id='topic+mpp2ddSim'></span>

<h3>Description</h3>

<p>Utility function to format a distribution name and a vector of its parameter values
to a <code><a href="#topic+ddSim">ddSim</a></code> object for use in the p/d/r/q family of functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpp2ddSim(distr, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpp2ddSim_+3A_distr">distr</code></td>
<td>
<p>character string giving the name of one of the models fit by
<code><a href="#topic+ddFit">ddFit</a></code></p>
</td></tr>
<tr><td><code id="mpp2ddSim_+3A_parms">parms</code></td>
<td>
<p>vector of parameters for the <code>distr</code>, or, alternatively, an array
of parameter sets. Parameterization may follow  either the GLM format or the 
distribution format. For example, the xep01  model (gamma distribution) has
GLM parameters for <code>log(r)</code> and <code>r</code>, which are the coefficients of 
the polynomial in the xep01 format (namely, x * exp(b0*log(r) + b1*r)), or 
the gamma distribution parameters, <code>shape</code> and <code>rate</code>. The 
elements of parameter vector must be named. For example, 
<code>parms = c(log(r) = -0.373, r = -0.0147)</code> for the GLM format for an 
xep01 model or, equivalently, <code>parms = c(shape = 1.63, rate = 0.0147)</code> 
for the distribution format. If  both formats are given, the GLM parameters 
are used and the distribution parameters ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ddSim object with <code>srad = NA</code>
</p>

<hr>
<h2 id='MpriorOK'>Check validity of format of custom prior for M</h2><span id='topic+MpriorOK'></span>

<h3>Description</h3>

<p>Check validity of format of custom prior for M
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MpriorOK(prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MpriorOK_+3A_prior">prior</code></td>
<td>
<p>a custom prior for M must be a matrix with columns for M and
and associated probabalities P(M = m). The M column must begin at 0 and the
probabilities must sum to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean. Is the prior formatted properly?
</p>

<hr>
<h2 id='natural'>Vector of Names of Models with Natural Offset</h2><span id='topic+natural'></span>

<h3>Description</h3>

<p>The natural offset is the area (m^2) searched at a given distance. Models
that use the natural offset are referred to as &quot;natural&quot;. Other models may
use different offsets which alter the shape of the curve with distance in an
a priori way that is unaffected by the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>natural
</code></pre>


<h3>Format</h3>

<p>An object of class <code>logical</code> of length 17.
</p>

<hr>
<h2 id='off'>Utility Function for Constructing Offsets for GLMs</h2><span id='topic+off'></span>

<h3>Description</h3>

<p>This is a simple utility function for calculating offsets when exposure
is assumed to be 100
calculating fitted distributions (<code>PDF</code> and <code>CDF</code>) but cannot be
used in the fitting of the distributions themselves because it does not
account for incomplete search coverages at given distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>off(r, distr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="off_+3A_r">r</code></td>
<td>
<p>vector of distances</p>
</td></tr>
<tr><td><code id="off_+3A_distr">distr</code></td>
<td>
<p>name of the distribution to calculate the offset for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of offset values to use with distances <code>r</code> when fitting
the <code>distr</code> model.
</p>

<hr>
<h2 id='par_default'>Default Graphics Parameters</h2><span id='topic+par_default'></span>

<h3>Description</h3>

<p>Default Graphics Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_default
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 65.
</p>

<hr>
<h2 id='parm_name'>List of Names of the Distribution Parameters Associated with Respective Models</h2><span id='topic+parm_name'></span>

<h3>Description</h3>

<p>List of Names of the Distribution Parameters Associated with Respective Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parm_name
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 17.
</p>

<hr>
<h2 id='parOK'>Check Parameter Value Validity the Distribution</h2><span id='topic+parOK'></span>

<h3>Description</h3>

<p>Performs a ouick check on whether the parameters given in <code>parms</code> are
valid for the <code>distr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parOK(parms, distr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parOK_+3A_parms">parms</code></td>
<td>
<p>vector or matrix of named glm parameters (with <code>"r"</code> as the
distance variable)</p>
</td></tr>
<tr><td><code id="parOK_+3A_distr">distr</code></td>
<td>
<p>name of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector (or scalar) of 0s, 1s, and 2s to indicate whether the parameters
are non-extensible (i.e., flat-out bogus), valid for the distribution, or
valid for the distribution and give finite point densities.
</p>

<hr>
<h2 id='Plot'>Plot dd and ddArray Objects</h2><span id='topic+Plot'></span><span id='topic+plot.ddArray'></span><span id='topic+plot.dd'></span><span id='topic+plot.fmod'></span><span id='topic+plot.polygonLayout'></span><span id='topic+plot.layoutSimple'></span><span id='topic+plot.psiHat'></span><span id='topic+plot.dwphat'></span>

<h3>Description</h3>

<p>Plot CDF, PDF, or rcd (relative carcass density) for a single
carcass dispersion glm model (<code><a href="#topic+ddFit">dd</a></code> object) or a list of 
models (<code><a href="#topic+ddFit">ddArray</a></code> object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ddArray'
plot(
  x,
  type = "CDF",
  extent = "full",
  distr = "all",
  xmax = NULL,
  resolution = 250,
  mod_highlight = NULL,
  ...
)

## S3 method for class 'dd'
plot(
  x,
  type = "CDF",
  extent = "full",
  xmax = NULL,
  resolution = 250,
  nsim = 1000,
  CL = 0.9,
  ...
)

## S3 method for class 'fmod'
plot(x, ...)

## S3 method for class 'polygonLayout'
plot(x, ...)

## S3 method for class 'layoutSimple'
plot(x, ...)

## S3 method for class 'psiHat'
plot(x, ...)

## S3 method for class 'dwphat'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plot_+3A_x">x</code></td>
<td>
<p>model(s) to plot</p>
</td></tr>
<tr><td><code id="Plot_+3A_type">type</code></td>
<td>
<p>Type or representation of carcass dispersion to plot:
<code>"CDF"</code>, <code>"PDF"</code>, or <code>"rcd"</code>. The <code>"CDF"</code> gives the
fraction of carcasses falling within <code>r</code> meters from a turbine and
<code>"PDF"</code> is the associated probability density. The <code>"rcd"</code> gives the
relative carcass density at a point <code>r</code> meters from a turbine and is
PDF/(2 * pi * r).</p>
</td></tr>
<tr><td><code id="Plot_+3A_extent">extent</code></td>
<td>
<p>Plot dispersions as fraction of total carcasses (<code>"full"</code>)
or as fraction of carcasses within the searched area (<code>"win"</code>).</p>
</td></tr>
<tr><td><code id="Plot_+3A_distr">distr</code></td>
<td>
<p>vector of names of distributions to plot or <code>set = "all"</code></p>
</td></tr>
<tr><td><code id="Plot_+3A_xmax">xmax</code></td>
<td>
<p>maximum distance to show in the graph; if <code>xmax = NULL</code>, the
maximum distance is taken as the max distance in the data set to which the
models were fit.</p>
</td></tr>
<tr><td><code id="Plot_+3A_resolution">resolution</code></td>
<td>
<p>The number of line segments to break the curves into when
plotting (i.e., <code>x = seq(0, xmax, length.out = resolution)</code>). Higher
resolutions give smoother-looking curves.</p>
</td></tr>
<tr><td><code id="Plot_+3A_mod_highlight">mod_highlight</code></td>
<td>
<p>Character string giving the name of the model to
highlight by plotting it last and with <code>lwd = 2</code>. If <code>NULL</code>, the
curve associated with the lowest (best) AICc score is highlighted.</p>
</td></tr>
<tr><td><code id="Plot_+3A_...">...</code></td>
<td>
<p>arguments that may be passed to plotting functions</p>
</td></tr>
<tr><td><code id="Plot_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulation reps to use for estimating confidence bounds
for <code><a href="#topic+ddFit">dd</a></code> plot (ignored for <code><a href="#topic+ddFit">ddArray</a></code>
objects)</p>
</td></tr>
<tr><td><code id="Plot_+3A_cl">CL</code></td>
<td>
<p>confidence level to show in a <code><a href="#topic+ddFit">dd</a></code> plot (ignored 
for <code><a href="#topic+ddFit">ddArray</a></code> objects)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+ddFit">ddArray</a></code> objects are plotted with lines in order 
of decreasing AICc, so that the &quot;better&quot; models are closer to the top and 
more prominent. The model with the lowest AICc (&quot;best&quot; model) is plotted 
last with a heavier line than the others.
</p>
<p>For <code><a href="#topic+ddFit">dd</a></code> objects, the curve for the MLE of the parameters
is plotted, along with a 100<code>CL</code>% confidence bounds determined for 
<code>nsim</code> simulation reps
</p>
<p>The legend follows the ordering given by <code><a href="#topic+modelFilter">modelFilter</a></code> with 
the default sieve or, if <code>extent = "win"</code> by (1) delta AICc &lt; 10, 
(2) the absence of high-influence points, and (2) AICc. The best model 
according to the filter is listed first, with a heavier line than the others; 
the remaining distributions are listed in descending order, with the best 
models in the leftmost column.
</p>


<h3>Value</h3>

<p>Plot displayed; no return value.
</p>

<hr>
<h2 id='postM'>Calculate posterior distribution of M and extract statistics (M* and CI)</h2><span id='topic+postM'></span><span id='topic+postM.ab'></span><span id='topic+calcMstar'></span><span id='topic+MCI'></span>

<h3>Description</h3>

<p>Calculation of the posterior distribution of total mortality
(<code>M</code>) given the carcass count, overall detection probability (<code>g</code>),
and prior distribtion; calculation of summary statistics from the
posterior distribution of <code>M</code>, including <code>M*</code> and credibility
intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postM(x, g, prior = "IbinRef", mmax = NA)

postM.ab(x, Ba, Bb, prior = "IbinRef", mmax = NULL)

calcMstar(pMgX, alpha)

MCI(pMgX, crlev = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postM_+3A_x">x</code></td>
<td>
<p>carcass count</p>
</td></tr>
<tr><td><code id="postM_+3A_g">g</code></td>
<td>
<p>overall carcass detection probability</p>
</td></tr>
<tr><td><code id="postM_+3A_prior">prior</code></td>
<td>
<p>prior distribution of <code class="reqn">M</code></p>
</td></tr>
<tr><td><code id="postM_+3A_mmax">mmax</code></td>
<td>
<p>cutoff for prior of M (large max requires large computing resources
but does not help in the estimation)</p>
</td></tr>
<tr><td><code id="postM_+3A_ba">Ba</code>, <code id="postM_+3A_bb">Bb</code></td>
<td>
<p>parameters for beta distribution characterizing estimated <code class="reqn">g</code></p>
</td></tr>
<tr><td><code id="postM_+3A_pmgx">pMgX</code></td>
<td>
<p>posterior distribution of <code class="reqn">M</code></p>
</td></tr>
<tr><td><code id="postM_+3A_crlev">crlev</code>, <code id="postM_+3A_alpha">alpha</code></td>
<td>
<p>credibility level (<code class="reqn">1-\alpha</code>) and its complement (<code class="reqn">\alpha</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>postM</code> and <code>postM.ab</code> return the posterior
distributions of <code class="reqn">M|(X, g)</code> and <code class="reqn">M|(X, Ba, Bb)</code>, respectively, where
<code>Ba</code> and <code>Bb</code> are beta distribution parameters for the estimated
detection probability. <code>postM</code> and <code>postM.ab</code> include options to
to specify a prior distribution for <code class="reqn">M</code> and a limit for truncating the
prior to disregard implausibly large values of <code class="reqn">M</code> and make the
calculations tractable in certain cases where they otherwise might not be.
Use <code>postM</code> when <code class="reqn">g</code> is fixed and known; otherwise, use <code>postM.ab</code>
when uncertainty in <code class="reqn">g</code> is characterized in a beta distribution with
parameters <code class="reqn">Ba</code> and <code class="reqn">Bb</code>. The non-informative, integrated reference
prior for binomial random variables is the default (<code>prior = "IbinRef"</code>).
Other options include &quot;binRef&quot;, &quot;IbetabinRef&quot;, and &quot;betabinRef&quot;, which are
the non-integrated and integrated forms of the binomial and betabinomial
reference priors (Berger et al., 2012). For <code class="reqn">X &gt; 2</code>, the integrated and
non-integrated reference priors give virtually identical posteriors. However,
the non-integrated priors assign infinite weight to <code class="reqn">m = 0</code> and return a
posterior of <code class="reqn">Pr(M = 0| X = 0, \hat{g}) = 1</code>, implying absolute certainty
that the total number of fatalities was 0 if no carcasses were observed. In
addition, a uniform prior may be specified by prior = &quot;uniform&quot;. Alternatively,
a custom prior may be given as a 2-dimensional array with columns for <code class="reqn">m</code>
and <code class="reqn">Pr(M = m)</code>, respectively. The first column (<code>m</code>) must be
sequential integers starting at <code class="reqn">m = 0</code>. The second column gives the
probabilities associated with <code class="reqn">m</code>, which must be non-negative and sum to 1.
The named priors (<code>"IbinRef"</code>, <code>"binRef"</code>, <code>"IbetabinRef"</code>,
and <code>"betabinRef"</code>) are functions of <code class="reqn">m</code> and defined on <code class="reqn">m=0,1,2,...</code>
without upper bound. However, the posteriors can only be calculated for a
finite number of <code class="reqn">m</code>'s up to a maximum of <code>mmax</code>, which is set by
default to the smallest value of <code class="reqn">m</code> such that
<code class="reqn">Pr(X \leq x | m, \hat{g}) &lt; 0.0001</code>, where <code class="reqn">x</code> is the observed
carcass count, or, alternatively, <code>mmax</code> may be specified by the user.
</p>


<h3>Value</h3>

<p>The functions <code>postM</code> and <code>postM.ab</code> return the posterior
distributions of <code class="reqn">M | (X, g)</code> and <code class="reqn">M | (X, Ba, Bb)</code>, respectively.
The functions <code>calcMstar</code> and <code>MCI</code> return <code class="reqn">M^*</code> value and
credibility interval for the given posterior distribution, <code>pMgX</code>
(which may be the return value of <code>postM</code> or <code>postM.ab</code>) and
<code class="reqn">\alpha</code> value or credibility level.
</p>

<hr>
<h2 id='prepmod'>Internal Utility Function to Parse and Format Model for Calculating Psihat</h2><span id='topic+prepmod'></span>

<h3>Description</h3>

<p>Internal Utility Function to Parse and Format Model for Calculating Psihat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepmod(model, nsim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepmod_+3A_model">model</code></td>
<td>
<p><code>dd</code> or <code>ddSim</code> object</p>
</td></tr>
<tr><td><code id="prepmod_+3A_nsim">nsim</code></td>
<td>
<p>number of simulation reps. If <code>nsim = 0</code>, return dd2ddSim</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+ddSim">ddSim</a></code> object of simulated distribution model parameters
</p>

<hr>
<h2 id='prepRing'>Format a Search Layout into Rings for Analysis</h2><span id='topic+prepRing'></span><span id='topic+prepRing.shapeLayout'></span><span id='topic+prepRing.simpleLayout'></span><span id='topic+prepRing.numeric'></span><span id='topic+prepRing.polygonLayout'></span>

<h3>Description</h3>

<p>A function for creating a characterization of the search plot at each turbine by
rings. The ground around each turbine is divided into 1 meter concentric rings
out to the limit of the search plot. The amount of area searched in each ring
and search class (if a search class column is present in the data) at each
turbine is calculated, along with the fraction of area searched in each ring.
In addition, sum totals of the area in each ring and the average fraction of
the area searched in each ring across all turbines at the site are tallied as well.
This is a convenient structure for the Poisson regressions that are used to
estimate the carcass distributions with respect to distance from the turbines,
the probabilities of carcasses landing in the searched areas, and the fraction
of carcasses in the searched area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepRing(x, ...)

## S3 method for class 'shapeLayout'
prepRing(x, scVar = NULL, notSearched = NULL, silent = FALSE, ...)

## S3 method for class 'simpleLayout'
prepRing(x, ...)

## S3 method for class 'numeric'
prepRing(x, srad, ...)

## S3 method for class 'polygonLayout'
prepRing(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepRing_+3A_x">x</code></td>
<td>
<p>a search plot layout as imported and processed by 
<code><a href="#topic+initLayout">initLayout</a></code> into a <code>shapeLayout</code>, <code>polygonLayout</code>, or 
<code>simpleLayout</code> object, or a bare vector of carcass distances if search 
plots are all circular with the same radius and no unsearched area within 
the search radius.</p>
</td></tr>
<tr><td><code id="prepRing_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="prepRing_+3A_scvar">scVar</code></td>
<td>
<p>name of the search class variable (optional), a column in the
shape file for the search polygons. <code>scVar</code> is ignored if <code>x</code> is not
a <code>shapeLayout</code> object.</p>
</td></tr>
<tr><td><code id="prepRing_+3A_notsearched">notSearched</code></td>
<td>
<p>name of the search class(es) in <code>scVar</code> that represent
unsearched areas. Applicable only if <code>x</code> is a <code>shapeLayout</code> object
and <code>scVar</code> is provided. Polygons associated with <code>scVar</code> values in
<code>notSearched</code> are not included in the rings characterization of the site.
Also, turbines with no polygons that are not <code>notSearched</code> are not included
in the rings.</p>
</td></tr>
<tr><td><code id="prepRing_+3A_silent">silent</code></td>
<td>
<p>Processing shape files into rings may take several minutes. By
default, <code>prepRing</code> prints periodic notice of the progress of the
calculations for shape files. To suppress these notices, use 
<code>silent = TRUE</code>.</p>
</td></tr>
<tr><td><code id="prepRing_+3A_srad">srad</code></td>
<td>
<p>search radius for data when <code>x</code> = bare vector of carcass
observation distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rings</code>, which is a list with components
</p>

<dl>
<dt><code>$rdat</code></dt><dd><p>list of data frames giving the area searched 
(<code>"exposure"</code>), in a 1 meter ring with outer radius <code>"r"</code> and 
the number of carcasses found <code>"ncarc"</code> in each ring, with search 
class <code>scVar</code> optional. There is also a summary data frame 
<code>$rdat[["total"]]</code> that sums the exposures and carcass counts for 
all turbines across the site. The <code>$rdat[["total"]]</code> is the data 
frame used in fitting the GLMs.</p>
</dd>
<dt><code>$rpA</code></dt><dd><p>list of data frames giving the proportion of area 
included in the searches (<code>"pinc"</code>) in each ring (<code>"r"</code>). and 
the number of carcasses found <code>"ncarc"</code> in each ring, with search 
class <code>scVar</code> optional. There is also a summary data frame that 
sums the exposures and carcass counts for all turbines across the site. 
The <code>$rpA</code> data frames are used in estimating the probability of 
carcasses falling in the searched area at each turbine, which, in turn 
is used for calculating <code>dwp</code></p>
</dd>
<dt><code>$srad</code></dt><dd><p>the maximum search radius at any of the turbines</p>
</dd>
<dt><code>$ncarc</code></dt><dd><p>vector of the number of carcasses at each turbine with
names equal to the turbine names.</p>
</dd>
<dt><code>$scVar</code></dt><dd><p>name of the search class variable(s) or <code>NULL</code></p>
</dd>
<dt><code>$tcenter</code></dt><dd><p>locations of turbine centers (nturb x 2 matrix) with
UTMs of turbine locations. Column names are <code>X</code> and <code>Y</code>. Row
names are the names of the turbines.</p>
</dd>
</dl>


<hr>
<h2 id='psi_extend'>Simple Extension of a <code>dd</code> Model beyond the Search Radius</h2><span id='topic+psi_extend'></span>

<h3>Description</h3>

<p>Extend a distance model beyond the search radius via multiplication by a fixed,
assumed constant rather than the default normalization used for extensible
models. <code>psi_extend</code> should not be used with <code>psiHat</code> objects that
were calculated with <code>extent = "full"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_extend(psi, fwin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psi_extend_+3A_psi">psi</code></td>
<td>
<p><code><a href="#topic+estpsi">psiHat</a></code> object</p>
</td></tr>
<tr><td><code id="psi_extend_+3A_fwin">fwin</code></td>
<td>
<p>fraction of carcasses assumed to lie within the search radius. If
<code>psi</code> includes <code>psiHat</code> for multiple carcass classes, <code>fwin</code>
should be either a vector with one value for each carcass class so that 
<code>length(psi) = length(fwin)</code> or a scalar (which assumes all carcasses, 
regardless of carcass class, have the same probability of landing outside the
search radius).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>psiHat</code> object extended beyond the search radius
</p>

<hr>
<h2 id='readCarcass'>Import Carcass Observations Locations from Shape Files</h2><span id='topic+readCarcass'></span>

<h3>Description</h3>

<p>Carcass coordiates (x, y) and turbine IDs are read using <code><a href="sf.html#topic+st_read">st_read</a></code> 
and formatted for adding to <code>rings</code> data structures for analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCarcass(file_cod, unitCol = "turbine", quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readCarcass_+3A_file_cod">file_cod</code></td>
<td>
<p>name of the file with carcass observation data. Currently, the
function requires a shape file, which gives the carcass locations on the same
coordinate system that is used for the turbines. The geometry is a simple
features points file, consisting of at least the three mandatory files standard
components (.shp, .shx, .dbf) stored in the same directory. Only the name of the
.shp is required (for example, <code>file_cod = "carcasses.shp"</code>). Other
components are automatically searched for and processed if available.</p>
</td></tr>
<tr><td><code id="readCarcass_+3A_unitcol">unitCol</code></td>
<td>
<p>name of column with turbine IDs. Column name and turbine IDs
must match those of the <code>data_layout</code> and <code>file_turbine</code> used in
the call to <code><a href="#topic+initLayout">initLayout</a></code>.</p>
</td></tr>
<tr><td><code id="readCarcass_+3A_quiet">quiet</code></td>
<td>
<p>boolean for directing the function to print calculation progress
updates and messages to the console. This should be set to <code>FALSE</code> unless
you know clearly why you want to turn off the messaging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>shapeCarcass</code> object, which is a list with <code>$carcasses</code>,
which is a <code>sf</code> representation of the shape file <code>file_cod</code> data;
<code>$unitCol</code>, which is the name of the unit column; and <code>$ncarc</code>, which
is a vector of carcass counts at the turbines listed in <code>unitCol</code>. The
elements of the <code>$ncarc</code> are named by turbines at which they were found.
</p>

<hr>
<h2 id='rmat'>Simple Utility Function Used in Optimizing the GLM</h2><span id='topic+rmat'></span>

<h3>Description</h3>

<p>A simple utility function that is used in fitting a GLM, creating a matrix
of &quot;x&quot; values for use in the polynomial part of a xep-type model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmat(r, distr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmat_+3A_r">r</code></td>
<td>
<p>vector of distances (&gt;=0)</p>
</td></tr>
<tr><td><code id="rmat_+3A_distr">distr</code></td>
<td>
<p>name of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array with <code>length(r)</code> rows and p columns, where p is the number 
of parameters in the glm (including the intercept). The first column is all 
1s, and the remaining columns are functions of r, specifically, log(r), r, 
r^2, r^3, or 1/r, depending on what the distribution requires.
</p>

<hr>
<h2 id='sieve_default'>Test Criteria for Model Selection</h2><span id='topic+sieve_default'></span>

<h3>Description</h3>

<p>Test Criteria for Model Selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sieve_default
</code></pre>


<h3>Format</h3>

<p>A list containing the parameters used for test criteria in model 
selection an <code>ddArray</code> objects. The <code>sieve_default</code> values are used as
a default in <code><a href="#topic+modelFilter">modelFilter</a></code>. If desired, users may create their 
own tests, using <code>sieve_default</code> as a template. The same list elements
must all be present and have the same structure as the defaults, namely:
</p>

<dl>
<dt><code>$aic</code></dt><dd><p>the cutoff for DeltaAIC scores; models with higher scores 
are removed from further consideration. Default is <code>$aic = 10</code></p>
</dd>
<dt><code>$hin</code></dt><dd><p>a boolean to indicate whether or not to use high leverage 
points as a criterion for model selection. Default is <code>$hin = TRUE</code></p>
</dd>
<dt><code>$rtail</code></dt><dd><p>a vector of probabilities that the fitted model must 
exceed at 80, 120, 150, and 200 meters. Default is 
<code>rtail = c(p80 = 0.50, p120 = 0.90, p150 = 0.95, p200 = 0.99)</code>.
Custom test parameters must be a vector probabilities with &quot;p80&quot;, &quot;p120&quot;,
&quot;p150&quot;, and &quot;p200&quot; in the names.</p>
</dd>
<dt><code>ltail</code></dt><dd><p>a vector of probabilities that a fitted model must 
not exceed at 20 and 50 meters. Default is 
<code>ltail = c(p20 = 0.50, p50 = 0.90)</code>. Custom test parameters must be
a vector of probabilities with &quot;p20&quot; and &quot;p50&quot; in <code>names</code>.</p>
</dd>
</dl>


<hr>
<h2 id='sieve_win'>Test Criteria for Model Selection within Search Area</h2><span id='topic+sieve_win'></span>

<h3>Description</h3>

<p>Test Criteria for Model Selection within Search Area
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sieve_win
</code></pre>


<h3>Format</h3>

<p>A list containing the parameters used for test criteria in model 
selection in <code>ddArray</code> objects. The <code>sieve_win</code> values are used 
when either <code>sieve = "win"</code> or <code>extent = "win"</code> in arg list of
<code><a href="#topic+modelFilter">modelFilter</a></code>. The sieve parameters are:
</p>

<dl>
<dt><code>$aic = 10</code></dt><dd><p>the cutoff for DeltaAIC scores; models with higher 
scores are removed from further consideration.</p>
</dd>
<dt><code>$hin = T</code></dt><dd><p>a boolean to indicate whether or not to use high 
leverage points as a criterion for model selection.</p>
</dd>
<dt><code>$rtail</code></dt><dd><p>Appropriate only for extrapolating beyond the search
radius. Automatically disabled via<code>rtail = sieve_default$rtail * 0</code>.</p>
</dd>
<dt><code>ltail</code></dt><dd><p>Appropriate only for extrapolating beyond the search
radius. Automaticall disabled via <code>ltail = sieve_default$ltail * 0 + 1</code></p>
</dd>
</dl>


<hr>
<h2 id='stats'>Display a Tables of Summary Statistics for Distance Distributions</h2><span id='topic+stats'></span><span id='topic+stats.dd'></span><span id='topic+stats.ddArray'></span><span id='topic+stats.ddArraycc'></span>

<h3>Description</h3>

<p>Calculate summary statistics for a single distance distribution 
(<code><a href="#topic+ddFit">dd</a></code> object), an array of distance distributions all fit to the
same data set (<code><a href="#topic+ddFit">ddArray</a></code>), or a list of arrays of distance 
distributions fit for different carcass classes but the same site layout
(<code><a href="#topic+ddFit">ddArraycc</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stats(x, ...)

## S3 method for class 'dd'
stats(x, extent = "full", zrad = 200, ...)

## S3 method for class 'ddArray'
stats(x, extent = "full", zrad = 200, ...)

## S3 method for class 'ddArraycc'
stats(x, extent = "full", zrad = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stats_+3A_x">x</code></td>
<td>
<p>list of models (<code>ddArray</code>) or single model (<code>dd</code>) to calculate summary statistics for</p>
</td></tr>
<tr><td><code id="stats_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="stats_+3A_extent">extent</code></td>
<td>
<p>distributions within searched area (<code>"win"</code>) or extended beyond (<code>"full"</code>)</p>
</td></tr>
<tr><td><code id="stats_+3A_zrad">zrad</code></td>
<td>
<p>maximum distance that carcasses can lie
(only used when glm parameters not extensible to Inf)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list (or list of lists if <code>x</code> is <code>ddArray</code>) with <code>$model</code>
giving the model parameters and <code>$stats</code> giving the median, and 75th,
90th, and 95th quantiles of carcass distances and the estimated probability
a carcass falls within the search area according to each model
</p>

<hr>
<h2 id='subset.shapeCarcass'>Subset Data from an Imported and Formatted Shape File</h2><span id='topic+subset.shapeCarcass'></span><span id='topic+subset.shapeLayout'></span>

<h3>Description</h3>

<p>Subset Data from an Imported and Formatted Shape File
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'shapeCarcass'
subset(x, subset, select, ...)

## S3 method for class 'shapeLayout'
subset(x, subset, select, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.shapeCarcass_+3A_x">x</code></td>
<td>
<p>object to be subsetted</p>
</td></tr>
<tr><td><code id="subset.shapeCarcass_+3A_subset">subset</code></td>
<td>
<p>values to subset by. For example, to subset <code>x</code> to include
only turbines <code>"t1"</code> and <code>"t2"</code>, then <code>subset = c("t1", "t2")</code>.
The name of the column with turbine names is given in <code>select</code>.</p>
</td></tr>
<tr><td><code id="subset.shapeCarcass_+3A_select">select</code></td>
<td>
<p>the name of the column with the values to subset by. For example,
to subset <code>x</code> by turbines names &quot;t1&quot; and &quot;t2&quot; as found in the &quot;turbine&quot;
column in the data, use <code>select = "turbine"</code> and <code>subset = c("t1", "t2")</code>.</p>
</td></tr>
<tr><td><code id="subset.shapeCarcass_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class as <code>x</code>, subsetted to values of <code>select</code>
equal to some element in <code>subset</code>.
</p>

<hr>
<h2 id='xyr'>Locations of All Carcasses in Grid Data</h2><span id='topic+xyr'></span>

<h3>Description</h3>

<p>Locations of All Carcasses in Grid Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyr
</code></pre>


<h3>Format</h3>

<p>matrix with columns x, y, r for all 100 carcasses in the simulation to
generate the carcass data for the xy grid that was searched on road and pad.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
