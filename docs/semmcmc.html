<!DOCTYPE html><html><head><title>Help for package semmcmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {semmcmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcmc'><p>mcmc function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Structural Equation Modeling in Multiple Omics Data
Integration</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-04-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides Markov Chain Monte Carlo (MCMC) routine for the 
             structural equation modelling described in 
             Maity et. al. (2020) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtaa286">doi:10.1093/bioinformatics/btaa286</a>&gt;. This MCMC sampler is 
             useful when one attempts to perform an integrative survival analysis for multiple 
             platforms of the Omics data where the response is time to event and the 
             predictors are different omics expressions for different platforms. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, msm</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>FALSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-12 23:42:13 UTC; MAITYA02</td>
</tr>
<tr>
<td>Author:</td>
<td>Arnab Maity [aut, cre],
  Sang Chan Lee [aut],
  Bani K. Mallick [aut],
  Samsiddhi Bhattacharjee [aut],
  Nidhan K. Biswas [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arnab Maity &lt;arnab.maity@pfizer.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-13 04:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='mcmc'>mcmc function</h2><span id='topic+mcmc'></span>

<h3>Description</h3>

<p>MCMC routine for the strucatural equation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc(ct, u1, u2, X, nburnin = 1000, nmc = 2000, nthin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_+3A_ct">ct</code></td>
<td>
<p>survival response, a <code class="reqn">n*2</code> matrix with first column as response and second column as right censored indicator,
1 is event time and 0 is right censored.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_u1">u1</code></td>
<td>
<p>Matix of predictors from the first platform, dimension <code class="reqn">n*q_1</code></p>
</td></tr>
<tr><td><code id="mcmc_+3A_u2">u2</code></td>
<td>
<p>Matix of predictors from the first platform, dimension <code class="reqn">n*q_2</code></p>
</td></tr>
<tr><td><code id="mcmc_+3A_x">X</code></td>
<td>
<p>Matrix of covariates, dimension <code class="reqn">n*p</code>.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_nburnin">nburnin</code></td>
<td>
<p>number of burnin samples</p>
</td></tr>
<tr><td><code id="mcmc_+3A_nmc">nmc</code></td>
<td>
<p>number of markov chain samples</p>
</td></tr>
<tr><td><code id="mcmc_+3A_nthin">nthin</code></td>
<td>
<p>thinning parameter. Default is 1 (no thinning)</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>pMean.beta.t</code></td>
<td>
</td></tr>
<tr><td><code>pMean.beta.t</code></td>
<td>
</td></tr> 
<tr><td><code>pMean.alpha.t</code></td>
<td>
</td></tr>
<tr><td><code>pMean.alpha.t</code></td>
<td>
</td></tr> 
<tr><td><code>pMean.phi.t</code></td>
<td>
</td></tr> 
<tr><td><code>pMean.phi.t</code></td>
<td>
</td></tr>
<tr><td><code>pMean.alpha.u1</code></td>
<td>
</td></tr>
<tr><td><code>pMean.alpha.u2</code></td>
<td>
</td></tr>
<tr><td><code>pMean.alpha.u2</code></td>
<td>
</td></tr>
<tr><td><code>pMean.phi.u1</code></td>
<td>
</td></tr>
<tr><td><code>pMean.eta1</code></td>
<td>
</td></tr>
<tr><td><code>pMean.eta2</code></td>
<td>
</td></tr>
<tr><td><code>pMean.sigma.t.square</code></td>
<td>
</td></tr>
<tr><td><code>pMean.sigma.u1.square</code></td>
<td>
</td></tr>
<tr><td><code>pMean.sigma.u2.square</code></td>
<td>
</td></tr>
<tr><td><code>alpha.t.samples</code></td>
<td>
</td></tr>
<tr><td><code>phi.t.samples</code></td>
<td>
</td></tr>
<tr><td><code>beta1.t.samples</code></td>
<td>
</td></tr>
<tr><td><code>beta2.t.samples</code></td>
<td>
</td></tr>
<tr><td><code>beta.t.samples</code></td>
<td>
</td></tr>
<tr><td><code>alpha.u1.samples</code></td>
<td>
</td></tr>
<tr><td><code>alpha.u2.samples</code></td>
<td>
</td></tr>
<tr><td><code>phi.u1.samples</code></td>
<td>
</td></tr>
<tr><td><code>phi.u2.samples</code></td>
<td>
</td></tr>
<tr><td><code>eta1.samples</code></td>
<td>
</td></tr>
<tr><td><code>eta2.samples</code></td>
<td>
</td></tr>
<tr><td><code>sigma.t.square.samples</code></td>
<td>
</td></tr>
<tr><td><code>sigma.u1.square.samples</code></td>
<td>
</td></tr>
<tr><td><code>sigma.u2.square.samples</code></td>
<td>
</td></tr>
<tr><td><code>pMean.logt.hat</code></td>
<td>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
</td></tr>
<tr><td><code>WAIC</code></td>
<td>
</td></tr>
</table>


<h3>References</h3>

<p>Maity, A. K., Lee, S. C., Mallick, B. K., &amp; Sarkar, T. R. (2020). 
Bayesian structural equation modeling in multiple omics data integration 
with application to circadian genes. Bioinformatics, 36(13), 3951-3958.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(MASS)  
# for random number from multivariate normal distribution

n &lt;- 100  # number of individuals
p &lt;- 5    # number of variables
q1 &lt;- 20    # dimension of the response
q2 &lt;- 20    # dimension of the response

ngrid   &lt;- 1000
nburnin &lt;- 100
nmc     &lt;- 200
nthin   &lt;- 5
niter   &lt;- nburnin + nmc
effsamp &lt;- (niter - nburnin)/nthin

alpha.tt  &lt;- runif(n = 1, min = -1, max = 1)  # intercept term
alpha.u1t &lt;- runif(n = 1, min = -1, max = 1)  # intercept term
alpha.u2t &lt;- runif(n = 1, min = -1, max = 1)  # intercept term
beta.tt   &lt;- runif(n = p, min = -1, max = 1)  # regression parameter 
gamma1.t  &lt;- runif(n = q1, min = -1, max = 1)
gamma2.t  &lt;- runif(n = q2, min = -1, max = 1)
phi.tt    &lt;- 1 
phi.u1t   &lt;- 1
phi.u2t   &lt;- 1

sigma.tt    &lt;- 1
sigma.u1t   &lt;- 1
sigma.u2t   &lt;- 1
sigma.etat1 &lt;- 1
sigma.etat2 &lt;- 1

x &lt;- mvrnorm(n = n, mu = rep(0, p), Sigma = diag(p))



eta2 &lt;- rnorm(n = 1, mean = 0, sd = sigma.etat2)
eta1 &lt;- rnorm(n = 1, mean = eta2, sd = sigma.etat1)
logt &lt;- rnorm(n = n, mean = alpha.tt + x %*% beta.tt + eta1 * phi.tt, 
sd = sigma.tt)
u1   &lt;- matrix(rnorm(n = n * q1, mean = alpha.u1t + eta1 * phi.u1t, 
sd = sigma.u1t), nrow = n, ncol = q1)
u2   &lt;- matrix(rnorm(n = n * q2, mean = alpha.u2t + eta2 * phi.u2t, 
sd = sigma.u2t), nrow = n, ncol = q2)
logt &lt;- rnorm(n = n, mean = alpha.tt + x %*% beta.tt + u1 %*% gamma1.t + 
u2 %*% gamma2.t, sd = sigma.tt)
  
# Survival time generation
T &lt;- exp(logt)   # AFT model
C &lt;- rgamma(n, shape = 1, rate = 1)  # 50% censor
time &lt;- pmin(T, C)  # observed time is min of censored and true
status = time == T   # set to 1 if event is observed
1 - sum(status)/length(T)   # censoring rate
censor.rate &lt;- 1 - sum(status)/length(T)    # censoring rate
censor.rate
summary(C)
summary(T)
ct &lt;- as.matrix(cbind(time = time, status = status))  # censored time
logt.grid &lt;- seq(from = min(logt) - 1, to = max(logt) + 1, length.out = ngrid)
  
index1 &lt;- which(ct[, 2] == 1)  # which are NOT censored
ct1    &lt;- ct[index1, ]
  
posterior.fit.sem &lt;- mcmc(ct, u1, u2, x, nburnin = nburnin, 
nmc = nmc, nthin = nthin)
  
pMean.beta.t   &lt;- posterior.fit.sem$pMean.beta.t
pMean.alpha.t  &lt;- posterior.fit.sem$pMean.alpha.t
pMean.phi.t    &lt;- posterior.fit.sem$pMean.phi.t
pMean.alpha.u1 &lt;- posterior.fit.sem$pMean.alpha.u1
pMean.alpha.u2 &lt;- posterior.fit.sem$pMean.alpha.u2
pMean.phi.u1   &lt;- posterior.fit.sem$pMean.phi.u1
pMean.phi.u2   &lt;- posterior.fit.sem$pMean.phi.u2
pMean.eta1     &lt;- posterior.fit.sem$pMean.eta1
pMean.eta2     &lt;- posterior.fit.sem$pMean.eta2
pMean.logt.hat &lt;- posterior.fit.sem$posterior.fit.sem

pMean.sigma.t.square  &lt;- posterior.fit.sem$pMean.sigma.t.square
pMean.sigma.u1.square &lt;- posterior.fit.sem$pMean.sigma.u1.square
pMean.sigma.u2.square &lt;- posterior.fit.sem$pMean.sigma.u2.square
pMean.logt.hat        &lt;- posterior.fit.sem$pMean.logt.hat

DIC.sem  &lt;- posterior.fit.sem$DIC
WAIC.sem &lt;- posterior.fit.sem$WAIC
mse.sem  &lt;- mean(pMean.logt.hat[index1] - log(ct1[, 1]))^2

alpha.t.samples         &lt;- posterior.fit.sem$alpha.t.samples
beta1.t.samples         &lt;- posterior.fit.sem$beta1.t.samples
beta2.t.samples         &lt;- posterior.fit.sem$beta2.t.samples
beta.t.samples          &lt;- posterior.fit.sem$beta.t.samples
phi.t.samples           &lt;- posterior.fit.sem$phi.t.samples          
alpha.u1.samples        &lt;- posterior.fit.sem$alpha.u1.samples
alpha.u2.samples        &lt;- posterior.fit.sem$alpha.u2.samples
phi.u1.samples          &lt;- posterior.fit.sem$phi.u1.samples
phi.u2.samples          &lt;- posterior.fit.sem$phi.u2.samples
sigma.t.square.samples  &lt;- posterior.fit.sem$sigma.t.square.samples
sigma.u1.square.samples &lt;- posterior.fit.sem$sigma.u1.square.samples
sigma.u2.square.samples &lt;- posterior.fit.sem$sigma.u2.square.samples
eta1.samples            &lt;- posterior.fit.sem$eta1.samples
eta2.samples            &lt;- posterior.fit.sem$eta2.samples
  
inv.cpo &lt;- matrix(0, nrow = effsamp, ncol = n)  
# this will store inverse cpo values
log.cpo &lt;- rep(0, n)                        # this will store log cpo  
for(iter in 1:effsamp)  # Post burn in
{
  inv.cpo[iter, ] &lt;- 1/(dnorm(ct[, 1], mean = alpha.t.samples[iter] + 
  x %*% beta.t.samples[, iter] + 
                                + eta1.samples[iter] * phi.t.samples[iter], 
                              sd = sqrt(sigma.t.square.samples[iter]))^ct[, 2] * 
                          pnorm(ct[, 1], mean = alpha.t.samples[iter] + 
                          x %*% beta.t.samples[, iter] + 
                                  + eta1.samples[iter] * phi.t.samples[iter], 
                                sd = sqrt(sigma.t.square.samples[iter]), 
                                lower.tail = FALSE)^(1 - ct[, 2]))
}                   # End of iter loop
for (i in 1:n){
  log.cpo[i]   &lt;- -log(mean(inv.cpo[, i]))    
  # You average invcpo[i] over the iterations,
  # then take 1/average and then take log.
  # Hence the negative sign in the log
}
lpml.sem &lt;- sum(log.cpo)
  
  
  
  
DIC.sem
WAIC.sem
mse.sem
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
