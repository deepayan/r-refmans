<!DOCTYPE html><html><head><title>Help for package SOMbrero</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SOMbrero}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SOMbrero-package'><p>Self Organizing Maps Bound to Realize Euclidean and Relational Outputs</p></a></li>
<li><a href='#impute'><p>Impute values from prototype information</p></a></li>
<li><a href='#initGrid'><p>Create an empty grid</p></a></li>
<li><a href='#initSOM'><p>Initialize parameters for the SOM algorithm</p></a></li>
<li><a href='#lesmis'><p>Dataset &quot;Les Misérables&quot;</p></a></li>
<li><a href='#myGrid'><p>Methods for 'myGrid' objects.</p></a></li>
<li><a href='#plot.somRes'><p>Plot a <code>somRes</code> class object</p></a></li>
<li><a href='#predict.somRes'><p>Predict the classification of a new observation</p></a></li>
<li><a href='#presidentielles2002'><p>2002 French presidential election data set</p></a></li>
<li><a href='#projectIGraph'><p>Compute the projection of a graph on a grid</p></a></li>
<li><a href='#protoDist'><p>Compute distances between prototypes</p></a></li>
<li><a href='#quality'><p>Compute SOM algorithm quality criteria</p></a></li>
<li><a href='#sombreroGUI'><p>Graphical Web User Interface for SOMbrero</p></a></li>
<li><a href='#somRes.plotting'><p>Plotting <code>somRes</code> results</p></a></li>
<li><a href='#superClass'><p>Create super-clusters from SOM results</p></a></li>
<li><a href='#trainSOM'><p>Run the SOM algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>SOM Bound to Realize Euclidean and Relational Outputs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-24</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathalie Vialaneix &lt;nathalie.vialaneix@inrae.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The stochastic (also called on-line) version of the Self-Organising
             Map (SOM) algorithm is provided. Different versions of the
             algorithm are implemented, for numeric and relational data and for
             contingency tables as described, respectively, in Kohonen (2001)
             &lt;isbn:3-540-67921-9&gt;, Olteanu &amp; Villa-Vialaneix (2005)
             &lt;<a href="https://doi.org/10.1016%2Fj.neucom.2013.11.047">doi:10.1016/j.neucom.2013.11.047</a>&gt; and Cottrell et al (2004)
             &lt;<a href="https://doi.org/10.1016%2Fj.neunet.2004.07.010">doi:10.1016/j.neunet.2004.07.010</a>&gt;. The package also contains many
             plotting features (to help the user interpret the results), can 
             handle (and impute) missing values and is delivered with a 
             graphical user interface based on 'shiny'.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tuxette/SOMbrero/issues">https://github.com/tuxette/SOMbrero/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://sombrero.clementine.wf/">http://sombrero.clementine.wf/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), igraph (&ge; 1.0), markdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>scatterplot3d, shiny, grDevices, graphics, stats, ggplot2,
ggwordcloud, metR, interp, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, rmarkdown, knitr, hexbin, shinycssloaders, shinyBS,
shinyjs, shinyjqui</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 20:48:27 UTC; nathalie</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathalie Vialaneix
    <a href="https://orcid.org/0000-0003-1156-0639"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Elise Maigne [aut],
  Jerome Mariette [aut],
  Madalina Olteanu [aut],
  Fabrice Rossi [aut],
  Laura Bendhaiba [ctb],
  Julien Boelaert [ctb]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-25 22:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='SOMbrero-package'>Self Organizing Maps Bound to Realize Euclidean and Relational Outputs</h2><span id='topic+SOMbrero-package'></span><span id='topic+SOMbrero'></span>

<h3>Description</h3>

<p>This package implements the stochastic (also called on-line) 
Self-Organizing Map (SOM) algorithms for numeric and relational data.
</p>
<p>It is based on a grid (see <code><a href="#topic+initGrid">initGrid</a></code>), which is part of the 
parameters given to the algorithm (see <code><a href="#topic+initSOM">initSOM</a></code> and 
<code><a href="#topic+trainSOM">trainSOM</a></code>). Many graphs can help you with the results (see 
<code><a href="#topic+plot.somRes">plot.somRes</a></code>).
</p>
<p>The version of the SOM algorithm implemented in this package is the 
stochastic version.
</p>
<p>Several variants able to handle non-vectorial data are also implemented in 
their stochastic versions: <code>type = "korresp"</code> for contingency tables, as 
described in Cottrell et al. (2004) (with the observation weights defined in 
Cottrell and Letrémy, 2005a) and <code>type = "relational"</code> for dissimilarity 
data, as described in Olteanu and Villa-Vialaneix (2015a) with the fast 
implementation of Mariette <em>et al.</em> (2017). A special focus has been put 
on representing graphs, as described in Olteanu and Villa-Vialaneix (2015b).
</p>
<p>In addition, the numeric version of the algorithm handles missing values: 
missing entries are not used during training but the resulting map can be 
used to fill missing entries (using the entry of the corresponding 
prototype). The method is taken from Cottrell and Letrémy (2005b).
</p>


<h3>Author(s)</h3>

<p>Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a><br />
Élise Maigné <a href="mailto:elise.maigne@inrae.fr">elise.maigne@inrae.fr</a><br />
Jérome Mariette <a href="mailto:jerome.mariette@inrae.fr">jerome.mariette@inrae.fr</a><br />
Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Fabrice Rossi <a href="mailto:fabrice.rossi@apiacoa.org">fabrice.rossi@apiacoa.org</a><br />
Laura Bendhaïba <a href="mailto:laurabendhaiba@gmail.com">laurabendhaiba@gmail.com</a><br />
Julien Boelaert <a href="mailto:julien.boelaert@gmail.com">julien.boelaert@gmail.com</a><br /> <br />
Maintainer: Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Kohonen T. (2001) <em>Self-Organizing Maps</em>. Berlin/Heidelberg:
Springer-Verlag, 3rd edition.
</p>
<p>Cottrell M., Ibbou S., Letrémy P. (2004) SOM-based algorithms for qualitative
variables. <em>Neural Networks</em>, <strong>17</strong>, 1149-1167.
</p>
<p>Cottrell M., Letrémy P. (2005a) How to use the Kohonen algorithm to 
simultaneously analyse individuals in a survey. <em>Neurocomputing</em>, 
<strong>21</strong>, 119-138.
</p>
<p>Cottrell M., Letrémy P. (2005b) Missing values: processing with the Kohonen 
algorithm. <em>Proceedings of Applied Stochastic Models and Data Analysis
(ASMDA 2005)</em>, 489-496.
</p>
<p>Letrémy P. (2005) Programmes basés sur l'algorithme de Kohonen et dediés à
l'analyse des données. SAS/IML programs for 'korresp'.
</p>
<p>Mariette J., Rossi F., Olteanu M., Villa-Vialaneix N. (2017) Accelerating 
stochastic kernel SOM. In: M. Verleysen, <em>XXVth European Symposium on 
Artificial Neural Networks, Computational Intelligence and Machine Learning 
(ESANN 2017)</em>, i6doc, Bruges, Belgium, 269-274.
</p>
<p>Olteanu M., Villa-Vialaneix N. (2015a) On-line relational and multiple 
relational SOM. <em>Neurocomputing</em>, <strong>147</strong>, 15-30. 
</p>
<p>Olteanu M., Villa-Vialaneix N. (2015b) Using SOMbrero for clustering and 
visualizing graphs. <em>Journal de la Société Française de Statistique</em>,
<strong>156</strong>, 95-119.
</p>
<p>Rossi F. (2013) yasomi: Yet Another Self-Organising Map Implementation. R 
package, version 0.3. <a href="https://github.com/fabrice-rossi/yasomi">https://github.com/fabrice-rossi/yasomi</a>
</p>
<p>Villa-Vialaneix N. (2017) Stochastic self-organizing map variants with the R
package SOMbrero. In: J.C. Lamirel, M. Cottrell, M. Olteanu, <em>12th 
International Workshop on Self-Organizing Maps and Learning Vector 
Quantization, Clustering and Data Visualization (Proceedings of WSOM 2017)</em>, 
IEEE, Nancy, France.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initGrid">initGrid</a></code>, <code><a href="#topic+trainSOM">trainSOM</a></code>, 
<code><a href="#topic+plot.somRes">plot.somRes</a></code> and <code><a href="#topic+sombreroGUI">sombreroGUI</a></code>.
</p>

<hr>
<h2 id='impute'>Impute values from prototype information</h2><span id='topic+impute'></span><span id='topic+impute.somRes'></span>

<h3>Description</h3>

<p>Impute values by replacing missing entries with the 
corresponding assigned prototype entries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_+3A_object">object</code></td>
<td>
<p>a <code>somRes</code> object.</p>
</td></tr>
<tr><td><code id="impute_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Imputed matrix as in Cottrell and Letrémy, (2005)
</p>


<h3>Author(s)</h3>

<p>Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Cottrell M., Letrémy P. (2005) Missing values: processing with the Kohonen 
algorithm. <em>Proceedings of Applied Stochastic Models and Data Analysis
(ASMDA 2005)</em>, 489-496.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainSOM">trainSOM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run trainSOM algorithm on the iris data with 500 iterations
set.seed(1505)
missings &lt;- cbind(sample(1:150, 50, replace = TRUE),
                  sample(1:4, 50, replace = TRUE))
x.data &lt;- as.matrix(iris[, 1:4])
x.data[missings] &lt;- NA
iris.som &lt;- trainSOM(x.data = x.data)
iris.som
impute(iris.som)
</code></pre>

<hr>
<h2 id='initGrid'>Create an empty grid</h2><span id='topic+initGrid'></span>

<h3>Description</h3>

<p>Create an empty (square) grid equipped with topology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initGrid(
  dimension = c(5, 5),
  topo = c("square", "hexagonal"),
  dist.type = c("euclidean", "maximum", "manhattan", "canberra", "minkowski", "letremy")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initGrid_+3A_dimension">dimension</code></td>
<td>
<p>a 2-dimensional vector giving the dimensions (width, length)
of the grid</p>
</td></tr>
<tr><td><code id="initGrid_+3A_topo">topo</code></td>
<td>
<p>topology of the grid. Accept values <code>"square"</code> (Default) or
<code>"hexagonal"</code>.</p>
</td></tr>
<tr><td><code id="initGrid_+3A_dist.type">dist.type</code></td>
<td>
<p>distance type that defines the topology of the grid (see
'Details'). Default to <code>"euclidean"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The units (neurons) of the grid are positionned at coordinates 
(1,1), (1,2), (1,3), ..., (2,1), (2,2), ..., for the <code>square</code> topology.
The topology of the map is defined by a distance based on those coordinates, 
that can be one of <code>"euclidean"</code>, <code>"maximum"</code>, <code>"manhattan"</code>, 
<code>"canberra"</code>, <code>"minkowski"</code>, <code>"letremy"</code>, where the first 5 
ones correspond to distance methods implemented in <code><a href="stats.html#topic+dist">dist</a></code> and 
<code>"letremy"</code> is the distance of the original implementation by Patrick 
Letrémy that switches between <code>"maximum"</code> and <code>"euclidean"</code> during
the training.
</p>


<h3>Value</h3>

<p>an object of class <code>myGrid</code> with the following entries:
</p>

<ul>
<li><p><code>coord</code> 2-column matrix with x and y coordinates of the grid 
units
</p>
</li>
<li><p><code>topo</code> topology of the grid;
</p>
</li>
<li><p><code>dim</code> dimensions of the grid (width corresponds to x 
coordinates)
</p>
</li>
<li><p><code>dist.type</code> distance type that defines the topology of the 
grid.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Élise Maigné <a href="mailto:elise.maigne@inrae.fr">elise.maigne@inrae.fr</a><br />
Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Letrémy P. (2005) Programmes basés sur l'algorithme de Kohonen 
et dédiés à l'analyse des données. SAS/IML programs for 'korresp'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.myGrid">plot.myGrid</a></code> for plotting the grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>initGrid()
initGrid(dimension=c(5, 7), dist.type = "maximum")

</code></pre>

<hr>
<h2 id='initSOM'>Initialize parameters for the SOM algorithm</h2><span id='topic+initSOM'></span><span id='topic+summary.paramSOM'></span><span id='topic+print.paramSOM'></span><span id='topic+paramSOM-class'></span>

<h3>Description</h3>

<p>The <code>initSOM</code> function returns a <code>paramSOM</code> class object that
contains the parameters needed to run the SOM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initSOM(
  dimension = c(5, 5),
  topo = c("square", "hexagonal"),
  radius.type = c("gaussian", "letremy"),
  dist.type = switch(match.arg(radius.type), letremy = "letremy", gaussian = "euclidean"),
  type = c("numeric", "relational", "korresp"),
  mode = c("online"),
  affectation = c("standard", "heskes"),
  maxit = 500,
  nb.save = 0,
  verbose = FALSE,
  proto0 = NULL,
  init.proto = switch(type, numeric = "random", relational = "obs", korresp = "random"),
  scaling = switch(type, numeric = "unitvar", relational = "none", korresp = "chi2"),
  eps0 = 1
)

## S3 method for class 'paramSOM'
print(x, ...)

## S3 method for class 'paramSOM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initSOM_+3A_dimension">dimension</code></td>
<td>
<p>Vector of two integer points corresponding to the x 
dimension and the y dimension of the <code>myGrid</code> class object. Default 
values are: <code>(5,5)</code>. Other data-driven defaults are set by function 
<code>trainSOM</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_topo">topo</code></td>
<td>
<p>The topology to be used to build the grid of the <code>myGrid</code> 
class object. Accept values <code>"square"</code> (Default) or <code>"hexagonal"</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_radius.type">radius.type</code></td>
<td>
<p>The neighborhood type. Default value is 
<code>"gaussian"</code>, which corresponds to a Gaussian neighborhood. The 
annealing of the neighborhood during the training step is similar to the one
implemented in <a href="https://github.com/fabrice-rossi/yasomi">yasomi</a>. The 
alternative value corresponds to an piecewise linear neighborhood as 
implemented by Patrick Letrémy in his SAS scripts.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_dist.type">dist.type</code></td>
<td>
<p>The neighborhood relationship on the grid. One of 
<code>c("letremy", "euclidean", "maximum", "manhattan", "canberra", "minkowski")</code>. 
When <code>radius.type</code> is <code>letremy</code>, default value is <code>letremy</code> 
which is the original implementation by Patrick Letrémy. When 
<code>radius.type</code> is <code>gaussian</code>, default value is <code>euclidean</code>. The
other possible values are passed to <code>method</code> in function 
<code><a href="stats.html#topic+dist">dist</a></code>. <code>dist.type = "letremy"</code> is not permitted with 
<code>radius.type = "gaussian"</code>. Only <code>euclidian</code> is allowed with 
hexagonal topology.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_type">type</code></td>
<td>
<p>The SOM algorithm type. Possible values are: <code>numeric</code> 
(default value), <code>korresp</code> and <code>relational</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_mode">mode</code></td>
<td>
<p>The SOM algorithm mode. Default value is <code>online</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_affectation">affectation</code></td>
<td>
<p>The SOM affectation type. Default value is <code>standard</code>
which corresponds to a hard affectation. Alternative is <code>heskes</code> which 
corresponds to Heskes's soft affectation.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations to be done during the SOM 
algorithm process. Default value is <code>500</code>. Other data-driven defaults
are set by function <code>trainSOM</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_nb.save">nb.save</code></td>
<td>
<p>The number of intermediate back-ups to be done during the 
algorithm process. Default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_verbose">verbose</code></td>
<td>
<p>The boolean value which activates the verbose mode during the
SOM algorithm process. Default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_proto0">proto0</code></td>
<td>
<p>The initial prototypes. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_init.proto">init.proto</code></td>
<td>
<p>The method to be used to initialize the prototypes, which
may be <code>"random"</code> (randomization), <code>"obs"</code> (each prototype is 
assigned a random observation) or <code>"pca"</code>. In <code>pca</code> the prototypes
are initialized to the observations closest to a grid along the two first 
principal components of the data (<code>numeric</code> case) or along a
two-dimensional multidimensional scaling (<code>relational</code> case, equivalent
to a <code>relational</code> PCA). Default value is <code>random</code> for the
<code>numeric</code> and <code>korresp</code> types, and <code>obs</code> for the  
<code>relational</code> type. <code>pca</code> is not available for <code>korresp</code> SOM.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_scaling">scaling</code></td>
<td>
<p>The type of data pre-processing. For <code>numeric</code> SOM, 
possibilities are <code>unitvar</code> (data are centered and scaled; this 
is the default value for a <code>numeric</code> SOM), <code>none</code> (no 
pre-processing), and <code>center</code> (data are centered but not scaled). For 
<code>korresp</code> SOM, the only available value is <code>chi2</code>. For 
<code>relational</code> SOM, possibilities are <code>none</code> (no pre-processing, 
default value for <code>relational</code> SOM) and <code>cosine</code>. This last one 
first turns the dissimilarity into a similarity using the suggestion in (Lee 
and Verleysen, 2007). Then, a cosine normalization as described in (Ben-Hur 
and Weston, 2010) is applied to the kernel, that is finally turned back into 
its induced distance. For further details on this processing, have a look at
the corresponding documentation in the directory &quot;doc&quot; of the package's 
installation directory.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_eps0">eps0</code></td>
<td>
<p>The scaling value for the stochastic gradient descent step in the
prototypes' update. The scaling value for the stochastic gradient descent 
step is equal to 
<code class="reqn">\frac{0.3\epsilon_0}{1+0.2t/\textrm{dim}}</code> where
<code class="reqn">t</code> is the current step number and <code class="reqn">\textrm{dim}</code> is the grid
dimension (width multiplied by height).</p>
</td></tr>
<tr><td><code id="initSOM_+3A_x">x</code></td>
<td>
<p>an object of class <code>paramSOM</code>.</p>
</td></tr>
<tr><td><code id="initSOM_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="initSOM_+3A_object">object</code></td>
<td>
<p>an object of class <code>paramSOM</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>initSOM</code> function returns an object of class 
<code>paramSOM</code> which is a list of the parameters passed to the 
<code>initSOM</code> function, plus the default parameters for the ones not 
specified by the user.
</p>


<h3>Author(s)</h3>

<p>Élise Maigné <a href="mailto:elise.maigne@inrae.fr">elise.maigne@inrae.fr</a><br />
Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Ben-Hur A., Weston J. (2010) A user's guide to support vector machine. In:
<em>Data Mining Techniques for the Life Sciences</em>, Springer-Verlag, 
223-239.
</p>
<p>Heskes T. (1999) Energy functions for self-organizing maps. In: <em>Kohonen
Maps</em>, Oja E., Kaski S. (Eds.), Elsevier, 303-315.
</p>
<p>Lee J., Verleysen M. (2007) <em>Nonlinear Dimensionality Reduction</em>.
Information Science and Statistics series, Springer.
</p>
<p>Letrémy P. (2005) Programmes basés sur l'algorithme de Kohonen et dediés à
l'analyse des données. SAS/IML programs for 'korresp'.
</p>
<p>Rossi F. (2013) yasomi: Yet Another Self-Organising Map Implementation. R 
package, version 0.3. <a href="https://github.com/fabrice-rossi/yasomi">https://github.com/fabrice-rossi/yasomi</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+initGrid">initGrid</a></code> for creating a SOM prior structure 
(grid).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a default 'paramSOM' class object
default.paramSOM &lt;- initSOM()
summary(default.paramSOM)
</code></pre>

<hr>
<h2 id='lesmis'>Dataset &quot;Les Misérables&quot;</h2><span id='topic+lesmis'></span><span id='topic+dissim.lesmis'></span>

<h3>Description</h3>

<p>This dataset contains the coappearance network (igraph object) 
of characters in the novel Les Misérables (written by the French writter 
Victor Hugo).
</p>


<h3>Format</h3>

<p><code>lesmis</code> is an <code><a href="igraph.html#topic+igraph">igraph</a></code> object. Its vertices
are the characters of the novel and an edge indicates that the two characters
appear together in the same chapter of the novel, at least once. Vertex 
attributes for this graph are <span class="option">id</span>, a vertex number between 1 and 77, 
and <span class="option">label</span>, the character's name. The edge attribute <span class="option">value</span> 
gives the number of co-appearances between the two characters afferent to the
edge (the <code><a href="igraph.html#topic+igraph">igraph</a></code> can thus be made a weighted graph 
using this attribute). Finally, a graph attribute <span class="option">layout</span> is used to 
provide a layout (generated with the <code><a href="igraph.html#topic+igraph">igraph</a></code> function 
<code><a href="igraph.html#topic+layout.fruchterman.reingold">layout_with_fr</a></code>) for 
visualizing the graph.
</p>
<p><code>dissim.lesmis</code> is a dissimilarity matrix computed with the function 
<code><a href="igraph.html#topic+shortest_paths">shortest_paths</a></code> and containing the length of the 
shortest paths between pairs of nodes.
</p>


<h3>Details</h3>

<p>Les Misérables is a French historical novel, written by Victor Hugo 
and published in 1862. The co-appearance network has been extracted by D.E.
Knuth (1993).
</p>


<h3>References</h3>

<p>Hugo V. (1862) <em>Les Miserables</em>.
</p>
<p>Knuth D.E. (1993) <em>The Stanford GraphBase: A Platform for Combinatorial 
Computing</em>. Reading (MA): Addison-Wesley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lesmis)
## Not run: 
summary(lesmis)
plot(lesmis,vertex.size=0)
## End(Not run)
</code></pre>

<hr>
<h2 id='myGrid'>Methods for 'myGrid' objects.</h2><span id='topic+myGrid'></span><span id='topic+print.myGrid'></span><span id='topic+summary.myGrid'></span><span id='topic+plot.myGrid'></span><span id='topic+myGrid-class'></span>

<h3>Description</h3>

<p>Methods for the result of <code><a href="#topic+initGrid">initGrid</a></code>
(<code>myGrid</code> object)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'myGrid'
print(x, ...)

## S3 method for class 'myGrid'
summary(object, ...)

## S3 method for class 'myGrid'
plot(x, show.names = TRUE, names = 1:prod(x$dim), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myGrid_+3A_x">x</code></td>
<td>
<p><code>myGrid</code> object</p>
</td></tr>
<tr><td><code id="myGrid_+3A_...">...</code></td>
<td>
<p>Further arguments to the <code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
<tr><td><code id="myGrid_+3A_object">object</code></td>
<td>
<p><code>myGrid</code> object</p>
</td></tr>
<tr><td><code id="myGrid_+3A_show.names">show.names</code></td>
<td>
<p>Whether the cluster names must be printed in center of
the grid or not. Default to <code>TRUE</code> (names not displayed).</p>
</td></tr>
<tr><td><code id="myGrid_+3A_names">names</code></td>
<td>
<p>If <code>show.names = TRUE</code>, values of the names to 
display. Default to the cluster number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>myGrid</code> class has the following entries:
</p>

<ul>
<li><p><code>coord</code> 2-column matrix with x and y coordinates of the grid 
units
</p>
</li>
<li><p><code>topo</code> topology of the grid;
</p>
</li>
<li><p><code>dim</code> dimensions of the grid (width corresponds to x 
coordinates)
</p>
</li>
<li><p><code>dist.type</code> distance type that defines the topology of the 
grid.
</p>
</li></ul>

<p>During plotting, the color filling process uses the coordinates of the object
<code>x</code> included in <code>x$coord</code>.
</p>


<h3>Author(s)</h3>

<p>Élise Maigné <a href="mailto:elise.maigne@inrae.fr">elise.maigne@inrae.fr</a><br />
Madalina Olteanu, <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix, <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+initGrid">initGrid</a></code> to define a <code>myGrid</code> class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating grid
a.grid &lt;- initGrid(dimension=c(5,5), topo="square", dist.type="maximum")

# plotting grid
# without any color specification
plot(a.grid)
# generating colors from rainbow() function
my.colors &lt;- grDevices::rainbow(5*5)
plot(a.grid) + ggplot2::scale_fill_manual(values = my.colors)
</code></pre>

<hr>
<h2 id='plot.somRes'>Plot a <code>somRes</code> class object</h2><span id='topic+plot.somRes'></span>

<h3>Description</h3>

<p>Produce graphics to help interpreting a <code>somRes</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'somRes'
plot(
  x,
  what = c("obs", "prototypes", "energy", "add"),
  type = switch(what, obs = "hitmap", prototypes = "color", add = "pie", energy =
    "energy"),
  variable = NULL,
  my.palette = NULL,
  is.scaled = if (x$parameters$type == "numeric") TRUE else FALSE,
  show.names = TRUE,
  names = if (what != "energy") switch(type, graph = 1:prod(x$parameters$the.grid$dim),
    1:prod(x$parameters$the.grid$dim)) else NULL,
  proportional = TRUE,
  pie.graph = FALSE,
  pie.variable = NULL,
  s.radius = 1,
  view = if (x$parameters$type == "korresp") "r" else NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.somRes_+3A_x">x</code></td>
<td>
<p>A <code>somRes</code> class object.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_what">what</code></td>
<td>
<p>What you want to plot. Either the observations (<code>obs</code>, 
default case), the evolution of energy (<code>energy</code>), the prototypes 
(<code>prototypes</code>) or an additional variable (<code>add</code>).</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_type">type</code></td>
<td>
<p>Further argument indicating which type of chart you want to have.
Choices depend on the value of <code>what</code> (<code>what="energy"</code> has no
<code>type</code> argument). Default values are <code>"hitmap"</code> for <code>obs</code>, 
<code>"color"</code> for <code>prototypes</code> and <code>"pie"</code> for <code>add</code>. See
section &ldquo;Details&rdquo; below for further details.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_variable">variable</code></td>
<td>
<p>Either the variable to be used for <code>what="add"</code> or the 
index of the variable of the data set to consider. For <code>type="boxplot"</code>, 
the default value is the sequence from 1 to the minimum between 5 and the 
number of columns of the data set. In all other cases, default value is 1. 
See <code><a href="#topic+somRes.plotting">somRes.plotting</a></code> for further details.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_my.palette">my.palette</code></td>
<td>
<p>A vector of colors. If omitted, predefined palettes are 
used, depending on the plot case. This argument is used for the following
combinations: all <code>"color"</code> types and <code>"prototypes"/"poly.dist"</code>.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_is.scaled">is.scaled</code></td>
<td>
<p>A boolean indicating whether values should be scaled prior 
to plotting or not. Default value is <code>TRUE</code> when <code>type="numeric"</code> 
and <code>FALSE</code> in the other cases.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_show.names">show.names</code></td>
<td>
<p>Boolean used to indicate whether each neuron should have a
title or not, if relevant. Default to <code>TRUE</code>. It is feasible on the 
following cases: all <code>"color"</code>, <code>"lines"</code>, <code>"meanline"</code>, 
<code>"barplot"</code>, <code>"boxplot"</code>, <code>"names"</code> types, <code>"add"/"pie"</code>, 
<code>"prototypes"/"umatrix"</code>, <code>"prototypes"/"poly.dist"</code> and 
<code>"add"/"words"</code>.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_names">names</code></td>
<td>
<p>The names to be printed for each neuron if 
<code>show.names=TRUE</code>. Default to a number which identifies the neuron.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_proportional">proportional</code></td>
<td>
<p>Boolean used when <code>what="add"</code> and 
<code>type="pie"</code>. It indicates if the pies should be proportional to the 
number of observations in the class. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_pie.graph">pie.graph</code></td>
<td>
<p>Boolean used when <code>what="add"</code> and <code>type="graph"</code>. 
It indicates if the vertices should be pies or not.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_pie.variable">pie.variable</code></td>
<td>
<p>The variable needed to plot the pies when 
<code>what="add"</code>, <code>type="graph"</code> and argument <code>pie.graph=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_s.radius">s.radius</code></td>
<td>
<p>The size of the pies to be plotted (maximum size when 
<code>proportional=TRUE</code>) for <code>what="add"</code>, <code>type="graph"</code> and 
<code>pie.graph=TRUE</code>. The default value is <code>0.9</code>.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_view">view</code></td>
<td>
<p>Used only when the algorithm's type is <code>"korresp"</code>. It
indicates whether rows (<code>"r"</code>) or columns (<code>"c"</code>) must be drawn.</p>
</td></tr>
<tr><td><code id="plot.somRes_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the underlined plot function
(which can be <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="graphics.html#topic+barplot">barplot</a></code>, <code><a href="graphics.html#topic+pie">pie</a></code>...
depending on <code>type</code>; see <code><a href="#topic+somRes.plotting">somRes.plotting</a></code> for further
details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+somRes.plotting">somRes.plotting</a></code> for further details and more 
examples.
</p>


<h3>Author(s)</h3>

<p>Élise Maigné &lt;elise.maigne@inrae.fr&gt;<br />
Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainSOM">trainSOM</a></code> to run the SOM algorithm, that returns a 
<code>somRes</code> class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># run the SOM algorithm on the numerical data of 'iris' data set
iris.som &lt;- trainSOM(x.data = iris[, 1:4], nb.save = 2)
# plots
# on energy
plot(iris.som, what = "energy") 
# on observations
plot(iris.som, what = "obs", type = "lines")
# on prototypes
plot(iris.som, what = "prototypes", type = "3d", variable = "Sepal.Length")
# on an additional variable: the flower species
plot(iris.som, what = "add", type = "pie", variable = iris$Species)
</code></pre>

<hr>
<h2 id='predict.somRes'>Predict the classification of a new observation</h2><span id='topic+predict.somRes'></span>

<h3>Description</h3>

<p>Predict the neuron where a new observation is classified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'somRes'
predict(object, x.new = NULL, ..., radius = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.somRes_+3A_object">object</code></td>
<td>
<p>a <code>somRes</code> object.</p>
</td></tr>
<tr><td><code id="predict.somRes_+3A_x.new">x.new</code></td>
<td>
<p>a new observation (optional). Default values is NULL which
corresponds to performing prediction on the training dataset.</p>
</td></tr>
<tr><td><code id="predict.somRes_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="predict.somRes_+3A_radius">radius</code></td>
<td>
<p>current radius used to perform soft affectation (when 
<code>affectation = "heskes"</code>, see <code><a href="#topic+initSOM">initSOM</a></code> for further details
about Heskes' soft affectation). Default value is <span class="option">0</span>, 
which corresponds to a hard affectation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of columns of the new observations (or its length if only 
one observation is provided) must match the number of columns of the data set
given to the SOM algorithm (see <code><a href="#topic+trainSOM">trainSOM</a></code>).
</p>


<h3>Value</h3>

<p><code>predict.somRes</code> returns the number of the neuron to which the 
new observation is assigned (i.e., neuron with the closest prototype).
</p>
<p>When the algorithm's type is <code>"korresp"</code>, <code>x.new</code> must be the 
original contingency table passed to the algorithm.
</p>


<h3>Author(s)</h3>

<p>Jérome Mariette <a href="mailto:jerome.mariette@inrae.fr">jerome.mariette@inrae.fr</a><br />
Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Fabrice Rossi <a href="mailto:fabrice.rossi@apiacoa.org">fabrice.rossi@apiacoa.org</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainSOM">trainSOM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2343)
my.som &lt;- trainSOM(x.data = iris[-100, 1:4], dimension = c(5, 5))
predict(my.som, iris[100, 1:4])
</code></pre>

<hr>
<h2 id='presidentielles2002'>2002 French presidential election data set</h2><span id='topic+presidentielles2002'></span>

<h3>Description</h3>

<p>This data set provides the number of votes at the first round of
the 2002 French presidential election for each of the 16 candidates for 106
administrative districts called &quot;Départements&quot;.
</p>


<h3>Format</h3>

<p><code>presidentielles2002</code> is a data frame of 106 rows (the French
administrative districts called &quot;Départements&quot;) and 16 columns (the 
candidates).
</p>


<h3>Source</h3>

<p>The data are provided by the French ministry &quot;Ministère de 
l'Intérieur&quot;. The original data can be downloaded at
<a href="https://www.interieur.gouv.fr/Elections/Les-resultats/Presidentielles">https://www.interieur.gouv.fr/Elections/Les-resultats/Presidentielles</a> 
(2002 élections and &quot;Résultats par départements&quot;).
</p>


<h3>References</h3>

<p>The 2002 French presidential election consisted of two rounds. 
The second round attracted a greater than usual amount of international 
attention because of far-right candidate Le Pen's unexpected victory over 
Socialist candidate Lionel Jospin. The event is known because, on the one 
hand, the number of candidates was unusually high (16) and, on the other 
hand, because the polls had failed to predict that Jean-Marie Le Pen would be
on the second round.
</p>
<p>Further comments at
<a href="https://en.wikipedia.org/wiki/2002_French_presidential_election">https://en.wikipedia.org/wiki/2002_French_presidential_election</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(presidentielles2002)
apply(presidentielles2002, 2, sum)
</code></pre>

<hr>
<h2 id='projectIGraph'>Compute the projection of a graph on a grid</h2><span id='topic+projectIGraph'></span><span id='topic+projectIGraph.somRes'></span>

<h3>Description</h3>

<p>Compute the projection of a graph, provided as an 
<code><a href="igraph.html#topic+igraph">igraph</a></code> object, on the grid of the <code>somRes</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projectIGraph(object, init.graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projectIGraph_+3A_object">object</code></td>
<td>
<p>a <code>somRes</code> object.</p>
</td></tr>
<tr><td><code id="projectIGraph_+3A_init.graph">init.graph</code></td>
<td>
<p>an <a href="igraph.html#topic+igraph">igraph</a> whose number of vertices is equal
to the clustering length of the <code>somRes</code> object.</p>
</td></tr>
<tr><td><code id="projectIGraph_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is an <code><a href="igraph.html#topic+igraph">igraph</a></code> which vertexes are the
clusters (the clustering is thus understood as a vertex clustering) and the 
edges are the counts of edges in the original graph between two vertices
corresponding to the two clusters in the projected graph or, if 
<code>init.graph</code> is a weighted graph, the sum of the weights between the 
pairs of vertices corresponding to the two clusters.
</p>
<p>The resulting igraph object's attributes are: </p>

<ul>
<li><p> the graph attribute <code>layout</code> which provides the layout of the 
projected graph according to the grid of the SOM;
</p>
</li>
<li><p> the vertex attributes <code>name</code> and <code>size</code> which, respectively
are the vertex number on the grid and the number of vertexes included in 
the corresponding cluster;
</p>
</li>
<li><p> the edge attribute <code>weight</code> which gives the number of edges (or 
the sum of the weights) between the vertexes of the two corresponding 
clusters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Olteanu M., Villa-Vialaneix N. (2015) Using SOMbrero for clustering and 
visualizing graphs. <em>Journal de la Société Française de Statistique</em>,
<strong>156</strong>, 95-119.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+projectIGraph.somSC">projectIGraph.somSC</a></code> which uses the results of a 
super-clustering to obtain another projected graph. <code><a href="#topic+plot.somRes">plot.somRes</a></code> 
with the option <code>type="graph"</code> or <code><a href="#topic+plot.somSC">plot.somSC</a></code> with the 
option <code>type="projgraph"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lesmis)
set.seed(7383)
mis.som &lt;- trainSOM(x.data=dissim.lesmis, type="relational", nb.save=10)
proj.lesmis &lt;- projectIGraph(mis.som, lesmis)
## Not run: plot(proj.lesmis)
</code></pre>

<hr>
<h2 id='protoDist'>Compute distances between prototypes</h2><span id='topic+protoDist'></span><span id='topic+protoDist.somRes'></span>

<h3>Description</h3>

<p>Compute distances, either between all prototypes 
(<code>mode = "complete"</code>) or only between prototypes' neighbours 
(<code>mode = "neighbors"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protoDist(object, mode = c("complete", "neighbors"), radius = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protoDist_+3A_object">object</code></td>
<td>
<p>a <code>somRes</code> object.</p>
</td></tr>
<tr><td><code id="protoDist_+3A_mode">mode</code></td>
<td>
<p>Specifies which distances should be computed (default to 
<code>"complete"</code>).</p>
</td></tr>
<tr><td><code id="protoDist_+3A_radius">radius</code></td>
<td>
<p>Radius used to fetch the neighbors (default to 1). The distance
used to compute the neighbors is the Euclidean distance.</p>
</td></tr>
<tr><td><code id="protoDist_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>mode="complete"</code>, distances between all prototypes are
computed. When <code>mode="neighbors"</code>, distances are computed only between 
the prototypes and their neighbors. If the data were preprocessed during the
SOM training procedure, the distances are computed on the normalized values 
of the prototypes.
</p>


<h3>Value</h3>

<p>When <code>mode = "complete"</code>, the function returns a square matrix 
which dimensions are equal to the product of the grid dimensions.
</p>
<p>When <code>mode = "neighbors"</code>, the function returns a list which length is 
equal to the product of the grid dimensions; the length of each item is equal
to the number of neighbors. Neurons are considered to have 8 neighbors at 
most (<em>i.e.</em>, two neurons are neighbors if they have an Euclidean 
distance smaller than <code>radius</code>. Natural choice for <code>radius</code> is
1 for hexagonal topology and 1 or <code class="reqn">\sqrt{2}</code> for square 
topology (4 and 8 neighbors respectively).
</p>


<h3>Author(s)</h3>

<p>Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainSOM">trainSOM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2343)
my.som &lt;- trainSOM(x.data = iris[,1:4], dimension = c(5,5))
protoDist(my.som)
</code></pre>

<hr>
<h2 id='quality'>Compute SOM algorithm quality criteria</h2><span id='topic+quality'></span><span id='topic+quality.somRes'></span>

<h3>Description</h3>

<p>The <code>quality</code> function computes several quality criteria 
for the result of a SOM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quality(sommap, quality.type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quality_+3A_sommap">sommap</code></td>
<td>
<p>A <code>somRes</code> object (see <code><a href="#topic+trainSOM">trainSOM</a></code> for 
details).</p>
</td></tr>
<tr><td><code id="quality_+3A_quality.type">quality.type</code></td>
<td>
<p>The quality type to compute. Two types are implemented: 
<code>quantization</code> and <code>topographic</code>. The output of the function is
one of those or both of them using the option <code>"all"</code>. Default value is 
the latter.</p>
</td></tr>
<tr><td><code id="quality_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>quality</code> function returns either a numeric value (if only 
one type is computed) or a list a numeric values (if all types are computed).
</p>
<p>The quantization error calculates the mean squared euclidean distance between
the sample vectors and their respective cluster prototypes. It is a 
decreasing function of the size of the map.
</p>
<p>The topographic error is the simplest of the topology preservation measure: 
it calculates the ratio of sample vectors for which the second best matching 
unit is not in the direct neighborhood of the best matching unit.
</p>


<h3>Author(s)</h3>

<p>Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Polzlbauer G. (2004) Survey and comparison of quality measures for
self-organizing maps. In: <em>Proceedings of the Fifth Workshop on Data
Analysis (WDA'04), Paralic, J., Polzlbauer, G., Rauber, A. (eds)</em> Sliezsky 
dom, Vysoke Tatry, Slovakia: Elfa Academic Press, 67-82.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainSOM">trainSOM</a></code>, <code><a href="#topic+plot.somRes">plot.somRes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.som &lt;- trainSOM(x.data = iris[,1:4])
quality(my.som, quality.type = "all")
quality(my.som, quality.type = "topographic")
</code></pre>

<hr>
<h2 id='sombreroGUI'>Graphical Web User Interface for SOMbrero</h2><span id='topic+sombreroGUI'></span>

<h3>Description</h3>

<p>Start the SOMbrero GUI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sombreroGUI()
</code></pre>


<h3>Value</h3>

<p>This function starts the graphical user interface with the default 
system browser. This interface is more lickely to work properly with Firefox
<a href="https://www.mozilla.org/fr/firefox/new/">https://www.mozilla.org/fr/firefox/new/</a>. In case Firefox is not your 
default browser, copy/paste http://localhost:8100 into the URL bar.
</p>


<h3>Author(s)</h3>

<p>Élise Maigné &lt;elise.maigne@inrae.fr&gt;<br />
Julien Boelaert <a href="mailto:julien.boelaert@gmail.com">julien.boelaert@gmail.com</a><br />
Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Villa-Vialaneix N. (2017) Stochastic self-organizing map variants with the R
package SOMbrero. In: J.C. Lamirel, M. Cottrell, M. Olteanu, <em>12th 
International Workshop on Self-Organizing Maps and Learning Vector 
Quantization, Clustering and Data Visualization (Proceedings of WSOM 2017)</em>,
IEEE, Nancy, France.
</p>
<p>RStudio and Inc. (2013). shiny: Web Application Framework for R. R package
version 0.7.0. <a href="https://cran.r-project.org/package=shiny">https://cran.r-project.org/package=shiny</a>
</p>

<hr>
<h2 id='somRes.plotting'>Plotting <code>somRes</code> results</h2><span id='topic+somRes.plotting'></span>

<h3>Description</h3>

<p>Useful details on how to produce graphics to help interpreting a <code>somRes</code>
object.<br />
</p>
<p>Important: the graphics availables for the different types of SOM are marked with a N, a K or a R. <br />
(<b>N</b> = numerical SOM, <b>K</b> = korresp SOM and <b>R</b> = relational SOM).
</p>


<h3>Graphics on the observations: <code>what = "obs"</code></h3>

<p>For the cases <code>what = "obs"</code> and <code>what = "add"</code>, if a neuron is empty,
nothing will be plotted at its location.
</p>
<p>The possible values for <b><code>type</code></b> are: 
</p>

<dl>
<dt><code>"hitmap"</code> (K, R)</dt><dd><p>plots proportional areas according to the number of
observations per neuron. It is the default plot when <code>what="obs"</code>.</p>
</dd>
<dt><code>"color"</code> (N)</dt><dd><p>can have one more argument, <code>variable</code>, the name or 
index of the variable to be considered (default, <code>1</code>, the first variable). 
Neurons are filled using the given colors according to the average value level 
of the observations for the chosen variable.</p>
</dd>
<dt><code>"lines"</code> (N)</dt><dd><p>plots a line for each observation in every neuron, between 
variables. A vector of variables (names or indexes) can be provided with the 
argument <code>variable</code>.</p>
</dd>
<dt><code>"meanline"</code> (N)</dt><dd><p>plots, for each neuron, the average value level of the
observations, with lines and points. One point represents a variable. By 
default, all variables of the dataset used to train the algorithm are plotted 
but a vector of variables (names or indexes) can be provided with the argument 
<code>variable</code>.</p>
</dd>
<dt><code>"barplot"</code> (N)</dt><dd><p>is similar to <code>"meanline"</code> but using barplots. Then, 
a bar represents a variable.</p>
</dd>
<dt><code>"boxplot"</code> (N)</dt><dd><p>plots boxplots for the observations in every neuron, by 
variable. Like <code>"lines"</code>, <code>"meanline"</code>  and <code>"barplot"</code> a vector of variables (names
or indexes) can be provided with the argument <code>variable</code>.</p>
</dd>
<dt><code>"names"</code> (N, K, R)</dt><dd><p>prints on the grid the element names (i.e., the
row names or row and column names in the case of <code>korresp</code>) in the neuron
to which it belongs.</p>
</dd>
</dl>



<h3>Graphic on the energy: <code>what = "energy"</code> (N, K, R)</h3>

<p>This graphic is only available if some intermediate backups have been registered
(i.e., with the argument <code>nb.save</code> of <code>trainSOM</code> or <code>initSOM</code> 
resulting in <code>x$parameters$nb.save&gt;1</code>). Graphic plots the evolution of the 
level of the energy according to the registered steps.</p>


<h3>Graphics on the prototypes: <code>what = "prototypes"</code></h3>

<p>The possible values for <b><code>type</code></b> are: 
</p>

<dl>
<dt><code>"lines"</code> (N, K, R)</dt><dd><p>has the same behavior as the <code>"lines"</code> case 
described in the observations section, but according to the prototypes level.</p>
</dd>
<dt><code>"barplot"</code> (N, K, R)</dt><dd><p>has the same behavior as the <code>"barplot"</code> case 
described in the observations section, but according to the prototypes level.</p>
</dd>
<dt><code>"color"</code> (N, K)</dt><dd><p>has the same behavior as the <code>"color"</code> case 
described in the observations section, but according to the prototypes level.</p>
</dd>
<dt><code>"3d"</code> (N)</dt><dd><p>case is similar to the <code>"color"</code> case, but in 3
dimensions, with x and y the coordinates of the grid and z the value of the
prototypes for the considered variable. This function can take two more 
arguments: <code>maxsize</code> (default to <code>2</code>) and <code>minsize</code> (default to 
<code>0.5</code>) for the size of the points representing neurons.</p>
</dd>
<dt><code>"smooth.dist"</code> (N, K, R)</dt><dd><p>depicts the average distance between a 
prototypes and its neighbors on a map where x and y are the coordinates of the 
prototypes on the grid.</p>
</dd>
<dt><code>"poly.dist"</code> (N, K, R)</dt><dd><p>also represents the distances between 
prototypes but with polygons plotted for each neuron. The closest from the 
border the polygon point is, the closest the pairs of prototypes are. The color 
used for filling the polygon shows the number of observations in each neuron. 
A white polygon means that there is no observation. With the default colors, a 
red polygon means a high number of observations.</p>
</dd>
<dt><code>"umatrix"</code> (N, K, R)</dt><dd><p>is another way of plotting distances between 
prototypes. The grid is plotted and filled with <code>my.palette</code> colors 
according to the mean distance between the current neuron and the neighboring 
neurons. With the default colors, red indicates proximity.</p>
</dd>
<dt><code>"mds"</code> (N, K, R)</dt><dd><p>plots the number of the neuron on a map according to 
a Multi Dimensional Scaling (MDS) projection on a two dimensional space.</p>
</dd>
<dt><code>"grid.dist"</code> (N, K, R)</dt><dd><p>plots on a 2 dimension map all distances. The 
number of points on this picture is equal to
<code class="reqn">\frac{\textrm{number of neurons}\times(\textrm{number of neurons}-1)}{2}</code>. 
On the x axis corresponds to the prototype distances whereas the y axis depicts 
the grid distances.</p>
</dd>
</dl>



<h3>Graphics on an additional variable: <code>what="add"</code></h3>

<p>The case <code>what="add"</code> considers an additional variable, which has to be 
given to the argument <code>variable</code>. Its length must match the number of
observations in the original data. 
</p>
<p>When the algorithm's type is <code>korresp</code>, no graphic is available for
<code>what = "add"</code>.
</p>
<p>The possible values for <code>type</code> are:
</p>

<dl>
<dt><code>"color"</code> (N, R)</dt><dd><p>has the same behavior as the <code>"color"</code> case 
described in the observations section. Then, the additional variable must be a 
numerical vector.</p>
</dd>
<dt><code>"lines"</code> (N, R)</dt><dd><p>has the same behavior as the <code>"lines"</code> case 
described in the observations section. Then, the additional variable must be a 
numerical matrix or a data frame.</p>
</dd>
<dt><code>"boxplot"</code> (N, R)</dt><dd><p>has the same behavior as the <code>"boxplot"</code> case 
described in the observations section. Then, the additional variable must be 
either a numeric vector or a numeric matrix/data frame.</p>
</dd>
<dt><code>"barplot"</code> (N, R)</dt><dd><p>has the same behavior as the <code>"barplot"</code> case 
described in the observations section. Then, the additional variable must be 
either a numeric vector or a numeric matrix/data frame.</p>
</dd>
<dt><code>"pie"</code> (N)</dt><dd><p>requires the argument <code>variable</code> to be a vector, which
will be passed to the function <code>as.factor</code>, and plots one pie for each 
neuron according to this factor. By default, the size of the pie is 
proportional to the number of observations affected to its neuron but this can 
be changed with the argument <code>proportional = FALSE</code>.</p>
</dd>
<dt><code>"names"</code> (N, R)</dt><dd><p>has the same behavior as the <code>"names"</code> case 
described in the observations section. Then, the names to be printed are the 
elements of the variable given to the <code>variable</code> argument.
This case can take one more argument: <code>size</code> (default to <code>4</code>) for the 
size of the words.</p>
</dd>
<dt><code>"words"</code> (N, R)</dt><dd><p>needs the argument <code>variable</code> be a numeric matrix 
or a <code>data.frame</code>: names of the columns will be used as words and the 
values express the frequency of a given word in the observation. Then, for each 
neuron of the grid, the words will be printed with sizes proportional to the sum
of their values in the neuron. If the <code>variable</code> given is a contingency 
table, it will plot directly the frequency of the words in the neurons.</p>
</dd>
<dt><code>"graph"</code> (N, R)</dt><dd><p>requires that the argument <code>variable</code> is an
<code>igraph</code> object (see <code>library("igraph")</code>. According to the existing
edges in the graph and to the clustering obtained with the SOM algorithm, a 
clustered graph will be produced where a vertex between two vertices represents
a neuron and the width of an edge is proportional to the number of edges in the
given graph between the vertices affected to the corresponding neurons.
The option can handle two more arguments: <code>pie.graph</code> and <code>pie.variable</code>.
These are used to display the vertex as pie charts. For this case, 
<code>pie.graph</code> must be set to <code>TRUE</code> and a factor vector is supplied by
<code>pie.variable</code>.</p>
</dd>
</dl>



<h3>Further arguments via ...</h3>

<p>Further arguments, their reference functions and the <code>plot.somRes</code> cases 
are summarized in the following list:
</p>

<ul>
<li> <p><code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> is called by the cases:
</p>

<ul>
<li> <p><code>what = "add"</code> / <code>type = "graph"</code>
</p>
</li>
<li> <p><code>what = "add"</code> / <code>type = "projgraph"</code> (for a superclass object)
</p>
</li></ul>

</li>
<li> <p><code><a href="graphics.html#topic+persp">persp</a></code> is called by the case 
<code>what = "prototypes"</code> / <code>type = "3d"</code>
</p>
</li>
<li> <p><code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> is called in all the other cases. 
</p>
</li></ul>

<p>In complement to ggplot, 
</p>

<ul>
<li> <p><code><a href="ggwordcloud.html#topic+geom_text_wordcloud">geom_text_wordcloud</a></code> is called by the cases:
</p>

<ul>
<li> <p><code>type = "names"</code>
</p>
</li>
<li> <p><code>what = "add"</code> / <code>type = "words"</code>
</p>
</li></ul>

</li>
<li> <p><code><a href="metR.html#topic+geom_contour_fill">geom_contour_fill</a></code> is called by the case
<code>what = "prototypes"</code> / <code>type = "smooth.dist"</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Élise Maigné <a href="mailto:elise.maigne@inrae.fr">elise.maigne@inrae.fr</a><br />
Madalina Olteanu <a href="mailto:madalina.olteanu@univ-paris1.fr">madalina.olteanu@univ-paris1.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inra.fr">nathalie.vialaneix@inra.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Numerical SOM
# run the SOM algorithm on the numerical data of 'iris' data set
iris.som &lt;- trainSOM(x.data = iris[,1:4], nb.save = 2)

####### energy plot
plot(iris.som, what = "energy") # energy

####### plots on observations
plot(iris.som, what = "obs", type = "hitmap")
## Not run: 
plot(iris.som, what = "obs", type = "lines")
plot(iris.som, what = "obs", type = "barplot")
plot(iris.som, what = "obs", type = "boxplot")
plot(iris.som, what = "obs", type = "meanline")
plot(iris.som, what = "obs", type = "color", variable = 1)
plot(iris.som, what = "obs", type = "names")
## End(Not run)

####### plots on prototypes
plot(iris.som, what = "prototypes", type = "3d", variable = "Sepal.Length")
## Not run: 
plot(iris.som, what = "prototypes", type = "lines")
plot(iris.som, what = "prototypes", type = "barplot")
plot(iris.som, what = "prototypes", type = "umatrix")
plot(iris.som, what = "prototypes", type = "color", variable = "Petal.Length")
plot(iris.som, what = "prototypes", type = "smooth.dist")
plot(iris.som, what = "prototypes", type = "poly.dist")
plot(iris.som, what = "prototypes", type = "grid.dist")
plot(iris.som, what = "prototypes", type = "mds")
## End(Not run)


####### plots on an additional variable: the flower species
plot(iris.som, what = "add", type = "pie", variable = iris$Species)
## Not run: 
plot(iris.som, what = "add", type = "names", variable = iris$Species)
plot(iris.som, what = "add", type = "words", variable = iris[,1:2])
## End(Not run)
</code></pre>

<hr>
<h2 id='superClass'>Create super-clusters from SOM results</h2><span id='topic+superClass'></span><span id='topic+superClass.somRes'></span><span id='topic+print.somSC'></span><span id='topic+summary.somSC'></span><span id='topic+projectIGraph.somSC'></span><span id='topic+plot.somSC'></span><span id='topic+somSC-class'></span>

<h3>Description</h3>

<p>Aggregate the resulting clustering of the SOM algorithm into 
super-clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>superClass(sommap, method, members, k, h, ...)

## S3 method for class 'somSC'
print(x, ...)

## S3 method for class 'somSC'
summary(object, ...)

## S3 method for class 'somSC'
plot(
  x,
  what = c("obs", "prototypes", "add"),
  type = c("dendrogram", "grid", "hitmap", "lines", "meanline", "barplot", "boxplot",
    "mds", "color", "poly.dist", "pie", "graph", "dendro3d", "projgraph"),
  plot.var = TRUE,
  show.names = TRUE,
  names = 1:prod(x$som$parameters$the.grid$dim),
  ...
)

## S3 method for class 'somSC'
projectIGraph(object, init.graph, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="superClass_+3A_sommap">sommap</code></td>
<td>
<p>A <code>somRes</code> object.</p>
</td></tr>
<tr><td><code id="superClass_+3A_method">method</code></td>
<td>
<p>Argument passed to the <code><a href="stats.html#topic+hclust">hclust</a></code> function.</p>
</td></tr>
<tr><td><code id="superClass_+3A_members">members</code></td>
<td>
<p>Argument passed to the <code><a href="stats.html#topic+hclust">hclust</a></code> function.</p>
</td></tr>
<tr><td><code id="superClass_+3A_k">k</code></td>
<td>
<p>Argument passed to the <code><a href="stats.html#topic+cutree">cutree</a></code> function (number of 
super-clusters to cut the dendrogram).</p>
</td></tr>
<tr><td><code id="superClass_+3A_h">h</code></td>
<td>
<p>Argument passed to the <code><a href="stats.html#topic+cutree">cutree</a></code> function (height where 
to cut the dendrogram).</p>
</td></tr>
<tr><td><code id="superClass_+3A_...">...</code></td>
<td>
<p>Used for <code>plot.somSC</code>: further arguments passed either to
the function <code><a href="graphics.html#topic+plot">plot</a></code> (case <code>type="dendro"</code>) or to 
<code><a href="#topic+plot.myGrid">plot.myGrid</a></code> (case <code>type="grid"</code>) or to 
<code><a href="#topic+plot.somRes">plot.somRes</a></code> (all other cases).</p>
</td></tr>
<tr><td><code id="superClass_+3A_x">x</code></td>
<td>
<p>A <code>somSC</code> object.</p>
</td></tr>
<tr><td><code id="superClass_+3A_object">object</code></td>
<td>
<p>A <code>somSC</code> object.</p>
</td></tr>
<tr><td><code id="superClass_+3A_what">what</code></td>
<td>
<p>What you want to plot for superClass object. Either the 
observations (<code>obs</code>), the prototypes (<code>prototypes</code>) or an 
additional variable (<code>add</code>), or <code>NULL</code> if not appropriate. 
Automatically set for types &quot;hitmap&quot; (to <code>"obs"</code>), 'grid' 
(to <code>"prototypes"</code>), default to &quot;obs&quot; otherwise.
If <code>what='add'</code>, the function <code><a href="#topic+plot.somRes">plot.somRes</a></code> will be called with
the argument <code>what</code> set to <code>"add"</code>.</p>
</td></tr>
<tr><td><code id="superClass_+3A_type">type</code></td>
<td>
<p>The type of plot to draw. Default value is <code>"dendrogram"</code>, 
to plot the dendrogram of the clustering. Case <code>"grid"</code> plots the grid 
in color according to the super clustering. Case <code>"projgraph"</code> uses an
<a href="igraph.html#topic+igraph">igraph</a> object passed to the argument <code>variable</code> and plots
the projected graph as defined by the function <code>projectIGraph.somSC</code>.
All other cases are those available in the function <code><a href="#topic+plot.somRes">plot.somRes</a></code> 
and surimpose the super-clusters over these plots.</p>
</td></tr>
<tr><td><code id="superClass_+3A_plot.var">plot.var</code></td>
<td>
<p>A boolean indicating whether a graph showing the evolution of
the explained variance should be plotted. This argument is only used when 
<code>type="dendrogram"</code>, its default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="superClass_+3A_show.names">show.names</code></td>
<td>
<p>Whether the cluster titles must be printed in center of
the grid or not for <code>type="grid"</code>. Default to <code>FALSE</code> (titles not 
displayed).</p>
</td></tr>
<tr><td><code id="superClass_+3A_names">names</code></td>
<td>
<p>If <code>show.names = TRUE</code>, values of the title to 
display for <code>type="grid"</code>. Default to &quot;Cluster &quot; followed by the cluster
number.</p>
</td></tr>
<tr><td><code id="superClass_+3A_init.graph">init.graph</code></td>
<td>
<p>An <a href="igraph.html#topic+igraph">igraph</a> object which is projected 
according to the super-clusters. The number of vertices of <code>init.graph</code> 
must be equal to the number of rows in the original dataset processed by the 
SOM (case <code>"korresp"</code> is not handled by this function). In the projected
graph, the vertices are positionned at the center of gravity of the 
super-clusters (more details in the section <strong>Details</strong> below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>superClass</code> function can be used in 2 ways: </p>

<ul>
<li><p> to choose the number of super clusters via an <code><a href="stats.html#topic+hclust">hclust</a></code> 
object: then, both arguments <code>k</code> and <code>h</code> are not filled.
</p>
</li>
<li><p> to cut the clustering into super clusters: then, either argument 
<code>k</code> or argument <code>h</code> must be filled. See <code><a href="stats.html#topic+cutree">cutree</a></code> for
details on these arguments.
</p>
</li></ul>

<p>The squared distance between prototypes is passed to the algorithm.
</p>
<p><code>summary</code> on a <code>superClass</code> object produces a complete summary of 
the results that displays the number of clusters and super-clusters, the 
clustering itself and performs ANOVA analyses. For <code>type="numeric"</code> the 
ANOVA is performed for each input variable and test the difference of this
variable across the super-clusters of the map. For <code>type="relational"</code> 
a dissimilarity ANOVA is performed (see (Anderson, 2001), except that in the 
present version, a crude estimate of the p-value is used which is based on 
the Fisher distribution and not on a permutation test.
</p>
<p>On plots, the different super classes are identified in the following ways:
</p>
 
<ul>
<li><p> either with different color, when <code>type</code> is set among: 
<code>"grid"</code> (N, K, R), <code>"hitmap"</code> (N, K, R), <code>"lines"</code> (N, K, R), 
<code>"barplot"</code> (N, K, R), <code>"boxplot"</code>, <code>"poly.dist"</code> (N, K, R), 
<code>"mds"</code> (N, K, R), <code>"dendro3d"</code> (N, K, R), <code>"graph"</code> (R),
<code>"projgraph"</code> (R)
</p>
</li>
<li><p> or with title, when <code>type</code> is set among: <code>"color"</code> (N, K),
<code>"pie"</code> (N, R)
</p>
</li></ul>

<p>In the list above, the charts available for a <code>numerical</code> SOM are marked
with a N, with a K for a <code>korresp</code> SOM and with a R for 
<code>relational</code> SOM.
</p>
<p><code><a href="#topic+projectIGraph.somSC">projectIGraph.somSC</a></code> produces a projected graph from the 
<a href="igraph.html#topic+igraph">igraph</a> object passed to the argument <code>variable</code> as 
described in (Olteanu and Villa-Vialaneix, 2015). The attributes of this 
graph are the same than the ones obtained from the SOM map itself in the 
function <code><a href="#topic+projectIGraph.somRes">projectIGraph.somRes</a></code>. <code><a href="#topic+plot.somSC">plot.somSC</a></code> used with 
<code>type="projgraph"</code> calculates this graph and represents it by 
positionning the super-vertexes at the center of gravity of the 
super-clusters. This feature can be combined with <code>pie.graph=TRUE</code> to 
super-impose the information from an external factor related to the 
individuals in the original dataset (or, equivalently, to the vertexes of the
graph).
</p>


<h3>Value</h3>

<p>The <code>superClass</code> function returns an object of class 
<code>somSC</code> which is a list of the following elements: 
</p>
<table>
<tr><td><code>cluster</code></td>
<td>
<p>The super clustering of the prototypes (only if either 
<code>k</code> or <code>h</code> are given by user).</p>
</td></tr>
<tr><td><code>tree</code></td>
<td>
<p>An <code><a href="stats.html#topic+hclust">hclust</a></code> object.</p>
</td></tr>
<tr><td><code>som</code></td>
<td>
<p>The <code>somRes</code> object given as argument (see 
<code><a href="#topic+trainSOM">trainSOM</a></code> for details).</p>
</td></tr>
</table>
<p>The <code>projectIGraph.somSC</code> function returns an object of class 
<code><a href="igraph.html#topic+igraph">igraph</a></code> with the following attributes: 
</p>
<table>
<tr><td><code>layout</code></td>
<td>
<p> provides the layout of the projected graph 
according to the center of gravity of the super-clusters positioned on 
the SOM grid (graph attribute);</p>
</td></tr>
<tr><td><code>name and size</code></td>
<td>
<p> respectively are the vertex number on 
the grid and the number of vertexes included in the corresponding cluster 
(vertex attribute);</p>
</td></tr>
<tr><td><code>weight</code></td>
<td>
<p> gives the number of edges (or the sum of the weights)
between the vertexes of the two corresponding clusters (edge attribute).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Élise Maigné <a href="mailto:elise.maigne@inrae.fr">elise.maigne@inrae.fr</a><br />
Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Anderson M.J. (2001). A new method for non-parametric multivariate analysis 
of variance. <em>Austral Ecology</em>, <strong>26</strong>, 32-46.
</p>
<p>Olteanu M., Villa-Vialaneix N. (2015) Using SOMbrero for clustering and 
visualizing graphs. <em>Journal de la Societe Francaise de Statistique</em>, 
<strong>156</strong>, 95-119.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code>, <code><a href="#topic+trainSOM">trainSOM</a></code>, 
<code><a href="#topic+plot.somRes">plot.somRes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11051729)
my.som &lt;- trainSOM(x.data = iris[,1:4])
# choose the number of super-clusters
sc &lt;- superClass(my.som)
plot(sc)
# cut the clustering
sc &lt;- superClass(my.som, k = 4)
summary(sc)
plot(sc)
plot(sc, type = "grid")
plot(sc, what = "obs", type = "hitmap")
</code></pre>

<hr>
<h2 id='trainSOM'>Run the SOM algorithm</h2><span id='topic+trainSOM'></span><span id='topic+summary.somRes'></span><span id='topic+print.somRes'></span>

<h3>Description</h3>

<p>The <code>trainSOM</code> function returns a <code>somRes</code> class 
object which contains the outputs of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainSOM(x.data, ...)

## S3 method for class 'somRes'
print(x, ...)

## S3 method for class 'somRes'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trainSOM_+3A_x.data">x.data</code></td>
<td>
<p>a data frame or matrix containing the observations to be mapped
on the grid by the SOM algorithm.</p>
</td></tr>
<tr><td><code id="trainSOM_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the function 
<code><a href="#topic+initSOM">initSOM</a></code> for specifying the parameters of the algorithm. The 
default values of the arguments <code>maxit</code> and <code>dimension</code> are 
calculated according to the SOM type if the user does not set them:
</p>

<ul>
<li> <p><code>maxit</code> is equal to (number of rows+number of columns)*5 if the 
SOM type is <code>korresp</code>. It is equal to number of rows*5 in all other 
SOM types
</p>
</li>
<li> <p><code>dimension</code>: for a <code>korresp</code> SOM, is approximately equal to
the square root of the number of observations to be classified divided by
10 but it is never smaller than 5 or larger than 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="trainSOM_+3A_x">x</code></td>
<td>
<p>an object of class <code>somRes</code>.</p>
</td></tr>
<tr><td><code id="trainSOM_+3A_object">object</code></td>
<td>
<p>an object of class <code>somRes</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The version of the SOM algorithm implemented in this package is the
stochastic version.
</p>
<p>Several variants able to handle non-vectorial data are also implemented in 
their stochastic versions: <code>type="korresp"</code> for contingency tables, as
described in Cottrell et al. (2004) (with weights as in Cottrell and Letrémy, 
2005a); <code>type = "relational"</code> for dissimilarity matrices, as described 
in Olteanu et al. (2015), with the fast implementation introduced in Mariette
<em>et al.</em> (2017).
</p>
<p>Missing values are handled as described in Cottrell et al. (2005b), not using
missing entries of the selected observation during winner computation or 
prototype updates. This allows to proceed with the imputation of missing
entries with the corresponding entries of the cluster prototype (with 
<code><a href="#topic+impute">impute</a></code>).
</p>
<p><code><a href="base.html#topic+summary">summary</a></code> produces a complete summary of the results that 
displays the parameters of the SOM, quality criteria and ANOVA. For 
<code>type = "numeric"</code> the ANOVA is performed for each input variable and 
test the difference of this variable across the clusters of the map. For 
<code>type = "relational"</code> a dissimilarity ANOVA is performed (Anderson, 
2001), except that in the present version, a crude estimate of the p-value is
used which is based on the Fisher distribution and not on a permutation test.
</p>


<h3>Value</h3>

<p>The <code>trainSOM</code> function returns an object of class <code>somRes</code>
which contains the following components:
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p> the final classification of the data.</p>
</td></tr>
<tr><td><code>prototypes</code></td>
<td>
<p> the final coordinates of the prototypes.</p>
</td></tr>
<tr><td><code>energy</code></td>
<td>
<p> the final energy of the map. For the numeric case, energy 
with data having missing entries is based on data imputation as described
in Cottrell and Letrémy (2005b).</p>
</td></tr>
<tr><td><code>backup</code></td>
<td>
<p> a list containing some intermediate backups of the 
prototypes coordinates, clustering, energy and the indexes of the recorded 
backups, if <code>nb.save</code> is set to a value larger than 1.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> the original dataset used to train the algorithm.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p> a list of the map's parameters, which is an object of 
class <code>paramSOM</code> as produced by the function <code><a href="#topic+initSOM">initSOM</a></code>.</p>
</td></tr>
</table>
<p>The function <code>summary.somRes</code> also provides an ANOVA (ANalysis Of 
VAriance) of each input numeric variables in function of the map's clusters. 
This is helpful to see which variables participate to the clustering.
</p>


<h3>Note</h3>

<p>Warning! Recording intermediate backups with the argument 
<code>nb.save</code> can strongly increase the computational time since calculating
the entire clustering and the energy is time consuming. Use this option with
care and only when it is strictly necessary.
</p>


<h3>Author(s)</h3>

<p>Élise Maigné <a href="mailto:elise.maigne@inrae.fr">elise.maigne@inrae.fr</a><br />
Jérome Mariette <a href="mailto:jerome.mariette@inrae.fr">jerome.mariette@inrae.fr</a><br />
Madalina Olteanu <a href="mailto:olteanu@ceremade.dauphine.fr">olteanu@ceremade.dauphine.fr</a><br />
Fabrice Rossi <a href="mailto:fabrice.rossi@apiacoa.org">fabrice.rossi@apiacoa.org</a><br />
Nathalie Vialaneix <a href="mailto:nathalie.vialaneix@inrae.fr">nathalie.vialaneix@inrae.fr</a>
</p>


<h3>References</h3>

<p>Anderson M.J. (2001). A new method for non-parametric multivariate analysis 
of variance. <em>Austral Ecology</em>, <strong>26</strong>, 32-46. 
</p>
<p>Kohonen T. (2001) <em>Self-Organizing Maps</em>. Berlin/Heidelberg: 
Springer-Verlag, 3rd edition.
</p>
<p>Cottrell M., Ibbou S., Letrémy P. (2004) SOM-based algorithms for qualitative
variables. <em>Neural Networks</em>, <strong>17</strong>, 1149-1167.
</p>
<p>Cottrell M., Letrémy P. (2005a) How to use the Kohonen algorithm to 
simultaneously analyse individuals in a survey. <em>Neurocomputing</em>, 
<strong>21</strong>, 119-138.
</p>
<p>Cottrell M., Letrémy P. (2005b) Missing values: processing with the Kohonen 
algorithm. <em>Proceedings of Applied Stochastic Models and Data Analysis
(ASMDA 2005)</em>, 489-496.
</p>
<p>Olteanu M., Villa-Vialaneix N. (2015) On-line relational and multiple
relational SOM. <em>Neurocomputing</em>, <strong>147</strong>, 15-30. 
</p>
<p>Mariette J., Rossi F., Olteanu M., Mariette J. (2017) Accelerating stochastic 
kernel SOM. In: M. Verleysen, <em>XXVth European Symposium on Artificial 
Neural Networks, Computational Intelligence and Machine Learning (ESANN 
2017)</em>, i6doc, Bruges, Belgium, 269-274.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+initSOM">initSOM</a></code> for a description of the parameters to 
pass to the trainSOM function to change its behavior and 
<code><a href="#topic+plot.somRes">plot.somRes</a></code> to plot the outputs of the algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run trainSOM algorithm on the iris data with 500 iterations
iris.som &lt;- trainSOM(x.data=iris[,1:4])
iris.som
summary(iris.som)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
