<!DOCTYPE html><html><head><title>Help for package StableEstim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {StableEstim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#StableEstim-package'>
<p>Stable law estimation functions</p></a></li>
<li><a href='#Best_t-class'><p>Class <code>"Best_t"</code></p></a></li>
<li><a href='#CgmmParametersEstim'>
<p>Estimate parameters of stable laws using a Cgmm method</p></a></li>
<li><a href='#ComplexCF'>
<p>Compute the characteristic function of stable laws</p></a></li>
<li><a href='#ComputeBest_t'>
<p>Monte Carlo simulation to investigate the optimal number of</p>
points to use in the moment conditions</a></li>
<li><a href='#ComputeBest_tau'>
<p>Run Monte Carlo simulation to investigate the optimal <code class="reqn">\tau</code></p></a></li>
<li><a href='#ComputeDuration'>
<p>Duration</p></a></li>
<li><a href='#ComputeFirstRootRealeCF'>
<p>First root of the empirical characteristic function</p></a></li>
<li><a href='#ComputeStatObjectFromFiles'>
<p>Parse an output file to create a summary object (<code>list</code>)</p></a></li>
<li><a href='#ConcatFiles'>
<p>Concatenates output files.</p></a></li>
<li><a href='#Estim'><p>Estimate parameters of stable laws</p></a></li>
<li><a href='#Estim_Simulation'>
<p>Monte Carlo simulation</p></a></li>
<li><a href='#Estim-class'><p>Class <code>"Estim"</code></p></a></li>
<li><a href='#expect_almost_equal'>
<p>Test approximate equality</p></a></li>
<li><a href='#get.abMat'>
<p>Default set of parameters to pass to <code>Estim_Simulation</code></p></a></li>
<li><a href='#get.StatFcts'>
<p>Default functions used to produce the statistical summary</p></a></li>
<li><a href='#getTime_'>
<p>Read time</p></a></li>
<li><a href='#GMMParametersEstim'>
<p>Estimate parameters of stable laws using a GMM method</p></a></li>
<li><a href='#IGParametersEstim'>
<p>Estimate parameters of stable laws by Kogon and McCulloch methods</p></a></li>
<li><a href='#IntegrateRandomVectorsProduct'>
<p>Integral outer product of random vectors</p></a></li>
<li><a href='#jacobianComplexCF'>
<p>Jacobian of the characteristic function of stable laws</p></a></li>
<li><a href='#KoutParametersEstim'>
<p>Iterative Koutrouvelis regression method</p></a></li>
<li><a href='#McCullochParametersEstim'>
<p>Quantile-based method</p></a></li>
<li><a href='#MLParametersEstim'>
<p>Maximum likelihood (ML) method</p></a></li>
<li><a href='#PrintDuration'>
<p>Print duration</p></a></li>
<li><a href='#PrintEstimatedRemainingTime'>
<p>Estimated remaining time</p></a></li>
<li><a href='#RegularisedSol'>
<p>Regularised Inverse</p></a></li>
<li><a href='#sampleComplexCFMoment'>
<p>Complex moment condition based on the characteristic function</p></a></li>
<li><a href='#sampleRealCFMoment'>
<p>Real moment condition based on the characteristic function</p></a></li>
<li><a href='#StableEstim_reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#StatFcts'>
<p>Default functions used to produce the statistical summary</p></a></li>
<li><a href='#TexSummary'>
<p>LaTeX summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate the Four Parameters of Stable Laws using Different
Methods</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-07</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, numDeriv, xtable, fBasics, MASS,
methods, Matrix, stabledist, testthat, Rdpack</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate the four parameters of stable laws using maximum
             likelihood method, generalised method of moments with
             finite and continuum number of points, iterative
             Koutrouvelis regression and Kogon-McCulloch method.  The
             asymptotic properties of the estimators (covariance
             matrix, confidence intervals) are also provided.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GeoBosh/StableEstim">https://github.com/GeoBosh/StableEstim</a> (devel),
<a href="https://geobosh.github.io/StableEstim/">https://geobosh.github.io/StableEstim/</a> (doc)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GeoBosh/StableEstim/issues">https://github.com/GeoBosh/StableEstim/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>cte.R ExternalPackageInterface.R ToolsFct.R Interpolation.R
RegularInverse.R stableCF.R CFbasedMoment.R WeightingMatrix.R
eCFfirstZero.R tSchemes.R MultiDimIntegral.R InitialGuess.R
KoutParamsEstim.R MLParamsEstim.R GMMParamsEstim.R
CgmmParamsEstim.R OutputFileManip.R CheckPoint.R BestT_Class.R
Estim_Class.R Estim.R Simulation.R BestT.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-07 08:58:27 UTC; georgi</td>
</tr>
<tr>
<td>Author:</td>
<td>Tarak Kharrat [aut],
  Georgi N. Boshnakov [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georgi N. Boshnakov &lt;georgi.boshnakov@manchester.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-07 10:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='StableEstim-package'>
Stable law estimation functions
</h2><span id='topic+StableEstim-package'></span>

<h3>Description</h3>

<p>A collection of methods to estimate the four parameters of stable
laws. The package also provides functions to compute the
characteristic function and tools to run Monte Carlo simulations.
</p>


<h3>Details</h3>

<p>The main functions of the package are briefly described below:
</p>

<dl>
<dt>main function:</dt><dd><p><code><a href="#topic+Estim">Estim</a></code> is the most useful
function of the package. It estimates of the parameters
and the asymptotic properties of the estimators.</p>
</dd>
<dt>estimation function:</dt><dd>
<p>the methods provided so far are the maximum-likelihood
(<code><a href="#topic+MLParametersEstim">MLParametersEstim</a></code>), the generalised method of
moment with finite (<code><a href="#topic+GMMParametersEstim">GMMParametersEstim</a></code>) or
continuum (<code><a href="#topic+CgmmParametersEstim">CgmmParametersEstim</a></code>) moment conditions,
the iterative Koutrouvelis regression method
(<code><a href="#topic+KoutParametersEstim">KoutParametersEstim</a></code>) and the fast Kogon-McCulloch
method used for first guess estimation
(<code><a href="#topic+IGParametersEstim">IGParametersEstim</a></code>).
</p>
</dd>
<dt>characteristic function:</dt><dd><p>the characteristic function
(<code><a href="#topic+ComplexCF">ComplexCF</a></code>)
and its Jacobian (<code><a href="#topic+jacobianComplexCF">jacobianComplexCF</a></code>)
can be computed and will return a vector (respectively a matrix)
of complex numbers.</p>
</dd>
<dt>Monte Carlo simulation</dt><dd>
<p><code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code> is a tool to run Monte Carlo
simulations with flexible options to select the estimation method,
the Monte Carlo control parameters, compute statistical summaries
or save results to a file.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Version 1 of this package had a somewhat restricted license since
it needed package <span class="pkg">akima</span> in some computations.
</p>
<p>In version 2 of the package we implemented a 2D interpolation routine
and removed the dependency on <span class="pkg">akima</span>.  Therefore,
<span class="pkg">StableEstim</span> is now under GPL license.  The package is related to
upcoming work by the authors where the different methods are compared
using MC simulations.
</p>


<h3>Author(s)</h3>

<p>Tarak Kharrat, Georgi N. Boshnakov
</p>


<h3>References</h3>


<p>Carrasco M and Florens J (2000).
&ldquo;Generalization of GMM to a continuum of moment conditions.&rdquo;
<em>Econometric Theory</em>, <b>16</b>(06), pp. 797&ndash;834.
</p>
<p>Carrasco M and Florens J (2002).
&ldquo;Efficient GMM estimation using the empirical characteristic function.&rdquo;
<em>IDEI Working Paper</em>, <b>140</b>.
</p>
<p>Carrasco M and Florens J (2003).
&ldquo;On the asymptotic efficiency of GMM.&rdquo;
<em>IDEI Working Paper</em>, <b>173</b>.
</p>
<p>Carrasco M, Chernov M, Florens J and Ghysels E (2007).
&ldquo;Efficient estimation of general dynamic models with a continuum of moment conditions.&rdquo;
<em>Journal of Econometrics</em>, <b>140</b>(2), pp. 529&ndash;573.
</p>
<p>Carrasco M, Florens J and Renault E (2007).
&ldquo;Linear inverse problems in structural econometrics estimation based on spectral decomposition and regularization.&rdquo;
<em>Handbook of econometrics</em>, <b>6</b>, pp. 5633&ndash;5751.
</p>
<p>Carrasco M and Kotchoni R (2010).
&ldquo;Efficient estimation using the characteristic function.&rdquo;
Mimeo. University of Montreal.
</p>
<p>Nolan J (2001).
&ldquo;Maximum likelihood estimation and diagnostics for stable distributions.&rdquo;
<em>L'evy processes: theory and applications</em>, pp. 379&ndash;400.
</p>
<p>Nolan JP (2012).
<em>Stable Distributions - Models for Heavy Tailed Data</em>.
Birkhauser, Boston.
In progress, Chapter 1 online at academic2.american.edu/<code class="reqn">\sim</code>jpnolan.
</p>
<p>Hansen LP (1982).
&ldquo;Large sample properties of generalized method of moments estimators.&rdquo;
<em>Econometrica: Journal of the Econometric Society</em>, pp. 1029&ndash;1054.
</p>
<p>Hansen LP, Heaton J and Yaron A (1996).
&ldquo;Finite-sample properties of some alternative GMM estimators.&rdquo;
<em>Journal of Business &amp; Economic Statistics</em>, <b>14</b>(3), pp. 262&ndash;280.
</p>
<p>Feuerverger A and McDunnough P (1981).
&ldquo;On efficient inference in symmetric stable laws and processes.&rdquo;
<em>Statistics and Related Topics</em>, <b>99</b>, pp. 109&ndash;112.
</p>
<p>Feuerverger A and McDunnough P (1981).
&ldquo;On some Fourier methods for inference.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>76</b>(374), pp. 379&ndash;387.
</p>
<p>Schmidt P (1982).
&ldquo;An improved version of the Quandt-Ramsey MGF estimator for mixtures of normal distributions and switching regressions.&rdquo;
<em>Econometrica: Journal of the Econometric Society</em>, pp. 501&ndash;516.
</p>
<p>Besbeas P and Morgan B (2008).
&ldquo;Improved estimation of the stable laws.&rdquo;
<em>Statistics and Computing</em>, <b>18</b>(2), pp. 219&ndash;231.
</p>


<h3>See Also</h3>

<p><code>fBasics:::.mleStableFit</code>,
<code>fBasics:::.qStableFit</code>
</p>
<p>package <span class="pkg">stabledist</span>
</p>

<hr>
<h2 id='Best_t-class'>Class <code>"Best_t"</code></h2><span id='topic+Best_t-class'></span><span id='topic++2B+2CBest_t+2CBest_t-method'></span><span id='topic+initialize+2CBest_t-method'></span><span id='topic+show+2CBest_t-method'></span>

<h3>Description</h3>

<p>Class used to store the result of function <code><a href="#topic+ComputeBest_t">ComputeBest_t</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form
<code>new("Best_t", theta, nbt, tvec, detVal, convcode, ...)</code>,
where the user can specify some/all of the inputs or call function
<code><a href="#topic+ComputeBest_t">ComputeBest_t</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>theta</code>:</dt><dd><p>Object of class <code>"vector"</code>; values of the
4 parameters.</p>
</dd>
<dt><code>nbt</code>:</dt><dd><p>Object of class <code>"vector"</code>; number of points
used in the minimisation.</p>
</dd>
<dt><code>tvec</code>:</dt><dd><p>Object of class <code>"list"</code>; values of the
best t-vectors.</p>
</dd>
<dt><code>detVal</code>:</dt><dd><p>Object of class <code>"vector"</code>; values of the
optimal determinant found after minimisation.</p>
</dd>
<dt><code>convcode</code>:</dt><dd><p>Convergence code.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>+</dt><dd><p><code>signature(e1 = "Best_t", e2 = "Best_t")</code>:
sum objects from class <code>Best_t</code>.
</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "Best_t")</code>:
initialise an object from class <code>Best_t</code> as described above.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Best_t")</code>:
print a summary of the object.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ComputeBest_t">ComputeBest_t</a></code>
</p>

<hr>
<h2 id='CgmmParametersEstim'>
Estimate parameters of stable laws using a Cgmm method
</h2><span id='topic+CgmmParametersEstim'></span>

<h3>Description</h3>

<p>Estimate the four parameters of stable laws using generalised method
of moments based on a continuum of complex moment conditions (Cgmm)
due to Carrasco and Florens.  Those moments are computed by matching
the characteristic function with its sample counterpart. The resulting
(ill-posed) estimation problem is solved by a regularisation
technique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CgmmParametersEstim(x, type = c("2S", "IT", "Cue"), alphaReg = 0.01,
                    subdivisions = 50,
                    IntegrationMethod = c("Uniform", "Simpson"),
                    randomIntegrationLaw = c("unif", "norm"),
                    s_min = 0, s_max = 1,
                    theta0 = NULL,
                    IterationControl = list(),
                    pm = 0, PrintTime = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CgmmParametersEstim_+3A_x">x</code></td>
<td>

<p>Data used to perform the estimation: a vector of length n.
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_type">type</code></td>
<td>

<p>Cgmm algorithm: <code>"2S"</code> is the two steps GMM proposed by
Hansen(1982).  <code>"Cue"</code> and <code>"IT"</code> are respectively the
continuous updated and the iterative GMM proposed by Hansen, Eaton
et Yaron (1996) and adapted to the continuum case.
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_alphareg">alphaReg</code></td>
<td>

<p>Value of the regularisation parameter; numeric, default = 0.01.
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_subdivisions">subdivisions</code></td>
<td>

<p>Number of subdivisions used to compute the different
integrals involved in the computation of the objective function (to
minimise); numeric.
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_integrationmethod">IntegrationMethod</code></td>
<td>

<p>Numerical integration method to be used to approximate the
(vectorial) integrals. Users can choose between <code>"Uniform"</code>
discretization or the <code>"Simpson"</code>'s rule (the 3-point
Newton-Cotes quadrature rule).
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_randomintegrationlaw">randomIntegrationLaw</code></td>
<td>

<p>Probability measure associated to the Hilbert space spanned by the
moment conditions. See Carrasco and Florens (2003) for more details.
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_s_min">s_min</code>, <code id="CgmmParametersEstim_+3A_s_max">s_max</code></td>
<td>

<p>Lower and Upper bounds of the interval where the
moment conditions are considered; numeric.
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_theta0">theta0</code></td>
<td>

<p>Initial guess for the 4 parameters values: vector of length 4.
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_iterationcontrol">IterationControl</code></td>
<td>

<p>Only used with <code>type = "IT"</code> or <code>type = "Cue"</code> to control the
iterations, see Details.
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_pm">pm</code></td>
<td>

<p>Parametrisation, an integer (0 or 1); default: <code>pm = 0</code> (Nolan's
&lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_printtime">PrintTime</code></td>
<td>

<p>Logical flag; if set to TRUE, the estimation duration is printed out to
the screen in a readable format (h/min/sec).
</p>
</td></tr>
<tr><td><code id="CgmmParametersEstim_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to the optimisation function and/or to
the integration function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>The moment conditions</b>

The moment conditions are given by:
</p>
<p style="text-align: center;"><code class="reqn">g_t(X,\theta)=g(t,X;\theta)= e^{itX} - \phi_{\theta}(t)</code>
</p>

<p>If one has a sample <code class="reqn">x_1,\dots,x_n</code> of i.i.d realisations of the
same random variable <code class="reqn">X</code>, then: 
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}_n(t,\theta)  = \frac{1}{n}\sum_{i=1}^n g(t,x_i;\theta) =  \phi_n(t) -\phi_\theta(t),</code>
</p>

<p>where <code class="reqn">\phi_n(t)</code> is the eCF associated with the sample
<code class="reqn">x_1,\dots,x_n</code>, defined by <code class="reqn">\phi_n(t)= \frac{1}{n}
    \sum_{j=1}^n e^{itX_j}</code>.

<b>Objective function</b>

</p>
<p>Following Carrasco et al. (2007, Proposition 3.4),
the objective function to minimise is given by:
</p>
<p style="text-align: center;"><code class="reqn">obj(\theta)=\overline{\underline{v}^{\prime}}(\theta)[\alpha_{Reg} \mathcal{I}_n+C^2]^{-1}\underline{v}(\theta)</code>
</p>

<p>where:
</p>

<dl>
<dt>
<code class="reqn">\underline{v} = [v_1,\ldots,v_n]^{\prime}</code>;</dt><dd><p><code class="reqn">v_i(\theta)
	= \int_I \overline{g_i}(t;\hat{\theta}^1_n) \hat{g}(t;\theta) \pi(t) dt</code>.
</p>
</dd>
<dt><code class="reqn">I_n</code></dt><dd><p>is the identity matrix of size <code class="reqn">n</code>.</p>
</dd>
<dt><code class="reqn">C</code></dt><dd><p>is a <code class="reqn">n \times n</code> matrix with <code class="reqn">(i,j)</code>th
element given by
<code class="reqn">c_{ij} = \frac{1}{n-4}\int_I
	\overline{g_i}(t;\hat{\theta}^1_n) g_j(t;\hat{\theta}^1_n)
	\pi(t) dt</code>.
</p>
</dd>
</dl>

<p>To compute <code class="reqn">C</code> and <code class="reqn">v_i()</code> we will use the function
<code><a href="#topic+IntegrateRandomVectorsProduct">IntegrateRandomVectorsProduct</a></code>.

<b>The IterationControl</b>

If <code>type = "IT"</code> or <code>type = "Cue"</code>, the user can control
each iteration using argument <code>IterationControl</code>, which should be
a <code>list</code> which contains the following elements:
</p>

<dl>
<dt><code>NbIter</code>:</dt><dd><p>maximum number of iterations.
The loop stops when <code>NBIter</code> is reached; default = 10.
</p>
</dd>
<dt><code>PrintIterlogical</code>:</dt><dd><p>if set to TRUE the values of the
current parameter estimates are printed to the screen at each
iteration; default = TRUE.
</p>
</dd>
<dt><code>RelativeErrMax</code>:</dt><dd><p>the loop stops if the relative error
between two consecutive estimation steps is smaller then
<code>RelativeErrMax</code>; default = 1e-3.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>Estim</code></td>
<td>
<p>output of the optimisation function,</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>estimation duration in numerical format,</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>character</code> describing the method used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>nlminb</code> as used to minimise the Cgmm objective function.
</p>


<h3>References</h3>

<p>Carrasco M, Florens J (2000).
&ldquo;Generalization of GMM to a continuum of moment conditions.&rdquo;
<em>Econometric Theory</em>, <b>16</b>(06), 797&ndash;834.
</p>
<p>Carrasco M, Florens J (2002).
&ldquo;Efficient GMM estimation using the empirical characteristic function.&rdquo;
<em>IDEI Working Paper</em>, <b>140</b>.
</p>
<p>Carrasco M, Florens J (2003).
&ldquo;On the asymptotic efficiency of GMM.&rdquo;
<em>IDEI Working Paper</em>, <b>173</b>.
</p>
<p>Carrasco M, Chernov M, Florens J, Ghysels E (2007).
&ldquo;Efficient estimation of general dynamic models with a continuum of moment conditions.&rdquo;
<em>Journal of Econometrics</em>, <b>140</b>(2), 529&ndash;573.
</p>
<p>Carrasco M, Kotchoni R (2010).
&ldquo;Efficient estimation using the characteristic function.&rdquo;
Mimeo. University of Montreal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim">Estim</a></code>,
<code><a href="#topic+GMMParametersEstim">GMMParametersEstim</a></code>,
<code><a href="#topic+IntegrateRandomVectorsProduct">IntegrateRandomVectorsProduct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## general inputs
theta &lt;- c(1.45, 0.55, 1, 0)
pm &lt;- 0
set.seed(2345)
x &lt;- rstable(50, theta[1], theta[2], theta[3], theta[4], pm)

## GMM specific params
alphaReg &lt;- 0.01
subdivisions &lt;- 20
randomIntegrationLaw &lt;- "unif"
IntegrationMethod &lt;- "Uniform"

## Estimation
twoS &lt;- CgmmParametersEstim(x = x, type = "2S", alphaReg = alphaReg, 
                          subdivisions = subdivisions, 
                          IntegrationMethod = IntegrationMethod, 
                          randomIntegrationLaw = randomIntegrationLaw, 
                          s_min = 0, s_max = 1, theta0 = NULL, 
                          pm = pm, PrintTime = TRUE)
twoS
</code></pre>

<hr>
<h2 id='ComplexCF'>
Compute the characteristic function of stable laws
</h2><span id='topic+ComplexCF'></span>

<h3>Description</h3>

<p>Theoretical characteristic function (CF) of stable laws under
parametrisation &lsquo;S0&rsquo; or &lsquo;S1&rsquo;. See Nolan (2013) for more
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComplexCF(t, theta, pm = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComplexCF_+3A_t">t</code></td>
<td>

<p>vector of (real) numbers where the CF is evaluated; numeric.
</p>
</td></tr>
<tr><td><code id="ComplexCF_+3A_theta">theta</code></td>
<td>

<p>vector of parameters of the stable law; vector of length 4.
</p>
</td></tr>
<tr><td><code id="ComplexCF_+3A_pm">pm</code></td>
<td>

<p>parametrisation, an integer (0 or 1); default: <code>pm = 0</code>
(Nolan's &lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details about the different parametrisation of the CF, see
<em>Nolan(2012)</em>.
</p>


<h3>Value</h3>

<p>vector of complex numbers with dimension <code>length(t)</code>.
</p>


<h3>References</h3>

<p>Nolan JP (2012).
<em>Stable Distributions - Models for Heavy Tailed Data</em>.
Birkhauser, Boston.
In progress, Chapter 1 online at academic2.american.edu/<code class="reqn">\sim</code>jpnolan.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jacobianComplexCF">jacobianComplexCF</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define the parameters
nt &lt;- 10
t &lt;- seq(0.1, 3, length.out = nt)
theta &lt;- c(1.5, 0.5, 1, 0)
pm &lt;- 0

## Compute the characteristic function
CF &lt;- ComplexCF(t = t, theta = theta, pm = pm)
CF
</code></pre>

<hr>
<h2 id='ComputeBest_t'>
Monte Carlo simulation to investigate the optimal number of
points to use in the moment conditions
</h2><span id='topic+ComputeBest_t'></span>

<h3>Description</h3>

<p>Runs Monte Carlo simulation for different values of <code class="reqn">\alpha</code> and
<code class="reqn">\beta</code> and computes a specified number of t-points that minimises
the determinant of the asymptotic covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeBest_t(AlphaBetaMatrix = abMat, nb_ts = seq(10, 100, 10),
              alphaReg = 0.001, FastOptim = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeBest_t_+3A_alphabetamatrix">AlphaBetaMatrix</code></td>
<td>

<p>values of the parameter <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> from which we
simulate the data. By default, the values of <code class="reqn">\gamma</code> and
<code class="reqn">\delta</code> are set to 1 and 0, respectively;
a <code class="reqn">2 \times  n</code> matrix.
</p>
</td></tr>
<tr><td><code id="ComputeBest_t_+3A_nb_ts">nb_ts</code></td>
<td>

<p>vector of numbers of t-points to use for the minimisation;
default = <code>seq(10, 100, 10)</code>.
</p>
</td></tr>
<tr><td><code id="ComputeBest_t_+3A_alphareg">alphaReg</code></td>
<td>

<p>value of the regularisation parameter; numeric, default = 0.001.
</p>
</td></tr>
<tr><td><code id="ComputeBest_t_+3A_fastoptim">FastOptim</code></td>
<td>

<p>Logical flag; if set to TRUE, <code>optim</code> with &quot;Nelder-Mead&quot; method
is used (fast but not accurate). Otherwise, <code>nlminb</code> is used
(more accurate but slower).
</p>
</td></tr>
<tr><td><code id="ComputeBest_t_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the optimisation function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing slots from class <code><a href="#topic+Best_t-class">Best_t-class</a></code>
corresponding to one value of the parameters <code class="reqn">\alpha</code> and
<code class="reqn">\beta</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComputeBest_tau">ComputeBest_tau</a></code>,
<code><a href="#topic+Best_t-class">Best_t-class</a></code>
</p>

<hr>
<h2 id='ComputeBest_tau'>
Run Monte Carlo simulation to investigate the optimal <code class="reqn">\tau</code>
</h2><span id='topic+ComputeBest_tau'></span>

<h3>Description</h3>

<p>Runs Monte Carlo simulation to investigate the optimal number of
points to use when one of the reduced spacing schemes is considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeBest_tau(AlphaBetaMatrix = abMat, nb_ts = seq(10, 100, 10),
                tScheme = c("uniformOpt", "ArithOpt"),
                Constrained = TRUE, alphaReg = 0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeBest_tau_+3A_alphabetamatrix">AlphaBetaMatrix</code></td>
<td>

<p>values of the parameter <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> from which we
simulate the data. By default, the values of <code class="reqn">\gamma</code> and
<code class="reqn">\delta</code> are set to 1 and 0, respectively;
a <code class="reqn">2 \times n</code> matrix.
</p>
</td></tr>
<tr><td><code id="ComputeBest_tau_+3A_nb_ts">nb_ts</code></td>
<td>

<p>vector of number of t-points to use for the minimisation;
default = <code>seq(10,100,10)</code>.
</p>
</td></tr>
<tr><td><code id="ComputeBest_tau_+3A_tscheme">tScheme</code></td>
<td>

<p>scheme used to select the points where the moment conditions are
evaluated, one of <code>"uniformOpt"</code> (uniform optimal placement)
and <code>"ArithOpt"</code> (arithmetic optimal placement). See function
<code><a href="#topic+GMMParametersEstim">GMMParametersEstim</a></code>.
</p>
</td></tr>
<tr><td><code id="ComputeBest_tau_+3A_constrained">Constrained</code></td>
<td>

<p>logical flag: if set to True, lower and upper bands will be computed
as discussed for function <code><a href="#topic+GMMParametersEstim">GMMParametersEstim</a></code>.
</p>
</td></tr>
<tr><td><code id="ComputeBest_tau_+3A_alphareg">alphaReg</code></td>
<td>

<p>value of the regularisation parameter; numeric, default = 0.001.
</p>
</td></tr>
<tr><td><code id="ComputeBest_tau_+3A_...">...</code></td>
<td>

<p>Other arguments to pass to the optimisation function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing slots from class <code><a href="#topic+Best_t-class">Best_t-class</a></code>
corresponding to one value of the parameters <code class="reqn">\alpha</code> and
<code class="reqn">\beta</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComputeBest_t">ComputeBest_t</a></code>,
<code><a href="#topic+Best_t-class">Best_t-class</a></code>
</p>

<hr>
<h2 id='ComputeDuration'>
Duration
</h2><span id='topic+ComputeDuration'></span>

<h3>Description</h3>

<p>Compute the duration between 2 time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeDuration(t_init, t_final, OneNumber = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeDuration_+3A_t_init">t_init</code></td>
<td>
<p>Starting time; numeric.</p>
</td></tr>
<tr><td><code id="ComputeDuration_+3A_t_final">t_final</code></td>
<td>
<p>Final time; numeric.</p>
</td></tr>
<tr><td><code id="ComputeDuration_+3A_onenumber">OneNumber</code></td>
<td>

<p>Logical flag; if set to TRUE, the duration in seconds will be
returned. Otherwise, a vector of length 3 will be computed
representing the time in h/min/sec.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>numeric</code> of length 1 or 3 depending on the value of
<code>OneNumber</code> flag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PrintDuration">PrintDuration</a></code>,
<code><a href="#topic+PrintEstimatedRemainingTime">PrintEstimatedRemainingTime</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ti &lt;- getTime_()
for (i in 1:100) x &lt;- i*22.1
tf &lt;- getTime_()
ComputeDuration(ti,tf)
</code></pre>

<hr>
<h2 id='ComputeFirstRootRealeCF'>
First root of the empirical characteristic function
</h2><span id='topic+ComputeFirstRootRealeCF'></span>

<h3>Description</h3>

<p>Computes the first root of the real part of the empirical
characteristic function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeFirstRootRealeCF(x, ..., tol = 0.001, maxIter = 100,
                        lowerBand = 1e-04, upperBand = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeFirstRootRealeCF_+3A_x">x</code></td>
<td>

<p>data used to perform the estimation: vector of length n.
</p>
</td></tr>
<tr><td><code id="ComputeFirstRootRealeCF_+3A_...">...</code></td>
<td>

<p>other arguments to pass to the optimisation function.
</p>
</td></tr>
<tr><td><code id="ComputeFirstRootRealeCF_+3A_tol">tol</code></td>
<td>

<p>tolerance to accept the solution; default = 1e-3.
</p>
</td></tr>
<tr><td><code id="ComputeFirstRootRealeCF_+3A_maxiter">maxIter</code></td>
<td>

<p>maximum number of iteration in the Welsh algorithm; default = 100.
</p>
</td></tr>
<tr><td><code id="ComputeFirstRootRealeCF_+3A_lowerband">lowerBand</code></td>
<td>

<p>lower band of the domain where the graphical seach is performed;
default = 1e-4.
</p>
</td></tr>
<tr><td><code id="ComputeFirstRootRealeCF_+3A_upperband">upperBand</code></td>
<td>

<p>Lower band of the domain where the graphical seach is performed;
default = 30.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Welsh algorithm is first applied. If it fails to provide a
satisfactory value (<code>&lt; tol</code>), a graphical/ numerical approach is
used. We first plot the real part of the eCF vs t in order to
determine the first zero directly and use it as the initial guess of a
numerical minimisation routine.
</p>


<h3>Value</h3>

<p><code>numeric</code>: first zero of the real part of the eCF.
</p>


<h3>References</h3>

<p>Welsh AH (1986).
&ldquo;Implementing empirical characteristic function procedures.&rdquo;
<em>Statistics &amp; probability letters</em>, <b>4</b>(2), 65&ndash;67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComplexCF">ComplexCF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(345)
x &lt;- rstable(500, 1.5, 0.5)
ComputeFirstRootRealeCF(x)
</code></pre>

<hr>
<h2 id='ComputeStatObjectFromFiles'>
Parse an output file to create a summary object (<code>list</code>)
</h2><span id='topic+ComputeStatObjectFromFiles'></span>

<h3>Description</h3>

<p>Parses the file saved by <code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code> and re-creates
a summary list identical to the one produced by
<code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code> when <code>StatSummary</code> is set to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeStatObjectFromFiles(files, sep_ = ",",
                           FctsToApply = StatFcts,
                           headers_=TRUE,readSizeFrom=1,
                           CheckMat=TRUE,
                           tolFailCheck=tolFailure,
                           MCparam=1000,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_files">files</code></td>
<td>

<p><code>character</code> vector containing the files name to be parsed.
See Details.
</p>
</td></tr>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_sep_">sep_</code></td>
<td>

<p>field separator character to be used in function <code>read.csv()</code>
and <code>write.table()</code>.  Values on each line of the file are
separated by this character. It can also be a character vector (same
length as <code>files</code>) if different separators are used for each
file; default: <code>","</code>.
</p>
</td></tr>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_fctstoapply">FctsToApply</code></td>
<td>

<p>functions used to produce the statistical summary.
See <code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>; character vector.
</p>
</td></tr>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_headers_">headers_</code></td>
<td>

<p><code>boolean</code> vector of length 1 or same length as <code>files</code> to
indicate for each file if the header argument is to be considered or
not. To be passed to function <code>read.csv()</code>.
</p>
</td></tr>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_readsizefrom">readSizeFrom</code></td>
<td>

<p>index of the file from which the sample sizes are determined;
default 1 (from first file in <code>files</code>).
</p>
</td></tr>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_checkmat">CheckMat</code></td>
<td>

<p>logical flag: if set to TRUE, an estimation is declared failed if
the squared error of the estimation is larger than
<code>tolFailCheck</code>; default TRUE.
</p>
</td></tr>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_tolfailcheck">tolFailCheck</code></td>
<td>

<p>tolerance on the squared error of the estimation to be declared
failed; default = 1.5.
</p>
</td></tr>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_mcparam">MCparam</code></td>
<td>

<p>number of Monte Carlo simulation for each couple of parameter,
default = 1000; integer.
</p>
</td></tr>
<tr><td><code id="ComputeStatObjectFromFiles_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to the estimation function.
See <code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The same sample sizes are assumed for all the files and we also assume
a different set of parameters (<code>alpha</code>,<code>beta</code>) within each
file (one and one only).
</p>
<p>This function is particularly useful when simulations are run in
parallel on different computers/CPUs and the output files are
collected afterwards. This function is also used to create the Latex
summary table: see <code><a href="#topic+TexSummary">TexSummary</a></code>.
</p>
<p>Some examples are provided in the example folder.
</p>


<h3>Value</h3>

<p>a list of <code>length</code> 4 containing a summary <code>matrix</code> object
associated to each parameter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>
</p>

<hr>
<h2 id='ConcatFiles'>
Concatenates output files.
</h2><span id='topic+ConcatFiles'></span>

<h3>Description</h3>

<p>Creates a unique file by concatenating several output files associated
to one set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConcatFiles(files, sep_ = ",", outfile, headers_ = TRUE,
            DeleteIfExists=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConcatFiles_+3A_files">files</code></td>
<td>

<p><code>character</code> Vector containing the files name to be concatenated.
See details.
</p>
</td></tr>
<tr><td><code id="ConcatFiles_+3A_sep_">sep_</code></td>
<td>

<p>Field separator character to be used in function
<code>read.csv()</code> and <code>write.table()</code>.
Values on each line of the file are separated by
this character; It can also be a vector character
(same length as <code>files</code>) if different separators are useed for
each file; default: &quot;,&quot;
</p>
</td></tr>
<tr><td><code id="ConcatFiles_+3A_outfile">outfile</code></td>
<td>

<p>Name of the output file; <code>character</code>
</p>
</td></tr>
<tr><td><code id="ConcatFiles_+3A_headers_">headers_</code></td>
<td>

<p>Vector of <code>boolean</code> of length 1 or same length as <code>files</code>
to indicate for each file if the header argument is to be considered
or not. To be passed to function <code>read.csv()</code>. 
</p>
</td></tr>
<tr><td><code id="ConcatFiles_+3A_deleteifexists">DeleteIfExists</code></td>
<td>
<p>if <code>outfile</code> exists, it will be deleted and
recreated (over-written).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The files to be concatenated should be related to the same set of
parameters <code>alpha</code> and <code>beta</code>. The function stops if one of
the file contains 2 (or more) different set of parameters (the
function compares the values of columns 1 and 2 row by row) or if the
set of parameters within one file is different from the one from other
files.
</p>


<h3>Value</h3>

<p>Returns an output file <code>outfile</code> saved in the working directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>
</p>

<hr>
<h2 id='Estim'>Estimate parameters of stable laws</h2><span id='topic+Estim'></span>

<h3>Description</h3>

<p>Estimates the four parameters of stable distributions using one of the
methods implemented in <span class="pkg">StableEstim</span>. This is the main user-level
function but the individul methods are available also as separate
functions.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Estim(EstimMethod = c("ML", "GMM", "Cgmm","Kout"), data, theta0 = NULL,
      ComputeCov = FALSE, HandleError = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Estim_+3A_estimmethod">EstimMethod</code></td>
<td>

<p>Estimation method to be used, one of <code>"ML"</code> (maximum
likelihood, default), <code>"GMM"</code> (generalised method of moment with finite
moment conditions), <code>"Cgmm"</code> (GMM with continuum moment
conditions), and <code>"Kout"</code> (Koutrouvelis regression method).
</p>
</td></tr>
<tr><td><code id="Estim_+3A_data">data</code></td>
<td>

<p>Data used to perform the estimation, a numeric vector.
</p>
</td></tr>
<tr><td><code id="Estim_+3A_theta0">theta0</code></td>
<td>

<p>Initial values for the 4 parameters. If <code>NULL</code> (default),
initial values are computed using the fast Kogon-McCulloch method,
see <code><a href="#topic+IGParametersEstim">IGParametersEstim</a></code>; vector of length 4.
</p>
</td></tr>
<tr><td><code id="Estim_+3A_computecov">ComputeCov</code></td>
<td>

<p>Logical flag: if <code>TRUE</code>, the asymptotic covariance matrix (4x4)
is computed (except for the Koutrouvelis method).
</p>
</td></tr>
<tr><td><code id="Estim_+3A_handleerror">HandleError</code></td>
<td>

<p>Logical flag: if <code>TRUE</code> and if an error occurs during the
estimation procedure, the computation will carry on and <code>NA</code>
will be returned. Useful for Monte Carlo simulations, see
<code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>.
</p>
</td></tr>
<tr><td><code id="Estim_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to the estimation function, such as the
asymptotic confidence level, see Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Estim</code> is the main estimation function in package
<span class="pkg">StableEstim</span>. 
</p>
<p>This function should be used in priority for estimation purpose as it
provides more information about the estimator. However, user needs to
pass the appropriate parameters to the selected method in
<code>...</code>. See the documentation of the selected method.
</p>
<p><b>Asymptotic Confidence Intervals</b>:
The <em>normal</em> asymptotic confidence intervals (CI) are computed.
The user can set the <em>level</em> of confidence by inputing the
<code>level</code> argument (in the <code>"\dots"</code>); default
<code>level=0.95</code>. The theoretical justification for asymptotic normal
CI can be found in the references for the individual methods. Note the
CI's are not computed for the Koutrouvelis regression method.
</p>


<h3>Value</h3>

<p>an object of class <code>Estim</code>, see <code><a href="#topic+Estim-class">Estim-class</a></code> for
more details
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CgmmParametersEstim">CgmmParametersEstim</a></code>,
<code><a href="#topic+GMMParametersEstim">GMMParametersEstim</a></code>,
<code><a href="#topic+MLParametersEstim">MLParametersEstim</a></code>,
<code><a href="#topic+KoutParametersEstim">KoutParametersEstim</a></code> for the individual estimation
methods;
</p>
<p><code><a href="#topic+IGParametersEstim">IGParametersEstim</a></code> for fast computation of initial
values. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## general inputs
theta &lt;- c(1.45, 0.55, 1, 0)
pm &lt;- 0
set.seed(2345)
x &lt;- rstable(200, theta[1], theta[2], theta[3], theta[4], pm)

objKout &lt;- Estim(EstimMethod = "Kout", data = x, pm = pm, 
                     ComputeCov = FALSE, HandleError = FALSE, 
                     spacing = "Kout")
</code></pre>

<hr>
<h2 id='Estim_Simulation'>
Monte Carlo simulation
</h2><span id='topic+Estim_Simulation'></span>

<h3>Description</h3>

<p>Runs Monte Carlo simulation for a selected estimation method. The
function can save a file and produce a statistical summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Estim_Simulation(AlphaBetaMatrix = abMat, SampleSizes = c(200, 1600),
                 MCparam = 100, Estimfct = c("ML", "GMM", "Cgmm","Kout"),
                 HandleError = TRUE, FctsToApply = StatFcts,
                 saveOutput = TRUE, StatSummary = FALSE,
                 CheckMat = TRUE, tolFailCheck = tolFailure,
                 SeedOptions=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Estim_Simulation_+3A_alphabetamatrix">AlphaBetaMatrix</code></td>
<td>

<p>values of the parameter <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> from which we
simulate the data. By default, the values of <code class="reqn">\gamma</code> and
<code class="reqn">\delta</code> are set to 1 and 0, respectively;
a <code class="reqn">2 \times n</code> matrix.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_samplesizes">SampleSizes</code></td>
<td>

<p>sample sizes to be used to simulate the data. By default, we use
<code>200</code> (small sample size) and <code>1600</code> (large sample size);
vector of integers.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_mcparam">MCparam</code></td>
<td>

<p>Number of Monte Carlo simulation for each couple of parameter,
default = 100; an integer number.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_estimfct">Estimfct</code></td>
<td>

<p>the estimation function to be used, one of 
<code>"ML"</code>, <code>"GMM"</code>, <code>"Cgmm"</code> or <code>"Kout"</code>.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_handleerror">HandleError</code></td>
<td>

<p>logical flag: if set to TRUE, the simulation doesn't stop when an
error in the estimation function is encountered. A vector of (size
4) <code>NA</code> is saved and the the simulation carries on. See
details.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_fctstoapply">FctsToApply</code></td>
<td>

<p>functions used to produce the statistical summary. See details;
a character vector.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_saveoutput">saveOutput</code></td>
<td>

<p>logical flag: if set to TRUE, a csv file (for each couple of
parameters <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>) with the the estimation
information is saved in the current directory. See Details.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_statsummary">StatSummary</code></td>
<td>

<p>logical flag: if set to TRUE, a statistical summary (using
<code>FctsToApply</code>) is returned. See Details.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_checkmat">CheckMat</code></td>
<td>

<p>logical flag: if set to TRUE, an estimation is declared failed if
the squared error of the estimation is larger than
<code>tolFailCheck</code>; default = TRUE.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_tolfailcheck">tolFailCheck</code></td>
<td>

<p>tolerance on the squared error of the estimation to be declared
failed; default = 1.5.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_seedoptions">SeedOptions</code></td>
<td>

<p>list to control the seed generation. See Details.
</p>
</td></tr>
<tr><td><code id="Estim_Simulation_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to the estimation function.
</p>
</td></tr>
</table>


<h3>Details</h3>


<p><b>Error Handling</b>

It is advisable to set it to TRUE when the user is planning to launch
long simulations as it will prevent the procedure from stopping if an
error occurs for one sample data. The estimation function will produce
a vector of <code>NA</code> as estimated parameters related to this (error
generating) sample data and move on to the next Monte Carlo step.

<b>Statistical summary</b>

The function is able to produce a statistical summary of the Monte
Carlo simulation for each parameter (slices of the list). Each slice
is a matrix where the rows represents the true values of the
parameters and the columns the statistical information.

In all cases, the following quantities are computed:
</p>

<dl>
<dt><code>sample size</code>:</dt><dd>
<p>the sample size used to produce the simulated data.
</p>
</dd>
<dt><code>alphaT</code>, <code>betaT</code>:</dt><dd>
<p>the true values of the parameters.
</p>
</dd>
<dt><code>failure</code>:</dt><dd>
<p>the number of times the procedure failed to produce relevant
estimation.
</p>
</dd>
<dt><code>time</code>:</dt><dd>
<p>the average running time in seconds of the estimation procedure
</p>
</dd>
</dl>

<p>Besides, the (vector of <code>character</code>) <code>FctsToApply</code> controls
the other quantities to be computed by providing the name of the
function object to be applied to the vector of estimated
parameters. The signature of the function should be of the form
<code>fctName = function(p,...){...}</code>, where <code>p</code> is the vector
(<code>length(p) = MCparam</code>) of parameter estimates and <code>...</code>
is the extra arguments to be passed the function.
</p>
<p>By default, the functions from <code>StatFcts</code> will be applied but the
user can pass his own functions by providing their names in argument
<code>FctsToApply</code> and their definitions in the global environment.
</p>
<p>Note that if <code>CheckMat</code> is set to TRUE, the estimation is
considered failed if the squared error (of the first 2 parameters
<code>alpha</code> and <code>beta</code>) is larger than <code>tolFailCheck</code>.
</p>
<p><b>Output file</b>
</p>
<p>Setting <code>saveOutput</code> to TRUE will have the side effect of saving
a csv file in the working directory. This file will have
<code>MCparam * length(SampleSizes)</code> lines and its columns will
be:
</p>

<dl>
<dt><code>alphaT</code>, <code>betaT</code>:</dt><dd>
<p>the true values of the parameters.
</p>
</dd> 
<dt><code>data size</code>:</dt><dd>
<p>the sample size used to generate the simulated data.
</p>
</dd>
<dt><code>seed</code>:</dt><dd>
<p>the seed value used to generate the simulated data.
</p>
</dd>
<dt><code>alphaE</code>, <code>betaE</code>, <code>gammaE</code>, <code>deltaE</code>:</dt><dd>
<p>the estimates of the 4 parameters.
</p>
</dd>
<dt><code>failure</code>:</dt><dd>
<p>binary: 0 for success, 1 for failure.
</p>
</dd>
<dt><code>time</code>:</dt><dd>
<p>estimation running time in seconds.
</p>
</dd>
</dl>

<p>The file name is informative to let the user identify the values of
the true parameters, the MC parameters, as well as the options
selected for the estimation method.
</p>
<p>The csv file is updated after each MC estimation, which is useful when
the simulation stops before it finishes. Besides, using the
check-pointing mechanism explained below, the simulation can re-start
from where it stopped.
</p>
<p><em>Check-pointing.</em>
Checkpointing is the act of saving enough program state and results so
far calculated that a computation can be stopped and restarted. The
way we did it here is to save a text file with some useful information
about the state of the estimation. This text file is updated after
each MC iteration and read at the beginning of function
<code>Estim_Simulation</code> to allow the simulation to re-start from where
it stopped. This file is deleted at the end of the simulation
procedure.
</p>
<p><em>SeedOptions.</em>
Users who do not want to control the seed generation can ignore this
argument (its default value is <code>NULL</code>). This argument can be more
useful when one wants to cut the simulation (even for one parameter
value) into pieces. In that case, the user can control which part of
the seed vector to use.
</p>

<dl>
<dt><code>MCtot</code>:</dt><dd>
<p>total values of MC simulations in the entire process.
</p>
</dd>
<dt><code>seedStart</code>:</dt><dd>
<p>starting index in the seed vector. The vector extracted will be of
size <code>MCparam</code>.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>If <code>StatSummary</code> is set to TRUE, a <code>list</code> with 4 components
(corresponding to the 4 parameters) is returned. Each component is a
matrix. If <code>SaveOutput</code> is set to TRUE, only a csv file is saved
and nothing is returned (if <code>StatSummary</code> is FALSE).  If both are
FALSE, the function stops.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim">Estim</a></code>,
<code><a href="#topic+CgmmParametersEstim">CgmmParametersEstim</a></code>,
<code><a href="#topic+GMMParametersEstim">GMMParametersEstim</a></code>,
<code><a href="#topic+MLParametersEstim">MLParametersEstim</a></code>
</p>

<hr>
<h2 id='Estim-class'>Class <code>"Estim"</code></h2><span id='topic+Estim-class'></span><span id='topic+initialize+2CEstim-method'></span><span id='topic+show+2CEstim-method'></span>

<h3>Description</h3>

<p>Class for storing the results of estimating parameters of stable
laws, output of function <code>Estim()</code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Estim", par,
  ...)</code>.  Users can provide some (or all) of the inputs stated below to
create an object from this class or call function <code><a href="#topic+Estim">Estim</a></code>
with appropriate arguments.
</p>


<h3>Slots</h3>


<dl>
<dt><code>par</code>:</dt><dd>
<p><code>numeric(4)</code>, values of the 4 estimated parameters.
</p>
</dd>
<dt><code>par0</code>:</dt><dd>
<p><code>numeric(4)</code>, initial values for the 4 parameters.      
</p>
</dd>
<dt><code>vcov</code>:</dt><dd>
<p>object of class <code>"matrix"</code> (<code>4 x 4</code>),
representing the covariance matrix of the estimated parameters.
</p>
</dd>
<dt><code>confint</code>:</dt><dd>
<p>object of class <code>"matrix"</code> (<code>4 x 4</code>),
representing the confidence interval computed
at a specific level (attribute of the object).
</p>
</dd>
<dt><code>data</code>:</dt><dd>
<p><code>numeric()</code>, the data used to compute the estimates.
</p>
</dd>
<dt><code>sampleSize</code>:</dt><dd>
<p><code>numeric(1)</code>, length of the data.
</p>
</dd>
<dt><code>others</code>:</dt><dd>
<p><code>list()</code>,
further information about the estimation method.
</p>
</dd>
<dt><code>duration</code>:</dt><dd>
<p><code>numeric(1)</code>, duration in seconds.
</p>
</dd>
<dt><code>failure</code>:</dt><dd>
<p><code>numeric(1)</code>,
represents the status of the procedure: 0 failure or 1 success.
</p>
</dd>
<dt><code>method</code>:</dt><dd>
<p>Object of class <code>"character"</code>,
description of the parameters used in the estimation.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd><p><code>signature(.Object = "Estim")</code>:
creates an object of this class using the inputs described above.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Estim")</code>:
summarised print of the object.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Estim">Estim</a></code>
</p>

<hr>
<h2 id='expect_almost_equal'>
Test approximate equality
</h2><span id='topic+expect_almost_equal'></span>

<h3>Description</h3>

<p>Tests the approximate equality of 2 objects. Useful for running tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expect_almost_equal(x, y, tolExpect = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expect_almost_equal_+3A_x">x</code></td>
<td>
<p>first object.</p>
</td></tr>
<tr><td><code id="expect_almost_equal_+3A_y">y</code></td>
<td>
<p>second object.</p>
</td></tr>
<tr><td><code id="expect_almost_equal_+3A_tolexpect">tolExpect</code></td>
<td>

<p>tolerance, default is 0.001.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with the <code>expect_that</code> function from package
<code>testhat</code> to test equality between 2 objects with a given
tolerance. It is used particularly for testing functions output. See the
CF examples in the Examples folder.
</p>


<h3>See Also</h3>

<p><code>expect_that</code>,<code>testthat</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1.1
y &lt;- 1.5
expect_almost_equal(x, y, 1)      # passes
## expect_almost_equal(x, y, 0.3) # fails
</code></pre>

<hr>
<h2 id='get.abMat'>
Default set of parameters to pass to <code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>
</h2><span id='topic+get.abMat'></span>

<h3>Description</h3>

<p>Default set of parameters to pass to <code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>,
inspired by the one used by Koutrevelis (1980) in his simulation
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abMat()
</code></pre>


<h3>Value</h3>

<p>a 2-columns matrix containing a wide range of parameters <code class="reqn">\alpha</code>
and <code class="reqn">\beta</code> covering the entire parameters space.
</p>

<hr>
<h2 id='get.StatFcts'>
Default functions used to produce the statistical summary
</h2><span id='topic+get.StatFcts'></span>

<h3>Description</h3>

<p>Default functions used to produce the statistical summary in the
Monte Carlo simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.StatFcts()
</code></pre>


<h3>Value</h3>

<p>The functions computed are:
</p>

<dl>
<dt>Mean</dt><dd><p><code>.mean &lt;- function(p,...) mean(p)</code></p>
</dd>
<dt>Min</dt><dd><p><code>.min &lt;- function(p,...) min(p)</code></p>
</dd>
<dt>Max</dt><dd><p><code>.max &lt;- function(p,...) max(p)</code></p>
</dd>
<dt>Sn</dt><dd><p><code>.Sn &lt;- function(p,n,...) sqrt(n)*sd(p)</code></p>
</dd>
<dt>MSE</dt><dd><p><code>.MSE &lt;- function(p,paramT,...) (1/length(p))*sum((p-paramT)^2)</code></p>
</dd>
<dt>Std error</dt><dd><p><code>.st.err &lt;- function(p,...) sd(p)/sqrt(length(p))</code></p>
</dd>
</dl>

<p>Users can define their own summaries by defining functions with
similar signatures and passing a <code>character</code> vector containing
the functions' names to <code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>.
</p>

<hr>
<h2 id='getTime_'>
Read time
</h2><span id='topic+getTime_'></span>

<h3>Description</h3>

<p>Reads the time when the function is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTime_()
</code></pre>


<h3>Value</h3>

<p>a <code>numeric</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PrintDuration">PrintDuration</a></code>,
<code><a href="#topic+PrintEstimatedRemainingTime">PrintEstimatedRemainingTime</a></code>,
<code><a href="#topic+ComputeDuration">ComputeDuration</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ti &lt;- getTime_()
</code></pre>

<hr>
<h2 id='GMMParametersEstim'>
Estimate parameters of stable laws using a GMM method
</h2><span id='topic+GMMParametersEstim'></span>

<h3>Description</h3>

<p>Estimate parameters of stable laws using generalised method of
moments (GMM) with finite number of moment conditions. It uses a
regularisation technique to make the method more robust (when the
number of moment condition is large) and allows different schemes
to select where the moment conditions are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GMMParametersEstim(x, algo = c("2SGMM", "ITGMM", "CueGMM"),
                   alphaReg = 0.01,
                   regularization = c("Tikhonov", "LF", "cut-off"),
                   WeightingMatrix = c("OptAsym", "DataVar", "Id"),
                   t_scheme = c("equally", "NonOptAr", "uniformOpt",
                                "ArithOpt", "VarOpt", "free"),
                   theta0 = NULL,
                   IterationControl = list(),
                   pm = 0, PrintTime = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GMMParametersEstim_+3A_x">x</code></td>
<td>

<p>data used to perform the estimation: vector of length n.
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_algo">algo</code></td>
<td>

<p>GMM algorithm: <code>"2SGMM"</code> is the two step GMM proposed by
Hansen(1982). <code>"CueGMM"</code> and <code>"ITGMM"</code> are respectively
the continuous updated and the iterative GMM proposed by Hansen,
Eaton et Yaron (1996) and adapted to the continuum case.
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_alphareg">alphaReg</code></td>
<td>

<p>value of the regularisation parameter; numeric, default = 0.01.
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_regularization">regularization</code></td>
<td>

<p>regularization scheme to be used, one of <code>"Tikhonov"</code>
(Tikhonov), <code>"LF"</code> (Landweber-Fridmann) and <code>"cut-off"</code>
(spectral cut-off). See <code><a href="#topic+RegularisedSol">RegularisedSol</a></code>.
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_weightingmatrix">WeightingMatrix</code></td>
<td>

<p>type of weighting matrix used to compute the objective function, one
of <code>"OptAsym"</code> (the optimal asymptotic), <code>"DataVar"</code> (the
data driven) and <code>"Id"</code> (the identity matrix). See Details.
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_t_scheme">t_scheme</code></td>
<td>

<p>scheme used to select the points where the moment conditions are
evaluated, one of <code>"equally"</code> (equally placed),
<code>"NonOptAr"</code> (non optimal arithmetic placement),
<code>"uniformOpt"</code> (uniform optimal placement), <code>"ArithOpt"</code>
(arithmetic optimal placement), <code>"Var Opt"</code> (optimal variance
placement) and <code>"free"</code> (users need to pass their own set of
points in <code>...</code>). See Details.
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_theta0">theta0</code></td>
<td>

<p>initial guess for the 4 parameters values: if <code>NULL</code>, the
Kogon-McCulloch method is called, see
<code><a href="#topic+IGParametersEstim">IGParametersEstim</a></code>; vector of length 4.
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_iterationcontrol">IterationControl</code></td>
<td>

<p>only used if <code>type = "IT"</code> or <code>type = "Cue"</code> to control the
iterations. See Details.
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_pm">pm</code></td>
<td>

<p>parametrisation, an integer (0 or 1); default: <code>pm = 0</code>
(Nolan's &lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_printtime">PrintTime</code></td>
<td>

<p>logical flag; if set to TRUE, the estimation duration is printed out
to the screen in a readable format (h/min/sec).
</p>
</td></tr>
<tr><td><code id="GMMParametersEstim_+3A_...">...</code></td>
<td>

<p>other arguments to pass to the regularisation function,
the optimisation function or the selection scheme (including the
function that finds the first zero of the eCF). See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>The moment conditions</b>
</p>
<p>The moment conditions are given by:
</p>
<p style="text-align: center;"><code class="reqn">g_t(X,\theta) = g(t,X;\theta)= e^{itX} - \phi_{\theta}(t)</code>
</p>

<p>If one has a sample <code class="reqn">x_1,\dots,x_n</code> of i.i.d realisations of the
same random variable <code class="reqn">X</code>, then: 
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}_n(t,\theta)  = \frac{1}{n}\sum_{i=1}^n g(t,x_i;\theta) =
    \phi_n(t) -\phi_\theta(t),</code>
</p>
 
<p>where <code class="reqn">\phi_n(t)</code> is the eCF associated to the sample
<code class="reqn">x_1,\dots,x_n</code>, and defined by
<code class="reqn">\phi_n(t)= \frac{1}{n} \sum_{j=1}^n e^{itX_j}</code>. 
</p>
<p><b>Objective function</b>
</p>
<p style="text-align: center;"><code class="reqn">obj{\theta} =
    &lt; K^{-1/2} \hat{g}_n(.;\theta),K^{-1/2}\hat{g}_n(.;\theta)&gt;,</code>
</p>
 
<p>where <code class="reqn">K^{-1}f</code> denotes the solution <code class="reqn">\varphi</code> (when it
exists) of the equation <code class="reqn">K \varphi=f</code> and
<code class="reqn">K^{-1/2}=(K^{-1})^{1/2}</code>.  The optimal choice of the Weighting
operator K (a matrix in the GMM case) and its estimation are discussed
in Hansen (1982).
</p>
<p><b>Weighting operator (Matrix)</b>
</p>

<dl>
<dt><code>OptAsym</code>:</dt><dd>
<p>the optimal asymptotic choice as described by Hansen. The
expression of the components of this matrix could be found for
example in Feuerverger and McDunnough (1981b).
</p>
</dd>
<dt><code>DataVar</code>:</dt><dd>
<p>the covariance matrix of the data provided.
</p>
</dd>
<dt><code>Id</code>:</dt><dd>
<p>the identity matrix.
</p>
</dd>
</dl>

<p><b>the t-scheme</b>
</p>
<p>One of the most important features of this method is that it allows
the user to choose how to place the points where the moment conditions
are evaluated. The general rule is that users can provide their own
set of points (option <code>"free"</code>) or choose one of the other
schemes. In the latter case they <em>need to specify the number of
points</em> <code>nb_t</code> in argument <code>"\dots"</code> and eventually the
lower and upper limit (by setting <code>Constrained</code> to FALSE and
providing <code>min_t</code> and <code>max_t</code>) in the non-optimised case. If
one of the optimised cases is selected, setting <code>Constrained</code> to
FALSE will not constrain the choice of <code class="reqn">\tau</code>, see below.  We mean
by optimised set of point, the set that minimises the (determinant) of
the asymptotic covariance matrix as suggested by Schmidt (1982) and
Besbeas and Morgan (2008).
</p>
<p>6 options have been implemented:
</p>

<dl>
<dt><code>"equally"</code>:</dt><dd>
<p>equally placed points in [<code>min_t</code>,<code>max_t</code>]. When
provided, user's <code>min_t</code> and <code>max_t</code> will be used (when
<code>Coinstrained = FALSE</code>).  Otherwise, <code>eps</code> and <code>An</code>
will be used instead (where <code>An</code> is the first zero of the
eCF).
</p>
</dd>
<dt><code>"NonOptAr"</code>:</dt><dd>
<p>non optimal arithmetic placement: <code class="reqn">t_j =
      \frac{j(j+1)}{nbt(nbt+1)}(max-eps); j=1,\dots,nbt</code>, where
<code class="reqn">max</code> is the upper band of the set of points selected as
discussed before.
</p>
</dd>
<dt><code>"uniformOpt"</code>:</dt><dd>
<p>uniform optimal placement: <code class="reqn">t_j=j \tau, j=1,\dots, nbt</code>
</p>
</dd>
<dt><code>"ArithOpt"</code>:</dt><dd>
<p>arithmetic optimal placement: <code class="reqn">t_j=j(j+1) \tau, j=1,\dots nbt</code>
</p>
</dd>
<dt><code>"Var Opt"</code>:</dt><dd>
<p>optimal variance placement as explained above.
</p>
</dd>
<dt><code>"free"</code>:</dt><dd>
<p>user needs to pass his own set of points in <code>"\dots"</code>.
</p>
</dd>
</dl>

<p>For the <code>"ArithOpt"</code> and <code>"uniformOpt"</code> schemes, the
function to minimise is seen as a function of the real parameter
<code class="reqn">\tau</code> instead of doing a vectorial optimisition as in the
<code>"Var Opt"</code> case. In the latter case, one can choose between a
fast (but less accurate) optimisation routine or a slow (but more
accurate) one by setting the <code>FastOptim</code> flag to the desired
value.
</p>
<p><b>The IterationControl</b>
</p>
<p>If <code>type = "IT"</code> or <code>type = "Cue"</code> the user can control each
iteration by setting up the <code>list</code> <code>IterationControl</code> which
contains the following elements:
</p>

<dl>
<dt><code>NbIter</code>:</dt><dd>
<p>maximum number of iteration. The loop stops when <code>NBIter</code> is
reached; default = 10.
</p>
</dd>
<dt><code>PrintIterlogical</code>:</dt><dd>
<p>if set to TRUE, the value of the current parameter estimation is
printed to the screen at each iteration; default = TRUE.
</p>
</dd>
<dt><code>RelativeErrMax</code>:</dt><dd>
<p>the loop stops if the relative error between two consecutive
estimation steps is smaller than <code>RelativeErrMax</code>; default =
1e-3.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>Estim</code></td>
<td>
<p>output of the optimisation function.</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>estimation duration in a numerical format.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>character</code> describing the method used.</p>
</td></tr>
<tr><td><code>tEstim</code></td>
<td>

<p>final set of points selected for the estimation. Only relevant when
one of the optimisation scheme is selected.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>nlminb</code> was used for the minimisation of the GMM objective
funcion and to compute <code class="reqn">tau</code> in the <code>"uniformOpt"</code> and
<code>"ArithOpt"</code> schemes. In the <code>"Var Opt"</code> scheme,
<code>optim</code> was preferred. All those routines have been selected
after running different tests using the summary table produced by
package <span class="pkg">optimx</span> for comparing the performance of different
optimisation methods.
</p>


<h3>References</h3>


<p>Hansen LP (1982).
&ldquo;Large sample properties of generalized method of moments estimators.&rdquo;
<em>Econometrica: Journal of the Econometric Society</em>, pp. 1029&ndash;1054.
</p>

<p>Hansen LP, Heaton J and Yaron A (1996).
&ldquo;Finite-sample properties of some alternative GMM estimators.&rdquo;
<em>Journal of Business &amp; Economic Statistics</em>, <b>14</b>(3), pp. 262&ndash;280.
</p>

<p>Feuerverger A and McDunnough P (1981).
&ldquo;On efficient inference in symmetric stable laws and processes.&rdquo;
<em>Statistics and Related Topics</em>, <b>99</b>, pp. 109&ndash;112.
</p>

<p>Feuerverger A and McDunnough P (1981).
&ldquo;On some Fourier methods for inference.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>76</b>(374), pp. 379&ndash;387.
</p>

<p>Schmidt P (1982).
&ldquo;An improved version of the Quandt-Ramsey MGF estimator for mixtures of normal distributions and switching regressions.&rdquo;
<em>Econometrica: Journal of the Econometric Society</em>, pp. 501&ndash;516.
</p>

<p>Besbeas P and Morgan B (2008).
&ldquo;Improved estimation of the stable laws.&rdquo;
<em>Statistics and Computing</em>, <b>18</b>(2), pp. 219&ndash;231.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim">Estim</a></code>,
<code><a href="#topic+CgmmParametersEstim">CgmmParametersEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## General data
theta &lt;- c(1.5, 0.5, 1, 0)
pm &lt;- 0
set.seed(345);
x &lt;- rstable(100, theta[1], theta[2], theta[3], theta[4], pm)
##---------------- 2S free ----------------
## method specific arguments
regularization &lt;- "cut-off"
WeightingMatrix &lt;- "OptAsym"
alphaReg &lt;- 0.005
t_seq &lt;- seq(0.1, 2, length.out = 12)

## If you are just interested by the value
## of the 4 estimated parameters
t_scheme = "free"
algo = "2SGMM"
     
suppressWarnings(GMMParametersEstim(
    x = x, algo = algo, alphaReg = alphaReg, 
    regularization = regularization, 
    WeightingMatrix = WeightingMatrix, 
    t_scheme = t_scheme, 
    pm = pm, PrintTime = TRUE, t_free = t_seq))
</code></pre>

<hr>
<h2 id='IGParametersEstim'>
Estimate parameters of stable laws by Kogon and McCulloch methods
</h2><span id='topic+IGParametersEstim'></span>

<h3>Description</h3>

<p>Kogon regression method is used together with the McCulloch quantile
method to provide initial estimates of parameters of stable
distributions. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IGParametersEstim(x, pm = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IGParametersEstim_+3A_x">x</code></td>
<td>

<p>data used to perform the estimation: vector of length n.
</p>
</td></tr>
<tr><td><code id="IGParametersEstim_+3A_pm">pm</code></td>
<td>

<p>parametrisation, an integer (0 or 1); default: <code>pm = 0</code>
(Nolan's &lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
<tr><td><code id="IGParametersEstim_+3A_...">...</code></td>
<td>

<p>other arguments. Currently not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters <code class="reqn">\gamma</code> and <code class="reqn">\delta</code> are estimated using the
McCulloch(1986) quantile method from <span class="pkg">fBasics</span>. The data is
rescaled using those estimates and used to perform the Kogon
regression method to estimate <code class="reqn">\alpha</code> and <code class="reqn">\beta</code>.
</p>


<h3>Value</h3>

<p>a vector of length 4 containing the estimates of the 4 parameters.
</p>


<h3>References</h3>


<p>Kogon SM and Williams DB (1998).
&ldquo;Characteristic function based estimation of stable distribution parameters.&rdquo;
<em>A practical guide to heavy tailed data</em>, pp. 311&ndash;335.

McCulloch JH (1986).
&ldquo;Simple consistent estimators of stable distribution parameters.&rdquo;
<em>Communications in Statistics-Simulation and Computation</em>, <b>15</b>(4), pp. 1109&ndash;1136.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim">Estim</a></code>, <code><a href="#topic+McCullochParametersEstim">McCullochParametersEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rstable(200, 1.2, 0.5, 1, 0, pm = 0)
IGParametersEstim(x, pm = 0)
</code></pre>

<hr>
<h2 id='IntegrateRandomVectorsProduct'>
Integral outer product of random vectors
</h2><span id='topic+IntegrateRandomVectorsProduct'></span>

<h3>Description</h3>

<p>Computes the integral outer product of two possibly complex random
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntegrateRandomVectorsProduct(f_fct, X, g_fct, Y, s_min, s_max,
                              subdivisions = 50,
                              method = c("Uniform", "Simpson"),
                              randomIntegrationLaw = c("norm","unif"),
                              ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_f_fct">f_fct</code></td>
<td>

<p>function object with signature <code>f_fct=function(s,X)</code> and
returns a matrix <code class="reqn">ns \times nx</code> where nx=<code>length(X)</code>
and ns=<code>length(s)</code>; <code>s</code> is the points where the integrand
is evaluated. 
</p>
</td></tr>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_x">X</code></td>
<td>

<p>random vector where the function <code>f_fct</code> is evaluated. See
Details. 
</p>
</td></tr>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_g_fct">g_fct</code></td>
<td>

<p>function object with signature <code>g_fct=function(s,Y)</code> and
returns a matrix <code class="reqn">ns \times ny</code> where ny=<code>length(Y)</code>
and ns=<code>length(s)</code>; <code>s</code> is the points where the integrand
is evaluated.
</p>
</td></tr>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_y">Y</code></td>
<td>

<p>random vector where the function <code>g_fct</code> is evaluated. See
Details. 
</p>
</td></tr>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_s_min">s_min</code>, <code id="IntegrateRandomVectorsProduct_+3A_s_max">s_max</code></td>
<td>

<p>limits of integration. Should be finite.
</p>
</td></tr>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_subdivisions">subdivisions</code></td>
<td>

<p>maximum number of subintervals.
</p>
</td></tr>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_method">method</code></td>
<td>

<p>numerical integration rule, one of <code>"uniform"</code> (fast) or
<code>"Simpson"</code> (more accurate quadratic rule).
</p>
</td></tr>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_randomintegrationlaw">randomIntegrationLaw</code></td>
<td>

<p>Random law pi(s) to be applied to the Random product vector, see
Details. Choices are <code>"unif"</code> (uniform) and <code>"norm"</code>
(normal distribution).
</p>
</td></tr>
<tr><td><code id="IntegrateRandomVectorsProduct_+3A_...">...</code></td>
<td>

<p>other arguments to pass to random integration law. Mainly, the mean
(<code>mu</code>) and standard deviation (<code>sd</code>) of the normal law.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the <code class="reqn">nx \times ny</code> matrix <code class="reqn">C =
  \int_{s_{min}}^{s_{max}} f_s(X) g_s(Y) \pi(s) ds</code>, such as the one
used in the objective function of the Cgmm method. This is essentially
an outer product with with multiplication replaced by integration.
</p>
<p>There is no function in R to compute vectorial integration and
computing <code class="reqn">C</code> element by element using <code>integrate</code> may
be very slow when <code>length(X)</code> (or <code>length(y)</code>) is large.
</p>
<p>The function allows complex vectors as its integrands.
</p>


<h3>Value</h3>

<p>an <code class="reqn">nx \times ny</code> matrix <code class="reqn">C</code> with elements:
</p>
<p style="text-align: center;"><code class="reqn">c_{ij} =
    \int_{s_{min}}^{s_{max}} f_s(X_i) g_s(Y_j) \pi(s) ds
    .
  </code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## Define the integrand
f_fct &lt;- function(s, x) {
    sapply(X = x, FUN = sampleComplexCFMoment, t = s, theta = theta)
}
f_bar_fct &lt;- function(s, x) Conj(f_fct(s, x))

## Function specific arguments
theta &lt;- c(1.5, 0.5, 1, 0)
set.seed(345)
X &lt;- rstable(3, 1.5, 0.5, 1, 0)
s_min &lt;- 0;
s_max &lt;- 2
numberIntegrationPoints &lt;- 10
randomIntegrationLaw &lt;- "norm"

Estim_Simpson &lt;-
    IntegrateRandomVectorsProduct(f_fct, X, f_bar_fct, X, s_min, s_max, 
                                  numberIntegrationPoints, 
                                  "Simpson", randomIntegrationLaw)
Estim_Simpson
</code></pre>

<hr>
<h2 id='jacobianComplexCF'>
Jacobian of the characteristic function of stable laws
</h2><span id='topic+jacobianComplexCF'></span>

<h3>Description</h3>

<p>Numeric jacobian of the  characteristic function (CF) as a function of
the parameter <code class="reqn">\theta</code> evaluated at a specific (vector) point
<code>t</code> and a given value <code class="reqn">\theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobianComplexCF(t, theta, pm = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobianComplexCF_+3A_t">t</code></td>
<td>

<p>vector of (real) numbers where the jacobian of the CF is evaluated;
numeric.
</p>
</td></tr>
<tr><td><code id="jacobianComplexCF_+3A_theta">theta</code></td>
<td>

<p>vector of parameters of the stable law; vector of length 4.
</p>
</td></tr>
<tr><td><code id="jacobianComplexCF_+3A_pm">pm</code></td>
<td>

<p>parametrisation, an integer (0 or 1); default: <code>pm = 0</code>
(Nolan's &lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numerical derivation is obtained by a call to the function
<code>jacobian</code> from package <span class="pkg">numDeriv</span>. We have set up its
arguments by default and the user is not given the option to modify
them.
</p>


<h3>Value</h3>

 
<p>a matrix <code>length(t)</code> <code class="reqn">\times </code> 4 of complex numbers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComplexCF">ComplexCF</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define the parameters
nt &lt;- 10
t &lt;- seq(0.1, 3, length.out = nt)
theta &lt;- c(1.5, 0.5, 1, 0)
pm &lt;- 0

## Compute the jacobian of the characteristic function
jack_CF &lt;- jacobianComplexCF(t = t, theta = theta, pm = pm)
</code></pre>

<hr>
<h2 id='KoutParametersEstim'>
Iterative Koutrouvelis regression method
</h2><span id='topic+KoutParametersEstim'></span>

<h3>Description</h3>

<p>Iterative Koutrouvelis regression method with different
spacing schemes (points where the eCF is computed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KoutParametersEstim(x, theta0 = NULL,
                    spacing = c("Kout", "UniformSpac", "ArithSpac", "free"),
                    pm = 0, tol = 0.05, NbIter = 10, PrintTime = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KoutParametersEstim_+3A_x">x</code></td>
<td>

<p>data used to perform the estimation: vector of length n.
</p>
</td></tr>
<tr><td><code id="KoutParametersEstim_+3A_theta0">theta0</code></td>
<td>

<p>initial guess for the 4 parameters values: vector of length 4
</p>
</td></tr>
<tr><td><code id="KoutParametersEstim_+3A_spacing">spacing</code></td>
<td>

<p>scheme used to select the points where the moment conditions are
evaluated. <code>Kout</code> is the scheme suggested by Koutrouvelis,
<code>UniformSpac</code> and <code>ArithSpac</code> are the uniform and
arithmetic spacing schemes over the informative interval
[<code class="reqn">\epsilon</code>,<code class="reqn">A_n</code>]. If user choose free, he needs to provide
a set of points <code>t_points</code> and <code>u_points</code> in <code>...</code>.
</p>
</td></tr>
<tr><td><code id="KoutParametersEstim_+3A_pm">pm</code></td>
<td>

<p>parametrisation, an integer (0 or 1); default: <code>pm = 0</code>
(Nolan's &lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
<tr><td><code id="KoutParametersEstim_+3A_tol">tol</code></td>
<td>

<p>the loop stops if the relative error between two consecutive
estimation is smaller then <code>tol</code>; default = 0.05.
</p>
</td></tr>
<tr><td><code id="KoutParametersEstim_+3A_nbiter">NbIter</code></td>
<td>

<p>maximum number of iteration. The loop stops when <code>NbIter</code>
is reached; default = 10.
</p>
</td></tr>
<tr><td><code id="KoutParametersEstim_+3A_printtime">PrintTime</code></td>
<td>

<p>logical flag; if set to TRUE, the estimation duration is printed out
to the screen in a readable format (h/min/sec).
</p>
</td></tr>
<tr><td><code id="KoutParametersEstim_+3A_...">...</code></td>
<td>

<p>other arguments to pass to the function. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>spacing</b>
</p>
<p>4 options for the spacing scheme are implemented as described
above. In particular:
</p>

<dl>
<dt><code>UniformSpac</code>, <code>ArithSpac</code>:</dt><dd>
<p>The user can specify the number of points to choose in both
regression by inputting <code>nb_t</code> and <code>nb_u</code>. Otherwise the
Koutrouvelis table will be used to compte them.
</p>
</dd>
<dt><code>free</code>:</dt><dd>
<p>The user is expected to provide <code>t_points</code> and
<code>u_points</code> otherwise the <code>Kout</code> scheme will be used.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>Estim</code></td>
<td>

<p><code>list</code> containing the vector of 4 parameters estimate
(<code>par</code>), the 2 regressions objects (<code>reg1</code> and
<code>reg2</code>) and the matrix of iterations estimate (<code>vals</code>).
</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>estimation duration in a numerical format.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>character</code> describing the method used.</p>
</td></tr>
</table>


<h3>References</h3>


<p>Koutrouvelis IA (1980).
&ldquo;Regression-type estimation of the parameters of stable laws.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>75</b>(372), pp. 918&ndash;928.
</p>

<p>Koutrouvelis IA (1981).
&ldquo;An iterative procedure for the estimation of the parameters of stable laws: An iterative procedure for the estimation.&rdquo;
<em>Communications in Statistics-Simulation and Computation</em>, <b>10</b>(1), pp. 17&ndash;28.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim">Estim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pm &lt;- 0
theta &lt;- c(1.45, 0.5, 1.1, 0.4)
set.seed(1235)
x &lt;- rstable(200, theta[1], theta[2], theta[3], theta[4], pm = pm)
theta0 &lt;- theta - 0.1
spacing &lt;- "Kout"

KoutParametersEstim(x = x, theta0 = theta0, 
                        spacing = spacing, pm = pm)
</code></pre>

<hr>
<h2 id='McCullochParametersEstim'>
Quantile-based method
</h2><span id='topic+McCullochParametersEstim'></span>

<h3>Description</h3>

<p>McCulloch quantile-based method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>McCullochParametersEstim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="McCullochParametersEstim_+3A_x">x</code></td>
<td>

<p>data used to perform the estimation: vector of length n.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code is a modified version of function <code>.qStableFit</code> from
package <span class="pkg">fBasics</span>. 
</p>


<h3>Value</h3>

<p><code>numeric</code> of length 4, represening the value of the 4
parameters. 
</p>


<h3>References</h3>


<p>McCulloch JH (1986).
&ldquo;Simple consistent estimators of stable distribution parameters.&rdquo;
<em>Communications in Statistics-Simulation and Computation</em>, <b>15</b>(4), pp. 1109&ndash;1136.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim">Estim</a></code>,
<code><a href="#topic+IGParametersEstim">IGParametersEstim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(333)
x &lt;- rstable(500, 1.3, 0.4, 1, 0)
McCullochParametersEstim(x)
</code></pre>

<hr>
<h2 id='MLParametersEstim'>
Maximum likelihood (ML) method
</h2><span id='topic+MLParametersEstim'></span>

<h3>Description</h3>

<p>Uses the numerical ML approach described by Nolan to estimate the 4
parameters of stable law. The method may be slow for large sample size
due to the use of numerical optimisation routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLParametersEstim(x, theta0 = NULL, pm = 0, PrintTime = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLParametersEstim_+3A_x">x</code></td>
<td>

<p>data used to perform the estimation: vector of length n.
</p>
</td></tr>
<tr><td><code id="MLParametersEstim_+3A_theta0">theta0</code></td>
<td>

<p>initial guess for the 4 parameters values: If <code>NULL</code>, the
Kogon-McCulloch method is called, see <code><a href="#topic+IGParametersEstim">IGParametersEstim</a></code>;
a vector of length 4.
</p>
</td></tr>
<tr><td><code id="MLParametersEstim_+3A_pm">pm</code></td>
<td>

<p>parametrisation, an integer (0 or 1); default: <code>pm=0</code>
(Nolan's &lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
<tr><td><code id="MLParametersEstim_+3A_printtime">PrintTime</code></td>
<td>

<p>logical flag; if set to TRUE, the estimation duration is printed out
to the screen in a readable format (h/min/sec).
</p>
</td></tr>
<tr><td><code id="MLParametersEstim_+3A_...">...</code></td>
<td>

<p>Other argument to be passed to the optimisation function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function performs the minimisation of the numerical (-)log-density
of stable laws computed by function <code>dstable</code> from package
<span class="pkg">stabledist</span>.
</p>
<p>After testing several optimisation routines, we have found out that
the <code>"L-BFGS-B"</code> algorithm performs better with the ML method
(faster, more accurate).
</p>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>Estim</code></td>
<td>
<p>output of the optimisation function,</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>estimation duration in a numerical format,</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p><code>character</code> describing the method used.</p>
</td></tr>
</table>


<h3>References</h3>


<p>Nolan J (2001).
&ldquo;Maximum likelihood estimation and diagnostics for stable distributions.&rdquo;
<em>L'evy processes: theory and applications</em>, pp. 379&ndash;400.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim">Estim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>theta &lt;- c(1.5, 0.4, 1, 0)
pm &lt;- 0
## 50 points does not give accurate estimation
## but it makes estimation fast for installation purposes
## use at least 200 points to get decent results.
set.seed(1333)
x &lt;- rstable(50, theta[1], theta[2], theta[3], theta[4], pm)

## This example takes &gt; 30 sec hence commented out
## Not run: 
  ML &lt;- MLParametersEstim(x = x, pm = pm, PrintTime = TRUE)

## End(Not run)
## see the Examples folder for more examples.
</code></pre>

<hr>
<h2 id='PrintDuration'>
Print duration
</h2><span id='topic+PrintDuration'></span>

<h3>Description</h3>

<p>Print duration in human readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintDuration(t, CallingFct = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrintDuration_+3A_t">t</code></td>
<td>

<p>Duration; <code>numeric</code> of <code>length</code> 1 or 3.
</p>
</td></tr>
<tr><td><code id="PrintDuration_+3A_callingfct">CallingFct</code></td>
<td>

<p>Name of the calling function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The duration will be printed in the format: hours/minutes/seconds.
</p>


<h3>Value</h3>

<p>Prints a <code>character</code> to the screen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ti &lt;- getTime_()
for (i in 1:100) x = i*22.1
tf &lt;- getTime_()
duration &lt;- ComputeDuration(ti, tf)
PrintDuration(duration, "test")
</code></pre>

<hr>
<h2 id='PrintEstimatedRemainingTime'>
Estimated remaining time
</h2><span id='topic+PrintEstimatedRemainingTime'></span>

<h3>Description</h3>

<p>Prints the estimated remaining time in a loop.
Useful in Monte Carlo simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintEstimatedRemainingTime(ActualIter, ActualIterStartTime, TotalIterNbr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrintEstimatedRemainingTime_+3A_actualiter">ActualIter</code></td>
<td>

<p>Actual Iteration; <code>integer</code>
</p>
</td></tr>
<tr><td><code id="PrintEstimatedRemainingTime_+3A_actualiterstarttime">ActualIterStartTime</code></td>
<td>

<p>Actual Iteration Starting time; <code>numeric</code>
</p>
</td></tr>
<tr><td><code id="PrintEstimatedRemainingTime_+3A_totaliternbr">TotalIterNbr</code></td>
<td>

<p>Total number of iterations; <code>integer</code>
</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>Called at the end of each Monte Carlo step, this function will compute
the duration of the actual step, an estimate of the remaining MC loops
duration and prints the result to the screen in a human readable
format using function <code><a href="#topic+PrintDuration">PrintDuration</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PrintDuration">PrintDuration</a></code>,
<code><a href="#topic+ComputeDuration">ComputeDuration</a></code>.
</p>

<hr>
<h2 id='RegularisedSol'>
Regularised Inverse
</h2><span id='topic+RegularisedSol'></span>

<h3>Description</h3>

<p>Regularised solution of the (ill-posed) problem <code class="reqn">K\phi = r</code> where
<code class="reqn">K</code> is a <code class="reqn">n \times n</code> matrix, <code class="reqn">r</code> is a given vector of
<code>length</code> n. Users can choose one of the 3 schemes described in
Carrasco and Florens (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RegularisedSol(Kn, alphaReg, r,
               regularization = c("Tikhonov", "LF", "cut-off"),
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RegularisedSol_+3A_kn">Kn</code></td>
<td>

<p>numeric <code class="reqn">n \times n</code> matrix.
</p>
</td></tr>
<tr><td><code id="RegularisedSol_+3A_alphareg">alphaReg</code></td>
<td>

<p>regularisation parameter; numeric in ]0,1].
</p>
</td></tr>
<tr><td><code id="RegularisedSol_+3A_r">r</code></td>
<td>

<p>numeric vector of <code>length</code> n.
</p>
</td></tr>
<tr><td><code id="RegularisedSol_+3A_regularization">regularization</code></td>
<td>

<p>regularization scheme to be used, one of <code>"Tikhonov"</code> (Tikhonov
scheme), <code>"LF"</code> (Landweber-Fridmann) and <code>"cut-off"</code>
(spectral cut-off). See Details.
</p>
</td></tr>
<tr><td><code id="RegularisedSol_+3A_...">...</code></td>
<td>

<p>the value of <code class="reqn">c</code> used in the <code>"LF"</code> scheme. See
Carrasco and Florens(2007).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following Carrasco and Florens(2007), the regularised solution of the
problem <code class="reqn">K \phi=r</code> is given by :
</p>
<p style="text-align: center;"><code class="reqn">\varphi_{\alpha_{reg}} =
    \sum_{j=1}^{n} q(\alpha_{reg},\mu_j)\frac{&lt;r,\psi_j &gt;}{\mu_j} \phi_j
    ,
  </code>
</p>

<p>where <code class="reqn">q</code> is a (positive) real function with some regularity
conditions and <code class="reqn">\mu,\phi,\psi</code> the singular decomposition of the
matrix <code class="reqn">K</code>.
</p>
<p>The <code>regularization</code> parameter defines the form of the function
<code class="reqn">q</code>. For example, the <code>"Tikhonov"</code> scheme defines
<code class="reqn">q(\alpha_{reg},\mu) = \frac{\mu^2}{\alpha_{reg}+\mu^2}</code>.
</p>
<p>When the matrix <code class="reqn">K</code> is symmetric, the singular decomposition is
replaced by a spectral decomposition.
</p>


<h3>Value</h3>

<p>the regularised solution, a vector of length n.
</p>


<h3>References</h3>

 
<p>Carrasco M, Florens J and Renault E (2007).
&ldquo;Linear inverse problems in structural econometrics estimation based on spectral decomposition and regularization.&rdquo;
<em>Handbook of econometrics</em>, <b>6</b>, pp. 5633&ndash;5751.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+solve">solve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Adapted from R examples for Solve 
## We compare the result of the regularized sol to the expected solution

hilbert &lt;- function(n) { i &lt;- 1:n; 1 / outer(i - 1, i, "+")}

K_h8 &lt;- hilbert(8);
r8 &lt;- 1:8

alphaReg_robust &lt;- 1e-4
Sa8_robust &lt;- RegularisedSol(K_h8,alphaReg_robust,r8,"LF")

alphaReg_accurate &lt;- 1e-10
Sa8_accurate &lt;- RegularisedSol(K_h8,alphaReg_accurate,r8,"LF")

## when pre multiplied by K_h8, the expected solution is 1:8
## User can check the influence of the choice of alphaReg
</code></pre>

<hr>
<h2 id='sampleComplexCFMoment'>
Complex moment condition based on the characteristic function
</h2><span id='topic+sampleComplexCFMoment'></span>

<h3>Description</h3>

<p>Computes the moment condition based on the characteristic function as
a complex vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleComplexCFMoment(x, t, theta, pm = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleComplexCFMoment_+3A_x">x</code></td>
<td>

<p>vector of data where the ecf is computed.
</p>
</td></tr>
<tr><td><code id="sampleComplexCFMoment_+3A_t">t</code></td>
<td>

<p>vector of (real) numbers where the CF is evaluated; numeric.
</p>
</td></tr>
<tr><td><code id="sampleComplexCFMoment_+3A_theta">theta</code></td>
<td>
	
<p>vector of parameters of the stable law; vector of length 4.
</p>
</td></tr>	  
<tr><td><code id="sampleComplexCFMoment_+3A_pm">pm</code></td>
<td>

<p>parametrisation, an integer (0 or 1); default: <code>pm=0</code>
(Nolan's &lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>The moment conditions</b>
</p>
<p>The moment conditions are given by:
</p>
<p style="text-align: center;"><code class="reqn">g_t(X,\theta) = g(t,X;\theta)= e^{itX} - \phi_{\theta}(t)</code>
</p>

<p>If one has a sample <code class="reqn">x_1,\dots,x_n</code> of i.i.d realisations of the
same random variable <code class="reqn">X</code>, then: 
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}_n(t,\theta)
    = \frac{1}{n}\sum_{i=1}^n g(t,x_i;\theta)
    =  \phi_n(t) - \phi_\theta(t)
    ,
  </code>
</p>

<p>where <code class="reqn">\phi_n(t)</code> is the eCF associated to the sample
<code class="reqn">x_1,\dots,x_n</code>, and defined by
<code class="reqn">\phi_n(t) = \frac{1}{n} \sum_{j=1}^n e^{itX_j}</code>.
</p>
<p>The function compute the vector of difference between the eCF and the
CF at a set of given point <code>t</code>.
</p>


<h3>Value</h3>

<p>a complex vector of <code>length(t)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComplexCF">ComplexCF</a></code>,
<code><a href="#topic+sampleRealCFMoment">sampleRealCFMoment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define the parameters
nt &lt;- 10   
t &lt;- seq(0.1, 3, length.out = nt)
theta &lt;- c(1.5, 0.5, 1, 0)
pm &lt;- 0

set.seed(222)
x &lt;- rstable(200, theta[1], theta[2], theta[3], theta[4], pm)

## Compute the characteristic function
CFMC &lt;- sampleComplexCFMoment(x = x, t = t, theta = theta, pm = pm)
CFMC
</code></pre>

<hr>
<h2 id='sampleRealCFMoment'>	
Real moment condition based on the characteristic function
</h2><span id='topic+sampleRealCFMoment'></span>

<h3>Description</h3>

<p>Computes the moment condition based on the characteristic function as
a real vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleRealCFMoment(x, t, theta, pm = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleRealCFMoment_+3A_x">x</code></td>
<td>

<p>vector of data where the ecf is computed.
</p>
</td></tr>
<tr><td><code id="sampleRealCFMoment_+3A_t">t</code></td>
<td>

<p>vector of (real) numbers where the CF is evaluated; numeric.
</p>
</td></tr>
<tr><td><code id="sampleRealCFMoment_+3A_theta">theta</code></td>
<td>
	
<p>vector of parameters of the stable law; vector of length 4.
</p>
</td></tr>	  
<tr><td><code id="sampleRealCFMoment_+3A_pm">pm</code></td>
<td>

<p>Parametrisation, an integer (0 or 1); default: <code>pm=0</code>
(Nolan's &lsquo;S0&rsquo; parametrisation).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>The moment conditions</b>
</p>
<p>The moment conditions are given by:
</p>
<p style="text-align: center;"><code class="reqn">g_t(X,\theta)
    = g(t,X;\theta)
    = e^{itX} - \phi_{\theta}(t)
    .
  </code>
</p>

<p>If one has a sample <code class="reqn">x_1,\dots,x_n</code> of i.i.d realisations of the
same random variable <code class="reqn">X</code>, then: 
</p>
<p style="text-align: center;"><code class="reqn">\hat{g}_n(t,\theta)
    = \frac{1}{n}\sum_{i=1}^n g(t,x_i;\theta)
    = \phi_n(t) -\phi_\theta(t)
    ,
  </code>
</p>

<p>where <code class="reqn">\phi_n(t)</code> is the eCF associated with the sample
<code class="reqn">x_1,\dots,x_n</code>, and defined by
<code class="reqn">\phi_n(t) = \frac{1}{n} \sum_{j=1}^n e^{itX_j}</code>.
</p>
<p>The function compute the vector of difference between the eCF and the
CF at a set of given point <code>t</code>.  If <code>length(t) = n</code>, the
resulting vector will be of <code>length = 2n</code>, where the first
<code>n</code> components will be the real part and the remaining the
imaginary part.
</p>


<h3>Value</h3>

<p>a vector of length <code>2 * length(t)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ComplexCF">ComplexCF</a></code>,
<code><a href="#topic+sampleComplexCFMoment">sampleComplexCFMoment</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define the parameters
nt &lt;- 10   
t &lt;- seq(0.1, 3, length.out = nt)
theta &lt;- c(1.5, 0.5, 1, 0)
pm &lt;- 0

set.seed(222)
x &lt;- rstable(200, theta[1], theta[2], theta[3], theta[4], pm)

# Compute the characteristic function
CFMR &lt;- sampleRealCFMoment(x = x, t = t, theta = theta, pm = pm)
CFMR
</code></pre>

<hr>
<h2 id='StableEstim_reexports'>Objects exported from other packages</h2><span id='topic+StableEstim_reexports'></span><span id='topic+rstable'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>rstable</dt><dd><p><code><a href="stabledist.html#topic+rstable">rstable</a></code></p>
</dd>
</dl>


<hr>
<h2 id='StatFcts'>
Default functions used to produce the statistical summary
</h2><span id='topic+StatFcts'></span>

<h3>Description</h3>

<p>Default functions used to produce the statistical summary in the
Monte Carlo simulations.
</p>


<h3>Details</h3>

<p>The functions are:
</p>

<dl>
<dt>Mean</dt><dd><p><code>.mean &lt;- function(p,...) mean(p)</code></p>
</dd>
<dt>Min</dt><dd><p><code>.min &lt;- function(p,...) min(p)</code></p>
</dd>
<dt>Max</dt><dd><p><code>.max &lt;- function(p,...) max(p)</code></p>
</dd>
<dt>Sn</dt><dd><p><code>.Sn &lt;- function(p,n,...) sqrt(n)*sd(p)</code></p>
</dd>
<dt>MSE</dt><dd><p><code>.MSE &lt;- function(p,paramT,...) (1/length(p))*sum((p-paramT)^2) </code></p>
</dd>
<dt>Std error</dt><dd><p><code>.st.err &lt;- function(p,...) sd(p)/sqrt(length(p))</code></p>
</dd>
</dl>

<p>To change the statistical summary, provide functions with similar
signatures and pass a character vector containing the function
names to <code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>.
</p>

<hr>
<h2 id='TexSummary'>
LaTeX summary
</h2><span id='topic+TexSummary'></span>

<h3>Description</h3>

<p>Creates a TeX table from a summary object or a vector of files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TexSummary(obj, files = NULL, sep_ = ",", FctsToApply = StatFcts,
           caption = "Statistical Summary", label = "Simtab",
           digits = 3, par_index = 1, MCparam = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TexSummary_+3A_obj">obj</code></td>
<td>

<p><code>list</code> of length 4 containing a summary <code>matrix</code>
object associated to each parameter identical to the one produced by
function <code><a href="#topic+ComputeStatObjectFromFiles">ComputeStatObjectFromFiles</a></code>.
</p>
</td></tr>
<tr><td><code id="TexSummary_+3A_files">files</code></td>
<td>

<p><code>character</code> vector containing the files name to be parsed. It
will be passed to function <code><a href="#topic+ComputeStatObjectFromFiles">ComputeStatObjectFromFiles</a></code>.
</p>
</td></tr>
<tr><td><code id="TexSummary_+3A_sep_">sep_</code></td>
<td>

<p>field separator character to be passed to function
<code><a href="#topic+ComputeStatObjectFromFiles">ComputeStatObjectFromFiles</a></code>.
</p>
</td></tr>
<tr><td><code id="TexSummary_+3A_fctstoapply">FctsToApply</code></td>
<td>

<p>functions used to produce the statistical summary to be passed
to the function <code><a href="#topic+ComputeStatObjectFromFiles">ComputeStatObjectFromFiles</a></code>.
</p>
</td></tr>
<tr><td><code id="TexSummary_+3A_caption">caption</code></td>
<td>

<p><code>character</code> vector with length equal to <code>length(par_index)</code>
containing the table's caption or title.
</p>
</td></tr>
<tr><td><code id="TexSummary_+3A_label">label</code></td>
<td>

<p><code>character</code> vector with length equal to <code>length(par_index)</code> 
containing the LaTeX label.
</p>
</td></tr>
<tr><td><code id="TexSummary_+3A_digits">digits</code></td>
<td>

<p><code>numeric</code> vector of length equal to one (in which case it will
be replicated as necessary) or to the number of columns of the
resulting table or length of <code>FctsToApply</code> or matrix of the
same size as the resulting table indicating the number of digits
to display in the corresponding columns. See <code>xtable</code>.
</p>
</td></tr> 
<tr><td><code id="TexSummary_+3A_par_index">par_index</code></td>
<td>

<p><code>numeric</code> or <code>character</code> vector of length 1, 2, 3 or 4 of
the desired indices to be selected in <code>obj</code>. See Details.
</p>
</td></tr>
<tr><td><code id="TexSummary_+3A_mcparam">MCparam</code></td>
<td>

<p>number of Monte Carlo simulations for each couple of parameters,
default = 1000; integer.
</p>
</td></tr>
<tr><td><code id="TexSummary_+3A_...">...</code></td>
<td>

<p>other arguments to be passed to function
<code><a href="#topic+ComputeStatObjectFromFiles">ComputeStatObjectFromFiles</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepted values for <code>par_index</code> are <code>c(1,2,3,4)</code> or
<code>c("alpha","beta","gamma","delta")</code> or mixed.
</p>
<p>Some examples are provided in the example folder.
</p>


<h3>Value</h3>

<p>a <code>list</code> of length <code>length(par_index)</code> whose elements are
objects from class <code>Latex</code> (produced by <code>toLatex</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Estim_Simulation">Estim_Simulation</a></code>,
<code><a href="#topic+ComputeStatObjectFromFiles">ComputeStatObjectFromFiles</a></code>,
<code>xtable</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
