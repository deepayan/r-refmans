<!DOCTYPE html><html lang="en"><head><title>Help for package forestSAS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {forestSAS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#forestSAS-package'>
<p>Forest Spatial Structure Analysis Systems</p></a></li>
<li><a href='#addmark.ppp'>
<p>Add marks for a point pattern</p></a></li>
<li><a href='#buffer'>
<p>Identify the buffer zone in the point pattern</p></a></li>
<li><a href='#crowding'>
<p>A forest spatial structure index characterizing crowding degree.</p></a></li>
<li><a href='#differ'>
<p>A forest spatial structure index characterizing differation degree of tree attributies.</p></a></li>
<li><a href='#dominance'>
<p>A forest spatial structure index characterizing tree dominance</p></a></li>
<li><a href='#expandedge'>
<p>Expand the edges for the point pattern with replication.</p></a></li>
<li><a href='#fsasN4'>
<p>A body function to analyze the forest saptial structure.</p></a></li>
<li><a href='#ideal'>
<p>A forest spatial structure index characterizing distribution of ideal state for tree attributies.</p></a></li>
<li><a href='#list_to_matrix'>
<p>Converting list to  matrix</p></a></li>
<li><a href='#mingling'>
<p>A forest spatial structure index characterizing tree diversity</p></a></li>
<li><a href='#nnangle'>
<p>Identify the angle among nearest neighbours</p></a></li>
<li><a href='#nnid'>
<p>Find the id of nearest neighbour for each point.</p></a></li>
<li><a href='#nnIndex'>
<p>Get the marks of nearest neighbour in the point pattern</p></a></li>
<li><a href='#nnoverlap'>
<p>Crown overlap among nearest neighbour</p></a></li>
<li><a href='#opt_spastr'>
<p>Optimal forest spatial structure indices.</p></a></li>
<li><a href='#pv'>
<p>Preference value</p></a></li>
<li><a href='#rebuild.ppp'>
<p>Reestablishing an object of class &quot;ppp&quot;</p></a></li>
<li><a href='#shrinkedge'>
<p>Shrink the edges for the point pattern</p></a></li>
<li><a href='#simtreecom'>
<p>Simulated a forest community data.</p></a></li>
<li><a href='#spastr'>
<p>Computing forest spatial structure indices.</p></a></li>
<li><a href='#storeydvd'>
<p>Dividing the forest storeies</p></a></li>
<li><a href='#tree.ppp'>
<p>Sample data for analizing the forest spatial structure.</p></a></li>
<li><a href='#treecom_example'>
<p>Example data for analizing the forest community.</p></a></li>
<li><a href='#treedata'>
<p>Sample data for analizing the forest spatial structure.</p></a></li>
<li><a href='#uniform.angle'>
<p>A forest spatial structure index characterizing tree spatial</p>
distribution patterns</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forest Spatial Structure Analysis Systems</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat, spatstat.data, spatstat.geom, spatstat.random</td>
</tr>
<tr>
<td>Description:</td>
<td>Recent years have seen significant interest in neighborhood-based structural parameters that effectively represent the spatial characteristics of tree populations and forest communities, and possess strong applicability for guiding forestry practices. This package provides valuable information that enhances our understanding and analysis of the fine-scale spatial structure of tree populations and forest stands. Reference: Yan L, Tan W, Chai Z, et al (2019) &lt;<a href="https://doi.org/10.13323%2Fj.cnki.j.fafu%28nat.sci.%29.2019.03.007">doi:10.13323/j.cnki.j.fafu(nat.sci.).2019.03.007</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-06 14:06:51 UTC; 78438</td>
</tr>
<tr>
<td>Author:</td>
<td>Zongzheng Chai <a href="https://orcid.org/0000-0002-0530-0040"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zongzheng Chai &lt;chaizz@126.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-11 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='forestSAS-package'>
Forest Spatial Structure Analysis Systems
</h2><span id='topic+forestSAS-package'></span><span id='topic+forestSAS'></span>

<h3>Description</h3>

<p>Recent years have seen significant interest in neighborhood-based structural parameters that effectively represent the spatial characteristics of tree populations and forest communities, and possess strong applicability for guiding forestry practices. This package provides valuable information that enhances our understanding and analysis of the fine-scale spatial structure of tree populations and forest stands. Reference: Yan L, Tan W, Chai Z, et al (2019) &lt;doi:10.13323/j.cnki.j.fafu(nat.sci.).2019.03.007&gt;.
</p>


<h3>Details</h3>

<p>Forest structure commonly refers to a distribution pattern of tree attributes within a forest ecosystem. Similarly, tree population structure describes the distribution characteristics of individuals of conspecifics within a community, and the spatial structure of a tree population is largely determined by the relationships among neighboring groups of trees.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat)
data(tree.ppp)
##Get the tree attributies of nearest neighbour
nnindices&lt;-nnIndex(tree.ppp,N=4,
            smark=c("sp.code","dbh.cm","storey",
               "crownwid.m","group","biomass.kg",
               "quality","x","y"),buffer=FALSE)

#Species mingling
M&lt;-fsasN4(nnindices$nnsp.code,match.fun=mingling)
M
#Stand storey differation degree
H&lt;-fsasN4(nnindices$nnstorey,match.fun=differ)
H
#Tree successional degree
S&lt;-fsasN4(nnindices$nngroup,match.fun=ideal,para="Climax")
S
#Tree quality ideal state
Q&lt;-fsasN4(nnindices$nnquality,match.fun=ideal,
          para=c("Excellent","Good"))
Q
#Tree corwding degree
C&lt;-fsasN4(nnoverlap(nnindices$nncrownwid.m,
         nnindices$nndist),match.fun=crowding)
C
#Tree uniform angle index
W&lt;-fsasN4(nnangle(nnindices$nndist,nnindices$nnx,
           nnindices$nny)$nnangle,
          match.fun=uniform.angle,para=72)
W
#Tree dominance
U&lt;-fsasN4(nnindices$nndbh.cm,match.fun=dominance)
U
#Tree biomass dominance
B&lt;-fsasN4(nnindices$nnbiomass.kg,match.fun=dominance)
B

##Compute the structrue heterogeneity of index
M.pv&lt;-pv(M$result$index,optm=1)
M.pv
H.pv&lt;-pv(H$result$index,optm=1)
H.pv
S.pv&lt;-pv(S$result$index,optm=1)
S.pv
Q.pv&lt;-pv(Q$result$index,optm=1)
Q.pv
C.pv&lt;-pv(C$result$index,optm=0.5)
C.pv
W.pv&lt;-pv(W$result$index,optm=0.5)
W.pv
U.pv&lt;-pv(U$result$index,optm=0)
U.pv
B.pv&lt;-pv(B$result$index,optm=0)
B.pv

##Compute total forest saptial structrue heterogeneity
#based on the average of indices preference value
IAVE&lt;-pv(index=c(M$meanI,H$meanI,S$meanI,Q$meanI,
                       C$meanI,W$meanI,U$meanI,B$meanI),
               optm=c(1,1,1,1,0.5,0.5,0,0))
IAVE

##Compute total forest saptial structrue heterogeneity
#based on the preference value of indices average
IPVE=mean(M.pv,H.pv,S.pv,Q.pv,C.pv,W.pv,U.pv,B.pv)
IPVE
</code></pre>

<hr>
<h2 id='addmark.ppp'>
Add marks for a point pattern
</h2><span id='topic+addmark.ppp'></span>

<h3>Description</h3>

<p>Add marks for a point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addmark.ppp(X, add.mark, add.name = "storey")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addmark.ppp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class &quot;ppp&quot;).
</p>
</td></tr>
<tr><td><code id="addmark.ppp_+3A_add.mark">add.mark</code></td>
<td>

<p>Marks need added in the point pattern
</p>
</td></tr>
<tr><td><code id="addmark.ppp_+3A_add.name">add.name</code></td>
<td>

<p>Names of added marks (add.mark)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A point pattern added marks
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat.data)
data(finpines)
####Dividing the stories
finpines.storey&lt;-storeydvd(finpines$marks$height,storeynum=6)
finpines.storey

####Computing the storey differation
##Add the storey mark for finepines
finpines.addstorey&lt;-addmark.ppp(finpines,
                                add.mark=finpines.storey$heightdata[,2:3],
                                add.name=c("interval","storey" ))
finpines.addstorey
</code></pre>

<hr>
<h2 id='buffer'>
Identify the buffer zone in the point pattern
</h2><span id='topic+buffer'></span>

<h3>Description</h3>

<p>To eliminate edge effects and improve the accuracy of the
Calculation,such as analyzing the forest spatial structure
parameters, we always established a buffer
zone around the plot. In the statistical analysis, only the
trees in the reduced window are used as
reference trees, and the individual trees in the buffer zone
are only considered to be the nearest neighbors of the
trees in the reduced window. This edge
correction can individually evaluate each tree to determine
whether all n nearest neighbors are truly located within
the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buffer(X, buf.xwid = 5, buf.ywid = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buffer_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class &quot;ppp&quot;).
</p>
</td></tr>
<tr><td><code id="buffer_+3A_buf.xwid">buf.xwid</code></td>
<td>

<p>The width of buffer zone in the x coordinates of data points
</p>
</td></tr>
<tr><td><code id="buffer_+3A_buf.ywid">buf.ywid</code></td>
<td>

<p>The width of buffer zone in the y coordinates of data points
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;ppp&quot;, which add a marks &quot;zone&quot; in the orginal point pattern
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>Chai ZZ, Sun CL, Wang DX, Liu WZ, and Zhang CS.2016.
Spatial structure and dynamics of predominant populations in a virgin
old-growthoak forest in the Qinling Mountains, China. Scandinavian Journal of Forest Research. DOI:
10.1080/02827581.2016.1183703
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat.geom)
####Based on the simulated data####
# Creating a simulated point pattern
x &lt;- runif(20)
y &lt;- runif(20)
X &lt;- ppp(x, y, c(0,1), c(0,1))
X
# Identifing the buffer zone and core zone in the point pattern
# The width of buffer zone in the x coordinates of data points is 0.2
# The width of buffer zone in the y coordinates of data points is 0.3
X_buf&lt;-buffer(X,buf.xwid =0.2,buf.ywid=0.3)
X_buf
as.data.frame(X_buf)

####Based on the example data####
library(spatstat.data)
data(finpines)
finpines
# Marked planar point pattern: 126 points
# Mark variables: diameter, height
# window: rectangle = [-5, 5] x [-8, 2] metres

# Identifing the buffer zone and core zone in the finpines
# The width of buffer zone in the x coordinates of finpines is 2
# The width of buffer zone in the y coordinates of finpines is 3
finpines_buf&lt;-buffer(finpines,buf.xwid =2,buf.ywid=3)
finpines_buf
as.data.frame(finpines_buf)
</code></pre>

<hr>
<h2 id='crowding'>
A forest spatial structure index characterizing crowding degree.
</h2><span id='topic+crowding'></span>

<h3>Description</h3>

<p>Analyze the crowding degree of a neighborhood unit according to the overlapping of the crown in spatial micro-environment which clearly define the crowding degree for a reference tree and its four nearest neighbors, and to some degree of the competition pressure on it as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crowding(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crowding_+3A_x">x</code></td>
<td>

<p>A vector composed by 5 crowding degree value
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result will retrun five values,0,0.25,0.5,0.75,1,which means none, one, two, three, or four overlap of nearest neighbors with reference tree,respectively.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>Hu YB, Hui GY. 2015. How to describe the crowding degree of trees based on the relationship of neighboring trees. Journal of Beijing Forestry University. 37(9):1-8.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>overlap1&lt;-c(-0.5,-0.4,-0.3,-0.2) ##negative means no overlap
overlap2&lt;-c(-0.5,-0.4,-0.3,0.2)  ##positive means overlap
overlap3&lt;-c(-0.5,-0.4,0.3,0.2)
overlap4&lt;-c(-0.5,0.4,0.3,0.2)
overlap5&lt;-c(0.5,0.4,0.3,0.2)

crowding1&lt;-crowding(overlap1)
crowding1
crowding2&lt;-crowding(overlap2)
crowding2
crowding3&lt;-crowding(overlap3)
crowding3
crowding4&lt;-crowding(overlap4)
crowding4
crowding5&lt;-crowding(overlap5)
crowding5
</code></pre>

<hr>
<h2 id='differ'>
A forest spatial structure index characterizing differation degree of tree attributies.
</h2><span id='topic+differ'></span>

<h3>Description</h3>

<p>Analyze the differation degree of tree attributies in a neighborhood unit according to the characteristics of the tree attributies,such as forest storey,speices,etc.in spatial micro-environment.which clearly define the differation degree of tree attributies for a reference 
tree and its four nearest neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>differ(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="differ_+3A_x">x</code></td>
<td>

<p>A vector composed by 5 tree attributies.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result will retrun five values,0,0.25,0.5,0.75,1,which means 
one, two, three, four or five different attributies of nearest neighbors 
for reference tree,respectively.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##S1,S2,S3,S4,S5,represent 5 different forest stoeries
storey1&lt;-c("S1","S1","S1","S1","S1")
storey2&lt;-c("S1","S1","S1","S1","S2")
storey3&lt;-c("S1","S1","S1","S3","S2")
storey4&lt;-c("S1","S1","S4","S3","S2")
storey5&lt;-c("S1","S5","S4","S3","S2")

differ1&lt;-differ(storey1)
differ1
differ2&lt;-differ(storey2)
differ2
differ3&lt;-differ(storey3)
differ3
differ4&lt;-differ(storey4)
differ4
differ5&lt;-differ(storey5)
differ5
</code></pre>

<hr>
<h2 id='dominance'>
A forest spatial structure index characterizing tree dominance
</h2><span id='topic+dominance'></span>

<h3>Description</h3>

<p>The tree attribute dominance was proposed by Hui et al. (1998) to relate the relative dominance of a given tree to its species or silvicultural significance. It is defined as the proportion of
the n nearest neighbours of a given reference tree which are bigger than the reference tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominance(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dominance_+3A_x">x</code></td>
<td>

<p>A vector composed by 5 tree attributes, such as dbh,biomass.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result will retrun five values,0,0.25,0.5,0.75,1,which means the propertion of
the larger tree attributes in the 4 nearest neighbours than the reference tree.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>Gadow Kv, and Hui GY. 2002. Characterizing forest spatial structure and diversity. Proc of the SUFOR international workshop: Sustainable forestry in temperate regions. p 20-30.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbh1&lt;-c(5,4,4,4,4)
dbh2&lt;-c(5,4,4,4,6)
dbh3&lt;-c(5,4,4,7,6)
dbh4&lt;-c(5,4,8,7,6)
dbh5&lt;-c(5,9,8,7,6)

dominance1&lt;-dominance(dbh1)
dominance1
dominance2&lt;-dominance(dbh2)
dominance2
dominance3&lt;-dominance(dbh3)
dominance3
dominance4&lt;-dominance(dbh4)
dominance4
dominance5&lt;-dominance(dbh5)
dominance5
</code></pre>

<hr>
<h2 id='expandedge'>
Expand the edges for the point pattern with replication.
</h2><span id='topic+expandedge'></span>

<h3>Description</h3>

<p>When computing forest spatial structure indices, The trees near the edges of the study region are distorted because the outside is empty. Common solutions to this problem are not to use indices computed for trees near the edges, or (with rectangular regions) to attach translated copies, thus changing the topology into a torus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandedge(X, xwidth, ywidth,id = 1:X$n, marks=X$marks,type="com")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandedge_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class &quot;ppp&quot;).
</p>
</td></tr>
<tr><td><code id="expandedge_+3A_xwidth">xwidth</code></td>
<td>

<p>Distance from the edges x coordinates,note xwidth is the half of your width wanted, because the width will expand both edges in the x coordinates.
</p>
</td></tr>
<tr><td><code id="expandedge_+3A_ywidth">ywidth</code></td>
<td>

<p>Distance from the edges y coordinates,note xwidth is the half of your width wanted, because the width will expand both edges in the y coordinates.
</p>
</td></tr>
<tr><td><code id="expandedge_+3A_id">id</code></td>
<td>

<p>Specific identification number of the points in the point pattern.
</p>
</td></tr>
<tr><td><code id="expandedge_+3A_marks">marks</code></td>
<td>

<p>Marks of nearest neighbour in the point pattern.
</p>
</td></tr>
<tr><td><code id="expandedge_+3A_type">type</code></td>
<td>

<p>Data format,com is data.frame and ppp is the ppp format in the spapstat package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When expanding for the full pattern, and using expandedge() with a positive  xwidth and ywidth; conversely, shrinking for the full pattern, and using shrinkedge () with a negative xwidth and ywidth.
</p>


<h3>Value</h3>

<p>Result returns original data (not a a point pattern with the same structure as trees), id is new id of points after edges expanded and old.id is orginal id of points.
The pattern is first expanded by surrounding it with 8 shifted copies (the window must be rectangular). Then, the parts of the pattern that are at a distance less than xwidth or ywidth from an edge of the enlarged pattern are discarded.
If xwidth or ywidth = 0, trees are returned unchanged.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat)
library(spatstat.data)
data(finpines)
finpines$window
# window: rectangle = [-5, 5] x [-8, 2] metres

# Expand the rectangle [-5,5]x[-8,2] to [-6,6]x[-9,3]
Expand.trees&lt;- expandedge(finpines,xwidth=2,ywidth=1,id=1:126)
Expand.trees

# Show the changes by figures
opar&lt;-par(mfrow=c(1,2))
plot(finpines$x,finpines$y)
text(finpines$x,finpines$y,1:126)
plot(Expand.trees$x,Expand.trees$y)
text(Expand.trees$x,Expand.trees$y,Expand.trees$old.id)
rect(-5,-8,5,2,border="red")
par(opar)
</code></pre>

<hr>
<h2 id='fsasN4'>
A body function to analyze the forest saptial structure.
</h2><span id='topic+fsasN4'></span>

<h3>Description</h3>

<p>The function provided a easy flexible funciton body to analyze the forest saptial structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsasN4(nnattri, match.fun, para = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fsasN4_+3A_nnattri">nnattri</code></td>
<td>

<p>attributies of nearest neighbour
</p>
</td></tr>
<tr><td><code id="fsasN4_+3A_match.fun">match.fun</code></td>
<td>

<p>funcitons,such as &quot;differ&quot;,&quot;dominance&quot;,&quot;ideal&quot;,&quot;uniform.angle&quot;,&quot;crowding&quot;,&quot;mingling&quot;,etc.
</p>
</td></tr>
<tr><td><code id="fsasN4_+3A_para">para</code></td>
<td>

<p>the parameter in the above match.fun
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result is the &quot;nnmark&quot; and,colum I is the sptial structre indices value
Icount is the count distribution  of I
Ifreq is the frequency distribution of I
meanI is the average value of I
data is the final point pattern
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>Gadow Kv, and Hui G. 2002. Characterizing forest spatial structure and diversity. Proc of the SUFOR international workshop: Sustainable forestry in temperate regions. p 20-30.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tree.ppp)
##Get the tree attributies of nearest neighbour for calculation
nnindices&lt;-nnIndex(tree.ppp,N=4,
                  smark=c("sp.code","dbh.cm","storey","crownwid.m","group",
                           "biomass.kg","quality","x","y"),buffer=FALSE)

#Species mingling
M&lt;-fsasN4(nnindices$nnsp.code,match.fun=mingling)
M
#Stand storey differation degree
H&lt;-fsasN4(nnindices$nnstorey,match.fun=differ)
H
#Tree successional degree
S&lt;-fsasN4(nnindices$nngroup,match.fun=ideal,para="Climax")
S
#Tree quality ideal state
Q&lt;-fsasN4(nnindices$nnquality,match.fun=ideal,para=c("Excellent","Good"))
Q
#Tree corwding degree
C&lt;-fsasN4(nnoverlap(nnindices$nncrownwid.m,nnindices$nndist),match.fun=crowding)
C
#Tree uniform angle index
W&lt;-fsasN4(nnangle(nnindices$nndist,nnindices$nnx,nnindices$nny)$nnangle,
          match.fun=uniform.angle,para=72)
W
#Tree dominance
U&lt;-fsasN4(nnindices$nndbh.cm,match.fun=dominance)
U
#Tree biomass dominance
B&lt;-fsasN4(nnindices$nnbiomass.kg,match.fun=dominance)
B
</code></pre>

<hr>
<h2 id='ideal'>
A forest spatial structure index characterizing distribution of ideal state for tree attributies.
</h2><span id='topic+ideal'></span>

<h3>Description</h3>

<p>Analyze the distribution of ideal state for tree attributies in a neighborhood unit according to the characteristics of the tree attributies,such as tree health,climax species distribution,etc.in spatial micro-environment.which clearly define the ideal degree of tree attributies for a reference tree and its four nearest neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ideal(x, para)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ideal_+3A_x">x</code></td>
<td>

<p>A vector composed by 5 tree attributies.
</p>
</td></tr>
<tr><td><code id="ideal_+3A_para">para</code></td>
<td>

<p>Ideal state of tree attributies.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result will retrun five values,0,0.25,0.5,0.75,1,which means 
none,one, two, three or four ideal tree attributies of nearest neighbors 
for reference tree,respectively.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>health1&lt;-c("poor","poor","poor","poor")
health2&lt;-c("poor","poor","poor","excellent")
health3&lt;-c("poor","poor","good","excellent")
health4&lt;-c("poor","excellent","good","excellent")
health5&lt;-c("good","excellent","good","excellent")

ideal1&lt;-ideal(health1,para=c("good","excellent"))
ideal1
ideal2&lt;-ideal(health2,para=c("good","excellent"))
ideal2
ideal3&lt;-ideal(health3,para=c("good","excellent"))
ideal3
ideal4&lt;-ideal(health4,para=c("good","excellent"))
ideal4
ideal5&lt;-ideal(health5,para=c("good","excellent"))
ideal5
</code></pre>

<hr>
<h2 id='list_to_matrix'>
Converting list to  matrix
</h2><span id='topic+list_to_matrix'></span>

<h3>Description</h3>

<p>Converting the data with class list to  the data with class matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_to_matrix(x, item = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_to_matrix_+3A_x">x</code></td>
<td>

<p>Data with class list
</p>
</td></tr>
<tr><td><code id="list_to_matrix_+3A_item">item</code></td>
<td>

<p>After converting list to  matrix, using NA to pad out the blanks within matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data with class matrix
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai,chaizz@126.com
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a list data "datalist", and covert "datalist" to a matrix data "datamat"
datalist&lt;-list(dataA=1:5,dataB=1:10,dataC=1:15,dataD=1:20)
datamat&lt;-list_to_matrix(datalist)
datamat
</code></pre>

<hr>
<h2 id='mingling'>
A forest spatial structure index characterizing tree diversity
</h2><span id='topic+mingling'></span>

<h3>Description</h3>

<p>The tree attribute mingling describes the species variety in the vicinity of a given reference tree and has been defined as the proportion of the n nearest neighbours
that do not belong to the same species
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mingling(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mingling_+3A_x">x</code></td>
<td>

<p>A vector composed by 5 tree species
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result will retrun five values,0,0.25,0.5,0.75,1,which means the propertion of 
the same tree species with refercence tree in the 4 nearest neighbours 
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>Hui GY, Zhao X, Zhao Z, Gadow Kv. 2011. Evaluating tree species spatial diversity based on neighborhood relationships. Forest Sci 57:292-300
</p>


<h3>Examples</h3>

<pre><code class='language-R'>spname1&lt;-c("sp1","sp1","sp1","sp1","sp1")
spname2&lt;-c("sp1","sp1","sp1","sp1","sp2")
spname3&lt;-c("sp1","sp1","sp1","sp3","sp2")
spname4&lt;-c("sp1","sp1","sp4","sp3","sp2")
spname5&lt;-c("sp1","sp5","sp4","sp3","sp2")

mingling1&lt;-mingling(spname1)
mingling1
mingling2&lt;-mingling(spname2)
mingling2
mingling3&lt;-mingling(spname3)
mingling3
mingling4&lt;-mingling(spname4)
mingling4
mingling5&lt;-mingling(spname5)
mingling5
</code></pre>

<hr>
<h2 id='nnangle'>
Identify the angle among nearest neighbours
</h2><span id='topic+nnangle'></span>

<h3>Description</h3>

<p>Describes the degree of regularity in the spatial distribution of n trees that are nearest to a reference tree. Moving clockwise around reference tree,the angle was obtained between two adjacent neighbours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnangle(nndist, nnx, nny)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnangle_+3A_nndist">nndist</code></td>
<td>

<p>Distance of nearest neighbour
</p>
</td></tr>
<tr><td><code id="nnangle_+3A_nnx">nnx</code></td>
<td>

<p>x coordinate of nearest neighbour
</p>
</td></tr>
<tr><td><code id="nnangle_+3A_nny">nny</code></td>
<td>

<p>y coordinate of nearest neighbour
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The angles obtained between two adjacent neighbours.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tree.ppp)
NNcoord&lt;-nnIndex(tree.ppp,N=4,smark=c("x","y"),buffer=FALSE)
NNangle&lt;-nnangle(NNcoord$nndist,NNcoord$nnx,NNcoord$nny)
NNangle
</code></pre>

<hr>
<h2 id='nnid'>
Find the id of nearest neighbour for each point.
</h2><span id='topic+nnid'></span>

<h3>Description</h3>

<p>Find the id of nearest neighbour for each point in a point pattern by specific numbers or  circular neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnid(X, N = NULL, R = NULL, id, exclude = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnid_+3A_x">X</code></td>
<td>

<p>A marked point pattern (object of class &quot;ppp&quot;).
</p>
</td></tr>
<tr><td><code id="nnid_+3A_n">N</code></td>
<td>

<p>Specific number of points in the neighborhood, the value is always assinged 4.
</p>
</td></tr>
<tr><td><code id="nnid_+3A_r">R</code></td>
<td>

<p>Specific circular neighborhood, the value is always assinged 5.
</p>
</td></tr>
<tr><td><code id="nnid_+3A_id">id</code></td>
<td>

<p>Specific identification number of each row in the point pattern.
</p>
</td></tr>
<tr><td><code id="nnid_+3A_exclude">exclude</code></td>
<td>

<p>Wether including id of core points,
if exclude is TRUE the result return the data removed the id of core points,
if exclude is FALSE the result return the data with the id of core points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>id of nearest neighbour for each point
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat)
library(spatstat.data)
data(finpines)
#Find the id of the nearest neighbour in a certain numbers and without id
finpines.rmidN4&lt;-nnid(finpines,id=paste("T",1:finpines$n),N=4)
finpines.rmidN4

#Find the id of the nearest neighbour in a certain numbers with id
finpines.idN4&lt;-nnid(finpines,id=paste("T",1:finpines$n),N=4,exclude=FALSE)
finpines.idN4

#Find the id of the nearest neighbour within a certain radius without id
data(tree.ppp)
finpines.rmidR0.5&lt;-nnid(tree.ppp,id=paste("T",1:41),R=0.5)
finpines.rmidR0.5

#Find the id of the nearest neighbour within a certain radius with id
finpines.idR0.5&lt;-nnid(tree.ppp,id=paste("T",1:41),R=0.5,exclude=FALSE)
finpines.idR0.5
</code></pre>

<hr>
<h2 id='nnIndex'>
Get the marks of nearest neighbour in the point pattern
</h2><span id='topic+nnIndex'></span>

<h3>Description</h3>

<p>Get the marks of nearest neighbour in the point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnIndex(X, id = 1:(X$n), smark = NULL, N = NULL,
        R = NULL, rm.id = NULL, add.X = NULL,
        add.id = paste("add", 1:(add.X$n), sep = ""),
        buffer = FALSE, buf.xwid = 5, buf.ywid = 5,
        exclusion = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnIndex_+3A_x">X</code></td>
<td>

<p>A marked point pattern (object of class &quot;ppp&quot;).
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_id">id</code></td>
<td>

<p>Specific identification number of each row in the point pattern.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_smark">smark</code></td>
<td>

<p>Selected marks to find the marks of nearest neighbour.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_n">N</code></td>
<td>

<p>Specific number of points in the neighborhood, the value is always assinged 4.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_r">R</code></td>
<td>

<p>Specific circular neighborhood, the value is always assinged 5.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_rm.id">rm.id</code></td>
<td>

<p>Needed removed the specific rows in the point pattern, refer to the id.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_add.x">add.X</code></td>
<td>

<p>Another point pattern need added in the point pattern.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_add.id">add.id</code></td>
<td>

<p>Specific identification number of each row in the added point pattern.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_buffer">buffer</code></td>
<td>

<p>if buffer is TRUE,show the all of data with buffer and core zone.
if buffer is FALSE,only show the data in the core zone.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_buf.xwid">buf.xwid</code></td>
<td>

<p>The width of buffer zone in the x coordinates of data points.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_buf.ywid">buf.ywid</code></td>
<td>

<p>The width of buffer zone in the y coordinates of data points.
</p>
</td></tr>
<tr><td><code id="nnIndex_+3A_exclusion">exclusion</code></td>
<td>

<p>Wether including the data of the buffer zone,
if exclude is TRUE the result return the data remove the data of the buffer zone,
and only the data of the core zone;if exclude is FALSE the result return the data with buffer and core zone.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a marked point pattern dataset X this function computes, for each desired location y, the mark attached to the point of X that is nearest to y. The desired locations y can be either a pixel grid or the point pattern X itself.see also the function &quot;nnmark&quot; in the package spatstat
</p>


<h3>Value</h3>

<p>Multiple &quot;nnmarks&quot; are the selected marks (smark) of nearest neighbour
nnid is the id of nearest neighbour
nndist is the distance of nearest neighbour
data is the final point pattern
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>See Also</h3>

<p>The function &quot;nnmark&quot; in the package spatstat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat)
library(spatstat.data)
library(spatstat.geom)
data(finpines)
#### Based on specific number (N=4) of nearest neighbour####
## Basic usage
nndN&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),N=1,
              smark="diameter",buffer=TRUE,buf.xwid =2,buf.ywid=3)
nndN
nndhN&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),N=4,
       smark=c("diameter","height"),buffer=TRUE,buf.xwid =2
       ,buf.ywid=3)
nndhN

# Only the points in the core zone (Removed the points in the buffer zone)
nndN_core&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),N=4,
              smark="diameter",buffer=FALSE,buf.xwid =2,buf.ywid=3)
nndN_core
nndhN_core&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),N=4,
         smark=c("diameter","height"),buffer=FALSE,buf.xwid =2,
         buf.ywid=3)
nndhN_core

## Remove some points, and then identify the marks of Nearest Neighbour
nndN.rm_core&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),
                    rm.id=c("T1","T3","T8","T9","T59","T60","T120"),
            N=4,smark="diameter",buffer=FALSE,buf.xwid =2,buf.ywid=3)
nndN.rm_core

## add some points, and then identify the marks  of Nearest Neighbour
add.x=c(-2,-1,0,2,4)
add.y=c(-4,-3,-6,0,1)
add.marks=data.frame(diameter=c(2.0,3.0,4.0,5.0,6.0),
                     height=c(2.5,3.5,4.5,5.5,6.5))
add.Xdata=ppp(x=add.x,y=add.y,marks=add.marks,c(-5,5),c(-8,2))

nndN.add_core&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),
                       add.X=add.Xdata,
                       add.id=paste("NT",1:5,sep=""),
          N=4,smark="diameter",buffer=FALSE,buf.xwid =2,buf.ywid=3)
nndN.add_core

#### Based on specific circular (R=5) of nearest neighbour####
## Basic usage
nndR&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),R=0.5,
              smark="diameter",buffer=TRUE,buf.xwid =2,buf.ywid=3)
nndR
nndhR&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),R=0.5,
              smark=c("diameter","height"),buffer=TRUE,
               buf.xwid =2,buf.ywid=3)
nndhR

# Only the points in the core zone (Removed the points in the buffer zone)
nndR_core&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),R=0.5,
            smark="diameter",buffer=FALSE,buf.xwid =2,buf.ywid=3)
nndR_core
nndhR_core&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),R=0.5,
            smark=c("diameter","height"),buffer=FALSE,
                    buf.xwid =2,buf.ywid=3)
nndhR_core

## Remove some points, and then identify the marks  of Nearest Neighbour
nndR.rm_core&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),
                  rm.id=c("T1","T3","T8","T9","T59","T60","T120"),
          R=0.5,smark="diameter",buffer=FALSE,buf.xwid =2,buf.ywid=3)
nndR.rm_core

## add some points, and then identify the marks  of Nearest Neighbour
nndR.add_core&lt;-nnIndex(finpines,id=paste("T",1:126,sep=""),
                       add.X=add.Xdata,
                       add.id=paste("NT",1:5,sep=""),
          R=0.5,smark="diameter",buffer=FALSE,buf.xwid =2,buf.ywid=3)
nndR.add_core
</code></pre>

<hr>
<h2 id='nnoverlap'>
Crown overlap among nearest neighbour
</h2><span id='topic+nnoverlap'></span>

<h3>Description</h3>

<p>Identify wheter crown overlap among nearest neighbour.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnoverlap(nncrown, nndist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nnoverlap_+3A_nncrown">nncrown</code></td>
<td>

<p>Crown width of nearest neighbour.
</p>
</td></tr>
<tr><td><code id="nnoverlap_+3A_nndist">nndist</code></td>
<td>

<p>Distance of nearest neighbour.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Crown overlap among nearest neighbour,the value is positive means overlap,
value is negative means no overlap.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tree.ppp)
NNcrown&lt;-nnIndex(tree.ppp,N=4,smark="crownwid.m",buffer=FALSE)
NNoverlap&lt;-nnoverlap(NNcrown$nncrownwid.m,NNcrown$nndist)
NNoverlap
</code></pre>

<hr>
<h2 id='opt_spastr'>
Optimal forest spatial structure indices.
</h2><span id='topic+opt_spastr'></span>

<h3>Description</h3>

<p>Optimal forest spatial structure indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_spastr(X_df,inter=100,pop=0.2,
                 smark=c("spe","storey","dbh","cw","x","y"),
                 xrange=c(0,100),yrange=c(0,100),
                 xwidth=5,ywidth=5,
                 buf.xwid = 5, buf.ywid = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opt_spastr_+3A_x_df">X_df</code></td>
<td>

<p>Forest community data (object of class &quot;data.frame&quot;)
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_inter">inter</code></td>
<td>

<p>Inter quanitity.
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_pop">pop</code></td>
<td>

<p>Cutting intensity.
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_smark">smark</code></td>
<td>

<p>Selected marks to compute forest spatial structure indices.
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_buf.xwid">buf.xwid</code></td>
<td>

<p>The width of buffer zone in the x coordinates of data points.
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_buf.ywid">buf.ywid</code></td>
<td>

<p>The width of buffer zone in the y coordinates of data points.
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_xrange">xrange</code></td>
<td>

<p>Range of X axes
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_yrange">yrange</code></td>
<td>

<p>Range of Y axes
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_xwidth">xwidth</code></td>
<td>

<p>Length of buffer zone of X axes
</p>
</td></tr>
<tr><td><code id="opt_spastr_+3A_ywidth">ywidth</code></td>
<td>

<p>Length of buffer zone of Y axes
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NULL
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat)
data(treecom_example)
head(treecom_example)
treecom_opt&lt;-opt_spastr(X_df=treecom_example,inter=5,pop=0.1,
              xrange=c(0,100),yrange=c(0,100),
              xwidth=10,ywidth=10,
              buf.xwid =10, buf.ywid = 10,
              smark=c("spe","storey","dbh","cw","x","y"))
treecom_opt
</code></pre>

<hr>
<h2 id='pv'>
Preference value
</h2><span id='topic+pv'></span>

<h3>Description</h3>

<p>A descriptive index to analyze the forest saptial structure indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pv(index, optm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pv_+3A_index">index</code></td>
<td>

<p>Actual value of forest spatial structure indices
</p>
</td></tr>
<tr><td><code id="pv_+3A_optm">optm</code></td>
<td>

<p>Optimal value of forest spatial structure indices
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of forest spatial structure heterogeneity assessment
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tree.ppp)
##Get the tree attributies of nearest neighbour 
nnindices&lt;-nnIndex(tree.ppp,N=4,
            smark=c("sp.code","dbh.cm","storey",
               "crownwid.m","group","biomass.kg",
               "quality","x","y"),buffer=FALSE)

#Species mingling
M&lt;-fsasN4(nnindices$nnsp.code,match.fun=mingling)
M
#Stand storey differation degree
H&lt;-fsasN4(nnindices$nnstorey,match.fun=differ)
H
#Tree successional degree
S&lt;-fsasN4(nnindices$nngroup,match.fun=ideal,para="Climax")
S
#Tree quality ideal state
Q&lt;-fsasN4(nnindices$nnquality,match.fun=ideal,
          para=c("Excellent","Good"))
Q
#Tree corwding degree
C&lt;-fsasN4(nnoverlap(nnindices$nncrownwid.m,
         nnindices$nndist),match.fun=crowding)
C
#Tree uniform angle index
W&lt;-fsasN4(nnangle(nnindices$nndist,nnindices$nnx,
           nnindices$nny)$nnangle,
          match.fun=uniform.angle,para=72)
W
#Tree dominance
U&lt;-fsasN4(nnindices$nndbh.cm,match.fun=dominance)
U
#Tree biomass dominance
B&lt;-fsasN4(nnindices$nnbiomass.kg,match.fun=dominance)
B

##Compute the structrue heterogeneity of index
M.pv&lt;-pv(M$result$index,optm=1)
M.pv
H.pv&lt;-pv(H$result$index,optm=1)
H.pv
S.pv&lt;-pv(S$result$index,optm=1)
S.pv
Q.pv&lt;-pv(Q$result$index,optm=1)
Q.pv
C.pv&lt;-pv(C$result$index,optm=0.5)
C.pv
W.pv&lt;-pv(W$result$index,optm=0.5)
W.pv
U.pv&lt;-pv(U$result$index,optm=0)
U.pv
B.pv&lt;-pv(B$result$index,optm=0)
B.pv

##Compute total forest saptial structrue heterogeneity 
#based on the average of indices preference value 
IAVE&lt;-pv(index=c(M$meanI,H$meanI,S$meanI,Q$meanI,
                       C$meanI,W$meanI,U$meanI,B$meanI),
               optm=c(1,1,1,1,0.5,0.5,0,0))
IAVE

##Compute total forest saptial structrue heterogeneity 
#based on the preference value of indices average 
IPVE=mean(M.pv,H.pv,S.pv,Q.pv,C.pv,W.pv,U.pv,B.pv)
IPVE
</code></pre>

<hr>
<h2 id='rebuild.ppp'>
Reestablishing an object of class &quot;ppp&quot;
</h2><span id='topic+rebuild.ppp'></span>

<h3>Description</h3>

<p>Reestablishing an object of class &quot;ppp&quot; by adding or removing some data from orginal point pattern (object of class &quot;ppp&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebuild.ppp(X, id = 1:(X$n), rm.id = NULL, add.X = NULL,
          add.id = paste("add", 1:(add.X$n), sep = ""))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rebuild.ppp_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class &quot;ppp&quot;).
</p>
</td></tr>
<tr><td><code id="rebuild.ppp_+3A_id">id</code></td>
<td>

<p>Specific identification number of each row in the point pattern.
</p>
</td></tr>
<tr><td><code id="rebuild.ppp_+3A_rm.id">rm.id</code></td>
<td>

<p>Needed removed the specific rows in the point pattern, refer to the id.
</p>
</td></tr>
<tr><td><code id="rebuild.ppp_+3A_add.x">add.X</code></td>
<td>

<p>Another point pattern need added in the point pattern.
</p>
</td></tr>
<tr><td><code id="rebuild.ppp_+3A_add.id">add.id</code></td>
<td>

<p>Specific identification number of each row in the added point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class &quot;ppp&quot; describing a point pattern in the two-dimensional plane (see ppp.object), which was Reestablished by adding or removing some data from orginal point pattern
</p>


<h3>Value</h3>

<p>A new point pattern after reestablished by adding or removing some data from orginal point pattern
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>See Also</h3>

<p>R function ppp in the package &quot;spatstat&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat.geom)
####Based on the simulated data####
# Creating a simulated point pattern
x &lt;- runif(20)
y &lt;- runif(20)
X &lt;- ppp(x, y, c(0,1), c(0,1))
X

# Adding a identification number (ID) for each data point in the point pattern
# the following are equivalent
X1&lt;-rebuild.ppp(X)
X1&lt;-rebuild.ppp(X,id=1:X$n)
X1&lt;-rebuild.ppp(X,id=1:20)
X1
as.data.frame(X1)

# Adding a identification number (ID) for each data point in the point pattern, and
# Removing the assinged points according to the ID.
X2&lt;-rebuild.ppp(X,id=1:20,rm.id=1:5)
X2
as.data.frame(X2)
# Adding some points into orginal point pattern
newx &lt;- runif(10)
newy &lt;- runif(10)
newX &lt;- ppp(newx, newy, c(0,1), c(0,1))
XY&lt;-rebuild.ppp(X,add.X=newX,add.id=paste("new",1:10,sep=""))
XY
as.data.frame(XY)

####Based on the example data####
library(spatstat.data)
data(finpines)
finpines
# Marked planar point pattern: 126 points
# Mark variables: diameter, height
# window: rectangle = [-5, 5] x [-8, 2] metres

# Adding a identification number (ID) for each tree in the finpines
# finpines$n
# [1] 126
finpines_id&lt;-rebuild.ppp(finpines,id=paste("T",1:126,sep=""))
finpines_id
head(as.data.frame(finpines_id))

# Removing the trees with id "T1","T3","T8","T9","T59","T60","T120"
finpines_rm&lt;-rebuild.ppp(X=finpines,id=paste("T",1:126,sep=""),
                        rm.id=c("T1","T3","T8","T9","T59","T60","T120"))
finpines_rm
as.data.frame(finpines_rm)

# Adding some trees data into finpines
add.x=c(-2,-1,0,2,4)
add.y=c(-4,-3,-6,0,1)
add.marks=data.frame(diameter=c(2.0,3.0,4.0,5.0,6.0),
                 height=c(2.5,3.5,4.5,5.5,6.5))
add.Xdata=ppp(x=add.x,y=add.y,marks=add.marks,c(-5,5),c(-8,2))

finpines_add&lt;-rebuild.ppp(X=finpines,id=paste("T",1:126,sep=""),
                         add.X=add.Xdata,add.id=paste("NT",1:5,sep=""))
finpines_add
as.data.frame(finpines_add)
</code></pre>

<hr>
<h2 id='shrinkedge'>
Shrink the edges for the point pattern
</h2><span id='topic+shrinkedge'></span>

<h3>Description</h3>

<p>Sometimes, the window of point pattern is too large, we can shrink its edges to the wanted window of point pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shrinkedge(X, xwidth, ywidth, id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shrinkedge_+3A_x">X</code></td>
<td>

<p>A point pattern (object of class &quot;ppp&quot;).
</p>
</td></tr>
<tr><td><code id="shrinkedge_+3A_xwidth">xwidth</code></td>
<td>

<p>Distance from the edges x coordinates,note xwidth is the half of your width wanted, because the width will shrink both edges in the x coordinates.
</p>
</td></tr>
<tr><td><code id="shrinkedge_+3A_ywidth">ywidth</code></td>
<td>

<p>Distance from the edges y coordinates,note xwidth is the half of your width wanted, because the width will shrink both edges in the y coordinates.
</p>
</td></tr>
<tr><td><code id="shrinkedge_+3A_id">id</code></td>
<td>

<p>Specific identification number of the points in the point pattern.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When expanding for the full pattern, and using expandedge() with a positive  xwidth and ywidth; conversely, shrinking for the full pattern, and using shrinkedge () with a negative xwidth and ywidth,the parts of the pattern that are at a distance less than -width from an edge are discarded.
</p>


<h3>Value</h3>

<p>Result returns original data (not a point pattern with the same structure as trees), id is new id of points after edges expanded and old.id is orginal id of points.
If xwidth or ywidth = 0, trees are returned unchanged.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat.data)
data(finpines)
finpines$window
# window: rectangle = [-5, 5] x [-8, 2] metres

#Shrink the rectangle [-5,5]x[-8,2] to [-3,3]x[-5,-1]
shrink.trees&lt;- shrinkedge(finpines,xwidth=2,ywidth=3,id=1:126)
shrink.trees

# Show the changes by figures
opar&lt;-par(mfrow=c(1,2))
plot(finpines$x,finpines$y)
text(finpines$x,finpines$y,1:126)
rect(-3,-5,3,-1,border="red")
plot(shrink.trees$x,shrink.trees$y)
text(shrink.trees$x,shrink.trees$y,shrink.trees$old.id)
par(opar)
</code></pre>

<hr>
<h2 id='simtreecom'>
Simulated a forest community data.
</h2><span id='topic+simtreecom'></span>

<h3>Description</h3>

<p>Simulated a forest community data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simtreecom(size,nspe,nspe_max,xrange,
           yrange,dbhrange,type="com",lambda=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simtreecom_+3A_size">size</code></td>
<td>

<p>Pool of species
</p>
</td></tr>
<tr><td><code id="simtreecom_+3A_nspe">nspe</code></td>
<td>

<p>Number of species
</p>
</td></tr>
<tr><td><code id="simtreecom_+3A_nspe_max">nspe_max</code></td>
<td>

<p>Maximum number of species
</p>
</td></tr>
<tr><td><code id="simtreecom_+3A_xrange">xrange</code></td>
<td>

<p>Range of X axes
</p>
</td></tr>
<tr><td><code id="simtreecom_+3A_yrange">yrange</code></td>
<td>

<p>Range of Y axes
</p>
</td></tr>
<tr><td><code id="simtreecom_+3A_dbhrange">dbhrange</code></td>
<td>

<p>Range of DBH
</p>
</td></tr>
<tr><td><code id="simtreecom_+3A_type">type</code></td>
<td>

<p>Data type, &quot;ppp&quot; or &quot;com&quot;
</p>
</td></tr>
<tr><td><code id="simtreecom_+3A_lambda">lambda</code></td>
<td>

<p>Degree of coordinate aggregation
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of forest community data
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>treecom&lt;-simtreecom(size=10,nspe=10,nspe_max=36,xrange=c(0,100),
           yrange=c(0,100),dbhrange=c(5,50),type="com",lambda=1)
treecom
</code></pre>

<hr>
<h2 id='spastr'>
Computing forest spatial structure indices.
</h2><span id='topic+spastr'></span>

<h3>Description</h3>

<p>Computing forest spatial structure indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spastr(X_df,smark=c("spe","storey","dbh","cw","x","y"),
                 buffer = FALSE,
                 xrange=c(0,100),yrange=c(0,100),
                 xwidth=5,ywidth=5,
                 buf.xwid = 5, buf.ywid = 5,
                 exclusion = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spastr_+3A_x_df">X_df</code></td>
<td>

<p>Forest community data (object of class &quot;data.frame&quot;)
</p>
</td></tr>
<tr><td><code id="spastr_+3A_smark">smark</code></td>
<td>

<p>Selected marks to compute forest spatial structure indices.
</p>
</td></tr>
<tr><td><code id="spastr_+3A_buffer">buffer</code></td>
<td>

<p>if buffer is TRUE,show the all of data with buffer and core zone.
if buffer is FALSE,only show the data in the core zone.
</p>
</td></tr>
<tr><td><code id="spastr_+3A_buf.xwid">buf.xwid</code></td>
<td>

<p>The width of buffer zone in the x coordinates of data points.
</p>
</td></tr>
<tr><td><code id="spastr_+3A_buf.ywid">buf.ywid</code></td>
<td>

<p>The width of buffer zone in the y coordinates of data points.
</p>
</td></tr>
<tr><td><code id="spastr_+3A_xrange">xrange</code></td>
<td>

<p>Range of X axes
</p>
</td></tr>
<tr><td><code id="spastr_+3A_yrange">yrange</code></td>
<td>

<p>Range of Y axes
</p>
</td></tr>
<tr><td><code id="spastr_+3A_xwidth">xwidth</code></td>
<td>

<p>Length of buffer zone of X axes
</p>
</td></tr>
<tr><td><code id="spastr_+3A_ywidth">ywidth</code></td>
<td>

<p>Length of buffer zone of Y axes
</p>
</td></tr>
<tr><td><code id="spastr_+3A_exclusion">exclusion</code></td>
<td>

<p>Wether including the data of the buffer zone,
if exclude is TRUE the result return the data remove the data of the buffer zone,
and only the data of the core zone;if exclude is FALSE the result return the data with buffer and core zone.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NULL
</p>


<h3>Value</h3>

<p>NULL
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat)
data(treecom_example)
head(treecom_example)
treecom_spastr&lt;-spastr(X_df=treecom_example,
              xrange=c(0,100),yrange=c(0,100),
              xwidth=10,ywidth=10,
              buf.xwid =10, buf.ywid = 10,
              smark=c("spe","storey","dbh","cw","x","y"))
treecom_spastr
</code></pre>

<hr>
<h2 id='storeydvd'>
Dividing the forest storeies
</h2><span id='topic+storeydvd'></span>

<h3>Description</h3>

<p>Forest overstory can be divided the many stories by dividing the range of tree height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storeydvd(height, minH = min(height), maxH = max(height),
      storeynum = 6, include.lowest = TRUE, right = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="storeydvd_+3A_height">height</code></td>
<td>

<p>Data of tree height
</p>
</td></tr>
<tr><td><code id="storeydvd_+3A_minh">minH</code></td>
<td>

<p>Minimum value of height
</p>
</td></tr>
<tr><td><code id="storeydvd_+3A_maxh">maxH</code></td>
<td>

<p>Maximum value of height
</p>
</td></tr>
<tr><td><code id="storeydvd_+3A_storeynum">storeynum</code></td>
<td>

<p>Number of storey
</p>
</td></tr>
<tr><td><code id="storeydvd_+3A_include.lowest">include.lowest</code></td>
<td>

<p>Logical, indicating if an &quot;[i]&quot; equal to the lowest (or highest, for right=FALSE) &quot;breaks&quot; value should be included. See the function &quot;cut&quot;.
</p>
</td></tr>
<tr><td><code id="storeydvd_+3A_right">right</code></td>
<td>

<p>Logical, indicating if the intervals should be closed on the right (and open on the left) or vice versa.See the function &quot;cut&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>heightfreq is the frequency of tree height
heightdata is the result after divided the storey
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spatstat)
data(finpines)
finpinesdata&lt;-as.data.frame(finpines)
####Dividing the stories
finpines.storey&lt;-storeydvd(finpinesdata$height,storeynum=6)
finpines.storey

####Computing the storey differation
##Add the storey mark for finepines
finpines.addstorey&lt;-addmark.ppp(finpines,
              add.mark=finpines.storey$heightdata[,2:3],
                    add.name=c("interval","storey" ))
finpines.addstorey
##Compute the storeies of nearest neighbour in the point pattern
finpines.nnstorey&lt;-nnIndex(finpines.addstorey,smark="storey",N=4,
                           buf.xwid =2,buf.ywid=3)
##Compute the stoery differation
finpines.H&lt;-fsasN4(finpines.nnstorey$nnstorey,match.fun=differ)
finpines.H
</code></pre>

<hr>
<h2 id='tree.ppp'>
Sample data for analizing the forest spatial structure.
</h2><span id='topic+tree.ppp'></span>

<h3>Description</h3>

<p>A sample data of field survey, to help us understanding the method of forest spatial structure analysis.class is &quot;ppp&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("tree.ppp")</code></pre>


<h3>Details</h3>

<p>The function &quot;ppp&quot; in the package spatstat.geom
</p>


<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tree.ppp)
</code></pre>

<hr>
<h2 id='treecom_example'>
Example data for analizing the forest community.
</h2><span id='topic+treecom_example'></span>

<h3>Description</h3>

<p>A example data of field survey, to help us understanding the method of forest spatial structure analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("treecom_example")</code></pre>


<h3>Format</h3>

<p>A data frame
</p>

<dl>
<dt><code>x</code></dt><dd><p>x coordinates of trees</p>
</dd>
<dt><code>y</code></dt><dd><p>y coordinates of trees</p>
</dd>
<dt><code>id</code></dt><dd><p>Specific identification number of trees</p>
</dd>
<dt><code>spe</code></dt><dd><p>Specific code of tree species in the point pattern</p>
</dd>
<dt><code>dbh</code></dt><dd><p>Diameter at breast height (DBH),1.3 m. unit:cm</p>
</dd>
<dt><code>ht</code></dt><dd><p>Tree height,unit:m</p>
</dd>
<dt><code>cw</code></dt><dd><p>Crown width,unit:m</p>
</dd>
<dt><code>hcb</code></dt><dd><p>height of crown base,unit:m</p>
</dd>
<dt><code>volume</code></dt><dd><p>volume of individual trees,unit:m3</p>
</dd>
<dt><code>quality</code></dt><dd><p>Quality of individual trees</p>
</dd>
<dt><code>storey</code></dt><dd><p>forest storey</p>
</dd>
</dl>



<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(treecom_example)
treecom_example
</code></pre>

<hr>
<h2 id='treedata'>
Sample data for analizing the forest spatial structure.
</h2><span id='topic+treedata'></span>

<h3>Description</h3>

<p>A sample data of field survey, to help us understanding the method of forest spatial structure analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("treedata")</code></pre>


<h3>Format</h3>

<p>A data frame with 41 observations on the following 11 variables.
</p>

<dl>
<dt><code>tree.id</code></dt><dd><p>Specific identification number of trees in the point pattern</p>
</dd>
<dt><code>x</code></dt><dd><p>x coordinates of trees</p>
</dd>
<dt><code>y</code></dt><dd><p>y coordinates of trees</p>
</dd>
<dt><code>sp.code</code></dt><dd><p>Specific code of tree species in the point pattern</p>
</dd>
<dt><code>dbh.cm</code></dt><dd><p>Diameter at breast height (DBH),1.3 m. unit:cm</p>
</dd>
<dt><code>h.m</code></dt><dd><p>Tree height,unit:m</p>
</dd>
<dt><code>storey</code></dt><dd><p>forest storey</p>
</dd>
<dt><code>crownwid.m</code></dt><dd><p>Crown width,unit:m</p>
</dd>
<dt><code>group</code></dt><dd><p>Tree group, which can be divided exotic,pioneer,transtional,climax,5 types</p>
</dd>
<dt><code>biomass.kg</code></dt><dd><p>Tree biomass,unit:kg</p>
</dd>
<dt><code>quality</code></dt><dd><p>Quality of individual trees</p>
</dd>
</dl>



<h3>References</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(treedata)
</code></pre>

<hr>
<h2 id='uniform.angle'>
A forest spatial structure index characterizing tree spatial
distribution patterns
</h2><span id='topic+uniform.angle'></span>

<h3>Description</h3>

<p>The uniform angle index (UAI) is used to characterize the spatial distribution of a forest community or of individual tree species
within that community.By gradually comparing the included  4 angles with the standard angle (72).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform.angle(x, para)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniform.angle_+3A_x">x</code></td>
<td>

<p>Moving clockwise around reference tree,4 angle were obtained among adjacent neighbours
</p>
</td></tr>
<tr><td><code id="uniform.angle_+3A_para">para</code></td>
<td>

<p>standard angle (72)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result will retrun five values,0,0.25,0.5,0.75,1,which means
none, one, two, three, or four angles are smaller than 72,
respectively.
</p>


<h3>Author(s)</h3>

<p>Zongzheng Chai, chaizz@126.com
</p>


<h3>References</h3>

<p>Zhao ZH, Hui GY, Hu YB, Wang HX, Zhang GQ, and von Gadow K. 2014. Testing the significance of different tree spatial distribution patterns based on the uniform angle index. Canadian Journal of Forest Research 44:1419-1425.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>angle1&lt;-c(80,80,80,80)
angle2&lt;-c(80,80,80,70)
angle3&lt;-c(80,80,60,70)
angle4&lt;-c(80,50,60,70)
angle5&lt;-c(40,50,60,70)

uai1&lt;-uniform.angle(angle1,para=72)
uai1
uai2&lt;-uniform.angle(angle2,para=72)
uai2
uai3&lt;-uniform.angle(angle3,para=72)
uai3
uai4&lt;-uniform.angle(angle4,para=72)
uai4
uai5&lt;-uniform.angle(angle5,para=72)
uai5
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
