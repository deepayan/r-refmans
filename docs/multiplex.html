<!DOCTYPE html><html><head><title>Help for package multiplex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multiplex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multiplex-package'>
<p>Algebraic Tools for the Analysis of Multiple Social Networks</p></a></li>
<li><a href='#as.semigroup'>
<p>Coerce to a Semigroup Object</p></a></li>
<li><a href='#as.signed'>
<p>Coerce to a Signed Object</p></a></li>
<li><a href='#as.strings'>
<p>Coerce an Object to a Strings Class</p></a></li>
<li><a href='#bnd'>
<p>internal function</p></a></li>
<li><a href='#bundle.census'>
<p>Bundle Census</p></a></li>
<li><a href='#bundles'>
<p>Bundle Class Patterns</p></a></li>
<li><a href='#cngr'>
<p>Congruence Relations</p></a></li>
<li><a href='#comps'>
<p>Find components in multiple networks</p></a></li>
<li><a href='#coor'>
<p>internal function</p></a></li>
<li><a href='#cpath'>
<p>internal function</p></a></li>
<li><a href='#cph'>
<p>Cumulated Person Hierarchy</p></a></li>
<li><a href='#cscl'>
<p>internal function</p></a></li>
<li><a href='#decomp'>
<p>Decomposition of a Semigroup Structure</p></a></li>
<li><a href='#dhc'>
<p>internal function</p></a></li>
<li><a href='#diagram'>
<p>Plot the Hasse Diagram of a set of ordered relations</p></a></li>
<li><a href='#diagram.levels'>
<p>Levels in the Lattice Diagram</p></a></li>
<li><a href='#dichot'>
<p>Dichotomize data with a cutoff value</p></a></li>
<li><a href='#edgel'>
<p>Read edge list files</p></a></li>
<li><a href='#edgeT'>
<p>Edge Table Generator</p></a></li>
<li><a href='#edgS'>
<p>internal function</p></a></li>
<li><a href='#expos'>
<p>Network exposure for multiple networks</p></a></li>
<li><a href='#fact'>
<p>Factorisation of semigroup structures</p></a></li>
<li><a href='#flt'>
<p>internal function</p></a></li>
<li><a href='#fltr'>
<p>Principal filters</p></a></li>
<li><a href='#galois'>
<p>Galois derivations between subsets</p></a></li>
<li><a href='#green.rel'>
<p>Green's Relations</p></a></li>
<li><a href='#hierar'>
<p>Person and Relation Hierarchy</p></a></li>
<li><a href='#incubs'>
<p>Incubator networks dataset</p></a></li>
<li><a href='#jnt'>
<p>internal function</p></a></li>
<li><a href='#men'>
<p>internal function</p></a></li>
<li><a href='#mlvl'>
<p>Construct multilevel networks</p></a></li>
<li><a href='#mmp'>
<p>internal function</p></a></li>
<li><a href='#mnplx'>
<p>Make a multiple network as monoplex structure</p></a></li>
<li><a href='#mxmn'>
<p>internal function</p></a></li>
<li><a href='#neighb'>
<p>Neighborhood of an actor or group of actors</p></a></li>
<li><a href='#ngbs'>
<p>internal function</p></a></li>
<li><a href='#pacnet'>
<p>Read Output from Pacnet</p></a></li>
<li><a href='#partial.order'>
<p>The Partial Order of String relations or of Galois derivations</p></a></li>
<li><a href='#perm'>
<p>Array Permutation</p></a></li>
<li><a href='#pfvn'>
<p>Pathfinder valued network and triangle inequality</p></a></li>
<li><a href='#pi.rels'>
<p><code class="reqn">\pi</code>-Relations</p></a></li>
<li><a href='#prev'>
<p>Preview of the Semigroup Construction</p></a></li>
<li><a href='#print.gml'>
<p>internal function</p></a></li>
<li><a href='#print.reduced'>
<p>internal function</p></a></li>
<li><a href='#rbox'>
<p>Construct the Relation-Box</p></a></li>
<li><a href='#read.dl'>
<p>Read <code>dl</code> Files</p></a></li>
<li><a href='#read.gml'>
<p>Read <code>gml</code> Files</p></a></li>
<li><a href='#redl'>
<p>internal function</p></a></li>
<li><a href='#reduc'>
<p>Reduce a matrix or array</p></a></li>
<li><a href='#reducs'>
<p>internal function</p></a></li>
<li><a href='#rel.sys'>
<p>Relational System</p></a></li>
<li><a href='#rm.isol'>
<p>Remove Isolates</p></a></li>
<li><a href='#semigroup'>
<p>Constructing the Semigroup of Relations</p></a></li>
<li><a href='#semiring'>
<p>Semiring Structures for Balance Theory</p></a></li>
<li><a href='#signed'>
<p>Signed Network</p></a></li>
<li><a href='#sprt'>
<p>internal function</p></a></li>
<li><a href='#strings'>
<p>Strings of Relations</p></a></li>
<li><a href='#strng'>
<p>internal function</p></a></li>
<li><a href='#summaryBundles'>
<p>Summary of Bundle Classes</p></a></li>
<li><a href='#swp'>
<p>internal function</p></a></li>
<li><a href='#ti'>
<p>internal function</p></a></li>
<li><a href='#transf'>
<p>Transform Data from/to Matrix/List Formats</p></a></li>
<li><a href='#transl'>
<p>internal function</p></a></li>
<li><a href='#trnf'>
<p>internal function</p></a></li>
<li><a href='#wordT'>
<p>The Word Table of Relations</p></a></li>
<li><a href='#write.dat'>
<p>Write <code>dat</code> Files</p></a></li>
<li><a href='#write.dl'>
<p>Write <code>dl</code> Files</p></a></li>
<li><a href='#write.edgel'>
<p>Write edge list files</p></a></li>
<li><a href='#write.gml'>
<p>Write <code>gml</code> Files</p></a></li>
<li><a href='#zbind'>
<p>Combine Arrays</p></a></li>
<li><a href='#zbnd'>
<p>internal function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>multigraph, Rgraphviz, knitr</td>
</tr>
<tr>
<td>Title:</td>
<td>Algebraic Tools for the Analysis of Multiple Social Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Algebraic procedures for analyses of multiple social networks are delivered with this 
	    package as described in Ostoic (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v092.i11">doi:10.18637/jss.v092.i11</a>&gt;. 'multiplex' makes 
	    possible, among other things, to create and manipulate multiplex, multimode, and 
	    multilevel network data with different formats. Effective ways are available to treat 
	    multiple networks with routines that combine algebraic systems like the partially ordered 
	    semigroup with decomposition procedures or semiring structures with the relational 
	    bundles occurring in different types of multivariate networks. 'multiplex' provides also 
	    an algebraic approach for affiliation networks through Galois derivations between families 
	    of the pairs of subsets in the two domains of the network with visualization options.</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-16</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Rivero Ostoic [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Rivero Ostoic &lt;multiplex@post.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mplex/multiplex/">https://github.com/mplex/multiplex/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mplex/multiplex/issues/">https://github.com/mplex/multiplex/issues/</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-16 13:23:42 UTC; AOST</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-16 15:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='multiplex-package'>
Algebraic Tools for the Analysis of Multiple Social Networks
</h2><span id='topic+multiplex-package'></span>

<h3>Description</h3>

<p>One of the aims of the <code>"multiplex"</code> package is to meet the necessity to count with an analytic tool specially designed for social networks with relations at different levels. In this sense, <code>"multiplex"</code> counts with functions that models the local role algebras of the network based on the simple and compound relations existing in the system, and also a procedure for the construction and analysis of signed networks through the semiring structure. The different relational patterns at the dyadic level in the network can be obtained as well, which can serve for a further analysis with different types of structural theories.
</p>
<p>It is also possible to take the attributes of the actors in the analysis of multiple networks with different forms to incorporate this kind of information to the existing relational structures. In this case for example the network exposure of the actors can be taken in the context of multiple networks, or else the attributes can be embedded in the resulted algebraic structures.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> multiplex </td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.1.1 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 16 November 2023 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>To work with this package we typically start with a specific algebraic structure. A semigroup is a closed system made of a set of elements and an associative operation on it. This algebraic structure is constructed by the <code>semigroup</code> function, and it takes an array of (usually but not necessarily) multiple binary relations, which are the generator relations. The Word Table and the Edge Table serve to describe completely the semigroup, and they are constructed with the functions <code>wordT</code> and <code>edgeT</code> respectively. Unique relations of the complete semigroup are given by the <code>strings</code> function. The <code>partial.order</code> function specifies the ordering of the string elements in the semigroup. The function <code>diagram</code> produces the lattice of inclusions of a structure having ordered relations.
</p>
<p>Semigroups can be analysed further by the <code>green.rel</code> function, and semigroups can also be reduced by a decomposition process. The decomposition is based on congruence or <code class="reqn">\pi</code>-relations of the unique strings imported from Pacnet. In this case <code>pi.rels</code>, <code>cngr</code>, and <code>decomp</code> will make this job for you either for an abstract or a partially ordered structure.
</p>
<p>In addition, it is possible to analyse structural balance in signed networks, which are built by <code>signed</code>, through the algebraic structure of the semiring. A semiring is an algebraic structure that combines an abstract semigroup with identity under multiplication and a commutative monoid under addition. The <code>semiring</code> function is capable to perform both balance and cluster semiring either with cycles or semicycles.
</p>
<p>There are other capabilities in the package that are not strictly algebraic. For instance, the <code>dichot</code> serves to dichotomize the input data with a specified cut-off value, <code>rm.isol</code> removes isolated nodes, and the <code>perm</code> function performs an automorphism of the elements in the representative array. All these functions are built for multiple networks represented by high dimensional structures that can be constructed by the function <code>zbind</code>.
</p>
<p>The <code>"multiplex"</code> package creates a Relation-Box with the <code>rbox</code> function, and it implements the Partial Structural Equivalence expressed in the cumulated person hierarchy of the network calculated via the <code>cph</code> function.
</p>
<p>Relational bundles are identified through the <code>bundles</code> function, which provides lists of pair relations. The <code>transf</code> function serves to transform such data into a matrix form. The enumeration of the different bundle classes is given by <code>bundle.census</code>. An advantage of counting with the bundle patterns is that the different types of bundles serve to establish a system inside the network, in which it is possible to measure the network exposure in multivariate relational systems. Such features can be realized via the <code>rel.sys</code> and <code>expos</code> functions respectively. Several attributes can be derived by <code>galois</code>, which provides an algebraic approach for two-mode networks.
</p>
<p>Finally, multivariate network data can be created through the (s)end (r)eceive (t)ies edge list format that can be loaded and transformed to arrays via the <code>edgel</code> function. Other formats for multiple network data like UCINET <code>dl</code> or Visone <code>gml</code> can be imported and exported as well with the <code>"multiplex"</code> package.
</p>


<h3>Author(s)</h3>

<p>J. Antonio Rivero Ostoic
</p>
<p>Maintainer: Antonio Rivero Ostoic &lt;multiplex@post.com&gt;
</p>


<h3>References</h3>

<p>Pattison, P.E. <em>Algebraic Models for Social Networks</em>. Cambridge University Press. 1993.
</p>
<p>Boyd, J.P. <em>Social Semigroups. A unified theory of scaling and blockmodelling as applied to social networks</em>. George Mason University Press. 1991.
</p>
<p>Lorrain, F. and H.C. White, &ldquo;Structural Equivalence of Individuals in Social Networks.&rdquo; <em>Journal of Mathematical Sociology</em>, 1, 49-80. 1971.
</p>
<p>Boorman, S.A. and H.C. White, &ldquo;Social Structure from Multiple Networks. II. Role Structures.&rdquo; <em>American Journal of Sociology</em>, 81 (6), 1384-1446. 1976.
</p>
<p>Ostoic, J.A.R. <em>Algebraic Analysis of Social Networks</em>. Wiley. 2021
</p>


<h3>See Also</h3>

<p><code><a href="multigraph.html#topic+multigraph">multigraph</a></code>, <code><a href="multigraph.html#topic+bmgraph">bmgraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two binary relations among three elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 3 ) )

## Dichotomize it with customized cutoff value
dichot(arr, c = 3)

## preview
prev(arr)

## create the semigroup and look at Green's relations
semigroup(arr) |&gt; green.rel()

## and look at the strings
strings(arr)

</code></pre>

<hr>
<h2 id='as.semigroup'>
Coerce to a Semigroup Object
</h2><span id='topic+as.semigroup'></span>

<h3>Description</h3>

<p>A generic function for coercing an R object to a <code><a href="#topic+semigroup">semigroup</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.semigroup(x, gens = NA, lbs, numerical, edgeT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.semigroup_+3A_x">x</code></td>
<td>

<p>an array representing the semigroup
</p>
</td></tr>
<tr><td><code id="as.semigroup_+3A_gens">gens</code></td>
<td>

<p>array or vector representing the semigroup generators
</p>
</td></tr>
<tr><td><code id="as.semigroup_+3A_lbs">lbs</code></td>
<td>

<p>(optional) label strings for the semigroup
</p>
</td></tr>
<tr><td><code id="as.semigroup_+3A_numerical">numerical</code></td>
<td>

<p>(optional and logical) should the semigroup have numerical format?
</p>
</td></tr>
<tr><td><code id="as.semigroup_+3A_edget">edgeT</code></td>
<td>

<p>(optional, logical, and experimental) is &lsquo;x&rsquo; an edge table?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since many of the functions in the <code>multiplex</code> package require an object of the '<code>Semigroup</code>' class, this function produces this class object from an array representing the semigroup structure.
</p>


<h3>Value</h3>

<p>An object of the '<code>Semigroup</code>' class
</p>
<table>
<tr><td><code>ord</code></td>
<td>

<p>a number with the dimension of the semigroup
</p>
</td></tr>
<tr><td><code>st</code></td>
<td>

<p>the strings, i.e. a vector of the unique relations
</p>
</td></tr>
<tr><td><code>gens</code></td>
<td>

<p>the semigroup generators
</p>
</td></tr>
<tr><td><code>S</code></td>
<td>

<p>the multiplication table of the semigroup
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semigroup">semigroup</a></code>, <code><a href="#topic+green.rel">green.rel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create labeled multiplication table data
s &lt;- matrix(data=c(1, 1, 1, 3, 3, 3, 3, 3, 3), nrow=3, ncol=3, byrow=TRUE)
attr(s, "dimnames") &lt;- list(1:3,1:3)

## make a semigroup object
as.semigroup(s)

</code></pre>

<hr>
<h2 id='as.signed'>
Coerce to a Signed Object
</h2><span id='topic+as.signed'></span>

<h3>Description</h3>

<p>A generic function for coercing an object to a <code>Signed</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.signed(x, lbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.signed_+3A_x">x</code></td>
<td>

<p>a matrix representing the signed network
</p>
</td></tr>
<tr><td><code id="as.signed_+3A_lbs">lbs</code></td>
<td>

<p>(optional) labels for the signed matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since the <code>semiring</code> function requires an object with a '<code>Signed</code>' class, this function produces this class object from an array representing the signed network
</p>


<h3>Value</h3>

<p>The array as a <code>Signed</code> class
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signed">signed</a></code>, <code><a href="#topic+semiring">semiring</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the data
data("incubA")

## Coerce parts of the signed matrix with two types of relations
as.signed(signed(incubA$IM)$s[1:2,1:2])

</code></pre>

<hr>
<h2 id='as.strings'>
Coerce an Object to a Strings Class
</h2><span id='topic+as.strings'></span>

<h3>Description</h3>

<p>A generic function for coercing an R object to a <code>Rel.Strings</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.strings(x, lbs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.strings_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed.
</p>
</td></tr>
<tr><td><code id="as.strings_+3A_lbs">lbs</code></td>
<td>

<p>(optional) the labels of the strings
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to proceed with the establishment of the partial order in the strings of relations where the object should be of a '<code>Strings</code>' class.
</p>


<h3>Value</h3>

<p>An object of '<code>Strings</code>' class
</p>
<table>
<tr><td><code>wt</code></td>
<td>

<p>the word tables
</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>

<p>the number of unique relations in the semigroup
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strings">strings</a></code>, <code><a href="#topic+partial.order">partial.order</a></code>, <code><a href="#topic+zbind">zbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two sets with a pair of binary relations among 
## three elements
arr1 &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
        c(3,3,2))&gt;.5, 3 ) )

arr2 &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
        c(3,3,2))&gt;.5, 3 ) )

## bind the data sets
arrs &lt;- zbind(arr1, arr2)

## make the data a strings object
as.strings(arrs)

</code></pre>

<hr>
<h2 id='bnd'>
internal function
</h2><span id='topic+bnd'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='bundle.census'>
Bundle Census
</h2><span id='topic+bundle.census'></span>

<h3>Description</h3>

<p>A function to perform the Bundle Census in multiple networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bundle.census(x, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bundle.census_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed.
</p>
</td></tr>
<tr><td><code id="bundle.census_+3A_loops">loops</code></td>
<td>

<p>(logical) whether or not the loops should be considered
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the number of occurrences for each bundle class pattern in multiple networks. A bundle is a particular type of pattern made of relations at different levels that is binding a pair of nodes or actors. Depending on the direction and occurrence of each possible tie, then it is possible to count with seven dyadic configuration classes in the census. 
</p>


<h3>Value</h3>

<p>A table with the occurrences in the distinct bundle class patterns. The first column in the output gives the number of bundles in the network, excluding the null pattern, and then the totals for each bundle class pattern are specified in the following columns. The last column of the table hosts loops in case these are activated in the input. 
</p>
<p>Functions <code><a href="#topic+bundles">bundles</a></code> and <code><a href="#topic+summaryBundles">summaryBundles</a></code> provide bundle class occurrences in the network with a more detailed information. 
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Ostoic, J. A. R. &lsquo;Dyadic Patterns in Multiple Networks,&rsquo; <em>Advances in Social Networks Analysis and Mining, International Conference on</em>, 475-481. 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bundles">bundles</a></code>, <code><a href="#topic+summaryBundles">summaryBundles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two binary relations among three elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.8, 3 ) )

## Calculate the Bundle Census
bundle.census(arr)

</code></pre>

<hr>
<h2 id='bundles'>
Bundle Class Patterns
</h2><span id='topic+bundles'></span>

<h3>Description</h3>

<p>Classify the Bundle class patterns in a system of multiple relations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bundles(x, loops = FALSE, smpl = FALSE, lb2lb = TRUE, 
           collapse = FALSE, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bundles_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed. 
</p>
</td></tr>
<tr><td><code id="bundles_+3A_loops">loops</code></td>
<td>

<p>(logical) whether or not the loops should be considered as a particular bundle
</p>
</td></tr>
<tr><td><code id="bundles_+3A_smpl">smpl</code></td>
<td>

<p>(logical) simplify the strings of relations? Default no.
</p>
</td></tr>
<tr><td><code id="bundles_+3A_lb2lb">lb2lb</code></td>
<td>

<p>(logical) should the labels of the nodes be included in the output? (default yes).
</p>
</td></tr>
<tr><td><code id="bundles_+3A_collapse">collapse</code></td>
<td>

<p>(logical) collapse the distinct levels of relations in the network? (default no).
</p>
</td></tr>
<tr><td><code id="bundles_+3A_sep">sep</code></td>
<td>

<p>(optional) the pair separator for the pairwise relations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bundle is a particular type of pattern made of relations at different levels that is binding a pair of nodes or actors in a network of relationships. A bundle class is a dyadic configuration resulting from the mixture of the direction and the types of ties between the nodes or actors. There are in total seven dyadic configuration classes, which are <em>null</em>, <em>asymmetric</em>, <em>reciprocal</em>, <em>tie entrainment</em>, <em>tie exchange</em>, <em>mixed</em>, and the <em>full</em> bundle pattern. This function provides detailed information about the bundle class patterns in multiple networks as lists of pair relations among the nodes or actors, except for the &lsquo;null&rsquo; pattern.
</p>
<p>In case that the nodes are not labeled, then an identification number will be assigned according to the nodes' location in the array representation and as well when the <code>lb2lb</code> option is set to <code>FALSE</code>. This function assumes that the network is directed, and self ties can also be considered in the output.
Long string labels can be simplified with <code>smpl</code>, whereas the <code>collapse</code> option blurs the levels in the strings. 
</p>


<h3>Value</h3>

<p>An object of '<code>Rel.Bundles</code>' class with the distinct bundle class patterns.
</p>
<table>
<tr><td><code>asym</code></td>
<td>
<p>asymmetric</p>
</td></tr>
<tr><td><code>recp</code></td>
<td>
<p>reciprocal</p>
</td></tr>
<tr><td><code>tent</code></td>
<td>
<p>tie entrainment</p>
</td></tr>
<tr><td><code>txch</code></td>
<td>
<p>tie exchange</p>
</td></tr>
<tr><td><code>mixed</code></td>
<td>
<p>mixed</p>
</td></tr>
<tr><td><code>full</code></td>
<td>
<p>full</p>
</td></tr>
<tr><td><code>loops</code></td>
<td>
<p>loops (if chosen)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The input array for this function is always dichotomized, and it is possible to obtain the total number of occurrences in each bundle class pattern with the <code><a href="#topic+bundle.census">bundle.census</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Ostoic, J. A. R. &lsquo;Dyadic Patterns in Multiple Networks,&rsquo; <em>Advances in Social Networks Analysis and Mining, International Conference on</em>, 475-481. 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bundle.census">bundle.census</a></code>, <code><a href="#topic+summaryBundles">summaryBundles</a></code>, <code><a href="#topic+transf">transf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two binary relations among three elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.8, 3 ) )

## Establish the different bundles
bundles(arr)

</code></pre>

<hr>
<h2 id='cngr'>
Congruence Relations
</h2><span id='topic+cngr'></span>

<h3>Description</h3>

<p>Find the congruence relations of a given abstract or a partially ordered semigroup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cngr(S, PO = NULL, uniq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cngr_+3A_s">S</code></td>
<td>

<p>an object from the '<code>Semigroup</code>' class.
</p>
</td></tr>
<tr><td><code id="cngr_+3A_po">PO</code></td>
<td>

<p>(optional) the partial order table
</p>
</td></tr>
<tr><td><code id="cngr_+3A_uniq">uniq</code></td>
<td>

<p>(optional and logical) whether or not return the unique congruence relations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Congruencies are equivalence relations that preserve the operation between the correspondent classes in the algebraic structure. In this case, the different congruence classes are based on the substitution property of the semigroup object.
</p>


<h3>Value</h3>

<p>An object of '<code>Congruence</code>' class.
The items included are:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>semigroup of relations </p>
</td></tr>
<tr><td><code>PO</code></td>
<td>
<p>partial order table (if specified)</p>
</td></tr>
<tr><td><code>clu</code></td>
<td>
<p>congruence classes</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If the partial order is supplied in the input, then the computation of the congruence classes is slightly faster than for an abstract semigroup.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Hartmanis, J. and R.E. Stearns <em>Algebraic Structure Theory of Sequential Machines</em>. Prentice-Hall. 1966.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decomp">decomp</a></code>, <code><a href="#topic+fact">fact</a></code>, <code><a href="#topic+pacnet">pacnet</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an abstract semigroup object
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )
#
S &lt;- semigroup(arr)

## look at the congruences in S
cngr(S, PO=NULL)

</code></pre>

<hr>
<h2 id='comps'>
Find components in multiple networks
</h2><span id='topic+comps'></span>

<h3>Description</h3>

<p>Function to find different components in the multiple network including isolates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comps(x, bonds = c("entire", "strong", "weak"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comps_+3A_x">x</code></td>
<td>

<p>array representing the network
</p>
</td></tr>
<tr><td><code id="comps_+3A_bonds">bonds</code></td>
<td>

<p>the type of bonds to be used in the creation of the relational system  for the different components
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The network's different components are obtained through the transitive closure of the bundle ties. By default, the &ldquo;entire&rdquo; system is chosen, but the option <code>bonds</code> allow discriminating different types of relational bundles for the components. 
</p>


<h3>Value</h3>

<p>A list with two possible &ldquo;components&rdquo;
</p>
<table>
<tr><td><code>com</code></td>
<td>
<p>a component</p>
</td></tr>
<tr><td><code>isol</code></td>
<td>
<p>the isolates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bundles">bundles</a></code>, <code><a href="#topic+rel.sys">rel.sys</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two binary relations among three elements
arr &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
       c(3, 3, 2) ) &gt; .9, 3 ) )

## Find components ans isolates
comps(arr)

</code></pre>

<hr>
<h2 id='coor'>
internal function
</h2><span id='topic+coor'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='cpath'>
internal function
</h2><span id='topic+cpath'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='cph'>
Cumulated Person Hierarchy
</h2><span id='topic+cph'></span>

<h3>Description</h3>

<p>A function to calculate the Cumulated Person Hierarchy in networks of multiple relations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cph(W, lbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cph_+3A_w">W</code></td>
<td>

<p>an object of the '<code>Rel.Box</code>' class.
</p>
</td></tr>
<tr><td><code id="cph_+3A_lbs">lbs</code></td>
<td>

<p>(optional) the labels of the relational system
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cumulated person hierarchy is used to determine the partial structural equivalence among the actors in a multiple network. Two nodes are considered as <em>partial structural equivalent</em> iff they have identical role sets.
</p>
<p>The outcome of this function depends on the characteristics of the Relation-Box.
</p>


<h3>Value</h3>

<p>An object of '<code>Partial.Order</code>' class with an array representing the cumulated person hierarchy.
</p>


<h3>Note</h3>

<p>If the length of the labels differs from the order of the relational system, then labels will be ignored.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Breiger, R.L. and P.E. Pattison, &lsquo;Cumulated social roles: The duality of persons and their algebras,&rsquo; <em>Social Networks</em>, 8, 215-256. 1986.
</p>
<p>Mandel, M.J. &lsquo;Roles and networks: A local approach&rsquo;. B.A. Honours thesis, Harvard University. 1978.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbox">rbox</a></code>, <code><a href="#topic+semigroup">semigroup</a></code>, <code><a href="#topic+diagram">diagram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data("incubA")

## Make the Relation Box of the image matrices
rb &lt;- rbox(incubA$IM)

## Calculate the cumulated person hierarchy
cph(rb)

</code></pre>

<hr>
<h2 id='cscl'>
internal function
</h2><span id='topic+cscl'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='decomp'>
Decomposition of a Semigroup Structure
</h2><span id='topic+decomp'></span>

<h3>Description</h3>

<p>A function to perform the decomposition of a semigroup structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp(S, pr, type = c("mca", "pi", "at", "cc"), reduc, fac, force)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomp_+3A_s">S</code></td>
<td>
  
<p>an object of a '<code>Semigroup</code>' class
</p>
</td></tr>
<tr><td><code id="decomp_+3A_pr">pr</code></td>
<td>
  
<p>either an object of a '<code>Congruence</code>' class or an object of a '<code>Pi.rels</code>' class
</p>
</td></tr>
<tr><td><code id="decomp_+3A_type">type</code></td>
<td>
  
<p>type of decomposition; ie. the reduction is based on 
</p>
<p><code>mca</code> meet-complements of atoms in the '<code>Pi.rels</code>' class
</p>
<p><code>pi</code> <code class="reqn">\pi</code>-relations in the '<code>Pi.rels</code>' class
</p>
<p><code>cc</code> congruence classes
</p>
</td></tr>
<tr><td><code id="decomp_+3A_reduc">reduc</code></td>
<td>
  
<p>(optional and logical) does the return object should include the reduced structures?
</p>
</td></tr>
<tr><td><code id="decomp_+3A_fac">fac</code></td>
<td>
  
<p>(optional) the factor that should be decomposed
</p>
</td></tr>
<tr><td><code id="decomp_+3A_force">force</code></td>
<td>
  
<p>(optional and logical) force further reduction of the semigroup when <code>S</code> has <code>NA</code>s? (see details)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>decomp</code> function is a reduction form of an algebraic structure like the semigroup that verifies which of the class members in the system are congruent to each other. The decomposed object then is made of congruent elements, which form part of the lattice of congruence classes in the algebraic structure. In case that the input data comes from the Pacnet program, then such elements are in form of <code class="reqn">\pi</code>-relations or the  meet-complements of the atoms; otherwise these are simply equivalent elements satisfying the substitution property.
</p>
<p>Sometimes a '<code>Semigroup</code>' class object contains not available data in the multiplication table, typically when it is an image from the <code><a href="#topic+fact">fact</a></code> function. In such case, it is possible to perform a reduction of the semigroup structure with the <code>force</code> option, which performs additional equations to the string relations in order to get rid of <code>NA</code>s in the semigroup data.
</p>


<h3>Value</h3>

<p>An object of '<code>Decomp</code>' class having:
</p>
<table>
<tr><td><code>clu</code></td>
<td>
<p>vector with the class membership</p>
</td></tr>
<tr><td><code>eq</code></td>
<td>
<p>the equations in the decomposition</p>
</td></tr>
<tr><td><code>IM</code></td>
<td>
<p>(optional) the image matrices</p>
</td></tr>
<tr><td><code>PO</code></td>
<td>
<p>(optional) the partial order table</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>
<p>(optional) a vector with the order of the image matrices</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Reduction of the partial order table should be made by the <code><a href="#topic+reduc">reduc</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Pattison, Philippa E. <em>Algebraic Models for Social Networks</em>. Cambridge University Press. 1993.
</p>
<p>Hartmanis, J. and R.E. Stearns <em>Algebraic Structure Theory of Sequential Machines</em>. Prentice-Hall. 1966.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fact">fact</a></code>, <code><a href="#topic+cngr">cngr</a></code>, <code><a href="#topic+reduc">reduc</a></code>, <code><a href="#topic+pi.rels">pi.rels</a></code>, <code><a href="#topic+semigroup">semigroup</a></code>, <code><a href="#topic+partial.order">partial.order</a></code>
</p>

<hr>
<h2 id='dhc'>
internal function
</h2><span id='topic+dhc'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='diagram'>
Plot the Hasse Diagram of a set of ordered relations
</h2><span id='topic+diagram'></span>

<h3>Description</h3>

<p>A function to plot the Hasse Diagram of partially ordered relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram(x, attrs = NULL, main = NULL, incmp, cex.main, bg, mar, shape, 
       col, col0, fcol, ecol, lty, lbs, ffamily, fstyle, fsize, 
       col.main, sep, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram_+3A_x">x</code></td>
<td>

<p>a matrix representing ordered relations
</p>
</td></tr>
<tr><td><code id="diagram_+3A_attrs">attrs</code></td>
<td>

<p>(optional) attributes of the diagram
</p>
</td></tr>
<tr><td><code id="diagram_+3A_main">main</code></td>
<td>

<p>(optional) title of the diagram
</p>
</td></tr>
<tr><td><code id="diagram_+3A_incmp">incmp</code></td>
<td>

<p>(optional and logical) whether or not the incomparable elements should be included in the lattice diagram
</p>
</td></tr>
<tr><td><code id="diagram_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) size of the diagram's title
</p>
</td></tr>
<tr><td><code id="diagram_+3A_bg">bg</code></td>
<td>

<p>(optional) the background color of the diagram
</p>
</td></tr>
<tr><td><code id="diagram_+3A_mar">mar</code></td>
<td>

<p>(optional) the margins of the plot
</p>
</td></tr>
<tr><td><code id="diagram_+3A_shape">shape</code></td>
<td>

<p>(optional) the shape of the vertices
</p>
</td></tr>
<tr><td><code id="diagram_+3A_col">col</code></td>
<td>

<p>(optional) the color of the vertices
</p>
</td></tr>
<tr><td><code id="diagram_+3A_col0">col0</code></td>
<td>

<p>(optional) the color of the vertices' contour
</p>
</td></tr>
<tr><td><code id="diagram_+3A_fcol">fcol</code></td>
<td>

<p>(optional) the color of the text's vertices
</p>
</td></tr>
<tr><td><code id="diagram_+3A_ecol">ecol</code></td>
<td>

<p>(optional) the color of the edges
</p>
</td></tr>
<tr><td><code id="diagram_+3A_lty">lty</code></td>
<td>

<p>(optional) the shape of the edges
</p>
</td></tr>
<tr><td><code id="diagram_+3A_lbs">lbs</code></td>
<td>

<p>(optional) labels of the elements in the partially ordered set
</p>
</td></tr>
<tr><td><code id="diagram_+3A_ffamily">ffamily</code></td>
<td>

<p>(optional) the font family of the vertex labels
</p>
</td></tr>
<tr><td><code id="diagram_+3A_fstyle">fstyle</code></td>
<td>

<p>(optional) the font style of the vertex labels with options: &lsquo;bold&rsquo;, &lsquo;italic&rsquo;, &lsquo;bolditalic&rsquo;
</p>
</td></tr>
<tr><td><code id="diagram_+3A_fsize">fsize</code></td>
<td>

<p>(optional) the font size of the vertex labels
</p>
</td></tr>
<tr><td><code id="diagram_+3A_col.main">col.main</code></td>
<td>

<p>(optional) the font color of the main title
</p>
</td></tr>
<tr><td><code id="diagram_+3A_sep">sep</code></td>
<td>

<p>(optional) the pair separator for the pairwise relations inside intents and extents
</p>
</td></tr>
<tr><td><code id="diagram_+3A_...">...</code></td>
<td>

<p>(optional) additional graphical items
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An example of ordered relations is found in the partial order table of relations, which is product of the '<code>strings</code>' option in the <code><a href="#topic+partial.order">partial.order</a></code> function. Another set of ordered relations comes from the table produced on Galois derivations in the mentioned function.
</p>
<p>In either case this function plot either the partial order or a linear order diagram, depending on the results as Hasse diagrams. 
</p>


<h3>Value</h3>

<p>A Hasse diagram of the partial order relation.
</p>


<h3>Warning</h3>

<p>This function requires that the <em>Rgraphviz</em> package is available.
</p>


<h3>Note</h3>

<p>Note that if the elements of the partial order are not labelled, Roman numerals will be given to each element.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial.order">partial.order</a></code>, <code><a href="#topic+as.strings">as.strings</a></code>, <code><a href="#topic+strings">strings</a></code>, <code><a href="#topic+diagram.levels">diagram.levels</a></code>, <code><a href="#topic+galois">galois</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data("incubA")

## given e.g. a partial order table in the object 'po'
po &lt;- partial.order(as.strings(incubA$IM), type="strings")


## plot the order relation as a Hasse diagram.
## Not run: if(require(Rgraphviz)) {
plot(diagram(po))
}
## End(Not run)
</code></pre>

<hr>
<h2 id='diagram.levels'>
Levels in the Lattice Diagram
</h2><span id='topic+diagram.levels'></span>

<h3>Description</h3>

<p>This is a function that reads the different levels in the lattice diagram of the partial order structure among actors and ties in the network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagram.levels(x, perm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagram.levels_+3A_x">x</code></td>
<td>

<p>A matrix representing the partial order
</p>
</td></tr>
<tr><td><code id="diagram.levels_+3A_perm">perm</code></td>
<td>

<p>(optional) whether or not to return the permuted structure
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When it comes to reduce the structure of a multiple network, many times the partial order structure provides different classes of elements depending in the inclusions these elements have. In this sense, the illustration given by the <code><a href="#topic+diagram">diagram</a></code> function provides us typically with different levels of the ordered relations, which are read by this routine.
</p>


<h3>Value</h3>

<p>A named list with components of the &ldquo;levels&rdquo; in the concept diagram produced by <code><a href="#topic+diagram">diagram</a></code>.
</p>
<p>If the permutation is specified, a data frame with the elements of the partial order structure with the column names indicating the element class plus a vector with the levels and a matrix with the permuted structure are given as well.
</p>


<h3>Note</h3>

<p>This function requires that the <em>Rgraphviz</em> package is available. Besides, since the <code>pictex</code> function from <code>grDevices</code> is inside this routine, which may imply in some cases running with administrator privileges.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial.order">partial.order</a></code>, <code><a href="#topic+diagram">diagram</a></code>, <code><a href="#topic+perm">perm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data("incubA")

## given e.g. a partial order table in the object 'po'
po &lt;- partial.order(as.strings(incubA$IM))

## find the levels in the lattice diagram
## Not run: diagram.levels(po)
</code></pre>

<hr>
<h2 id='dichot'>
Dichotomize data with a cutoff value
</h2><span id='topic+dichot'></span>

<h3>Description</h3>

<p>Function to dichotomize the input data for the semigroup construction with a cutoff value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dichot(x, c = 1, diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dichot_+3A_x">x</code></td>
<td>

<p>some data in a numeric form (usually arrays)
</p>
</td></tr>
<tr><td><code id="dichot_+3A_c">c</code></td>
<td>

<p>the cutoff value to perform the dichotomization (default <code>1</code>)
</p>
</td></tr>
<tr><td><code id="dichot_+3A_diag">diag</code></td>
<td>

<p>(optional and logical) whether or not the diagonals should be included (default <code>TRUE</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenient function (or wrapper if you like) of the <code><a href="base.html#topic+replace">replace</a></code> function. 
In this case, the function is aimed to specify a cutoff value for the dichotomization of the data where the values equal or higher to the cutoff are converted to one, while the others are set to zero. The cutoff can be any real number.
</p>


<h3>Value</h3>

<p>Binary values of the input data.
</p>


<h3>Note</h3>

<p>The labels are preserved after the dichotomization.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+replace">replace</a></code>, <code><a href="#topic+prev">prev</a></code>, <code><a href="#topic+semigroup">semigroup</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 3 ) )

## dichotomize it with a cutoff value of 2
dichot(arr, c = 2)
</code></pre>

<hr>
<h2 id='edgel'>
Read edge list files
</h2><span id='topic+edgel'></span><span id='topic+read.srt'></span>

<h3>Description</h3>

<p>A function to read edge list files with <em>s</em>end, <em>r</em>eceive, and <em>t</em>ies format 
for a multivariate network with the possibility to transform it into an three dimenasional array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgel(file, header = TRUE, sep = "\t", toarray = TRUE, dichot = FALSE, 
      attr = FALSE, rownames = FALSE, add = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgel_+3A_file">file</code></td>
<td>

<p>path to the file
</p>
</td></tr>
<tr><td><code id="edgel_+3A_header">header</code></td>
<td>

<p>(logical) does the file has a header?
</p>
</td></tr>
<tr><td><code id="edgel_+3A_sep">sep</code></td>
<td>

<p>the separator among the columns (default is horizontal tab)
</p>
</td></tr>
<tr><td><code id="edgel_+3A_toarray">toarray</code></td>
<td>

<p>(logical) should the data frame be transformed to arrays?
</p>
</td></tr>
<tr><td><code id="edgel_+3A_dichot">dichot</code></td>
<td>

<p>(logical) should the data be dichotomized?
</p>
</td></tr>
<tr><td><code id="edgel_+3A_attr">attr</code></td>
<td>

<p>(logical) whether or not the file corresponds to attribute-based data
</p>
</td></tr>
<tr><td><code id="edgel_+3A_rownames">rownames</code></td>
<td>

<p>(logical) are rownames the labels of the nodes?
</p>
</td></tr>
<tr><td><code id="edgel_+3A_add">add</code></td>
<td>

<p>(optional) isolates to be added to the network
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>edgel</code> is a function to read files with <em>s</em>end, <em>r</em>eceive, and <em>t</em>ies format, 
which is a data frame with at least 2 columns for the sender, receiver and for multiplex networks also the ties, one column for each type of relation. 
However, the <code>attr</code> option correspond to a actor and self-ties data frame file with the option to transform it into a diagonal matrix. 
When <code>toarray</code> is set to <code>FALSE</code>, options <code>attr</code> and <code>rownames</code> allow placing the first column of the data frame as the name of the table, 
which is the format of two-mode data, and compute for instance Galois transformations among the partite sets. 
If more than one isolate is added, then the data must be included as a vector.
</p>
<p>It is also possible to treat the input data as data frame object and manipulate it via e.g. the <code><a href="base.html#topic+subset">subset</a></code> function with the <code>toarray</code> option. Valued networks are now supported as well.
</p>


<h3>Value</h3>

<p>By default an array; usually with three dimensions of stacked matrices where the multiple relations are placed. If <code>toarray = FALSE</code>, then the data frame is given.
</p>


<h3>Note</h3>

<p>For compatibility reasons, alias for <code>edgel</code> is <code>read.srt</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.edgel">write.edgel</a></code>, <code><a href="#topic+read.gml">read.gml</a></code>, <code><a href="#topic+read.dl">read.dl</a></code>, <code><a href="#topic+galois">galois</a></code>
</p>

<hr>
<h2 id='edgeT'>
Edge Table Generator
</h2><span id='topic+edgeT'></span>

<h3>Description</h3>

<p>The Edge Table generator of multiple relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgeT(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edgeT_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Edge Table is the complete right multiplication table of the semigroup having its elements for each of its generators.
</p>


<h3>Value</h3>

<p>An object of the '<code>EdgeTable</code>' class
</p>
<table>
<tr><td><code>gens</code></td>
<td>

<p>the generator relations
</p>
</td></tr>
<tr><td><code>ET</code></td>
<td>

<p>the Edge Table
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Cannon, J.J. &lsquo;Computing the ideal structure of finite semigroup,&rsquo; <em>Numerische Mathematik</em>, 18, 254-266. 1971.
</p>
<p>Pattison, P.E. <em>Algebraic Models for Social Networks</em>. Cambridge University Press. 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wordT">wordT</a></code>, <code><a href="#topic+semigroup">semigroup</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )

## get the edge table
edgeT(arr)
</code></pre>

<hr>
<h2 id='edgS'>
internal function
</h2><span id='topic+edgS'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='expos'>
Network exposure for multiple networks
</h2><span id='topic+expos'></span>

<h3>Description</h3>

<p>Function to measure the network exposure of the nodes according to a chosen relational system representing the multiple network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expos(rs, classes = FALSE, allClasses = FALSE, allNodes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expos_+3A_rs">rs</code></td>
<td>

<p>an object of '<code>Rel.System</code>', typically with node attributes.
</p>
</td></tr>
<tr><td><code id="expos_+3A_classes">classes</code></td>
<td>

<p>(optional) whether or not should be included in the output the categories of adopters 
</p>
</td></tr>
<tr><td><code id="expos_+3A_allclasses">allClasses</code></td>
<td>

<p>(optional) whether or not to include empty classes within the categories of adopters. Ignored if <code>classes</code> is <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="expos_+3A_allnodes">allNodes</code></td>
<td>

<p>(optional) whether or not to include all actors in the network regardless they are in the chosen system. Ignored if <code>classes</code> is <code>FALSE</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalization of the network exposure measure for multiple networks with the characteristics chosen for the representative relational system. 
Such a system can be the entire network or configuration with strong or weak bonds among the actors. 
It is possible to specify different behaviors of the nodes representing social actors, which are indicated in the form of a relational system. 
The network exposure measure is calculated according to the immediate neighbours to the reference actor. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>Classes</code></td>
<td>

<p>if option <code>classes</code> is set to <code>TRUE</code>, the adoption membership for the type of relational system chosen, including isolated actors in the system. 
</p>
</td></tr>
<tr><td><code>Bonds</code></td>
<td>

<p>the type of bonds of the relational system (cf. <code><a href="#topic+rel.sys">rel.sys</a></code>)
</p>
</td></tr>
<tr><td><code>Exposure</code></td>
<td>

<p>the exposure to the attribute(s) for acquisition through immediate neighbour relations 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Ostoic, J.A.R. &lsquo;Creating context for social influence processes in multiplex networks.&rsquo; <em>Network Science</em>, 5(1), 1-29.
</p>
<p>Valente, T. W. <em>Social networks and health</em>. Oxford University Press. 2010.
</p>
<p>Rogers, E. <em>The Diffusion of Innovations</em>. 5th ed. (1st ed. 1964) The Free Press. 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rel.sys">rel.sys</a></code>, <code><a href="#topic+neighb">neighb</a></code>, <code><a href="#topic+bundles">bundles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two binary relations among three elements
arr &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
c(3, 3, 2) ) &gt; .9, 3 ) )

## the first array is for attributes
rs &lt;- rel.sys(arr, att = 1)

## Calculate the exposure measure for an attribute type with adopter categories
expos(rs, classes = TRUE)

</code></pre>

<hr>
<h2 id='fact'>
Factorisation of semigroup structures
</h2><span id='topic+fact'></span>

<h3>Description</h3>

<p>A function to decompose partially ordered semigroups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fact(S, P, uniq = TRUE, fac, atoms, mca, atmc, patm, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fact_+3A_s">S</code></td>
<td>

<p>The semigroup object
</p>
</td></tr>
<tr><td><code id="fact_+3A_p">P</code></td>
<td>

<p>The partial order structure associada to <code>S</code>
</p>
</td></tr>
<tr><td><code id="fact_+3A_uniq">uniq</code></td>
<td>

<p>(logical) whether the factorisation include the unique induced inclusions
</p>
</td></tr>
<tr><td><code id="fact_+3A_fac">fac</code></td>
<td>

<p>the &lsquo;factor&rsquo; to be factorised, in case that input factorised partially ordered structures
</p>
</td></tr>
<tr><td><code id="fact_+3A_atoms">atoms</code></td>
<td>

<p>(logical) whether or not include the atoms in the output
</p>
</td></tr>
<tr><td><code id="fact_+3A_mca">mca</code></td>
<td>

<p>(logical) whether or not include the meet-complements of atoms in the output
</p>
</td></tr>
<tr><td><code id="fact_+3A_atmc">atmc</code></td>
<td>

<p>(logical) whether or not include the atoms'  meet-complements in the output
</p>
</td></tr>
<tr><td><code id="fact_+3A_patm">patm</code></td>
<td>

<p>(logical) whether or not include the potential atoms in the output
</p>
</td></tr>
<tr><td><code id="fact_+3A_k">k</code></td>
<td>

<p>the length of the induced inclusion (only relevant if <code>patm</code> is activated)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factorisation is part of the decomposition process for partially ordered semigroups.
</p>


<h3>Value</h3>

<p>An object of <code>"Ind.incl"</code> class having:
</p>
<table>
<tr><td><code>po</code></td>
<td>
<p>the partial order table</p>
</td></tr>
<tr><td><code>iin</code></td>
<td>
<p>list of induced inclusions pairwise listed</p>
</td></tr>
<tr><td><code>niin</code></td>
<td>
<p>length of the induced inclusion</p>
</td></tr>
<tr><td><code>patm</code></td>
<td>
<p>(optional) a vector with the potential atoms</p>
</td></tr>
<tr><td><code>atm</code></td>
<td>
<p>(optional) a vector with the atoms</p>
</td></tr>
<tr><td><code>atmc</code></td>
<td>
<p>(optional) array with meet-complements of atoms</p>
</td></tr>
<tr><td><code>mc</code></td>
<td>
<p>(optional) meet-complements</p>
</td></tr>
<tr><td><code>note</code></td>
<td>
<p>(optional) induced inclusions without the substitution property</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic (based on the algorithm described in Ardu, 1995)
</p>


<h3>References</h3>

<p>Ardu, S. <em>ASNET &ndash; Algebraic and Statistical Network Analysis. User Manual</em>. University of Melbourne. 1995.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decomp">decomp</a></code>, <code><a href="#topic+cngr">cngr</a></code>, <code><a href="#topic+pacnet">pacnet</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a partially ordered semigroup
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )
# semigroup
S &lt;- semigroup(arr)
# string relations
St &lt;- strings(arr)
# partial order
P &lt;- partial.order(St)

## Perform the factorisation of PO S
fact(S, P)
</code></pre>

<hr>
<h2 id='flt'>
internal function
</h2><span id='topic+flt'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='fltr'>
Principal filters
</h2><span id='topic+fltr'></span>

<h3>Description</h3>

<p>A function to find principal filters in a partial order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fltr(x, PO, ideal = FALSE, rclos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fltr_+3A_x">x</code></td>
<td>

<p>the reference element in the partial order (integer or character)
</p>
</td></tr>
<tr><td><code id="fltr_+3A_po">PO</code></td>
<td>

<p>the partial order
</p>
</td></tr>
<tr><td><code id="fltr_+3A_ideal">ideal</code></td>
<td>

<p>(logical) whether or not the &ldquo;filter&rdquo; is an ideal
</p>
</td></tr>
<tr><td><code id="fltr_+3A_rclos">rclos</code></td>
<td>

<p>(optional and logical) apply reflexive closure?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps to find principal filters or principal ideals for an element in a partial order structure. Such inputs are normally a concept or an object or attribute in the concept together with the associated partial ordering structure of the concepts, which results from Galois derivations. Typically, if the reference element refers to a concept, then it is given as a positive integer indicating the concept label. Another option is to refer to an object or an attribute by a character name, which should be part of the labels of the dimensions of the partial order table with reduced labelling. Principal filters with full labelling are not allowed if the reference element is an object or an attribute. Use an integer for the concept instead.
</p>


<h3>Value</h3>

<p>A named list with the elements in the upset or downset of the principal filter or ideal corresponding to the reference element in the partial order.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Ganter, B. and R. Wille  <em>Formal Concept Analysis &ndash; Mathematical Foundations</em>. Springer. 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+galois">galois</a></code>, <code><a href="#topic+partial.order">partial.order</a></code>, <code><a href="#topic+diagram">diagram</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a data frame
dfr &lt;- data.frame(x=1:3, y=5:7)

## Partial ordering of concepts
PO &lt;- partial.order(galois(dfr),"galois")

## Filter for the first element
fltr(1, PO, rclos=TRUE)

</code></pre>

<hr>
<h2 id='galois'>
Galois derivations between subsets
</h2><span id='topic+galois'></span>

<h3>Description</h3>

<p>Function to perform Galois derivations between partially ordered subsets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galois(x, labeling = c("full", "reduced"), sep, valued, scl, 
    sep2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="galois_+3A_x">x</code></td>
<td>

<p>a data frame with objects and attributes
</p>
</td></tr>
<tr><td><code id="galois_+3A_labeling">labeling</code></td>
<td>

<p>whether the derivations should be with full or reduced labeling
</p>
</td></tr>
<tr><td><code id="galois_+3A_sep">sep</code></td>
<td>

<p>(optional) the pair separator for the pairwise relations
</p>
</td></tr>
<tr><td><code id="galois_+3A_valued">valued</code></td>
<td>

<p>(logical) whether the galois derivation is on a many-valued formal context
</p>
</td></tr>
<tr><td><code id="galois_+3A_scl">scl</code></td>
<td>

<p>(optional, only for valued) the scale to be used in the galois derivation
</p>
</td></tr>
<tr><td><code id="galois_+3A_sep2">sep2</code></td>
<td>

<p>(optional, only for valued) the separator in the formal concept
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Galois derivations (or connections) are mappings between families of partially ordered subsets of elements. Such derivations are useful to analyze the structure of both subsets, which in a social network are typically the actors and their corresponding affiliations or events. That is, two-mode networks, but also a group of objects with a list of different attributes as used in formal concept analysis. 
</p>


<h3>Value</h3>

<p>A labelled list with Galois derivations of objects and attributes
</p>


<h3>Note</h3>

<p>Full labeling implies first objects and then attributes, whereas the reduced option is given the other way around.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Ganter, B. and R. Wille  <em>Formal Concept Analysis &ndash; Mathematical Foundations</em>. Springer. 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial.order">partial.order</a></code>, <code><a href="#topic+diagram">diagram</a></code>, <code><a href="#topic+fltr">fltr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a data frame
dfr &lt;- data.frame(x=1:3, y=5:7)

## Find Galois derivations
galois(dfr)
</code></pre>

<hr>
<h2 id='green.rel'>
Green's Relations
</h2><span id='topic+green.rel'></span>

<h3>Description</h3>

<p>A function to produce the Green's relations of a semigroup object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>green.rel(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="green.rel_+3A_s">S</code></td>
<td>

<p>an object of a '<code>Semigroup</code>' class
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>green.rel</code> produces the <em>egg-box diagram</em> (Green, 1951) of a semigroup <code class="reqn">S</code>, 
which is the union of the left compatible <code class="reqn">R</code> equivalence and 
the right compatible <code class="reqn">L</code> equivalence classes that makes the <code class="reqn">D</code>-class on <code class="reqn">S</code>.
</p>


<h3>Value</h3>

<p>A list with the semigroup, clustering of equivalence classes, and egg-box diagram that 
are separated by <code>|</code> and <code>-</code>.
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>multiplication matrix of the input semigroup</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>
<p>dimension of the semigroup</p>
</td></tr>
<tr><td><code>st</code></td>
<td>
<p>vector of the unique string relations</p>
</td></tr>
<tr><td><code>clu</code></td>
<td>
<p>list of vectors with clustering information for <code class="reqn">R</code> and <code class="reqn">L</code> classes</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p><code class="reqn">R</code> equivalence classes</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p><code class="reqn">L</code> equivalence classes</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p><code class="reqn">D</code> equivalence classes</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Some systems have the <code class="reqn">D</code>-class equal to <code class="reqn">S</code>.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Green, J. &ldquo;On the structure of semigroups&rdquo;, <em>Annals of Mathematics</em> 54(1), 163&ndash;172, 1951.
</p>
<p>Ostoic, JAR  &ldquo;Relational systems of transport network and provinces in ancient Rome,&rdquo; in 
<em>Mathematics for social sciences and arts &ndash; algebraic modeling</em>. Springer Nature. 2023.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semigroup">semigroup</a></code>, <code><a href="#topic+as.semigroup">as.semigroup</a></code>, <code><a href="#topic+edgeT">edgeT</a></code>, <code><a href="#topic+wordT">wordT</a></code>, <code><a href="#topic+fact">fact</a></code>, <code><a href="#topic+cngr">cngr</a></code>, <code><a href="#topic+decomp">decomp</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )
## optional string labels
dimnames(arr)[[3]] &lt;- list("n", "m")

## look at the semigroup and its Green's relations
semigroup(arr) |&gt; 
  green.rel()
</code></pre>

<hr>
<h2 id='hierar'>
Person and Relation Hierarchy
</h2><span id='topic+hierar'></span>

<h3>Description</h3>

<p>A function to establish either the Person or the Relation Hierarchy in a multiple network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hierar(W, x, type = c("person", "relation"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hierar_+3A_w">W</code></td>
<td>

<p>an object of '<code>Rel.Box</code>'
</p>
</td></tr>
<tr><td><code id="hierar_+3A_x">x</code></td>
<td>

<p>(integer or character) the actor of reference, either by its location in the adjacency matrix or by the label.
</p>
</td></tr>
<tr><td><code id="hierar_+3A_type">type</code></td>
<td>

<p>whether the hierarchy is for the '<code>person</code>s' or for the '<code>relation</code>s' in the network with respect to '<code>x</code>'
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>person</code> hierarchy refers to the inclusion relations among the actors, whereas the <code>relation</code> hierarchy refers to the inclusion relations among the ties. Both are from the perspective of a chosen actor of reference in the given network.
</p>


<h3>Value</h3>

<p>An array that represents the partial order structure of the respective hierarchy.
</p>


<h3>Note</h3>

<p>The cumulative person hierarchy is obtained through the <code><a href="#topic+cph">cph</a></code> function.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Breiger, R.L. and P.E. Pattison, &lsquo;Cumulated social roles: The duality of persons and their algebras,&rsquo; <em>Social Networks</em>, 8, 215-256. 1986.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rbox">rbox</a></code>, <code><a href="#topic+cph">cph</a></code>, <code><a href="#topic+partial.order">partial.order</a></code>, <code><a href="#topic+diagram">diagram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
c(3, 3, 2) ) &gt; .5, 3 ) )

## The relation box
rarr &lt;- rbox(arr, k=1)

## Calculated the person hierarchy of a random actor
hierar(rarr, ceiling(runif(1, min=0, max=dim(arr)[2])))

</code></pre>

<hr>
<h2 id='incubs'>
Incubator networks dataset
</h2><span id='topic+incubs'></span><span id='topic+incubA'></span><span id='topic+incubB'></span><span id='topic+incubC'></span><span id='topic+incubD'></span><span id='topic+incA'></span><span id='topic+incB'></span><span id='topic+incC'></span><span id='topic+incD'></span>

<h3>Description</h3>

<p>These are four data sets collected in the year 2010 (see &lsquo;source&rsquo; for the details) of multiple relations between entrepreneurial firms working in business incubators in Denmark.
</p>
<p>Each data set contains the adjacency matrices of the three social relations, coded as <code>C</code>, <code>F</code>, and <code>K</code> for working collaboration, informal friendship, and perceived competition among the firms. There are also a pair of actor attributes corresponding to the adoption of two Web innovations in the year 2010 by the firms where <code>A</code> stands for Linkedin and <code>B</code> for Facebook.
</p>
<p>In addition, there is a blockmodel attached to each data set that is a product of Compositional Equivalence (cf. <code><a href="#topic+cph">cph</a></code>) with transposes for each type of social tie labelled with the following letter in the Latin alphabet; i.e. <code>D</code> for collaboration, <code>G</code> for friendship, and <code>L</code> for perceived competition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("incubs")
data("incubA")
data("incubB")
data("incubC")
data("incubD")
data("incA")
data("incB")
data("incC")
data("incD")
</code></pre>


<h3>Format</h3>

<p>Each data set is a list with a pair of three-dimensional arrays.
</p>
<p>For <code>incubA</code>, the dimensions of <code>net</code> are <code class="reqn">26 \times 26 \times 5</code>, and of <code>IM</code> are <code class="reqn">4 \times 4 \times 7</code> (the two attributes led to the identity matrix).
</p>
<p>For <code>incubB</code>, the dimensions of <code>net</code> are <code class="reqn">18 \times 18 \times 5</code>, and of <code>IM</code> are <code class="reqn">4 \times 4 \times 8</code>.
</p>
<p>For <code>incubC</code>, the dimensions of <code>net</code> are <code class="reqn">22 \times 22 \times 5</code>, and of <code>IM</code> are <code class="reqn">3 \times 3 \times 8</code>.
</p>
<p>For <code>incubD</code>, the dimensions of <code>net</code> are <code class="reqn">15 \times 15 \times 5</code>, and of <code>IM</code> are <code class="reqn">4 \times 4 \times 6</code>.
</p>
<p>All four networks are together in <code>incubs</code>.
</p>
<p>To plot automatically actor attributes in the graph with function <code><a href="multigraph.html#topic+multigraph">multigraph</a></code>, another version of these data sets are given in <code>incA</code>, <code>incB</code>, <code>incC</code>, and <code>incD</code>, which  are <code>"Data.Set"</code> objects class having:
</p>
<p>&ndash; <code>net</code> for the network data
</p>
<p>&ndash; <code>atnet</code> a vector that indicates whether or not the arrays in <code>'net'</code> is attribute data
</p>
<p>&ndash; <code>IM</code> for the Image Matrices of the reduced network data
</p>
<p>&ndash; <code>atIM</code> a vector that indicates whether or not the array in <code>'IM'</code> is attribute data
</p>
<p>&ndash; <code>cite</code> relational content of the ties
</p>


<h3>Source</h3>

<p>Ostoic, J.A.R.  'Algebraic methods for the analysis of multiple social networks and actors attributes&rdquo; PhD Thesis. University of Southern Denmark. 2013.
</p>

<hr>
<h2 id='jnt'>
internal function
</h2><span id='topic+jnt'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='men'>
internal function
</h2><span id='topic+men'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='mlvl'>
Construct multilevel networks
</h2><span id='topic+mlvl'></span>

<h3>Description</h3>

<p>Function to construct multilevel networks from multimodal structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlvl(x = NULL, y = NULL, type = c("bpn", "cn", "cn2", "list"), 
     symCdm, diag, lbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlvl_+3A_x">x</code></td>
<td>

<p>domain data
</p>
</td></tr>
<tr><td><code id="mlvl_+3A_y">y</code></td>
<td>

<p>codomain data
</p>
</td></tr>
<tr><td><code id="mlvl_+3A_type">type</code></td>
<td>

<p>type of multilevel system: 
</p>
<p>- <code>bpn</code> for binomial projection
</p>
<p>- <code>cn</code> for common membership network
</p>
<p>- <code>cn2</code> for co-affiliation of network members
</p>
<p>- <code>list</code> for the multimodal structures as a list
</p>
</td></tr>
<tr><td><code id="mlvl_+3A_symcdm">symCdm</code></td>
<td>

<p>(optional and logical, only for <code>bpn</code>) whether or not symmetrize the codomain structure
</p>
</td></tr>
<tr><td><code id="mlvl_+3A_diag">diag</code></td>
<td>

<p>(optional and logical) whether or not include the entries in the diagonal matrices
</p>
</td></tr>
<tr><td><code id="mlvl_+3A_lbs">lbs</code></td>
<td>

<p>(optional, only for <code>cn2</code>) tie labels
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default multilevel system is a binomial projection <code>bpn</code> that requires data for the two domains, as with 
<code>cn2</code> as well. 
Option <code>cn</code> does not need the domain in <code>x</code> since returns the co-affiliation of network members from the codomain structure. 
</p>
<p>Since these are different components in the multilevel system for co-affiliation of network members, 
it is possible to specify the domain and codomain labels in <code>lbs</code> as a list object. 
</p>
<p>Making symmetric the codomain structure with <code>symCdm</code> is many times convenient for visualization purposes.
</p>


<h3>Value</h3>

<p>An object of '<code>Multilevel</code>' class of chosen type.
</p>
<table>
<tr><td><code>mlnet</code></td>
<td>

<p>the multilevel network
</p>
</td></tr>
<tr><td><code>lbs</code></td>
<td>

<p>(list) domain and codomain labels
</p>
</td></tr>
<tr><td><code>modes</code></td>
<td>

<p>a vector indicating the domain of the data in <code>mlnet</code> where <code>1M</code> is for domain and <code>2</code> is for the codomain.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="multigraph.html#topic+mlgraph">mlgraph</a></code>, <code><a href="multigraph.html#topic+multigraph">multigraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># array for the domain
arr1 &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18), c(3,3,2))&gt;.9, 3 ) )

# rectangle array for the co-domain
arr2 &lt;- round( replace( array(runif(12), c(3,2,2)), array(runif(12), c(3,2,2))&gt;.9, 3 ) )

# multilevel system with default type
mlvl(arr1, arr2)
</code></pre>

<hr>
<h2 id='mmp'>
internal function
</h2><span id='topic+mmp'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='mnplx'>
Make a multiple network as monoplex structure
</h2><span id='topic+mnplx'></span>

<h3>Description</h3>

<p>A function to transform multiple networks into a monoplex structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnplx(net, directed = TRUE, dichot, diag, clu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnplx_+3A_net">net</code></td>
<td>

<p>a three-dimensional array to be transformed into a matrix
</p>
</td></tr>
<tr><td><code id="mnplx_+3A_directed">directed</code></td>
<td>

<p>(optional) whether to make the matrix symmetric or not
</p>
</td></tr>
<tr><td><code id="mnplx_+3A_dichot">dichot</code></td>
<td>

<p>(optional) should the output be dichotomized?
</p>
</td></tr>
<tr><td><code id="mnplx_+3A_diag">diag</code></td>
<td>

<p>(optional) should the diagonals be included?
</p>
</td></tr>
<tr><td><code id="mnplx_+3A_clu">clu</code></td>
<td>

<p>(optional) a vector with the cluster for the permutation
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With this function, it is possible to collapse multiple types of tie into a matrix representation with monoplex relations.
</p>


<h3>Value</h3>

<p>A matrix of monoplex relations
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zbind">zbind</a></code>, <code><a href="#topic+dichot">dichot</a></code>, <code><a href="#topic+reduc">reduc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )

## Make it monoplex
mnplx(arr)

</code></pre>

<hr>
<h2 id='mxmn'>
internal function
</h2><span id='topic+mxmn'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='neighb'>
Neighborhood of an actor or group of actors
</h2><span id='topic+neighb'></span>

<h3>Description</h3>

<p>A function to find the neighbourhood of an actor or group of actors with a customized distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighb(x, rs, type = c("und", "inn", "out"), k = 1, inclx = FALSE, expand)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighb_+3A_x">x</code></td>
<td>

<p>the reference actor labeled in <code>rs</code> or a vector of several actors
</p>
</td></tr>
<tr><td><code id="neighb_+3A_rs">rs</code></td>
<td>

<p>the relational system of the network
</p>
</td></tr>
<tr><td><code id="neighb_+3A_type">type</code></td>
<td>

<p>whether the system is 
</p>
<p>- <code>und</code> for <em>undirected</em> (default)
</p>
<p>- <code>inn</code> for <em>incoming</em> node's ties to the reference actor
</p>
<p>- <code>out</code> for <em>outgoing</em> arcs from the reference actor
</p>
</td></tr>
<tr><td><code id="neighb_+3A_k">k</code></td>
<td>

<p>the &ldquo;distance&rdquo; of the neighbour nodes to the reference actor (where <code>k=1</code> gives the adjacent nodes)
</p>
</td></tr>
<tr><td><code id="neighb_+3A_inclx">inclx</code></td>
<td>

<p>(logical) should the reference actor be included in the output?
</p>
</td></tr>
<tr><td><code id="neighb_+3A_expand">expand</code></td>
<td>

<p>(optional and logical) should the output be given by <code>k</code> (it only makes sense when <code>k&gt;1</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relational system serves to represent either the entire multiple network, or else just the relational bundles having a mutual or an asymmetric character. 
In this sense, this function detects the adjacent nodes to <code>x</code> according to the specified relational system, but as well the neighbours of the adjacent nodes with a customized length. 
Eventually, when the longest path or chain is reached, adding more value to <code>k</code> obviously will not produce more nodes in the graph system. 
Type options <code>inn</code> and <code>out</code> are for directed networks.
</p>


<h3>Value</h3>

<p>Depending on <code>expand</code>, the output is either a vector or a list with the neighbour nodes to the reference actor(s).
</p>


<h3>Note</h3>

<p>The output does not differentiate in case the reference actors are in different components of the network.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expos">expos</a></code>, <code><a href="#topic+rel.sys">rel.sys</a></code>, <code><a href="#topic+bundles">bundles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two binary relations among three elements
arr &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
       c(3, 3, 2) ) &gt; .9, 3 ) )

## Determine the system of strong bonds
rs &lt;- rel.sys(arr, bonds = "strong")

## the inmediate neighbourhood of the first node
neighb(1, rs)

</code></pre>

<hr>
<h2 id='ngbs'>
internal function
</h2><span id='topic+ngbs'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='pacnet'>
Read Output from Pacnet
</h2><span id='topic+pacnet'></span>

<h3>Description</h3>

<p>A function to read output files from the Pacnet program with the full factorization option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pacnet(file, toarray = FALSE, uniq = FALSE, 
            transp = FALSE, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pacnet_+3A_file">file</code></td>
<td>
  
<p>character vector containing a file name or path
</p>
</td></tr>
<tr><td><code id="pacnet_+3A_toarray">toarray</code></td>
<td>
  
<p>(logical) should the induced inclusions be transformed into arrays?
</p>
</td></tr>
<tr><td><code id="pacnet_+3A_uniq">uniq</code></td>
<td>
  
<p>(logical) should only be considered the induced inclusions that are unique?
</p>
</td></tr>
<tr><td><code id="pacnet_+3A_transp">transp</code></td>
<td>
  
<p>(logical) should the partially ordered structures be transposed?
</p>
</td></tr>
<tr><td><code id="pacnet_+3A_sep">sep</code></td>
<td>
  
<p>(optional) the pair separator for the pairwise relations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to read the output file from the Pacnet program, which typically has the <code>.out</code> extension. By default the result is given in a list format, but it is possible to transform the pair lists into arrays. Note that the options in the Pacnet program should include the full factorization in the output; otherwise the object will be <code>NULL</code>.
</p>


<h3>Value</h3>

<p>An object of the '<code>Pacnet</code>' class  with items:
</p>
<table>
<tr><td><code>ii</code></td>
<td>
<p>induced inclusions</p>
</td></tr>
<tr><td><code>at</code></td>
<td>
<p>atoms</p>
</td></tr>
<tr><td><code>mc</code></td>
<td>
<p>meet complements</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Currently only partial order structures of order 36 and less are supported.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Pattison, P., S. Wasserman, G. Robins and A.M. Kanfer  &lsquo;Statistical Evaluation of Algebraic Constraints for Social Networks,&rsquo; <em>Journal of Mathematical Psychology</em>, 44, 536-568. 2000
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pi.rels">pi.rels</a></code>, <code><a href="#topic+cngr">cngr</a></code>, <code><a href="#topic+decomp">decomp</a></code>, <code><a href="#topic+write.dat">write.dat</a></code>
</p>

<hr>
<h2 id='partial.order'>
The Partial Order of String relations or of Galois derivations
</h2><span id='topic+partial.order'></span>

<h3>Description</h3>

<p>Construct the partial order table of unique relations of the semigroup, or else of the concepts produced by Galois derivations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial.order(x, type = c("strings", "galois", "pi.rels"), 
              lbs, sel, po.incl, dichot)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial.order_+3A_x">x</code></td>
<td>

<p>an object of a '<code>Strings</code>' or a '<code>Galois</code>' class
</p>
</td></tr>
<tr><td><code id="partial.order_+3A_type">type</code></td>
<td>

<p>whether the object corresponds to string relations, Galois derivations, or <code class="reqn">\pi</code>-relations
</p>
</td></tr>
<tr><td><code id="partial.order_+3A_lbs">lbs</code></td>
<td>

<p>(optional) the labels of the unique relations
</p>
</td></tr>
<tr><td><code id="partial.order_+3A_sel">sel</code></td>
<td>

<p>(optional) selected elements in &lsquo;x&rsquo; for the partial order
</p>
</td></tr>
<tr><td><code id="partial.order_+3A_po.incl">po.incl</code></td>
<td>

<p>(optional, works only with type <code>"pi.rels"</code>) should the partial order in the <code class="reqn">\pi</code>-relations be included
</p>
</td></tr>
<tr><td><code id="partial.order_+3A_dichot">dichot</code></td>
<td>

<p>(optional) should the string relations in <code>x</code> be dichotomized?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To get the partial order of an entire semigroup, both generators and compound relations must be considered. This information and the labels of the unique relations are given by the <code><a href="#topic+strings">strings</a></code> function. cf. <code><a href="#topic+semigroup">semigroup</a></code> to see how the <code>x</code> should be specified properly.
</p>
<p>Galois derivations are now possible to be partially ordered as well, and this option is based on the output given by the <code><a href="#topic+galois">galois</a></code> function.
</p>


<h3>Value</h3>

<p>An object of '<code>Partial.Order</code>' class with the partial order table in a matrix form.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Pattison, P.E. <em>Algebraic Models for Social Networks</em>. Cambridge University Press. 1993.
</p>
<p>Ganter, B. and R. Wille  <em>Formal Concept Analysis - Mathematical Foundations</em>. Springer. 1996.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.strings">as.strings</a></code>, <code><a href="#topic+strings">strings</a></code>, <code><a href="#topic+galois">galois</a></code>, <code><a href="#topic+perm">perm</a></code>, <code><a href="#topic+diagram">diagram</a></code>, <code><a href="#topic+fltr">fltr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the data, and obtain the partial order
data("incubA")

## the strings in the structure
st &lt;- strings(incubA$IM) 

## Get the partial order
partial.order(st)

</code></pre>

<hr>
<h2 id='perm'>
Array Permutation
</h2><span id='topic+perm'></span>

<h3>Description</h3>

<p>Function to permutate a given array of relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm(x, clu, rev, lbs, sort)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm_+3A_x">x</code></td>
<td>

<p>a matrix or an array to be permuted
</p>
</td></tr>
<tr><td><code id="perm_+3A_clu">clu</code></td>
<td>

<p>the cluster for the permutation
</p>
</td></tr>
<tr><td><code id="perm_+3A_rev">rev</code></td>
<td>

<p>(optional and logical) whether the order in <code>clu</code> sholud be reverted.
</p>
</td></tr>
<tr><td><code id="perm_+3A_lbs">lbs</code></td>
<td>

<p>(optional) the labels after the permutation
</p>
</td></tr>
<tr><td><code id="perm_+3A_sort">sort</code></td>
<td>

<p>(optional and logical) sort array according to labels?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves to permutate an array representing relations according to a vector for the clustering membership.
</p>


<h3>Value</h3>

<p>A permuted matrix or array
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cph">cph</a></code>, <code><a href="#topic+partial.order">partial.order</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## scan the multiplication table data
s &lt;- matrix(data=c(1, 1, 1, 3, 3, 3, 3, 3, 3), nrow=3, ncol=3, byrow=TRUE)

## the permutation as an endomorphism
perm(s, clu = c(1,2,3))

</code></pre>

<hr>
<h2 id='pfvn'>
Pathfinder valued network and triangle inequality
</h2><span id='topic+pfvn'></span>

<h3>Description</h3>

<p>A function to establish the skeleton of a valued network with the pathfinder algorithm and triangle inequality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pfvn(x, r, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfvn_+3A_x">x</code></td>
<td>

<p>network data, typically valued
</p>
</td></tr>
<tr><td><code id="pfvn_+3A_r">r</code></td>
<td>

<p>a distance function parameter 
</p>
</td></tr>
<tr><td><code id="pfvn_+3A_q">q</code></td>
<td>

<p>parameter with the minimum distance between actors in the proximity matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pathfinder structure is for undirected networks, whereas for directed network structures the triangle inequality principle is applied
</p>


<h3>Value</h3>

<table>
<tr><td><code>max</code></td>
<td>
<p>max value of the network with the Frobenius norm</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>parameter <em>r</em></p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>parameter <em>q</em></p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>salient structure of <em>x</em></p>
</td></tr>
<tr><td><code>Note</code></td>
<td>
<p>A note when triangle inequality is used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Schvaneveldt, R., Durso, F. and Dearholt, D., &lsquo;Network structures in proximity data,&rsquo; in G. Bower, ed., <em>The psychology of learning and motivation: Advances in research &amp; theory</em>, Vol. 24, Academic Press, pp. 249-284. 1989.
</p>
<p>Batagelj, V., Doreian, P., Ferligoj, A. and Kejzar, N., <em>Understanding Large Temporal Networks and Spatial Networks: Exploration, Pattern Searching, Visualization and Network Evolution</em>, John Wiley &amp; Sons. 2014.
</p>


<h3>See Also</h3>

<p><code><a href="multigraph.html#topic+multigraph">multigraph</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create valued network data
arr &lt;- round( array(runif(18), c(3,3,2)), array(runif(18), c(3,3,2)) ) * 10L

# pathfinder valued network of 'arr'
pfvn(arr)

</code></pre>

<hr>
<h2 id='pi.rels'>
<code class="reqn">\pi</code>-Relations
</h2><span id='topic+pi.rels'></span>

<h3>Description</h3>

<p>A function to establish the <code class="reqn">\pi</code>-relations of a partially ordered structure comming from a 'Pacnet' class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi.rels(x, po.incl, vc, po)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pi.rels_+3A_x">x</code></td>
<td>

<p>an object of a '<code>Pacnet</code>' class
</p>
</td></tr>
<tr><td><code id="pi.rels_+3A_po.incl">po.incl</code></td>
<td>

<p>(optional and logical) should the partial order be included in the outcome?
</p>
</td></tr>
<tr><td><code id="pi.rels_+3A_vc">vc</code></td>
<td>

<p>(optional) vector of the induced inclusions to be computed
</p>
</td></tr>
<tr><td><code id="pi.rels_+3A_po">po</code></td>
<td>

<p>(optional) the partial order structure
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function process the outcome of the Pacnet report by adding induced inclusions to partial order, the minimal element of the lattice of congruence relations. Such type of structure serves for the decomposition of a partially ordered semigroup structure.
</p>


<h3>Value</h3>

<p>An object of the '<code>Pi.rels</code>' class
</p>
<table>
<tr><td><code>pi</code></td>
<td>
<p>the <code class="reqn">\pi</code>-relations, eventually with the partial order</p>
</td></tr>
<tr><td><code>mca</code></td>
<td>
<p>the meet-complements of atoms</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Pattison, Philippa E. <em>Algebraic Models for Social Networks</em>. Cambridge University Press. 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pacnet">pacnet</a></code>, <code><a href="#topic+decomp">decomp</a></code>, <code><a href="#topic+semigroup">semigroup</a></code>
</p>

<hr>
<h2 id='prev'>
Preview of the Semigroup Construction
</h2><span id='topic+prev'></span>

<h3>Description</h3>

<p>A function to preview the partial right multiplication table of the semigroup to assess the size of the complete semigroup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prev_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the input data is large, i.e. having a dozen or more elements and/or more than five dimensions, it is recommended to perform this function before the semigroup construction to get the partial right multiplication table. 
</p>
<p>That is because the amount of undefined data in such a table gives an idea of how much time may take to get the complete semigroup. However, the performance depends mainly on whether the generator matrices are sparse and/or have a relatively large number of elements for a semigroup construction of the course.
</p>


<h3>Value</h3>

<table>
<tr><td><code>'2stpT'</code></td>
<td>

<p>a partial right multiplication table at two-step.
</p>
</td></tr>
<tr><td><code>'PcU2stpT'</code></td>
<td>

<p>the proportion of undefined elements at two-step.
</p>
</td></tr>
<tr><td><code>ordr</code></td>
<td>

<p>the dimension of the right multiplication table so far.
</p>
</td></tr>
<tr><td><code>Note</code></td>
<td>

<p>a conditional warning message.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The warning message is given only if the percentage of undefined elements and the dimension of the input data are relatively high; however, the semigroup construction can still take a long time without the message. 
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semigroup">semigroup</a></code>, <code><a href="#topic+edgeT">edgeT</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )

## preview it
prev(arr)

</code></pre>

<hr>
<h2 id='print.gml'>
internal function
</h2><span id='topic+print.gml'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='print.reduced'>
internal function
</h2><span id='topic+print.reduced'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='rbox'>
Construct the Relation-Box
</h2><span id='topic+rbox'></span>

<h3>Description</h3>

<p>Function to construct the Relation-Box of a multiple network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbox(w, transp = FALSE, smpl = FALSE, k = 3, tlbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbox_+3A_w">w</code></td>
<td>

<p>an array with three dimensions of stacked matrices of generating relations.
</p>
</td></tr>
<tr><td><code id="rbox_+3A_transp">transp</code></td>
<td>

<p>(logical) whether or not the transpose of each matrix in <code class="reqn">w</code> should be included.
</p>
</td></tr>
<tr><td><code id="rbox_+3A_smpl">smpl</code></td>
<td>

<p>(logical) whether to simplify or not the strings of relations
</p>
</td></tr>
<tr><td><code id="rbox_+3A_k">k</code></td>
<td>

<p>length of the Relation-Box in <code class="reqn">z</code>
</p>
</td></tr>
<tr><td><code id="rbox_+3A_tlbs">tlbs</code></td>
<td>

<p>(optional) a vector with the labels for the transpose relations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>transp = TRUE</code> the labels of the transpose are toggle case of the labels of the original matrices, and in such case, it is advised to simplify the strings of relations. To prevent a transposed structure for a certain array of <code>w</code>, use <code>NA</code> in the vector the transpose labels <code>tlbs</code> corresponding to the respective matrix.
</p>


<h3>Value</h3>

<p>An object of the '<code>Rel.Box</code>' class.
</p>
<table>
<tr><td><code>w</code></td>
<td>
<p>the primitive relations in the Relation-Box</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>the structure of the Relation-Box</p>
</td></tr>
<tr><td><code>lbs</code></td>
<td>
<p>the labels in the relational system</p>
</td></tr>
<tr><td><code>Note</code></td>
<td>
<p>(optional) Notes indicating the particularities in the input</p>
</td></tr>
<tr><td><code>Orels</code></td>
<td>
<p>the original labels of the relations</p>
</td></tr>
<tr><td><code>Srels</code></td>
<td>
<p>(optional) the simplified labels of the relations</p>
</td></tr>
<tr><td><code>Trels</code></td>
<td>
<p>(optional) the labels of the transposed relations</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the maximal length of the word</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the length of the Relation-Box in the <code class="reqn">z</code> dimension</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Values of <code>k</code> until 9 are supported. With many types of relations, and when the order of the multiplex network is high, turning <code>k</code> to more than three may take a long time of computation.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Winship, C. and M.J. Mandel &lsquo;Roles and positions: A critique and extension of the blockmodelling approach,&rsquo; <em>Sociological Methodology</em>, 314-344. 1983.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cph">cph</a></code>, <code><a href="#topic+semigroup">semigroup</a></code>, <code><a href="#topic+hierar">hierar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load the data
data("incubA")

## The relation box of the image matrices
## Not run:
rbox(incubA$IM)
## End(**Not run**)
</code></pre>

<hr>
<h2 id='read.dl'>
Read <code>dl</code> Files
</h2><span id='topic+read.dl'></span>

<h3>Description</h3>

<p>A function to read files with the Ucinet <code>dl</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.dl(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.dl_+3A_file">file</code></td>
<td>

<p>character vector containing a file name or path of the data representing the network
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Files <code>dl</code> serve to represent multiple network structures, and it is one of the formats used in Netdraw, which is a component of the Ucinet program. Besides multiple networks, the function can read two-mode structures as well.
</p>


<h3>Value</h3>

<p>a data frame for two-mode networks, or an array representing the multiple networks with one set of actors.
</p>


<h3>Note</h3>

<p>The '<code>EDGELIST</code>' option in <code>DL</code> is not yet supported for reading.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Borgatti, S.P., <code>NetDraw</code> Software for Network Visualization. Analytic Technologies. 2002.
</p>
<p>Borgatti, S.P., Everett, M.G. and Freeman, L.C. <code>Ucinet for Windows</code>: Software for Social Network Analysis. Analytic Technologies. 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.dl">write.dl</a></code>, <code><a href="#topic+edgel">edgel</a></code>, <code><a href="#topic+read.gml">read.gml</a></code>
</p>

<hr>
<h2 id='read.gml'>
Read <code>gml</code> Files
</h2><span id='topic+read.gml'></span>

<h3>Description</h3>

<p>A function to read files with the <code>gml</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.gml(file, as = c("srt", "array"), directed = TRUE, coords = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.gml_+3A_file">file</code></td>
<td>
  
<p>character vector containing a file name or path
</p>
</td></tr>
<tr><td><code id="read.gml_+3A_as">as</code></td>
<td>

<p>should the data be given as a <code>srt</code> or with an <code>array</code> format?
</p>
</td></tr>
<tr><td><code id="read.gml_+3A_directed">directed</code></td>
<td>

<p>(logical) whether the graph is directed or undirected.
</p>
</td></tr>
<tr><td><code id="read.gml_+3A_coords">coords</code></td>
<td>

<p>(logical) whether the coordenates in the <code>gml</code> file should be included.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>gml</code> format, an acronym for <em>graph modelling language</em>, provides capabilities to represent multiple networks and add arguments both to the nodes and the edges for visualization purposes.
</p>
<p>For the multiplexity in the ties the <code>gml</code> file distinguishes &ldquo;graphics&rdquo; arguments inside &ldquo;edge&rdquo;. Both &ldquo;style&rdquo; and &ldquo;fill&rdquo; are supported here and the former has priority over the latter in case the two are given; otherwise when these arguments are absent, the function separates up to a couple of relational levels when several pairwise ties are specified.
</p>


<h3>Value</h3>

<p>Depending the option chosen, the output is either a data frame or an array representing the multigraph. If the coordenates are chosen then these are part of the obejct structure, but they are not visible.
</p>


<h3>Note</h3>

<p>If the coordenates are chosen, node attributes can also be retrieved.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p><code>visone</code> Software for the analysis and visualization of social networks. <em>http://visone.info</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.gml">write.gml</a></code>, <code><a href="#topic+edgel">edgel</a></code>, <code><a href="#topic+read.dl">read.dl</a></code>
</p>

<hr>
<h2 id='redl'>
internal function
</h2><span id='topic+redl'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='reduc'>
Reduce a matrix or array
</h2><span id='topic+reduc'></span>

<h3>Description</h3>

<p>Function to reduce a matrix or array with a given clustering vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduc(x, clu, lbs = NULL, slbs = NULL, valued, row, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduc_+3A_x">x</code></td>
<td>

<p>a matrix or a three-dimensional array to be reduced
</p>
</td></tr>
<tr><td><code id="reduc_+3A_clu">clu</code></td>
<td>

<p>a vector with the class membership
</p>
</td></tr>
<tr><td><code id="reduc_+3A_lbs">lbs</code></td>
<td>

<p>(optional) the labels to be used in the reduction
</p>
</td></tr>
<tr><td><code id="reduc_+3A_slbs">slbs</code></td>
<td>

<p>(optional) the string labels to be used in the reduction
</p>
</td></tr>
<tr><td><code id="reduc_+3A_valued">valued</code></td>
<td>

<p>(logical) whether the reduction should preserve valued data?
</p>
</td></tr>
<tr><td><code id="reduc_+3A_row">row</code></td>
<td>

<p>(optional) the reduction by rows
</p>
</td></tr>
<tr><td><code id="reduc_+3A_col">col</code></td>
<td>

<p>(optional) the reduction by columns
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a partition, this function serves to reduce either a matrix representing e.g. a partial order structure. However, the reduction is also generalized to three-dimensional arrays representing multiple relations.
</p>


<h3>Value</h3>

<p>The reduced matrix or a reduced three-dimensional array of the input data according to the clustering information.
</p>


<h3>Note</h3>

<p>Use <code><a href="#topic+decomp">decomp</a></code> for the reduction of a semigroup object.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cngr">cngr</a></code>, <code><a href="#topic+rbox">rbox</a></code>, <code><a href="#topic+decomp">decomp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## scan the multiplication table data
s &lt;- matrix(data=c(1, 1, 1, 3, 3, 3, 3, 3, 3), nrow=3, ncol=3, byrow=TRUE)

## Reduce the multiplication table
reduc(s, clu=c(1,2,2))

</code></pre>

<hr>
<h2 id='reducs'>
internal function
</h2><span id='topic+reducs'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='rel.sys'>
Relational System
</h2><span id='topic+rel.sys'></span>

<h3>Description</h3>

<p>Create the Relation System of a multiplex network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rel.sys(x, type = c("tolist", "toarray"), bonds = c("entire", "strong", "weak", 
        "asym", "recp", "txch", "tent", "mixd", "full"), sel = NULL, 
        loops = FALSE, att = NULL, sep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rel.sys_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed.
</p>
</td></tr>
<tr><td><code id="rel.sys_+3A_type">type</code></td>
<td>

<p>if the transformation is from (array of) matrices into lists of pairwise relations or vice versa
</p>
</td></tr>
<tr><td><code id="rel.sys_+3A_bonds">bonds</code></td>
<td>

<p>the type of bonds to be used in the creation of the relational system (default the &lsquo;entire&rsquo; network)
</p>
</td></tr>
<tr><td><code id="rel.sys_+3A_sel">sel</code></td>
<td>

<p>(optional) the set of actors to be selected. For <code>"toarray"</code> <code>att</code> and <code>noatt</code> also supported (see details)
</p>
</td></tr>
<tr><td><code id="rel.sys_+3A_loops">loops</code></td>
<td>

<p>(logical) whether or not the loops should be considered in the relational system
</p>
</td></tr>
<tr><td><code id="rel.sys_+3A_att">att</code></td>
<td>

<p>the arrays in <code>x</code> corresponding to attributes
</p>
</td></tr>
<tr><td><code id="rel.sys_+3A_sep">sep</code></td>
<td>

<p>(optional) the pair separator for the pairwise relations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the type of bonds chosen is <code>entire</code> then the nodes with ties are considered in the relational system without isolated nodes. <code>strong</code> bonds are relational bundles with a mutual character, whereas <code>weak</code> bonds are those patterns exclusively without mutual character.
</p>
<p>When choosing from a list with actor attributes, it is also possible to select the network members having or <em>not</em> having the attribute that is specified in the <code>Attrs</code> output by using in argument <code>sel</code> for the two options <code>att</code> or <code>noatt</code>.
</p>


<h3>Value</h3>

<p>An object of '<code>Rel.System</code>' class for the <code>type = "tolist"</code> (default) option.
The items are:
</p>
<table>
<tr><td><code>ord</code></td>
<td>
<p>order of the network relational system</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>the nodes in the relational system</p>
</td></tr>
<tr><td><code>sel</code></td>
<td>
<p>the selected set of actors</p>
</td></tr>
<tr><td><code>sys.ord</code></td>
<td>
<p>the order of the relational system with the chosen bond type</p>
</td></tr>
<tr><td><code>incl</code></td>
<td>
<p>the nodes included the relational system with the chosen bond type</p>
</td></tr>
<tr><td><code>excl</code></td>
<td>
<p>the nodes excluded the relational system with the chosen bond type</p>
</td></tr>
<tr><td><code>bond.type</code></td>
<td>
<p>the type of bonds used in the relational system creation</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>number of ties in the relational system</p>
</td></tr>
<tr><td><code>Note</code></td>
<td>
<p>(optional) note</p>
</td></tr>
<tr><td><code>sep</code></td>
<td>
<p>the pairwise separator of the relational system</p>
</td></tr>
<tr><td><code>Ties</code></td>
<td>
<p>the ties in the relational system</p>
</td></tr>
<tr><td><code>Attrs.ord</code></td>
<td>
<p>if <code>att</code> is not <code>NULL</code>, the number of nodes with the chosen attribute(s) </p>
</td></tr>
<tr><td><code>Attrs</code></td>
<td>
<p>if <code>att</code> is not <code>NULL</code>, the actors with the chosen attribute(s)</p>
</td></tr>
</table>
<p>For <code>type = "toarray"</code> the output is a dichotomous 2D or 3D array recording the relations among the actors in the network.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Ostoic, J.A.R. &ldquo;Creating context for social influence processes in multiplex networks.&rdquo; <em>Network Science</em>, 5(1), 1-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expos">expos</a></code>, <code><a href="#topic+bundles">bundles</a></code>, <code><a href="#topic+neighb">neighb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two binary relations among three elements
arr &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
       c(3, 3, 2) ) &gt; .9, 3 ) )

## Determine the system of strong bonds
rel.sys(arr, bonds = "strong")

## the first array is for attributes
rel.sys(arr, att = 1)

## select the first node
rel.sys(arr, sel = 1)

</code></pre>

<hr>
<h2 id='rm.isol'>
Remove Isolates
</h2><span id='topic+rm.isol'></span>

<h3>Description</h3>

<p>Function to remove isolate nodes in simple and multiple networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm.isol(x, diag, diag.incl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm.isol_+3A_x">x</code></td>
<td>

<p>a matrix or array representing a network
</p>
</td></tr>
<tr><td><code id="rm.isol_+3A_diag">diag</code></td>
<td>

<p>(optional and logical) if arrays, should the diagonals be included in the computation?
</p>
</td></tr>
<tr><td><code id="rm.isol_+3A_diag.incl">diag.incl</code></td>
<td>

<p>(optional and logical) if arrays, should the diagonals be included in the output?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Isolated nodes do not have any edges in the network, and in a multivariate system, there is no edges adjacent to these kinds of nodes at any level.
</p>


<h3>Value</h3>

<p>The matrix or array representing a multiple network without the isolated actors.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+edgel">edgel</a></code>, <code><a href="#topic+zbind">zbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two binary relations among three elements
arr &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
c(3, 3, 2) ) &gt; .5, 3 ) )

## Remove isolates (if exist)
rm.isol(arr)
</code></pre>

<hr>
<h2 id='semigroup'>
Constructing the Semigroup of Relations
</h2><span id='topic+semigroup'></span>

<h3>Description</h3>

<p>Function to create the complete semigroup of multiple relations, where the multiplication table can be specified with either a numerical or a symbolic form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semigroup(x, type = c("numerical", "symbolic"), cmps, 
          smpl, valued)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semigroup_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed.
</p>
</td></tr>
<tr><td><code id="semigroup_+3A_type">type</code></td>
<td>

<p>whether the semigroup should be returned with a <code>numerical</code> (default) or in a <code>symbolic</code> form?
</p>
</td></tr>
<tr><td><code id="semigroup_+3A_cmps">cmps</code></td>
<td>

<p>(optional and logical) a logical to indicate whether the composite matrices should be also given in the output.
</p>
</td></tr>
<tr><td><code id="semigroup_+3A_smpl">smpl</code></td>
<td>

<p>(logical and logical) whether to simplify or not the strings of relations.
</p>
</td></tr>
<tr><td><code id="semigroup_+3A_valued">valued</code></td>
<td>

<p>(logical) whether the semigroup should be with a valued format
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A multiple relation can be defined by square matrices of 0's and 1's indicating the presence and absence of ties among a set of actors. If there is more than one relation type, the matrices must preserve the label ordering of its elements and stacked into an object array in order to be effectively applied to this function.
</p>
<p>The semigroup, which is an algebraic structure having a set with an associative operation on it, is calculated considering binary matrices only. This means that if the provided matrices are valued, the function will dichotomise the input data automatically; values higher or equal to a unit are converted to one, otherwise they are set to zero. If you are not happy with that, you can go to <code><a href="#topic+dichot">dichot</a></code> and specify your own cutoff value for the dichotomization. 
</p>
<p>Semigroup structures for valued relations apply the max min operation in the composition of generators and strings. 
</p>


<h3>Value</h3>

<p>An object of '<code>Semigroup</code>' class.
The items included are:
</p>
<table>
<tr><td><code>gens</code></td>
<td>

<p>array with generator relations
</p>
</td></tr>
<tr><td><code>cmps</code></td>
<td>

<p>array with the unique compound relations
</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>

<p>dimension of the semigroup
</p>
</td></tr>
<tr><td><code>st</code></td>
<td>

<p>vector of the unique string relations
</p>
</td></tr>
<tr><td><code>S</code></td>
<td>

<p>multiplication matrix with semigroup of relations (see below)
</p>
</td></tr>
</table>
<p>If the specified type is '<code>numerical</code>', then a matrix of semigroup values is given, otherwise the values is returned as a data frame with the strings of the semigroup.
</p>


<h3>Warning</h3>

<p>For medium size or bigger sets (having e.g. more the 4 relation types), the semigroup construction could take a long time.
</p>


<h3>Note</h3>

<p>It is recommendable to perform the function <code>prev</code> before attempting to construct the semigroup, unless the input data has few dimensions.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Boorman, S.A. and H.C. White, &lsquo;Social Structure from Multiple Networks. II. Role Structures.&rsquo; <em>American Journal of Sociology</em>, 81 (6), 1384-1446. 1976.
</p>
<p>Boyd, J.P. <em>Social Semigroups. A unified theory of scaling and blockmodelling as applied to social networks</em>. George Mason University Press. 1991.
</p>
<p>Pattison, P.E. <em>Algebraic Models for Social Networks</em>. Cambridge University Press. 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+green.rel">green.rel</a></code>, <code><a href="#topic+prev">prev</a></code>, <code><a href="#topic+strings">strings</a></code>, <code><a href="#topic+edgeT">edgeT</a></code>, <code><a href="#topic+wordT">wordT</a></code>, <code><a href="#topic+cngr">cngr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )

## optional: put labels
dimnames(arr)[[3]] &lt;- list("n", "m")

## look at the semigroup
semigroup(arr)

</code></pre>

<hr>
<h2 id='semiring'>
Semiring Structures for Balance Theory
</h2><span id='topic+semiring'></span>

<h3>Description</h3>

<p>A function to construct semiring structures for the analysis of structural balance theory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>semiring(x, type = c("balance", "cluster"), symclos = TRUE,
            transclos = TRUE, k = 2, lbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="semiring_+3A_x">x</code></td>
<td>
<p>  an object of a '<code>Signed</code>' class
</p>
</td></tr>
<tr><td><code id="semiring_+3A_type">type</code></td>
<td>
<p>  balance or cluster semiring?
</p>
</td></tr>
<tr><td><code id="semiring_+3A_symclos">symclos</code></td>
<td>
<p>  (logical) apply symmetric closure?
</p>
</td></tr>
<tr><td><code id="semiring_+3A_transclos">transclos</code></td>
<td>
<p>  (logical) apply transitive closure?
</p>
</td></tr>
<tr><td><code id="semiring_+3A_k">k</code></td>
<td>
<p>  length of the cycle or the semicycle
</p>
</td></tr>
<tr><td><code id="semiring_+3A_lbs">lbs</code></td>
<td>
<p>  (optional) labels for the semiring output
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Semiring structures are based on signed networks, and this function provides the capabilities to handle either the balance semiring or the cluster semiring within the structural balance theory.
A semiring combines two different kinds of operations with a single underlying set, and it can be seen as an abstract semigroup with identity under multiplication and a commutative monoid under addition. Semirings are useful to determine whether a given signed network is balanced or clusterable. The symmetric closure evaluates this by looking at semicycles in the system; otherwise, the evaluation is through closed paths. 
</p>


<h3>Value</h3>

<p>An object of '<code>Semiring</code>' class. 
The items included are:
</p>
<table>
<tr><td><code>val</code></td>
<td>
<p>the valences in the semiring</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>the original semiring structure</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the resulted semiring structure</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the number of cycles or semicycles</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Disabling transitive closure should be made with good substantial reasons.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Harary, F, Z. Norman, and D. Cartwright  <em>Structural Models: An Introduction to the Theory of Directed Graphs</em>. New York: John Wiley &amp; Sons. 1965.
</p>
<p>Doreian, P., V. Batagelj and A. Ferligoj  <em>Generalized Blockmodeling</em>. Cambridge University Press. 2004.
</p>
<p>Ostoic, J.A.R. &lsquo;Creating context for social influence processes in multiplex networks.&rsquo; <em>Network Science</em>, 5(1), 1-29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+signed">signed</a></code>, <code><a href="#topic+as.signed">as.signed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two sets with a pair of binary relations 
## among three elements
arr &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
       c(3, 3, 2) ) &gt; .5, 3 ) )

## Make the signed matrix with two types of relations
sg &lt;- signed(arr)

## Establish the semiring structure
semiring(sg)

</code></pre>

<hr>
<h2 id='signed'>
Signed Network
</h2><span id='topic+signed'></span>

<h3>Description</h3>

<p>Construct the signed network of a system of contrasting relations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signed(P, N = NULL, lbs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signed_+3A_p">P</code></td>
<td>

<p>array with the positive ties and possible with negative ties (see Details)
</p>
</td></tr>
<tr><td><code id="signed_+3A_n">N</code></td>
<td>

<p>(optional) array with the negative ties
</p>
</td></tr>
<tr><td><code id="signed_+3A_lbs">lbs</code></td>
<td>

<p>(optional) labels for the signed matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function coerces an array(s) to become a '<code>Signed</code>' object. 
Positive ties are always in the first argument, and in case that this array has three dimensions, 
the second dimension is considered as the negative ties, provided that <code>N</code> is still <code>NULL</code>. 
If ambivalent ties are present in the structure then the signed matrix represent positive, negative, ambivalent, and null ties 
as <code>p</code>, <code>n</code>, <code>a</code>, and <code>o</code> respectively; otherwise, the values are <code>1</code>, <code>-1</code>, and <code>0</code>.
</p>


<h3>Value</h3>

<p>An object of '<code>Signed</code>' class with items: 
</p>
<table>
<tr><td><code>val</code></td>
<td>
<p>the valences in the signed matrix</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>the signed matrix</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A warning message is shown when the <code>N</code> argument has more than two dimensions.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Doreian, P., V. Batagelj and A. Ferligoj  <em>Generalized Blockmodeling</em>. Cambridge University Press. 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+semiring">semiring</a></code>, <code><a href="#topic+as.signed">as.signed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the data
data("incubA")

## Make the signed matrix with two types of relations
signed(incubA$IM)

</code></pre>

<hr>
<h2 id='sprt'>
internal function
</h2><span id='topic+sprt'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='strings'>
Strings of Relations
</h2><span id='topic+strings'></span>

<h3>Description</h3>

<p>Function to get the labels of the unique relations of the semigroup; that is the generators and compound relations that are the elements of the complete semigroup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strings(x, equat = FALSE, k = 2, smpl, valued)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strings_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed.
</p>
</td></tr>
<tr><td><code id="strings_+3A_equat">equat</code></td>
<td>

<p>(logical) should the equations be included in the output?
</p>
</td></tr>
<tr><td><code id="strings_+3A_k">k</code></td>
<td>

<p>length of the strings in the equations
</p>
</td></tr>
<tr><td><code id="strings_+3A_smpl">smpl</code></td>
<td>

<p>(optional and logical) whether to simplify or not the string relations
</p>
</td></tr>
<tr><td><code id="strings_+3A_valued">valued</code></td>
<td>

<p>(logical) whether the strings are with a valued format
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The strings are the unique relations, which constitute the elements of the complete semigroup. These are both the generators and the compound relations after applying the Axiom of Quality, which means that even some generators can be disregarded.
</p>
<p>This function is especially useful to construct the partial order of relations and to establish the set of equations in the relational structure.
</p>


<h3>Value</h3>

<p>An object of '<code>Strings</code>' class.
</p>
<table>
<tr><td><code>wt</code></td>
<td>

<p>the generators and compound relations
</p>
</td></tr>
<tr><td><code>ord</code></td>
<td>

<p>the order of the structure
</p>
</td></tr>
<tr><td><code>st</code></td>
<td>

<p>the labels of the unique relations
</p>
</td></tr>
<tr><td><code>equat</code></td>
<td>

<p>the equations among strings of relations
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The maximum length of the strings in the equations is currently 4.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Boorman, S.A. and H.C. White, &lsquo;Social Structure from Multiple Networks. II. Role Structures.&rsquo; <em>American Journal of Sociology</em>, 81 (6), 1384-1446. 1976.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partial.order">partial.order</a></code>, <code><a href="#topic+semigroup">semigroup</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )

## get the strings
strings(arr)

</code></pre>

<hr>
<h2 id='strng'>
internal function
</h2><span id='topic+strng'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='summaryBundles'>
Summary of Bundle Classes
</h2><span id='topic+summaryBundles'></span>

<h3>Description</h3>

<p>Pretty printing of the bundle class patterns results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryBundles(x, file = NULL, latex = FALSE, byties)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryBundles_+3A_x">x</code></td>
<td>

<p>an object of the '<code>Rel.Bundles</code>' class
</p>
</td></tr>
<tr><td><code id="summaryBundles_+3A_file">file</code></td>
<td>

<p>(optional) the path where the output file is to be placed
</p>
</td></tr>
<tr><td><code id="summaryBundles_+3A_latex">latex</code></td>
<td>

<p>(logical) whether the output should be in latex format or not
</p>
</td></tr>
<tr><td><code id="summaryBundles_+3A_byties">byties</code></td>
<td>

<p>(optional and logical) expand tie patterns and collapse tie labels?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints the bundle census patterns existing in the network with an option to export such information in a friendly format. 
The dyadic bundle patterns are provided by the function <code><a href="#topic+bundles">bundles</a></code>; however, the outcome of this function provides a list of pair lists for 
each bundle with the involved types of relations and nodes in the network. 
This form for presentation, although is convenient for further computation, it is not always easy to read for the human eye. 
The pair separator used to print the bundle occurrences is taken from the output of the <code><a href="#topic+bundles">bundles</a></code> function.
</p>
<p>If <code>latex</code> is set to <code>TRUE</code>, then the path file is activated to obtain a <code>tex</code> file with the different bundle class patterns. 
Finally, the optional argument <code>byties</code> provide more precise information about the patterned ties disregarding the relational content.
</p>


<h3>Value</h3>

<p>The distinct bundle class patterns with a user friendly format.
</p>


<h3>Note</h3>

<p>If a file with the same name already exists in the pointed directory, then this file will be overwritten.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Ostoic, J. A. R. &lsquo;Dyadic Patterns in Multiple Networks,&rsquo; <em>Advances in Social Networks Analysis and Mining, International Conference on</em>, 475-481. 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bundles">bundles</a></code>, <code><a href="#topic+bundle.census">bundle.census</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
c(3, 3, 2) ) &gt; .8, 3 ) )

## Establish the different bundles
bd &lt;- bundles(arr)

## Print the different relational bundles
summaryBundles(bd)

</code></pre>

<hr>
<h2 id='swp'>
internal function
</h2><span id='topic+swp'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='ti'>
internal function
</h2><span id='topic+ti'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='transf'>
Transform Data from/to Matrix/List Formats
</h2><span id='topic+transf'></span>

<h3>Description</h3>

<p>Function to transform data from/to matrix/list formats or edge list representing a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transf(x, type = c("toarray", "tolist", "toarray2", "toedgel"), lbs = NULL, lb2lb, 
    sep, ord, sort, sym, add, adc, na.rm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transf_+3A_x">x</code></td>
<td>

<p>an array or a list of pair relations
</p>
</td></tr>
<tr><td><code id="transf_+3A_type">type</code></td>
<td>

<p>The type of transformation.
</p>
<p><code>toarray</code> from a list of pair relations to an array format
</p>
<p><code>tolist</code> from a matrix to a list of pair relations
</p>
<p><code>toarray2</code> from a list of pair relations to a square array
</p>
<p><code>toedgel</code> from arrays to edge list
</p>
</td></tr>
<tr><td><code id="transf_+3A_lbs">lbs</code></td>
<td>

<p>(optional) the labels in the transformation
</p>
</td></tr>
<tr><td><code id="transf_+3A_lb2lb">lb2lb</code></td>
<td>

<p>(optional and logical) whether the transformation is label-to-label. Default <code>TRUE</code> for <code>"toarray"</code> and <code>FALSE</code> for <code>"tolist"</code>
</p>
</td></tr>
<tr><td><code id="transf_+3A_sep">sep</code></td>
<td>

<p>(optional) the pair separator for the pairwise relations
</p>
</td></tr>
<tr><td><code id="transf_+3A_ord">ord</code></td>
<td>

<p>(optional) the order of the resulted structure (for <code>"toarray"</code>; otherwise ignored)
</p>
</td></tr>
<tr><td><code id="transf_+3A_sort">sort</code></td>
<td>

<p>(optional and logical) sort the arrays in the output?
</p>
</td></tr>
<tr><td><code id="transf_+3A_sym">sym</code></td>
<td>

<p>(optional and logical) symmetrize the arrays? (for <code>"toarray"</code>; otherwise ignored)
</p>
</td></tr>
<tr><td><code id="transf_+3A_add">add</code></td>
<td>

<p>(optional) add elements in the array's &lsquo;domain&rsquo;
</p>
</td></tr>
<tr><td><code id="transf_+3A_adc">adc</code></td>
<td>

<p>(optional) add elements in the array's &lsquo;codomain&rsquo;
</p>
</td></tr>
<tr><td><code id="transf_+3A_na.rm">na.rm</code></td>
<td>

<p>(optional) remove NAs?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Option <code>"tolist"</code> is for transforming a matrix or an array to a list of pair elements. 
In case that the <code>lb2lb</code> is enabled in this type of transformation, then <code>lbs</code> 
must be provided, whereas the pair separator is optional. On the other hand <code>"toarray"</code> 
will produce a matrix from a list of pair elements, and in this case is advisable to specify the order of the structure. 
Three dimensional structures are supported in the transformations with all options.
</p>
<p>Data frames are also accepted for the <code>"tolist"</code> option; however, in case that this information 
is given as a list of pair relations the output will be a square matrix.
</p>
<p>When the transformation option is <code>"edgel"</code>, the output is a data frame with the first two 
columns for the sending and receiving ties. For simple networks, these two columns are enough and for 
multiplex networks additional columns are for the types of tie, one for each (cf. function <code><a href="#topic+edgel">edgel</a></code>).
</p>


<h3>Value</h3>

<p>Depending on the input data, the result is either a list of pair relations or a matrix of relations.
</p>


<h3>Note</h3>

<p>For high dimensional arrays, the <code><a href="#topic+rel.sys">rel.sys</a></code> function privides additional information other than the list of pair relations of the entire structure.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgel">edgel</a></code>, <code><a href="#topic+bundles">bundles</a></code>, <code><a href="#topic+reduc">reduc</a></code>, <code><a href="#topic+rel.sys">rel.sys</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## scan the multiplication table data
s &lt;- matrix(data=c(1, 1, 1, 3, 3, 3, 3, 3, 3), nrow=3, ncol=3, byrow=TRUE)

## transform the matrix to a list format
transf(s, lb2lb = TRUE, lbs = c('n','m','u'))
</code></pre>

<hr>
<h2 id='transl'>
internal function
</h2><span id='topic+transl'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='trnf'>
internal function
</h2><span id='topic+trnf'></span>

<h3>Description</h3>

<p>internal function
</p>

<hr>
<h2 id='wordT'>
The Word Table of Relations
</h2><span id='topic+wordT'></span>

<h3>Description</h3>

<p>The Word Table of multiple relations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wordT(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wordT_+3A_x">x</code></td>
<td>

<p>an array; usually with three dimensions of stacked matrices where the multiple relations are placed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Word Table is a consequence of the Edge Table and the function gives a list of indexed elements in the complete semigroup. 
</p>
<p>In terms of the Cayley graph of the semigroup (cf. <code><a href="multigraph.html#topic+ccgraph">ccgraph</a></code>, the collection of unique relations 
(both compound and generators) are represented by nodes. 
On the other hand, the generators are edges that record the result of post-multiplying the compound relations by the generators.
</p>
<p>The labels for the elements can be retrieved by the <code><a href="#topic+strings">strings</a></code> function. 
</p>


<h3>Value</h3>

<p>An object of the '<code>WordTable</code>' class
</p>
<table>
<tr><td><code>gens</code></td>
<td>

<p>the generator relations
</p>
</td></tr>
<tr><td><code>WT</code></td>
<td>

<p>the Word Table where <code>"n"</code> stands for &lsquo;node&rsquo; and <code>"g"</code> stands for &lsquo;generator&rsquo;
</p>
</td></tr>
</table>
<p>The generators do not have values in neither the &lsquo;node&rsquo; nor the &lsquo;generator&rsquo; of the Word table since they are not a product of any other element in the semigroup (cf. details for the rest of the values).
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Cannon, J.J. &ldquo;Computing the ideal structure of finite semigroup,&rdquo; <em>Numerische Mathematik</em>, 18, 254-266. 1971.
</p>
<p>Pattison, P.E. <em>Algebraic Models for Social Networks</em>. Cambridge University Press. 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgeT">edgeT</a></code>, <code><a href="#topic+semigroup">semigroup</a></code>, <code><a href="#topic+strings">strings</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: 2 binary relations among 3 elements
arr &lt;- round( replace( array(runif(18), c(3,3,2)), array(runif(18),
       c(3,3,2))&gt;.5, 1 ) )

## get the word table
wordT(arr)

</code></pre>

<hr>
<h2 id='write.dat'>
Write <code>dat</code> Files
</h2><span id='topic+write.dat'></span>

<h3>Description</h3>

<p>A function to write <code>dat</code> files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.dat(x, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.dat_+3A_x">x</code></td>
<td>

<p>an object representing the multiple network structure
</p>
</td></tr>
<tr><td><code id="write.dat_+3A_path">path</code></td>
<td>

<p>the path file for the output
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'<code>dat</code>' files are the format used in the Pacnet program. In case that the input data represents a multiple network then a separate file will be produced, each one representing a single type of relationship in the system. The name of the output files depends on the object title.
</p>


<h3>Value</h3>

<p>File(s) with adjacency matrices with a <code>.dat</code> format
</p>


<h3>Note</h3>

<p>In case that the directory in the path for the output does not exist then it will be created automatically.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p><code>StOCNET</code> An open software system for the advanced statistical analysis of social networks.
<em>http://www.gmw.rug.nl/~stocnet/</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pacnet">pacnet</a></code>, <code><a href="#topic+write.gml">write.gml</a></code>, <code><a href="#topic+write.dl">write.dl</a></code>
</p>

<hr>
<h2 id='write.dl'>
Write <code>dl</code> Files
</h2><span id='topic+write.dl'></span>

<h3>Description</h3>

<p>A function to write <code>dl</code> files representing multiple networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.dl(x, file = NULL, type = c("nodelist", "fullmat"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.dl_+3A_x">x</code></td>
<td>
<p>  an object representing the multiple network
</p>
</td></tr>
<tr><td><code id="write.dl_+3A_file">file</code></td>
<td>
<p>  path to the file
</p>
</td></tr>
<tr><td><code id="write.dl_+3A_type">type</code></td>
<td>
<p>  whether to write the data as a <code>nodelist</code> or as a <code>fullmat</code> format
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dl</code> files serve to represent multiple networks, and it is one of the formats used in Netdraw, which is a component of the Ucinet program.
</p>


<h3>Value</h3>

<p>A file with the data with a <code>.dl</code> format
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p>Borgatti, S.P., <code>NetDraw</code> Software for Network Visualization. Analytic Technologies. 2002.
</p>
<p>Borgatti, S.P., Everett, M.G. and Freeman, L.C. <code>Ucinet for Windows</code>: Software for Social Network Analysis. Analytic Technologies. 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.dl">read.dl</a></code>, <code><a href="#topic+write.gml">write.gml</a></code>, <code><a href="#topic+write.srt">write.srt</a></code>, <code><a href="#topic+write.dat">write.dat</a></code>
</p>

<hr>
<h2 id='write.edgel'>
Write edge list files
</h2><span id='topic+write.edgel'></span><span id='topic+write.srt'></span>

<h3>Description</h3>

<p>A function to write edge list files having columns for sender, receiver, and the ties for multiplex networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.edgel(x, file = NULL, sep = "\t", header = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.edgel_+3A_x">x</code></td>
<td>

<p>an object representing the multiple network
</p>
</td></tr>
<tr><td><code id="write.edgel_+3A_file">file</code></td>
<td>

<p>path to the file
</p>
</td></tr>
<tr><td><code id="write.edgel_+3A_sep">sep</code></td>
<td>

<p>the separator used between the columns
</p>
</td></tr>
<tr><td><code id="write.edgel_+3A_header">header</code></td>
<td>

<p>(logical) whether the header should be included in the file
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Write edge list files with a <em>s</em>end, <em>r</em>eceive, and <em>t</em>ies, which is a data frame with at least two columns for the sender and receiver, 
and the different types of tie for multiplex networks, one column for each type of relation.
</p>


<h3>Value</h3>

<p>A file with the edge list format
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+edgel">edgel</a></code>, , <code><a href="#topic+write.dl">write.dl</a></code>
</p>

<hr>
<h2 id='write.gml'>
Write <code>gml</code> Files
</h2><span id='topic+write.gml'></span>

<h3>Description</h3>

<p>A function to write files with a <code>gml</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.gml(x, file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.gml_+3A_x">x</code></td>
<td>

<p>an object representing the multiple network
</p>
</td></tr>
<tr><td><code id="write.gml_+3A_file">file</code></td>
<td>

<p>path to the file
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>gml</code> format, an acronym for <em>graph modelling language</em>, provides capabilities to represent multiple networks and add arguments to both the nodes and the edges for visualization purposes. 
</p>


<h3>Value</h3>

<p>A file with the data with a graph modelling language format.
</p>


<h3>Note</h3>

<p>In case that the file already exists in the pointed directory, then the file will be overwritten.
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>References</h3>

<p><code>visone</code> Software for the analysis and visualization of social networks. <em>http://visone.info</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.gml">read.gml</a></code>, <code><a href="#topic+write.dl">write.dl</a></code>, <code><a href="#topic+write.dat">write.dat</a></code>
</p>

<hr>
<h2 id='zbind'>
Combine Arrays 
</h2><span id='topic+zbind'></span>

<h3>Description</h3>

<p>Combine multidimensional arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zbind(..., sort, force)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zbind_+3A_...">...</code></td>
<td>

<p>One or more arrays with two or three dimensions
</p>
</td></tr>
<tr><td><code id="zbind_+3A_sort">sort</code></td>
<td>

<p>(optional and logical) sort array according to labels?
</p>
</td></tr>
<tr><td><code id="zbind_+3A_force">force</code></td>
<td>

<p>(optional and logical) force binding matrices with different order?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for stacking two-dimensional arrays into a single three-dimensional object to represent a multivariate system structure. Both square and rectangular arrays are supported provided that the dimensions in the input are equal. The <code>dimnames</code> in the output correspond to the first array in the input, and a Warning message is given when these are NULL.
</p>


<h3>Value</h3>

<p>Usually a three dimensional array
</p>


<h3>Note</h3>

<p>Data frames should be transformed into arrays
</p>


<h3>Author(s)</h3>

<p>Antonio Rivero Ostoic
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mnplx">mnplx</a></code>, <code><a href="#topic+dichot">dichot</a></code>, <code><a href="#topic+strings">strings</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create the data: two sets with a pair of binary relations 
## among three elements
arr1 &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
        c(3, 3, 2) ) &gt; .5, 3 ) )

arr2 &lt;- round( replace( array( runif(18), c(3 ,3, 2) ), array( runif(18),
        c(3, 3, 2) ) &gt; .5, 3 ) )

## bind the data sets
zbind(arr1, arr2)
</code></pre>

<hr>
<h2 id='zbnd'>
internal function
</h2><span id='topic+zbnd'></span>

<h3>Description</h3>

<p>internal function
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
