<!DOCTYPE html><html><head><title>Help for package nimbleSCR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nimbleSCR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculateDensity'><p>NIMBLE function to calculate the density of individuals alive in each habitat cell.</p></a></li>
<li><a href='#calcWindowSizes'><p>Window size calculation</p></a></li>
<li><a href='#dbernppAC'><p>Bernoulli point process for the distribution of activity centers</p></a></li>
<li><a href='#dbernppACmovement_exp'><p>Bernoulli point process for activity center movement (exponential kernel)</p></a></li>
<li><a href='#dbernppACmovement_normal'><p>Bernoulli point process for activity center movement (normal kernel)</p></a></li>
<li><a href='#dbernppDetection_normal'><p>Bernoulli point process detection model</p></a></li>
<li><a href='#dbernppLocalACmovement_exp'><p>Local evaluation of a Bernoulli point process for activity center movement (exponential kernel)</p></a></li>
<li><a href='#dbernppLocalACmovement_normal'><p>Local evaluation of a Bernoulli point process for activity center movement (normal kernel)</p></a></li>
<li><a href='#dbernppLocalDetection_normal'><p>Local evaluation for a Bernoulli point process detection model</p></a></li>
<li><a href='#dbinom_vector'><p>Vectorized binomial distribution</p></a></li>
<li><a href='#dbinomLocal_exp'><p>Local evaluation of a binomial SCR observation process</p></a></li>
<li><a href='#dbinomLocal_normal'><p>Local evaluation of a binomial SCR detection process</p></a></li>
<li><a href='#dbinomLocal_normalPlateau'><p>Local evaluation of a binomial SCR observation process</p></a></li>
<li><a href='#dcatState1Alive1Dead'><p>Density and random generation of a categorical distribution describing state transition with one alive and one dead states.</p></a></li>
<li><a href='#dcatState1Alive2Dead'><p>Density and random generation of a categorical distribution describing state transition with one alive and two dead states.</p></a></li>
<li><a href='#dcatState2Alive2Dead'><p>Density and random generation of a categorical distribution describing state transition with two alive and two dead states.</p></a></li>
<li><a href='#dDispersal_exp'><p>Bivariate exponential dispersal distribution for activity centers</p></a></li>
<li><a href='#dHabitatMask'><p>Ones trick distribution for irregular habitat shapes</p></a></li>
<li><a href='#dmultiLocal_normal'><p>Local evaluation of a multinomial SCR detection process</p></a></li>
<li><a href='#dnormalizer'><p>Normalizing constant generator</p></a></li>
<li><a href='#dpoisLocal_normal'><p>Local evaluation of a Poisson SCR detection process</p></a></li>
<li><a href='#dpoisppAC'><p>Poisson point process for the distribution of activity centers</p></a></li>
<li><a href='#dpoisppDetection_normal'><p>Poisson point process detection model</p></a></li>
<li><a href='#dpoisppLocalDetection_normal'><p>Local evaluation for a Poisson point process detection model</p></a></li>
<li><a href='#getHomeRangeArea'><p>Computation of home range radius and area</p></a></li>
<li><a href='#getLocalObjects'><p>Local Objects Identification</p></a></li>
<li><a href='#getMidPointNodes'><p>Generate midpoint integration nodes</p></a></li>
<li><a href='#getSparseY'><p>Sparse Matrix Preparation</p></a></li>
<li><a href='#getWindowCoords'><p>Get lower and upper windows coordinates</p></a></li>
<li><a href='#getWindowIndex'><p>Get window index</p></a></li>
<li><a href='#integrateIntensity_exp'><p>Integrate the multivariate exponential intensity</p></a></li>
<li><a href='#integrateIntensity_normal'><p>Integrate the multivariate normal intensity</p></a></li>
<li><a href='#integrateIntensityLocal_exp'><p>Integrate the multivariate exponential intensity with local evaluation</p></a></li>
<li><a href='#integrateIntensityLocal_normal'><p>Integrate the multivariate normal intensity with local evaluation</p></a></li>
<li><a href='#localTrapCalculations'><p>Local Trap Calculations</p></a></li>
<li><a href='#makeConstantNimbleFunction'><p><code>nimble</code> constant function generator</p></a></li>
<li><a href='#marginalVoidProbIntegrand'><p>Integrand of the marginal void probability integral</p></a></li>
<li><a href='#marginalVoidProbNumIntegration'><p>Marginal void probability</p></a></li>
<li><a href='#sampler_categorical_general'><p><code>nimble</code> MCMC sampler function for general categorial distributions</p></a></li>
<li><a href='#scaleCoordsToHabitatGrid'><p>Scale x- and y-coordinates to grid cells coordinates.</p></a></li>
<li><a href='#stratRejectionSampler_exp'><p>Stratified rejection sampler for multivariate exponential point process</p></a></li>
<li><a href='#stratRejectionSampler_normal'><p>Stratified rejection sampler for multivariate normal point process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Capture-Recapture (SCR) Methods Using 'nimble'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Turek &lt;danielturek@gmail.com&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides utility functions, distributions, and fitting methods for Bayesian Spatial Capture-Recapture (SCR) and Open Population Spatial Capture-Recapture (OPSCR) modelling using the nimble package (de Valpine et al. 2017 &lt;doi:10.1080/10618600.2016.1172487 &gt;). Development of the package was motivated primarily by the need for flexible and efficient analysis of large-scale SCR data (Bischof et al. 2020 &lt;doi:10.1073/pnas.2011383117 &gt;). Computational methods and techniques implemented in nimbleSCR include those discussed in Turek et al. 2021 &lt;<a href="https://doi.org/10.1002%2Fecs2.3385">doi:10.1002/ecs2.3385</a>&gt;; among others. For a recent application of nimbleSCR, see Milleret et al. (2021) &lt;<a href="https://doi.org/10.1098%2Frsbl.2021.0128">doi:10.1098/rsbl.2021.0128</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), nimble</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), coda, basicMCMCplots</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>calcWindowSizes.R getWindowIndex.R
integrateIntensityLocal_normal.R integrateIntensityLocal_exp.R
integrateIntensity_normal.R integrateIntensity_exp.R
stratRejectionSampler_normal.R stratRejectionSampler_exp.R
dDispersal_exp.R dHabitatMask.R dbernppAC.R
dbernppACmovement_normal.R dbernppACmovement_exp.R
dbernppDetection_normal.R dbernppLocalACmovement_normal.R
dbernppLocalACmovement_exp.R dbernppLocalDetection_normal.R
dbinomLocal_normal.R dmultiLocal_normal.R dbinom_vector.R
dnormalizer.R dpoisLocal_normal.R dbinomLocal_normalPlateau.R
dbinomLocal_exp.R dpoisppAC.R dpoisppDetection_normal.R
dpoisppLocalDetection_normal.R getLocalObjects.R
getMidPointNodes.R getWindowCoords.R getSparseY.R
getHomeRangeArea.R localTrapCalculations.R
makeConstantNimbleFunction.R marginalVoidProbIntegrand.R
marginalVoidProbNumIntegration.R scaleCoordsToHabitatGrid.R
dcatState1Alive1Dead.R dcatState1Alive2Dead.R
dcatState2Alive2Dead.R sampler_categorical_general.R
calculateDensity.R zzz.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-30 14:37:23 UTC; dturek</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard Bischof [aut],
  Daniel Turek [aut, cre],
  Cyril Milleret [aut],
  Torbjørn Ergon [aut],
  Pierre Dupont [aut],
  Soumen Dey [aut],
  Wei Zhang [aut],
  Perry de Valpine [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-30 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculateDensity'>NIMBLE function to calculate the density of individuals alive in each habitat cell.</h2><span id='topic+calculateDensity'></span>

<h3>Description</h3>

<p><code>calculateDensity</code> is a NIMBLE function to calculate number of individual activity centers (s) in each habitat cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateDensity(s, habitatGrid, indicator, numWindows, nIndividuals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateDensity_+3A_s">s</code></td>
<td>
<p><code>Matrix</code> of x- and y-coordinates of individual AC locations.</p>
</td></tr>
<tr><td><code id="calculateDensity_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the 
order of habitat windows in spatial probabilities (e.g. <code>prob1To2Hab</code> as used in the function <code>dcatState1Alive2Dead</code>) or in <code>lowerCoords</code> and <code>upperCoords</code> as used in the <code>dbernppAC</code> function. #' @param indicator <code>Vector</code> of binary arguments specifying whether the individuals are considered alive (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="calculateDensity_+3A_indicator">indicator</code></td>
<td>
<p><code>Vector</code> of binary arguments specifying whether the individuals are considered alive (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="calculateDensity_+3A_numwindows">numWindows</code></td>
<td>
<p><code>Scalar</code> Number of habitat windows.</p>
</td></tr>
<tr><td><code id="calculateDensity_+3A_nindividuals">nIndividuals</code></td>
<td>
<p><code>Scalar</code> Number of individuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyril Milleret
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)  
logIntensities &lt;- log(rep(1,4))
logSumIntensity &lt;- log(sum(c(1:4))) 
habitatGrid &lt;- matrix(c(1:4), nrow = 2, byrow = TRUE)
numGridRows &lt;- nrow(habitatGrid)
numGridCols &lt;- ncol(habitatGrid)

s &lt;- matrix(NA,nrow=10,ncol=2)
for(i in 1:10){
  s[i,] &lt;- rbernppAC(n=1, lowerCoords, upperCoords, logIntensities, logSumIntensity, 
                     habitatGrid, numGridRows, numGridCols)
}

calculateDensity(s = s,
                 habitatGrid = habitatGrid,
                 indicator = rep(1, 10),
                 numWindows = prod(dim(habitatGrid)),
                 nIndividuals = 10
)
</code></pre>

<hr>
<h2 id='calcWindowSizes'>Window size calculation</h2><span id='topic+calcWindowSizes'></span>

<h3>Description</h3>

<p>Calculates the sizes of a set of windows based on their lower and upper coordinates of each dimension.
Can be applied to detection and habitat windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcWindowSizes(lowerCoords, upperCoords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcWindowSizes_+3A_lowercoords">lowerCoords</code></td>
<td>
<p>Matrix of lower x- and y-coordinates of all windows. One row for each window.</p>
</td></tr>
<tr><td><code id="calcWindowSizes_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrix of upper x- and y-coordinates of all windows. One row for each window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of window sizes.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 3, 1, 1, 4, 3, 4), nrow = 4, byrow = TRUE)
calcWindowSizes(lowerCoords, upperCoords)


</code></pre>

<hr>
<h2 id='dbernppAC'>Bernoulli point process for the distribution of activity centers</h2><span id='topic+dbernppAC'></span><span id='topic+rbernppAC'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Bernoulli point process for the distribution of activity centers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernppAC(
  x,
  lowerCoords,
  upperCoords,
  logIntensities,
  logSumIntensity,
  habitatGrid,
  numGridRows,
  numGridCols,
  log = 0
)

rbernppAC(
  n,
  lowerCoords,
  upperCoords,
  logIntensities,
  logSumIntensity,
  habitatGrid,
  numGridRows,
  numGridCols
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbernppAC_+3A_x">x</code></td>
<td>
<p>Vector of x- and y-coordinates of a single spatial point (i.e. AC location) scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbernppAC_+3A_lowercoords">lowerCoords</code>, <code id="dbernppAC_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all habitat windows scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>). One row for each window. 
Each window should be of size 1x1.</p>
</td></tr>
<tr><td><code id="dbernppAC_+3A_logintensities">logIntensities</code></td>
<td>
<p>Vector of log habitat intensities for all habitat windows.</p>
</td></tr>
<tr><td><code id="dbernppAC_+3A_logsumintensity">logSumIntensity</code></td>
<td>
<p>Log of the sum of habitat intensities over all windows.</p>
</td></tr>
<tr><td><code id="dbernppAC_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the order of habitat windows in
<code>lowerCoords</code>, <code>upperCoords</code>, and <code>logIntensities</code>. 
When the habitat grid only consists of a single row or column of windows, an additional row or column of dummy indices has to be added because the <code>nimble</code> model code requires a matrix.</p>
</td></tr>
<tr><td><code id="dbernppAC_+3A_numgridrows">numGridRows</code>, <code id="dbernppAC_+3A_numgridcols">numGridCols</code></td>
<td>
<p>Numbers of rows and columns of the habitat grid.</p>
</td></tr>
<tr><td><code id="dbernppAC_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbernppAC_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbernppAC</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
the activity center location (<em>x</em>) of a single individual in continuous space over a set of habitat windows defined by their upper and lower
coordinates (<em>lowerCoords,upperCoords</em>). The distribution assumes that the activity center  
follows a Bernoulli point process with intensity = <em>exp(logIntensities)</em>.
</p>


<h3>Value</h3>

<p><code>dbernppAC</code> gives the (log) probability density of the observation vector <code>x</code>. 
<code>rbernppAC</code> gives coordinates of a randomly generated spatial point.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the distribution in R
lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)  
logIntensities &lt;- log(c(1:4))
logSumIntensity &lt;- log(sum(c(1:4)))  
habitatGrid &lt;- matrix(c(1:4), nrow = 2, byrow = TRUE)
numGridRows &lt;- nrow(habitatGrid)
numGridCols &lt;- ncol(habitatGrid)
dbernppAC(c(0.5, 1.5), lowerCoords, upperCoords, logIntensities, logSumIntensity, 
          habitatGrid, numGridRows, numGridCols, log = TRUE)
</code></pre>

<hr>
<h2 id='dbernppACmovement_exp'>Bernoulli point process for activity center movement (exponential kernel)</h2><span id='topic+dbernppACmovement_exp'></span><span id='topic+rbernppACmovement_exp'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Bernoulli point process for activity center movement between occasions based on a bivariate exponential distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernppACmovement_exp(
  x,
  lowerCoords,
  upperCoords,
  s,
  lambda = -999,
  rate,
  baseIntensities,
  habitatGrid,
  numGridRows,
  numGridCols,
  numWindows,
  log = 0
)

rbernppACmovement_exp(
  n,
  lowerCoords,
  upperCoords,
  s,
  lambda = -999,
  rate,
  baseIntensities,
  habitatGrid,
  numGridRows,
  numGridCols,
  numWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbernppACmovement_exp_+3A_x">x</code></td>
<td>
<p>Vector of x- and y-coordinates of a single spatial point (typically AC location at time t+1) scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_lowercoords">lowerCoords</code>, <code id="dbernppACmovement_exp_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all habitat windows. One row for each window.
Each window should be of size 1x1 (after rescaling if necessary).</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic multivariate exponential distribution mean (AC location at time t).</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_lambda">lambda</code></td>
<td>
<p>Rate parameter of the isotropic bivariate exponential distribution. Soon deprecated, use argument &quot;rate&quot; instead.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_rate">rate</code></td>
<td>
<p>Rate parameter of the isotropic multivariate exponential distribution.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline habitat intensities for all habitat windows.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the order of habitat windows in  <code>lowerCoords</code> and <code>upperCoords</code>. 
When the habitat grid only consists of a single row or column of windows, an additional row or column of dummy indices has to be added because the <code>nimble</code> model code requires a matrix.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_numgridrows">numGridRows</code>, <code id="dbernppACmovement_exp_+3A_numgridcols">numGridCols</code></td>
<td>
<p>Numbers of rows and columns of the habitat grid.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of habitat windows. This value (positive integer) can be used to truncate <code>lowerCoords</code> and <code>upperCoords</code> so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_exp_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbernppACmovement_exp</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
movement of activity centers between consecutive occasions in open population models.
The distribution assumes that the new individual activity center location (<em>x</em>)
follows an isotropic exponential normal centered on the previous activity center (<em>s</em>) with rate (<em>lambda</em>).
</p>


<h3>Value</h3>

<p><code>dbernppACmovement_exp</code> gives the (log) probability density of the observation vector <code>x</code>. 
<code>rbernppACmovement_exp</code> gives coordinates of a randomly generated spatial point.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang and Cyril Milleret
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the distribution in R
lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)  
s &lt;- c(1, 1) # Currrent activity center location
rate &lt;- 0.1
baseIntensities &lt;- c(1:4)
habitatGrid &lt;- matrix(c(1:4), nrow = 2, byrow = TRUE)
numRows &lt;- nrow(habitatGrid)
numCols &lt;- ncol(habitatGrid)
numWindows &lt;- 4
# The log probability density of moving from (1,1) to (1.2, 0.8) 
dbernppACmovement_exp(x = c(1.2, 0.8),
lowerCoords = lowerCoords,
upperCoords = upperCoords,
s = s,
rate = rate,
baseIntensities = baseIntensities, 
habitatGrid = habitatGrid,
numGridRows = numRows,
numGridCols = numCols,
numWindows = numWindows,
log = TRUE)
</code></pre>

<hr>
<h2 id='dbernppACmovement_normal'>Bernoulli point process for activity center movement (normal kernel)</h2><span id='topic+dbernppACmovement_normal'></span><span id='topic+rbernppACmovement_normal'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Bernoulli point process for activity center movement between occasions based on a bivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernppACmovement_normal(
  x,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  habitatGrid,
  numGridRows,
  numGridCols,
  numWindows,
  log = 0
)

rbernppACmovement_normal(
  n,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  habitatGrid,
  numGridRows,
  numGridCols,
  numWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbernppACmovement_normal_+3A_x">x</code></td>
<td>
<p>Vector of x- and y-coordinates of a single spatial point (typically AC location at time t+1) scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_lowercoords">lowerCoords</code>, <code id="dbernppACmovement_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all habitat windows scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).
One row for each window. Each window should be of size 1x1.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic bivariate normal distribution mean (AC location at time t).</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic bivariate normal distribution..</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline habitat intensities for all habitat windows.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the order of habitat windows in  <code>lowerCoords</code> and <code>upperCoords</code>. 
When the habitat grid only consists of a single row or column of windows, an additional row or column of dummy indices has to be added because the <code>nimble</code> model code requires a matrix.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_numgridrows">numGridRows</code>, <code id="dbernppACmovement_normal_+3A_numgridcols">numGridCols</code></td>
<td>
<p>Numbers of rows and columns of the habitat grid.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of habitat windows. This value (positive integer) can be used to truncate <code>lowerCoords</code> and <code>upperCoords</code> so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbernppACmovement_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbernppACmovement_normal</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
movement of activity centers between consecutive occasions in open population models.
The distribution assumes that the new individual activity center location (<em>x</em>)
follows an isotropic multivariate normal centered on the previous activity center (<em>s</em>) with standard deviation (<em>sd</em>).
</p>


<h3>Value</h3>

<p><code>dbernppACmovement_normal</code> gives the (log) probability density of the observation vector <code>x</code>. 
<code>rbernppACmovement_normal</code> gives coordinates of a randomly generated spatial point.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang and Cyril Milleret
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the distribution in R
lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)  
s &lt;- c(1, 1) # Currrent activity center location
sd &lt;- 0.1
baseIntensities &lt;- c(1:4)
habitatGrid &lt;- matrix(c(1:4), nrow = 2, byrow = TRUE)
numRows &lt;- nrow(habitatGrid)
numCols &lt;- ncol(habitatGrid)
numWindows &lt;- 4
# The log probability density of moving from (1,1) to (1.2, 0.8) 
dbernppACmovement_normal(c(1.2, 0.8), lowerCoords, upperCoords, s, sd, baseIntensities, 
                         habitatGrid, numRows, numCols, numWindows, log = TRUE)
</code></pre>

<hr>
<h2 id='dbernppDetection_normal'>Bernoulli point process detection model</h2><span id='topic+dbernppDetection_normal'></span><span id='topic+rbernppDetection_normal'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Bernoulli point process for detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernppDetection_normal(
  x,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  numWindows,
  indicator,
  log = 0
)

rbernppDetection_normal(
  n,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  numWindows,
  indicator
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbernppDetection_normal_+3A_x">x</code></td>
<td>
<p>Vector with three elements representing the x- and y-coordinates and the id of the corresponding detection window for a single spatial point (detection location) scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbernppDetection_normal_+3A_lowercoords">lowerCoords</code>, <code id="dbernppDetection_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all detection windows scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>). One row for each window. Each window should be of size 1x1.</p>
</td></tr>
<tr><td><code id="dbernppDetection_normal_+3A_s">s</code></td>
<td>
<p>VVector of x- and y-coordinates of the isotropic bivariate normal distribution mean (i.e. the AC location)..</p>
</td></tr>
<tr><td><code id="dbernppDetection_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic bivariate normal distribution.</p>
</td></tr>
<tr><td><code id="dbernppDetection_normal_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline detection intensities for all detection windows.</p>
</td></tr>
<tr><td><code id="dbernppDetection_normal_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of detection windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
<tr><td><code id="dbernppDetection_normal_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dbernppDetection_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbernppDetection_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbernppDetection_normal</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
Bernoulli observations (<em>x</em>) of a single individual in continuous space over a set of detection windows defined by their upper and lower
coordinates (<em>lowerCoords,upperCoords</em>). The distribution assumes that an individual’s detection probability 
follows an isotropic multivariate normal centered on the individual's activity center (<em>s</em>) with standard deviation (<em>sd</em>).
</p>


<h3>Value</h3>

<p><code>dbernppDetection_normal</code> gives the (log) probability density of the observation vector <code>x</code>. 
<code>rbernppDetection_normal</code> gives coordinates of a randomly generated spatial point.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang and Cyril Milleret
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol = 2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# Create observation windows
 lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
 upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
 colnames(lowerCoords) &lt;- colnames(upperCoords) &lt;- c("x","y")
# Rescale coordinates
ScaledLowerCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  lowerCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  upperCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords$coordsDataScaled[,2] &lt;- ScaledUpperCoords$coordsDataScaled[,2] + 1.5
ScaledLowerCoords$coordsDataScaled[,2] &lt;- ScaledLowerCoords$coordsDataScaled[,2] - 1.5


s &lt;- c(1, 1)
sd &lt;- 0.1
baseIntensities &lt;- c(1:4)
windowIndex &lt;- 4
numPoints &lt;- 1
numWindows &lt;- 4
indicator &lt;- 1
x &lt;- c(0.5, 2)
windowIndex &lt;- getWindowIndex(curCoords = x,
                              lowerCoords = ScaledLowerCoords$coordsDataScaled,
                              upperCoords =ScaledUpperCoords$coordsDataScaled)
x &lt;- c(x, windowIndex)

dbernppDetection_normal(x, lowerCoords, upperCoords,
                        s, sd, baseIntensities
                        , numWindows,
                        indicator, log = TRUE)
</code></pre>

<hr>
<h2 id='dbernppLocalACmovement_exp'>Local evaluation of a Bernoulli point process for activity center movement (exponential kernel)</h2><span id='topic+dbernppLocalACmovement_exp'></span><span id='topic+rbernppLocalACmovement_exp'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Bernoulli point process for activity center movement between occasions based on a bivariate exponential distribution and local evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernppLocalACmovement_exp(
  x,
  lowerCoords,
  upperCoords,
  s,
  lambda = -999,
  rate,
  baseIntensities,
  habitatGrid,
  habitatGridLocal,
  resizeFactor = 1,
  localHabWindowIndices,
  numLocalHabWindows,
  numGridRows,
  numGridCols,
  numWindows,
  log = 0
)

rbernppLocalACmovement_exp(
  n,
  lowerCoords,
  upperCoords,
  s,
  lambda = -999,
  rate,
  baseIntensities,
  habitatGrid,
  habitatGridLocal,
  resizeFactor = 1,
  localHabWindowIndices,
  numLocalHabWindows,
  numGridRows,
  numGridCols,
  numWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_x">x</code></td>
<td>
<p>Vector of x- and y-coordinates of a single spatial point (typically AC location at time t+1) scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_lowercoords">lowerCoords</code>, <code id="dbernppLocalACmovement_exp_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all habitat windows. One row for each window.
Each window should be of size 1x1 (after rescaling if necessary).</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic multivariate exponential distribution mean (AC location at time t).</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_lambda">lambda</code></td>
<td>
<p>Rate parameter of the isotropic bivariate exponential distribution. Soon deprecated, use argument &quot;rate&quot; instead.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_rate">rate</code></td>
<td>
<p>Rate parameter of the isotropic bivariate exponential distribution.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline habitat intensities for all habitat windows.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the order of habitat windows in  <code>lowerCoords</code> and <code>upperCoords</code>. 
When the habitat grid only consists of a single row or column of windows, an additional row or column of dummy indices has to be added because the <code>nimble</code> model code requires a matrix.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_habitatgridlocal">habitatGridLocal</code></td>
<td>
<p>Matrix of rescaled habitat grid cells indices, as returned by the <code>getLocalObjects</code> function (object named <code>habitatGrid</code>).</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the  <code>getLocalObjects</code> function to reduce the number of habitat grid cells.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_localhabwindowindices">localHabWindowIndices</code></td>
<td>
<p>Matrix of indices of local habitat windows around each local habitat grid cell (<code>habitatGridLocal</code>) from localIndices returned by <code>getLocalObjects</code> function.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_numlocalhabwindows">numLocalHabWindows</code></td>
<td>
<p>Vector of numbers of local habitat windows around all habitat grid cells, from  <code>numLocalIndices</code> returned by the <code>getLocalObjects</code> function. The ith number gives the number of local (original) habitat windows for the ith local habitat grid cell <code>habitatGridLocal</code>.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_numgridrows">numGridRows</code>, <code id="dbernppLocalACmovement_exp_+3A_numgridcols">numGridCols</code></td>
<td>
<p>Numbers of rows and columns of the <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of habitat windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_exp_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbernppLocalACmovement_exp</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
movement of activity centers between consecutive occasions in open population models.
The distribution assumes that the new individual activity center location (<em>x</em>)
follows an isotropic exponential normal centered on the previous activity center (<em>s</em>) with rate (<em>lambda</em>).
The local evaluation approach is implemented.
</p>


<h3>Value</h3>

<p>The (log) probability density of the observation vector <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang and Cyril Milleret
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035 
</p>
<p>C. Milleret, P. Dupont, C. Bonenfant, H. Broseth, O. Flagstad, C. Sutherland and R. Bischof. 2019. 
A local evaluation of the individual state-space to scale up Bayesian spatial capture-recapture. Ecology and Evolution 9:352-363
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creat habitat grid
habitatGrid &lt;- matrix(c(1:(4^2)), nrow = 4, ncol=4, byrow = TRUE)
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol = 2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# Create habitat windows
lowerCoords &lt;- coordsHabitatGridCenter-0.5
upperCoords &lt;- coordsHabitatGridCenter+0.5
colnames(lowerCoords) &lt;- colnames(upperCoords) &lt;- c("x","y")
# Plot check
plot(lowerCoords[,"y"]~lowerCoords[,"x"],pch=16, xlim=c(0,4), ylim=c(0,4),col="red") 
points(upperCoords[,"y"]~upperCoords[,"x"],col="red",pch=16) 
points(coordsHabitatGridCenter[,"y"]~coordsHabitatGridCenter[,"x"],pch=16) 

# Rescale coordinates 
ScaledLowerCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  lowerCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  upperCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords$coordsDataScaled[,2] &lt;- ScaledUpperCoords$coordsDataScaled[,2] + 1
ScaledLowerCoords$coordsDataScaled[,2] &lt;- ScaledLowerCoords$coordsDataScaled[,2] - 1
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)
# Create local objects 
HabWindowsLocal &lt;- getLocalObjects(habitatMask = habitatMask,
                                   coords = coordsHabitatGridCenter,
                                   dmax=4,
                                   resizeFactor = 1,
                                   plot.check = TRUE
)

s &lt;- c(1, 1) # Currrent activity center location
rate &lt;- 0.1
numWindows &lt;- nrow(coordsHabitatGridCenter)
baseIntensities &lt;- rep(1,numWindows)
numRows &lt;- nrow(habitatGrid)
numCols &lt;- ncol(habitatGrid)

# The log probability density of moving from (1,1) to (1.2, 0.8) 
dbernppLocalACmovement_exp(x = c(1.2, 0.8),
 lowerCoords =lowerCoords,
 upperCoords = upperCoords,
 s =s,
 rate = rate,
 baseIntensities = baseIntensities,
 habitatGrid = habitatGrid, 
 habitatGridLocal = HabWindowsLocal$habitatGrid,
 resizeFactor = HabWindowsLocal$resizeFactor,
 localHabWindowIndices = HabWindowsLocal$localIndices,
 numLocalHabWindows = HabWindowsLocal$numLocalIndices,
 numGridRows = numRows,
 numGridCols = numCols,
 numWindows = numWindows,
 log = TRUE)



</code></pre>

<hr>
<h2 id='dbernppLocalACmovement_normal'>Local evaluation of a Bernoulli point process for activity center movement (normal kernel)</h2><span id='topic+dbernppLocalACmovement_normal'></span><span id='topic+rbernppLocalACmovement_normal'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Bernoulli point process for activity center movement between occasions based on a bivariate normal distribution and local evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernppLocalACmovement_normal(
  x,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  habitatGrid,
  habitatGridLocal,
  resizeFactor = 1,
  localHabWindowIndices,
  numLocalHabWindows,
  numGridRows,
  numGridCols,
  numWindows,
  log = 0
)

rbernppLocalACmovement_normal(
  n,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  habitatGrid,
  habitatGridLocal,
  resizeFactor = 1,
  localHabWindowIndices,
  numLocalHabWindows,
  numGridRows,
  numGridCols,
  numWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_x">x</code></td>
<td>
<p>Vector of x- and y-coordinates of a single spatial point (typically AC location at time t+1) scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_lowercoords">lowerCoords</code>, <code id="dbernppLocalACmovement_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all habitat windows. One row for each window.
Each window should be of size 1x1 (after rescaling if necessary).</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic bivariate normal distribution mean (i.e. the AC location).</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic bivariate normal distribution.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline habitat intensities for all habitat windows.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the order of habitat windows in  <code>lowerCoords</code> and <code>upperCoords</code>. 
When the habitat grid only consists of a single row or column of windows, an additional row or column of dummy indices has to be added because the <code>nimble</code> model code requires a matrix.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_habitatgridlocal">habitatGridLocal</code></td>
<td>
<p>Matrix of rescaled habitat grid cells indices, from localIndices returned by the  <code>getLocalObjects</code> function (</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the  <code>getLocalObjects</code> function to reduce the number of habitat grid cells.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_localhabwindowindices">localHabWindowIndices</code></td>
<td>
<p>Matrix of indices of local habitat windows around each local habitat grid cell (<code>habitatGridLocal</code>), from localIndices returned by the <code>getLocalObjects</code> function.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_numlocalhabwindows">numLocalHabWindows</code></td>
<td>
<p>Vector of numbers of local habitat windows around all habitat grid cells, as returned by the getLocalObjects function (object named <code>numLocalIndices</code>). 
The ith number gives the number of local (original) habitat windows for the ith (rescaled) habitat window.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_numgridrows">numGridRows</code>, <code id="dbernppLocalACmovement_normal_+3A_numgridcols">numGridCols</code></td>
<td>
<p>Numbers of rows and columns of the <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of habitat windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbernppLocalACmovement_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbernppLocalACmovement_normal</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
movement of activity centers between consecutive occasions in open population models.
The distribution assumes that the new individual activity center location (<em>x</em>)
follows an isotropic multivariate normal centered on the previous activity center (<em>s</em>) with standard deviation (<em>sd</em>).
The local evaluation technique is implemented.
</p>


<h3>Value</h3>

<p>The (log) probability density of the observation vector <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang and Cyril Milleret
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035 
</p>
<p>C. Milleret, P. Dupont, C. Bonenfant, H. Brøseth, Ø. Flagstad, C. Sutherland and R. Bischof. 2019. 
A local evaluation of the individual state-space to scale up Bayesian spatial capture-recapture. Ecology and Evolution 9:352-363
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creat habitat grid
habitatGrid &lt;- matrix(c(1:(4^2)), nrow = 4, ncol=4, byrow = TRUE)
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol = 2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# Create habitat windows
lowerCoords &lt;- coordsHabitatGridCenter-0.5
upperCoords &lt;- coordsHabitatGridCenter+0.5
colnames(lowerCoords) &lt;- colnames(upperCoords) &lt;- c("x","y")
# Plot check
plot(lowerCoords[,"y"]~lowerCoords[,"x"],pch=16, xlim=c(0,4), ylim=c(0,4),col="red") 
points(upperCoords[,"y"]~upperCoords[,"x"],col="red",pch=16) 
points(coordsHabitatGridCenter[,"y"]~coordsHabitatGridCenter[,"x"],pch=16) 

# Rescale coordinates 
ScaledLowerCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  lowerCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  upperCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords$coordsDataScaled[,2] &lt;- ScaledUpperCoords$coordsDataScaled[,2] + 1
ScaledLowerCoords$coordsDataScaled[,2] &lt;- ScaledLowerCoords$coordsDataScaled[,2] - 1
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)
# Create local objects 
HabWindowsLocal &lt;- getLocalObjects(habitatMask = habitatMask,
                                   coords = coordsHabitatGridCenter,
                                   dmax=4,
                                   resizeFactor = 1,
                                   plot.check = TRUE
)

s &lt;- c(1, 1) # Currrent activity center location
sd &lt;- 0.1
numWindows &lt;- nrow(coordsHabitatGridCenter)
baseIntensities &lt;- rep(1,numWindows)
numRows &lt;- nrow(habitatGrid)
numCols &lt;- ncol(habitatGrid)

# The log probability density of moving from (1,1) to (1.2, 0.8) 
dbernppLocalACmovement_normal(x = c(1.2, 0.8), lowerCoords, upperCoords, s,
                              sd, baseIntensities, habitatGrid, 
                              HabWindowsLocal$habitatGrid, HabWindowsLocal$resizeFactor,
                              HabWindowsLocal$localIndices, HabWindowsLocal$numLocalIndices,
                              numRows, numCols, numWindows, log = TRUE)


</code></pre>

<hr>
<h2 id='dbernppLocalDetection_normal'>Local evaluation for a Bernoulli point process detection model</h2><span id='topic+dbernppLocalDetection_normal'></span><span id='topic+rbernppLocalDetection_normal'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Bernoulli point process for detection based on a bivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbernppLocalDetection_normal(
  x,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  habitatGridLocal,
  resizeFactor = 1,
  localObsWindowIndices,
  numLocalObsWindows,
  numWindows,
  indicator,
  log = 0
)

rbernppLocalDetection_normal(
  n,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  habitatGridLocal,
  resizeFactor = 1,
  localObsWindowIndices,
  numLocalObsWindows,
  numWindows,
  indicator
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbernppLocalDetection_normal_+3A_x">x</code></td>
<td>
<p>Vector with three elements representing the x- and y-coordinates (x[1:2]), and the corresponding id the detection window (x[3]) of a single spatial point (detection location) scaled to the habitat (see <code>scaleCoordsToHabitatGrid</code>).</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_lowercoords">lowerCoords</code>, <code id="dbernppLocalDetection_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all detection windows. One row for each window.
Each window should be of size 1x1 (after rescaling if necessary).</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic bivariate normal distribution mean (i.e. the AC location).</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the bivariate normal distribution.</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline detection intensities for all detection windows.</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_habitatgridlocal">habitatGridLocal</code></td>
<td>
<p>Matrix of rescaled habitat grid cells indices, as returned by the <code>getLocalObjects</code> function (object named <code>habitatGrid</code>).</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the  <code>getLocalObjects</code> function to reduce the number of habitat grid cells.</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_localobswindowindices">localObsWindowIndices</code></td>
<td>
<p>Matrix of indices of local observation windows around each local habitat grid cell (habitatGridLocal), from localIndices returned by the <code>getLocalObjects</code> function.</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_numlocalobswindows">numLocalObsWindows</code></td>
<td>
<p>Vector of numbers of local observation windows around all habitat grid cells, as returned by the getLocalObjects function (object named <code>numLocalIndices</code>). 
The ith number gives the number of local (original) observation windows for the ith (rescaled) habitat window.</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of detection windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbernppLocalDetection_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbernppDetection_normal</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
Bernoulli observations (<em>x</em>) of a single individual in continuous space over a set of detection windows defined by their upper and lower
coordinates (<em>lowerCoords,upperCoords</em>). The distribution assumes that an individual’s detection probability 
follows an isotropic multivariate normal centered on the individual's activity center (<em>s</em>) with standard deviation (<em>sd</em>).
The local evaluation approach is implemented.
</p>


<h3>Value</h3>

<p>The (log) probability density of the observation vector <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang and Cyril Milleret
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035 
</p>
<p>C. Milleret, P. Dupont, C. Bonenfant, H. Brøseth, Ø. Flagstad, C. Sutherland and R. Bischof. 2019. 
A local evaluation of the individual state-space to scale up Bayesian spatial capture-recapture. Ecology and Evolution 9:352-363
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create habitat grid
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol = 2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# Create observation windows
lowerCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(2, 2, 3, 2, 2, 3, 3, 3), nrow = 4, byrow = TRUE)  
colnames(lowerCoords) &lt;- colnames(upperCoords) &lt;- c("x","y")
# Plot check
plot(coordsHabitatGridCenter[,"y"]~coordsHabitatGridCenter[,"x"],pch=16) 
points(lowerCoords[,"y"]~lowerCoords[,"x"],col="red",pch=16) 
points(upperCoords[,"y"]~upperCoords[,"x"],col="red",pch=16) 
#'
s &lt;- c(1, 1)
sd &lt;- 0.1
baseIntensities &lt;- c(1:4)
windowIndex &lt;- 4
numPoints &lt;- 1
numWindows &lt;- 4
indicator &lt;- 1

# Rescale coordinates
ScaledLowerCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  lowerCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  upperCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords$coordsDataScaled[,2] &lt;- ScaledUpperCoords$coordsDataScaled[,2] + 1.5
ScaledLowerCoords$coordsDataScaled[,2] &lt;- ScaledLowerCoords$coordsDataScaled[,2] - 1.5
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)
# Create local objects 
ObsWindowsLocal &lt;- getLocalObjects(habitatMask = habitatMask,
                                   coords = ScaledLowerCoords$coordsDataScaled,
                                   dmax=3,
                                   resizeFactor = 1,
                                   plot.check = TRUE
)
x &lt;- c(1.1, 1.2)
windowIndex &lt;- getWindowIndex(curCoords = x,
                              lowerCoords = ScaledLowerCoords$coordsDataScaled,
                              upperCoords =ScaledUpperCoords$coordsDataScaled)
x &lt;- c(x, windowIndex)
dbernppLocalDetection_normal(x, ScaledLowerCoords$coordsDataScaled,
                             ScaledUpperCoords$coordsDataScaled,
                             s, sd, baseIntensities,  
                             ObsWindowsLocal$habitatGrid, ObsWindowsLocal$resizeFactor,
                             ObsWindowsLocal$localIndices,ObsWindowsLocal$numLocalIndices,
                             numWindows, indicator, log = TRUE)
</code></pre>

<hr>
<h2 id='dbinom_vector'>Vectorized binomial distribution</h2><span id='topic+dbinom_vector'></span><span id='topic+rbinom_vector'></span>

<h3>Description</h3>

<p>The <code>dbinom_vector</code> distribution is a vectorized version of the binomial distribution.
It can be used to model a vector of binomial realizations. NB: using the vectorized version 
is beneficial only when the entire joint likelihood of the vector of binomial realizations (x)
is calculated simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbinom_vector(x, size, prob, log = 0)

rbinom_vector(n = 1, size, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbinom_vector_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="dbinom_vector_+3A_size">size</code></td>
<td>
<p>Vector of number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="dbinom_vector_+3A_prob">prob</code></td>
<td>
<p>Vector of success probabilities on each trial</p>
</td></tr>
<tr><td><code id="dbinom_vector_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbinom_vector_+3A_n">n</code></td>
<td>
<p>Number of observations. Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log-likelihood value associated with the vector of binomial observations.
</p>


<h3>Author(s)</h3>

<p>Pierre Dupont
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define vectorized model code
code &lt;- nimbleCode({
    p ~ dunif(0,1)
    p_vector[1:J] &lt;- p
    y[1:J] ~ dbinom_vector(size = trials[1:J],
                           prob = p_vector[1:J])
})
 
## simulate binomial data
J &lt;- 1000
trials &lt;- sample(x = 10, size = J, replace = TRUE)
y &lt;- rbinom_vector(J, size = trials, prob = 0.21)
 
constants &lt;- list(J = J, trials = trials)
 
data &lt;- list(y = y)
 
inits &lt;- list(p = 0.5)
 
## create NIMBLE model object
Rmodel &lt;- nimbleModel(code, constants, data, inits)
 
## use model object for MCMC, etc.

</code></pre>

<hr>
<h2 id='dbinomLocal_exp'>Local evaluation of a binomial SCR observation process</h2><span id='topic+dbinomLocal_exp'></span><span id='topic+rbinomLocal_exp'></span>

<h3>Description</h3>

<p>The <code>dbinomLocal_exp</code> distribution is a NIMBLE custom distribution which can be used to model 
and simulate binomial observations (x) of a single individual over a set of traps defined by their coordinates <em>trapCoords</em>
the distribution assumes that an individual’s detection probability at any trap follows an exponential function of the distance between 
the individual's activity center (s) and the trap location. All coordinates (<code>s</code> and <code>trapCoords</code>) should be scaled to the habitat (see <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbinomLocal_exp(
  x,
  detNums = -999,
  detIndices,
  size,
  p0 = -999,
  p0Traps,
  rate,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0,
  log = 0
)

rbinomLocal_exp(
  n = 1,
  detNums = -999,
  detIndices,
  size,
  p0 = -999,
  p0Traps,
  rate,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbinomLocal_exp_+3A_x">x</code></td>
<td>
<p>Vector of individual detection frequencies. This argument can be provided in two formats: (i) with the <em>y</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>; (ii) with the
<em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code> Note that when the random generation functionality is used (rbinomLocal_normal), only the yCombined format can be used. 
The  <em>yCombined</em>  object combines <em>detNums</em>, <em>x</em>, and <em>detIndices</em> (in that order). When such consolidated 
representation of the detection data x is used, <em>detIndices</em> and <em>detNums</em> arguments should not be specified.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_detnums">detNums</code></td>
<td>
<p>Number of traps with at least one detection recorded in <em>x</em>; from the <em>detNums</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when the <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code>) is provided as <em>x</em> and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_detindices">detIndices</code></td>
<td>
<p>Vector of indices of traps where the detections in <em>x</em> were recorded; from the <em>detIndices</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when x is provided as the  <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code> ) and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_size">size</code></td>
<td>
<p>Vector of the number of trials (zero or more) for each trap (<em>trapCoords</em>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_p0">p0</code></td>
<td>
<p>Baseline detection probability (scalar) used in the half-normal detection function. For trap-specific baseline detection probabilities use argument <em>p0Traps</em> (vector) instead.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_p0traps">p0Traps</code></td>
<td>
<p>Vector of baseline detection probabilities for each trap used in the half-normal detection function. When <em>p0Traps</em> is used, <em>p0</em> should not be provided.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_rate">rate</code></td>
<td>
<p>Rate parameter of the exponential detection function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_s">s</code></td>
<td>
<p>Individual activity center x- and y-coordinates scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_trapcoords">trapCoords</code></td>
<td>
<p>Matrix of x- and y-coordinates of all traps scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_localtrapsindices">localTrapsIndices</code></td>
<td>
<p>Matrix of indices of local traps around each habitat grid cell, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_localtrapsnum">localTrapsNum</code></td>
<td>
<p>Vector of numbers of local traps around all habitat grid cells, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function to reduce the number of habitat grid cells to retrieve local traps for.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of local habitat grid cell indices, from <em>habitatGrid</em> returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_lengthycombined">lengthYCombined</code></td>
<td>
<p>The length of the x argument when the (<em>yCombined</em>) format of the detection data is provided;  from the <em>lengthYCombined</em> object returned by <code><a href="#topic+getSparseY">getSparseY</a></code></p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbinomLocal_exp_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbinomLocal_exp</code> distribution incorporates three features to increase computation efficiency (see Turek et al., 2021 &lt;doi.org/10.1002/ecs2.3385&gt;  for more details):
</p>

<ol>
<li><p> A local evaluation of the detection probability calculation (see Milleret et al., 2019 &lt;doi:10.1002/ece3.4751&gt; for more details)
</p>
</li>
<li><p> A sparse matrix representation (<em>x</em>, <em>detIndices</em> and <em>detNums</em>) of the observation data to reduce the size of objects to be processed.
</p>
</li>
<li><p> An indicator (<em>indicator</em>) to shortcut calculations for individuals unavailable for detection.
</p>
</li></ol>

<p>The <code>dbinomLocal_exp</code> distribution requires x- and y- detector coordinates (<em>trapCoords</em>) to be scaled to the habitat grid (<em>habitatGrid</em>) using the (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code> function.)
</p>
<p>When the aim is to simulate detection data: 
</p>

<ol>
<li> <p><em>x</em> should be provided using the <em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>, 
</p>
</li>
<li><p> arguments <em>detIndices</em> and <em>detNums</em> should not be provided, 
</p>
</li>
<li><p> argument <em>lengthYCombined</em> should be provided using the <em>lengthYCombined</em> object as returned by  <code><a href="#topic+getSparseY">getSparseY</a></code>.
</p>
</li></ol>



<h3>Value</h3>

<p>The log-likelihood value associated with the vector of detections, given the location of the activity center (s),
and the exponential detection function : <code class="reqn">p = p0 * exp(- rate * d)</code>.
</p>


<h3>Author(s)</h3>

<p>Soumen Dey
</p>


<h3>References</h3>

<p>Dey, S., Bischof, R., Dupont, P. P. A., &amp; Milleret, C. (2022). Does the punishment fit the crime? Consequences and diagnosis of misspecified detection functions in Bayesian spatial capture–recapture modeling. Ecology and Evolution, 12, e8600. https://doi.org/10.1002/ece3.8600
</p>


<h3>Examples</h3>

<pre><code class='language-R'># I. DATA SET UP 
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol=2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# CREATE OBSERVATION WINDOWS
trapCoords &lt;- matrix(c(1.5, 1.5, 2.5, 1.5, 1.5, 2.5, 2.5, 2.5), nrow = 4, byrow = TRUE)
colnames(trapCoords) &lt;- c("x","y")
# PLOT CHECK
plot(coordsHabitatGridCenter[,"y"]~coordsHabitatGridCenter[,"x"],pch=16) 
points(trapCoords[,"y"]~trapCoords[,"x"],col="red",pch=16) 

# PARAMETERS
p0 &lt;- 0.3
rate &lt;- 1/1.5
indicator &lt;- 1 
# WE CONSIDER 2 INDIVIDUALS
y &lt;- matrix(c(0, 1, 1, 0,
              0, 1, 0, 1),ncol=4,nrow=2)
s &lt;- matrix(c(0.5, 1,
              1.6, 2.3),ncol=2,nrow=2)

# RESCALE COORDINATES 
ScaledtrapCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  trapCoords,
                                             coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledtrapCoords&lt;- ScaledtrapCoords$coordsDataScaled
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)


# CREATE LOCAL OBJECTS 
TrapLocal &lt;- getLocalObjects(habitatMask = habitatMask,
                                   coords = ScaledtrapCoords,
                                   dmax=2.5,
                                   resizeFactor = 1,
                                   plot.check = TRUE
)

# GET SPARSE MATRIX 
SparseY &lt;- getSparseY(y)

# II. USING THE DENSITY FUNCTION 
 # WE TAKE THE FIRST INDIVIDUAL
i=1
  # OPTION 1: USING THE RANDOM GENERATION FUNCTIONNALITY 
dbinomLocal_exp(x=SparseY$y[i,,1],
                   detNums=SparseY$detNums[i],
                   detIndices=SparseY$detIndices[i,,1],
                   size=rep(1,4),
                   p0 = p0,
                   rate= rate, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator)
                                                                
  # OPTION 2: USING RANDOM GENERATION FUNCTIONNALITY 
  # WE DO NOT PROVIDE THE detNums AND detIndices ARGUMENTS
dbinomLocal_exp(x=SparseY$yCombined[i,,1],
                   size=rep(1,4),
                   p0 = p0,
                   rate= rate, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator,
                   lengthYCombined = SparseY$lengthYCombined)

# III. USING THE RANDOM GENERATION FUNCTION 
rbinomLocal_exp(n=1,
                   size=rep(1,4),
                   p0 = p0,
                   rate= rate, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator,
                   lengthYCombined = SparseY$lengthYCombined)

</code></pre>

<hr>
<h2 id='dbinomLocal_normal'>Local evaluation of a binomial SCR detection process</h2><span id='topic+dbinomLocal_normal'></span><span id='topic+rbinomLocal_normal'></span>

<h3>Description</h3>

<p>The <code>dbinomLocal_normal</code> distribution is a NIMBLE custom distribution which can be used to model 
and simulate binomial observations (x) of a single individual over a set of traps defined by their coordinates <em>trapCoords</em>
the distribution assumes that an individual’s detection probability at any trap follows a half-normal function of the distance between 
the individual's activity center (s) and the trap location. All coordinates (<code>s</code> and <code>trapCoords</code>) should be scaled to the habitat (see <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbinomLocal_normal(
  x,
  detNums = -999,
  detIndices,
  size,
  p0 = -999,
  p0Traps,
  sigma,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0,
  log = 0
)

rbinomLocal_normal(
  n = 1,
  detNums = -999,
  detIndices,
  size,
  p0 = -999,
  p0Traps,
  sigma,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbinomLocal_normal_+3A_x">x</code></td>
<td>
<p>Vector of individual detection frequencies. This argument can be provided in two formats: (i) with the <em>y</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>; (ii) with the
<em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code> Note that when the random generation functionality is used (rbinomLocal_normal), only the yCombined format can be used. 
The  <em>yCombined</em>  object combines <em>detNums</em>, <em>x</em>, and <em>detIndices</em> (in that order). When such consolidated 
representation of the detection data x is used, <em>detIndices</em> and <em>detNums</em> arguments should not be specified.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_detnums">detNums</code></td>
<td>
<p>Number of traps with at least one detection recorded in <em>x</em>; from the <em>detNums</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when the <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code>) is provided as <em>x</em> and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_detindices">detIndices</code></td>
<td>
<p>Vector of indices of traps where the detections in <em>x</em> were recorded; from the <em>detIndices</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when x is provided as the  <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code> ) and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_size">size</code></td>
<td>
<p>Vector of the number of trials (zero or more) for each trap (<em>trapCoords</em>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_p0">p0</code></td>
<td>
<p>Baseline detection probability (scalar) used in the half-normal detection function. For trap-specific baseline detection probabilities use argument <em>p0Traps</em> (vector) instead.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_p0traps">p0Traps</code></td>
<td>
<p>Vector of baseline detection probabilities for each trap used in the half-normal detection function. When <em>p0Traps</em> is used, <em>p0</em> should not be provided.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of the half-normal detection function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_s">s</code></td>
<td>
<p>Individual activity center x- and y-coordinates scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_trapcoords">trapCoords</code></td>
<td>
<p>Matrix of x- and y-coordinates of all traps scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_localtrapsindices">localTrapsIndices</code></td>
<td>
<p>Matrix of indices of local traps around each habitat grid cell, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_localtrapsnum">localTrapsNum</code></td>
<td>
<p>Vector of numbers of local traps around all habitat grid cells, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function to reduce the number of habitat grid cells to retrieve local traps for.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of local habitat grid cell indices, from <em>habitatGrid</em> returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_lengthycombined">lengthYCombined</code></td>
<td>
<p>The length of the x argument when the (<em>yCombined</em>) format of the detection data is provided;  from the <em>lengthYCombined</em> object returned by <code><a href="#topic+getSparseY">getSparseY</a></code></p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dbinomLocal_normal</code> distribution incorporates three features to increase computation efficiency (see Turek et al., 2021 &lt;doi.org/10.1002/ecs2.3385&gt;  for more details):
</p>

<ol>
<li><p> A local evaluation of the detection probability calculation (see Milleret et al., 2019 &lt;doi:10.1002/ece3.4751&gt; for more details)
</p>
</li>
<li><p> A sparse matrix representation (<em>x</em>, <em>detIndices</em> and <em>detNums</em>) of the observation data to reduce the size of objects to be processed.
</p>
</li>
<li><p> An indicator (<em>indicator</em>) to shortcut calculations for individuals unavailable for detection.
</p>
</li></ol>

<p>The <code>dbinomLocal_normal</code> distribution requires x- and y- detector coordinates (<em>trapCoords</em>) and activity centers coordinates (<em>s</em>) to be scaled to the habitat grid (<em>habitatGrid</em>) using the (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code> function.)
</p>
<p>When the aim is to simulate detection data: 
</p>

<ol>
<li> <p><em>x</em> should be provided using the <em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>, 
</p>
</li>
<li><p> arguments <em>detIndices</em> and <em>detNums</em> should not be provided, 
</p>
</li>
<li><p> argument <em>lengthYCombined</em> should be provided using the <em>lengthYCombined</em> object as returned by  <code><a href="#topic+getSparseY">getSparseY</a></code>.
</p>
</li></ol>



<h3>Value</h3>

<p>The log-likelihood value associated with the vector of detections, given the location of the activity center (s),
and the half-normal detection function : <code class="reqn">p = p0 * exp(-d^2 / 2 \sigma^2)</code>.
</p>


<h3>Author(s)</h3>

<p>Cyril Milleret, Soumen Dey
</p>


<h3>Examples</h3>

<pre><code class='language-R'># I. DATA SET UP 
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol=2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# CREATE OBSERVATION WINDOWS
trapCoords &lt;- matrix(c(1.5, 1.5, 2.5, 1.5, 1.5, 2.5, 2.5, 2.5), nrow = 4, byrow = TRUE)
colnames(trapCoords) &lt;- c("x","y")
# PLOT CHECK
plot(coordsHabitatGridCenter[,"y"]~coordsHabitatGridCenter[,"x"],pch=16) 
points(trapCoords[,"y"]~trapCoords[,"x"],col="red",pch=16) 

# PARAMETERS
p0 &lt;- 0.2
sigma &lt;- 2
indicator &lt;- 1 
# WE CONSIDER 2 INDIVIDUALS
y &lt;- matrix(c(0, 1, 1, 0,
              0, 1, 0, 1),ncol=4,nrow=2)
s &lt;- matrix(c(0.5, 1,
              1.6, 2.3),ncol=2,nrow=2)

# RESCALE COORDINATES 
ScaledtrapCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  trapCoords,
                                             coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledtrapCoords&lt;- ScaledtrapCoords$coordsDataScaled
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)


# CREATE LOCAL OBJECTS 
TrapLocal &lt;- getLocalObjects(habitatMask = habitatMask,
                                   coords = ScaledtrapCoords,
                                   dmax=2.5,
                                   resizeFactor = 1,
                                   plot.check = TRUE
)

# GET SPARSE MATRIX 
SparseY &lt;- getSparseY(y)

# II. USING THE DENSITY FUNCTION 
 # WE TAKE THE FIRST INDIVIDUAL
i=1
  # OPTION 1: USING THE RANDOM GENERATION FUNCTIONNALITY 
dbinomLocal_normal(x=SparseY$y[i,,1],
                   detNums=SparseY$detNums[i],
                   detIndices=SparseY$detIndices[i,,1],
                   size=rep(1,4),
                   p0 = p0,
                   sigma= sigma, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator)
                                                                
  # OPTION 2: USING RANDOM GENERATION FUNCTIONNALITY 
  # WE DO NOT PROVIDE THE detNums AND detIndices ARGUMENTS
dbinomLocal_normal(x=SparseY$yCombined[i,,1],
                   size=rep(1,4),
                   p0 = p0,
                   sigma= sigma, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator,
                   lengthYCombined = SparseY$lengthYCombined)

# III. USING THE RANDOM GENERATION FUNCTION 
rbinomLocal_normal(n=1,
                   size=rep(1,4),
                   p0 = p0,
                   sigma= sigma, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator,
                   lengthYCombined = SparseY$lengthYCombined)

</code></pre>

<hr>
<h2 id='dbinomLocal_normalPlateau'>Local evaluation of a binomial SCR observation process</h2><span id='topic+dbinomLocal_normalPlateau'></span><span id='topic+rbinomLocal_normalPlateau'></span>

<h3>Description</h3>

<p>The <code>dbinomLocal_normalPlateau</code> distribution is a NIMBLE custom distribution which can be used to model 
and simulate binomial observations (x) of a single individual over a set of traps defined by their coordinates <em>trapCoords</em>
the distribution assumes that an individual’s detection probability at any trap follows a half-normal plateau function of the distance between 
the individual's activity center (s) and the trap location. With the half-normal plateau function, detection probability remains constant with value 
p0 for a plateau of width w before declining with scale sigma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbinomLocal_normalPlateau(
  x,
  detNums = -999,
  detIndices,
  size,
  p0 = -999,
  p0Traps,
  sigma,
  w = 2,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0,
  log = 0
)

rbinomLocal_normalPlateau(
  n = 1,
  detNums = -999,
  detIndices,
  size,
  p0 = -999,
  p0Traps,
  sigma,
  w = 2,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_x">x</code></td>
<td>
<p>Vector of individual detection frequencies. This argument can be provided in two formats: (i) with the <em>y</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>; (ii) with the
<em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code> Note that when the random generation functionality is used (rbinomLocal_normal), only the yCombined format can be used. 
The  <em>yCombined</em>  object combines <em>detNums</em>, <em>x</em>, and <em>detIndices</em> (in that order). When such consolidated 
representation of the detection data x is used, <em>detIndices</em> and <em>detNums</em> arguments should not be specified.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_detnums">detNums</code></td>
<td>
<p>Number of traps with at least one detection recorded in <em>x</em>; from the <em>detNums</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when the <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code>) is provided as <em>x</em> and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_detindices">detIndices</code></td>
<td>
<p>Vector of indices of traps where the detections in <em>x</em> were recorded; from the <em>detIndices</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when x is provided as the  <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code> ) and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_size">size</code></td>
<td>
<p>Vector of the number of trials (zero or more) for each trap (<em>trapCoords</em>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_p0">p0</code></td>
<td>
<p>Baseline detection probability (scalar) used in the half-normal detection function. For trap-specific baseline detection probabilities use argument <em>p0Traps</em> (vector) instead.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_p0traps">p0Traps</code></td>
<td>
<p>Vector of baseline detection probabilities for each trap used in the half-normal detection function. When <em>p0Traps</em> is used, <em>p0</em> should not be provided.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of the half-normal detection function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_w">w</code></td>
<td>
<p>Length of plateau of the half-normal plateau detection function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_s">s</code></td>
<td>
<p>Individual activity center x- and y-coordinates scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_trapcoords">trapCoords</code></td>
<td>
<p>Matrix of x- and y-coordinates of all traps scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_localtrapsindices">localTrapsIndices</code></td>
<td>
<p>Matrix of indices of local traps around each habitat grid cell, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_localtrapsnum">localTrapsNum</code></td>
<td>
<p>Vector of numbers of local traps around all habitat grid cells, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function to reduce the number of habitat grid cells to retrieve local traps for.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of local habitat grid cell indices, from <em>habitatGrid</em> returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_lengthycombined">lengthYCombined</code></td>
<td>
<p>The length of the x argument when the (<em>yCombined</em>) format of the detection data is provided;  from the <em>lengthYCombined</em> object returned by <code><a href="#topic+getSparseY">getSparseY</a></code></p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dbinomLocal_normalPlateau_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All coordinates (<code>s</code> and <code>trapCoords</code>) should be scaled to the habitat (see <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>)
</p>
<p>The <code>dbinomLocal_normalPlateau</code> distribution incorporates three features to increase computation efficiency (see Turek et al., 2021 &lt;doi.org/10.1002/ecs2.3385&gt;  for more details):
</p>

<ol>
<li><p> A local evaluation of the detection probability calculation (see Milleret et al., 2019 &lt;doi:10.1002/ece3.4751&gt; for more details)
</p>
</li>
<li><p> A sparse matrix representation (<em>x</em>, <em>detIndices</em> and <em>detNums</em>) of the observation data to reduce the size of objects to be processed.
</p>
</li>
<li><p> An indicator (<em>indicator</em>) to shortcut calculations for individuals unavailable for detection.
</p>
</li></ol>

<p>The <code>dbinomLocal_normalPlateau</code> distribution requires x- and y- detector coordinates (<em>trapCoords</em>) to be scaled to the habitat grid (<em>habitatGrid</em>) using the (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code> function.)
</p>
<p>When the aim is to simulate detection data: 
</p>

<ol>
<li> <p><em>x</em> should be provided using the <em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>, 
</p>
</li>
<li><p> arguments <em>detIndices</em> and <em>detNums</em> should not be provided, 
</p>
</li>
<li><p> argument <em>lengthYCombined</em> should be provided using the <em>lengthYCombined</em> object as returned by  <code><a href="#topic+getSparseY">getSparseY</a></code>.
</p>
</li></ol>



<h3>Value</h3>

<p>The log-likelihood value associated with the vector of detections, given the location of the activity center (s),
and the half-normal plateau detection function : <code class="reqn">p = p0</code> when <em>d &lt; w</em> and <code class="reqn">p = p0 * exp(-(d-w)^2 / \sigma^2)</code> when <em>d &gt;= w</em>.
</p>


<h3>Author(s)</h3>

<p>Soumen Dey
</p>


<h3>References</h3>

<p>Dey, S., Bischof, R., Dupont, P. P. A., &amp; Milleret, C. (2022). Does the punishment fit the crime? Consequences and diagnosis of misspecified detection functions in Bayesian spatial capture–recapture modeling. Ecology and Evolution, 12, e8600. https://doi.org/10.1002/ece3.8600
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A user friendly vignette is also available on github: 
# https://github.com/nimble-dev/nimbleSCR/blob/master/nimbleSCR/vignettes/
# Vignette name: Fit_with_dbinomLocal_normalPlateau_and_HomeRangeAreaComputation.rmd

# I. DATA SET UP 
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol=2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# CREATE OBSERVATION WINDOWS
trapCoords &lt;- matrix(c(1.5, 1.5, 2.5, 1.5, 1.5, 2.5, 2.5, 2.5), nrow = 4, byrow = TRUE)
colnames(trapCoords) &lt;- c("x","y")
# PLOT CHECK
plot(coordsHabitatGridCenter[,"y"]~coordsHabitatGridCenter[,"x"],pch=16) 
points(trapCoords[,"y"]~trapCoords[,"x"],col="red",pch=16) 

# PARAMETERS
p0 &lt;- 0.25
sigma &lt;- 1
w &lt;- 1.5
indicator &lt;- 1 
# WE CONSIDER 2 INDIVIDUALS
y &lt;- matrix(c(0, 1, 1, 0,
              0, 1, 0, 1),ncol=4,nrow=2)
s &lt;- matrix(c(0.5, 1,
              1.6, 2.3),ncol=2,nrow=2)

# RESCALE COORDINATES 
ScaledtrapCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  trapCoords,
                                             coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledtrapCoords&lt;- ScaledtrapCoords$coordsDataScaled
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)


# CREATE LOCAL OBJECTS 
TrapLocal &lt;- getLocalObjects(habitatMask = habitatMask,
                                   coords = ScaledtrapCoords,
                                   dmax=2.5,
                                   resizeFactor = 1,
                                   plot.check = TRUE
)

# GET SPARSE MATRIX 
SparseY &lt;- getSparseY(y)

# II. USING THE DENSITY FUNCTION 
 # WE TAKE THE FIRST INDIVIDUAL
i=1
  # OPTION 1: USING THE RANDOM GENERATION FUNCTIONNALITY 
dbinomLocal_normalPlateau(x=SparseY$y[i,,1],
                   detNums=SparseY$detNums[i],
                   detIndices=SparseY$detIndices[i,,1],
                   size=rep(1,4),
                   p0 = p0,
                   sigma= sigma, 
                   w = w,
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator)
                                                                
  # OPTION 2: USING RANDOM GENERATION FUNCTIONNALITY 
  # WE DO NOT PROVIDE THE detNums AND detIndices ARGUMENTS
dbinomLocal_normalPlateau(x=SparseY$yCombined[i,,1],
                   size=rep(1,4),
                   p0 = p0,
                   sigma= sigma, 
                   w = w,
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator,
                   lengthYCombined = SparseY$lengthYCombined)

# III. USING THE RANDOM GENERATION FUNCTION 
rbinomLocal_normalPlateau(n=1,
                   size=rep(1,4),
                   p0 = p0,
                   sigma= sigma, 
                   w = w,
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator,
                   lengthYCombined = SparseY$lengthYCombined)

</code></pre>

<hr>
<h2 id='dcatState1Alive1Dead'>Density and random generation of a categorical distribution describing state transition with one alive and one dead states.</h2><span id='topic+dcatState1Alive1Dead'></span><span id='topic+rcatState1Alive1Dead'></span>

<h3>Description</h3>

<p>The <code>dcatState1Alive1Dead</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
individual state transition. This function can be used to model transitions from one alive and one dead state. 
If z_i,t = 1, individual i can be recruited (transition to state 2) with probability prob1To2_t, so z_i,t+1 ~ dcat(1- prob1To2_t, prob1To2_t, 0,0 , 0) where prob1To2_t represent the probability of an unborn individual to be recruited.
If z_i,t = 2, individual i can die and transition to z_i,t+1=3 with probability prob2To3, or survive with probability 1-prob2To3
Individuals in dead states (z_i,t = 3 ) remain in that state with probability 1, the absorbing state.
If transition probabilities are spatially variable, a probability vector containing the transition probability value in each habitat window can be provided using the &quot;Hab&quot; arguments (e.g. prob1To2Hab,prob2To3Hab).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcatState1Alive1Dead(
  x,
  z,
  prob1To2 = -999,
  prob1To2Hab,
  prob2To3 = -999,
  prob2To3Hab,
  s,
  habitatGrid,
  log = 0
)

rcatState1Alive1Dead(
  n,
  z,
  prob1To2 = -999,
  prob1To2Hab,
  prob2To3 = -999,
  prob2To3Hab,
  s,
  habitatGrid
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcatState1Alive1Dead_+3A_x">x</code></td>
<td>
<p>Scalar, individual state z_i,t+1.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_z">z</code></td>
<td>
<p>Scalar, initial individual state z_i,t.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_prob1to2">prob1To2</code></td>
<td>
<p>scalar, probability to transition from state 1 to 2.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_prob1to2hab">prob1To2Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 3.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_prob2to3">prob2To3</code></td>
<td>
<p>scalar, probability to transition from state 2 to 3.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_prob2to3hab">prob2To3Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 3.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates corresponding to the AC location of the individual. Used to extract transition spatially-explicit probabilities when they are provided.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the 
order of habitat windows in <code>prob1To2Hab</code>, <code>prob2To3Hab</code> and in <code>lowerCoords</code>  and <code>upperCoords</code> as used in the <code>dbernppAC</code> function.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.
<code>dcatState1Alive1Dead</code> gives the (log) probability density of <code>x</code>. 
<code>rcatState1Alive2Dead</code> gives a randomly generated individual states conditional on the initial state <code>z</code>.</p>
</td></tr>
<tr><td><code id="dcatState1Alive1Dead_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cyril Milleret
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the distribution in R
z &lt;- 2
prob1To2 &lt;- 0.2
prob2To3 &lt;- 0.7

lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)  
logIntensities &lt;- log(rep(1,4))
logSumIntensity &lt;- log(sum(c(1:4))) 
habitatGrid &lt;- matrix(c(1:4), nrow = 2, byrow = TRUE)
numGridRows &lt;- nrow(habitatGrid)
numGridCols &lt;- ncol(habitatGrid)
s &lt;- rbernppAC(n=1, lowerCoords, upperCoords, logIntensities, logSumIntensity, 
               habitatGrid, numGridRows, numGridCols)

## No spatial mortality 
zPlusOne &lt;- rcatState1Alive1Dead( z = z
                                 , prob1To2 = prob1To2
                                 , prob2To3 = prob2To3
                                 , s = s
                                 , habitatGrid = habitatGrid)
zPlusOne     

dcatState1Alive1Dead(  x = zPlusOne
                     , z = z
                     , prob1To2 = prob1To2
                     , prob2To3 = prob2To3
                     , s = s
                     , habitatGrid = habitatGrid)
    
##  With spatial mortality
prob2To3Hab &lt;- c(0.60, 0.70, 0.74, 0.65)
prob1To2Hab &lt;- c(0.4,0.5,0.1,0.3)
zPlusOne &lt;- rcatState1Alive1Dead( z = z
                                , prob1To2Hab = prob1To2Hab
                                , prob2To3Hab = prob2To3Hab
                                , s = s
                                , habitatGrid = habitatGrid)
zPlusOne    
dcatState1Alive1Dead(  x = zPlusOne
                     , z = z
                     , prob1To2Hab = prob1To2Hab
                     , prob2To3Hab = prob2To3Hab
                     , s = s
                     , habitatGrid = habitatGrid)





</code></pre>

<hr>
<h2 id='dcatState1Alive2Dead'>Density and random generation of a categorical distribution describing state transition with one alive and two dead states.</h2><span id='topic+dcatState1Alive2Dead'></span><span id='topic+rcatState1Alive2Dead'></span>

<h3>Description</h3>

<p>The <code>dcatState1Alive2Dead</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
individual state transition. This function can be used to model transitions from one alive and two dead states. 
If z_i,t = 1, individual i can be recruited (transition to state 2) with probability prob1To2_t, so z_i,t+1 ~ dcat(1- prob1To2_t, prob1To2_t, 0,0 , 0) where prob1To2_t represent the probability of an unborn individual to be recruited.
If z_i,t = 2, individual i can die from one cause of mortality (e.g. culling) and transition to z_i,t+1=3 with probability prob2To3, or die from another cause with probability prob2To4 z_i,t+1=4. 
If the individual does not die it can survive and remain in state 2 with probability (1-(prob2To3+prob2To4)). 
Individuals in dead states (z_i,t = 3 or 4) transition to z_i,t+1 = 4, the absorbing state, with probability 1.
If transition probabilities are spatially variable, a probability vector containing the transition probability value in each habitat window can be provided using the &quot;Hab&quot; arguments (e.g. prob1To2Hab,prob2To3Hab).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcatState1Alive2Dead(
  x,
  z,
  prob1To2 = -999,
  prob1To2Hab,
  prob2To3 = -999,
  prob2To3Hab,
  prob2To4 = -999,
  prob2To4Hab,
  s,
  habitatGrid,
  log = 0
)

rcatState1Alive2Dead(
  n,
  z,
  prob1To2 = -999,
  prob1To2Hab,
  prob2To3 = -999,
  prob2To3Hab,
  prob2To4 = -999,
  prob2To4Hab,
  s,
  habitatGrid
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcatState1Alive2Dead_+3A_x">x</code></td>
<td>
<p>Scalar, individual state z_i,t+1.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_z">z</code></td>
<td>
<p>Scalar, initial individual state z_i,t.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_prob1to2">prob1To2</code></td>
<td>
<p>scalar, probability to transition from state 1 to 2.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_prob1to2hab">prob1To2Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 3.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_prob2to3">prob2To3</code></td>
<td>
<p>scalar, probability to transition from state 2 to 3.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_prob2to3hab">prob2To3Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 3.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_prob2to4">prob2To4</code></td>
<td>
<p>scalar, probability to transition from state 2 to 4.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_prob2to4hab">prob2To4Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 4.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates corresponding to the AC location of the individual. Used to extract transition spatially-explicit probabilities when they are provided.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the 
order of habitat windows in <code>prob1To2Hab</code>, <code>prob2To3Hab</code> and in <code>lowerCoords</code>  and <code>upperCoords</code> as used in the <code>dbernppAC</code> function.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dcatState1Alive2Dead_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dcatState1Alive2Dead</code> gives the (log) probability density of <code>x</code>. 
<code>rcatState1Alive2Dead</code> gives a randomly generated individual states conditional on the initial state <code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Cyril Milleret
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the distribution in R

z &lt;- 2
prob1To2 &lt;- 0.2
prob2To3 &lt;- 0.4
prob2To4 &lt;- 0.1

lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)  
logIntensities &lt;- log(rep(1,4))
logSumIntensity &lt;- log(sum(c(1:4))) 
habitatGrid &lt;- matrix(c(1:4), nrow = 2, byrow = TRUE)
numGridRows &lt;- nrow(habitatGrid)
numGridCols &lt;- ncol(habitatGrid)
s &lt;- rbernppAC(n=1, lowerCoords, upperCoords, logIntensities, logSumIntensity, 
                 habitatGrid, numGridRows, numGridCols)

## No spatial mortality 
zPlusOne &lt;- rcatState1Alive2Dead( z = z
                                 , prob1To2 = prob1To2
                                 , prob2To3 = prob2To3
                                 , prob2To4 = prob2To4
                                 , s = s
                                 , habitatGrid = habitatGrid)
   
dcatState1Alive2Dead(  x = zPlusOne
                     , z = z
                     , prob1To2 = prob1To2
                     , prob2To3 = prob2To3
                     , prob2To4 = prob2To4
                     , s = s
                     , habitatGrid = habitatGrid)
     
##  With spatial mortality
prob2To3Hab &lt;- c(0.10, 0.20, 0.15, 0.30)
prob2To4Hab &lt;- c(0.13, 0.21, 0.12, 0.08)
phiSpatial &lt;- 1-(prob2To3Hab+prob2To4Hab)
zPlusOne &lt;- rcatState1Alive2Dead( z = z
                                 , prob1To2Hab = prob1To2Hab
                                 , prob2To3Hab =  prob2To3Hab
                                 , prob2To4Hab = prob2To4Hab
                                 , s = s
                                 , habitatGrid = habitatGrid)

dcatState1Alive2Dead(  x = zPlusOne
                     , z = z
                     , prob1To2Hab = prob1To2Hab
                     , prob2To3Hab =  prob2To3Hab
                     , prob2To4Hab = prob2To4Hab
                     , s = s
                     , habitatGrid = habitatGrid)




</code></pre>

<hr>
<h2 id='dcatState2Alive2Dead'>Density and random generation of a categorical distribution describing state transition with two alive and two dead states.</h2><span id='topic+dcatState2Alive2Dead'></span><span id='topic+rcatState2Alive2Dead'></span>

<h3>Description</h3>

<p>The <code>dcatState2Alive2Dead</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
individual state transition. This function can be used to model transitions from two alive and two dead states. 
If z_i,t = 1, individual i can be recruited (transition to state 2) with probability prob1To2_t, so z_i,t+1 ~ dcat(1- prob1To2_t, prob1To2_t, 0,0 , 0) where prob1To2_t represent the probability of an unborn individual to be recruited.
If z_i,t = 2, individual i can die from one cause of mortality (e.g. culling) and transition to z_i,t+1=4 with probability prob2To4, or die from another cause with probability prob2To5 z_i,t+1=5. 
If the individual does not die (1-(prob2To4+prob2To5)), it can either transition to the second state alive (z_i,t+1=3) with probability prob2To3 or remain in the first state alive (z_i,t+1=2) with probability (1-prob2To3). 
If z_i,t = 3, individual i can die from one cause of mortality (e.g. culling) and transition to z_i,t+1=4 with probability prob3To4, or die from another cause with probability prob3To5 z_i,t+1=5. 
if the individual does not die (1-(prob3To4+prob3To5)), the individual remain in state 3. 
Individuals in dead states (z_i,t = 4 or 5) transition to z_i,t+1 = 5, the absorbing state, with probability 1.
If transition probabilities are spatially variable, a probability vector containing the transition probability value in each habitat window can be provided using the &quot;Hab&quot; arguments (e.g. prob1To2Hab,prob2To3Hab).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcatState2Alive2Dead(
  x,
  z,
  prob1To2 = -999,
  prob1To2Hab,
  prob2To3 = -999,
  prob2To3Hab,
  prob2To4 = -999,
  prob2To4Hab,
  prob3To4 = -999,
  prob3To4Hab,
  prob2To5 = -999,
  prob2To5Hab,
  prob3To5 = -999,
  prob3To5Hab,
  s,
  habitatGrid,
  log = 0
)

rcatState2Alive2Dead(
  n,
  z,
  prob1To2 = -999,
  prob1To2Hab,
  prob2To3 = -999,
  prob2To3Hab,
  prob2To4 = -999,
  prob2To4Hab,
  prob3To4 = -999,
  prob3To4Hab,
  prob2To5 = -999,
  prob2To5Hab,
  prob3To5 = -999,
  prob3To5Hab,
  s,
  habitatGrid
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcatState2Alive2Dead_+3A_x">x</code></td>
<td>
<p>Scalar, individual state z_i,t+1.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_z">z</code></td>
<td>
<p>Scalar, initial individual state z_i,t.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob1to2">prob1To2</code></td>
<td>
<p>scalar, probability to transition from state 1 to 2.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob1to2hab">prob1To2Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 3.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob2to3">prob2To3</code></td>
<td>
<p>scalar, probability to transition from state 2 to 3.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob2to3hab">prob2To3Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 3.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob2to4">prob2To4</code></td>
<td>
<p>scalar, probability to transition from state 2 to 4.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob2to4hab">prob2To4Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 4.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob3to4">prob3To4</code></td>
<td>
<p>scalar, probability to transition from state 3 to 4.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob3to4hab">prob3To4Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 3 to 4.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob2to5">prob2To5</code></td>
<td>
<p>scalar, probability to transition from state 2 to 5.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob2to5hab">prob2To5Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 2 to 5.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob3to5">prob3To5</code></td>
<td>
<p>scalar, probability to transition from state 3 to 5.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_prob3to5hab">prob3To5Hab</code></td>
<td>
<p>vector, Spatially-explicit probability to transition from state 3 to 5.  The length of the vector should be equal the number of habitat windows in <code>habitatGrid</code>.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates corresponding to the AC location of the individual. Used to extract transition spatially-explicit probabilities when they are provided.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the 
order of habitat windows in <code>prob1To2Hab</code>, <code>prob2To3Hab</code> and in <code>lowerCoords</code>  and <code>upperCoords</code> as used in the <code>dbernppAC</code> function.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dcatState2Alive2Dead_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dcatState2Alive2Dead</code> gives the (log) probability density of <code>x</code>. 
<code>dcatState2Alive2Dead</code> gives a randomly generated individual states conditional on the initial state <code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Cyril Milleret
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use the distribution in R

z &lt;- 3
prob1To2 &lt;- 0.2
prob2To3 &lt;- 0.4
prob2To4 &lt;- 0.1
prob2To5 &lt;- 0.1

prob3To4 &lt;- 0.2
prob3To5 &lt;- 0.1


lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)  
logIntensities &lt;- log(rep(1,4))
logSumIntensity &lt;- log(sum(c(1:4))) 
habitatGrid &lt;- matrix(c(1:4), nrow = 2, byrow = TRUE)
numGridRows &lt;- nrow(habitatGrid)
numGridCols &lt;- ncol(habitatGrid)
s &lt;- rbernppAC(n=1, lowerCoords, upperCoords, logIntensities, logSumIntensity, 
              habitatGrid, numGridRows, numGridCols)

## No spatial mortality 
zPlusOne &lt;- rcatState2Alive2Dead( z = z
                                 , prob1To2 = prob1To2
                                 , prob2To3 = prob2To3
                                 , prob2To4 = prob2To4
                                 , prob2To5 = prob2To5
                                 , prob3To4 = prob3To4
                                 , prob3To5 = prob3To5
                                 , s = s
                                 , habitatGrid = habitatGrid)

dcatState2Alive2Dead(  x = zPlusOne
                      , z = z
                      , prob1To2 = prob1To2
                      , prob2To3 = prob2To3
                      , prob2To4 = prob2To4
                      , prob2To5 = prob2To5
                      , prob3To4 = prob3To4
                      , prob3To5 = prob3To5
                      , s = s
                      , habitatGrid = habitatGrid)

##  With spatial mortality
prob2To3Hab &lt;- runif(length(habitatGrid),0,0.1)
prob2To4Hab &lt;- runif(length(habitatGrid),0,0.1)
prob2To5Hab &lt;- runif(length(habitatGrid),0,0.1)
prob3To4Hab &lt;- runif(length(habitatGrid),0,0.1)
prob3To5Hab &lt;- runif(length(habitatGrid),0,0.1)



zPlusOne &lt;- rcatState2Alive2Dead( z = z
                                 , prob1To2 = prob1To2
                                 , prob2To3Hab = prob2To3Hab
                                 , prob2To4Hab = prob2To4Hab
                                 , prob2To5Hab = prob2To5Hab
                                 , prob3To4Hab = prob3To4Hab
                                 , prob3To5Hab = prob3To5Hab
                                 , s = s
                                 , habitatGrid = habitatGrid)

dcatState2Alive2Dead(  x = zPlusOne
                      , z = z
                      , prob1To2 = prob1To2
                      , prob2To3Hab = prob2To3Hab
                      , prob2To4Hab = prob2To4Hab
                      , prob2To5Hab = prob2To5Hab
                      , prob3To4Hab = prob3To4Hab
                      , prob3To5Hab = prob3To5Hab
                      , s = s
                      , habitatGrid = habitatGrid)


</code></pre>

<hr>
<h2 id='dDispersal_exp'>Bivariate exponential dispersal distribution for activity centers</h2><span id='topic+dDispersal_exp'></span><span id='topic+rDispersal_exp'></span>

<h3>Description</h3>

<p>This function is deprecated, and it will be removed from a future release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dDispersal_exp(x, s, rate, log)

rDispersal_exp(n, s, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dDispersal_exp_+3A_x">x</code></td>
<td>
<p>Bivariate activity center coordinates (at time t+1).</p>
</td></tr>
<tr><td><code id="dDispersal_exp_+3A_s">s</code></td>
<td>
<p>Current location of the bivariate activity center (at time t).</p>
</td></tr>
<tr><td><code id="dDispersal_exp_+3A_rate">rate</code></td>
<td>
<p>Rate parameter of the exponential distribution for dispersal distance.</p>
</td></tr>
<tr><td><code id="dDispersal_exp_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dDispersal_exp_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dDispersal_exp distribution is a bivariate distribution which can be used to model the latent bivariate activity centers (ACs) of individuals in a population.  This distribution models the situation when individual AC dispersal is uniform in direction (that is, dispersal occurs in a direction theta, where theta is uniformly distributed on [-pi, pi]), and with an exponential distribution for the radial dispersal distance.
</p>
<p>The dDispersal_exp distribution models the location of an AC at time (t+1), conditional on the previous AC location at time (t) and the rate parameter (rate) of the exponential distribution for dispersal distance.
</p>


<h3>Value</h3>

<p>The log-probability value associated with the bivariate activity center location x, given the current activity center s, and the rate parameter of the exponential dispersal distance distribution.
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## define model code
code &lt;- nimbleCode({
    lambda ~ dgamma(0.001, 0.001)
    for(i in 1:N) {
        AC[i, 1, 1] ~ dunif(0, 100)
        AC[i, 2, 1] ~ dunif(0, 100)
        for(t in 2:T) {
            AC[i, 1:2, t+1] ~ dDispersal_exp(s = AC[i, 1:2, t], rate = lambda)
        }
    }
})

constants &lt;- list(N = 10, T = 6)

## create NIMBLE model object
Rmodel &lt;- nimbleModel(code, constants)

## use model object for MCMC, etc.


## End(Not run)

</code></pre>

<hr>
<h2 id='dHabitatMask'>Ones trick distribution for irregular habitat shapes</h2><span id='topic+dHabitatMask'></span><span id='topic+rHabitatMask'></span>

<h3>Description</h3>

<p>The dHabitatMask distribution checks and ensures that the proposed activity center location (s) falls
within the suitable habitat (defined in the binary matrix habitatMask).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dHabitatMask(x, s, xmax, xmin, ymax, ymin, habitatMask, log = 0)

rHabitatMask(n, s, xmax, xmin, ymax, ymin, habitatMask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dHabitatMask_+3A_x">x</code></td>
<td>
<p>Ones trick data.</p>
</td></tr>
<tr><td><code id="dHabitatMask_+3A_s">s</code></td>
<td>
<p>Bivariate activity center coordinates.</p>
</td></tr>
<tr><td><code id="dHabitatMask_+3A_xmax">xmax</code></td>
<td>
<p>Maximum of trap location x-coordinates.</p>
</td></tr>
<tr><td><code id="dHabitatMask_+3A_xmin">xmin</code></td>
<td>
<p>Minimum of trap location x-coordinates.</p>
</td></tr>
<tr><td><code id="dHabitatMask_+3A_ymax">ymax</code></td>
<td>
<p>Maximum of trap location y-coordinates.</p>
</td></tr>
<tr><td><code id="dHabitatMask_+3A_ymin">ymin</code></td>
<td>
<p>Minimum of trap location y-coordinates.</p>
</td></tr>
<tr><td><code id="dHabitatMask_+3A_habitatmask">habitatMask</code></td>
<td>
<p>A binary matrix object indicating which cells are considered as suitable habitat.</p>
</td></tr>
<tr><td><code id="dHabitatMask_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dHabitatMask_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rHabitatMask function returns the value of the habitat mask cell (0 or 1) where the proposed activity center falls. 
See also <a href="http://mmeredith.net/blog/2016/SECR_patchy_habitat_makeJAGSmask.htm">M. Meredith: SECR in BUGS/JAGS with patchy habitat</a>.
</p>


<h3>Value</h3>

<p>The log-likelihood value associated with the bivariate activity center location s being in the suitable habitat
(i.e. 0 if it falls within the habitat mask and -Inf otherwise).
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define model code
code &lt;- nimbleCode({
    for(i in 1:N) {
        s[i, 1] ~ dunif(0, 100)
        s[i, 2] ~ dunif(0, 100)
        OK[i] ~ dHabitatMask( s = s[i,1:2],
                              xmax = 100,
                              xmin = 0,
                              ymax = 100,
                              ymin = 0,
                              habitatMask = habitatMask[1:100,1:100])
    }
})
 
N &lt;- 20
 
habitatMask &lt;- matrix(rbinom(10000,1,0.75), nrow = 100)
 
constants &lt;- list(N = N, habitatMask = habitatMask)
 
data &lt;- list(OK = rep(1, N))
 
inits &lt;- list(s = array(runif(2*N, 0, 100), c(N,2)))
 
## create NIMBLE model object
Rmodel &lt;- nimbleModel(code, constants, data, inits)
 
## use model object for MCMC, etc.

</code></pre>

<hr>
<h2 id='dmultiLocal_normal'>Local evaluation of a multinomial SCR detection process</h2><span id='topic+dmultiLocal_normal'></span><span id='topic+rmultiLocal_normal'></span>

<h3>Description</h3>

<p>The <code>dmultiLocal_normal</code> distribution is a NIMBLE custom distribution which can be used to model 
and simulate multinomial observations (x) of a single individual over a set of traps defined by their coordinates <em>trapCoords</em>
the distribution assumes that an individual’s detection probability at any trap follows a half-normal function of the distance between 
the individual's activity center (s) and the trap location. All coordinates (<code>s</code> and <code>trapCoords</code>) should be scaled to the habitat (see <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmultiLocal_normal(
  x,
  detNums = -999,
  detIndices,
  size,
  p0 = -999,
  p0Traps,
  sigma,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0,
  log = 0
)

rmultiLocal_normal(
  n = 1,
  detNums = -999,
  detIndices,
  size,
  p0 = -999,
  p0Traps,
  sigma,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmultiLocal_normal_+3A_x">x</code></td>
<td>
<p>Vector of individual detection frequencies. This argument can be provided in two formats: 
(i) with the <em>y</em> object as returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function;
(ii) with the <em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>. 
Note that when the random generation functionality is used (<code>rmultiLocal_normal</code>), only the <em>yCombined</em> format can be used. 
The <em>yCombined</em> object combines <em>detNums</em>, <em>x</em>, and <em>detIndices</em> (in that order).  When such consolidated representation of the detection data <em>x</em> is used, <em>detIndices</em> and <em>detNums</em> arguments should not be specified.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_detnums">detNums</code></td>
<td>
<p>umber of traps with at least one detection recorded in <em>x</em>; from the <em>detNums</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when the <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code>) is provided as <em>x</em> and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_detindices">detIndices</code></td>
<td>
<p>Vector of indices of traps where the detections in <em>x</em> were recorded; from the <em>detIndices</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when x is provided as the  <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code> ) and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_size">size</code></td>
<td>
<p>Number of occasions.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_p0">p0</code></td>
<td>
<p>Baseline detection probability (scalar) used in the half-normal detection function. For trap-specific baseline detection probabilities use argument <em>p0Traps</em> (vector) instead.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_p0traps">p0Traps</code></td>
<td>
<p>Vector of baseline detection probabilities for each trap used in the half-normal detection function. When <em>p0Traps</em> is used, <em>p0</em> should not be provided.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of the half-normal detection function.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_s">s</code></td>
<td>
<p>Individual activity center x- and y-coordinates scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>)).</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_trapcoords">trapCoords</code></td>
<td>
<p>Matrix of x- and y-coordinates of all traps scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>)).</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_localtrapsindices">localTrapsIndices</code></td>
<td>
<p>Matrix of indices of local traps around each habitat grid cell, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_localtrapsnum">localTrapsNum</code></td>
<td>
<p>Vector of numbers of local traps around all habitat grid cells, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function to reduce the number of habitat grid cells to retrieve local traps for.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of local habitat grid cell indices, from <em>habitatGrid</em> returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_lengthycombined">lengthYCombined</code></td>
<td>
<p>The length of the x argument when the (<em>yCombined</em>) format of the detection data is provided;  from the <em>lengthYCombined</em> object returned by <code><a href="#topic+getSparseY">getSparseY</a></code></p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dmultiLocal_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dmultiLocal_normal</code> distribution incorporates three features to increase computation efficiency (see Turek et al., 2021 &lt;doi.org/10.1002/ecs2.3385&gt;  for more details):
</p>

<ol>
<li><p> A local evaluation of the detection probability calculation (see Milleret et al., 2019 &lt;doi:10.1002/ece3.4751&gt; for more details)
</p>
</li>
<li><p> A sparse matrix representation (<em>x</em>, <em>detIndices</em> and <em>detNums</em>) of the observation data to reduce the size of objects to be processed.
</p>
</li>
<li><p> An indicator (<em>indicator</em>) to shortcut calculations for individuals unavailable for detection.
</p>
</li></ol>

<p>The <code>dmultiLocal_normal</code> distribution requires x- and y- detector coordinates (<em>trapCoords</em>) and activity centers coordinates (<em>s</em>) to be scaled to the habitat grid (<em>habitatGrid</em>) using the (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code> function.)
</p>
<p>When the aim is to simulate detection data: 
</p>

<ol>
<li> <p><em>x</em> should be provided using the <em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>, 
</p>
</li>
<li><p> arguments <em>detIndices</em> and <em>detNums</em> should not be provided, 
</p>
</li>
<li><p> argument <em>lengthYCombined</em> should be provided using the <em>lengthYCombined</em> object as returned by  <code><a href="#topic+getSparseY">getSparseY</a></code>.
</p>
</li></ol>



<h3>Value</h3>

<p>The log-likelihood value associated with the vector of detections, given the location of the activity center (s),
and the half-normal detection function : <code class="reqn">p = p0 * exp(-d^2 / 2 \sigma^2)</code>.
</p>


<h3>Author(s)</h3>

<p>Soumen Dey, Cyril Milleret
</p>


<h3>Examples</h3>

<pre><code class='language-R'># I. DATA SET UP 
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                   1.5, 3.5,
                                   2.5, 3.5,
                                   3.5, 3.5,
                                   0.5, 2.5,
                                   1.5, 2.5,
                                   2.5, 2.5,
                                   3.5, 2.5,
                                   0.5, 1.5,
                                   1.5, 1.5,
                                   2.5, 1.5,
                                   3.5, 1.5,
                                   0.5, 0.5,
                                   1.5, 0.5,
                                   2.5, 0.5,
                                   3.5, 0.5), ncol=2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# CREATE OBSERVATION WINDOWS
trapCoords &lt;- matrix(c(1.5, 1.5, 2.5, 1.5, 1.5, 2.5, 2.5, 2.5), nrow = 4, byrow = TRUE)
colnames(trapCoords) &lt;- c("x","y")
# PLOT CHECK
plot(coordsHabitatGridCenter[,"y"]~coordsHabitatGridCenter[,"x"],pch=16) 
points(trapCoords[,"y"]~trapCoords[,"x"],col="red",pch=16) 

# PARAMETERS
p0 &lt;- 0.2
sigma &lt;- 2
indicator &lt;- 1 
# WE CONSIDER 2 INDIVIDUALS

y &lt;- matrix(c(2, 1, 1,-1, 1, 4, -1,#id#1 detected 2 times at detector 1 and 4 
             2, 2,-1,-1, 3,-1, -1),#id#2 detected 2 times at detector 3
              ncol=7, nrow=2, byrow = TRUE)




s &lt;- matrix(c(0.5, 1,
             1.6, 2.3),ncol=2,nrow=2)

# RESCALE COORDINATES 
ScaledtrapCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  trapCoords,
                                            coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledtrapCoords&lt;- ScaledtrapCoords$coordsDataScaled
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)


# CREATE LOCAL OBJECTS 
TrapLocal &lt;- getLocalObjects(habitatMask = habitatMask,
                                  coords = ScaledtrapCoords,
                                  dmax=2.5,
                                  resizeFactor = 1,
                                  plot.check = TRUE
)

# GET SPARSE MATRIX 
#SparseY &lt;- getSparseY(y)

# II. USING THE DENSITY FUNCTION 
# WE TAKE THE FIRST INDIVIDUAL
i=1
 # OPTION 1: USING THE RANDOM GENERATION FUNCTIONNALITY 
dmultiLocal_normal(x=y[i,]
                  ,
                  size=3
                  ,
                  p0 = p0
                  ,
                  sigma= sigma
                  , 
                  s=s[i,1:2]
                  ,
                  trapCoords=ScaledtrapCoords
                  ,
                  localTrapsIndices=TrapLocal$localIndices
                  ,
                  localTrapsNum=TrapLocal$numLocalIndices
                  ,
                  resizeFactor=TrapLocal$resizeFactor
                  ,
                  habitatGrid=TrapLocal$habitatGrid
                  ,
                  indicator=indicator
                  ,
                  lengthYCombined = ncol(y)
                  )
                                                               
 

# III. USING THE RANDOM GENERATION FUNCTION 
rmultiLocal_normal(n=1,
                  size=3,
                  p0 = p0,
                  sigma= sigma, 
                  s=s[i,1:2],
                  trapCoords=ScaledtrapCoords,
                  localTrapsIndices=TrapLocal$localIndices,
                  localTrapsNum=TrapLocal$numLocalIndices,
                  resizeFactor=TrapLocal$resizeFactor,
                  habitatGrid=TrapLocal$habitatGrid,
                  indicator=indicator,
                  lengthYCombined = ncol(y))
                  
</code></pre>

<hr>
<h2 id='dnormalizer'>Normalizing constant generator</h2><span id='topic+dnormalizer'></span><span id='topic+rnormalizer'></span>

<h3>Description</h3>

<p>A normalizer used for normalizing <code>nimble</code> distributions. 
It is particularly useful for fitting <code>dpoisppDetection_normal</code> and <code>dpoisppLocalDetection_normal</code> models 
using the semi-complete data likelihood approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dnormalizer(x, logNormConstant, log = 0)

rnormalizer(n, logNormConstant)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dnormalizer_+3A_x">x</code></td>
<td>
<p>Input data, which can be any scalar and will not influence the return value.</p>
</td></tr>
<tr><td><code id="dnormalizer_+3A_lognormconstant">logNormConstant</code></td>
<td>
<p>Normalizing constant on a log scale.</p>
</td></tr>
<tr><td><code id="dnormalizer_+3A_log">log</code></td>
<td>
<p>Logical. If <code>TRUE</code> return the log normalizing constant. Otherwise return the normalizing constant.</p>
</td></tr>
<tr><td><code id="dnormalizer_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The normalizing constant.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dnormalizer(1, log(0.5), log = TRUE)
dnormalizer(0, log(0.5), log = FALSE)

</code></pre>

<hr>
<h2 id='dpoisLocal_normal'>Local evaluation of a Poisson SCR detection process</h2><span id='topic+dpoisLocal_normal'></span><span id='topic+rpoisLocal_normal'></span>

<h3>Description</h3>

<p>The <code>dpoisLocal_normal</code> distribution is a NIMBLE custom distribution which can be used to model 
and simulate Poisson observations (x) of a single individual over a set of traps defined by their coordinates <em>trapCoords</em>
the distribution assumes that an individual’s detection probability at any trap follows a half-normal function of the distance between 
the individual's activity center (s) and the trap location. All coordinates (<code>s</code> and <code>trapCoords</code>) should be scaled to the habitat (see <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpoisLocal_normal(
  x,
  detNums = -999,
  detIndices,
  lambda = -999,
  lambdaTraps,
  sigma,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0,
  log = 0
)

rpoisLocal_normal(
  n = 1,
  detNums = -999,
  detIndices,
  lambda = -999,
  lambdaTraps,
  sigma,
  s,
  trapCoords,
  localTrapsIndices,
  localTrapsNum,
  resizeFactor = 1,
  habitatGrid,
  indicator,
  lengthYCombined = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpoisLocal_normal_+3A_x">x</code></td>
<td>
<p>Vector of individual detection frequencies. This argument can be provided in two formats: (i) with the <em>y</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>; (ii) with the
<em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code> Note that when the random generation functionality is used (rpoisLocal_normal), only the yCombined format can be used. 
The  <em>yCombined</em>  object combines <em>detNums</em>, <em>x</em>, and <em>detIndices</em> (in that order). When such consolidated 
representation of the detection data x is used, <em>detIndices</em> and <em>detNums</em> arguments should not be specified.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_detnums">detNums</code></td>
<td>
<p>Number of traps with at least one detection recorded in <em>x</em>; from the <em>detNums</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when the <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code>) is provided as <em>x</em> and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_detindices">detIndices</code></td>
<td>
<p>Vector of indices of traps where the detections in <em>x</em> were recorded; from the <em>detIndices</em> object returned by the <code><a href="#topic+getSparseY">getSparseY</a></code> function. 
This argument should not be specified when x is provided as the  <em>yCombined</em> object (returned by <code><a href="#topic+getSparseY">getSparseY</a></code> ) and when detection data are simulated.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_lambda">lambda</code></td>
<td>
<p>Baseline detection rate used in the half-normal detection function.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_lambdatraps">lambdaTraps</code></td>
<td>
<p>Vector of baseline detection rate for each trap used in the half-normal detection function. When <em>lambdaTraps</em> is used, <em>lambda</em> should not be provided.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_sigma">sigma</code></td>
<td>
<p>Scale parameter of the half-normal detection function.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_s">s</code></td>
<td>
<p>Individual activity center x- and y-coordinates scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_trapcoords">trapCoords</code></td>
<td>
<p>Matrix of x- and y-coordinates of all traps scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_localtrapsindices">localTrapsIndices</code></td>
<td>
<p>Matrix of indices of local traps around each habitat grid cell, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_localtrapsnum">localTrapsNum</code></td>
<td>
<p>Vector of numbers of local traps around all habitat grid cells, as returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function to reduce the number of habitat grid cells to retrieve local traps for.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of local habitat grid cell indices, from <em>habitatGrid</em> returned by the <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> function.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_lengthycombined">lengthYCombined</code></td>
<td>
<p>The length of the x argument when the (<em>yCombined</em>) format of the detection data is provided;  from the <em>lengthYCombined</em> object returned by <code><a href="#topic+getSparseY">getSparseY</a></code></p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dpoisLocal_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realizations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dpoisLocal_normal</code> distribution incorporates three features to increase computation efficiency (see Turek et al., 2021 &lt;doi.org/10.1002/ecs2.3385&gt;  for more details):
</p>

<ol>
<li><p> A local evaluation of the detection probability calculation (see Milleret et al., 2019 &lt;doi:10.1002/ece3.4751&gt; for more details)
</p>
</li>
<li><p> A sparse matrix representation (<em>x</em>, <em>detIndices</em> and <em>detNums</em>) of the observation data to reduce the size of objects to be processed.
</p>
</li>
<li><p> An indicator (<em>indicator</em>) to shortcut calculations for individuals unavailable for detection.
</p>
</li></ol>

<p>The <code>dpoisLocal_normal</code> distribution requires x- and y- detector coordinates (<em>trapCoords</em>) and activity centers coordinates (<em>s</em>) to be scaled to the habitat grid (<em>habitatGrid</em>) using the (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code> function.)
</p>
<p>When the aim is to simulate detection data: 
</p>

<ol>
<li> <p><em>x</em> should be provided using the <em>yCombined</em> object as returned by <code><a href="#topic+getSparseY">getSparseY</a></code>, 
</p>
</li>
<li><p> arguments <em>detIndices</em> and <em>detNums</em> should not be provided, 
</p>
</li>
<li><p> argument <em>lengthYCombined</em> should be provided using the <em>lengthYCombined</em> object as returned by  <code><a href="#topic+getSparseY">getSparseY</a></code>.
</p>
</li></ol>



<h3>Value</h3>

<p>The log-likelihood value associated with the vector of detections, given the location of the activity center (s),
and the half-normal detection function : <code class="reqn">p = lambda * exp(-d^2 / 2 \sigma^2)</code>.
</p>


<h3>Author(s)</h3>

<p>Cyril Milleret, Soumen Dey
</p>


<h3>Examples</h3>

<pre><code class='language-R'># I. DATA SET UP 
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol=2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# CREATE OBSERVATION WINDOWS
trapCoords &lt;- matrix(c(1.5, 1.5, 2.5, 1.5, 1.5, 2.5, 2.5, 2.5), nrow = 4, byrow = TRUE)
colnames(trapCoords) &lt;- c("x","y")
# PLOT CHECK
plot(coordsHabitatGridCenter[,"y"]~coordsHabitatGridCenter[,"x"],pch=16) 
points(trapCoords[,"y"]~trapCoords[,"x"],col="red",pch=16) 

# PARAMETERS
lambda &lt;- 0.2
sigma &lt;- 2
indicator &lt;- 1 
# WE CONSIDER 2 INDIVIDUALS
y &lt;- matrix(c(0, 1, 1, 0,
              0, 1, 0, 1),ncol=4,nrow=2)
s &lt;- matrix(c(0.5, 1,
              1.6, 2.3),ncol=2,nrow=2)

# RESCALE COORDINATES 
ScaledtrapCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  trapCoords,
                                             coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledtrapCoords&lt;- ScaledtrapCoords$coordsDataScaled
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)


# CREATE LOCAL OBJECTS 
TrapLocal &lt;- getLocalObjects(habitatMask = habitatMask,
                                   coords = ScaledtrapCoords,
                                   dmax=2.5,
                                   resizeFactor = 1,
                                   plot.check = TRUE
)

# GET SPARSE MATRIX 
SparseY &lt;- getSparseY(y)

# II. USING THE DENSITY FUNCTION 
 # WE TAKE THE FIRST INDIVIDUAL
i=1
  # OPTION 1: USING THE RANDOM GENERATION FUNCTIONNALITY 
dpoisLocal_normal(x=SparseY$y[i,,1],
                   detNums=SparseY$detNums[i],
                   detIndices=SparseY$detIndices[i,,1],
                   lambda = lambda,
                   sigma= sigma, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator)
                                                                
  # OPTION 2: USING RANDOM GENERATION FUNCTIONNALITY 
  # WE DO NOT PROVIDE THE detNums AND detIndices ARGUMENTS
dpoisLocal_normal(x=SparseY$yCombined[i,,1],
                   lambda = lambda,
                   sigma= sigma, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator,
                   lengthYCombined = SparseY$lengthYCombined)

# III. USING THE RANDOM GENERATION FUNCTION 
rpoisLocal_normal(n=1,
                   lambda = lambda,
                   sigma= sigma, 
                   s=s[i,1:2],
                   trapCoords=ScaledtrapCoords,
                   localTrapsIndices=TrapLocal$localIndices,
                   localTrapsNum=TrapLocal$numLocalIndices,
                   resizeFactor=TrapLocal$resizeFactor,
                   habitatGrid=TrapLocal$habitatGrid,
                   indicator=indicator,
                   lengthYCombined = SparseY$lengthYCombined)

</code></pre>

<hr>
<h2 id='dpoisppAC'>Poisson point process for the distribution of activity centers</h2><span id='topic+dpoisppAC'></span><span id='topic+rpoisppAC'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Poisson point process for the distribution of activity centers. 
The <code>dpoisppAC</code> distribution is a NIMBLE custom distribution which 
can be used to model and simulate activity center locations (<em>x</em>) of multiple individual in 
continuous space over a set of habitat windows defined by their upper and lower coordinates (<em>lowerCoords,upperCoords</em>). 
The distribution assumes that activity centers follow a Poisson point process with intensity = exp(logIntensities).  
All coordinates (<em>s</em> and <em>trapCoords</em>) should be scaled to the habitat (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpoisppAC(
  x,
  lowerCoords,
  upperCoords,
  logIntensities,
  sumIntensity,
  habitatGrid,
  numGridRows,
  numGridCols,
  numPoints,
  log = 0
)

rpoisppAC(
  n,
  lowerCoords,
  upperCoords,
  logIntensities,
  sumIntensity,
  habitatGrid,
  numGridRows,
  numGridCols,
  numPoints
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpoisppAC_+3A_x">x</code></td>
<td>
<p>Matrix of x- and y-coordinates of a set of spatial points (AC locations) scaled to the habitat (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>). Each row corresponds to a point.</p>
</td></tr>
<tr><td><code id="dpoisppAC_+3A_lowercoords">lowerCoords</code>, <code id="dpoisppAC_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all detection windows scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>). One row for each window. Each window should be of size 1x1.</p>
</td></tr>
<tr><td><code id="dpoisppAC_+3A_logintensities">logIntensities</code></td>
<td>
<p>Vector of log habitat intensities for all habitat windows.</p>
</td></tr>
<tr><td><code id="dpoisppAC_+3A_sumintensity">sumIntensity</code></td>
<td>
<p>Sum of the habitat intensities over all windows. Provided as an argument for computational speed, instead of calculating it in the function.</p>
</td></tr>
<tr><td><code id="dpoisppAC_+3A_habitatgrid">habitatGrid</code></td>
<td>
<p>Matrix of habitat window indices. Cell values should correspond to the order of habitat windows in
<code>lowerCoords</code>, <code>upperCoords</code>, and <code>logIntensities</code>. 
When the habitat grid only consists of a single row or column of windows, an additional row or column of dummy indices has to be added because the <code>nimble</code> model code requires a matrix.</p>
</td></tr>
<tr><td><code id="dpoisppAC_+3A_numgridrows">numGridRows</code>, <code id="dpoisppAC_+3A_numgridcols">numGridCols</code></td>
<td>
<p>Numbers of rows and columns of the habitat grid.</p>
</td></tr>
<tr><td><code id="dpoisppAC_+3A_numpoints">numPoints</code></td>
<td>
<p>Number of points in the Poisson point process. This value (non-negative integer) is used to truncate <code>x</code> 
so that extra rows beyond <code>numPoints</code> are ignored.</p>
</td></tr>
<tr><td><code id="dpoisppAC_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dpoisppAC_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate. Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dpoisppAC</code> gives the (log) probability density of the observation matrix <code>x</code>. 
<code>rpoisppAC</code> gives coordinates of a set of randomly generated spatial points.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
logIntensities &lt;- log(c(1:4))
logSumIntensity &lt;- sum(exp(logIntensities))
habitatGrid &lt;- matrix(c(1:4), nrow = 2, byrow = TRUE)
numGridRows &lt;- nrow(habitatGrid)
numGridCols &lt;- ncol(habitatGrid)
#Simulate data
x &lt;- rpoisppAC(1, lowerCoords, upperCoords, logIntensities, logSumIntensity, habitatGrid,
               numGridRows, numGridCols, -1)
numPoints &lt;- nrow(x)
dpoisppAC(x, lowerCoords, upperCoords, logIntensities, logSumIntensity,
          habitatGrid, numGridRows, numGridCols, numPoints, log = TRUE)
          
</code></pre>

<hr>
<h2 id='dpoisppDetection_normal'>Poisson point process detection model</h2><span id='topic+dpoisppDetection_normal'></span><span id='topic+rpoisppDetection_normal'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Poisson point process for detection. 
The <code>dpoisppDetection_normal</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
Poisson observations (<em>x</em>) of a single individual in continuous space over a set of detection windows defined by their upper and lower
coordinates (<em>lowerCoords,upperCoords</em>). The distribution assumes that an individual’s detection intensity 
follows an isotropic bivariate normal function centered on the individual's activity center (<em>s</em>) with standard deviation (<em>sd</em>).
All coordinates (<em>s</em> and <em>trapCoords</em>) should be scaled to the habitat (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpoisppDetection_normal(
  x,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  numMaxPoints,
  numWindows,
  indicator,
  log = 0
)

rpoisppDetection_normal(
  n,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  numMaxPoints,
  numWindows,
  indicator
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpoisppDetection_normal_+3A_x">x</code></td>
<td>
<p>Array containing the total number of detections (x[1,1]), the x- and y-coordinates (x[2:(x[1,1]+1),1:2]), 
and the corresponding detection window indices (x[2:(x[1,1]+1),3]) for a set of spatial points (detection locations).</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_lowercoords">lowerCoords</code>, <code id="dpoisppDetection_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all detection windows scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>). One row for each window. Each window should be of size 1x1.</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic multivariate normal distribution mean (the AC location).</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline detection intensities for all detection windows.</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_nummaxpoints">numMaxPoints</code></td>
<td>
<p>Maximum number of points. This value (non-negative integer) is only used when simulating detections to constrain the maximum number of detections.</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of detection windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dpoisppDetection_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate.  Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dpoisppDetection_normal</code> gives the (log) probability density of the observation matrix <code>x</code>.
<code>rpoisppDetection_normal</code> gives coordinates of a set of randomly generated spatial points.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
                                    1.5, 3.5,
                                    2.5, 3.5,
                                    3.5, 3.5,
                                    0.5, 2.5,
                                    1.5, 2.5,
                                    2.5, 2.5,
                                    3.5, 2.5,
                                    0.5, 1.5,
                                    1.5, 1.5,
                                    2.5, 1.5,
                                    3.5, 1.5,
                                    0.5, 0.5,
                                    1.5, 0.5,
                                    2.5, 0.5,
                                    3.5, 0.5), ncol = 2,byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c("x","y")
# Create observation windows
lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
colnames(lowerCoords) &lt;- colnames(upperCoords) &lt;- c("x","y")

# Rescale coordinates
ScaledLowerCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  lowerCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  upperCoords,
                                              coordsHabitatGridCenter = coordsHabitatGridCenter)
ScaledUpperCoords$coordsDataScaled[,2] &lt;- ScaledUpperCoords$coordsDataScaled[,2] + 1.5
ScaledLowerCoords$coordsDataScaled[,2] &lt;- ScaledLowerCoords$coordsDataScaled[,2] - 1.5



# Detection locations
x &lt;- matrix(c(1.5, 2, 1.1, 1.5,0.6, 2.1, 0.5, 2, 1, 1.5), nrow = 5, byrow = TRUE)

# get the window indeces on the third dimension of x

windowIndexes &lt;- 0
for(i in 1:nrow(x)){
  windowIndexes[i] &lt;- getWindowIndex(curCoords = x[i,],
                                     lowerCoords = ScaledLowerCoords$coordsDataScaled,
                                     upperCoords = ScaledUpperCoords$coordsDataScaled)
}
x &lt;- cbind(x, windowIndexes)
# get the total number of detections on x[1,1]
x &lt;- rbind(c(length(windowIndexes),0,0) ,x )


s &lt;- c(1, 1)
sd &lt;- 0.1
baseIntensities &lt;- c(1:4)
windowIndices &lt;- c(1, 2, 2, 3, 4)
numPoints &lt;- 5
numWindows &lt;- 4
indicator &lt;- 1
dpoisppDetection_normal(x, lowerCoords, upperCoords, s, sd, baseIntensities,
                        numMaxPoints = dim(x)[1] , numWindows, indicator, log = TRUE)
</code></pre>

<hr>
<h2 id='dpoisppLocalDetection_normal'>Local evaluation for a Poisson point process detection model</h2><span id='topic+dpoisppLocalDetection_normal'></span><span id='topic+rpoisppLocalDetection_normal'></span>

<h3>Description</h3>

<p>Density and random generation functions of the Poisson point process for detection. 
The <code>dpoisppLocalDetection_normal</code> distribution is a NIMBLE custom distribution which can be used to model and simulate
Poisson observations (<em>x</em>) of a single individual in continuous space over a set of detection windows defined by their upper and lower
coordinates (<em>lowerCoords,upperCoords</em>). The distribution assumes that an individual’s detection intensity 
follows an isotropic bivariate normal function centered on the individual's activity center (<em>s</em>) with standard deviation (<em>sd</em>).
All coordinates (<em>s</em> and <em>trapCoords</em>) should be scaled to the habitat (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpoisppLocalDetection_normal(
  x,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  habitatGridLocal,
  resizeFactor = 1,
  localObsWindowIndices,
  numLocalObsWindows,
  numMaxPoints,
  numWindows,
  indicator,
  log = 0
)

rpoisppLocalDetection_normal(
  n,
  lowerCoords,
  upperCoords,
  s,
  sd,
  baseIntensities,
  habitatGridLocal,
  resizeFactor = 1,
  localObsWindowIndices,
  numLocalObsWindows,
  numMaxPoints,
  numWindows,
  indicator
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_x">x</code></td>
<td>
<p>Matrix containing the total number of detections (x[1,1]), the x- and y-coordinates (x[2:(x[1,1]+1),1:2]), 
and the corresponding detection window indices (x[2:(x[1,1]+1),3]) for a set of spatial points (detection locations).</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_lowercoords">lowerCoords</code>, <code id="dpoisppLocalDetection_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of all detection windows scaled to the habitat (see (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>). One row for each window. Each window should be of size 1x1.</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic multivariate normal distribution mean (the AC location).</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline detection intensities for all detection windows.</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_habitatgridlocal">habitatGridLocal</code></td>
<td>
<p>Matrix of rescaled habitat grid cells indices, from localIndices returned by the  <code>getLocalObjects</code> function (</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>Aggregation factor used in the  <code>getLocalObjects</code> function to reduce the number of habitat grid cells.</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_localobswindowindices">localObsWindowIndices</code></td>
<td>
<p>Matrix of indices of local observation windows around each rescaled habitat grid cell, as returned by the getLocalObjects function (object named <code>localIndices</code>).</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_numlocalobswindows">numLocalObsWindows</code></td>
<td>
<p>Vector of numbers of local observation windows around all habitat grid cells, as returned by the getLocalObjects function (object named <code>numLocalIndices</code>). 
The ith number gives the number of local (original) observation windows for the ith (rescaled) habitat window.</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_nummaxpoints">numMaxPoints</code></td>
<td>
<p>Maximum number of points. This value (non-negative integer) is only used when simulating detections to constrain the maximum number of detections.</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of detection windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_indicator">indicator</code></td>
<td>
<p>Binary argument specifying whether the individual is available for detection (indicator = 1) or not (indicator = 0).</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_log">log</code></td>
<td>
<p>Logical argument, specifying whether to return the log-probability of the distribution.</p>
</td></tr>
<tr><td><code id="dpoisppLocalDetection_normal_+3A_n">n</code></td>
<td>
<p>Integer specifying the number of realisations to generate. Only n = 1 is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (log) probability density of the observation matrix <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang, Cyril Milleret and Pierre Dupont
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035 
</p>
<p>C. Milleret, P. Dupont, C. Bonenfant, H. Brøseth, Ø. Flagstad, C. Sutherland and R. Bischof. 2019. 
A local evaluation of the individual state-space to scale up Bayesian spatial capture-recapture. Ecology and Evolution 9:352-363
</p>
<p>#' @examples 
# Create habitat grid
coordsHabitatGridCenter &lt;- matrix(c(0.5, 3.5,
1.5, 3.5,
2.5, 3.5,
3.5, 3.5,
0.5, 2.5,
1.5, 2.5,
2.5, 2.5,
3.5, 2.5,
0.5, 1.5,
1.5, 1.5,
2.5, 1.5,
3.5, 1.5,
0.5, 0.5,
1.5, 0.5,
2.5, 0.5,
3.5, 0.5), ncol = 2, byrow = TRUE)
colnames(coordsHabitatGridCenter) &lt;- c(&quot;x&quot;,&quot;y&quot;)
# Create observation windows
lowerCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(2, 2, 3, 2, 2, 3, 3, 3), nrow = 4, byrow = TRUE)  
colnames(lowerCoords) &lt;- colnames(upperCoords) &lt;- c(&quot;x&quot;,&quot;y&quot;)
# Plot check
plot(coordsHabitatGridCenter[,&quot;y&quot;]~coordsHabitatGridCenter[,&quot;x&quot;],pch=16) 
points(lowerCoords[,&quot;y&quot;]~lowerCoords[,&quot;x&quot;],col=&quot;red&quot;,pch=16) 
points(upperCoords[,&quot;y&quot;]~upperCoords[,&quot;x&quot;],col=&quot;red&quot;,pch=16) 
</p>
<p>s &lt;- c(1, 1)
sd &lt;- 0.1
baseIntensities &lt;- c(1:4)
windowIndex &lt;- 4
numPoints &lt;- 1
numWindows &lt;- 4
indicator &lt;- 1
</p>
<p># Rescale coordinates
ScaledLowerCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  lowerCoords,
coordsHabitatGridCenter = coordsHabitatGridCenter)$coordsDataScaled
ScaledUpperCoords &lt;- scaleCoordsToHabitatGrid(coordsData =  upperCoords,
coordsHabitatGridCenter = coordsHabitatGridCenter)$coordsDataScaled
ScaledUpperCoords[,2] &lt;- ScaledUpperCoords[,2] + 1.5
ScaledLowerCoords[,2] &lt;- ScaledLowerCoords[,2] - 1.5
habitatMask &lt;- matrix(1, nrow = 4, ncol=4, byrow = TRUE)
# Create local objects 
ObsWindowsLocal &lt;- getLocalObjects(habitatMask = habitatMask,
coords = ScaledLowerCoords,
dmax=3,
resizeFactor = 1,
plot.check = TRUE
)
</p>
<p># Detection locations
x &lt;- matrix(c(1.5, 2, 1.1, 1.5, 1.4, 0.7, 2, 1.3, 1, 1.5), nrow = 5, byrow = TRUE)
</p>
<p># get the window indeces on the third dimension of x
windowIndexes &lt;- 0
for(i in 1:nrow(x))
windowIndexes[i] &lt;- getWindowIndex(curCoords = x[i,],
lowerCoords = ScaledLowerCoords,
upperCoords =ScaledUpperCoords)

x &lt;- cbind(x, windowIndexes)
# get the total number of detections on x[1,1]
x &lt;- rbind(c(length(windowIndexes),0,0), x)
dpoisppLocalDetection_normal(x, ScaledLowerCoords, ScaledUpperCoords, s, sd, baseIntensities,  
ObsWindowsLocal$habitatGrid, ObsWindowsLocal$resizeFactor,
ObsWindowsLocal$localIndices,ObsWindowsLocal$numLocalIndices,
numMaxPoints = dim(x)[1], numWindows, indicator, log = TRUE)
</p>

<hr>
<h2 id='getHomeRangeArea'>Computation of home range radius and area</h2><span id='topic+getHomeRangeArea'></span>

<h3>Description</h3>

<p><code>getHomeRangeArea</code> returns approximates estimates of home range radius and area for a given set of parameters with respect to a specified detection function using bisection algorithm. The following circular detection functions are available to use in nimbleSCR: half-normal (detFun = 0), half-normal plateau (detFun = 1), exponential (detFun = 2), asymmetric logistic (detFun = 3), bimodal (detFun = 4) and donut (detFun = 5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHomeRangeArea(
  x = 2,
  detFun = 0,
  prob = 0.95,
  d = 6,
  xlim = c(0, 30),
  ylim = c(0, 30),
  nBreaks = 800,
  tol = 0.00001,
  nIter = 2000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHomeRangeArea_+3A_x">x</code></td>
<td>
<p><code>Vector</code> or <code>matrix</code> (parameters in columns) of values for different parameters corresponding to the specified detection function.</p>
</td></tr>
<tr><td><code id="getHomeRangeArea_+3A_detfun">detFun</code></td>
<td>
<p><code>Numeric</code> vNumeric variable denoting the type of detection function. 0 = Half-normal, 1 = Half-normal plateau, 2 = Exponential, 3 = Asymmetric logistic, 4 = Bimodal, 5 = Donut.</p>
</td></tr>
<tr><td><code id="getHomeRangeArea_+3A_prob">prob</code></td>
<td>
<p><code>Numeric</code>  variable denoting the quantile probability to compute the home range radius.</p>
</td></tr>
<tr><td><code id="getHomeRangeArea_+3A_d">d</code></td>
<td>
<p><code>Numeric</code> variable giving an initial value of the radius.</p>
</td></tr>
<tr><td><code id="getHomeRangeArea_+3A_xlim">xlim</code></td>
<td>
<p><code>Vector</code> of length 2 giving the range along x-axis.</p>
</td></tr>
<tr><td><code id="getHomeRangeArea_+3A_ylim">ylim</code></td>
<td>
<p><code>Vector</code> of length 2 giving the range along y-axis.</p>
</td></tr>
<tr><td><code id="getHomeRangeArea_+3A_nbreaks">nBreaks</code></td>
<td>
<p><code>Numeric</code> variable denoting the number of breaks along an axis.</p>
</td></tr>
<tr><td><code id="getHomeRangeArea_+3A_tol">tol</code></td>
<td>
<p><code>Numeric</code> variable denoting the allowed tolerance in the radius estimate.</p>
</td></tr>
<tr><td><code id="getHomeRangeArea_+3A_niter">nIter</code></td>
<td>
<p><code>Numeric</code> variable giving the maximum number of iterations in bisection algorithm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Soumen Dey
</p>


<h3>References</h3>

<p>Dey, S., Bischof, R., Dupont, P. P. A., &amp; Milleret, C. (2022). Does the punishment fit the crime? Consequences and diagnosis of misspecified detection functions in Bayesian spatial capture–recapture modeling. Ecology and Evolution, 12, e8600. https://doi.org/10.1002/ece3.8600
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

# A user friendly vignette is also available on github: 
# https://github.com/nimble-dev/nimbleSCR/blob/master/nimbleSCR/vignettes/
# Vignette name: Fit_with_dbinomLocal_normalPlateau_and_HomeRangeAreaComputation.rmd

# HALF-NORMAL PLATEAU FUNCTION (detFun = 1) 
habitatMask &lt;- matrix(1, nrow = 30, ncol= 30, byrow = TRUE)

prob &lt;- 0.95
paramnames.hr &lt;- c("HRradius", "HRarea")
sigma &lt;- 1
w &lt;- 1.5
params &lt;- c(sigma, w)
names(params) &lt;- c("sigma", "w")
HRAnim &lt;- getHomeRangeArea( x = params, detFun = 1, prob = prob, d = 6,
                      xlim = c(0, dim(habitatMask)[2]), ylim = c(0, dim(habitatMask)[1]),
                      nBreaks = 800, tol = 1E-5, nIter = 2000)

# Different values of argument "detFun"
# 0 = Half-normal, 1 = Half-normal plateau, 2 = Exponential,
# 3 = Aysmmetric logistic, 4 = Bimodal, 5 = Donut.
HR.hnp &lt;- c(HRAnim$run())
names(HR.hnp) &lt;- paramnames.hr
print(HR.hnp)
# FASTER HRA COMPUTATION USING NIMBLE
samples &lt;- cbind(rgamma(n = 500, shape = 1, rate = 1), rgamma(n = 500, shape = 1.5, rate = 1))
colnames(samples) &lt;- c("sigma", "w")
HRAnim.mat &lt;- getHomeRangeArea(x = samples, detFun = 1, prob = prob, d = 6, 
                         xlim = c(0, dim(habitatMask)[2]), ylim = c(0, dim(habitatMask)[1]),
                         nBreaks = 800, tol = 1E-5, nIter = 2000)

cHRAnim.arr &lt;- compileNimble(HRAnim.mat, resetFunctions = TRUE)

HRA.Runtime &lt;- system.time(
  HR.chain &lt;- cHRAnim.arr$run()
)
print(HRA.Runtime)
dimnames(HR.chain)[[2]] &lt;- paramnames.hr
HRest &lt;- do.call(rbind, lapply(c(1:2), function(j){
  c(mean(HR.chain[,j], na.rm = TRUE), sd(HR.chain[,j], na.rm = TRUE))
}))
dimnames(HRest) &lt;- list(paramnames.hr, c("MEAN", "SD"))

cat("Numerical estimates using MCMC samples: \n", sep = "")
print(HRest)

# HALF-NORMAL FUNCTION (detFun = 0) 
sigma = 2
params &lt;- c(sigma)
names(params) &lt;- c("sigma")

HRAnim &lt;- getHomeRangeArea(x = params, detFun = 0, prob = prob, d = 6, 
                     xlim = c(0, dim(habitatMask)[2]), ylim = c(0, dim(habitatMask)[1]),
                     nBreaks = 800, tol = 1E-5, nIter = 2000)

HR.hn &lt;- c(HRAnim$run())
names(HR.hn) &lt;- paramnames.hr
print(HR.hn)

# Exponential (detFun = 2) 

rate = 1/2
params &lt;- c(rate)
names(params) &lt;- c("rate")
HRAnim &lt;- getHomeRangeArea(x = params, detFun = 2, prob = prob, d = 6, 
                     xlim = c(0, dim(habitatMask)[2]), ylim = c(0, dim(habitatMask)[1]),
                     nBreaks = 800, tol = 1E-5, nIter = 2000)
HR.exp &lt;- c(HRAnim$run())
names(HR.exp) &lt;- paramnames.hr
print(HR.exp)

# Asymmetric logistic (detFun = 3) 

sigma = 2
alpha.a = 5 
alpha.b = 1
params &lt;- c(sigma, alpha.a, alpha.b)
names(params) &lt;- c("sigma", "alpha.a", "alpha.b")
HRAnim &lt;- getHomeRangeArea(x = params, detFun = 3, prob = prob, d = 6, 
                     xlim = c(0, dim(habitatMask)[2]), ylim = c(0, dim(habitatMask)[1]),
                     nBreaks = 800, tol = 1E-5, nIter = 2000)
HR.al &lt;- c(HRAnim$run())
names(HR.al) &lt;- paramnames.hr
print(HR.al)


# Bimodal (detFun = 4) 

p0.a = 0.25
sigma.a = 0.5
p0.b = 0.15 
sigma.b = 1
w = 2
params &lt;- c(sigma.a, sigma.b, p0.a, p0.b, w)
names(params) &lt;- c("sigma.a", "sigma.b", "p0.a", "p0.b", "w")
HRAnim &lt;- getHomeRangeArea(x = params, detFun = 4, prob = prob, d = 6, 
                     xlim = c(0, dim(habitatMask)[2]), ylim = c(0, dim(habitatMask)[1]),
                     nBreaks = 800, tol = 1E-5, nIter = 2000)
HR.bi &lt;- c(HRAnim$run())
names(HR.bi) &lt;- paramnames.hr
print(HR.bi)

# Donut (detFun = 5) 

sigma.a = 1.5 
sigma.b = 1 
w = 1 
params &lt;- c(sigma.a, sigma.b, w)
names(params) &lt;- c("sigma.a", "sigma.b", "w")
HRAnim &lt;- getHomeRangeArea(x = params, detFun = 5, prob = prob, d = 6, 
                     xlim = c(0, dim(habitatMask)[2]), ylim = c(0, dim(habitatMask)[1]),
                     nBreaks = 800, tol = 1E-5, nIter = 2000)
HR.dn &lt;- c(HRAnim$run())
names(HR.dn) &lt;- paramnames.hr
print(HR.dn)


## End(Not run)

</code></pre>

<hr>
<h2 id='getLocalObjects'>Local Objects Identification</h2><span id='topic+getLocalObjects'></span>

<h3>Description</h3>

<p>R utility function to identify all objects (e.g. traps) within a given radius dmax of each cell in a habitat mask.
Used in the implementation of the local evaluation approach in SCR models (<code><a href="#topic+dbinomLocal_normal">dbinomLocal_normal</a></code>;<code><a href="#topic+dpoisLocal_normal">dpoisLocal_normal</a></code>).
The distance to the activity center and the detection probability are then calculated for local objects only (i.e. the detection probability is assumed to be 0 
for all other objects as they are far enough from the activity center).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLocalObjects(habitatMask, coords, dmax, resizeFactor = 1, plot.check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLocalObjects_+3A_habitatmask">habitatMask</code></td>
<td>
<p>a binary matrix object indicating which cells are considered as suitable habitat.</p>
</td></tr>
<tr><td><code id="getLocalObjects_+3A_coords">coords</code></td>
<td>
<p>A matrix giving the x- and y-coordinate of each object (i.e. trap). x- and y- coordinates should be scaled to the habitat (<code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="getLocalObjects_+3A_dmax">dmax</code></td>
<td>
<p>The maximal radius from a habitat cell center within which detection probability is evaluated locally for each trap.</p>
</td></tr>
<tr><td><code id="getLocalObjects_+3A_resizefactor">resizeFactor</code></td>
<td>
<p>An aggregation factor to reduce the number of habitat cells to retrieve local objects for. Defaults to 1; no aggregation.</p>
</td></tr>
<tr><td><code id="getLocalObjects_+3A_plot.check">plot.check</code></td>
<td>
<p>A visualization option (if TRUE); displays which objects are considered &quot;local objects&quot; for a randomly chosen habitat cell.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getLocalObjects</code> function is used in advance of model building.
</p>


<h3>Value</h3>

<p>This function returns a list of objects:
</p>

<ul>
<li><p> localIndices: a matrix with number of rows equal to the reduced number of habitat grid cells (following aggregation).
Each row gives the id numbers of the local objects associated with this grid cell.
</p>
</li>
<li><p> habitatGrid: a matrix of habitat grid cells ID corresponding to the row indices in localIndices. 
</p>
</li>
<li><p> numLocalIndices: a vector of the number of local objects for each habitat grid cell in habitatGrid.
</p>
</li>
<li><p> numLocalIndicesMax: the maximum number of local objects for any habitat grid cell ; corresponds to the number of columns in habitatGrid.
</p>
</li>
<li><p> resizeFactor: the aggregation factor used to reduce the number of habitat grid cells.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Cyril Milleret and Pierre Dupont
</p>


<h3>Examples</h3>

<pre><code class='language-R'>colNum &lt;- sample(20:100,1)
rowNum &lt;- sample(20:100,1)
coords &lt;- expand.grid(list(x = seq(0.5, colNum, 1),
                               y = seq(0.5, rowNum, 1)))

habitatMask &lt;- matrix(rbinom(colNum*rowNum, 1, 0.8), ncol = colNum, nrow = rowNum)

localObject.list &lt;- getLocalObjects(habitatMask, coords,  dmax = 7,resizeFactor = 1)

</code></pre>

<hr>
<h2 id='getMidPointNodes'>Generate midpoint integration nodes</h2><span id='topic+getMidPointNodes'></span>

<h3>Description</h3>

<p>Generate midpoint nodes and weights for integrating a function numerically over a set of windows. 
For each window, generate a set of equally spaced nodes and weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMidPointNodes(lowerCoords, upperCoords, numSubintervals = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMidPointNodes_+3A_lowercoords">lowerCoords</code>, <code id="getMidPointNodes_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of windows. One row for each window.</p>
</td></tr>
<tr><td><code id="getMidPointNodes_+3A_numsubintervals">numSubintervals</code></td>
<td>
<p>Number of subintervals each dimension of a window is divided into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of midpoint nodes and weights.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
getMidPointNodes(lowerCoords, upperCoords, 5)

</code></pre>

<hr>
<h2 id='getSparseY'>Sparse Matrix Preparation</h2><span id='topic+getSparseY'></span>

<h3>Description</h3>

<p>R utility function to turn a two or three-dimensional detection array into a sparse matrix representation (see Turek et al., 2021 &lt;doi.org/10.1002/ecs2.3385&gt;  for more details).
Used in the implementation of the <code><a href="#topic+dbinomLocal_normal">dbinomLocal_normal</a></code> and <code><a href="#topic+dpoisLocal_normal">dpoisLocal_normal</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSparseY(x, noDetections = -1, nMaxTraps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSparseY_+3A_x">x</code></td>
<td>
<p>A two- or three-dimensional observation data array with dimensions : number of  individuals, number of traps, (and number of detection occasions/sessions).</p>
</td></tr>
<tr><td><code id="getSparseY_+3A_nodetections">noDetections</code></td>
<td>
<p>The value indicating no detection. Defaults to -1.</p>
</td></tr>
<tr><td><code id="getSparseY_+3A_nmaxtraps">nMaxTraps</code></td>
<td>
<p>The maximum number of traps at which detections can occur. 
It is necessary to artificially augment the sparse detection array when using the random generation functionality of the <a href="#topic+rbinomLocal_normal">rbinomLocal_normal</a> or <a href="#topic+rpoisLocal_normal">rpoisLocal_normal</a> functions.
When simulating detection data, augmenting the size of the detection array is necessary to avoids artificially limiting the number of detectors at which individuals can be detected.
Default value is maxDetNums * 2, which doubles the maximum number of traps at which an individual can be detected. 
We generally recommend using <em>numLocalIndicesMax</em> obtained from <code><a href="#topic+getLocalObjects">getLocalObjects</a></code> when aiming at randomly generating detections from <a href="#topic+rbinomLocal_normal">rbinomLocal_normal</a> or <a href="#topic+rpoisLocal_normal">rpoisLocal_normal</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>getSparseY</code> function is used in advance of model building to create a sparse matrix representation of the observation data. 
It creates and returns a list of objects:
</p>


<h3>Value</h3>

<p>A list of objects which constitute a sparse representation of the observation data:
</p>

<ul>
<li> <p><em>detNums</em> A matrix with number of traps at which each individual (in rows) was detected at each occasions/sessions (in columns).
</p>
</li>
<li> <p><em>maxDetNums</em> The maximum number of traps at which an individual was detected (i.e., the maximum of <em>detNums</em>).
</p>
</li>
<li> <p><em>detIndices</em> An array of dimensions n.individuals, maxDetNums, and number of occasions/sessions, which contains the IDs of the traps where each individual was detected.
</p>
</li>
<li> <p><em>y</em> An array of dimensions n.individuals, maxDetNums, and occasions/sessions, which contains the number of observations of each individual at the traps it was detected at.
</p>
</li>
<li> <p><em>yCombined</em> An array that combines <em>detNums</em>, <em>y</em>, and <em>detIndices</em> by columns (in that specific order). 
Note that  <em>y</em>, and <em>detIndices</em> are augmented before combining, such that the maximum number of detectors at which an individual can be detected is equal to <em>nMaxTraps</em>
Consequently, the number of columns of <em>lengthYCombined</em> is 2*nMaxTraps + 1.
</p>
</li>
<li> <p><em>lengthYCombined</em> Dimension of the augmented lengthYCombined object to be specified as the argument <em>lengthYCombined</em> of the <code><a href="#topic+dbinomLocal_normal">dbinomLocal_normal</a></code>  or <code><a href="#topic+dpoisLocal_normal">dpoisLocal_normal</a></code> functions when simulating detection data.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Cyril Milleret
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y.full &lt;- matrix(rbinom(5000, 5, 0.02), ncol = 100)

y &lt;- getSparseY(y.full)

</code></pre>

<hr>
<h2 id='getWindowCoords'>Get lower and upper windows coordinates</h2><span id='topic+getWindowCoords'></span>

<h3>Description</h3>

<p>The <code>getWindowCoords</code> is an R utility function to create lower and upper habitat and observation windows coordinates, as well an habitat grid with cell ids. 
Those objects are necessary to run all point process (pp) functions. All input data should be scaled to the habitat grid using <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>. 
Note that we assume homogeneous window sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWindowCoords(
  scaledHabGridCenter = scaledHabGridCenter,
  scaledObsGridCenter = NULL,
  plot.check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWindowCoords_+3A_scaledhabgridcenter">scaledHabGridCenter</code></td>
<td>
<p>A matrix with the scaled &quot;x&quot; and &quot;y&quot; habitat windows grid cell centers (after using <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>).</p>
</td></tr>
<tr><td><code id="getWindowCoords_+3A_scaledobsgridcenter">scaledObsGridCenter</code></td>
<td>
<p>A matrix with the scaled &quot;x&quot; and &quot;y&quot; observation windows grid cell centers (afer using <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code>). 
This is an optional argument and only necessary when modelling detection as a point process (e.g. <code><a href="#topic+dpoisppDetection_normal">dpoisppDetection_normal</a></code>).</p>
</td></tr>
<tr><td><code id="getWindowCoords_+3A_plot.check">plot.check</code></td>
<td>
<p>A visualization option (if TRUE); displays habitat and detection windows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects :
</p>

<ul>
<li> <p><em>lowerHabCoords</em> A matrix with the &quot;x&quot; and &quot;y&quot; lower habitat window coordinates.
</p>
</li>
<li> <p><em>upperHabCoords</em> A matrix with the &quot;x&quot; and &quot;y&quot; upper habitat window coordinates.
</p>
</li>
<li> <p><em>habitatGrid</em> A matrix of habitat cell ID that can be used to lookup efficiently the cell ID from a coordinate scaled to the habitat grid:
habitatGrid[trunc(scaledHabGridCenter[1,&quot;y&quot;]) + 1, trunc(scaledHabGridCenter[1,&quot;x&quot;]) + 1]. See <code><a href="#topic+scaleCoordsToHabitatGrid">scaleCoordsToHabitatGrid</a></code> for more details.
</p>
</li>
<li> <p><em>lowerObsCoords</em> A matrix with the &quot;x&quot; and &quot;y&quot; lower observation window coordinates. Only returned when <em>scaledObsGridCenter</em> is provided.
</p>
</li>
<li> <p><em>upperObsCoords</em> A matrix with the &quot;x&quot; and &quot;y&quot; upper observation window coordinates. Only returned when <em>scaledObsGridCenter</em> is provided.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Cyril Milleret
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coordsGridCenter &lt;- expand.grid(list(x = seq(50.5, 100, 1),
                                     y = seq(100.5, 150, 1)))
coordsData &lt;- expand.grid(list(x = seq(60, 90, 1),
                               y = seq(110, 140, 1)))

plot(coordsGridCenter[,2] ~ coordsGridCenter[,1])
points(coordsData[,2] ~ coordsData[,1], col="red")
scaled &lt;- scaleCoordsToHabitatGrid(coordsData = coordsData
                                   , coordsHabitatGridCenter = coordsGridCenter)
plot(scaled$coordsHabitatGridCenterScaled[,2] ~ scaled$coordsHabitatGridCenterScaled[,1])
points(scaled$coordsDataScaled[,2] ~ scaled$coordsDataScaled[,1], col="red")

LowerAndUpperCoords &lt;- getWindowCoords(scaledHabGridCenter = scaled$coordsHabitatGridCenterScaled,
                                         scaledObsGridCenter = scaled$coordsDataScaled)

# Plot habitat window cell centers and lower/upper coordinates 
plot(scaled$coordsHabitatGridCenterScaled[,2] ~ 
     scaled$coordsHabitatGridCenterScaled[,1], 
     pch=16, cex=0.3, col=grey(0.5))
points(LowerAndUpperCoords$lowerHabCoords[,2] ~ 
       LowerAndUpperCoords$lowerHabCoords[,1],
       pch=16, cex=0.3, col=grey(0.1))
points(LowerAndUpperCoords$upperHabCoords[,2] ~
       LowerAndUpperCoords$upperHabCoords[,1],
       pch=16, cex=0.3, col=grey(0.1))

# Plot observation window cells center and lower/upper coordinates
points(scaled$coordsDataScaled[,2]~scaled$coordsDataScaled[,1], pch=16,
 cex=0.3, col = adjustcolor("red",alpha.f = 0.8))
points(LowerAndUpperCoords$lowerObsCoords[,2] ~ 
        LowerAndUpperCoords$lowerObsCoords[,1],
       pch=16, cex=0.3, col = adjustcolor("red", alpha.f = 0.8))
points(LowerAndUpperCoords$upperObsCoords[,2] ~
       LowerAndUpperCoords$upperObsCoords[,1],
       pch=16, cex=0.3, col = adjustcolor("red", alpha.f = 0.8))
       
</code></pre>

<hr>
<h2 id='getWindowIndex'>Get window index</h2><span id='topic+getWindowIndex'></span>

<h3>Description</h3>

<p>From a set of windows, find the index of the window into which a given point falls. 
Can be applied to detection and habitat windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWindowIndex(curCoords, lowerCoords, upperCoords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWindowIndex_+3A_curcoords">curCoords</code></td>
<td>
<p>Vector of coordinates of a single spatial point</p>
</td></tr>
<tr><td><code id="getWindowIndex_+3A_lowercoords">lowerCoords</code>, <code id="getWindowIndex_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of windows. One row for each window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Index of the window where the given point falls; -1 is returned if the point does not fall in any window.
</p>


<h3>Author(s)</h3>

<p>Pierre Dupont
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sourceCoords &lt;- c(1.5,2.2)
lowerCoords &lt;- cbind(c(0,1,3,0),c(0,1,2,2))
upperCoords &lt;- cbind(c(1,3,5,3),c(1,2,4,4))
getWindowIndex(sourceCoords, lowerCoords, upperCoords)

</code></pre>

<hr>
<h2 id='integrateIntensity_exp'>Integrate the multivariate exponential intensity</h2><span id='topic+integrateIntensity_exp'></span>

<h3>Description</h3>

<p>Calculate the integral of the intensity function with an isotropic multivariate exponential
kernel over a set of windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateIntensity_exp(
  lowerCoords,
  upperCoords,
  s,
  baseIntensities,
  lambda,
  numWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateIntensity_exp_+3A_lowercoords">lowerCoords</code>, <code id="integrateIntensity_exp_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of windows. One row for each window.</p>
</td></tr>
<tr><td><code id="integrateIntensity_exp_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the AC location.</p>
</td></tr>
<tr><td><code id="integrateIntensity_exp_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline intensities for all windows.</p>
</td></tr>
<tr><td><code id="integrateIntensity_exp_+3A_lambda">lambda</code></td>
<td>
<p>Rate parameter of the isotropic multivariate exponential distribution.</p>
</td></tr>
<tr><td><code id="integrateIntensity_exp_+3A_numwindows">numWindows</code></td>
<td>
<p>Total number of windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integrated intensities over all windows.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
s &lt;- c(1, 1)
lambda &lt;- 1.0
baseIntensities &lt;- c(1:4)
numWindows &lt;- 4
integrateIntensity_exp(lowerCoords, upperCoords, s, baseIntensities, lambda, numWindows)

</code></pre>

<hr>
<h2 id='integrateIntensity_normal'>Integrate the multivariate normal intensity</h2><span id='topic+integrateIntensity_normal'></span>

<h3>Description</h3>

<p>Calculate the integral of the intensity function with an isotropic multivariate normal
kernel over a set of windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateIntensity_normal(
  lowerCoords,
  upperCoords,
  s,
  baseIntensities,
  sd,
  numWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateIntensity_normal_+3A_lowercoords">lowerCoords</code>, <code id="integrateIntensity_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of windows. One row for each window.</p>
</td></tr>
<tr><td><code id="integrateIntensity_normal_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic multivariate normal distribution mean (AC location).</p>
</td></tr>
<tr><td><code id="integrateIntensity_normal_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline intensities for all windows.</p>
</td></tr>
<tr><td><code id="integrateIntensity_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="integrateIntensity_normal_+3A_numwindows">numWindows</code></td>
<td>
<p>Total number of windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integrated intensities over all windows.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
s &lt;- c(1, 1)
sd &lt;- 0.1
baseIntensities &lt;- c(1:4)
numWindows &lt;- 4
integrateIntensity_normal(lowerCoords, upperCoords, s, baseIntensities, sd, numWindows)

</code></pre>

<hr>
<h2 id='integrateIntensityLocal_exp'>Integrate the multivariate exponential intensity with local evaluation</h2><span id='topic+integrateIntensityLocal_exp'></span>

<h3>Description</h3>

<p>Calculate the integral of the intensity function with an isotropic multivariate exponential
kernel over a set of windows. The local evaluation technique is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateIntensityLocal_exp(
  lowerCoords,
  upperCoords,
  s,
  baseIntensities,
  lambda,
  numLocalWindows,
  localWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateIntensityLocal_exp_+3A_lowercoords">lowerCoords</code>, <code id="integrateIntensityLocal_exp_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of windows. One row for each window.</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_exp_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic multivariate exponential distribution mean (AC location).</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_exp_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline intensities for all windows.</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_exp_+3A_lambda">lambda</code></td>
<td>
<p>Rate parameter of the isotropic multivariate exponential distribution.</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_exp_+3A_numlocalwindows">numLocalWindows</code></td>
<td>
<p>Number of windows that are close to the activity center</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_exp_+3A_localwindows">localWindows</code></td>
<td>
<p>Vector of indices of the windows that are close to the activity center.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integrated intensities over all local windows.
</p>


<h3>Author(s)</h3>

<p>Cyril Milleret and Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
s &lt;- c(0.1, 0.9)
lambda &lt;- 0.1
baseIntensities &lt;- c(1:4)
numLocalWindows &lt;- 2
localWindows &lt;- c(1, 3)
integrateIntensityLocal_exp(lowerCoords, upperCoords,
                            s, baseIntensities, lambda, 
                            numLocalWindows, localWindows)

</code></pre>

<hr>
<h2 id='integrateIntensityLocal_normal'>Integrate the multivariate normal intensity with local evaluation</h2><span id='topic+integrateIntensityLocal_normal'></span>

<h3>Description</h3>

<p>Calculate the integral of the intensity function with an isotropic multivariate normal
kernel over a set of windows. The local evaluation technique is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateIntensityLocal_normal(
  lowerCoords,
  upperCoords,
  s,
  baseIntensities,
  sd,
  numLocalWindows,
  localWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integrateIntensityLocal_normal_+3A_lowercoords">lowerCoords</code>, <code id="integrateIntensityLocal_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of windows. One row for each window.</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_normal_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of the isotropic multivariate normal distribution mean (AC location).</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_normal_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline intensities for all windows.</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_normal_+3A_numlocalwindows">numLocalWindows</code></td>
<td>
<p>Number of windows that are close to the activity center</p>
</td></tr>
<tr><td><code id="integrateIntensityLocal_normal_+3A_localwindows">localWindows</code></td>
<td>
<p>Vector of indices of the windows that are close to the activity center.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of integrated intensities over all local windows.
</p>


<h3>Author(s)</h3>

<p>Cyril Milleret and Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
 upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
 s &lt;- c(0.1, 0.9)
 sd &lt;- 0.1
 baseIntensities &lt;- c(1:4)
 numLocalWindows &lt;- 2
 localWindows &lt;- c(1, 3)
 integrateIntensityLocal_normal(lowerCoords, upperCoords, s,
                                baseIntensities, sd,
                                numLocalWindows, localWindows)

</code></pre>

<hr>
<h2 id='localTrapCalculations'>Local Trap Calculations</h2><span id='topic+localTrapCalculations'></span><span id='topic+makeGrid'></span><span id='topic+findLocalTraps'></span><span id='topic+getNumLocalTraps'></span><span id='topic+getLocalTrapIndices'></span><span id='topic+calcLocalTrapDists'></span><span id='topic+calcLocalTrapExposure'></span>

<h3>Description</h3>

<p>These functions are deprecated, and they will be removed from a future release.  Utility functions to enable local trap calculations in SCR models.  See details section for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGrid(xmin = 0, ymin = 0, xmax, ymax, resolution = 1, buffer = 0)

findLocalTraps(grid, trapCoords, dmax)

getNumLocalTraps(idarg, nLocalTraps, LTD1arg)

getLocalTrapIndices(MAXNUM, localTraps, n, idarg)

calcLocalTrapDists(MAXNUM, n, localTrapInd, s, trapCoords)

calcLocalTrapExposure(R, n, d, localTrapInd, sigma, p0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localTrapCalculations_+3A_xmin">xmin</code></td>
<td>
<p>Minimal value among all trap location x-coordinates.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_ymin">ymin</code></td>
<td>
<p>Minimal value among all trap location y-coordinates.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_xmax">xmax</code></td>
<td>
<p>Maximal value among all trap location x-coordinates.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_ymax">ymax</code></td>
<td>
<p>Maximal value among all trap location y-coordinates.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_resolution">resolution</code></td>
<td>
<p>Desired resolution (in both x and y directions) of discretized grid.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_buffer">buffer</code></td>
<td>
<p>Horizontal and vertical buffer for discretized grid, specifying how much it should extend (above, below, left, and right) of the maximal trap locations.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_grid">grid</code></td>
<td>
<p>The grid object returned from the makeGrid function.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_trapcoords">trapCoords</code></td>
<td>
<p>An nTraps x 2 array giving giving the x- and y-coordinate locations of all traps.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_dmax">dmax</code></td>
<td>
<p>The maximal radius from an activity center for performing trap calculations (dmax).</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_idarg">idarg</code></td>
<td>
<p>A grid id, returned from the makeID function inside model code.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_nlocaltraps">nLocalTraps</code></td>
<td>
<p>The number of local traps to all grid cells, which is given by the first column of the localTraps array.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_ltd1arg">LTD1arg</code></td>
<td>
<p>The number of columns in the localTraps array.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_maxnum">MAXNUM</code></td>
<td>
<p>The maximum number of local traps among all grid cells.  This is given by the (number of rows)-1 of the localTraps array.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_localtraps">localTraps</code></td>
<td>
<p>The array returned from the findLocalTraps function.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_n">n</code></td>
<td>
<p>The number of local traps to a specified grid cell, as return.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_localtrapind">localTrapInd</code></td>
<td>
<p>The indices of the local traps to a grid cell, as returned by the getLocalTrapIndices function.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_s">s</code></td>
<td>
<p>A length-2 vector giving the activity center of an indiviual.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_r">R</code></td>
<td>
<p>The total number of traps.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_d">d</code></td>
<td>
<p>A vector of distances from an activity center to the local traps.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_sigma">sigma</code></td>
<td>
<p>Scale of decay for detection probability.</p>
</td></tr>
<tr><td><code id="localTrapCalculations_+3A_p0">p0</code></td>
<td>
<p>Baseline detection probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are deprecated, and they will be removed from a future release.
</p>
<p>The makeGrid function is used in advance of model building.  It creates and returns a list of two objects: a table (grid) corresponding to the discretized grid, where each row gives the x-coordinate, the y-coordinate, and the id number for a grid cell; and second, a function (makeID) to be used in the model code which operates on a discretized AC location, and returns the id number of the corresponding grid cell.
</p>
<p>The findLocalTraps function operates on the grid object returned from makeGrid, and an array of the trap location coordinates, and the desired maximal exposure radius for caluclations (dmax).  It returns a array (localTraps) with number of rows equal to the number of grid cells.  The first element of each row gives the number of local traps within exposure radius to that grid cell.  The following elements of each row give the id numbers of those local traps.
</p>
<p>A visualization function (plotTraps) is also provided in the example code, which displaces the discretized grid (small black points), all trap locations (green circles), a specified grid cell location (specified by i) as a large X, and the local traps to that specified grid cell (red circles).
</p>
<p>The getNumLocalTraps function is used inside the model code.  It operates on an id for a grid cell, the localTraps array (generated by findLocalTraps), and the constant value LTD1.  This function returns the number of traps which are local to a specified grid cell.
</p>
<p>The getLocalTrapIndices function is used inside the model code.  It returns a vector containing the ids of the local traps to a particular grid cell.
</p>
<p>The calcLocalTrapDists function is used inside the model code.  It calculates the distances from an activity center, to the local traps relative to the grid cell nearest that activity center.
</p>
<p>The calcLocalTrapExposure function is specific to the detection probability calculations used in this example.  This function should be modified specifically to the detection function, exposure function, or otherwise calculations to be done only for the traps in the vicinity of individual activity center locations
</p>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## generate random trap locations
nTraps &lt;- 200
traps_xmin &lt;- 0
traps_ymin &lt;- 0
traps_xmax &lt;- 100
traps_ymax &lt;- 200
set.seed(0)
traps_xCoords &lt;- round(runif(nTraps, traps_xmin, traps_xmax))
traps_yCoords &lt;- round(runif(nTraps, traps_ymin, traps_ymax))
trap_coords &lt;- cbind(traps_xCoords, traps_yCoords)
 
## buffer distance surrounding sides of rectangular discretization grid
## which overlays trap locations
buffer &lt;- 10
 
## resolution of rectangular discretization grid
resolution &lt;- 10
 
## creates grid and makeID function,
## for grid overlaying trap locations,
## and to lookup nearest grid cell to any AC
makeGridReturn &lt;- makeGrid(xmin = traps_xmin, xmax = traps_xmax,
                           ymin = traps_ymin, ymax = traps_ymax,
                           buffer = buffer,
                           resolution = resolution)
 
grid &lt;- makeGridReturn$grid
makeID &lt;- makeGridReturn$makeID
 
## maximum radis within an individual AC to perform trap calculations,
dmax &lt;- 30
 
## n = localTraps[i,1] gives the number of local traps
## localTraps[i, 2:(n+1)] gives the indices of the local traps
localTraps &lt;- findLocalTraps(grid, trap_coords, dmax)
 
plotTraps &lt;- function(i, grid, trap_coords, localTraps) {
    plot(grid[,1], grid[,2], pch = '.', cex=2)
    points(trap_coords[,1], trap_coords[,2], pch=20, col='forestgreen', cex=1)
    if(!missing(i)) {
        i &lt;- max(i %% dim(grid)[1], 1)
        n &lt;- localTraps[i,1]
        trapInd &lt;- numeric(0)
        if(n &gt; 0)  trapInd &lt;- localTraps[i,2:(n+1)]
        theseTraps &lt;- trap_coords[trapInd,, drop = FALSE]
        points(theseTraps[,1], theseTraps[,2], pch = 20, col = 'red', cex=1.5)
        points(grid[i,1], grid[i,2], pch = 'x', col = 'blue', cex=3)
    }
}
 
## visualise some local traps
plotTraps(10,  grid, trap_coords, localTraps)
plotTraps(200, grid, trap_coords, localTraps)
plotTraps(380, grid, trap_coords, localTraps)
 
## example model code
## using local trap calculations
code &lt;- nimbleCode({
    sigma ~ dunif(0, 100)
    p0 ~ dunif(0, 1)
    for(i in 1:N) {
        S[i,1] ~ dunif(0, xmax)
        S[i,2] ~ dunif(0, ymax)
        Sdiscrete[i,1] &lt;- round(S[i,1]/res) * res
        Sdiscrete[i,2] &lt;- round(S[i,2]/res) * res
        id[i] &lt;- makeID( Sdiscrete[i,1:2] )
        nLocalTraps[i] &lt;- getNumLocalTraps(id[i], localTraps[1:LTD1,1], LTD1)
        localTrapIndices[i,1:maxTraps] &lt;-
            getLocalTrapIndices(maxTraps, localTraps[1:LTD1,1:LTD2], nLocalTraps[i], id[i])
        d[i, 1:maxTraps] &lt;- calcLocalTrapDists(
            maxTraps, nLocalTraps[i], localTrapIndices[i,1:maxTraps],
            S[i,1:2], trap_coords[1:nTraps,1:2])
        g[i, 1:nTraps] &lt;- calcLocalTrapExposure(
            nTraps, nLocalTraps[i], d[i,1:maxTraps], localTrapIndices[i,1:maxTraps], sigma, p0)
        y[i, 1:nTraps] ~ dbinom_vector(prob = g[i,1:nTraps], size = trials[1:nTraps])
    }
})
 
## generate random detection data; completely random
N &lt;- 100
set.seed(0)
y &lt;- array(rbinom(N*nTraps, size=1, prob=0.8), c(N, nTraps))
 
## generate AC location initial values
Sinit &lt;- cbind(runif(N, traps_xmin, traps_xmax),
               runif(N, traps_ymin, traps_ymax))
 
constants &lt;- list(N = N,
                  nTraps = nTraps,
                  trap_coords = trap_coords,
                  xmax = traps_xmax,
                  ymax = traps_ymax,
                  res = resolution,
                  localTraps = localTraps,
                  LTD1 = dim(localTraps)[1],
                  LTD2 = dim(localTraps)[2],
                  maxTraps = dim(localTraps)[2] - 1)
 
data &lt;- list(y = y, trials = rep(1,nTraps))
 
inits &lt;- list(sigma = 1,
              p0 = 0.5,
              S = Sinit)
 
## create NIMBLE model object
Rmodel &lt;- nimbleModel(code, constants, data, inits,
                      calculate = FALSE, check = FALSE)
 
## use model object for MCMC, etc.


## End(Not run)

</code></pre>

<hr>
<h2 id='makeConstantNimbleFunction'><code>nimble</code> constant function generator</h2><span id='topic+makeConstantNimbleFunction'></span>

<h3>Description</h3>

<p>Create global constants that can be used in <code>nimble</code> functions.
As of <code>nimble</code> 0.6-12 there does not appear to be official support for global constants. 
This function creates functions that can be used in place of constants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeConstantNimbleFunction(inValue, isDouble = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeConstantNimbleFunction_+3A_invalue">inValue</code></td>
<td>
<p>Scalar to be set as a constant</p>
</td></tr>
<tr><td><code id="makeConstantNimbleFunction_+3A_isdouble">isDouble</code></td>
<td>
<p>Logical. If <code>TRUE</code> the constant is a numeric scalar, and if <code>FALSE</code> the constant is an integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the type returned by <code>nimbleFunction</code> that can be called inside
other <code>nimble</code> code to retrieve the value of the global constant.
</p>


<h3>Author(s)</h3>

<p>Joseph D. Chipperfield
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maxMNormTrunc &lt;- makeConstantNimbleFunction(0.0001, TRUE)   

</code></pre>

<hr>
<h2 id='marginalVoidProbIntegrand'>Integrand of the marginal void probability integral</h2><span id='topic+marginalVoidProbIntegrand'></span>

<h3>Description</h3>

<p>Integrand of the marginal void probability integral. The domain of this function is the habitat domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalVoidProbIntegrand(
  x,
  lowerCoords,
  upperCoords,
  sd,
  baseIntensities,
  numPoints,
  numWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalVoidProbIntegrand_+3A_x">x</code></td>
<td>
<p>Matrix of x- and y-coordinates of a set of spatial points. One row corresponds to one point.</p>
</td></tr>
<tr><td><code id="marginalVoidProbIntegrand_+3A_lowercoords">lowerCoords</code>, <code id="marginalVoidProbIntegrand_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of detection windows. One row for each window.</p>
</td></tr>
<tr><td><code id="marginalVoidProbIntegrand_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="marginalVoidProbIntegrand_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline detection intensities for all detection windows.</p>
</td></tr>
<tr><td><code id="marginalVoidProbIntegrand_+3A_numpoints">numPoints</code></td>
<td>
<p>Number of points that should be considered. This value (positive integer) is used to truncate <code>x</code> 
so that extra rows beyond <code>numPoints</code> are ignored.</p>
</td></tr>
<tr><td><code id="marginalVoidProbIntegrand_+3A_numwindows">numWindows</code></td>
<td>
<p>Number of windows. This value (positive integer) is used to truncate <code>lowerCoords</code> and <code>upperCoords</code> 
so that extra rows beyond <code>numWindows</code> are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values of the integrand evaluated at each point of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(10, 0, 2), nrow = 5)
lowerCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
sd &lt;- 0.1
baseIntensities &lt;- c(1:4)
numPoints &lt;- 5
numWindows &lt;- 4
marginalVoidProbIntegrand(x, lowerCoords, upperCoords, sd, baseIntensities, numPoints, numWindows)

</code></pre>

<hr>
<h2 id='marginalVoidProbNumIntegration'>Marginal void probability</h2><span id='topic+marginalVoidProbNumIntegration'></span>

<h3>Description</h3>

<p>Calculate the marginal void probability using the midpoint integration method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalVoidProbNumIntegration(
  quadNodes,
  quadWeights,
  numNodes,
  lowerCoords,
  upperCoords,
  sd,
  baseIntensities,
  habIntensities,
  sumHabIntensity,
  numObsWindows,
  numHabWindows
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_quadnodes">quadNodes</code></td>
<td>
<p>Three-dimensional array of nodes for midpoint integration. The dimension sizes are equal to 
the number of nodes per habitat window (1st), 2 (2nd), and the number of habitat windows (3rd).</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_quadweights">quadWeights</code></td>
<td>
<p>Vector of weights for midpoint integration.</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_numnodes">numNodes</code></td>
<td>
<p>Vector of numbers of nodes for all habitat windows.</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_lowercoords">lowerCoords</code>, <code id="marginalVoidProbNumIntegration_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrix of lower and upper x- and y-coordinates of all detection windows. One row for each window.</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_baseintensities">baseIntensities</code></td>
<td>
<p>Vector of baseline detection intensities for all detection windows.</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_habintensities">habIntensities</code></td>
<td>
<p>Vector of habitat intensities for all habitat windows.</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_sumhabintensity">sumHabIntensity</code></td>
<td>
<p>Total habitat selection intensity over all windows.</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_numobswindows">numObsWindows</code></td>
<td>
<p>Number of detection windows.</p>
</td></tr>
<tr><td><code id="marginalVoidProbNumIntegration_+3A_numhabwindows">numHabWindows</code></td>
<td>
<p>Number of habitat windows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The marginal void probability.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>References</h3>

<p>W. Zhang, J. D. Chipperfield, J. B. Illian, P. Dupont, C. Milleret, P. de Valpine and R. Bischof. 2020. 
A hierarchical point process model for spatial capture-recapture data. bioRxiv. DOI 10.1101/2020.10.06.325035
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lowerHabCoords &lt;- matrix(c(0, 0, 0, 1), nrow = 2, byrow = TRUE)
upperHabCoords &lt;- matrix(c(2, 1, 2, 2), nrow = 2, byrow = TRUE)
lowerObsCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperObsCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
nodesRes &lt;- getMidPointNodes(lowerHabCoords, upperHabCoords, 10)
quadNodes &lt;- nodesRes$quadNodes
quadWeights &lt;- nodesRes$quadWeights
numNodes &lt;- rep(100, 2)
sd &lt;- 0.1
baseDetIntensities &lt;- c(1:4)
habIntensities &lt;- c(1:2)
sumHabIntensity &lt;- sum(habIntensities * c(2, 2))
numObsWindows &lt;- 4
numHabWindows &lt;- 2
marginalVoidProbNumIntegration(quadNodes, quadWeights, numNodes,
                               lowerObsCoords, upperObsCoords, sd, 
                               baseDetIntensities, habIntensities,
                               sumHabIntensity, numObsWindows, numHabWindows)

</code></pre>

<hr>
<h2 id='sampler_categorical_general'><code>nimble</code> MCMC sampler function for general categorial distributions</h2><span id='topic+sampler_categorical_general'></span>

<h3>Description</h3>

<p>The <code>categorical_general</code> sampler operates within <code>nimble</code>'s MCMC engine to perform Gibbs sampling for a single node, which must in essence follow a categorical distribution.  However, the prior distribution need not be <code>nimble</code>'s <code>dcat</code> distribution, but rather can be any (potentially user-defined) distribution which has the same support as a standard categorical (<code>dcat</code>) distribution.  Specifically: the distribution must define a discrete random variable, which can only attain values from the set 1, 2, 3, ..., <code>numCategories</code>.
</p>
<p>The <code>categorical_general</code> sampler requires one control list argument, named <code>numCategories</code>, which specifies the fixed upper-bound for the range of the random variable.
</p>
<p>The <code>categorical_general</code> sampler is designed to be used in <code>nimble</code>'s MCMC engine, and can be added to an MCMC configuration object using the <code>addSampler</code> method.  See <code>help(configureMCMC)</code> for more information about MCMC configuration objects and adding custom samplers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_categorical_general(model, mvSaved, target, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler_categorical_general_+3A_model">model</code></td>
<td>
<p>(uncompiled) model on which the MCMC is to be run.</p>
</td></tr>
<tr><td><code id="sampler_categorical_general_+3A_mvsaved">mvSaved</code></td>
<td>
<p><code>modelValues</code> object to be used to store MCMC samples.</p>
</td></tr>
<tr><td><code id="sampler_categorical_general_+3A_target">target</code></td>
<td>
<p>node on which the sampler will operate.</p>
</td></tr>
<tr><td><code id="sampler_categorical_general_+3A_control">control</code></td>
<td>
<p>named list containing an elemente named <code>numCategories</code>, which specifies the upper-bound for the range of the random variable.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Turek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## define custom dmy_categorical distribution as a nimbleFunction
dmy_categorical &lt;- nimbleFunction(...)

## nimble model code, using custom-written dmy_categorical distribution
code &lt;- nimbleCode({
  x ~ dmy_categorical(...)
})

## create NIMBLE model object
Rmodel &lt;- nimbleModel(code)

## create MCMC configuration object with no samplers
conf &lt;- configureMCMC(Rmodel, nodes = NULL)

## add categorical_general sampler to MCMC configuration
conf$addSampler(target = 'x', type = 'categorical_general', control = list(numCategories = 10))

## build MCMC algorithm
Rmcmc &lt;- buildMCMC(conf)

## compile model and MCMC, run MCMC algorithm

## End(Not run)

</code></pre>

<hr>
<h2 id='scaleCoordsToHabitatGrid'>Scale x- and y-coordinates to grid cells coordinates.</h2><span id='topic+scaleCoordsToHabitatGrid'></span>

<h3>Description</h3>

<p>R utility function to scale x- and y- coordinates to the habitat grid.
Scaling the coordinates to the habitat grid allows implementation of the fast look-up approach to identify the habitat grid cell in which a point is located. 
This technique was first applied by Mike Meredith in SCR (<a href="https://mmeredith.net/blog/2013/1309_SECR_in_JAGS_patchy_habitat.htm">https://mmeredith.net/blog/2013/1309_SECR_in_JAGS_patchy_habitat.htm</a>).
Re-scaling the entire coordinate system of the data input is a requirement to run SCR models with the local evaluation approach. 
This function requires square grid cells and coordinates using projection with units in meters or km (e.g., UTM but not latitude/longitude)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleCoordsToHabitatGrid(
  coordsData = coordsData,
  coordsHabitatGridCenter = coordsHabitatGridCenter,
  scaleToGrid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleCoordsToHabitatGrid_+3A_coordsdata">coordsData</code></td>
<td>
<p>A matrix or array of x- and y-coordinates to be scaled to the habitat grid. x- and y- coordinates must be identified using &quot;x&quot; and &quot;y&quot; dimnames.</p>
</td></tr>
<tr><td><code id="scaleCoordsToHabitatGrid_+3A_coordshabitatgridcenter">coordsHabitatGridCenter</code></td>
<td>
<p>A matrix of x- and y-coordinates for each habitat grid cell center.</p>
</td></tr>
<tr><td><code id="scaleCoordsToHabitatGrid_+3A_scaletogrid">scaleToGrid</code></td>
<td>
<p>Defaults to TRUE. If FALSE, coordsData are already scaled and will be rescaled to its original coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of objects:
</p>

<ul>
<li><p> coordsDataScaled: A matrix or array of scaled (rescaled if scaleToGrid==FALSE) x- and y-coordinates for coordsData.
</p>
</li>
<li><p> coordsHabitatGridCenterScaled: A matrix of scaled x- and y-cell coordinates for coordsHabitatGridCenter.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Richard Bischof, Cyril Milleret
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coordsGridCenter &lt;- expand.grid(list(x = seq(50.5, 100, 1),
                                    y = seq(100.5, 150, 1)))
coordsData &lt;- expand.grid(list(x = seq(60, 90, 1),
                             y = seq(110, 140, 1)))
plot(coordsGridCenter[,2]~coordsGridCenter[,1])
points(coordsData[,2]~coordsData[,1], col="red")
scaled &lt;- scaleCoordsToHabitatGrid(coordsData = coordsData
                                  , coordsHabitatGridCenter = coordsGridCenter)
plot(scaled$coordsHabitatGridCenterScaled[,2]~scaled$coordsHabitatGridCenterScaled[,1])
points(scaled$coordsDataScaled[,2]~scaled$coordsDataScaled[,1], col="red")

</code></pre>

<hr>
<h2 id='stratRejectionSampler_exp'>Stratified rejection sampler for multivariate exponential point process</h2><span id='topic+stratRejectionSampler_exp'></span>

<h3>Description</h3>

<p>Simulate data using a stratified rejection sampler from a point process with an isotropic multivariate exponential decay kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratRejectionSampler_exp(
  numPoints,
  lowerCoords,
  upperCoords,
  s,
  windowIntensities,
  lambda
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratRejectionSampler_exp_+3A_numpoints">numPoints</code></td>
<td>
<p>Number of spatial points to generate.</p>
</td></tr>
<tr><td><code id="stratRejectionSampler_exp_+3A_lowercoords">lowerCoords</code>, <code id="stratRejectionSampler_exp_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of detection windows. One row for each window.</p>
</td></tr>
<tr><td><code id="stratRejectionSampler_exp_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of of the isotropic multivariate exponential distribution mean.</p>
</td></tr>
<tr><td><code id="stratRejectionSampler_exp_+3A_windowintensities">windowIntensities</code></td>
<td>
<p>Vector of integrated intensities over all detection windows.</p>
</td></tr>
<tr><td><code id="stratRejectionSampler_exp_+3A_lambda">lambda</code></td>
<td>
<p>Rate parameter of the isotropic multivariate exponential distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of x- and y-coordinates of the generated points. One row corresponds to one point.
</p>


<h3>Author(s)</h3>

<p>Wei Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numPoints &lt;- 10
lowerObsCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperObsCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
s &lt;- c(1, 1)
windowIntensities &lt;- c(1:4)
lambda &lt;- 0.1
stratRejectionSampler_exp(numPoints, lowerObsCoords, upperObsCoords, s, windowIntensities, lambda)

</code></pre>

<hr>
<h2 id='stratRejectionSampler_normal'>Stratified rejection sampler for multivariate normal point process</h2><span id='topic+stratRejectionSampler_normal'></span>

<h3>Description</h3>

<p>Simulate data using a stratified rejection sampler from a point process with an isotropic multivariate normal decay kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratRejectionSampler_normal(
  numPoints,
  lowerCoords,
  upperCoords,
  s,
  windowIntensities,
  sd
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratRejectionSampler_normal_+3A_numpoints">numPoints</code></td>
<td>
<p>Number of spatial points to generate.</p>
</td></tr>
<tr><td><code id="stratRejectionSampler_normal_+3A_lowercoords">lowerCoords</code>, <code id="stratRejectionSampler_normal_+3A_uppercoords">upperCoords</code></td>
<td>
<p>Matrices of lower and upper x- and y-coordinates of a set of detection windows. One row for each window.</p>
</td></tr>
<tr><td><code id="stratRejectionSampler_normal_+3A_s">s</code></td>
<td>
<p>Vector of x- and y-coordinates of of the isotropic multivariate normal distribution mean.</p>
</td></tr>
<tr><td><code id="stratRejectionSampler_normal_+3A_windowintensities">windowIntensities</code></td>
<td>
<p>Vector of integrated intensities over all detection windows.</p>
</td></tr>
<tr><td><code id="stratRejectionSampler_normal_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the isotropic multivariate normal distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of x- and y-coordinates of the generated points. One row corresponds to one point.
</p>


<h3>Author(s)</h3>

<p>Joseph D. Chipperfield and Wei Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numPoints &lt;- 10
lowerObsCoords &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1), nrow = 4, byrow = TRUE)
upperObsCoords &lt;- matrix(c(1, 1, 2, 1, 1, 2, 2, 2), nrow = 4, byrow = TRUE)
s &lt;- c(1, 1)
windowIntensities &lt;- c(1:4)
sd &lt;- 0.1
set.seed(0)
stratRejectionSampler_normal(numPoints, lowerObsCoords, upperObsCoords, s, windowIntensities, sd)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
