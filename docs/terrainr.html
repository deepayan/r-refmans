<!DOCTYPE html><html lang="en"><head><title>Help for package terrainr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {terrainr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#terrainr-package'><p>terrainr: Landscape Visualizations in R and 'Unity'</p></a></li>
<li><a href='#addbuff'><p>Add a uniform buffer around a bounding box for geographic coordinates</p></a></li>
<li><a href='#calc_haversine_distance'><p>Extract latitude and longitude from a provided object</p></a></li>
<li><a href='#combine_overlays'><p>Combine multiple image overlays into a single file</p></a></li>
<li><a href='#deg_to_rad'><p>Convert decimal degrees to radians</p></a></li>
<li><a href='#geom_spatial_rgb'><p>Plot RGB rasters in ggplot2</p></a></li>
<li><a href='#georeference_overlay'><p>Georeference image overlays based on a reference raster</p></a></li>
<li><a href='#get_centroid'><p>Get the great-circle centroid for latitude/longitude data</p></a></li>
<li><a href='#get_tiles'><p>A user-friendly way to get USGS National Map data tiles for an area</p></a></li>
<li><a href='#hit_national_map_api'><p>Hit the USGS 3DEP API and retrieve an elevation heightmap</p></a></li>
<li><a href='#make_manifest'><p>Transform rasters and write manifest file for import into Unity</p></a></li>
<li><a href='#make_unity'><p>Initialize terrain inside of a Unity project.</p></a></li>
<li><a href='#merge_rasters'><p>Merge multiple raster files into a single raster</p></a></li>
<li><a href='#point_from_distance'><p>Find latitude and longitude for a certain distance and azimuth from a point.</p></a></li>
<li><a href='#rad_to_deg'><p>Convert radians to degrees</p></a></li>
<li><a href='#raster_to_raw_tiles'><p>Crop a raster and convert the output tiles into new formats.</p></a></li>
<li><a href='#terrainr_bounding_box'><p>Construct a terrainr_bounding_box object</p></a></li>
<li><a href='#terrainr_bounding_box-class'><p>S4 class for bounding boxes in the format expected by <code>terrainr</code></p>
functions.</a></li>
<li><a href='#terrainr_coordinate_pair'><p>Construct a terrainr_coordinate_pair object.</p></a></li>
<li><a href='#terrainr_coordinate_pair-class'><p>S4 class for coordinate points in the format expected by</p>
<code>terrainr</code> functions.</a></li>
<li><a href='#vector_to_overlay'><p>Turn spatial vector data into an image overlay</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Landscape Visualizations in R and 'Unity'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the retrieval, manipulation, and visualization
    of 'geospatial' data, with an aim towards producing '3D' landscape
    visualizations in the 'Unity' '3D' rendering engine. Functions are
    also provided for retrieving elevation data and base map tiles from
    the 'USGS' National Map <a href="https://apps.nationalmap.gov/services/">https://apps.nationalmap.gov/services/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/terrainr/">https://docs.ropensci.org/terrainr/</a>,
<a href="https://github.com/ropensci/terrainr">https://github.com/ropensci/terrainr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/terrainr/issues">https://github.com/ropensci/terrainr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>base64enc, ggplot2 (&ge; 3.4.0), glue, grDevices, httr, magick
(&ge; 2.5.0), methods, png, rlang, sf (&ge; 1.0-5), terra, unifir,
units</td>
</tr>
<tr>
<td>Suggests:</td>
<td>brio, covr, jpeg, knitr, progress, progressr, rmarkdown,
testthat, tiff</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-04 12:52:23 UTC; mikemahoney218</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Mahoney <a href="https://orcid.org/0000-0003-2402-304X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mike Johnson [rev] (Mike reviewed the package (v. 0.2.1) for rOpenSci,
    see &lt;https://github.com/ropensci/software-review/issues/416&gt;),
  Sydney Foks [rev] (Sydney reviewed the package (v. 0.2.1) for rOpenSci,
    see &lt;https://github.com/ropensci/software-review/issues/416&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Mahoney &lt;mike.mahoney.218@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-04 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='terrainr-package'>terrainr: Landscape Visualizations in R and 'Unity'</h2><span id='topic+terrainr'></span><span id='topic+terrainr-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Functions for the retrieval, manipulation, and visualization of 'geospatial' data, with an aim towards producing '3D' landscape visualizations in the 'Unity' '3D' rendering engine. Functions are also provided for retrieving elevation data and base map tiles from the 'USGS' National Map <a href="https://apps.nationalmap.gov/services/">https://apps.nationalmap.gov/services/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Mahoney <a href="mailto:mike.mahoney.218@gmail.com">mike.mahoney.218@gmail.com</a> (<a href="https://orcid.org/0000-0003-2402-304X">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Mike Johnson (Mike reviewed the package (v. 0.2.1) for rOpenSci, see &lt;https://github.com/ropensci/software-review/issues/416&gt;) [reviewer]
</p>
</li>
<li><p> Sydney Foks (Sydney reviewed the package (v. 0.2.1) for rOpenSci, see &lt;https://github.com/ropensci/software-review/issues/416&gt;) [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://docs.ropensci.org/terrainr/">https://docs.ropensci.org/terrainr/</a>
</p>
</li>
<li> <p><a href="https://github.com/ropensci/terrainr">https://github.com/ropensci/terrainr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ropensci/terrainr/issues">https://github.com/ropensci/terrainr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addbuff'>Add a uniform buffer around a bounding box for geographic coordinates</h2><span id='topic+addbuff'></span><span id='topic+add_bbox_buffer'></span><span id='topic+add_bbox_buffer.sf'></span><span id='topic+add_bbox_buffer.Raster'></span><span id='topic+add_bbox_buffer.SpatRaster'></span><span id='topic+set_bbox_side_length'></span><span id='topic+set_bbox_side_length.sf'></span><span id='topic+set_bbox_side_length.Raster'></span><span id='topic+set_bbox_side_length.SpatRaster'></span>

<h3>Description</h3>

<p><a href="#topic+add_bbox_buffer">add_bbox_buffer</a> calculates the great circle distance both corners of
your bounding box are from the centroid and extends those by a set distance.
Due to using Haversine/great circle distance, latitude/longitude calculations
will not be exact.
</p>
<p><a href="#topic+set_bbox_side_length">set_bbox_side_length</a> is a thin wrapper around <a href="#topic+add_bbox_buffer">add_bbox_buffer</a> which sets
all sides of the bounding box to (approximately) a specified length.
</p>
<p>Both of these functions are intended to be used with geographic coordinate
systems (data using longitude and latitude for position). For projected
coordinate systems, a more sane approach is to use <a href="sf.html#topic+geos_unary">sf::st_buffer</a> to add a
buffer, or combine <a href="sf.html#topic+geos_unary">sf::st_centroid</a> with the buffer to set a specific side
length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_bbox_buffer(data, distance, distance_unit = "meters", error_crs = NULL)

## S3 method for class 'sf'
add_bbox_buffer(data, distance, distance_unit = "meters", error_crs = NULL)

## S3 method for class 'Raster'
add_bbox_buffer(data, distance, distance_unit = "meters", error_crs = NULL)

## S3 method for class 'SpatRaster'
add_bbox_buffer(data, distance, distance_unit = "meters", error_crs = NULL)

set_bbox_side_length(
  data,
  distance,
  distance_unit = "meters",
  error_crs = NULL
)

## S3 method for class 'sf'
set_bbox_side_length(
  data,
  distance,
  distance_unit = "meters",
  error_crs = NULL
)

## S3 method for class 'Raster'
set_bbox_side_length(
  data,
  distance,
  distance_unit = "meters",
  error_crs = NULL
)

## S3 method for class 'SpatRaster'
set_bbox_side_length(
  data,
  distance,
  distance_unit = "meters",
  error_crs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addbuff_+3A_data">data</code></td>
<td>
<p>The original data to add a buffer around. Must be either an <code>sf</code>
or <code>SpatRaster</code> object.</p>
</td></tr>
<tr><td><code id="addbuff_+3A_distance">distance</code></td>
<td>
<p>The distance to add or to set side lengths equal to.</p>
</td></tr>
<tr><td><code id="addbuff_+3A_distance_unit">distance_unit</code></td>
<td>
<p>The units of the distance to add to the buffer, passed
to <a href="units.html#topic+units">units::as_units</a>.</p>
</td></tr>
<tr><td><code id="addbuff_+3A_error_crs">error_crs</code></td>
<td>
<p>Logical: Should this function error if <code>data</code> has no CRS?
If <code>TRUE</code>, function errors; if <code>FALSE</code>, function quietly assumes EPSG:4326.
If <code>NULL</code>, the default, function assumes EPSG:4326 with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sfc</code> object (from <a href="sf.html#topic+st_as_sfc">sf::st_as_sfc</a>).
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+calc_haversine_distance">calc_haversine_distance</a>()</code>,
<code><a href="#topic+deg_to_rad">deg_to_rad</a>()</code>,
<code><a href="#topic+get_centroid">get_centroid</a>()</code>,
<code><a href="#topic+rad_to_deg">rad_to_deg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- data.frame(
  lat = c(44.04905, 44.17609),
  lng = c(-74.01188, -73.83493)
)

df_sf &lt;- sf::st_as_sf(df, coords = c("lng", "lat"))
df_sf &lt;- sf::st_set_crs(df_sf, 4326)

add_bbox_buffer(df_sf, 10)

df &lt;- data.frame(
  lat = c(44.04905, 44.17609),
  lng = c(-74.01188, -73.83493)
)

df_sf &lt;- sf::st_as_sf(df, coords = c("lng", "lat"))
df_sf &lt;- sf::st_set_crs(df_sf, 4326)

set_bbox_side_length(df_sf, 4000)
</code></pre>

<hr>
<h2 id='calc_haversine_distance'>Extract latitude and longitude from a provided object</h2><span id='topic+calc_haversine_distance'></span>

<h3>Description</h3>

<p>This is an internal utility function to convert bounding boxes into
coordinate pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_haversine_distance(point_1, point_2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_haversine_distance_+3A_point_1">point_1</code>, <code id="calc_haversine_distance_+3A_point_2">point_2</code></td>
<td>
<p>Coordinate pairs (as length-2 numeric vectors with the
names &quot;lat&quot; and &quot;lng&quot;) to calculate distance between.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length 1 containing distance between points
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+addbuff">addbuff</a></code>,
<code><a href="#topic+deg_to_rad">deg_to_rad</a>()</code>,
<code><a href="#topic+get_centroid">get_centroid</a>()</code>,
<code><a href="#topic+rad_to_deg">rad_to_deg</a>()</code>
</p>

<hr>
<h2 id='combine_overlays'>Combine multiple image overlays into a single file</h2><span id='topic+combine_overlays'></span>

<h3>Description</h3>

<p>This function combines any number of images into a single file, which may
then be further processed as an image or transformed into an image overlay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_overlays(
  ...,
  output_file = tempfile(fileext = ".png"),
  transparency = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_overlays_+3A_...">...</code></td>
<td>
<p>File paths for images to be combined. Note that combining TIFF
images requires the <code>tiff</code> package be installed.</p>
</td></tr>
<tr><td><code id="combine_overlays_+3A_output_file">output_file</code></td>
<td>
<p>The path to save the resulting image to. Can
be any format accepted by <a href="magick.html#topic+editing">magick::image_read</a>. Optionally, can be set to
<code>NULL</code>, in which case this function will return the image as a <code>magick</code>
object instead of writing to disk.</p>
</td></tr>
<tr><td><code id="combine_overlays_+3A_transparency">transparency</code></td>
<td>
<p>A value indicating how much transparency should be added
to each image. If less than 1, interpreted as a proportion (so a value of
0.1 results in each image becoming 10% more transparent); if between 1 and
100, interpreted as a percentage (so a value of 10 results in each image
becoming 10% more transparent.) A value of 0 is equivalent to no
additional transparency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>output_file</code> is not null, <code>output_file</code>, invisibly. If
<code>output_file</code> is null, a <code>magick</code> image object.
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+georeference_overlay">georeference_overlay</a>()</code>,
<code><a href="#topic+merge_rasters">merge_rasters</a>()</code>,
<code><a href="#topic+raster_to_raw_tiles">raster_to_raw_tiles</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>
<p>Other overlay creation functions: 
<code><a href="#topic+georeference_overlay">georeference_overlay</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>
<p>Other visualization functions: 
<code><a href="#topic+geom_spatial_rgb">geom_spatial_rgb</a>()</code>,
<code><a href="#topic+raster_to_raw_tiles">raster_to_raw_tiles</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate points and download orthoimagery
mt_elbert_points &lt;- data.frame(
  lat = runif(100, min = 39.11144, max = 39.12416),
  lng = runif(100, min = -106.4534, max = -106.437)
)

mt_elbert_sf &lt;- sf::st_as_sf(mt_elbert_points, coords = c("lng", "lat"))
sf::st_crs(mt_elbert_sf) &lt;- sf::st_crs(4326)

output_files &lt;- get_tiles(
  mt_elbert_sf,
  output_prefix = tempfile(),
  services = c("ortho")
)

# Merge orthoimagery into a single file
ortho_merged &lt;- merge_rasters(
  input_rasters = output_files[1],
  output_raster = tempfile(fileext = ".tif")
)

# Convert our points into an overlay
mt_elbert_overlay &lt;- vector_to_overlay(mt_elbert_sf,
  ortho_merged[[1]],
  size = 15,
  color = "red",
  na.rm = TRUE
)

# Combine the overlay with our orthoimage
ortho_with_points &lt;- combine_overlays(
  ortho_merged[[1]],
  mt_elbert_overlay
)

## End(Not run)

</code></pre>

<hr>
<h2 id='deg_to_rad'>Convert decimal degrees to radians</h2><span id='topic+deg_to_rad'></span>

<h3>Description</h3>

<p>Convert decimal degrees to radians
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg_to_rad(deg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deg_to_rad_+3A_deg">deg</code></td>
<td>
<p>A vector of values, in decimal degrees, to convert to radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length in radians
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+addbuff">addbuff</a></code>,
<code><a href="#topic+calc_haversine_distance">calc_haversine_distance</a>()</code>,
<code><a href="#topic+get_centroid">get_centroid</a>()</code>,
<code><a href="#topic+rad_to_deg">rad_to_deg</a>()</code>
</p>

<hr>
<h2 id='geom_spatial_rgb'>Plot RGB rasters in ggplot2</h2><span id='topic+geom_spatial_rgb'></span><span id='topic+StatSpatialRGB'></span><span id='topic+stat_spatial_rgb'></span>

<h3>Description</h3>

<p><code>geom_spatial_rgb</code> and <code>stat_spatial_rgb</code> allow users to plot three-band RGB
rasters in <a href="ggplot2.html#topic+ggplot2">ggplot2</a>, using these layers as background base maps for other
spatial plotting. Note that unlike <a href="ggplot2.html#topic+ggsf">ggplot2::geom_sf</a>, this function does
<em>not</em> force <a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf</a>; for accurate mapping, add
<a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf</a> with a <code>crs</code> value matching your input raster as a layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_spatial_rgb(
  mapping = NULL,
  data = NULL,
  stat = "spatialRGB",
  position = "identity",
  ...,
  hjust = 0.5,
  vjust = 0.5,
  interpolate = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  scale = NULL
)

stat_spatial_rgb(
  mapping = NULL,
  data = NULL,
  geom = "raster",
  position = "identity",
  na.rm = FALSE,
  show.legend = FALSE,
  inherit.aes = TRUE,
  scale = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_spatial_rgb_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. In addition to the three
options described in <a href="ggplot2.html#topic+geom_tile">ggplot2::geom_raster</a>, there are two additional
methods:
</p>
<p>If a <code>SpatRaster</code> object (see <a href="terra.html#topic+rast">terra::rast</a>), this function will coerce
the raster to a data frame and assume the raster bands are in RGB order
(while allowing for, but ignoring, a fourth alpha band).
</p>
<p>If a length-1 character vector, this function will attempt to load the object
via <a href="terra.html#topic+rast">terra::rast</a>.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this
layer, either as a <code>ggproto</code> <code>Geom</code> subclass or as a string naming the
stat stripped of the <code>stat_</code> prefix (e.g. <code>"count"</code> rather than
<code>"stat_count"</code>)</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_hjust">hjust</code>, <code id="geom_spatial_rgb_+3A_vjust">vjust</code></td>
<td>
<p>horizontal and vertical justification of the grob.  Each
justification value should be a number between 0 and 1.  Defaults to 0.5
for both, centering each pixel over its data location.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_interpolate">interpolate</code></td>
<td>
<p>If <code>TRUE</code> interpolate linearly, if <code>FALSE</code>
(the default) don't interpolate.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_scale">scale</code></td>
<td>
<p>Integer. Maximum (possible) value in the three channels.
If <code>NULL</code>, attempts to infer proper values from data &ndash; if all RGB values
are &lt;= 1 then 1, &lt;= 255 then 255, and otherwise 65535.</p>
</td></tr>
<tr><td><code id="geom_spatial_rgb_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data, either as a
<code>ggproto</code> <code>Geom</code> subclass or as a string naming the geom stripped of the
<code>geom_</code> prefix (e.g. <code>"point"</code> rather than <code>"geom_point"</code>)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other visualization functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+raster_to_raw_tiles">raster_to_raw_tiles</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

simulated_data &lt;- data.frame(
  id = seq(1, 100, 1),
  lat = runif(100, 44.04905, 44.17609),
  lng = runif(100, -74.01188, -73.83493)
)

simulated_data &lt;- sf::st_as_sf(simulated_data, coords = c("lng", "lat"))
simulated_data &lt;- sf::st_set_crs(simulated_data, 4326)

output_tiles &lt;- get_tiles(simulated_data,
  services = c("ortho"),
  resolution = 120
)

merged_ortho &lt;- tempfile(fileext = ".tif")
merge_rasters(output_tiles[["ortho"]], merged_ortho)

merged_stack &lt;- terra::rast(merged_ortho)

library(ggplot2)

ggplot() +
  geom_spatial_rgb(
    data = merged_ortho,
    mapping = aes(
      x = x,
      y = y,
      r = red,
      g = green,
      b = blue
    )
  ) +
  geom_sf(data = simulated_data) +
  coord_sf(crs = 4326)

ggplot() +
  geom_spatial_rgb(
    data = merged_stack,
    mapping = aes(
      x = x,
      y = y,
      r = red,
      g = green,
      b = blue
    )
  ) +
  geom_sf(data = simulated_data) +
  coord_sf(crs = 4326)

## End(Not run)

</code></pre>

<hr>
<h2 id='georeference_overlay'>Georeference image overlays based on a reference raster</h2><span id='topic+georeference_overlay'></span>

<h3>Description</h3>

<p>This function georeferences an image overlay based on a reference raster,
setting the extent and CRS of the image to those of the raster file. To
georeference multiple images and merge them into a single file, see
<a href="#topic+merge_rasters">merge_rasters</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>georeference_overlay(
  overlay_file,
  reference_raster,
  output_file = tempfile(fileext = ".tif")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="georeference_overlay_+3A_overlay_file">overlay_file</code></td>
<td>
<p>The image overlay to georeference. File format will be
detected automatically from file extension; options include <code>jpeg/jpg</code>,
<code>png</code>, and <code>tif/tiff</code>.</p>
</td></tr>
<tr><td><code id="georeference_overlay_+3A_reference_raster">reference_raster</code></td>
<td>
<p>The raster file to base georeferencing on. The output
image will have the same extent and CRS as the reference raster. Accepts
anything that can be read by <a href="terra.html#topic+rast">terra::rast</a></p>
</td></tr>
<tr><td><code id="georeference_overlay_+3A_output_file">output_file</code></td>
<td>
<p>The path to write the georeferenced image file to. Must
be a TIFF.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file path written to, invisibly.
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+merge_rasters">merge_rasters</a>()</code>,
<code><a href="#topic+raster_to_raw_tiles">raster_to_raw_tiles</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>
<p>Other overlay creation functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simulated_data &lt;- data.frame(
  id = seq(1, 100, 1),
  lat = runif(100, 44.1114, 44.1123),
  lng = runif(100, -73.92273, -73.92147)
)

simulated_data &lt;- sf::st_as_sf(simulated_data, coords = c("lng", "lat"))

downloaded_tiles &lt;- get_tiles(simulated_data,
  services = c("elevation", "ortho"),
  georeference = FALSE
)

georeference_overlay(
  overlay_file = downloaded_tiles[[2]],
  reference_raster = downloaded_tiles[[1]],
  output_file = tempfile(fileext = ".tif")
)

## End(Not run)

</code></pre>

<hr>
<h2 id='get_centroid'>Get the great-circle centroid for latitude/longitude data</h2><span id='topic+get_centroid'></span>

<h3>Description</h3>

<p>Get the great-circle centroid for latitude/longitude data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_centroid(lat, lng)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_centroid_+3A_lat">lat</code></td>
<td>
<p>A vector of latitudes in degrees.</p>
</td></tr>
<tr><td><code id="get_centroid_+3A_lng">lng</code></td>
<td>
<p>A vector of longitudes in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A latitude/longitude
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+addbuff">addbuff</a></code>,
<code><a href="#topic+calc_haversine_distance">calc_haversine_distance</a>()</code>,
<code><a href="#topic+deg_to_rad">deg_to_rad</a>()</code>,
<code><a href="#topic+rad_to_deg">rad_to_deg</a>()</code>
</p>

<hr>
<h2 id='get_tiles'>A user-friendly way to get USGS National Map data tiles for an area</h2><span id='topic+get_tiles'></span><span id='topic+get_tiles.sf'></span><span id='topic+get_tiles.sfc'></span><span id='topic+get_tiles.Raster'></span><span id='topic+get_tiles.SpatRaster'></span><span id='topic+get_tiles.list'></span>

<h3>Description</h3>

<p>This function splits the area contained within a bounding box into a set of
tiles, and retrieves data from the USGS National map for each tile. As of
version 0.5.0, the method for lists has been deprecated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tiles(
  data,
  output_prefix = tempfile(),
  side_length = NULL,
  resolution = 1,
  services = "elevation",
  verbose = FALSE,
  georeference = TRUE,
  projected = NULL,
  ...
)

## S3 method for class 'sf'
get_tiles(
  data,
  output_prefix = tempfile(),
  side_length = NULL,
  resolution = 1,
  services = "elevation",
  verbose = FALSE,
  georeference = TRUE,
  projected = NULL,
  ...
)

## S3 method for class 'sfc'
get_tiles(
  data,
  output_prefix = tempfile(),
  side_length = NULL,
  resolution = 1,
  services = "elevation",
  verbose = FALSE,
  georeference = TRUE,
  projected = NULL,
  ...
)

## S3 method for class 'Raster'
get_tiles(
  data,
  output_prefix = tempfile(),
  side_length = NULL,
  resolution = 1,
  services = "elevation",
  verbose = FALSE,
  georeference = TRUE,
  projected = NULL,
  ...
)

## S3 method for class 'SpatRaster'
get_tiles(
  data,
  output_prefix = tempfile(),
  side_length = NULL,
  resolution = 1,
  services = "elevation",
  verbose = FALSE,
  georeference = TRUE,
  projected = NULL,
  ...
)

## S3 method for class 'list'
get_tiles(
  data,
  output_prefix = tempfile(),
  side_length = NULL,
  resolution = 1,
  services = "elevation",
  verbose = FALSE,
  georeference = TRUE,
  projected = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_tiles_+3A_data">data</code></td>
<td>
<p>An <code>sf</code> or <code>SpatRaster</code> object; tiles will be downloaded for the
full extent of the provided object.</p>
</td></tr>
<tr><td><code id="get_tiles_+3A_output_prefix">output_prefix</code></td>
<td>
<p>The file prefix to use when saving tiles.</p>
</td></tr>
<tr><td><code id="get_tiles_+3A_side_length">side_length</code></td>
<td>
<p>The length, in meters, of each side of tiles to download.
If <code>NULL</code>, defaults to the maximum side length permitted by the least
permissive service requested.</p>
</td></tr>
<tr><td><code id="get_tiles_+3A_resolution">resolution</code></td>
<td>
<p>How many meters are represented by each pixel? The default
value of 1 means that 1 pixel = 1 meter, while a value of 2 means that
1 pixel = 2 meters, and so on.</p>
</td></tr>
<tr><td><code id="get_tiles_+3A_services">services</code></td>
<td>
<p>A character vector of services to download data from. Current
options include &quot;3DEPElevation&quot;, &quot;USGSNAIPPlus&quot;, and &quot;nhd&quot;. Users can also
use short codes to download a specific type of data without specifying the
source; current options for short codes include &quot;elevation&quot; (equivalent to
&quot;3DEPElevation&quot;), &quot;ortho&quot; (equivalent to &quot;USGSNAIPPlus), and &quot;hydro&quot; (&quot;nhd&quot;).
Short codes are
not guaranteed to refer to the same source across releases. Short codes are
converted to their service name and then duplicates are removed, so any given
source will only be queried once per tile.</p>
</td></tr>
<tr><td><code id="get_tiles_+3A_verbose">verbose</code></td>
<td>
<p>Logical: should tile retrieval functions run in verbose mode?</p>
</td></tr>
<tr><td><code id="get_tiles_+3A_georeference">georeference</code></td>
<td>
<p>Logical: should tiles be downloaded as PNGs without
georeferencing, or should they be downloaded as georeferenced TIFF files?
This option does nothing when only elevation data is being downloaded.</p>
</td></tr>
<tr><td><code id="get_tiles_+3A_projected">projected</code></td>
<td>
<p>Logical: is <code>data</code> in a projected coordinate reference
system? If <code>NULL</code>, the default, inferred from <a href="sf.html#topic+st_is_longlat">sf::st_is_longlat</a>.</p>
</td></tr>
<tr><td><code id="get_tiles_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <a href="#topic+hit_national_map_api">hit_national_map_api</a>.
These can be used to change default query parameters or as additional options
for the National Map services. See below for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the same length as the number of unique services requested,
containing named vectors of where data files were saved to. Returned
invisibly.
</p>


<h3>Available Datasources</h3>

<p>The following services are currently available
(with short codes in parentheses where applicable). See links for API
documentation.
</p>

<ul>
<li> <p><a href="https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer">3DEPElevation</a>
(short code: elevation)
</p>
</li>
<li> <p><a href="https://imagery.nationalmap.gov/arcgis/rest/services/USGSNAIPPlus/ImageServer/exportImage">USGSNAIPPlus</a>
(short code: ortho)
</p>
</li>
<li> <p><a href="https://imagery.nationalmap.gov/arcgis/rest/services/USGSNAIPImagery/ImageServer">USGSNAIPImagery</a>
</p>
</li>
<li> <p><a href="https://hydro.nationalmap.gov/arcgis/rest/services/nhd/MapServer">nhd</a>
(short code: hydro)
</p>
</li>
<li> <p><a href="https://carto.nationalmap.gov/arcgis/rest/services/govunits/MapServer">govunits</a>
</p>
</li>
<li> <p><a href="https://carto.nationalmap.gov/arcgis/rest/services/contours/MapServer">contours</a>
</p>
</li>
<li> <p><a href="https://carto.nationalmap.gov/arcgis/rest/services/geonames/MapServer">geonames</a>
</p>
</li>
<li> <p><a href="https://hydro.nationalmap.gov/arcgis/rest/services/NHDPlus_HR/MapServer">NHDPlus_HR</a>
</p>
</li>
<li> <p><a href="https://carto.nationalmap.gov/arcgis/rest/services/structures/MapServer">structures</a>
</p>
</li>
<li> <p><a href="https://carto.nationalmap.gov/arcgis/rest/services/transportation/MapServer">transportation</a>
</p>
</li>
<li> <p><a href="https://hydro.nationalmap.gov/arcgis/rest/services/wbd/MapServer">wbd</a>
(&quot;short code&quot;: watersheds)
</p>
</li>
<li> <p><a href="https://www.usgs.gov/centers/geosciences-and-environmental-change-science-center/science/global-ecosystems">ecosystems</a>
</p>
</li>
<li> <p><a href="https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer">USGSTopo</a>
</p>
</li>
<li> <p><a href="https://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer">USGSShadedReliefOnly</a>
</p>
</li>
<li> <p><a href="https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer">USGSImageryOnly</a>
</p>
</li>
<li> <p><a href="https://basemap.nationalmap.gov/arcgis/rest/services/USGSHydroCached/MapServer">USGSHydroCached</a>
</p>
</li>
<li> <p><a href="https://basemap.nationalmap.gov/arcgis/rest/services/USGSTNMBlank/MapServer">USGSTNMBlank</a>
</p>
</li></ul>



<h3>Additional Arguments</h3>

<p>The <code>...</code> argument can be used to pass additional arguments to the
National Map API or to edit the hard-coded defaults used by this function.
More information on common arguments to change can be found in
<a href="#topic+hit_national_map_api">hit_national_map_api</a>. Note that <code>...</code> can also be used to change
the formats returned by the server, but that doing so while using this
function will likely cause the function to error (or corrupt the output
data). To download files in different formats, use <a href="#topic+hit_national_map_api">hit_national_map_api</a>.
</p>


<h3>See Also</h3>

<p>Other data retrieval functions: 
<code><a href="#topic+hit_national_map_api">hit_national_map_api</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simulated_data &lt;- data.frame(
  id = seq(1, 100, 1),
  lat = runif(100, 44.04905, 44.17609),
  lng = runif(100, -74.01188, -73.83493)
)

simulated_data &lt;- sf::st_as_sf(simulated_data, coords = c("lng", "lat"))

get_tiles(simulated_data, tempfile())

## End(Not run)

</code></pre>

<hr>
<h2 id='hit_national_map_api'>Hit the USGS 3DEP API and retrieve an elevation heightmap</h2><span id='topic+hit_national_map_api'></span>

<h3>Description</h3>

<p>This function retrieves a single tile of data from a single National Map
service and returns the raw response. End users are recommended to use
<a href="#topic+get_tiles">get_tiles</a> instead, as it does much more validation and provides
a more friendly interface. For a description of the datasets provided by the
National Map, see <a href="https://apps.nationalmap.gov/services">https://apps.nationalmap.gov/services</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hit_national_map_api(
  bbox,
  img_width,
  img_height,
  service,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hit_national_map_api_+3A_bbox">bbox</code></td>
<td>
<p>An object from <a href="sf.html#topic+st_bbox">sf::st_bbox</a>.</p>
</td></tr>
<tr><td><code id="hit_national_map_api_+3A_img_width">img_width</code></td>
<td>
<p>The number of pixels in the x direction to retrieve</p>
</td></tr>
<tr><td><code id="hit_national_map_api_+3A_img_height">img_height</code></td>
<td>
<p>The number of pixels in the y direction to retrieve</p>
</td></tr>
<tr><td><code id="hit_national_map_api_+3A_service">service</code></td>
<td>
<p>A string indicating what service API to use. For a full list
of available services, see <a href="#topic+get_tiles">get_tiles</a>. Short codes are not accepted by this
function.</p>
</td></tr>
<tr><td><code id="hit_national_map_api_+3A_verbose">verbose</code></td>
<td>
<p>Logical: Print out the number of tries required to pull each
tile? Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="hit_national_map_api_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the National Map API.
These can be used to change default query parameters or as additional options
for the National Map services. See below for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raw vector.
</p>


<h3>Additional Arguments</h3>

<p>The <code>...</code> argument can be used to pass additional arguments to the
National Map API or to edit the hard-coded defaults used by this function.
Some of the most useful options that can be changed include:
</p>

<ul>
<li> <p><code>bboxSR</code>: The spatial reference of the bounding box given to this function.
If not specified, assumed to be
<a href="https://spatialreference.org/ref/epsg/wgs-84/">4326</a>.
</p>
</li>
<li> <p><code>imageSR</code>: The spatial reference of the image downloaded.
If not specified, assumed to be
<a href="https://spatialreference.org/ref/epsg/wgs-84/">4326</a>.
</p>
</li>
<li><p> layers: Which data layers to download. If the National Map API returns data
without specifying layers, this argument isn't used by default. When the
National Map requires this argument, the default value is 0.
</p>
</li>
<li><p> format: The image format to be downloaded. Defaults depend on the service
being used and are set to be compatible with <a href="#topic+get_tiles">get_tiles</a>.
</p>
</li></ul>

<p>Pass these arguments to <code>hit_national_map_api</code> like you would any other
argument to substitute new values. Note that <code>...</code> values are never
validated before being used; passing invalid parameters to <code>...</code> will
cause data retrieval to fail.
</p>


<h3>See Also</h3>

<p><a href="#topic+get_tiles">get_tiles</a> for a friendlier interface to the National
Map API.
</p>
<p>Other data retrieval functions: 
<code><a href="#topic+get_tiles">get_tiles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
hit_national_map_api(
  bbox = list(
    c(lat = 44.10438, lng = -74.01231),
    c(lat = 44.17633, lng = -73.91224)
  ),
  img_width = 8000,
  img_height = 8000,
  service = "3DEPElevation"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='make_manifest'>Transform rasters and write manifest file for import into Unity</h2><span id='topic+make_manifest'></span><span id='topic+transform_elevation'></span><span id='topic+transform_overlay'></span>

<h3>Description</h3>

<p>These functions crop input raster files into smaller square tiles and then
converts them into either .png or .raw files which are ready to be imported
into the Unity game engine. <a href="#topic+make_manifest">make_manifest</a> also writes a &quot;manifest&quot; file and
importer script which may be used to automatically import the tiles into
Unity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_manifest(
  heightmap,
  overlay = NULL,
  output_prefix = "import",
  manifest_path = "terrainr.manifest",
  importer_path = "import_terrain.cs"
)

transform_elevation(heightmap, side_length = 4097, output_prefix = "import")

transform_overlay(overlay, side_length = 4097, output_prefix = "import")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_manifest_+3A_heightmap">heightmap</code></td>
<td>
<p>File path to the heightmap to transform.</p>
</td></tr>
<tr><td><code id="make_manifest_+3A_overlay">overlay</code></td>
<td>
<p>File path to the image overlay to transform. Optional for
<a href="#topic+make_manifest">make_manifest</a>.</p>
</td></tr>
<tr><td><code id="make_manifest_+3A_output_prefix">output_prefix</code></td>
<td>
<p>The file path to prefix output tiles with.</p>
</td></tr>
<tr><td><code id="make_manifest_+3A_manifest_path">manifest_path</code></td>
<td>
<p>File path to write the manifest file to.</p>
</td></tr>
<tr><td><code id="make_manifest_+3A_importer_path">importer_path</code></td>
<td>
<p>File name to write the importer script to. Set to NULL
to not copy the importer script. Will overwrite any file at the same path.</p>
</td></tr>
<tr><td><code id="make_manifest_+3A_side_length">side_length</code></td>
<td>
<p>Side length, in pixels, of each output tile. If the raster
has dimensions not evenly divisible by <code>side_length</code>, tiles will be generated
with overhanging pieces set to 0 units of elevation or RGB 0 (pure black).
Side lengths not equal to 2^x + 1 (for x &lt;= 12) will cause a warning, as
tiles must be this size for import into Unity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>manifest_path</code>, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (!isTRUE(as.logical(Sys.getenv("CI")))) {
  simulated_data &lt;- data.frame(
    id = seq(1, 100, 1),
    lat = runif(100, 44.04905, 44.17609),
    lng = runif(100, -74.01188, -73.83493)
  )
  simulated_data &lt;- sf::st_as_sf(simulated_data, coords = c("lng", "lat"))
  output_files &lt;- get_tiles(simulated_data)
  temptiff &lt;- tempfile(fileext = ".tif")
  merge_rasters(output_files["elevation"][[1]], temptiff)
  make_manifest(temptiff, output_prefix = tempfile(), importer_path = NULL)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='make_unity'>Initialize terrain inside of a Unity project.</h2><span id='topic+make_unity'></span>

<h3>Description</h3>

<p>Initialize terrain inside of a Unity project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_unity(
  project,
  heightmap,
  overlay = NULL,
  side_length = 4097,
  scene_name = "terrainr_scene",
  action = TRUE,
  unity = find_unity()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_unity_+3A_project">project</code></td>
<td>
<p>The directory path of the Unity project to create terrain
inside.</p>
</td></tr>
<tr><td><code id="make_unity_+3A_heightmap">heightmap</code></td>
<td>
<p>The file path for the raster to transform into terrain.</p>
</td></tr>
<tr><td><code id="make_unity_+3A_overlay">overlay</code></td>
<td>
<p>Optionally, a file path for an image overlay to layer on top
of the terrain surface. Leave as NULL for no overlay.</p>
</td></tr>
<tr><td><code id="make_unity_+3A_side_length">side_length</code></td>
<td>
<p>The side length, in map units, for the terrain tiles.
Must be equal to 2^x + 1, for any x between 5 and 12.</p>
</td></tr>
<tr><td><code id="make_unity_+3A_scene_name">scene_name</code></td>
<td>
<p>The name of the Unity scene to create the terrain in.</p>
</td></tr>
<tr><td><code id="make_unity_+3A_action">action</code></td>
<td>
<p>Boolean: Execute the unifir &quot;script&quot; and create the Unity
project? If FALSE, returns a non-executed script.</p>
</td></tr>
<tr><td><code id="make_unity_+3A_unity">unity</code></td>
<td>
<p>The location of the Unity executable to create projects with.
By default, will be auto-detected by <a href="unifir.html#topic+find_unity">unifir::find_unity</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;unifir_script&quot;, containing either an executed
unifir script (if action = TRUE) or a non-executed script object
(if action = FALSE).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (!isTRUE(as.logical(Sys.getenv("CI")))) {
  simulated_data &lt;- data.frame(
    id = seq(1, 100, 1),
    lat = runif(100, 44.04905, 44.17609),
    lng = runif(100, -74.01188, -73.83493)
  )
  simulated_data &lt;- sf::st_as_sf(simulated_data, coords = c("lng", "lat"))
  output_files &lt;- get_tiles(simulated_data)
  temptiff &lt;- tempfile(fileext = ".tif")
  merge_rasters(output_files["elevation"][[1]], temptiff)
  make_unity(file.path(tempdir(), "unity"), temptiff)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='merge_rasters'>Merge multiple raster files into a single raster</h2><span id='topic+merge_rasters'></span>

<h3>Description</h3>

<p>Some functions like <a href="#topic+get_tiles">get_tiles</a> return multiple separate files
when it can be useful to have a single larger raster instead. This function
is a thin wrapper over <a href="sf.html#topic+gdal_utils">sf::gdal_utils</a>, making it easy to
collapse those multiple raster files into a single TIFF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_rasters(
  input_rasters,
  output_raster = tempfile(fileext = ".tif"),
  options = character(0),
  overwrite = FALSE,
  force_fallback = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_rasters_+3A_input_rasters">input_rasters</code></td>
<td>
<p>A character vector containing the file paths to the
georeferenced rasters you want to use.</p>
</td></tr>
<tr><td><code id="merge_rasters_+3A_output_raster">output_raster</code></td>
<td>
<p>The file path to save the merged georeferenced raster
to.</p>
</td></tr>
<tr><td><code id="merge_rasters_+3A_options">options</code></td>
<td>
<p>Optionally, a character vector of options to be passed
directly to <a href="sf.html#topic+gdal_utils">sf::gdal_utils</a>. If the fallback is used and any options (other
than &quot;-overwrite&quot;) are specified, this will issue a warning.</p>
</td></tr>
<tr><td><code id="merge_rasters_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical: overwrite <code>output_raster</code> if it exists? If FALSE
and the file exists, this function will fail with an error. The behavior if
this argument is TRUE and &quot;-overwrite&quot; is passed to <code>options</code> directly is
not stable.</p>
</td></tr>
<tr><td><code id="merge_rasters_+3A_force_fallback">force_fallback</code></td>
<td>
<p>Logical: if TRUE, uses the much slower fallback method
by default. This is used for testing purposes and is not recommended for use
by end users.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>output_raster</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+georeference_overlay">georeference_overlay</a>()</code>,
<code><a href="#topic+raster_to_raw_tiles">raster_to_raw_tiles</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
simulated_data &lt;- data.frame(
  lat = c(44.10379, 44.17573),
  lng = c(-74.01177, -73.91171)
)

simulated_data &lt;- sf::st_as_sf(simulated_data, coords = c("lng", "lat"))

img_files &lt;- get_tiles(simulated_data)
merge_rasters(img_files[[1]])

## End(Not run)

</code></pre>

<hr>
<h2 id='point_from_distance'>Find latitude and longitude for a certain distance and azimuth from a point.</h2><span id='topic+point_from_distance'></span>

<h3>Description</h3>

<p>Find latitude and longitude for a certain distance and azimuth from a point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_from_distance(
  coord_pair,
  distance,
  azimuth,
  distance_unit = "meters",
  azimuth_unit = c("degrees", "radians")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point_from_distance_+3A_coord_pair">coord_pair</code></td>
<td>
<p>A numeric vector of length 2 with names &quot;lat&quot; and &quot;lng&quot;</p>
</td></tr>
<tr><td><code id="point_from_distance_+3A_distance">distance</code></td>
<td>
<p>A distance (in meters) representing the distance away from
the original point to apply</p>
</td></tr>
<tr><td><code id="point_from_distance_+3A_azimuth">azimuth</code></td>
<td>
<p>A azimuth (in units specified in <code>azimuth_unit</code>)
representing the direction to apply the distance from the original point in</p>
</td></tr>
<tr><td><code id="point_from_distance_+3A_distance_unit">distance_unit</code></td>
<td>
<p>A string passed to convert_distance
indicating the units of the provided distance.</p>
</td></tr>
<tr><td><code id="point_from_distance_+3A_azimuth_unit">azimuth_unit</code></td>
<td>
<p>A string (either <code>degrees</code> or <code>radians</code>)
indicating the units of the <code>azimuth</code> argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+terrainr_coordinate_pair">terrainr_coordinate_pair</a>.
</p>

<hr>
<h2 id='rad_to_deg'>Convert radians to degrees</h2><span id='topic+rad_to_deg'></span>

<h3>Description</h3>

<p>Convert radians to degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rad_to_deg(rad)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rad_to_deg_+3A_rad">rad</code></td>
<td>
<p>A vector of values, in radians, to convert to decimal degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length in decimal degrees
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+addbuff">addbuff</a></code>,
<code><a href="#topic+calc_haversine_distance">calc_haversine_distance</a>()</code>,
<code><a href="#topic+deg_to_rad">deg_to_rad</a>()</code>,
<code><a href="#topic+get_centroid">get_centroid</a>()</code>
</p>

<hr>
<h2 id='raster_to_raw_tiles'>Crop a raster and convert the output tiles into new formats.</h2><span id='topic+raster_to_raw_tiles'></span>

<h3>Description</h3>

<p>This function has been deprecated as of terrainr 0.5.0 in favor of the new
function, <a href="#topic+make_manifest">make_manifest</a>. While it will be continued to be exported until
at least 2022, improvements and bug fixes will only be made to the new
function. Please open an issue if any features you relied upon is
missing from the new function!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_to_raw_tiles(input_file, output_prefix, side_length = 4097, raw = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raster_to_raw_tiles_+3A_input_file">input_file</code></td>
<td>
<p>File path to the input TIFF file to convert.</p>
</td></tr>
<tr><td><code id="raster_to_raw_tiles_+3A_output_prefix">output_prefix</code></td>
<td>
<p>The file path to prefix output tiles with.</p>
</td></tr>
<tr><td><code id="raster_to_raw_tiles_+3A_side_length">side_length</code></td>
<td>
<p>The side length, in pixels, for the .raw tiles.</p>
</td></tr>
<tr><td><code id="raster_to_raw_tiles_+3A_raw">raw</code></td>
<td>
<p>Logical: Convert the cropped tiles to .raw? When <code>FALSE</code>
returns a .png.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function crops input raster files into smaller square tiles and then
converts them into either .png or .raw files which are ready to be imported
into the Unity game engine.
</p>


<h3>Value</h3>

<p>Invisibly, a character vector containing the file paths that were
written to.
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+georeference_overlay">georeference_overlay</a>()</code>,
<code><a href="#topic+merge_rasters">merge_rasters</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>
<p>Other visualization functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+geom_spatial_rgb">geom_spatial_rgb</a>()</code>,
<code><a href="#topic+vector_to_overlay">vector_to_overlay</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (!isTRUE(as.logical(Sys.getenv("CI")))) {
  simulated_data &lt;- data.frame(
    id = seq(1, 100, 1),
    lat = runif(100, 44.04905, 44.17609),
    lng = runif(100, -74.01188, -73.83493)
  )
  simulated_data &lt;- sf::st_as_sf(simulated_data, coords = c("lng", "lat"))
  output_files &lt;- get_tiles(simulated_data)
  temptiff &lt;- tempfile(fileext = ".tif")
  merge_rasters(output_files["elevation"][[1]], temptiff)
  raster_to_raw_tiles(temptiff, tempfile())
}

## End(Not run)

</code></pre>

<hr>
<h2 id='terrainr_bounding_box'>Construct a terrainr_bounding_box object</h2><span id='topic+terrainr_bounding_box'></span>

<h3>Description</h3>

<p>In order to simplify code, most <code>terrainr</code> functions expect a set S4
class representation of coordinate pairs and bounding boxes. If the provided
data is not in the expected S4 format, these functions are used to cast the
data into the target class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terrainr_bounding_box(bl, tr, coord_units = "degrees")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terrainr_bounding_box_+3A_bl">bl</code>, <code id="terrainr_bounding_box_+3A_tr">tr</code></td>
<td>
<p>The bottom left (<code>bl</code>) and top right (<code>tr</code>) corners of
the bounding box, either as a <a href="#topic+terrainr_coordinate_pair">terrainr_coordinate_pair</a> object
or a coordinate pair. If the coordinate pair is not named, it is assumed to
be in (lat, lng) format; if it is named, the function will attempt to
properly identify coordinates.</p>
</td></tr>
<tr><td><code id="terrainr_bounding_box_+3A_coord_units">coord_units</code></td>
<td>
<p>Arguments passed to <a href="#topic+terrainr_coordinate_pair">terrainr_coordinate_pair</a>.
If <code>bl</code> and <code>tr</code> are already <a href="#topic+terrainr_coordinate_pair">terrainr_coordinate_pair</a>
objects, these arguments are not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+terrainr_bounding_box">terrainr_bounding_box</a>.
</p>

<hr>
<h2 id='terrainr_bounding_box-class'>S4 class for bounding boxes in the format expected by <code>terrainr</code>
functions.</h2><span id='topic+terrainr_bounding_box-class'></span>

<h3>Description</h3>

<p>S4 class for bounding boxes in the format expected by <code>terrainr</code>
functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>bl</code></dt><dd><p>A <code><a href="#topic+terrainr_coordinate_pair">terrainr_coordinate_pair</a></code> representing the bottom
left corner of the bounding box</p>
</dd>
<dt><code>tr</code></dt><dd><p>A <code><a href="#topic+terrainr_coordinate_pair">terrainr_coordinate_pair</a></code> representing the top right
corner of the bounding box</p>
</dd>
</dl>

<hr>
<h2 id='terrainr_coordinate_pair'>Construct a terrainr_coordinate_pair object.</h2><span id='topic+terrainr_coordinate_pair'></span>

<h3>Description</h3>

<p>In order to simplify code, most <code>terrainr</code> functions expect a set S4
class representation of coordinate pairs and bounding boxes. If the provided
data isn't in the expected S4 format, these functions are used to cast the
data into the target class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terrainr_coordinate_pair(coords, coord_units = c("degrees", "radians"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terrainr_coordinate_pair_+3A_coords">coords</code></td>
<td>
<p>A vector of length 2 containing a latitude and longitude. If
unnamed, coordinates are assumed to be in (latitude, longitude) format; if
named, the function will attempt to figure out which value represents which
coordinate. Currently this function understands &quot;lat&quot;, &quot;latitude&quot;, and &quot;y&quot; as
names for latitude and &quot;lng&quot;, &quot;long&quot;, &quot;longitude&quot;, and &quot;x&quot; for longitude.</p>
</td></tr>
<tr><td><code id="terrainr_coordinate_pair_+3A_coord_units">coord_units</code></td>
<td>
<p>String indicating whether coordinates are in degrees or
radians. Degrees stored in radians will be converted to degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>terrainr_coordinate_pair</code> object
</p>


<h3>See Also</h3>

<p>Other classes and related functions: 
<code><a href="#topic+terrainr_coordinate_pair-class">terrainr_coordinate_pair-class</a></code>
</p>

<hr>
<h2 id='terrainr_coordinate_pair-class'>S4 class for coordinate points in the format expected by
<code>terrainr</code> functions.</h2><span id='topic+terrainr_coordinate_pair-class'></span>

<h3>Description</h3>

<p>S4 class for coordinate points in the format expected by
<code>terrainr</code> functions.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lat</code></dt><dd><p>Numeric latitude, in decimal degrees</p>
</dd>
<dt><code>lng</code></dt><dd><p>Numeric longitude, in decimal degrees</p>
</dd>
</dl>


<h3>See Also</h3>

<p>Other classes and related functions: 
<code><a href="#topic+terrainr_coordinate_pair">terrainr_coordinate_pair</a></code>
</p>

<hr>
<h2 id='vector_to_overlay'>Turn spatial vector data into an image overlay</h2><span id='topic+vector_to_overlay'></span>

<h3>Description</h3>

<p>This function allows users to quickly transform any vector data into an
image overlay, which may then be imported as a texture into Unity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_to_overlay(
  vector_data,
  reference_raster,
  output_file = NULL,
  transparent = "#ffffff",
  ...,
  error_crs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector_to_overlay_+3A_vector_data">vector_data</code></td>
<td>
<p>The spatial vector data set to be transformed into an
overlay image. Users may provide either an <code>sf</code> object or a length 1
character vector containing a path to a file readable by <a href="sf.html#topic+st_read">sf::read_sf</a>.</p>
</td></tr>
<tr><td><code id="vector_to_overlay_+3A_reference_raster">reference_raster</code></td>
<td>
<p>The raster file to produce an overlay for. The output
overlay will have the same extent and resolution as the input raster. Users
may provide either a Raster* object or a length 1 character
vector containing a path to a file readable by <a href="terra.html#topic+rast">terra::rast</a>.</p>
</td></tr>
<tr><td><code id="vector_to_overlay_+3A_output_file">output_file</code></td>
<td>
<p>The path to save the image overlay to. If <code>NULL</code>, saves to
a tempfile.</p>
</td></tr>
<tr><td><code id="vector_to_overlay_+3A_transparent">transparent</code></td>
<td>
<p>The hex code for a color to be made transparent in the
final image. Set to <code>FALSE</code> to not set any colors to transparent.</p>
</td></tr>
<tr><td><code id="vector_to_overlay_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>...</code> in either <a href="ggplot2.html#topic+geom_point">ggplot2::geom_point</a> (for
point vector data), <a href="ggplot2.html#topic+geom_path">ggplot2::geom_line</a> (for line data),
or <a href="ggplot2.html#topic+geom_polygon">ggplot2::geom_polygon</a> (for all other data types).</p>
</td></tr>
<tr><td><code id="vector_to_overlay_+3A_error_crs">error_crs</code></td>
<td>
<p>Logical: Should this function error if <code>data</code> has no CRS?
If <code>TRUE</code>, function errors; if <code>FALSE</code>, function quietly assumes EPSG:4326.
If <code>NULL</code>, the default, function assumes EPSG:4326 with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>output_file</code>, invisibly.
</p>


<h3>See Also</h3>

<p>Other data manipulation functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+georeference_overlay">georeference_overlay</a>()</code>,
<code><a href="#topic+merge_rasters">merge_rasters</a>()</code>,
<code><a href="#topic+raster_to_raw_tiles">raster_to_raw_tiles</a>()</code>
</p>
<p>Other overlay creation functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+georeference_overlay">georeference_overlay</a>()</code>
</p>
<p>Other visualization functions: 
<code><a href="#topic+combine_overlays">combine_overlays</a>()</code>,
<code><a href="#topic+geom_spatial_rgb">geom_spatial_rgb</a>()</code>,
<code><a href="#topic+raster_to_raw_tiles">raster_to_raw_tiles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# Generate points to download raster tiles for
set.seed(123)
simulated_data &lt;- data.frame(
  id = seq(1, 100, 1),
  lat = runif(100, 44.1114, 44.1123),
  lng = runif(100, -73.92273, -73.92147)
)

# Create an sf object from our original simulated data

simulated_data_sf &lt;- sf::st_as_sf(simulated_data, coords = c("lng", "lat"))
sf::st_crs(simulated_data_sf) &lt;- sf::st_crs(4326)

# Download data!

downloaded_tiles &lt;- get_tiles(simulated_data_sf, tempfile())

merged_file &lt;- merge_rasters(
  downloaded_tiles[[1]],
  tempfile(fileext = ".tif")
)


# Create an overlay image
vector_to_overlay(simulated_data_sf, merged_file[[1]], na.rm = TRUE)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
