<!DOCTYPE html><html><head><title>Help for package RHPCBenchmark</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RHPCBenchmark}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CholeskyAllocator'><p>Allocates and initializes input to the Cholesky factorization dense matrix</p>
kernel microbenchmarks</a></li>
<li><a href='#CholeskyMicrobenchmark'><p>Conducts a single performance trial with the Cholesky factorization dense</p>
matrix kernel</a></li>
<li><a href='#ClaraClusteringMicrobenchmark'><p>Conducts a single performance trial with the cluster::clara function</p></a></li>
<li><a href='#ClusteringAllocator'><p>Allocates and initializes input to the clustering for machine learning</p>
microbenchmarks</a></li>
<li><a href='#ClusteringMicrobenchmark'><p>This class specifies a clustering for machine learning microbenchmark.</p></a></li>
<li><a href='#ComputeAverageTime'><p>Computes the average of a vector of performance trial times</p></a></li>
<li><a href='#ComputeStandardDeviation'><p>Computes the standard deviation of a vector of performance trial times</p></a></li>
<li><a href='#CrossprodAllocator'><p>Allocates and populates input to the matrix cross product dense matrix kernel</p>
microbenchmarks</a></li>
<li><a href='#CrossprodMicrobenchmark'><p>Conducts a single performance trial with the matrix cross product dense</p>
matrix kernel</a></li>
<li><a href='#DeformtransAllocator'><p>Allocates and populates input to the matrix deformation and transpose dense</p>
matrix kernel microbenchmarks</a></li>
<li><a href='#DeformtransMicrobenchmark'><p>Conducts a single performance trial with the matrix deformation and transpose</p>
dense matrix kernel</a></li>
<li><a href='#DenseMatrixMicrobenchmark'><p>This class specifies a dense matrix microbenchmark.</p></a></li>
<li><a href='#DeterminantAllocator'><p>Allocates and populates input to the matrix determinant dense matrix kernel</p>
microbenchmarks</a></li>
<li><a href='#DeterminantMicrobenchmark'><p>Conducts a single performance trial with the matrix determinant dense</p>
matrix kernel</a></li>
<li><a href='#EigenAllocator'><p>Allocates and populates input to the matrix eigendecomposition kernel</p>
microbenchmarks</a></li>
<li><a href='#EigenMicrobenchmark'><p>Conducts a single performance trial with the matrix eigendecomposition dense</p>
matrix kernel</a></li>
<li><a href='#GenerateClusterData'><p>Generates clusters from multivariate normal distributions</p></a></li>
<li><a href='#GetClusteringDefaultMicrobenchmarks'><p>Initializes the list of default clustering microbenchmarks</p></a></li>
<li><a href='#GetClusteringExampleMicrobenchmarks'><p>Initializes the list of example clustering microbenchmarks</p></a></li>
<li><a href='#GetConfigurableEnvParameter'><p>Retrieves the value of an environment variable referenced by another</p>
environment variable</a></li>
<li><a href='#GetDenseMatrixDefaultMicrobenchmarks'><p>Initializes the list of default dense matrix microbenchmarks</p></a></li>
<li><a href='#GetDenseMatrixExampleMicrobenchmarks'><p>Initializes the list of example dense matrix microbenchmarks</p></a></li>
<li><a href='#GetNumberOfThreads'><p>Retrieves the number of threads from the environment</p></a></li>
<li><a href='#GetSparseCholeskyDefaultMicrobenchmarks'><p>Initializes the list of default sparse Cholesky factorization</p>
microbenchmarks</a></li>
<li><a href='#GetSparseCholeskyExampleMicrobenchmarks'><p>Initializes the list of example sparse Cholesky factorization</p>
microbenchmarks</a></li>
<li><a href='#GetSparseLuDefaultMicrobenchmarks'><p>Initializes the list of default sparse LU factorization microbenchmarks</p></a></li>
<li><a href='#GetSparseMatrixVectorDefaultMicrobenchmarks'><p>Initializes the list of default sparse matrix-vector microbenchmarks</p></a></li>
<li><a href='#GetSparseMatrixVectorExampleMicrobenchmarks'><p>Initializes the list of example sparse matrix-vector microbenchmarks</p></a></li>
<li><a href='#GetSparseQrDefaultMicrobenchmarks'><p>Initializes the list of default sparse QR factorization microbenchmarks</p></a></li>
<li><a href='#LsfitAllocator'><p>Allocates and populates input to the matrix least squares fit dense matrix</p>
kernel microbenchmarks</a></li>
<li><a href='#LsfitMicrobenchmark'><p>Conducts a single performance trial with the matrix least squares fit dense</p>
matrix kernel</a></li>
<li><a href='#MatmatAllocator'><p>Allocates and populates input to the matrix-matrix multiplication dense</p>
matrix kernel microbenchmarks</a></li>
<li><a href='#MatmatMicrobenchmark'><p>Conducts a single performance trial with the matrix-matrix multiplication</p>
dense matrix kernel</a></li>
<li><a href='#MatvecAllocator'><p>Allocates and populates input to the matrix-vector multiplication dense</p>
matrix kernel microbenchmarks</a></li>
<li><a href='#MatvecMicrobenchmark'><p>Conducts a single performance trial with the matrix-vector multiplication</p>
dense matrix kernel</a></li>
<li><a href='#MicrobenchmarkClusteringKernel'><p>Performs microbenchmarking of a clustering for machine learning kernel</p></a></li>
<li><a href='#MicrobenchmarkDenseMatrixKernel'><p>Performs microbenchmarking of a dense matrix linear algebra kernel</p></a></li>
<li><a href='#MicrobenchmarkSparseMatrixKernel'><p>Performs microbenchmarking of a sparse matrix linear algebra kernel</p></a></li>
<li><a href='#PamClusteringMicrobenchmark'><p>Conducts a single performance trial with the cluster::pam function</p></a></li>
<li><a href='#PerformClusteringMicrobenchmarking'><p>Performs microbenchmarking of machine learning functions specified by an</p>
input list</a></li>
<li><a href='#PerformSparseMatrixKernelMicrobenchmarking'><p>Performs microbenchmarking of sparse matrix kernels specified by an input</p>
list</a></li>
<li><a href='#PrintClusteringMicrobenchmarkResults'><p>Prints results of a clustering for machine learning microbenchmark</p></a></li>
<li><a href='#PrintDenseMatrixMicrobenchmarkResults'><p>Prints results of a dense matrix microbenchmark</p></a></li>
<li><a href='#PrintSparseMatrixMicrobenchmarkResults'><p>Prints results of a sparse matrix microbenchmark</p></a></li>
<li><a href='#QrAllocator'><p>Allocates and populates input to the QR factorization dense matrix kernel</p>
microbenchmarks</a></li>
<li><a href='#QrMicrobenchmark'><p>Conducts a single performance trial with the QR factorization dense matrix</p>
kernel</a></li>
<li><a href='#RHPCBenchmark'><p>RHPCBenchmark: A package for performance testing intrinsic R functionality</p>
and established packages relevant to high-performance computing</a></li>
<li><a href='#RunDenseMatrixBenchmark'><p>Runs all of the dense matrix microbenchmarks</p></a></li>
<li><a href='#RunMachineLearningBenchmark'><p>Runs all of the machine learning microbenchmarks</p></a></li>
<li><a href='#RunSparseMatrixBenchmark'><p>Runs all of the sparse matrix microbenchmarks</p></a></li>
<li><a href='#SolveAllocator'><p>Allocates and populates input to the dense matrix kernel microbenchmark</p>
for computing the solution to a system of linear equations with multiple
right-hand sides</a></li>
<li><a href='#SolveMicrobenchmark'><p>Conducts a single performance trial with the dense matrix kernel for</p>
computing the solution to a system of linear equations with multiple
right-hand sides</a></li>
<li><a href='#SparseCholeskyAllocator'><p>Allocates and initializes input to the Cholesky factorization sparse</p>
matrix kernel microbenchmarks</a></li>
<li><a href='#SparseCholeskyMicrobenchmark'><p>Conducts a single performance trial with the Cholesky factorization</p>
sparse matrix kernel</a></li>
<li><a href='#SparseLuAllocator'><p>Allocates and initializes input to the LU factorization sparse matrix kernel</p>
microbenchmarks</a></li>
<li><a href='#SparseLuMicrobenchmark'><p>Conducts a single performance trial with the LU factorization sparse matrix</p>
kernel</a></li>
<li><a href='#SparseMatrixMicrobenchmark'><p>This class specifies a sparse matrix microbenchmark.</p></a></li>
<li><a href='#SparseMatrixVectorAllocator'><p>Allocates and initializes input to the matrix-vector multiplication sparse</p>
matrix kernel microbenchmarks</a></li>
<li><a href='#SparseMatrixVectorMicrobenchmark'><p>Conducts a single performance trial with the matrix-vector multiplication</p>
sparse matrix kernel</a></li>
<li><a href='#SparseQrAllocator'><p>Allocates and initializes input to the QR factorization sparse matrix kernel</p>
microbenchmarks</a></li>
<li><a href='#SparseQrMicrobenchmark'><p>Conducts a single performance trial with the QR factorization sparse matrix</p>
kernel</a></li>
<li><a href='#SvdAllocator'><p>Allocates and populates input to the singular value decomposition (SVD) dense</p>
matrix kernel microbenchmarks</a></li>
<li><a href='#SvdMicrobenchmark'><p>Conducts a single performance trial with the singular value decomposition</p>
(SVD) dense matrix kernel</a></li>
<li><a href='#TransposeAllocator'><p>Allocates and populates input to the matrix transpose dense matrix kernel</p>
microbenchmarks</a></li>
<li><a href='#TransposeMicrobenchmark'><p>Conducts a single performance trial with the matrix transpose dense matrix</p>
kernel</a></li>
<li><a href='#WriteClusteringPerformanceResultsCsv'><p>Appends performance test results of a clustering microbenchmark to a file in</p>
CSV format</a></li>
<li><a href='#WriteDenseMatrixPerformanceResultsCsv'><p>Appends dense matrix performance test results to a file in CSV format</p></a></li>
<li><a href='#WriteSparseMatrixPerformanceResultsCsv'><p>Appends sparse matrix performance test results to a file in CSV format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Benchmarks for High-Performance Computing Environments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>James McCombs [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James McCombs &lt;jmccombs@iu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Microbenchmarks for determining the run time
  performance of aspects of the R programming environment and packages
  relevant to high-performance computation.  The benchmarks are divided into
  three categories: dense matrix linear algebra kernels, sparse matrix linear
  algebra kernels, and machine learning functionality.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.1), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, mvtnorm, cluster, Matrix</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-05-23 15:43:29 UTC; jmccombs</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-05-23 17:26:28 UTC</td>
</tr>
</table>
<hr>
<h2 id='CholeskyAllocator'>Allocates and initializes input to the Cholesky factorization dense matrix
kernel microbenchmarks</h2><span id='topic+CholeskyAllocator'></span>

<h3>Description</h3>

<p><code>CholeskyAllocator</code> allocates and populates the input to the
Cholesky factorization dense matrix kernel for the purposes of conducting a
single performance trial with the <code>CholeskyMicrobenchmark</code> function.
The matrices or vectors corresponding to the <code>index</code> parameter must be
allocated, populated and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CholeskyAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CholeskyAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="CholeskyAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the matrices or vectors to be input for the
dense matrix kernel for which a single performance trial is to be
conducted.
</p>

<hr>
<h2 id='CholeskyMicrobenchmark'>Conducts a single performance trial with the Cholesky factorization dense
matrix kernel</h2><span id='topic+CholeskyMicrobenchmark'></span>

<h3>Description</h3>

<p><code>CholeskyMicrobenchmark</code> conducts a single performance trial of the
Cholesky factorization dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>chol(kernelParameters$A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CholeskyMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CholeskyMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="CholeskyMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the user, system, and elapsed performance
timings in that order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the Cholesky microbenchmark for the first matrix size
# to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- CholeskyAllocator(microbenchmarks[["cholesky"]], 1)
# Execute the microbenchmark
timings &lt;- CholeskyMicrobenchmark(microbenchmarks[["cholesky"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='ClaraClusteringMicrobenchmark'>Conducts a single performance trial with the cluster::clara function</h2><span id='topic+ClaraClusteringMicrobenchmark'></span>

<h3>Description</h3>

<p><code>ClusteringMicrobenchmark</code> conducts a single performance trial
of the cluster::clara function with the data given in the
<code>kernelParameters</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClaraClusteringMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClaraClusteringMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the cluster::clara function</p>
</td></tr>
<tr><td><code id="ClaraClusteringMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of data objects to be used as input to
the clustering function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the user, system, and elapsed performance
timings in that order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the pam clustering microbenchmark
microbenchmarks &lt;- GetClusteringExampleMicrobenchmarks()
kernelParameters &lt;- ClusteringAllocator(microbenchmarks[["clara_cluster_3_3_1000"]])
# Execute the microbenchmark
timings &lt;- ClaraClusteringMicrobenchmark(
   microbenchmarks[["clara_cluster_3_3_1000"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='ClusteringAllocator'>Allocates and initializes input to the clustering for machine learning
microbenchmarks</h2><span id='topic+ClusteringAllocator'></span>

<h3>Description</h3>

<p><code>ClusteringAllocator</code> allocates and initializes the data sets that are
input to the clustering microbenchmarks for the purposes of conducting a
single performance trial with one of the clustering microbenchmark functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClusteringAllocator(benchmarkParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClusteringAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code> specifying various parameters
needed to generate input for the clustering microbenchmarks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the data objects to be input to the
clustering microbenchmark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PamClusteringMicrobenchmark">PamClusteringMicrobenchmark</a></code> <code><a href="#topic+ClaraClusteringMicrobenchmark">ClaraClusteringMicrobenchmark</a></code>
</p>

<hr>
<h2 id='ClusteringMicrobenchmark'>This class specifies a clustering for machine learning microbenchmark.</h2><span id='topic+ClusteringMicrobenchmark'></span>

<h3>Description</h3>

<p>This class specifies a clustering for machine learning microbenchmark.
</p>


<h3>Fields</h3>


<dl>
<dt><code>active</code></dt><dd><p>a logical indicating whether the microbenchmark is to be
executed (TRUE) or not (FALSE).</p>
</dd>
<dt><code>benchmarkName</code></dt><dd><p>a character string that is the name of the
microbenchmark.</p>
</dd>
<dt><code>benchmarkDescription</code></dt><dd><p>a character string describing the microbenchmark.</p>
</dd>
<dt><code>dataObjectName</code></dt><dd><p>a character string specifying the name of the data
object that is input to the benchmark; the object must be stored in
the R data file with the same base name and a <code>.RData</code> extension.
Setting the field to <code>NA_character_</code> indicates that the test data will
be dynamically generated by the function given in the
<code>allocatorFunction</code> field instead of read from a data file.</p>
</dd>
<dt><code>numberOfFeatures</code></dt><dd><p>the number features; this value must match the
number of features in the data set given by the field <code>dataObjectName</code>
unless the field is populated with <code>NA_character_</code>.</p>
</dd>
<dt><code>numberOfClusters</code></dt><dd><p>the number of clusters in the data set; this value
must match the number of clusters in the data set given by the field
<code>dataObjectName</code> unless the field is populated with
<code>NA_character_</code>.</p>
</dd>
<dt><code>numberOfFeatureVectorsPerCluster</code></dt><dd><p>the number of feature vectors per
cluster; this value must match the number of clusters in the data set given
by the field <code>dataObjectName</code> unless the field is populated with
<code>NA_character_</code>.</p>
</dd>
<dt><code>numberOfTrials</code></dt><dd><p>an integer specifying the number of performance
trials conducted on the data set to be tested.</p>
</dd>
<dt><code>numberOfWarmupTrials</code></dt><dd><p>an integer specifying the number of warmup
trials to be conducted on the data set.</p>
</dd>
<dt><code>allocatorFunction</code></dt><dd><p>the function that allocates and initializes input
to the benchmark function.  The function takes a
<code>ClusteringMicrobenchmark</code> object.  For clustering benchmarks, the
allocator function should return a list containing the following items:
</p>

<dl>
<dt>featureVectors</dt><dd><p>a matrix, the rows of which are the feature
vectors</p>
</dd>
<dt>numberOfFeatures</dt><dd><p>an integer indicating the number of features</p>
</dd>
<dt>numberOfFeatureVectors</dt><dd><p>an integer indicating the number of feature
vectors</p>
</dd>
<dt>numberOfClusters</dt><dd><p>an integer indicating the number of clusters in
the data set</p>
</dd>
</dl>
</dd>
<dt><code>benchmarkFunction</code></dt><dd><p>the benchmark function which executes the
functionality to be timed.  The function takes a
<code>SparseMatrixMicrobenchmark</code> and a list of kernel parameters
returned by the allocator function.</p>
</dd>
</dl>

<hr>
<h2 id='ComputeAverageTime'>Computes the average of a vector of performance trial times</h2><span id='topic+ComputeAverageTime'></span>

<h3>Description</h3>

<p><code>ComputeAverageTime</code> computes the average of a vector of performance
trial times.  The average is computed only over the first
<code>numberOfSuccessfulTrials</code> elements of the <code>times</code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeAverageTime(numberOfSuccessfulTrials, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeAverageTime_+3A_numberofsuccessfultrials">numberOfSuccessfulTrials</code></td>
<td>
<p>the number of successful performance trials
to be averaged over</p>
</td></tr>
<tr><td><code id="ComputeAverageTime_+3A_times">times</code></td>
<td>
<p>a vector of wall clock times for the performance trials</p>
</td></tr>
</table>

<hr>
<h2 id='ComputeStandardDeviation'>Computes the standard deviation of a vector of performance trial times</h2><span id='topic+ComputeStandardDeviation'></span>

<h3>Description</h3>

<p><code>ComputeStandardDeviation</code> computes the standard deviation of a vector
of performance trial times.  The standard deviation is computed only over
the first <code>numberOfSuccessfulTrials</code> elements of the <code>times</code>
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeStandardDeviation(numberOfSuccessfulTrials, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeStandardDeviation_+3A_numberofsuccessfultrials">numberOfSuccessfulTrials</code></td>
<td>
<p>the number of successful performance trials
over which the standard deviation will be computed</p>
</td></tr>
<tr><td><code id="ComputeStandardDeviation_+3A_times">times</code></td>
<td>
<p>a vector of wall clock times for the performance trials</p>
</td></tr>
</table>

<hr>
<h2 id='CrossprodAllocator'>Allocates and populates input to the matrix cross product dense matrix kernel
microbenchmarks</h2><span id='topic+CrossprodAllocator'></span>

<h3>Description</h3>

<p><code>CrossprodAllocator</code> allocates and populates the input to the
matrix cross product dense matrix kernel for the purposes of conducting a
single performance trial with the <code>CrossprodMicrobenchmark</code> function.
The matrices or vectors corresponding to the <code>index</code> parameter must be
allocated, initialized and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossprodAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CrossprodAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="CrossprodAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='CrossprodMicrobenchmark'>Conducts a single performance trial with the matrix cross product dense
matrix kernel</h2><span id='topic+CrossprodMicrobenchmark'></span>

<h3>Description</h3>

<p><code>CrossprodMicrobenchmark</code> conducts a single performance trial of the
matrix cross product dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>crossprod(kernelParameters$A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CrossprodMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CrossprodMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="CrossprodMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the matrix cross product microbenchmark for the first
# matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- CrossprodAllocator(microbenchmarks[["crossprod"]], 1)
# Execute the microbenchmark
timings &lt;- CrossprodMicrobenchmark(microbenchmarks[["crossprod"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='DeformtransAllocator'>Allocates and populates input to the matrix deformation and transpose dense
matrix kernel microbenchmarks</h2><span id='topic+DeformtransAllocator'></span>

<h3>Description</h3>

<p><code>DeformtransAllocator</code> allocates and populates the input to the
matrix deformation and transpose dense matrix kernel for the purposes of
conducting a single performance trial with the
<code>DeformtransMicrobenchmark</code> function.  The matrices or vectors
corresponding to the <code>index</code> parameter must be allocated, initialized
and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeformtransAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DeformtransAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="DeformtransAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='DeformtransMicrobenchmark'>Conducts a single performance trial with the matrix deformation and transpose
dense matrix kernel</h2><span id='topic+DeformtransMicrobenchmark'></span>

<h3>Description</h3>

<p><code>DeformtransMicrobenchmark</code> conducts a single performance trial of the
matrix deformation and transpose dense matrix kernel for the matrix given in
the <code>kernelParameters</code> parameter.  The function times the transposition
of the input matrix, resizing of the input matrix, and transposition of the
resized matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeformtransMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DeformtransMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="DeformtransMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the matrix deformation and transpose microbenchmark for
# the first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- DeformtransAllocator(microbenchmarks[["deformtrans"]], 1)
# Execute the microbenchmark
timings &lt;- DeformtransMicrobenchmark(microbenchmarks[["deformtrans"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='DenseMatrixMicrobenchmark'>This class specifies a dense matrix microbenchmark.</h2><span id='topic+DenseMatrixMicrobenchmark'></span>

<h3>Description</h3>

<p>This class specifies a dense matrix microbenchmark.
</p>


<h3>Fields</h3>


<dl>
<dt><code>active</code></dt><dd><p>a logical indicating whether the microbenchmark is to be
executed (TRUE) or not (FALSE).</p>
</dd>
<dt><code>benchmarkName</code></dt><dd><p>a character string that is the name of the
microbenchmark.</p>
</dd>
<dt><code>benchmarkDescription</code></dt><dd><p>a character string describing the microbenchmark.</p>
</dd>
<dt><code>dimensionParameters</code></dt><dd><p>an integer vector specifying the dimension
parameters the microbenchmark uses to define the matrix dimensions to be
tested with.</p>
</dd>
<dt><code>numberOfTrials</code></dt><dd><p>an integer vector specifying the number of performance
trials conducted for each matrix to be tested.  Must be the same length as
<code>dimensionParameters</code>.</p>
</dd>
<dt><code>numberOfWarmupTrials</code></dt><dd><p>an integer vector specifying the number of warmup
trials to be performed for each matrix to be tested.</p>
</dd>
<dt><code>allocatorFunction</code></dt><dd><p>the function that allocates and initializes input to
the benchmark function.  The function takes a
<code>DenseMatrixMicrobenchmark</code> object and an integer index indicating
which matrix dimension parameter from <code>dimensionParameters</code> should
be used to generate the matrix.</p>
</dd>
<dt><code>benchmarkFunction</code></dt><dd><p>the benchmark function which executes the
functionality to be timed.  The function takes a
<code>DenseMatrixMicrobenchmark</code> and a list of kernel parameters
returned by the allocator function.</p>
</dd>
</dl>

<hr>
<h2 id='DeterminantAllocator'>Allocates and populates input to the matrix determinant dense matrix kernel
microbenchmarks</h2><span id='topic+DeterminantAllocator'></span>

<h3>Description</h3>

<p><code>DeterminantAllocator</code> allocates and populates the input to the
matrix determinant dense matrix kernel for the purposes of conducting a
single performance trial with the <code>DeterminantMicrobenchmark</code> function.
The matrices or vectors corresponding to the <code>index</code> parameter must be
allocated, initialized and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeterminantAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DeterminantAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="DeterminantAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='DeterminantMicrobenchmark'>Conducts a single performance trial with the matrix determinant dense
matrix kernel</h2><span id='topic+DeterminantMicrobenchmark'></span>

<h3>Description</h3>

<p><code>DeterminantMicrobenchmark</code> conducts a single performance trial of the
dense matrix determinant dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>determinant(kernelParameters$A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeterminantMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DeterminantMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="DeterminantMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the matrix determinant microbenchmark for the first
# matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- DeterminantAllocator(microbenchmarks[["determinant"]], 1)
# Execute the microbenchmark
timings &lt;- DeterminantMicrobenchmark(microbenchmarks[["determinant"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='EigenAllocator'>Allocates and populates input to the matrix eigendecomposition kernel
microbenchmarks</h2><span id='topic+EigenAllocator'></span>

<h3>Description</h3>

<p><code>EigenAllocator</code> allocates and populates the input to the
matrix eigendecomposition dense matrix kernel for the purposes of conducting
a single performance trial with the <code>EigenMicrobenchmark</code> function.  The
matrices or vectors corresponding to the <code>index</code> parameter must be
allocated, initialized and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EigenAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EigenAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="EigenAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='EigenMicrobenchmark'>Conducts a single performance trial with the matrix eigendecomposition dense
matrix kernel</h2><span id='topic+EigenMicrobenchmark'></span>

<h3>Description</h3>

<p><code>EigenMicrobenchmark</code> conducts a single performance trial of the
matrix eigendecomposition dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>eigen(kernelParameters$A, symmetric=FALSE, only.values=FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EigenMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EigenMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="EigenMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the matrix eigendecomposition microbenchmark for the
# first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- EigenAllocator(microbenchmarks[["eigen"]], 1)
# Execute the microbenchmark
timings &lt;- EigenMicrobenchmark(microbenchmarks[["eigen"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='GenerateClusterData'>Generates clusters from multivariate normal distributions</h2><span id='topic+GenerateClusterData'></span>

<h3>Description</h3>

<p><code>GenerateClusterData</code> generates clusters of feature vectors drawn
from multivariate normal (MVN) distributions.  The mean values of the normal
distribution corresponding to the first cluster is always at the origin. 
The remaining clusters are generated from MVN distributions with mean values
at v_i and -v_i where v_i is the i-th unit vector.  The clusters are
generated in the following order by mean value of the MVN for each cluster:
origin, v_1, -v_1, v_2, -v_2, v_3, -v_3,..., v_(numberOfClusters-1)/2,
-v_(numberOfClusters-1)/2 (if <code>numberOfClusters</code> is odd)
origin, v_1, -v_1, v_2, -v_2, v_3, -v_3,..., v_(numberOfClusters-1)/2
(if <code>numberOfClusters</code> is even).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateClusterData(numberOfFeatures, numberOfVectorsPerCluster,
  numberOfClusters = 2 * numberOfFeatures + 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateClusterData_+3A_numberoffeatures">numberOfFeatures</code></td>
<td>
<p>the number of features, the dimension of the feature
space</p>
</td></tr>
<tr><td><code id="GenerateClusterData_+3A_numberofvectorspercluster">numberOfVectorsPerCluster</code></td>
<td>
<p>the number of vectors to randomly generate
for each cluster</p>
</td></tr>
<tr><td><code id="GenerateClusterData_+3A_numberofclusters">numberOfClusters</code></td>
<td>
<p>the number of clusters to be generated.  The value
of this parameter must be in the interval [1,2*<code>numberOfFeatures</code>+1]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing a matrix of feature vectors <code>featureVectors</code>
as rows of feature vectors,
number of features <code>numberOfFeatures</code>, number of feature vectors
<code>numberOfFeatureVectors</code>, and number of clusters
<code>numberOfClusters</code>.
</p>

<hr>
<h2 id='GetClusteringDefaultMicrobenchmarks'>Initializes the list of default clustering microbenchmarks</h2><span id='topic+GetClusteringDefaultMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetClusteringDefaultMicrobenchmarks</code> defines the default clustering
microbenchmarks to be executed by the
<code><a href="#topic+RunMachineLearningBenchmark">RunMachineLearningBenchmark</a></code> function.  The current clustering
microbenchmarks are:
</p>

<ol>
<li><p>pam_cluster_3_7_2500N=3, seven clusters with 2500 vectors per
cluster, using pam function
</p>
</li>
<li><p>pam_cluster_3_7_5000N=3, seven clusters with 5000 vectors per
cluster, using pam function
</p>
</li>
<li><p>pam_cluster_3_7_5715N=3, seven clusters with 5715 vectors per
cluster, using pam function
</p>
</li>
<li><p>pam_cluster_16_33_1213N=16, 33 clusters with 1213 vectors per
cluster, using pam function
</p>
</li>
<li><p>pam_cluster_64_33_1213N=64, 33 clusters with 1213 vectors per
cluster, using pam function
</p>
</li>
<li><p>pam_cluster_16_7_2858N=16, seven clusters with 2858 vectors per
cluster, using pam function
</p>
</li>
<li><p>pam_cluster_32_7_2858N=32, seven clusters with 2858 vectors per
cluster, using pam function
</p>
</li>
<li><p>pam_cluster_64_7_5715,N=64, seven clusters with 5715 vectors per
cluster, using pam function
</p>
</li>
<li><p>clara_cluster_64_33_1213N=64, 33 clusters with 1213 vectors per
cluster, using clara function
</p>
</li>
<li><p>clara_cluster_1000_99_1000N=1000, 99 clusters with 1000 vectors
per cluster, using clara function 
</p>
</li></ol>

<p>The <code><a href="cluster.html#topic+pam">pam</a></code> and <code><a href="cluster.html#topic+pam">pam</a></code>
microbenchmarks test those clustering functions.  The pam function
applies a quadratic time algorithm to partition around medoids (pam); the
clara function is a linear time approximation to the partitioning around
medoids algorithm.  See the documentation for the
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetClusteringDefaultMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>ClusteringMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  The microbenchmarks appear in the order
listed in the function description and are assigned the names enumerated
in the description.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code>
<code><a href="cluster.html#topic+pam">pam</a></code>
<code><a href="cluster.html#topic+pam">pam</a></code>
</p>
<p>Other machine learning default microbenchmarks: <code><a href="#topic+GetClusteringExampleMicrobenchmarks">GetClusteringExampleMicrobenchmarks</a></code>
</p>

<hr>
<h2 id='GetClusteringExampleMicrobenchmarks'>Initializes the list of example clustering microbenchmarks</h2><span id='topic+GetClusteringExampleMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetClusteringExampleMicrobenchmarks</code> defines the example clustering
microbenchmarks to be executed by the
<code><a href="#topic+RunMachineLearningBenchmark">RunMachineLearningBenchmark</a></code> function.  The example
are chosen so that they can run in a few minutes or less.
</p>

<ol>
<li><p>pam_cluster_3_7_2500N=3, seven clusters with 2500 vectors per
cluster
</p>
</li>
<li><p>clara_cluster_64_33_1213N=64, 33 clusters with 1213 vectors per
cluster
</p>
</li></ol>

<p>See the documentation for the
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetClusteringExampleMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>ClusteringMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  Microbenchmarks for the <code>pam</code>
and <code>clara</code> functions from the <code>cluster</code> package are
provided.
</p>


<h3>See Also</h3>

<p>Other machine learning default microbenchmarks: <code><a href="#topic+GetClusteringDefaultMicrobenchmarks">GetClusteringDefaultMicrobenchmarks</a></code>
</p>

<hr>
<h2 id='GetConfigurableEnvParameter'>Retrieves the value of an environment variable referenced by another
environment variable</h2><span id='topic+GetConfigurableEnvParameter'></span>

<h3>Description</h3>

<p><code>GetConfigurableEnvParameters</code> returns the value of the environment
variable referenced by the argument <code>configurableVariable</code> which
is also an environment variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetConfigurableEnvParameter(configurableVariable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetConfigurableEnvParameter_+3A_configurablevariable">configurableVariable</code></td>
<td>
<p>a string parameter containing the name
of an environment variable which itself references another 
environment variable</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the argument <code>configurableVariable</code> which
contains the name of an environment variable whose value is an
environment variable referencing a value to be returned by this
function.
</p>


<h3>Value</h3>

<p>the value of the environment variable referenced by the
environment variable specified in the <code>configurableVariable</code>
parameter
</p>

<hr>
<h2 id='GetDenseMatrixDefaultMicrobenchmarks'>Initializes the list of default dense matrix microbenchmarks</h2><span id='topic+GetDenseMatrixDefaultMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetDenseMatrixDefaultMicrobenchmarks</code> defines the default dense
matrix microbenchmarks to be executed by the
<code><a href="#topic+RunDenseMatrixBenchmark">RunDenseMatrixBenchmark</a></code> function.  The current microbenchmarks
are Cholesky factorization, matrix cross product, matrix determinant,
eigendecomposition, linear solve with multiple right hand sides, least
squares fit, matrix deformation and transpose, matrix-matrix multiplication,
matrix-vector multiplication, QR decomposition, and singular value
decomposition.  See the documentation for the
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDenseMatrixDefaultMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>DenseMatrixMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  The microbenchmarks appear in the order
listed in the function description and are assigned the following names:
cholesky, crossprod, determinant, eigen, solve, lsfit, deformtrans,
transpose, matmat, matvec, qr, and svd.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code>
</p>

<hr>
<h2 id='GetDenseMatrixExampleMicrobenchmarks'>Initializes the list of example dense matrix microbenchmarks</h2><span id='topic+GetDenseMatrixExampleMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetDenseMatrixExampleMicrobenchmarks</code> defines example dense
matrix microbenchmarks to be executed by the examples section
of the <code><a href="#topic+RunDenseMatrixBenchmark">RunDenseMatrixBenchmark</a></code> function.  The examples
are chosen so that they can run in a few minutes or less.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDenseMatrixExampleMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>DenseMatrixMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  Microbenchmarks for Cholesky factorization
and matrix cross product are provided.
</p>

<hr>
<h2 id='GetNumberOfThreads'>Retrieves the number of threads from the environment</h2><span id='topic+GetNumberOfThreads'></span>

<h3>Description</h3>

<p><code>GetNumberOfThreads</code> retrieves from the environment the number of
threads kernels are intended to be executed with
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetNumberOfThreads()
</code></pre>


<h3>Details</h3>

<p>This function retrieves the number of threads kernels are intended to be
microbenchmarked with.  The number of threads is assumed to be stored
in an environment variable which this function retrieves.
</p>


<h3>Value</h3>

<p>the number of threads retrieved from the environment
</p>

<hr>
<h2 id='GetSparseCholeskyDefaultMicrobenchmarks'>Initializes the list of default sparse Cholesky factorization
microbenchmarks</h2><span id='topic+GetSparseCholeskyDefaultMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetSparseCholeskyDefaultMicrobenchmarks</code> defines the default sparse
Cholesky factorization microbenchmarks to be executed by the
<code><a href="#topic+RunSparseMatrixBenchmark">RunSparseMatrixBenchmark</a></code> function.  The current sparse
Cholesky factorization microbenchmarks cover a variety of matrices of
different dimensions and number of non-zero values.  They are as follows:
</p>

<ol>
<li><p> cholesky_ct20stif &ndash; Boeing structural matrix with 2600295 nonzeros
</p>
</li>
<li><p> cholesky_Andrews &ndash; computer vision matrix with 760154
</p>
</li>
<li><p> cholesky_G3_circuit &ndash; AMD circuit simulation matrix with 7660826
nonzeros
</p>
</li></ol>

<p>See the documentation for the
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSparseCholeskyDefaultMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>SparseMatrixMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  The microbenchmarks appear in the order
listed in the function description and are assigned the names enumerated
in the description.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code>
</p>
<p>Other sparse matrix default microbenchmarks: <code><a href="#topic+GetSparseCholeskyExampleMicrobenchmarks">GetSparseCholeskyExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseLuDefaultMicrobenchmarks">GetSparseLuDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorDefaultMicrobenchmarks">GetSparseMatrixVectorDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorExampleMicrobenchmarks">GetSparseMatrixVectorExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseQrDefaultMicrobenchmarks">GetSparseQrDefaultMicrobenchmarks</a></code>
</p>

<hr>
<h2 id='GetSparseCholeskyExampleMicrobenchmarks'>Initializes the list of example sparse Cholesky factorization
microbenchmarks</h2><span id='topic+GetSparseCholeskyExampleMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetSparseCholeskyExampleMicrobenchmarks</code> defines the example sparse
Cholesky factorization microbenchmarks to be executed by the
<code><a href="#topic+RunSparseMatrixBenchmark">RunSparseMatrixBenchmark</a></code> function.  The current sparse
Cholesky factorization microbenchmarks cover the following matrices:
</p>

<ol>
<li><p> cholesky_ct20stif &ndash; Boeing structural matrix with 2600295 nonzeros
</p>
</li></ol>

<p>See the documentation for the
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSparseCholeskyExampleMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>SparseMatrixMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  The microbenchmark for the Cholesky
factorization of the ct20stif matrix.
</p>


<h3>See Also</h3>

<p>Other sparse matrix default microbenchmarks: <code><a href="#topic+GetSparseCholeskyDefaultMicrobenchmarks">GetSparseCholeskyDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseLuDefaultMicrobenchmarks">GetSparseLuDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorDefaultMicrobenchmarks">GetSparseMatrixVectorDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorExampleMicrobenchmarks">GetSparseMatrixVectorExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseQrDefaultMicrobenchmarks">GetSparseQrDefaultMicrobenchmarks</a></code>
</p>

<hr>
<h2 id='GetSparseLuDefaultMicrobenchmarks'>Initializes the list of default sparse LU factorization microbenchmarks</h2><span id='topic+GetSparseLuDefaultMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetSparseLuDefaultMicrobenchmarks</code> defines the default sparse LU
factorization microbenchmarks to be executed by the
<code><a href="#topic+RunSparseMatrixBenchmark">RunSparseMatrixBenchmark</a></code> function.  The current sparse LU
factorization microbenchmarks cover a variety of matrices of different
dimensions and number of non-zero values.  They are as follows:
</p>

<ol>
<li><p> lu_circuit5M_dc &ndash; Freescale DC circuit simulation matrix 2600295
nonzeros
</p>
</li>
<li><p> lu_stomach &ndash; 3D electro-physical model matrix with 3021648 nonzeros
</p>
</li>
<li><p> lu_torso3 &ndash; 3D electro-physical model matrix with 4429042 nonzeros
</p>
</li></ol>

<p>See the documentation for the
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSparseLuDefaultMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>SparseMatrixMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  The microbenchmarks appear in the order
listed in the function description and are assigned the names enumerated
in the description.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code>
</p>
<p>Other sparse matrix default microbenchmarks: <code><a href="#topic+GetSparseCholeskyDefaultMicrobenchmarks">GetSparseCholeskyDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseCholeskyExampleMicrobenchmarks">GetSparseCholeskyExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorDefaultMicrobenchmarks">GetSparseMatrixVectorDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorExampleMicrobenchmarks">GetSparseMatrixVectorExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseQrDefaultMicrobenchmarks">GetSparseQrDefaultMicrobenchmarks</a></code>
</p>

<hr>
<h2 id='GetSparseMatrixVectorDefaultMicrobenchmarks'>Initializes the list of default sparse matrix-vector microbenchmarks</h2><span id='topic+GetSparseMatrixVectorDefaultMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetSparseMatrixVectorDefaultMicrobenchmarks</code> defines the default sparse
matrix-vector microbenchmarks to be executed by the
<code><a href="#topic+RunSparseMatrixBenchmark">RunSparseMatrixBenchmark</a></code> function.  The current sparse
matrix-vector microbenchmarks cover a variety of matrices of different
dimensions and number of non-zero values.  They are as follows:
</p>

<ol>
<li><p> matvec_laplacian7pt_100 &ndash; 100x100x100 7-point Laplacian operator
</p>
</li>
<li><p> matvec_laplacian7pt_200 &ndash; 200x200x200 7-point Laplacian operator
</p>
</li>
<li><p> matvec_ca2010 &ndash; DIMACS10/ca2010 710145x710145 undirected graph
matrix
</p>
</li></ol>

<p>See the documentation for the
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSparseMatrixVectorDefaultMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>SparseMatrixMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  The microbenchmarks appear in the order
listed in the function description and are assigned the names enumerate
in the description.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code>
</p>
<p>Other sparse matrix default microbenchmarks: <code><a href="#topic+GetSparseCholeskyDefaultMicrobenchmarks">GetSparseCholeskyDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseCholeskyExampleMicrobenchmarks">GetSparseCholeskyExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseLuDefaultMicrobenchmarks">GetSparseLuDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorExampleMicrobenchmarks">GetSparseMatrixVectorExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseQrDefaultMicrobenchmarks">GetSparseQrDefaultMicrobenchmarks</a></code>
</p>

<hr>
<h2 id='GetSparseMatrixVectorExampleMicrobenchmarks'>Initializes the list of example sparse matrix-vector microbenchmarks</h2><span id='topic+GetSparseMatrixVectorExampleMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetSparseMatrixVectorExampleMicrobenchmarks</code> defines example sparse
matrix-vector microbenchmarks to be executed by the
<code><a href="#topic+RunSparseMatrixBenchmark">RunSparseMatrixBenchmark</a></code> function.  The example
matrix-vector microbenchmarks cover the following matrices:
</p>

<ol>
<li><p> matvec_laplacian7pt_100 &ndash; 100x100x100 7-point Laplacian operator
</p>
</li></ol>

<p>See the documentation for the
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSparseMatrixVectorExampleMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>SparseMatrixMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  The microbenchmark for matrix-vector
operations with the Laplacian operator laplacian7pt_100 is
returned.
</p>


<h3>See Also</h3>

<p>Other sparse matrix default microbenchmarks: <code><a href="#topic+GetSparseCholeskyDefaultMicrobenchmarks">GetSparseCholeskyDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseCholeskyExampleMicrobenchmarks">GetSparseCholeskyExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseLuDefaultMicrobenchmarks">GetSparseLuDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorDefaultMicrobenchmarks">GetSparseMatrixVectorDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseQrDefaultMicrobenchmarks">GetSparseQrDefaultMicrobenchmarks</a></code>
</p>

<hr>
<h2 id='GetSparseQrDefaultMicrobenchmarks'>Initializes the list of default sparse QR factorization microbenchmarks</h2><span id='topic+GetSparseQrDefaultMicrobenchmarks'></span>

<h3>Description</h3>

<p><code>GetSparseQrDefaultMicrobenchmarks</code> defines the default sparse QR
factorization microbenchmarks to be executed by the
<code><a href="#topic+RunSparseMatrixBenchmark">RunSparseMatrixBenchmark</a></code> function.  The current sparse QR
factorization microbenchmarks cover a variety of matrices of different
dimensions and number of non-zero values.  They are as follows:
</p>

<ol>
<li><p> Maragal_6 &ndash; rank deficient least squares matrix of 537694 nonzeros
</p>
</li>
<li><p> landmark &ndash; least squares matrix of 1146848
</p>
</li></ol>

<p>See the documentation for the
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> class for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSparseQrDefaultMicrobenchmarks()
</code></pre>


<h3>Value</h3>

<p>a list of <code>SparseMatrixMicrobenchmark</code> objects defining the
microbenchmarks to be executed.  The microbenchmarks appear in the order
listed in the function description and are assigned the names enumerated
in the description.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code>
</p>
<p>Other sparse matrix default microbenchmarks: <code><a href="#topic+GetSparseCholeskyDefaultMicrobenchmarks">GetSparseCholeskyDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseCholeskyExampleMicrobenchmarks">GetSparseCholeskyExampleMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseLuDefaultMicrobenchmarks">GetSparseLuDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorDefaultMicrobenchmarks">GetSparseMatrixVectorDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseMatrixVectorExampleMicrobenchmarks">GetSparseMatrixVectorExampleMicrobenchmarks</a></code>
</p>

<hr>
<h2 id='LsfitAllocator'>Allocates and populates input to the matrix least squares fit dense matrix
kernel microbenchmarks</h2><span id='topic+LsfitAllocator'></span>

<h3>Description</h3>

<p><code>LsfitAllocator</code> allocates and populates the input to the
matrix least squares fit dense matrix kernel for the purposes of conducting
matrices or vectors corresponding to the <code>index</code> parameter must be
allocated, initialized and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LsfitAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LsfitAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="LsfitAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='LsfitMicrobenchmark'>Conducts a single performance trial with the matrix least squares fit dense
matrix kernel</h2><span id='topic+LsfitMicrobenchmark'></span>

<h3>Description</h3>

<p><code>LsfitMicrobenchmark</code> conducts a single performance trial of the
matrix least squares fit dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>lsfit(kernelParameters$A, kernelParameters$b, intercept=FALSE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LsfitMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LsfitMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="LsfitMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the least-squares fit microbenchmark for the
# first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- LsfitAllocator(microbenchmarks[["lsfit"]], 1)
# Execute the microbenchmark
timings &lt;- LsfitMicrobenchmark(microbenchmarks[["lsfit"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='MatmatAllocator'>Allocates and populates input to the matrix-matrix multiplication dense
matrix kernel microbenchmarks</h2><span id='topic+MatmatAllocator'></span>

<h3>Description</h3>

<p><code>MatmatAllocator</code> allocates and populates the input to the
matrix-matrix multiplication dense matrix kernel for the purposes of
conducting a single performance trial with the <code>MatmatMicrobenchmark</code>
function.  The matrices or vectors corresponding to the <code>index</code>
parameter must be allocated, initialized and returned in the
<code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatmatAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatmatAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="MatmatAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='MatmatMicrobenchmark'>Conducts a single performance trial with the matrix-matrix multiplication
dense matrix kernel</h2><span id='topic+MatmatMicrobenchmark'></span>

<h3>Description</h3>

<p><code>MatmatMicrobenchmark</code> conducts a single performance trial of the
matrix-matrix multiplication dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>kernelParameters$A %*% kernelParameters$B</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatmatMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatmatMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="MatmatMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the matrix-matrix multiplication microbenchmark for the
# first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- MatmatAllocator(microbenchmarks[["matmat"]], 1)
# Execute the microbenchmark
timings &lt;- MatmatMicrobenchmark(microbenchmarks[["matmat"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='MatvecAllocator'>Allocates and populates input to the matrix-vector multiplication dense
matrix kernel microbenchmarks</h2><span id='topic+MatvecAllocator'></span>

<h3>Description</h3>

<p><code>MatvecAllocator</code> allocates and populates the input to the
matrix-vector multiplication dense matrix kernel for the purposes of
conducting a single performance trial with the <code>MatvecMicrobenchmark</code>
function.  The matrices or vectors corresponding to the <code>index</code>
parameter must be allocated, initialized and returned in the
<code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatvecAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatvecAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="MatvecAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='MatvecMicrobenchmark'>Conducts a single performance trial with the matrix-vector multiplication
dense matrix kernel</h2><span id='topic+MatvecMicrobenchmark'></span>

<h3>Description</h3>

<p><code>MatvecMicrobenchmark</code> conducts a single performance trial of the
matrix-vector multiplication dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>kernelParameters$A %*% kernelParameters$b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatvecMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatvecMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="MatvecMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the matrix-vector multiplication microbenchmark for the
# first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- MatvecAllocator(microbenchmarks[["matvec"]], 1)
# Execute the microbenchmark
timings &lt;- MatvecMicrobenchmark(microbenchmarks[["matvec"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='MicrobenchmarkClusteringKernel'>Performs microbenchmarking of a clustering for machine learning kernel</h2><span id='topic+MicrobenchmarkClusteringKernel'></span>

<h3>Description</h3>

<p><code>MicrobenchmarkClusteringKernel</code> performs microbenchmarking of a
clustering for machine learning kernel for a given data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MicrobenchmarkClusteringKernel(benchmarkParameters, numberOfThreads,
  resultsDirectory, runIdentifier)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MicrobenchmarkClusteringKernel_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code> specifying the data set
to be read in or generated and the number of performance trials
to perform with the data set.</p>
</td></tr>
<tr><td><code id="MicrobenchmarkClusteringKernel_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads the microbenchmark is being
performed with.  The value is for informational purposes only and does not
effect the number threads the kernel is executed with.</p>
</td></tr>
<tr><td><code id="MicrobenchmarkClusteringKernel_+3A_resultsdirectory">resultsDirectory</code></td>
<td>
<p>a character string specifying the directory
where all of the CSV performance results files will be saved</p>
</td></tr>
<tr><td><code id="MicrobenchmarkClusteringKernel_+3A_runidentifier">runIdentifier</code></td>
<td>
<p>a character string specifying the suffix to be
appended to the base of the file name of the output CSV format files</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs microbenchmarking of a clustering for machine learning
kernel for a given data set and a given number of threads.  The
kernel to be performance tested and other parameters specifying how the
kernel is to be benchmarked are given in the input object
<code>benchmarkParameters</code> which is an instance of the class
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code>.  The
performance results are averaged over the number of performance trials
and written to a CSV file.  The results of the individual performance
trials are retained in a data frame that is returned upon completion of the
microbenchmark.  The kernel can be executed with multiple threads if the
kernel supports multithreading.  See
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code> for more details on the
benchmarking parameters.
</p>


<h3>Value</h3>

<p>a dataframe containing the performance trial times for the given
kernel and data set being tested, that is the raw performance data before
averaging.  The columns of the data frame are the following:
</p>

<dl>
<dt>BenchmarkName</dt><dd><p>The name of the microbenchmark</p>
</dd>
<dt>NumberOfFeatures</dt><dd><p>The number of features in each feature vector</p>
</dd>
<dt>NumberOfFeatureVectors</dt><dd><p>The number of features in the data set</p>
</dd>
<dt>NumberOfClusters</dt><dd><p>The number of clusters in the data set</p>
</dd>
<dt>UserTime</dt><dd><p>The amount of time spent in user-mode code within the
microbenchmarked code</p>
</dd>
<dt>SystemTime</dt><dd><p>The amount of time spent in the kernel within the
process</p>
</dd>
<dt>WallClockTime</dt><dd><p>The total time spent to complete the performance
trial</p>
</dd>
<dt>DateStarted</dt><dd><p>The date and time the performance trial was commenced</p>
</dd>
<dt>DateFinished</dt><dd><p>The date and time the performance trial ended</p>
</dd>
</dl>


<hr>
<h2 id='MicrobenchmarkDenseMatrixKernel'>Performs microbenchmarking of a dense matrix linear algebra kernel</h2><span id='topic+MicrobenchmarkDenseMatrixKernel'></span>

<h3>Description</h3>

<p><code>MicrobenchmarkDenseMatrixKernel</code> performs microbenchmarking of a
dense matrix linear algebra kernel for several matrix dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MicrobenchmarkDenseMatrixKernel(benchmarkParameters, numberOfThreads,
  resultsDirectory, runIdentifier)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MicrobenchmarkDenseMatrixKernel_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying the matrix
dimensions of matrices to be tested and the number of performance trials
to perform for each matrix dimension.</p>
</td></tr>
<tr><td><code id="MicrobenchmarkDenseMatrixKernel_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads the microbenchmark is being
performed with.  The value is for informational purposes only and does not
effect the number threads the kernel is executed with.</p>
</td></tr>
<tr><td><code id="MicrobenchmarkDenseMatrixKernel_+3A_resultsdirectory">resultsDirectory</code></td>
<td>
<p>a character string specifying the directory
where all of the CSV performance results files will be saved</p>
</td></tr>
<tr><td><code id="MicrobenchmarkDenseMatrixKernel_+3A_runidentifier">runIdentifier</code></td>
<td>
<p>a character string specifying the suffix to be
appended to the base of the file name of the output CSV format files</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs microbenchmarking of a dense matrix linear algebra
kernel for several matrix dimensions and a given number of threads.  The
kernel to be performance tested, the matrix dimensions to be tested, and
other parameters specifying how the kernel is to be benchmarked are given in
the input object <code>benchmarkParameters</code> which is an instance of
the class <code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code>.  For each matrix dimension
to be tested, the run time performance of the kernel is averaged over
multiple performance trials, and the averages are written to a CSV file.  The
results of the individual performance trials are retained in a data frame
that is returned upon completion of the microbenchmark.  The kernel can also
be executed with multiple threads if the kernel supports multithreading.  See
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> for more details on the benchmarking
parameters.
</p>


<h3>Value</h3>

<p>a dataframe containing the performance trial times for each matrix
tested, that is the raw performance data before averaging.  The columns
of the data frame are the following:
</p>

<dl>
<dt>BenchmarkName</dt><dd><p>The name of the microbenchmark</p>
</dd>
<dt>DimensionParameter</dt><dd><p>The dimension parameters the microbenchmark
uses to define the matrix dimensions to be tested with</p>
</dd>
<dt>UserTime</dt><dd><p>The amount of time spent in user-mode code within the
microbenchmarked code</p>
</dd>
<dt>SystemTime</dt><dd><p>The amount of time spent in the kernel within the
process</p>
</dd>
<dt>WallClockTime</dt><dd><p>The total time spent to complete the performance
trial</p>
</dd>
<dt>DateStarted</dt><dd><p>The date and time the performance trial was commenced</p>
</dd>
<dt>DateFinished</dt><dd><p>The date and time the performance trial ended</p>
</dd>
</dl>


<hr>
<h2 id='MicrobenchmarkSparseMatrixKernel'>Performs microbenchmarking of a sparse matrix linear algebra kernel</h2><span id='topic+MicrobenchmarkSparseMatrixKernel'></span>

<h3>Description</h3>

<p><code>MicrobenchmarkSparseMatrixKernel</code> performs microbenchmarking of a
sparse matrix linear algebra kernel for several matrix dimensions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MicrobenchmarkSparseMatrixKernel(benchmarkParameters, numberOfThreads,
  resultsDirectory, runIdentifier)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MicrobenchmarkSparseMatrixKernel_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying the matrix
dimensions of matrices to be tested and the number of performance trials
to perform for each matrix dimension.</p>
</td></tr>
<tr><td><code id="MicrobenchmarkSparseMatrixKernel_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads the microbenchmark is being
performed with.  The value is for informational purposes only and does not
effect the number threads the kernel is executed with.</p>
</td></tr>
<tr><td><code id="MicrobenchmarkSparseMatrixKernel_+3A_resultsdirectory">resultsDirectory</code></td>
<td>
<p>a character string specifying the directory
where all of the CSV performance results files will be saved</p>
</td></tr>
<tr><td><code id="MicrobenchmarkSparseMatrixKernel_+3A_runidentifier">runIdentifier</code></td>
<td>
<p>a character string specifying the suffix to be
appended to the base of the file name of the output CSV format files</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs microbenchmarking of a sparse matrix linear algebra
kernel for several matrix dimensions and a given number of threads.  The
kernel to be performance tested, the matrix dimensions to be tested, and
other parameters specifying how the kernel is to be benchmarked are given in
the input object <code>benchmarkParameters</code> which is an instance of
the class <code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code>.
For each matrix dimension to be tested, the run time performance of the
kernel is averaged over multiple runs.  The kernel can also be executed with
multiple threads if the kernel supports multithreading.
See <code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code>
for more details on the benchmarking parameters.
</p>


<h3>Value</h3>

<p>a dataframe containing the performance trial times for each matrix
tested, that is the raw performance data before averaging.  The columns
of the data frame are the following:
</p>

<dl>
<dt>BenchmarkName</dt><dd><p>The name of the microbenchmark</p>
</dd>
<dt>NumberOfRows</dt><dd><p>An integer specifying the expected number of rows in
the input sparse matrix</p>
</dd>
<dt>NumberOfColumns</dt><dd><p>An integer specifying the expected number of
columns in the input sparse matrix</p>
</dd>
<dt>UserTime</dt><dd><p>The amount of time spent in user-mode code within the
microbenchmarked code</p>
</dd>
<dt>SystemTime</dt><dd><p>The amount of time spent in the kernel within the
process</p>
</dd>
<dt>WallClockTime</dt><dd><p>The total time spent to complete the performance
trial</p>
</dd>
<dt>DateStarted</dt><dd><p>The date and time the performance trial was commenced</p>
</dd>
<dt>DateFinished</dt><dd><p>The date and time the performance trial ended</p>
</dd>
</dl>


<hr>
<h2 id='PamClusteringMicrobenchmark'>Conducts a single performance trial with the cluster::pam function</h2><span id='topic+PamClusteringMicrobenchmark'></span>

<h3>Description</h3>

<p><code>ClusteringMicrobenchmark</code> conducts a single performance trial
of the cluster::pam function with the data given in the
<code>kernelParameters</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PamClusteringMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PamClusteringMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the cluster::pam function</p>
</td></tr>
<tr><td><code id="PamClusteringMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of data objects to be used as input to
the clustering function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the user, system, and elapsed performance
timings in that order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the pam clustering microbenchmark
microbenchmarks &lt;- GetClusteringExampleMicrobenchmarks()
kernelParameters &lt;- ClusteringAllocator(microbenchmarks[["pam_cluster_3_3_1000"]])
# Execute the microbenchmark
timings &lt;- PamClusteringMicrobenchmark(
   microbenchmarks[["pam_cluster_3_3_1000"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='PerformClusteringMicrobenchmarking'>Performs microbenchmarking of machine learning functions specified by an
input list</h2><span id='topic+PerformClusteringMicrobenchmarking'></span>

<h3>Description</h3>

<p><code>PerformClusteringMicrobenchmarking</code> performs microbenchmarking
of machine learning functionality specified by the input list of
<code>ClusteringMicrobenchmark</code> objects.  Objects with the <code>active</code>
flag set to TRUE indicate that the corresponding microbenchmark will be
performed; FALSE indicates that the microbenchmark will be skipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PerformClusteringMicrobenchmarking(microbenchmarks, microbenchmarkingFunction,
  numberOfThreads, runIdentifier, resultsDirectory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PerformClusteringMicrobenchmarking_+3A_microbenchmarks">microbenchmarks</code></td>
<td>
<p>a list of
<code>ClusteringMicrobenchmark</code> objects defining the machine learning
microbenchmarks to be executed as part of the machine learning
benchmark.</p>
</td></tr>
<tr><td><code id="PerformClusteringMicrobenchmarking_+3A_microbenchmarkingfunction">microbenchmarkingFunction</code></td>
<td>
<p>a function that performs the run time
performance trials, computes the summary performance statistics, and
writes the performance results to standard out,</p>
</td></tr>
<tr><td><code id="PerformClusteringMicrobenchmarking_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads the microbenchmarks are
intended to be executed with; the value is for display purposes only as
the number of threads used is assumed to be controlled through environment
variables</p>
</td></tr>
<tr><td><code id="PerformClusteringMicrobenchmarking_+3A_runidentifier">runIdentifier</code></td>
<td>
<p>a character string specifying the suffix to be
appended to the base of the file name of the output CSV format files</p>
</td></tr>
<tr><td><code id="PerformClusteringMicrobenchmarking_+3A_resultsdirectory">resultsDirectory</code></td>
<td>
<p>a character string specifying the directory
where all of the CSV performance results files will be saved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the benchmark name, user, system, and elapsed
(wall clock) times of each performance trial each microbenchmark
</p>

<hr>
<h2 id='PerformSparseMatrixKernelMicrobenchmarking'>Performs microbenchmarking of sparse matrix kernels specified by an input
list</h2><span id='topic+PerformSparseMatrixKernelMicrobenchmarking'></span>

<h3>Description</h3>

<p><code>PerformSparseMatrixKernelMicrobenchmarking</code> performs microbenchmarking
of sparse matrix kernels specified by the input list of
<code>SparseMatrixMicrobenchmark</code> objects.  Objects with the <code>active</code>
flag set to TRUE indicate that the corresponding microbenchmark will be
performed; FALSE indicates that the microbenchmark will be skipped.
If the <code>matrixObjectName</code> field of an input
<code>SparseMatrixMicrobenchmark</code> object is set to <code>NA_character_</code>,
then the sparse matrix is assumed to be dynamically generated by the
allocator function specified in the <code>allocatorFunction</code> field.
If the <code>matrixObjectName</code> field is specified, then the sparse
matrix object is expected to be found in an <code>.RData</code> file with
base file name the same as the value of <code>matrixObjectName</code>, and
located in the either an attached R data package or a directory named
<code>data</code> in the current working directory.  See the
the <code><a href="utils.html#topic+data">data</a></code> package for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PerformSparseMatrixKernelMicrobenchmarking(microbenchmarks, numberOfThreads,
  runIdentifier, resultsDirectory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PerformSparseMatrixKernelMicrobenchmarking_+3A_microbenchmarks">microbenchmarks</code></td>
<td>
<p>a list of
<code>SparseMatrixMicrobenchmark</code> objects defining the sparse matrix
microbenchmarks to be executed as part of the sparse matrix
benchmark.</p>
</td></tr>
<tr><td><code id="PerformSparseMatrixKernelMicrobenchmarking_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads the microbenchmarks are
intended to be executed with; the value is for display purposes only as
the number of threads used is assumed to be controlled through environment
variables</p>
</td></tr>
<tr><td><code id="PerformSparseMatrixKernelMicrobenchmarking_+3A_runidentifier">runIdentifier</code></td>
<td>
<p>a character string specifying the suffix to be
appended to the base of the file name of the output CSV format files</p>
</td></tr>
<tr><td><code id="PerformSparseMatrixKernelMicrobenchmarking_+3A_resultsdirectory">resultsDirectory</code></td>
<td>
<p>a character string specifying the directory
where all of the CSV performance results files will be saved</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the benchmark name, user, system, and
elapsed (wall clock) times of each performance trial for each
microbenchmark
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+data">data</a></code>
</p>

<hr>
<h2 id='PrintClusteringMicrobenchmarkResults'>Prints results of a clustering for machine learning microbenchmark</h2><span id='topic+PrintClusteringMicrobenchmarkResults'></span>

<h3>Description</h3>

<p><code>PrintClusteringMicrobenchmarkResults</code> prints performance results
for a clustering for machine learning microbenchmark to standard output in a
format that is easily human readable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintClusteringMicrobenchmarkResults(benchmarkName, numberOfThreads,
  numberOfFeatures, numberOfFeatureVectors, numberOfClusters,
  numberOfSuccessfulTrials, trialTimes, averageWallClockTimes,
  standardDeviations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_benchmarkname">benchmarkName</code></td>
<td>
<p>character string specifying the name of the
microbenchmark</p>
</td></tr>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads all of the performance trials
were conducted with</p>
</td></tr>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_numberoffeatures">numberOfFeatures</code></td>
<td>
<p>the number of features, i.e. the dimension of the
feature vector</p>
</td></tr>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_numberoffeaturevectors">numberOfFeatureVectors</code></td>
<td>
<p>the number of feature vectors in the data set</p>
</td></tr>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_numberofclusters">numberOfClusters</code></td>
<td>
<p>the number of clusters in the data set</p>
</td></tr>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_numberofsuccessfultrials">numberOfSuccessfulTrials</code></td>
<td>
<p>an integer vector specifying the number of
performance trials that were successfully performed for each data set</p>
</td></tr>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_trialtimes">trialTimes</code></td>
<td>
<p>a real matrix with each column containing the run times
of all of the successful performance trials associated with a particular
data set.  The number of valid entries in each column are specified by the
entries in the <code>numberOfSuccessfulTrials</code> vector</p>
</td></tr>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_averagewallclocktimes">averageWallClockTimes</code></td>
<td>
<p>a vector of average wall clock times computed
for each matrix tested during the performance trials</p>
</td></tr>
<tr><td><code id="PrintClusteringMicrobenchmarkResults_+3A_standarddeviations">standardDeviations</code></td>
<td>
<p>a vector of standard deviations of the wall clock
times obtained for each matrix tested during the performance trials</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints the performance results obtained by a clustering for
machine learning microbenchmark.  Summary run time performance statistics for
each clustering data set tested are computed and printed.  The summary
statistics include the minimum, maximum, average, and standard deviation of
the wall clock times obtained by the performance trials with respect to each
data tested.
</p>

<hr>
<h2 id='PrintDenseMatrixMicrobenchmarkResults'>Prints results of a dense matrix microbenchmark</h2><span id='topic+PrintDenseMatrixMicrobenchmarkResults'></span>

<h3>Description</h3>

<p><code>PrintDenseMatrixMicrobenchmarkResults</code> prints performance results for a
dense matrix microbenchmark to standard output in a format that is easily
human readable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintDenseMatrixMicrobenchmarkResults(benchmarkName, numberOfThreads,
  dimensionParameters, numberOfSuccessfulTrials, trialTimes,
  averageWallClockTimes, standardDeviations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrintDenseMatrixMicrobenchmarkResults_+3A_benchmarkname">benchmarkName</code></td>
<td>
<p>character string specifying the name of the
microbenchmark</p>
</td></tr>
<tr><td><code id="PrintDenseMatrixMicrobenchmarkResults_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads all of the performance trials
were conducted with</p>
</td></tr>
<tr><td><code id="PrintDenseMatrixMicrobenchmarkResults_+3A_dimensionparameters">dimensionParameters</code></td>
<td>
<p>an integer vector specifying the dimension
parameters the microbenchmark uses to define the matrix dimensions to be
tested with; length is assumed to be greater than zero</p>
</td></tr>
<tr><td><code id="PrintDenseMatrixMicrobenchmarkResults_+3A_numberofsuccessfultrials">numberOfSuccessfulTrials</code></td>
<td>
<p>an integer vector specifying the number of
performance trials that were successfully performed for each matrix tested</p>
</td></tr>
<tr><td><code id="PrintDenseMatrixMicrobenchmarkResults_+3A_trialtimes">trialTimes</code></td>
<td>
<p>a real matrix with each column containing the run times
of all of the successful performance trials associated with a particular
matrix.  The number of valid entries in each column are specified by the
entries in the <code>numberOfSuccessfulTrials</code> vector</p>
</td></tr>
<tr><td><code id="PrintDenseMatrixMicrobenchmarkResults_+3A_averagewallclocktimes">averageWallClockTimes</code></td>
<td>
<p>a vector of average wall clock times computed
for each matrix tested during the performance trials</p>
</td></tr>
<tr><td><code id="PrintDenseMatrixMicrobenchmarkResults_+3A_standarddeviations">standardDeviations</code></td>
<td>
<p>a vector of standard deviations of the wall clock
times obtained for each matrix tested during the performance trials</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints the performance results obtained by a dense matrix
microbenchmark for matrices of various dimensions.  The results include
summary statistics for each matrix tested.  The summary statistics
include the minimum, maximum, average, and standard deviation of the wall
clock times obtained by the performance trials with respect to each matrix
tested.
</p>

<hr>
<h2 id='PrintSparseMatrixMicrobenchmarkResults'>Prints results of a sparse matrix microbenchmark</h2><span id='topic+PrintSparseMatrixMicrobenchmarkResults'></span>

<h3>Description</h3>

<p><code>PrintSparseMatrixMicrobenchmarkResults</code> prints performance results for
a sparse matrix microbenchmark to standard output in a format that is easily
human readable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrintSparseMatrixMicrobenchmarkResults(benchmarkName, numberOfThreads,
  numberOfRows, numberOfColumns, numberOfNonzeros, numberOfSuccessfulTrials,
  trialTimes, averageWallClockTimes, standardDeviations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_benchmarkname">benchmarkName</code></td>
<td>
<p>character string specifying the name of the
microbenchmark</p>
</td></tr>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads all of the performance trials
were conducted with</p>
</td></tr>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_numberofrows">numberOfRows</code></td>
<td>
<p>the number of expected rows in the matrix; assumed to
be greater than zero</p>
</td></tr>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_numberofcolumns">numberOfColumns</code></td>
<td>
<p>the number of expected columns in the matrix; assumed
to be greater than zero</p>
</td></tr>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_numberofnonzeros">numberOfNonzeros</code></td>
<td>
<p>the number of non-zero elements in the matrix</p>
</td></tr>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_numberofsuccessfultrials">numberOfSuccessfulTrials</code></td>
<td>
<p>an integer vector specifying the number of
performance trials that were successfully performed for each matrix tested</p>
</td></tr>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_trialtimes">trialTimes</code></td>
<td>
<p>a real matrix with each column containing the run times
of all of the successful performance trials associated with a particular
matrix.  The number of valid entries in each column are specified by the
entries in the <code>numberOfSuccessfulTrials</code> vector</p>
</td></tr>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_averagewallclocktimes">averageWallClockTimes</code></td>
<td>
<p>a vector of average wall clock times computed
for each matrix tested during the performance trials</p>
</td></tr>
<tr><td><code id="PrintSparseMatrixMicrobenchmarkResults_+3A_standarddeviations">standardDeviations</code></td>
<td>
<p>a vector of standard deviations of the wall clock
times obtained for each matrix tested during the performance trials</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints the run time performance results obtained by a sparse
matrix microbenchmark for matrices of various dimensions.  The summary
statistics include the minimum, maximum, average, and standard deviation of
the wall clock times obtained by the performance trials with respect to each
matrix tested.
</p>

<hr>
<h2 id='QrAllocator'>Allocates and populates input to the QR factorization dense matrix kernel
microbenchmarks</h2><span id='topic+QrAllocator'></span>

<h3>Description</h3>

<p><code>QrAllocator</code> allocates and populates the input to the
QR factorization dense matrix kernel for the purposes of
conducting a single performance trial with the <code>QrMicrobenchmark</code>
function.  The matrices or vectors corresponding to the <code>index</code>
parameter must be allocated, initialized and returned in the
<code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QrAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QrAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="QrAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='QrMicrobenchmark'>Conducts a single performance trial with the QR factorization dense matrix
kernel</h2><span id='topic+QrMicrobenchmark'></span>

<h3>Description</h3>

<p><code>QrMicrobenchmark</code> conducts a single performance trial of the
QR factorization dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>qr(kernelParameters$A, LAPACK=TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QrMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QrMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="QrMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the QR decomposition microbenchmark for the
# first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- QrAllocator(microbenchmarks[["qr"]], 1)
# Execute the microbenchmark
timings &lt;- QrMicrobenchmark(microbenchmarks[["qr"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='RHPCBenchmark'>RHPCBenchmark: A package for performance testing intrinsic R functionality
and established packages relevant to high-performance computing</h2><span id='topic+RHPCBenchmark'></span><span id='topic+RHPCBenchmark-package'></span>

<h3>Description</h3>

<p>The benchmarks are divided into three categories: dense matrix linear
algebra kernels, sparse matrix linear algebra kernels, and machine learning
functionality.  All of the dense linear algebra kernels are implemented
around BLAS or LAPACK interfaces.  The sparse linear algebra kernels are
members of the R Matrix library.  The machine learning benchmarks currently
only cover variants of K-means functionality for clustering using the
<code>cluster</code> package.  The dense matrix linear algebra kernels, sparse
matrix linear algebra kernels, and machine learning functions that are
benchmarked are all part of the R interpreter's intrinsic functionality or
packages included the with the R programming environment standard
distributions from CRAN.
</p>


<h3>Details</h3>

<p>For fast performance of the dense matrix kernels, it is crucial to link
the R programming environment with optimized BLAS and LAPACK libraries.
It is also important to have substantial amounts of memory (16GB minimum)
to run most of the microbenchmarks.  If any of the microbenchmarks fails
to run in a timely manner or fails due to memory constraints, the matrix
sizes and number of performance trials per matrix can be adjusted.  See
the documentation for top-level benchmark functions and the microbenchmark
definition classes listed below for information on how to configure the
individual microbenchmarks.
</p>


<h3>Top-level benchmark functions</h3>


<dl>
<dt><code><a href="#topic+RunDenseMatrixBenchmark">RunDenseMatrixBenchmark</a></code></dt><dd><p>Executes the dense matrix
microbenchmarks</p>
</dd>
<dt><code><a href="#topic+RunSparseMatrixBenchmark">RunSparseMatrixBenchmark</a></code></dt><dd><p>Executes the sparse matrix
microbenchmarks</p>
</dd>
<dt><code><a href="#topic+RunMachineLearningBenchmark">RunMachineLearningBenchmark</a></code></dt><dd><p>Executes the machine
learning microbenchmarks</p>
</dd>
</dl>



<h3>Microbenchmark definition classes</h3>


<dl>
<dt><code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code></dt><dd><p>Specifies a dense matrix
microbenchmark</p>
</dd>
<dt><code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code></dt><dd><p>Specifies a sparse matrix
microbenchmark</p>
</dd>
<dt><code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code></dt><dd><p>Specifies a clustering for
machine learning microbenchmark</p>
</dd>
</dl>


<hr>
<h2 id='RunDenseMatrixBenchmark'>Runs all of the dense matrix microbenchmarks</h2><span id='topic+RunDenseMatrixBenchmark'></span>

<h3>Description</h3>

<p><code>RunDenseMatrixBenchmark</code> runs all of the microbenchmarks for
performance testing the dense matrix linear algebra kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunDenseMatrixBenchmark(runIdentifier, resultsDirectory,
  microbenchmarks = GetDenseMatrixDefaultMicrobenchmarks())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunDenseMatrixBenchmark_+3A_runidentifier">runIdentifier</code></td>
<td>
<p>a character string specifying the suffix to be
appended to the base of the file name of the output CSV format files</p>
</td></tr>
<tr><td><code id="RunDenseMatrixBenchmark_+3A_resultsdirectory">resultsDirectory</code></td>
<td>
<p>a character string specifying the directory
where all of the CSV performance results files will be saved</p>
</td></tr>
<tr><td><code id="RunDenseMatrixBenchmark_+3A_microbenchmarks">microbenchmarks</code></td>
<td>
<p>a list of <code>DenseMatrixMicrobenchmark</code> objects
defining the microbenchmarks to execute as part of the dense matrix
benchmark.  Default values are provided by the function
<code><a href="#topic+GetDenseMatrixDefaultMicrobenchmarks">GetDenseMatrixDefaultMicrobenchmarks</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs all of the dense matrix microbenchmarks defined in the
<code>microbenchmarks</code> input list for which the <code>active</code> field is 
set to TRUE.  For each microbenchmark, it attempts to create a
separate output file in CSV format containing the performance results for
each matrix tested by the microbenchmark.  The names of the output files
follow the format <code>benchmarkName</code>_<code>runIdentifier</code>.csv,
where <code>benchmarkName</code> is specified in the
<code>DenseMatrixMicrobenchmark</code> object of each microbenchmark, and
<code>runIdentifier</code> is an input parameter to this function.  If the file
already exists, the results will be appended to the existing file.  The
<code>microbenchmarks</code> input list
contains instances of the <code>DenseMatrixMicrobenchmark</code> class defining
each microbenchmark.  The default microbenchmarks are generated by the
function <code><a href="#topic+GetDenseMatrixDefaultMicrobenchmarks">GetDenseMatrixDefaultMicrobenchmarks</a></code>.  If the
linear algebra kernels are multithreaded, by linking to multithreaded
BLAS or LAPACK libraries for example, then the number of threads must
be retrievable from an environment variable which is set before execution of
the R programming environment.  The name of the environment variable
specifying the number of threads must be provided in the R HPC benchmark
environment variable R_BENCH_NUM_THREADS_VARIABLE.  This function will
retrieve the number of threads through R_BENCH_NUM_THREADS_VARIABLE so that
the number of threads can be printed to the results files and recorded in
data frames for reporting purposes.  This function utilizes the number of
threads only for reporting purposes and is not used by the benchmark to
effect the actual number of threads utilized by the kernels, as that is
assumed to be controlled by the numerical library.  An error exception will
be thrown if the environment variable R_BENCH_NUM_THREADS_VARIABLE and the
variable it is set to are not both set.
</p>


<h3>Value</h3>

<p>a data frame containing the benchmark name, 
user, system, and elapsed (wall clock) times of each performance trial
for each microbenchmark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetDenseMatrixDefaultMicrobenchmarks">GetDenseMatrixDefaultMicrobenchmarks</a></code>
<code><a href="#topic+GetDenseMatrixExampleMicrobenchmarks">GetDenseMatrixExampleMicrobenchmarks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Set needed environment variables for multithreading.  Only single threading
# is used in the example.
#
# Note: The environment variables are usually set by the user before starting
#       the R programming environment; they are set here only to facilitate
#       a working example.  See the section on multithreading in the vignette
#       for further details.
Sys.setenv(R_BENCH_NUM_THREADS_VARIABLE="MKL_NUM_THREADS")
Sys.setenv(MKL_NUM_THREADS="1")
#
# Generate example microbechmarks that can be run in a few minutes; see
# the vignette for more involved examples.  The Cholesky factorization and
# matrix crossproduct microbenchmarks are performed in the example code
# below.
#
# Note: These microbenchmarks are different than the microbenchmarks
#       generated by \code{\link{GetDenseMatrixDefaultMicrobenchmarks}}.
#       They are chosen for their short run times and suitability for
#       example code. 
exampleMicrobenchmarks &lt;- GetDenseMatrixExampleMicrobenchmarks()
# Set the output directory of the CSV summary results files
resultsDirectory &lt;- "./DenseMatrixExampleOutput"
# Create the output directory
dir.create(resultsDirectory)
# Set an appropriate run identifier
runIdentifier &lt;- "example"
resultsFrame &lt;- RunDenseMatrixBenchmark(runIdentifier, resultsDirectory,
   microbenchmarks=exampleMicrobenchmarks)

# This example runs all but the matrix transpose microbenchmarks.
exampleMicrobenchmarks[["transpose"]]$active &lt;- FALSE
# Set an appropriate run identifier
runIdentifier &lt;- "no_transpose"
exTransposeResultsFrame &lt;- RunDenseMatrixBenchmark(runIdentifier,
  resultsDirectory, microbenchmarks=exampleMicrobenchmarks)

# This example runs only the matrix-matrix multiplication microbenchmark,
# and it adds a larger matrix to test.
matMatMicrobenchmark &lt;- list()
matMatMicrobenchmark[["matmat"]] &lt;- GetDenseMatrixExampleMicrobenchmarks()[["matmat"]]
matMatMicrobenchmark[["matmat"]]$dimensionParameters &lt;- as.integer(c(1000, 2000))
matMatMicrobenchmark[["matmat"]]$numberOfTrials &lt;- as.integer(c(3, 3))
matMatMicrobenchmark[["matmat"]]$numberOfWarmupTrials &lt;- as.integer(c(1, 1))
# Set an appropriate run identifier
runIdentifier &lt;- "matmat"
matMatResults &lt;- RunDenseMatrixBenchmark(runIdentifier, resultsDirectory,
   microbenchmarks=matMatMicrobenchmark)

## End(Not run)

</code></pre>

<hr>
<h2 id='RunMachineLearningBenchmark'>Runs all of the machine learning microbenchmarks</h2><span id='topic+RunMachineLearningBenchmark'></span>

<h3>Description</h3>

<p><code>RunMachineLearningBenchmark</code> runs all of the microbenchmarks for
performance testing machine learning functionality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunMachineLearningBenchmark(runIdentifier, resultsDirectory,
  clusteringMicrobenchmarks = GetClusteringDefaultMicrobenchmarks())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunMachineLearningBenchmark_+3A_runidentifier">runIdentifier</code></td>
<td>
<p>a character string specifying the suffix to be
appended to the base of the file name of the output CSV format files</p>
</td></tr>
<tr><td><code id="RunMachineLearningBenchmark_+3A_resultsdirectory">resultsDirectory</code></td>
<td>
<p>a character string specifying the directory
where all of the CSV performance results files will be saved</p>
</td></tr>
<tr><td><code id="RunMachineLearningBenchmark_+3A_clusteringmicrobenchmarks">clusteringMicrobenchmarks</code></td>
<td>
<p>a list of
<code>ClusteringMicrobenchmark</code> objects defining the clustering
microbenchmarks to execute as part of the machine learning benchmark.
Default values are provided by the function
<code><a href="#topic+GetClusteringDefaultMicrobenchmarks">GetClusteringDefaultMicrobenchmarks</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs the machine learning microbenchmarks, which are divided
into four categories supported by this benchmark, defined in the
<code>clusteringMicrobenchmarks</code> input list.  For each microbenchmark, it
attempts to create a separate output file in CSV format containing the
performance results for data set and function tested by the microbenchmark.
The names of the output files follow the format
<code>benchmarkName</code>_<code>runIdentifier</code>.csv, where
<code>benchmarkName</code> is specified in the
<code>ClusteringMicrobenchmark</code> object of each microbenchmark and
<code>runIdentifier</code> is an input parameter to this function.  If the file
already exists, the results will be appended to the existing file.  Each
input list contains instances of the
<code><a href="#topic+ClusteringMicrobenchmark">ClusteringMicrobenchmark</a></code> class defining each
microbenchmark.  Each microbenchmark object with the
<code>active</code> field set to TRUE will be executed.  The lists of default
microbenchmarks are generated by the function
<code><a href="#topic+GetClusteringDefaultMicrobenchmarks">GetClusteringDefaultMicrobenchmarks</a></code>.  Each 
<code>ClusteringMicrobenchmark</code> specifies an R data file which contains
the data object needed by the microbenchmark.  The needed R data
files should either be given in an attached R package or given in the
<code>data</code> subdirectory of the current working directory, and they should
have the extension <code>.RData</code>.  If the linear algebra kernels are
multithreaded, by linking to multithreaded BLAS or LAPACK libraries for
example, then the number of threads must be retrievable from an environment
variable which is set before execution of the R programming environment.
The name of the environment variable specifying the number of threads must
be provided in the R HPC benchmark environment variable
R_BENCH_NUM_THREADS_VARIABLE.  This function will retrieve the number of
threads through R_BENCH_NUM_THREADS_VARIABLE so that the number of threads
can be printed to the results files and recorded in data frames for reporting
purposes.  This function utilizes the number of threads only for reporting
purposes and is not used by the benchmark to effect the actual number of
threads utilized by the kernels, as that is assumed to be controlled by the
numerical library.  An error exception will be thrown if the environment
variable R_BENCH_NUM_THREADS_VARIABLE and the variable it is set to are not
both set.
</p>


<h3>Value</h3>

<p>a data frame containing the user, system, and elapsed (wall clock)
time of times of each performance trial
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetClusteringDefaultMicrobenchmarks">GetClusteringDefaultMicrobenchmarks</a></code>
<code><a href="#topic+GetClusteringExampleMicrobenchmarks">GetClusteringExampleMicrobenchmarks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Set needed environment variables for multithreading.  Only single threading
# is used in the example.
#
# Note: The environment variables are usually set by the user before starting
#       the R programming environment; they are set here only to facilitate
#       a working example.  See the section on multithreading in the vignette
#       for further details.
Sys.setenv(R_BENCH_NUM_THREADS_VARIABLE="MKL_NUM_THREADS")
Sys.setenv(MKL_NUM_THREADS="1")
#
# Generate example microbechmarks that can be run in a few minutes; see
# the vignette for more involved examples. Clustering microbenchmarks
# are defined in the examples.
#
# Note: These microbenchmarks are different than the microbenchmarks
#       generated by \code{\link{GetDenseMatrixDefaultMicrobenchmarks}}.
#       They are chosen for their short run times and suitability for
#       example code. 
exampleMicrobenchmarks &lt;- GetClusteringExampleMicrobenchmarks()
# Set the output directory of the CSV summary results files
resultsDirectory &lt;- "./MachineLearningExampleOutput"
# Create the output directory
dir.create(resultsDirectory)
# Set an appropriate run identifier
runIdentifier &lt;- "example"
resultsFrame &lt;- RunMachineLearningBenchmark(runIdentifier, resultsDirectory,
   clusteringMicrobenchmarks=exampleMicrobenchmarks)

# Create a new clustering microbenchmark that tests the clara method from
# the cluster package using a data set with 16 features, 8 clusters, and
# 1000 normally distributed feature vectors per cluster. 
claraMicrobenchmark &lt;- list()
claraMicrobenchmark[["clara_cluster_16_8_1000"]] &lt;- methods::new(
   "ClusteringMicrobenchmark",
   active = TRUE,
   benchmarkName = "clara_cluster_16_8_1000",
   benchmarkDescription = "Example of new clara microbenchmark",
   dataObjectName = NA_character_,
   numberOfFeatures = as.integer(16),
   numberOfClusters = as.integer(8),
   numberOfFeatureVectorsPerCluster = as.integer(1000),
   numberOfTrials = as.integer(3),
   numberOfWarmupTrials = as.integer(1),
   allocatorFunction = ClusteringAllocator,
   benchmarkFunction = ClaraClusteringMicrobenchmark
)

# Set an appropriate run identifier
runIdentifier &lt;- "clara_new"
# Run the clara microbenchmark
claraResults &lt;- RunMachineLearningBenchmark(runIdentifier, resultsDirectory,
   clusteringMicrobenchmarks=claraMicrobenchmark)

## End(Not run)

</code></pre>

<hr>
<h2 id='RunSparseMatrixBenchmark'>Runs all of the sparse matrix microbenchmarks</h2><span id='topic+RunSparseMatrixBenchmark'></span>

<h3>Description</h3>

<p><code>RunSparseMatrixBenchmark</code> runs all of the microbenchmarks for
performance testing the sparse matrix linear algebra kernels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RunSparseMatrixBenchmark(runIdentifier, resultsDirectory,
  matrixVectorMicrobenchmarks = GetSparseMatrixVectorDefaultMicrobenchmarks(),
  choleskyMicrobenchmarks = GetSparseCholeskyDefaultMicrobenchmarks(),
  luMicrobenchmarks = GetSparseLuDefaultMicrobenchmarks(),
  qrMicrobenchmarks = GetSparseQrDefaultMicrobenchmarks())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RunSparseMatrixBenchmark_+3A_runidentifier">runIdentifier</code></td>
<td>
<p>a character string specifying the suffix to be
appended to the base of the file name of the output CSV format files</p>
</td></tr>
<tr><td><code id="RunSparseMatrixBenchmark_+3A_resultsdirectory">resultsDirectory</code></td>
<td>
<p>a character string specifying the directory
where all of the CSV performance results files will be saved</p>
</td></tr>
<tr><td><code id="RunSparseMatrixBenchmark_+3A_matrixvectormicrobenchmarks">matrixVectorMicrobenchmarks</code></td>
<td>
<p>a list of
<code>SparseMatrixMicrobenchmark</code> objects defining the matrix-vector
multiplication microbenchmarks to execute as part of the sparse matrix
benchmark.  Default values are provided by the function
<code><a href="#topic+GetSparseMatrixVectorDefaultMicrobenchmarks">GetSparseMatrixVectorDefaultMicrobenchmarks</a></code>.  If the
value is NULL, then all of the matrix-vector multiplication
microbenchmarks will be skipped.</p>
</td></tr>
<tr><td><code id="RunSparseMatrixBenchmark_+3A_choleskymicrobenchmarks">choleskyMicrobenchmarks</code></td>
<td>
<p>a list of
<code>SparseMatrixMicrobenchmark</code> objects defining the Cholesky
factorization microbenchmarks to execute as part of the sparse matrix
benchmark.  Default values are provided by the function
<code><a href="#topic+GetSparseCholeskyDefaultMicrobenchmarks">GetSparseCholeskyDefaultMicrobenchmarks</a></code>.  If the value
is NULL, then all of the Cholesky factorization microbenchmarks will
be skipped.</p>
</td></tr>
<tr><td><code id="RunSparseMatrixBenchmark_+3A_lumicrobenchmarks">luMicrobenchmarks</code></td>
<td>
<p>a list of <code>SparseMatrixMicrobenchmark</code>
objects defining the LU factorization microbenchmarks to execute as part
of the sparse matrix benchmark.  Default values are provided by the
function <code><a href="#topic+GetSparseLuDefaultMicrobenchmarks">GetSparseLuDefaultMicrobenchmarks</a></code>.  If the value
is NULL, then all of the LU factorization microbenchmarks will
be skipped.</p>
</td></tr>
<tr><td><code id="RunSparseMatrixBenchmark_+3A_qrmicrobenchmarks">qrMicrobenchmarks</code></td>
<td>
<p>a list of <code>SparseMatrixMicrobenchmark</code>
objects defining the QR factorization microbenchmarks to execute as part
of the sparse matrix benchmark.  Default values are provided by the
function <code><a href="#topic+GetSparseQrDefaultMicrobenchmarks">GetSparseQrDefaultMicrobenchmarks</a></code>.  If the value
is NULL, then all of the QR factorization microbenchmarks will
be skipped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function runs the sparse matrix microbenchmarks, which are divided
into four categories supported by this benchmark, defined in the
<code>matrixVectorMicrobenchmarks</code>, <code>choleskyMicrobenchmarks</code>, 
<code>luMicrobenchmarks</code>, and <code>qrMicrobenchmarks</code> input lists
For each microbenchmark, it attempts to create a separate output file in CSV
format containing the performance results for each matrix tested by the
microbenchmark.  The names of the output files follow the format
<code>benchmarkName</code>_<code>runIdentifier</code>.csv, where
<code>benchmarkName</code> is specified in the
<code>SparseMatrixMicrobenchmark</code> object of each microbenchmark and
<code>runIdentifier</code> is an input parameter to this function.  If the file,
already exists, the results will be appended to the existing file.  Each
input lists contains instances of the
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> class defining each microbenchmark.
Each microbenchmark object with the
<code>active</code> field set to TRUE will be executed.  The lists of default
microbenchmarks are generated by the functions
<code><a href="#topic+GetSparseMatrixVectorDefaultMicrobenchmarks">GetSparseMatrixVectorDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseCholeskyDefaultMicrobenchmarks">GetSparseCholeskyDefaultMicrobenchmarks</a></code>,
<code><a href="#topic+GetSparseLuDefaultMicrobenchmarks">GetSparseLuDefaultMicrobenchmarks</a></code>, and
<code><a href="#topic+GetSparseQrDefaultMicrobenchmarks">GetSparseQrDefaultMicrobenchmarks</a></code>.  Each 
<code>SparseMatrixMicrobenchmark</code> specifies an R data file which contains the
sparse matrix object needed by the microbenchmark.  The needed R data files
should either be given in an attached R package or given in the <code>data</code>
subdirectory of the current working directory, and they should have the
extension <code>.RData</code>.  If the linear algebra kernels are multithreaded,
by linking to multithreaded BLAS or LAPACK libraries for example, then the
number of threads must be retrievable from an environment variable which is
set before execution of the R programming environment.  The name of the
environment variable specifying the number of threads must be provided in
the R HPC benchmark environment variable R_BENCH_NUM_THREADS_VARIABLE.  This
function will retrieve the number of threads through
R_BENCH_NUM_THREADS_VARIABLE so that the number of threads can be printed to
the results files and recorded in data frames for reporting purposes.  This
function utilizes the number of threads only for reporting purposes and is
not used by the benchmark to effect the actual number of threads utilized by
the kernels, as that is assumed to be controlled by the numerical library.
An error exception will be thrown if the environment variable
R_BENCH_NUM_THREADS_VARIABLE and the variable it is set to are not both set.
</p>


<h3>Value</h3>

<p>a data frame containing the benchmark name, user, system, and
elapsed (wall clock) times of each performance trial for each
microbenchmark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetSparseMatrixVectorDefaultMicrobenchmarks">GetSparseMatrixVectorDefaultMicrobenchmarks</a></code>
<code><a href="#topic+GetSparseCholeskyDefaultMicrobenchmarks">GetSparseCholeskyDefaultMicrobenchmarks</a></code>
<code><a href="#topic+GetSparseLuDefaultMicrobenchmarks">GetSparseLuDefaultMicrobenchmarks</a></code>
<code><a href="#topic+GetSparseQrDefaultMicrobenchmarks">GetSparseQrDefaultMicrobenchmarks</a></code>
<code><a href="#topic+GetSparseMatrixVectorExampleMicrobenchmarks">GetSparseMatrixVectorExampleMicrobenchmarks</a></code>
<code><a href="#topic+GetSparseCholeskyExampleMicrobenchmarks">GetSparseCholeskyExampleMicrobenchmarks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Set needed environment variables for multithreading.  Only single threading
# is used in the example.
#
# Note: The environment variables are usually set by the user before starting
#       the R programming environment; they are set here only to facilitate
#       a working example.  See the section on multithreading in the vignette
#       for further details.
Sys.setenv(R_BENCH_NUM_THREADS_VARIABLE="MKL_NUM_THREADS")
Sys.setenv(MKL_NUM_THREADS="1")
#
# Generate example microbenchmarks that can be run in a few minutes; see
# the vignette for more involved examples.  The matvec_laplacian7pt_100
# and cholesky_ct20stif microbenchmarks are defined in the examples.
#
# Note: The example microbenchmarks are different than the microbenchmarks
#       generated by
#       \code{\link{GetSparseMatrixVectorDefaultMicrobenchmarks}},
#       \code{\link{GetSparseCholeskyDefaultMicrobenchmarks}},
#       \code{\link{GetSparseLuDefaultMicrobenchmarks}}, and
#       \code{\link{GetSparseQrDefaultMicrobenchmarks}};
#       they were chosen for their short run times and suitability for
#       example code. 
exampleMatrixVectorMicrobenchmarks &lt;- GetSparseMatrixVectorExampleMicrobenchmarks()
exampleCholeskyMicrobenchmarks &lt;- GetSparseCholeskyExampleMicrobenchmarks()
# Set the output directory of the CSV summary results files
resultsDirectory &lt;- "./SparseMatrixExampleOutput"
# Create the output directory
dir.create(resultsDirectory)
# Set an appropriate run identifier
runIdentifier &lt;- "example"
# Run only the matrix-vector and Cholesky factorization microbenchmarks, as
# the others take a long time
resultsFrame &lt;- RunSparseMatrixBenchmark(runIdentifier, resultsDirectory,
   matrixVectorMicrobenchmarks=exampleMatrixVectorMicrobenchmarks,
   choleskyMicrobenchmarks=exampleCholeskyMicrobenchmarks,
   luMicrobenchmarks=NULL,
   qrMicrobenchmarks=NULL)

# This example runs only the Cholesky factorization microbenchmarks.
runIdentifier &lt;- "choleksy_only"
# Run only the sparse Choleksy factorization microbenchmarks
choleskyResults &lt;- RunSparseMatrixBenchmark(runIdentifier, resultsDirectory,
   matrixVectorMicrobenchmarks=NULL, luMicrobenchmarks=NULL,
   qrMicrobenchmarks=NULL)


## End(Not run)

</code></pre>

<hr>
<h2 id='SolveAllocator'>Allocates and populates input to the dense matrix kernel microbenchmark
for computing the solution to a system of linear equations with multiple
right-hand sides</h2><span id='topic+SolveAllocator'></span>

<h3>Description</h3>

<p><code>SolveAllocator</code> allocates and populates the input to the
solve kernel for the purposes of conducting a single performance trial with
the <code>QrMicrobenchmark</code> function.  The matrices or vectors corresponding
to the <code>index</code> parameter must be allocated, initialized and returned in
the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SolveAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SolveAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="SolveAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='SolveMicrobenchmark'>Conducts a single performance trial with the dense matrix kernel for
computing the solution to a system of linear equations with multiple
right-hand sides</h2><span id='topic+SolveMicrobenchmark'></span>

<h3>Description</h3>

<p><code>SolveMicrobenchmark</code> conducts a single performance trial of the
solve dense matrix kernel for the matrix given in the
<code>kernelParameters</code> parameter.  The function times the single function
call <code>solve(kernelParameters$A, kernelParameters$B, LAPACK=TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SolveMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SolveMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="SolveMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the linear solve microbenchmark for the
# first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- SolveAllocator(microbenchmarks[["solve"]], 1)
# Execute the microbenchmark
timings &lt;- SolveMicrobenchmark(microbenchmarks[["solve"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='SparseCholeskyAllocator'>Allocates and initializes input to the Cholesky factorization sparse
matrix kernel microbenchmarks</h2><span id='topic+SparseCholeskyAllocator'></span>

<h3>Description</h3>

<p><code>SparseCholeskyAllocator</code> allocates and initializes the sparse
matrix that is input to the sparse matrix kernel for the
purposes of conducting a single performance trial with the
<code>SparseCholeskyMicrobenchmark</code> function.  The matrix is populated
and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseCholeskyAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseCholeskyAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the sparse matrix kernel.</p>
</td></tr>
<tr><td><code id="SparseCholeskyAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the sparse matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='SparseCholeskyMicrobenchmark'>Conducts a single performance trial with the Cholesky factorization
sparse matrix kernel</h2><span id='topic+SparseCholeskyMicrobenchmark'></span>

<h3>Description</h3>

<p><code>SparseMatrixVectorMicrobenchmark</code> conducts a single performance trial
of the Cholesky factorization sparse matrix kernel for the matrix given in
the <code>kernelParameters</code> parameter.  The function times the single
function call <code>kernelParameters$A %*% kernelParameters$b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseCholeskyMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseCholeskyMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the sparse matrix kernel</p>
</td></tr>
<tr><td><code id="SparseCholeskyMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the sparse matrix kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the user, system, and elapsed performance
timings in that order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the Cholesky factorization microbenchmark for the
# ct20stif matrix
microbenchmarks &lt;- GetSparseCholeskyDefaultMicrobenchmarks()
kernelParameters &lt;- SparseCholeskyAllocator(microbenchmarks[["cholesky_ct20stif"]], 1)
# Execute the microbenchmark
timings &lt;- SparseCholeskyMicrobenchmark(
   microbenchmarks[["choleksy_ct20stif"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='SparseLuAllocator'>Allocates and initializes input to the LU factorization sparse matrix kernel
microbenchmarks</h2><span id='topic+SparseLuAllocator'></span>

<h3>Description</h3>

<p><code>SparseLuAllocator</code> allocates and initializes the sparse matrix that is
input to the sparse matrix kernel for the purposes of conducting a single
performance trial with the <code>SparseCholeskyMicrobenchmark</code> function.  The
matrix is populated and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseLuAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseLuAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the sparse matrix kernel.</p>
</td></tr>
<tr><td><code id="SparseLuAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the sparse matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='SparseLuMicrobenchmark'>Conducts a single performance trial with the LU factorization sparse matrix
kernel</h2><span id='topic+SparseLuMicrobenchmark'></span>

<h3>Description</h3>

<p><code>SparseMatrixVectorMicrobenchmark</code> conducts a single performance trial
of the Cholesky factorization sparse matrix kernel for the matrix given
in the <code>kernelParameters</code> parameter.  The function times the single
function
call <code>kernelParameters$A %*% kernelParameters$b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseLuMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseLuMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the sparse matrix kernel</p>
</td></tr>
<tr><td><code id="SparseLuMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the sparse matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the LU factorization microbenchmark for the
# circuit5M_dc matrix
microbenchmarks &lt;- GetSparseLuDefaultMicrobenchmarks()
kernelParameters &lt;- SparseLuAllocator(microbenchmarks[["lu_circuit5M_dc"]], 1)
# Execute the microbenchmark
timings &lt;- SparseLuMicrobenchmark(
   microbenchmarks[["lu_circuit5M_dc"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='SparseMatrixMicrobenchmark'>This class specifies a sparse matrix microbenchmark.</h2><span id='topic+SparseMatrixMicrobenchmark'></span>

<h3>Description</h3>

<p>This class specifies a sparse matrix microbenchmark.
</p>


<h3>Fields</h3>


<dl>
<dt><code>active</code></dt><dd><p>a logical indicating whether the microbenchmark is to be
executed (TRUE) or not (FALSE).</p>
</dd>
<dt><code>benchmarkName</code></dt><dd><p>a character string that is the name of the
microbenchmark.</p>
</dd>
<dt><code>benchmarkDescription</code></dt><dd><p>a character string describing the microbenchmark.</p>
</dd>
<dt><code>matrixObjectName</code></dt><dd><p>a character string specifying the name of the sparse
matrix object that is input to the benchmark; the object must be stored in
the R data file with name <code>matrixObjectName</code>.RData
Setting the field to NA_character_ indicates that the test data will
be generated dynamically by the function given in the
<code>allocatorFunction</code> field instead of read from a data file.</p>
</dd>
<dt><code>numberOfRows</code></dt><dd><p>an integer specifying the expected number of rows in the
input sparse matrix.</p>
</dd>
<dt><code>numberOfColumns</code></dt><dd><p>an integer specifying the expected number of columns
in the input sparse matrix.</p>
</dd>
<dt><code>numberOfNonzeros</code></dt><dd><p>an integer specifying the expected number of nonzeros
in the input sparse matrix.</p>
</dd>
<dt><code>numberOfTrials</code></dt><dd><p>an integer vector specifying the number of performance
trials conducted for each matrix to be tested.</p>
</dd>
<dt><code>numberOfWarmupTrials</code></dt><dd><p>an integer vector specifying the number of warmup
trials to be performed for each matrix to be tested.</p>
</dd>
<dt><code>allocatorFunction</code></dt><dd><p>the function that allocates and initializes input
to the benchmark function.  The function takes a
<code>SparseMatrixMicrobenchmark</code> object and an integer index indicating
which matrix parameter from <code>numberOfRows</code>, <code>numberOfColumns</code>,
and <code>numberOfNonzeros</code> should be used to generate the matrix.</p>
</dd>
<dt><code>benchmarkFunction</code></dt><dd><p>the benchmark function which executes the
functionality to be timed.  The function takes a
<code>SparseMatrixMicrobenchmark</code> and a list of kernel parameters
returned by the allocator function.</p>
</dd>
</dl>

<hr>
<h2 id='SparseMatrixVectorAllocator'>Allocates and initializes input to the matrix-vector multiplication sparse
matrix kernel microbenchmarks</h2><span id='topic+SparseMatrixVectorAllocator'></span>

<h3>Description</h3>

<p><code>SparseMatrixVectorAllocator</code> allocates and initializes the sparse
matrix and vector that are inputs to the sparse matrix kernel for the
purposes of conducting a single performance trial with the
<code>SparseMatrixVectorMicrobenchmark</code> function.  The matrix and vector
are populated and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseMatrixVectorAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseMatrixVectorAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the sparse matrix kernel.</p>
</td></tr>
<tr><td><code id="SparseMatrixVectorAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the sparse matrix kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the matrices or vectors to be input for the
sparse matrix kernel for which a single performance trial is to be
conducted.
</p>

<hr>
<h2 id='SparseMatrixVectorMicrobenchmark'>Conducts a single performance trial with the matrix-vector multiplication
sparse matrix kernel</h2><span id='topic+SparseMatrixVectorMicrobenchmark'></span>

<h3>Description</h3>

<p><code>SparseMatrixVectorMicrobenchmark</code> conducts a single performance trial
of the matrix-vector multiplication sparse matrix kernel for the matrix given
in the <code>kernelParameters</code> parameter.  The function times the single
function call <code>kernelParameters$A %*% kernelParameters$b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseMatrixVectorMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseMatrixVectorMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the sparse matrix kernel</p>
</td></tr>
<tr><td><code id="SparseMatrixVectorMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the sparse matrix kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the user, system, and elapsed performance
timings in that order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the matrix-vector microbenchmark for the first Laplacian
# matrix
microbenchmarks &lt;- GetSparseMatrixVectorDefaultMicrobenchmarks()
kernelParameters &lt;- SparseMatrixVectorAllocator(
   microbenchmarks[["matvec_laplacian7pt_100"]], 1)
# Execute the microbenchmark
timings &lt;- SparseMatrixVectorMicrobenchmark(
   microbenchmarks[["matvec_laplacian7pt_100"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='SparseQrAllocator'>Allocates and initializes input to the QR factorization sparse matrix kernel
microbenchmarks</h2><span id='topic+SparseQrAllocator'></span>

<h3>Description</h3>

<p><code>SparseQrAllocator</code> allocates and initializes the sparse matrix that is
input to the sparse matrix kernel for the purposes of conducting a single
performance trial with the <code>SparseQrMicrobenchmark</code> function.  The
matrix is populated and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseQrAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseQrAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the sparse matrix kernel.</p>
</td></tr>
<tr><td><code id="SparseQrAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the sparse matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='SparseQrMicrobenchmark'>Conducts a single performance trial with the QR factorization sparse matrix
kernel</h2><span id='topic+SparseQrMicrobenchmark'></span>

<h3>Description</h3>

<p><code>SparseQrVectorMicrobenchmark</code> conducts a single performance trial
of the QR factorization sparse matrix kernel for the matrix given
in the <code>kernelParameters</code> parameter.  The function times the single
function call <code>qr(kernelParameters$A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SparseQrMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SparseQrMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+SparseMatrixMicrobenchmark">SparseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the sparse matrix kernel</p>
</td></tr>
<tr><td><code id="SparseQrMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the sparse matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the QR factorization microbenchmark for the
# Maragal_6 matrix
microbenchmarks &lt;- GetSparseQrDefaultMicrobenchmarks()
kernelParameters &lt;- SparseQrAllocator(microbenchmarks[["qr_Maragal_6"]], 1)
# Execute the microbenchmark
timings &lt;- SparseQrMicrobenchmark(
   microbenchmarks[["qr_Maragal_6"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='SvdAllocator'>Allocates and populates input to the singular value decomposition (SVD) dense
matrix kernel microbenchmarks</h2><span id='topic+SvdAllocator'></span>

<h3>Description</h3>

<p><code>SvdAllocator</code> allocates and populates the input to the
SVD dense matrix kernel for the purposes of conducting a single performance
trial with the <code>SvdMicrobenchmark</code> function.  The matrices or vectors
corresponding to the <code>index</code> parameter must be allocated, initialized
and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SvdAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SvdAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="SvdAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='SvdMicrobenchmark'>Conducts a single performance trial with the singular value decomposition
(SVD) dense matrix kernel</h2><span id='topic+SvdMicrobenchmark'></span>

<h3>Description</h3>

<p><code>SvdMicrobenchmark</code> conducts a single performance trial of the
SVD dense matrix kernel for the matrix given in the <code>kernelParameters</code>
parameter.  The function times the single function call
<code>svd(kernelParameters$A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SvdMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SvdMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="SvdMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the singular value decomposition microbenchmark for the
# first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- SvdAllocator(microbenchmarks[["svd"]], 1)
# Execute the microbenchmark
timings &lt;- SvdMicrobenchmark(microbenchmarks[["svd"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='TransposeAllocator'>Allocates and populates input to the matrix transpose dense matrix kernel
microbenchmarks</h2><span id='topic+TransposeAllocator'></span>

<h3>Description</h3>

<p><code>TransposeAllocator</code> allocates and populates the input to the
transpose dense matrix kernel for the purposes of conducting a single
performance trial with the <code>TransposeMicrobenchmark</code> function.  The
matrices or vectors corresponding to the <code>index</code> parameter must be
allocated, initialized and returned in the <code>kernelParameters</code> list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransposeAllocator(benchmarkParameters, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransposeAllocator_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
needed to generate input for the dense matrix kernel.</p>
</td></tr>
<tr><td><code id="TransposeAllocator_+3A_index">index</code></td>
<td>
<p>an integer index indicating the dimensions of the matrix or
vector data to be generated as input for the dense matrix kernel.</p>
</td></tr>
</table>

<hr>
<h2 id='TransposeMicrobenchmark'>Conducts a single performance trial with the matrix transpose dense matrix
kernel</h2><span id='topic+TransposeMicrobenchmark'></span>

<h3>Description</h3>

<p><code>TransposeMicrobenchmark</code> conducts a single performance trial of the
SVD dense matrix kernel for the matrix given in the <code>kernelParameters</code>
parameter.  The function times the single function call
<code>svd(transposeParameters$A)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransposeMicrobenchmark(benchmarkParameters, kernelParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransposeMicrobenchmark_+3A_benchmarkparameters">benchmarkParameters</code></td>
<td>
<p>an object of type
<code><a href="#topic+DenseMatrixMicrobenchmark">DenseMatrixMicrobenchmark</a></code> specifying various parameters
for microbenchmarking the dense matrix kernel</p>
</td></tr>
<tr><td><code id="TransposeMicrobenchmark_+3A_kernelparameters">kernelParameters</code></td>
<td>
<p>a list of matrices or vectors to be used as input to
the dense matrix kernel</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Allocate input to the matrix transpose microbenchmark for the
# first matrix size to be tested
microbenchmarks &lt;- GetDenseMatrixDefaultMicrobenchmarks()
kernelParameters &lt;- TransposeAllocator(microbenchmarks[["transpose"]], 1)
# Execute the microbenchmark
timings &lt;- TransposeMicrobenchmark(microbenchmarks[["transpose"]], kernelParameters)

## End(Not run)

</code></pre>

<hr>
<h2 id='WriteClusteringPerformanceResultsCsv'>Appends performance test results of a clustering microbenchmark to a file in
CSV format</h2><span id='topic+WriteClusteringPerformanceResultsCsv'></span>

<h3>Description</h3>

<p><code>WriteClusteringPerformanceResultsCsv</code> appends performance results
for a clustering for machine learning microbenchmark to a CSV file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteClusteringPerformanceResultsCsv(numberOfThreads, numberOfFeatures,
  numberOfFeatureVectors, numberOfClusters, averageWallClockTime,
  standardDeviation, csvResultsFileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WriteClusteringPerformanceResultsCsv_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads all of the performance trials
were conducted with</p>
</td></tr>
<tr><td><code id="WriteClusteringPerformanceResultsCsv_+3A_numberoffeatures">numberOfFeatures</code></td>
<td>
<p>the number of features, i.e. the dimension of the
feature vector</p>
</td></tr>
<tr><td><code id="WriteClusteringPerformanceResultsCsv_+3A_numberoffeaturevectors">numberOfFeatureVectors</code></td>
<td>
<p>the number of feature vectors in the data set</p>
</td></tr>
<tr><td><code id="WriteClusteringPerformanceResultsCsv_+3A_numberofclusters">numberOfClusters</code></td>
<td>
<p>the number of clusters in the data set</p>
</td></tr>
<tr><td><code id="WriteClusteringPerformanceResultsCsv_+3A_averagewallclocktime">averageWallClockTime</code></td>
<td>
<p>average wall clock time computed for the data
set tested during the performance trials</p>
</td></tr>
<tr><td><code id="WriteClusteringPerformanceResultsCsv_+3A_standarddeviation">standardDeviation</code></td>
<td>
<p>standard deviation of the wall clock times obtained
for the performance trials</p>
</td></tr>
<tr><td><code id="WriteClusteringPerformanceResultsCsv_+3A_csvresultsfilename">csvResultsFileName</code></td>
<td>
<p>the CSV results file the performance result will be
appended to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function appends the performance results obtained by a single clustering
for machine learning microbenchmark conducted with a specific data set.
If the CSV file does not exist, header information is printed on the first
line to describe the subsequent entries.  Each entry includes the
number of features, number of feature vectors, and number of clusters in the
data set.  The performance results included in each entry are the average of
the wall clock times obtained for the performance trials, the standard
deviation of the performance trial wall clock times, and the number of
threads the performance trials were conducted with.
</p>

<hr>
<h2 id='WriteDenseMatrixPerformanceResultsCsv'>Appends dense matrix performance test results to a file in CSV format</h2><span id='topic+WriteDenseMatrixPerformanceResultsCsv'></span>

<h3>Description</h3>

<p><code>WriteDenseMatrixPerformanceResultsCsv</code> appends performance results
for a single dense matrix microbenchmark to a CSV file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteDenseMatrixPerformanceResultsCsv(numberOfThreads, dimensionParameter,
  averageWallClockTime, standardDeviation, csvResultsFileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WriteDenseMatrixPerformanceResultsCsv_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads all of the performance trials
were conducted with</p>
</td></tr>
<tr><td><code id="WriteDenseMatrixPerformanceResultsCsv_+3A_dimensionparameter">dimensionParameter</code></td>
<td>
<p>an integer vector specifying the dimension
parameter the microbenchmark uses to define the dimension of the test
matrix</p>
</td></tr>
<tr><td><code id="WriteDenseMatrixPerformanceResultsCsv_+3A_averagewallclocktime">averageWallClockTime</code></td>
<td>
<p>average wall clock time computed for the matrix
tested during the performance trials</p>
</td></tr>
<tr><td><code id="WriteDenseMatrixPerformanceResultsCsv_+3A_standarddeviation">standardDeviation</code></td>
<td>
<p>standard deviation of the wall clock times obtained
for the performance trials</p>
</td></tr>
<tr><td><code id="WriteDenseMatrixPerformanceResultsCsv_+3A_csvresultsfilename">csvResultsFileName</code></td>
<td>
<p>the CSV results file the performance result will be
appended to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function appends to a CSV file the performance results obtained by a
single dense matrix performance microbenchmark conducted for a specific
matrix.  If the CSV file does not exist, header information is printed on the
first line to describe the subsequent entries.  Each entry consists of the
dimension parameter used to specify the dimensions of the matrix, the average
of the wall clock times obtained for the performance trials, the standard
deviation of the performance trial wall clock times, and the number of
threads the performance trials conducted with.
</p>

<hr>
<h2 id='WriteSparseMatrixPerformanceResultsCsv'>Appends sparse matrix performance test results to a file in CSV format</h2><span id='topic+WriteSparseMatrixPerformanceResultsCsv'></span>

<h3>Description</h3>

<p><code>WriteSparseMatrixPerformanceResultsCsv</code> appends performance results
for a single sparse matrix performance test to a CSV file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WriteSparseMatrixPerformanceResultsCsv(numberOfThreads, numberOfRows,
  numberOfColumns, numberOfNonzeros, averageWallClockTime, standardDeviation,
  csvResultsFileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WriteSparseMatrixPerformanceResultsCsv_+3A_numberofthreads">numberOfThreads</code></td>
<td>
<p>the number of threads all of the performance trials
were conducted with</p>
</td></tr>
<tr><td><code id="WriteSparseMatrixPerformanceResultsCsv_+3A_numberofrows">numberOfRows</code></td>
<td>
<p>the number of rows in the matrix</p>
</td></tr>
<tr><td><code id="WriteSparseMatrixPerformanceResultsCsv_+3A_numberofcolumns">numberOfColumns</code></td>
<td>
<p>the number of columns in the matrix</p>
</td></tr>
<tr><td><code id="WriteSparseMatrixPerformanceResultsCsv_+3A_numberofnonzeros">numberOfNonzeros</code></td>
<td>
<p>the number of non-zero elements in the matrix</p>
</td></tr>
<tr><td><code id="WriteSparseMatrixPerformanceResultsCsv_+3A_averagewallclocktime">averageWallClockTime</code></td>
<td>
<p>average wall clock time computed for the matrix
tested during the performance trials</p>
</td></tr>
<tr><td><code id="WriteSparseMatrixPerformanceResultsCsv_+3A_standarddeviation">standardDeviation</code></td>
<td>
<p>standard deviation of the wall clock times obtained
for the performance trials</p>
</td></tr>
<tr><td><code id="WriteSparseMatrixPerformanceResultsCsv_+3A_csvresultsfilename">csvResultsFileName</code></td>
<td>
<p>the CSV results file the performance result will be
appended to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function appends the performance results obtained by a single sparse
matrix microbenchmark conducted for a specific matrix.
If the CSV file does not exist, header information is printed on the first
line to describe the subsequent entries.  Each entry consists of the
dimension parameter used to specify the dimensions of the matrix, the
average of the wall clock times obtained for the performance trials, the
standard deviation of the performance trial wall clock times, and the number
of threads the performance trials were conducted with.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
