<!DOCTYPE html><html><head><title>Help for package tsnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_eigen'><p>Check Eigenvalues of Bayesian GVAR object</p></a></li>
<li><a href='#compare_gvar'><p>Compare two Bayesian GVAR models</p></a></li>
<li><a href='#fit_data'><p>Example Posterior Samples</p></a></li>
<li><a href='#get_centrality'><p>Compute Centrality Measures</p></a></li>
<li><a href='#plot_centrality'><p>Plot Centrality Measures</p></a></li>
<li><a href='#plot.compare_gvar'><p>Plot compare_gvar</p></a></li>
<li><a href='#post_distance_within'><p>Calculates distances between pairs of posterior samples using the posterior</p>
samples or posterior predictive draws</a></li>
<li><a href='#posterior_plot'><p>posterior_plot</p></a></li>
<li><a href='#print.compare_gvar'><p>Print method for compare_gvar objects</p></a></li>
<li><a href='#print.tsnet_fit'><p>Print method for tsnet_fit objects</p></a></li>
<li><a href='#stan_fit_convert'><p>Convert Stan Fit to Array of Samples</p></a></li>
<li><a href='#stan_gvar'><p>Fit Bayesian Graphical Vector Autoregressive (GVAR) Models with Stan</p></a></li>
<li><a href='#ts_data'><p>Simulated Time Series Dataset</p></a></li>
<li><a href='#tsnet-package'><p>The 'tsnet' package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting, Comparing, and Visualizing Networks Based on Time
Series Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Björn S. Siepe &lt;bjoernsiepe@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit, compare, and visualize Bayesian graphical vector autoregressive (GVAR) network models using 'Stan'. These models are commonly used in psychology to represent temporal and contemporaneous relationships between multiple variables in intensive longitudinal data. Fitted models can be compared with a test based on matrix norm differences of posterior point estimates to quantify the differences between two estimated networks. See also Siepe, Kloft &amp; Heck (2024) &lt;<a href="https://doi.org/10.31234%2Fosf.io%2Fuwfjc">doi:10.31234/osf.io/uwfjc</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bsiepe/tsnet">https://github.com/bsiepe/tsnet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bsiepe/tsnet/issues">https://github.com/bsiepe/tsnet/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>cowplot, dplyr, ggdist, ggokabeito, ggplot2, methods,
posterior, Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1), rlang,
rstan (&ge; 2.18.1), rstantools (&ge; 2.3.1.1), stats, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-27 07:01:04 UTC; Bjoern</td>
</tr>
<tr>
<td>Author:</td>
<td>Björn S. Siepe <a href="https://orcid.org/0000-0002-9558-4648"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Matthias Kloft <a href="https://orcid.org/0000-0003-1845-6957"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel W. Heck <a href="https://orcid.org/0000-0002-6302-9252"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_eigen'>Check Eigenvalues of Bayesian GVAR object</h2><span id='topic+check_eigen'></span>

<h3>Description</h3>

<p>This function checks the eigenvalues of the Beta matrix (containing the
temporal coefficients) to assure that the model is stationary. It uses the
same check as the 'graphicalVAR' package. The function calculates the
eigenvalues of the Beta matrix and checks if the sum of the squares of the
real and imaginary parts of the eigenvalues is less than 1. If it is, the VAR
model is considered stable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_eigen(fitobj, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_eigen_+3A_fitobj">fitobj</code></td>
<td>
<p>A fitted Bayesian GVAR object. This can be a tsnet_fit object
(obtained from [stan_gvar()]), a BGGM object (obtained from
[BGGM::var_estimate()]), or extracted posterior samples (obtained from
[stan_fit_convert()).</p>
</td></tr>
<tr><td><code id="check_eigen_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, a verbal summary of the results is printed.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the eigenvalues and a verbal summary of the
results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(fit_data)
 fitobj &lt;- fit_data[[1]]
 result &lt;- check_eigen(fitobj)

</code></pre>

<hr>
<h2 id='compare_gvar'>Compare two Bayesian GVAR models</h2><span id='topic+compare_gvar'></span>

<h3>Description</h3>

<p>This function compares two Bayesian Graphical Vector
Autoregressive models using matrix norms to test if the observed
differences between two models is reliable. It computes the empirical
distance between two models based on their point estimates and compares
them using reference distributions created from their posterior
distributions. Returns the p-value for the comparison based on a decision
rule specified by the user. Details are available in Siepe, Kloft &amp; Heck (2024)
&lt;doi:10.31234/osf.io/uwfjc&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_gvar(
  fit_a,
  fit_b,
  cutoff = 5,
  dec_rule = "or",
  n_draws = 1000,
  comp = "frob",
  return_all = FALSE,
  sampling_method = "random",
  indices = NULL,
  burnin = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_gvar_+3A_fit_a">fit_a</code></td>
<td>
<p>Fitted model object for Model A. This can be a tsnet_fit object
(obtained from [stan_gvar()]), a BGGM object (obtained from
[BGGM::var_estimate()]), or extracted posterior samples (obtained from
[stan_fit_convert()).</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_fit_b">fit_b</code></td>
<td>
<p>Fitted model object for Model B. This can be a tsnet_fit object
(obtained from [stan_gvar()]), a BGGM object (obtained from
[BGGM::var_estimate()]), or extracted posterior samples (obtained from
[stan_fit_convert()).</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_cutoff">cutoff</code></td>
<td>
<p>The percentage level of the test (default: 5%) as integer.</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_dec_rule">dec_rule</code></td>
<td>
<p>The decision rule to be used. Currently supports default &quot;or&quot;
(comparing against two reference distributions) and &quot;comb&quot; (combining the
reference distributions). The use of &quot;or&quot; is recommended, as &quot;comb&quot; is less
stable.</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_n_draws">n_draws</code></td>
<td>
<p>The number of draws to use for reference distributions
(default: 1000).</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_comp">comp</code></td>
<td>
<p>The distance metric to use. Should be one of &quot;frob&quot; (Frobenius
norm), &quot;maxdiff&quot; (maximum  difference), or &quot;l1&quot; (L1 norm) (default:
&quot;frob&quot;). The use of the Frobenius norm is recommended.</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_return_all">return_all</code></td>
<td>
<p>Logical indicating whether to return all distributions
(default: FALSE). Has to be set to TRUE for plotting the results.</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_sampling_method">sampling_method</code></td>
<td>
<p>Draw sequential pairs of samples from the posterior,
with certain distance between them (&quot;sequential&quot;) or randomly from two
halves of the posterior (&quot;random&quot;). The &quot;random&quot; method is preferred to
account for potential autocorrelation between subsequent samples. Default:
&quot;random&quot;.</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_indices">indices</code></td>
<td>
<p>A list of &quot;beta&quot; and &quot;pcor&quot; indices specifying which elements
of the matrices to consider when calculating distances. If NULL (default),
all elements of both matrices are considered. If provided, only the
elements at these indices are considered. If only one of the matrices
should have indices, the other one should be NULL. This can be useful if
you want to calculate distances based on a subset of the elements in the
matrices.</p>
</td></tr>
<tr><td><code id="compare_gvar_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations to discard (default: 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (of class &quot;compare_gvar&quot;) containing the results of the
comparison. The list includes:
</p>
<table>
<tr><td><code>sig_beta</code></td>
<td>
<p>Binary decision on whether there is a significant difference between the temporal networks of A and B</p>
</td></tr>
<tr><td><code>sig_pcor</code></td>
<td>
<p>Binary decision on whether there is a significant difference between the contemporaneous networks of A and B</p>
</td></tr>
<tr><td><code>res_beta</code></td>
<td>
<p>The null distribution for the temporal networks for both models</p>
</td></tr>
<tr><td><code>res_pcor</code></td>
<td>
<p>The null distribution for the contemporaneous networks for both models</p>
</td></tr>
<tr><td><code>emp_beta</code></td>
<td>
<p>The empirical distance between the two temporal networks</p>
</td></tr>
<tr><td><code>emp_pcor</code></td>
<td>
<p>The empirical distance between the two contemporaneous networks</p>
</td></tr>
<tr><td><code>larger_beta</code></td>
<td>
<p>The number of reference distances larger than the empirical distance for the temporal network</p>
</td></tr>
<tr><td><code>larger_pcor</code></td>
<td>
<p>The number of reference distances larger than the empirical distance for the temporal network</p>
</td></tr>
<tr><td><code>arguments</code></td>
<td>
<p>The arguments used in the function call</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># use internal fit data of two individuals
data(fit_data)
test_res &lt;- compare_gvar(fit_data[[1]],
fit_data[[2]],
n_draws = 100,
return_all = TRUE)
print(test_res)
</code></pre>

<hr>
<h2 id='fit_data'>Example Posterior Samples</h2><span id='topic+fit_data'></span>

<h3>Description</h3>

<p>This dataset contains posterior samples of beta coefficients and partial correlations for two individuals.
It was generated by fitting a GVAR model using [stan_gvar()] with three variables from the [ts_data] dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fit_data)
</code></pre>


<h3>Format</h3>

<p>## 'fit_data'
A list with two elements, each containing posterior samples for one individual.
</p>


<h3>Details</h3>

<p>The list contains two elements, each containing posterior samples for one individual.
The samples were extracted using the [stan_fit_convert()] function.
For each individual, the list elements contain the posterior means of the beta coefficients
(&quot;beta_mu&quot;) and the posterior means of the partial correlations (&quot;pcor_mu&quot;).
The &quot;fit&quot; element contains all 1000 posterior samples of the beta coefficients and partial correlations.
</p>


<h3>Source</h3>

<p>The data is generated using the [stan_gvar()] function on subsets
of the [ts_data] time series data.
</p>

<hr>
<h2 id='get_centrality'>Compute Centrality Measures</h2><span id='topic+get_centrality'></span>

<h3>Description</h3>

<p>This function computes various network centrality measures for a given GVAR
fit object. Centrality measures describe the &quot;connectedness&quot; of a variable in
a network, while density describes the networks' overall connectedness.
Specifically, it computes the in-strength, out-strength, contemporaneous
strength, temporal network density, and contemporaneous network density. The
result can then be visualized using [plot_centrality()].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_centrality(fitobj, burnin = 0, remove_ar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_centrality_+3A_fitobj">fitobj</code></td>
<td>
<p>Fitted model object for a Bayesian GVAR model. This can be
'tsnet_fit' object (obtained from [stan_gvar()]), a BGGM object (obtained
from [BGGM::var_estimate()]), or extracted posterior samples (obtained from
[stan_fit_convert()).</p>
</td></tr>
<tr><td><code id="get_centrality_+3A_burnin">burnin</code></td>
<td>
<p>An integer specifying the number of initial samples to discard
as burn-in. Default is 0.</p>
</td></tr>
<tr><td><code id="get_centrality_+3A_remove_ar">remove_ar</code></td>
<td>
<p>A logical value specifying whether to remove the
autoregressive effects for centrality calculation. Default is TRUE. This is
only relevant for the calculation of temporal centrality/density measures.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following centrality measures:
</p>

<ul>
<li> <p><code>instrength</code>: In-strength centrality.
</p>
</li>
<li> <p><code>outstrength</code>: Out-strength centrality.
</p>
</li>
<li> <p><code>strength</code>: Contemporaneous strength centrality.
</p>
</li>
<li> <p><code>density_beta</code>: Temporal network density.
</p>
</li>
<li> <p><code>density_pcor</code>: Contemporaneous network density.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'> # Use first individual from example fit data from tsnet
 data(fit_data)
 centrality_measures &lt;- get_centrality(fit_data[[1]])

</code></pre>

<hr>
<h2 id='plot_centrality'>Plot Centrality Measures</h2><span id='topic+plot_centrality'></span>

<h3>Description</h3>

<p>This function creates a plot of various centrality measures for a given
object. The plot can be either a &quot;tiefighter&quot; plot or a &quot;density&quot; plot. The
&quot;tiefighter&quot; plot shows the centrality measures for each variable with
uncertainty bands, while the &quot;density&quot; plot shows the full density of the
centrality measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_centrality(obj, plot_type = "tiefighter", cis = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_centrality_+3A_obj">obj</code></td>
<td>
<p>An object containing the centrality measures obtained from
[get_centrality()].</p>
</td></tr>
<tr><td><code id="plot_centrality_+3A_plot_type">plot_type</code></td>
<td>
<p>A character string specifying the type of plot. Accepts
&quot;tiefighter&quot; or &quot;density&quot;. Default is &quot;tiefighter&quot;.</p>
</td></tr>
<tr><td><code id="plot_centrality_+3A_cis">cis</code></td>
<td>
<p>A numeric value specifying the credible interval. Must be between
0 and 1 (exclusive). Default is 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object visualizing the centrality measures. For a
&quot;tiefighter&quot; plot, each point represents the mean centrality measure for a
variable, and the bars represent the credible interval. In a &quot;density&quot;
plot, distribution of the centrality measures is visualized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fit_data)
obj &lt;- get_centrality(fit_data[[1]])
  plot_centrality(obj,
  plot_type = "tiefighter",
  cis = 0.95)


</code></pre>

<hr>
<h2 id='plot.compare_gvar'>Plot compare_gvar</h2><span id='topic+plot.compare_gvar'></span>

<h3>Description</h3>

<p>This function is a plotting method for the class produced by
[compare_gvar()]. It generates a plot showing the density of posterior
uncertainty distributions for distances and the empirical distance value for two GVAR models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compare_gvar'
plot(x, name_a = NULL, name_b = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.compare_gvar_+3A_x">x</code></td>
<td>
<p>An object of class &quot;compare_gvar&quot;.</p>
</td></tr>
<tr><td><code id="plot.compare_gvar_+3A_name_a">name_a</code></td>
<td>
<p>Optional. The name for model A. If provided, it replaces
&quot;mod_a&quot; in the plot.</p>
</td></tr>
<tr><td><code id="plot.compare_gvar_+3A_name_b">name_b</code></td>
<td>
<p>Optional. The name for model B. If provided, it replaces
&quot;mod_b&quot; in the plot.</p>
</td></tr>
<tr><td><code id="plot.compare_gvar_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first checks if the full reference distributions of
[compare_gvar()] are saved using the argument 'return_all' set to TRUE. If
not, an error is thrown.
</p>
<p>Using the &quot;name_a&quot; and &quot;name_b&quot; arguments allows for custom labeling of the
two models in the plot.
</p>
<p>The function generates two density plots using 'ggplot2', one for the
temporal network (beta) and another for the contemporaneous network (pcor).
The density distributions are filled with different colors based on the
corresponding models (mod_a and mod_b). The empirical distances between the
networks are indicated by red vertical lines.
</p>


<h3>Value</h3>

<p>A ggplot object representing the density plots of the posterior
uncertainty distributions for distances and the empirical distance for two GVAR models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fit_data)
test_res &lt;- compare_gvar(fit_data[[1]],
fit_data[[2]],
n_draws = 100,
return_all = TRUE)
plot(test_res)

</code></pre>

<hr>
<h2 id='post_distance_within'>Calculates distances between pairs of posterior samples using the posterior
samples or posterior predictive draws</h2><span id='topic+post_distance_within'></span>

<h3>Description</h3>

<p>This function computes distances between posterior samples of a
single fitted GVAR model. Thereby, it calculates the uncertainty contained
in the posterior distribution, which can be used as a reference to compare
two modes. Distances can be obtained either from posterior samples or
posterior predictive draws. The distance between two models can currently
be calculated based on three options: Frobenius norm, maximum difference,
or L1 norm. Used within [compare_gvar()]. The function is not intended to
be used directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_distance_within(
  fitobj,
  comp,
  pred,
  n_draws = 1000,
  sampling_method = "random",
  indices = NULL,
  burnin = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_distance_within_+3A_fitobj">fitobj</code></td>
<td>
<p>Fitted model object. This can be a tsnet_fit object (obtained
from [stan_gvar()]), a BGGM object (obtained from [BGGM::var_estimate()]),
or extracted posterior samples (obtained from [stan_fit_convert()).</p>
</td></tr>
<tr><td><code id="post_distance_within_+3A_comp">comp</code></td>
<td>
<p>The distance metric to use. Should be one of &quot;frob&quot; (Frobenius
norm), &quot;maxdiff&quot; (maximum  difference), or &quot;l1&quot; (L1 norm) (default:
&quot;frob&quot;). The use of the Frobenius norm is recommended.</p>
</td></tr>
<tr><td><code id="post_distance_within_+3A_pred">pred</code></td>
<td>
<p>A logical indicating whether the input is posterior predictive
draws (TRUE) or posterior samples (FALSE). Default: FALSE</p>
</td></tr>
<tr><td><code id="post_distance_within_+3A_n_draws">n_draws</code></td>
<td>
<p>The number of draws to use for reference distributions
(default: 1000).</p>
</td></tr>
<tr><td><code id="post_distance_within_+3A_sampling_method">sampling_method</code></td>
<td>
<p>Draw sequential pairs of samples from the posterior,
with certain distance between them (&quot;sequential&quot;) or randomly from two
halves of the posterior (&quot;random&quot;). The &quot;random&quot; method is preferred to
account for potential autocorrelation between subsequent samples. Default:
&quot;random&quot;.</p>
</td></tr>
<tr><td><code id="post_distance_within_+3A_indices">indices</code></td>
<td>
<p>A list of &quot;beta&quot; and &quot;pcor&quot; indices specifying which elements
of the matrices to consider when calculating distances. If NULL (default),
all elements of both matrices are considered. If provided, only the
elements at these indices are considered. If only one of the matrices
should have indices, the other one should be NULL. This can be useful if
you want to calculate distances based on a subset of the elements in the
matrices.</p>
</td></tr>
<tr><td><code id="post_distance_within_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations to discard (default: 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of distances between the specified pairs of fitted models. The
list has length equal to the specified number of random pairs. Each list
element contains two distance values, one for beta coefficients and one for
partial correlations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fit_data)
post_distance_within(fitobj = fit_data[[1]],
comp = "frob",
pred = FALSE,
n_draws = 100)

</code></pre>

<hr>
<h2 id='posterior_plot'>posterior_plot</h2><span id='topic+posterior_plot'></span>

<h3>Description</h3>

<p>Plots posterior distributions of the parameters of the temporal
or the contemporaneous networks of a GVAR model. The posterior distributions
are visualized as densities in a matrix layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_plot(fitobj, mat = "beta", cis = c(0.8, 0.9, 0.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior_plot_+3A_fitobj">fitobj</code></td>
<td>
<p>Fitted model object. This can be a tsnet_fit object (obtained
from [stan_gvar()]) or a BGGM object (obtained from [BGGM::var_estimate()]).</p>
</td></tr>
<tr><td><code id="posterior_plot_+3A_mat">mat</code></td>
<td>
<p>A matrix to use for plotting. Possibilities include &quot;beta&quot;
(temporal network) and &quot;pcor&quot; (contemporaneous network). Default is &quot;beta&quot;
(temporal network).</p>
</td></tr>
<tr><td><code id="posterior_plot_+3A_cis">cis</code></td>
<td>
<p>A numeric vector of credible intervals to use for plotting.
Default is c(0.8, 0.9, 0.95).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the returned plot, posterior distributions for every parameter
are shown. Lagged variables are displayed along the vertical line of the
grid, and non-lagged variables along the horizontal line of the grids.
</p>


<h3>Value</h3>

<p>A ggplot object representing the posterior distributions of the parameters of the temporal
or the contemporaneous networks of a GVAR model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load simulated time series data
data(ts_data)
example_data &lt;- ts_data[1:100,1:4]

# Estimate a GVAR model
fit &lt;- stan_gvar(example_data, n_chains = 2)

# Extract posterior samples
posterior_plot(fit)

</code></pre>

<hr>
<h2 id='print.compare_gvar'>Print method for compare_gvar objects</h2><span id='topic+print.compare_gvar'></span>

<h3>Description</h3>

<p>This function prints a summary of the Norm-Based Comparison Test for a [compare_gvar()] object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compare_gvar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.compare_gvar_+3A_x">x</code></td>
<td>
<p>A test object obtained from [compare_gvar()]</p>
</td></tr>
<tr><td><code id="print.compare_gvar_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the print method. (currently not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints a summary of the Norm-Based Comparison Test for a [compare_gvar()] object.
in the temporal and contemporaneous networks, as well as the number of reference distances that were larger
than the empirical distance for each network.
</p>


<h3>Value</h3>

<p>Prints a summary of the Norm-Based Comparison Test to the console
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example fits
data(fit_data)

# Perform test
test_res &lt;- compare_gvar(fit_data[[1]], fit_data[[2]], n_draws = 100)

# Print results
print(test_res)

</code></pre>

<hr>
<h2 id='print.tsnet_fit'>Print method for tsnet_fit objects</h2><span id='topic+print.tsnet_fit'></span>

<h3>Description</h3>

<p>This method provides a summary of the Bayesian GVAR model fitted with [stan_gvar()].
It prints general information about the model, including the estimation method and the number of chains and iterations
It also prints the posterior mean of the temporal and contemporaneous coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsnet_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tsnet_fit_+3A_x">x</code></td>
<td>
<p>A tsnet_fit object.</p>
</td></tr>
<tr><td><code id="print.tsnet_fit_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the print method (currently not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load example data
data(ts_data)
example_data &lt;- ts_data[1:100,1:3]

# Fit the model
fit &lt;- stan_gvar(example_data,
                 method = "sampling",
                 cov_prior = "IW",
                 n_chains = 2)

print(fit)

</code></pre>

<hr>
<h2 id='stan_fit_convert'>Convert Stan Fit to Array of Samples</h2><span id='topic+stan_fit_convert'></span>

<h3>Description</h3>

<p>This function converts a Stan fit object into an array of samples for the
temporal coefficients and the innovation covariance or partial correlation
matrices. It supports rstan as a backend. It can be used to convert models
fit using [stan_gvar()] into 3D arrays, which is the standard data structure
used in 'tsnet'. The function allows to select which parameters should be
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_fit_convert(stan_fit, return_params = c("beta", "sigma", "pcor"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_fit_convert_+3A_stan_fit">stan_fit</code></td>
<td>
<p>A Stan fit object obtained from rstan or a tsnet_fit object
from [stan_gvar()].</p>
</td></tr>
<tr><td><code id="stan_fit_convert_+3A_return_params">return_params</code></td>
<td>
<p>A character vector specifying which parameters to
return. Options are &quot;beta&quot; (temporal network), &quot;sigma&quot; (innovation
covariance), and &quot;pcor&quot; (partial correlations). Default is
c(&quot;beta&quot;,&quot;sigma&quot;, &quot;pcor&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing 3D arrays for the selected parameters. Each array
represents the posterior samples for a parameter, and each slice of the
array represents a single iteration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ts_data)
example_data &lt;- ts_data[1:100,1:3]
fit &lt;- stan_gvar(data = example_data,
                 n_chains = 2,
                 n_cores = 1)
samples &lt;- stan_fit_convert(fit, return_params = c("beta", "pcor"))


</code></pre>

<hr>
<h2 id='stan_gvar'>Fit Bayesian Graphical Vector Autoregressive (GVAR) Models with Stan</h2><span id='topic+stan_gvar'></span>

<h3>Description</h3>

<p>This function fits a Bayesian GVAR model to the provided data
using Stan. The estimation procedure is described further in Siepe, Kloft &amp;
Heck (2023) &lt;doi:10.31234/osf.io/uwfjc&gt;. The current implementation allows
for a normal prior on the temporal effects and either an Inverse Wishart or
an LKJ prior on the contemporaneous effects. 'rstan' is used as a backend
for fitting the model in Stan. Data should be provided in long format, where
the columns represent the variables and the rows represent the time points.
Data are automatically z-scaled for estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_gvar(
  data,
  beep = NULL,
  priors = NULL,
  method = "sampling",
  cov_prior = "IW",
  rmv_overnight = FALSE,
  iter_sampling = 500,
  iter_warmup = 500,
  n_chains = 4,
  n_cores = 1,
  center_only = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_gvar_+3A_data">data</code></td>
<td>
<p>A data frame or matrix containing the time series data of a
single subject. The data should be in long format,  where the columns
represent the variables and the rows represent the time points. See the
example data [ts_data] for the correct format.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_beep">beep</code></td>
<td>
<p>A vector of beeps with length of 'nrow(data)'. The beep indicator
can be used to remove overnight effects from the last beep of a day to the
first beep of the next day. This should be a vector of positive integers.
If left empty, the function will assume that there are no overnight
effects to remove.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_priors">priors</code></td>
<td>
<p>A list of prior distributions for the model parameters. This
should be a named list, with names corresponding to the parameter names and
values corresponding to the prior distributions. The following priors can
be specified:
</p>

<ul>
<li><p> 'prior_Beta_loc' A matrix of the same dimensions as the beta matrix
'B' containing the mean of the prior distribution for the beta coefficients.
</p>
</li>
<li><p> 'prior_Beta_scale' A matrix of the same dimensions as the beta matrix
'B' containing the standard deviation of the prior distribution for the beta
coefficients.</p>
</li></ul>
</td></tr>
<tr><td><code id="stan_gvar_+3A_method">method</code></td>
<td>
<p>A string indicating the method to use for fitting the model.
Options are &quot;sampling&quot; (for MCMC estimation) or &quot;variational&quot; (for
variational inference). We currently recommend only using MCMC estimation.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_cov_prior">cov_prior</code></td>
<td>
<p>A string indicating the prior distribution to use for the
covariance matrix. Options are &quot;LKJ&quot; or &quot;IW&quot; (Inverse-Wishart).</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_rmv_overnight">rmv_overnight</code></td>
<td>
<p>A logical indicating whether to remove overnight
effects. Default is 'FALSE'. If 'TRUE', the function will remove overnight
effects from the last beep of a day to the first beep of the next day.
This requires the 'beep' argument to be specified.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_iter_sampling">iter_sampling</code></td>
<td>
<p>An integer specifying the number of iterations for the
sampling method. Default is 500.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_iter_warmup">iter_warmup</code></td>
<td>
<p>An integer specifying the number of warmup iterations for
the sampling method. Default is 500.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_n_chains">n_chains</code></td>
<td>
<p>An integer specifying the number of chains for the sampling
method. Default is 4. If variational inference is used, the number of
iterations is calculated as 'iter_sampling'*'n_chains'.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_n_cores">n_cores</code></td>
<td>
<p>An integer specifying the number of cores to use for parallel
computation. Default is 1. [rstan] is used for parallel computation.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_center_only">center_only</code></td>
<td>
<p>A logical indicating whether to only center (and not
scale) the data. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="stan_gvar_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the 'rstan::sampling' or
'rstan::vb' function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>General Information</b>
</p>
<p>In a Graphical Vector Autoregressive (GVAR) model of lag 1, each variable
is regressed on itself and all other variables at the previous timepoint to
obtain estimates of the temporal association between variables
(encapsulated in the beta matrix). This is the &quot;Vector Autoregressive&quot; part
of the model. Additionally, the innovation structure at each time point
(which resembles the residuals) is modeled to obtain estimates of the
contemporaneous associations between all variables (controlling for the
lagged effects). This is typically represented in the partial correlation
(pcor) matrix. If the model is represented and interpreted as a network,
variables are called
*nodes*, *edges* represent the statistical association between the nodes, and
*edge weights* quantify the strength of these associations.
</p>
<p><b>Model</b>
</p>
<p>Let <code class="reqn">Y</code> be a matrix with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns, where <code class="reqn">n_t</code> is the
number of time points and <code class="reqn">p</code> is the number of variables. The GVAR model is
given by the following equations: </p>
<p style="text-align: center;"><code class="reqn">Y_t = B* Y_{t-1} + zeta_t</code>
</p>

<p style="text-align: center;"><code class="reqn">zeta_t \sim  N(0, \Sigma)</code>
</p>
<p> where <code class="reqn">B</code> is a 'p x p' matrix of VAR
coefficients between variables i and j (beta_ij), <code class="reqn">\zeta_t</code> contains the
innovations at time point <code class="reqn">t</code>, and <code class="reqn">\Sigma</code> is a 'p x p'covariance matrix.
The inverse of <code class="reqn">\Sigma</code> is the precision matrix, which is used to obtain the
partial correlations between variables (rho_ij). The model setup is
explained in more detail in Siepe, Kloft &amp; Heck (2023)
&lt;doi:10.31234/osf.io/uwfjc&gt;.
</p>
<p><b>Prior Setup</b>
</p>
<p>For the p x p temporal matrix B (containing the beta coefficients), we use
a normal prior distribution on each individual parameter: </p>
<p style="text-align: center;"><code class="reqn">\beta_{ij}
  \sim N(PriorBetaLoc_{ij}, PriorBetaScale_{ij})</code>
</p>
<p> where 'PriorBetaLoc' is the
mean of the prior distribution and 'PriorBetaScale' is the standard
deviation of the prior distribution. The default prior is a weakly
informative normal distribution with mean 0 and standard deviation 0.5. The
user can specify a different prior distribution by a matrix
'prior_Beta_loc' and a matrix 'prior_Beta_scale' with the same dimensions
as <code class="reqn">B</code>.
</p>
<p>Both a Lewandowski-Kurowicka-Joe (LKJ) and an Inverse-Wishart (IW)
distribution can be used as a prior for the contemporaneous network.
However, the LKJ prior does not allow for direct specifications of priors
on the partial correlations. We implemented a workaround to enable priors
on specific partial correlations (described below). We consider this
feature experimental would advise users wishing to implement edge-specific
priors in the contemporaneous network to preferentially use IW priors.
</p>
<p>The LKJ prior is a distribution on the correlation matrix, which is
parameterized by the shape parameter <code class="reqn">\eta</code>. To enable edge-specific priors
on the partial correlations, we use the workaround of a &quot;joint&quot; prior
that, in addition to the LKJ on the correlation matrix itself, allows for
an additional beta prior on each of the partial correlations. We first
assigned an uninformed LKJ prior to the Cholesky factor decomposition of
the correlation matrix of innovations: </p>
<p style="text-align: center;"><code class="reqn">\Omega_L \sim
  LKJ-Cholesky(\eta)</code>
</p>
<p>. For <code class="reqn">\eta = 1</code>, this implies a symmetric marginal
scaled beta distribution on the zero-order correlations <code class="reqn">\omega_{ij}</code>.
</p>
<p style="text-align: center;"><code class="reqn">(\omega_{ij}+1)/2 \sim Beta(p/2, p/2)</code>
</p>

<p>We can then obtain the covariance matrix and,
subsequently, the precision matrix (see Siepe, Kloft &amp; Heck (2023))
for details.
The second part of the prior is a beta prior on each partial correlation
<code class="reqn">\rho_{ij}</code> (obtained from the off-diagonal elements of the precision matrix).
This prior was assigned by transforming the partial correlations to the
interval of 0,1 and then assigning a proportional (mean-variance
parameterized) beta prior:
</p>
<p style="text-align: center;"><code class="reqn">(\rho_{ij}+1)/2 \sim Beta_{prop}(PriorRhoLoc, PriorRhoScale)</code>
</p>

<p>A beta location parameter of 0.5 translates to an expected correlation of 0.
The variance parameter of sqrt(0.5) implies a uniform distribution of
partial correlations.
The user can specify a different prior distribution by a matrix
'prior_Rho_loc' and a matrix 'prior_Rho_scale' with the same dimensions as
the partial correlation matrix. Additionally, the user can change <code class="reqn">eta</code>
via the 'prior_Eta' parameter.
</p>
<p>The Inverse-Wishart prior is a distribution on the innovation covariance
matrix 'Sigma':
</p>
<p style="text-align: center;"><code class="reqn">\Sigma \sim IW(\nu, S)</code>
</p>

<p>where <code class="reqn">\nu</code> is the degrees of freedom and <code class="reqn">S</code> is the scale matrix. We here
use the default prior of </p>
<p style="text-align: center;"><code class="reqn">nu = delta + p - 1</code>
</p>
<p> for the degrees of freedom,
where <code class="reqn">\delta</code> is defined as <code class="reqn">s_{\rho}^{-1}-1</code> and <code class="reqn">s_{\rho}</code> is the
standard deviation of the implied marginal beta distribution of the
partial correlations. For the scale matrix <code class="reqn">S</code>, we use the identity matrix
<code class="reqn">I_p</code> of order p.
The user can set a prior on the expected standard deviation of the partial
correlations by specifying a 'prior_Rho_marginal' parameter. The default
value is 0.25, which has worked well in a simulation study.
Additionally, the user can specify a 'prior_S' parameter to set a different
scale matrix.
</p>
<p><b>Sampling</b>
The model can be fitted using either MCMC sampling or variational
inference via [rstan]. Per default, the model is fitted using the Stan
Hamiltonian Monte Carlo (HMC) No U-Turn (NUTS) sampler with 4 chains,
500 warmup iterations and 500 sampling iterations. We use a default
target average acceptance probability 'adapt_delta' of 0.8. As the output
is returned as a standard 'stanfit' object, the user can use the
'rstan' package to extract and analyze the results and obtain convergence
diagnostics.
</p>


<h3>Value</h3>

<p>A 'tsnet_fit' object in list format. The object contains the
following elements:
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p>A stanfit object containing the fitted model.</p>
</td></tr>
<tr><td><code>arguments</code></td>
<td>
<p>The number of variables &quot;p&quot;, the number of time points &quot;n_t&quot;, the column names &quot;cnames&quot;, and the arguments used in the function call.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load example data
data(ts_data)
example_data &lt;- ts_data[1:100,1:3]

# Fit the model
fit &lt;- stan_gvar(example_data,
                 method = "sampling",
                 cov_prior = "IW",
                 n_chains = 2)
print(fit)

</code></pre>

<hr>
<h2 id='ts_data'>Simulated Time Series Dataset</h2><span id='topic+ts_data'></span>

<h3>Description</h3>

<p>This dataset contains a simulated time series dataset for two individuals
generated using the 'graphicalVAR' package. The dataset is useful for testing
and demonstrating the functionality of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ts_data)
</code></pre>


<h3>Format</h3>

<p>## 'ts_data' A data frame with 500 rows and 7 columns.
</p>

<dl>
<dt>id</dt><dd><p>A character string identifier for the individual. There are two unique ids, representing two individuals.</p>
</dd>
<dt>V1-V6</dt><dd><p>These columns represent six different variables in the time series data.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The dataset consists of 250 observations each of 6 variables for two individuals.
The variables V1-V6 represent simulated time series data generated using the graphicalVARsim function from the graphicalVAR package.
The 'id' column contains a character string as identifier of the two individuals.
The data have been standardized  to have zero mean and unit variance.
</p>


<h3>Source</h3>

<p>Simulated using the [graphicalVAR::graphicalVARsim()] function.
</p>

<hr>
<h2 id='tsnet-package'>The 'tsnet' package</h2><span id='topic+tsnet-package'></span><span id='topic+tsnet'></span>

<h3>Description</h3>

<p>Time Series Network Analysis with R
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Björn S. Siepe <a href="mailto:bjoernsiepe@gmail.com">bjoernsiepe@gmail.com</a> (<a href="https://orcid.org/0000-0002-9558-4648">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Matthias Kloft <a href="mailto:kloft@uni-marburg.de">kloft@uni-marburg.de</a> (<a href="https://orcid.org/0000-0003-1845-6957">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Daniel W. Heck <a href="mailto:daniel.heck@uni-marburg.de">daniel.heck@uni-marburg.de</a> (<a href="https://orcid.org/0000-0002-6302-9252">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bsiepe/tsnet">https://github.com/bsiepe/tsnet</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bsiepe/tsnet/issues">https://github.com/bsiepe/tsnet/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
