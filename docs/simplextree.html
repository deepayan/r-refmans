<!DOCTYPE html><html lang="en-US"><head><title>Help for package simplextree</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simplextree}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simplextree-package'><p>simplextree package</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#adjacent'><p>Adjacent vertices.</p></a></li>
<li><a href='#as.list.st_traversal'><p>as.list.st_traversal</p></a></li>
<li><a href='#clear'><p>Clears the simplex tree</p></a></li>
<li><a href='#clone'><p>Clones the given simplex tree.</p></a></li>
<li><a href='#coface_roots'><p>Generates a coface roots traversal on the simplex tree.</p></a></li>
<li><a href='#cofaces'><p>Generates a coface traversal on the simplex tree.</p></a></li>
<li><a href='#collapse'><p>Elementary collapse</p></a></li>
<li><a href='#contract'><p>Edge contraction</p></a></li>
<li><a href='#degree'><p>The vertex degree.</p></a></li>
<li><a href='#deserialize'><p>Deserializes the simplex tree.</p></a></li>
<li><a href='#empty_face'><p>empty_face</p></a></li>
<li><a href='#enclosing_radius'><p>enclosing_radius</p></a></li>
<li><a href='#expand'><p>k-expansion.</p></a></li>
<li><a href='#faces'><p>Generates a face traversal on the simplex tree.</p></a></li>
<li><a href='#find'><p>Find simplices</p></a></li>
<li><a href='#flag'><p>flag</p></a></li>
<li><a href='#generate_ids'><p>Generates vertex ids.</p></a></li>
<li><a href='#insert'><p>Insert simplices</p></a></li>
<li><a href='#inverse.choose'><p>inverse.choose</p></a></li>
<li><a href='#is_face'><p>Is face</p></a></li>
<li><a href='#is_tree'><p>Checks if the simplicial complex is a tree.</p></a></li>
<li><a href='#k_simplices'><p>Generates a traversal on the k-simplices of the simplex tree.</p></a></li>
<li><a href='#k_skeleton'><p>Generates a k-skeleton traversal on the simplex tree.</p></a></li>
<li><a href='#level_order'><p>Generates a level order traversal on the simplex tree.</p></a></li>
<li><a href='#link'><p>Generates a traversal on the link of a given simplex in the simplex tree.</p></a></li>
<li><a href='#maximal'><p>Generates a traversal on the maximal of the simplex tree.</p></a></li>
<li><a href='#nat_to_sub'><p>nat_to_sub</p></a></li>
<li><a href='#nerve'><p>nerve</p></a></li>
<li><a href='#plot.Rcpp_Filtration'><p>plot.Rcpp_Filtration</p></a></li>
<li><a href='#plot.simplextree'><p>Plots the simplex tree</p></a></li>
<li><a href='#preorder'><p>Generates a preorder traversal on the simplex tree.</p></a></li>
<li><a href='#print_simplices'><p>Print simplices to the console</p></a></li>
<li><a href='#print.st_traversal'><p>print.st_traversal</p></a></li>
<li><a href='#reindex'><p>reindexes vertex ids</p></a></li>
<li><a href='#remove'><p>Remove simplices</p></a></li>
<li><a href='#rips'><p>rips</p></a></li>
<li><a href='#serialize'><p>Serializes the simplex tree.</p></a></li>
<li><a href='#simplex_tree'><p>Simplex Tree</p></a></li>
<li><a href='#sub_to_nat'><p>sub_to_nat</p></a></li>
<li><a href='#threshold'><p>threshold</p></a></li>
<li><a href='#traverse'><p>traverse</p></a></li>
<li><a href='#union_find'><p>UnionFind</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Provides Tools for Working with General Simplicial Complexes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-08-25</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Piekenbrock &lt;matt.piekenbrock@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an interface to a Simplex Tree data structure, which is 
  a data structure aimed at enabling efficient manipulation of simplicial complexes 
  of any dimension. The Simplex Tree data structure was originally introduced by 
  Jean-Daniel Boissonnat and Cl√©ment Maria (2014) &lt;<a href="https://doi.org/10.1007%2Fs00453-014-9887-3">doi:10.1007/s00453-014-9887-3</a>&gt;. </td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/peekxc/simplextree">https://github.com/peekxc/simplextree</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.10), methods, magrittr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-09 22:00:17 UTC; mpiekenbrock</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Piekenbrock [cre, aut],
  Jason Cory Brunson [ctb],
  Howard Hinnant [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-12 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simplextree-package'>simplextree package</h2><span id='topic+simplextree-package'></span>

<h3>Description</h3>

<p>Provides an R/Rcpp implementation of a Simplex Tree data structure and its related tools.
</p>


<h3>Details</h3>

<p>This package provides a lightweight implementation of a Simplex Tree data structure, exported as an Rcpp Module.
The current implementation provides a limited API and a subset of the functionality described in the paper.
</p>


<h3>Author(s)</h3>

<p>Matt Piekenbrock
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='adjacent'>Adjacent vertices.</h2><span id='topic+adjacent'></span>

<h3>Description</h3>

<p>Returns a vector of vertex ids that are immediately adjacent to a given vertex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacent(st, vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjacent_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="adjacent_+3A_vertices">vertices</code></td>
<td>
<p>vertex ids.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree(1:3)
st %&gt;% adjacent(2) 
# 1 3
</code></pre>

<hr>
<h2 id='as.list.st_traversal'>as.list.st_traversal</h2><span id='topic+as.list.st_traversal'></span>

<h3>Description</h3>

<p>as.list.st_traversal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'st_traversal'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.list.st_traversal_+3A_x">x</code></td>
<td>
<p>traversal object.</p>
</td></tr>
<tr><td><code id="as.list.st_traversal_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>

<hr>
<h2 id='clear'>Clears the simplex tree</h2><span id='topic+clear'></span>

<h3>Description</h3>

<p>Removes all simplices from the simplex tree, except the root node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear(st)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clear_+3A_st">st</code></td>
<td>
<p>a simplex tree object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree()
st %&gt;% insert(1:3)
print(st) ## Simplex Tree with (3, 3, 1) (0, 1, 2)-simplices
st %&gt;% clear()
print(st) ## &lt; empty simplex tree &gt;
</code></pre>

<hr>
<h2 id='clone'>Clones the given simplex tree.</h2><span id='topic+clone'></span>

<h3>Description</h3>

<p>Performs a deep-copy on the supplied simplicial complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clone(st)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clone_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
</table>

<hr>
<h2 id='coface_roots'>Generates a coface roots traversal on the simplex tree.</h2><span id='topic+coface_roots'></span>

<h3>Description</h3>

<p>The coface roots of a given simplex <code>sigma</code> are the roots of subtrees 
in the trie whose descendents (including the roots themselves) are cofaces of <code>sigma</code>.
This traversal is more useful when used in conjunction with other traversals, e.g. a <em>preorder</em> 
or <em>level_order</em> traversal at the roots enumerates the cofaces of <code>sigma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coface_roots(st, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coface_roots_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="coface_roots_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='cofaces'>Generates a coface traversal on the simplex tree.</h2><span id='topic+cofaces'></span>

<h3>Description</h3>

<p>Generates a coface traversal on the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cofaces(st, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cofaces_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="cofaces_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='collapse'>Elementary collapse</h2><span id='topic+collapse'></span>

<h3>Description</h3>

<p>Performs an elementary collapse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse(st, pair, w = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapse_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="collapse_+3A_pair">pair</code></td>
<td>
<p>list of simplices to collapse.</p>
</td></tr>
<tr><td><code id="collapse_+3A_w">w</code></td>
<td>
<p>vertex to collapse to, if performing a vertex collapse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides two types of <em>elementary collapses</em>. <br /> 
<br /> 
The first type of collapse is in the sense described by (1), which is 
summarized here. A simplex <code class="reqn">\sigma</code> is said to be collapsible through one of its faces <code class="reqn">\tau</code> if 
<code class="reqn">\sigma</code> is the only coface of <code class="reqn">\tau</code> (excluding <code class="reqn">\tau</code> itself). This function checks whether its possible to collapse <code class="reqn">\sigma</code> through <code class="reqn">\tau</code>, 
(if <code class="reqn">\tau</code> has <code class="reqn">\sigma</code> as its only coface), and if so, both simplices are removed. 
<code>tau</code> and <code>sigma</code> are sorted before comparison.
To perform this kind of elementary collapse, call <code>collapse</code> with two simplices as arguments, i.e. <code>tau</code> before <code>sigma</code>.
</p>
<p>Alternatively, this method supports another type of elementary collapse, also called a <em>vertex collapse</em>, as described 
in (2). This type of collapse maps a pair of vertices into a single vertex. To use this collapse, specify three vertex ids, the first 
two representing the free pair, and the last representing the target vertex to collapse to.
</p>


<h3>Value</h3>

<p>boolean indicating whether the collapse was performed.
</p>


<h3>References</h3>

<p>1. Boissonnat, Jean-Daniel, and Clement Maria. &quot;The simplex tree: An efficient data structure for general simplicial complexes.&quot; Algorithmica 70.3 (2014): 406-427.
</p>
<p>2. Dey, Tamal K., Fengtao Fan, and Yusu Wang. &quot;Computing topological persistence for simplicial maps.&quot; Proceedings of the thirtieth annual symposium on Computational geometry. ACM, 2014.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplextree::simplex_tree(1:3)
st %&gt;% print_simplices()
# 1, 2, 3, 1 2, 1 3, 2 3, 1 2 3
st %&gt;% collapse(list(1:2, 1:3))
# 1, 2, 3, 1 3, 2 3=

st %&gt;% insert(list(1:3, 2:5))
st %&gt;% print_simplices("column")
# 1 2 3 4 5 1 1 2 2 2 3 3 4 1 2 2 2 3 2
#           2 3 3 4 5 4 5 5 2 3 3 4 4 3
#                           3 4 5 5 5 4
#                                     5

st %&gt;% collapse(list(2:4, 2:5))
st %&gt;% print_simplices("column") 
# 1 2 3 4 5 1 1 2 2 2 3 3 4 1 2 2 3
#           2 3 3 4 5 4 5 5 2 3 4 4
#                           3 5 5 5
</code></pre>

<hr>
<h2 id='contract'>Edge contraction</h2><span id='topic+contract'></span>

<h3>Description</h3>

<p>Performs an edge contraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract(st, edge)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contract_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="contract_+3A_edge">edge</code></td>
<td>
<p>an edge to contract, as a 2-length vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs an <em>edge contraction</em> in the sense described by (1), which is 
summarized here. Given an edge <code class="reqn"> {va, vb}</code>, <code class="reqn">vb</code> is contracted to <code class="reqn">va</code> if <code class="reqn">vb</code> is 
removed from the complex and the link of <code class="reqn">va</code> is augmented with the link of <code class="reqn">vb</code>. This may be thought as 
applying the mapping: <br />
</p>
<p style="text-align: center;"><code class="reqn">f(u) = va</code>
</p>

<p>if <code class="reqn">u = vb</code>
and identity otherwise, to all simplices in the complex. <br /> 
<code>edge</code> is <strong>not</strong> sorted prior to contraction: the second vertex of the edge is always contracted to the first. 
Note that edge contraction is not symmetric.
</p>


<h3>References</h3>

<p>1. Boissonnat, Jean-Daniel, and Clement Maria. &quot;The simplex tree: An efficient data structure for general simplicial complexes.&quot; Algorithmica 70.3 (2014): 406-427.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree(1:3) 
st %&gt;% print_simplices()
# 1, 2, 3, 1 2, 1 3, 2 3, 1 2 3
st %&gt;% contract(c(1, 3)) %&gt;% print_simplices()
# 1, 2, 1 2
</code></pre>

<hr>
<h2 id='degree'>The vertex degree.</h2><span id='topic+degree'></span>

<h3>Description</h3>

<p>Returns the number of edges (degree) for each given vertex id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree(st, vertices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="degree_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="degree_+3A_vertices">vertices</code></td>
<td>
<p>the vertex ids to check the degree of.</p>
</td></tr>
</table>

<hr>
<h2 id='deserialize'>Deserializes the simplex tree.</h2><span id='topic+deserialize'></span>

<h3>Description</h3>

<p>Provides a compressed serialization interface for the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deserialize(complex, st = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deserialize_+3A_complex">complex</code></td>
<td>
<p>The result of <code><a href="#topic+serialize">serialize</a></code>.</p>
</td></tr>
<tr><td><code id="deserialize_+3A_st">st</code></td>
<td>
<p>optionally, the simplex tree to insert into. Otherwise a new one is created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The serialize/deserialize commands can be used to compress/uncompress the complex into 
smaller form amenable for e.g. storing on disk (see <code>saveRDS</code>) or saving for later use.
</p>


<h3>See Also</h3>

<p>Other serialization: 
<code><a href="#topic+serialize">serialize</a>()</code>
</p>

<hr>
<h2 id='empty_face'>empty_face</h2><span id='topic+empty_face'></span>

<h3>Description</h3>

<p>Alias to the empty integer vector (integer(0L)). Used to indicate the empty face of the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empty_face
</code></pre>


<h3>Format</h3>

<p>An object of class <code>integer</code> of length 0.
</p>


<h3>See Also</h3>

<p>traverse
</p>

<hr>
<h2 id='enclosing_radius'>enclosing_radius</h2><span id='topic+enclosing_radius'></span>

<h3>Description</h3>

<p>Computes the enclosing radius of a set of distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enclosing_radius(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enclosing_radius_+3A_d">d</code></td>
<td>
<p>a <code><a href="stats.html#topic+dist">dist</a></code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The enclosing radius is useful as an upper bound of the scale parameter 
for the rips filtration. Scales above the enclosing radius render the Vietoris‚ÄìRips
complex as a simplicial cone, beyond which the homology is trivial.
</p>

<hr>
<h2 id='expand'>k-expansion.</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>Performs a k-expansion on the 1-skeleton of the complex, adding k-simplices 
if all combinations of edges are included. Because this operation uses the edges alone to infer 
the existence of higher order simplices, the expansion assumes the underlying complex
is a flag complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(st, k = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="expand_+3A_k">k</code></td>
<td>
<p>the target dimension of the expansion.</p>
</td></tr>
</table>

<hr>
<h2 id='faces'>Generates a face traversal on the simplex tree.</h2><span id='topic+faces'></span>

<h3>Description</h3>

<p>Generates a face traversal on the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faces(st, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="faces_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="faces_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='find'>Find simplices</h2><span id='topic+find'></span>

<h3>Description</h3>

<p>Returns whether supplied simplices exist in the complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find(st, simplices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="find_+3A_simplices">simplices</code></td>
<td>
<p>simplices to insert, either as a vector, a list of vectors, or a column-matrix. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Traverses the simplex tree looking for <code>simplex</code>, returning whether or not it exists.
<code>simplex</code> can be specified as vector to represent a single simplex, and a list to represent a set of simplices. 
Each <code>simplex</code> is sorted before traversing the trie. <br />
<br />
If <code>simplices</code> is a vector, it's assumed to be a simplex. If a list, its assumed each element in the list 
represents a simplex (as vectors). If the simplices to insert are all of the same dimension, you can also 
optionally use a matrix, where each column is assumed to be a simplex.
</p>


<h3>Value</h3>

<p>boolean indicating whether or not <code>simplex</code> exists in the tree.
</p>


<h3>Usage</h3>

<p>st 
</p>


<h3>See Also</h3>

<p>insert remove
</p>

<hr>
<h2 id='flag'>flag</h2><span id='topic+flag'></span>

<h3>Description</h3>

<p>Creates a filtration of flag complexes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag(st, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flag_+3A_st">st</code></td>
<td>
<p>a simplex tree. See details.</p>
</td></tr>
<tr><td><code id="flag_+3A_d">d</code></td>
<td>
<p>a vector of edge weights, or a 'dist' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A flag complex is a simplicial complex whose k-simplices for k &gt;= 2 are completely determined 
by edges/graph of the complex. This function creates filtered simplicial complex using the supplied edge 
weights. The resulting complex is a simplex tree object endowed with additional structure; see. 
Vertices have their weights set to 0, and k-simplices w/ k &gt;= 2 have their weights set to the maximum
weight of any of its edges.
</p>

<hr>
<h2 id='generate_ids'>Generates vertex ids.</h2><span id='topic+generate_ids'></span><span id='topic+id_policy'></span>

<h3>Description</h3>

<p>Generates vertex ids representing 0-simplices not in the tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_ids(st, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_ids_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="generate_ids_+3A_n">n</code></td>
<td>
<p>the number of ids to generate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates new vertex ids for use in situations which involve generating new 
new 0-simplices, e.g. insertions, contractions, collapses, etc. There are two 'policies' which designate 
the generating mechanism of these ids: 'compressed' and 'unique'. 'compressed' generates vertex ids 
sequentially, starting at 0. 'unique' tracks an incremental internal counter, which is updated on every 
call to <code>generate_ids</code>. The new ids under the 'unique' policy generates the first sequential <code>n</code> 
ids that are strictly greater  <code>max</code>(<em>counter</em>, <em>max vertex id</em>). <br />
<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree()
print(st$id_policy)
## "compressed"
st %&gt;% generate_ids(3) 
## 0 1 2
st %&gt;% generate_ids(3) 
## 0 1 2
st %&gt;% insert(list(1,2,3))
print(st$vertices) 
## 1 2 3
st %&gt;% insert(as.list(st %&gt;% generate_ids(2)))
st %&gt;% print_simplices() 
# 0, 1, 2, 3, 4
st %&gt;% remove(4)
st %&gt;% generate_ids(1) 
# 4
</code></pre>

<hr>
<h2 id='insert'>Insert simplices</h2><span id='topic+insert'></span>

<h3>Description</h3>

<p>Inserts simplices into the simplex tree. Individual simplices are specified as vectors, and a set of simplices as a list of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insert(st, simplices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insert_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="insert_+3A_simplices">simplices</code></td>
<td>
<p>simplices to insert, either as a vector, a list of vectors, or a column-matrix. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows insertion of arbitrary order simplices. If the simplex already exists in the tree, 
no insertion is made, and the tree is not modified. <code>simplex</code> is sorted before traversing the trie. 
Faces of <code>simplex</code> not in the simplex tree are inserted as needed. <br />
<br />
If <code>simplices</code> is a vector, it's assumed to be a simplex. If a list, its assumed each element in the list 
represents a simplex (as vectors). If the simplices to insert are all of the same dimension, you can also 
optionally use a matrix, where each column is assumed to be a simplex.
</p>


<h3>See Also</h3>

<p>find remove
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree()
st %&gt;% insert(1:3) ## inserts the 2-simplex { 1, 2, 3 }
st %&gt;% insert(list(4:5, 6)) ## inserts a 1-simplex { 4, 5 } and a 0-simplex { 6 }.
st %&gt;% insert(combn(5,3)) ## inserts all the 2-faces of a 4-simplex
</code></pre>

<hr>
<h2 id='inverse.choose'>inverse.choose</h2><span id='topic+inverse.choose'></span>

<h3>Description</h3>

<p>Inverts the binomial coefficient for general (n,k).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inverse.choose(x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse.choose_+3A_x">x</code></td>
<td>
<p>the binomial coefficient.</p>
</td></tr>
<tr><td><code id="inverse.choose_+3A_k">k</code></td>
<td>
<p>the denominator of the binomial coefficient <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a quantity x = choose(n, k) with fixed k, finds n.
</p>


<h3>Value</h3>

<p>the numerator of the binomial coefficient, if the Otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>100 == inverse.choose(choose(100,2), k = 2)
# TRUE 
12345 == inverse.choose(choose(12345, 5), k = 5)
# TRUE
</code></pre>

<hr>
<h2 id='is_face'>Is face</h2><span id='topic+is_face'></span>

<h3>Description</h3>

<p>Checks whether a simplex is a face of another simplex and is in the complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_face(st, tau, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_face_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="is_face_+3A_tau">tau</code></td>
<td>
<p>a simplex which may contain <code>sigma</code> as a coface.</p>
</td></tr>
<tr><td><code id="is_face_+3A_sigma">sigma</code></td>
<td>
<p>a simplex which may contain <code>tau</code> as a face.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simplex <code class="reqn">\tau</code> is a face of <code class="reqn">\sigma</code> if <code class="reqn">\tau \subset \sigma</code>. This function 
checks whether that is true. <code>tau</code> and <code>sigma</code> are sorted before comparison.
</p>


<h3>Value</h3>

<p>boolean indicating whether <code>tau</code> is a face of <code>sigma</code>.
</p>


<h3>See Also</h3>

<p><a href="https://en.cppreference.com/w/cpp/algorithm/includes">std::includes</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree()
st %&gt;% insert(1:3)
st %&gt;% is_face(2:3, 1:3)
st %&gt;% is_face(1:3, 2:3)
</code></pre>

<hr>
<h2 id='is_tree'>Checks if the simplicial complex is a tree.</h2><span id='topic+is_tree'></span>

<h3>Description</h3>

<p>This function performs a breadth-first search on the simplicial complex, checking if the complex is acyclic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_tree(st)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_tree_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree()
st %&gt;% insert(list(1:2, 2:3))
st %&gt;% is_tree() # true
st %&gt;% insert(c(1, 3))
st %&gt;% is_tree() # false
</code></pre>

<hr>
<h2 id='k_simplices'>Generates a traversal on the k-simplices of the simplex tree.</h2><span id='topic+k_simplices'></span>

<h3>Description</h3>

<p>Generates a traversal on the k-simplices of the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_simplices(st, k, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k_simplices_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="k_simplices_+3A_k">k</code></td>
<td>
<p>the dimension of the skeleton to include.</p>
</td></tr>
<tr><td><code id="k_simplices_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='k_skeleton'>Generates a k-skeleton traversal on the simplex tree.</h2><span id='topic+k_skeleton'></span>

<h3>Description</h3>

<p>Generates a k-skeleton traversal on the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_skeleton(st, k, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k_skeleton_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="k_skeleton_+3A_k">k</code></td>
<td>
<p>the dimension of the skeleton to include.</p>
</td></tr>
<tr><td><code id="k_skeleton_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='level_order'>Generates a level order traversal on the simplex tree.</h2><span id='topic+level_order'></span>

<h3>Description</h3>

<p>Generates a level order traversal on the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>level_order(st, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="level_order_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="level_order_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='link'>Generates a traversal on the link of a given simplex in the simplex tree.</h2><span id='topic+link'></span>

<h3>Description</h3>

<p>Generates a traversal on the link of a given simplex in the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(st, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="link_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="link_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='maximal'>Generates a traversal on the maximal of the simplex tree.</h2><span id='topic+maximal'></span>

<h3>Description</h3>

<p>Generates a traversal on the maximal of the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximal(st, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maximal_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="maximal_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='nat_to_sub'>nat_to_sub</h2><span id='topic+nat_to_sub'></span>

<h3>Description</h3>

<p>Computes the <code>x</code>^th (<code>n</code> choose <code>2</code>) combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nat_to_sub(x, n, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nat_to_sub_+3A_x">x</code></td>
<td>
<p>non-negative integers in the range <code>c(1, choose(n, k))</code></p>
</td></tr>
<tr><td><code id="nat_to_sub_+3A_n">n</code></td>
<td>
<p>numerator of the binomial coefficient</p>
</td></tr>
<tr><td><code id="nat_to_sub_+3A_k">k</code></td>
<td>
<p>denominator of the binomial coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mapping is done via an lexicographically-ordered combinadic mapping. <br />
In general, this function is <em>not</em> intended to be used to <em>generate</em> all (n choose <code>k</code>)  combinations in the combinadic mapping.
</p>


<h3>Value</h3>

<p>integer matrix whose columns give the combinadics of <code>x</code>.
</p>


<h3>References</h3>

<p>McCaffrey, J. D. &quot;Generating the mth lexicographical element of a mathematical combination.&quot; MSDN Library (2004).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(simplextree)
all(nat_to_sub(seq(choose(100,2)), n = 100, k = 2) == combn(100,2))

## Generating pairwise combinadics is particularly fast
## Below: test to generate ~ 45k combinadics (note: better to use microbenchmark) 
system.time({
  x &lt;- seq(choose(300,2))
  nat_to_sub(x, n = 300, k = 2L)
})

## Compare with generating raw combinations
system.time(combn(300,2))
</code></pre>

<hr>
<h2 id='nerve'>nerve</h2><span id='topic+nerve'></span>

<h3>Description</h3>

<p>Compute the nerve of a given cover.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nerve(st, cover, k = st$dimension, threshold = 1L, neighborhood = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nerve_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="nerve_+3A_cover">cover</code></td>
<td>
<p>list of integers indicating set membership. See details.</p>
</td></tr>
<tr><td><code id="nerve_+3A_k">k</code></td>
<td>
<p>max simplex dimension to consider.</p>
</td></tr>
<tr><td><code id="nerve_+3A_threshold">threshold</code></td>
<td>
<p>the number of elements in common for <code>k</code> sets to be considered intersecting. Defaults to 1.</p>
</td></tr>
<tr><td><code id="nerve_+3A_neighborhood">neighborhood</code></td>
<td>
<p>which combinations of sets to check. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This computes the nerve of a given cover, adding a <em>k</em>-simplex for each combination of <em>k+1</em> sets 
in the given <code>cover</code> that have at least <code>threshold</code> elements in their common intersection. <br />
<br />
If <code>neighborhood</code> is supplied, it can be either 1) a matrix, 2) a list, or 3) a function. Each 
type parameterizes which sets in the cover need be checked for to see if they have at least <code>threshold</code>
elements in their common intersection. If a matrix is supplied, the columns should indicate the indices 
of the cover to check (e.g if <code>neighborhood = matrix(c(1,2), nrow = 2)</code>, then only the first two sets of <code>cover</code>
are tested.). Similarly, if a list is supplied, each element in the list should give the indices to test. <br />
<br />
The most flexible option is supplying a function to <code>neighborhood</code>. If a function is passed, it's assumed to 
accept an integer vector of <em>k</em> indices (of the cover) and return a boolean indicating whether or not to 
<em>test</em> if they have at least <code>threshold</code> elements in their common intersection. This can be used
to filter out subsets of the cover the user knows are  The indices are 
generated using the same code that performs <code><a href="#topic+expand">expand</a></code>.
</p>

<hr>
<h2 id='plot.Rcpp_Filtration'>plot.Rcpp_Filtration</h2><span id='topic+plot.Rcpp_Filtration'></span>

<h3>Description</h3>

<p>plot.Rcpp_Filtration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rcpp_Filtration'
plot(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Rcpp_Filtration_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+plot.Rcpp_SimplexTree">plot.Rcpp_SimplexTree</a></code></p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>plot.Rcpp_Filtration</code>: family of plotting methods.
</p>
</li></ul>

<hr>
<h2 id='plot.simplextree'>Plots the simplex tree</h2><span id='topic+plot.simplextree'></span><span id='topic+plot.Rcpp_SimplexTree'></span>

<h3>Description</h3>

<p>Plots the simplex tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rcpp_SimplexTree'
plot(
  x,
  coords = NULL,
  vertex_opt = NULL,
  text_opt = NULL,
  edge_opt = NULL,
  polygon_opt = NULL,
  color_pal = NULL,
  maximal = TRUE,
  by_dim = TRUE,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.simplextree_+3A_x">x</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_coords">coords</code></td>
<td>
<p>Optional (n x 2) matrix of coordinates, where n is the number of 0-simplices.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_vertex_opt">vertex_opt</code></td>
<td>
<p>Optional parameters to modify default vertex plotting options. Passed to <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_text_opt">text_opt</code></td>
<td>
<p>Optional parameters to modify default vertex text plotting options. Passed to <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_edge_opt">edge_opt</code></td>
<td>
<p>Optional parameters to modify default edge plotting options. Passed to <code><a href="graphics.html#topic+segments">segments</a></code>.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_polygon_opt">polygon_opt</code></td>
<td>
<p>Optional parameters to modify default k-simplex plotting options for k &gt; 1. Passed to <code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_color_pal">color_pal</code></td>
<td>
<p>Optional vector of colors. See details.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_maximal">maximal</code></td>
<td>
<p>Whether to draw only the maximal faces of the complex. Defaults to true.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_by_dim">by_dim</code></td>
<td>
<p>Whether to apply (and recycle or truncate) the color palette to the dimensions rather than to the individual simplices. Defaults to true.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_add">add</code></td>
<td>
<p>Whether to add to the plot or redraw. Defaults to false. See details.</p>
</td></tr>
<tr><td><code id="plot.simplextree_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows generic plotting of simplicial complexes using base <code><a href="graphics.html#topic+graphics-package">graphics</a></code>.<br />
If not (x,y) coordinates are supplied via <code>coords</code>, a default layout is generated via phyllotaxis arrangement. This layout is 
not in general does not optimize the embedding towards any usual visualization criteria e.g. it doesn't try to separate connected components, 
minimize the number of crossings, etc. For those, the user is recommended to look in existing code graph drawing libraries, e.g. igraphs 'layout.auto' function, etc. 
The primary benefit of the default phyllotaxis arrangement is that it is deterministic and fast to generate. 
<br />
All parameters passed via list to <code>vertex_opt</code>, <code>text_opt</code>, <code>edge_opt</code>, <code>polygon_opt</code> 
override default parameters and are passed to <code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+text">text</a></code>, <code><a href="graphics.html#topic+segments">segments</a></code>, 
and <code><a href="graphics.html#topic+polygon">polygon</a></code>, respectively.<br />
<br />
If <code>add</code> is true, the plot is not redrawn. <br />
<br />
If <code>maximal</code> is true, only the maximal simplices are drawn. <br />
<br />
The <code>color_pal</code> argument controls how the simplicial complex is colored. It can be specified in multiple ways.
</p>

<ol>
<li><p> A vector of colors of length <em>dim+1</em>, where <em>dim</em>=<code>x$dimension</code>
</p>
</li>
<li><p> A vector of colors of length <em>n</em>, where <em>n</em>=<code>sum(x$n_simplices)</code>
</p>
</li>
<li><p> A named list of colors
</p>
</li></ol>

<p>Option (1) assigns every simplex a color based on its dimension. <br />
<br />
Option (2) assigns each individual simplex a color. The vector must be specified in level-order 
(see <code><a href="#topic+ltraverse">ltraverse</a></code> or examples below). <br />
<br />
Option (3) allows specifying individual simplices to draw. It expects a named list, where the names
must correspond to simplices in <code>x</code> as comma-separated strings and whose values are colors. If 
option (3) is specified, this method will <em>only</em> draw the simplices given in <code>color_pal</code>.<br />
<br />
If <code>length(color_pal)</code> does not match the dimension or the number of simplices in the complex, 
the color palette is recyled and simplices are as such.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simple 3-simplex 
st &lt;- simplex_tree() %&gt;% insert(list(1:4))

## Default is categorical colors w/ diminishing opacity
plot(st)

## If supplied colors have alpha defined, use that 
vpal &lt;- rainbow(st$dimension + 1)
plot(st, color_pal = vpal)

## If alpha not supplied, decreasing opacity applied
plot(st, color_pal = substring(vpal, first=1, last=7))

## Bigger example; observe only maximal faces (+vertices and edges) are drawn
st &lt;- simplex_tree(list(1:3, 2:5, 5:9, 7:8, 10))
plot(st, color_pal = rainbow(st$dimension + 1))

## If maximal == FALSE, every simplex is drawn (even on top of each other)
vpal &lt;- rainbow(st$dimension + 1)[c(1,2,5,4,3)]
pal_alpha &lt;- c(1, 1, 0.2, 0.35, 0.35)
vpal &lt;- sapply(seq_along(vpal), function(i) adjustcolor(vpal[i], alpha.f = pal_alpha[i]))
plot(st, color_pal = vpal, maximal = FALSE)

## You can also color each simplex individually by supplying a vector 
## of the same length as the number of simplices. 
plot(st, color_pal = sample(rainbow(sum(st$n_simplices))))

## The order is assumed to follow the level order traversal (first 0-simplices, 1-, etc.)
## This example colors simplices on a rainbow gradient based on the sum of their labels
si_sum &lt;- straverse(st %&gt;% level_order, sum) 
rbw_pal &lt;- rev(rainbow(50, start=0,end=4/6))
plot(st, color_pal=rbw_pal[cut(si_sum, breaks=50, labels = FALSE)])

## This also makes highlighting simplicial operations fairly trivial 
four_cofaces &lt;- as.list(cofaces(st, 4))
coface_pal &lt;- straverse(level_order(st), function(simplex){ 
    ifelse(list(simplex) %in% four_cofaces, "orange", "blue") 
})
plot(st, color_pal=unlist(coface_pal))

## You can also give a named list to draw individual simplices. 
## **Only the maximal simplices in the list are drawn** 
blue_vertices &lt;- structure(as.list(rep("blue", 5)), names=as.character(seq(5, 9)))
plot(st, color_pal=append(blue_vertices, list("5,6,7,8,9"="red")))
</code></pre>

<hr>
<h2 id='preorder'>Generates a preorder traversal on the simplex tree.</h2><span id='topic+preorder'></span>

<h3>Description</h3>

<p>Generates a preorder traversal on the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preorder(st, sigma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preorder_+3A_st">st</code></td>
<td>
<p>the simplex tree to traverse.</p>
</td></tr>
<tr><td><code id="preorder_+3A_sigma">sigma</code></td>
<td>
<p>simplex to start the traversal at.</p>
</td></tr>
</table>

<hr>
<h2 id='print_simplices'>Print simplices to the console</h2><span id='topic+print_simplices'></span>

<h3>Description</h3>

<p>Prints simplices in a formatted way
</p>
<p>Prints a traversal, a simplex tree, or a list of simplices to the R console, with 
options to customize how the simplices are printed. The <code>format</code> must be one of 
&quot;summary&quot;, &quot;tree&quot;, &quot;cousins&quot;, &quot;short&quot;, &quot;column&quot;, or &quot;row&quot;, with the default being &quot;short&quot;.
In general, the &quot;tree&quot; and &quot;cousins&quot; format give more details on the structure of the trie, 
whereas the other formats just change how the given set of simplices are formatted.
<br />
The &quot;tree&quot; method prints the nodes grouped by the same last label and indexed by depth.
The printed format is: <br /> 
<br />
[vertex] (h = [subtree height]): [subtree depth]([subtree]) <br /> 
<br />
Where each lists the top node (<em>vertex</em>) and its corresponding subtree. The 
<em>subtree height</em> displays the highest order k-simplex in that subtree. Each 
level in the subtree tree is a set of sibling k-simplices whose order is given  
by the number of dots ('.') proceeding the print level.<br /> 
<br />
The &quot;cousin&quot; format prints the simplex relations used by various algorithms to speed 
up finding adjacencies in the complex. The cousins are grouped by label and depth. <br /> 
The format looks like: 
<br />
(last=[label], depth=[depth of label]): [simplex] <br />
<br />
This function is useful for understanding how the simplex tree is stored, and for debugging purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_simplices(
  st,
  format = c("summary", "tree", "cousins", "short", "column", "row")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_simplices_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="print_simplices_+3A_format">format</code></td>
<td>
<p>the choice of how to format the printing. See details.</p>
</td></tr>
</table>

<hr>
<h2 id='print.st_traversal'>print.st_traversal</h2><span id='topic+print.st_traversal'></span>

<h3>Description</h3>

<p>print.st_traversal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'st_traversal'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.st_traversal_+3A_x">x</code></td>
<td>
<p>traversal object.</p>
</td></tr>
<tr><td><code id="print.st_traversal_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>

<hr>
<h2 id='reindex'>reindexes vertex ids</h2><span id='topic+reindex'></span>

<h3>Description</h3>

<p>This function allows one to 'reorder' or 'reindex' vertex ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reindex(st, ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reindex_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="reindex_+3A_ids">ids</code></td>
<td>
<p>vector of new vertex ids. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ids</code> parameter must be a sorted integer vector of new ids with length matching the 
number of vertices. The simplex tree is modified to replace the vertex label at index <code>i</code> with 
<code>ids</code>[i]. See examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree()
st %&gt;% insert(1:3) %&gt;% print_simplices("tree")
# 1 (h = 2): .( 2 3 )..( 3 )
# 2 (h = 1): .( 3 )
# 3 (h = 0):
st %&gt;% reindex(4:6) %&gt;% print_simplices("tree")
# 4 (h = 2): .( 5 6 )..( 6 )
# 5 (h = 1): .( 6 )
# 6 (h = 0):
</code></pre>

<hr>
<h2 id='remove'>Remove simplices</h2><span id='topic+remove'></span>

<h3>Description</h3>

<p>Removes simplices from the simplex tree. Individual simplices are specified as vectors, and a set of simplices as a list of vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove(st, simplices)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
<tr><td><code id="remove_+3A_simplices">simplices</code></td>
<td>
<p>simplices to insert, either as a vector, a list of vectors, or a column-matrix. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows removal of a arbitrary order simplices. If <code>simplex</code> already exists in the tree, 
it is removed, otherwise the tree is not modified. <code>simplex</code> is sorted before traversing the trie.
Cofaces of <code>simplex</code> are also removed. <br />
<br />
If <code>simplices</code> is a vector, it's assumed to be a simplex. If a list, its assumed each element in the list 
represents a simplex (as vectors). If the simplices to insert are all of the same dimension, you can also 
optionally use a matrix, where each column is assumed to be a simplex.
</p>


<h3>See Also</h3>

<p>find remove
</p>

<hr>
<h2 id='rips'>rips</h2><span id='topic+rips'></span>

<h3>Description</h3>

<p>Constructs the Vietoris-Rips complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rips(d, eps = enclosing_radius(d), dim = 1L, filtered = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rips_+3A_d">d</code></td>
<td>
<p>a numeric 'dist' vector.</p>
</td></tr>
<tr><td><code id="rips_+3A_eps">eps</code></td>
<td>
<p>diameter parameter.</p>
</td></tr>
<tr><td><code id="rips_+3A_dim">dim</code></td>
<td>
<p>maximum dimension to construct up to. Defaults to 1 (edges only).</p>
</td></tr>
<tr><td><code id="rips_+3A_filtered">filtered</code></td>
<td>
<p>whether to construct the filtration. Defaults to false. See details.</p>
</td></tr>
</table>

<hr>
<h2 id='serialize'>Serializes the simplex tree.</h2><span id='topic+serialize'></span>

<h3>Description</h3>

<p>Provides a compressed serialization interface for the simplex tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialize(st)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serialize_+3A_st">st</code></td>
<td>
<p>a simplex tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The serialize/deserialize commands can be used to compress/uncompress the complex into 
smaller form amenable for e.g. storing on disk (see <code>saveRDS</code>) or saving for later use. 
The serialization.
</p>


<h3>See Also</h3>

<p>Other serialization: 
<code><a href="#topic+deserialize">deserialize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>st &lt;- simplex_tree(list(1:5, 7:9))
st2 &lt;- deserialize(serialize(st))
all.equal(as.list(preorder(st)), as.list(preorder(st2)))
# TRUE 

set.seed(1234)
R &lt;- rips(dist(replicate(2, rnorm(100))), eps = pnorm(0.10), dim = 2)
print(R$n_simplices)
# 100 384 851

## Approx. size of the full complex 
print(utils::object.size(as.list(preorder(R))), units = "Kb")
# 106.4 Kb

## Approx. size of serialized version 
print(utils::object.size(serialize(R)), units = "Kb")
# 5.4 Kb
## You can save these to disk via e.g. saveRDS(serialize(R), ...)
</code></pre>

<hr>
<h2 id='simplex_tree'>Simplex Tree</h2><span id='topic+simplex_tree'></span><span id='topic+simplextree'></span><span id='topic+SimplexTree'></span>

<h3>Description</h3>

<p>Simplex tree class exposed as an Rcpp Module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplex_tree(simplices = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simplex_tree_+3A_simplices">simplices</code></td>
<td>
<p>optional simplices to initialize the simplex tree with. See <code><a href="#topic+insert">insert</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simplex tree is an ordered trie-like structure specialized for storing and doing general computation 
simplicial complexes. Here is figure of a simplex tree, taken from the original paper (see 1): <br />  
<img src="../help/figures/simplextree.png" width="80%" alt="Figure: simplextree.png" />

<br /> 
The current implementation provides a subset of the functionality described in the paper.
</p>


<h3>Value</h3>

<p>A queryable simplex tree, as a <code>Rcpp_SimplexTree</code> object (Rcpp module).
</p>


<h3>Fields</h3>


<dl>
<dt><code>n_simplices</code></dt><dd><p>A vector, where each index k denotes the number (k-1)-simplices.</p>
</dd>
<dt><code>dimension</code></dt><dd><p>The dimension of the simplicial complex.</p>
</dd>
</dl>


<h3>Properties</h3>

<p>Properties are actively bound shortcuts to various methods of the simplex tree that may be thought of as fields. 
Unlike fields, however, properties are not explicitly stored: they are generated on access. 
</p>

<dl>
<dt>$<code>id_policy</code></dt><dd><p> The policy used to generate new vertex ids. May be assigned &quot;compressed&quot; or &quot;unique&quot;. See <code><a href="#topic+generate_ids">generate_ids</a></code>. </p>
</dd>
<dt>$<code>vertices</code></dt><dd><p> The 0-simplices of the simplicial complex, as a matrix. </p>
</dd>
<dt>$<code>edges</code></dt><dd><p> The 1-simplices of the simplicial complex, as a matrix. </p>
</dd>
<dt>$<code>triangles</code></dt><dd><p> The 2-simplices of the simplicial complex, as a matrix. </p>
</dd>
<dt>$<code>quads</code></dt><dd><p> The 3-simplices of the simplicial complex, as a matrix. </p>
</dd>
<dt>$<code>connected_components</code></dt><dd><p> The connected components of the simplicial complex. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>$<code>as_XPtr</code></dt><dd><p> Creates an external pointer. </p>
</dd>
<dt>$<code>clear</code></dt><dd><p> Clears the simplex tree. </p>
</dd>
<dt>$<code><a href="#topic+generate_ids">generate_ids</a></code></dt><dd><p> Generates new vertex ids according to the set policy. </p>
</dd>
<dt>$<code><a href="#topic+degree">degree</a></code></dt><dd><p> Returns the degree of each given vertex. </p>
</dd>
<dt>$<code><a href="#topic+adjacent">adjacent</a></code></dt><dd><p> Returns vertices adjacent to a given vertex. </p>
</dd>
<dt>$<code><a href="#topic+insert">insert</a></code></dt><dd><p> Inserts a simplex into the trie. </p>
</dd>
<dt>$<code><a href="#topic+remove">remove</a></code></dt><dd><p> Removes a simplex from the trie. </p>
</dd>
<dt>$<code><a href="#topic+find">find</a></code></dt><dd><p> Returns whether a simplex exists in the trie. </p>
</dd>
<dt>$<code><a href="#topic+collapse">collapse</a></code></dt><dd><p> Performs an elementary collapse. </p>
</dd>
<dt>$<code><a href="#topic+contract">contract</a></code></dt><dd><p> Performs an edge contraction. </p>
</dd>
<dt>$<code><a href="#topic+expand">expand</a></code></dt><dd><p> Performs an k-expansion. </p>
</dd>
<dt>$<code><a href="#topic+traverse">traverse</a></code></dt><dd><p> Traverses a subset of the simplex tree, applying a function to each simplex. </p>
</dd>
<dt>$<code><a href="#topic+ltraverse">ltraverse</a></code></dt><dd><p> Traverses a subset of the simplex tree, applying a function to each simplex and returning the result as a list. </p>
</dd>
<dt>$<code><a href="#topic+is_face">is_face</a></code></dt><dd><p> Checks for faces. </p>
</dd>
<dt>$<code><a href="#topic+is_tree">is_tree</a></code></dt><dd><p> Checks if the simplicial complex is a tree. </p>
</dd>
<dt>$<code>as_list</code></dt><dd><p> Converts the simplicial complex to a list. </p>
</dd>
<dt>$<code>as_adjacency_matrix</code></dt><dd><p> Converts the 1-skeleton to an adjacency matrix. </p>
</dd>
<dt>$<code>as_adjacency_list</code></dt><dd><p> Converts the 1-skeleton to an adjacency list. </p>
</dd>
<dt>$<code>as_edgelist</code></dt><dd><p> Converts the 1-skeleton to an edgelist. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matt Piekenbrock
</p>


<h3>References</h3>

<p>Boissonnat, Jean-Daniel, and Clement Maria. &quot;The simplex tree: An efficient data structure for general simplicial complexes.&quot; Algorithmica 70.3 (2014): 406-427.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Recreating simplex tree from figure. 
st &lt;- simplex_tree()
st %&gt;% insert(list(1:3, 2:5, c(6, 7, 9), 7:8, 10))
plot(st)

## Example insertion
st &lt;- simplex_tree(list(1:3, 4:5, 6)) ## Inserts one 2-simplex, one 1-simplex, and one 0-simplex
print(st) 
# Simplex Tree with (6, 4, 1) (0, 1, 2)-simplices

## More detailed look at structure
print_simplices(st, "tree")
# 1 (h = 2): .( 2 3 )..( 3 )
# 2 (h = 1): .( 3 )
# 3 (h = 0): 
# 4 (h = 1): .( 5 )
# 5 (h = 0): 
# 6 (h = 0): 
## Print the set of simplices making up the star of the simplex '2'
print_simplices(st %&gt;% cofaces(2))
# 2, 2 3, 1 2, 1 2 3

## Retrieves list of all simplices in DFS order, starting with the empty face 
dfs_list &lt;- ltraverse(st %&gt;% preorder(empty_face), identity)

## Get connected components 
print(st$connected_components)
# [1] 1 1 1 4 4 5

## Use clone() to make copies of the complex (don't use the assignment `&lt;-`)
new_st &lt;- st %&gt;% clone()

## Other more internal methods available via `$` 
list_of_simplices &lt;- st$as_list()
adj_matrix &lt;- st$as_adjacency_matrix()
# ... see also as_adjacency_list(), as_edge_list(), etc 
</code></pre>

<hr>
<h2 id='sub_to_nat'>sub_to_nat</h2><span id='topic+sub_to_nat'></span>

<h3>Description</h3>

<p>Given a combination <code>x</code>, computes its position out of all lexicographically-ordered (<code>n</code> choose <code>2</code>) combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_to_nat(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sub_to_nat_+3A_x">x</code></td>
<td>
<p>matrix whose columns represent <code>k</code>-combinations.</p>
</td></tr>
<tr><td><code id="sub_to_nat_+3A_n">n</code></td>
<td>
<p>numerator of the binomial coefficient</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mapping is done via an lexicographically-ordered combinadic mapping.
</p>


<h3>Value</h3>

<p>integer vector of the positions of the given combinations.
</p>


<h3>References</h3>

<p>McCaffrey, J. D. &quot;Generating the mth lexicographical element of a mathematical combination.&quot; MSDN Library (2004).
</p>

<hr>
<h2 id='threshold'>threshold</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>Thresholds a given filtered simplicial complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(st, index = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold_+3A_st">st</code></td>
<td>
<p>simplex tree.</p>
</td></tr>
<tr><td><code id="threshold_+3A_index">index</code></td>
<td>
<p>integer index to threshold to.</p>
</td></tr>
<tr><td><code id="threshold_+3A_value">value</code></td>
<td>
<p>numeric index to threshold filtration.</p>
</td></tr>
</table>

<hr>
<h2 id='traverse'>traverse</h2><span id='topic+traverse'></span><span id='topic+straverse'></span><span id='topic+ltraverse'></span>

<h3>Description</h3>

<p>Traverses specific subsets of a simplicial complex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traverse(traversal, f, ...)

straverse(traversal, f, ...)

ltraverse(traversal, f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traverse_+3A_traversal">traversal</code></td>
<td>
<p>the type of traversal.</p>
</td></tr>
<tr><td><code id="traverse_+3A_f">f</code></td>
<td>
<p>the function to apply to each simplex.</p>
</td></tr>
<tr><td><code id="traverse_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+traverse">traverse</a></code> allows for traversing ordered subsets of the simplex tree. 
The specific subset and order are determined by the choice of <em>traversal</em>: examples include 
the <code><a href="#topic+preorder">preorder</a></code> traversal, the <code><a href="#topic+cofaces">cofaces</a></code> traversal, etc. See the links below. 
Each simplex in the traversal is passed as the first and only argument to <code>f</code>, one per simplex in the traversal.
<code><a href="#topic+traverse">traverse</a></code> does nothing with the result; if you want to collect the results of applying <code>f</code> to each simplex 
into a list, use <code><a href="#topic+ltraverse">ltraverse</a></code> (or <code><a href="#topic+straverse">straverse</a></code>), which are meant to be used like <code><a href="base.html#topic+lapply">lapply</a></code> 
and <code><a href="base.html#topic+sapply">sapply</a></code>, respectively.
</p>


<h3>Value</h3>

<p>NULL; for list or vector-valued returns, use <code>ltraverse</code> and <code>straverse</code> respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Starter example complex 
st &lt;- simplex_tree()
st %&gt;% insert(list(1:3, 2:5))

## Print out complex using depth-first traversal. 
st %&gt;% preorder() %&gt;% traverse(print)

## Collect the last labels of each simplex in the tree. 
last_labels &lt;- st %&gt;% preorder() %&gt;% straverse(function(simplex){ tail(simplex, 1) })
</code></pre>

<hr>
<h2 id='union_find'>UnionFind</h2><span id='topic+union_find'></span>

<h3>Description</h3>

<p>Union find structure exposed as an Rcpp Module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>union_find(n = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="union_find_+3A_n">n</code></td>
<td>
<p>Number of elements in the set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A disjoint set, as a <code>Rcpp_UnionFind</code> object (Rcpp module).
</p>


<h3>Methods</h3>


<dl>
<dt>$<code>print.simplextree</code></dt><dd><p> S3 method to print a basic summary of the simplex tree. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Matt Piekenbrock
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
