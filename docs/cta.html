<!DOCTYPE html><html lang="en"><head><title>Help for package cta</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cta}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cta-package'>
<p>cta: Contingency Table Analysis Based on ML Fitting of MPH Models</p></a></li>
<li><a href='#block.fct'>
<p>Matrix Direct Sum</p></a></li>
<li><a href='#check.HLP'>
<p>HLP Link Status Check</p></a></li>
<li><a href='#check.homog'>
<p><code class="reqn">Z</code> Homogeneity Check</p></a></li>
<li><a href='#check.zero.order.homog'>
<p>Zero-Order <code class="reqn">Z</code> Homogeneity Check</p></a></li>
<li><a href='#ci.table'><p>Test-Inversion CIs for Estimands in Contingency Tables</p></a></li>
<li><a href='#compute_cons_MLE_ase'>
<p>Constrained MLE and ASE</p></a></li>
<li><a href='#create.U'>
<p>Orthogonal Complement of the Column Space of a Matrix</p></a></li>
<li><a href='#create.Z.ZF'>
<p>Population Matrix and Sampling Constraint Matrix</p></a></li>
<li><a href='#diff_Gsq_nr'>
<p>Difference in <code class="reqn">G</code>-Squared Statistic Based CIs (Non-Robust)</p></a></li>
<li><a href='#diff_Gsq_robust'>
<p>Difference in <code class="reqn">G</code>-Squared Statistic Based CIs (Robust)</p></a></li>
<li><a href='#diff_PD_nr'>
<p>Difference in Power-Divergence Statistic Based CIs (Non-Robust)</p></a></li>
<li><a href='#diff_PD_robust'>
<p>Difference in Power-Divergence Statistic Based CIs (Robust)</p></a></li>
<li><a href='#diff_Xsq_nr'>
<p>Difference in <code class="reqn">X</code>-Squared Statistic Based CIs (Non-Robust)</p></a></li>
<li><a href='#diff_Xsq_robust'>
<p>Difference in <code class="reqn">X</code>-Squared Statistic Based CIs (Robust)</p></a></li>
<li><a href='#f.psi'>
<p>Model Comparison Statistics</p></a></li>
<li><a href='#M.fct'>
<p>Marginalizing Matrix Based on Strata Information</p></a></li>
<li><a href='#mph.fit'>
<p>Fitting MPH and HLP Models</p></a></li>
<li><a href='#mph.summary'>
<p>Summary Statistics of the Fitted MPH Model</p></a></li>
<li><a href='#nested_Gsq_nr'>
<p>Nested <code class="reqn">G</code>-Squared Statistic Based CIs (Non-Robust)</p></a></li>
<li><a href='#nested_Gsq_robust'>
<p>Nested <code class="reqn">G</code>-Squared Statistic Based CIs (Robust)</p></a></li>
<li><a href='#nested_PD_nr'>
<p>Nested Power-Divergence Statistic Based CIs (Non-Robust)</p></a></li>
<li><a href='#nested_PD_robust'>
<p>Nested Power-Divergence Statistic Based CIs (Robust)</p></a></li>
<li><a href='#nested_Xsq_nr'>
<p>Nested <code class="reqn">X</code>-Squared Statistic Based CIs (Non-Robust)</p></a></li>
<li><a href='#nested_Xsq_robust'>
<p>Nested <code class="reqn">X</code>-Squared Statistic Based CIs (Robust)</p></a></li>
<li><a href='#num.deriv.fct'>
<p>Numerical Derivatives Based on Central Difference Formula</p></a></li>
<li><a href='#quadratic.fit'>
<p>Quadratic Fit</p></a></li>
<li><a href='#solve_quadratic'>
<p>Solve for Real Root(s) to the Quadratic Equation</p></a></li>
<li><a href='#Wald_trans.Wald_nr'>
<p>Wald-Type CIs (Non-Robust)</p></a></li>
<li><a href='#Wald_trans.Wald_robust'>
<p>Wald-Type CIs (Robust)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Contingency Table Analysis Based on ML Fitting of MPH Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-8-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph B. Lang [aut],
  Qiansheng Zhu [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qiansheng Zhu &lt;qiansheng-zhu@uiowa.edu&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>intervals, numDeriv, limSolve, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>vcd, MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Contingency table analysis is performed based on maximum likelihood (ML) fitting of 
             multinomial-Poisson homogeneous (MPH) and homogeneous linear predictor (HLP) models. 
             See Lang (2004) &lt;<a href="https://doi.org/10.1214%2Faos%2F1079120140">doi:10.1214/aos/1079120140</a>&gt; and Lang (2005) &lt;<a href="https://doi.org/10.1198%2F016214504000001042">doi:10.1198/016214504000001042</a>&gt; 
             for MPH and HLP models. Objects computed include model goodness-of-fit statistics; likelihood-
             based (cell- and link-specific) residuals; and cell probability and expected count estimates along 
             with standard errors. This package can also compute test-inversion&ndash;e.g. Wald, profile likelihood, 
             score, power-divergence&ndash;confidence intervals for contingency table estimands, when table 
             probabilities are potentially subject to equality constraints. For test-inversion intervals, see 
             Lang (2008) &lt;<a href="https://doi.org/10.1002%2Fsim.3391">doi:10.1002/sim.3391</a>&gt; and Zhu (2020) &lt;<a href="https://doi.org/10.17077%2Fetd.005331">doi:10.17077/etd.005331</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-22 01:16:52 UTC; QianshengZhu</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-23 18:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='cta-package'>
cta: Contingency Table Analysis Based on ML Fitting of MPH Models
</h2><span id='topic+cta-package'></span>

<h3>Description</h3>

<p>Contingency table analysis is performed based on maximum likelihood (ML) fitting of multinomial-Poisson homogeneous (MPH) models (Lang, 2004) and homogeneous linear predictor (HLP) models (Lang, 2005). Objects computed include model goodness-of-fit statistics; likelihood-based (cell- and link-specific) residuals; and cell probability and expected count estimates along with standard errors. This package can also compute test-inversion&ndash;e.g. Wald, profile likelihood, score, power-divergence&ndash;confidence intervals for contingency table estimands, when table probabilities are potentially subject to equality constraints. See Lang (2008) and Zhu (2020) for test-inversion intervals.
</p>


<h3>Details</h3>

<p>Please call the following two <span class="rlang"><b>R</b></span> functions in this <span class="pkg">cta</span> package.
</p>
<p><code><a href="#topic+mph.fit">mph.fit</a></code>: Computes maximum likelihood estimates and fit statistics for MPH and HLP models for contingency tables.
</p>
<p><code><a href="#topic+ci.table">ci.table</a></code>: Constructs test-inversion approximate confidence intervals for estimands in contingency tables with or without equality constraints.
</p>


<h3>Author(s)</h3>

<p>Joseph B. Lang, Qiansheng Zhu</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>
<p>Lang, J. B. (2005) Homogeneous linear predictor models for contingency tables, <em>Journal of the American Statistical Association</em>, <b>100</b>, 121&ndash;134.
</p>
<p>Lang, J. B. (2008) Score and profile likelihood confidence intervals for contingency table parameters, <em>Statistics in Medicine</em>, <b>27</b>, 5975&ndash;5990.
</p>
<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>

<hr>
<h2 id='block.fct'>
Matrix Direct Sum
</h2><span id='topic+block.fct'></span>

<h3>Description</h3>

<p>Matrix direct sum function. Creates a block diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block.fct(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block.fct_+3A_...">...</code></td>
<td>
<p><span class="rlang"><b>R</b></span> matrices (matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>block.fct</code> returns a block diagonal matrix, where the direct sum is
in the order of the input matrices (matrix).
</p>


<h3>Author(s)</h3>

<p>Joseph B. Lang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, 2, 3, 4), nrow = 2, byrow = TRUE)
B &lt;- matrix(c(5, 6, 7, 8, 9, 10), nrow = 2, byrow = TRUE)
C &lt;- matrix(c(11, 12, 13, 14), nrow = 1, byrow = TRUE)
block.fct(A, B, C)
</code></pre>

<hr>
<h2 id='check.HLP'>
HLP Link Status Check
</h2><span id='topic+check.HLP'></span>

<h3>Description</h3>

<p>Checks whether the link function <code class="reqn">L(\cdot)</code> is a candidate HLP link
function.
</p>
<p>Specifically, this program checks whether <code class="reqn">L(\cdot)</code> satisfies
certain necessary conditions that follow from a sufficient condition for HLP
link status.
</p>
<p>If the necessary conditions are satisfied then there is corroborating evidence
that <code class="reqn">L(\cdot)</code> has HLP link status. If the necessary conditions are not satisfied,
then the sufficient condition for HLP link status is not satisfied, so <code class="reqn">L(\cdot)</code>
may or may not have HLP link status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.HLP(L.fct, Z, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.HLP_+3A_l.fct">L.fct</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> function object, indicating the link <code class="reqn">L(\cdot)</code> for HLP
link status check.</p>
</td></tr>
<tr><td><code id="check.HLP_+3A_z">Z</code></td>
<td>
<p>Population (aka strata) matrix <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="check.HLP_+3A_tol">tol</code></td>
<td>
<p>The pre-set tolerance with which <code>norm(diff)</code> is to be compared
with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea:
</p>
<p>The model <code class="reqn">L(m) = X\beta</code> is an HLP model if <code class="reqn">L(\cdot)</code> is a smooth link function that satisfies the HLP conditions with respect to <code class="reqn">Z</code> (i.e. strata <code class="reqn">s</code>) and <code class="reqn">X</code>. That is,
</p>

<ul>
<li><p> (1) <code class="reqn">L(\cdot)</code> has HLP link status with respect to <code class="reqn">Z</code>,   and
</p>
</li>
<li><p> (2) The implied constraint function <code class="reqn">h(m) = U'L(m)</code> is <code class="reqn">Z</code> homogeneous.
Here, <code class="reqn">null(U') = span(X)</code>.
</p>
</li></ul>

<p>Here, (1) <code class="reqn">L(\cdot)</code> has HLP link status with respect to <code class="reqn">Z</code> if, for <code class="reqn">m = Diag(Z\gamma)p</code>, equivalently, for <code class="reqn">\gamma = Z'm</code> and <code class="reqn">p = Diag^{-1}(ZZ'm)m</code>,
</p>

<ul>
<li><p> (1)(a) <code class="reqn">L(m) = a(\gamma) + L(p)</code>, where <code class="reqn">a(\gamma_{1}/\gamma_{2}) - a(1) = a(\gamma_{1}) - a(\gamma_{2})</code>,
i.e. <code class="reqn">a(\gamma)</code> has the form <code class="reqn">C \log\gamma + \texttt{constant}</code>;
or
</p>
</li>
<li><p> (1)(b) <code class="reqn">L(m) = G(\gamma) L(p)</code>, where <code class="reqn">G(\gamma)</code> is a diagonal matrix with
diagonal elements that are powers of the <code class="reqn">\gamma</code> elements, i.e. <code class="reqn">L(\cdot)</code>
is <code class="reqn">Z</code> homogeneous (see Lang (2004));
or
</p>
</li>
<li><p> (1)(c) The components of <code class="reqn">L(\cdot)</code> are a mixture of types (a) and (b):
<code class="reqn">L_{j}(m) = a_{j}(\gamma) + L_{j}(p)</code> or  <code class="reqn">L_{j}(m) = G_{j}(\gamma) L_{j}(p)</code>,
<code class="reqn">j = 1, \ldots, l</code>.
</p>
</li></ul>

<p>N.B. Lang (2005) defined HLP models as those satisfying (1)(a) and (2). <code>mph.fit</code> uses a broader definition of HLP model. Specifically, models
satisfying (1)(b) and (2) or (1)(c) and (2) are also considered HLP models.
</p>
<p>Conditions (1)(b) and (2) can be checked using the <code>check.homog</code> function.
Condition (1)(c) is not checked.
</p>
<p>This function, <code>check.HLP</code>, is concerned with sufficient condition (1)(a) only. If <code class="reqn">L(\cdot)</code> satisfies (1)(a)  then
</p>

<ul>
<li><p> (i) <code class="reqn">\texttt{diff1} = [L(Diag(Z\gamma_{1})p_{1}) - L(Diag(Z\gamma_{2})p_{1})] - [L(Diag(Z \gamma_{1}/\gamma_{2})p_{1}) - L(p_{1})] = 0</code>, and
</p>
</li>
<li><p> (ii) <code class="reqn">\texttt{diff2} = [L(Diag(Z\gamma_{1})p_{1}) - L(Diag(Z\gamma_{1})p_{2})] - [L(p_{1}) - L(p_{2})] = 0</code>.
</p>
</li></ul>

<p>Here <code class="reqn">p_{i} = Diag^{-1}(ZZ'm_{i})m_{i}</code>, where <code class="reqn">m_{i} = Diag(Z\gamma_{i})p_{i}</code>, <code class="reqn">i = 1, 2</code>.
</p>
<p>This program randomly generates <code>g1</code> (<code class="reqn">\gamma_{1}</code>), <code>g2</code> (<code class="reqn">\gamma_{2}</code>), <code>p1</code>, <code>p2</code>, and
computes <code>norm(diff) = sqrt(norm(diff1)^2 + norm(diff2)^2)</code>. It returns a warning if <code>norm(diff)</code> is too far from <code class="reqn">0</code>.
</p>


<h3>Value</h3>

<p><code>check.HLP</code> returns a character string <code>chk</code>. If <code>chk = ""</code>, then
there is corroborating evidence that <code class="reqn">L(\cdot)</code> has HLP link status. If
<code>chk = paste("L(m) may not be an HLP link [based on tol=",tol,"]!")</code>, then the sufficient condition for HLP link status is not satisfied, so <code class="reqn">L(\cdot)</code> may or
may not have HLP link status.
</p>


<h3>Author(s)</h3>

<p>Joseph B. Lang
</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>
<p>Lang, J. B. (2005) Homogeneous linear predictor models for contingency tables, <em>Journal of the American Statistical Association</em>, <b>100</b>, 121&ndash;134.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mph.fit">mph.fit</a></code>, <code><a href="#topic+check.homog">check.homog</a></code>, <code><a href="#topic+check.zero.order.homog">check.zero.order.homog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 3-by-3-by-3 Table.
# For a description of the model, see Michael Haber's Example 2,
# p. 433, in  Biometrics (in Shorter Communications), Vol. 42,
# No. 2. (Jun., 1986), pp. 429-435.
A &lt;- gl(3, 9, 27)
B &lt;- gl(3, 3, 27)
C &lt;- gl(3, 1, 27)
MAB &lt;- kronecker(diag(9), matrix(1, 1, 3))
MAC &lt;- kronecker(diag(3), kronecker(matrix(1, 1, 3), diag(3)))
MBC &lt;- kronecker(matrix(1, 1, 3), diag(9))
M &lt;- rbind(MAB, MAC, MBC)
Mr &lt;- M[-c(3, 6, 7, 8, 9, 12, 15, 16, 17, 18, 21, 24,
           25, 26, 27), ]
C &lt;- c(1, -1, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 1, -1, -1, 1, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 1, -1, -1, 1)
C &lt;- matrix(C, 3, 12, byrow = TRUE)
L.fct &lt;- function(m) {
  p &lt;- m / sum(m)
  C %*% log(Mr %*% p)
}
Z &lt;- matrix(rep(1, 27), ncol = 1)
check.HLP(L.fct, Z)
</code></pre>

<hr>
<h2 id='check.homog'>
<code class="reqn">Z</code> Homogeneity Check
</h2><span id='topic+check.homog'></span>

<h3>Description</h3>

<p>Checks whether the constraint function <code class="reqn">h(\cdot)</code> satisfies
a necessary condition for <code class="reqn">Z</code> homogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.homog(h.fct, Z, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.homog_+3A_h.fct">h.fct</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> function object, indicating the constraint function
<code class="reqn">h(\cdot)</code> for <code class="reqn">Z</code> homogeneity check.</p>
</td></tr>
<tr><td><code id="check.homog_+3A_z">Z</code></td>
<td>
<p>Population (aka strata) matrix <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="check.homog_+3A_tol">tol</code></td>
<td>
<p>The pre-set tolerance with which <code>norm(diff)</code> is to be compared
with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea:
</p>
<p><code class="reqn">h(\cdot)</code> is <code class="reqn">Z</code> homogeneous if <code class="reqn">h(Diag(Z\gamma)x) = G(\gamma)h(x)</code>, where
<code class="reqn">G</code> is a diagonal matrix with <code class="reqn">\gamma</code> elements raised to some power.
</p>
<p>As a check,  if <code class="reqn">h(\cdot)</code> is homogeneous then
</p>
<p style="text-align: center;"><code class="reqn">h(Diag(Z\gamma) x_{1}) / h(Diag(Z\gamma) x_{2}) = h(x_{1}) / h(x_{2});</code>
</p>

<p>That is, </p>
<p style="text-align: center;"><code class="reqn">\texttt{diff} = h(Diag(Z\gamma) x_{1}) h(x_{2}) - h(Diag(Z\gamma) x_{2}) h(x_{1}) = 0.</code>
</p>
<p> Here, the division and multiplication are taken element-wise.
</p>
<p>This program randomly generates <code>gamma</code>, <code>x1</code>, and <code>x2</code>, and
computes <code>norm(diff)</code>. It returns a warning if <code>norm(diff)</code> is
too far from <code class="reqn">0</code>.
</p>


<h3>Value</h3>

<p><code>check.homog</code> returns a character string <code>chk</code> that states whether
<code class="reqn">h(\cdot)</code> is <code class="reqn">Z</code> homogeneous. If <code>chk = ""</code>, it means that based on the necessary condition, we cannot state that <code class="reqn">h(\cdot)</code> is not <code class="reqn">Z</code> homogeneous.
</p>


<h3>Author(s)</h3>

<p>Joseph B. Lang
</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.zero.order.homog">check.zero.order.homog</a></code>, <code><a href="#topic+mph.fit">mph.fit</a></code>, <code><a href="#topic+check.HLP">check.HLP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1
h.fct &lt;- function(m) {m[1] - m[2]}
Z &lt;- matrix(c(1, 1), nrow = 2)
check.homog(h.fct, Z)

# EXAMPLE 2
h.fct.2 &lt;- function(m) {m[1]^2 - m[2]}
Z &lt;- matrix(c(1, 1), nrow = 2)
check.homog(h.fct.2, Z)
</code></pre>

<hr>
<h2 id='check.zero.order.homog'>
Zero-Order <code class="reqn">Z</code> Homogeneity Check
</h2><span id='topic+check.zero.order.homog'></span>

<h3>Description</h3>

<p>Checks whether the estimand function <code class="reqn">S(\cdot)</code> is zero-order <code class="reqn">Z</code> homogeneous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.zero.order.homog(S.fct, Z, tol = 1e-9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.zero.order.homog_+3A_s.fct">S.fct</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> function object, indicating the estimand function
<code class="reqn">S(\cdot)</code> for zero-order <code class="reqn">Z</code> homogeneity check.</p>
</td></tr>
<tr><td><code id="check.zero.order.homog_+3A_z">Z</code></td>
<td>
<p>Population (aka strata) matrix <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="check.zero.order.homog_+3A_tol">tol</code></td>
<td>
<p>The pre-set tolerance with which <code>norm(diff.LRHS)</code> is
to be compared with.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea:
</p>
<p><code class="reqn">S(\cdot)</code> is zero-order <code class="reqn">Z</code> homogeneous if <code class="reqn">S(Diag(Z\gamma) x) = S(x)</code>, for all <code class="reqn">\gamma &gt; 0</code>, and for all <code class="reqn">x</code> within its domain. This program randomly generates <code>gam</code> (<code class="reqn">\gamma</code>) and <code>x</code> (<code class="reqn">x</code>), and computes </p>
<p style="text-align: center;"><code class="reqn">\texttt{diff.LRHS} = S(Diag(Z\gamma) x) - S(x).</code>
</p>
<p> It returns a warning if <code>norm(diff.LRHS)</code> is too far from <code class="reqn">0</code>.
</p>


<h3>Value</h3>

<p><code>check.zero.order.homog</code> returns a character string <code>check.result</code> that states whether <code class="reqn">S(\cdot)</code> is zero-order <code class="reqn">Z</code> homogeneous. If <code>check.result = ""</code>, it means that we cannot state that <code class="reqn">S(\cdot)</code> is not zero-order <code class="reqn">Z</code> homogeneous based on the result of the check.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check.homog">check.homog</a></code>, <code><a href="#topic+check.HLP">check.HLP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># EXAMPLE 1
S.fct &lt;- function(m) {(m[1] - m[2]) / (m[1] + m[2])}
Z &lt;- matrix(c(1, 1, 1, 1), nrow = 4)
check.zero.order.homog(S.fct, Z)

# EXAMPLE 2
S.fct.2 &lt;- function(m) {m[1] - m[2]}
Z &lt;- matrix(c(1, 1, 1, 1), nrow = 4)
check.zero.order.homog(S.fct.2, Z)
</code></pre>

<hr>
<h2 id='ci.table'>Test-Inversion CIs for Estimands in Contingency Tables</h2><span id='topic+ci.table'></span>

<h3>Description</h3>

<p>Constructs test-inversion approximate confidence intervals (CIs) for
estimands in contingency tables subject to equality constraints.
Test statistics include Wald-type statistics, and difference and
nested versions of power-divergence statistics. This program can also compute
test-inversion approximate confidence intervals for estimands in
contingency tables without additionally imposed equality constraints,
by setting the constraint function <code>h.fct = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.table(y, h.fct = 0, h.mean = FALSE, S.fct, S.mean = FALSE, S.P = FALSE,
         S.space.H0 = NULL, method = "all", cc = 0.95, pdlambda = 2/3,
         trans.g = NULL, trans.g.epsilon = 0, trans.g.inv = NULL,
         strata = rep(1, length(y)), fixed.strata = "all", delta = 0.5,
         max.iter = 50, tol = 1e-2, tol.psi = 1e-4, adj.epsilon = 0.03,
         iter.robust.max = 30, iter.robust.eff = 10, check.homog.tol = 1e-9,
         check.zero.order.homog.tol = 1e-9, max.mph.iter = 1000, step = 1,
         change.step.after = 0.25 * max.mph.iter, y.eps = 0, iter.orig = 5,
         norm.diff.conv = 1e-6, norm.score.conv = 1e-6,
         max.score.diff.iter = 10, h0.fct.deriv = NULL,
         S0.fct.deriv = NULL, trans.g.deriv = NULL, plot.CIs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci.table_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_h.fct">h.fct</code></td>
<td>
<p>The imposed equality constraint(s). Note that sampling constraints are not included in <code>h.fct</code>, and the imposed equality constraints should be non-redundant.
</p>
<p>If <code>h.mean = FALSE</code> (default), <code class="reqn">h(p)</code> should be the input, where <code class="reqn">p</code> is the vector of data model probabilities, or it can be called the vector of table probabilities; If <code>h.mean = TRUE</code>, <code class="reqn">h(m)</code> should be the input, where <code class="reqn">m</code> is the vector of expected table counts, i.e. <code class="reqn">m = E(Y)</code>. In the case of <code class="reqn">h(m)</code> being the input, the function <code class="reqn">h(\cdot)</code> should be <code class="reqn">Z</code> homogeneous, where <code class="reqn">Z</code> is the population matrix. For the definition of <code class="reqn">Z</code> homogeneity and the population matrix, see Lang (2004). Note that if there is no imposed equality constraint, we should input <code>h.fct = 0</code> (real number <code>0</code>). Please do not specify <code>h.fct</code> as a zero function in this case. On the contrary, if there is (are) imposed equality constraint(s), please specify <code>h.fct</code> as an <span class="rlang"><b>R</b></span> function. Another important note is that if there are multiple imposed equality constraints, please use <code>rbind()</code>, not <code>c()</code>, to concatenate the imposed equality constraints into a column vector.
</p>
<p>By default, <code>h.fct = 0</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_h.mean">h.mean</code></td>
<td>
<p>Logical argument, <code>TRUE</code> or <code>FALSE</code>. If <code>h.mean = FALSE</code> (default), the input <code>h.fct</code> is treated as a function of <code class="reqn">p</code>; If <code>h.mean = TRUE</code>, the input <code>h.fct</code> is treated as a function of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_s.fct">S.fct</code></td>
<td>
<p>Parameter or estimand of interest. It should be an <span class="rlang"><b>R</b></span> function, which returns a real number. i.e. <code class="reqn">S(\cdot)</code> is a real-valued function. If <code>S.mean = FALSE</code> and <code>S.P = FALSE</code> (default), <code class="reqn">S(p)</code> should be the input; If <code>S.mean = TRUE</code>, <code class="reqn">S(m)</code> should be the input; If <code>S.P = TRUE</code>, <code class="reqn">S(P)</code> should be the input, where <code class="reqn">P</code> is the vector of joint probabilities, or it can be called the vector of pre-data probabilities. In the case of <code class="reqn">S(m)</code> or <code class="reqn">S(P)</code> being the input, the function <code class="reqn">S(\cdot)</code> should be zero-order <code class="reqn">Z</code> homogeneous, then <code class="reqn">S(P)</code> is <code class="reqn">Z</code> estimable with <code class="reqn">S(P) = S(m)</code>. In addition, when we are in the process of computing test-inversion confidence intervals other than Wald intervals, we have to fit several models and obtain constrained MLEs of expected table counts. These models have equality constraints <code class="reqn">h_{0}^{*}(m) = 0</code>, where <code class="reqn">h_{0}^{*}(m) = (h_{0}'(m), S_{0}(m) - \psi, samp_{0}'(m))'</code>. Here <code class="reqn">h_{0}(m) = 0</code> is (are) the imposed equality constraint(s), written in terms of <code class="reqn">m</code>; <code class="reqn">S_{0}(m) - \psi = 0</code> means that the estimand of interest is equal to <code class="reqn">\psi</code>; <code class="reqn">samp_{0}(m) = 0</code> is (are) the sampling constraint(s), written in terms of <code class="reqn">m</code>. Restriction of <code class="reqn">S(m)</code> [or <code class="reqn">S(P)</code>] to zero-order <code class="reqn">Z</code> homogeneity guarantees the <code class="reqn">Z</code> homogeneity of <code class="reqn">h_{0}^{*}(m)</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_s.mean">S.mean</code>, <code id="ci.table_+3A_s.p">S.P</code></td>
<td>
<p>Logical argument, <code>TRUE</code> or <code>FALSE</code>. If <code>S.mean = FALSE</code> and <code>S.P = FALSE</code> (default), the input <code>S.fct</code> is treated as a function of <code class="reqn">p</code>; If <code>S.mean = TRUE</code>, the input <code>S.fct</code> is treated as a function of <code class="reqn">m</code>; If <code>S.P = TRUE</code>, the input <code>S.fct</code> is treated as a function of <code class="reqn">P</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e. subject to the imposed equality constraints along with sampling constraints. If <code>S.space.H0</code> is not specified or the input <code>S.space.H0 = NULL</code>, the restricted estimand space is treated as <code class="reqn">(-\infty, \infty)</code>, i.e. the whole real number line. If <code>S.space.H0</code> is specified, it can either be input as a vector of length of an even number, or be input in class <code>Intervals_full {intervals}</code>. As an example, if the restricted estimand space is <code class="reqn">(-\infty, -1] \cup [1, \infty)</code>, then the input <code>S.space.H0</code> could be <code>c(-Inf, -1, 1, Inf)</code>, or
<code>Intervals_full(matrix(c(-Inf, -1, 1, Inf), ncol = 2, byrow = TRUE), closed = matrix(c(FALSE, TRUE, TRUE, FALSE), ncol = 2, byrow = TRUE), type = "R")</code>. It is strongly recommended that <code>S.space.H0</code> be specified, as it will improve the accuracy and (possibly) speed in interval estimation. However, it is often difficult to have an idea of the restricted estimand space exactly. In this scenario, specification of one (or several) possibly larger interval(s) that cover(s) the exact restricted estimand space is also helpful.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_method">method</code></td>
<td>
<p>The test statistic(s) in constructing the test-inversion approximate confidence interval(s). There are eight different test statistics, and the user is allowed to choose any number of the test statistics out of the eight. The eight test statistics are listed as follows: <code>"Wald"</code>, <code>"trans.Wald"</code> (need specification of the transformation <code class="reqn">g</code>), <code>"diff.Xsq"</code>, <code>"nested.Xsq"</code>, <code>"diff.Gsq"</code> (same as <code>"PL"</code> or <code>"LR"</code>), <code>"nested.Gsq"</code>, <code>"diff.PD"</code>, <code>"nested.PD"</code> (need specification of the power-divergence index parameter <code class="reqn">\lambda</code>). If the input <code>method = "all"</code> (default), all test statistics will be employed to compute confidence intervals.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_cc">cc</code></td>
<td>
<p>Confidence coefficient, or the nominal level of the confidence interval.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_pdlambda">pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_trans.g">trans.g</code></td>
<td>
<p>The transformation <code class="reqn">g</code> used in the transformed Wald confidence interval. First, we construct a confidence interval for <code class="reqn">g(S(\cdot))</code>, then we back-transform, i.e. apply <code class="reqn">g^{-1}</code> to the endpoints in order to obtain a confidence interval for <code class="reqn">S(\cdot)</code>. There are several built-in options for the transformation: <code>"Fisher's z"</code>, <code>"log"</code>, <code>"-log"</code> (same as <code>"negative log"</code>), and <code>"[A, B]"</code>. <code>"[A, B]"</code> refers to the reparameterization trick as stated in the Discussion part of Lang (2008). The user is also allowed to input their own choice of <code>trans.g</code>. Ordinarily, the transformation <code class="reqn">g</code> should be a bijection. Ideally, <code class="reqn">g</code> should be smooth, strictly monotonically increasing, and &quot;to parameterize away the boundary&quot; (Lang, 2008).</p>
</td></tr>
<tr><td><code id="ci.table_+3A_trans.g.epsilon">trans.g.epsilon</code></td>
<td>
<p>The small <code class="reqn">\epsilon</code> adjustment included in the transformation <code class="reqn">g</code>. For example, the <code>"[A, B]"</code> transformation <code class="reqn">g</code> with the small <code class="reqn">\epsilon</code> is </p>
<p style="text-align: center;"><code class="reqn">g(x) = \log(x - A + \epsilon) - \log(B + \epsilon - x).</code>
</p>

<p>By default, <code>trans.g.epsilon = 0</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_trans.g.inv">trans.g.inv</code></td>
<td>
<p><code class="reqn">g^{-1}</code> function used in back-transformation step in construction of the transformed Wald confidence interval. If <code>trans.g</code> is any one of the built-in options, then <code>trans.g.inv</code> is automatically specified accordingly.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership identifier. By default, <code>strata = rep(1, length(y))</code> refers to the single stratum (non-stratified) setting. As another example, <code>strata = c(1,1,2,2)</code> means that the first and second table cells belong to the first stratum, and the third and fourth table cells belong to the second stratum.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has (have) fixed sample sizes. It can equal one of the keywords, <code>fixed.strata = "all"</code> or <code>fixed.strata = "none"</code>, or it can be a vector of stratum membership identifiers, e.g. <code>fixed.strata = c(1,3)</code> or <code>fixed.strata = c("pop1", "pop5")</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical values within each sliding quadratic step. By default, <code>delta = 0.5</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_max.iter">max.iter</code></td>
<td>
<p>One of the stopping criteria. It is the maximum number of iterations in the sliding quadratic root-finding algorithm for searching the two roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_tol">tol</code></td>
<td>
<p>One of the stopping criteria. In solving for the roots to the test-inversion equation, if the test statistic for testing <code class="reqn">H_{0}(\psi): S_{0}(m) = \psi</code> vs. not <code class="reqn">H_{0}(\psi)</code> under the general hypothesis <code class="reqn">H_{0}: (h_{0}'(m), samp_{0}'(m))' = 0</code>, for a certain <code class="reqn">\psi</code>, is within <code>tol</code> of the critical value, then we stop the iterations, and this current <code class="reqn">\psi</code> is treated as one root. Note that since we are constructing approximate (contrary to exact) confidence intervals based on the asymptotic distribution under the null hypothesis, <code>tol</code> need not be too small.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_tol.psi">tol.psi</code></td>
<td>
<p>One of the stopping criteria. In solving for the roots to the test-inversion equation, if the two <code class="reqn">\psi</code>'s that are in nearby iterates in the corresponding tests <code class="reqn">H_{0}(\psi)</code> vs. not <code class="reqn">H_{0}(\psi)</code> under the general hypothesis <code class="reqn">H_{0}</code>, are less than <code>tol.psi</code> apart in distance, then we stop the iterations, and the current <code class="reqn">\psi</code> is treated as one root. Note that we should specify <code>tol.psi</code> to be sufficiently small (compared with the size of the restricted estimand space) so that the iterations are to be terminated mainly because of closeness of the test statistic to the critical value.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_adj.epsilon">adj.epsilon</code>, <code id="ci.table_+3A_iter.robust.max">iter.robust.max</code>, <code id="ci.table_+3A_iter.robust.eff">iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure. First, we attempt to construct confidence intervals based on the original data <code>y</code>, but an error might occur during this process. The reason for occurrence of the error might be the non-existence of the constrained MLE subject to <code class="reqn">H_{0}</code>, or it might be because of the fact that the <code class="reqn">\psi</code> in the hypothesis test <code class="reqn">H_{0}(\psi)</code> vs. not <code class="reqn">H_{0}(\psi)</code> is, on some scale, too far away from <code class="reqn">\widehat{\psi}</code> which is the constrained MLE of the estimand subject to <code class="reqn">H_{0}</code>, although this <code class="reqn">\psi</code> is still within the restricted estimand space. If an error, or non-convergence issue occurs, then the program will go through the robustifying procedure, with the goal of reporting a confidence interval anyway, even in the most extreme configuration and/or with the most &quot;extreme&quot; data.
</p>
<p>In the robustifying procedure, we adjust the original data <code>y</code> by adding <code>1 * adj.epsilon</code> to each original table count, and compute the confidence interval based on the adjusted data <code>y + 1 * adj.epsilon</code>. Note, however, that even the adjusted data may lead to non-convergence issue sometimes. We also adjust the original data by adding <code>2 * adj.epsilon</code>, <code class="reqn">\ldots</code>, <code>iter.robust.max * adj.epsilon</code>, and compute confidence intervals based on these adjusted data, respectively. For computing purposes, as soon as <code>iter.robust.eff</code> confidence intervals based on the adjusted data have been successfully computed, we will not proceed further into adjustment and interval estimation based on adjusted data. Now, by exploiting the property that </p>
<p style="text-align: center;"><code class="reqn">\lim_{\texttt{adj.epsilon} \rightarrow 0+} CI(y + \texttt{adj.epsilon}; H_{0}) = CI(y; H_{0}) ,</code>
</p>
<p> we extrapolate using a polynomial fit of degree at most three based on lower and upper endpoints of the confidence intervals on adjusted data. It is advised that
<code>adj.epsilon</code> should not exceed <code>0.1</code>, but it should not be too small. By default, <code>adj.epsilon = 0.03</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_check.homog.tol">check.homog.tol</code></td>
<td>
<p>Round-off tolerance for <code class="reqn">Z</code> homogeneity check. If the function <code class="reqn">h(\cdot)</code> with respect to <code class="reqn">m</code> is not <code class="reqn">Z</code> homogeneous, the algorithm will stop immediately and report an error.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_check.zero.order.homog.tol">check.zero.order.homog.tol</code></td>
<td>
<p>Round-off tolerance for zero-order <code class="reqn">Z</code> homogeneity check. If the function <code class="reqn">S(\cdot)</code> with respect to <code class="reqn">m</code> or <code class="reqn">P</code> is not zero-order <code class="reqn">Z</code> homogeneous, the algorithm will stop immediately and report an error.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_max.mph.iter">max.mph.iter</code>, <code id="ci.table_+3A_step">step</code>, <code id="ci.table_+3A_change.step.after">change.step.after</code>, <code id="ci.table_+3A_y.eps">y.eps</code>, <code id="ci.table_+3A_iter.orig">iter.orig</code>, <code id="ci.table_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="ci.table_+3A_norm.score.conv">norm.score.conv</code>, <code id="ci.table_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>. In this algorithm, if the input function <code>h.fct</code> is a function of <code class="reqn">p</code>, then the algorithm automatically rewrites it into another function of <code class="reqn">m</code>: <code class="reqn">h(p) = h(Diag^{-1}(ZZ'm)m) = h_{0}(m)</code>. If the input function <code>h.fct</code> is a function of <code class="reqn">m</code>, then we let <code class="reqn">h_{0}(m) = h(m)</code>. <code>h0.fct.deriv</code>, if it is specified, equals <code class="reqn">\partial h_{0}'(m) / \partial m</code>. Note that if <code class="reqn">h_{0}(\cdot)</code> maps from <code class="reqn">R^p</code> to <code class="reqn">R^q</code>, i.e. there are <code class="reqn">q</code> constraints, then <code>h0.fct.deriv</code> returns a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix of partial derivatives. If <code>h0.fct.deriv</code> is not specified or <code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>. In this algorithm, if the input function <code>S.fct</code> is a function of <code class="reqn">p</code>, then the algorithm automatically rewrites it into another function of <code class="reqn">m</code>: <code class="reqn">S(p) = S(Diag^{-1}(ZZ'm)m) = S_{0}(m)</code>. If the input function <code>S.fct</code> is a function of <code class="reqn">m</code>, then we let <code class="reqn">S_{0}(m) = S(m)</code>. If the input function <code>S.fct</code> is a function of <code class="reqn">P</code>, since <code class="reqn">S(\cdot)</code> is required to be zero-order <code class="reqn">Z</code> homogeneous, in which case <code class="reqn">S(P) = S(m)</code>, we let <code class="reqn">S_{0}(m) =
S(P)</code>. <code>S0.fct.deriv</code>, if it is specified, equals <code class="reqn">\partial S_{0}(m) / \partial m</code>. It is a column vector, whose length is the same as the length of <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_trans.g.deriv">trans.g.deriv</code></td>
<td>
<p>The derivative function of the transformation <code class="reqn">g</code>, i.e. <code class="reqn">d g(w) / d w</code>. If it is specified, it should be an <span class="rlang"><b>R</b></span> function, even if the derivative function is a constant function.</p>
</td></tr>
<tr><td><code id="ci.table_+3A_plot.cis">plot.CIs</code></td>
<td>
<p>Logical argument, <code>TRUE</code> or <code>FALSE</code>. If <code>plot.CIs = TRUE</code> (default), a visual display of the computed confidence interval(s) will be created. If <code>plot.CIs = FALSE</code>, no plots will be created.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ci.table</code> returns a list, which includes the following objects:
</p>
<table role = "presentation">
<tr><td><code>result.table</code></td>
<td>
<p>A table that displays lower and upper endpoints of the computed confidence interval(s). The length(s) of the confidence interval(s) is (are) reported in the last column.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>An object of class <code>Intervals_full</code> <code>{intervals}</code> that includes all of the computed confidence interval(s).</p>
</td></tr>
<tr><td><code>Shat</code></td>
<td>
<p>The constrained MLE of <code class="reqn">S(\cdot)</code> subject to <code class="reqn">H_{0}</code>. If there is an error or non-convergence issue during the process of fitting the model subject to <code class="reqn">H_{0}</code> by <code>mph.fit</code>, <code>Shat</code> is set to be <code>NA</code>; or if the constrained MLE does not exist, <code>Shat</code> is also set to be <code>NA</code>.</p>
</td></tr>
<tr><td><code>ase.Shat</code></td>
<td>
<p>The asymptotic standard error, i.e. ase, of the constrained MLE of <code class="reqn">S(\cdot)</code> subject to <code class="reqn">H_{0}</code>. If there is an error or non-convergence issue during the process of fitting the model subject to <code class="reqn">H_{0}</code> by <code>mph.fit</code>, <code>ase.Shat</code> is set to be <code>NA</code>; or if the constrained MLE does not exist, <code>ase.Shat</code> is also set to be <code>NA</code>.</p>
</td></tr>
<tr><td><code>S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>. It might be different from the input <code>S.space.H0</code>. If the input <code>S.space.H0</code> is the union of at least two disjoint intervals, then the output <code>S.space.H0</code> displays the particular interval in which <code>Shat</code>, the constrained MLE of <code class="reqn">S(\cdot)</code> subject to <code class="reqn">H_{0}</code>, lies. If the input <code>S.space.H0</code> is an interval, then the output <code>S.space.H0</code> is the same as the input. If <code>S.space.H0</code> is unspecified or <code>S.space.H0 = NULL</code> in the input, then the output <code>S.space.H0 = NULL</code>.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>Confidence coefficient, or the nominal level of the confidence interval. It is the same as the <code>cc</code> in the input.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>The test statistic(s) that is (are) actually used to construct the test-inversion approximate confidence interval(s).</p>
</td></tr>
<tr><td><code>pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic. It is the same as the <code>pdlambda</code> in the input.</p>
</td></tr>
<tr><td><code>warnings.collection</code></td>
<td>
<p>Includes all of the warning messages that occur during construction of the confidence
interval(s). They might be on evoking of the robustifying procedure: <code>"xxx.CI: Adjustment used. Not on original data.\n"</code>, or they might be on unsuccessful construction of the confidence interval(s): <code>"xxx.CI: NA.\n"</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Qiansheng Zhu</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>
<p>Lang, J. B. (2008) Score and profile likelihood confidence intervals for contingency table parameters, <em>Statistics in Medicine</em>, <b>27</b>, 5975&ndash;5990.
</p>
<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mph.fit">mph.fit</a></code>, <code><a href="#topic+mph.summary">mph.summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Construct test-inversion CIs subject to equality constraints.

# I. Mice-Fungicide data: Innes et al. (1969) conducted an experiment
#    to test the possible carcinogenic effect of a fungicide Avadex on
#    four subgroups of mice. The data is reproduced as a 2-by-2-by-4
#    three-way contingency table. Within each of the four 2-by-2 two-way
#    sub-tables, there is one fixed stratum for the treated group, and
#    there is also one fixed stratum for the control group. Overall,
#    the data was collected under the product-multinomial sampling scheme.
#    We assume that the relative risks that correspond to the four 2-by-2
#    two-way sub-tables are the same, and we construct 95% test-inversion
#    confidence intervals for this common relative risk.
#
#    For a detailed description of the Mice-Fungicide data set, see
#    Gart (1971):
#    Gart, J. J. (1971) The comparison of proportions: a review of
#    significance tests, confidence intervals and adjustments for
#    stratification. Revue de l'Institut International de Statistique,
#    39(2), pp. 148-169.

obs.y &lt;- c(4, 12, 5, 74, 2, 14, 3, 84, 4, 14, 10, 80, 1, 14, 3, 79)

h.fct &lt;- function(p) {
  RR_1 &lt;- p[1] / p[3]
  RR_2 &lt;- p[5] / p[7]
  RR_3 &lt;- p[9] / p[11]
  RR_4 &lt;- p[13] / p[15]
  rbind(RR_1 - RR_2, RR_1 - RR_3, RR_1 - RR_4)
}

S.fct &lt;- function(p) {
  p[1] / p[3]
}

mice_result &lt;- ci.table(obs.y, h.fct = h.fct, S.fct = S.fct,
                        S.space.H0 = c(0, Inf), trans.g = "log",
                        strata = rep(seq(1, 8), each = 2))


# II. Suppose there is a 3-by-4-by-2 three-way contingency table which
#     cross-classifies three variables: X, Y, and Z. We assign scores
#     {1,2,3}, {1,2,3,4}, and {1,2} to the variables X, Y, and Z,
#     respectively. At each level of Z, there is a 3-by-4 two-way sub-table
#     for variables X and Y, and the 3-by-4 sub-table forms a fixed
#     stratum. We assume that the Pearson's correlation coefficient between
#     X and Y when Z = 1 is the same as that when Z = 2. The observed table
#     counts are (1,2,3,4,5,6,7,8,9,10,11,12) for the 3-by-4 sub-table when
#     Z = 1, and (13,14,15,16,17,18,19,20,21,22,23,24) for the 3-by-4 sub-
#     table when Z = 2. We construct a 95% profile likelihood confidence
#     interval for this common Pearson's correlation coefficient.

corr_freq_prob &lt;- function(freq, score.X, score.Y) {
  # Compute the Pearson's correlation coefficient based on the vector
  # of table (frequency) counts or the vector of underlying table
  # probabilities.
  # Note that the input freq is a vector.
  c &lt;- length(score.X)
  d &lt;- length(score.Y)
  freq &lt;- matrix(freq, nrow = c, ncol = d, byrow = TRUE)
  P &lt;- freq / sum(freq)
  P.row.sum &lt;- apply(P, 1, sum)
  P.column.sum &lt;- apply(P, 2, sum)
  EX &lt;- crossprod(score.X, P.row.sum)
  EY &lt;- crossprod(score.Y, P.column.sum)
  EXsq &lt;- crossprod(score.X^2, P.row.sum)
  EYsq &lt;- crossprod(score.Y^2, P.column.sum)
  sdX &lt;- sqrt(EXsq - EX^2)
  sdY &lt;- sqrt(EYsq - EY^2)
  EXY &lt;- 0
  for (i in seq(1, c)) {
    for (j in seq(1, d)) {
      EXY &lt;- EXY + score.X[i] * score.Y[j] * P[i, j]
    }
  }
  Cov.X.Y &lt;- EXY - EX * EY
  if (Cov.X.Y == 0) {
    corr &lt;- 0
  }
  else {
    corr &lt;- as.numeric(Cov.X.Y / (sdX * sdY))
  }
  corr
}

h.fct &lt;- function(p) {
  corr_1 &lt;- corr_freq_prob(p[seq(1, 12)], c(1, 2, 3), c(1, 2, 3, 4))
  corr_2 &lt;- corr_freq_prob(p[seq(13, 24)], c(1, 2, 3), c(1, 2, 3, 4))
  corr_1 - corr_2
}

S.fct &lt;- function(p) {
  corr_freq_prob(p[seq(1, 12)], c(1, 2, 3), c(1, 2, 3, 4))
}

corr_result &lt;- ci.table(y = seq(1, 24), h.fct = h.fct, S.fct = S.fct,
                        S.space.H0 = c(-1, 1), method = "LR",
                        trans.g = "Fisher's z", strata = rep(c(1, 2), each = 12),
                        plot.CIs = FALSE)


# III. Crying Baby data: Gordon and Foss (1966) conducted an experiment to
#      investigate the effect of rocking on the crying of full term babies.
#      The data set can be reproduced as a 2-by-2-by-18 three-way contingency
#      table. Within each of the eighteen 2-by-2 two-way sub-tables, there is
#      one fixed stratum for the experimental group and one fixed stratum for
#      the control group. Overall, the data was collected under the product-
#      multinomial sampling scheme. We assume common odds ratios among the
#      eighteen two-way sub-tables, and we construct 95% test-inversion
#      confidence intervals for this common odds ratio.
#
#      For a detailed description of the Crying Baby data set, see Cox (1966):
#      Cox, D. R. (1966) A simple example of a comparison involving quantal
#      data. Biometrika, 53(1-2), pp. 213-220.

obs.y &lt;- c(0,1,5,3,0,1,4,2,0,1,4,1,1,0,5,1,0,1,1,4,0,1,5,4,0,1,3,5,0,1,
           4,4,0,1,2,3,1,0,1,8,0,1,1,5,0,1,1,8,0,1,3,5,0,1,1,4,0,1,2,4,
           0,1,1,7,1,0,2,4,0,1,3,5)
strata &lt;- rep(seq(1, 36), each = 2)

h.fct &lt;- function(p) {
  OR_1 &lt;- p[1] * p[4] / (p[2] * p[3])
  OR_2 &lt;- p[5] * p[8] / (p[6] * p[7])
  OR_3 &lt;- p[9] * p[12] / (p[10] * p[11])
  OR_4 &lt;- p[13] * p[16] / (p[14] * p[15])
  OR_5 &lt;- p[17] * p[20] / (p[18] * p[19])
  OR_6 &lt;- p[21] * p[24] / (p[22] * p[23])
  OR_7 &lt;- p[25] * p[28] / (p[26] * p[27])
  OR_8 &lt;- p[29] * p[32] / (p[30] * p[31])
  OR_9 &lt;- p[33] * p[36] / (p[34] * p[35])
  OR_10 &lt;- p[37] * p[40] / (p[38] * p[39])
  OR_11 &lt;- p[41] * p[44] / (p[42] * p[43])
  OR_12 &lt;- p[45] * p[48] / (p[46] * p[47])
  OR_13 &lt;- p[49] * p[52] / (p[50] * p[51])
  OR_14 &lt;- p[53] * p[56] / (p[54] * p[55])
  OR_15 &lt;- p[57] * p[60] / (p[58] * p[59])
  OR_16 &lt;- p[61] * p[64] / (p[62] * p[63])
  OR_17 &lt;- p[65] * p[68] / (p[66] * p[67])
  OR_18 &lt;- p[69] * p[72] / (p[70] * p[71])
  rbind(OR_1 - OR_2, OR_1 - OR_3, OR_1 - OR_4, OR_1 - OR_5, OR_1 - OR_6,
        OR_1 - OR_7, OR_1 - OR_8, OR_1 - OR_9, OR_1 - OR_10, OR_1 - OR_11,
        OR_1 - OR_12, OR_1 - OR_13, OR_1 - OR_14, OR_1 - OR_15,
        OR_1 - OR_16, OR_1 - OR_17, OR_1 - OR_18)
}

S.fct &lt;- function(p) {
  p[1] * p[4] / (p[2] * p[3])
}

crying_baby_result &lt;- ci.table(obs.y, h.fct = h.fct, S.fct = S.fct,
                               S.space.H0 = c(0, Inf), trans.g = "log",
                               strata = strata, fixed.strata = "all",
                               y.eps = 0.4)


# IV. Homicide data: Radelet &amp; Pierce (1985) examined cases of 1017 homicide
#     defendants in Florida between 1973 and 1977. Both the police department
#     and prosecutors classified these cases into three mutually exclusive
#     categories: 1 = "No Felony", 2 = "Possible Felony", 3 = "Felony".
#     Three variables: police classification (P), court (i.e. prosecutors')
#     classification (C), and race of defendant/victim (R) are cross-
#     classified in a 3-by-3-by-4 three-way contingency table. The data
#     was collected based on independent Poisson sampling, and the strata
#     correspond to levels of the race combination (R).
#
#     For a detailed description of the Homicide data set, see Agresti (1984)
#     and Radelet &amp; Pierce (1985):
#     Agresti, A. (1984). Analysis of Ordinal Categorical Data. John Wiley &amp;
#     Sons.
#     Radelet, M. L., &amp; Pierce, G. L. (1985). Race and prosecutorial
#     discretion in homicide cases. Law &amp; Society Review, 19(4), pp. 587-622.
#
#     To measure agreement between police and court classifications, the four
#     estimands of interest are Cohen's unweighted kappa coefficients at four
#     levels of R, respectively. We construct 95% test-inversion confidence
#     intervals for the estimands subject to two sets of equality constraints,
#     respectively.
#     (1) WkW and BkB have the same unweighted kappa, and BkW and WkB have
#     the same unweighted kappa.
#     (2) A "row effects" model for the conditional R-C association:
#     log mu_{ijk} = lambda + lambda_{i}^{R} + lambda_{j}^{P} + lambda_{k}^{C} +
#           lambda_{ij}^{RP} + lambda_{jk}^{PC} + tau_{i}^{RC}(w_{k} - bar{w}),
#     where race effects {tau_{i}^{RC}} that sum to zero are introduced for an
#     R-C association. The variable C is viewed as being ordinal with integer
#     monotonic scores {w_{k}}={1,2,3}.

BkW_v &lt;- c(7, 1, 3, 0, 2, 6, 5, 5, 109)
WkW_v &lt;- c(236, 11, 26, 7, 2, 21, 25, 4, 101)
BkB_v &lt;- c(328, 6, 13, 7, 2, 3, 21, 1, 36)
WkB_v &lt;- c(14, 1, 0, 6, 1, 1, 1, 0, 5)
obs.y &lt;- c(BkW_v, WkW_v, BkB_v, WkB_v)

Unweighted.Kappa.BkW &lt;- function(p) {
  mat.p &lt;- matrix(p[seq(1,9)], nrow = 3, byrow = TRUE)
  Kappa(mat.p)$Unweighted[1]
}
Unweighted.Kappa.WkW &lt;- function(p) {
  mat.p &lt;- matrix(p[seq(10,18)], nrow = 3, byrow = TRUE)
  Kappa(mat.p)$Unweighted[1]
}
Unweighted.Kappa.BkB &lt;- function(p) {
  mat.p &lt;- matrix(p[seq(19,27)], nrow = 3, byrow = TRUE)
  Kappa(mat.p)$Unweighted[1]
}
Unweighted.Kappa.WkB &lt;- function(p) {
  mat.p &lt;- matrix(p[seq(28,36)], nrow = 3, byrow = TRUE)
  Kappa(mat.p)$Unweighted[1]
}

# Constraints (1)
library(vcd)
WkW.BkB_BkW.WkB_cons &lt;- function(p) {
  mat.BkW &lt;- matrix(p[seq(1,9)], nrow = 3, byrow = TRUE)
  mat.WkW &lt;- matrix(p[seq(10,18)], nrow = 3, byrow = TRUE)
  mat.BkB &lt;- matrix(p[seq(19,27)], nrow = 3, byrow = TRUE)
  mat.WkB &lt;- matrix(p[seq(28,36)], nrow = 3, byrow = TRUE)
  rbind(Kappa(mat.BkW)$Unweighted[1] - Kappa(mat.WkB)$Unweighted[1],
        Kappa(mat.WkW)$Unweighted[1] - Kappa(mat.BkB)$Unweighted[1])
}
homicide_kappa_same_fit &lt;- mph.fit(obs.y, h.fct = WkW.BkB_BkW.WkB_cons,
                                   strata = rep(c(1,2,3,4), each = 9),
                                   fixed.strata = "none")
homicide_kappa_same_fit$Gsq
pchisq(homicide_kappa_same_fit$Gsq, 2, lower.tail = FALSE)  # p-value

BkW_kappa_same &lt;- ci.table(obs.y, h.fct = WkW.BkB_BkW.WkB_cons,
                           S.fct = Unweighted.Kappa.BkW, S.space.H0 = c(0,1),
                           strata = rep(c(1,2,3,4), each = 9),
                           fixed.strata = "none", trans.g = "[A,B]")
WkW_kappa_same &lt;- ci.table(obs.y, h.fct = WkW.BkB_BkW.WkB_cons,
                           S.fct = Unweighted.Kappa.WkW, S.space.H0 = c(0,1),
                           strata = rep(c(1,2,3,4), each = 9),
                           fixed.strata = "none", trans.g = "[A,B]")

# Constraints (2)
X_cond_RC_v &lt;- c(1,1,0,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,-1,0,0,
                 1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,
                 1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,
                 1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,0,-1,0,0,
                 1,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,
                 1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,
                 1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,-1,0,0,
                 1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
                 1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,0,0,-1,0,
                 1,0,1,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,
                 1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,
                 1,0,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,0,-1,0,
                 1,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,
                 1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,
                 1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,-1,0,
                 1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
                 1,0,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,-1,
                 1,0,0,1,1,0,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,
                 1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
                 1,0,0,1,0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,-1,
                 1,0,0,1,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,
                 1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,
                 1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,
                 1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
                 1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,
                 1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,
                 1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,
                 1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,1,1,
                 1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,
                 1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1,
                 1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,1,1,
                 1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
                 1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,-1)
X_cond_RC_mat &lt;- matrix(X_cond_RC_v, ncol = 21, byrow = TRUE)

cond_RC_HLP_fit &lt;- mph.fit(obs.y, L.fct = "logm", L.mean = TRUE,
                           X = X_cond_RC_mat,
                           strata = rep(c(1,2,3,4), each = 9),
                           fixed.strata = "none")
mph.summary(cond_RC_HLP_fit)

library(MASS)
X_cond_RC_U &lt;- Null(X_cond_RC_mat)
cond_RC_MPH_fit &lt;- mph.fit(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                           h.mean = TRUE, strata = rep(c(1,2,3,4), each = 9),
                           fixed.strata = "none")
mph.summary(cond_RC_MPH_fit)

BkW_cond_RC &lt;- ci.table(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                        h.mean = TRUE, S.fct = Unweighted.Kappa.BkW,
                        S.space.H0 = c(0,1), trans.g = "[A,B]",
                        strata = rep(c(1,2,3,4), each = 9), fixed.strata = "none")
WkW_cond_RC &lt;- ci.table(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                        h.mean = TRUE, S.fct = Unweighted.Kappa.WkW,
                        S.space.H0 = c(0,1), trans.g = "[A,B]",
                        strata = rep(c(1,2,3,4), each = 9), fixed.strata = "none")
BkB_cond_RC &lt;- ci.table(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                        h.mean = TRUE, S.fct = Unweighted.Kappa.BkB,
                        S.space.H0 = c(0,1), trans.g = "[A,B]",
                        strata = rep(c(1,2,3,4), each = 9), fixed.strata = "none")
WkB_cond_RC &lt;- ci.table(obs.y, h.fct = function(m) {t(X_cond_RC_U) %*% log(m)},
                        h.mean = TRUE, S.fct = Unweighted.Kappa.WkB,
                        S.space.H0 = c(0,1), trans.g = "[A,B]",
                        strata = rep(c(1,2,3,4), each = 9), fixed.strata = "none")



### Construct test-inversion CIs, without additionally imposed constraints.

# V. Binomial success rate parameter p.
#    Model: 0 = x &lt;- X | p ~ Bin(n = 5, p).
#    Goal: Compute approximate 90% CIs for the success probability p.

bin_p_result &lt;- ci.table(c(0, 5), h.fct = 0, S.fct = function(p) {p[1]},
                         S.space.H0 = c(0, 1), cc = 0.9, y.eps = 0.1)

#    Example 2.1 in Lang (2008).
#    Model: y = (39, 1) &lt;- Y ~ mult(40, p1, p2).
#    Goal: Compute approximate 95% CIs for the success probability p1.

bin_p_eg21_result &lt;- ci.table(c(39,1), h.fct = 0, S.fct = function(p) {p[1]},
                              S.space.H0 = c(0,1), trans.g = "[A,B]")


# VI. Conditional probability.
#     Model: y = (0, 39, 18, 11) &lt;- Y ~ mult(68, p1, p2, p3, p4)
#     Goal: Compute approximate 95% CIs for the conditional probability
#           p1 / (p1 + p2).

cond_prob_result &lt;- ci.table(c(0, 39, 18, 11), h.fct = 0,
                             S.fct = function(p) {p[1] / (p[1] + p[2])},
                             S.space.H0 = c(0, 1), y.eps = 0.1)

#     Model: y = (0, 39 // 18, 11) &lt;- Y ~ prod mult(39, p1, p2 // 29, p3, p4).
#     That is,
#     y &lt;- Y ~ MP(gamma, p | strata = c(1, 1, 2, 2), fixed = "all"),
#          where gamma = (39, 29)'.
#     Goal: Compute approximate 95% CIs for p1.

cond_prob_SS_result &lt;- ci.table(c(0, 39, 18, 11), h.fct = 0,
                                S.fct = function(p) {p[1]}, S.space.H0 = c(0, 1),
                                strata = c(1, 1, 2, 2), y.eps = 0.1)


# VII. Difference between conditional probabilities.
#      Model: y = (0, 39, 18, 11) &lt;- Y ~ mult(68, p1, p2, p3, p4)
#      Goal: Compute approximate 95% CIs for the difference between conditional
#            probabilities, p1 / (p1 + p2) - p3 / (p3 + p4).

diff_cond_prob_result &lt;- ci.table(c(0, 39, 18, 11), h.fct = 0,
                                  S.fct = function(p) {p[1]/(p[1]+p[2]) - p[3]/(p[3]+p[4])},
                                  S.space.H0 = c(-1, 1), trans.g = "[A,B]")


# VIII. Gamma variant.
#       Example 2.3 in Lang (2008).
#       Model: y = (25, 25, 12 // 0, 1, 3)
#                   ~ prod mult(62, p11, p12, p13 // 4, p21, p22, p23).
#       Goal: Compute approximate 95% CIs for the Gamma* parameter as
#             described in Lang (2008).

Gamma_variant_23 &lt;- function(p) {
  p &lt;- matrix(p, 2, 3, byrow = TRUE)
  P.case.gt.control &lt;- (p[2, 2] + p[2, 3]) * p[1, 1] + p[2, 3] * p[1, 2]
  P.case.lt.control &lt;- p[1, 2] * p[2, 1] + p[1, 3] * (p[2, 1] + p[2, 2])
  P.case.neq.control &lt;- P.case.gt.control + P.case.lt.control
  P.case.gt.control / P.case.neq.control
}
Gamma_variant_result &lt;- ci.table(c(25, 25, 12, 0, 1, 3), h.fct = 0,
                                 S.fct = Gamma_variant_23, S.space.H0 = c(0, 1),
                                 trans.g = "[A,B]", strata = c(1, 1, 1, 2, 2, 2))

### Alternative code...
gammastar.fct &lt;- function(p) {
  nr &lt;- nrow(p)
  nc &lt;- ncol(p)
  probC &lt;- 0
  probD &lt;- 0
  for (i in 1:(nr-1)) {
    for (j in 1:(nc-1)) {
      Aij &lt;- 0
      for (h in (i+1):nr) {
        for (k in (j+1):nc) {
          Aij &lt;- Aij + p[h, k]
        }
      }
      probC &lt;- probC + p[i, j] * Aij
    }
  }
  for (i in 1:(nr-1)) {
    for (j in 2:nc) {
      Aij &lt;- 0
      for (h in (i+1):nr) {
        for (k in 1:(j-1)) {
          Aij &lt;- Aij + p[h, k]
        }
      }
      probD &lt;- probD + p[i, j] * Aij
    }
  }
  probC / (probC + probD)
}

Gamma_variant_23_a &lt;- function(p) {
  p &lt;- matrix(p, 2, 3, byrow = TRUE)
  gammastar.fct(p)
}
Gamma_variant_a_result &lt;- ci.table(c(25, 25, 12, 0, 1, 3), h.fct = 0,
                                   S.fct = Gamma_variant_23_a,
                                   S.space.H0 = c(0, 1), trans.g = "[A,B]",
                                   strata = c(1, 1, 1, 2, 2, 2))


# IX. Global odds ratio.
#     Model: y = (25, 25, 12 // 0, 1, 3)
#                 ~ prod mult(62, p11, p12, p13 // 4, p21, p22, p23).
#     Goal: Compute approximate 95% CIs for the first global odds ratio.

global_odds_ratio_23_11 &lt;- function(p) {
  p &lt;- matrix(p, 2, 3, byrow = TRUE)
  p[1, 1] * (p[2, 2] + p[2, 3]) / (p[2, 1] * (p[1, 2] + p[1, 3]))
}
global_odds_ratio_result &lt;- ci.table(c(25, 25, 12, 0, 1, 3), h.fct = 0,
                                     S.fct = global_odds_ratio_23_11,
                                     S.space.H0 = c(0, Inf), trans.g = "log",
                                     strata = c(1, 1, 1, 2, 2, 2))


# X. Difference between product-multinomial probabilities.
#    Example 2.2 in Lang (2008).
#    Source (secondary): Agresti 2002:65
#    Early study of the death penalty in Florida (Radelet)
#    Victim Black...
#    White Defendant  0/9   received Death Penalty
#    Black Defendant  6/103 received Death Penalty
#
#    Model: y = (0, 9 // 6, 97) &lt;- Y ~ prod mult(9, p1, p2 // 103, p3, p4).
#    Goal: Compute approximate 95% CIs for the difference between
#          product-multinomial probabilities, p1 - p3.

diff_prod_mult_prob_result &lt;- ci.table(c(0, 9, 6, 97), h.fct = 0,
                                       S.fct = function(p) {p[1] - p[3]},
                                       S.space.H0 = c(-1, 1),
                                       trans.g = "Fisher's z",
                                       strata = c(1, 1, 2, 2))

### Alternative (artificial) data that is even more sparse...

diff_prod_mult_prob_a_result &lt;- ci.table(c(0, 9, 0, 97), h.fct = 0,
                                         S.fct = function(p) {p[1] - p[3]},
                                         S.space.H0 = c(-1, 1),
                                         trans.g = "Fisher's z",
                                         strata = c(1, 1, 2, 2), y.eps = 0.4)


# XI. Kappa coefficient.
#     Example 2.4 in Lang (2008).
#     Model: y = (4, 0, 0, 0, 1, 0, 0, 0, 15)
#              &lt;- Y ~ mult(20, p11, p12, ..., p33).
#     Goal: Compute approximate 95% CIs for the unweighted kappa coefficient.

Kappa_coeff_33 &lt;- function(p) {
  p &lt;- matrix(p, 3, 3, byrow = TRUE)
  s1 &lt;- p[1, 1] + p[2, 2] + p[3, 3]
  prow &lt;- apply(p, 1, sum)
  pcol &lt;- apply(p, 2, sum)
  s2 &lt;- prow[1] * pcol[1] + prow[2] * pcol[2] + prow[3] * pcol[3]
  (s1 - s2) / (1 - s2)
}
kappa_coeff_result &lt;- ci.table(c(4, 0, 0, 0, 1, 0, 0, 0, 15), h.fct = 0,
                               S.fct = Kappa_coeff_33, S.space.H0 = c(-1, 1))

</code></pre>

<hr>
<h2 id='compute_cons_MLE_ase'>
Constrained MLE and ASE
</h2><span id='topic+compute_cons_MLE_ase'></span>

<h3>Description</h3>

<p>Computes the constrained MLE of <code class="reqn">S_{0}(m)</code> subject to equality constraints <code class="reqn">h_{0}(m) = 0</code> under the specified <code>strata</code> and <code>fixed.strata</code> configuration, and its associated asymptotic standard error. Here <code class="reqn">m</code> is the vector of expected table counts, i.e. <code class="reqn">m = E(Y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_cons_MLE_ase(y, strata, fixed.strata, h0.fct, h0.fct.deriv, S0.fct,
                     S0.fct.deriv, max.mph.iter, step, change.step.after,
                     y.eps, iter.orig, norm.diff.conv, norm.score.conv,
                     max.score.diff.iter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_cons_MLE_ase_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="compute_cons_MLE_ase_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="compute_cons_MLE_ase_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="compute_cons_MLE_ase_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="compute_cons_MLE_ase_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="compute_cons_MLE_ase_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="compute_cons_MLE_ase_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="compute_cons_MLE_ase_+3A_max.mph.iter">max.mph.iter</code>, <code id="compute_cons_MLE_ase_+3A_step">step</code>, <code id="compute_cons_MLE_ase_+3A_change.step.after">change.step.after</code>, <code id="compute_cons_MLE_ase_+3A_y.eps">y.eps</code>, <code id="compute_cons_MLE_ase_+3A_iter.orig">iter.orig</code>, <code id="compute_cons_MLE_ase_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="compute_cons_MLE_ase_+3A_norm.score.conv">norm.score.conv</code>, <code id="compute_cons_MLE_ase_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>compute_cons_MLE_ase</code> returns a vector of length two. The first element <code>S0.fct.m_H0</code> is the constrained MLE of <code class="reqn">S_{0}(m)</code> subject to equality
constraints <code class="reqn">h_{0}(m) = 0</code>, and the second element <code>ase.S0.fct.m_H0</code> is the
associated asymptotic standard error.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>
<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='create.U'>
Orthogonal Complement of the Column Space of a Matrix
</h2><span id='topic+create.U'></span>

<h3>Description</h3>

<p>Creates a full column rank matrix, <code class="reqn">U</code>, with column space
equal to the orthogonal complement of the column space of <code class="reqn">X</code>. That is,
<code class="reqn">U</code> has column space equal to the null space of <code class="reqn">X'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.U(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.U_+3A_x">X</code></td>
<td>
<p>A full column rank matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>create.U</code> returns a full column rank matrix <code>U</code>, with column
space equal to the orthogonal complement of the column space of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph B. Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mph.fit">mph.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(seq(1, 12), ncol = 2, byrow = TRUE)
create.U(X)
</code></pre>

<hr>
<h2 id='create.Z.ZF'>
Population Matrix and Sampling Constraint Matrix
</h2><span id='topic+create.Z.ZF'></span>

<h3>Description</h3>

<p>Creates the population (aka strata) matrix <code class="reqn">Z</code> and the sampling constraint
matrix <code class="reqn">Z_{F}</code> using strata and sampling constraint information found in
input variables <code>strata</code> and <code>fixed.strata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.Z.ZF(strata, nrowZ = length(strata), fixed.strata = "all")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.Z.ZF_+3A_strata">strata</code></td>
<td>
<p>The vector that gives the stratum membership identifier.</p>
</td></tr>
<tr><td><code id="create.Z.ZF_+3A_nrowz">nrowZ</code></td>
<td>
<p>Number of rows of the to-be-created population (aka strata)
matrix <code class="reqn">Z</code>.</p>
</td></tr>
<tr><td><code id="create.Z.ZF_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum have
fixed sample sizes. It can equal one of the keywords,
<code>fixed.strata = "all"</code> or <code>fixed.strata = "none"</code>,
or it can be a vector of stratum membership identifiers,
e.g. <code>fixed.strata = c(1,3)</code>. Default:
<code>fixed.strata = "all"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>create.Z.ZF</code> returns a list, which includes the following two objects:
</p>
<table role = "presentation">
<tr><td><code>Z</code></td>
<td>
<p>Population (aka strata) matrix.</p>
</td></tr>
<tr><td><code>ZF</code></td>
<td>
<p>Sampling constraint matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joseph B. Lang
</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mph.fit">mph.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create.Z.ZF(c(1, 1, 2, 3, 3), fixed.strata = "all")
create.Z.ZF(c(1, 1, 2, 3, 3), fixed.strata = "none")
create.Z.ZF(c(1, 1, 2, 3, 3), fixed.strata = c(1, 2))
</code></pre>

<hr>
<h2 id='diff_Gsq_nr'>
Difference in <code class="reqn">G</code>-Squared Statistic Based CIs (Non-Robust)
</h2><span id='topic+diff_Gsq_nr'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the difference in <code class="reqn">G^2</code> statistic, for estimands in contingency tables subject to equality constraints.
</p>
<p>These confidence intervals are also referred to as likelihood
ratio confidence intervals or profile likelihood confidence intervals.
</p>
<p>The program may stop because of a non-convergence issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_Gsq_nr(y, strata, fixed.strata, h0.fct, h0.fct.deriv, S0.fct,
            S0.fct.deriv, max.mph.iter, step, change.step.after,
            y.eps, iter.orig, norm.diff.conv, norm.score.conv,
            max.score.diff.iter, S.space.H0, tol.psi, tol,
            max.iter, cut.off, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_Gsq_nr_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_max.mph.iter">max.mph.iter</code>, <code id="diff_Gsq_nr_+3A_step">step</code>, <code id="diff_Gsq_nr_+3A_change.step.after">change.step.after</code>, <code id="diff_Gsq_nr_+3A_y.eps">y.eps</code>, <code id="diff_Gsq_nr_+3A_iter.orig">iter.orig</code>, <code id="diff_Gsq_nr_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="diff_Gsq_nr_+3A_norm.score.conv">norm.score.conv</code>, <code id="diff_Gsq_nr_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_tol.psi">tol.psi</code>, <code id="diff_Gsq_nr_+3A_tol">tol</code>, <code id="diff_Gsq_nr_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="diff_Gsq_nr_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provided that <code>diff_Gsq_nr</code> does not stop,
it returns a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the difference in <code class="reqn">G^2</code> statistic.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_Gsq_robust">diff_Gsq_robust</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='diff_Gsq_robust'>
Difference in <code class="reqn">G</code>-Squared Statistic Based CIs (Robust)
</h2><span id='topic+diff_Gsq_robust'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the difference in <code class="reqn">G^2</code> statistic, for estimands in contingency tables subject to equality constraints.
</p>
<p>These confidence intervals are also referred to as likelihood ratio confidence intervals or profile likelihood confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_Gsq_robust(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
                S0.fct, S0.fct.deriv, max.mph.iter, step,
                change.step.after, y.eps, iter.orig, norm.diff.conv,
                norm.score.conv, max.score.diff.iter, S.space.H0,
                tol.psi, tol, max.iter, cut.off, delta, adj.epsilon,
                iter.robust.max, iter.robust.eff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_Gsq_robust_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_max.mph.iter">max.mph.iter</code>, <code id="diff_Gsq_robust_+3A_step">step</code>, <code id="diff_Gsq_robust_+3A_change.step.after">change.step.after</code>, <code id="diff_Gsq_robust_+3A_y.eps">y.eps</code>, <code id="diff_Gsq_robust_+3A_iter.orig">iter.orig</code>, <code id="diff_Gsq_robust_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="diff_Gsq_robust_+3A_norm.score.conv">norm.score.conv</code>, <code id="diff_Gsq_robust_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_tol.psi">tol.psi</code>, <code id="diff_Gsq_robust_+3A_tol">tol</code>, <code id="diff_Gsq_robust_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
<tr><td><code id="diff_Gsq_robust_+3A_adj.epsilon">adj.epsilon</code>, <code id="diff_Gsq_robust_+3A_iter.robust.max">iter.robust.max</code>, <code id="diff_Gsq_robust_+3A_iter.robust.eff">iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>diff_Gsq_robust</code> returns a list, which includes two objects. The first object is a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the difference in <code class="reqn">G^2</code> statistic. For the second object, it includes the warning message that occurs during construction of the confidence
interval if the robustifying procedure is evoked: <code>"diff.Gsq.CI: Adjustment used. Not on original data.\n"</code>. If the robustifying procedure is not evoked, the second object is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_Gsq_nr">diff_Gsq_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='diff_PD_nr'>
Difference in Power-Divergence Statistic Based CIs (Non-Robust)
</h2><span id='topic+diff_PD_nr'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the difference in power-divergence statistic, for estimands in contingency tables subject to equality constraints.
</p>
<p>The program may stop because of a non-convergence issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_PD_nr(y, strata, fixed.strata, h0.fct, h0.fct.deriv, S0.fct,
           S0.fct.deriv, max.mph.iter, step, change.step.after,
           y.eps, iter.orig, norm.diff.conv, norm.score.conv,
           max.score.diff.iter, S.space.H0, tol.psi, tol,
           max.iter, cut.off, delta, pdlambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_PD_nr_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_max.mph.iter">max.mph.iter</code>, <code id="diff_PD_nr_+3A_step">step</code>, <code id="diff_PD_nr_+3A_change.step.after">change.step.after</code>, <code id="diff_PD_nr_+3A_y.eps">y.eps</code>, <code id="diff_PD_nr_+3A_iter.orig">iter.orig</code>, <code id="diff_PD_nr_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="diff_PD_nr_+3A_norm.score.conv">norm.score.conv</code>, <code id="diff_PD_nr_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_tol.psi">tol.psi</code>, <code id="diff_PD_nr_+3A_tol">tol</code>, <code id="diff_PD_nr_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
<tr><td><code id="diff_PD_nr_+3A_pdlambda">pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provided that <code>diff_PD_nr</code> does not stop,
it returns a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the difference in power-divergence statistic.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_PD_robust">diff_PD_robust</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='diff_PD_robust'>
Difference in Power-Divergence Statistic Based CIs (Robust)
</h2><span id='topic+diff_PD_robust'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the difference in power-divergence statistic, for estimands in contingency tables subject to equality constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_PD_robust(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
               S0.fct, S0.fct.deriv, max.mph.iter, step,
               change.step.after, y.eps, iter.orig, norm.diff.conv,
               norm.score.conv, max.score.diff.iter, S.space.H0,
               tol.psi, tol, max.iter, cut.off, delta, pdlambda,
               adj.epsilon, iter.robust.max, iter.robust.eff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_PD_robust_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum
membership identifier.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_max.mph.iter">max.mph.iter</code>, <code id="diff_PD_robust_+3A_step">step</code>, <code id="diff_PD_robust_+3A_change.step.after">change.step.after</code>, <code id="diff_PD_robust_+3A_y.eps">y.eps</code>, <code id="diff_PD_robust_+3A_iter.orig">iter.orig</code>, <code id="diff_PD_robust_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="diff_PD_robust_+3A_norm.score.conv">norm.score.conv</code>, <code id="diff_PD_robust_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_tol.psi">tol.psi</code>, <code id="diff_PD_robust_+3A_tol">tol</code>, <code id="diff_PD_robust_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_pdlambda">pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic.</p>
</td></tr>
<tr><td><code id="diff_PD_robust_+3A_adj.epsilon">adj.epsilon</code>, <code id="diff_PD_robust_+3A_iter.robust.max">iter.robust.max</code>, <code id="diff_PD_robust_+3A_iter.robust.eff">iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>diff_PD_robust</code> returns a list, which includes two objects. The first object is a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the difference in power-divergence statistic. For the second object, it includes the warning message that occurs during construction of the confidence
interval if the robustifying procedure is evoked: <code>"diff.PD.CI: Adjustment used. Not on original data.\n"</code>. If the robustifying procedure is not evoked, the second object is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_PD_nr">diff_PD_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='diff_Xsq_nr'>
Difference in <code class="reqn">X</code>-Squared Statistic Based CIs (Non-Robust)
</h2><span id='topic+diff_Xsq_nr'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the difference in <code class="reqn">X^2</code> statistic, for estimands in contingency tables subject to equality constraints.
</p>
<p>The program may stop because of a non-convergence issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_Xsq_nr(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
            S0.fct, S0.fct.deriv, max.mph.iter, step,
            change.step.after, y.eps, iter.orig, norm.diff.conv,
            norm.score.conv, max.score.diff.iter, S.space.H0,
            tol.psi, tol, max.iter, cut.off, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_Xsq_nr_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
estimand function <code class="reqn">S_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_max.mph.iter">max.mph.iter</code>, <code id="diff_Xsq_nr_+3A_step">step</code>, <code id="diff_Xsq_nr_+3A_change.step.after">change.step.after</code>, <code id="diff_Xsq_nr_+3A_y.eps">y.eps</code>, <code id="diff_Xsq_nr_+3A_iter.orig">iter.orig</code>, <code id="diff_Xsq_nr_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="diff_Xsq_nr_+3A_norm.score.conv">norm.score.conv</code>, <code id="diff_Xsq_nr_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_tol.psi">tol.psi</code>, <code id="diff_Xsq_nr_+3A_tol">tol</code>, <code id="diff_Xsq_nr_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="diff_Xsq_nr_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provided that <code>diff_Xsq_nr</code> does not stop,
it returns a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the difference in <code class="reqn">X^2</code> statistic.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_Xsq_robust">diff_Xsq_robust</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='diff_Xsq_robust'>
Difference in <code class="reqn">X</code>-Squared Statistic Based CIs (Robust)
</h2><span id='topic+diff_Xsq_robust'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the difference in <code class="reqn">X^2</code> statistic, for estimands in contingency tables subject to equality constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_Xsq_robust(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
                S0.fct, S0.fct.deriv, max.mph.iter, step,
                change.step.after, y.eps, iter.orig, norm.diff.conv,
                norm.score.conv, max.score.diff.iter, S.space.H0,
                tol.psi, tol, max.iter, cut.off, delta, adj.epsilon,
                iter.robust.max, iter.robust.eff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_Xsq_robust_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum
membership identifier.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of
the estimand function <code class="reqn">S_{0}(\cdot)</code> with respect
to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_max.mph.iter">max.mph.iter</code>, <code id="diff_Xsq_robust_+3A_step">step</code>, <code id="diff_Xsq_robust_+3A_change.step.after">change.step.after</code>, <code id="diff_Xsq_robust_+3A_y.eps">y.eps</code>, <code id="diff_Xsq_robust_+3A_iter.orig">iter.orig</code>, <code id="diff_Xsq_robust_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="diff_Xsq_robust_+3A_norm.score.conv">norm.score.conv</code>, <code id="diff_Xsq_robust_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_tol.psi">tol.psi</code>, <code id="diff_Xsq_robust_+3A_tol">tol</code>, <code id="diff_Xsq_robust_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
<tr><td><code id="diff_Xsq_robust_+3A_adj.epsilon">adj.epsilon</code>, <code id="diff_Xsq_robust_+3A_iter.robust.max">iter.robust.max</code>, <code id="diff_Xsq_robust_+3A_iter.robust.eff">iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>diff_Xsq_robust</code> returns a list, which includes two objects. The first object is a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the difference in <code class="reqn">X^2</code> statistic. For the second object, it includes the warning message that occurs during construction of the confidence
interval if the robustifying procedure is evoked: <code>"diff.Xsq.CI: Adjustment used. Not on original data.\n"</code>. If the robustifying procedure is not evoked, the second object is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_Xsq_nr">diff_Xsq_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='f.psi'>
Model Comparison Statistics
</h2><span id='topic+f.psi'></span>

<h3>Description</h3>

<p>Computes one of the model comparison statistics.
</p>
<p>The model comparison statistics include:
</p>

<ul>
<li> <p><code>"diff.Gsq"</code>: The difference in <code class="reqn">G^2</code> statistic, </p>
<p style="text-align: center;"><code class="reqn">G^{2}(\psi) - G^2 = G^{2}(y; H_{0}(\psi)) - G^{2}(y; H_{0});</code>
</p>

</li>
<li> <p><code>"diff.Xsq"</code>: The difference in <code class="reqn">X^2</code> statistic, </p>
<p style="text-align: center;"><code class="reqn">X^{2}(\psi) - X^2 = X^{2}(y; H_{0}(\psi)) - X^{2}(y; H_{0});</code>
</p>

</li>
<li> <p><code>"diff.PD"</code>: The difference in power-divergence statistic, with index parameter <code class="reqn">\lambda</code>, </p>
<p style="text-align: center;"><code class="reqn">PD_{\lambda}(\psi) - PD_{\lambda} = PD_{\lambda}(y; H_{0}(\psi)) - PD_{\lambda}(y; H_{0});</code>
</p>

</li>
<li> <p><code>"nested.Gsq"</code>: The nested <code class="reqn">G^2</code> statistic, </p>
<p style="text-align: center;"><code class="reqn">G^{2}(y; H_{0}(\psi) | H_{0});</code>
</p>

</li>
<li> <p><code>"nested.Xsq"</code>: The nested <code class="reqn">X^2</code> statistic, </p>
<p style="text-align: center;"><code class="reqn">X^{2}(y; H_{0}(\psi) | H_{0});</code>
</p>

</li>
<li> <p><code>"nested.PD"</code>: The nested power-divergence statistic, with index parameter
<code class="reqn">\lambda</code>, </p>
<p style="text-align: center;"><code class="reqn">PD_{\lambda}(y; H_{0}(\psi) | H_{0}).</code>
</p>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>f.psi(y, strata, fixed.strata, h0.fct, h0.fct.deriv = NULL,
      S0.fct, S0.fct.deriv = NULL, method_specific, psi,
      max.mph.iter, step, change.step.after, y.eps, iter.orig,
      norm.diff.conv, norm.score.conv, max.score.diff.iter,
      pdlambda = NULL, Gsq_H0, Xsq_H0, PD_H0, cons.MLE.m_H0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f.psi_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum
membership identifier.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of                       the estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_method_specific">method_specific</code></td>
<td>
<p>A character string that indicates which model comparison
statistic to compute. It can be one of <code>"diff.Xsq"</code>,
<code>"nested.Xsq"</code>, <code>"diff.Gsq"</code>, <code>"nested.Gsq"</code>,
<code>"diff.PD"</code>, or <code>"nested.PD"</code>.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_psi">psi</code></td>
<td>
<p>The real number <code class="reqn">\psi</code> in the model comparison statistic.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_max.mph.iter">max.mph.iter</code>, <code id="f.psi_+3A_step">step</code>, <code id="f.psi_+3A_change.step.after">change.step.after</code>, <code id="f.psi_+3A_y.eps">y.eps</code>, <code id="f.psi_+3A_iter.orig">iter.orig</code>, <code id="f.psi_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="f.psi_+3A_norm.score.conv">norm.score.conv</code>, <code id="f.psi_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_pdlambda">pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_gsq_h0">Gsq_H0</code></td>
<td>
<p>The <code class="reqn">G^2</code> statistic for testing <code class="reqn">H_{0}</code> vs. not <code class="reqn">H_{0}</code>, i.e.
<code class="reqn">G^{2}(y; H_{0})</code>.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_xsq_h0">Xsq_H0</code></td>
<td>
<p>The <code class="reqn">X^2</code> statistic for testing <code class="reqn">H_{0}</code> vs. not <code class="reqn">H_{0}</code>, i.e.
<code class="reqn">X^{2}(y; H_{0})</code>.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_pd_h0">PD_H0</code></td>
<td>
<p>The power-divergence statistic for testing <code class="reqn">H_{0}</code> vs. not <code class="reqn">H_{0}</code>,
i.e. <code class="reqn">PD_{\lambda}(y; H_{0})</code>.</p>
</td></tr>
<tr><td><code id="f.psi_+3A_cons.mle.m_h0">cons.MLE.m_H0</code></td>
<td>
<p>Constrained MLE of <code class="reqn">m = E(Y)</code> subject to <code class="reqn">H_{0}</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>f.psi</code> returns a numeric value, which is the computed model comparison statistic.
</p>


<h3>Note</h3>

<p>Among the four inputs: <code>Gsq_H0</code>, <code>Xsq_H0</code>, <code>PD_H0</code>, and
<code>cons.MLE.m_H0</code>, only one of them needs to be specified.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diff_Xsq_nr">diff_Xsq_nr</a></code>, <code><a href="#topic+nested_Xsq_nr">nested_Xsq_nr</a></code>, <code><a href="#topic+diff_Gsq_nr">diff_Gsq_nr</a></code>, <code><a href="#topic+nested_Gsq_nr">nested_Gsq_nr</a></code>, <code><a href="#topic+diff_PD_nr">diff_PD_nr</a></code>, <code><a href="#topic+nested_PD_nr">nested_PD_nr</a></code>, <code><a href="#topic+diff_Xsq_robust">diff_Xsq_robust</a></code>, <code><a href="#topic+nested_Xsq_robust">nested_Xsq_robust</a></code>, <code><a href="#topic+diff_Gsq_robust">diff_Gsq_robust</a></code>, <code><a href="#topic+nested_Gsq_robust">nested_Gsq_robust</a></code>, <code><a href="#topic+diff_PD_robust">diff_PD_robust</a></code>, <code><a href="#topic+nested_PD_robust">nested_PD_robust</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='M.fct'>
Marginalizing Matrix Based on Strata Information
</h2><span id='topic+M.fct'></span>

<h3>Description</h3>

<p>Creates the marginalizing matrix <code class="reqn">M</code> using strata information found in input variable <code>strata</code>. That is, <code class="reqn">Mp</code> gives the marginal probabilities corresponding to the levels of factor <code>strata</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M.fct(strata, ncells = length(strata))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="M.fct_+3A_strata">strata</code></td>
<td>
<p>The vector that gives the stratum membership identifier.</p>
</td></tr>
<tr><td><code id="M.fct_+3A_ncells">ncells</code></td>
<td>
<p>Number of contingency table cells. Default:
<code>ncells = length(strata)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>M.fct</code> returns the marginalizing matrix <code>M</code>.
</p>


<h3>Note</h3>

<p>Marginals are ordered according to the levels of factor
<code>strata</code>.
</p>
<p>Examples:
</p>

<table>
<tr>
 <td style="text-align: center;">
  <code>V1</code>  </td><td style="text-align: right;">  <code>V2</code>  </td><td style="text-align: right;">    <code>y</code></td>
</tr>
<tr>
 <td style="text-align: center;">
  <code>b</code> </td><td style="text-align: right;">   <code>yes</code>  </td><td style="text-align: right;">   <code>15</code></td>
</tr>
<tr>
 <td style="text-align: center;">
 <code>a</code>  </td><td style="text-align: right;">   <code>no</code> </td><td style="text-align: right;">    <code>12</code></td>
</tr>
<tr>
 <td style="text-align: center;">
  <code>a</code> </td><td style="text-align: right;">   <code>yes</code>  </td><td style="text-align: right;">   <code>13</code></td>
</tr>
<tr>
 <td style="text-align: center;">
 <code>b</code> </td><td style="text-align: right;">   <code>yes</code>   </td><td style="text-align: right;">     <code>5</code></td>
</tr>
<tr>
 <td style="text-align: center;">
  <code>b</code> </td><td style="text-align: right;">    <code>no</code>  </td><td style="text-align: right;">   <code>1</code></td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p><code>M1 &lt;- M.fct(V1)</code><br />
<code>M1 %*% y</code><br />
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: right;"> <code>[,1]</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>a</code> </td><td style="text-align: right;">  <code>25</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>b</code> </td><td style="text-align: right;">  <code>21</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>M2 &lt;- M.fct(V2)</code><br />
<code>M2 %*% y</code><br />
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: right;"> <code>[,1]</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>no</code> </td><td style="text-align: right;">  <code>13</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>yes</code> </td><td style="text-align: right;">  <code>33</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><code>M12 &lt;- M.fct(paste(V1, V2))</code><br />
<code>M12 %*% y</code>
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: right;"> </td><td style="text-align: right;"> <code>[,1]</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>a</code> </td><td style="text-align: right;"> <code>no</code> </td><td style="text-align: right;">  <code>12</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>a</code> </td><td style="text-align: right;"> <code>yes</code>  </td><td style="text-align: right;"> <code>13</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>b</code> </td><td style="text-align: right;"> <code>no</code>   </td><td style="text-align: right;"> <code>1</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code>b</code> </td><td style="text-align: right;"> <code>yes</code>  </td><td style="text-align: right;">  <code>20</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Joseph B. Lang
</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M.fct(rep(1, 9))
M.fct(seq(1, 9))
M.fct(c(1, 1, 2, 3, 3))
</code></pre>

<hr>
<h2 id='mph.fit'>
Fitting MPH and HLP Models
</h2><span id='topic+mph.fit'></span>

<h3>Description</h3>

<p>Computes maximum likelihood estimates and fit statistics for
multinomial-Poisson homogeneous (MPH) and homogeneous linear predictor
(HLP) models for contingency tables.
</p>
<p>More detailed <a href="https://homepage.divms.uiowa.edu/~jblang/mph.fitting/">DOCUMENTATION and EXAMPLES</a> of <code>mph.fit</code> are <a href="https://homepage.divms.uiowa.edu/~jblang/mph.fitting/">online</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mph.fit(y, h.fct = constraint, constraint = NULL, h.mean = FALSE,
        L.fct = link, link = NULL, L.mean = FALSE, X = NULL,
        strata = rep(1, length(y)), fixed.strata = "all",
        check.homog.tol = 1e-9, check.HLP.tol = 1e-9, maxiter = 100,
        step = 1, change.step.after = 0.25 * maxiter, y.eps = 0,
        iter.orig = 5, m.initial = y, norm.diff.conv = 1e-6,
        norm.score.conv = 1e-6, max.score.diff.iter = 10,
        derht.fct = NULL, derLt.fct = NULL, pdlambda = 2/3,
        verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mph.fit_+3A_y">y</code></td>
<td>
<p>Vector (not matrix) of table counts.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_h.fct">h.fct</code></td>
<td>
<p>Function object that defines the constraint function <code class="reqn">h(\cdot)</code>.
It must return a column vector. <code>h.fct</code> can also be set to
<code>0</code>, in which case <code class="reqn">h(\cdot)</code> is viewed as the <code class="reqn">0</code>
function, so no constraints are imposed.
</p>
<p>By default, <code class="reqn">h(\cdot)</code> is viewed as a function of the table
probabilities <code class="reqn">p</code>. If <code>h.mean</code> is set to <code>h.mean = TRUE</code>,
then <code class="reqn">h(\cdot)</code> is viewed as a function of the expected counts
<code class="reqn">m</code>.
</p>
<p>Default: <code>h.fct = NULL</code>. If both <code>h.fct = NULL</code>
and <code>L.fct = NULL</code>, then <code>h.fct</code> is set to <code>0</code> and
no constraints are imposed. If <code>h.fct = NULL</code> and <code>L.fct</code>
is not <code>NULL</code>, then <code>h.fct</code> will be computed as
<code>t(U) %*% L.fct</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_constraint">constraint</code></td>
<td>
<p>Alias for the argument <code>h.fct</code>. Argument <code>constraint</code>
is secondary to the primary argument <code>h.fct</code> in the                           following senses: If <code>constraint</code> and <code>h.fct</code> are not
equal, <code>h.fct</code> is used.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_h.mean">h.mean</code></td>
<td>
<p>Logical argument. If <code>h.mean = FALSE</code> (the default), <code>h.fct</code>
is treated as a function of <code class="reqn">p</code>. If <code>h.mean = TRUE</code>, then
<code>h.fct</code> is treated as a function of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_l.fct">L.fct</code></td>
<td>
<p>Function object that defines the link <code class="reqn">L(\cdot)</code> in the HLP model;
it must return a column vector. Or ... <code>L.fct = keyword</code>,
where candidate keywords include <code>"logp"</code> and <code>"logm"</code>.
</p>
<p>Entering <code>L.fct = "logp"</code> tells the program to create the
function object as <code>L.fct &lt;- function(p) {log(p)}</code>.
<code>L.fct = "logm"</code> tells the program to (i) create the
function object as <code>L.fct &lt;- function(m) {log(m)}</code> and
(ii) set <code>L.mean = TRUE</code>.
</p>
<p>By default, <code>L.fct</code> is treated as a function of the table
probabilities <code class="reqn">p</code> (even if the argument in the <code>L.fct</code>
function object is <code>m</code> ). If <code>L.mean</code> is set to
<code>L.mean = TRUE</code>, then <code>L.fct</code> is treated as a function
of the expected counts <code class="reqn">m</code>. Default: <code>L.fct = NULL</code> means
no constraints of the form <code class="reqn">L(p) = X\beta</code> are imposed.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_link">link</code></td>
<td>
<p>Alias for the argument <code>L.fct</code>. Argument <code>link</code> is
secondary to the primary argument <code>L.fct</code> in the following
senses: If <code>link</code> and <code>L.fct</code> are not equal, <code>L.fct</code>
is used.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_l.mean">L.mean</code></td>
<td>
<p>Logical argument. If <code>L.mean = FALSE</code> (the default), <code>L.fct</code>
is treated as a function of <code class="reqn">p</code>. If <code>L.mean = TRUE</code>,
<code>L.fct</code> is treated as a function of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_x">X</code></td>
<td>
<p>HLP model design matrix, assumed to be full rank. Default:
<code>X = NULL</code>; i.e., it is left unspecified and unused.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum
membership identifier. Default: <code>strata = rep(1, length(y))</code>;
i.e. the default is the single stratum (non-stratified) setting.
Examples: <code>strata = A</code>, or
<code>strata = c(1,1,1,2,2,2,3,3,3)</code>, or
<code>strata = paste(sep = "", "A=", A, ", B=", B)</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum have
fixed sample sizes. It can equal one of the keywords,
<code>fixed.strata = "all"</code> or <code>fixed.strata = "none"</code>,
or it can be a vector of stratum membership identifiers,
e.g. <code>fixed.strata = c(1,3)</code> or
<code>fixed.strata = c("pop1", "pop5")</code>. Default:
<code>fixed.strata = "all"</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_check.homog.tol">check.homog.tol</code></td>
<td>
<p>Round-off tolerance for <code class="reqn">Z</code> homogeneity check.
Default: <code>check.homog.tol = 1e-9</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_check.hlp.tol">check.HLP.tol</code></td>
<td>
<p>Round-off tolerance for HLP link status check. Default:
<code>check.HLP.tol = 1e-9</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations. Default: <code>maxiter = 100</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_step">step</code></td>
<td>
<p>Step-size value. Default: <code>step = 1</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_change.step.after">change.step.after</code></td>
<td>
<p>If the score value increases for more than
<code>change.step.after</code> iterations in a row, then
the initial step size is halved. Default:
<code>change.step.after = 0.25 * maxiter</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_y.eps">y.eps</code></td>
<td>
<p>Non-negative constant to be temporarily added to the original
counts in <code>y</code>. Default: <code>y.eps = 0</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_iter.orig">iter.orig</code></td>
<td>
<p>Iteration at which the original counts will be used. Default:
<code>iter.orig = 5</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_m.initial">m.initial</code></td>
<td>
<p>Initial estimate of <code class="reqn">m</code>. Default: <code>m.initial = y</code>.
See Input Note 6 below.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_norm.diff.conv">norm.diff.conv</code></td>
<td>
<p>Convergence criteria value; see <code>norm.diff</code> in the
<b>Value</b> section. Default: <code>norm.diff.conv = 1e-6</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_norm.score.conv">norm.score.conv</code></td>
<td>
<p>Convergence criteria value; see <code>norm.score</code> in the
<b>Value</b> section. Default:
<code>norm.score.conv = 1e-6</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The variable <code>score.diff.iter</code> keeps track of
how long <code>norm.score</code> is smaller than
<code>norm.score.conv</code>, but <code>norm.diff</code> is
greater than <code>norm.diff.conv</code>. If this is the
case too long (i.e.
<code>score.diff.iter &gt;= max.score.diff.iter</code>),
then stop the iterations because the solution likely
includes at least one ML fitted value of <code class="reqn">0</code>.
Default: <code>max.score.diff.iter = 10</code>.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_derht.fct">derht.fct</code></td>
<td>
<p>Function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h(\cdot)</code> with respect
to <code class="reqn">m</code>. If <code class="reqn">h(\cdot)</code> maps from <code class="reqn">R^p</code> to <code class="reqn">R^q</code>
(i.e. there are <code class="reqn">q</code> constraints), then <code>derht.fct</code>
returns a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix of partial derivatives.
Default: <code>derht.fct = NULL</code>. This means that the
derivative is calculated numerically.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_derlt.fct">derLt.fct</code></td>
<td>
<p>Function object that computes analytic derivative of the
transpose of the link function <code class="reqn">L(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code class="reqn">L(\cdot)</code> maps from <code class="reqn">R^p</code> to <code class="reqn">R^q</code> (i.e.
there are <code class="reqn">q</code> link components), then <code>derLt.fct</code>
returns a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix of partial derivatives.
Default: <code>derLt.fct = NULL</code>, i.e. by default this
derivative is calculated numerically.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_pdlambda">pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence
statistic.</p>
</td></tr>
<tr><td><code id="mph.fit_+3A_verbose">verbose</code></td>
<td>
<p>Logical argument. If <code>verbose = FALSE</code>, do not print out
iteration information. If <code>verbose = TRUE</code>, then
iteration information is printed out. Default:
<code>verbose = FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the following, let <code class="reqn">y</code> be the vector of contingency table counts, <code class="reqn">p</code>
be the unknown vector of contingency table probabilities, <code class="reqn">s</code> be a vector of
strata identifiers, and <code class="reqn">F</code> be the set of strata with a priori fixed sample
sizes.
</p>
<p>Although <code>mph.fit</code> can fit more general models (see below), two important
special cases include:
</p>

<ul>
<li><p> MPH (Special-Case): <code class="reqn">y</code> is
a realization of random vector <code class="reqn">Y</code>, where <code class="reqn">Y \sim MP(\gamma, p | \texttt{strata} = s, \texttt{fixed} = F)</code>, <code class="reqn">h(p) = 0</code>.
</p>
</li>
<li><p> HLP (Special-Case): <code class="reqn">y</code> is
a realization of random vector <code class="reqn">Y</code>, where <code class="reqn">Y \sim MP(\gamma, p | \texttt{strata} = s, \texttt{fixed} = F)</code>, <code class="reqn">L(p) = X \beta</code>.
</p>
</li></ul>

<p>Here, <code class="reqn">h(\cdot)</code> is a smooth constraint function and <code class="reqn">L(\cdot)</code> is a smooth link function. It is assumed that the constraints in <code class="reqn">h(p) = 0</code> are non-redundant so that the Jacobian, <code class="reqn">\partial h'(p) / \partial p</code>, is full column rank.
</p>
<p>The link <code class="reqn">L(\cdot)</code> is allowed to be many-to-one and row-rank deficient, so this
HLP model is quite general. It is only required that the implied constraints,
<code class="reqn">U'L(p) = 0</code>, where <code class="reqn">null(U') = span(X)</code>, are non-redundant.
</p>
<p>Here, MP stands for the multinomial-Poisson distribution. The parameters are
<code class="reqn">\gamma</code>, the vector of expected sample sizes, and <code class="reqn">p</code>, the vector of table
probabilities.
</p>
<p>The notation </p>
<p style="text-align: center;"><code class="reqn">Y \sim MP(\gamma, p | \texttt{strata} = s, \texttt{fixed} = F)</code>
</p>
<p> means that the random vector <code class="reqn">Y</code> is composed of independent blocks of multinomial and/or Poisson random variables. The strata vector <code class="reqn">s</code> determines the blocks and <code class="reqn">F</code> determines which blocks are multinomial and which blocks comprise independent Poisson random variables. More specifically, suppose there are <code class="reqn">K</code> strata, so <code class="reqn">s</code> contains <code class="reqn">K</code> distinct strata identifiers. The components in
<code class="reqn">Y</code> corresponding to <code class="reqn">s = \texttt{identifier[k]}</code> make up a block. If
<code>identifier[k]</code> is included in <code class="reqn">F</code>, then this block has a multinomial distribution and <code class="reqn">\gamma_{k}</code> is the a priori known, i.e. fixed, sample size. If <code>identifier[k]</code> is not in <code class="reqn">F</code>, then this block comprises independent Poisson random variables and <code class="reqn">\gamma_{k}</code> is an unknown expected sample size.
</p>
<p>Note: Given the observed counts <code class="reqn">y</code>, the pair <code class="reqn">\texttt{(strata, fixed)} = (s, F)</code>
contains the same information as the sampling plan triple <code class="reqn">(Z, Z_{F}, n_{F})</code> described in Lang (2004, 2005). Specifically, <code class="reqn">Z = Z(s)</code>, the strata/population matrix, is determined by <code class="reqn">s</code>. <code class="reqn">Z_{F} = Z_{F}(s, F)</code>, the sampling constraint matrix, is determined by <code class="reqn">s</code> and <code class="reqn">F</code>. <code class="reqn">n_{F} = Z_{F}'y</code> is the vector of a priori fixed sample sizes.
</p>
<p>Special case MP distributions include...
</p>

<ul>
<li><p> Full Multinomial:
<code class="reqn">MP(\gamma, p | \texttt{strata = 1, fixed = "all"})</code>.
A simple random sample of fixed size <code class="reqn">\gamma</code> is taken from a single strata
(population).
</p>
</li>
<li><p> Product Multinomial:
<code class="reqn">MP(\gamma, p | \texttt{strata = s, fixed = "all"})</code>.
A stratified random sample of fixed sample sizes <code class="reqn">\gamma = (\gamma_{1}, \ldots, \gamma_{K})'</code> is taken from the <code class="reqn">K</code> strata determined by <code class="reqn">s</code>.
</p>
</li>
<li><p> Full Poisson:
<code class="reqn">MP(\gamma, p | \texttt{strata = 1, fixed = "none"})</code>.
A simple random sample is taken from a single strata (population). The sample size is random and follows a Poisson distribution with unknown mean <code class="reqn">\gamma</code>.
</p>
</li>
<li><p> Product Poisson:
<code class="reqn">MP(\gamma, p | \texttt{strata = s, fixed = "none"})</code>.
A stratified random sample is taken from <code class="reqn">K</code> strata. The sample sizes are all random and distributed as Poissons with unknown means in
<code class="reqn">\gamma = (\gamma_{1}, \ldots, \gamma_{K})'</code>.
</p>
</li></ul>

<p>Specifying the MP distribution in <code>mph.fit</code>...
</p>
<p>The user need only enter <code>(strata, fixed.strata)</code>, the input variables corresponding to <code class="reqn">(s, F)</code>. Keywords, <code>fixed.strata = "all"</code> [<code>"none"</code>] means that all [none] of the strata have a priori fixed sample sizes.
</p>
<p>To fit MPH (Special Case), the user must enter the counts <code>y</code>, the constraint function <code>h.fct</code> (alias <code>constraint</code>), and the sampling plan variables, <code>strata</code> and <code>fixed.strata</code>. Note: The user can omit the sampling plan variables if the default, multinomial sampling <code>(strata = 1, fixed = "all")</code>, can be assumed.
</p>
<p>To fit HLP (Special Case), the user must enter the counts <code>y</code>, the link function <code>L.fct</code> (alias <code>link</code>), the model matrix <code>X</code>, and the sampling plan variables, <code>strata</code> and <code>fixed.strata</code>. Note: The user can omit the sampling plan variables if the default, multinomial sampling, can be assumed.
</p>
<p>IMPORTANT: When specifying the model and creating the input objects for
<code>mph.fit</code>, keep in mind that the interpretation of the table probabilities <code class="reqn">p</code> depends on the sampling plan!
</p>
<p>Specifically, if the <code class="reqn">i^{th}</code> count <code class="reqn">y_{i}</code> is in block <code class="reqn">k</code> (i.e. corresponds with strata <code>identifier[k]</code>), then the <code class="reqn">i^{th}</code> table probability <code class="reqn">p_{i}</code> is the conditional probability defined as <code class="reqn">p_{i}</code> = probability of a Type <code class="reqn">i</code> outcome GIVEN that the outcome is one of the types in stratum <code class="reqn">k</code>.
</p>
<p>For example, in an <code class="reqn">I</code>-by-<code class="reqn">J</code> table with row variable <code class="reqn">A</code> and column variable <code class="reqn">B</code>, if row-stratified sampling is used, the table probabilities have the interpretation, <code class="reqn">p_{ij} =</code> prob of a Type <code class="reqn">(i, j)</code> outcome GIVEN that the outcome is one of the types in stratum <code class="reqn">i</code> (i.e. one of <code class="reqn">(i, 1), \ldots, (i, J)</code>) <code class="reqn"> = P(A = i, B = j | A = i)</code> <code class="reqn"> = P(B = j | A = i)</code>. For column-stratified sampling, <code class="reqn">p_{ij} = P(A = i | B = j)</code>. And for non-stratified sampling, <code class="reqn">p_{ij} = P(A = i, B = j)</code>.
</p>
<p>Log-Linear Models: Log-linear models specified as <code class="reqn">\log(p) = X\beta</code>, are HLP models.
</p>
<p>As with any HLP model, <code class="reqn">\log(p) = X\beta</code> can be restated as a collection of constraints; specifically, <code class="reqn">\log(p) = X\beta</code> is equivalent to <code class="reqn">h(p) = U'\log(p) = 0</code>, where <code class="reqn">null(U') = span(X)</code>. Noting that <code class="reqn">Z'p = 1</code>, we see that to avoid redundant constraints, <code class="reqn">span(X)</code> should contain <code class="reqn">span(Z)</code>. Loosely, fixed-by-sampling-design parameters should be included.
</p>
<p>Log-linear models of the form <code class="reqn">\log(p) = X\beta</code> are simple to fit using <code>mph.fit</code>. For example,<br /> <code>&gt; mph.fit(y, link = "logp", X = model.matrix(~ A + B))</code>,<br />
or, equivalently,<br /> <code>&gt; mph.fit(y, link = function(p) {log(p)}, X = model.matrix(~ A + B))</code>.
</p>
<p>MORE GENERAL MPH and HLP MODELS...
</p>
<p>Instead of <code class="reqn">(\gamma, p)</code>, the MP distribution can alternatively be parameterized in terms of the vector of expected table counts, <code class="reqn">m = E(Y)</code>. Formally, <code class="reqn">(\gamma, p)</code> and <code class="reqn">m</code> are in one-to-one correspondence and satisfy:
</p>
<p style="text-align: center;"><code class="reqn">m = Diag(Z\gamma)p,</code>
</p>
<p> and </p>
<p style="text-align: center;"><code class="reqn">\gamma = Z'm, p = Diag^{-1}(ZZ'm)m.</code>
</p>
<p> Here, <code class="reqn">Z = Z(s)</code> is the <code class="reqn">c</code>-by-<code class="reqn">K</code> strata/population matrix determined by strata vector <code class="reqn">s</code>. Specifically, <code class="reqn">Z_{ik}  =  I\{s_{i} = \texttt{identifier[k]}\}</code>.
</p>
<p>The MPH (Special-Case) Model given above is a special case because it constrains the expected counts <code class="reqn">m</code> only through the table probabilities <code class="reqn">p</code>. Similarly, the HLP (Special-Case) Model given above is a special case because it uses a link function that depends on <code class="reqn">m</code> only through the table probabilities <code class="reqn">p</code>.
</p>
<p>More generally, <code>mph.fit</code> computes maximum likelihood estimates and fit
statistics for MPH and HLP models of the form...
</p>

<ul>
<li><p>  MPH: <code class="reqn">y</code> is
a realization of random vector <code class="reqn">Y</code>, where <code class="reqn">Y \sim MP(\gamma, p | \texttt{strata} = s, \texttt{fixed} = F), h(m) = 0</code>.
</p>
</li>
<li><p>  HLP: <code class="reqn">y</code> is
a realization of random vector <code class="reqn">Y</code>, where <code class="reqn">Y \sim MP(\gamma, p | \texttt{strata} = s, \texttt{fixed} = F), L(m) = X\beta</code>.
</p>
</li></ul>

<p>Here, <code class="reqn">h(\cdot)</code> is a smooth constraint function that must also be <code class="reqn">Z</code> (i.e. strata <code class="reqn">s</code>) homogeneous. <code class="reqn">L(\cdot)</code> is a smooth link function that must also satisfy the HLP conditions with respect to <code class="reqn">Z</code> (i.e. strata <code class="reqn">s</code>) and <code class="reqn">X</code>.
That is,
</p>

<ul>
<li><p> (1) <code class="reqn">L(\cdot)</code> has HLP link status with respect to <code class="reqn">Z</code>, and
</p>
</li>
<li><p> (2) The implied constraint function <code class="reqn">h(m) = U'L(m)</code> is <code class="reqn">Z</code> homogeneous. Here, <code class="reqn">null(U') = span(X)</code>.
</p>
</li></ul>

<p>Here, (1) <code class="reqn">L(\cdot)</code> has HLP link status with respect to <code class="reqn">Z</code> if, for <code class="reqn">m = Diag(Z\gamma) p</code>,
</p>

<ul>
<li><p> (1)(a) <code class="reqn">L(m) = a(\gamma) + L(p)</code>, where
<code class="reqn">a(\gamma_{1}/\gamma_{2}) - a(1) = a(\gamma_{1}) - a(\gamma_{2})</code>, i.e. <code class="reqn">a(\gamma)</code> has the form
<code class="reqn">C \log \gamma + \texttt{constant}</code>;
or
</p>
</li>
<li><p> (1)(b) <code class="reqn">L(m) = G(\gamma) L(p)</code>, where <code class="reqn">G(\gamma)</code> is a diagonal matrix with
diagonal elements that are powers of the <code class="reqn">\gamma</code> elements, i.e. <code class="reqn">L(\cdot)</code> is
<code class="reqn">Z</code> homogeneous (see Lang (2004));
or
</p>
</li>
<li><p> (1)(c) The components of <code class="reqn">L(\cdot)</code> are a mixture of types (a) and (b):
<code class="reqn">L_{j}(m) = a_{j}(\gamma) + L_{j}(p)</code> or <code class="reqn">L_{j}(m) = G_{j}(\gamma) L_{j}(p)</code>,
<code class="reqn">j = 1, \ldots, l</code>.
</p>
</li></ul>

<p>Lang (2005) described HLP models that satisfied (1)(a) and (2), but the definition
of HLP models can be broadened to include those models satisfying (1) and (2).
That is, HLP models can be defined so they also include models that satisfy (1)(b)
and (2) or (1)(c) and (2). <code>mph.fit</code> uses this broader definition
of HLP Model.
</p>
<p>Note: The input variable <code>h.mean</code> must be set to <code>TRUE</code> to fit this more general MPH model. Similarly, the input variable <code>L.mean</code> must be set to
<code>TRUE</code> to fit this more general HLP model. (An exception: If the link function
is specified using the keyword <code>"logm"</code> then <code>L.mean</code> is automatically
set to <code>TRUE</code>.)
</p>
<p>Note: <code>mph.fit</code> carries out &quot;necessary-condition&quot; checks
of <code class="reqn">Z</code> homogeneity of <code class="reqn">h(\cdot)</code> and HLP link status of <code class="reqn">L(\cdot)</code> for these general models.
</p>
<p>Log-Linear Models: Log-linear models of the form <code class="reqn">\log(m) = X\beta</code> are HLP models
provided the <code class="reqn">span(X)</code> contains the <code class="reqn">span(Z)</code>. Loosely, provided fixed-by-design
parameters are included, the log-linear model is a special case HLP model.
</p>
<p>Log-linear models of the form <code class="reqn">\log(m) = X\beta</code> are simple to fit using
<code>mph.fit</code>. For example,<br />
<code>&gt; mph.fit(y, link = "logm", X = model.matrix(~ A + B))</code>,<br />
or, equivalently,<br />
<code>&gt; mph.fit(y, link = function(m) {log(m)}, L.mean = TRUE, X = model.matrix(~ A + B))</code>.
</p>
<p>Note: Most reasonable generalized log-linear models, which have the form
<code class="reqn">L(m) = C \log Mm  = X\beta</code>, are also HLP models. See Lang (2005).
</p>


<h3>Value</h3>

<p><code>mph.fit</code> returns a list, which includes the following objects:
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>Vector of counts used in the algorithm for ML estimation. Usually, this
vector is identical to the observed table counts.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Vector of ML fitted values.</p>
</td></tr>
<tr><td><code>covm</code></td>
<td>
<p>Approximate covariance matrix of fitted values.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Vector of cell probability ML estimates.</p>
</td></tr>
<tr><td><code>covp</code></td>
<td>
<p>Approximate covariance matrix of cell probability estimators.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Vector of Lagrange multiplier ML estimates.</p>
</td></tr>
<tr><td><code>covlambda</code></td>
<td>
<p>Approximate covariance matrix of multiplier estimators.</p>
</td></tr>
<tr><td><code>resid</code></td>
<td>
<p>Vector of raw residuals (i.e. observed minus fitted counts).</p>
</td></tr>
<tr><td><code>presid</code></td>
<td>
<p>Vector of Pearson residuals.</p>
</td></tr>
<tr><td><code>adjresid</code></td>
<td>
<p>Vector of adjusted residuals.</p>
</td></tr>
<tr><td><code>covresid</code></td>
<td>
<p>Approximate covariance matrix of raw residuals.</p>
</td></tr>
<tr><td><code>Gsq</code></td>
<td>
<p>Likelihood ratio statistic for testing <code class="reqn">H_{0}: h(m) = 0</code> vs.
<code class="reqn">H_{1}:</code> not <code class="reqn">H_{0}</code>.</p>
</td></tr>
<tr><td><code>Xsq</code></td>
<td>
<p>Pearson's score statistic (same as Lagrange multiplier statistic)
for testing <code class="reqn">H_{0}: h(m) = 0</code> vs. <code class="reqn">H_{1}:</code> not <code class="reqn">H_{0}</code>.</p>
</td></tr>
<tr><td><code>Wsq</code></td>
<td>
<p>Generalized Wald statistic for testing <code class="reqn">H_{0}: h(m) = 0</code> vs.
<code class="reqn">H_{1}:</code> not <code class="reqn">H_{0}</code>.</p>
</td></tr>
<tr><td><code>PD.stat</code></td>
<td>
<p>Power-divergence statistic (with index parameter <code>pdlambda</code>)
for testing <code class="reqn">H_{0}: h(m) = 0</code> vs. <code class="reqn">H_{1}:</code> not <code class="reqn">H_{0}</code>.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom associated with <code>Gsq</code>, <code>Xsq</code>, and <code>PD.stat</code>.
<code class="reqn">df = \dim(h)</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Vector of HLP model parameter ML estimates.</p>
</td></tr>
<tr><td><code>covbeta</code></td>
<td>
<p>Approximate covariance matrix of HLP model parameter estimators.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>Vector of HLP model link ML estimates.</p>
</td></tr>
<tr><td><code>Lobs</code></td>
<td>
<p>Vector of HLP model observed link values, <code class="reqn">L(y)</code>.</p>
</td></tr>
<tr><td><code>covL</code></td>
<td>
<p>Approximate covariance matrix of HLP model link estimators.</p>
</td></tr>
<tr><td><code>Lresid</code></td>
<td>
<p>Vector of adjusted link residuals of the form
</p>
<p style="text-align: center;"><code class="reqn">(L(\texttt{obs}) - L(\texttt{fitted})) / ase(L(\texttt{obs}) - L(\texttt{fitted})).</code>
</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of update iterations performed.</p>
</td></tr>
<tr><td><code>norm.diff</code></td>
<td>
<p>Distance between last and second last <code>theta</code> iterates
(<code>theta</code> is the vector of log fitted values and Lagrange
multipliers).</p>
</td></tr>
<tr><td><code>norm.score</code></td>
<td>
<p>Distance between the score vector and zero.</p>
</td></tr>
<tr><td><code>h.fct</code></td>
<td>
<p>Constraint function used in algorithm.</p>
</td></tr>
<tr><td><code>h.input.fct</code></td>
<td>
<p>Constraint function as originally input.</p>
</td></tr>
<tr><td><code>h.mean</code></td>
<td>
<p>Logical variable. If <code>h.mean = FALSE</code>, <code>h.fct</code> is treated as a
function of <code class="reqn">p</code>. If <code>h.mean = TRUE</code>, <code>h.fct</code> is treated as
a function of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code>derht.fct</code></td>
<td>
<p>Analytic function used in algorithm that computes derivative of
transpose of constraint function <code class="reqn">h</code>.</p>
</td></tr>
<tr><td><code>L.fct</code></td>
<td>
<p>Link function used in algorithm.</p>
</td></tr>
<tr><td><code>L.input.fct</code></td>
<td>
<p>Link function as originally input.</p>
</td></tr>
<tr><td><code>L.mean</code></td>
<td>
<p>Logical variable. If <code>L.mean = FALSE</code>, <code>L.fct</code> is treated as a
function of <code class="reqn">p</code>. If <code>L.mean = TRUE</code>, <code>L.fct</code> is treated as
a function of <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code>derLt.fct</code></td>
<td>
<p>Analytic function used in algorithm that computes derivative of
transpose of link function <code class="reqn">L</code>.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>HLP model design matrix used in algorithm.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Orthogonal complement of design matrix <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code>triple</code></td>
<td>
<p>A list object containing the sampling plan triple <code class="reqn">(Z, Z_{F}, n)</code>,
where <code class="reqn">Z</code> is the population (or strata) matrix, <code class="reqn">Z_{F}</code> is the
sampling constraint matrix, and <code class="reqn">n</code> is the collection of fixed
sample sizes.</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p><code>strata</code> variable used as input.</p>
</td></tr>
<tr><td><code>fixed.strata</code></td>
<td>
<p>The strata corresponding to fixed sample sizes.</p>
</td></tr>
<tr><td><code>warn.message</code></td>
<td>
<p>Message stating whether or not the original counts were used.</p>
</td></tr>
<tr><td><code>warn.message.score</code></td>
<td>
<p>Message stating whether or not the norm score convergence
criterion was met.</p>
</td></tr>
<tr><td><code>warn.message.diff</code></td>
<td>
<p>Message stating whether or not the norm diff convergence
criterion was met.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Input Notes:
</p>

<ol>
<li><p> CONSTRAINT FUNCTION.
</p>
<p><code>constraint</code> is an alias for <code>h.fct</code>. If <code>h.fct</code> is a function object, it must return a column vector.
</p>
<p>By default, <code>h.fct</code> is treated as a function of the table probabilities
<code class="reqn">p</code>. To treat <code>h.fct</code> as a function of the expected counts <code class="reqn">m</code>,
you must set <code>h.mean = TRUE</code> (by default, <code>h.mean = FALSE</code>).
</p>
<p>The fitting algorithm will fail if the constraints in <code>h.fct</code> <code class="reqn">= 0</code>
are redundant.
</p>
</li>
<li><p> MODEL WITH NO CONSTRAINTS.
</p>
<p>The model with no constraints can be specified using <code>h.fct = 0</code>. The
no-constraint model is the default when neither <code>h.fct</code> nor <code>L.fct</code>        are input (i.e. when <code>h.fct = NULL</code> and <code>L.fct = NULL</code>).
</p>
</li>
<li><p> HLP MODEL SPECIFICATION.
</p>
<p><code>link</code> is an alias for <code>L.fct</code>. For HLP models, both <code>L.fct</code> and <code>X</code> must be specified. The design matrix <code class="reqn">X</code> must be of full column rank. <code>mph.fit</code> recognizes two keywords for link specification, <code>"logp"</code> and <code>"logm"</code>. These are convenient for log-linear modeling. If <code>L.fct</code> is a function object, it must return a column vector.
</p>
<p>By default, <code>L.fct</code> is treated as a function of the table probabilities
<code class="reqn">p</code>. To treat <code>L.fct</code> as a function of the expected counts <code class="reqn">m</code>,
you must set <code>L.mean = TRUE</code> (by default, <code>L.mean = FALSE</code>).
</p>
<p>The constraint function <code>h.fct</code> is typically left unspecified for HLP
models, but it need not be.
</p>
<p>If <code>h.fct</code> is left unspecified, it is created within the program as
<code>h.fct(m) &lt;- function(m) {t(U) %*% L.fct(m)}</code>, where matrix
<code class="reqn">U</code> is an orthogonal complement of <code class="reqn">X</code>. If <code>h.fct</code> is specified, the constraints implied by <code>L.fct</code><code class="reqn">(p) = X\beta</code>, or <code>L.fct</code><code class="reqn">(m) = X\beta</code>, are ignored.
</p>
<p>Note: Although the HLP constraints are ignored when <code>h.fct</code> is
specified, estimates of <code class="reqn">\beta</code> and the link are computed under the
model with constraints <code>h.fct</code><code class="reqn">(p) = 0</code> or
<code>h.fct</code><code class="reqn">(m) = 0</code>.
</p>
<p>The fitting algorithm will fail to converge if the implied constraints,
<code class="reqn">U' </code><code> L.fct </code><code class="reqn"> = 0</code>, include redundancies.
</p>
</li>
<li><p> EXTENDED ML ESTIMATES.
</p>
<p>When ML estimates are non-existent owing to zero counts, <code>norm.diff</code>
will not converge to zero, instead it tends to level off at some constant
positive value. This is because at least one ML fitted value is <code class="reqn">0</code>,
which on the log scale is <code class="reqn">\log(0) = -\infty</code>, and the log-scale iterates
slowly move toward <code class="reqn">-\infty</code>. One solution to this problem is to set the
convergence value <code>norm.diff.conv</code> to some large number so only the
score convergence criterion is used. In this case, the algorithm often
converges to a solution that can be viewed as an extended ML estimate, for
which <code class="reqn">0</code> estimates are allowed. <code>mph.fit</code> automates the
detection of such problems. See the description of the input variable
<code>max.score.diff.iter</code> above and the MISC COMPUTATIONAL NOTES in <a href="https://homepage.divms.uiowa.edu/~jblang/mph.fitting/mph.fit.documentation.htm">
<code>mph.fit</code> online documentation</a>.
</p>
</li>
<li><p> CONVERGENCE PROBLEMS / FINE TUNING ITERATIONS.
</p>
<p>First check to make sure that the model is correctly specified and redundant
constraints are avoided.
</p>
<p>When ML estimates exist, but there are non-convergence problems (perhaps
caused by zero counts), a modification to the tuning parameters <code>step</code>,
<code>change.step.after</code>, <code>y.eps</code>, and/or <code>iter.orig</code> will often
lead to convergence.
</p>
<p>With zero counts, it might help to set <code>y.eps = 0.1</code> (or some other
positive number) and <code>iter.orig = 5</code> (the default). This tells the
program to initially use <code>y + y.eps</code> rather than the original counts
<code>y</code>. At iteration <code class="reqn">5</code> <code class="reqn">=</code> <code>iter.orig</code>, after the algorithm
has had time to move toward a non-boundary solution, the original counts are
again used.
</p>
<p>To further mitigate non-convergence problems, the parameter <code>step</code> can
be set to a smaller value (default: <code>step = 1</code>) so the iterates do not
change as much.
</p>
</li>
<li><p> The initial estimate of <code class="reqn">m</code> is actually
<code>m.initial + y.eps + 0.01 * ((m.initial + y.eps) == 0)</code>. The program
defaults are <code>m.initial = y</code> and <code>y.eps = 0</code>. Note: If
<code>m.initial &gt; 0</code> and <code>y.eps = 0</code>, then the initial estimate of
<code class="reqn">m</code> is simply <code>m.initial</code>.
</p>
</li></ol>

<p>Output Notes:
</p>

<ol>
<li><p> ITERATION HISTORY.
</p>
<p>An iteration history is printed out when <code>verbose</code> is set equal to
<code>TRUE</code>. A single line of the history looks like the following:
</p>
<p>&quot;<code>iter= 18[0] norm.diff= 3.574936e-08 norm.score= 1.901705e-15</code>&quot;.
</p>
<p>Here, <code>iter</code> is the number of update iterations performed. The number
in <code>[]</code> gives the number of step size searches required within each
iteration. <code>norm.diff</code> and <code>norm.score</code> are defined above.
Finally, the time elapsed is output. Note: For the model with no
restrictions (<code>h.fct = 0</code>), there are no step size changes.
</p>
</li>
<li><p> STORING and VIEWING RESULTS.
</p>
<p>To store the results of <code>mph.fit</code>, issue a command like the following
example
</p>
<p><code>&gt;  results &lt;-  mph.fit(y, h.fct = h.fct)</code>
</p>
<p>Use program <code>mph.summary</code> to view the results of <code>mph.fit</code>.
Specifically, if the results of <code>mph.fit</code> are saved in object
<code>results</code>, submit the command <code>mph.summary(results)</code>
[or <code>mph.summary(results, TRUE)</code> or <code>mph.summary(results, TRUE, TRUE)</code>
depending on how much of the output you need to see.]
</p>
</li>
<li><p>  The output objects <code>beta</code>, <code>covbeta</code>, <code>L</code>, <code>covL</code>,
and <code>Lresid</code> will be set to <code>NA</code> unless an HLP model is
specified (i.e. <code>L.fct</code> and <code>X</code> are input).
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Joseph B. Lang</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>
<p>Lang, J. B. (2005) Homogeneous linear predictor models for contingency tables, <em>Journal of the American Statistical Association</em>, <b>100</b>, 121&ndash;134.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mph.summary">mph.summary</a></code>, <code><a href="#topic+create.Z.ZF">create.Z.ZF</a></code>, <code><a href="#topic+create.U">create.U</a></code>, <code><a href="#topic+num.deriv.fct">num.deriv.fct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Listed below is a collection of Basic Examples:
# https://homepage.divms.uiowa.edu/~jblang/mph.fitting/mph.basic.numerical.examples.htm

# Another collection of Less Basic Examples is online:
# https://homepage.divms.uiowa.edu/~jblang/mph.fitting/mph.numerical.examples.htm


# EXAMPLE 1. Test whether a binomial probability equals 0.5.
#
# y = (15, 22) &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "all");
# i.e. Y ~ multinomial.
#
# In other symbols,
#
# y = (15, 22) &lt;- Y = (Y[1], Y[2]) ~ multinomial(37, p = (p[1], p[2])).
#
# GOAL: Test H0: p[1] = 0.5 vs. H1: not H0.

a1 &lt;- mph.fit(y = c(15, 22), constraint = function(p) {p[1] - 0.5})

# Alternative specifications...
a2 &lt;- mph.fit(y = c(15, 22), constraint = function(p) {p[1] - p[2]})
a3 &lt;- mph.fit(y = c(15, 22), constraint = function(p) {log(p[1] / p[2])})
a4 &lt;- mph.fit(y = c(15, 22), constraint = function(m) {m[1] - m[2]},
              h.mean = TRUE)
a5 &lt;- mph.fit(y = c(15, 22), link = function(p) {p}, X = matrix(1, 2, 1))
a6 &lt;- mph.fit(y = c(15, 22), link = "logm", X = matrix(1, 2, 1))

# Alternatively, assume that
#
# y = (15, 22) &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "none");
# i.e. Y ~ indep Poisson.
#
# In other symbols,
#
# y = (15, 22) &lt;- Y = (Y[1], Y[2]), where
# Y[i] indep ~ Poisson(gamma * p[i]), i = 1, 2.
#
# GOAL: Test H0: p[1] = 0.5 vs. H1: not H0.

b1 &lt;- mph.fit(y = c(15, 22), constraint = function(p) {p[1] - 0.5},
              fixed.strata = "none")

mph.summary(a1, TRUE)
mph.summary(b1, TRUE)


# EXAMPLE 2. Test whether a multinomial probability vector is uniform.
#            Test whether a multinomial probability vector equals a
#            specific value.
#
# y &lt;- Y = (Y[1], ..., Y[6]) ~ MP(gamma, p | strata = 1, fixed = "all");
# i.e. Y ~ multinomial.
#
# In other symbols,
#
# y &lt;- Y ~ multinomial(15, p = (p[1], ..., p[6]))
#
# GOAL: Test H0: p[1] = p[2] = ... = p[6] vs. H1: not H0.

y &lt;- rmultinom(1, 15, rep(1, 6))
a1 &lt;- mph.fit(y, L.fct = function(p) {p}, X = matrix(1, 6, 1),
              y.eps = 0.1)

# Alternative specification...
a2 &lt;- mph.fit(y, h.fct = function(p) {as.matrix(p[-6] - 1/6)},
              y.eps = 0.1)

mph.summary(a1, TRUE)
mph.summary(a2, TRUE)

# Test whether p = (1, 2, 3, 1, 2, 3) / 12 .

p0 &lt;- c(1, 2, 3, 1, 2, 3) / 12
b &lt;- mph.fit(y, h.fct = function(p) {as.matrix(p[-6] - p0[-6])},
             y.eps = 0.1)
mph.summary(b, TRUE)


# EXAMPLE 3. Test whether a multinomial probability vector satisfies a
#            particular constraint.
#
# Data Source: Agresti 25:2002.
#
# y = (30, 63, 63) &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "all");
# i.e. Y ~ multinomial.
#
# In other symbols,
#
# y = (30, 63, 63) &lt;- Y ~ multinomial(156, p = (p[1], p[2], p[3]))
#
# GOAL: Test H0: p[1] + p[2] = p[1] / (p[1] + p[2]) vs. H1: not H0.

y &lt;- c(30, 63, 63)
h.fct &lt;- function(p) {
    (p[1] + p[2]) - p[1] / (p[1] + p[2])
}
a &lt;- mph.fit(y, h.fct = h.fct)
mph.summary(a, TRUE)


# EXAMPLE 4. Test of Independence in a 2-by-2 Table.
#
# y = (y[1, 1], y[1, 2], y[2, 1], y[2, 2]) = (25, 18, 13, 21)
#   &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "all");
# i.e. Y ~ multinomial.
#
# In other symbols,
# y = (y[1, 1], y[1, 2], y[2, 1], y[2, 2])
#   &lt;- Y ~ multinomial(77, p = (p[1, 1], p[1, 2], p[2, 1], p[2, 2]))
#
# GOAL: Test H0: p[1, 1] * p[2, 2] / p[1, 2] / p[2, 1] = 1
#        vs. H1: not H0.

d &lt;- data.frame(A = c(1, 1, 2, 2), B = c(1, 2, 1, 2),
                count = c(25, 18, 13, 21))

a1 &lt;- mph.fit(y = d$count, h.fct = function(p)
              {log(p[1] * p[4] / p[2] / p[3])})

# Alternative specifications of independence....
a2 &lt;- mph.fit(y = d$count, h.fct = function(p)
              {p &lt;- matrix(p, 2, 2, byrow = TRUE);
               log(p[1, 1] * p[2, 2] / p[1, 2] / p[2, 1])})
a3 &lt;- mph.fit(y = d$count, h.fct = function(p)
              {p[1] * p[4] / p[2] / p[3] - 1})
a4 &lt;- mph.fit(y = d$count, h.fct = function(p)
              {p[1] / (p[1] + p[2]) - p[3] / (p[3] + p[4])})
a5 &lt;- mph.fit(y = d$count, L.fct = "logm",
              X = model.matrix(~ A + B, data = d))

# Suppose we wished to output observed and fitted values of
# log OR, OR, and P(B = 1 | A = 1) - P(B = 1 | A = 2)...

L.fct &lt;- function(p) {
  L &lt;- as.matrix(c(
    log(p[1] * p[4] / p[2] / p[3]),
    p[1] * p[4] / p[2] / p[3],
    p[1] / (p[1] + p[2]) - p[3] / (p[3] + p[4])
  ))
  rownames(L) &lt;- c("log OR", "OR",
                   "P(B = 1 | A = 1) - P(B = 1 | A = 2)")
  L
}

a6 &lt;- mph.fit(y = d$count, h.fct = function(p)
              {log(p[1] * p[4] / p[2] / p[3])},
              L.fct = L.fct, X = diag(3))

# Unrestricted Model...
b &lt;- mph.fit(y = d$count, L.fct = L.fct, X = diag(3))

mph.summary(a6, TRUE)
mph.summary(b, TRUE)


# EXAMPLE 5. Test of Independence in a 4-by-4 Table.
#            (Using Log-Linear Model.)
#
# Data Source: Table 2.8, Agresti, 57:2002.
#
# y &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "all");
# i.e. Y ~ multinomial.
#
# In other symbols,
# y &lt;- Y ~ multinomial(96, p = (p[1, 1], p[1, 2], p[2, 1], p[2, 2]))
#
# GOAL: Test H0: p[1, 1] * p[2, 2] / p[1, 2] / p[2, 1] = 1 vs. H1: not H0.

d &lt;- data.frame(Income = c("&lt;15", "&lt;15", "&lt;15", "&lt;15", "15-25", "15-25",
                           "15-25", "15-25", "25-40", "25-40", "25-40",
                           "25-40", "&gt;40", "&gt;40", "&gt;40", "&gt;40"),
                JobSatisf = c("VD", "LD", "MS", "VS", "VD", "LD", "MS", "VS",
                              "VD", "LD", "MS", "VS", "VD", "LD", "MS", "VS"),
                count = c(1, 3, 10, 6, 2, 3, 10, 7, 1, 6, 14, 12, 0, 1, 9, 11))

a &lt;- mph.fit(y = d$count, link = "logp",
             X = model.matrix(~ Income + JobSatisf, data = d))
mph.summary(a)

# Alternatively,
b &lt;- mph.fit(y = d$count, link = "logm",
             X = model.matrix(~ Income + JobSatisf, data = d))
mph.summary(b)


# EXAMPLE 6. Test Marginal Homogeneity in a 3-by-3 Table.
#
# Data Source: Table 10.16, Agresti, 445:2002.
#
# y &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "all");
# i.e. Y ~ multinomial.
#
# Specifically,
# y &lt;- Y ~ multinomial(160, p = (p[1, 1], ..., p[3, 3]))
#
# GOAL: Test H0: p[1, +] = p[+, 1], p[2, +] = p[+, 2], p[3, +] = p[+, 3]
#        vs. H1: not H0.

d &lt;- data.frame(Siskel = c("Pro", "Pro", "Pro", "Mixed", "Mixed",
                           "Mixed", "Con", "Con", "Con"),
                Ebert = c("Pro", "Mixed", "Con", "Pro", "Mixed",
                          "Con", "Pro", "Mixed", "Con"),
                count = c(64, 9, 10, 11, 13, 8, 13, 8, 24))

h.fct &lt;- function(p){
    p.Siskel &lt;- M.fct(d$Siskel) %*% p
    p.Ebert  &lt;- M.fct(d$Ebert) %*% p
    as.matrix(c(p.Siskel[-3] - p.Ebert[-3]))
}
a1 &lt;- mph.fit(y = d$count, h.fct = h.fct)
mph.summary(a1, TRUE)

# Suppose that we wish to report on the observed and fitted
# marginal probabilities.

L.fct &lt;- function(p) {
    p.Siskel &lt;- M.fct(d$Siskel) %*% p
    p.Ebert &lt;- M.fct(d$Ebert) %*% p
    L &lt;- as.matrix(c(p.Siskel, p.Ebert))
    rownames(L) &lt;- c(paste(sep = "", "P(Siskel=", levels(as.factor(d$Siskel)), ")"),
                     paste(sep = "", "P(Ebert=", levels(as.factor(d$Ebert)), ")"))
    L
}
a2 &lt;- mph.fit(y = d$count, h.fct = h.fct, L.fct = L.fct, X = diag(6))
mph.summary(a2, TRUE)

# M.fct(factor) %*% p gives the marginal probabilities corresponding to
# the levels of 'factor'. The marginal probabilities are ordered by the
# levels of 'factor'.
#
# Alternatively, in this rectangular table setting, we can find the
# marginal probabilities using the apply(...) function. In this case,
# the marginal probabilities are ordered as they are entered in the
# data set.

h.fct &lt;- function(p) {
    p &lt;- matrix(p, 3, 3, byrow = TRUE)
    p.Siskel &lt;- apply(p, 1, sum)
    p.Ebert &lt;- apply(p, 2, sum)
    as.matrix(c(p.Siskel[-3] - p.Ebert[-3]))
}

L.fct &lt;- function(p) {
    p &lt;- matrix(p, 3, 3, byrow = TRUE)
    p.Siskel &lt;- apply(p, 1, sum)
    p.Ebert &lt;- apply(p, 2, sum)
    L &lt;- as.matrix(c(p.Siskel, p.Ebert))
    rownames(L) &lt;- c("P(Siskel=Pro)", "P(Siskel=Mixed)",
                     "P(Siskel=Con)", "P(Ebert=Pro)",
                     "P(Ebert=Mixed)", "P(Ebert=Con)")
    L
}
b &lt;- mph.fit(y = d$count, h.fct = h.fct, L.fct = L.fct, X = diag(6))


# EXAMPLE 7. Log-Linear Model for 2-by-2-by-2 Table.
#
# Data Source: Table 8.16, Agresti 347:2002
#
# y &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "all");
# i.e. Y ~ multinomial.
#
# Specifically,
#
# y &lt;- Y ~ multinomial(621, p).
#
# The counts in y are cross-classification counts for variables
# G = Gender, I = Information Opinion, H = Health Opinion.
#
# GOAL: Fit the loglinear models [GI, GH, IH] and [G, IH].

d &lt;- data.frame(G = c("Male", "Male", "Male", "Male",
                      "Female", "Female", "Female", "Female"),
                I = c("Support", "Support", "Oppose", "Oppose",
                      "Support", "Support", "Oppose", "Oppose"),
                H = c("Support", "Oppose", "Support", "Oppose",
                      "Support", "Oppose", "Support", "Oppose"),
                count = c(76, 160, 6, 25, 114, 181, 11, 48))

# Fit loglinear model [GI, GH, IH]...

a1 &lt;- mph.fit(y = d$count, link = "logm",
              X = model.matrix(~ G + I + H + G:I + G:H + I:H, data = d))

# Fit loglinear model [G, IH]...

a2 &lt;- mph.fit(y = d$count, link = "logm",
              X = model.matrix(~ G + I + H + I:H, data = d))

# Different Sampling Distribution Assumptions:
#
# Alternatively, assume
# y &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "none");
# that is, Y ~ indep Poisson.
#
# In other symbols,
# y &lt;- Y, where Y[i] indep ~ Poisson(m[i] = gamma * p[i]).
# Here, gamma is the unknown expected sample size.

b2 &lt;- mph.fit(y = d$count, link = "logm",
              X = model.matrix(~ G + I + H + I:H, data = d),
              fixed = "none")

# Alternatively, assume
# y &lt;- Y ~ MP(gamma, p | strata = Gender, fixed = "all");
# that is, Y ~ prod multinomial.
#
# In other symbols,
# y &lt;- Y = (Y[1, 1, 1], Y[1, 1, 2], ..., Y[2, 2, 2]),
# where (Y[i, 1, 1], ..., Y[i, 2, 2]) indep ~ multinomial(n[i], p[i, , ]).
# Here, p[i, j, k] = P(I = j, H = k | G = i) and n[1] = 267 and
# n[2] = 354 are the a priori fixed sample sizes for males and females.

c2 &lt;- mph.fit(y = d$count, link = "logm",
              X = model.matrix(~ G + I + H + I:H, data = d),
              strata = d$G)

# Alternatively, assume
# y &lt;- Y ~ MP(gamma, p | strata = Gender, fixed = "none");
# that is, Y ~ prod Poisson.
#
# In other symbols,
# y &lt;- Y = (Y[1, 1, 1], Y[1, 1, 2], ..., Y[2, 2, 2]),
# where Y[i, j, k] indep ~ Poisson(m[i, j, k] = gamma[i] * p[i, j, k]).
# Here, p[i, j, k] = P(I = j, H = k | G = i) and gamma[1] and gamma[2] are the
# unknown expected sample sizes for males and for females.

d2 &lt;- mph.fit(y = d$count, link = "logm",
              X = model.matrix(~ G + I + H + I:H, data = d),
              strata = d$G, fixed = "none")

cbind(a2$m, b2$m, c2$m, d2$m, sqrt(diag(a2$covm)), sqrt(diag(b2$covm)),
      sqrt(diag(c2$covm)), sqrt(diag(d2$covm)))
cbind(a2$p, b2$p, c2$p, d2$p, sqrt(diag(a2$covp)), sqrt(diag(b2$covp)),
      sqrt(diag(c2$covp)), sqrt(diag(d2$covp)))


# EXAMPLE 8. Fit Linear-by-Linear Log-Linear Model
#
# Data Source: Table 8.15, Agresti, 345:2002
#
# y &lt;- Y ~ MP(gamma, p | strata = 1, fixed = "all");
# i.e. Y ~ multinomial.
#
# Specifically,
# y &lt;- Y ~ multinomial(1425, p)
#
# GOAL: Assess the fit of the linear-by-linear log-linear model.

d &lt;- list(Schooling = c("&lt;HS", "&lt;HS", "&lt;HS", "HS", "HS", "HS", "&gt;HS", "&gt;HS", "&gt;HS"),
          Abortion = c("Disapprove", "Middle", "Approve", "Disapprove", "Middle",
                       "Approve", "Disapprove", "Middle", "Approve"),
          count = c(209, 101, 237, 151, 126, 426, 16, 21, 138))

Schooling.score &lt;- -1 * (d$Schooling == "&lt;HS") +
                    0 * (d$Schooling == "HS") +
                    1 * (d$Schooling == "&gt;HS")
Abortion.score  &lt;- -1 * (d$Abortion == "Disapprove") +
                    0 * (d$Abortion == "Middle") +
                    1 * (d$Abortion == "Approve")

d &lt;- data.frame(d, Schooling.score, Abortion.score)

a &lt;- mph.fit(y = d$count, link = "logm",
             X = model.matrix(~ Schooling + Abortion +
             Schooling.score : Abortion.score, data = d))
mph.summary(a, TRUE)


# EXAMPLE 9. Marginal Standardization of a Contingency Table.
#
# Data Source: Table 8.15, Agresti 345:2002.
#
# GOAL: For a two-way table, find the standardized values of y, say y*,
# that satisfy (i) y* has the same odds ratios as y, and
#             (ii) y* has row and column totals equal to 100.
#
# Note: This is equivalent to the problem of finding the fitted values
# for the following model...
# x &lt;- Y ~ multinomial(n, p = (p[1, 1], ..., p[3, 3]))
#      p[1, +] = p[2, +] = p[3, +] = p[+, 1] = p[+, 2] = p[+, 3] = 1/3
#      p[1, 1] * p[2, 2] / p[2, 1] / p[1, 2] = or[1, 1]
#      p[1, 2] * p[2, 3] / p[2, 2] / p[1, 3] = or[1, 2]
#      p[2, 1] * p[3, 2] / p[3, 1] / p[2, 2] = or[2, 1]
#      p[2, 2] * p[3, 3] / p[3, 2] / p[2, 3] = or[2, 2],
# where or[i, j] = y[i, j] * y[i + 1, j + 1] / y[i + 1, j] / y[i, j + 1]
# are the observed (y) odds ratios.
# If m is the vector of fitted values, then y* = m * 300 / sum(m)
# are the standardized values of y.
# Here x can be any vector of 9 counts.
# Choosing x so that the sum is 300 leads to sum(m) = 300, so that
# y* = m in this case.

d &lt;- data.frame(Schooling = c("&lt;HS", "&lt;HS", "&lt;HS", "HS", "HS", "HS", "&gt;HS", "&gt;HS", "&gt;HS"),
                Abortion = c("Disapprove", "Middle", "Approve", "Disapprove", "Middle",
                             "Approve", "Disapprove", "Middle", "Approve"),
                count = c(209, 101, 237, 151, 126, 426, 16, 21, 138))

h.fct &lt;- function(p) {
   p.Schooling &lt;- M.fct(d$Schooling) %*% p
   p.Abortion  &lt;- M.fct(d$Abortion) %*% p
   p &lt;- matrix(p, 3, 3, byrow = TRUE)
   as.matrix(c(
     p.Schooling[-3] - 1/3, p.Abortion[-3] - 1/3,
     p[1, 1] * p[2, 2] / p[2, 1] / p[1, 2] - 209 * 126 / 151 / 101,
     p[1, 2] * p[2, 3] / p[2, 2] / p[1, 3] - 101 * 426 / 126 / 237,
     p[2, 1] * p[3, 2] / p[3, 1] / p[2, 2] - 151 * 21 / 16 / 126,
     p[2, 2] * p[3, 3] / p[3, 2] / p[2, 3] - 126 * 138 / 21 / 426
   ))
}

b &lt;- mph.fit(y = d$count, h.fct = h.fct)
ystar &lt;- b$m * 300 / sum(b$m)
matrix(round(ystar, 1), 3, 3, byrow = TRUE)

x &lt;- c(rep(33, 8), 36)
b &lt;- mph.fit(y = x, h.fct = h.fct)
ystar &lt;- b$m
matrix(round(ystar, 1), 3, 3, byrow = TRUE)


# EXAMPLE 10. Cumulative Logit Model.
#
# Data Source: Table 7.19, Agresti, 306:2002.
#
# y &lt;- Y ~ MP(gamma, p | strata = Therapy * Gender, fixed = "all");
# i.e. Y ~ prod multinomial.
#
# Here, y[i, j, k] is the cross-classification count corresponding to
# Therapy = i, Gender = j, Response = k.
#
# The table probabilities are defined as
# p[i, j, k] = P(Response = k | Therapy = i, Gender = j).
#
# Goal: Fit the cumulative logit proportional odds model that includes
# the main effect of Therapy and Gender.

d &lt;- data.frame(Therapy = c("Sequential", "Sequential", "Sequential", "Sequential",
                            "Sequential", "Sequential", "Sequential", "Sequential",
                            "Alternating", "Alternating", "Alternating", "Alternating",
                            "Alternating", "Alternating", "Alternating", "Alternating"),
                Gender = c("Male", "Male", "Male", "Male", "Female", "Female",
                           "Female", "Female", "Male", "Male", "Male", "Male",
                           "Female", "Female", "Female", "Female"),
                Response = c("Progressive", "NoChange", "Partial", "Complete",
                             "Progressive", "NoChange", "Partial", "Complete",
                             "Progressive", "NoChange", "Partial", "Complete",
                             "Progressive", "NoChange", "Partial", "Complete"),
                count = c(28, 45, 29, 26, 4, 12, 5, 2, 41, 44, 20, 20, 12, 7, 3, 1))

strata &lt;- paste(sep = "", d$Therapy, ".", d$Gender)
d &lt;- data.frame(d, strata)

d3 &lt;- subset(d, Response != "Complete")
levels(d3$Response) &lt;- c(NA, "NoChange", "Partial", "Progressive")

L.fct &lt;- function(p) {
   p &lt;- matrix(p, 4, 4, byrow = TRUE)
   clogit &lt;- c()
   for (s in 1:4) {
     clogit &lt;- c(clogit,
                 log(sum(p[s, 1])   / sum(p[s, 2:4])),
                 log(sum(p[s, 1:2]) / sum(p[s, 3:4])),
                 log(sum(p[s, 1:3]) / sum(p[s, 4]))
     )
   }
   L &lt;- as.matrix(clogit)
   rownames(L) &lt;- c(paste(sep = "", "log odds(R &lt; ", 2:4, "|",
                          d3$strata, ")"))
   L
}

a &lt;- mph.fit(d$count, link = L.fct,
             X = model.matrix(~ -1 + Response + Therapy + Gender,
                              data = d3),
             strata = strata)

# Fit the related non-proportional odds cumulative logit model
b &lt;- mph.fit(d$count, link = L.fct,
             X = model.matrix(~ Response + Response * Therapy +
                                Response * Gender - 1 - Therapy - Gender,
                              data = d3),
             strata = strata)

mph.summary(a, TRUE)
mph.summary(b, TRUE)

</code></pre>

<hr>
<h2 id='mph.summary'>
Summary Statistics of the Fitted MPH Model
</h2><span id='topic+mph.summary'></span>

<h3>Description</h3>

<p>Computes and prints a collection of summary statistics of the
fitted MPH model.
</p>
<p>This function is used in conjunction with the ML fitting function
<code>mph.fit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mph.summary(mph.out, cell.stats = FALSE, model.info = FALSE, digits = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mph.summary_+3A_mph.out">mph.out</code></td>
<td>
<p>Result of <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="mph.summary_+3A_cell.stats">cell.stats</code></td>
<td>
<p>Logical variable indicating whether cell specific
statistics are to be output. Default:
<code>cell.stats = FALSE</code>.</p>
</td></tr>
<tr><td><code id="mph.summary_+3A_model.info">model.info</code></td>
<td>
<p>Logical variable indicating whether model
information is to be output. Default:
<code>model.info = FALSE</code>.</p>
</td></tr>
<tr><td><code id="mph.summary_+3A_digits">digits</code></td>
<td>
<p>Integer giving output precision; used in the
<code>round()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Joseph B. Lang
</p>


<h3>References</h3>

<p>Lang, J. B. (2004) Multinomial-Poisson homogeneous models for contingency tables, <em>Annals of Statistics</em>, <b>32</b>, 340&ndash;383.
</p>
<p>Lang, J. B. (2005) Homogeneous linear predictor models for contingency tables, <em>Journal of the American Statistical Association</em>, <b>100</b>, 121&ndash;134.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mph.fit">mph.fit</a></code>
</p>

<hr>
<h2 id='nested_Gsq_nr'>
Nested <code class="reqn">G</code>-Squared Statistic Based CIs (Non-Robust)
</h2><span id='topic+nested_Gsq_nr'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the nested <code class="reqn">G^2</code> statistic, for estimands in contingency tables subject to equality constraints.
</p>
<p>The program may stop because of a non-convergence issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_Gsq_nr(y, strata, fixed.strata, h0.fct, h0.fct.deriv, S0.fct,
              S0.fct.deriv, max.mph.iter, step, change.step.after,
              y.eps, iter.orig, norm.diff.conv, norm.score.conv,
              max.score.diff.iter, S.space.H0, tol.psi, tol,
              max.iter, cut.off, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_Gsq_nr_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_max.mph.iter">max.mph.iter</code>, <code id="nested_Gsq_nr_+3A_step">step</code>, <code id="nested_Gsq_nr_+3A_change.step.after">change.step.after</code>, <code id="nested_Gsq_nr_+3A_y.eps">y.eps</code>, <code id="nested_Gsq_nr_+3A_iter.orig">iter.orig</code>, <code id="nested_Gsq_nr_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="nested_Gsq_nr_+3A_norm.score.conv">norm.score.conv</code>, <code id="nested_Gsq_nr_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_tol.psi">tol.psi</code>, <code id="nested_Gsq_nr_+3A_tol">tol</code>, <code id="nested_Gsq_nr_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="nested_Gsq_nr_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provided that <code>nested_Gsq_nr</code> does not stop,
it returns a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the nested <code class="reqn">G^2</code> statistic.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested_Gsq_nr">nested_Gsq_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='nested_Gsq_robust'>
Nested <code class="reqn">G</code>-Squared Statistic Based CIs (Robust)
</h2><span id='topic+nested_Gsq_robust'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the nested <code class="reqn">G^2</code> statistic, for estimands in contingency tables subject to equality constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_Gsq_robust(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
                  S0.fct, S0.fct.deriv, max.mph.iter, step,
                  change.step.after, y.eps, iter.orig, norm.diff.conv,
                  norm.score.conv, max.score.diff.iter, S.space.H0,
                  tol.psi, tol, max.iter, cut.off, delta, adj.epsilon,
                  iter.robust.max, iter.robust.eff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_Gsq_robust_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum
membership identifier.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_max.mph.iter">max.mph.iter</code>, <code id="nested_Gsq_robust_+3A_step">step</code>, <code id="nested_Gsq_robust_+3A_change.step.after">change.step.after</code>, <code id="nested_Gsq_robust_+3A_y.eps">y.eps</code>, <code id="nested_Gsq_robust_+3A_iter.orig">iter.orig</code>, <code id="nested_Gsq_robust_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="nested_Gsq_robust_+3A_norm.score.conv">norm.score.conv</code>, <code id="nested_Gsq_robust_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_tol.psi">tol.psi</code>, <code id="nested_Gsq_robust_+3A_tol">tol</code>, <code id="nested_Gsq_robust_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
<tr><td><code id="nested_Gsq_robust_+3A_adj.epsilon">adj.epsilon</code>, <code id="nested_Gsq_robust_+3A_iter.robust.max">iter.robust.max</code>, <code id="nested_Gsq_robust_+3A_iter.robust.eff">iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nested_Gsq_robust</code> returns a list, which includes two objects. The first object is a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the nested <code class="reqn">G^2</code> statistic. For the second object, it includes the warning message that occurs during construction of the confidence
interval if the robustifying procedure is evoked: <code>"nested.Gsq.CI: Adjustment used. Not on original data.\n"</code>. If the robustifying procedure is not evoked, the second object is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested_Gsq_nr">nested_Gsq_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='nested_PD_nr'>
Nested Power-Divergence Statistic Based CIs (Non-Robust)
</h2><span id='topic+nested_PD_nr'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the nested power-divergence statistic, for estimands in contingency tables subject to equality constraints.
</p>
<p>The program may stop because of a non-convergence issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_PD_nr(y, strata, fixed.strata, h0.fct, h0.fct.deriv, S0.fct,
             S0.fct.deriv, max.mph.iter, step, change.step.after,
             y.eps, iter.orig, norm.diff.conv, norm.score.conv,
             max.score.diff.iter, S.space.H0, tol.psi, tol,
             max.iter, cut.off, delta, pdlambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_PD_nr_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_max.mph.iter">max.mph.iter</code>, <code id="nested_PD_nr_+3A_step">step</code>, <code id="nested_PD_nr_+3A_change.step.after">change.step.after</code>, <code id="nested_PD_nr_+3A_y.eps">y.eps</code>, <code id="nested_PD_nr_+3A_iter.orig">iter.orig</code>, <code id="nested_PD_nr_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="nested_PD_nr_+3A_norm.score.conv">norm.score.conv</code>, <code id="nested_PD_nr_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_tol.psi">tol.psi</code>, <code id="nested_PD_nr_+3A_tol">tol</code>, <code id="nested_PD_nr_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
<tr><td><code id="nested_PD_nr_+3A_pdlambda">pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provided that <code>nested_PD_nr</code> does not stop,
it returns a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the nested power-divergence statistic.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested_PD_robust">nested_PD_robust</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='nested_PD_robust'>
Nested Power-Divergence Statistic Based CIs (Robust)
</h2><span id='topic+nested_PD_robust'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the nested power-divergence statistic, for estimands in contingency tables subject to equality constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_PD_robust(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
                 S0.fct, S0.fct.deriv, max.mph.iter, step,
                 change.step.after, y.eps, iter.orig, norm.diff.conv,
                 norm.score.conv, max.score.diff.iter, S.space.H0,
                 tol.psi, tol, max.iter, cut.off, delta, pdlambda,
                 adj.epsilon, iter.robust.max, iter.robust.eff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_PD_robust_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum
membership identifier.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_max.mph.iter">max.mph.iter</code>, <code id="nested_PD_robust_+3A_step">step</code>, <code id="nested_PD_robust_+3A_change.step.after">change.step.after</code>, <code id="nested_PD_robust_+3A_y.eps">y.eps</code>, <code id="nested_PD_robust_+3A_iter.orig">iter.orig</code>, <code id="nested_PD_robust_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="nested_PD_robust_+3A_norm.score.conv">norm.score.conv</code>, <code id="nested_PD_robust_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_tol.psi">tol.psi</code>, <code id="nested_PD_robust_+3A_tol">tol</code>, <code id="nested_PD_robust_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_pdlambda">pdlambda</code></td>
<td>
<p>The index parameter <code class="reqn">\lambda</code> in the power-divergence statistic.</p>
</td></tr>
<tr><td><code id="nested_PD_robust_+3A_adj.epsilon">adj.epsilon</code>, <code id="nested_PD_robust_+3A_iter.robust.max">iter.robust.max</code>, <code id="nested_PD_robust_+3A_iter.robust.eff">iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nested_PD_robust</code> returns a list, which includes two objects. The first object is a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the nested power-divergence statistic. For the second object, it includes the warning message that occurs during construction of the confidence
interval if the robustifying procedure is evoked: <code>"nested.PD.CI: Adjustment used. Not on original data.\n"</code>. If the robustifying procedure is not evoked, the second object is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested_PD_nr">nested_PD_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='nested_Xsq_nr'>
Nested <code class="reqn">X</code>-Squared Statistic Based CIs (Non-Robust)
</h2><span id='topic+nested_Xsq_nr'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the nested <code class="reqn">X^2</code> statistic, for estimands in contingency tables subject to equality constraints.
</p>
<p>The program may stop because of a non-convergence issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_Xsq_nr(y, strata, fixed.strata, h0.fct, h0.fct.deriv, S0.fct,
              S0.fct.deriv, max.mph.iter, step, change.step.after,
              y.eps, iter.orig, norm.diff.conv, norm.score.conv,
              max.score.diff.iter, S.space.H0, tol.psi, tol,
              max.iter, cut.off, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_Xsq_nr_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_max.mph.iter">max.mph.iter</code>, <code id="nested_Xsq_nr_+3A_step">step</code>, <code id="nested_Xsq_nr_+3A_change.step.after">change.step.after</code>, <code id="nested_Xsq_nr_+3A_y.eps">y.eps</code>, <code id="nested_Xsq_nr_+3A_iter.orig">iter.orig</code>, <code id="nested_Xsq_nr_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="nested_Xsq_nr_+3A_norm.score.conv">norm.score.conv</code>, <code id="nested_Xsq_nr_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_tol.psi">tol.psi</code>, <code id="nested_Xsq_nr_+3A_tol">tol</code>, <code id="nested_Xsq_nr_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="nested_Xsq_nr_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provided that <code>nested_Xsq_nr</code> does not stop,
it returns a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the nested <code class="reqn">X^2</code> statistic.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested_Xsq_nr">nested_Xsq_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='nested_Xsq_robust'>
Nested <code class="reqn">X</code>-Squared Statistic Based CIs (Robust)
</h2><span id='topic+nested_Xsq_robust'></span>

<h3>Description</h3>

<p>Constructs confidence intervals (CIs), based on the nested <code class="reqn">X^2</code> statistic, for estimands in contingency tables subject to equality constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nested_Xsq_robust(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
                  S0.fct, S0.fct.deriv, max.mph.iter, step,
                  change.step.after, y.eps, iter.orig, norm.diff.conv,
                  norm.score.conv, max.score.diff.iter, S.space.H0,
                  tol.psi, tol, max.iter, cut.off, delta, adj.epsilon,
                  iter.robust.max, iter.robust.eff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nested_Xsq_robust_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum
membership identifier.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_max.mph.iter">max.mph.iter</code>, <code id="nested_Xsq_robust_+3A_step">step</code>, <code id="nested_Xsq_robust_+3A_change.step.after">change.step.after</code>, <code id="nested_Xsq_robust_+3A_y.eps">y.eps</code>, <code id="nested_Xsq_robust_+3A_iter.orig">iter.orig</code>, <code id="nested_Xsq_robust_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="nested_Xsq_robust_+3A_norm.score.conv">norm.score.conv</code>, <code id="nested_Xsq_robust_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_tol.psi">tol.psi</code>, <code id="nested_Xsq_robust_+3A_tol">tol</code>, <code id="nested_Xsq_robust_+3A_max.iter">max.iter</code></td>
<td>
<p>The parameters used in the three stopping criteria in solving for the roots to the test-inversion equation.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_delta">delta</code></td>
<td>
<p>The constant <code class="reqn">\delta</code> that is in expressions of the moving critical
values within each sliding quadratic step.</p>
</td></tr>
<tr><td><code id="nested_Xsq_robust_+3A_adj.epsilon">adj.epsilon</code>, <code id="nested_Xsq_robust_+3A_iter.robust.max">iter.robust.max</code>, <code id="nested_Xsq_robust_+3A_iter.robust.eff">iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nested_Xsq_robust</code> returns a list, which includes two objects. The first object is a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the confidence interval based on the nested <code class="reqn">X^2</code> statistic. For the second object, it includes the warning message that occurs during construction of the confidence
interval if the robustifying procedure is evoked: <code>"nested.Xsq.CI: Adjustment used. Not on original data.\n"</code>. If the robustifying procedure is not evoked, the second object is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nested_Xsq_nr">nested_Xsq_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='num.deriv.fct'>
Numerical Derivatives Based on Central Difference Formula
</h2><span id='topic+num.deriv.fct'></span>

<h3>Description</h3>

<p>Computes the numerical derivative of the transpose of the
vector-valued function <code class="reqn">f</code> evaluated at the point <code class="reqn">m</code>, based
on the central difference formula.
</p>
<p>If <code class="reqn">f</code> is a mapping from <code class="reqn">R^p</code> to <code class="reqn">R^q</code>, then the result
is a <code class="reqn">p</code>-by-<code class="reqn">q</code> matrix.
i.e. The result is an approximation to
<code class="reqn">\partial f'(m)/\partial m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num.deriv.fct(f.fct, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="num.deriv.fct_+3A_f.fct">f.fct</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> function object that defines a vector-valued
function <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="num.deriv.fct_+3A_m">m</code></td>
<td>
<p>A vector, indicating the point <code class="reqn">m</code> at which the numerical
derivative is to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>num.deriv.fct</code> returns a matrix, which is the numerical
derivative of the transpose of the function <code class="reqn">f</code> evaluated at <code class="reqn">m</code>.
</p>


<h3>Author(s)</h3>

<p>Joseph B. Lang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Let x = (x[1], x[2], x[3])', and
# f(x) = (x[1]^3 - 2 * x[2] + 1, sin(x[1] * x[3]), log(x[2] + x[3]))'.
# Approximate d f^{T}(x) / d x  at x = (1, 2, 3)'.
# The true value of the derivative is
# [ 3   3cos(3)    0
#  -2      0      0.2
#   0    cos(3)   0.2] .

f.fct &lt;- function(x) {
  c(x[1]^3 - 2 * x[2] + 1,
    sin(x[1] * x[3]),
    log(x[2] + x[3]))
}
num.deriv.fct(f.fct, c(1, 2, 3))
</code></pre>

<hr>
<h2 id='quadratic.fit'>
Quadratic Fit
</h2><span id='topic+quadratic.fit'></span>

<h3>Description</h3>

<p>Fits a quadratic curve that passes all three points on the two-dimensional Euclidean space <code class="reqn">R^2</code>.
</p>
<p>If the design matrix <code class="reqn">X</code> of the quadratic fit has a condition number which is greater than <code class="reqn">10^8</code>, a linear regression line is fitted to the three points instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadratic.fit(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadratic.fit_+3A_x">x</code></td>
<td>
<p>A vector of length three, which represents the <code class="reqn">x</code>-values of the three points.</p>
</td></tr>
<tr><td><code id="quadratic.fit_+3A_y">y</code></td>
<td>
<p>A vector of length three, which represents the <code class="reqn">y</code>-values of the three points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>quadratic.fit</code> returns a vector of length three. The first, second, and third elements of the returned vector are the second degree, first degree, and zero-th degree coefficients, respectively, of the fitted quadratic curve, or of the fitted linear regression line.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+solve_quadratic">solve_quadratic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Three points: (0, 1), (1, 0), (3, 4).
quadratic.fit(c(0, 1, 3), c(1, 0, 4))
</code></pre>

<hr>
<h2 id='solve_quadratic'>
Solve for Real Root(s) to the Quadratic Equation
</h2><span id='topic+solve_quadratic'></span>

<h3>Description</h3>

<p>Solves for real-valued roots to the quadratic equation <code class="reqn">ax^{2} + bx + c = 0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solve_quadratic(a, b, c)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solve_quadratic_+3A_a">a</code>, <code id="solve_quadratic_+3A_b">b</code>, <code id="solve_quadratic_+3A_c">c</code></td>
<td>
<p>Coefficients in the quadratic equation
<code class="reqn">ax^{2} + bx + c = 0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>solve_quadratic</code> returns a list, which includes the following two objects:
</p>
<table role = "presentation">
<tr><td><code>flag</code></td>
<td>
<p>Indicates the number of distinct real roots to the quadratic equation. It can be one of <code>"infinite"</code>, <code>"none"</code>, <code>"one"</code>,
or <code>"two"</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Real root(s) to the quadratic equation. If
<code>flag = "infinite"</code>, we simply write <code>x = 0</code>;
If <code>flag = "none"</code>, we write <code>x = NA</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadratic.fit">quadratic.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>solve_quadratic(1, 2, 1)
solve_quadratic(1, 2, 2)
solve_quadratic(0, 2, 1)
</code></pre>

<hr>
<h2 id='Wald_trans.Wald_nr'>
Wald-Type CIs (Non-Robust)
</h2><span id='topic+Wald_trans.Wald_nr'></span>

<h3>Description</h3>

<p>Constructs non-transformed and transformed (if the
transformation <code class="reqn">g</code> is specified) Wald confidence intervals (CIs) for estimands in contingency tables subject to equality constraints.
</p>
<p>The program may stop because of a non-convergence issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wald_trans.Wald_nr(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
                   S0.fct, S0.fct.deriv, max.mph.iter, step,
                   change.step.after, y.eps, iter.orig, norm.diff.conv,
                   norm.score.conv, max.score.diff.iter, cut.off,
                   S.space.H0, trans.g, trans.g.deriv, trans.g.inv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Wald_trans.Wald_nr_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum membership
identifier.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or <code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_max.mph.iter">max.mph.iter</code>, <code id="Wald_trans.Wald_nr_+3A_step">step</code>, <code id="Wald_trans.Wald_nr_+3A_change.step.after">change.step.after</code>, <code id="Wald_trans.Wald_nr_+3A_y.eps">y.eps</code>, <code id="Wald_trans.Wald_nr_+3A_iter.orig">iter.orig</code>, <code id="Wald_trans.Wald_nr_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="Wald_trans.Wald_nr_+3A_norm.score.conv">norm.score.conv</code>, <code id="Wald_trans.Wald_nr_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e. subject to the imposed equality constraints along with sampling constraints.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_trans.g">trans.g</code></td>
<td>
<p>The transformation <code class="reqn">g</code> used in the transformed Wald confidence interval.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_trans.g.deriv">trans.g.deriv</code></td>
<td>
<p>The derivative function of the transformation <code class="reqn">g</code>, i.e. <code class="reqn">d g(w) / d w</code>. If it is specified, it should be an <span class="rlang"><b>R</b></span> function, even if the derivative function is a constant function.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_nr_+3A_trans.g.inv">trans.g.inv</code></td>
<td>
<p><code class="reqn">g^{-1}</code> function used in back-transformation step in construction of the transformed Wald confidence interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Provided that <code>Wald_trans.Wald_nr</code> does not stop,
</p>

<ul>
<li><p> either it returns a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the non-transformed Wald confidence interval, if the
transformation <code class="reqn">g</code> is not specified;
</p>
</li>
<li><p> or it returns a <code class="reqn">2</code>-by-<code class="reqn">2</code> matrix, whose first row displays two endpoints of the non-transformed Wald confidence interval, and whose second row displays two endpoints of the transformed Wald confidence interval, if the transformation <code class="reqn">g</code> is specified.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Wald_trans.Wald_robust">Wald_trans.Wald_robust</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

<hr>
<h2 id='Wald_trans.Wald_robust'>
Wald-Type CIs (Robust)
</h2><span id='topic+Wald_trans.Wald_robust'></span>

<h3>Description</h3>

<p>Constructs non-transformed and transformed (if the
transformation <code class="reqn">g</code> is specified) Wald confidence intervals (CIs) for estimands in contingency tables subject to equality constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wald_trans.Wald_robust(y, strata, fixed.strata, h0.fct, h0.fct.deriv,
                       S0.fct, S0.fct.deriv, max.mph.iter, step,
                       change.step.after, y.eps, iter.orig, norm.diff.conv,
                       norm.score.conv, max.score.diff.iter, cut.off,
                       S.space.H0, trans.g, trans.g.deriv, trans.g.inv,
                       adj.epsilon, iter.robust.max, iter.robust.eff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Wald_trans.Wald_robust_+3A_y">y</code></td>
<td>
<p>Observed table counts in the contingency table(s), in vector form.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_strata">strata</code></td>
<td>
<p>Vector of the same length as <code>y</code> that gives the stratum
membership identifier.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_fixed.strata">fixed.strata</code></td>
<td>
<p>The object that gives information on which stratum (strata) has
(have) fixed sample sizes.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_h0.fct">h0.fct</code></td>
<td>
<p>The constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to <code class="reqn">m</code>, where
<code class="reqn">m = E(Y)</code>, the vector of expected table counts.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_h0.fct.deriv">h0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of the
transpose of the constraint function <code class="reqn">h_{0}(\cdot)</code> with respect to
<code class="reqn">m</code>. If <code>h0.fct.deriv</code> is not specified or
<code>h0.fct.deriv = NULL</code>, numerical derivatives will be used.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_s0.fct">S0.fct</code></td>
<td>
<p>The estimand function <code class="reqn">S_{0}(\cdot)</code> with respect to <code class="reqn">m</code>.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_s0.fct.deriv">S0.fct.deriv</code></td>
<td>
<p>The <span class="rlang"><b>R</b></span> function object that computes analytic derivative of
the estimand function <code class="reqn">S_{0}(\cdot)</code> with
respect to <code class="reqn">m</code>. If <code>S0.fct.deriv</code> is not
specified or <code>S0.fct.deriv = NULL</code>, numerical derivatives
will be used.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_max.mph.iter">max.mph.iter</code>, <code id="Wald_trans.Wald_robust_+3A_step">step</code>, <code id="Wald_trans.Wald_robust_+3A_change.step.after">change.step.after</code>, <code id="Wald_trans.Wald_robust_+3A_y.eps">y.eps</code>, <code id="Wald_trans.Wald_robust_+3A_iter.orig">iter.orig</code>, <code id="Wald_trans.Wald_robust_+3A_norm.diff.conv">norm.diff.conv</code>, <code id="Wald_trans.Wald_robust_+3A_norm.score.conv">norm.score.conv</code>, <code id="Wald_trans.Wald_robust_+3A_max.score.diff.iter">max.score.diff.iter</code></td>
<td>
<p>The parameters used in <code>mph.fit</code>.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_cut.off">cut.off</code></td>
<td>
<p><code>qchisq(cc, 1)</code>. i.e. The chi-square cutoff, with <code class="reqn">1</code>
df, based on the significance level <code>1-cc</code>.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_s.space.h0">S.space.H0</code></td>
<td>
<p>Restricted estimand space of <code class="reqn">S(\cdot)</code> under <code class="reqn">H_{0}</code>, i.e.
subject to the imposed equality constraints along with sampling
constraints.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_trans.g">trans.g</code></td>
<td>
<p>The transformation <code class="reqn">g</code> used in the transformed Wald confidence interval.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_trans.g.deriv">trans.g.deriv</code></td>
<td>
<p>The derivative function of the transformation <code class="reqn">g</code>, i.e. <code class="reqn">d g(w) / d w</code>. If it is specified, it should be an <span class="rlang"><b>R</b></span> function, even if the derivative function is a constant function.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_trans.g.inv">trans.g.inv</code></td>
<td>
<p><code class="reqn">g^{-1}</code> function used in back-transformation step in construction of the transformed Wald confidence interval.</p>
</td></tr>
<tr><td><code id="Wald_trans.Wald_robust_+3A_adj.epsilon">adj.epsilon</code>, <code id="Wald_trans.Wald_robust_+3A_iter.robust.max">iter.robust.max</code>, <code id="Wald_trans.Wald_robust_+3A_iter.robust.eff">iter.robust.eff</code></td>
<td>
<p>The parameters used in the robustifying procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Wald_trans.Wald_robust</code> returns a list, which includes two objects. The first object is
</p>

<ul>
<li><p> either a <code class="reqn">1</code>-by-<code class="reqn">2</code> matrix which displays two endpoints of the non-transformed Wald confidence interval, if the
transformation <code class="reqn">g</code> is not specified;
</p>
</li>
<li><p> or a <code class="reqn">2</code>-by-<code class="reqn">2</code> matrix, whose first row displays two endpoints of the non-transformed Wald confidence interval, and whose second row displays two endpoints of the transformed Wald confidence interval, if the transformation <code class="reqn">g</code> is specified.
</p>
</li></ul>

<p>For the second object, it includes the warning message that occurs during construction of the confidence
interval(s) if the robustifying procedure is evoked: <code>"Wald.CI: Adjustment used. Not on original data.\n"</code>, or <code>"Wald.CI and trans.Wald.CI: Adjustment used. Not on original data.\n"</code>. If the robustifying procedure is not evoked, the second object is <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Qiansheng Zhu
</p>


<h3>References</h3>

<p>Zhu, Q. (2020) &quot;On improved confidence intervals for parameters of discrete distributions.&quot; PhD dissertation, University of Iowa.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Wald_trans.Wald_nr">Wald_trans.Wald_nr</a></code>, <code><a href="#topic+f.psi">f.psi</a></code>, <code><a href="#topic+ci.table">ci.table</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
