<!DOCTYPE html><html lang="en"><head><title>Help for package wv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wv'><p>wv</p></a></li>
<li><a href='#.acf'><p>Auto-Covariance and Correlation Functions</p></a></li>
<li><a href='#ACF'><p>Auto-Covariance and Correlation Functions</p></a></li>
<li><a href='#acf_sum'><p>Helper Function for ARMA to WV Approximation</p></a></li>
<li><a href='#adis_wv'><p>Wavelet variance of IMU Data from an ADIS 16405 sensor</p></a></li>
<li><a href='#ar1_to_wv'><p>AR(1) process to WV</p></a></li>
<li><a href='#arma_to_wv'><p>ARMA process to WV</p></a></li>
<li><a href='#arma_to_wv_app'><p>ARMA process to WV Approximation</p></a></li>
<li><a href='#arma11_to_wv'><p>ARMA(1,1) to WV</p></a></li>
<li><a href='#ARMAacf_cpp'><p>Compute Theoretical ACF for an ARMA Process</p></a></li>
<li><a href='#ARMAtoMA_cpp'><p>Converting an ARMA Process to an Infinite MA Process</p></a></li>
<li><a href='#av_ar1'><p>Calculate Theoretical Allan Variance for Stationary First-Order Autoregressive</p>
(AR1) Process</a></li>
<li><a href='#av_wn'><p>Calculate Theoretical Allan Variance for Stationary White Noise Process</p></a></li>
<li><a href='#batch_modwt_wvar_cpp'><p>Computes the MO/DWT wavelet variance for multiple processes</p></a></li>
<li><a href='#cfilter'><p>Time Series Convolution Filters</p></a></li>
<li><a href='#ci_eta3'><p>Generate eta3 confidence interval</p></a></li>
<li><a href='#ci_eta3_robust'><p>Generate eta3 robust confidence interval</p></a></li>
<li><a href='#ci_wave_variance'><p>Generate a Confidence interval for a Univariate Time Series</p></a></li>
<li><a href='#compare_wvar'><p>Comparison Between Multiple Wavelet Variances</p></a></li>
<li><a href='#compare_wvar_no_split'><p>Combined Plot Comparison Between Multiple Wavelet Variances</p></a></li>
<li><a href='#compare_wvar_split'><p>Multi-Plot Comparison Between Multiple Wavelet Variances</p></a></li>
<li><a href='#create_wvar'><p>Create a <code>wvar</code> object</p></a></li>
<li><a href='#decomp_theoretical_wv'><p>Each Models Process Decomposed to WV</p></a></li>
<li><a href='#decomp_to_theo_wv'><p>Decomposed WV to Single WV</p></a></li>
<li><a href='#dft_acf'><p>Discrete Fourier Transformation for Autocovariance Function</p></a></li>
<li><a href='#diff_cpp'><p>Lagged Differences in Armadillo</p></a></li>
<li><a href='#dr_to_wv'><p>Drift to WV</p></a></li>
<li><a href='#dwt'><p>Discrete Wavelet Transform</p></a></li>
<li><a href='#dwt_cpp'><p>Discrete Wavelet Transform</p></a></li>
<li><a href='#imar_wv'><p>Wavelet variance of IMU Data from IMAR Gyroscopes</p></a></li>
<li><a href='#intgr_vec'><p>Discrete Intergral: Inverse Difference</p></a></li>
<li><a href='#kvh1750_wv'><p>Wavelet variance of IMU Data from a KVH1750 IMU  sensor</p></a></li>
<li><a href='#ln200_wv'><p>Wavelet variance of IMU Data from a LN200 sensor</p></a></li>
<li><a href='#ma1_to_wv'><p>Moving Average Order 1 (MA(1)) to WV</p></a></li>
<li><a href='#mean_diff'><p>Mean of the First Difference of the Data</p></a></li>
<li><a href='#modwt'><p>Maximum Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#modwt_cpp'><p>Maximum Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#modwt_wvar_cpp'><p>Computes the (MODWT) wavelet variance</p></a></li>
<li><a href='#navchip_wv'><p>Wavelet variance of IMU Data from a navchip sensor</p></a></li>
<li><a href='#num_rep'><p>Replicate a Vector of Elements <code class="reqn">n</code> times</p></a></li>
<li><a href='#plot.auto_corr'><p>Auto-Covariance and Correlation Functions</p></a></li>
<li><a href='#plot.dwt'><p>Plot Discrete Wavelet Transform</p></a></li>
<li><a href='#plot.imu_wvar'><p>Plot Wavelet Variance based on IMU Data</p></a></li>
<li><a href='#plot.modwt'><p>Plot Maximum Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#plot.wccv_pair'><p>Plot Cross Covariance Pair</p></a></li>
<li><a href='#plot.wvar'><p>Plot Wavelet Variance</p></a></li>
<li><a href='#print.dwt'><p>Print Discrete Wavelet Transform</p></a></li>
<li><a href='#print.modwt'><p>Print Maximum Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#print.wvar'><p>Print Wavelet Variances</p></a></li>
<li><a href='#qn_to_wv'><p>Quantisation Noise (QN) to WV</p></a></li>
<li><a href='#quantile_cpp'><p>Find Quantiles</p></a></li>
<li><a href='#rfilter'><p>Time Series Recursive Filters</p></a></li>
<li><a href='#robust_eda'><p>Comparison between classical and robust Wavelet Variances</p></a></li>
<li><a href='#rw_to_wv'><p>Random Walk to WV</p></a></li>
<li><a href='#sarma_calculate_spadding'><p>Calculates Length of Seasonal Padding</p></a></li>
<li><a href='#sarma_components'><p>Determine parameter expansion based upon objdesc</p></a></li>
<li><a href='#sarma_expand'><p>Expand Parameters for an SARMA object</p></a></li>
<li><a href='#sarma_expand_unguided'><p>(Internal) Expand the SARMA Parameters</p></a></li>
<li><a href='#sarma_objdesc'><p>Create the ts.model obj.desc given split values</p></a></li>
<li><a href='#sarma_params_construct'><p>Efficient way to merge items together</p></a></li>
<li><a href='#scales_cpp'><p>Computes the MODWT scales</p></a></li>
<li><a href='#seq_cpp'><p>Generate a sequence of values</p></a></li>
<li><a href='#seq_len_cpp'><p>Generate a sequence of values based on supplied number</p></a></li>
<li><a href='#sp_hfilter'><p>Haar filter for a spatial case</p></a></li>
<li><a href='#sp_modwt_cpp'><p>Compute the Spatial Wavelet Coefficients</p></a></li>
<li><a href='#summary.dwt'><p>Summary Discrete Wavelet Transform</p></a></li>
<li><a href='#summary.modwt'><p>Summary Maximum Overlap Discrete Wavelet Transform</p></a></li>
<li><a href='#summary.wvar'><p>Summary of Wavelet Variances</p></a></li>
<li><a href='#theoretical_wv'><p>Model Process to WV</p></a></li>
<li><a href='#unitConversion'><p>Convert Unit of Time Series Data</p></a></li>
<li><a href='#wave_variance'><p>Generate a Wave Variance for a Univariate Time Series</p></a></li>
<li><a href='#wccv'><p>Cross Covariance of Matrix</p></a></li>
<li><a href='#wccv_get_y'><p>Mapping to log10 scale</p></a></li>
<li><a href='#wccv_pair'><p>Cross Covariance of a TS Pair</p></a></li>
<li><a href='#wn_to_wv'><p>Gaussian White Noise to WV</p></a></li>
<li><a href='#wvar'><p>Wavelet Variance</p></a></li>
<li><a href='#wvar_cpp'><p>Computes the (MODWT) wavelet variance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelet Variance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-29</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stéphane Guerrier &lt;stef.guerrier@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a series of tools to compute and plot quantities related to classical and robust wavelet variance for time series and regular lattices. More details can be found, for example, in Serroukh, A., Walden, A.T., &amp; Percival, D.B. (2000) &lt;<a href="https://doi.org/10.2307%2F2669537">doi:10.2307/2669537</a>&gt; and Guerrier, S. &amp; Molinari, R. (2016) &lt;<a href="https://doi.org/10.48550/arXiv.1607.05858">doi:10.48550/arXiv.1607.05858</a>&gt;.  </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, simts, utils, grDevices, coda, methods, graphics, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SMAC-Group/wv">https://github.com/SMAC-Group/wv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SMAC-Group/wv/issues">https://github.com/SMAC-Group/wv/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-30 08:10:40 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Stéphane Guerrier [aut, cre],
  James Balamuta [aut],
  Justin Lee [aut],
  Roberto Molinari [aut],
  Yuming Zhang [aut],
  Mucyo Karemera [aut],
  Nathanael Claussen [ctb],
  Haotian Xu [ctb],
  Lionel Voirol [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-31 04:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='wv'>wv</h2><span id='topic+wv'></span><span id='topic+wv-package'></span>

<h3>Description</h3>

<p>Provides a series of tools to compute and plot quantities related to classical and robust wavelet variance for time series and regular lattices. More details can be found, for example, in Serroukh, A., Walden, A.T., &amp; Percival, D.B. (2000) &lt;doi:10.2307/2669537&gt; and Guerrier, S. &amp; Molinari, R. (2016) &lt;arXiv:1607.05858&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stéphane Guerrier <a href="mailto:stef.guerrier@gmail.com">stef.guerrier@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> James Balamuta
</p>
</li>
<li><p> Justin Lee
</p>
</li>
<li><p> Roberto Molinari
</p>
</li>
<li><p> Yuming Zhang
</p>
</li>
<li><p> Mucyo Karemera
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Nathanael Claussen [contributor]
</p>
</li>
<li><p> Haotian Xu [contributor]
</p>
</li>
<li><p> Lionel Voirol [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/SMAC-Group/wv">https://github.com/SMAC-Group/wv</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/SMAC-Group/wv/issues">https://github.com/SMAC-Group/wv/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.acf'>Auto-Covariance and Correlation Functions</h2><span id='topic+.acf'></span>

<h3>Description</h3>

<p>The acf function computes the estimated
autocovariance or autocorrelation for both univariate and multivariate cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.acf(x, lagmax = 0L, cor = TRUE, demean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".acf_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> with dimensions <code class="reqn">N \times S</code> or N observations and S processes</p>
</td></tr>
<tr><td><code id=".acf_+3A_lagmax">lagmax</code></td>
<td>
<p>A <code>integer</code></p>
</td></tr>
<tr><td><code id=".acf_+3A_cor">cor</code></td>
<td>
<p>A <code>bool</code> indicating whether the correlation 
(<code>TRUE</code>) or covariance (<code>FALSE</code>) should be computed.</p>
</td></tr>
<tr><td><code id=".acf_+3A_demean">demean</code></td>
<td>
<p>A <code>bool</code> indicating whether the data should be detrended
(<code>TRUE</code>) or not (<code>FALSE</code>)</p>
</td></tr>
</table>

<hr>
<h2 id='ACF'>Auto-Covariance and Correlation Functions</h2><span id='topic+ACF'></span>

<h3>Description</h3>

<p>The ACF function computes the estimated
autocovariance or autocorrelation for both univariate and multivariate cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACF(x, lagmax = 0, cor = TRUE, demean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACF_+3A_x">x</code></td>
<td>
<p>A <code>matrix</code> with dimensions <code class="reqn">N \times S</code> or N observations and S processes</p>
</td></tr>
<tr><td><code id="ACF_+3A_lagmax">lagmax</code></td>
<td>
<p>A <code>integer</code> indicating the max lag.</p>
</td></tr>
<tr><td><code id="ACF_+3A_cor">cor</code></td>
<td>
<p>A <code>bool</code> indicating whether the correlation 
(<code>TRUE</code>) or covariance (<code>FALSE</code>) should be computed.</p>
</td></tr>
<tr><td><code id="ACF_+3A_demean">demean</code></td>
<td>
<p>A <code>bool</code> indicating whether the data should be detrended
(<code>TRUE</code>) or not (<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lagmax</code> default is <code class="reqn">10*log10(N/m)</code> where <code class="reqn">N</code> is the number of
observations and <code class="reqn">m</code> is the number of series being compared. If 
<code>lagmax</code> supplied is greater than the number of observations, then one
less than the total will be taken.
</p>


<h3>Value</h3>

<p>An <code>array</code> of dimensions <code class="reqn">N \times S \times S</code>.
</p>


<h3>Author(s)</h3>

<p>Yunxiang Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get Autocorrelation
m = ACF(datasets::AirPassengers)

# Get Autocovariance and do not remove trend from signal
m = ACF(datasets::AirPassengers, cor = FALSE, demean = FALSE)
</code></pre>

<hr>
<h2 id='acf_sum'>Helper Function for ARMA to WV Approximation</h2><span id='topic+acf_sum'></span>

<h3>Description</h3>

<p>Indicates where the minimum ARMAacf value is and returns that as an index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf_sum(ar, ma, last_tau, alpha = 0.99)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acf_sum_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the AR process</p>
</td></tr>
<tr><td><code id="acf_sum_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the MA process</p>
</td></tr>
<tr><td><code id="acf_sum_+3A_last_tau">last_tau</code></td>
<td>
<p>An <code>int</code> the Jth scale of 2^(1:J)</p>
</td></tr>
<tr><td><code id="acf_sum_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the cutoff.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the ARMA process.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arma_to_wv_app">arma_to_wv_app</a></code>
</p>

<hr>
<h2 id='adis_wv'>Wavelet variance of IMU Data from an ADIS 16405 sensor</h2><span id='topic+adis_wv'></span>

<h3>Description</h3>

<p>This data set contains wavelet variance of gyroscope and accelerometer data from an ADIS 16405 sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adis_wv
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;wvar&quot;: A list containing the computed wavelet variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data comes from Department of Geomatics Engineering, University of Calgary.
</p>

<hr>
<h2 id='ar1_to_wv'>AR(1) process to WV</h2><span id='topic+ar1_to_wv'></span>

<h3>Description</h3>

<p>This function computes the Haar WV of an AR(1) process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar1_to_wv(phi, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ar1_to_wv_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> that is the phi term of the AR(1) process</p>
</td></tr>
<tr><td><code id="ar1_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to variance of AR(1) process</p>
</td></tr>
<tr><td><code id="ar1_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is significantly faster than its generalized counter part
<code><a href="#topic+arma_to_wv">arma_to_wv</a></code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the AR(1) process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Autoregressive Order <code class="reqn">1</code> (AR(<code class="reqn">1</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{2{\sigma ^2}\left( {4{\phi ^{\frac{{{\tau _j}}}{2} + 1}} - {\phi ^{{\tau _j} + 1}} - \frac{1}{2}{\phi ^2}{\tau _j} + \frac{{{\tau _j}}}{2} - 3\phi } \right)}}{{{{\left( {1 - \phi } \right)}^2}\left( {1 - {\phi ^2}} \right)\tau _j^2}}</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+arma_to_wv">arma_to_wv</a></code>, <code><a href="#topic+arma11_to_wv">arma11_to_wv</a></code>
</p>

<hr>
<h2 id='arma_to_wv'>ARMA process to WV</h2><span id='topic+arma_to_wv'></span>

<h3>Description</h3>

<p>This function computes the Haar Wavelet Variance of an ARMA process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_to_wv(ar, ma, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_to_wv_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the AR process</p>
</td></tr>
<tr><td><code id="arma_to_wv_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the MA process</p>
</td></tr>
<tr><td><code id="arma_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> containing the residual variance</p>
</td></tr>
<tr><td><code id="arma_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a generic implementation that requires a stationary theoretical autocorrelation function (ACF)
and the ability to transform an ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>) process into an MA(<code class="reqn">\infty</code>) (e.g. infinite MA process).
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the ARMA process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Autoregressive Order <code class="reqn">p</code> and Moving Average Order <code class="reqn">q</code> (ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\tau _j}\left[ {1 - \rho \left( {\frac{{{\tau _j}}}{2}} \right)} \right] + 2\sum\limits_{i = 1}^{\frac{{{\tau _j}}}{2} - 1} {i\left[ {2\rho \left( {\frac{{{\tau _j}}}{2} - i} \right) - \rho \left( i \right) - \rho \left( {{\tau _j} - i} \right)} \right]} }}{{\tau _j^2}}\sigma _X^2</code>
</p>

<p>where <code class="reqn">\sigma _X^2</code> is given by the variance of the ARMA process. 
Furthermore, this assumes that stationarity has been achieved as it directly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARMAtoMA_cpp">ARMAtoMA_cpp</a></code>, <code><a href="#topic+ARMAacf_cpp">ARMAacf_cpp</a></code>, and <code><a href="#topic+arma11_to_wv">arma11_to_wv</a></code>
</p>

<hr>
<h2 id='arma_to_wv_app'>ARMA process to WV Approximation</h2><span id='topic+arma_to_wv_app'></span>

<h3>Description</h3>

<p>This function computes the (haar) WV of an ARMA process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_to_wv_app(ar, ma, sigma2, tau, alpha = 0.9999)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma_to_wv_app_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the AR process</p>
</td></tr>
<tr><td><code id="arma_to_wv_app_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> containing the coefficients of the MA process</p>
</td></tr>
<tr><td><code id="arma_to_wv_app_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> containing the residual variance</p>
</td></tr>
<tr><td><code id="arma_to_wv_app_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
<tr><td><code id="arma_to_wv_app_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> indicating the cutoff.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an approximation to the <code><a href="#topic+arma_to_wv">arma_to_wv</a></code> as computation times
were previously a concern. However, this is no longer the case and, thus, this has been left
in for the curious soul to discover...
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the ARMA process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Autoregressive Order <code class="reqn">p</code> and Moving Average Order <code class="reqn">q</code> (ARMA(<code class="reqn">p</code>,<code class="reqn">q</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\frac{{{\tau _j}\left[ {1 - \rho \left( {\frac{{{\tau _j}}}{2}} \right)} \right] + 2\sum\limits_{i = 1}^{\frac{{{\tau _j}}}{2} - 1} {i\left[ {2\rho \left( {\frac{{{\tau _j}}}{2} - i} \right) - \rho \left( i \right) - \rho \left( {{\tau _j} - i} \right)} \right]} }}{{\tau _j^2}}\sigma _X^2</code>
</p>

<p>where <code class="reqn">\sigma _X^2</code> is given by the variance of the ARMA process. 
Furthermore, this assumes that stationarity has been achieved as it directly
</p>


<h3>Haar Wavelet Derivation Information</h3>

<p>For more information, please see: blog post on SMAC group website.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARMAtoMA_cpp">ARMAtoMA_cpp</a></code>, <code><a href="#topic+ARMAacf_cpp">ARMAacf_cpp</a></code>, <code><a href="#topic+acf_sum">acf_sum</a></code> and <code><a href="#topic+arma_to_wv">arma_to_wv</a></code>
</p>

<hr>
<h2 id='arma11_to_wv'>ARMA(1,1) to WV</h2><span id='topic+arma11_to_wv'></span>

<h3>Description</h3>

<p>This function computes the WV (haar) of an Autoregressive Order 1 - Moving Average Order 1 (ARMA(1,1)) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma11_to_wv(phi, theta, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arma11_to_wv_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> corresponding to the autoregressive term.</p>
</td></tr>
<tr><td><code id="arma11_to_wv_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> corresponding to the moving average term.</p>
</td></tr>
<tr><td><code id="arma11_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> the variance of the process.</p>
</td></tr>
<tr><td><code id="arma11_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is significantly faster than its generalized counter part
<code><a href="#topic+arma_to_wv">arma_to_wv</a></code>
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the ARMA(1,1) process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Autoregressive Order <code class="reqn">1</code> and Moving Average Order <code class="reqn">1</code> (ARMA(<code class="reqn">1</code>,<code class="reqn">1</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {\phi ,\theta ,{\sigma ^2}} \right) =  - \frac{{2{\sigma ^2}\left( { - \frac{1}{2}{{(\theta  + 1)}^2}\left( {{\phi ^2} - 1} \right){\tau _j} - (\theta  + \phi )(\theta \phi  + 1)\left( {{\phi ^{{\tau _j}}} - 4{\phi ^{\frac{{{\tau _j}}}{2}}} + 3} \right)} \right)}}{{{{(\phi  - 1)}^3}(\phi  + 1)\tau _j^2}}</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+arma_to_wv">arma_to_wv</a></code>
</p>

<hr>
<h2 id='ARMAacf_cpp'>Compute Theoretical ACF for an ARMA Process</h2><span id='topic+ARMAacf_cpp'></span>

<h3>Description</h3>

<p>Compute the theoretical autocorrelation function for an ARMA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMAacf_cpp(ar,ma,lag_max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARMAacf_cpp_+3A_ar">ar</code></td>
<td>
<p>A <code>vector</code> of length p containing AR coefficients</p>
</td></tr>
<tr><td><code id="ARMAacf_cpp_+3A_ma">ma</code></td>
<td>
<p>A <code>vector</code> of length q containing MA coefficients</p>
</td></tr>
<tr><td><code id="ARMAacf_cpp_+3A_lag_max">lag_max</code></td>
<td>
<p>A <code>unsigned integer</code> indicating the maximum lag necessary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementaiton of the ARMAacf function in R. It is approximately 40x times faster. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
</p>


<h3>Value</h3>

<p>x A <code>matrix</code> listing values from 1...nx in one column and 1...1, 2...2,....,n...n, in the other
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='ARMAtoMA_cpp'>Converting an ARMA Process to an Infinite MA Process</h2><span id='topic+ARMAtoMA_cpp'></span>

<h3>Description</h3>

<p>Takes an ARMA function and converts it to an infinite MA process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMAtoMA_cpp(ar, ma, lag_max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARMAtoMA_cpp_+3A_ar">ar</code></td>
<td>
<p>A <code>column vector</code> of length p</p>
</td></tr>
<tr><td><code id="ARMAtoMA_cpp_+3A_ma">ma</code></td>
<td>
<p>A <code>column vector</code> of length q</p>
</td></tr>
<tr><td><code id="ARMAtoMA_cpp_+3A_lag_max">lag_max</code></td>
<td>
<p>A <code>int</code> of the largest MA(Inf) coefficient required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a port of the base stats package's ARMAtoMA. There is no significant speed difference between the two.
</p>


<h3>Value</h3>

<p>A <code>column vector</code> containing coefficients
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='av_ar1'>Calculate Theoretical Allan Variance for Stationary First-Order Autoregressive 
(AR1) Process</h2><span id='topic+av_ar1'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical allan variance for stationary 
first-order autoregressive (AR1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_ar1(n, phi, sigma2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="av_ar1_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> value for the size of the cluster.</p>
</td></tr>
<tr><td><code id="av_ar1_+3A_phi">phi</code></td>
<td>
<p>A <code>double</code> value for the autocorrection parameter <code class="reqn">\phi</code>.</p>
</td></tr>
<tr><td><code id="av_ar1_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> indicating the theoretical allan variance for AR1 process.
</p>


<h3>Note</h3>

<p>This function is based on the calculation of the theoretical allan variance 
for stationary AR1 process raised in &quot;Allan Variance of Time Series Models for 
Measurement Data&quot; by Nien Fan Zhang.) This calculation
is fundamental and necessary for the study in &quot;A Study of the Allan Variance for Constant-Mean 
Non-Stationary Processes&quot; by Xu et al. (IEEE Signal Processing Letters, 2017).
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>av1 = av_ar1(n = 5, phi = 0.9, sigma2 = 1)
av2 = av_ar1(n = 8, phi = 0.5, sigma2 = 2)
</code></pre>

<hr>
<h2 id='av_wn'>Calculate Theoretical Allan Variance for Stationary White Noise Process</h2><span id='topic+av_wn'></span>

<h3>Description</h3>

<p>This function allows us to calculate the theoretical allan variance for stationary 
white noise process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_wn(sigma2, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="av_wn_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> value for the variance parameter <code class="reqn">\sigma ^2</code>.</p>
</td></tr>
<tr><td><code id="av_wn_+3A_n">n</code></td>
<td>
<p>An <code>integer</code> value for the size of the cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> indicating the theoretical allan variance for the white noise
process.
</p>


<h3>Note</h3>

<p>This function is based on the calculation of the theoretical allan variance 
for stationary white noise process raised in &quot;Allan Variance of Time Series Models for 
Measurement Data&quot; by Nien Fan Zhang. This calculation
is fundamental and necessary for the study in &quot;A Study of the Allan Variance for Constant-Mean 
Non-Stationary Processes&quot; by Xu et al. (IEEE Signal Processing Letters, 2017).
</p>


<h3>Author(s)</h3>

<p>Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>av1 = av_wn(sigma2 = 1, n = 5)
av2 = av_wn(sigma2 = 2, n = 8)
</code></pre>

<hr>
<h2 id='batch_modwt_wvar_cpp'>Computes the MO/DWT wavelet variance for multiple processes</h2><span id='topic+batch_modwt_wvar_cpp'></span>

<h3>Description</h3>

<p>Calculates the MO/DWT wavelet variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch_modwt_wvar_cpp(
  signal,
  nlevels,
  robust,
  eff,
  alpha,
  ci_type,
  strWavelet,
  decomp
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batch_modwt_wvar_cpp_+3A_signal">signal</code></td>
<td>
<p>A <code>matrix</code> that contains the same number of observations per dataset</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)\times \alpha</code> confidence level</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_ci_type">ci_type</code></td>
<td>
<p>A <code>string</code> indicating the confidence interval being calculated. Valid value: &quot;eta3&quot;</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_strwavelet">strWavelet</code></td>
<td>
<p>A <code>string</code> indicating the type of wave filter to be applied. Must be &quot;haar&quot;</p>
</td></tr>
<tr><td><code id="batch_modwt_wvar_cpp_+3A_decomp">decomp</code></td>
<td>
<p>A <code>string</code> indicating whether to use &quot;modwt&quot; or &quot;dwt&quot; decomp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function processes the decomposition of multiple signals quickly
</p>


<h3>Value</h3>

<p>A <code>field&lt;mat&gt;</code> with the structure:
</p>

<ul>
<li><p>&quot;variance&quot;Wavelet Variance
</p>
</li>
<li><p>&quot;low&quot;Lower CI
</p>
</li>
<li><p>&quot;high&quot;Upper CI
</p>
</li></ul>


<hr>
<h2 id='cfilter'>Time Series Convolution Filters</h2><span id='topic+cfilter'></span>

<h3>Description</h3>

<p>Applies a convolution filter to a univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfilter(x, filter, sides, circular)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cfilter_+3A_x">x</code></td>
<td>
<p>A <code>column vector</code> of length T</p>
</td></tr>
<tr><td><code id="cfilter_+3A_filter">filter</code></td>
<td>
<p>A <code>column vector</code> of length f</p>
</td></tr>
<tr><td><code id="cfilter_+3A_sides">sides</code></td>
<td>
<p>An <code>int</code> that takes either 1:for using past values only or 2: filter coefficients are centered around lag 0.</p>
</td></tr>
<tr><td><code id="cfilter_+3A_circular">circular</code></td>
<td>
<p>A <code>bool</code> that indicates if the filter should be wrapped around the ends of the time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a port of the cfilter function harnessed by the filter function in stats. 
It is about 5-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
</p>


<h3>Value</h3>

<p>A <code>column vec</code> that contains the results of the filtering process.
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='ci_eta3'>Generate eta3 confidence interval</h2><span id='topic+ci_eta3'></span>

<h3>Description</h3>

<p>Computes the eta3 CI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_eta3(y, dims, alpha_ov_2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_eta3_+3A_y">y</code></td>
<td>
<p>A <code>vec</code> that computes the modwt dot product of each wavelet coefficient divided by their length.</p>
</td></tr>
<tr><td><code id="ci_eta3_+3A_dims">dims</code></td>
<td>
<p>A <code>String</code> indicating the confidence interval being calculated.</p>
</td></tr>
<tr><td><code id="ci_eta3_+3A_alpha_ov_2">alpha_ov_2</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)*\alpha</code> confidence level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> with the structure:
</p>

<ul>
<li><p>Column 1Wavelet Variance
</p>
</li>
<li><p>Column 2Chi-squared Lower Bounds
</p>
</li>
<li><p>Column 3Chi-squared Upper Bounds
</p>
</li></ul>


<hr>
<h2 id='ci_eta3_robust'>Generate eta3 robust confidence interval</h2><span id='topic+ci_eta3_robust'></span>

<h3>Description</h3>

<p>Computes the eta3 robust CI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_eta3_robust(wv_robust, wv_ci_class, alpha_ov_2, eff)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_eta3_robust_+3A_wv_robust">wv_robust</code></td>
<td>
<p>A <code>vec</code> that computes the modwt dot product of each wavelet coefficient divided by their length.</p>
</td></tr>
<tr><td><code id="ci_eta3_robust_+3A_wv_ci_class">wv_ci_class</code></td>
<td>
<p>A <code>mat</code> that contains the CI mean, CI Lower, and CI Upper</p>
</td></tr>
<tr><td><code id="ci_eta3_robust_+3A_alpha_ov_2">alpha_ov_2</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)*\alpha</code> confidence level</p>
</td></tr>
<tr><td><code id="ci_eta3_robust_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Within this function we are scaling the classical
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with the structure:
</p>

<ul>
<li><p>Column 1Robust Wavelet Variance
</p>
</li>
<li><p>Column 2Chi-squared Lower Bounds
</p>
</li>
<li><p>Column 3Chi-squared Upper Bounds
</p>
</li></ul>


<hr>
<h2 id='ci_wave_variance'>Generate a Confidence interval for a Univariate Time Series</h2><span id='topic+ci_wave_variance'></span>

<h3>Description</h3>

<p>Computes an estimate of the multiscale variance and a chi-squared confidence interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_wave_variance(
  signal_modwt_bw,
  wv,
  type = "eta3",
  alpha_ov_2 = 0.025,
  robust = FALSE,
  eff = 0.6
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_wave_variance_+3A_signal_modwt_bw">signal_modwt_bw</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains the modwt or dwt decomposition</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_wv">wv</code></td>
<td>
<p>A <code>vec</code> that contains the wave variance.</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_type">type</code></td>
<td>
<p>A <code>String</code> indicating the confidence interval being calculated.</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_alpha_ov_2">alpha_ov_2</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)*\alpha</code> confidence level.</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> to determine the type of wave estimation.</p>
</td></tr>
<tr><td><code id="ci_wave_variance_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be expanded to allow for other confidence interval calculations.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with the structure:
</p>

<ul>
<li><p>Column 1Wavelet Variance
</p>
</li>
<li><p>Column 2Chi-squared Lower Bounds
</p>
</li>
<li><p>Column 3Chi-squared Upper Bounds
</p>
</li></ul>


<hr>
<h2 id='compare_wvar'>Comparison Between Multiple Wavelet Variances</h2><span id='topic+compare_wvar'></span>

<h3>Description</h3>

<p>Displays plots of multiple wavelet variances of different time series accounting for CI values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_wvar(
  ...,
  split = FALSE,
  add_legend = TRUE,
  units = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_wv = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  legend_position = NULL,
  ci_wv = NULL,
  point_cex = NULL,
  point_pch = NULL,
  names = NULL,
  cex_labels = 0.8,
  x_range = NULL,
  y_range = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_wvar_+3A_...">...</code></td>
<td>
<p>One or more time series objects.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_split">split</code></td>
<td>
<p>A <code>boolean</code> that, if TRUE, arranges the plots into a matrix-like format.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_add_legend">add_legend</code></td>
<td>
<p>A <code>boolean</code> that, if TRUE, adds a legend to the plot.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_units">units</code></td>
<td>
<p>A <code>string</code> that specifies the units of time plotted on the x axes. Note: This argument will not be used if xlab is specified.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axes.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axes.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_col_wv">col_wv</code></td>
<td>
<p>A <code>string</code> that specifies the color of the wavelet variance lines.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the confidence interval shade.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_legend_position">legend_position</code></td>
<td>
<p>A <code>string</code> that specifies the position of the legend (use <code>legend_position = NA</code> to remove legend).</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_ci_wv">ci_wv</code></td>
<td>
<p>A <code>boolean</code> that determines whether confidence interval polygons will be drawn.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_point_cex">point_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of each symbol to be plotted.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_point_pch">point_pch</code></td>
<td>
<p>A <code>double</code> that specifies the symbol type to be plotted.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_names">names</code></td>
<td>
<p>A <code>string</code> that specifies the name of the WVAR objects.</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_cex_labels">cex_labels</code></td>
<td>
<p>A <code>double</code> that specifies the magnification of the labels (x and y).</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_x_range">x_range</code></td>
<td>
<p>A <code>vector</code> that specifies the range of values on the x axis (default NULL).</p>
</td></tr>
<tr><td><code id="compare_wvar_+3A_y_range">y_range</code></td>
<td>
<p>A <code>vector</code> that specifies the range of values on the y axis (default NULL).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stephane Guerrier and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
n = 10^4
Xt = arima.sim(n = n, list(ar = 0.10))
Yt = arima.sim(n = n, list(ar = 0.35))
Zt = arima.sim(n = n, list(ar = 0.70))
Wt = arima.sim(n = n, list(ar = 0.95))

wv_Xt = wvar(Xt)
wv_Yt = wvar(Yt)
wv_Zt = wvar(Zt)
wv_Wt = wvar(Wt)

compare_wvar(wv_Xt, wv_Yt, wv_Zt, wv_Wt)
</code></pre>

<hr>
<h2 id='compare_wvar_no_split'>Combined Plot Comparison Between Multiple Wavelet Variances</h2><span id='topic+compare_wvar_no_split'></span>

<h3>Description</h3>

<p>This is a helper function for the <code>compare_var()</code> function. 
This method accepts the same set of arguments as <code>compare_wvar</code> and returns a single plot
that compares multiple wavelet variances of different time series accounting for CI values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_wvar_no_split(graph_details)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_wvar_no_split_+3A_graph_details">graph_details</code></td>
<td>
<p>List of inputs</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stephane Guerrier, Justin Lee, and Nathanael Claussen
</p>

<hr>
<h2 id='compare_wvar_split'>Multi-Plot Comparison Between Multiple Wavelet Variances</h2><span id='topic+compare_wvar_split'></span>

<h3>Description</h3>

<p>This is a helper function for the <code>compare_var()</code> function. 
This method accepts the same set of arguments as <code>compare_wvar</code> and returns a comparision 
of multiple wavelet variances of different time series accounting for CI values as a set of different plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_wvar_split(graph_details)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_wvar_split_+3A_graph_details">graph_details</code></td>
<td>
<p>List of inputs</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stephane Guerrier, Justin Lee, and Nathanael Claussen
</p>

<hr>
<h2 id='create_wvar'>Create a <code>wvar</code> object</h2><span id='topic+create_wvar'></span>

<h3>Description</h3>

<p>Structures elements into a <code>wvar</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_wvar(
  obj,
  decomp,
  filter,
  robust,
  eff,
  alpha,
  scales,
  unit,
  mean_diff,
  N,
  ranged,
  J
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_wvar_+3A_obj">obj</code></td>
<td>
<p>A <code>matrix</code> with dimensions N x 3 that contains Wavelet Variance, Lower CI, and Upper CI.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_decomp">decomp</code></td>
<td>
<p>A <code>string</code> that indicates whether to use a &quot;dwt&quot; or &quot;modwt&quot; decomposition.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_filter">filter</code></td>
<td>
<p>A <code>string</code> that specifies the type of wavelet filter used in the decomposition.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that specifies the significance level which in turn specifies the <code class="reqn">1-\alpha</code> confidence level.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_scales">scales</code></td>
<td>
<p>A <code>vec</code> that contains the amount of decomposition performed at each level.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_unit">unit</code></td>
<td>
<p>A <code>string</code> that indicates the unit expression of the frequency.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_mean_diff">mean_diff</code></td>
<td>
<p>A <code>double</code> that specified the empirical mean of the first difference.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_n">N</code></td>
<td>
<p>A <code>integer</code> that specified the empirical length of the time series.</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_ranged">ranged</code></td>
<td>
<p>A <code>double</code> that specified the scaled range of the data, i.e. (max(x) - min(x))/length(x).</p>
</td></tr>
<tr><td><code id="create_wvar_+3A_j">J</code></td>
<td>
<p>A <code>integer</code> that specified the number of scales.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> with the structure:
</p>

<ul>
<li><p> &quot;variance&quot;: Wavelet variance
</p>
</li>
<li><p> &quot;ci_low&quot;: Lower CI
</p>
</li>
<li><p> &quot;ci_high&quot;: Upper CI
</p>
</li>
<li><p> &quot;robust&quot;: Robust active
</p>
</li>
<li><p> &quot;eff&quot;: Efficiency level for robust calculation
</p>
</li>
<li><p> &quot;alpha&quot;: p value used for CI
</p>
</li>
<li><p> &quot;unit&quot;: String representation of the unit
</p>
</li>
<li><p> &quot;mean_diff&quot;: Empirical mean of the first difference
</p>
</li>
<li><p> &quot;N&quot;: Length of the time series
</p>
</li>
<li><p> &quot;ranged&quot;: Scaled range of the data, i.e. (max(x) - min(x))/length(x)
</p>
</li>
<li><p> &quot;J&quot;: Number of scales
</p>
</li></ul>


<hr>
<h2 id='decomp_theoretical_wv'>Each Models Process Decomposed to WV</h2><span id='topic+decomp_theoretical_wv'></span>

<h3>Description</h3>

<p>This function computes each process to WV (haar) in a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp_theoretical_wv(theta, desc, objdesc, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decomp_theoretical_wv_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the list of estimated parameters.</p>
</td></tr>
<tr><td><code id="decomp_theoretical_wv_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> containing a list of descriptors.</p>
</td></tr>
<tr><td><code id="decomp_theoretical_wv_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of object descriptors.</p>
</td></tr>
<tr><td><code id="decomp_theoretical_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mat</code> containing the wavelet variance of each process in the model
</p>

<hr>
<h2 id='decomp_to_theo_wv'>Decomposed WV to Single WV</h2><span id='topic+decomp_to_theo_wv'></span>

<h3>Description</h3>

<p>This function computes the combined processes to WV (haar) in a given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomp_to_theo_wv(decomp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decomp_to_theo_wv_+3A_decomp">decomp</code></td>
<td>
<p>A <code>mat</code> with scales as rows and processes as columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the process for the overall model
</p>

<hr>
<h2 id='dft_acf'>Discrete Fourier Transformation for Autocovariance Function</h2><span id='topic+dft_acf'></span>

<h3>Description</h3>

<p>Calculates the autovariance function (ACF) using Discrete Fourier Transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dft_acf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dft_acf_+3A_x">x</code></td>
<td>
<p>A <code>cx_vec</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation is 2x as slow as Rs. 
Two issues: 1. memory resize and 2. unoptimized fft algorithm in arma.
Consider piping back into R and rewrapping the object. (Decrease of about 10 microseconds.)
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the ACF.
</p>

<hr>
<h2 id='diff_cpp'>Lagged Differences in Armadillo</h2><span id='topic+diff_cpp'></span>

<h3>Description</h3>

<p>Returns the ith difference of a time series of rth lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_cpp(x, lag, differences)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diff_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> that is the time series</p>
</td></tr>
<tr><td><code id="diff_cpp_+3A_lag">lag</code></td>
<td>
<p>A <code>unsigned int</code> that indicates the lag</p>
</td></tr>
<tr><td><code id="diff_cpp_+3A_differences">differences</code></td>
<td>
<p>A <code>dif</code> that indicates how many differences should be taken</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing the differenced time series.
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='dr_to_wv'>Drift to WV</h2><span id='topic+dr_to_wv'></span>

<h3>Description</h3>

<p>This function compute the WV (haar) of a Drift process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr_to_wv(omega, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dr_to_wv_+3A_omega">omega</code></td>
<td>
<p>A <code>double</code> corresponding to the slope of the drift</p>
</td></tr>
<tr><td><code id="dr_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the drift.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Drift (DR) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn"> \nu _j^2\left( {{\omega }} \right) = \frac{{\tau _j^2{\omega ^2}}}{{16}}  </code>
</p>


<hr>
<h2 id='dwt'>Discrete Wavelet Transform</h2><span id='topic+dwt'></span>

<h3>Description</h3>

<p>Calculation of the coefficients for the discrete wavelet transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt(x, nlevels = floor(log2(length(x))), filter = "haar")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dwt_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1.</p>
</td></tr>
<tr><td><code id="dwt_+3A_nlevels">nlevels</code></td>
<td>
<p>A <code>integer</code> indicating the <code class="reqn">J</code> levels of decomposition.</p>
</td></tr>
<tr><td><code id="dwt_+3A_filter">filter</code></td>
<td>
<p>A <code>string</code> indicating the filter name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a level <code class="reqn">J</code> decomposition of the time series using the pyramid algorithm.
The default <code class="reqn">J</code> is determined by <code class="reqn">floor\left(log_2 \left(length\left(x\right)\right)\right)</code>
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains the wavelet coefficients for each decomposition level
</p>


<h3>Author(s)</h3>

<p>James Balamuta, Justin Lee and Stephane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(2^8)
ret = dwt(x)

summary(ret)

plot(ret)
</code></pre>

<hr>
<h2 id='dwt_cpp'>Discrete Wavelet Transform</h2><span id='topic+dwt_cpp'></span>

<h3>Description</h3>

<p>Calculation of the coefficients for the discrete wavelet transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwt_cpp(x, filter_name, nlevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dwt_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions <code class="reqn">N\times 1</code>.</p>
</td></tr>
<tr><td><code id="dwt_cpp_+3A_filter_name">filter_name</code></td>
<td>
<p>A <code>string</code> indicating the filter.</p>
</td></tr>
<tr><td><code id="dwt_cpp_+3A_nlevels">nlevels</code></td>
<td>
<p>An <code>integer</code>, <code class="reqn">J</code>, indicating the level of the decomposition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a level J decomposition of the time series using the pyramid algorithm
</p>


<h3>Value</h3>

<p>y A <code>field&lt;vec&gt;</code> that contains the wavelet coefficients for each decomposition level
</p>


<h3>Author(s)</h3>

<p>James Balamuta and Justin Lee
</p>

<hr>
<h2 id='imar_wv'>Wavelet variance of IMU Data from IMAR Gyroscopes</h2><span id='topic+imar_wv'></span>

<h3>Description</h3>

<p>This data set contains wavelet variance of IMAR gyroscopes data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imar_wv
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;wvar&quot;: A list containing the computed wavelet variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data comes from Geodetic Engineering Laboratory (TOPO) and Swiss Federal Institute of Technology Lausanne (EPFL).
</p>

<hr>
<h2 id='intgr_vec'>Discrete Intergral: Inverse Difference</h2><span id='topic+intgr_vec'></span><span id='topic+diff_inv_values'></span><span id='topic+diff_inv'></span>

<h3>Description</h3>

<p>Takes the inverse difference (e.g. goes from diff() result back to previous vector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intgr_vec(x, xi, lag)

diff_inv_values(x, lag, d, xi)

diff_inv(x, lag, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intgr_vec_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing the data</p>
</td></tr>
<tr><td><code id="intgr_vec_+3A_xi">xi</code></td>
<td>
<p>A <code>vec</code> with length <code class="reqn">lag*d</code> that provides initial values for the integration.</p>
</td></tr>
<tr><td><code id="intgr_vec_+3A_lag">lag</code></td>
<td>
<p>An <code>unsigned int</code> indicating the lag between observations.</p>
</td></tr>
<tr><td><code id="intgr_vec_+3A_d">d</code></td>
<td>
<p>An <code>unsigned int</code> which gives the number of &quot;differences&quot; to invert.</p>
</td></tr>
</table>

<hr>
<h2 id='kvh1750_wv'>Wavelet variance of IMU Data from a KVH1750 IMU  sensor</h2><span id='topic+kvh1750_wv'></span>

<h3>Description</h3>

<p>This data set contains wavelet variance of gyroscope and accelerometer data from an KVH1750 sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kvh1750_wv
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;wvar&quot;: A list containing the computed wavelet variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data comes from Department of Geomatics Engineering, University of Calgary.
</p>

<hr>
<h2 id='ln200_wv'>Wavelet variance of IMU Data from a LN200 sensor</h2><span id='topic+ln200_wv'></span>

<h3>Description</h3>

<p>This data set contains wavelet variance of LN200 gyroscope and accelerometer data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ln200_wv
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;wvar&quot;: A list containing the computed wavelet variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data comes from Geodetic Engineering Laboratory (TOPO) and Swiss Federal Institute of Technology Lausanne (EPFL).
</p>

<hr>
<h2 id='ma1_to_wv'>Moving Average Order 1 (MA(1)) to WV</h2><span id='topic+ma1_to_wv'></span>

<h3>Description</h3>

<p>This function computes the WV (haar) of a Moving Average order 1 (MA1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ma1_to_wv(theta, sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ma1_to_wv_+3A_theta">theta</code></td>
<td>
<p>A <code>double</code> corresponding to the moving average term.</p>
</td></tr>
<tr><td><code id="ma1_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> the variance of the process.</p>
</td></tr>
<tr><td><code id="ma1_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is significantly faster than its generalized counter part
<code><a href="#topic+arma_to_wv">arma_to_wv</a></code>.
</p>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the MA(1) process.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Moving Average Order <code class="reqn">1</code> (MA(<code class="reqn">1</code>)) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {\theta ,{\sigma ^2}} \right) = \frac{{\left( {{{\left( {\theta  + 1} \right)}^2}{\tau _j} - 6\theta } \right){\sigma ^2}}}{{\tau _j^2}}</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+arma_to_wv">arma_to_wv</a></code>, <code><a href="#topic+arma11_to_wv">arma11_to_wv</a></code>
</p>

<hr>
<h2 id='mean_diff'>Mean of the First Difference of the Data</h2><span id='topic+mean_diff'></span>

<h3>Description</h3>

<p>The mean of the first difference of the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_diff(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_diff_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>double</code> that contains the mean of the first difference of the data.
</p>

<hr>
<h2 id='modwt'>Maximum Overlap Discrete Wavelet Transform</h2><span id='topic+modwt'></span>

<h3>Description</h3>

<p>Calculates the coefficients for the discrete wavelet transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt(x, nlevels = floor(log2(length(x) - 1)), filter = "haar")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modwt_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1.</p>
</td></tr>
<tr><td><code id="modwt_+3A_nlevels">nlevels</code></td>
<td>
<p>A <code>integer</code> indicating the <code class="reqn">J</code> levels of decomposition.</p>
</td></tr>
<tr><td><code id="modwt_+3A_filter">filter</code></td>
<td>
<p>A <code>string</code> indicating the filter name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a level <code class="reqn">J</code> decomposition of the time series using the pyramid algorithm.
The default <code class="reqn">J</code> is determined by <code class="reqn">floor\left(log_2 \left(length\left(x\right)\right)\right)</code>
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains the wavelet coefficients for each decomposition level
</p>


<h3>Author(s)</h3>

<p>James Balamuta, Justin Lee and Stephane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(100)
ret = modwt(x)

summary(ret)

plot(ret)
</code></pre>

<hr>
<h2 id='modwt_cpp'>Maximum Overlap Discrete Wavelet Transform</h2><span id='topic+modwt_cpp'></span>

<h3>Description</h3>

<p>Calculation of the coefficients for the discrete wavelet transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt_cpp(x, filter_name, nlevels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modwt_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions <code class="reqn">N\times 1</code>.</p>
</td></tr>
<tr><td><code id="modwt_cpp_+3A_filter_name">filter_name</code></td>
<td>
<p>A <code>string</code> indicating the filter.</p>
</td></tr>
<tr><td><code id="modwt_cpp_+3A_nlevels">nlevels</code></td>
<td>
<p>An <code>integer</code>, <code class="reqn">J</code>, indicating the level of the decomposition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a level J decomposition of the time series using the pyramid algorithm.
Use this implementation to supply custom parameters instead of modwt(x),
which serves as a wrapper function.
</p>


<h3>Value</h3>

<p>y A <code>field&lt;vec&gt;</code> that contains the wavelet coefficients for each decomposition level
</p>


<h3>Author(s)</h3>

<p>James Balamuta and Justin Lee
</p>

<hr>
<h2 id='modwt_wvar_cpp'>Computes the (MODWT) wavelet variance</h2><span id='topic+modwt_wvar_cpp'></span>

<h3>Description</h3>

<p>Calculates the (MODWT) wavelet variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modwt_wvar_cpp(
  signal,
  nlevels,
  robust,
  eff,
  alpha,
  ci_type,
  strWavelet,
  decomp
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modwt_wvar_cpp_+3A_signal">signal</code></td>
<td>
<p>A <code>vec</code> that contains the data.</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)\times \alpha</code> confidence level</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_ci_type">ci_type</code></td>
<td>
<p>A <code>string</code> indicating the confidence interval being calculated. Valid value: &quot;eta3&quot;</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_strwavelet">strWavelet</code></td>
<td>
<p>A <code>string</code> indicating the type of wave filter to be applied. Must be &quot;haar&quot;</p>
</td></tr>
<tr><td><code id="modwt_wvar_cpp_+3A_decomp">decomp</code></td>
<td>
<p>A <code>string</code> indicating whether to use &quot;modwt&quot; or &quot;dwt&quot; decomp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function powers the wvar object. It is also extendable...
</p>


<h3>Value</h3>

<p>A <code>mat</code> with the structure:
</p>

<ul>
<li><p>&quot;variance&quot;Wavelet Variance
</p>
</li>
<li><p>&quot;low&quot;Lower CI
</p>
</li>
<li><p>&quot;high&quot;Upper CI
</p>
</li></ul>


<hr>
<h2 id='navchip_wv'>Wavelet variance of IMU Data from a navchip sensor</h2><span id='topic+navchip_wv'></span>

<h3>Description</h3>

<p>This data set contains wavelet variance of gyroscope and accelerometer data from a navchip sensor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navchip_wv
</code></pre>


<h3>Format</h3>

<p>A list of the following elements:
</p>

<ul>
<li><p> &quot;sensor&quot;: Name of the sensor.
</p>
</li>
<li><p> &quot;freq&quot;: The frequency at which the error signal is measured.
</p>
</li>
<li><p> &quot;n&quot;: Sample size of the data.
</p>
</li>
<li><p> &quot;type&quot;: The types of sensors considered in the data.
</p>
</li>
<li><p> &quot;axis&quot;: The axes of sensors considered in the data.
</p>
</li>
<li><p> &quot;wvar&quot;: A list containing the computed wavelet variance based on the data.
</p>
</li></ul>



<h3>Source</h3>

<p>The IMU data of the navchip sensor comes from Geodetic Engineering Laboratory (TOPO) and Swiss Federal Institute of Technology Lausanne (EPFL).
</p>

<hr>
<h2 id='num_rep'>Replicate a Vector of Elements <code class="reqn">n</code> times</h2><span id='topic+num_rep'></span>

<h3>Description</h3>

<p>This function takes a vector and replicates all of the data <code class="reqn">n</code> times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_rep(x, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="num_rep_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> containing the data</p>
</td></tr>
<tr><td><code id="num_rep_+3A_n">n</code></td>
<td>
<p>An <code>unsigned int</code> indicating the number of times the vector should be repeated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with repeated elements of the initial supplied vector.
</p>

<hr>
<h2 id='plot.auto_corr'>Auto-Covariance and Correlation Functions</h2><span id='topic+plot.auto_corr'></span>

<h3>Description</h3>

<p>The acf function computes the estimated
autocovariance or autocorrelation for both univariate and multivariate cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'auto_corr'
plot(x, show.ci = TRUE, alpha = 0.05, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.auto_corr_+3A_x">x</code></td>
<td>
<p>An <code>"ACF"</code> object from <code><a href="#topic+ACF">ACF</a></code>.</p>
</td></tr>
<tr><td><code id="plot.auto_corr_+3A_show.ci">show.ci</code></td>
<td>
<p>A <code>bool</code> indicating whether to show confidence region</p>
</td></tr>
<tr><td><code id="plot.auto_corr_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
<tr><td><code id="plot.auto_corr_+3A_ci">ci</code></td>
<td>
<p>A <code>double</code> containing the 1-alpha level. Default is 0.95</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>array</code> of dimensions <code class="reqn">N \times S \times S</code>.
</p>


<h3>Author(s)</h3>

<p>Yunxiang Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the Autocorrelation
m = ACF(datasets::AirPassengers)

# Plot with 95% CI
plot(m) 

# Plot with 90% CI
plot(m, ci = 0.90) 

# Plot without 95% CI
plot(m, show.ci = FALSE)
</code></pre>

<hr>
<h2 id='plot.dwt'>Plot Discrete Wavelet Transform</h2><span id='topic+plot.dwt'></span>

<h3>Description</h3>

<p>Plots results of the dwt list in which additional parameters can be specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dwt'
plot(x, index = NULL, couleur = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dwt_+3A_x">x</code></td>
<td>
<p>A <code>dwt</code> object.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_index">index</code></td>
<td>
<p>A <code>vector</code> containing the indices to scales to be included in 
the graph. By default <code>index = 1:(min(c(J,4)))</code>, where <code>J</code> denotes the 
number of scales in <code>y</code>.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_couleur">couleur</code></td>
<td>
<p>A <code>vector</code> of colors of the same size as <code>index</code> used
for the different scales depicted in the graph. If <code>couleur</code> contains a single 
value the the same color will be used for all scales.</p>
</td></tr>
<tr><td><code id="plot.dwt_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the plot produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Justin Lee and Stephane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a Gaussian white noise
n = 10^3
Xt = rnorm(n)

# dwt
Yt = dwt(Xt)

# Graph examples
plot(Yt)
plot(Yt, index = c(1,4,5,6,8,2))
plot(Yt, index = c(1,4,5,6), couleur = "blue")
plot(Yt, index = c(1,4,5,6), couleur = rep(c("blue","yellow"),2))
</code></pre>

<hr>
<h2 id='plot.imu_wvar'>Plot Wavelet Variance based on IMU Data</h2><span id='topic+plot.imu_wvar'></span>

<h3>Description</h3>

<p>Displays a plot of wavelet variance accounting for CI values and supplied efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imu_wvar'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_wv = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  ci_wv = NULL,
  point_cex = NULL,
  point_pch = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.imu_wvar_+3A_x">x</code></td>
<td>
<p>A <code>wvar</code> object.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_col_wv">col_wv</code></td>
<td>
<p>A <code>string</code> that specifies the color of the wavelet variance line.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the confidence interval polygon.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_ci_wv">ci_wv</code></td>
<td>
<p>A <code>boolean</code> that determines whether a confidence interval polygon will be drawn.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_point_cex">point_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of each symbol to be plotted.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_point_pch">point_pch</code></td>
<td>
<p>A <code>double</code> that specifies the symbol type to be plotted.</p>
</td></tr>
<tr><td><code id="plot.imu_wvar_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of wavelet variance and confidence interval for each scale.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier and Yuming Zhang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("kvh1750_wv")
plot(kvh1750_wv)
</code></pre>

<hr>
<h2 id='plot.modwt'>Plot Maximum Overlap Discrete Wavelet Transform</h2><span id='topic+plot.modwt'></span>

<h3>Description</h3>

<p>Plots results of the modwt list in which additional parameters can be specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modwt'
plot(x, index = NULL, couleur = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.modwt_+3A_x">x</code></td>
<td>
<p>A <code>modwt</code> object.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_index">index</code></td>
<td>
<p>A <code>vector</code> containing the indices to scales to be included in 
the graph. By default <code>index = 1:(min(c(J,4)))</code>, where <code>J</code> denotes the 
number of scales in <code>y</code>.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_couleur">couleur</code></td>
<td>
<p>A <code>vector</code> of colors of the same size as <code>index</code> used
for the different scales depicted in the graph. If <code>couleur</code> contains a single 
value the the same color will be used for all scales.</p>
</td></tr>
<tr><td><code id="plot.modwt_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the plot produced.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Justin Lee and Stephane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a Gaussian white noise
n = 10^3
Xt = rnorm(n)

# MODWT
Yt = modwt(Xt)

# Graph examples
plot(Yt)
plot(Yt, index = c(1,4,5,6,8,2))
plot(Yt, index = c(1,4,5,6), couleur = "blue")
plot(Yt, index = c(1,4,5,6), couleur = rep(c("blue","yellow"),2))
</code></pre>

<hr>
<h2 id='plot.wccv_pair'>Plot Cross Covariance Pair</h2><span id='topic+plot.wccv_pair'></span>

<h3>Description</h3>

<p>Plots results of the a wccv_pair list in which additional parameters can be specified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wccv_pair'
plot(
  x,
  theo.wccv = NULL,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  units = NULL,
  col_wccv = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  ...
)
</code></pre>


<h3>Author(s)</h3>

<p>Justin Lee, Haotian Xu, and Stephane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 10^5
Xt = cumsum(rnorm(n, 0, 0.01))
Wt = Xt + rnorm(n)
Yt = Xt + rnorm(n)
wcov = wccv_pair(Wt, Yt)
plot(wcov)
</code></pre>

<hr>
<h2 id='plot.wvar'>Plot Wavelet Variance</h2><span id='topic+plot.wvar'></span>

<h3>Description</h3>

<p>Displays a plot of wavelet variance accounting for CI values and supplied efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wvar'
plot(
  x,
  units = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_wv = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  legend_position = NULL,
  ci_wv = NULL,
  point_cex = NULL,
  point_pch = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.wvar_+3A_x">x</code></td>
<td>
<p>A <code>wvar</code> object.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_units">units</code></td>
<td>
<p>A <code>string</code> that specifies the units of time plotted on the x axis.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_col_wv">col_wv</code></td>
<td>
<p>A <code>string</code> that specifies the color of the wavelet variance line.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the confidence interval polygon.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_legend_position">legend_position</code></td>
<td>
<p>A <code>string</code> that specifies the position of the legend (use <code>legend_position = NA</code> to remove legend).</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_ci_wv">ci_wv</code></td>
<td>
<p>A <code>boolean</code> that determines whether a confidence interval polygon will be drawn.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_point_cex">point_cex</code></td>
<td>
<p>A <code>double</code> that specifies the size of each symbol to be plotted.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_point_pch">point_pch</code></td>
<td>
<p>A <code>double</code> that specifies the symbol type to be plotted.</p>
</td></tr>
<tr><td><code id="plot.wvar_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of wavelet variance and confidence interval for each scale.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier, Nathanael Claussen, and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
n = 10^4
Xt = rnorm(n)
wv = wvar(Xt)
plot(wv)
plot(wv, main = "Simulated white noise", xlab = "Scales")
plot(wv, units = "sec", legend_position = "topright")
plot(wv, col_wv = "darkred", col_ci = "pink")
</code></pre>

<hr>
<h2 id='print.dwt'>Print Discrete Wavelet Transform</h2><span id='topic+print.dwt'></span>

<h3>Description</h3>

<p>Prints the results of the modwt list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dwt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.dwt_+3A_x">x</code></td>
<td>
<p>A <code>dwt</code> object</p>
</td></tr>
<tr><td><code id="print.dwt_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the dwt decomposition
</p>


<h3>Author(s)</h3>

<p>James Balamuta and Nathanael Claussen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(2^8)
print(dwt(x))
</code></pre>

<hr>
<h2 id='print.modwt'>Print Maximum Overlap Discrete Wavelet Transform</h2><span id='topic+print.modwt'></span>

<h3>Description</h3>

<p>Prints the results of the modwt list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modwt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.modwt_+3A_x">x</code></td>
<td>
<p>A <code>modwt</code> object</p>
</td></tr>
<tr><td><code id="print.modwt_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the modwt decomposition
</p>


<h3>Author(s)</h3>

<p>James Balamuta and Nathanael Claussen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(100)
print(modwt(x))
</code></pre>

<hr>
<h2 id='print.wvar'>Print Wavelet Variances</h2><span id='topic+print.wvar'></span>

<h3>Description</h3>

<p>Displays the summary table of wavelet variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wvar'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.wvar_+3A_x">x</code></td>
<td>
<p>A <code>wvar</code> object.</p>
</td></tr>
<tr><td><code id="print.wvar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary table
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(100)
out = wvar(x)
print( out )
</code></pre>

<hr>
<h2 id='qn_to_wv'>Quantisation Noise (QN) to WV</h2><span id='topic+qn_to_wv'></span>

<h3>Description</h3>

<p>This function compute the Haar WV of a Quantisation Noise (QN) process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qn_to_wv(q2, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qn_to_wv_+3A_q2">q2</code></td>
<td>
<p>A <code>double</code> corresponding to variance of drift</p>
</td></tr>
<tr><td><code id="qn_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the QN.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Quantization Noise (QN) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {{Q^2}} \right) = \frac{{6{Q^2}}}{{\tau _j^2}}</code>
</p>


<hr>
<h2 id='quantile_cpp'>Find Quantiles</h2><span id='topic+quantile_cpp'></span>

<h3>Description</h3>

<p>Attempts to find quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_cpp(x, probs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile_cpp_+3A_x">x</code></td>
<td>
<p>A <code>vec</code> of data</p>
</td></tr>
<tr><td><code id="quantile_cpp_+3A_probs">probs</code></td>
<td>
<p>A <code>vec</code> of the quantiles to find.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing the quantiles
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='rfilter'>Time Series Recursive Filters</h2><span id='topic+rfilter'></span>

<h3>Description</h3>

<p>Applies a recursive filter to a univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfilter(x, filter, init)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfilter_+3A_x">x</code></td>
<td>
<p>A <code>column vector</code> of length T</p>
</td></tr>
<tr><td><code id="rfilter_+3A_filter">filter</code></td>
<td>
<p>A <code>column vector</code> of length f</p>
</td></tr>
<tr><td><code id="rfilter_+3A_init">init</code></td>
<td>
<p>A <code>column vector</code> of length f that contains the initial values of the time series in reverse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: The length of 'init' must be equal to the length of 'filter'.
This is a port of the rfilter function harnessed by the filter function in stats. 
It is about 6-7 times faster than R's base function. The benchmark was done on iMac Late 2013 using vecLib as the BLAS.
</p>


<h3>Value</h3>

<p>x A <code>column vector</code> with its contents reversed.
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='robust_eda'>Comparison between classical and robust Wavelet Variances</h2><span id='topic+robust_eda'></span>

<h3>Description</h3>

<p>Displays a plot of the wavelet variances (classical and robust) for a given time series accounting for CI values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_eda(
  x,
  eff = 0.6,
  units = NULL,
  xlab = NULL,
  ylab = NULL,
  main = NULL,
  col_wv = NULL,
  col_ci = NULL,
  nb_ticks_x = NULL,
  nb_ticks_y = NULL,
  legend_position = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_eda_+3A_x">x</code></td>
<td>
<p>A time series objects.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_eff">eff</code></td>
<td>
<p>An <code>integer</code> that specifies the efficiency of the robust estimator.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_units">units</code></td>
<td>
<p>A <code>string</code> that specifies the units of time plotted on the x axis.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_xlab">xlab</code></td>
<td>
<p>A <code>string</code> that gives a title for the x axis.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_ylab">ylab</code></td>
<td>
<p>A <code>string</code> that gives a title for the y axis.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_main">main</code></td>
<td>
<p>A <code>string</code> that gives an overall title for the plot.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_col_wv">col_wv</code></td>
<td>
<p>A <code>string</code> that specifies the color of the wavelet variance line.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_col_ci">col_ci</code></td>
<td>
<p>A <code>string</code> that specifies the color of the confidence interval shade.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_nb_ticks_x">nb_ticks_x</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the x-axis.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_nb_ticks_y">nb_ticks_y</code></td>
<td>
<p>An <code>integer</code> that specifies the maximum number of ticks for the y-axis.</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_legend_position">legend_position</code></td>
<td>
<p>A <code>string</code> that specifies the position of the legend (use <code>legend_position = NA</code> to remove legend).</p>
</td></tr>
<tr><td><code id="robust_eda_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of wavelet variance and confidence interval for each scale.
</p>


<h3>Author(s)</h3>

<p>Stephane Guerrier, Nathanael Claussen, and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
n = 10^4
Xt = rnorm(n)
wv = wvar(Xt)

plot(wv)
plot(wv, main = "Simulated white noise", xlab = "Scales")
plot(wv, units = "sec", legend_position = "topright")
plot(wv, col_wv = "darkred", col_ci = "pink")
</code></pre>

<hr>
<h2 id='rw_to_wv'>Random Walk to WV</h2><span id='topic+rw_to_wv'></span>

<h3>Description</h3>

<p>This function compute the WV (haar) of a Random Walk process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rw_to_wv(gamma2, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rw_to_wv_+3A_gamma2">gamma2</code></td>
<td>
<p>A <code>double</code> corresponding to variance of RW</p>
</td></tr>
<tr><td><code id="rw_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the random walk.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Random Walk (RW) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {{\gamma ^2}} \right) = \frac{{\left( {\tau _j^2 + 2} \right){\gamma ^2}}}{{12{\tau _j}}} </code>
</p>


<hr>
<h2 id='sarma_calculate_spadding'>Calculates Length of Seasonal Padding</h2><span id='topic+sarma_calculate_spadding'></span>

<h3>Description</h3>

<p>Computes the total phi and total theta vector length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_calculate_spadding(np, nq, nsp, nsq, ns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarma_calculate_spadding_+3A_np">np</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of non-seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_calculate_spadding_+3A_nq">nq</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of non-seasonal theta parameters.</p>
</td></tr>
<tr><td><code id="sarma_calculate_spadding_+3A_nsp">nsp</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_calculate_spadding_+3A_nsq">nsq</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of seasonal theta parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with rows:
</p>

<dl>
<dt>p</dt><dd><p>Number of phi parameters</p>
</dd>
<dt>q</dt><dd><p>Number of theta parameters</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+sarma_components">sarma_components</a></code>
</p>

<hr>
<h2 id='sarma_components'>Determine parameter expansion based upon objdesc</h2><span id='topic+sarma_components'></span>

<h3>Description</h3>

<p>Calculates the necessary vec space needed to pad the vectors
for seasonal terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_components(objdesc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarma_components_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>vec</code> with the appropriate sarima object description</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with the structure:
</p>

<dl>
<dt>np</dt><dd><p>Number of Non-Seasonal AR Terms</p>
</dd>
<dt>nq</dt><dd><p>Number of Non-Seasonal MA Terms</p>
</dd>
<dt>nsp</dt><dd><p>Number of Seasonal AR Terms</p>
</dd>
<dt>nsq</dt><dd><p>Number of Seasonal MA Terms</p>
</dd>
<dt>ns</dt><dd><p>Number of Seasons (e.g. 12 is year)</p>
</dd>
<dt>p</dt><dd><p>Total number of phi terms</p>
</dd>
<dt>q</dt><dd><p>Total number of theta terms</p>
</dd>
</dl>


<hr>
<h2 id='sarma_expand'>Expand Parameters for an SARMA object</h2><span id='topic+sarma_expand'></span>

<h3>Description</h3>

<p>Creates an expanded PHI and THETA vector for use in other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_expand(params, objdesc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarma_expand_+3A_params">params</code></td>
<td>
<p>A <code>vec</code> containing the theta values of the parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>vec</code> containing the model term information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>objdesc</code> is assumed to have the structure of:
</p>

<ul>
<li><p> AR(p)
</p>
</li>
<li><p> MA(q)
</p>
</li>
<li><p> SAR(P)
</p>
</li>
<li><p> SMA(Q)
</p>
</li>
<li><p> Seasons
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> of size two as follows:
</p>

<ul>
<li><p> AR    values
</p>
</li>
<li><p> THETA values
</p>
</li></ul>


<hr>
<h2 id='sarma_expand_unguided'>(Internal) Expand the SARMA Parameters</h2><span id='topic+sarma_expand_unguided'></span>

<h3>Description</h3>

<p>(Internal) Expand the SARMA Parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_expand_unguided(params, np, nq, nsp, nsq, ns, p, q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarma_expand_unguided_+3A_params">params</code></td>
<td>
<p>A <code>vec</code> containing the theta values of the parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_np">np</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of non-seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_nq">nq</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of non-seasonal theta parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_nsp">nsp</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_nsq">nsq</code></td>
<td>
<p>An <code>unsigned int</code> containing the number of seasonal theta parameters.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_p">p</code></td>
<td>
<p>An <code>unsigned int</code> that is the total size of the phi vector.</p>
</td></tr>
<tr><td><code id="sarma_expand_unguided_+3A_q">q</code></td>
<td>
<p>An <code>unsigned int</code> that is the total size of the theta vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains the expansion.
</p>

<hr>
<h2 id='sarma_objdesc'>Create the ts.model obj.desc given split values</h2><span id='topic+sarma_objdesc'></span>

<h3>Description</h3>

<p>Computes the total phi and total theta vector length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_objdesc(ar, ma, sar, sma, s, i, si)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sarma_objdesc_+3A_ar">ar</code></td>
<td>
<p>A <code>vec</code> containing the non-seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_objdesc_+3A_ma">ma</code></td>
<td>
<p>A <code>vec</code> containing the non-seasonal theta parameters.</p>
</td></tr>
<tr><td><code id="sarma_objdesc_+3A_sar">sar</code></td>
<td>
<p>A <code>vec</code> containing the seasonal phi parameters.</p>
</td></tr>
<tr><td><code id="sarma_objdesc_+3A_sma">sma</code></td>
<td>
<p>A <code>vec</code> containing the seasonal theta parameters.</p>
</td></tr>
<tr><td><code id="sarma_objdesc_+3A_s">s</code></td>
<td>
<p>An <code>unsigned integer</code> containing the frequency of seasonality.</p>
</td></tr>
<tr><td><code id="sarma_objdesc_+3A_i">i</code></td>
<td>
<p>An <code>unsigned integer</code> containing the number of non-seasonal differences.</p>
</td></tr>
<tr><td><code id="sarma_objdesc_+3A_si">si</code></td>
<td>
<p>An <code>unsigned integer</code> containing the number of seasonal differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> with rows:
</p>

<dl>
<dt>np</dt><dd><p>Number of Non-Seasonal AR Terms</p>
</dd>
<dt>nq</dt><dd><p>Number of Non-Seasonal MA Terms</p>
</dd>
<dt>nsp</dt><dd><p>Number of Seasonal AR Terms</p>
</dd>
<dt>nsq</dt><dd><p>Number of Seasonal MA Terms</p>
</dd>
<dt>nsigma</dt><dd><p>Number of Variances (always 1)</p>
</dd>
<dt>s</dt><dd><p>Season Value</p>
</dd>
<dt>i</dt><dd><p>Number of non-seasonal differences</p>
</dd>
<dt>si</dt><dd><p>Number of Seasonal Differences</p>
</dd>
</dl>


<hr>
<h2 id='sarma_params_construct'>Efficient way to merge items together</h2><span id='topic+sarma_params_construct'></span>

<h3>Description</h3>

<p>Efficient way to merge items together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sarma_params_construct(ar, ma, sar, sma)
</code></pre>

<hr>
<h2 id='scales_cpp'>Computes the MODWT scales</h2><span id='topic+scales_cpp'></span>

<h3>Description</h3>

<p>Calculates the MODWT scales
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scales_cpp(nb_level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scales_cpp_+3A_nb_level">nb_level</code></td>
<td>
<p>A <code>integer</code> that contains the level of decomposition J.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used in wvar object.
</p>


<h3>Value</h3>

<p>A <code>vec</code> that contains 2^1, ... , 2^J
</p>

<hr>
<h2 id='seq_cpp'>Generate a sequence of values</h2><span id='topic+seq_cpp'></span>

<h3>Description</h3>

<p>Creates a vector containing a sequence of values starting at the initial point and going to the terminal point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_cpp(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_cpp_+3A_a">a</code></td>
<td>
<p>An <code>int</code>, that denotes the starting point.</p>
</td></tr>
<tr><td><code id="seq_cpp_+3A_b">b</code></td>
<td>
<p>An <code>int</code>, that denotes the ending point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing values moving from a to b. There are no restrictions on A's range.
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='seq_len_cpp'>Generate a sequence of values based on supplied number</h2><span id='topic+seq_len_cpp'></span>

<h3>Description</h3>

<p>Creates a vector containing a sequence of values starting at 1 and going to the terminal point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_len_cpp(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_len_cpp_+3A_n">n</code></td>
<td>
<p>An <code>int</code> that denotes the length of the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> containing values moving from 1 to n.
</p>


<h3>Author(s)</h3>

<p>James J Balamuta
</p>

<hr>
<h2 id='sp_hfilter'>Haar filter for a spatial case</h2><span id='topic+sp_hfilter'></span>

<h3>Description</h3>

<p>Haar filter for a spatial case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_hfilter(jscale)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp_hfilter_+3A_jscale">jscale</code></td>
<td>
<p>An <code>int</code> of the Number of Scales</p>
</td></tr>
</table>

<hr>
<h2 id='sp_modwt_cpp'>Compute the Spatial Wavelet Coefficients</h2><span id='topic+sp_modwt_cpp'></span>

<h3>Description</h3>

<p>Compute the Spatial Wavelet Coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_modwt_cpp(X, J1, J2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp_modwt_cpp_+3A_x">X</code></td>
<td>
<p>is a matrix with row, col orientation</p>
</td></tr>
<tr><td><code id="sp_modwt_cpp_+3A_j1">J1</code>, <code id="sp_modwt_cpp_+3A_j2">J2</code></td>
<td>
<p>is the levels of decomposition along the rows, columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default this function will return the wavelet coefficient in
addition to the wavelet
</p>


<h3>Value</h3>

<p>A <code>list</code> of <code>vectors</code> containing the wavelet coefficients.
</p>

<hr>
<h2 id='summary.dwt'>Summary Discrete Wavelet Transform</h2><span id='topic+summary.dwt'></span>

<h3>Description</h3>

<p>Prints DWT object in a concise format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dwt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dwt_+3A_object">object</code></td>
<td>
<p>A <code>dwt</code> object</p>
</td></tr>
<tr><td><code id="summary.dwt_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the dwt matrix decomposition
</p>


<h3>Author(s)</h3>

<p>Nathanael Claussen and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(2^8)
summary(dwt(x))
</code></pre>

<hr>
<h2 id='summary.modwt'>Summary Maximum Overlap Discrete Wavelet Transform</h2><span id='topic+summary.modwt'></span>

<h3>Description</h3>

<p>Prints MODWT object in a concise format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modwt'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.modwt_+3A_object">object</code></td>
<td>
<p>A <code>modwt</code> object</p>
</td></tr>
<tr><td><code id="summary.modwt_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the modwt matrix decomposition
</p>


<h3>Author(s)</h3>

<p>Nathanael Claussen and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(100)
summary(modwt(x))
</code></pre>

<hr>
<h2 id='summary.wvar'>Summary of Wavelet Variances</h2><span id='topic+summary.wvar'></span>

<h3>Description</h3>

<p>Displays the summary table of wavelet variance accounting for CI values and supplied efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wvar'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.wvar_+3A_object">object</code></td>
<td>
<p>A <code>wvar</code> object.</p>
</td></tr>
<tr><td><code id="summary.wvar_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary table and other properties of the object.
</p>


<h3>Author(s)</h3>

<p>James Balamuta
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(100)
ret = wvar(x)
summary(ret)
</code></pre>

<hr>
<h2 id='theoretical_wv'>Model Process to WV</h2><span id='topic+theoretical_wv'></span>

<h3>Description</h3>

<p>This function computes the summation of all Processes to WV (haar) in a given model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theoretical_wv(theta, desc, objdesc, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theoretical_wv_+3A_theta">theta</code></td>
<td>
<p>A <code>vec</code> containing the list of estimated parameters.</p>
</td></tr>
<tr><td><code id="theoretical_wv_+3A_desc">desc</code></td>
<td>
<p>A <code>vector&lt;string&gt;</code> containing a list of descriptors.</p>
</td></tr>
<tr><td><code id="theoretical_wv_+3A_objdesc">objdesc</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> containing a list of object descriptors.</p>
</td></tr>
<tr><td><code id="theoretical_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the model.
</p>

<hr>
<h2 id='unitConversion'>Convert Unit of Time Series Data</h2><span id='topic+unitConversion'></span>

<h3>Description</h3>

<p>Manipulate the units of time to different ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitConversion(x, from.unit, to.unit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unitConversion_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> containing the values on x-axis.</p>
</td></tr>
<tr><td><code id="unitConversion_+3A_from.unit">from.unit</code></td>
<td>
<p>A <code>string</code> indicating the unit which the data is converted from.</p>
</td></tr>
<tr><td><code id="unitConversion_+3A_to.unit">to.unit</code></td>
<td>
<p>A <code>string</code> indicating the unit which the data is converted to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supported units are &quot;ns&quot;(nanosecond), &quot;ms&quot;(millisecond), &quot;sec&quot;, &quot;min&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;month&quot;, and &quot;year&quot;.
Make sure <code>from.unit</code> and <code>to.unit</code> are not <code>NULL</code> before it is passed to this function.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the following structure:
</p>

<ul>
<li><p> &quot;x&quot;: Data
</p>
</li>
<li><p> &quot;converted&quot;: A <code>boolean</code> indicating whether conversion is made
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x = seq(60, 3600, 60)
unitConversion(x, 'sec', 'min')
y = 1:10
unitConversion(y, 'hour', 'sec')
</code></pre>

<hr>
<h2 id='wave_variance'>Generate a Wave Variance for a Univariate Time Series</h2><span id='topic+wave_variance'></span>

<h3>Description</h3>

<p>Computes an estimate of the wave variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wave_variance(signal_modwt_bw, robust = FALSE, eff = 0.6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wave_variance_+3A_signal_modwt_bw">signal_modwt_bw</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains the modwt or dwt decomposition</p>
</td></tr>
<tr><td><code id="wave_variance_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> to determine the type of wave estimation.</p>
</td></tr>
<tr><td><code id="wave_variance_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> that contains the wave variance.
</p>

<hr>
<h2 id='wccv'>Cross Covariance of Matrix</h2><span id='topic+wccv'></span>

<h3>Description</h3>

<p>Calculates the Cross-covariance between multiple wavelet transfomations (dwt or modwt)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wccv(x, decomp = "modwt", filter = "haar", nlevels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wccv_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions N x M.</p>
</td></tr>
<tr><td><code id="wccv_+3A_decomp">decomp</code></td>
<td>
<p>A <code>string</code> that indicates whether to use the &quot;dwt&quot; or &quot;modwt&quot; decomposition.</p>
</td></tr>
<tr><td><code id="wccv_+3A_filter">filter</code></td>
<td>
<p>A <code>string</code> that specifies what wavelet filter to use.</p>
</td></tr>
<tr><td><code id="wccv_+3A_nlevels">nlevels</code></td>
<td>
<p>An <code>integer</code> that indicates the level of decomposition. It must be less than or equal to floor(log2(length(x))).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nlevels</code> is not specified, it is set to <code class="reqn">\left\lfloor {{{\log }_2}\left( {length\left( x \right)} \right)} \right\rfloor</code>
</p>


<h3>Value</h3>

<p>Returns a <code>matrix</code> of <code>lists</code> of all the possible pair cross-covariance, variance of each wavelet cross-covariance and its 95
</p>


<h3>Author(s)</h3>

<p>Justin Lee
</p>

<hr>
<h2 id='wccv_get_y'>Mapping to log10 scale</h2><span id='topic+wccv_get_y'></span>

<h3>Description</h3>

<p>Map x to the value in log10 scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wccv_get_y(x, tick_y_min, tick_y_step)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wccv_get_y_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions J x 1.</p>
</td></tr>
<tr><td><code id="wccv_get_y_+3A_tick_y_min">tick_y_min</code></td>
<td>
<p>A <code>negtive integer</code> the minimum power of 10, which corresponds to the smallest scale on y-axis.</p>
</td></tr>
<tr><td><code id="wccv_get_y_+3A_tick_y_step">tick_y_step</code></td>
<td>
<p>An <code>integer</code> indicating the increment of the sequence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tick_y_min</code> is usually chosen as <code class="reqn">floor(min(log10(abs(x))))</code>
</p>


<h3>Value</h3>

<p>A <code>field&lt;vec&gt;</code> that contains values in log10 scale.
</p>


<h3>Author(s)</h3>

<p>James Balamuta and Justin Lee
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 2^(-1:-9)
y.min = floor(min(log10(abs(x))))
y.step = 2
wccv_get_y(x, y.min, y.step)
</code></pre>

<hr>
<h2 id='wccv_pair'>Cross Covariance of a TS Pair</h2><span id='topic+wccv_pair'></span>

<h3>Description</h3>

<p>Calculates the Cross-covariance between two wavelet transfomations (dwt or modwt)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wccv_pair(x, y, decomp = "modwt", filter = "haar", nlevels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wccv_pair_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1.</p>
</td></tr>
<tr><td><code id="wccv_pair_+3A_y">y</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1.</p>
</td></tr>
<tr><td><code id="wccv_pair_+3A_decomp">decomp</code></td>
<td>
<p>A <code>string</code> that indicates whether to use the &quot;dwt&quot; or &quot;modwt&quot; decomposition.</p>
</td></tr>
<tr><td><code id="wccv_pair_+3A_filter">filter</code></td>
<td>
<p>A <code>string</code> that specifies what wavelet filter to use.</p>
</td></tr>
<tr><td><code id="wccv_pair_+3A_nlevels">nlevels</code></td>
<td>
<p>An <code>integer</code> that indicates the level of decomposition. It must be less than or equal to floor(log2(length(x))).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>nlevels</code> is not specified, it is set to <code class="reqn">\left\lfloor {{{\log }_2}\left( {length\left( x \right)} \right)} \right\rfloor</code>
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> of a <code>matrix</code> containing cross-covariance, variance of each wavelet cross-covariance and its 95
</p>


<h3>Author(s)</h3>

<p>Justin Lee
</p>

<hr>
<h2 id='wn_to_wv'>Gaussian White Noise to WV</h2><span id='topic+wn_to_wv'></span>

<h3>Description</h3>

<p>This function compute the Haar WV of a Gaussian White Noise process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wn_to_wv(sigma2, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wn_to_wv_+3A_sigma2">sigma2</code></td>
<td>
<p>A <code>double</code> corresponding to variance of WN</p>
</td></tr>
<tr><td><code id="wn_to_wv_+3A_tau">tau</code></td>
<td>
<p>A <code>vec</code> containing the scales e.g. <code class="reqn">2^{\tau}</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vec</code> containing the wavelet variance of the white noise.
</p>


<h3>Process Haar Wavelet Variance Formula</h3>

<p>The Gaussian White Noise (WN) process has a Haar Wavelet Variance given by:
</p>
<p style="text-align: center;"><code class="reqn">\nu _j^2\left( {{\sigma ^2}} \right) = \frac{{{\sigma ^2}}}{{\tau _j^2}}</code>
</p>


<hr>
<h2 id='wvar'>Wavelet Variance</h2><span id='topic+wvar'></span><span id='topic+wvar.lts'></span><span id='topic+wvar.gts'></span><span id='topic+wvar.ts'></span><span id='topic+wvar.imu'></span><span id='topic+wvar.default'></span>

<h3>Description</h3>

<p>Calculates the (MO)DWT wavelet variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wvar(x, ...)

## S3 method for class 'lts'
wvar(
  x,
  decomp = "modwt",
  filter = "haar",
  nlevels = NULL,
  alpha = 0.05,
  robust = FALSE,
  eff = 0.6,
  to.unit = NULL,
  ...
)

## S3 method for class 'gts'
wvar(
  x,
  decomp = "modwt",
  filter = "haar",
  nlevels = NULL,
  alpha = 0.05,
  robust = FALSE,
  eff = 0.6,
  to.unit = NULL,
  ...
)

## S3 method for class 'ts'
wvar(
  x,
  decomp = "modwt",
  filter = "haar",
  nlevels = NULL,
  alpha = 0.05,
  robust = FALSE,
  eff = 0.6,
  to.unit = NULL,
  ...
)

## S3 method for class 'imu'
wvar(
  x,
  decomp = "modwt",
  filter = "haar",
  nlevels = NULL,
  alpha = 0.05,
  robust = FALSE,
  eff = 0.6,
  to.unit = NULL,
  ...
)

## Default S3 method:
wvar(
  x,
  decomp = "modwt",
  filter = "haar",
  nlevels = NULL,
  alpha = 0.05,
  robust = FALSE,
  eff = 0.6,
  freq = 1,
  from.unit = NULL,
  to.unit = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wvar_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> with dimensions N x 1.</p>
</td></tr>
<tr><td><code id="wvar_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="wvar_+3A_decomp">decomp</code></td>
<td>
<p>A <code>string</code> that indicates whether to use a &quot;dwt&quot; or &quot;modwt&quot; decomposition.</p>
</td></tr>
<tr><td><code id="wvar_+3A_filter">filter</code></td>
<td>
<p>A <code>string</code> that specifies which wavelet filter to use.</p>
</td></tr>
<tr><td><code id="wvar_+3A_nlevels">nlevels</code></td>
<td>
<p>An <code>integer</code> that indicates the level of decomposition. It must be less than or equal to floor(log2(length(x))).</p>
</td></tr>
<tr><td><code id="wvar_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that specifies the significance level which in turn specifies the <code class="reqn">1-\alpha</code> confidence level.</p>
</td></tr>
<tr><td><code id="wvar_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="wvar_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
<tr><td><code id="wvar_+3A_to.unit">to.unit</code></td>
<td>
<p>A <code>string</code> indicating the unit to which the data is converted.</p>
</td></tr>
<tr><td><code id="wvar_+3A_freq">freq</code></td>
<td>
<p>A <code>numeric</code> that provides the rate of samples.</p>
</td></tr>
<tr><td><code id="wvar_+3A_from.unit">from.unit</code></td>
<td>
<p>A <code>string</code> indicating the unit from which the data is converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value of <code>nlevels</code> will be set to <code class="reqn">\left\lfloor {{{\log }_2}\left( {length\left( x \right)} \right)} \right\rfloor</code>, unless otherwise specified.
</p>


<h3>Value</h3>

<p>A <code>list</code> with the structure:
</p>

<ul>
<li><p> &quot;variance&quot;: Wavelet Variance
</p>
</li>
<li><p> &quot;ci_low&quot;: Lower CI
</p>
</li>
<li><p> &quot;ci_high&quot;: Upper CI
</p>
</li>
<li><p> &quot;robust&quot;: Robust active 
</p>
</li>
<li><p> &quot;eff&quot;: Efficiency level for Robust calculation
</p>
</li>
<li><p> &quot;alpha&quot;: p value used for CI
</p>
</li>
<li><p> &quot;unit&quot;: String representation of the unit
</p>
</li></ul>



<h3>Author(s)</h3>

<p>James Balamuta, Justin Lee and Stephane Guerrier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(999)
x = rnorm(100)

# Default
wvar(x)

# Robust
wvar(x, robust = TRUE, eff=0.3)

# Classical
wvar(x, robust = FALSE, eff=0.3)

# 90% Confidence Interval 
wvar(x, alpha = 0.10)
</code></pre>

<hr>
<h2 id='wvar_cpp'>Computes the (MODWT) wavelet variance</h2><span id='topic+wvar_cpp'></span>

<h3>Description</h3>

<p>Calculates the (MODWT) wavelet variance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wvar_cpp(signal_modwt_bw, robust, eff, alpha, ci_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wvar_cpp_+3A_signal_modwt_bw">signal_modwt_bw</code></td>
<td>
<p>A <code>field&lt;vec&gt;</code> that contains the modwt decomposition after it has been brick walled.</p>
</td></tr>
<tr><td><code id="wvar_cpp_+3A_robust">robust</code></td>
<td>
<p>A <code>boolean</code> that triggers the use of the robust estimate.</p>
</td></tr>
<tr><td><code id="wvar_cpp_+3A_eff">eff</code></td>
<td>
<p>A <code>double</code> that indicates the efficiency as it relates to an MLE.</p>
</td></tr>
<tr><td><code id="wvar_cpp_+3A_alpha">alpha</code></td>
<td>
<p>A <code>double</code> that indicates the <code class="reqn">\left(1-p\right)*\alpha</code> confidence level</p>
</td></tr>
<tr><td><code id="wvar_cpp_+3A_ci_type">ci_type</code></td>
<td>
<p>A <code>String</code> indicating the confidence interval being calculated. Valid value: &quot;eta3&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does the heavy lifting with the signal_modwt_bw
</p>


<h3>Value</h3>

<p>A <code>mat</code> with the structure:
</p>

<ul>
<li><p>&quot;variance&quot;Wavelet Variance
</p>
</li>
<li><p>&quot;low&quot;Lower CI
</p>
</li>
<li><p>&quot;high&quot;Upper CI
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
