<!DOCTYPE html><html><head><title>Help for package pcaone</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pcaone}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pcaone'><p>Randomized Singular Value Decomposition Algorithm with Window-based Power Iterations from PCAone (Li et al 2022).</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Randomized Singular Value Decomposition Algorithms with
'RcppEigen'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Zilong Li [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zilong Li &lt;zilong.dk@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Randomized Singular Value Decomposition (RSVD) methods proposed in the 'PCAone' paper by Li (2022) &lt;<a href="https://doi.org/10.1101%2F2022.05.25.493261">doi:10.1101/2022.05.25.493261</a>&gt;, where we implement and propose two RSVD methods. One is based on Yu (2017) &lt;<a href="https://arxiv.org/abs/1704.07669">arXiv:1704.07669</a>&gt; single pass RSVD but with power iteration scheme. The other is our new window based RSVD.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen (&ge; 0.3.3.3.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Zilong-Li/PCAoneR">https://github.com/Zilong-Li/PCAoneR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Zilong-Li/PCAoneR/issues">https://github.com/Zilong-Li/PCAoneR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-28 12:17:24 UTC; zilong</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-29 08:57:35 UTC</td>
</tr>
</table>
<hr>
<h2 id='pcaone'>Randomized Singular Value Decomposition Algorithm with Window-based Power Iterations from PCAone (Li et al 2022).</h2><span id='topic+pcaone'></span>

<h3>Description</h3>

<p>The Randomized Singular Value Decomposition (RSVD) computes the near-optimal low-rank approximation of a rectangular matrix
using a fast probablistic algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaone(
  A,
  k = NULL,
  p = 7,
  q = 10,
  sdist = "normal",
  method = "alg2",
  windows = 64,
  shuffle = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcaone_+3A_a">A</code></td>
<td>
<p>array_like; <br />
a real/complex <code class="reqn">(m, n)</code> input matrix (or data frame) to be decomposed.</p>
</td></tr>
<tr><td><code id="pcaone_+3A_k">k</code></td>
<td>
<p>integer; <br />
specifies the target rank of the low-rank decomposition. <code class="reqn">k</code> should satisfy <code class="reqn">k &lt;&lt; min(m,n)</code>.</p>
</td></tr>
<tr><td><code id="pcaone_+3A_p">p</code></td>
<td>
<p>integer, optional; <br />
number of additional power iterations (by default <code class="reqn">p=7</code>).</p>
</td></tr>
<tr><td><code id="pcaone_+3A_q">q</code></td>
<td>
<p>integer, optional; <br />
oversampling parameter (by default <code class="reqn">q=10</code>).</p>
</td></tr>
<tr><td><code id="pcaone_+3A_sdist">sdist</code></td>
<td>
<p>string <code class="reqn">c( 'unif', 'normal')</code>, optional; <br />
specifies the sampling distribution of the random test matrix: <br />
<code class="reqn">'unif'</code> :  Uniform <code style="white-space: pre;">&#8288;[-1,1]&#8288;</code>. <br />
<code class="reqn">'normal'</code> (default) : Normal <code>~N(0,1)</code>. <br /></p>
</td></tr>
<tr><td><code id="pcaone_+3A_method">method</code></td>
<td>
<p>string <code class="reqn">c( 'alg1', 'agl2')</code>, optional; <br />
specifies the different variation of the randomized singular value decomposition : <br />
<code class="reqn">'alg1'</code> : single pass RSVD with power iterations in PCAone refered to algorithm1. <br />
<code class="reqn">'alg2'</code> (default): window based RSVD in PCAone refered to algorithm2. <br /></p>
</td></tr>
<tr><td><code id="pcaone_+3A_windows">windows</code></td>
<td>
<p>integer, optional; <br />
the number of windows for 'alg2' method. must be a power of 2 (by default <code class="reqn">windows=64</code>).</p>
</td></tr>
<tr><td><code id="pcaone_+3A_shuffle">shuffle</code></td>
<td>
<p>logical, optional; <br />
if shuffle the rows of input tall matrix or not. recommended for algorithm 2 (by default <code class="reqn">shuffle=FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The singular value decomposition (SVD) plays an important role in data analysis, and scientific computing.
Given a rectangular <code class="reqn">(m,n)</code> matrix <code class="reqn">A</code>, and a target rank <code class="reqn">k &lt;&lt; min(m,n)</code>,
the SVD factors the input matrix <code class="reqn">A</code> as
</p>
<p style="text-align: center;"><code class="reqn"> A  =  U_{k} diag(d_{k}) V_{k}^\top </code>
</p>

<p>The <code class="reqn">k</code> left singular vectors are the columns of the
real or complex unitary matrix <code class="reqn">U</code>. The <code class="reqn">k</code> right singular vectors are the columns
of the real or complex unitary matrix <code class="reqn">V</code>. The <code class="reqn">k</code> dominant singular values are the
entries of <code class="reqn">d</code>, and non-negative and real numbers.
</p>
<p><code class="reqn">q</code> is an oversampling parameter to improve the approximation.
A value of at least 10 is recommended, and <code class="reqn">q=10</code> is set by default.
</p>
<p>The parameter <code class="reqn">p</code> specifies the number of power (subspace) iterations
to reduce the approximation error. The power scheme is recommended,
especially when the singular values decay slowly. However, computing power iterations increases the
computational costs. Even though most RSVD implementations recommend <code class="reqn">p=3</code> power iterations by default,
it's always sufficient to run only few power iterations where our window-based power iterations (<code class="reqn">'alg2'</code>)
come to play. We recommend using <code class="reqn">windows=64</code> and <code class="reqn">p&gt;=7</code> for pcaone algorithm2. As it is designed for large dataset,
we recommend using <code class="reqn">'alg2'</code> when <code class="reqn">max(n,m) &gt; 5000</code>.
</p>
<p>If <code class="reqn">k &gt; (min(n,m)/4)</code>, a deterministic partial or truncated <code><a href="base.html#topic+svd">svd</a></code>
algorithm might be faster.
</p>


<h3>Value</h3>

<p><code>pcaone</code> returns a list containing the following three components:
</p>

<dl>
<dt>d</dt><dd><p>  array_like; <br />
singular values; vector of length <code class="reqn">(k)</code>.
</p>
</dd>
<dt>u</dt><dd><p>  array_like; <br />
left singular vectors; <code class="reqn">(m, k)</code> or <code class="reqn">(m, nu)</code> dimensional array.
</p>
</dd>
<dt>v</dt><dd><p>  array_like; <br />
right singular vectors; <code class="reqn">(n, k)</code> or <code class="reqn">(n, nv)</code> dimensional array. <br />
</p>
</dd>
</dl>



<h3>Note</h3>

<p>The singular vectors are not unique and only defined up to sign.
If a left singular vector has its sign changed, changing the sign of the corresponding right vector
gives an equivalent decomposition.
</p>


<h3>Author(s)</h3>

<p>Zilong Li <a href="mailto:zilong.dk@gmail.com">zilong.dk@gmail.com</a>
</p>


<h3>References</h3>


<ul>
<li><p> Z. Li, J Meisner, A Albrechtsen. &quot;PCAone: fast and accurate out-of-core PCA framework for large scale biobank data&quot; (2022)
doi: <a href="https://doi.org/10.1101/2022.05.25.493261">10.1101/2022.05.25.493261</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library('pcaone')
mat &lt;- matrix(rnorm(100*20000), 100, 20000)
res &lt;- pcaone(mat, k = 10, p = 7, method = "alg2")
str(res)
res &lt;- pcaone(mat, k = 10, p = 7, method = "alg1")
str(res)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
