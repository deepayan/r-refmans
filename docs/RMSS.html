<!DOCTYPE html><html lang="en"><head><title>Help for package RMSS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RMSS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.cv.RMSS'><p>Coefficients for cv.RMSS Object</p></a></li>
<li><a href='#coef.RMSS'><p>Coefficients for RMSS Object</p></a></li>
<li><a href='#cv.RMSS'><p>Cross-Validatoin for Robust Multi-Model Subset Selection</p></a></li>
<li><a href='#predict.cv.RMSS'><p>Predictions for cv.RMSS Object</p></a></li>
<li><a href='#predict.RMSS'><p>Predictions for RMSS Object</p></a></li>
<li><a href='#RMSS'><p>Robust Multi-Model Subset Selection</p></a></li>
<li><a href='#trimmed_samples'><p>Trimmed samples for RMSS or cv.RMSS Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Multi-Model Subset Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Christidis &lt;anthony.christidis@stat.ubc.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient algorithms for generating ensembles of robust, sparse and diverse models via robust 
             multi-model subset selection (RMSS). The robust ensembles are generated by minimizing the sum of 
             the least trimmed square loss of the models in the ensembles under constraints  for the size of 
             the models and the sharing of the predictors. Tuning parameters for the robustness, sparsity and
             diversity of the robust ensemble are selected by cross-validation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), srlars, robStepSplitReg, cellWise, robustbase</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, mvnfast</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-19 23:39:20 UTC; anthony</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Christidis [aut, cre],
  Gabriela Cohen-Freue [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-20 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.cv.RMSS'>Coefficients for cv.RMSS Object</h2><span id='topic+coef.cv.RMSS'></span>

<h3>Description</h3>

<p><code>coef.cv.RMSS</code> returns the coefficients for a cv.RMSS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.RMSS'
coef(
  object,
  h_ind = NULL,
  t_ind = NULL,
  u_ind = NULL,
  individual_models = FALSE,
  group_index = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.cv.RMSS_+3A_object">object</code></td>
<td>
<p>An object of class cv.RMSS.</p>
</td></tr>
<tr><td><code id="coef.cv.RMSS_+3A_h_ind">h_ind</code></td>
<td>
<p>Index for robustness parameter.</p>
</td></tr>
<tr><td><code id="coef.cv.RMSS_+3A_t_ind">t_ind</code></td>
<td>
<p>Index for sparsity parameter.</p>
</td></tr>
<tr><td><code id="coef.cv.RMSS_+3A_u_ind">u_ind</code></td>
<td>
<p>Index for diversity parameter.</p>
</td></tr>
<tr><td><code id="coef.cv.RMSS_+3A_individual_models">individual_models</code></td>
<td>
<p>Argument to determine whether the coefficients of each model are returned. Default is FALSE.</p>
</td></tr>
<tr><td><code id="coef.cv.RMSS_+3A_group_index">group_index</code></td>
<td>
<p>Groups included in the ensemble. Default setting includes all the groups.</p>
</td></tr>
<tr><td><code id="coef.cv.RMSS_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coefficients for the cv.RMSS object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.RMSS">cv.RMSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
n &lt;- 50
p &lt;- 100
rho &lt;- 0.8
rho.inactive &lt;- 0.2
group.size &lt;- 5
p.active &lt;- 15
snr &lt;- 2
contamination.prop &lt;- 0.3

# Setting the seed
set.seed(0)

# Block Correlation
sigma.mat &lt;- matrix(0, p, p)
sigma.mat[1:p.active, 1:p.active] &lt;- rho.inactive
for(group in 0:(p.active/group.size - 1))
  sigma.mat[(group*group.size+1):(group*group.size+group.size),
            (group*group.size+1):(group*group.size+group.size)] &lt;- rho
diag(sigma.mat) &lt;- 1

# Simulation of beta vector
true.beta &lt;- c(runif(p.active, 0, 5)*(-1)^rbinom(p.active, 1, 0.7), 
               rep(0, p - p.active))

# Setting the SD of the variance
sigma &lt;- as.numeric(sqrt(t(true.beta) %*% sigma.mat %*% true.beta)/sqrt(snr))

# Simulation of test data
m &lt;- 2e3
x_test &lt;- mvnfast::rmvn(m, mu = rep(0, p), sigma = sigma.mat)
y_test &lt;- x_test %*% true.beta + rnorm(m, 0, sigma)

# Simulation of uncontaminated data 
x &lt;- mvnfast::rmvn(n, mu = rep(0, p), sigma = sigma.mat)
y &lt;- x %*% true.beta + rnorm(n, 0, sigma)

# Contamination of data 
contamination_indices &lt;- 1:floor(n*contamination.prop)
k_lev &lt;- 2
k_slo &lt;- 100
x_train &lt;- x
y_train &lt;- y
beta_cont &lt;- true.beta
beta_cont[true.beta!=0] &lt;- beta_cont[true.beta!=0]*(1 + k_slo)
beta_cont[true.beta==0] &lt;- k_slo*max(abs(true.beta))
for(cont_id in contamination_indices){
 
 a &lt;- runif(p, min = -1, max = 1)
 a &lt;- a - as.numeric((1/p)*t(a) %*% rep(1, p))
  x_train[cont_id,] &lt;- mvnfast::rmvn(1, rep(0, p), 0.1^2*diag(p)) + k_lev * a / 
                        as.numeric(sqrt(t(a) %*% solve(sigma.mat) %*% a))
  y_train[cont_id] &lt;- t(x_train[cont_id,]) %*% beta_cont
}

# CV RMSS
rmss_fit &lt;- cv.RMSS(x = x_train, y = y_train,
                    n_models = 3,
                    h_grid = c(35), t_grid = c(6, 8, 10), u_grid = c(1:3),
                    initial_estimator = "robStepSplitReg",
                    tolerance = 1e-1,
                    max_iter = 1e3,
                    neighborhood_search = FALSE,
                    neighborhood_search_tolerance = 1e-1,
                    n_folds = 5,
                    alpha = 1/4,
                    gamma = 1, 
                    n_threads = 1)
rmss_coefs &lt;- coef(rmss_fit, 
                   h_ind = rmss_fit$h_opt, 
                   t_ind = rmss_fit$t_opt, 
                   u_ind = rmss_fit$u_opt,
                   group_index = 1:rmss_fit$n_models)
sens_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/p.active
spec_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/sum(rmss_coefs[-1]!=0)
rmss_preds &lt;- predict(rmss_fit, newx = x_test,
                      h_ind = rmss_fit$h_opt, 
                      t_ind = rmss_fit$t_opt, 
                      u_ind = rmss_fit$u_opt,
                      group_index = 1:rmss_fit$n_models,
                      dynamic = FALSE)
rmss_mspe &lt;- mean((y_test - rmss_preds)^2)/sigma^2

</code></pre>

<hr>
<h2 id='coef.RMSS'>Coefficients for RMSS Object</h2><span id='topic+coef.RMSS'></span>

<h3>Description</h3>

<p><code>coef.RMSS</code> returns the coefficients for a RMSS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RMSS'
coef(
  object,
  h_ind,
  t_ind,
  u_ind,
  individual_models = FALSE,
  group_index = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.RMSS_+3A_object">object</code></td>
<td>
<p>An object of class RMSS.</p>
</td></tr>
<tr><td><code id="coef.RMSS_+3A_h_ind">h_ind</code></td>
<td>
<p>Index for robustness parameter.</p>
</td></tr>
<tr><td><code id="coef.RMSS_+3A_t_ind">t_ind</code></td>
<td>
<p>Index for sparsity parameter.</p>
</td></tr>
<tr><td><code id="coef.RMSS_+3A_u_ind">u_ind</code></td>
<td>
<p>Index for diversity parameter.</p>
</td></tr>
<tr><td><code id="coef.RMSS_+3A_individual_models">individual_models</code></td>
<td>
<p>Argument to determine whether the coefficients of each model are returned. Default is FALSE.</p>
</td></tr>
<tr><td><code id="coef.RMSS_+3A_group_index">group_index</code></td>
<td>
<p>Groups included in the ensemble. Default setting includes all the groups.</p>
</td></tr>
<tr><td><code id="coef.RMSS_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coefficients for the RMSS object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RMSS">RMSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
n &lt;- 50
p &lt;- 100
rho &lt;- 0.8
rho.inactive &lt;- 0.2
group.size &lt;- 5
p.active &lt;- 15
snr &lt;- 2
contamination.prop &lt;- 0.3

# Setting the seed
set.seed(0)

# Block Correlation
sigma.mat &lt;- matrix(0, p, p)
sigma.mat[1:p.active, 1:p.active] &lt;- rho.inactive
for(group in 0:(p.active/group.size - 1))
  sigma.mat[(group*group.size+1):(group*group.size+group.size),
            (group*group.size+1):(group*group.size+group.size)] &lt;- rho
diag(sigma.mat) &lt;- 1

# Simulation of beta vector
true.beta &lt;- c(runif(p.active, 0, 5)*(-1)^rbinom(p.active, 1, 0.7), 
               rep(0, p - p.active))

# Setting the SD of the variance
sigma &lt;- as.numeric(sqrt(t(true.beta) %*% sigma.mat %*% true.beta)/sqrt(snr))

# Simulation of test data
m &lt;- 2e3
x_test &lt;- mvnfast::rmvn(m, mu = rep(0, p), sigma = sigma.mat)
y_test &lt;- x_test %*% true.beta + rnorm(m, 0, sigma)

# Simulation of uncontaminated data 
x &lt;- mvnfast::rmvn(n, mu = rep(0, p), sigma = sigma.mat)
y &lt;- x %*% true.beta + rnorm(n, 0, sigma)

# Contamination of data 
contamination_indices &lt;- 1:floor(n*contamination.prop)
k_lev &lt;- 2
k_slo &lt;- 100
x_train &lt;- x
y_train &lt;- y
beta_cont &lt;- true.beta
beta_cont[true.beta!=0] &lt;- beta_cont[true.beta!=0]*(1 + k_slo)
beta_cont[true.beta==0] &lt;- k_slo*max(abs(true.beta))
for(cont_id in contamination_indices){
 
 a &lt;- runif(p, min = -1, max = 1)
 a &lt;- a - as.numeric((1/p)*t(a) %*% rep(1, p))
  x_train[cont_id,] &lt;- mvnfast::rmvn(1, rep(0, p), 0.1^2*diag(p)) + k_lev * a / 
                        as.numeric(sqrt(t(a) %*% solve(sigma.mat) %*% a))
  y_train[cont_id] &lt;- t(x_train[cont_id,]) %*% beta_cont
}

# RMSS
rmss_fit &lt;- RMSS(x = x_train, y = y_train,
                 n_models = 3,
                 h_grid = c(35), t_grid = c(6, 8, 10), u_grid = c(1:3),
                 initial_estimator = "robStepSplitReg",
                 tolerance = 1e-1,
                 max_iter = 1e3,
                 neighborhood_search = FALSE,
                 neighborhood_search_tolerance = 1e-1)
rmss_coefs &lt;- coef(rmss_fit, 
                   h_ind = 1, t_ind = 2, u_ind = 1,
                   group_index = 1:rmss_fit$n_models)
sens_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/p.active
spec_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/sum(rmss_coefs[-1]!=0)
rmss_preds &lt;- predict(rmss_fit, newx = x_test,
                      h_ind = 1, t_ind = 2, u_ind = 1,
                      group_index = 1:rmss_fit$n_models,
                      dynamic = FALSE)
rmss_mspe &lt;- mean((y_test - rmss_preds)^2)/sigma^2

</code></pre>

<hr>
<h2 id='cv.RMSS'>Cross-Validatoin for Robust Multi-Model Subset Selection</h2><span id='topic+cv.RMSS'></span>

<h3>Description</h3>

<p><code>cv.RMSS</code> performs the cross-validation procedure for robust multi-model subset selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.RMSS(
  x,
  y,
  n_models,
  h_grid,
  t_grid,
  u_grid,
  initial_estimator = c("robStepSplitReg", "srlars")[1],
  tolerance = 0.1,
  max_iter = 1000,
  neighborhood_search = FALSE,
  neighborhood_search_tolerance = 0.1,
  cv_criterion = c("tau", "trimmed")[1],
  n_folds = 5,
  alpha = 1/4,
  gamma = 1,
  n_threads = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.RMSS_+3A_x">x</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_n_models">n_models</code></td>
<td>
<p>Number of models into which the variables are split.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_h_grid">h_grid</code></td>
<td>
<p>Grid for robustness parameter.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_t_grid">t_grid</code></td>
<td>
<p>Grid for sparsity parameter.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_u_grid">u_grid</code></td>
<td>
<p>Grid for diversity parameter.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_initial_estimator">initial_estimator</code></td>
<td>
<p>Method used for initial estimator. Must be one of &quot;robStepSplitReg&quot; (default) or &quot;srlars&quot;.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance level for convergence of PSBGD algorithm.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations in PSBGD algorithm.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_neighborhood_search">neighborhood_search</code></td>
<td>
<p>Neighborhood search to improve solution. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_neighborhood_search_tolerance">neighborhood_search_tolerance</code></td>
<td>
<p>Tolerance parameter for neighborhood search. Default is 1e-1.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_cv_criterion">cv_criterion</code></td>
<td>
<p>Criterion to use for cross-validation procedure. Must be one of &quot;tau&quot; (default) or &quot;trimmed&quot;.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_n_folds">n_folds</code></td>
<td>
<p>Number of folds for cross-validation procedure. Default is 5.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_alpha">alpha</code></td>
<td>
<p>Proportion of trimmed samples for cross-validation procedure. Default is 1/4.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_gamma">gamma</code></td>
<td>
<p>Weight parameter for ensemble MSPE (gamma) and average MSPE of individual models (1 - gamma). Default is 1.</p>
</td></tr>
<tr><td><code id="cv.RMSS_+3A_n_threads">n_threads</code></td>
<td>
<p>Number of threads used by OpenMP for multithreading over the folds. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class cv.RMSS
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.cv.RMSS">coef.cv.RMSS</a></code>, <code><a href="#topic+predict.cv.RMSS">predict.cv.RMSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
n &lt;- 50
p &lt;- 100
rho &lt;- 0.8
rho.inactive &lt;- 0.2
group.size &lt;- 5
p.active &lt;- 15
snr &lt;- 2
contamination.prop &lt;- 0.3

# Setting the seed
set.seed(0)

# Block Correlation
sigma.mat &lt;- matrix(0, p, p)
sigma.mat[1:p.active, 1:p.active] &lt;- rho.inactive
for(group in 0:(p.active/group.size - 1))
  sigma.mat[(group*group.size+1):(group*group.size+group.size),
            (group*group.size+1):(group*group.size+group.size)] &lt;- rho
diag(sigma.mat) &lt;- 1

# Simulation of beta vector
true.beta &lt;- c(runif(p.active, 0, 5)*(-1)^rbinom(p.active, 1, 0.7), 
               rep(0, p - p.active))

# Setting the SD of the variance
sigma &lt;- as.numeric(sqrt(t(true.beta) %*% sigma.mat %*% true.beta)/sqrt(snr))

# Simulation of test data
m &lt;- 2e3
x_test &lt;- mvnfast::rmvn(m, mu = rep(0, p), sigma = sigma.mat)
y_test &lt;- x_test %*% true.beta + rnorm(m, 0, sigma)

# Simulation of uncontaminated data 
x &lt;- mvnfast::rmvn(n, mu = rep(0, p), sigma = sigma.mat)
y &lt;- x %*% true.beta + rnorm(n, 0, sigma)

# Contamination of data 
contamination_indices &lt;- 1:floor(n*contamination.prop)
k_lev &lt;- 2
k_slo &lt;- 100
x_train &lt;- x
y_train &lt;- y
beta_cont &lt;- true.beta
beta_cont[true.beta!=0] &lt;- beta_cont[true.beta!=0]*(1 + k_slo)
beta_cont[true.beta==0] &lt;- k_slo*max(abs(true.beta))
for(cont_id in contamination_indices){
 
 a &lt;- runif(p, min = -1, max = 1)
 a &lt;- a - as.numeric((1/p)*t(a) %*% rep(1, p))
  x_train[cont_id,] &lt;- mvnfast::rmvn(1, rep(0, p), 0.1^2*diag(p)) + k_lev * a / 
                        as.numeric(sqrt(t(a) %*% solve(sigma.mat) %*% a))
  y_train[cont_id] &lt;- t(x_train[cont_id,]) %*% beta_cont
}

# CV RMSS
rmss_fit &lt;- cv.RMSS(x = x_train, y = y_train,
                    n_models = 3,
                    h_grid = c(35), t_grid = c(6, 8, 10), u_grid = c(1:3),
                    initial_estimator = "robStepSplitReg",
                    tolerance = 1e-1,
                    max_iter = 1e3,
                    neighborhood_search = FALSE,
                    neighborhood_search_tolerance = 1e-1,
                    n_folds = 5,
                    alpha = 1/4,
                    gamma = 1, 
                    n_threads = 1)
rmss_coefs &lt;- coef(rmss_fit, 
                   h_ind = rmss_fit$h_opt, 
                   t_ind = rmss_fit$t_opt, 
                   u_ind = rmss_fit$u_opt,
                   group_index = 1:rmss_fit$n_models)
sens_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/p.active
spec_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/sum(rmss_coefs[-1]!=0)
rmss_preds &lt;- predict(rmss_fit, newx = x_test,
                      h_ind = rmss_fit$h_opt, 
                      t_ind = rmss_fit$t_opt, 
                      u_ind = rmss_fit$u_opt,
                      group_index = 1:rmss_fit$n_models,
                      dynamic = FALSE)
rmss_mspe &lt;- mean((y_test - rmss_preds)^2)/sigma^2
 
</code></pre>

<hr>
<h2 id='predict.cv.RMSS'>Predictions for cv.RMSS Object</h2><span id='topic+predict.cv.RMSS'></span>

<h3>Description</h3>

<p><code>predict.cv.RMSS</code> returns the predictions for a cv.RMSS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.RMSS'
predict(
  object,
  newx,
  h_ind = NULL,
  t_ind = NULL,
  u_ind = NULL,
  group_index = NULL,
  dynamic = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cv.RMSS_+3A_object">object</code></td>
<td>
<p>An object of class cv.RMSS.</p>
</td></tr>
<tr><td><code id="predict.cv.RMSS_+3A_newx">newx</code></td>
<td>
<p>New data for predictions.</p>
</td></tr>
<tr><td><code id="predict.cv.RMSS_+3A_h_ind">h_ind</code></td>
<td>
<p>Index for robustness parameter.</p>
</td></tr>
<tr><td><code id="predict.cv.RMSS_+3A_t_ind">t_ind</code></td>
<td>
<p>Index for sparsity parameter.</p>
</td></tr>
<tr><td><code id="predict.cv.RMSS_+3A_u_ind">u_ind</code></td>
<td>
<p>Index for diversity parameter.</p>
</td></tr>
<tr><td><code id="predict.cv.RMSS_+3A_group_index">group_index</code></td>
<td>
<p>Groups included in the ensemble. Default setting includes all the groups.</p>
</td></tr>
<tr><td><code id="predict.cv.RMSS_+3A_dynamic">dynamic</code></td>
<td>
<p>Argument to determine whether dynamic predictions are used based on deviating cells. Default is FALSE.</p>
</td></tr>
<tr><td><code id="predict.cv.RMSS_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predictions for the cv.RMSS object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.RMSS">cv.RMSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
n &lt;- 50
p &lt;- 100
rho &lt;- 0.8
rho.inactive &lt;- 0.2
group.size &lt;- 5
p.active &lt;- 15
snr &lt;- 2
contamination.prop &lt;- 0.3

# Setting the seed
set.seed(0)

# Block Correlation
sigma.mat &lt;- matrix(0, p, p)
sigma.mat[1:p.active, 1:p.active] &lt;- rho.inactive
for(group in 0:(p.active/group.size - 1))
  sigma.mat[(group*group.size+1):(group*group.size+group.size),
            (group*group.size+1):(group*group.size+group.size)] &lt;- rho
diag(sigma.mat) &lt;- 1

# Simulation of beta vector
true.beta &lt;- c(runif(p.active, 0, 5)*(-1)^rbinom(p.active, 1, 0.7), 
               rep(0, p - p.active))

# Setting the SD of the variance
sigma &lt;- as.numeric(sqrt(t(true.beta) %*% sigma.mat %*% true.beta)/sqrt(snr))

# Simulation of test data
m &lt;- 2e3
x_test &lt;- mvnfast::rmvn(m, mu = rep(0, p), sigma = sigma.mat)
y_test &lt;- x_test %*% true.beta + rnorm(m, 0, sigma)

# Simulation of uncontaminated data 
x &lt;- mvnfast::rmvn(n, mu = rep(0, p), sigma = sigma.mat)
y &lt;- x %*% true.beta + rnorm(n, 0, sigma)

# Contamination of data 
contamination_indices &lt;- 1:floor(n*contamination.prop)
k_lev &lt;- 2
k_slo &lt;- 100
x_train &lt;- x
y_train &lt;- y
beta_cont &lt;- true.beta
beta_cont[true.beta!=0] &lt;- beta_cont[true.beta!=0]*(1 + k_slo)
beta_cont[true.beta==0] &lt;- k_slo*max(abs(true.beta))
for(cont_id in contamination_indices){
 
 a &lt;- runif(p, min = -1, max = 1)
 a &lt;- a - as.numeric((1/p)*t(a) %*% rep(1, p))
  x_train[cont_id,] &lt;- mvnfast::rmvn(1, rep(0, p), 0.1^2*diag(p)) + k_lev * a / 
                        as.numeric(sqrt(t(a) %*% solve(sigma.mat) %*% a))
  y_train[cont_id] &lt;- t(x_train[cont_id,]) %*% beta_cont
}

# CV RMSS
rmss_fit &lt;- cv.RMSS(x = x_train, y = y_train,
                    n_models = 3,
                    h_grid = c(35), t_grid = c(6, 8, 10), u_grid = c(1:3),
                    initial_estimator = "robStepSplitReg",
                    tolerance = 1e-1,
                    max_iter = 1e3,
                    neighborhood_search = FALSE,
                    neighborhood_search_tolerance = 1e-1,
                    n_folds = 5,
                    alpha = 1/4,
                    gamma = 1, 
                    n_threads = 1)
rmss_coefs &lt;- coef(rmss_fit, 
                   h_ind = rmss_fit$h_opt, 
                   t_ind = rmss_fit$t_opt, 
                   u_ind = rmss_fit$u_opt,
                   group_index = 1:rmss_fit$n_models)
sens_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/p.active
spec_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/sum(rmss_coefs[-1]!=0)
rmss_preds &lt;- predict(rmss_fit, newx = x_test,
                      h_ind = rmss_fit$h_opt, 
                      t_ind = rmss_fit$t_opt, 
                      u_ind = rmss_fit$u_opt,
                      group_index = 1:rmss_fit$n_models,
                      dynamic = FALSE)
rmss_mspe &lt;- mean((y_test - rmss_preds)^2)/sigma^2

</code></pre>

<hr>
<h2 id='predict.RMSS'>Predictions for RMSS Object</h2><span id='topic+predict.RMSS'></span>

<h3>Description</h3>

<p><code>predict.RMSS</code> returns the predictions for a RMSS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RMSS'
predict(
  object,
  newx,
  h_ind,
  t_ind,
  u_ind,
  group_index = NULL,
  dynamic = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.RMSS_+3A_object">object</code></td>
<td>
<p>An object of class RMSS.</p>
</td></tr>
<tr><td><code id="predict.RMSS_+3A_newx">newx</code></td>
<td>
<p>New data for predictions.</p>
</td></tr>
<tr><td><code id="predict.RMSS_+3A_h_ind">h_ind</code></td>
<td>
<p>Index for robustness parameter.</p>
</td></tr>
<tr><td><code id="predict.RMSS_+3A_t_ind">t_ind</code></td>
<td>
<p>Index for sparsity parameter.</p>
</td></tr>
<tr><td><code id="predict.RMSS_+3A_u_ind">u_ind</code></td>
<td>
<p>Index for diversity parameter.</p>
</td></tr>
<tr><td><code id="predict.RMSS_+3A_group_index">group_index</code></td>
<td>
<p>Groups included in the ensemble. Default setting includes all the groups.</p>
</td></tr>
<tr><td><code id="predict.RMSS_+3A_dynamic">dynamic</code></td>
<td>
<p>Argument to determine whether dynamic predictions are used based on deviating cells. Default is FALSE.</p>
</td></tr>
<tr><td><code id="predict.RMSS_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predictions for the RMSS object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RMSS">RMSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
n &lt;- 50
p &lt;- 100
rho &lt;- 0.8
rho.inactive &lt;- 0.2
group.size &lt;- 5
p.active &lt;- 15
snr &lt;- 2
contamination.prop &lt;- 0.3

# Setting the seed
set.seed(0)

# Block Correlation
sigma.mat &lt;- matrix(0, p, p)
sigma.mat[1:p.active, 1:p.active] &lt;- rho.inactive
for(group in 0:(p.active/group.size - 1))
  sigma.mat[(group*group.size+1):(group*group.size+group.size),
            (group*group.size+1):(group*group.size+group.size)] &lt;- rho
diag(sigma.mat) &lt;- 1

# Simulation of beta vector
true.beta &lt;- c(runif(p.active, 0, 5)*(-1)^rbinom(p.active, 1, 0.7), 
               rep(0, p - p.active))

# Setting the SD of the variance
sigma &lt;- as.numeric(sqrt(t(true.beta) %*% sigma.mat %*% true.beta)/sqrt(snr))

# Simulation of test data
m &lt;- 2e3
x_test &lt;- mvnfast::rmvn(m, mu = rep(0, p), sigma = sigma.mat)
y_test &lt;- x_test %*% true.beta + rnorm(m, 0, sigma)

# Simulation of uncontaminated data 
x &lt;- mvnfast::rmvn(n, mu = rep(0, p), sigma = sigma.mat)
y &lt;- x %*% true.beta + rnorm(n, 0, sigma)

# Contamination of data 
contamination_indices &lt;- 1:floor(n*contamination.prop)
k_lev &lt;- 2
k_slo &lt;- 100
x_train &lt;- x
y_train &lt;- y
beta_cont &lt;- true.beta
beta_cont[true.beta!=0] &lt;- beta_cont[true.beta!=0]*(1 + k_slo)
beta_cont[true.beta==0] &lt;- k_slo*max(abs(true.beta))
for(cont_id in contamination_indices){
 
 a &lt;- runif(p, min = -1, max = 1)
 a &lt;- a - as.numeric((1/p)*t(a) %*% rep(1, p))
  x_train[cont_id,] &lt;- mvnfast::rmvn(1, rep(0, p), 0.1^2*diag(p)) + k_lev * a / 
                        as.numeric(sqrt(t(a) %*% solve(sigma.mat) %*% a))
  y_train[cont_id] &lt;- t(x_train[cont_id,]) %*% beta_cont
}

# RMSS
rmss_fit &lt;- RMSS(x = x_train, y = y_train,
                 n_models = 3,
                 h_grid = c(35), t_grid = c(6, 8, 10), u_grid = c(1:3),
                 initial_estimator = "robStepSplitReg",
                 tolerance = 1e-1,
                 max_iter = 1e3,
                 neighborhood_search = FALSE,
                 neighborhood_search_tolerance = 1e-1)
rmss_coefs &lt;- coef(rmss_fit, 
                   h_ind = 1, t_ind = 2, u_ind = 1,
                   group_index = 1:rmss_fit$n_models)
sens_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/p.active
spec_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/sum(rmss_coefs[-1]!=0)
rmss_preds &lt;- predict(rmss_fit, newx = x_test,
                      h_ind = 1, t_ind = 2, u_ind = 1,
                      group_index = 1:rmss_fit$n_models,
                      dynamic = FALSE)
rmss_mspe &lt;- mean((y_test - rmss_preds)^2)/sigma^2

</code></pre>

<hr>
<h2 id='RMSS'>Robust Multi-Model Subset Selection</h2><span id='topic+RMSS'></span>

<h3>Description</h3>

<p><code>RMSS</code> performs robust multi-model subset selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSS(
  x,
  y,
  n_models,
  h_grid,
  t_grid,
  u_grid,
  initial_estimator = c("robStepSplitReg", "srlars")[1],
  tolerance = 0.1,
  max_iter = 1000,
  neighborhood_search = FALSE,
  neighborhood_search_tolerance = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RMSS_+3A_x">x</code></td>
<td>
<p>Design matrix.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_y">y</code></td>
<td>
<p>Response vector.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_n_models">n_models</code></td>
<td>
<p>Number of models into which the variables are split.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_h_grid">h_grid</code></td>
<td>
<p>Grid for robustness parameter.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_t_grid">t_grid</code></td>
<td>
<p>Grid for sparsity parameter.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_u_grid">u_grid</code></td>
<td>
<p>Grid for diversity parameter.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_initial_estimator">initial_estimator</code></td>
<td>
<p>Method used for initial estimator. Must be one of &quot;robStepSplitReg&quot; (default) or &quot;srlars&quot;.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance level for convergence of PSBGD algorithm.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations in PSBGD algorithm.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_neighborhood_search">neighborhood_search</code></td>
<td>
<p>Neighborhood search to improve solution. Default is FALSE.</p>
</td></tr>
<tr><td><code id="RMSS_+3A_neighborhood_search_tolerance">neighborhood_search_tolerance</code></td>
<td>
<p>Tolerance parameter for neighborhood search. Default is 1e-1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class RMSS
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.RMSS">coef.RMSS</a></code>, <code><a href="#topic+predict.RMSS">predict.RMSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
n &lt;- 50
p &lt;- 100
rho &lt;- 0.8
rho.inactive &lt;- 0.2
group.size &lt;- 5
p.active &lt;- 15
snr &lt;- 2
contamination.prop &lt;- 0.3

# Setting the seed
set.seed(0)

# Block Correlation
sigma.mat &lt;- matrix(0, p, p)
sigma.mat[1:p.active, 1:p.active] &lt;- rho.inactive
for(group in 0:(p.active/group.size - 1))
  sigma.mat[(group*group.size+1):(group*group.size+group.size),
            (group*group.size+1):(group*group.size+group.size)] &lt;- rho
diag(sigma.mat) &lt;- 1

# Simulation of beta vector
true.beta &lt;- c(runif(p.active, 0, 5)*(-1)^rbinom(p.active, 1, 0.7), 
               rep(0, p - p.active))

# Setting the SD of the variance
sigma &lt;- as.numeric(sqrt(t(true.beta) %*% sigma.mat %*% true.beta)/sqrt(snr))

# Simulation of test data
m &lt;- 2e3
x_test &lt;- mvnfast::rmvn(m, mu = rep(0, p), sigma = sigma.mat)
y_test &lt;- x_test %*% true.beta + rnorm(m, 0, sigma)

# Simulation of uncontaminated data 
x &lt;- mvnfast::rmvn(n, mu = rep(0, p), sigma = sigma.mat)
y &lt;- x %*% true.beta + rnorm(n, 0, sigma)

# Contamination of data 
contamination_indices &lt;- 1:floor(n*contamination.prop)
k_lev &lt;- 2
k_slo &lt;- 100
x_train &lt;- x
y_train &lt;- y
beta_cont &lt;- true.beta
beta_cont[true.beta!=0] &lt;- beta_cont[true.beta!=0]*(1 + k_slo)
beta_cont[true.beta==0] &lt;- k_slo*max(abs(true.beta))
for(cont_id in contamination_indices){
 
 a &lt;- runif(p, min = -1, max = 1)
 a &lt;- a - as.numeric((1/p)*t(a) %*% rep(1, p))
  x_train[cont_id,] &lt;- mvnfast::rmvn(1, rep(0, p), 0.1^2*diag(p)) + k_lev * a / 
                        as.numeric(sqrt(t(a) %*% solve(sigma.mat) %*% a))
  y_train[cont_id] &lt;- t(x_train[cont_id,]) %*% beta_cont
}

# RMSS
rmss_fit &lt;- RMSS(x = x_train, y = y_train,
                 n_models = 3,
                 h_grid = c(35), t_grid = c(6, 8, 10), u_grid = c(1:3),
                 initial_estimator = "robStepSplitReg",
                 tolerance = 1e-1,
                 max_iter = 1e3,
                 neighborhood_search = FALSE,
                 neighborhood_search_tolerance = 1e-1)
rmss_coefs &lt;- coef(rmss_fit, 
                   h_ind = 1, t_ind = 2, u_ind = 1,
                   group_index = 1:rmss_fit$n_models)
sens_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/p.active
spec_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/sum(rmss_coefs[-1]!=0)
rmss_preds &lt;- predict(rmss_fit, newx = x_test,
                      h_ind = 1, t_ind = 2, u_ind = 1,
                      group_index = 1:rmss_fit$n_models,
                      dynamic = FALSE)
rmss_mspe &lt;- mean((y_test - rmss_preds)^2)/sigma^2

</code></pre>

<hr>
<h2 id='trimmed_samples'>Trimmed samples for RMSS or cv.RMSS Object</h2><span id='topic+trimmed_samples'></span>

<h3>Description</h3>

<p><code>trimmed_samples</code> returns the coefficients for a RMSS or cv.RMSS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimmed_samples(
  object,
  h_ind = NULL,
  t_ind = NULL,
  u_ind = NULL,
  group_index = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimmed_samples_+3A_object">object</code></td>
<td>
<p>An object of class RMSS</p>
</td></tr>
<tr><td><code id="trimmed_samples_+3A_h_ind">h_ind</code></td>
<td>
<p>Index for robustness parameter.</p>
</td></tr>
<tr><td><code id="trimmed_samples_+3A_t_ind">t_ind</code></td>
<td>
<p>Index for sparsity parameter.</p>
</td></tr>
<tr><td><code id="trimmed_samples_+3A_u_ind">u_ind</code></td>
<td>
<p>Index for diversity parameter.</p>
</td></tr>
<tr><td><code id="trimmed_samples_+3A_group_index">group_index</code></td>
<td>
<p>Groups included in the ensemble. Default setting includes all the groups.</p>
</td></tr>
<tr><td><code id="trimmed_samples_+3A_...">...</code></td>
<td>
<p>Additional arguments for compatibility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The trimmed samples for the RMSS or cv.RMSS object.
</p>


<h3>Author(s)</h3>

<p>Anthony-Alexander Christidis, <a href="mailto:anthony.christidis@stat.ubc.ca">anthony.christidis@stat.ubc.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RMSS">RMSS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation parameters
n &lt;- 50
p &lt;- 100
rho &lt;- 0.8
rho.inactive &lt;- 0.2
group.size &lt;- 5
p.active &lt;- 15
snr &lt;- 2
contamination.prop &lt;- 0.3

# Setting the seed
set.seed(0)

# Block Correlation
sigma.mat &lt;- matrix(0, p, p)
sigma.mat[1:p.active, 1:p.active] &lt;- rho.inactive
for(group in 0:(p.active/group.size - 1))
  sigma.mat[(group*group.size+1):(group*group.size+group.size),
            (group*group.size+1):(group*group.size+group.size)] &lt;- rho
diag(sigma.mat) &lt;- 1

# Simulation of beta vector
true.beta &lt;- c(runif(p.active, 0, 5)*(-1)^rbinom(p.active, 1, 0.7), 
               rep(0, p - p.active))

# Setting the SD of the variance
sigma &lt;- as.numeric(sqrt(t(true.beta) %*% sigma.mat %*% true.beta)/sqrt(snr))

# Simulation of test data
m &lt;- 2e3
x_test &lt;- mvnfast::rmvn(m, mu = rep(0, p), sigma = sigma.mat)
y_test &lt;- x_test %*% true.beta + rnorm(m, 0, sigma)

# Simulation of uncontaminated data 
x &lt;- mvnfast::rmvn(n, mu = rep(0, p), sigma = sigma.mat)
y &lt;- x %*% true.beta + rnorm(n, 0, sigma)

# Contamination of data 
contamination_indices &lt;- 1:floor(n*contamination.prop)
k_lev &lt;- 2
k_slo &lt;- 100
x_train &lt;- x
y_train &lt;- y
beta_cont &lt;- true.beta
beta_cont[true.beta!=0] &lt;- beta_cont[true.beta!=0]*(1 + k_slo)
beta_cont[true.beta==0] &lt;- k_slo*max(abs(true.beta))
for(cont_id in contamination_indices){
 
 a &lt;- runif(p, min = -1, max = 1)
 a &lt;- a - as.numeric((1/p)*t(a) %*% rep(1, p))
  x_train[cont_id,] &lt;- mvnfast::rmvn(1, rep(0, p), 0.1^2*diag(p)) + k_lev * a / 
                        as.numeric(sqrt(t(a) %*% solve(sigma.mat) %*% a))
  y_train[cont_id] &lt;- t(x_train[cont_id,]) %*% beta_cont
}

# RMSS
rmss_fit &lt;- RMSS(x = x_train, y = y_train,
                 n_models = 3,
                 h_grid = c(35), t_grid = c(6, 8, 10), u_grid = c(1:3),
                 tolerance = 1e-1,
                 max_iter = 1e3,
                 neighborhood_search = FALSE,
                 neighborhood_search_tolerance = 1e-1)
rmss_coefs &lt;- coef(rmss_fit, 
                   h_ind = 1, t_ind = 2, u_ind = 1,
                   group_index = 1:rmss_fit$n_models)
sens_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/p.active
spec_rmss &lt;- sum(which((rmss_coefs[-1]!=0)) &lt;= p.active)/sum(rmss_coefs[-1]!=0)
rmss_preds &lt;- predict(rmss_fit, newx = x_test,
                      h_ind = 1, t_ind = 2, u_ind = 1,
                      group_index = 1:rmss_fit$n_models,
                      dynamic = FALSE)
rmss_mspe &lt;- mean((y_test - rmss_preds)^2)/sigma^2
trimmed_id &lt;- trimmed_samples(rmss_fit, h_ind = 1, t_ind = 1, u_ind = 1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
