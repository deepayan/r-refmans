<!DOCTYPE html><html><head><title>Help for package miceRanger</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {miceRanger}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addDatasets'><p>addDatasets</p></a></li>
<li><a href='#addIterations'><p>addIterations</p></a></li>
<li><a href='#amputeData'><p>amputeData</p></a></li>
<li><a href='#completeData'><p>completeData</p></a></li>
<li><a href='#getVarImps'><p>Get Variable Imputations</p></a></li>
<li><a href='#impute'><p>Impute New Data With Existing Models</p></a></li>
<li><a href='#miceRanger'><p>miceRanger: Fast Imputation with Random Forests</p></a></li>
<li><a href='#plotCorrelations'><p>plotCorrelations</p></a></li>
<li><a href='#plotDistributions'><p>plotDistributions</p></a></li>
<li><a href='#plotImputationVariance'><p>plotImputationVariance</p></a></li>
<li><a href='#plotModelError'><p>plotModelError</p></a></li>
<li><a href='#plotVarConvergence'><p>plotVarConvergence</p></a></li>
<li><a href='#plotVarImportance'><p>plotVarImportance</p></a></li>
<li><a href='#print.miceDefs'><p>Print a <code>miceDefs</code> object</p></a></li>
<li><a href='#sampleMiceDefs'><p>Sample miceDefs object built off of iris dataset.</p>
Included so examples don't run for too long.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Multiple Imputation by Chained Equations with Random Forests</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sam Wilson &lt;samwilson303@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple Imputation has been shown to 
  be a flexible method to impute missing values by 
  Van Buuren (2007) &lt;<a href="https://doi.org/10.1177%2F0962280206074463">doi:10.1177/0962280206074463</a>&gt;. 
  Expanding on this, random forests have been shown 
  to be an accurate model by Stekhoven and Buhlmann 
  &lt;<a href="https://doi.org/10.48550/arXiv.1105.0828">doi:10.48550/arXiv.1105.0828</a>&gt; to impute missing values in datasets. 
  They have the added benefits of returning out of bag 
  error and variable importance estimates, as well as 
  being simple to run in parallel.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/FarrellDay/miceRanger">https://github.com/FarrellDay/miceRanger</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/FarrellDay/miceRanger/issues">https://github.com/FarrellDay/miceRanger/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ranger, data.table, stats, FNN, ggplot2, crayon, corrplot,
ggpubr, DescTools, foreach</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, doParallel, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-06 14:50:29 UTC; SamWilson_</td>
</tr>
<tr>
<td>Author:</td>
<td>Sam Wilson [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-06 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addDatasets'>addDatasets</h2><span id='topic+addDatasets'></span>

<h3>Description</h3>

<p>Add datasets to a current miceDefs object. 
Adds the same number of iterations as other datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addDatasets(miceObj, datasets = 3, parallel = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addDatasets_+3A_miceobj">miceObj</code></td>
<td>
<p>A miceDefs object created by <code>miceRanger</code>.</p>
</td></tr>
<tr><td><code id="addDatasets_+3A_datasets">datasets</code></td>
<td>
<p>The number of datasets to add.</p>
</td></tr>
<tr><td><code id="addDatasets_+3A_parallel">parallel</code></td>
<td>
<p>Should the process run in parallel? This process will take advantage of any cluster 
set up when <code>miceRanger</code> is called.</p>
</td></tr>
<tr><td><code id="addDatasets_+3A_verbose">verbose</code></td>
<td>
<p>should progress be printed?</p>
</td></tr>
<tr><td><code id="addDatasets_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>ranger()</code> to control model building.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated miceDefs object with additional datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
miceObj &lt;- addDatasets(
    sampleMiceDefs
  , datasets = 1
  , verbose = FALSE
  , num.threads = 1
  , num.trees=5
)
</code></pre>

<hr>
<h2 id='addIterations'>addIterations</h2><span id='topic+addIterations'></span>

<h3>Description</h3>

<p>Add iterations to a current miceDefs object. Adds iterations for all datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addIterations(miceObj, iters = 5, parallel = FALSE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addIterations_+3A_miceobj">miceObj</code></td>
<td>
<p>A miceDefs object created by <code>miceRanger</code>.</p>
</td></tr>
<tr><td><code id="addIterations_+3A_iters">iters</code></td>
<td>
<p>The number of iterations to add to each dataset.</p>
</td></tr>
<tr><td><code id="addIterations_+3A_parallel">parallel</code></td>
<td>
<p>Should the process run in parallel? This process will take advantage of any cluster 
set up when <code>miceRanger</code> is called.</p>
</td></tr>
<tr><td><code id="addIterations_+3A_verbose">verbose</code></td>
<td>
<p>should progress be printed?</p>
</td></tr>
<tr><td><code id="addIterations_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>ranger()</code> to control model building.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated miceDefs object with additional iterations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
miceObj &lt;- addIterations(
    sampleMiceDefs
  , iters=2
  , verbose=FALSE
  , num.threads = 1
  , num.trees=5
)
</code></pre>

<hr>
<h2 id='amputeData'>amputeData</h2><span id='topic+amputeData'></span>

<h3>Description</h3>

<p>Randomly amputes data (MCAR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amputeData(data, perc = 0.1, cols = names(data))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amputeData_+3A_data">data</code></td>
<td>
<p>The data to be amputed</p>
</td></tr>
<tr><td><code id="amputeData_+3A_perc">perc</code></td>
<td>
<p>A scalar. The percentage (0-1) to be amputed.</p>
</td></tr>
<tr><td><code id="amputeData_+3A_cols">cols</code></td>
<td>
<p>The columns to ampute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same dataset with random values in <code>cols</code> set to NA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
head(iris,10)

ampIris &lt;- amputeData(iris)
head(ampIris,10)
</code></pre>

<hr>
<h2 id='completeData'>completeData</h2><span id='topic+completeData'></span>

<h3>Description</h3>

<p>Return imputed datasets from a <code>miceDefs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>completeData(miceObj, datasets = 1:miceObj$callParams$m, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="completeData_+3A_miceobj">miceObj</code></td>
<td>
<p>an object of class miceDefs.</p>
</td></tr>
<tr><td><code id="completeData_+3A_datasets">datasets</code></td>
<td>
<p>a vector of the datasets you want to return.</p>
</td></tr>
<tr><td><code id="completeData_+3A_verbose">verbose</code></td>
<td>
<p>a warning is thrown if integers are converted to doubles.
To suppress this warning, set to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of imputed datasets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
imputedList &lt;- completeData(sampleMiceDefs)
</code></pre>

<hr>
<h2 id='getVarImps'>Get Variable Imputations</h2><span id='topic+getVarImps'></span>

<h3>Description</h3>

<p>Returns imputations for the specified datasets and variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVarImps(x, datasets, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVarImps_+3A_x">x</code></td>
<td>
<p>A <code>miceDefs</code> or <code>impDefs</code> object.</p>
</td></tr>
<tr><td><code id="getVarImps_+3A_datasets">datasets</code></td>
<td>
<p>The datasets to return. Can be a number, of a numeric vector.</p>
</td></tr>
<tr><td><code id="getVarImps_+3A_var">var</code></td>
<td>
<p>The variable to return the imputations for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions exist solely to get at the imputed data for a
specific dataset and variable.
</p>


<h3>Value</h3>

<p>A matrix of imputations for a single variable. 
Each column represents a different dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
getVarImps(sampleMiceDefs,var="Petal.Width")
</code></pre>

<hr>
<h2 id='impute'>Impute New Data With Existing Models</h2><span id='topic+impute'></span>

<h3>Description</h3>

<p>Impute data using the information from an existing <code>miceDefs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute(
  data,
  miceObj,
  datasets = 1:miceObj$callParams$m,
  iterations = miceObj$callParams$maxiter,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_+3A_data">data</code></td>
<td>
<p>The data to be imputed. Must have all columns used in the imputation of miceDefs.</p>
</td></tr>
<tr><td><code id="impute_+3A_miceobj">miceObj</code></td>
<td>
<p>A miceDefs object created by <code>miceRanger()</code>.</p>
</td></tr>
<tr><td><code id="impute_+3A_datasets">datasets</code></td>
<td>
<p>A numeric vector specifying the datasets with which to impute <code>data</code>.
See details for more information.</p>
</td></tr>
<tr><td><code id="impute_+3A_iterations">iterations</code></td>
<td>
<p>The number of iterations to run. 
By default, the same as the number of iterations currently in <code>miceObj</code>.</p>
</td></tr>
<tr><td><code id="impute_+3A_verbose">verbose</code></td>
<td>
<p>should progress be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This capability is experimental, but works well in 
<a href="https://github.com/FarrellDay/miceRanger/tree/master/benchmarks">benchmarking</a>. 
The original data and random forests (if returnModels = TRUE) are returned when <code>miceRanger</code> 
is called. These models can be recycled to impute a new dataset in the same fashion as <code>miceRanger</code>,
by imputing each variable over a series of iterations. Each dataset created in <code>miceObj</code> 
can be thought of as a different imputation mechanism, with different initialized values
and a different associated random forests. Therefore, it is necessary to choose the datasets
which will be used to impute the data. When mean matching a numeric variable, the candidate 
values are drawn from the original data passed to <code>miceRanger</code>, not the <code>data</code> passed 
to this function.
</p>


<h3>Value</h3>

<p>An object of class impDefs, which contains information about the imputation process.
</p>
<table>
<tr><td><code>callParams</code></td>
<td>
<p>The parameters of the object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original data provided by the user.</p>
</td></tr>
<tr><td><code>naWhere</code></td>
<td>
<p>Logical index of missing data, having the same dimensions as <code>data</code>.</p>
</td></tr>
<tr><td><code>missingCounts</code></td>
<td>
<p>The number of missing values for each variable.</p>
</td></tr>
<tr><td><code>imputedData</code></td>
<td>
<p>A list of imputed datasets.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ampDat &lt;- amputeData(iris)
miceObj &lt;- miceRanger(ampDat,1,1,returnModels=TRUE,verbose=FALSE)

newDat &lt;- amputeData(iris)
newImps &lt;- impute(newDat,miceObj)
</code></pre>

<hr>
<h2 id='miceRanger'>miceRanger: Fast Imputation with Random Forests</h2><span id='topic+miceRanger'></span>

<h3>Description</h3>

<p>Performs multiple imputation by chained random forests.
Returns a miceDefs object, which contains information about the imputation process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>miceRanger(
  data,
  m = 5,
  maxiter = 5,
  vars,
  valueSelector = c("meanMatch", "value"),
  meanMatchCandidates = pmax(round(nrow(data) * 0.01), 5),
  returnModels = FALSE,
  parallel = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="miceRanger_+3A_data">data</code></td>
<td>
<p>A data.frame or data.table to be imputed.</p>
</td></tr>
<tr><td><code id="miceRanger_+3A_m">m</code></td>
<td>
<p>The number of datasets to produce.</p>
</td></tr>
<tr><td><code id="miceRanger_+3A_maxiter">maxiter</code></td>
<td>
<p>The number of iterations to run for each dataset.</p>
</td></tr>
<tr><td><code id="miceRanger_+3A_vars">vars</code></td>
<td>
<p>Specifies which and how variables should be imputed. Can be specified in 3 different ways:
</p>

<ul>
<li> <p>&lt;missing&gt; If not provided, all columns will be imputed using all columns. If
a column contains no missing values, it will still be used as a feature to impute missing columns.
</p>
</li>
<li> <p>&lt;character vector&gt; If a character vector of column names is passed, these columns will
be imputed using all available columns in the dataset. The order of this vector will determine the 
order in which the variables are imputed.
</p>
</li>
<li> <p>&lt;named list of character vectors&gt; Predictors can be specified for each variable with a named list. 
List names are the variables to impute. Elements in the vectors should be features used to 
impute that variable. The order of this list will determine the order in which the variables are imputed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="miceRanger_+3A_valueselector">valueSelector</code></td>
<td>
<p>How to select the value to be imputed from the model predictions. 
Can be &quot;meanMatching&quot;, &quot;value&quot;, or a named vector containing a mixture of those values.
If a named vector is passed, the names must equal the variables to be imputed specified in <code>vars</code>.</p>
</td></tr>
<tr><td><code id="miceRanger_+3A_meanmatchcandidates">meanMatchCandidates</code></td>
<td>
<p>Specifies the number of candidate values which are selected from in the 
mean matching algorithm. Can be either specified as an integer or a named integer vector for different 
values by variable. If a named integer vector is passed, the names of the vector must contain at a 
minimum the names of the numeric variables imputed using <code>valueSelector = "meanMatch"</code>.</p>
</td></tr>
<tr><td><code id="miceRanger_+3A_returnmodels">returnModels</code></td>
<td>
<p>Logical. Should the final model for each variable be returned? Set to <code>TRUE</code>
to use the <code>impute</code> function, which allows imputing new samples without having to run <code>miceRanger</code> again.
Setting to TRUE can cause the returned <code>miceDefs</code> object to take up a lot of memory. Use only if
you plan on using the <code>impute</code> function.</p>
</td></tr>
<tr><td><code id="miceRanger_+3A_parallel">parallel</code></td>
<td>
<p>Should the process run in parallel? Usually not necessary. This process will 
take advantage of any cluster set up when <code>miceRanger</code> is called.</p>
</td></tr>
<tr><td><code id="miceRanger_+3A_verbose">verbose</code></td>
<td>
<p>should progress be printed?</p>
</td></tr>
<tr><td><code id="miceRanger_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>ranger()</code> to control forest growth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a miceDefs object, containing the following:
</p>
<table>
<tr><td><code>callParams</code></td>
<td>
<p>The parameters of the object.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original data provided by the user, cast to a data.table.</p>
</td></tr>
<tr><td><code>naWhere</code></td>
<td>
<p>Logical index of missing data, having the same dimensions as <code>data</code>.</p>
</td></tr>
<tr><td><code>missingCounts</code></td>
<td>
<p>The number of missing values for each variable</p>
</td></tr>
<tr><td><code>rawClasses</code></td>
<td>
<p>The original classes provided in <code>data</code></p>
</td></tr>
<tr><td><code>newClasses</code></td>
<td>
<p>The new classes of the returned data.</p>
</td></tr>
<tr><td><code>allImps</code></td>
<td>
<p>The imputations of all variables at each iteration, for each dataset.</p>
</td></tr>
<tr><td><code>allImport</code></td>
<td>
<p>The variable importance metrics at each iteration, for each dataset.</p>
</td></tr>
<tr><td><code>allError</code></td>
<td>
<p>The OOB model error for all variables at each iteration, for each dataset.</p>
</td></tr>
<tr><td><code>finalImps</code></td>
<td>
<p>The final imputations for each dataset.</p>
</td></tr>
<tr><td><code>finalImport</code></td>
<td>
<p>The final variable importance metrics for each dataset.</p>
</td></tr>
<tr><td><code>finalError</code></td>
<td>
<p>The final model error for each variable in every dataset.</p>
</td></tr>
<tr><td><code>finalModels</code></td>
<td>
<p>Only returned if <code>returnModels = TRUE</code>. A list of <code>ranger</code> random forests for each dataset/variable.</p>
</td></tr>
<tr><td><code>imputationTime</code></td>
<td>
<p>The total time in seconds taken to create the imputations for the 
specified datasets and iterations. Does not include any setup time.</p>
</td></tr>
</table>


<h3>Vignettes</h3>

<p>It is highly recommended to visit the <a href="https://github.com/farrellday/miceRanger">GitHub README</a> 
for a thorough walkthrough of miceRanger's capabilities, as well as performance benchmarks.
</p>
<p>Several vignettes are also available on <a href="https://cran.r-project.org/package=miceRanger">miceRanger's listing</a>
on the CRAN website.
</p>

<ol>
<li> <p><a href="https://cran.r-project.org/package=miceRanger/vignettes/miceAlgorithm.html">The MICE Algorithm</a>
</p>
</li>
<li> <p><a href="https://cran.r-project.org/package=miceRanger/vignettes/usingMiceRanger.html">Imputing Missing Data with miceRanger</a>
</p>
</li>
<li> <p><a href="https://cran.r-project.org/package=miceRanger/vignettes/diagnosticPlotting.html">Diagnostic Plotting</a>
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>#################
## Simple Example

data(iris)
ampIris &lt;- amputeData(iris)

miceObj &lt;- miceRanger(
    ampIris
  , m = 1
  , maxiter = 1
  , verbose=FALSE
  , num.threads = 1
  , num.trees=5
)


##################
## Run in parallel

data(iris)
ampIris &lt;- amputeData(iris)

library(doParallel)
cl &lt;- makeCluster(2)
registerDoParallel(cl)

# Perform mice 
miceObjPar &lt;- miceRanger(
    ampIris
  , m = 2
  , maxiter = 2
  , parallel = TRUE
  , verbose = FALSE
)
stopCluster(cl)
registerDoSEQ()


############################
## Complex Imputation Schema

data(iris)
ampIris &lt;- amputeData(iris)

# Define variables to impute, as well as their predictors
v &lt;- list(
  Sepal.Width = c("Sepal.Length","Petal.Width","Species")
  , Sepal.Length = c("Sepal.Width","Petal.Width")
  , Species = c("Sepal.Width")
)

# Specify mean matching for certain variables.
vs &lt;- c(
  Sepal.Width = "meanMatch"
  , Sepal.Length = "value"
  , Species = "meanMatch"
)

# Different mean matching candidates per variable.
mmc &lt;- c(
  Sepal.Width = 4
  , Species = 10
)

miceObjCustom &lt;- miceRanger(
    ampIris
  , m = 1
  , maxiter = 1
  , vars = v
  , valueSelector = vs
  , meanMatchCandidates = mmc
  , verbose=FALSE
)

</code></pre>

<hr>
<h2 id='plotCorrelations'>plotCorrelations</h2><span id='topic+plotCorrelations'></span>

<h3>Description</h3>

<p>Plot the correlation of imputed values between every combination of datasets for each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCorrelations(
  miceObj,
  vars = names(miceObj$callParams$vars),
  factCorrMetric = "CramerV",
  numbCorrMetric = "pearson",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCorrelations_+3A_miceobj">miceObj</code></td>
<td>
<p>an object of class miceDefs, created by the miceRanger function.</p>
</td></tr>
<tr><td><code id="plotCorrelations_+3A_vars">vars</code></td>
<td>
<p>the variables you want to plot. Default is to plot all variables. Can be a vector of
variable names, or one of 'allNumeric' or 'allCategorical'</p>
</td></tr>
<tr><td><code id="plotCorrelations_+3A_factcorrmetric">factCorrMetric</code></td>
<td>
<p>The correlation metric for categorical variables. Can be one of:
</p>

<ul>
<li> <p><code>"CramerV"</code> Cramer's V correlation metric.
</p>
</li>
<li> <p><code>"Chisq"</code> Chi Square test statistic.
</p>
</li>
<li> <p><code>"TschuprowT"</code> Tschuprow's T correlation metric.
</p>
</li>
<li> <p><code>"Phi"</code> (Binary Variables Only) Phi coefficient.
</p>
</li>
<li> <p><code>"YuleY"</code> (Binary Variables Only) Yule's Y, also known as coefficient of colligation
</p>
</li>
<li> <p><code>"YuleQ"</code> (Binary Variables Only) Yule's Q, related to Yule's Y by Q=2Y/(1+Y^2)
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotCorrelations_+3A_numbcorrmetric">numbCorrMetric</code></td>
<td>
<p>The correlation metric for numeric variables. Can be one of:
</p>

<ul>
<li> <p><code>"pearson"</code> Pearson's Correlation Coefficient
</p>
</li>
<li> <p><code>"spearman"</code> Spearman's Rank Correlation Coefficient
</p>
</li>
<li> <p><code>"kendall"</code> Kendall's Rank Correlation Coefficient
</p>
</li>
<li> <p><code>"Rsquared"</code> R-squared
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotCorrelations_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to ggarrange()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>ggarrange</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
plotCorrelations(sampleMiceDefs)
</code></pre>

<hr>
<h2 id='plotDistributions'>plotDistributions</h2><span id='topic+plotDistributions'></span>

<h3>Description</h3>

<p>Plots the distribution of the original data beside the imputed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistributions(
  miceObj,
  vars = names(miceObj$callParams$vars),
  dotsize = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDistributions_+3A_miceobj">miceObj</code></td>
<td>
<p>an object of class miceDefs, created by the miceRanger function.</p>
</td></tr>
<tr><td><code id="plotDistributions_+3A_vars">vars</code></td>
<td>
<p>the variables you want to plot. Default is to plot all variables. Can be a vector of
variable names, or one of 'allNumeric' or 'allCategorical'</p>
</td></tr>
<tr><td><code id="plotDistributions_+3A_dotsize">dotsize</code></td>
<td>
<p>Passed to <code>geom_dotplot()</code>. Depending on the number of graphs plotted, you may want to
change the dot size for categorical variables.</p>
</td></tr>
<tr><td><code id="plotDistributions_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>ggarrange()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>ggarrange</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
plotDistributions(sampleMiceDefs)
</code></pre>

<hr>
<h2 id='plotImputationVariance'>plotImputationVariance</h2><span id='topic+plotImputationVariance'></span>

<h3>Description</h3>

<p>Plots the distribution of the difference between datasets of the imputed values.
For categorical variables, the distribution of the number of distinct levels imputed for each sample
is shown next to the distribution of unique draws from that variable in the nonmissing data, given that
the draws were completely random.
For numeric variables, the density of the standard deviation (between datasets) of imputations is 
plotted. The shaded area represents the samples that had a standard deviation lower than the total
nonmissing standard deviation for the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImputationVariance(
  miceObj,
  vars = names(miceObj$callParams$vars),
  monteCarloSimulations = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotImputationVariance_+3A_miceobj">miceObj</code></td>
<td>
<p>an object of class miceDefs, created by the miceRanger function.</p>
</td></tr>
<tr><td><code id="plotImputationVariance_+3A_vars">vars</code></td>
<td>
<p>the variables you want to plot. Default is to plot all variables. Can be a vector of
variable names, or one of 'allNumeric' or 'allCategorical'</p>
</td></tr>
<tr><td><code id="plotImputationVariance_+3A_montecarlosimulations">monteCarloSimulations</code></td>
<td>
<p>The number of simulations to run to determine the distribution of
unique categorical levels drawn if the draws were completely random.</p>
</td></tr>
<tr><td><code id="plotImputationVariance_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code>ggarrange()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>ggarrange</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
plotImputationVariance(
  sampleMiceDefs
  , monteCarloSimulations = 100
)
</code></pre>

<hr>
<h2 id='plotModelError'>plotModelError</h2><span id='topic+plotModelError'></span>

<h3>Description</h3>

<p>Plot the Out Of Bag model error for specified variables over all iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModelError(
  miceObj,
  vars = names(miceObj$callParams$vars),
  pointSize = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotModelError_+3A_miceobj">miceObj</code></td>
<td>
<p>an object of class miceDefs, created by the miceRanger function.</p>
</td></tr>
<tr><td><code id="plotModelError_+3A_vars">vars</code></td>
<td>
<p>the variables you want to plot. Default is to plot all variables. Can be a vector of
variable names, or one of 'allNumeric' or 'allCategorical'</p>
</td></tr>
<tr><td><code id="plotModelError_+3A_pointsize">pointSize</code></td>
<td>
<p>passed to <code>geom_point</code>, allows user to change dot size.</p>
</td></tr>
<tr><td><code id="plotModelError_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>ggarrange()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>ggarrange</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
plotModelError(sampleMiceDefs)
</code></pre>

<hr>
<h2 id='plotVarConvergence'>plotVarConvergence</h2><span id='topic+plotVarConvergence'></span>

<h3>Description</h3>

<p>Plot the evolution of the dispersion and center of each variable.
For numeric variables, the center is the mean, and the dispersion is the standard deviation.
For categorical variables, the center is the mode, and the dispersion is the entropy of the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVarConvergence(miceObj, vars = names(miceObj$callParams$vars), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVarConvergence_+3A_miceobj">miceObj</code></td>
<td>
<p>an object of class <code>miceDefs</code>, created by the <code>miceRanger</code> function.</p>
</td></tr>
<tr><td><code id="plotVarConvergence_+3A_vars">vars</code></td>
<td>
<p>the variables you want to plot. Default is to plot all variables. Can be a vector of
variable names, or one of 'allNumeric' or 'allCategorical'</p>
</td></tr>
<tr><td><code id="plotVarConvergence_+3A_...">...</code></td>
<td>
<p>options passed to <code>ggarrange()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>ggarrange</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
plotVarConvergence(sampleMiceDefs)
</code></pre>

<hr>
<h2 id='plotVarImportance'>plotVarImportance</h2><span id='topic+plotVarImportance'></span>

<h3>Description</h3>

<p>Plot the variable importance for each imputed variable. The values
represent the variables on the top axis importance in imputing the variables on
the left axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVarImportance(
  miceObj,
  display = c("Relative", "Absolute"),
  dataset = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVarImportance_+3A_miceobj">miceObj</code></td>
<td>
<p>an object of class miceDefs, created by the miceRanger function.</p>
</td></tr>
<tr><td><code id="plotVarImportance_+3A_display">display</code></td>
<td>
<p>How do you want to display variable importance?
</p>

<ul>
<li> <p>&quot;Relative&quot; Scales the importance measure between 0-1 for each variable.
</p>
</li>
<li> <p>&quot;Absolute&quot; Displays the variable importance as is. May be highly skewed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotVarImportance_+3A_dataset">dataset</code></td>
<td>
<p>The dataset you want to plot the variable importance of.</p>
</td></tr>
<tr><td><code id="plotVarImportance_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>corrplot()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("sampleMiceDefs")
plotVarImportance(sampleMiceDefs)
</code></pre>

<hr>
<h2 id='print.miceDefs'>Print a <code>miceDefs</code> object</h2><span id='topic+print.miceDefs'></span>

<h3>Description</h3>

<p>Print a <code>miceDefs</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'miceDefs'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.miceDefs_+3A_x">x</code></td>
<td>
<p>Object of class <code>miceDefs</code></p>
</td></tr>
<tr><td><code id="print.miceDefs_+3A_...">...</code></td>
<td>
<p>required to use S3 method</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='sampleMiceDefs'>Sample miceDefs object built off of iris dataset.
Included so examples don't run for too long.</h2><span id='topic+sampleMiceDefs'></span>

<h3>Description</h3>

<p>Sample miceDefs object built off of iris dataset.
Included so examples don't run for too long.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleMiceDefs
</code></pre>


<h3>Format</h3>

<p>A miceDefs object. See &ldquo;'?miceRanger&ldquo;' for details.
</p>


<h3>Source</h3>

<p>set.seed(1991)
data(iris)
ampIris &lt;- amputeData(iris,cols = c(&quot;Petal.Width&quot;,&quot;Species&quot;))
sampleMiceDefs &lt;- miceRanger(
ampIris
,m=3
,maxiter=3
,vars=c(&quot;Petal.Width&quot;,&quot;Species&quot;)
)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 sampleMiceDefs

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
