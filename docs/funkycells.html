<!DOCTYPE html><html><head><title>Help for package funkycells</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {funkycells}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#computePseudoROCCurves'><p>Compute Pseudo-ROC Curves</p></a></li>
<li><a href='#funkyForest'><p>Compute a Modified Random Forest Model</p></a></li>
<li><a href='#funkyModel'><p>Fit a Modified Random Forest Model with Bounds and Alignment</p></a></li>
<li><a href='#getCountData'><p>Get Agent Count Data</p></a></li>
<li><a href='#getKFunction'><p>Get K function</p></a></li>
<li><a href='#getKsPCAData'><p>Get K Functions and Compute Principal Components</p></a></li>
<li><a href='#plot_K_functions'><p>Compare K Functions Between outcomes</p></a></li>
<li><a href='#plotPP'><p>Plot Spatial Point Process</p></a></li>
<li><a href='#predict_funkyForest'><p>Predict a funkyForest</p></a></li>
<li><a href='#simulateMeta'><p>Simulate Meta Variables</p></a></li>
<li><a href='#simulatePP'><p>Simulate a Point Process</p></a></li>
<li><a href='#TNBC'><p>Triple Negative Breast Cancer Data</p></a></li>
<li><a href='#TNBC_meta'><p>Triple Negative Breast Cancer Phenotypes</p></a></li>
<li><a href='#TNBC_pheno'><p>Triple Negative Breast Cancer Phenotypes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functional Data Analysis for Multiplexed Cell Images</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Compare variables of interest between (potentially large
    numbers of) spatial interactions and meta-variables. Spatial variables
    are summarized using K, or other, functions, and projected for use in
    a modified random forest model. The model allows comparison of
    functional and non-functional variables to each other and to noise,
    giving statistical significance to the results. Included are
    preparation, modeling, and interpreting tools along with example
    datasets, as described in VanderDoes et al., (2023)
    &lt;<a href="https://doi.org/10.1101%2F2023.07.18.549619">doi:10.1101/2023.07.18.549619</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jrvanderdoes/funkycells">https://github.com/jrvanderdoes/funkycells</a>,
<a href="https://jrvanderdoes.github.io/funkycells/">https://jrvanderdoes.github.io/funkycells/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jrvanderdoes/funkycells/issues">https://github.com/jrvanderdoes/funkycells/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>fda, ggplot2, rpart, spatstat.explore, spatstat.geom, stats,
stringr, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, pROC, rmarkdown, scales, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 12:48:11 UTC; jerem</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy VanderDoes <a href="https://orcid.org/0009-0001-9885-3073"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Jack Hywood <a href="https://orcid.org/0000-0002-2028-2629"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Gregory Rice [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeremy VanderDoes &lt;jeremy.vanderdoes@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-09 16:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='computePseudoROCCurves'>Compute Pseudo-ROC Curves</h2><span id='topic+computePseudoROCCurves'></span>

<h3>Description</h3>

<p>An receiver operating characteristic (ROC) curve is a curve showing the
performance of a classification model at all classification thresholds.
True ROC can only be computed for two-options, but we can consider each
classification, i.e. prediction, correct or incorrect and overlay the
curves. Note this means the lines may cover each other and be difficult to
see.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computePseudoROCCurves(trueOutcomes, modelPercents)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computePseudoROCCurves_+3A_trueoutcomes">trueOutcomes</code></td>
<td>
<p>Vector of the true results</p>
</td></tr>
<tr><td><code id="computePseudoROCCurves_+3A_modelpercents">modelPercents</code></td>
<td>
<p>Data.frame with columns named after the true outcomes,
giving the percent of selecting that outcome. This is what is returned
predict.RandomForest_PC with type='all' in object <code>PredPerc[-1]</code> (first
column is the predictions).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the package 'pROC' to be installed.
</p>


<h3>Value</h3>

<p>ggplot object containing the ROC curves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>percents &lt;- data.frame(c(0.980, 0.675, 0.878, 0.303, 0.457, 0.758,
                         0.272, 0.524, 0.604, 0.342, 0.214, 0.569,
                         0.279, 0.128, 0.462, 0.098, 0.001, 0.187),
                       c(0.005, 0.160, 0.100, 0.244, 0.174, 0.143,
                         0.652, 0.292, 0.040, 0.312, 0.452, 0.168,
                         0.173, 0.221, 0.281, 0.029, 0.005, 0.057),
                       c(0.015, 0.165, 0.022, 0.453, 0.369, 0.099,
                         0.076, 0.084, 0.156, 0.346, 0.334, 0.263,
                         0.548, 0.651, 0.257, 0.873, 0.994, 0.756))
colnames(percents) &lt;- c('0','1','2')
proc &lt;- computePseudoROCCurves(c(0, 0, 0, 0, 0, 0,
                                 1, 1, 1, 1, 1, 1,
                                 2, 2, 2, 2, 2, 2),
                               percents)
</code></pre>

<hr>
<h2 id='funkyForest'>Compute a Modified Random Forest Model</h2><span id='topic+funkyForest'></span>

<h3>Description</h3>

<p>This function creates a modified random forest model for principal component
and meta-data. This can be useful to get a final model, but we recommend
use of randomForest_CVPC in general, which includes the final model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funkyForest(
  data,
  outcome = colnames(data)[1],
  unit = colnames(data)[2],
  nTrees = 500,
  varImpPlot = TRUE,
  metaNames = NULL,
  keepModels = TRUE,
  varSelPercent = 0.8,
  method = "class"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funkyForest_+3A_data">data</code></td>
<td>
<p>Data.frame of outcome and predictors. The predictors include
groups of variables which are finite projections of a higher dimensional
variables as well as single meta-variables.
</p>
<p>Any replicate data, i.e. repeated observations, should already be handled.
The unit column is needed just to drop data (so pre-removing and giving
NULL works). Typically use the results from getKsPCAData, potentially with
meta-variables attached.</p>
</td></tr>
<tr><td><code id="funkyForest_+3A_outcome">outcome</code></td>
<td>
<p>(Optional) String indicating the outcome column name in data.
Default is the first column of data.</p>
</td></tr>
<tr><td><code id="funkyForest_+3A_unit">unit</code></td>
<td>
<p>(Optional) String indicating the unit column name in data.
Default is the second column of data.</p>
</td></tr>
<tr><td><code id="funkyForest_+3A_ntrees">nTrees</code></td>
<td>
<p>(Optional) Numeric indicating the number of trees to use in the
random forest model. Default is 500.</p>
</td></tr>
<tr><td><code id="funkyForest_+3A_varimpplot">varImpPlot</code></td>
<td>
<p>(Optional) Boolean indicating if variable importance plots
should also be returned with the model. Default is TRUE.</p>
</td></tr>
<tr><td><code id="funkyForest_+3A_metanames">metaNames</code></td>
<td>
<p>(Optional) Vector with the column names of data that
correspond to metavariables. Default is NULL.</p>
</td></tr>
<tr><td><code id="funkyForest_+3A_keepmodels">keepModels</code></td>
<td>
<p>(Optional) Boolean indicating if the individual models
should be kept. Can get large in size. Default is TRUE as it is needed
for predictions.</p>
</td></tr>
<tr><td><code id="funkyForest_+3A_varselpercent">varSelPercent</code></td>
<td>
<p>(Optional) Numeric in (0,1) indicating (approx)
percentage of variables to keep for each tree. Default is 0.8.</p>
</td></tr>
<tr><td><code id="funkyForest_+3A_method">method</code></td>
<td>
<p>(Optional) Method for rpart tree to build random forest.
Default is &quot;class&quot;. Currently this is the only tested method. This will
be expanded in future releases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with  entries
</p>

<ol>
<li><p> varImportanceData: Data.frame for variable importance
information.
</p>
</li>
<li><p> (Optional) model: List of CART that builds the random forest model.
</p>
</li>
<li><p> (Optional) varImportancePlot: Variable importance plots.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>ff &lt;- funkyForest(
  data = TNBC[, c(1:8, ncol(TNBC))],
  outcome = "Class", unit = "Person",
  metaNames = c("Age")
  )
</code></pre>

<hr>
<h2 id='funkyModel'>Fit a Modified Random Forest Model with Bounds and Alignment</h2><span id='topic+funkyModel'></span>

<h3>Description</h3>

<p>The function fits a modified random forest model to principal components
of spatial interactions as well as meta-data. Additionally permutation and
cross-validation is employed to improve understanding of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funkyModel(
  data,
  K = 10,
  outcome = colnames(data)[1],
  unit = colnames(data)[2],
  metaNames = NULL,
  synthetics = 100,
  alpha = 0.05,
  silent = FALSE,
  rGuessSims = 500,
  subsetPlotSize = 25,
  nTrees = 500,
  method = "class"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funkyModel_+3A_data">data</code></td>
<td>
<p>Data.frame of outcome and predictors. The predictors include
groups of variables which are finite projections of a higher dimensional
variables as well as single meta-variables.
</p>
<p>Any replicate data, i.e. repeated observations, should already be handled.
The unit column is needed just to drop data (so pre-removing and giving
NULL works). Typically use the results from getKsPCAData, potentially with
meta-variables attached.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_k">K</code></td>
<td>
<p>(Optional) Numeric indicating the number of folds to use in K-fold
cross-validation. The default is 10.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_outcome">outcome</code></td>
<td>
<p>(Optional) String indicating the outcome column name in data.
Default is the first column of data.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_unit">unit</code></td>
<td>
<p>(Optional) String indicating the unit column name in data.
Default is the second column of data.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_metanames">metaNames</code></td>
<td>
<p>(Optional) Vector indicating the meta-variables to be
considered. Default is NULL.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_synthetics">synthetics</code></td>
<td>
<p>(Optional) Numeric indicating the number of synthetics for
variables (one set of sythethics for functional variables and one for each
meta-variable). If 0 are used, the data cannot be aligned properly. Default
is 100.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_alpha">alpha</code></td>
<td>
<p>(Optional) Numeric in (0,1) indicating the significance used
throughout the analysis. Default is 0.05.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_silent">silent</code></td>
<td>
<p>(Optional) Boolean indicating if output should be suppressed
when the function is running. Default is FALSE.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_rguesssims">rGuessSims</code></td>
<td>
<p>(Optional) Numeric value indicating the number of
simulations used for guessing and creating the guess estimate on the
plot. Default is 500.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_subsetplotsize">subsetPlotSize</code></td>
<td>
<p>(Optional) Numeric indicating the number of top
variables to include in a subset graph. If this is larger than the total
number then no subset graph will be produced. Default is 25.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_ntrees">nTrees</code></td>
<td>
<p>(Optional) Numeric indicating the number of trees to use in the
random forest model. Default is 500.</p>
</td></tr>
<tr><td><code id="funkyModel_+3A_method">method</code></td>
<td>
<p>(Optional) Method for rpart tree to build random forest.
Default is &quot;class&quot;. Currently this is the only tested method. This will
be expanded in future releases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following items:
</p>

<ol>
<li><p> model: The funkyForest Model fit on the entire given data.
</p>
</li>
<li><p> VariableImportance: Data.frame with the results of variable
importance indices from the models and CV. The columns are
var, est, sd, and cvSD.
</p>
</li>
<li><p> AccuracyEstimate: Data.frame with model accuracy estimates:
out-of-bag accuracy (OOB), biased estimate (bias), and
random guess (guess). The columns are OOB, bias, and guess.
</p>
</li>
<li><p> NoiseCutoff: Numeric indicating noise cutoff (vertical line).
</p>
</li>
<li><p> InterpolationCutoff: Vector of numerics indicating the
interpolation cutoff (curved line).
</p>
</li>
<li><p> AdditionalParams: List of additional parameters for reference:
Alpha and subsetPlotSize.
</p>
</li>
<li><p> viPlot: ggplot2 object for vi plot with standardized results.
It displays ordered underlying functions and meta-variables
with point estimates, sd, noise cutoff, and interpolation
cutoff all based on variable importance values.
</p>
</li>
<li><p> subset_viPlot: (Optional) ggplot2 object for vi plot with
standardized results and only top subsetPlotSize variables.
It displays ordered underlying functions and meta-variables
with point estimates, sd, noise cutoff, and interpolation
cutoff all based on variable importance values.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Parameters are reduced beyond recommended levels for speed
fm &lt;- funkyModel(
  data = TNBC[, c(1:8, ncol(TNBC))],
  outcome = "Class", unit = "Person",
  metaNames = c("Age"),
  nTrees = 5, synthetics = 10,
  silent = TRUE
)
</code></pre>

<hr>
<h2 id='getCountData'>Get Agent Count Data</h2><span id='topic+getCountData'></span>

<h3>Description</h3>

<p>This function gets the average percent agent counts per replicate, if there
are replicates (i.e. replicate is not NULL), then the agent percents are
calculated for each replicate and these percentages are averaged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCountData(
  agent_data,
  outcome,
  unit,
  replicate = NULL,
  type = "type",
  data_append = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCountData_+3A_agent_data">agent_data</code></td>
<td>
<p>Data.frame of agent data information, with columns as
defined in subsequent parameters</p>
</td></tr>
<tr><td><code id="getCountData_+3A_outcome">outcome</code></td>
<td>
<p>String of the column name in data indicating the outcome or
response.</p>
</td></tr>
<tr><td><code id="getCountData_+3A_unit">unit</code></td>
<td>
<p>String of the column name in data indicating a unit or
base thing. Note this unit may have replicates.</p>
</td></tr>
<tr><td><code id="getCountData_+3A_replicate">replicate</code></td>
<td>
<p>(Optional) String of the column name in data indicating the
replicate id. Default is NULL.</p>
</td></tr>
<tr><td><code id="getCountData_+3A_type">type</code></td>
<td>
<p>(Optional) String of the column name in data indicating the
type. Default is type.</p>
</td></tr>
<tr><td><code id="getCountData_+3A_data_append">data_append</code></td>
<td>
<p>(Optional) Data.frame with outcome, patient that the
results can be appended to if desired. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two elements:
</p>

<ul>
<li><p> dat: Data.frame with outcome, unit, data_append, and the count
data. Columns of the count data are named after the type and are given
in the next list entry.
</p>
</li>
<li><p> agents: Vector of the the types, i.e. the column names for the
new count data. This can be treated as meta data for funkyForest.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data_ct &lt;- getCountData(TNBC_pheno[TNBC_pheno$Phenotype %in% c('Tumor','B'),],
                        outcome="Class", unit="Person",type="Phenotype")
</code></pre>

<hr>
<h2 id='getKFunction'>Get K function</h2><span id='topic+getKFunction'></span>

<h3>Description</h3>

<p>This function computes the K function between the two agents for each unit,
potentially averaging over replicates, or repeated measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKFunction(
  data,
  agents,
  unit,
  replicate = NULL,
  rCheckVals = NULL,
  xRange = NULL,
  yRange = NULL,
  edgeCorrection = "isotropic"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getKFunction_+3A_data">data</code></td>
<td>
<p>Dataframe with column titles for at least x, y, agents,
and unit. For consistency (and avoiding errors), use that order.
Additionally, replicate can be added.</p>
</td></tr>
<tr><td><code id="getKFunction_+3A_agents">agents</code></td>
<td>
<p>Two value vector indicating the two agents to use for the K
function, the first to the second. These should be in the unit column.</p>
</td></tr>
<tr><td><code id="getKFunction_+3A_unit">unit</code></td>
<td>
<p>String of the column name in data indicating a unit or base
thing. Note this unit may have replicates.</p>
</td></tr>
<tr><td><code id="getKFunction_+3A_replicate">replicate</code></td>
<td>
<p>(Optional) String of the column name in data indicating the
unique replicates, or repeated measures.</p>
</td></tr>
<tr><td><code id="getKFunction_+3A_rcheckvals">rCheckVals</code></td>
<td>
<p>(Optional) Numeric vector indicating the radius to check.
Note, if note specified, this could take a lot of memory, particularly
with many units and replicates.</p>
</td></tr>
<tr><td><code id="getKFunction_+3A_xrange">xRange</code>, <code id="getKFunction_+3A_yrange">yRange</code></td>
<td>
<p>(Optional) Two value numeric vector indicating the min
and max x / y values. Note this is re-used for all images. The default just
takes the min and max from each image. This allows different sized images,
but the edges are defined by some agent location.</p>
</td></tr>
<tr><td><code id="getKFunction_+3A_edgecorrection">edgeCorrection</code></td>
<td>
<p>(Optional) String indicating type of edgeCorrection(s)
to apply when computing the K functions. Options include: &quot;border&quot;,
&quot;bord.modif&quot;, &quot;isotropic&quot;, &quot;Ripley&quot;, &quot;translate&quot;, &quot;translation&quot;, &quot;periodic&quot;,
&quot;none&quot;, &quot;best&quot; or &quot;all&quot; selects all options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with the first column being the checked radius and the
remaining columns relating to the K function for each unit at those
points. If a K function could not be computed, perhaps due to lack of
data, an NA is returned for the K function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KFunction &lt;- getKFunction(
  agents = c("B", "Tumor"), unit = "Person",
  data = TNBC_pheno[TNBC_pheno$Person == 1, -1],
  rCheckVals = seq(0, 50, 1),
  edgeCorrection = "isotropic"
)
</code></pre>

<hr>
<h2 id='getKsPCAData'>Get K Functions and Compute Principal Components</h2><span id='topic+getKsPCAData'></span>

<h3>Description</h3>

<p>This function computes K functions from point process data then converts it
into PCs. Note, if there are replicates, i.e. multiple observations per
unit, the K functions will be a weighted average based on the number of
the first agents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getKsPCAData(
  data,
  outcome = colnames(data)[1],
  unit = colnames(data)[5],
  replicate = NULL,
  rCheckVals = NULL,
  nPCs = 3,
  agents_df = as.data.frame(expand.grid(unique(data[, 4]), unique(data[, 4]))),
  xRange = NULL,
  yRange = NULL,
  edgeCorrection = "isotropic",
  nbasis = 21,
  silent = FALSE,
  displayTVE = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getKsPCAData_+3A_data">data</code></td>
<td>
<p>Data.frame with column titles for at least outcome, x, y, agents,
and unit. For consistency (and avoiding errors), use that order.
Additionally, replicate can be added.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_outcome">outcome</code></td>
<td>
<p>(Optional) String of the column name in data indicating the
outcome or response. Default is the 1st column.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_unit">unit</code></td>
<td>
<p>(Optional) String of the column name in data indicating a unit or
base thing. Note this unit may have replicates. Default is the 4th
column.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_replicate">replicate</code></td>
<td>
<p>(Optional) String of the column name in data indicating the
replicate id. Default is NULL.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_rcheckvals">rCheckVals</code></td>
<td>
<p>(Optional) Numeric vector indicating the radius to check.
Note, if not specified, this could take a lot of memory, particularly
with many units and replicates.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_npcs">nPCs</code></td>
<td>
<p>(Optional) Numeric indicating the number of principal components.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_agents_df">agents_df</code></td>
<td>
<p>(Optional) Two-column data.frame. The first for agent 1
and the second for agent 2. Both should be in data agents column. This
determines which K functions to compute. Default is to compute all, but
may be misspecified if the data is in a different order.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_xrange">xRange</code>, <code id="getKsPCAData_+3A_yrange">yRange</code></td>
<td>
<p>(Optional) Two value numeric vector indicating the min
and max x/y values. Note this is re-used for all replicates. The default
just takes the min and max x from each replicate. This allows different
sized images, but the edges are defined by some agent location.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_edgecorrection">edgeCorrection</code></td>
<td>
<p>(Optional) String indicating type of edgeCorrection(s)
to apply when computing the K functions. Options include: &quot;border&quot;,
&quot;bord.modif&quot;, &quot;isotropic&quot;, &quot;Ripley&quot;, &quot;translate&quot;, &quot;translation&quot;, &quot;periodic&quot;,
&quot;none&quot;, &quot;best&quot; or &quot;all&quot; selects all options.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_nbasis">nbasis</code></td>
<td>
<p>(Optional) Numeric indicating number of basis functions to fit
K functions in order to compute PCA. Current implementation uses a
b-spline basis.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_silent">silent</code></td>
<td>
<p>(Optional) Boolean indicating if progress should be printed.</p>
</td></tr>
<tr><td><code id="getKsPCAData_+3A_displaytve">displayTVE</code></td>
<td>
<p>(Optional) Boolean to  indicate if total variance explained
(TVE) should be displayed. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame with the outcome, unit and principle components of
computed K functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataPCA_pheno &lt;- getKsPCAData(
  data = TNBC_pheno, unit = "Person",
  agents_df = data.frame(rep("B", 2), c("Tumor", "Fake")),
  nPCs = 3,
  rCheckVals = seq(0, 50, 1),
  displayTVE = TRUE
)
</code></pre>

<hr>
<h2 id='plot_K_functions'>Compare K Functions Between outcomes</h2><span id='topic+plot_K_functions'></span>

<h3>Description</h3>

<p>This function plots K functions from different outcomes for comparison.
Group means are included as bold lines. Additionally a reference line for
a spatially random process can be included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_K_functions(data, inc.legend = TRUE, inc.noise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_K_functions_+3A_data">data</code></td>
<td>
<p>Data.frame with named columns r, K, unit, and outcome. The column
r indicates the radius of checked K function, K indicates the K function
value, unit specifies the unique K function, and outcome indicates the unit
outcome.</p>
</td></tr>
<tr><td><code id="plot_K_functions_+3A_inc.legend">inc.legend</code></td>
<td>
<p>(Optional) Boolean indicating if the legend should be given.
This will also include numbers to indicate if any K functions are missing.
The default is TRUE.</p>
</td></tr>
<tr><td><code id="plot_K_functions_+3A_inc.noise">inc.noise</code></td>
<td>
<p>(Optional) Boolean indicating if a gray, dashed line should
be included to show what spatially random noise would be like. The default
is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object showing the K function with a superimposed average.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
tmp &lt;- getKFunction(TNBC_pheno[TNBC_pheno$Class == 0, -1],
  agents = c("Tumor", "Tumor"),
  unit = "Person",
  rCheckVals = seq(0, 50, 1)
)
tmp1 &lt;- getKFunction(TNBC_pheno[TNBC_pheno$Class == 1, -1],
  agents = c("Tumor", "Tumor"),
  unit = "Person",
  rCheckVals = seq(0, 50, 1)
)
tmp_1 &lt;- tidyr::pivot_longer(data = tmp, cols = K1:K18)
tmp1_1 &lt;- tidyr::pivot_longer(data = tmp1, cols = K1:K15)

data_plot &lt;- rbind(
  data.frame(
    "r" = tmp_1$r,
    "K" = tmp_1$value,
    "unit" = tmp_1$name,
    "outcome" = "0"
  ),
  data.frame(
    "r" = tmp1_1$r,
    "K" = tmp1_1$value,
    "unit" = paste0(tmp1_1$name, "_1"),
    "outcome" = "1"
  )
)

pk1 &lt;- plot_K_functions(data_plot)

# Example 2
tmp &lt;- getKFunction(TNBC_pheno[TNBC_pheno$Class == 0, -1],
  agents = c("Tumor", "B"), unit = "Person",
  rCheckVals = seq(0, 50, 1)
)
tmp1 &lt;- getKFunction(TNBC_pheno[TNBC_pheno$Class == 1, -1],
  agents = c("Tumor", "B"), unit = "Person",
  rCheckVals = seq(0, 50, 1)
)

tmp_1 &lt;- tidyr::pivot_longer(data = tmp, cols = K1:K18)
tmp1_1 &lt;- tidyr::pivot_longer(data = tmp1, cols = K1:K15)

data_plot &lt;- rbind(
  data.frame(
    "r" = tmp_1$r,
    "K" = tmp_1$value,
    "unit" = tmp_1$name,
    "outcome" = "0"
  ),
  data.frame(
    "r" = tmp1_1$r,
    "K" = tmp1_1$value,
    "unit" = paste0(tmp1_1$name, "_1"),
    "outcome" = "1"
  )
)

pk2 &lt;- plot_K_functions(data_plot)
</code></pre>

<hr>
<h2 id='plotPP'>Plot Spatial Point Process</h2><span id='topic+plotPP'></span>

<h3>Description</h3>

<p>This function is used to plot a spatial point process. This does not split
data and instead puts all given data on a single plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPP(
  data,
  colorGuide = NULL,
  ptSize = 1,
  xlim = c(min(data[, 1]), max(data[, 1])),
  ylim = c(min(data[, 2]), max(data[, 2])),
  dropAxes = FALSE,
  layerBasedOnFrequency = TRUE,
  colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPP_+3A_data">data</code></td>
<td>
<p>Data.frame with x, y, and agent type (in that order)</p>
</td></tr>
<tr><td><code id="plotPP_+3A_colorguide">colorGuide</code></td>
<td>
<p>(Optional) String for 'guides(color=)' in ggplot2. Usually
NULL or 'none' is sufficient, but ggplot2::guide_legend() can also be
used for more custom results. Default is NULL.</p>
</td></tr>
<tr><td><code id="plotPP_+3A_ptsize">ptSize</code></td>
<td>
<p>(Optional) Numeric indicating point size. Default is 1.</p>
</td></tr>
<tr><td><code id="plotPP_+3A_xlim">xlim</code></td>
<td>
<p>(Optional) Two value numeric vector indicating the size of the
region in the x-direction. Default is c(min(x), max(x)).</p>
</td></tr>
<tr><td><code id="plotPP_+3A_ylim">ylim</code></td>
<td>
<p>(Optional) Two value numeric vector indicating the size of the
region in the y-direction. Default is c(min(y), max(y)).</p>
</td></tr>
<tr><td><code id="plotPP_+3A_dropaxes">dropAxes</code></td>
<td>
<p>(Optional) Boolean indicating if the x and y axis title and
labels should be dropped. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotPP_+3A_layerbasedonfrequency">layerBasedOnFrequency</code></td>
<td>
<p>(Optional) Boolean indicating if the data should be
layer based on the number of agents of the type. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plotPP_+3A_colors">colors</code></td>
<td>
<p>(Optional) Vector of colors for the points. Default is NULL, or
ggplot2 selected colors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 plot of the spatial point process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ppplot &lt;- plotPP(
  TNBC_pheno[
    TNBC_pheno$Person == 1,
    c("cellx", "celly", "Phenotype")
  ],
  colorGuide = "none"
)
</code></pre>

<hr>
<h2 id='predict_funkyForest'>Predict a funkyForest</h2><span id='topic+predict_funkyForest'></span>

<h3>Description</h3>

<p>This function gets the predicted value from a funkyForest model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_funkyForest(model, data_pred, type = "all", data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_funkyForest_+3A_model">model</code></td>
<td>
<p>funkyForest model. See funkyForest. A list of
CART models from rpart. Additionally this is given in funkyModel.</p>
</td></tr>
<tr><td><code id="predict_funkyForest_+3A_data_pred">data_pred</code></td>
<td>
<p>data.frame of the data to be predicted.</p>
</td></tr>
<tr><td><code id="predict_funkyForest_+3A_type">type</code></td>
<td>
<p>(Optional) String indicating type of analysis. Options are pred
or all. The choice changes the return to best fit intended use.</p>
</td></tr>
<tr><td><code id="predict_funkyForest_+3A_data">data</code></td>
<td>
<p>(Optional) Data.frame of full data. The data used to fit the
model will be extracted (by row name).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned data depends on type:
</p>

<ul>
<li><p> type='pred': returns a vector of the predictions
</p>
</li>
<li><p> type='all': returns a vector of the predictions
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data_pp &lt;- simulatePP(
  agentVarData =
    data.frame(
      "outcome" = c(0, 1),
      "A" = c(0, 0),
      "B" = c(1 / 50, 1 / 50)
    ),
  agentKappaData = data.frame(
    "agent" = c("A", "B"),
    "clusterAgent" = c(NA, "A"),
    "kappa" = c(10, 5)
  ),
  unitsPerOutcome = 5,
  replicatesPerUnit = 1,
  silent = FALSE
)
pcaData &lt;- getKsPCAData(data_pp,
  replicate = "replicate",
  xRange = c(0, 1), yRange = c(0, 1), silent = FALSE
)
RF &lt;- funkyForest(data = pcaData[-2], nTrees = 5) #
pred &lt;- predict_funkyForest(
  model = RF$model, type = "all",
  data_pred = pcaData[-2],
  data = pcaData[-2]
)
</code></pre>

<hr>
<h2 id='simulateMeta'>Simulate Meta Variables</h2><span id='topic+simulateMeta'></span>

<h3>Description</h3>

<p>This function simulates meta-variables with varying distributions to append
to some data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateMeta(
  data,
  outcome = colnames(data)[1],
  metaInfo = data.frame(var = c("randUnif", "randBin", "rNorm", "corrUnif", "corrBin",
    "corrNorm"), rdist = c("runif", "rbinom", "rnorm", "runif", "rbinom", "rnorm"),
    outcome_0 = c("0.5", "0.5", "1", "0.5", "0.6", "1"), outcome_1 = c("0.5", "0.5", "1",
    "0.75", "0.65", "1.5"), outcome_2 = c("0.5", "0.5", "1", "0.95", "0.75", "1.5"))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateMeta_+3A_data">data</code></td>
<td>
<p>Data.frame with the outcome and unit. Typically this also
includes PCA data as it is run after computing the principle components (see
examples).</p>
</td></tr>
<tr><td><code id="simulateMeta_+3A_outcome">outcome</code></td>
<td>
<p>(Optional) String for column title of the data's outcome.
Default is the first column.</p>
</td></tr>
<tr><td><code id="simulateMeta_+3A_metainfo">metaInfo</code></td>
<td>
<p>(Optional) Data.frame indicating the meta-variables (and
properties) to generate. Default has some examples of possible options.
</p>
<p>The data.frame has a var column, rdist column, and columns for each outcome.
The var column names the meta-variables, rdist indicates the distribution
(options are runif, rbinom, and rnorm), and the outcome columns indicate
mean of the variable for that outcome.
</p>
<p>In order to allow designation of the expected values, the following rules are
imposed on each distribution:
</p>

<ul>
<li><p> runif: a=0, so b is modified,
</p>
</li>
<li><p> rbinom: n=1, so this defines the probability
</p>
</li>
<li><p> runif: variance is set to 1
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Notes: runif may induce useless information so don't recommend correlating it
</p>


<h3>Value</h3>

<p>Data.frame of the original data with meta-variables appended (as
columns) at the end.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simulatePP(
  agentVarData = data.frame(
    "outcome" = c(0, 1, 2),
    "A" = c(0, 0, 0),
    "B" = c(1 / 100, 1 / 500, 1 / 1000)
  ),
  agentKappaData = data.frame(
    "agent" = c("A", "B"),
    "clusterAgent" = c(NA, "A"),
    "kappa" = c(10, 3)
  ),
  unitsPerOutcome = 5,
  replicatesPerUnit = 1
)
pcaData &lt;- getKsPCAData(
  data = data, replicate = "replicate",
  xRange = c(0, 1), yRange = c(0, 1)
)
pcaMeta &lt;- simulateMeta(pcaData)

## Another simple example
data &lt;- simulateMeta(
  data.frame("outcome" = c(0, 0, 0, 1, 1, 1), "unit" = 1:6)
)
</code></pre>

<hr>
<h2 id='simulatePP'>Simulate a Point Process</h2><span id='topic+simulatePP'></span>

<h3>Description</h3>

<p>This function simulates a point pattern with optional clustering (visible
and invisible). Multiple outcomes, units, and replicates are
possible, e.g. a 3 stage disease (outcomes) over 20 people (units) with
3 images each (replicates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatePP(
  agentVarData = data.frame(outcome = c(0, 1, 2), A = c(0, 0, 0), B = c(1/100, 1/500,
    1/500), C = c(1/500, 1/250, 1/100), D = c(1/100, 1/100, 1/100), E = c(1/500, 1/500,
    1/500), F = c(1/250, 1/250, 1/250)),
  agentKappaData = data.frame(agent = c("A", "B", "C", "D", "E", "F"), clusterAgent =
    c(NA, "A", "B", "C", NA, "A"), kappa = c(20, 5, 4, 2, 15, 5)),
  unitsPerOutcome = 20,
  replicatesPerUnit = 5,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulatePP_+3A_agentvardata">agentVarData</code></td>
<td>
<p>(Optional) Data.frame describing variances with each
agent type.
</p>
<p>The data.frame has a outcome column and a named column for each agent type.
Currently, these names are mandatory.</p>
</td></tr>
<tr><td><code id="simulatePP_+3A_agentkappadata">agentKappaData</code></td>
<td>
<p>(Optional) Data.frame describing agent interactions.
</p>
<p>The data.frame has a agent column giving agent names (matching agentVarData),
a clusterAgent column indicating which agent the agent clusters (put NA
if the agent doesn't cluster or clusters a hidden agent / self-clusters),
and a kappa column directing the number of agents of per replicate.</p>
</td></tr>
<tr><td><code id="simulatePP_+3A_unitsperoutcome">unitsPerOutcome</code></td>
<td>
<p>(Optional) Numeric indicating the number of units per
outcome.</p>
</td></tr>
<tr><td><code id="simulatePP_+3A_replicatesperunit">replicatesPerUnit</code></td>
<td>
<p>(Optional) Numeric indicating the number of
replicates, or repeated measures, per unit.</p>
</td></tr>
<tr><td><code id="simulatePP_+3A_silent">silent</code></td>
<td>
<p>(Optional) Boolean indicating if progress output should be
printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame containing each point the defined patterns.
</p>
<p>The data.frame has columns for outcome, x coordinate, y coordinate, agent
type, unit, and replicate id.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simulatePP(
  agentVarData = data.frame(
    "outcome" = c(0, 1),
    "A" = c(0, 0),
    "B" = c(1 / 100, 1 / 500),
    "C" = c(1 / 500, 1 / 250),
    "D" = c(1 / 100, 1 / 100),
    "E" = c(1 / 500, 1 / 500)
  ),
  agentKappaData = data.frame(
    "agent" = c("A", "B", "C", "D", "E"),
    "clusterAgent" = c(NA, "A", "B", "C", NA),
    "kappa" = c(10, 3, 2, 1, 8)
  ),
  unitsPerOutcome = 4,
  replicatesPerUnit = 1
)
</code></pre>

<hr>
<h2 id='TNBC'>Triple Negative Breast Cancer Data</h2><span id='topic+TNBC'></span>

<h3>Description</h3>

<p>A funky model ready set of principle components from K functions based on
triple negative breast cancer data from patients. The original data was
proteins as coded in T/F values. Additionally, the age meta-variable was
added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TNBC
</code></pre>


<h3>Format</h3>



<h4><code>TNBC</code></h4>

<p>A data frame with 33 rows and 1398 columns:
</p>

<dl>
<dt>Class</dt><dd><p>Outcome of each patient</p>
</dd>
<dt>Person</dt><dd><p>Person for each image</p>
</dd>
<dt>NA_Si_PC1 through tumerYN_tumerYN_PC3</dt><dd><p>Principle components of the K
functions for the named interactions</p>
</dd>
<dt>age</dt><dd><p>Meta-variable for patient age</p>
</dd>
</dl>
<p>...

</p>



<h3>Source</h3>

<p><a href="https://www.angelolab.com/mibi-data">https://www.angelolab.com/mibi-data</a>
</p>

<hr>
<h2 id='TNBC_meta'>Triple Negative Breast Cancer Phenotypes</h2><span id='topic+TNBC_meta'></span>

<h3>Description</h3>

<p>Data of meta-variable age related to triple negative breast cancer biopsies
from patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TNBC_meta
</code></pre>


<h3>Format</h3>



<h4><code>TNBC_meta</code></h4>

<p>A data frame with 33 rows and 2 columns:
</p>

<dl>
<dt>Person</dt><dd><p>Person for each image</p>
</dd>
<dt>Age</dt><dd><p>Meta-variable for patient age</p>
</dd>
</dl>
<p>...

</p>



<h3>Source</h3>

<p><a href="https://www.angelolab.com/mibi-data">https://www.angelolab.com/mibi-data</a>
</p>

<hr>
<h2 id='TNBC_pheno'>Triple Negative Breast Cancer Phenotypes</h2><span id='topic+TNBC_pheno'></span>

<h3>Description</h3>

<p>Data of triple negative breast cancer biopsies from patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TNBC_pheno
</code></pre>


<h3>Format</h3>



<h4><code>TNBC_pheno</code></h4>

<p>A data frame with 170,171 rows and 5 columns:
</p>

<dl>
<dt>Class</dt><dd><p>Outcome of each patient</p>
</dd>
<dt>Person</dt><dd><p>Person for which each cell is related</p>
</dd>
<dt>cellx, celly</dt><dd><p>The x-y coordinates of the cell</p>
</dd>
<dt>Phenotype</dt><dd><p>The classified phenotype for the cecll</p>
</dd>
</dl>
<p>...

</p>



<h3>Source</h3>

<p><a href="https://www.angelolab.com/mibi-data">https://www.angelolab.com/mibi-data</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
