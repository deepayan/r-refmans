<!DOCTYPE html><html><head><title>Help for package gnm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gnm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.gnm'><p> Analysis of Deviance for Generalized Nonlinear Models</p></a></li>
<li><a href='#asGnm'><p> Coerce Linear Model to gnm Object</p></a></li>
<li><a href='#backPain'><p> Data on Back Pain Prognosis, from Anderson (1984)</p></a></li>
<li><a href='#barley'><p> Jenkyn's Data on Leaf-blotch on Barley</p></a></li>
<li><a href='#barleyHeights'><p> Heights of Barley Plants</p></a></li>
<li><a href='#cautres'><p> Data on Class, Religion and Vote in France</p></a></li>
<li><a href='#checkEstimable'><p> Check Whether One or More Parameter Combinations in a gnm Model</p>
are Identified</a></li>
<li><a href='#confint.gnm'><p> Compute Confidence Intervals of Parameters in a Generalized Nonlinear Model</p></a></li>
<li><a href='#Const'><p> Specify a Constant in a &quot;nonlin&quot; Function Predictor</p></a></li>
<li><a href='#Diag'><p>Equality of Two or More Factors</p></a></li>
<li><a href='#Dref'><p>Specify a Diagonal Reference Term in a gnm Model Formula</p></a></li>
<li><a href='#erikson'><p>Intergenerational Class Mobility in England/Wales, France and Sweden</p></a></li>
<li><a href='#exitInfo'><p> Print Exit Information for gnm Fit</p></a></li>
<li><a href='#Exp'><p> Specify the Exponential of a Predictor in a gnm Model Formula</p></a></li>
<li><a href='#expandCategorical'><p> Expand Data Frame by Re-expressing Categorical Data as Counts</p></a></li>
<li><a href='#friend'><p> Occupation of Respondents and Their Closest Friend</p></a></li>
<li><a href='#getContrasts'><p> Estimated Contrasts and Standard Errors for Parameters in a gnm</p>
Model</a></li>
<li><a href='#gnm'><p> Fitting Generalized Nonlinear Models</p></a></li>
<li><a href='#gnm-defunct'><p>Defunct Functions in gnm Package</p></a></li>
<li><a href='#gnm-package'>
<p>Generalized Nonlinear Models</p></a></li>
<li><a href='#House2001'><p> Data on twenty roll calls in the US House of Representatives, 2001</p></a></li>
<li><a href='#instances'><p> Specify Multiple Instances of a Nonlinear Term in a gnm Model</p>
Formula</a></li>
<li><a href='#Inv'><p> Specify the Reciprocal of a Predictor in a gnm Model Formula</p></a></li>
<li><a href='#meanResiduals'><p>Average Residuals within Factor Levels</p></a></li>
<li><a href='#mentalHealth'><p> Data on Mental Health and Socioeconomic Status</p></a></li>
<li><a href='#model.matrix.gnm'><p> Local Design Matrix for a Generalized Nonlinear Model</p></a></li>
<li><a href='#MPinv'><p> Moore-Penrose Pseudoinverse of a Real-valued Matrix</p></a></li>
<li><a href='#MultHomog'><p>Specify a Multiplicative Interaction with Homogeneous Effects in</p>
a gnm Model Formula</a></li>
<li><a href='#Multiplicative interaction'><p>Specify a Product of Predictors in a gnm Model Formula</p></a></li>
<li><a href='#nonlin.function'><p> Functions to Specify Nonlinear Terms in gnm Models</p></a></li>
<li><a href='#ofInterest'><p> Coefficients of Interest in a Generalized Nonlinear Model</p></a></li>
<li><a href='#parameters'><p> Extract Constrained and Estimated Parameters from a gnm Object</p></a></li>
<li><a href='#pickCoef'><p> Get Indices or Values of Selected Model Coefficients</p></a></li>
<li><a href='#plot.gnm'><p> Plot Diagnostics for a gnm Object</p></a></li>
<li><a href='#predict.gnm'><p> Predict Method for Generalized Nonlinear Models</p></a></li>
<li><a href='#profile.gnm'><p> Profile Deviance for Parameters in a Generalized Nonlinear Model</p></a></li>
<li><a href='#residSVD'><p> Multiplicative Approximation of Model Residuals</p></a></li>
<li><a href='#se'><p>Extract Standard Errors</p></a></li>
<li><a href='#se.gnm'><p> Standard Errors of Linear Parameter Combinations in gnm Models</p></a></li>
<li><a href='#summary.gnm'><p> Summarize Generalized Nonlinear Model Fits</p></a></li>
<li><a href='#Symm'><p> Symmetric Interaction of Factors</p></a></li>
<li><a href='#termPredictors'><p> Extract Term Contributions to Predictor</p></a></li>
<li><a href='#Topo'><p> Topological Interaction of Factors</p></a></li>
<li><a href='#vcov.gnm'><p> Variance-covariance Matrix for</p>
Parameters in a Generalized Nonlinear Model</a></li>
<li><a href='#voting'><p>Data on Social Mobility and the Labour Vote</p></a></li>
<li><a href='#wedderburn'><p> Wedderburn Quasi-likelihood Family</p></a></li>
<li><a href='#wheat'><p> Wheat Yields from  Mexican Field Trials</p></a></li>
<li><a href='#yaish'><p> Class Mobility by Level of Education in Israel</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalized Nonlinear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-5</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to specify and fit generalized nonlinear models,
    including models with multiplicative interaction terms such as the
    UNIDIFF model from sociology and the AMMI model from crop science, and
    many others.  Over-parameterized representations of models are used
    throughout; functions are provided for inference on estimable
    parameter combinations, as well as standard methods for diagnostics
    etc.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hturner/gnm">https://github.com/hturner/gnm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hturner/gnm/issues">https://github.com/hturner/gnm/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, MASS, Matrix, methods, nnet, qvcalc (&ge;
0.8-3), relimp, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>logmult, testthat (&ge; 3.0.0), vcdExtra</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-16 11:07:03 UTC; stspao</td>
</tr>
<tr>
<td>Author:</td>
<td>Heather Turner <a href="https://orcid.org/0000-0002-1256-3375"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  David Firth <a href="https://orcid.org/0000-0003-0302-2312"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Brian Ripley [ctb],
  Bill Venables [ctb],
  Douglas M. Bates [ctb],
  Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Heather Turner &lt;ht@heatherturner.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-16 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.gnm'> Analysis of Deviance for Generalized Nonlinear Models </h2><span id='topic+anova.gnm'></span>

<h3>Description</h3>

<p>Compute an analysis of deviance table for one or more generalized
nonlinear models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
anova(object, ..., dispersion = NULL, test = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.gnm_+3A_object">object</code></td>
<td>
<p> an object of class <code>gnm</code> </p>
</td></tr>
<tr><td><code id="anova.gnm_+3A_...">...</code></td>
<td>
<p> additional objects of class <code>gnm</code> or <code>glm</code></p>
</td></tr>
<tr><td><code id="anova.gnm_+3A_dispersion">dispersion</code></td>
<td>
<p> the dispersion parameter for the fitting family. By
default it is derived from <code>object</code> </p>
</td></tr>
<tr><td><code id="anova.gnm_+3A_test">test</code></td>
<td>
<p> (optional) a character string, (partially) matching one
of <code>"Chisq"</code>, <code>"F"</code>, or <code>"Cp"</code>. See
<code><a href="stats.html#topic+stat.anova">stat.anova</a></code>. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Specifying a single object gives a sequential analysis of deviance
table for that fit. The rows of the table show the reduction
in the residual deviance and the current residual deviance as each
term in the formula is added in turn.
</p>
<p>If more than one object is specified, the rows of the table show the
residual deviance of the current model and the change in the residual
deviance from the previous model. (This only makes statistical
sense if the models are nested.) It is conventional to list the models
from smallest to largest, but this is up to the user.
</p>
<p>If <code>test</code> is specified, the table will include test statistics
and/or p values for the reduction in deviance. For models with known
dispersion (e.g., binomial and Poisson fits) the chi-squared test is
most appropriate, and for those with dispersion estimated by moments
(e.g., 'gaussian', 'quasibinomial' and 'quasipoisson' fits) the F test
is most appropriate.  Mallows' Cp statistic is the residual deviance
plus twice the estimate of <code class="reqn">\sigma^2</code> times the residual degrees of
freedom, which is closely related to AIC (and a multiple of it if the
dispersion is known). 
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> inheriting from class <code>"data.frame"</code>.
</p>


<h3>Warning </h3>

<p> The comparison between two or more models will only
be valid if they are fitted to the same dataset. This may be a problem
if there are missing values and R's default of <code>na.action = na.omit</code>
is used; an error will be given in this case. </p>


<h3>Author(s)</h3>

<p> Modification of <code><a href="stats.html#topic+anova.glm">anova.glm</a></code> by the R Core Team. Adapted
for <code>"gnm"</code> objects by Heather Turner. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+anova">anova</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

##  Fit a uniform association model separating diagonal effects
Rscore &lt;- scale(as.numeric(row(occupationalStatus)), scale = FALSE)
Cscore &lt;- scale(as.numeric(col(occupationalStatus)), scale = FALSE)
Uniform &lt;- glm(Freq ~ origin + destination + Diag(origin, destination) + 
               Rscore:Cscore, family = poisson, data = occupationalStatus)

##  Fit an association model with homogeneous row-column effects
RChomog &lt;- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               MultHomog(origin, destination), family = poisson,
               data = occupationalStatus)

##  Fit an association model with separate row and column effects
RC &lt;- gnm(Freq ~ origin + destination + Diag(origin, destination) +
          Mult(origin, destination), family = poisson,
          data = occupationalStatus)

anova(RC, test = "Chisq")

anova(Uniform, RChomog, RC, test = "Chisq")
</code></pre>

<hr>
<h2 id='asGnm'> Coerce Linear Model to gnm Object </h2><span id='topic+asGnm'></span>

<h3>Description</h3>

<p><code>asGnm</code> is a generic function which coerces objects of class
&quot;glm&quot; or &quot;lm&quot; to an object of class &quot;gnm&quot;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asGnm(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asGnm_+3A_object">object</code></td>
<td>
<p> an object of class &quot;glm&quot; or &quot;lm&quot;. </p>
</td></tr>
<tr><td><code id="asGnm_+3A_...">...</code></td>
<td>
<p> additional arguments for method functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Components are added to or removed from <code>object</code> to produce an
object of class &quot;gnm&quot;. This can be useful in model building,
see examples.
</p>


<h3>Value</h3>

<p>An object of class &quot;gnm&quot; - see <code><a href="#topic+gnm">gnm</a></code> for full description.
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>References</h3>

<p>Vargas, M, Crossa, J, van Eeuwijk, F, Sayre, K D and Reynolds, M P
(2001).  Interpreting treatment by environment interaction in agronomy
trials.  <em>Agronomy Journal</em> <b>93</b>, 949&ndash;960.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+lm">lm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

##  Scale yields to reproduce analyses reported in Vargas et al (2001)
yield.scaled &lt;- wheat$yield * sqrt(3/1000)
treatment &lt;- interaction(wheat$tillage, wheat$summerCrop, wheat$manure,
                         wheat$N, sep = "")
##  Fit linear model
mainEffects &lt;- lm(yield.scaled ~ year + treatment, data = wheat)

##  Convert to gnm object to allow addition of Mult() term
svdStart &lt;- residSVD(mainEffects, year, treatment, 3)
bilinear1 &lt;- update(asGnm(mainEffects), . ~ . + 
                    Mult(year, treatment),
                    start = c(coef(mainEffects), svdStart[,1]))
</code></pre>

<hr>
<h2 id='backPain'> Data on Back Pain Prognosis, from Anderson (1984) </h2><span id='topic+backPain'></span>

<h3>Description</h3>

<p>Data from a study of patients suffering from back pain. Prognostic
variables were recorded at presentation and progress was categorised
three weeks after treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backPain</code></pre>


<h3>Format</h3>

<p>A data frame with 101 observations on the following 4 variables.
</p>

<dl>
<dt>x1</dt><dd><p>length of previous attack.</p>
</dd>
<dt>x2</dt><dd><p>pain change.</p>
</dd>
<dt>x3</dt><dd><p>lordosis.</p>
</dd>
<dt>pain</dt><dd><p>an ordered factor describing the progress of each
patient with levels <code>worse</code> &lt; <code>same</code> &lt;
<code>slight.improvement</code> &lt; <code>moderate.improvement</code> &lt;
<code>marked.improvement</code> &lt; <code>complete.relief</code>. </p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://ideas.repec.org/c/boc/bocode/s419001.html">https://ideas.repec.org/c/boc/bocode/s419001.html</a>
</p>


<h3>References</h3>

<p>Anderson, J. A. (1984) Regression and Ordered Categorical
Variables. <em>J. R. Statist. Soc. B</em>, <b>46(1)</b>, 1-30.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
summary(backPain)

### Re-express as count data
backPainLong &lt;- expandCategorical(backPain, "pain")

### Fit models described in Table 5 of Anderson (1984)

### Logistic family models
noRelationship &lt;- gnm(count ~ pain, eliminate = id,
                      family = "poisson", data = backPainLong)

## stereotype model
oneDimensional &lt;- update(noRelationship,
                         ~ . + Mult(pain, x1 + x2 + x3))

## multinomial logistic
threeDimensional &lt;- update(noRelationship, ~ . + pain:(x1 + x2 + x3))

### Models to determine distinguishability in stereotype model
## constrain scale of category-specific multipliers
oneDimensional &lt;- update(noRelationship,
                         ~ . + Mult(pain, offset(x1) + x2 + x3))
## obtain identifiable contrasts; id possibly indistinguishable slopes
getContrasts(oneDimensional, pickCoef(oneDimensional, "[.]pain"))

## Not run: 
## (this part not needed for package testing)
## fit simpler models and compare 
.pain &lt;- backPainLong$pain

levels(.pain)[2:3] &lt;- paste(levels(.pain)[2:3], collapse = " | ")
fiveGroups &lt;- update(noRelationship,
                     ~ . + Mult(.pain, x1 + x2 + x3))

levels(.pain)[4:5] &lt;- paste(levels(.pain)[4:5], collapse = " | ")
fourGroups &lt;- update(fiveGroups)

levels(.pain)[2:3] &lt;- paste(levels(.pain)[2:3], collapse = " | ")
threeGroups &lt;- update(fourGroups)

### Grouped continuous model, aka proportional odds model
library(MASS)
sixCategories &lt;- polr(pain ~ x1 + x2 + x3, data = backPain)

### Obtain number of parameters and log-likelihoods for equivalent
### multinomial models as presented in Anderson (1984)
logLikMultinom &lt;- function(model, size){
    object &lt;- get(model)
    if (inherits(object, "gnm")) {
        l &lt;- sum(object$y * log(object$fitted/size))
        c(nParameters = object$rank - nlevels(object$eliminate),
          logLikelihood = l)
    }
    else
        c(nParameters = object$edf, logLikelihood = -deviance(object)/2)
}
size &lt;- tapply(backPainLong$count, backPainLong$id, sum)[backPainLong$id]
models &lt;- c("threeDimensional", "oneDimensional", "noRelationship",
            "fiveGroups", "fourGroups", "threeGroups", "sixCategories")
t(sapply(models, logLikMultinom, size))

## End(Not run)
</code></pre>

<hr>
<h2 id='barley'> Jenkyn's Data on Leaf-blotch on Barley </h2><span id='topic+barley'></span>

<h3>Description</h3>

<p>Incidence of <em>R. secalis</em> on the leaves of ten varieties of barley grown
at nine sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barley</code></pre>


<h3>Format</h3>

<p>A data frame with 90 observations on the following 3 variables.
</p>

<dl>
<dt>y</dt><dd><p>the proportion of leaf affected (values in [0,1])</p>
</dd>
<dt>site</dt><dd><p>a factor with 9 levels <code>A</code> to <code>I</code></p>
</dd>
<dt>variety</dt><dd><p>a factor with 10 levels <code>c(1:9, "X")</code></p>
</dd>
</dl>



<h3>Note</h3>

<p>This dataset was used in Wedderburn's original paper (1974) on 
quasi-likelihood.
</p>


<h3>Source</h3>

<p>Originally in an unpublished Aberystwyth PhD thesis by J F Jenkyn.
</p>


<h3>References</h3>

<p>Gabriel, K R (1998).  Generalised bilinear regression.  <em>Biometrika</em> 
<b>85</b>, 689&ndash;700.
</p>
<p>McCullagh, P and Nelder, J A (1989)  <em>Generalized Linear Models</em> (2nd ed).  
Chapman and Hall.
</p>
<p>Wedderburn, R W M (1974).  Quasilikelihood functions, generalized linear models 
and the Gauss-Newton method.  <em>Biometrika</em> <b>61</b>, 439&ndash;47.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

###  Fit Wedderburn's logit model with variance proportional to [mu(1-mu)]^2
logitModel &lt;- glm(y ~ site + variety, family = wedderburn, data = barley)
fit &lt;- fitted(logitModel)
print(sum((barley$y - fit)^2 / (fit * (1-fit))^2))
##  Agrees with the chi-squared value reported in McCullagh and Nelder 
##  (1989, p331), which differs slightly from Wedderburn's reported value.

###  Fit the biplot model as in Gabriel (1998, p694)
biplotModel &lt;- gnm(y ~ -1 + instances(Mult(site, variety), 2),
                   family = wedderburn, data = barley)
barleySVD &lt;- svd(matrix(biplotModel$predictors, 10, 9))
A &lt;- sweep(barleySVD$v, 2, sqrt(barleySVD$d), "*")[, 1:2]
B &lt;- sweep(barleySVD$u, 2, sqrt(barleySVD$d), "*")[, 1:2]
##  These are essentially A and B as in Gabriel (1998, p694), from which
##  the biplot is made by
plot(rbind(A, B), pch = c(levels(barley$site), levels(barley$variety)))

##  Fit the double-additive model as in Gabriel (1998, p697)
variety.binary &lt;- factor(match(barley$variety, c(2,3,6), nomatch = 0) &gt; 0,
                        labels = c("rest", "2,3,6"))
doubleAdditive &lt;- gnm(y ~ variety + Mult(site, variety.binary),
                      family = wedderburn, data = barley)
##  It is unclear why Gabriel's chi-squared statistics differ slightly
##  from the ones produced in these fits.  Possibly Gabriel adjusted the
##  data somehow prior to fitting?
</code></pre>

<hr>
<h2 id='barleyHeights'> Heights of Barley Plants </h2><span id='topic+barleyHeights'></span>

<h3>Description</h3>

<p>Average heights for 15 genotypes of barley recorded over 9 years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barleyHeights</code></pre>


<h3>Format</h3>

<p>A data frame with 135 observations on the following 3 variables.
</p>

<dl>
<dt><code>height</code></dt><dd><p>average height over 4 replicates (cm)</p>
</dd>
<dt><code>year</code></dt><dd><p>a factor with 9 levels <code>1974</code> to <code>1982</code></p>
</dd>
<dt><code>genotype</code></dt><dd><p>a factor with 15 levels <code>1:15</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>Aastveit, A. H. and Martens, H. (1986). ANOVA interactions interpreted
by partial least squares regression. <em>Biometrics</em>, <b>42</b>, 829&ndash;844.
</p>


<h3>References</h3>

<p>Chadoeuf, J and Denis, J B (1991). Asymptotic variances for the
multiplicative interaction model. <em>J. App. Stat.</em> <b>18(3)</b>, 331&ndash;353.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
## Fit AMMI-1 model
barleyModel &lt;- gnm(height ~ year + genotype + Mult(year, genotype),
                   data = barleyHeights)

## Get row and column scores with se's
gamma &lt;- getContrasts(barleyModel, pickCoef(barleyModel, "[.]y"),
                      ref = "mean", scaleWeights = "unit")
delta &lt;- getContrasts(barleyModel, pickCoef(barleyModel, "[.]g"),
                      ref = "mean", scaleWeights = "unit")

## Corresponding CI's similar to Chadoeuf and Denis (1991) Table 8
## (allowing for change in sign)
gamma[[2]][,1] + (gamma[[2]][,2]) %o% c(-1.96, 1.96)
delta[[2]][,1] + (delta[[2]][,2]) %o% c(-1.96, 1.96)

## Multiplier of row and column scores
height &lt;- matrix(scale(barleyHeights$height, scale = FALSE), 15, 9)
R &lt;- height - outer(rowMeans(height), colMeans(height), "+")
svd(R)$d[1]
</code></pre>

<hr>
<h2 id='cautres'> Data on Class, Religion and Vote in France</h2><span id='topic+cautres'></span>

<h3>Description</h3>

<p>A 4-way contingency table of vote by class by religion
in four French elections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cautres</code></pre>


<h3>Format</h3>

<p>A table of counts, with classifying factors <code>vote</code> (levels
<code>1:2</code>), <code>class</code> (levels <code>1:6</code>) and <code>religion</code>
(levels <code>1:4</code>) and <code>election</code> (levels <code>1:4</code>).
</p>


<h3>Source</h3>

<p>Bruno Cautres
</p>


<h3>References</h3>

<p>Cautres, B, Heath, A F and Firth, D (1998).  Class, religion and vote in
Britain and France.  <em>La Lettre de la Maison Francaise</em> <b>8</b>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

##  Fit a "double UNIDIFF" model with the religion-vote and class-vote
##  interactions both modulated by nonnegative election-specific multipliers
doubleUnidiff &lt;- gnm(Freq ~ election*vote + election*class*religion +
                     Mult(Exp(election), religion:vote) +
                     Mult(Exp(election), class:vote),
                     family = poisson, data = cautres)
##  Deviance should be 133.04

##  Examine the multipliers of the class-vote log odds ratios
ofInterest(doubleUnidiff) &lt;- pickCoef(doubleUnidiff, "class:vote[).]")
coef(doubleUnidiff)
## Coefficients of interest:
## Mult(Exp(.), class:vote).election1 
##                        -0.38357138 
## Mult(Exp(.), class:vote).election2 
##                         0.29816599 
## Mult(Exp(.), class:vote).election3 
##                         0.06580307 
## Mult(Exp(.), class:vote).election4 
##                        -0.02174104
##  Re-parameterize by setting Mult2.Factor1.election1 to zero
getContrasts(doubleUnidiff, ofInterest(doubleUnidiff))
##                                     estimate        SE
## Mult(Exp(.), class:vote).election1 0.0000000 0.0000000
## Mult(Exp(.), class:vote).election2 0.6817374 0.2401644
## Mult(Exp(.), class:vote).election3 0.4493745 0.2473521
## Mult(Exp(.), class:vote).election4 0.3618301 0.2534754
##                                       quasiSE    quasiVar
## Mult(Exp(.), class:vote).election1 0.22854401 0.052232363
## Mult(Exp(.), class:vote).election2 0.07395886 0.005469913
## Mult(Exp(.), class:vote).election3 0.09475938 0.008979340
## Mult(Exp(.), class:vote).election4 0.10934798 0.011956981

##  Same thing but with election 4 as reference category:
getContrasts(doubleUnidiff, rev(ofInterest(doubleUnidiff)))
##                                       estimate        SE
## Mult(Exp(.), class:vote).election4  0.00000000 0.0000000
## Mult(Exp(.), class:vote).election3  0.08754436 0.1446833
## Mult(Exp(.), class:vote).election2  0.31990727 0.1320022
## Mult(Exp(.), class:vote).election1 -0.36183013 0.2534754
##                                       quasiSE    quasiVar
## Mult(Exp(.), class:vote).election4 0.10934798 0.011956981
## Mult(Exp(.), class:vote).election3 0.09475938 0.008979340
## Mult(Exp(.), class:vote).election2 0.07395886 0.005469913
## Mult(Exp(.), class:vote).election1 0.22854401 0.052232363
</code></pre>

<hr>
<h2 id='checkEstimable'> Check Whether One or More Parameter Combinations in a gnm Model
are Identified </h2><span id='topic+checkEstimable'></span>

<h3>Description</h3>

<p>For each of a specified set of linear combinations of parameters from a
<code><a href="#topic+gnm">gnm</a></code> model, checks numerically whether the combination's
estimate is invariant to re-parameterization of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkEstimable(model, combMatrix = diag(length(coef(model))),
               tolerance = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkEstimable_+3A_model">model</code></td>
<td>
<p>  a model object of class <code>"gnm"</code> </p>
</td></tr>
<tr><td><code id="checkEstimable_+3A_combmatrix">combMatrix</code></td>
<td>
<p>  numeric: either a vector of length the same as
<code>length(coef(model))</code>, or a matrix with that number of rows.
Coefficients of one or more linear combinations of the model's parameters.</p>
</td></tr>
<tr><td><code id="checkEstimable_+3A_tolerance">tolerance</code></td>
<td>
<p> numeric: a threshold value for detection of
non-estimability.  If <code>NULL</code>, the default value of the
<code>tol</code> argument to <code><a href="Matrix.html#topic+rankMatrix">rankMatrix</a></code> is used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of length equal to the number of parameter combinations
tested; <code>NA</code> where a parameter combination is identically zero.</p>


<h3>Author(s)</h3>

<p> David Firth and Heather Turner </p>


<h3>References</h3>

<p>Catchpole, E.A. and Morgan, B.J.T. (1997).  Detecting parameter
redundancy. <em>Biometrika</em>, <b>84</b>, 187&ndash;196.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm">gnm</a></code>, 
<code><a href="#topic+se.gnm">se.gnm</a></code>,
<code><a href="#topic+getContrasts">getContrasts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

## Fit the "UNIDIFF" mobility model across education levels
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest), family = poisson,
               data = yaish, subset = (dest != 7))

## Check whether multiplier contrast educ4 - educ5 is estimable
ofInterest(unidiff) &lt;- pickCoef(unidiff, "[.]educ")
mycontrast &lt;- numeric(length(coef(unidiff)))
mycontrast[ofInterest(unidiff)[4:5]] &lt;- c(1, -1)
checkEstimable(unidiff, mycontrast)
## should be TRUE

## Check whether multiplier educ4 itself is estimable
mycontrast[ofInterest(unidiff)[5]] &lt;- 0
checkEstimable(unidiff, mycontrast)
## should be FALSE -- only *differences* are identified here
</code></pre>

<hr>
<h2 id='confint.gnm'> Compute Confidence Intervals of Parameters in a Generalized Nonlinear Model </h2><span id='topic+confint.gnm'></span><span id='topic+confint.profile.gnm'></span>

<h3>Description</h3>

<p>Computes confidence intervals for one or more parameters in a
generalized nonlinear model, based on the profiled deviance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
confint(object, parm = ofInterest(object), level = 0.95,
    trace = FALSE, ...)

## S3 method for class 'profile.gnm'
confint(object, parm = names(object), level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.gnm_+3A_object">object</code></td>
<td>
<p> an object of class <code>"gnm"</code> or <code>"profile.gnm"</code></p>
</td></tr>
<tr><td><code id="confint.gnm_+3A_parm">parm</code></td>
<td>
<p> (optional) either a numeric vector of indices or a
character vector of names, specifying the parameters for which
confidence intervals are to be estimated. If <code>parm</code> is <code>NULL</code>,
confidence intervals are found for all parameters.</p>
</td></tr> 
<tr><td><code id="confint.gnm_+3A_level">level</code></td>
<td>
<p> the confidence level required. </p>
</td></tr>
<tr><td><code id="confint.gnm_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether profiling should be
traced. </p>
</td></tr>
<tr><td><code id="confint.gnm_+3A_...">...</code></td>
<td>
<p> arguments passed to or from other methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are methods for the generic function <code>confint</code> in the
<code>base</code> package.
</p>
<p>For <code>"gnm"</code> objects, <code>profile.gnm</code> is first called to
profile the deviance over each parameter specified by <code>parm</code>, or
over all parameters in the model if <code>parm</code> is <code>NULL</code>.
</p>
<p>The method for <code>"profile.gnm"</code> objects is then called, which
interpolates the deviance profiles to estimate the limits of the
confidence interval for each parameter, see <code><a href="#topic+profile.gnm">profile.gnm</a></code>
for more details.
</p>
<p>If a <code>"profile.gnm"</code> object is passed directly to <code>confint</code>,
parameters specified by <code>parm</code> must be a subset of the profiled
parameters.
</p>
<p>For unidentified parameters a confidence interval cannot be calculated
and the limits will be returned as <code>NA</code>. If the deviance curve
has an asymptote and a limit of the confidence interval cannot be
reached, the limit will be returned as <code>-Inf</code> or <code>Inf</code> 
appropriately. If the range of the profile does not extend far enough
to estimate a limit of the confidence interval, the limit will be
returned as <code>NA</code>. In such cases, it may be desirable create a
profile object directly, see <code><a href="#topic+profile.gnm">profile.gnm</a></code> for more
details.
</p>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper
confidence limits for each parameter. These will be labelled as
(1-level)/2 and 1 - (1-level)/2 in % (by default 2.5% and 97.5%).
</p>


<h3>Author(s)</h3>

<p> Modification of <code>MASS:::confint.glm</code> by W. N. Venables and
B. D. Ripley. Adapted for <code>"gnm"</code> objects by Heather Turner. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+profile.gnm">profile.gnm</a></code>, <code><a href="#topic+gnm">gnm</a></code>,
<code><a href="MASS.html#topic+confint.glm">confint.glm</a></code>, <code><a href="MASS.html#topic+profile.glm">profile.glm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example in which profiling doesn't take too long
count &lt;- with(voting, percentage/100 * total)
yvar &lt;- cbind(count, voting$total - count)
classMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination),
                     constrain = "delta1", family = binomial,
                     data = voting)
## profile diagonal effects
confint(classMobility, parm = 3:7, trace = TRUE)

## Not run: 
### Profiling takes much longer here, but example more interesting!
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest), 
               ofInterest = "[.]educ", constrain = "[.]educ1",
               family = poisson, data = yaish, subset = (dest != 7))

## Letting 'confint' compute profile
confint(unidiff, trace = TRUE)
##                                                   2.5 %     97.5 %
## Mult(Exp(.), orig:dest).educ1         NA         NA
## Mult(Exp(.), orig:dest).educ2 -0.5978901  0.1022447
## Mult(Exp(.), orig:dest).educ3 -1.4836854 -0.2362378
## Mult(Exp(.), orig:dest).educ4 -2.5792398 -0.2953420
## Mult(Exp(.), orig:dest).educ5       -Inf -0.7007616

## Creating profile object first with user-specified stepsize
prof &lt;- profile(unidiff, trace = TRUE, stepsize = 0.1)
confint(prof, ofInterest(unidiff)[2:5])
##                                    2.5 %     97.5 %
## Mult(Exp(.), orig:dest).educ2 -0.5978324  0.1022441
## Mult(Exp(.), orig:dest).educ3 -1.4834753 -0.2362138
## Mult(Exp(.), orig:dest).educ4         NA -0.2950790
## Mult(Exp(.), orig:dest).educ5         NA         NA

## For 95% confidence interval, need to estimate parameters for which
## z = +/- 1.96. Profile has not gone far enough for last two parameters
range(prof[[4]]$z)
## -1.566601  2.408650
range(prof[[5]]$z)
## -0.5751376  1.1989487

## End(Not run)
</code></pre>

<hr>
<h2 id='Const'> Specify a Constant in a &quot;nonlin&quot; Function Predictor </h2><span id='topic+Const'></span>

<h3>Description</h3>

<p>A symbolic wrapper to specify a constant in the predictor of a
<code>"nonlin"</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Const(const)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Const_+3A_const">const</code></td>
<td>
<p> a numeric value. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A call to <code>rep</code> used to create a variable representing the
constant in the model frame.
</p>


<h3>Note</h3>

<p><code>Const</code> may only be used in the predictor of a <code>"nonlin"</code>
function. Use <code>offset</code> to specify a constant in the model formula.
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+offset">offset</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## One way to fit the logistic function without conditional
## linearity as in ?nls
library(gnm)
set.seed(1)
DNase1 &lt;- subset(DNase, Run == 1)

test &lt;- gnm(density ~ -1 +
            Mult(1, Inv(Const(1) + Exp(Mult(1 + offset(-log(conc)),
                                                Inv(1))))),
            start = c(NA, 0, 1), data = DNase1, trace = TRUE)
coef(test)
</code></pre>

<hr>
<h2 id='Diag'>Equality of Two or More Factors</h2><span id='topic+Diag'></span>

<h3>Description</h3>

<p>Converts two or more factors into a new factor whose value is 0 where
the original factors are not all equal, and nonzero otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diag(..., binary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diag_+3A_...">...</code></td>
<td>
<p> One or more factors</p>
</td></tr>
<tr><td><code id="Diag_+3A_binary">binary</code></td>
<td>
<p> Logical </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used mainly in regression models for data classified by 
two or more factors with the same levels.  By default, 
operates on k-level factors to produce a new factor having k+1 levels;
if <code>binary = TRUE</code> is specified, the result is a coarser binary 
variable equal to 1 where all of the input factors are equal and 0 
otherwise.
</p>
<p>If the original levels are identical the levels of the factor created 
in the <code>binary = FALSE</code> case will be in the same order, with 
<code>"."</code> added as the first level. Otherwise the levels of the new 
factor will be <code>"."</code> followed by the sorted combined levels.
</p>


<h3>Value</h3>

<p>Either a factor (if <code>binary = FALSE</code>) or a 0-1 numeric vector
(if <code>binary = TRUE</code>).
</p>


<h3>Author(s)</h3>

<p> David Firth and Heather Turner</p>


<h3>See Also</h3>

<p><code><a href="#topic+Symm">Symm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rowfac &lt;- gl(4, 4, 16)
colfac &lt;- gl(4, 1, 16)
diag4by4 &lt;- Diag(rowfac, colfac)
matrix(Diag(rowfac, colfac, binary = TRUE), 4, 4)
</code></pre>

<hr>
<h2 id='Dref'>Specify a Diagonal Reference Term in a gnm Model Formula</h2><span id='topic+Dref'></span><span id='topic+DrefWeights'></span>

<h3>Description</h3>

<p>Dref is a function of class <code>"nonlin"</code> to specify a diagonal
reference term in the formula argument to <code><a href="#topic+gnm">gnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dref(..., delta = ~ 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dref_+3A_...">...</code></td>
<td>
<p>a comma-separated list of two or more factors.</p>
</td></tr>
<tr><td><code id="Dref_+3A_delta">delta</code></td>
<td>
<p>a formula with no left-hand-side specifying the model for
each factor weight.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>Dref</code> specifies diagonal reference terms as introduced by
Sobel (1981, 1985).  Such terms comprise an additive component for
each factor of the form
</p>
<p style="text-align: center;"><code class="reqn">w_f\gamma_l</code>
</p>

<p>where <code class="reqn">w_f</code> is the weight for factor <code class="reqn">f</code>,
<code class="reqn">\gamma_l</code> is the diagonal effect for level <code class="reqn">l</code> and
<code class="reqn">l</code> is the level of factor <code class="reqn">f</code> for the given data point.
</p>
<p>The weights are constrained to be nonnegative and to sum to one as
follows
</p>
<p style="text-align: center;"><code class="reqn">w_f = \frac{e^{\delta_f}}{\sum_i e^{\delta_i}}</code>
</p>

<p>and the <code class="reqn">\delta_f</code> are modelled as specified by the
<code>delta</code> argument (constant weights by default). The
returned parameters are those in the model for
<code class="reqn">\delta_f</code>, rather than the implied weights
<code class="reqn">w_f</code>. The <code>DrefWeights</code> function will take a fitted gnm
model and return the weights <code class="reqn">w_f</code>, along with their standard
errors. 
</p>
<p>If the factors passed to <code>Dref</code> do not have exactly the same
levels, the set of levels in the diagonal reference term is taken to
be the union of the factor levels, sorted into increasing order.
</p>


<h3>Value</h3>

<p>A list with the anticipated components of a &quot;nonlin&quot; function:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p> the factors passed to <code>Dref</code> and the
formulae for the weights. </p>
</td></tr>
<tr><td><code>common</code></td>
<td>
<p> an index to specify that common effects are to be
estimated across the factors. </p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p> a function to create a deparsed mathematical expression
of the term, given labels for the predictors.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p> a function to generate starting values for the parameters.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the call to use as a prefix for parameter labels. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>References</h3>

<p>Sobel, M. E. (1981), Diagonal mobility models: A substantively
motivated class of designs for the analysis of mobility effects.
<em>American Sociological Review</em> <b>46</b>, 893&ndash;906.
</p>
<p>Sobel, M. E. (1985), Social mobility and fertility revisited: Some
new models for the analysis of the mobility effects hypothesis.  
<em>American Sociological Review</em> <b>50</b>, 699&ndash;712.
</p>
<p>Clifford, P. and Heath, A. F. (1993) The Political Consequences of
Social Mobility. <em>J. Roy. Stat. Soc. A</em>, <b>156(1)</b>, 51-61.
</p>
<p>Van der Slik, F. W. P., De Graaf, N. D and Gerris, J. R. M. (2002)
Conformity to Parental Rules: Asymmetric Influences of Father's and
Mother's Levels of Education. <em>European Sociological Review</em>
<b>18(4)</b>, 489 &ndash; 502. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+nonlin.function">nonlin.function</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Examples from Clifford and Heath paper
### (Results differ slightly - possible transcription error in
### published data?)
set.seed(1)

## reconstruct counts voting Labour/non-Labour
count &lt;- with(voting, percentage/100 * total)
yvar &lt;- cbind(count, voting$total - count)

## fit diagonal reference model with constant weights
classMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination), 
                     family = binomial, data = voting)
DrefWeights(classMobility)

## create factors indicating movement in and out of salariat (class 1)
upward &lt;- with(voting, origin != 1 &amp; destination == 1)
downward &lt;- with(voting, origin == 1 &amp; destination != 1)

## fit separate weights for the "socially mobile" groups
socialMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination,
                                       delta = ~ 1 + downward + upward),
                      family = binomial, data = voting)
DrefWeights(socialMobility)

## fit separate weights for downwardly mobile groups only
downwardMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination,
                                         delta = ~ 1 + downward),
                        family = binomial, data = voting)
DrefWeights(downwardMobility)

## Not run: 	       
### Examples from Van der Slik paper
### For illustration only - data not publically available
### Using data in data.frame named 'conformity', with variables
### MCFM - mother's conformity score
### FCFF - father's conformity score
### MOPLM - a factor describing the mother's education with 7 levels
### FOPLF - a factor describing the father's education with 7 levels
### AGEM - mother's birth cohort
### MRMM - mother's traditional role model
### FRMF - father's traditional role model
### MWORK - mother's employment
### MFCM - mother's family conflict score
### FFCF - father's family conflict score

set.seed(1)

## Models for mothers' conformity score as specified in Figure 1
A &lt;- gnm(MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM + 
         Dref(MOPLM, FOPLF), family = gaussian, data = conformity,
         verbose = FALSE)
A
## Call:
## gnm(formula = MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM + 
##     Dref(MOPLM, FOPLF), family = gaussian, data = conformity, 
##     verbose = FALSE)
## 
## Coefficients:
##                     AGEM                      MRMM  
##                  0.06363                  -0.32425  
##                     FRMF                     MWORK  
##                 -0.25324                  -0.06430  
##                     MFCM  Dref(MOPLM, FOPLF)delta1  
##                 -0.06043                  -0.33731  
## Dref(MOPLM, FOPLF)delta2   Dref(., .).MOPLM|FOPLF1  
##                 -0.02505                   4.95121  
##  Dref(., .).MOPLM|FOPLF2   Dref(., .).MOPLM|FOPLF3  
##                  4.86329                   4.86458  
##  Dref(., .).MOPLM|FOPLF4   Dref(., .).MOPLM|FOPLF5  
##                  4.72343                   4.43516  
##  Dref(., .).MOPLM|FOPLF6   Dref(., .).MOPLM|FOPLF7  
##                  4.18873                   4.43378  
## 
## Deviance:            425.3389 
## Pearson chi-squared: 425.3389 
## Residual df:         576    
 
## Weights as in Table 4
DrefWeights(A)
## Refitting with parameters of first Dref weight constrained to zero
## $MOPLM
##    weight        se
## 0.4225636 0.1439829
## 
## $FOPLF
##    weight        se
## 0.5774364 0.1439829 

F &lt;- gnm(MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM + 
         Dref(MOPLM, FOPLF, delta = ~1 + MFCM), family = gaussian,
         data = conformity, verbose = FALSE)
F	 
## Call:
## gnm(formula = MCFM ~ -1 + AGEM + MRMM + FRMF + MWORK + MFCM + 
##     Dref(MOPLM, FOPLF, delta = ~1 + MFCM), family = gaussian, 
##     data = conformity, verbose = FALSE)
## 
## 
## Coefficients:
##                                                     AGEM  
##                                                  0.05818  
##                                                     MRMM  
##                                                 -0.32701  
##                                                     FRMF  
##                                                 -0.25772  
##                                                    MWORK  
##                                                 -0.07847  
##                                                     MFCM  
##                                                 -0.01694  
## Dref(MOPLM, FOPLF, delta = ~ . + MFCM).delta1(Intercept)  
##                                                  1.03515  
##           Dref(MOPLM, FOPLF, delta = ~ 1 + .).delta1MFCM  
##                                                 -1.77756  
## Dref(MOPLM, FOPLF, delta = ~ . + MFCM).delta2(Intercept)  
##                                                 -0.03515  
##           Dref(MOPLM, FOPLF, delta = ~ 1 + .).delta2MFCM  
##                                                  2.77756  
##              Dref(., ., delta = ~ 1 + MFCM).MOPLM|FOPLF1  
##                                                  4.82476  
##              Dref(., ., delta = ~ 1 + MFCM).MOPLM|FOPLF2  
##                                                  4.88066  
##              Dref(., ., delta = ~ 1 + MFCM).MOPLM|FOPLF3  
##                                                  4.83969  
##              Dref(., ., delta = ~ 1 + MFCM).MOPLM|FOPLF4  
##                                                  4.74850  
##              Dref(., ., delta = ~ 1 + MFCM).MOPLM|FOPLF5  
##                                                  4.42020  
##              Dref(., ., delta = ~ 1 + MFCM).MOPLM|FOPLF6  
##                                                  4.17957  
##              Dref(., ., delta = ~ 1 + MFCM).MOPLM|FOPLF7  
##                                                  4.40819  
## 
## Deviance:            420.9022 
## Pearson chi-squared: 420.9022 
## Residual df:         575 
##
##

## Standard error for MFCM == 1 lower than reported by Van der Slik et al
DrefWeights(F)
## Refitting with parameters of first Dref weight constrained to zero
## $MOPLM
##   MFCM     weight        se
## 1    1 0.02974675 0.2277711
## 2    0 0.74465224 0.2006916
## 
## $FOPLF
##   MFCM    weight        se
## 1    1 0.9702532 0.2277711
## 2    0 0.2553478 0.2006916

## End(Not run)
</code></pre>

<hr>
<h2 id='erikson'>Intergenerational Class Mobility in England/Wales, France and Sweden</h2><span id='topic+erikson'></span>

<h3>Description</h3>

<p>Intergenerational class mobility among the male populations of England
and Wales; France, and Sweden.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erikson</code></pre>


<h3>Format</h3>

<p>A table of counts, with classifying factors <code>origin</code> (father's
class; levels <code>I</code>, <code>II</code>, <code>III</code>, <code>IVa</code>,
<code>IVb</code>, <code>IVc</code>, <code>V/VI</code>, 
<code>VIIa</code>, <code>VIIb</code>) <code>destination</code> (son's
class; levels as before), and <code>country</code> (son's country of
residence; levels <code>EW</code>, <code>F</code>, <code>S</code>).
</p>


<h3>Source</h3>

<p>Hauser, R. M. (1984) Vertical Class Mobility in England, France and
Sweden. <em>Acta Sociol.</em>, <b>27(2)</b>, 87-110.
</p>


<h3>References</h3>

<p>Erikson, R., Goldthorpe, J. H. and Portocarero, L. (1982) Social
Fluidity in Industrial Nations: England, France and
Sweden. <em>Brit. J. Sociol.</em> <b>33(1)</b>, 1-34.
</p>
<p>Xie, Y. (1992) The Log-multiplicative Layer Effect Model for Comparing
Mobility Tables. <em>Am. Sociol. Rev.</em> <b>57(3)</b>, 380-395.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

### Collapse to 7 by 7 table as in Erikson (1982)

erikson &lt;- as.data.frame(erikson)
lvl &lt;- levels(erikson$origin)
levels(erikson$origin) &lt;- levels(erikson$destination) &lt;-
    c(rep(paste(lvl[1:2], collapse = " + "), 2), lvl[3],
      rep(paste(lvl[4:5], collapse = " + "), 2), lvl[6:9])
erikson &lt;- xtabs(Freq ~ origin + destination + country, data = erikson)

### Fit the models given in first half of Table 3 of Xie (1992)

## Null association between origin and destination
nullModel &lt;- gnm(Freq ~ country*origin + country*destination,
                 family = poisson, data = erikson)

## Full interaction, common to all countries
commonInteraction &lt;- update(nullModel, ~ . + origin:destination)

## Full Interaction, different multiplier for each country
multInteraction &lt;- update(nullModel,
                          ~ . + Mult(Exp(country), origin:destination))

### Create array of interaction levels as in Table 2 of Xie (1992)

levelMatrix &lt;- matrix(c(2, 3, 4, 6, 5, 6, 6,
                        3, 3, 4, 6, 4, 5, 6,
                        4, 4, 2, 5, 5, 5, 5,
                        6, 6, 5, 1, 6, 5, 2,
                        4, 4, 5, 6, 3, 4, 5,
                        5, 4, 5, 5, 3, 3, 5,
                        6, 6, 5, 3, 5, 4, 1), 7, 7, byrow = TRUE)

### Fit models in second half of Table 3 in Xie (1992)

## Interaction specified by levelMatrix, common to all countries
commonTopo &lt;- update(nullModel, ~ . +
                     Topo(origin, destination, spec = levelMatrix))

## Interaction specified by levelMatrix, different multiplier for
## each country
multTopo &lt;- update(nullModel, ~ . +
                   Mult(Exp(country),
                        Topo(origin, destination, spec = levelMatrix)))

## Interaction specified by levelMatrix, different effects for
## each country
separateTopo &lt;- update(nullModel, ~ . +
                       country:Topo(origin, destination,
                                    spec = levelMatrix))
</code></pre>

<hr>
<h2 id='exitInfo'> Print Exit Information for gnm Fit </h2><span id='topic+exitInfo'></span>

<h3>Description</h3>

<p>A utility function to print information on final iteration in
<code>gnm</code> fit, intended for use when <code>gnm</code> has not converged.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exitInfo(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exitInfo_+3A_object">object</code></td>
<td>
<p> a <code>gnm</code> object. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If <code>gnm</code> has not converged within the pre-specified maximum
number of iterations, it may be because the algorithm has converged to
a non-solution of the likelihood equations. In order to determine
appropriate action, it is necessary to differentiate this case from
one of near-convergence to the solution.
</p>
<p><code>exitInfo</code> prints the absolute score and the corresponding
convergence criterion for all parameters which failed to meet the
convergence criterion at the last iteration. Clearly a small number of
parameters with scores close to the criterion suggests
near-convergence.  
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>References</h3>

<p>Vargas, M, Crossa, J, van Eeuwijk, F, Sayre, K D and Reynolds, M P
(2001).  Interpreting treatment by environment interaction in agronomy
trials.  <em>Agronomy Journal</em> <b>93</b>, 949&ndash;960.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
##  Fit a "double UNIDIFF" model with low iterMax for illustration!
set.seed(1)
doubleUnidiff &lt;- gnm(Freq ~ election*vote + election*class*religion +
                     Mult(Exp(election), religion:vote) +
                     Mult(Exp(election), class:vote),
                     family = poisson, data = cautres, iterMax = 10)
exitInfo(doubleUnidiff)
</code></pre>

<hr>
<h2 id='Exp'> Specify the Exponential of a Predictor in a gnm Model Formula </h2><span id='topic+Exp'></span>

<h3>Description</h3>

<p>A function of class <code>"nonlin"</code> to specify the exponential
of a predictor in the formula argument to <code><a href="#topic+gnm">gnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Exp(expression, inst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Exp_+3A_expression">expression</code></td>
<td>
<p> a symbolic expression representing the (possibly
nonlinear) predictor. </p>
</td></tr>
<tr><td><code id="Exp_+3A_inst">inst</code></td>
<td>
<p> (optional) an integer specifying the instance number of
the term. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>expression</code> argument is interpreted as the right hand side
of a formula in an object of class <code>"formula"</code>, except that an
intercept term is not added by default. Any function of class
<code>"nonlin"</code> may be used in addition to the usual operators and
functions.  
</p>


<h3>Value</h3>

<p>A list with the components required of a <code>"nonlin"</code> function:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p>the <code>expression</code> argument passed to <code>Exp</code></p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>a function to create a deparsed mathematical expression
of the term, given a label for the predictor.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call to use as a prefix for parameter labels. </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Heather Turner and David Firth </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+nonlin.function">nonlin.function</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

## Using 'Mult' with 'Exp' to constrain the first constituent multiplier
##  to be non-negative

## Fit the "UNIDIFF" mobility model across education levels
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest),
               family = poisson, data = yaish, subset = (dest != 7))
</code></pre>

<hr>
<h2 id='expandCategorical'> Expand Data Frame by Re-expressing Categorical Data as Counts </h2><span id='topic+expandCategorical'></span>

<h3>Description</h3>

<p>Expands the rows of a data frame by re-expressing observations of a
categorical variable specified by <code>catvar</code>, such that the
column(s) corresponding to <code>catvar</code> are replaced by a factor 
specifying the possible categories for each observation and a vector
of 0/1 counts over these categories.




</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandCategorical(data, catvar, sep = ".", countvar = "count",
                  idvar = "id", as.ordered = FALSE, group = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandCategorical_+3A_data">data</code></td>
<td>
<p> a data frame. </p>
</td></tr>
<tr><td><code id="expandCategorical_+3A_catvar">catvar</code></td>
<td>
<p> a character vector specifying factors in <code>data</code>
whose interaction will form the basis of the expansion. </p>
</td></tr>
<tr><td><code id="expandCategorical_+3A_sep">sep</code></td>
<td>
<p> a character string used to separate the concatenated
values of <code>catvar</code> in the name of the new interaction factor. </p>
</td></tr> 
<tr><td><code id="expandCategorical_+3A_countvar">countvar</code></td>
<td>
<p> (optional) a character string to be used for the name
of the new count variable. </p>
</td></tr>
<tr><td><code id="expandCategorical_+3A_idvar">idvar</code></td>
<td>
<p> (optional) a character string to be used for the name
of the new factor identifying the original rows (cases). </p>
</td></tr>
<tr><td><code id="expandCategorical_+3A_as.ordered">as.ordered</code></td>
<td>
<p> logical - whether the new interaction factor should
be of class <code>"ordered"</code>.</p>
</td></tr>
<tr><td><code id="expandCategorical_+3A_group">group</code></td>
<td>
<p>logical: whether or not to group individuals with common values
over all covariates. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Each row of the data frame is replicated <code class="reqn">c</code> times, where <code class="reqn">c</code>
is the number of levels of the interaction of the factors specified by
<code>catvar</code>. In the expanded data frame, the columns specified by
<code>catvar</code> are replaced by a factor specifying the <code class="reqn">r</code> possible
categories for each case, named by the concatenated values of
<code>catvar</code> separated by <code>sep</code>. The ordering of factor levels
will be preserved in the creation of the new factor, but this factor
will not be of class <code>"ordered"</code> unless the argument
<code>as.ordered = TRUE</code>. A variable with name <code>countvar</code> is added
to the data frame which is equal to 1 for the observed category in each
case and 0 elsewhere. Finally a factor with name <code>idvar</code> is added
to index the cases. </p>


<h3>Value</h3>

<p>The expanded data frame as described in Details.
</p>


<h3>Note</h3>

<p>Re-expressing categorical data in this way allows a multinomial
response to be modelled as a poisson response, see examples.
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>References</h3>

<p>Anderson, J. A. (1984) Regression and Ordered Categorical
Variables. <em>J. R. Statist. Soc. B</em>, <b>46(1)</b>, 1-30.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="nnet.html#topic+multinom">multinom</a></code>,
<code><a href="stats.html#topic+reshape">reshape</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from help(multinom, package = "nnet")
library(MASS)
example(birthwt)
library(nnet)
bwt.mu &lt;- multinom(low ~ ., data = bwt)

## Equivalent using gnm - include unestimable main effects in model so 
## that interactions with low0 automatically set to zero, else could use
## 'constrain' argument. 
bwtLong &lt;- expandCategorical(bwt, "low", group = FALSE)
bwt.po &lt;- gnm(count ~  low*(. - id), eliminate = id, data = bwtLong, family =
              "poisson") 
summary(bwt.po) # same deviance; df reflect extra id parameters

### Example from ?backPain
set.seed(1)
summary(backPain)
backPainLong &lt;- expandCategorical(backPain, "pain")

## Fit models described in Table 5 of Anderson (1984)

noRelationship &lt;- gnm(count ~ pain, eliminate = id,
                      family = "poisson", data = backPainLong)

oneDimensional &lt;- update(noRelationship,
                         ~ . + Mult(pain, x1 + x2 + x3))
</code></pre>

<hr>
<h2 id='friend'> Occupation of Respondents and Their Closest Friend </h2><span id='topic+friend'></span>

<h3>Description</h3>

<p>Cross-classification of the occupation of respondent and that of their
closest friend. Data taken from wave 10 (year 2000) of the British
Household Panel Survey.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>friend</code></pre>


<h3>Format</h3>

<p>A table of counts, with classifying factors <code>r</code> (respondent's
occupational category; levels <code>1:31</code>) and <code>c</code> (friend's
occupational category; levels <code>1:31</code>).
</p>


<h3>Source</h3>

<p>Chan, T.W. and Goldthorpe, J.H. (2004) Is there a status order 
in contemporary British society: Evidence from the occupational 
structure of friendship, <em>European Sociological Review</em>,
<b>20</b>, 383&ndash;401. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

###  Fit an association model with homogeneous row-column effects
rc1 &lt;- gnm(Freq ~ r + c + Diag(r,c) + MultHomog(r, c),
           family = poisson, data = friend)
rc1

## Not run: 
###  Extend to two-component interaction
rc2 &lt;- update(rc1, . ~ . + MultHomog(r, c, inst = 2),
              etastart = rc1$predictors)
rc2

## End(Not run)

</code></pre>

<hr>
<h2 id='getContrasts'> Estimated Contrasts and Standard Errors for Parameters in a gnm
Model </h2><span id='topic+getContrasts'></span>

<h3>Description</h3>

<p>Computes contrasts or scaled contrasts for a set of (non-eliminated)
parameters from a <code><a href="#topic+gnm">gnm</a></code> model, and computes standard errors
for the estimated contrasts.  Where possible, quasi standard errors are
also computed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getContrasts(model, set = NULL,  ref = "first", scaleRef = "mean",
  scaleWeights = NULL, dispersion = NULL, check = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getContrasts_+3A_model">model</code></td>
<td>
<p> a model object of class <code>"gnm"</code>.</p>
</td></tr>
<tr><td><code id="getContrasts_+3A_set">set</code></td>
<td>
<p> a vector of indices (numeric) or coefficient names
(character). If <code>NULL</code>, a dialog will open for parameter
selection. </p>
</td></tr>
<tr><td><code id="getContrasts_+3A_ref">ref</code></td>
<td>
<p>either a single numeric index, or a vector
of real numbers which sum to 1, or one of the character
strings <code>"first"</code>, <code>"last"</code> or <code>"mean"</code>.</p>
</td></tr>
<tr><td><code id="getContrasts_+3A_scaleref">scaleRef</code></td>
<td>
<p>as for <code>ref</code></p>
</td></tr>
<tr><td><code id="getContrasts_+3A_scaleweights">scaleWeights</code></td>
<td>
<p>either <code>NULL</code>, a vector of real numbers,
<code>"unit"</code> or <code>"setLength"</code>.</p>
</td></tr>
<tr><td><code id="getContrasts_+3A_dispersion">dispersion</code></td>
<td>
<p>either <code>NULL</code>, or a positive number by which
the model's variance-covariance matrix should be scaled.</p>
</td></tr>
<tr><td><code id="getContrasts_+3A_check">check</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> or a numeric vector &ndash; for
which of the specified parameter combinations should estimability be
checked? If <code>TRUE</code>, all are checked; if <code>FALSE</code>, none is checked.</p>
</td></tr>
<tr><td><code id="getContrasts_+3A_...">...</code></td>
<td>
<p> arguments to pass to other functions. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The indices in <code>set</code>
must all be in <code>1:length(coef(object))</code>.  If
<code>set = NULL</code>, a dialog is presented for the selection
of indices (model coefficients).
</p>
<p>For the set of coefficients selected, contrasts and their standard
errors are computed. A check is performed first on the estimability of
all such contrasts (if <code>check = TRUE</code>) or on a specified subset
(if <code>check</code> is a numeric index vector).  The specific
contrasts to be computed are controlled by the choice of <code>ref</code>:
this may be <code>"first"</code> (the default), for contrasts with the first
of the selected coefficients, or <code>"last"</code> for contrasts with the
last, or <code>"mean"</code> for contrasts with the arithmetic mean of the
coefficients in the selected set; or it may be an arbitrary vector of
weights (summing to 1, not necessarily all non-negative) which specify
a weighted mean against which contrasts are taken; or it may be a
single index specifying one of the coefficients with which all
contrasts should be taken.  Thus, for example, <code>ref = 1</code> is
equivalent to <code>ref = "first"</code>, and <code>ref = c(1/3, 1/3, 1/3)</code>
is equivalent to <code>ref = "mean"</code> when there are three coefficients
in the selected <code>set</code>.
</p>
<p>The contrasts may be scaled by
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\sqrt{\sum_r v_r * d_r^2}}</code>
</p>

<p>where <code class="reqn">d_r</code> is a contrast of the r'th coefficient in <code>set</code>
with the reference level specified by <code>scaleRef</code> and <code class="reqn">v</code> is a
vector of weights (of the same length as <code>set</code>)
specified by <code>scaleWeights</code>. If
<code>scaleWeights</code> is <code>NULL</code> (the default), <code>scaleRef</code>
is ignored and no scaling is performed. Other options for
<code>scaleWeights</code> are <code>"unit"</code> for weights equal to one and
<code>"setLength"</code> for weights equal to the reciprocal of
<code>length(set)</code>. If <code>scaleRef</code>
is the same as <code>ref</code>, these options constrain the sum of squared
contrasts to 1 and <code>length(set)</code> respectively.
</p>
<p>Quasi-variances (and corresponding quasi standard errors) are
reported for <b>unscaled</b> contrasts where possible. These statistics are
invariant to the choice of <code>ref</code>, see Firth (2003) or Firth and
Menezes (2004) for more details.
</p>


<h3>Value</h3>

<p>An object of class
<code>qv</code> &mdash; see <code><a href="qvcalc.html#topic+qvcalc">qvcalc</a></code>.
</p>


<h3>Author(s)</h3>

<p> David Firth and Heather Turner </p>


<h3>References</h3>

<p>Firth, D (2003).  Overcoming the reference category problem in the
presentation of statistical models.  <em>Sociological Methodology</em>
<b>33</b>, 1&ndash;18.
</p>
<p>Firth, D and Menezes, R X de (2004).  Quasi-variances.
<em>Biometrika</em> <b>91</b>, 65&ndash;80.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="#topic+se.gnm">se.gnm</a></code>,
<code><a href="#topic+checkEstimable">checkEstimable</a></code>, <code><a href="qvcalc.html#topic+qvcalc">qvcalc</a></code>,
<code><a href="#topic+ofInterest">ofInterest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### Unscaled contrasts ###
set.seed(1)

## Fit the "UNIDIFF" mobility model across education levels -- see ?yaish
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest),
               ofInterest = "[.]educ", family = poisson,
               data = yaish,  subset = (dest != 7))
## Examine the education multipliers (differences on the log scale):
unidiffContrasts &lt;- getContrasts(unidiff, ofInterest(unidiff))
plot(unidiffContrasts,
  main = "Unidiff multipliers (log scale): intervals based on
           quasi standard errors",
  xlab = "Education level", levelNames = 1:5)


### Scaled contrasts (elliptical contrasts) ###
set.seed(1)

##  Goodman Row-Column association model fits well (deviance 3.57, df 8)
mentalHealth$MHS &lt;- C(mentalHealth$MHS, treatment)
mentalHealth$SES &lt;- C(mentalHealth$SES, treatment)
RC1model &lt;- gnm(count ~ SES + MHS + Mult(SES, MHS),
                family = poisson, data = mentalHealth)
## Row scores and column scores are both unnormalized in this
## parameterization of the model 

## The scores can be normalized as in Agresti's eqn (9.15):
rowProbs &lt;- with(mentalHealth, tapply(count, SES, sum) / sum(count))
colProbs &lt;- with(mentalHealth, tapply(count, MHS, sum) / sum(count))
mu &lt;- getContrasts(RC1model, pickCoef(RC1model, "[.]SES"),
                   ref = rowProbs, scaleRef = rowProbs,
                   scaleWeights = rowProbs)
nu &lt;- getContrasts(RC1model, pickCoef(RC1model, "[.]MHS"),
                   ref = colProbs, scaleRef = colProbs,
                   scaleWeights = colProbs)
all.equal(sum(mu$qv[,1] * rowProbs), 0)
all.equal(sum(nu$qv[,1] * colProbs), 0)
all.equal(sum(mu$qv[,1]^2 * rowProbs), 1)
all.equal(sum(nu$qv[,1]^2 * colProbs), 1)
</code></pre>

<hr>
<h2 id='gnm'> Fitting Generalized Nonlinear Models </h2><span id='topic+gnm'></span>

<h3>Description</h3>

<p><code>gnm</code> fits generalised nonlinear models using an
over-parameterized representation. Nonlinear terms are specified by
calls to functions of class <code>"nonlin"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gnm(formula, eliminate = NULL, ofInterest = NULL, constrain = numeric(0),
    constrainTo = numeric(length(constrain)), family = gaussian, 
    data = NULL, subset, weights, na.action,  method = "gnmFit", 
    checkLinear = TRUE, offset, start = NULL, etastart = NULL,
    mustart = NULL, tolerance = 1e-06, iterStart = 2, iterMax = 500,
    trace = FALSE, verbose = TRUE, model = TRUE, x = TRUE,
    termPredictors = FALSE, ridge = 1e-08, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gnm_+3A_formula">formula</code></td>
<td>
<p> a symbolic description of the nonlinear predictor. </p>
</td></tr>
<tr><td><code id="gnm_+3A_eliminate">eliminate</code></td>
<td>
<p> a factor to be included as the first term in the
model. <code>gnm</code> will exploit the structure of this factor to
improve computational efficiency. See details. </p>
</td></tr>
<tr><td><code id="gnm_+3A_ofinterest">ofInterest</code></td>
<td>
<p> optional coefficients of interest, specified by a
regular expression, a numeric vector of indices, a character vector of
names, or &quot;[?]&quot; to select from a Tk dialog. If <code>NULL</code>, it is
assumed that all non-<code>eliminate</code>d coefficients are of interest. </p>
</td></tr>
<tr><td><code id="gnm_+3A_constrain">constrain</code></td>
<td>
<p> (non-eliminated) coefficients to constrain, specified
by a regular expression, a numeric vector of indices, a logical vector, a
character vector of names, or &quot;[?]&quot; to select from a Tk dialog. </p>
</td></tr>
<tr><td><code id="gnm_+3A_constrainto">constrainTo</code></td>
<td>
<p> a numeric vector of the same length as
<code>constrain</code> specifying the values to constrain to. By default
constrained parameters will be set to zero. </p>
</td></tr> 
<tr><td><code id="gnm_+3A_family">family</code></td>
<td>
<p> a specification of the error distribution and link function
to be used in the model. This can be a character string naming
a family function; a family function, or the result of a call
to a family function. See <code><a href="stats.html#topic+family">family</a></code> and
<code><a href="#topic+wedderburn">wedderburn</a></code> for possibilities. 
</p>
</td></tr>
<tr><td><code id="gnm_+3A_data">data</code></td>
<td>
<p> an optional data frame containing the variables in the model.
If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which
<code>gnm</code> is called.</p>
</td></tr>
<tr><td><code id="gnm_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="gnm_+3A_weights">weights</code></td>
<td>
<p> an optional vector of weights to be used in the fitting
process.</p>
</td></tr>
<tr><td><code id="gnm_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain <code>NA</code>s. If <code>data</code> is a contingency table, the
default is <code>"exclude"</code>. Otherwise the default is first, any
<code>na.action</code> attribute of <code>data</code>; second, any
<code>na.action</code> setting of <code>options</code>, and third,
<code>na.fail</code>.</p>
</td></tr>
<tr><td><code id="gnm_+3A_method">method</code></td>
<td>
<p> the method to be used: either <code>"gnmFit"</code> to fit
the model using the default maximum likelihood algorithm,
<code>"coefNames"</code> to return a character vector of names for the
coefficients in the model, <code>"model.matrix"</code> to return the model
matrix, <code>"model.frame"</code> to return the model frame, or the name
of a function providing an alternative fitting algorithm. </p>
</td></tr>
<tr><td><code id="gnm_+3A_checklinear">checkLinear</code></td>
<td>
<p> logical: if <code>TRUE</code> <code>glm.fit</code> is used
when the predictor is found to be linear </p>
</td></tr>
<tr><td><code id="gnm_+3A_offset">offset</code></td>
<td>
<p> this can be used to specify an a priori known component to
be added to the predictor during fitting. <code>offset</code> terms
can be included in the formula instead or as well, and if both
are specified their sum is used.</p>
</td></tr>
<tr><td><code id="gnm_+3A_start">start</code></td>
<td>
<p> a vector of starting values for the parameters in the
model; if a starting value is <code>NA</code>, the default starting value
will be used. Starting values need not be specified for eliminated
parameters. </p>
</td></tr>
<tr><td><code id="gnm_+3A_etastart">etastart</code></td>
<td>
<p> starting values for the linear predictor. </p>
</td></tr>
<tr><td><code id="gnm_+3A_mustart">mustart</code></td>
<td>
<p> starting values for the vector of means. </p>
</td></tr>
<tr><td><code id="gnm_+3A_tolerance">tolerance</code></td>
<td>
<p> a positive numeric value specifying the tolerance level for
convergence. </p>
</td></tr>
<tr><td><code id="gnm_+3A_iterstart">iterStart</code></td>
<td>
<p> a positive integer specifying the number of start-up iterations
to perform. </p>
</td></tr>
<tr><td><code id="gnm_+3A_itermax">iterMax</code></td>
<td>
<p> a positive integer specifying the maximum number of main
iterations to perform. </p>
</td></tr>
<tr><td><code id="gnm_+3A_trace">trace</code></td>
<td>
<p> a logical value indicating whether the deviance
should be printed after each iteration. </p>
</td></tr>
<tr><td><code id="gnm_+3A_verbose">verbose</code></td>
<td>
<p> logical: if <code>TRUE</code> and model includes nonlinear
terms, progress indicators are printed as the model is fitted,
including a diagnostic error message if the algorithm fails. </p>
</td></tr> 
<tr><td><code id="gnm_+3A_model">model</code></td>
<td>
<p> logical: if <code>TRUE</code> the model frame is returned. </p>
</td></tr>
<tr><td><code id="gnm_+3A_x">x</code></td>
<td>
<p> logical: if <code>TRUE</code> the local design matrix from the last
iteration is included as a component of returned model object. </p>
</td></tr>
<tr><td><code id="gnm_+3A_termpredictors">termPredictors</code></td>
<td>
<p> logical: if <code>TRUE</code>, a matrix is returned
with a column for each term in the model, containing the additive
contribution of that term to the predictor. </p>
</td></tr>
<tr><td><code id="gnm_+3A_ridge">ridge</code></td>
<td>
<p>numeric, a positive value for the ridge constant to be
used in the fitting algorithm</p>
</td></tr>
<tr><td><code id="gnm_+3A_...">...</code></td>
<td>
<p> further arguments passed to fitting function. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for <code>gnm</code> are specified by giving a symbolic description
of the nonlinear predictor, of the form <code>response ~ terms</code>. The
<code>response</code> is typically a numeric vector, see later in this
section for alternatives. The usual symbolic language may be used to
specify any linear terms, see <code><a href="stats.html#topic+formula">formula</a></code> for details.
</p>
<p>Nonlinear terms may be specified by calls to functions of class
&quot;nonlin&quot;. There are several &quot;nonlin&quot; functions in the <code>gnm</code>
package. Some of these specify simple
mathematical functions of predictors: <code>Exp</code>, <code>Mult</code>, and 
<code>Inv</code>. Others specify more specialised nonlinear terms, in
particular <code>MultHomog</code> specifies homogeneous multiplicative
interactions and <code>Dref</code> specifies diagonal reference terms. Users
may also define their own &quot;nonlin&quot; functions, see
<code><a href="#topic+nonlin.function">nonlin.function</a></code> for details.
</p>
<p>The <code>eliminate</code> argument may be used to specify a factor that
is to be included as the first term in the model (since an intercept
is then redundant, none is fitted). The structure of the factor is
exploited to improve computational efficiency &mdash; substantially so if
the <code>eliminate</code>d factor has a large number of levels. Use of
<code>eliminate</code> is designed for factors that are required in the
model but are not of direct interest (e.g., terms needed to fit
multinomial-response models as conditional Poisson models). See
<code><a href="#topic+backPain">backPain</a></code> for an example.
</p>
<p>The <code>ofInterest</code> argument may be used to specify coefficients of
interest, the indices of which are returned in the <code>ofInterest</code>
component of the model object. <code>print()</code> displays of the model
object or its components obtained using accessor functions such as
<code>coef()</code> etc, will only show these coefficients. In addition
methods for <code>"gnm"</code> objects which may be applied to a subset of
the parameters are by default applied to the coefficients of interest.
See <code><a href="#topic+ofInterest">ofInterest</a></code> for accessor and replacement functions.
</p>
<p>For contingency tables, the data may be provided as an object of class
<code>"table"</code> from which the frequencies will be extracted to use
as the response. In this case, the response should be specified as
<code>Freq</code> in the model formula. The <code>"predictors"</code>,
<code>"fitted.values"</code>, <code>"residuals"</code>, <code>"prior.weights"</code>,
<code>"weights"</code>, <code>"y"</code> and <code>"offset"</code> components of
the returned <code>gnm</code> fit will be tables with the same format as the
data, completed with <code>NA</code>s where necessary.
</p>
<p>For binomial models, the <code>response</code> may be specified as a factor
in which the first level denotes failure and all other levels denote
success, as a two-column matrix with the columns giving the numbers
of successes and failures, or as a vector of the proportions of
successes.
</p>
<p>The <code>gnm</code> fitting algorithm consists of two stages.  In the start-up
iterations, any nonlinear parameters that are not specified by either the
<code>start</code> argument of <code>gnm</code> or a plug-in function are
updated one parameter at a time, then the linear parameters are
jointly updated before the next iteration. In the main iterations, all
the parameters are jointly updated, until convergence is reached or
the number or iterations reaches <code>iterMax</code>. To solve the
(typically rank-deficient) least squares problem at the heart of the
<code>gnm</code> fitting algorithm,  the design matrix is standardized and
regularized (in the Levenberg-Marquardt sense) prior to solving; the
<code>ridge</code> argument provides a degree of control over the
regularization performed (smaller values may sometimes give faster
convergence but can lead to numerical instability).
</p>
<p>Convergence is judged by comparing the squared components of the score vector
with corresponding elements of the diagonal of the Fisher information
matrix. If, for all components of the score vector, the ratio is less
than <code>tolerance^2</code>, or the corresponding diagonal element of the
Fisher information matrix is less than 1e-20, iterations cease. If the
algorithm has not converged by <code>iterMax</code> iterations,
<code><a href="#topic+exitInfo">exitInfo</a></code> can be used to print information on the
parameters which failed the convergence criteria at the last iteration.
</p>
<p>By default, <code>gnm</code> uses an over-parameterized representation of
the model that is being fitted. Only minimal identifiability constraints
are imposed, so that in general a random parameterization is obtained.
The parameter estimates are ordered so that those for any linear terms
appear first.
</p>
<p><code><a href="#topic+getContrasts">getContrasts</a></code> may be used to obtain estimates of
specified scaled contrasts, if these contrasts are identifiable. For
example, <code>getContrasts</code> may be used to estimate the contrasts
between the first level of a factor and the rest, and obtain standard
errors. 
</p>
<p>If appropriate constraints are known in advance, or have been
determined from a <code>gnm</code> fit, the model may be (re-)fitted using
the <code>constrain</code> argument to specify coefficients which should be
set to values specified by <code>constrainTo</code>. Constraints should only
be specified for non-eliminated parameters. <code><a href="stats.html#topic+update">update</a></code>
provides a convenient way of re-fitting a  <code>gnm</code> model with new
constraints. 
</p>


<h3>Value</h3>

<p>If <code>method = "gnmFit"</code>, <code>gnm</code> returns <code>NULL</code> if the
algorithm has failed and an object of class <code>"gnm"</code> otherwise. A
<code>"gnm"</code> object inherits first from <code>"glm"</code> then <code>"lm"</code>
and is a list containing the following components:     
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p> the matched call. </p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p> the formula supplied. </p>
</td></tr>
<tr><td><code>constrain</code></td>
<td>
<p> a numeric vector specifying any coefficients that
were constrained in the fitting process. </p>
</td></tr>
<tr><td><code>constrainTo</code></td>
<td>
<p> a numeric vector of the same length as
<code>constrain</code> specifying the values which constrained parameters
were set to. </p>
</td></tr>  
<tr><td><code>family</code></td>
<td>
<p> the <code>family</code> object used. </p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p> the case weights initially supplied. </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> the <code>terms</code> object used. </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> the <code>data</code> argument. </p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p> the <code>na.action</code> attribute of the model frame </p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p> a record of the levels of the factors used in fitting. </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> the response used. </p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p> the offset vector used. </p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector of non-eliminated coefficients,
with an attribute <code>"eliminated"</code> specifying the eliminated
coefficients if <code>eliminate</code> is non-<code>NULL</code>. </p>
</td></tr>
<tr><td><code>eliminate</code></td>
<td>
<p> the <code>eliminate</code> argument. </p>
</td></tr>
<tr><td><code>ofInterest</code></td>
<td>
<p> a named numeric vector of indices corresponding
to non-eliminated coefficients, or <code>NULL</code>. </p>
</td></tr>
<tr><td><code>predictors</code></td>
<td>
<p> the fitted values on the link scale. </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> the fitted mean values, obtained by transforming the
predictors by the inverse of the link function. </p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> up to a constant, minus twice the maximised
log-likelihood. Where sensible, the constant is chosen so
that a saturated model has deviance zero. </p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p> Akaike's <em>An Information Criterion</em>, minus twice the
maximized log-likelihood plus twice the number of parameters (so assuming
that the dispersion is known).</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> the number of main iterations.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p> logical indicating whether the main iterations
converged, with an attribute for use by <code><a href="#topic+exitInfo">exitInfo</a></code> if
<code>FALSE</code>. </p>
</td></tr> 
<tr><td><code>weights</code></td>
<td>
<p> the <em>working</em> weights, that is, the weights used in
the last iteration.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> the <em>working</em> residuals, that is, the residuals
from the last iteration. </p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p> the residual degrees of freedom. </p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p> the numeric rank of the fitted model. </p>
</td></tr>
</table>
<p>The list may also contain the components <code>model</code>, <code>x</code>,
or <code>termPredictors</code> if requested in the arguments to <code>gnm</code>.
</p>
<p>If a table was passed to <code>data</code> and the default for
<code>na.action</code> was not overridden, the list will also contain a
<code>table.attr</code> component, for use by the extractor functions.
</p>
<p>If a binomial <code>gnm</code> model is specified by giving a two-column
response, the weights returned by <code>prior.weights</code> are the total
numbers of cases (factored by the supplied case weights) and the
component <code>y</code> of the result is the proportion of successes.
</p>
<p>The function <code><a href="#topic+summary.gnm">summary.gnm</a></code> may be used to obtain and print
a summary of the results, whilst <code><a href="#topic+plot.gnm">plot.gnm</a></code> may be used
for model diagnostics.
</p>
<p>The generic functions <code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="stats.html#topic+family">family</a></code>, 
<code><a href="stats.html#topic+terms">terms</a></code>, <code><a href="stats.html#topic+coefficients">coefficients</a></code>, 
<code><a href="stats.html#topic+fitted.values">fitted.values</a></code>, <code><a href="stats.html#topic+deviance">deviance</a></code>, 
<code><a href="stats.html#topic+extractAIC">extractAIC</a></code>, <code><a href="stats.html#topic+weights">weights</a></code>, 
<code><a href="stats.html#topic+residuals">residuals</a></code>, <code><a href="stats.html#topic+df.residual">df.residual</a></code>, 
<code><a href="stats.html#topic+model.frame">model.frame</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, 
<code><a href="stats.html#topic+vcov">vcov</a></code> and <code><a href="#topic+termPredictors">termPredictors</a></code> maybe used to
extract components from the object returned by <code><a href="#topic+gnm">gnm</a></code> or to
construct the relevant objects where necessary. 
</p>
<p>Note that the generic functions <code><a href="stats.html#topic+weights">weights</a></code> and
<code><a href="stats.html#topic+residuals">residuals</a></code> do not act as straight-forward accessor
functions for <code>gnm</code> objects, but return the prior weights and
deviance residuals respectively, as for <code>glm</code> objects.  
</p>


<h3>Note</h3>

<p>Regular expression matching is performed using <code>grep</code> with
default settings.
</p>


<h3>Author(s)</h3>

<p> Heather Turner and David Firth </p>


<h3>References</h3>

<p>Cautres, B, Heath, A F and Firth, D (1998).  Class,
religion and vote in Britain and France.  <em>La Lettre de la Maison
Francaise</em> <b>8</b>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+formula">formula</a></code> for the symbolic language used to specify
formulae. 
</p>
<p><code><a href="#topic+Diag">Diag</a></code> and <code><a href="#topic+Symm">Symm</a></code> for specifying special types
of interaction.
</p>
<p><code>Exp</code>, <code>Mult</code>, <code>Inv</code>, <code><a href="#topic+MultHomog">MultHomog</a></code>,
<code><a href="#topic+Dref">Dref</a></code> and <code><a href="#topic+nonlin.function">nonlin.function</a></code> for incorporating
nonlinear terms in the  <code>formula</code> argument to <code>gnm</code>.
</p>
<p><code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code> and the generic functions
<code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+fitted">fitted</a></code>, etc. for extracting
components from <code>gnm</code> objects.
</p>
<p><code><a href="#topic+exitInfo">exitInfo</a></code> to print more information on last iteration
when <code>gnm</code> has not converged.
</p>
<p><code><a href="#topic+getContrasts">getContrasts</a></code> to estimate (identifiable) scaled contrasts
from a <code>gnm</code> model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###  Analysis of a 4-way contingency table
set.seed(1)
print(cautres)

##  Fit a "double UNIDIFF" model with the religion-vote and class-vote
##  interactions both modulated by nonnegative election-specific
##  multipliers.
doubleUnidiff &lt;- gnm(Freq ~ election:vote + election:class:religion
                     + Mult(Exp(election), religion:vote) +
                     Mult(Exp(election), class:vote), family = poisson,
                     data = cautres)

##  Examine the multipliers of the class-vote log odds ratios
ofInterest(doubleUnidiff) &lt;- pickCoef(doubleUnidiff, "class:vote[).]")
coef(doubleUnidiff)
## Coefficients of interest:
## Mult(Exp(.), class:vote).election1 
##                        -0.38357138 
## Mult(Exp(.), class:vote).election2 
##                         0.29816599 
## Mult(Exp(.), class:vote).election3 
##                         0.06580307 
## Mult(Exp(.), class:vote).election4 
##                        -0.02174104

##  Re-parameterize by setting first multiplier to zero
getContrasts(doubleUnidiff, ofInterest(doubleUnidiff))
##                                     estimate        SE
## Mult(Exp(.), class:vote).election1 0.0000000 0.0000000
## Mult(Exp(.), class:vote).election2 0.6817374 0.2401644
## Mult(Exp(.), class:vote).election3 0.4493745 0.2473521
## Mult(Exp(.), class:vote).election4 0.3618301 0.2534754
##                                       quasiSE    quasiVar
## Mult(Exp(.), class:vote).election1 0.22854401 0.052232363
## Mult(Exp(.), class:vote).election2 0.07395886 0.005469913
## Mult(Exp(.), class:vote).election3 0.09475938 0.008979340
## Mult(Exp(.), class:vote).election4 0.10934798 0.011956981

##  Same thing but with last multiplier as reference category:
getContrasts(doubleUnidiff, rev(ofInterest(doubleUnidiff)))
##                                       estimate        SE
## Mult(Exp(.), class:vote).election4  0.00000000 0.0000000
## Mult(Exp(.), class:vote).election3  0.08754436 0.1446833
## Mult(Exp(.), class:vote).election2  0.31990727 0.1320022
## Mult(Exp(.), class:vote).election1 -0.36183013 0.2534754
##                                       quasiSE    quasiVar
## Mult(Exp(.), class:vote).election4 0.10934798 0.011956981
## Mult(Exp(.), class:vote).election3 0.09475938 0.008979340
## Mult(Exp(.), class:vote).election2 0.07395886 0.005469913
## Mult(Exp(.), class:vote).election1 0.22854401 0.052232363

##  Re-fit model with first multiplier set to zero
doubleUnidiffConstrained &lt;-
    update(doubleUnidiff, constrain = ofInterest(doubleUnidiff)[1])

##  Examine the multipliers of the class-vote log odds ratios
coef(doubleUnidiffConstrained)[ofInterest(doubleUnidiff)]
##  ...as using 'getContrasts' (to 4 d.p.).
</code></pre>

<hr>
<h2 id='gnm-defunct'>Defunct Functions in gnm Package</h2><span id='topic+gnm-defunct'></span><span id='topic+Nonlin'></span><span id='topic+getModelFrame'></span><span id='topic+qrSolve'></span>

<h3>Description</h3>

<p>The functions listed here are no longer part of gnm as they are not
needed any more. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nonlin(functionCall)
getModelFrame()
qrSolve(A, b, rank = NULL, ...)
</code></pre>


<h3>Details</h3>

<p><code>Nonlin</code> is not needed any more as
the plug-in architecture has been replaced by functions of class
<code>"nonlin"</code>, see <code><a href="#topic+nonlin.function">nonlin.function</a></code>.
</p>
<p><code>getModelFrame</code> was designed to work from within a plug-in
function so is no longer needed.
</p>
<p><code>qrSolve</code> was a function to solve the linear system Ax = b by two
applications of QR decomposition. Alternative methods were found to be
more robust.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+.Defunct">.Defunct</a></code></p>

<hr>
<h2 id='gnm-package'>
Generalized Nonlinear Models
</h2><span id='topic+gnm-package'></span>

<h3>Description</h3>

<p>Functions to specify, fit and evaluate generalized nonlinear
models.
</p>


<h3>Details</h3>

<p><code>gnm</code> provides functions to fit generalized nonlinear models by
maximum likelihood. Such models extend the class of generalized linear
models by allowing nonlinear terms in the predictor.
</p>
<p>Some special cases are models with multiplicative interaction terms,
such as the UNIDIFF and row-column association models from sociology
and the AMMI and GAMMI models from crop science; stereotype models for
ordered categorical response, and diagonal reference models for
dependence on a square two-way classification.
</p>
<p><code>gnm</code> is a major re-working of an earlier Xlisp-Stat package,
&quot;Llama&quot;. Over-parameterized representations of models are used
throughout; functions are provided for inference on estimable
parameter combinations, as well as standard methods for diagnostics
etc.
</p>
<p>The following documentation provides further information on the
<code>gnm</code> package:
</p>

<dl>
<dt>gnmOverview</dt><dd><p><code>vignette("gnmOverview", package = "gnm")</code></p>
</dd>
<dt>NEWS</dt><dd><p><code>file.show(system.file("NEWS", package = "gnm"))</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Heather Turner and David Firth
</p>
<p>Maintainer: Heather Turner &lt;ht@heatherturner.net&gt;
</p>


<h3>References</h3>

<p>http://www.warwick.ac.uk/go/gnm
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm">gnm</a></code> for the model fitting function, with links to
associated functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>demo(gnm)
</code></pre>

<hr>
<h2 id='House2001'> Data on twenty roll calls in the US House of Representatives, 2001 </h2><span id='topic+House2001'></span>

<h3>Description</h3>

<p>The voting record of every representative in the 2001 House, on 20
roll calls selected by <em>Americans for Democratic Action</em>.  Each row is
the record of one representative; the first column records the
representative's registered party allegiance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>House2001</code></pre>


<h3>Format</h3>

<p>A data frame with 439 observations on the following 21 variables.
</p>

<dl>
<dt><code>party</code></dt><dd><p>a factor with levels <code>D</code> <code>I</code> <code>N</code> <code>R</code></p>
</dd>
<dt><code>HR333.BankruptcyOverhaul.Yes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SJRes6.ErgonomicsRuleDisapproval.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR3.IncomeTaxReduction.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR6.MarriageTaxReduction.Yes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR8.EstateTaxRelief.Yes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR503.FetalProtection.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR1.SchoolVouchers.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR1836.TaxCutReconciliationBill.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR2356.CampaignFinanceReform.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HJRes36.FlagDesecration.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR7.FaithBasedInitiative.Yes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HJRes50.ChinaNormalizedTradeRelations.Yes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR4.ANWRDrillingBan.Yes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR2563.PatientsRightsHMOLiability.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR2563.PatientsBillOfRights.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR2944.DomesticPartnerBenefits.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR2586.USMilitaryPersonnelOverseasAbortions.Yes</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR2975.AntiTerrorismAuthority.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR3090.EconomicStimulus.No</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>HR3000.TradePromotionAuthorityFastTrack.No</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Coding of the votes is as described in ADA (2002).
</p>


<h3>Source</h3>

<p>Originally printed in ADA (2002).  Kindly supplied in electronic
format by Jan deLeeuw, who used the data to illustrate methods
developed in deLeeuw (2006).
</p>


<h3>References</h3>

<p>Americans for Democratic Action, ADA (2002).  2001 voting record:
Shattered promise of liberal progress.  <em>ADA Today</em> <b>57</b>(1),
1&ndash;17.
</p>
<p>deLeeuw, J (2006).  Principal component analysis of binary data by
iterated singular value decomposition.  <em>Computational Statistics
and Data Analysis</em> <b>50</b>, 21&ndash;39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example takes some time to run!
summary(House2001)
## Put the votes in a matrix, and discard members with too many NAs etc:
House2001m &lt;- as.matrix(House2001[-1])
informative &lt;- apply(House2001m, 1, function(row){
    valid &lt;- !is.na(row)
    validSum &lt;- if (any(valid)) sum(row[valid]) else 0
    nValid &lt;- sum(valid)
    uninformative &lt;- (validSum == nValid) || (validSum == 0) || (nValid &lt; 10)
    !uninformative})
House2001m &lt;- House2001m[informative, ]
## Make a vector of colours, blue for Republican and red for Democrat:
parties &lt;- House2001$party[informative]
partyColors &lt;- rep("black", length(parties))
partyColors &lt;- ifelse(parties == "D", "red", partyColors)
partyColors &lt;- ifelse(parties == "R", "blue", partyColors)
## Expand the data for statistical modelling:
House2001v &lt;- as.vector(House2001m)
House2001f &lt;- data.frame(member = rownames(House2001m),
                         party = parties,
                         rollCall = factor(rep((1:20),
                                           rep(nrow(House2001m), 20))),
                         vote = House2001v)
## Now fit an "empty" model, in which all members vote identically:
baseModel &lt;- glm(vote ~ -1 + rollCall, family = binomial, data = House2001f)
## From this, get starting values for a one-dimensional multiplicative term:
Start &lt;- residSVD(baseModel, rollCall, member)
##
## Now fit the logistic model with one multiplicative term.
## For the response variable, instead of vote=0,1 we use 0.03 and 0.97,
## corresponding approximately to a bias-reducing adjustment of p/(2n),
## where p is the number of parameters and n the number of observations.
##
voteAdj &lt;- 0.5 + 0.94*(House2001f$vote - 0.5)
House2001model1 &lt;- gnm(voteAdj ~ Mult(rollCall, member),
              eliminate = rollCall,
              family = binomial, data = House2001f,
              na.action = na.exclude, trace = TRUE, tolerance = 1e-03,
              start = -Start)
## Deviance is 2234.847, df = 5574
##
## Plot the members' positions as estimated in the model:
##
memberParameters &lt;- pickCoef(House2001model1, "member")
plot(coef(House2001model1)[memberParameters], col = partyColors,
     xlab = "Alphabetical index (Abercrombie 1 to Young 301)",
     ylab = "Member's relative position, one-dimensional model")
## Can do the same thing with two dimensions, but gnm takes around 40
## slow iterations to converge (there are more than 600 parameters): 
Start2 &lt;- residSVD(baseModel, rollCall, member, d = 2)
House2001model2 &lt;- gnm(
              voteAdj ~ instances(Mult(rollCall - 1, member - 1), 2),
              eliminate = rollCall,
              family = binomial, data = House2001f,
              na.action = na.exclude, trace = TRUE, tolerance = 1e-03,
              start = Start2, lsMethod = "qr")
## Deviance is 1545.166, df = 5257
##
memberParameters1 &lt;- pickCoef(House2001model2, "1).member")
memberParameters2 &lt;- pickCoef(House2001model2, "2).member")
plot(coef(House2001model2)[memberParameters1],
     coef(House2001model2)[memberParameters2],
     col = partyColors,
     xlab = "Dimension 1",
     ylab = "Dimension 2",
     main = "House2001 data: Member positions, 2-dimensional model")
##
## The second dimension is mainly due to rollCall 12, which does not
## correlate well with the rest -- look at the coefficients of
## House2001model1, or at the 12th row of
cormat &lt;- cor(na.omit(House2001m))

## End(Not run)
</code></pre>

<hr>
<h2 id='instances'> Specify Multiple Instances of a Nonlinear Term in a gnm Model
Formula </h2><span id='topic+instances'></span>

<h3>Description</h3>

<p>A symbolic wrapper, for use in the formula argument to
<code><a href="#topic+gnm">gnm</a></code>, to specify multiple instances of a term specified
by a function with an <code>inst</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instances(term, instances = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="instances_+3A_term">term</code></td>
<td>
<p> a call to a function with an inst argument, which
specifies some term. </p>
</td></tr>
<tr><td><code id="instances_+3A_instances">instances</code></td>
<td>
<p> the desired number of instances of the term. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A deparsed expression representing the summation of <code>term</code>
specified with <code>inst = 1</code>, <code>inst = 2</code>, ..., <code>inst =
    instances</code>, which is used to create an expanded formula.
</p>


<h3>Author(s)</h3>

<p> Heather Turner</p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>, 
<code><a href="#topic+nonlin.function">nonlin.function</a></code>, <code><a href="#topic+Mult">Mult</a></code>,
<code><a href="#topic+MultHomog">MultHomog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## (this example can take quite a while to run)
##
## Fitting two instances of a multiplicative interaction (i.e. a
## two-component interaction)
yield.scaled &lt;- wheat$yield * sqrt(3/1000)
treatment &lt;- factor(paste(wheat$tillage, wheat$summerCrop, wheat$manure,
                          wheat$N, sep = ""))
bilinear2 &lt;- gnm(yield.scaled ~ year + treatment +
                 instances(Mult(year, treatment), 2),
                 family = gaussian, data = wheat)

## End(Not run)
</code></pre>

<hr>
<h2 id='Inv'> Specify the Reciprocal of a Predictor in a gnm Model Formula</h2><span id='topic+Inv'></span>

<h3>Description</h3>

<p>A function of class <code>"nonlin"</code> to specify the reciprocal
of a predictor in the formula argument to <code><a href="#topic+gnm">gnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Inv(expression, inst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inv_+3A_expression">expression</code></td>
<td>
<p> a symbolic expression representing the (possibly
nonlinear) predictor. </p>
</td></tr>
<tr><td><code id="Inv_+3A_inst">inst</code></td>
<td>
<p> (optional) an integer specifying the instance number of
the term. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>expression</code> argument is interpreted as the right hand side
of a formula in an object of class <code>"formula"</code>, except that an
intercept term is not added by default. Any function of class
<code>"nonlin"</code> may be used in addition to the usual operators and
functions.  
</p>


<h3>Value</h3>

<p>A list with the components required of a <code>"nonlin"</code> function:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p>the <code>expression</code> argument passed to <code>Inv</code></p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p>a function to create a deparsed mathematical expression
of the term, given a label for the predictor.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the call to use as a prefix for parameter labels. </p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>,
<code><a href="#topic+nonlin.function">nonlin.function</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## One way to fit the logistic function without conditional
## linearity as in ?nls
library(gnm)
set.seed(1)
DNase1 &lt;- subset(DNase, Run == 1)

test &lt;- gnm(density ~ -1 +
            Mult(1, Inv(Const(1) + Exp(Mult(1 + offset(-log(conc)),
                                                Inv(1))))),
            start = c(NA, 0, 1), data = DNase1, trace = TRUE)
coef(test)
</code></pre>

<hr>
<h2 id='meanResiduals'>Average Residuals within Factor Levels</h2><span id='topic+meanResiduals'></span>

<h3>Description</h3>

<p>Computes the mean working residuals from a model fitted using
Iterative Weighted Least Squares for each level of a factor or
interaction of factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanResiduals(object, by, standardized=TRUE, as.table=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanResiduals_+3A_object">object</code></td>
<td>
<p>model object for which <code>object$residuals</code> gives the
working residuals and <code>object$weights</code> gives the working weights.</p>
</td></tr>
<tr><td><code id="meanResiduals_+3A_by">by</code></td>
<td>
<p>either a formula specifying a factor or interaction of
factors (recommended), or a list of factors (the elements of which
must correspond exactly to observations in the model frame). When a
list of factors is specified, their interaction is used to specify
the grouping factor.</p>
</td></tr>
<tr><td><code id="meanResiduals_+3A_standardized">standardized</code></td>
<td>
<p>logical: if <code>TRUE</code>, the mean residuals are
standardized to be approximately standard normal.</p>
</td></tr>
<tr><td><code id="meanResiduals_+3A_as.table">as.table</code></td>
<td>
<p>logical: logical: if <code>TRUE</code> and <code>by</code>
specifies an interaction of factors, the result is returned as a
table cross-classified by these factors.</p>
</td></tr>
<tr><td><code id="meanResiduals_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For level <code class="reqn">i</code> of the grouping factor <code class="reqn">A</code> the mean working
residual is defined as
</p>
<p style="text-align: center;"><code class="reqn">\frac{r_{ij} * w_{ij}}{\sum_{j = 1}^{n_i} w_{ij}}</code>
</p>

<p>where <code class="reqn">r_{ij}</code> is the <code class="reqn">j</code>'th residual for level <code class="reqn">i</code>,
<code class="reqn">w_{ij}</code> is the corresponding working weight and <code class="reqn">n_i</code>
is the number of observations for level <code class="reqn">i</code>. The denominator gives
the weight corresponding to mean residual.
</p>
<p>For non-aggregated residuals, i.e. when the factor has one level per
observation, the residuals are the same as Pearson residuals.
</p>


<h3>Value</h3>

<p>An object of class <code>"meanResiduals"</code>, for which <code>print</code>
and <code>summary</code> methods are provided. A <code>"meanResiduals"</code>
object is a list containing the following elements:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p> the call used to create the model object from which the
mean residuals are derived. </p>
</td></tr>
<tr><td><code>by</code></td>
<td>
<p> a label for the grouping factor. </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> the mean residuals. </p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p> the degrees of freedom associated with the mean
residuals. </p>
</td></tr>
<tr><td><code>standardized</code></td>
<td>
<p> the <code>standardized</code> argument. </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> the weights corresponding to the mean residuals. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heather Turner</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit a conditional independence model, leaving out
## the uninformative subtable for dest == 7:
CImodel &lt;- gnm(Freq ~ educ*orig + educ*dest, family = poisson,
               data = yaish, subset = (dest != 7))

## compute mean residuals over origin and destination
meanRes &lt;- meanResiduals(CImodel, ~ orig:dest)
meanRes
summary(meanRes)

## Not run: 
## requires vcdExtra package
## display mean residuals for origin and destination
library(vcdExtra)
mosaic(CImodel, ~orig+dest)

## End(Not run)

## non-aggregated residuals
res1 &lt;- meanResiduals(CImodel, ~ educ:orig:dest)
res2 &lt;- residuals(CImodel, type = "pearson")
all.equal(as.numeric(res1), as.numeric(res2))
</code></pre>

<hr>
<h2 id='mentalHealth'> Data on Mental Health and Socioeconomic Status</h2><span id='topic+mentalHealth'></span>

<h3>Description</h3>

<p>A 2-way contingency table from a sample of residents of Manhattan.
Classifying variables are child's mental impairment (<code>MHS</code>) and
parents' socioeconomic status (<code>SES</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mentalHealth</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on the following 3 variables.
</p>

<dl>
<dt><code>count</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>SES</code></dt><dd><p>an ordered factor with levels <code>A</code> &lt; <code>B</code> &lt; <code>C</code> &lt; <code>D</code> &lt; <code>E</code> &lt; <code>F</code></p>
</dd>
<dt><code>MHS</code></dt><dd><p>an ordered factor with levels <code>well</code> &lt; <code>mild</code> &lt; <code>moderate</code> &lt; <code>impaired</code></p>
</dd>
</dl>



<h3>Source</h3>

<p>From Agresti (2002, p381); originally in Srole et al. (1978, p289).
</p>


<h3>References</h3>

<p>Agresti, A. (2002).  <em>Categorical Data Analysis</em> (2nd edn).  New
York: Wiley.
</p>
<p>Srole, L, Langner, T. S., Michael, S. T., Opler, M. K. and Rennie,
T. A. C. (1978), <em>Mental Health in the Metropolis: The Midtown
Manhattan Study</em>.  New York: NYU Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

##  Goodman Row-Column association model fits well (deviance 3.57, df 8)
mentalHealth$MHS &lt;- C(mentalHealth$MHS, treatment)
mentalHealth$SES &lt;- C(mentalHealth$SES, treatment)
RC1model &lt;- gnm(count ~ SES + MHS + Mult(SES, MHS),
                family = poisson, data = mentalHealth)
## Row scores and column scores are both unnormalized in this
## parameterization of the model 

## The scores can be normalized as in Agresti's eqn (9.15):
rowProbs &lt;- with(mentalHealth, tapply(count, SES, sum) / sum(count))
colProbs &lt;- with(mentalHealth, tapply(count, MHS, sum) / sum(count))
mu &lt;- getContrasts(RC1model, pickCoef(RC1model, "[.]SES"),
                   ref = rowProbs, scaleRef = rowProbs,
                   scaleWeights = rowProbs)
nu &lt;- getContrasts(RC1model, pickCoef(RC1model, "[.]MHS"),
                   ref = colProbs, scaleRef = colProbs,
                   scaleWeights = colProbs)
all.equal(sum(mu$qv[,1] * rowProbs), 0)
all.equal(sum(nu$qv[,1] * colProbs), 0)
all.equal(sum(mu$qv[,1]^2 * rowProbs), 1)
all.equal(sum(nu$qv[,1]^2 * colProbs), 1)
</code></pre>

<hr>
<h2 id='model.matrix.gnm'> Local Design Matrix for a Generalized Nonlinear Model  </h2><span id='topic+model.matrix.gnm'></span>

<h3>Description</h3>

<p>This method extracts or evaluates a local design matrix for a
generalized nonlinear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
model.matrix(object, coef = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.gnm_+3A_object">object</code></td>
<td>
<p> an object of class <code>gnm</code>. </p>
</td></tr>
<tr><td><code id="model.matrix.gnm_+3A_coef">coef</code></td>
<td>
<p> if specified, the vector of (non-eliminated) coefficients
at which the local design matrix is evaluated.  </p>
</td></tr>
<tr><td><code id="model.matrix.gnm_+3A_...">...</code></td>
<td>
<p> further arguments.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>coef = NULL</code>, the local design matrix with columns
corresponding to the non-eliminated parameters evaluated at
<code>coef(object)</code> (extracted from <code>object</code> if possible).
</p>
<p>Otherwise, the local design matrix evaluated at <code>coef</code>.
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>example(mentalHealth)
model.matrix(RC1model)
model.matrix(RC1model, coef = seq(coef(RC1model)))
</code></pre>

<hr>
<h2 id='MPinv'> Moore-Penrose Pseudoinverse of a Real-valued Matrix </h2><span id='topic+MPinv'></span>

<h3>Description</h3>

<p>Computes the Moore-Penrose generalized inverse. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MPinv(mat, tolerance = 100*.Machine$double.eps,
      rank = NULL, method = "svd")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MPinv_+3A_mat">mat</code></td>
<td>
<p> a real matrix.</p>
</td></tr>
<tr><td><code id="MPinv_+3A_tolerance">tolerance</code></td>
<td>
<p> A positive scalar which determines the tolerance for
detecting zeroes among the singular values. </p>
</td></tr>
<tr><td><code id="MPinv_+3A_rank">rank</code></td>
<td>
<p>Either <code>NULL</code>, in which case the rank of <code>mat</code> is
determined numerically; or an integer specifying the rank of
<code>mat</code> if it is known.  No check is made on the validity of any
non-<code>NULL</code> value.</p>
</td></tr>
<tr><td><code id="MPinv_+3A_method">method</code></td>
<td>
<p>Character, one of <code>"svd", "chol"</code>. The
specification <code>method = "chol"</code> is valid only for 
symmetric matrices.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Real-valuedness is not checked, neither is symmetry when <code>method
    = "chol"</code>. 
</p>


<h3>Value</h3>

<p>A matrix, with an additional attribute named <code>"rank"</code> containing
the numerically determined rank of the matrix.
</p>


<h3>Author(s)</h3>

<p> David Firth and Heather Turner </p>


<h3>References</h3>

<p>Harville, D. A. (1997).  <em>Matrix Algebra from a
Statistician's Perspective</em>.  New York: Springer.
</p>
<p>Courrieu, P. (2005).  Fast computation of Moore-Penrose
inverse matrices. <em>Neural Information Processing</em> <b>8</b>,
25&ndash;29
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1, 1, 0,
              1, 1, 0,
              2, 3, 4), 3, 3)
B &lt;- MPinv(A)
A %*% B %*% A - A  # essentially zero
B %*% A %*% B - B  # essentially zero
attr(B, "rank")    # here 2

## demonstration that "svd" and "chol" deliver essentially the same
## results for symmetric matrices:
A &lt;- crossprod(A)
MPinv(A) - MPinv(A, method = "chol") ##  (essentially zero) 
</code></pre>

<hr>
<h2 id='MultHomog'>Specify a Multiplicative Interaction with Homogeneous Effects in
a gnm Model Formula</h2><span id='topic+MultHomog'></span>

<h3>Description</h3>

<p>A function of class <code>"nonlin"</code> to specify a multiplicative
interaction with homogeneous effects in the formula argument to
<code><a href="#topic+gnm">gnm</a></code>.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultHomog(..., inst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultHomog_+3A_...">...</code></td>
<td>
<p> a comma-separated list of two or more factors. </p>
</td></tr>
<tr><td><code id="MultHomog_+3A_inst">inst</code></td>
<td>
<p> (optional) an integer specifying the instance number of
the term. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>MultHomog</code> specifies instances of a multiplicative interaction
in which the constituent multipliers are the effects of two or more
factors and the effects of these factors are constrained to be equal
when the factor levels are equal.  Thus the interaction effect would
be
</p>
<p style="text-align: center;"><code class="reqn">\gamma_i\gamma_j...</code>
</p>

<p>for an observation with level <code class="reqn">i</code> of the first factor, level
<code class="reqn">j</code> of the second factor and so on, where <code class="reqn">\gamma_l</code>
is the effect for level <code class="reqn">l</code> of the homogeneous multiplicative
factor. 
</p>
<p>If the factors passed to <code>MultHomog</code> do not have exactly the same
levels, the set of levels is taken to be the union of the factor
levels, sorted into increasing order. 
</p>


<h3>Value</h3>

<p>A list with the anticipated components of a <code>"nonlin"</code> function:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p> the factors passed to <code>MultHomog</code></p>
</td></tr>
<tr><td><code>common</code></td>
<td>
<p> an index to specify that common effects are to be
estimated across the factors </p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p> a function to create a deparsed mathematical expression
of the term, given labels for the predictors.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the call to use as a prefix for parameter labels. </p>
</td></tr> 
</table>


<h3>Note</h3>

<p>Currently, <code>MultHomog</code> can only be used to specify a
one-dimensional interaction. See examples for a workaround to specify
interactions with more than one dimension. </p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>References</h3>

<p>Goodman, L. A. (1979) Simple Models for the Analysis of Association in
Cross-Classifications having Ordered
Categories. <em>J. Am. Stat. Assoc.</em>, <b>74(367)</b>, 537-552. </p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="#topic+instances">instances</a></code>,
<code><a href="#topic+nonlin.function">nonlin.function</a></code>, <code><a href="#topic+Mult">Mult</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

###  Fit an association model with homogeneous row-column effects
rc1 &lt;- gnm(Freq ~ r + c + Diag(r,c) + MultHomog(r, c),
           family = poisson, data = friend)
rc1

## Not run: 
###  Extend to two-component interaction
rc2 &lt;- update(rc1, . ~ . + MultHomog(r, c, inst = 2),
              etastart = rc1$predictors)
rc2

## End(Not run)

### For factors with a large number of levels, save time by
### setting diagonal elements to NA rather than fitting exactly;
### skipping start-up iterations may also save time
dat &lt;- as.data.frame(friend)
id &lt;- with(dat, r == c)
dat[id,] &lt;- NA
rc2 &lt;- gnm(Freq ~ r + c + instances(MultHomog(r, c), 2),
           family = poisson, data = dat, iterStart = 0)


</code></pre>

<hr>
<h2 id='Multiplicative+20interaction'>Specify a Product of Predictors in a gnm Model Formula</h2><span id='topic+Mult'></span>

<h3>Description</h3>

<p>A function of class <code>"nonlin"</code> to specify a multiplicative interaction in
the formula argument to <code><a href="#topic+gnm">gnm</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mult(..., inst = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Multiplicative+2B20interaction_+3A_...">...</code></td>
<td>
<p>a comma-separated list of two or more symbolic
expressions representing the constituent multipliers in the
interaction.</p>
</td></tr> 
<tr><td><code id="Multiplicative+2B20interaction_+3A_inst">inst</code></td>
<td>
<p>a positive integer specifying the instance number of the
term.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>Mult</code> specifies instances of a multiplicative interaction,
i.e. a product of the form 
</p>
<p style="text-align: center;"><code class="reqn">m_1 m_2 ... m_n,</code>
</p>

<p>where the constituent multipliers <code class="reqn">m_1, m_2, ..., m_n</code> are linear
or nonlinear predictors.
</p>
<p>Models for the constituent multipliers are specified symbolically
as unspecified arguments to <code>Mult</code>. These symbolic expressions
are interpreted in the same way as the right hand side of a formula in
an object of class <code>"formula"</code>, except that an intercept term
is not added by default. Offsets can be added to constituent
multipliers, using <code>offset</code>.
</p>
<p>The family of multiplicative interaction models include
row-column association models for contingency tables (e.g., Agresti,
2002, Sec 9.6), log-multiplicative or UNIDIFF models (Erikson and
Goldthorpe, 1992; Xie, 1992), and GAMMI models (van Eeuwijk, 1995).
</p>


<h3>Value</h3>

<p>A list with the required components of a <code>"nonlin"</code> function:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p> the expressions passed to <code>Mult</code></p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p> a function to create a deparsed mathematical expression
of the term, given labels for the predictors.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the call to use as a prefix for parameter labels. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heather Turner</p>


<h3>References</h3>

<p>Agresti, A (2002).  <em>Categorical Data Analysis</em> (2nd ed.)  New
York: Wiley.
</p>
<p>Erikson, R and Goldthorpe, J H (1992).  <em>The Constant Flux</em>.
Oxford: Clarendon Press.
</p>
<p>van Eeuwijk, F A (1995).  Multiplicative interaction in generalized
linear models.  <em>Biometrics</em> <b>51</b>, 1017-1032.
</p>
<p>Vargas, M, Crossa, J, van Eeuwijk, F, Sayre, K D and Reynolds, M P
(2001).  Interpreting treatment by environment interaction in agronomy
trials.  <em>Agronomy Journal</em> <b>93</b>, 949&ndash;960.
</p>
<p>Xie, Y (1992).  The log-multiplicative layer effect model for comparing
mobility tables.  <em>American Sociological Review</em> <b>57</b>,
380-395.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+formula">formula</a></code>, <code><a href="#topic+instances">instances</a></code>,
<code><a href="#topic+nonlin.function">nonlin.function</a></code>, <code><a href="#topic+MultHomog">MultHomog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

## Using 'Mult' with 'Exp' to constrain the first constituent multiplier
##  to be non-negative

## Fit the "UNIDIFF" mobility model across education levels
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest),
               family = poisson, data = yaish, subset = (dest != 7))

## Not run: 
## (this example can take quite a while to run)
##
## Fitting two instances of a multiplicative interaction (i.e. a
## two-component interaction))
yield.scaled &lt;- wheat$yield * sqrt(3/1000)
treatment &lt;- factor(paste(wheat$tillage, wheat$summerCrop, wheat$manure,
                          wheat$N, sep = ""))
bilinear2 &lt;- gnm(yield.scaled ~ year + treatment +
                 instances(Mult(year, treatment), 2),
                 family = gaussian, data = wheat)
formula(bilinear2)
## yield.scaled ~ year + treatment + Mult(year, treatment, inst = 1) + 
##     Mult(year, treatment, inst = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='nonlin.function'> Functions to Specify Nonlinear Terms in gnm Models  </h2><span id='topic+nonlin.function'></span>

<h3>Description</h3>

<p>Nonlinear terms maybe be specified in the formula argument to gnm by
a call to a function of class <code>"nonlin"</code>.  A <code>"nonlin"</code>
function takes a list of arguments and returns a list of arguments for
the internal <code>nonlinTerms</code> function.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonlin.function_+3A_...">...</code></td>
<td>
<p> arguments required to define the term, e.g. symbolic
representations of predictors in the term. </p>
</td></tr>
<tr><td><code id="nonlin.function_+3A_inst">inst</code></td>
<td>
<p>(optional) an integer specifying the instance number of
the term - for compatibility with <code><a href="#topic+instances">instances</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function should return a list with the following components:
</p>
<table>
<tr><td><code>predictors</code></td>
<td>
<p> a list of symbolic expressions or formulae with no
left hand side which represent (possibly nonlinear)
predictors that form part of the term. Intercepts will be added by
default to predictors specified by formulae. If predictors are
named, these names will be used as a prefix for parameter labels or
the parameter label itself in the single parameter case (in either
case, prefixed by the call if supplied.) Predictors that may include
an intercept should always be named or matched to a call. </p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p> an optional list of expressions representing variables
in the term. </p>
</td></tr>
<tr><td><code>term</code></td>
<td>
<p> a function which takes the arguments <code>predLabels</code>
and <code>varLabels</code>, which are vectors of labels defined by
<code>gnm</code> that correspond to the specified predictors and variables,
and returns a deparsed mathematical expression of the full
term. Only functions recognised by <code>deriv</code> should be used in
the expression, e.g. <code>+</code> rather than <code>sum</code>.</p>
</td></tr>  
<tr><td><code>common</code></td>
<td>
<p> an optional numeric index of <code>predictors</code> with
duplicated indices identifying single factor predictors for which
homologous effects are to be estimated. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> an optional call to be used as a prefix for parameter
labels, specified as an R expression. </p>
</td></tr>
<tr><td><code>match</code></td>
<td>
<p> (if <code>call</code> is non-<code>NULL</code>) a numeric index
of <code>predictors</code> specifying which arguments of <code>call</code> the
predictors match to - zero indicating no match. If <code>NULL</code>,
predictors will not be matched. It is recommended that matches are
specified wherever possible, to ensure parameter labels are
well-defined. Parameters in matched predictors 
are labelled using &quot;dot-style&quot; labelling, see examples.</p>
</td></tr> 
<tr><td><code>start</code></td>
<td>
<p> an optional function which takes a named vector of parameters
corresponding to the predictors and returns a vector of
starting values for those parameters. This function is ignored if the
term is nested within another nonlinear term.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="#topic+Const">Const</a></code> to specify a constant,
<code><a href="#topic+Dref">Dref</a></code> to specify a diagonal reference term,
<code><a href="#topic+Exp">Exp</a></code> to specify the exponential of a predictor,
<code><a href="#topic+Inv">Inv</a></code> to specify the reciprocal of a predictor,


<code><a href="#topic+Mult">Mult</a></code> to specify a multiplicative interaction,
<code><a href="#topic+MultHomog">MultHomog</a></code> to specify a homogeneous multiplicative
interaction,

</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Equivalent of weighted.MM function in ?nls
weighted.MM &lt;- function(resp, conc){
    list(predictors = list(Vm = substitute(conc), K = 1),
         variables = list(substitute(resp), substitute(conc)),
         term = function(predictors, variables) {
             pred &lt;- paste("(", predictors[1], "/(", predictors[2],
                           " + ", variables[2], "))", sep = "")
             pred &lt;- paste("(", variables[1], " - ", pred, ")/sqrt(",
                           pred, ")", sep = "")
         })
}
class(weighted.MM) &lt;- "nonlin"

## use to fitted weighted Michaelis-Menten model
Treated &lt;- Puromycin[Puromycin$state == "treated", ]
Pur.wt.2 &lt;- gnm( ~ -1 + weighted.MM(rate, conc), data = Treated,
                start = c(Vm = 200, K = 0.1), verbose = FALSE)
Pur.wt.2
## 
## Call:
## gnm(formula = ~-1 + weighted.MM(rate, conc), data = Treated, 
##     start = c(Vm = 200, K = 0.1), verbose = FALSE)
## 
## Coefficients:
##        Vm          K  
## 206.83477    0.05461  
## 
## Deviance:            14.59690 
## Pearson chi-squared: 14.59690 
## Residual df:         10

### The definition of MultHomog
MultHomog &lt;- function(..., inst = NULL){
    dots &lt;- match.call(expand.dots = FALSE)[["..."]]
    list(predictors = dots,
         common = rep(1, length(dots)),
         term = function(predictors, ...) {
             paste("(", paste(predictors, collapse = ")*("), ")", sep = "")
         },
         call = as.expression(match.call()))
}
class(MultHomog) &lt;- "nonlin"
## use to fit homogeneous multiplicative interaction
set.seed(1)
RChomog &lt;- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               MultHomog(origin, destination), ofInterest = "MultHomog",
               family = poisson, data = occupationalStatus,
               verbose = FALSE)
RChomog
## 
## Call:
## 
## gnm(formula = Freq ~ origin + destination + Diag(origin, destination) + 
##     MultHomog(origin, destination), ofInterest = "MultHomog", family = poisson, 
##     data = occupationalStatus, verbose = FALSE)
## 
## Coefficients of interest:
## MultHomog(origin, destination)1  
##                              -1.50089  
## MultHomog(origin, destination)2  
##                              -1.28260  
## MultHomog(origin, destination)3  
##                              -0.68443  
## MultHomog(origin, destination)4  
##                              -0.10055  
## MultHomog(origin, destination)5  
##                              -0.08338  
## MultHomog(origin, destination)6  
##                               0.42838  
## MultHomog(origin, destination)7  
##                               0.84452  
## MultHomog(., .).`origin|destination`8  
##                               1.08809  
## 
## Deviance:            32.56098 
## Pearson chi-squared: 31.20716 
## Residual df:         34 
##

## the definition of Exp
Exp &lt;- function(expression, inst = NULL){
    list(predictors = list(substitute(expression)),
         term = function(predictors, ...) {
             paste("exp(", predictors, ")", sep = "")
         },
         call = as.expression(match.call()),
         match = 1)
}
class(Exp) &lt;- "nonlin"


## use to fit exponentional model
x &lt;- 1:100
y &lt;- exp(- x / 10)
set.seed(4)
exp1 &lt;- gnm(y ~ Exp(1 + x), verbose = FALSE)
exp1
## 
## Call:
## gnm(formula = y ~ Exp(1 + x), verbose = FALSE)
## 
## Coefficients:
##            (Intercept)  Exp(. + x).(Intercept)
##              1.549e-11              -7.934e-11
##           Exp(1 + .).x  
##             -1.000e-01 
## 
## Deviance:            9.342418e-20 
## Pearson chi-squared: 9.342418e-20 
## Residual df:         97
</code></pre>

<hr>
<h2 id='ofInterest'> Coefficients of Interest in a Generalized Nonlinear Model </h2><span id='topic+ofInterest'></span><span id='topic+ofInterest+3C-'></span>

<h3>Description</h3>

<p>Retrieve or set the <code>"ofInterest"</code> component of a <code>"gnm"</code>
(generalized nonlinear model) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ofInterest(object)
ofInterest(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ofInterest_+3A_object">object</code></td>
<td>
<p> an object of class <code>"gnm"</code>. </p>
</td></tr>
<tr><td><code id="ofInterest_+3A_value">value</code></td>
<td>
<p> a numeric vector of indices specifying the subset of
(non-eliminated) coefficients of interest, or <code>NULL</code> to specify
that all non-eliminated coefficients are of interest.  </p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The <code>"ofInterest"</code> component of a <code>"gnm"</code> object is a named
numeric vector of indices specifying a subset of the non-eliminated
coefficients which are of specific interest.
</p>
<p>If the <code>"ofInterest"</code> component is non-NULL, printed summaries of
the model only show the coefficients of interest. In addition 
methods for <code>"gnm"</code> objects which may be applied to a subset of
the parameters are by default applied to the coefficients of interest.
</p>
<p>These functions provide a way of extracting and replacing the
<code>"ofInterest"</code> component. The replacement function prints the
replacement value to show which parameters have been specified by
<code>value</code>.  
</p>


<h3>Value</h3>

<p>A named vector of indices, or <code>NULL</code>.
</p>


<h3>Note</h3>

<p>Regular expression matching is performed using <code>grep</code> with
default settings.
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+gnm">gnm</a></code>, <code><a href="#topic+se.gnm">se.gnm</a></code>,
<code><a href="#topic+getContrasts">getContrasts</a></code>,<code><a href="#topic+profile.gnm">profile.gnm</a></code>, <code><a href="#topic+confint.gnm">confint.gnm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

## Fit the "UNIDIFF" mobility model across education levels
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest),
               ofInterest = "[.]educ", family = poisson,
               data = yaish,  subset = (dest != 7))
ofInterest(unidiff)

## Get all of the contrasts with educ1 in the UNIDIFF multipliers
getContrasts(unidiff, ofInterest(unidiff))

## Get estimate and se for the contrast between educ4 and educ5 in the
## UNIDIFF multiplier
mycontrast &lt;- numeric(length(coef(unidiff)))
mycontrast[ofInterest(unidiff)[4:5]] &lt;- c(1, -1)
se(unidiff, mycontrast)
</code></pre>

<hr>
<h2 id='parameters'> Extract Constrained and Estimated Parameters from a gnm Object</h2><span id='topic+parameters'></span>

<h3>Description</h3>

<p>A function to extract non-eliminated parameters from a <code>"gnm"</code>
object, including parameters that were constrained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_object">object</code></td>
<td>
<p> an object of class <code>"gnm"</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>parameters</code> acts like <code>coefficients</code> except that for
constrained parameters, the value at which the parameter was
constrained is returned instead of <code>NA</code>.
</p>


<h3>Value</h3>

<p>A vector of parameters.
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+coefficients">coefficients</a></code>, <code><a href="#topic+gnm">gnm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>RChomog &lt;- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               MultHomog(origin, destination), family = poisson,
               data = occupationalStatus, ofInterest = "MultHomog",
               constrain = "MultHomog.*1")
coefficients(RChomog)
parameters(RChomog)
</code></pre>

<hr>
<h2 id='pickCoef'> Get Indices or Values of Selected Model Coefficients  </h2><span id='topic+pickCoef'></span>

<h3>Description</h3>

<p>Get the indices or values of a subset of non-eliminated coefficients selected
via a Tk dialog or by pattern matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pickCoef(object, pattern = NULL, value = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pickCoef_+3A_object">object</code></td>
<td>
<p> a model object. </p>
</td></tr>
<tr><td><code id="pickCoef_+3A_pattern">pattern</code></td>
<td>
<p> character string containing a regular expression or
(with <code>fixed = TRUE</code>) a pattern to be matched exactly. If
<code>NULL</code>, a Tk dialog will open for coefficient selection.  </p>
</td></tr>
<tr><td><code id="pickCoef_+3A_value">value</code></td>
<td>
<p> if <code>FALSE</code>, a named vector of indices, otherwise
the value of the selected coefficients. </p>
</td></tr>
<tr><td><code id="pickCoef_+3A_...">...</code></td>
<td>
<p> arguments to pass on to <a href="relimp.html#topic+pickFrom">pickFrom</a> if
<code>pattern</code> is missing, otherwise <code>grep</code>. In particular, <code>fixed
    = TRUE</code> specifies that <code>pattern</code> is a string to be matched as is.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>value = FALSE</code> (the default), a named vector of indices,
otherwise the values of the selected coefficients. If no coefficients
are selected the returned value will be <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+regexp">regexp</a></code>, <code><a href="base.html#topic+grep">grep</a></code>,
<code><a href="relimp.html#topic+pickFrom">pickFrom</a></code>, <code><a href="#topic+ofInterest">ofInterest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

### Extract indices for use with ofInterest

## fit the "UNIDIFF" mobility model across education levels
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest),
               family = poisson, data = yaish, subset = (dest != 7))

## set coefficients in first constituent multiplier as 'ofInterest'
## using regular expression
ofInterest(unidiff) &lt;- pickCoef(unidiff, "[.]educ")

## summarise model, only showing coefficients of interest
summary(unidiff)

## get contrasts of these coefficients
getContrasts(unidiff, ofInterest(unidiff))

### Extract coefficients to use as starting values

## fit diagonal reference model with constant weights
set.seed(1)

## reconstruct counts voting Labour/non-Labour
count &lt;- with(voting, percentage/100 * total)
yvar &lt;- cbind(count, voting$total - count)

classMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination), 
                     family = binomial, data = voting)

## create factors indicating movement in and out of salariat (class 1)
upward &lt;- with(voting, origin != 1 &amp; destination == 1)
downward &lt;- with(voting, origin == 1 &amp; destination != 1)

## extract diagonal effects from first model to use as starting values
diagCoef &lt;- pickCoef(classMobility, "Dref(., .)", fixed = TRUE,
                     value = TRUE)

## fit separate weights for the "socially mobile" groups
## -- there are now 3 parameters for each weight
socialMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination,
                                       delta = ~ 1 + downward + upward),
                      family = binomial, data = voting,
                      start = c(rep(NA, 6), diagCoef))
</code></pre>

<hr>
<h2 id='plot.gnm'> Plot Diagnostics for a gnm Object </h2><span id='topic+plot.gnm'></span>

<h3>Description</h3>

<p>Five plots are available: a plot of residuals against fitted values, a
Scale-Location plot of <code class="reqn">\sqrt{| residuals |}</code>
against fitted values, a Normal Q-Q plot, a plot of Cook's distances
versus row labels, and a plot of residuals against leverages.  By
default, all except the fourth are produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
plot(x, which = c(1:3, 5), caption = c("Residuals vs Fitted",
         "Normal Q-Q", "Scale-Location", "Cook's distance",
         "Residuals vs Leverage"),
         panel = if (add.smooth) panel.smooth else points,
         sub.caption = NULL, main = "",
         ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(),
         ..., id.n = 3, labels.id = names(residuals(x)), cex.id = 0.75,
         qqline = TRUE, cook.levels = c(0.5, 1),
         add.smooth = getOption("add.smooth"), label.pos = c(4, 2),
         cex.caption = 1)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gnm_+3A_x">x</code></td>
<td>
<p> a <code>"gnm"</code> object. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_which">which</code></td>
<td>
<p> a subset of the numbers 1:5 specifying which plots to
produce (out of those listed in Description section). </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_caption">caption</code></td>
<td>
<p> captions to appear above the plots. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_panel">panel</code></td>
<td>
<p> panel function.  The useful alternative to <code>points</code>,
<code>panel.smooth</code> can be chosen by <code>add.smooth = TRUE</code>. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_sub.caption">sub.caption</code></td>
<td>
<p> common title - above figures if there are
multiple; used as <code>sub</code> (s.<code>title</code>) otherwise. If
<code>NULL</code>, as by default, a possible shortened version of
<code>deparse(x$call)</code> is used. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_main">main</code></td>
<td>
<p> title to each plot - in addition to the above <code>caption</code>. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_ask">ask</code></td>
<td>
<p> logical; if <code>TRUE</code>, the user is asked before each
plot, see <code>par(ask = .)</code>.</p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_...">...</code></td>
<td>
<p> other parameters to be passed through to plotting functions. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_id.n">id.n</code></td>
<td>
<p> number of points to be labelled in each plot starting
with the most extreme. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_labels.id">labels.id</code></td>
<td>
<p> vector of labels, from which the labels for extreme
points will be chosen. <code>NULL</code> uses observation numbers. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_cex.id">cex.id</code></td>
<td>
<p> magnification of point labels. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_qqline">qqline</code></td>
<td>
<p> logical indicating if a <code>qqline()</code> should be added
to the normal Q-Q plot.</p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_cook.levels">cook.levels</code></td>
<td>
<p> levels of Cook's distance at which to draw contours. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_add.smooth">add.smooth</code></td>
<td>
<p> logical indicating if a smoother should be added to
most plots; see also <code>panel</code> above.</p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_label.pos">label.pos</code></td>
<td>
<p> positioning of labels, for the left half and right
half of the graph respectively, for plots 1-3. </p>
</td></tr>
<tr><td><code id="plot.gnm_+3A_cex.caption">cex.caption</code></td>
<td>
<p> controls the size of 'caption'. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sub.caption</code> - by default the function call - is shown as a subtitle
(under the x-axis title) on each plot when plots are on separate
pages, or as a subtitle in the outer margin (if any) when there
are multiple plots per page.
</p>
<p>The &quot;Scale-Location&quot; plot, also called &quot;Spread-Location&quot; or &quot;S-L&quot;
plot, takes the square root of the absolute residuals in order to
diminish skewness (<code class="reqn">\sqrt{| E |}</code> is much less skewed
than <code class="reqn">| E |</code> for Gaussian zero-mean <code class="reqn">E</code>).
</p>
<p>The S-L, the Q-Q, and the Residual-Leverage plot, use
<em>standardized</em> residuals which have identical variance (under the
hypothesis).  They are given as <code class="reqn">R[i] / (s*\sqrt(1 - h_{ii}))</code> where <code class="reqn">h_{ii}</code> are the diagonal
entries of the hat matrix, <code>influence()$hat</code>, see also
<code><a href="stats.html#topic+hat">hat</a></code>.  
</p>
<p>The Residual-Leverage plot shows contours of equal Cook's
distance, for values of <code>cook.levels</code> (by default 0.5 and 1) and
omits cases with leverage one. If the leverages are constant, as
typically in a balanced <code>aov</code> situation, the plot uses factor
level combinations instead of the leverages for the x-axis.
</p>


<h3>Author(s)</h3>

<p> Modification of <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> by the R Core Team. Adapted
for <code>"gnm"</code> objects by Heather Turner. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+plot.lm">plot.lm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

##  Fit an association model with homogeneous row-column effects
RChomog &lt;- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               MultHomog(origin, destination), family = poisson,
               data = occupationalStatus)

## Plot model diagnostics
plot(RChomog)

## Put 4 plots on 1 page; allow room for printing model formula in outer margin:
par(mfrow = c(2, 2), oma = c(0, 0, 3, 0))
title &lt;- paste(deparse(RChomog$formula, width.cutoff = 50), collapse = "\n")
plot(RChomog, sub.caption = title)

## Fit smoother curves
plot(RChomog, sub.caption = title, panel = panel.smooth)
plot(RChomog, sub.caption = title, panel = function(x,y) panel.smooth(x, y, span = 1))

</code></pre>

<hr>
<h2 id='predict.gnm'> Predict Method for Generalized Nonlinear Models </h2><span id='topic+predict.gnm'></span>

<h3>Description</h3>

<p>Obtains predictions and optionally estimates standard errors of
those predictions from a fitted generalized nonlinear model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
predict(object, newdata = NULL,
type = c("link", "response", "terms"), se.fit = FALSE, dispersion =
NULL, terms = NULL, na.action = na.exclude, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gnm_+3A_object">object</code></td>
<td>
<p> a fitted object of class inheriting from <code>"gnm"</code>. </p>
</td></tr>
<tr><td><code id="predict.gnm_+3A_newdata">newdata</code></td>
<td>
<p> optionally, a data frame in which to look for variables with
which to predict.  If omitted, the fitted predictors are used. </p>
</td></tr>
<tr><td><code id="predict.gnm_+3A_type">type</code></td>
<td>
<p> the type of prediction required.  The default is on the scale
of the predictors; the alternative <code>"response"</code> is on
the scale of the response variable.  Thus for a default
binomial model the default predictions are of log-odds
(probabilities on logit scale) and <code>type = "response"</code> gives
the predicted probabilities.  The <code>"terms"</code> option returns a
matrix giving the fitted values of each term in the model
formula on the predictor scale.
</p>
<p>The value of this argument can be abbreviated. </p>
</td></tr>
<tr><td><code id="predict.gnm_+3A_se.fit">se.fit</code></td>
<td>
<p> logical switch indicating if standard errors are required. </p>
</td></tr>
<tr><td><code id="predict.gnm_+3A_dispersion">dispersion</code></td>
<td>
<p>  the dispersion of the fit to be assumed in computing
the standard errors.  If omitted, that returned by <code>summary</code>
applied to the object is used. </p>
</td></tr>
<tr><td><code id="predict.gnm_+3A_terms">terms</code></td>
<td>
<p> with <code>type="terms"</code> by default all terms are returned. A
character vector specifies which terms are to be returned </p>
</td></tr>
<tr><td><code id="predict.gnm_+3A_na.action">na.action</code></td>
<td>
<p> function determining what should be done with missing values
in <code>newdata</code>.  The default is to predict <code>NA</code>. </p>
</td></tr>
<tr><td><code id="predict.gnm_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is omitted the predictions are based on the data used
for the fit.  In that case how cases with missing values in the
original fit is determined by the <code>na.action</code> argument of that
fit.  If <code>na.action = na.omit</code> omitted cases will not appear in
the residuals, whereas if <code>na.action = na.exclude</code> they will
appear (in predictions and standard errors), with residual value
<code>NA</code>.  See also <code><a href="stats.html#topic+napredict">napredict</a></code>.
</p>


<h3>Value</h3>

<p>If <code>se = FALSE</code>, a vector or matrix of predictions.  If <code>se =
  TRUE</code>, a list with components
</p>
<table>
<tr><td><code>fit</code></td>
<td>
<p> predictions.</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p> estimated standard errors.</p>
</td></tr>
<tr><td><code>residual.scale</code></td>
<td>
<p> a scalar giving the square root of the dispersion used
in computing the standard errors.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Variables are first looked for in 'newdata' and then searched for
in the usual way (which will include the environment of the
formula used in the fit).  A warning will be given if the
variables found are not of the same length as those in 'newdata'
if it was supplied.</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>References</h3>

<p> Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical Models in S </em></p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

##  Fit an association model with homogeneous row-column effects
RChomog &lt;- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               MultHomog(origin, destination), family = poisson,
               data = occupationalStatus)

## Fitted values (expected counts)
predict(RChomog, type = "response", se.fit = TRUE)

## Fitted values on log scale
predict(RChomog, type = "link", se.fit = TRUE)
</code></pre>

<hr>
<h2 id='profile.gnm'> Profile Deviance for Parameters in a Generalized Nonlinear Model </h2><span id='topic+profile.gnm'></span><span id='topic+plot.profile.gnm'></span>

<h3>Description</h3>

<p>For one or more parameters in a generalized nonlinear model, profile
the deviance over a range of values about the fitted estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
profile(fitted, which = ofInterest(fitted), alpha = 0.05, maxsteps = 10,
            stepsize = NULL, trace = FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.gnm_+3A_fitted">fitted</code></td>
<td>
<p> an object of class <code>"gnm"</code>. </p>
</td></tr>
<tr><td><code id="profile.gnm_+3A_which">which</code></td>
<td>
<p> (optional) either a numeric vector of indices or a
character vector of names, specifying the parameters over which the
deviance is to be profiled. If <code>NULL</code>, the deviance is profiled
over all parameters. </p>
</td></tr>  
<tr><td><code id="profile.gnm_+3A_alpha">alpha</code></td>
<td>
<p> the significance level of the z statistic, indicating
the range that the profile must cover (see details). </p>
</td></tr>
<tr><td><code id="profile.gnm_+3A_maxsteps">maxsteps</code></td>
<td>
<p> the maximum number of steps to take either side of
the fitted parameter. </p>
</td></tr>
<tr><td><code id="profile.gnm_+3A_stepsize">stepsize</code></td>
<td>
<p> (optional) a numeric vector of length two, specifying
the size of steps to take when profiling down and up respectively,
or a single number specifying the step size in both directions. If
<code>NULL</code>, the step sizes will be determined automatically. </p>
</td></tr>
<tr><td><code id="profile.gnm_+3A_trace">trace</code></td>
<td>
<p> logical, indicating whether profiling should be
traced. </p>
</td></tr> 
<tr><td><code id="profile.gnm_+3A_...">...</code></td>
<td>
<p> further arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic function <code>profile</code> in the
<code>base</code> package.
</p>
<p>For a given parameter, the deviance is profiled by constraining that
parameter to certain values either side of its estimate in the fitted
model and refitting the model.
</p>
<p>For each updated model, the following &quot;z statistic&quot; is computed
</p>
<p style="text-align: center;"><code class="reqn">z(\theta) = (\theta - \hat{\theta}) *
    \sqrt{\frac{D_{theta} - D_{\hat{theta}}}{\delta}}</code>
</p>
 
<p>where <code class="reqn">\theta</code> is the constrained value of the parameter;
<code class="reqn">\hat{\theta}</code> is the original fitted value;
<code class="reqn">D_{\theta}</code> is the deviance when the parameter is equal
to <code class="reqn">\theta</code>, and <code class="reqn">\delta</code> is the dispersion
parameter.
</p>
<p>When the deviance is quadratic in <code class="reqn">\theta</code>, z will be
linear in <code class="reqn">\theta</code>. Therefore departures from quadratic
behaviour can easily be identified by plotting z against
<code class="reqn">\theta</code> using <code>plot.profile.gnm</code>.
</p>
<p><code>confint.profile.gnm</code> estimates confidence intervals for the
parameters by interpolating the deviance profiles and identifying the
parameter values at which z is equal to the relevant percentage points
of the normal distribution. The <code>alpha</code> argument to
<code>profile.gnm</code> specifies the significance level of z which must be
covered by the profile. In particular, the profiling in a given
direction will stop when <code>maxsteps</code> is reached or two steps have
been taken in which
</p>
<p style="text-align: center;"><code class="reqn">z(\theta) &gt; (\theta - \hat{\theta}) * z_{(1 - \alpha)/2}</code>
</p>

<p>By default, the stepsize is
</p>
<p style="text-align: center;"><code class="reqn">z_{(1 - \alpha)/2} * s_{\hat{\theta}}</code>
</p>

<p>where <code class="reqn">s_{\hat{\theta}}</code> is the standard error of
<code class="reqn">\hat{\theta}</code>. Strong asymmetry is detected and
the stepsize is adjusted accordingly, to try to ensure that the range
determined by <code>alpha</code> is adequately covered. <code>profile.gnm</code>
will also attempt to detect if the deviance is asymptotic such that
the desired significance level cannot be reached. Each profile has an
attribute <code>"asymptote"</code>, a two-length logical vector specifying
whether an asymptote has been detected in either direction.
</p>
<p>For unidentified parameters the profile will be <code>NA</code>, as such
parameters cannot be profiled.  
</p>


<h3>Value</h3>

<p>A list of profiles, with one named component for each parameter
profiled. Each profile is a data.frame: the first column, &quot;z&quot;, contains
the z statistics and the second column &quot;par.vals&quot; contains a matrix of
parameter values, with one column for each parameter in the model.
</p>
<p>The list has two attributes: &quot;original.fit&quot; containing <code>fitted</code>
and &quot;summary&quot; containing <code>summary(fitted)</code>.
</p>


<h3>Author(s)</h3>

<p> Modification of <code><a href="MASS.html#topic+profile.glm">profile.glm</a></code> from the MASS
package. Originally D. M. Bates and W. N. Venables, ported to R by
B. D. Ripley, adapted for <code>"gnm"</code> objects by Heather Turner. </p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992) <em>Statistical Models in S</em> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+confint.gnm">confint.gnm</a></code>,  <code><a href="#topic+gnm">gnm</a></code>,
<code><a href="MASS.html#topic+profile.glm">profile.glm</a></code>, <code><a href="#topic+ofInterest">ofInterest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

### Example in which deviance is near quadratic
count &lt;- with(voting, percentage/100 * total)
yvar &lt;- cbind(count, voting$total - count)
classMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination),
                     constrain = "delta1", family = binomial,
                     data = voting)
prof &lt;- profile(classMobility, trace = TRUE)
plot(prof)
## confint similar to MLE +/- 1.96*s.e. 
confint(prof, trace = TRUE)
coefData &lt;- se(classMobility)
cbind(coefData[1] - 1.96 * coefData[2], coefData[1] + 1.96 * coefData[2])

## Not run: 
### These examples take longer to run
### Another near quadratic example
RChomog &lt;- gnm(Freq ~ origin + destination + Diag(origin, destination) +
               MultHomog(origin, destination),
               ofInterest = "MultHomog", constrain = "MultHomog.*1",
               family = poisson, data = occupationalStatus)
prof &lt;- profile(RChomog, trace = TRUE)
plot(prof)
## confint similar to MLE +/- 1.96*s.e. 
confint(prof)
coefData &lt;- se(RChomog)
cbind(coefData[1] - 1.96 * coefData[2], coefData[1] + 1.96 * coefData[2])

## Another near quadratic example, with more complex constraints
count &lt;- with(voting, percentage/100 * total)
yvar &lt;- cbind(count, voting$total - count)
classMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination), 
                     family = binomial, data = voting)
wts &lt;- prop.table(exp(coef(classMobility))[1:2])
classMobility &lt;- update(classMobility, constrain = "delta1",
                        constrainTo = log(wts[1]))
sum(exp(parameters(classMobility))[1:2]) #=1
prof &lt;- profile(classMobility, trace = TRUE)
plot(prof)
## confint similar to MLE +/- 1.96*s.e. 
confint(prof, trace = TRUE)
coefData &lt;- se(classMobility)
cbind(coefData[1] - 1.96 * coefData[2], coefData[1] + 1.96 * coefData[2])

### An example showing asymptotic deviance
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest),
               ofInterest = "[.]educ", constrain = "[.]educ1",
               family = poisson, data = yaish, subset = (dest != 7))
prof &lt;- profile(unidiff, trace = TRUE)
plot(prof)
## clearly not quadratic for Mult1.Factor1.educ4 or Mult1.Factor1.educ5!
confint(prof)
##                          2.5 %     97.5 %
## Mult(Exp(.), orig:dest).educ1         NA         NA
## Mult(Exp(.), orig:dest).educ2 -0.5978901  0.1022447
## Mult(Exp(.), orig:dest).educ3 -1.4836854 -0.2362378
## Mult(Exp(.), orig:dest).educ4 -2.5792398 -0.2953420
## Mult(Exp(.), orig:dest).educ5       -Inf -0.7006889
coefData &lt;- se(unidiff)
cbind(coefData[1] - 1.96 * coefData[2], coefData[1] + 1.96 * coefData[2])

### A far from quadratic example, also with eliminated parameters
backPainLong &lt;- expandCategorical(backPain, "pain")

oneDimensional &lt;- gnm(count ~ pain + Mult(pain, x1 + x2 + x3),
                      eliminate = id,  family = "poisson",
                      constrain = "[.](painworse|x1)", constrainTo = c(0, 1),
                      data = backPainLong)
prof &lt;- profile(oneDimensional, trace = TRUE)
plot(prof)
## not quadratic for any non-eliminated parameter
confint(prof)
coefData &lt;- se(oneDimensional)
cbind(coefData[1] - 1.96 * coefData[2], coefData[1] + 1.96 * coefData[2])

## End(Not run)
</code></pre>

<hr>
<h2 id='residSVD'> Multiplicative Approximation of Model Residuals </h2><span id='topic+residSVD'></span>

<h3>Description</h3>

<p>This function uses the first <code>d</code> components of the singular value
decomposition in order to approximate a vector of model residuals by a
sum of <code>d</code> multiplicative terms, with the multiplicative
structure determined by two specified factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residSVD(model, fac1, fac2, d = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residSVD_+3A_model">model</code></td>
<td>
<p> a model object with <code><a href="stats.html#topic+na.action">na.action</a></code>, <code><a href="stats.html#topic+residuals">residuals</a></code>, and <code><a href="stats.html#topic+weights">weights</a></code> methods, e.g. objects inheriting from class <code>"lm"</code> </p>
</td></tr>
<tr><td><code id="residSVD_+3A_fac1">fac1</code></td>
<td>
<p> a factor </p>
</td></tr>
<tr><td><code id="residSVD_+3A_fac2">fac2</code></td>
<td>
<p> a factor </p>
</td></tr>
<tr><td><code id="residSVD_+3A_d">d</code></td>
<td>
<p> integer, the number of multiplicative terms to use in the approximation </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function operates on the matrix of mean residuals, with rows
indexed by <code>fac1</code> and columns indexed by <code>fac2</code>.  For
<code>glm</code> and <code>glm</code> models, the matrix entries are weighted
working residuals.  The primary use of <code>residSVD</code> is to
generate good starting values for the parameters in <code><a href="#topic+Mult">Mult</a></code> terms
in models to be fitted using <code><a href="#topic+gnm">gnm</a></code>.   
</p>


<h3>Value</h3>

<p>If <code>d = 1</code>, a numeric vector; otherwise a numeric
matrix with <code>d</code> columns.
</p>


<h3>Author(s)</h3>

<p> David Firth and Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="#topic+Mult">Mult</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

##  Goodman RC1  association model fits well (deviance 3.57, df 8)
mentalHealth$MHS &lt;- C(mentalHealth$MHS, treatment)
mentalHealth$SES &lt;- C(mentalHealth$SES, treatment)
## independence model
indep &lt;- gnm(count ~ SES + MHS, family = poisson, data = mentalHealth)
mult1 &lt;- residSVD(indep, SES, MHS)
## Now use mult1 as starting values for the RC1 association parameters
RC1model &lt;- update(indep, . ~ . + Mult(SES, MHS),
                   start = c(coef(indep), mult1), trace = TRUE)
##  Similarly for the RC2 model:
mult2 &lt;- residSVD(indep, SES, MHS, d = 2)
RC2model &lt;- update(indep, . ~ . + instances(Mult(SES, MHS), 2),
                   start = c(coef(indep), mult2), trace = TRUE)
##
## See also example(House2001), where good starting values matter much more!
##
</code></pre>

<hr>
<h2 id='se'>Extract Standard Errors</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>Generic function for extracting standard errors from fitted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_object">object</code></td>
<td>
<p> A fitted model object.</p>
</td></tr>
<tr><td><code id="se_+3A_...">...</code></td>
<td>
<p> Arguments to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Standard errors of model parameters.</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="#topic+se.gnm">se.gnm</a></code></p>

<hr>
<h2 id='se.gnm'> Standard Errors of Linear Parameter Combinations in gnm Models </h2><span id='topic+se.gnm'></span>

<h3>Description</h3>

<p>Computes approximate standard errors for (a selection of) individual
parameters or one or more linear combinations of the parameters in a
<code><a href="#topic+gnm">gnm</a></code> (generalized nonlinear model) object.  By default, a
check is made first on the estimability of each specified combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
se(object, estimate = NULL, checkEstimability = TRUE, 
       Vcov = NULL, dispersion = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se.gnm_+3A_object">object</code></td>
<td>
<p> a model object of class <code>"gnm"</code>.</p>
</td></tr>
<tr><td><code id="se.gnm_+3A_estimate">estimate</code></td>
<td>
<p> (optional) specifies parameters or linear
combinations of parameters for which to find standard errors. In the
first case either a character vector of names, a
numeric vector of indices or <code>"[?]"</code> to select from a Tk
dialog. In the second case coefficients given as a vector or the
rows of a matrix, such that <code>NROW(estimate)</code> is equal to 
<code>length(coef(object))</code>. If <code>NULL</code>, standard errors are returned
for all (non-eliminated) parameters in the model.</p>
</td></tr>
<tr><td><code id="se.gnm_+3A_checkestimability">checkEstimability</code></td>
<td>
<p> logical: should the estimability of
all specified combinations be checked?</p>
</td></tr>
<tr><td><code id="se.gnm_+3A_vcov">Vcov</code></td>
<td>
<p> either NULL, or a matrix </p>
</td></tr>
<tr><td><code id="se.gnm_+3A_dispersion">dispersion</code></td>
<td>
<p> either NULL, or a positive number </p>
</td></tr>
<tr><td><code id="se.gnm_+3A_...">...</code></td>
<td>
<p> possible further arguments for
<code><a href="#topic+checkEstimable">checkEstimable</a></code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns:
</p>
<table>
<tr><td><code>Estimate</code></td>
<td>
<p>The estimated parameter combinations</p>
</td></tr>
<tr><td><code>Std. Error</code></td>
<td>
<p>Their estimated standard errors</p>
</td></tr>
</table>
<p>If available, the column names of <code>coefMatrix</code> will be used to name
the rows.
</p>


<h3>Note</h3>

<p>In the case where <code>estimate</code> is a numeric vector, <code>se</code> will
assume that indices have been specified if all the values of
<code>estimate</code> are in <code>seq(length(coef(object))</code>.
</p>
<p>Where both <code>Vcov</code> and <code>dispersion</code> are supplied, the
variance-covariance matrix of estimated model coefficients is taken to
be <code>Vcov * dispersion</code>.
</p>


<h3>Author(s)</h3>

<p> David Firth and Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="#topic+getContrasts">getContrasts</a></code>,
<code><a href="#topic+checkEstimable">checkEstimable</a></code>, <code><a href="#topic+ofInterest">ofInterest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

## Fit the "UNIDIFF" mobility model across education levels
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest),
               ofInterest = "[.]educ", family = poisson,
               data = yaish,  subset = (dest != 7))
## Deviance is 200.3

## Get estimate and se for the contrast between educ4 and educ5 in the
## UNIDIFF multiplier
mycontrast &lt;- numeric(length(coef(unidiff)))
mycontrast[ofInterest(unidiff)[4:5]] &lt;- c(1, -1)
se(unidiff, mycontrast)

## Get all of the contrasts with educ5 in the UNIDIFF multipliers
getContrasts(unidiff, rev(ofInterest(unidiff)))
</code></pre>

<hr>
<h2 id='summary.gnm'> Summarize Generalized Nonlinear Model Fits </h2><span id='topic+summary.gnm'></span><span id='topic+print.summary.gnm'></span>

<h3>Description</h3>

<p><code>summary</code> method for objects of class <code>"gnm"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
summary(object, dispersion = NULL, correlation = FALSE,
                      symbolic.cor = FALSE, with.eliminate = FALSE, ...)

## S3 method for class 'summary.gnm'
print(x, digits = max(3, getOption("digits") - 3),
                            signif.stars = getOption("show.signif.stars"),
                            symbolic.cor = x$symbolic.cor, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gnm_+3A_object">object</code></td>
<td>
<p> an object of class <code>"gnm"</code>. </p>
</td></tr>
<tr><td><code id="summary.gnm_+3A_x">x</code></td>
<td>
<p> an object of class <code>"summary.gnm"</code>. </p>
</td></tr>
<tr><td><code id="summary.gnm_+3A_dispersion">dispersion</code></td>
<td>
<p> the dispersion parameter for the fitting family. By
default it is obtained from <code>object</code>. </p>
</td></tr>
<tr><td><code id="summary.gnm_+3A_correlation">correlation</code></td>
<td>
<p> logical: if <code>TRUE</code>, the correlation matrix of
the estimated parameters is returned. </p>
</td></tr>
<tr><td><code id="summary.gnm_+3A_digits">digits</code></td>
<td>
<p> the number of significant digits to use when
printing. </p>
</td></tr>
<tr><td><code id="summary.gnm_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p> logical: if <code>TRUE</code>, the correlations are
printed in a symbolic form rather than numbers (see
<code>symnum</code>). </p>
</td></tr>
<tr><td><code id="summary.gnm_+3A_signif.stars">signif.stars</code></td>
<td>
<p> logical. If <code>TRUE</code>, &quot;significance stars&quot; are
printed for each coefficient. </p>
</td></tr>
<tr><td><code id="summary.gnm_+3A_with.eliminate">with.eliminate</code></td>
<td>
<p> Logical. If <code>TRUE</code>, any eliminated
coefficients are included in the summary. </p>
</td></tr>
<tr><td><code id="summary.gnm_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.summary.gnm</code> prints the original call to <code>gnm</code>; a
summary of the deviance residuals from the model fit; the coefficients
of the model; the residual deviance; the Akaike's Information
Criterion value, and the number of main iterations performed.
</p>
<p>Standard errors, z-values and p-values are printed alongside the
coefficients, with &quot;significance stars&quot; if <code>signif.stars</code> is
<code>TRUE</code>.
</p>
<p>When the <code>"summary.gnm"</code> object has a <code>"correlation"</code>
component, the lower triangle of this matrix is also printed, to two
decimal places (or symbolically); to see the full matrix of
correlations print <code>summary(object, correlation =
    TRUE)$correlation</code> directly.
</p>
<p>The standard errors returned by <code>summary.gnm</code> are scaled by
<code>sqrt(dispersion)</code>. If the dispersion is not specified, it is
taken as <code>1</code> for the <code>binomial</code> and <code>Poisson</code> families,
and otherwise estimated by the residual Chi-squared statistic divided
by the residual degrees of freedom. For coefficients that have been
constrained or are not estimable, the standard error is returned as
<code>NA</code>.    
</p>


<h3>Value</h3>

<p><code>summary.gnm</code> returns an object of class <code>"summary.gnm"</code>,
which is a list with components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p> the <code>"call"</code> component from object.  </p>
</td></tr>
<tr><td><code>ofInterest</code></td>
<td>
<p> the <code>"ofInterest"</code> component from object. </p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p> the <code>"family"</code> component from object. </p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> the <code>"deviance"</code> component from object. </p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p> the <code>"aic"</code> component from object. </p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p> the <code>"df.residual"</code> component from object. </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p> the <code>"iter"</code> component from object. </p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p> the deviance residuals, see
<code><a href="stats.html#topic+residuals.glm">residuals.glm</a></code>. </p>
</td></tr> 
<tr><td><code>coefficients</code></td>
<td>
<p> the matrix of coefficients, standard errors,
z-values and p-values. </p>
</td></tr>
<tr><td><code>elim.coefs</code></td>
<td>
<p> if <code>with.eliminate = TRUE</code> a matrix of
eliminated coefficients, standard errors, z-values and p-values. </p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p> either the supplied argument or the estimated dispersion if
the latter is <code>NULL</code>. </p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p> a 3-vector of the rank of the model; the number of
residual degrees of freedom, and number of unconstrained
coefficients. </p>
</td></tr>
<tr><td><code>cov.scaled</code></td>
<td>
<p> the estimated covariance matrix scaled by
<code>dispersion</code> (see <code><a href="#topic+vcov.gnm">vcov.gnm</a></code> for more details). </p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p> (only if <code>correlation</code> is <code>TRUE</code>) the
estimated correlations of the estimated coefficients. </p>
</td></tr>
<tr><td><code>symbolic.cor</code></td>
<td>
<p> (only if <code>correlation</code> is <code>TRUE</code>) the value
of the argument <code>symbolic.cor</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p> The <code>gnm</code> class includes generalized linear models, and it
should be noted that <code>summary.gnm</code> differs from
<code><a href="stats.html#topic+summary.glm">summary.glm</a></code> in that it does not omit coefficients which
are <code>NA</code> from the objects it returns. (Such coefficients are
<code>NA</code> since they have been fixed at <code>0</code> either by use of the
<code>constrain</code> argument to <code>gnm</code> or by a convention to handle
linear aliasing).
</p>


<h3>Author(s)</h3>

<p> Modification of <code><a href="stats.html#topic+summary.glm">summary.glm</a></code> by the R Core Team. Adapted
for <code>"gnm"</code> objects by Heather Turner. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code>, <code><a href="base.html#topic+summary">summary</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### First example from ?Dref
set.seed(1)

## reconstruct counts voting Labour/non-Labour
count &lt;- with(voting, percentage/100 * total)
yvar &lt;- cbind(count, voting$total - count)
     
## fit diagonal reference model with constant weights
classMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination), 
                     family = binomial, data = voting)

## summarize results - note diagonal weights are over-parameterised
summary(classMobility)

## refit setting first weight to zero (as DrefWeights() does)
classMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination), 
                     family = binomial, data = voting,
                     constrain = "delta1")
summary(classMobility)

</code></pre>

<hr>
<h2 id='Symm'> Symmetric Interaction of Factors </h2><span id='topic+Symm'></span>

<h3>Description</h3>

<p><code>Symm</code> codes the symmetric interaction of factors having
the same set of levels, for use in regression models of symmetry or 
quasi-symmetry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Symm(..., separator = ":")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Symm_+3A_...">...</code></td>
<td>
<p> one or more factors. </p>
</td></tr>
<tr><td><code id="Symm_+3A_separator">separator</code></td>
<td>
<p> a character string of length 1 or more, to be used in naming the levels of the resulting interaction factor. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor whose levels index the symmetric interaction of all factors 
supplied as input.
</p>


<h3>Author(s)</h3>

<p> David Firth and Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="#topic+Diag">Diag</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># square table
rowfac &lt;- gl(4, 4, 16)
colfac &lt;- gl(4, 1, 16)
symm4by4 &lt;- Symm(rowfac, colfac)
matrix(symm4by4, 4, 4)

# 3 x 3 x 3 table
ind &lt;- expand.grid(A = 1:3, B = 1:3, C = 1:3)
symm3cubed &lt;- with(ind, Symm(A, B, C))
array(symm3cubed, c(3, 3, 3))
</code></pre>

<hr>
<h2 id='termPredictors'> Extract Term Contributions to Predictor </h2><span id='topic+termPredictors'></span>

<h3>Description</h3>

<p><code>termPredictors</code> is a generic function which extracts the
contribution of each term to the predictor from a fitted model object.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>termPredictors(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="termPredictors_+3A_object">object</code></td>
<td>
<p> a fitted model object. </p>
</td></tr>
<tr><td><code id="termPredictors_+3A_...">...</code></td>
<td>
<p> additional arguments for method functions.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method assumes that the predictor is linear and calculates
the contribution of each term from the model matrix and fitted
coefficients. A method is also available for <code><a href="#topic+gnm">gnm</a></code> objects.
</p>


<h3>Value</h3>

<p>A matrix with the additive components of the predictor in labelled columns.
</p>


<h3>Author(s)</h3>

<p> Heather Turner </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gnm">gnm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Linear model
G &lt;- gl(4, 6)
x &lt;- 1:24
y &lt;- rnorm(24, 0, 1)
lmGx &lt;- lm(y ~ G + x)
contrib &lt;- termPredictors(lmGx)
contrib
all.equal(as.numeric(rowSums(contrib)), as.numeric(lmGx$fitted)) #TRUE

## Generalized linear model
y &lt;- cbind(rbinom(24, 10, 0.5), rep(10, 24))
glmGx &lt;- glm(y ~ G + x, family = binomial)
contrib &lt;- termPredictors(glmGx)
contrib
all.equal(as.numeric(rowSums(contrib)),
          as.numeric(glmGx$linear.predictors)) #TRUE

## Generalized nonlinear model
A &lt;- gl(4, 6)
B &lt;- gl(6, 1, 24)
y &lt;- cbind(rbinom(24, 10, 0.5), rep(10, 24))
set.seed(1)
gnmAB &lt;- gnm(y ~ A + B + Mult(A, B), family = binomial)
contrib &lt;- termPredictors(gnmAB)
contrib
all.equal(as.numeric(rowSums(contrib)),
          as.numeric(gnmAB$predictors)) #TRUE
</code></pre>

<hr>
<h2 id='Topo'> Topological Interaction of Factors </h2><span id='topic+Topo'></span>

<h3>Description</h3>

<p>Given two or more factors <code>Topo</code> creates an interaction factor
as specified by an array of levels, which may be arbitrarily
structured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Topo(..., spec = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Topo_+3A_...">...</code></td>
<td>
<p> two or more factors </p>
</td></tr>
<tr><td><code id="Topo_+3A_spec">spec</code></td>
<td>
<p> an array of levels, with dimensions corresponding to the
number of levels of each factor in the interaction </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor of levels extracted from the levels array given in
<code>spec</code>, using the given factors as index variables.
</p>


<h3>Author(s)</h3>

<p> David Firth </p>


<h3>References</h3>

<p>Erikson, R., Goldthorpe, J. H. and Portocarero, L. (1982) Social
Fluidity in Industrial Nations: England, France and
Sweden. <em>Brit. J. Sociol.</em> <b>33(1)</b>, 1-34.
</p>
<p>Xie, Y. (1992) The Log-multiplicative Layer Effect Model for Comparing
Mobility Tables. <em>Am. Sociol. Rev.</em> <b>57(3)</b>, 380-395.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Symm">Symm</a></code> and <code><a href="#topic+Diag">Diag</a></code> for special cases </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

### Collapse to 7 by 7 table as in Erikson (1982)

erikson &lt;- as.data.frame(erikson)
lvl &lt;- levels(erikson$origin)
levels(erikson$origin) &lt;- levels(erikson$destination) &lt;-
    c(rep(paste(lvl[1:2], collapse = " + "), 2), lvl[3],
      rep(paste(lvl[4:5], collapse = " + "), 2), lvl[6:9])
erikson &lt;- xtabs(Freq ~ origin + destination + country, data = erikson)

### Create array of interaction levels as in Table 2 of Xie (1992)

levelMatrix &lt;- matrix(c(2, 3, 4, 6, 5, 6, 6,
                        3, 3, 4, 6, 4, 5, 6,
                        4, 4, 2, 5, 5, 5, 5,
                        6, 6, 5, 1, 6, 5, 2,
                        4, 4, 5, 6, 3, 4, 5,
                        5, 4, 5, 5, 3, 3, 5,
                        6, 6, 5, 3, 5, 4, 1), 7, 7, byrow = TRUE)

### Fit the levels models given in Table 3 of Xie (1992)

## Null association between origin and destination
nullModel &lt;- gnm(Freq ~ country:origin + country:destination,
                 family = poisson, data = erikson)

## Interaction specified by levelMatrix, common to all countries
commonTopo &lt;- update(nullModel, ~ . +
                     Topo(origin, destination, spec = levelMatrix))

## Interaction specified by levelMatrix, different multiplier for
## each country
multTopo &lt;- update(nullModel, ~ . +
                   Mult(Exp(country),
                        Topo(origin, destination, spec = levelMatrix)))

## Interaction specified by levelMatrix, different effects for
## each country
separateTopo &lt;- update(nullModel, ~ . +
                       country:Topo(origin, destination,
                                    spec = levelMatrix))
</code></pre>

<hr>
<h2 id='vcov.gnm'> Variance-covariance Matrix for 
Parameters in a Generalized Nonlinear Model </h2><span id='topic+vcov.gnm'></span>

<h3>Description</h3>

<p>This method extracts or computes a variance-covariance matrix for
use in approximate inference on estimable parameter combinations in a
generalized nonlinear model.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gnm'
vcov(object, dispersion = NULL, with.eliminate = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.gnm_+3A_object">object</code></td>
<td>
<p> a model object of class <code>gnm</code>. </p>
</td></tr>
<tr><td><code id="vcov.gnm_+3A_dispersion">dispersion</code></td>
<td>
<p>the dispersion parameter for the fitting family. By
default it is obtained from <code>object</code>. </p>
</td></tr>
<tr><td><code id="vcov.gnm_+3A_with.eliminate">with.eliminate</code></td>
<td>
<p>logical; should parts of the variance-covariance
matrix corresponding to eliminated coefficients be computed?</p>
</td></tr>
<tr><td><code id="vcov.gnm_+3A_...">...</code></td>
<td>
<p> as for <code><a href="stats.html#topic+vcov">vcov</a></code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resultant matrix does not itself necessarily
contain variances and covariances, since <code>gnm</code> typically works
with over-parameterized model representations in which parameters are
not all identified.  Rather, the resultant matrix is to be used as
the kernel of quadratic forms which are the variances or
covariances for estimable parameter combinations.
</p>
<p>The matrix values are scaled by <code>dispersion</code>. If the dispersion
is not specified, it is taken as <code>1</code> for the <code>binomial</code> and
<code>Poisson</code> families, and otherwise estimated by the residual
Chi-squared statistic divided by the residual degrees of freedom. The
dispersion used is returned as an attribute of the matrix.
</p>
<p>The dimensions of the matrix correspond to the non-eliminated
coefficients of the <code>"gnm"</code> object.  If <code>use.eliminate =
    TRUE</code>  then setting can sometimes give appreciable
speed gains; see <code><a href="#topic+gnm">gnm</a></code> for details of the <code>eliminate</code>
mechanism.  The <code>use.eliminate</code> argument is currently ignored if the
model has full rank.
</p>


<h3>Value</h3>

<p>A matrix with number of rows/columns equal to
<code>length(coef(object))</code>. If there are eliminated coefficients and
<code>use.eliminate = TRUE</code>, the matrix will have the following
attributes:
</p>
<table>
<tr><td><code>covElim</code></td>
<td>
<p> a matrix of covariances between the
eliminated and non-eliminated parameters. </p>
</td></tr>
<tr><td><code>varElim</code></td>
<td>
<p> a vector of variances corresponding to the eliminated
parameters.</p>
</td></tr> 
</table>


<h3>Note</h3>

<p> The <code>gnm</code> class includes generalized linear models, and it
should be noted that the
behaviour of <code>vcov.gnm</code> differs from that of
<code><a href="stats.html#topic+vcov.glm">vcov.glm</a></code> whenever <code>any(is.na(coef(object)))</code> is
<code>TRUE</code>.  Whereas <code>vcov.glm</code> drops all rows and columns which
correspond to <code>NA</code> values in <code>coef(object)</code>, <code>vcov.gnm</code>
keeps those columns (which are full of zeros, since the <code>NA</code>
represents a parameter which is fixed either by use of the
<code>constrain</code> argument to <code>gnm</code> or by a convention to handle
linear aliasing). 
</p>


<h3>Author(s)</h3>

<p> David Firth </p>


<h3>References</h3>

<p> Turner, H and Firth, D (2005). Generalized nonlinear models
in R: An overview of the gnm package.  At <a href="https://cran.r-project.org">https://cran.r-project.org</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+getContrasts">getContrasts</a></code>, <code><a href="#topic+se.gnm">se.gnm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
## Fit the "UNIDIFF" mobility model across education levels
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
               Mult(Exp(educ), orig:dest), family = poisson,
               data = yaish, subset = (dest != 7))
## Examine the education multipliers (differences on the log scale):
ind &lt;- pickCoef(unidiff, "[.]educ")
educMultipliers &lt;- getContrasts(unidiff, rev(ind))
## Now get the same standard errors using a suitable set of
## quadratic forms, by calling vcov() directly:
cmat &lt;- contr.sum(ind)
sterrs &lt;- sqrt(diag(t(cmat)
                    %*% vcov(unidiff)[ind, ind]
                    %*% cmat))
all(sterrs == (educMultipliers$SE)[-1]) ## TRUE
</code></pre>

<hr>
<h2 id='voting'>Data on Social Mobility and the Labour Vote</h2><span id='topic+voting'></span>

<h3>Description</h3>

<p>Voting data from the 1987 British general election, cross-classified
by the class of the head of household and the class of their father.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voting</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 4 variables.
</p>

<dl>
<dt><code>percentage</code></dt><dd><p>the percentage of the cell voting Labour.</p>
</dd>
<dt><code>total</code></dt><dd><p>the cell count.</p>
</dd>
<dt><code>origin</code></dt><dd><p>a factor describing the father's class with
levels <code>1:5</code>.</p>
</dd> 
<dt><code>destination</code></dt><dd><p>a factor describing the head of
household's class with levels <code>1:5</code>.</p>
</dd> 
</dl>



<h3>Source</h3>

<p>Clifford, P. and Heath, A. F. (1993) The Political Consequences of
Social Mobility. <em>J. Roy. Stat. Soc. A</em>, <b>156(1)</b>, 51-61.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Examples from Clifford and Heath paper
### (Results differ slightly - possible transcription error in
### published data?)
set.seed(1)

## reconstruct counts voting Labour/non-Labour
count &lt;- with(voting, percentage/100 * total)
yvar &lt;- cbind(count, voting$total - count)

## fit diagonal reference model with constant weights
classMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination), 
                     family = binomial, data = voting)
DrefWeights(classMobility)

## create factors indicating movement in and out of salariat (class 1)
upward &lt;- with(voting, origin != 1 &amp; destination == 1)
downward &lt;- with(voting, origin == 1 &amp; destination != 1)

## fit separate weights for the "socially mobile" groups
socialMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination,
                                       delta = ~ 1 + downward + upward),
                      family = binomial, data = voting)
DrefWeights(socialMobility)

## fit separate weights for downwardly mobile groups only
downwardMobility &lt;- gnm(yvar ~ -1 + Dref(origin, destination,
                                         delta = ~ 1 + downward),
                        family = binomial, data = voting)
DrefWeights(downwardMobility)
</code></pre>

<hr>
<h2 id='wedderburn'> Wedderburn Quasi-likelihood Family </h2><span id='topic+wedderburn'></span>

<h3>Description</h3>

<p>Creates a <code><a href="stats.html#topic+family">family</a></code> object for use with <code><a href="stats.html#topic+glm">glm</a></code>,
<code><a href="#topic+gnm">gnm</a></code>, etc., for the variance function 
<code class="reqn">[\mu(1-\mu)]^2</code> introduced by Wedderburn (1974) for response values in
[0,1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wedderburn(link = "logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wedderburn_+3A_link">link</code></td>
<td>
<p> The name of a link function.  Allowed are &quot;logit&quot;, &quot;probit&quot;
and &quot;cloglog&quot;. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="stats.html#topic+family">family</a></code>.
</p>


<h3>Note</h3>

<p>   The reported deviance involves an arbitrary constant (see McCullagh and
Nelder, 1989, p330); for estimating dispersion, use the Pearson chi-squared
statistic instead. </p>


<h3>Author(s)</h3>

<p> Modification of <code><a href="stats.html#topic+binomial">binomial</a></code> by the R Core Team. Adapted
for the Wedderburn quasi-likelihood family by David Firth. </p>


<h3>References</h3>

 
<p>Gabriel, K R (1998).  Generalised bilinear regression.  <em>Biometrika</em> 
<b>85</b>, 689&ndash;700.
</p>
<p>McCullagh, P and Nelder, J A (1989).  <em>Generalized Linear Models</em>
(2nd ed).  Chapman and Hall.
</p>
<p>Wedderburn, R W M (1974).  Quasilikelihood functions, generalized
linear models and the Gauss-Newton method.  <em>Biometrika</em>
<b>61</b>, 439&ndash;47.
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+gnm">gnm</a></code>, <code><a href="stats.html#topic+family">family</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
###  Use data from Wedderburn (1974), see ?barley

###  Fit Wedderburn's logit model with variance proportional to the
###  square of mu(1-mu)
logitModel &lt;- glm(y ~ site + variety, family = wedderburn, data = barley)
fit &lt;- fitted(logitModel)
print(sum((barley$y - fit)^2 / (fit * (1-fit))^2))
##  Agrees with the chi-squared value reported in McCullagh and Nelder 
##  (1989, p331), which differs slightly from Wedderburn's reported value.

###  Fit the biplot model as in Gabriel (1998, p694)
biplotModel &lt;- gnm(y ~ -1 + instances(Mult(site, variety), 2),
                   family = wedderburn, data = barley)
barleySVD &lt;- svd(matrix(biplotModel$predictors, 10, 9))
A &lt;- sweep(barleySVD$v, 2, sqrt(barleySVD$d), "*")[, 1:2]
B &lt;- sweep(barleySVD$u, 2, sqrt(barleySVD$d), "*")[, 1:2]
##  These are essentially A and B as in Gabriel (1998, p694), from which
##  the biplot is made by
plot(rbind(A, B), pch = c(LETTERS[1:9], as.character(1:9), "X"))

###  Fit the double-additive model as in Gabriel (1998, p697)
variety.binary &lt;- factor(match(barley$variety, c(2,3,6), nomatch = 0) &gt; 0,
                         labels = c("Rest", "2,3,6"))
doubleAdditive &lt;- gnm(y ~ variety + Mult(site, variety.binary),
                      family = wedderburn, data = barley)
</code></pre>

<hr>
<h2 id='wheat'> Wheat Yields from  Mexican Field Trials </h2><span id='topic+wheat'></span>

<h3>Description</h3>

<p>Data from a 10-year experiment at the CIMMYT experimental station
located in the Yaqui Valley near Ciudad Obregon, Sonora, Mexico &mdash; factorial
design using 24 treatments in all.  In each of the 10 years the experiment was 
arranged in a randomized complete block design with three replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wheat</code></pre>


<h3>Format</h3>

<p>A data frame with 240 observations on the following 33 variables.
</p>

<dl>
<dt>yield</dt><dd><p>numeric, mean yield in kg/ha for 3 replicates</p>
</dd>
<dt>year</dt><dd><p>a factor with levels <code>1988:1997</code></p>
</dd>
<dt>tillage</dt><dd><p>a factor with levels <code>T</code> <code>t</code></p>
</dd>
<dt>summerCrop</dt><dd><p>a factor with levels <code>S</code> <code>s</code></p>
</dd>
<dt>manure</dt><dd><p>a factor with levels <code>M</code> <code>m</code></p>
</dd>
<dt>N</dt><dd><p>a factor with levels <code>0</code> <code>N</code> <code>n</code></p>
</dd>
<dt>MTD</dt><dd><p>numeric, mean max temp sheltered (deg C) in December</p>
</dd>
<dt>MTJ</dt><dd><p>same for January</p>
</dd>
<dt>MTF</dt><dd><p>same for February</p>
</dd>
<dt>MTM</dt><dd><p>same for March</p>
</dd>
<dt>MTA</dt><dd><p>same for April</p>
</dd>
<dt>mTD</dt><dd><p>numeric, mean min temp sheltered (deg C) in December</p>
</dd>
<dt>mTJ</dt><dd><p>same for January</p>
</dd>
<dt>mTF</dt><dd><p>same for February</p>
</dd>
<dt>mTM</dt><dd><p>same for March</p>
</dd>
<dt>mTA</dt><dd><p>same for April</p>
</dd>
<dt>mTUD</dt><dd><p>numeric, mean min temp unsheltered (deg C)in December</p>
</dd>
<dt>mTUJ</dt><dd><p>same for January</p>
</dd>
<dt>mTUF</dt><dd><p>same for February</p>
</dd>
<dt>mTUM</dt><dd><p>same for March</p>
</dd>
<dt>mTUA</dt><dd><p>same for April</p>
</dd>
<dt>PRD</dt><dd><p>numeric, total precipitation (mm) in December</p>
</dd>
<dt>PRJ</dt><dd><p>same for January</p>
</dd>
<dt>PRF</dt><dd><p>same for February</p>
</dd>
<dt>PRM</dt><dd><p>same for March</p>
</dd>
<dt>SHD</dt><dd><p>numeric, mean sun hours in December</p>
</dd>
<dt>SHJ</dt><dd><p>same for January</p>
</dd>
<dt>SHF</dt><dd><p>same for February</p>
</dd>
<dt>EVD</dt><dd><p>numeric, total evaporation (mm) in December</p>
</dd>
<dt>EVJ</dt><dd><p>same for January</p>
</dd>
<dt>EVF</dt><dd><p>same for February</p>
</dd>
<dt>EVM</dt><dd><p>same for March</p>
</dd>
<dt>EVA</dt><dd><p>same for April</p>
</dd>
</dl>



<h3>Source</h3>

<p> Tables A1 and A3 of
Vargas, M, Crossa, J, van Eeuwijk, F, Sayre, K D and Reynolds, M P
(2001).  Interpreting treatment by environment interaction in agronomy
trials.  <em>Agronomy Journal</em> <b>93</b>, 949&ndash;960.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

##  Scale yields to reproduce analyses reported in Vargas et al (2001)
yield.scaled &lt;- wheat$yield * sqrt(3/1000)

##  Reproduce (up to error caused by rounding) Table 1 of Vargas et al (2001)
aov(yield.scaled ~ year*tillage*summerCrop*manure*N, data = wheat)
treatment &lt;- interaction(wheat$tillage, wheat$summerCrop, wheat$manure,
                         wheat$N, sep = "")
mainEffects &lt;- lm(yield.scaled ~ year + treatment, data = wheat)
svdStart &lt;- residSVD(mainEffects, year, treatment, 3)
bilinear1 &lt;- update(asGnm(mainEffects), . ~ . + 
                    Mult(year, treatment),
                    start = c(coef(mainEffects), svdStart[,1]))
bilinear2 &lt;- update(bilinear1, . ~ . + 
                    Mult(year, treatment, inst = 2),
                    start = c(coef(bilinear1), svdStart[,2]))
bilinear3 &lt;- update(bilinear2, . ~ . + 
                    Mult(year, treatment, inst = 3),
                    start = c(coef(bilinear2), svdStart[,3]))
anova(mainEffects, bilinear1, bilinear2, bilinear3)

##  Examine the extent to which, say, mTF explains the first bilinear term
bilinear1mTF &lt;- gnm(yield.scaled ~ year + treatment + Mult(1 + mTF, treatment),
                    family = gaussian, data = wheat)
anova(mainEffects, bilinear1mTF, bilinear1)

##  How to get the standard SVD representation of an AMMI-n model
##
##  We'll work with the AMMI-2 model, which here is called "bilinear2"
##
##  First, extract the contributions of the 5 terms in the model:
##
wheat.terms &lt;- termPredictors(bilinear2)
##
##  That's a matrix, whose 4th and 5th columns are the interaction terms
##
##  Combine those two interaction terms, to get the total estimated
##  interaction effect:
##
wheat.interaction &lt;- wheat.terms[, 4] + wheat.terms[, 5]
##
##  That's a vector, so we need to re-shape it as a 24 by 10 matrix
##  ready for calculating the SVD:
##
wheat.interaction &lt;- matrix(wheat.interaction, 24, 10)
##
##  Now we can compute the SVD:
##
wheat.interaction.SVD &lt;- svd(wheat.interaction)
##
##  Only the first two singular values are nonzero, as expected
##  (since this is an AMMI-2 model, the interaction has rank 2)
##
##  So the result object can be simplified by re-calculating the SVD with
##  just two dimensions:
##
wheat.interaction.SVD &lt;- svd(wheat.interaction, nu = 2, nv = 2)
</code></pre>

<hr>
<h2 id='yaish'> Class Mobility by Level of Education in Israel</h2><span id='topic+yaish'></span>

<h3>Description</h3>

<p>A 3-way contingency table of father/son pairs, classified by father's
social class (<code>orig</code>), son's social class (<code>dest</code>) and son's 
education level (<code>educ</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yaish</code></pre>


<h3>Format</h3>

<p>A table of counts, with classifying factors <code>educ</code> (levels <code>1:5</code>),
<code>orig</code> (levels <code>1:7</code>) and <code>dest</code> (levels <code>1:7</code>).
</p>


<h3>Author(s)</h3>

<p>David Firth</p>


<h3>Source</h3>

<p>Originally in Yaish (1998), see also Yaish (2004, p316).</p>


<h3>References</h3>

<p>Yaish, M (1998). Opportunities, Little Change. Class Mobility in
Israeli Society: 1974-1991.  D.Phil. Thesis, Nuffield College,
University of Oxford. 
</p>
<p>Yaish, M (2004).  <em>Class Mobility Trends in Israeli Society, 1974-1991.</em>
Lewiston: Edwin Mellen Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

## Fit the "UNIDIFF" mobility model across education levels, leaving out
## the uninformative subtable for dest == 7:
##
unidiff &lt;- gnm(Freq ~ educ*orig + educ*dest +
                     Mult(Exp(educ), orig:dest), family = poisson,
                     data = yaish, subset = (dest != 7))
## Deviance should be 200.3, 116 d.f.
##
## Look at the multipliers of the orig:dest association:
ofInterest(unidiff) &lt;- pickCoef(unidiff, "[.]educ")
coef(unidiff)
##
## Coefficients of interest:
## Mult(Exp(.), orig:dest).educ1 Mult(Exp(.), orig:dest).educ2 
##                    -0.5513258                    -0.7766976 
## Mult(Exp(.), orig:dest).educ3 Mult(Exp(.), orig:dest).educ4 
##                    -1.2947494                    -1.5902644 
## Mult(Exp(.), orig:dest).educ5 
##                    -2.8008285 
##
## Get standard errors for the contrasts with educ1:
##
getContrasts(unidiff, ofInterest(unidiff))
##                                 estimate        SE    quasiSE
## Mult(Exp(.), orig:dest).educ1  0.0000000 0.0000000 0.09757438
## Mult(Exp(.), orig:dest).educ2 -0.2253718 0.1611874 0.12885847
## Mult(Exp(.), orig:dest).educ3 -0.7434236 0.2335083 0.21182123
## Mult(Exp(.), orig:dest).educ4 -1.0389386 0.3434256 0.32609380
## Mult(Exp(.), orig:dest).educ5 -2.2495026 0.9453764 0.93560643
##                                 quasiVar
## Mult(Exp(.), orig:dest).educ1 0.00952076
## Mult(Exp(.), orig:dest).educ2 0.01660450
## Mult(Exp(.), orig:dest).educ3 0.04486823
## Mult(Exp(.), orig:dest).educ4 0.10633716
## Mult(Exp(.), orig:dest).educ5 0.87535940
##
## Table of model residuals:
##
residuals(unidiff)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
