<!DOCTYPE html><html><head><title>Help for package pleLMA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pleLMA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convergence.stats'><p>Computes statistics to assess convergence of the nominal model</p></a></li>
<li><a href='#convergenceGPCM'><p>Computes statistics to assess convergence for generalized partial credit models</p></a></li>
<li><a href='#dass'><p>Dateframe of responses to items from depression, anxiety, and stress scales</p></a></li>
<li><a href='#error.check'><p>Checks for basic errors in input to the 'ple.lma' function</p></a></li>
<li><a href='#fit.gpcm'><p>Fits LMA model where category scale values equal a_im * x_j</p></a></li>
<li><a href='#fit.independence'><p>Fits the log-linear model of independence</p></a></li>
<li><a href='#fit.nominal'><p>Fits the nominal model</p></a></li>
<li><a href='#fit.rasch'><p>Fits an LMA using fixed category scores</p></a></li>
<li><a href='#FitStack'><p>Up-dates association parameters of the nominal model</p></a></li>
<li><a href='#fitStackGPCM'><p>Up-dates association parameters of the GPCM by fitting model to stacked data</p></a></li>
<li><a href='#item.gpcm'><p>Estimates item parameters of LMA with linear restrictions on category scores</p></a></li>
<li><a href='#ItemData'><p>Prepares data for up-dating scale value parameters of nominal model</p></a></li>
<li><a href='#ItemGPCM.data'><p>Creates data frame up-dating phi parameters of the gpcm.</p></a></li>
<li><a href='#ItemLoop'><p>loops through items and up-dates estimates of scale values for each item in Nominal Model</p></a></li>
<li><a href='#iterationPlot'><p>Plots estimated parameters by iteration for the gpcm and nominal models</p></a></li>
<li><a href='#lma.summary'><p>Produces a summary of results</p></a></li>
<li><a href='#ple.lma'><p>Main function for estimating parameters of LMA models</p></a></li>
<li><a href='#reScaleItem'><p>Re-scales the category scale values and Phi after convergence of the nominal model</p></a></li>
<li><a href='#Scale'><p>Imposes scaling constraint to identify parameters of the LMA (nominal) model</p></a></li>
<li><a href='#ScaleGPCM'><p>Imposes scaling constraint to identify parameters of LMA (GPCM)</p></a></li>
<li><a href='#scalingPlot'><p>Graphs estimated scale values by integers of the LMA (nominal) model</p></a></li>
<li><a href='#set.up'><p>Sets up the data based on input data and model specifications</p></a></li>
<li><a href='#StackData'><p>Prepares data for up-dating association parameters of a multidimensional nominal LMA</p></a></li>
<li><a href='#StackDataGPCM'><p>Prepares data for up-dating association parameters of LMA (GPCM) model</p></a></li>
<li><a href='#theta.estimates'><p>Computes estimates of theta (values on latent trait(s)) for all LMA models</p></a></li>
<li><a href='#vocab'><p>Dataframe of response to vocabulary items from the 2018 General Social Survey</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pseudo-Likelihood Estimation of Log-Multiplicative Association
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Carolyn J. Anderson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carolyn J. Anderson &lt;cja@illinois.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Log-multiplicative association models (LMA) are
    models for cross-classifications of categorical variables
    where interactions are represented by products of category
    scale values and an association parameter. Maximum
    likelihood estimation (MLE) fails for moderate to large
    numbers of categorical variables. The 'pleLMA' package
    overcomes this limitation of MLE by using pseudo-likelihood
    estimation to fit the models to small or large
    cross-classifications dichotomous or multi-category variables.
    Originally proposed by Besag (1974,
    &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1974.tb00999.x">doi:10.1111/j.2517-6161.1974.tb00999.x</a>&gt;), pseudo-likelihood
    estimation takes large complex models and breaks it down
    into smaller ones. Rather than maximizing the likelihood
    of the joint distribution of all the variables, a
    pseudo-likelihood function, which is the product likelihoods
    from conditional distributions, is maximized. LMA models can
    be derived from a number of different frameworks including
    (but not limited to) graphical models and uni-dimensional
    and multi-dimensional item response theory models. More
    details about the models and estimation can be found in
    the vignette.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>mlogit, dfidx, stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-01 17:05:14 UTC; cja</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-05 23:20:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='convergence.stats'>Computes statistics to assess convergence of the nominal model</h2><span id='topic+convergence.stats'></span>

<h3>Description</h3>

<p>For the nominal model, convergence statistics are computed for each item, as
well as the algorithm as a whole. The main argument is the history or log
from fitting item regressions. The convergence statistics are the differences
between current values of the log likelihoods and item parameter estimates
and those from the previous iteration. The maximum over item of the
differences of the log likelihood values is used to determine convergence
of the pseudo-likelihood algorithm.  This function is used internally, but
it can also be used after fitting a model to examine how many iterations
are required for parameter estimates to get close to the final values
and whether any item parameters are still changing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convergence.stats(item.log, nitems, nless, LambdaName, NuName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convergence.stats_+3A_item.log">item.log</code></td>
<td>
<p>Iteration history of items' log likelihoods and parameter estimates</p>
</td></tr>
<tr><td><code id="convergence.stats_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="convergence.stats_+3A_nless">nless</code></td>
<td>
<p>Number of unique marginal terms (i.e., lambdas) and
unique category scale values(i.e., nus)</p>
</td></tr>
<tr><td><code id="convergence.stats_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Names of lambdas in item regressions</p>
</td></tr>
<tr><td><code id="convergence.stats_+3A_nuname">NuName</code></td>
<td>
<p>Names of nu in item regressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>diff.last   	 Differences between item loglikes &amp; parameters on last two iterations
</p>
<p>criterion.loglike  Maximum over items of the absolute value of LogLike differences
</p>
<p>criterion.items  Sum of item differences of item parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # 9 items from dass data for 250 cases
 data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]

#---   input for uni-dimensional
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)

 #--- Uni-dimensional Nominal Model
 n1 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj,inTraitAdj, tol=1e-02)

# Since this function in internal to fit.nominal, need to also run
 s &lt;- set.up(inData, model.type='nominal', inTraitAdj, inItemTraitAdj)

 convergence.stats(n1$item.log, n1$nitems, n1$nless, s$LambdaName, s$NuName)

#--- Multidimensional models
#--- re-define inTraitAdj and inItemTraitAdj for 3 dimensional models
  inTraitAdj  &lt;- matrix(1, nrow=3, ncol=3)

  dpress &lt;- matrix(c(1,0,0), nrow=3, ncol=3, byrow=TRUE)
  anxiety &lt;- matrix(c(0,1,0), nrow=3, ncol=3, byrow=TRUE)
  stress &lt;- matrix(c(0,0,1), nrow=3, ncol=3, byrow=TRUE)
  das &lt;- list(dpress, anxiety, stress)
  inItemTraitAdj &lt;- rbind(das[[1]], das[[2]], das[[3]])

#--- 3 dimensional nominal
  n3 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj, inTraitAdj, tol=1e-03)
  s &lt;- set.up(inData, model.type='nominal', inTraitAdj, inItemTraitAdj)
  convergence.stats(n3$item.log, n3$nitems, n3$nless, s$LambdaName, s$NuName)


</code></pre>

<hr>
<h2 id='convergenceGPCM'>Computes statistics to assess convergence for generalized partial credit models</h2><span id='topic+convergenceGPCM'></span>

<h3>Description</h3>

<p>For the generalized partial credit model, convergence statistics are computed
for each item, as well as the algorithm as a whole. The convergence statistics
are the differences between current values of the log likelihoods and item
parameter estimates and those from the previous iteration. The maximum over
items' differences of the log likelihood values is used to determine
convergence of the pseudo-likelihood algorithm. This function is used
internally, but it can also be used after fitting a model to examine how
many iterations are required for parameter estimates to get close to the
final values and whether any item parameters are still changing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convergenceGPCM(item.log, nitems, ncat, nless, LambdaName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convergenceGPCM_+3A_item.log">item.log</code></td>
<td>
<p>Iteration history of items' log likelihoods and parameter estimates</p>
</td></tr>
<tr><td><code id="convergenceGPCM_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="convergenceGPCM_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="convergenceGPCM_+3A_nless">nless</code></td>
<td>
<p>Number of unique lambdas</p>
</td></tr>
<tr><td><code id="convergenceGPCM_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Names of lambdas in formula used to fit item regressions (internal to fit_gpcm)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>diff.last   	       Differences between item's log likelihoods and parameters for each item
</p>
<p>criterion.loglike   Maximum overs item of the absolute value of differences between item LogLike values
</p>
<p>criterions.items    Sum of item differences of their parameters
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 9 items from dass data for 250 cases
 data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]

 #---   input for uni-dimensional
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)
 

 #--- fit Unidiemsional gpcm Model
 g1&lt;- ple.lma(inData, model.type="gpcm",inItemTraitAdj,inTraitAdj, tol= 1e-03)

 # Since convergenceGPCM is internal to fit.gpcm, need to get 'Lambdaname'
 s &lt;- set.up(inData, model.type='gpcm', inTraitAdj, inItemTraitAdj)

 convergenceGPCM(g1$item.log, g1$nitems, g1$ncat, g1$nless, s$LambdaName)

#--- Multidimensional models
#--- re-define inTraitAdj and inItemTraitAdj for 3 dimensional models
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]
 inTraitAdj  &lt;- matrix(1, nrow=3, ncol=3)
 dpress &lt;- matrix(c(1,0,0), nrow=3, ncol=3, byrow=TRUE)
 anxiety &lt;- matrix(c(0,1,0), nrow=3, ncol=3, byrow=TRUE)
 stress &lt;- matrix(c(0,0,1), nrow=3, ncol=3, byrow=TRUE)
 das &lt;- list(dpress, anxiety, stress)
 inItemTraitAdj &lt;- rbind(das[[1]], das[[2]], das[[3]])

#--- 3 dimensional gpcm
 g3 &lt;- ple.lma(inData, model.type="gpcm", inItemTraitAdj, inTraitAdj, tol=1e-03)
 s &lt;- set.up(inData, model.type='gpcm', inTraitAdj, inItemTraitAdj)
 convergenceGPCM(g1$item.log, g1$nitems, g1$ncat, g1$nless, s$LambdaName)


</code></pre>

<hr>
<h2 id='dass'>Dateframe of responses to items from depression, anxiety, and stress scales</h2><span id='topic+dass'></span>

<h3>Description</h3>

<p>The dass data are responses from a random sample of 1,000 individuals
collected during the period 2017 &ndash; 2019. The data were retrieved July
2020.  The items included here are on scales designed to measure
depression (14 items), anxiety (13 items), and stress (15 items).  The
42 items were presented online and in random order.  Respondents were
instructed to consider the last week when responding to the items using the
following categories:
(1) Did not apply to me at all;
(2) Applied to me to some degree, or some of the time;
(3) Applied to me to a considerable degree, or a good part of the time;
(4) Applied to me very much, or most of the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dass
</code></pre>


<h3>Format</h3>

<p>A data frame with 1,000 rows (respondents) and 42 columns (items):
</p>

<dl>
<dt>d1</dt><dd><p>I couldn't seem to experience any positive feeling at all.</p>
</dd>
<dt>d2</dt><dd><p>I just couldn't seem to get going</p>
</dd>
<dt>d3</dt><dd><p>I felt that I had nothing to look forward to</p>
</dd>
<dt>d4</dt><dd><p>I felt sad and depressed</p>
</dd>
<dt>d5</dt><dd><p>I felt that I had lost interest in just about everything</p>
</dd>
<dt>d6</dt><dd><p>I felt I wasn't worth much as a person</p>
</dd>
<dt>d7</dt><dd><p>I felt that life wasn't worthwhile</p>
</dd>
<dt>d8</dt><dd><p>I couldn't seem to get any enjoyment out of the things I did</p>
</dd>
<dt>d9</dt><dd><p>I felt down-hearted and blue</p>
</dd>
<dt>d10</dt><dd><p>I was unable to become enthusiastic about anything</p>
</dd>
<dt>d11</dt><dd><p>I felt I was pretty worthless</p>
</dd>
<dt>d12</dt><dd><p>I could see nothing in the future to be hopeful about</p>
</dd>
<dt>d13</dt><dd><p>I felt that life was meaningless</p>
</dd>
<dt>d14</dt><dd><p>I found it difficult to work up the initiative to do things</p>
</dd>
<dt>a1</dt><dd><p>I was aware of dryness of my mouth</p>
</dd>
<dt>a2</dt><dd><p>I experienced breathing difficulty (eg, excessively rapid
breathing, breathlessness in the absence of physical exertion)</p>
</dd>
<dt>a3</dt><dd><p>I had a feeling of shakiness (eg, legs going to give way)</p>
</dd>
<dt>a4</dt><dd><p>I felt that I was using a lot of nervous energy</p>
</dd>
<dt>a5</dt><dd><p>I had a feeling of faintness</p>
</dd>
<dt>a6</dt><dd><p>I perspired noticeably (eg, hands sweaty) in the absence of high
temperatures or physical exertion</p>
</dd>
<dt>a7</dt><dd><p>I felt scared without any good reason</p>
</dd>
<dt>a8</dt><dd><p>I had difficulty in swallowing</p>
</dd>
<dt>a9</dt><dd><p>I was aware of the action of my heart in the absence of physical
exertion (eg, sense of heart rate increase, heart missing a beat)</p>
</dd>
<dt>a10</dt><dd><p>I felt I was close to panic</p>
</dd>
<dt>a11</dt><dd><p>I felt terrified</p>
</dd>
<dt>a12</dt><dd><p>I was worried about situations in which I might panic and make a
fool of myself</p>
</dd>
<dt>a13</dt><dd><p>I experienced trembling (eg, in the hands)</p>
</dd>
<dt>s1</dt><dd><p>I found myself getting upset by quite trivial things</p>
</dd>
<dt>s2</dt><dd><p>I tended to over-react to situations</p>
</dd>
<dt>s3</dt><dd><p>I found it difficult to relax</p>
</dd>
<dt>s4</dt><dd><p>I found myself in situations that made me so anxious I was most
relieved when they ended</p>
</dd>
<dt>s5</dt><dd><p>I found myself getting upset rather easily</p>
</dd>
<dt>s6</dt><dd><p>I found myself getting impatient when I was delayed in any way
(eg, elevators, traffic lights, being kept waiting)</p>
</dd>
<dt>s7</dt><dd><p>I felt that I was rather touchy</p>
</dd>
<dt>s8</dt><dd><p>I found it hard to wind down</p>
</dd>
<dt>s9</dt><dd><p>I found that I was very irritable</p>
</dd>
<dt>s10</dt><dd><p>I found it hard to calm down after something upset me</p>
</dd>
<dt>s11</dt><dd><p>I feared that I would be thrownnoff by some trivial but
unfamiliar task</p>
</dd>
<dt>s12</dt><dd><p>I found it difficult to tolerate interruptions to what I was
doing</p>
</dd>
<dt>s13</dt><dd><p>I was in a state of nervous tension</p>
</dd>
<dt>s14</dt><dd><p>I was intolerant of anything that kept me from getting on with
what I was doing</p>
</dd>
<dt>s15</dt><dd><p>I found myself getting agitated</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://openpsychometrics.org">https://openpsychometrics.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dass)
head(dass)

</code></pre>

<hr>
<h2 id='error.check'>Checks for basic errors in input to the 'ple.lma' function</h2><span id='topic+error.check'></span>

<h3>Description</h3>

<p>This functions looks at the input to the main function (ple.lma) and checks
for 11 different possible errors. If an error is detected, the function
issues a warning and stops any further execution.  This funcion is internal
to 'ple.lma' but can be used outside of the wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error.check(inData, model.type, inTraitAdj = NULL, inItemTraitAdj = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error.check_+3A_indata">inData</code></td>
<td>
<p>Data frame with columns corresponding to categorical variables
and rows to the number of cases</p>
</td></tr>
<tr><td><code id="error.check_+3A_model.type">model.type</code></td>
<td>
<p>Type of model that will be fit to data</p>
</td></tr>
<tr><td><code id="error.check_+3A_intraitadj">inTraitAdj</code></td>
<td>
<p>Trait x Trait adjacency matrix (not required for independence)</p>
</td></tr>
<tr><td><code id="error.check_+3A_initemtraitadj">inItemTraitAdj</code></td>
<td>
<p>Item x Trait adjacency matrix (not required for independence)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Message whether error was detected in input, and if so the nature of the error
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #--- some data
 data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]

 #--- no errors
 error.check(inData, model.type="independence")

 #--- for unidimensional
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)

 #--- no errors
 error.check(inData, model.type="rasch", inTraitAdj, inItemTraitAdj)
 error.check(inData, model.type="gpcm", inTraitAdj, inItemTraitAdj)
 error.check(inData, model.type="nominal", inTraitAdj, inItemTraitAdj)


</code></pre>

<hr>
<h2 id='fit.gpcm'>Fits LMA model where category scale values equal a_im * x_j</h2><span id='topic+fit.gpcm'></span>

<h3>Description</h3>

<p>Function estimates the parameters of LMA models with fixed category scores
multiplied by an item weight parameter. This function can be used to estimate
the LMA model corresponding to is a generalized partial credit model for
multi-category items and the 2 parameter logistic model for dichotomous
items. The function sets up log objects and model formula.  In the case of
unidimensional models, the function iterates over item regressions; whereas,
for multidimensional models, the function iterates between the item and phi
regressions.  This function is called from 'ple.lma', but can be run outside
of 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.gpcm(
  Master,
  Phi.mat,
  PersonByItem,
  TraitByTrait,
  item.by.trait,
  tol,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  Maxnphi,
  pq.mat,
  starting.sv,
  ItemNames,
  LambdaName,
  LambdaNames,
  PhiNames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.gpcm_+3A_master">Master</code></td>
<td>
<p>Master data set in long format</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_phi.mat">Phi.mat</code></td>
<td>
<p>Matrix of starting values of association parameters</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_personbyitem">PersonByItem</code></td>
<td>
<p>Person by item matrix of responses (same as inData)</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_traitbytrait">TraitByTrait</code></td>
<td>
<p>Trait by trait adjacency matrix (same as inTraitAdj)</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_item.by.trait">item.by.trait</code></td>
<td>
<p>Item by trait vector indicating trait item load on (same as inItemTraitAdj)</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_tol">tol</code></td>
<td>
<p>Criterion used to determine convergence</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories per item</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_nless">nless</code></td>
<td>
<p>Number of categories minus 1 (i.e., unique lambdas)</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of latent traits</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_maxnphi">Maxnphi</code></td>
<td>
<p>Number of phi parameters to be estimated</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_pq.mat">pq.mat</code></td>
<td>
<p>Used to compute rest-scores and totals</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Fixed category scores</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_itemnames">ItemNames</code></td>
<td>
<p>Names of items needed label output</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Names of lambdas needed for formula of the item regressions</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_lambdanames">LambdaNames</code></td>
<td>
<p>Names of lambdas needed for formula of the stacked regression</p>
</td></tr>
<tr><td><code id="fit.gpcm_+3A_phinames">PhiNames</code></td>
<td>
<p>Name of phi parameters (Null for uni-dimensional models)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>item.log		  History over iterations of the algorithm for items' log likelihood,
lambda, and a parameter
</p>
<p>phi.log			  History over iterations of the algorithm for log likelihood, lambdas
nd phi parameters
</p>
<p>criterion		  Current value of the convergence statistic which is the maximum of items'
absolute differences between the current and previous value of the log
likelihood
</p>
<p>estimates   	An item by parameter matrix of estimated item parameter where the
first column are items' log likelihood
</p>
<p>Phi.mat	   	  Estimated matrix of association parameters
</p>
<p>fitem		      Formula for item data
</p>
<p>fstack	      Formula for stacked data
</p>
<p>item.mlogit 	Summary from final run of mlogit for item regressions for each item
</p>
<p>phi.mlogit	  Summary from final run mlogit for stacked regression
</p>
<p>mlpl.item     Value of maximum of log ple function from fitting items (i.e., sum of logLike)
</p>
<p>mlpl.phi	    Value of maximum of log ple function from stacked regression to get phi estimates
</p>
<p>AIC           Akaike information criterion for pseudo-likelihood (smaller is better)
</p>
<p>BIC           Bayesian information criterion for pseudo-likelihood (smaller is better)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "a1","a2","s1","s2")]
 #--- unidimensional
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=6, ncol=1)

# Need to set up data
s &lt;- set.up(inData, model.type='gpcm', inTraitAdj, inItemTraitAdj, tol=1e-03)

g &lt;- fit.gpcm(s$Master, s$Phi.mat, s$PersonByItem, s$TraitByTrait,
              s$item.by.trait, s$tol, s$npersons, s$nitems, s$ncat,
              s$nless, s$ntraits, s$Maxnphi, s$pq.mat, s$starting.sv,
              s$ItemNames, s$LambdaName, s$LambdaNames, s$PhiNames)

</code></pre>

<hr>
<h2 id='fit.independence'>Fits the log-linear model of independence</h2><span id='topic+fit.independence'></span>

<h3>Description</h3>

<p>This function fits by the log-linear model of independence (i.e., only
includes marginal effect terms) using pseudo-likelihood estimation.
This provides a baseline model with which to compare other models.
The independence maximumn of the loglikehood can be used is a measure
of no association. The input to the function is only the Master data
set and the names of marginal effect terms and items, all of which
are created by the 'set.up' function.  This function is called from
'ple.lma' or can be run output of wrapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.independence(Master, LambdaNames, LambdaName, ItemNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.independence_+3A_master">Master</code></td>
<td>
<p>Master data set from set.up</p>
</td></tr>
<tr><td><code id="fit.independence_+3A_lambdanames">LambdaNames</code></td>
<td>
<p>Needed to define formula</p>
</td></tr>
<tr><td><code id="fit.independence_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Used for column names of matrix estimates</p>
</td></tr>
<tr><td><code id="fit.independence_+3A_itemnames">ItemNames</code></td>
<td>
<p>Used for row names of number of item by parameter matrix of
estimated Lambda parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phi.mlogit     Parameters estimates and mlpl = logLike output from mnlogit
</p>
<p>fstack          Formual used in stacked regression
</p>
<p>estimates       Item by parameter estimates matrix
</p>
<p>mlpl.phi        Maximum of log pseudo-likelihood from stacked regression
</p>
<p>AIC             Akaike information criterion for pseudo-likelihood (smaller is better)
</p>
<p>BIC             Bayesian information criterion for pseudo-likelihood (smaller is better)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- data and set-up
data(dass)
inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]
s &lt;- set.up(inData, model.type='independence')

#--- fit independence model
ind &lt;- fit.independence(s$Master, s$LambdaNames, s$LambdaName, s$ItemNames)

</code></pre>

<hr>
<h2 id='fit.nominal'>Fits the nominal model</h2><span id='topic+fit.nominal'></span>

<h3>Description</h3>

<p>Function estimates the parameters of LMA models where the category scale
are estimated. The function can be used to estimate the parameters of the
LMA model corresponding the nominal model (for multi-category items) and
the 2 parameter logistic model for dichotomous items. The function sets
up log object(s) and model formula.  In the case of unidimensional models,
the function iterates over item regressions; whereas, for multidimensional
models, the function iterates between the item and phi regressions. This
function is called from 'ple.lma', but can be run outside of 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.nominal(
  Master,
  Phi.mat,
  starting.sv,
  pq.mat,
  tol,
  PersonByItem,
  TraitByTrait,
  ItemByTrait,
  item.by.trait,
  ItemNames,
  LambdaNames,
  NuNames,
  LambdaName,
  NuName,
  PhiNames,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  Maxnphi
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.nominal_+3A_master">Master</code></td>
<td>
<p>Master data set in long format</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_phi.mat">Phi.mat</code></td>
<td>
<p>Matrix of starting values of the association parameters</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Matrix starting values category scale values</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_pq.mat">pq.mat</code></td>
<td>
<p>Array used compute rest scores and total scores</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_tol">tol</code></td>
<td>
<p>Value used to determine convergence of algorithm</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_personbyitem">PersonByItem</code></td>
<td>
<p>Same as inData (rows are response patterns)</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_traitbytrait">TraitByTrait</code></td>
<td>
<p>Same as inTraitAdj (trait x trait adjacency)</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_itembytrait">ItemByTrait</code></td>
<td>
<p>Same as inItemTraitAdj (item x trait adjacency)</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_item.by.trait">item.by.trait</code></td>
<td>
<p>One dimensional array indicating trait item loads on</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_itemnames">ItemNames</code></td>
<td>
<p>Names of items in inData (i.e. columns names of
categorical variables)</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_lambdanames">LambdaNames</code></td>
<td>
<p>Lambda names used in the Master and stacked data frames</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_nunames">NuNames</code></td>
<td>
<p>Nu names in Master data frame</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Lambda names in formula for items</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_nuname">NuName</code></td>
<td>
<p>Nu names in formula for item regressions</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_phinames">PhiNames</code></td>
<td>
<p>Association parameter names for stacked regression</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories per item</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_nless">nless</code></td>
<td>
<p>ncat-1 = number unique lambda and unique nus</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of traits</p>
</td></tr>
<tr><td><code id="fit.nominal_+3A_maxnphi">Maxnphi</code></td>
<td>
<p>Number of association parametets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>item.log 	 Iteration history of LogLike, lambda, and item parameters
</p>
<p>phi.log		 Iteration history of LogLike, lambdas and phi parameters
</p>
<p>criterion	 Current value of the convergence statistic
</p>
<p>estimates 	 Item x parameter matrix: LogLike, lambda and scale values
</p>
<p>Phi.mat	     Estimated conditional correlation matrix
</p>
<p>fitem		 Formula for item data
</p>
<p>fstack	     Formula for stacked data
</p>
<p>item.mlogit   Summaries from final run of mlogit for item regressions
</p>
<p>phi.mlogit	 Summary from final run of mlogit for stacked regression
</p>
<p>mlpl.item	 Max log pseudo-likelihood function from item regressions
</p>
<p>mlpl.phi      Maximum of log pseudo-likelihood function from stacked regression
</p>
<p>AIC           Akaike information criterion for pseudo-likelihood (smaller is better)
</p>
<p>BIC           Bayesian information criterion for pseudo-likelihood (smaller is better)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]
 #--- unidimensional
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)
 s &lt;- set.up(inData, model.type='nominal', inTraitAdj, inItemTraitAdj,
           tol=1e-02)

 n1 &lt;- fit.nominal(s$Master, s$Phi.mat, s$starting.sv, s$pq.mat, s$tol,
       s$PersonByItem, s$TraitByTrait, s$ItemByTrait, s$item.by.trait,
       s$ItemNames, s$LambdaNames,  s$NuNames, s$LambdaName, s$NuName,
       s$PhiNames, s$npersons, s$nitems, s$ncat,s$ nless, s$ntraits,
       s$Maxnphi)

</code></pre>

<hr>
<h2 id='fit.rasch'>Fits an LMA using fixed category scores</h2><span id='topic+fit.rasch'></span>

<h3>Description</h3>

<p>The LMA model with fixed category scores is fit by this function and
the model corresponds to models in the Rasch family of item response
models.  The category scores can be set by either the user or the
package defaults. The default category scores are equally spaced, sum to
zero, and sum of squares equal 1. Scores can be set by user by
specifying them in the item by category matrix of 'starting.sv'.  The
pseudo-likelihood algorithm only runs a single stacked regression.
This functionis called from' ple.lma' but can also be run outside
of the main wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.rasch(
  Master,
  npersons,
  nitems,
  ncat,
  nless,
  Maxnphi,
  pq.mat,
  starting.sv,
  LambdaNames,
  PhiNames,
  ItemNames,
  LambdaName,
  ntraits
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.rasch_+3A_master">Master</code></td>
<td>
<p>Master data set in long format</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_nless">nless</code></td>
<td>
<p>Number of unique Lambdas (i.e., ncat-1)</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_maxnphi">Maxnphi</code></td>
<td>
<p>Number of phi parameters</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_pq.mat">pq.mat</code></td>
<td>
<p>One dimensional array to compute rest-scores</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Fixed category scores</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_lambdanames">LambdaNames</code></td>
<td>
<p>Names of lambda paramters in Master and formula
for stacked regression</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_phinames">PhiNames</code></td>
<td>
<p>Names of association parameters</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_itemnames">ItemNames</code></td>
<td>
<p>Names of items</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Names of lambdas used in output</p>
</td></tr>
<tr><td><code id="fit.rasch_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of traits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimates 	  An item by parameter matrix of the maximum of the log likelihood,
estimated item parameters (i.e., Lambdas), and the values of
the fixed category scores.
</p>
<p>fstack	    	Formula for stacked regression
</p>
<p>phi.mlogit	Results from mlogit for stacked regression
</p>
<p>estimates    An item x parameter estimate matrix and fixed category scores used
</p>
<p>Phi.mat      Estimated phi parameters
</p>
<p>mlpl.phi     Value of maximum of log pseudo-likelihood function from the stacked regression
</p>
<p>AIC          Akaike information criterion for pseudo-likelihood (smaller is better)
</p>
<p>BIC          Bayesian information criterion for pseudo-likelihood (smaller is better)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #---  data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]
 #--- unidimensional
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)

 s &lt;- set.up(inData, model.type='rasch', inTraitAdj, inItemTraitAdj)

 r &lt;- fit.rasch(s$Master, s$npersons, s$nitems, s$ncat, s$nless, s$Maxnphi,
          s$pq.mat, s$starting.sv, s$LambdaNames, s$PhiNames, s$ItemNames,
          s$LambdaName, s$ntraits)

</code></pre>

<hr>
<h2 id='FitStack'>Up-dates association parameters of the nominal model</h2><span id='topic+FitStack'></span>

<h3>Description</h3>

<p>Discrete choice model (conditional multinominal logistic regression model)
is fit to stacked data to up-date the matrix of association parameters of
the LMA that corresponds to the nominal item response model. This is a
function internal to 'fit.nominal' and is used for multi-dimensional models.
The function is similar to 'fit.StackGPCM'. This function is unlikely to
be run outside of 'fit.nominal' or 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitStack(
  Master,
  item.log,
  phi.log,
  fstack,
  TraitByTrait,
  pq.mat,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  Maxnphi,
  PhiNames,
  LambdaNames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitStack_+3A_master">Master</code></td>
<td>
<p>Master data set from which stacked data is created</p>
</td></tr>
<tr><td><code id="FitStack_+3A_item.log">item.log</code></td>
<td>
<p>Last row contains current scale values (item.history)</p>
</td></tr>
<tr><td><code id="FitStack_+3A_phi.log">phi.log</code></td>
<td>
<p>Last row contains current estimates of phi</p>
</td></tr>
<tr><td><code id="FitStack_+3A_fstack">fstack</code></td>
<td>
<p>Formula for stacked regression</p>
</td></tr>
<tr><td><code id="FitStack_+3A_traitbytrait">TraitByTrait</code></td>
<td>
<p>inTraitAdj matrix</p>
</td></tr>
<tr><td><code id="FitStack_+3A_pq.mat">pq.mat</code></td>
<td>
<p>Summing array to get rest scores and totals</p>
</td></tr>
<tr><td><code id="FitStack_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="FitStack_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="FitStack_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories per item</p>
</td></tr>
<tr><td><code id="FitStack_+3A_nless">nless</code></td>
<td>
<p>Number of categories less 1 (unique lambdas &amp; unique nus)</p>
</td></tr>
<tr><td><code id="FitStack_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of latent traits</p>
</td></tr>
<tr><td><code id="FitStack_+3A_maxnphi">Maxnphi</code></td>
<td>
<p>Number of phis to be estimated</p>
</td></tr>
<tr><td><code id="FitStack_+3A_phinames">PhiNames</code></td>
<td>
<p>Names of the Phi parameters</p>
</td></tr>
<tr><td><code id="FitStack_+3A_lambdanames">LambdaNames</code></td>
<td>
<p>Names of lambdas that correspond to those in Master</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Phi.mat		 Matrix of up-dated estimates of assocation (phi) parameters
</p>
<p>phi.log 	 History of iterations log likelihood and estimates of
lambda and phi parameters
</p>

<hr>
<h2 id='fitStackGPCM'>Up-dates association parameters of the GPCM by fitting model to stacked data</h2><span id='topic+fitStackGPCM'></span>

<h3>Description</h3>

<p>Discrete choice model (conditional multinomial logistic regression) is fit to
stacked data to up-date matrix of association parameters of the LMA that
corresponds to the generalized partial credit model. This function is called
from 'fit.gpcm', which is called from 'ple.lma'.  It is unlikely that it
would be run outside of these wrappers.  It is only slightly different from
'fitStack' for nominal models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitStackGPCM(
  Master,
  item.log,
  phi.log,
  fstack,
  TraitByTrait,
  starting.sv,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  Maxnphi,
  pq.mat,
  LambdaNames,
  PhiNames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitStackGPCM_+3A_master">Master</code></td>
<td>
<p>Master data set from which stacked data is created</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_item.log">item.log</code></td>
<td>
<p>Needed to get most recent values of scale values (item.log)</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_phi.log">phi.log</code></td>
<td>
<p>History of estimates parameters from stacked regression</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_fstack">fstack</code></td>
<td>
<p>Forumla for stacked regression</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_traitbytrait">TraitByTrait</code></td>
<td>
<p>inTraitAdj matrix</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Fixed category scores</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories per item</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_nless">nless</code></td>
<td>
<p>Number of unique lambdas and unique nus per item</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of latent traits</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_maxnphi">Maxnphi</code></td>
<td>
<p>Number of phi parameters to bet estimated (NULL for 1 dimensional)</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_pq.mat">pq.mat</code></td>
<td>
<p>Used to compute rest-scores and totals</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_lambdanames">LambdaNames</code></td>
<td>
<p>Needed for formula and data for up-dating phi (stacked regresson)</p>
</td></tr>
<tr><td><code id="fitStackGPCM_+3A_phinames">PhiNames</code></td>
<td>
<p>Null for 1D models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Phi.mat	Up-dated matrix of phi parameters
</p>
<p>item.log of iterations for LogLike, Lambda and phi parameters
</p>

<hr>
<h2 id='item.gpcm'>Estimates item parameters of LMA with linear restrictions on category scores</h2><span id='topic+item.gpcm'></span>

<h3>Description</h3>

<p>This function is internal to the function 'fit.gpcm' and performs the item
regressions. It is a core function of the pseudo-likelihood algorithm for
items of the GPCM. The function calls function 'itemGPCM.data' to create
the data for input into 'mlogit', which is use to fit a conditional
multinomial model for each item.  The up-dated scale values are put into
the Master data frame and the 'item.log' array.  It generally would not
run outside of 'fit.gpcm' or 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>item.gpcm(
  Master,
  item.log,
  Phi.mat,
  fitem,
  TraitByTrait,
  PersonByItem,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  Maxnphi,
  pq.mat,
  starting.sv,
  LambdaName
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="item.gpcm_+3A_master">Master</code></td>
<td>
<p>Master data frame</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_item.log">item.log</code></td>
<td>
<p>History over iterations of items' log likelihood and
estimates of lambda, and item parameters</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_phi.mat">Phi.mat</code></td>
<td>
<p>Starting value of matrix of association parameters (optional)</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_fitem">fitem</code></td>
<td>
<p>Formula for item regressions</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_traitbytrait">TraitByTrait</code></td>
<td>
<p>Trait adjacency matrix (same as inTraitAdj)</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_personbyitem">PersonByItem</code></td>
<td>
<p>Same as inData</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories per item</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_nless">nless</code></td>
<td>
<p>Number of unique lambdas and unique nus per item</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of latent traits</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_maxnphi">Maxnphi</code></td>
<td>
<p>Number of phi parameters to bet estimated (NULL for 1 dimensional)</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_pq.mat">pq.mat</code></td>
<td>
<p>Used to compute rest-scores and totals</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Fixed category scores</p>
</td></tr>
<tr><td><code id="item.gpcm_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Lambda names for formula for items item regressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Master     	Master data frame with up-dated category scores for items
</p>
<p>item.log   	Up-dated history array over iterations of the algorithm
of items' log likelihood and estimated lambda and
alpha parameters
</p>

<hr>
<h2 id='ItemData'>Prepares data for up-dating scale value parameters of nominal model</h2><span id='topic+ItemData'></span>

<h3>Description</h3>

<p>This function creates a data frame, 'item data', to be used in the item
regressions for nominal models. It computes weighted rest scores and totals,
including correlated traits. This function is internal to 'ItemLoop' and
it is unlikely to be run outside of 'fit.nominal' or 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ItemData(
  Master,
  ItemID,
  Phi.mat = Phi.mat,
  npersons,
  nitems,
  ntraits,
  ncat,
  nless,
  TraitByTrait,
  pq.mat,
  LambdaName,
  NuName
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ItemData_+3A_master">Master</code></td>
<td>
<p>Master data frame</p>
</td></tr>
<tr><td><code id="ItemData_+3A_itemid">ItemID</code></td>
<td>
<p>The item for which scale values are being up-dated</p>
</td></tr>
<tr><td><code id="ItemData_+3A_phi.mat">Phi.mat</code></td>
<td>
<p>Current estimate conditional covariance matrix
(i.e., association paramters)</p>
</td></tr>
<tr><td><code id="ItemData_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="ItemData_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="ItemData_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of traits</p>
</td></tr>
<tr><td><code id="ItemData_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="ItemData_+3A_nless">nless</code></td>
<td>
<p>Number of unique lambdas and unique nus</p>
</td></tr>
<tr><td><code id="ItemData_+3A_traitbytrait">TraitByTrait</code></td>
<td>
<p>Same as inTraitAdj</p>
</td></tr>
<tr><td><code id="ItemData_+3A_pq.mat">pq.mat</code></td>
<td>
<p>One dimemsinal array used to get rest and totals scores</p>
</td></tr>
<tr><td><code id="ItemData_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Name of lambdas for in item regression</p>
</td></tr>
<tr><td><code id="ItemData_+3A_nuname">NuName</code></td>
<td>
<p>Name of nus in item regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ItemFit 	Data frame used to up-date scale values
</p>

<hr>
<h2 id='ItemGPCM.data'>Creates data frame up-dating phi parameters of the gpcm.</h2><span id='topic+ItemGPCM.data'></span>

<h3>Description</h3>

<p>This function creates a data frame, 'gpcm.item.data', to be used in the item
regressions of LMA models where category scales values are fixed. Sets up data
for up-dating alpha parameters of the LMA that corresponds to the GPCM. This
function is internal to 'item.gpcm' and it is unlikely to be run outside of
'fit.gpcm' or 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ItemGPCM.data(
  Master,
  ItemID,
  Phi.mat,
  TraitByTrait,
  pq.mat,
  starting.sv,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  LambdaName
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ItemGPCM.data_+3A_master">Master</code></td>
<td>
<p>Data frame of all data in long format</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_itemid">ItemID</code></td>
<td>
<p>Specifies the item for which a data frame is created to be
input into an item regression</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_phi.mat">Phi.mat</code></td>
<td>
<p>Starting value of matrix of association parameters</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_traitbytrait">TraitByTrait</code></td>
<td>
<p>Trait by trait adjacency matrix (same as inTraitAdj)</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_pq.mat">pq.mat</code></td>
<td>
<p>Array used to compute rest scores</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Matrix of item category scores that are fixed</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_nless">nless</code></td>
<td>
<p>Number of unique lambdas (ncat-1)</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of latent traits</p>
</td></tr>
<tr><td><code id="ItemGPCM.data_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Names for lambda for item regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gpcm.item.data  Data frame for item to be used up-dated in an item regression for specified item
</p>

<hr>
<h2 id='ItemLoop'>loops through items and up-dates estimates of scale values for each item in Nominal Model</h2><span id='topic+ItemLoop'></span>

<h3>Description</h3>

<p>This is a core function of the pseudo-likelihood algorithm for items of
the nominal model. The function calls function 'ItemData' to create
the data frame for input into 'mlogit', which is use to fit a conditional
multinomial model (i.e., a discrete choice model) for each item.  The
up-dated scale are put into the Master data frame and added to the
item.log array.  Generally the function would not run outside of
'fit.nominal' or 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ItemLoop(
  Master,
  item.log,
  Phi.mat = Phi.mat,
  PersonByItem,
  npersons,
  nitems,
  ntraits,
  ncat,
  nless,
  TraitByTrait,
  pq.mat,
  LambdaName,
  NuName,
  fitem
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ItemLoop_+3A_master">Master</code></td>
<td>
<p>Current master frame</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_item.log">item.log</code></td>
<td>
<p>Iteration history for the items parameters</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_phi.mat">Phi.mat</code></td>
<td>
<p>Current estimate of Phi.mat</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_personbyitem">PersonByItem</code></td>
<td>
<p>Person by item adjacency matrix (same as inData)</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of traits</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_nless">nless</code></td>
<td>
<p>Number of unique lambda and unique nus (ncat-1)</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_traitbytrait">TraitByTrait</code></td>
<td>
<p>TraitsByTrait adjacency matrix (sam as TraitAdj)</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_pq.mat">pq.mat</code></td>
<td>
<p>One dimensional array for computing rest-scores</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_lambdaname">LambdaName</code></td>
<td>
<p>Marginal effect names used in formula and item
data frame for item regressions</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_nuname">NuName</code></td>
<td>
<p>Scale values names in used in formula and item
data frame for item regressions</p>
</td></tr>
<tr><td><code id="ItemLoop_+3A_fitem">fitem</code></td>
<td>
<p>Formula for item regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Master	  Master data frame up-dated scale values for all items
</p>
<p>item.log  Iteration history of item parameters where the last
row showing results from the current iteration
</p>

<hr>
<h2 id='iterationPlot'>Plots estimated parameters by iteration for the gpcm and nominal models</h2><span id='topic+iterationPlot'></span>

<h3>Description</h3>

<p>This is a utility function that plots the estimated item parameters
by iterations.  The plots can be used to determine how many iterations
are required to get close to final values.  This functions can be used
uni- or multi-dimensional gpcm and models.  The number of pages equals
the number of items and each page has the plots of marginal effects
(left side) and category scale values or alph parameters (right).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterationPlot(model.fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterationPlot_+3A_model.fit">model.fit</code></td>
<td>
<p>Object from fitting nominal or gpcm model to data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots of estimated parameters by iteration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(dass)
inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]
#---   input for uni-dimensional
inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)

#--- generalized partial credit model
g1 &lt;- ple.lma(inData, model.type="gpcm", inItemTraitAdj, inTraitAdj)
iterationPlot(g1)

#--- nominal response model
n1 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj,inTraitAdj)
iterationPlot(n1)

#--- Multidimensional models
 inTraitAdj  &lt;- matrix(1, nrow=3, ncol=3)

dpress &lt;- matrix(c(1,0,0), nrow=3, ncol=3, byrow=TRUE)
anxiety &lt;- matrix(c(0,1,0), nrow=3, ncol=3, byrow=TRUE)
stress &lt;- matrix(c(0,0,1), nrow=3, ncol=3, byrow=TRUE)
das &lt;- list(dpress, anxiety, stress)
inItemTraitAdj &lt;- rbind(das[[1]], das[[2]], das[[3]])

g3 &lt;- ple.lma(inData, model.type="gpcm", inItemTraitAdj, inTraitAdj)
iterationPlot(g3)

n3 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj, inTraitAdj)
iterationPlot(n3)



</code></pre>

<hr>
<h2 id='lma.summary'>Produces a summary of results</h2><span id='topic+lma.summary'></span>

<h3>Description</h3>

<p>This utility function creates a summary list with five elements.
The first is a 'report' that contains a summary of characteristics
of the data, the model specification, convergence information,
and fit statistics. The second and third elements complete the
model specification and are the trait adjacency matrix
('TraitByTrait') and  the item x trait adjacency matrix
('ItemByTrait'), respectively. The fouth element, 'estimates',
contains a matrix of item parameters, and the fifth element,
'phi.mat' contains association parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lma.summary(model.fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lma.summary_+3A_model.fit">model.fit</code></td>
<td>
<p>A list object from fitting a model to data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results   A list with summary information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- 3 items from depression, anxiety and stress scales of
#    the daass for 250 cases
 data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]

#---  log-linear model of independence
 ind &lt;- ple.lma(inData, model.type="independence")
 noquote(lma.summary(ind))

#---   input for uni-dimensional
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)

#--- rasch family
 r1 &lt;- ple.lma(inData, model.type="rasch", inItemTraitAdj, inTraitAdj)
 lma.summary(r1)
 #--- Or if specific output is desired
 noquote(lma.summary(r1)$report)
 lma.summary(r1)$TraitByTrait
 lma.summary(r1)$ItemByTrait
 lma.summary(r1)$estimates
 lma.summary(r1)$phi


#--- generalized parial credit model
g1 &lt;- ple.lma(inData, model.type="gpcm", inItemTraitAdj, inTraitAdj, tol=1e-03)
lma.summary(g1)$report
lma.summary(g1)$estimates
lma.summary(g1)$phi

#--- nominal response model
n1 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj, inTraitAdj, tol=1e-03)
noquote(lma.summary(n1))


</code></pre>

<hr>
<h2 id='ple.lma'>Main function for estimating parameters of LMA models</h2><span id='topic+ple.lma'></span>

<h3>Description</h3>

<p>This function is a wrapper function that checks for errors in the input
(i.e., &lsquo;error.check&rsquo;),  sets up required objects and data (i.e., &lsquo;set.up&rsquo;),
calls function to fit specified model (either &lsquo;fit.independence&rsquo;,
fit.rasch', &lsquo;fit.gpcm&rsquo;, or  &lsquo;fit.nomial&rsquo;), and outputs an extensive
list of details and results. The required input for all models consist
of a data frame where elements are consecutive integers (1, 2, ...)
indicating the category chosen by each case/individual (rows) for
each variable (columns), and the model type.  For the LMA models that
correspond to item response theory models require an Item x Trait
adjacency matrix (&lsquo;inItemTraitAdj&rsquo;) and a Trait x Trait adjacency matrix
(&lsquo;inTraitAdj&rsquo;).  Optional input  include the tolerance  value (&lsquo;tol&rsquo;)
which is used to for determine whether the pseudo-likelihood algorithm
has converged for a gpcm or nominal model default=1e-6).  Additional
optional input (&lsquo;starting.sv&rsquo;) is an item by category a matrix of
starting scale values for the nominal model or fixed category scores
for the gpcm and rasch models. The default category scale values/scores
are eqaully spaced, centered at zero, and the sum of squared values
equals 1. The final optional input is a trait x trait (&lsquo;starting.phi&rsquo;)
matrix of starting values for the association parameter matrix
(default= identity matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ple.lma(
  inData,
  model.type,
  inItemTraitAdj = NULL,
  inTraitAdj = NULL,
  tol = NULL,
  starting.sv = NULL,
  starting.phi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ple.lma_+3A_indata">inData</code></td>
<td>
<p>A person x item data matrix or data frame with elements equal to reponse options choosen by an individual.</p>
</td></tr>
<tr><td><code id="ple.lma_+3A_model.type">model.type</code></td>
<td>
<p>Model to be fit (nominal, gpcm, rasch, independence) to data.</p>
</td></tr>
<tr><td><code id="ple.lma_+3A_initemtraitadj">inItemTraitAdj</code></td>
<td>
<p>An Item x Trait adjacency matrix indicating what trait an item loads on.</p>
</td></tr>
<tr><td><code id="ple.lma_+3A_intraitadj">inTraitAdj</code></td>
<td>
<p>A Trait x Trait adjacency matrix indicating relationship among traits.</p>
</td></tr>
<tr><td><code id="ple.lma_+3A_tol">tol</code></td>
<td>
<p>Convergence criterion, default = 1e-6</p>
</td></tr>
<tr><td><code id="ple.lma_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Starting category scale values/fixed scores</p>
</td></tr>
<tr><td><code id="ple.lma_+3A_starting.phi">starting.phi</code></td>
<td>
<p>Starting matrix of phi parameters (i.e., conditional covariance matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model.type     The model (nominal, gpcm, rash, or independence) that was fit to data
</p>
<p>TraitByTrait   The Trait x Trait adjacency matrix used.
</p>
<p>ItemByTrait    The Item x Trait adjacency matrix.
</p>
<p>item.by.trait  One dimensional version of ItemByTrait that gives the number of trait.
</p>
<p>ItemNames      Names of items in inData
</p>
<p>PhiNames       Names of the association parameters (i.e., phi)
</p>
<p>formula.item   Formula used to up-date item parameters via item regressions.
</p>
<p>formula.phi    Formula used to up-date association parameters via stacked regression.
</p>
<p>npersons       Number of persons in data set.
</p>
<p>nitems         Number of items.
</p>
<p>ncat           Number of categories per item.
</p>
<p>nless          Number of unique marginal effects &amp; unique scale values.
</p>
<p>Maxnphi        Number of association parameters estimated.
</p>
<p>ntraits        Number of traits.
</p>
<p>starting.sv    Starting scale values for nominal model or fixed scores for rasch or gpcm.
</p>
<p>tol            Used to determine convergence default= 1e-7
</p>
<p>criterion      Final value criterion at convergence
</p>
<p>item.log       Item iteration history plus maximum of the LogLike for each item
</p>
<p>phi.log        Assocation parameter iteration history
</p>
<p>estimates      Item x Parameter matrix where 1st column is max LogLike for each item and remaining columns are item parameter estimate
</p>
<p>Phi.mat        Estimated conditional correlation matrix
</p>
<p>item.mlogit   Output from final mlogit fit to items
</p>
<p>phi.mlogit    Output form final mlogit fit to stacked data
</p>
<p>mlpl.item      Max Log(pseudo-likelihood) function from item models (i.e. sum of first column of estimates)
</p>
<p>mlpl.phi       Max Log(pseudo-likelihood) function from stacked regression(s).
</p>
<p>AIC            Akaike information criterion for pseudo-likelihood (smaller is better)
</p>
<p>BIC            Bayesian information criterion for pseudo-likelihood (smaller is better)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#--- some data, 3 items from dpression, anxiety and stress scales
#    and only 250 cases out of possible 1000
 data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]

#---  log-linear model of independence
 ind &lt;- ple.lma(inData, model.type="independence")

#---   input for uni-dimensional
  inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
  inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)

#--- rasch family
 r1 &lt;- ple.lma(inData, model.type="rasch", inItemTraitAdj, inTraitAdj)

#---  rasch with alternative scores
 scores &lt;- matrix(c(0,1,2,3),nrow=9,ncol=4,byrow=TRUE)
 r1b &lt;- ple.lma(inData, model.type="rasch", inItemTraitAdj,
                inTraitAdj, starting.sv=scores)


#--- generalized partial credit model
g1 &lt;- ple.lma(inData, model.type="gpcm", inItemTraitAdj, inTraitAdj)

#--- gpcm with alternative scores
scores &lt;- matrix(c(0,1,2,3),nrow=9,ncol=4,byrow=TRUE)
g1b &lt;- ple.lma(inData, model.type="gpcm", inItemTraitAdj, inTraitAdj, starting.sv=scores)

#--- nominal response model
n1 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj,inTraitAdj)

#--- re-run nominal model with input starting values and phi
#    and setting stronger convergnce criterion.
sv &lt;- n1$estimates[, 6:9]
phi &lt;- n1$Phi.mat
n1b &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj,
               inTraitAdj, starting.sv=sv, starting.phi=phi, tol=1e-8)



#--- Multidimensional models
#--- re-define inTraitAdj and inItemTraitAdj for 3 dimensional models
  inTraitAdj  &lt;- matrix(1, nrow=3, ncol=3)

  dpress &lt;- matrix(c(1,0,0), nrow=3, ncol=3, byrow=TRUE)
  anxiety &lt;- matrix(c(0,1,0), nrow=3, ncol=3, byrow=TRUE)
  stress &lt;- matrix(c(0,0,1), nrow=3, ncol=3, byrow=TRUE)
  das &lt;- list(dpress, anxiety, stress)
  inItemTraitAdj &lt;- rbind(das[[1]], das[[2]], das[[3]])

#--- 3 dimensional rasch
  r3 &lt;- ple.lma(inData, model.type="rasch", inItemTraitAdj, inTraitAdj)


#--- 3 dimensional gpcm
  g3 &lt;- ple.lma(inData, model.type="gpcm", inItemTraitAdj, inTraitAdj)

#--- 3 dimensional nominal
  n3 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj, inTraitAdj)


#--- 2 parameter logistic IRT model fit to responses to
#    10 dichotomous Vocabulary items from from 2018 GSS
#    by 1309 respondents
  data(vocab)
  inItemTraitAdj &lt;- matrix(1, nrow=10, ncol=1)
  inTraitAdj &lt;- matrix(1, nrow=1, ncol=1)

#--- rasch irt
  rasch &lt;- ple.lma(inData=vocab, model.type="rasch", inItemTraitAdj, inTraitAdj, tol=1e-03)

#--- 2 pl as a gpcm model
  g.2pl &lt;- ple.lma(inData=vocab, model.type="gpcm", inItemTraitAdj, inTraitAdj, tol=1e-03)

#--- 2 pl as a nominal model
  n.2pl &lt;- ple.lma(inData=vocab, model.type="nominal", inItemTraitAdj, inTraitAdj, tol=1e-03)


</code></pre>

<hr>
<h2 id='reScaleItem'>Re-scales the category scale values and Phi after convergence of the nominal model</h2><span id='topic+reScaleItem'></span>

<h3>Description</h3>

<p>This auxillary function only applies to nominal models after estimating the
parameters of the model.  During estimation that scaling identification
constraint is put on conditional variances (i.e., phi_mm) such that they
equal 1. This function provide an alternative identification constraint
after the algorithm has converged. This function allow a user to tease
apart the strength and structure of associations. The alternative
scaling identification constraint is to set the sum of category scale
values equals 0 and the sum of squares equal to 1. The phi parameters
are adjusted accordingly. Only one item per trait should be selected for
the identification constraint and this is indicated by the object anchor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reScaleItem(model.fit, anchor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reScaleItem_+3A_model.fit">model.fit</code></td>
<td>
<p>Model object for a nominal model</p>
</td></tr>
<tr><td><code id="reScaleItem_+3A_anchor">anchor</code></td>
<td>
<p>Indicator of item(s) to place scaling constraint on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sNu         	Re-scaled category scale values
</p>
<p>sPhi.mat	  	Re-scale phi matrix (conditional covariance matrix)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#--- 3 items from depression, anxiety, and stress scales
#    for 250 cases out of possible 1000
data(dass)
inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]
inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)
#--- nominal response model
n1 &lt;- ple.lma(inData, model.type="nominal",inItemTraitAdj,inTraitAdj,tol=1e-03)
anchor &lt;- c(1,0,0,0,0,0,0,0,0)
reScaleItem(model.fit=n1, anchor)

#--- Multidimensional models
inTraitAdj  &lt;- matrix(1, nrow=3, ncol=3)
dpress &lt;- matrix(c(1,0,0), nrow=3, ncol=3, byrow=TRUE)
anxiety &lt;- matrix(c(0,1,0), nrow=3, ncol=3, byrow=TRUE)
stress &lt;- matrix(c(0,0,1), nrow=3, ncol=3, byrow=TRUE)
das &lt;- list(dpress, anxiety, stress)
inItemTraitAdj &lt;- rbind(das[[1]], das[[2]], das[[3]])

n3 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj, inTraitAdj, tol=1e-03)
anchor &lt;- c(1,0,0, 0,1,0, 1,0,0)
reScaleItem(model.fit=n3, anchor)



</code></pre>

<hr>
<h2 id='Scale'>Imposes scaling constraint to identify parameters of the LMA (nominal) model</h2><span id='topic+Scale'></span>

<h3>Description</h3>

<p>Scaling is internal to the function 'fit.nominal', which corresponds
the the nominal item response theory model.  It imposes the required
scaling identification constraint by transforming the conditional
covariance matrix 'Phi.mat' to a conditional correlation matrix (i.e.,
set phi_mm=1 for all m). The inverse transformation is applied to
the current category scale value estimates and these are put back
into the Master data frame so that data are ready for the next
iteration of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Scale(
  Master,
  item.log,
  Phi.mat,
  PersonByItem,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  item.by.trait
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Scale_+3A_master">Master</code></td>
<td>
<p>Current Master data frame.</p>
</td></tr>
<tr><td><code id="Scale_+3A_item.log">item.log</code></td>
<td>
<p>Iteration history of LogLike, lambda, and item parameters</p>
</td></tr>
<tr><td><code id="Scale_+3A_phi.mat">Phi.mat</code></td>
<td>
<p>Current phi matrix</p>
</td></tr>
<tr><td><code id="Scale_+3A_personbyitem">PersonByItem</code></td>
<td>
<p>inData</p>
</td></tr>
<tr><td><code id="Scale_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="Scale_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="Scale_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="Scale_+3A_nless">nless</code></td>
<td>
<p>Number of unique nus (ncat-1)</p>
</td></tr>
<tr><td><code id="Scale_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of (latent) dimensions</p>
</td></tr>
<tr><td><code id="Scale_+3A_item.by.trait">item.by.trait</code></td>
<td>
<p>Indicates the trait an item load on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Master       Master frame with re-scaled scale values
</p>
<p>Phi.mat		   Re-scaled matrix of association parameters
</p>

<hr>
<h2 id='ScaleGPCM'>Imposes scaling constraint to identify parameters of LMA (GPCM)</h2><span id='topic+ScaleGPCM'></span>

<h3>Description</h3>

<p>Scaling is internal to the function 'fit.gpcm', which fits the GPCM
version of the LMA. It imposes the required scaling identification
constraint by transforming the conditional covariance matrix 'Phi.mat' to a
conditional correlation matrix. The inverse transformation is applied to the
current estimates of the slope or 'a' parameters. Category scale values are
recomputed using the re-scale slopes (i.e., nu= a*x) and these are put back
into the Master data set so that data are ready for the next iteration of the
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScaleGPCM(
  Master,
  item.log,
  Phi.mat,
  PersonByItem,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  starting.sv,
  item.by.trait
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ScaleGPCM_+3A_master">Master</code></td>
<td>
<p>Master/main data set</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_item.log">item.log</code></td>
<td>
<p>Iteration history array, last row are current parameters</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_phi.mat">Phi.mat</code></td>
<td>
<p>Current phi matrix</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_personbyitem">PersonByItem</code></td>
<td>
<p>inData (response patterns)</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_nless">nless</code></td>
<td>
<p>Number of unique lambdas (ncat-1)</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of latent traits</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Matrix of fixed category scores (nitems x ncat)</p>
</td></tr>
<tr><td><code id="ScaleGPCM_+3A_item.by.trait">item.by.trait</code></td>
<td>
<p>Object that indicates which trait item loads on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Master   Master data set with re-scaled scale values
</p>
<p>Phi.mat	 Re-scaled matrix of association parameters
</p>

<hr>
<h2 id='scalingPlot'>Graphs estimated scale values by integers of the LMA (nominal) model</h2><span id='topic+scalingPlot'></span>

<h3>Description</h3>

<p>This function plots the estimated item scale values (i.e, nus) by integers
to see shape of scaling of the categories.A linear regression is overlaid
in the plot to help assess linearity. The dashed red line overlaid in the
plot is the linear regression line of the scale values on integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scalingPlot(model.fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scalingPlot_+3A_model.fit">model.fit</code></td>
<td>
<p>Output from a nominal model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots of estimated scale values by integers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#--- some data, 2 items from depression, anxiety and stress scales
#    for 250 cases out of possible 1000
 data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "a1", "a2", "s1", "s2")]
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=6, ncol=1)
 n1 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj, inTraitAdj, tol=1e-03)
 scalingPlot(n1)

</code></pre>

<hr>
<h2 id='set.up'>Sets up the data based on input data and model specifications</h2><span id='topic+set.up'></span>

<h3>Description</h3>

<p>This function sets up the data and sets constants that are essentially
the same for all models. This is used within the main wrapper function 
&lsquo;ple.lma&rsquo;, but can also be run independently. If a user wants to run 
the functions &lsquo;fit.independence&rsquo;, &lsquo;fit.rasch&rsquo;, &lsquo;fit.gpcm&rsquo;, or &lsquo;fit.nominal&rsquo;,
the set up function should be run prior to using these functions to 
create required input. Such an approach can speed up replication studies 
because &lsquo;set.up&rsquo; would only need to be run once and the response vector 
(i.e., named &lsquo;y&rsquo;) in the Master data frame be replaced by a new one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.up(
  inData,
  model.type,
  inTraitAdj = NULL,
  inItemTraitAdj = NULL,
  tol = NULL,
  starting.sv = NULL,
  starting.phi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.up_+3A_indata">inData</code></td>
<td>
<p>A person x item Data frame with response patterns</p>
</td></tr>
<tr><td><code id="set.up_+3A_model.type">model.type</code></td>
<td>
<p>Type of model to be fit</p>
</td></tr>
<tr><td><code id="set.up_+3A_intraitadj">inTraitAdj</code></td>
<td>
<p>Trait x Trait adjacency matrix (NULL for independence)</p>
</td></tr>
<tr><td><code id="set.up_+3A_initemtraitadj">inItemTraitAdj</code></td>
<td>
<p>Item x Trait adjacency matrix (NULL for independence)</p>
</td></tr>
<tr><td><code id="set.up_+3A_tol">tol</code></td>
<td>
<p>Tolerence for deteriming convergence (default: 1e-06)</p>
</td></tr>
<tr><td><code id="set.up_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Starting category scale values/fixed scores (default: sum equal to zero and sum of squares equal to 1)</p>
</td></tr>
<tr><td><code id="set.up_+3A_starting.phi">starting.phi</code></td>
<td>
<p>optional: Starting phi matrix (default:  identity matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PersonByItem   inData (rows are response patterns)
</p>
<p>TraitByTrait   Trait x Trait adjacency matrix
</p>
<p>ItemByTrait    Item x Trait adjacency matrix
</p>
<p>item.by.trait  Need for re-scaling phi.mat
</p>
<p>starting.sv		An item by number of category matrix with starting values for scale values for nominal model and fixed category scores for gpcm and rasch models
</p>
<p>ItemNames      Names of items in inData and PersonByItem
</p>
<p>LambdaName     Short list of lambda names needed for item regressions
</p>
<p>NuName         Short list of nu names names needed for item regressions
</p>
<p>LambdaNames    Long list of lambdas using in Master data set
</p>
<p>NuNames        Long list of nu using in Master data set
</p>
<p>PhiNames       Names of the unique phi parameters
</p>
<p>npersons       Number of individual or persons in data
</p>
<p>nitems         Number of items
</p>
<p>ncat         	Number of categories
</p>
<p>nless          Number of unique lambdas and unique nus
</p>
<p>ntraits        Number of traits
</p>
<p>Maxnphi        Number of phis to estimate
</p>
<p>Nstack         Length of master data set
</p>
<p>pq.mat         An array used to computed (weighted) rest-scores
</p>
<p>Phi.mat        A number of traits x number of traits Phi matrix (defual: the identity matrix)
</p>
<p>Master         Master data set formated for input to to mlogit
</p>
<p>tol            Tolerence for deteriming convergence
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]

 #--- to set data up for model of independence
 ind.setup &lt;- set.up(inData, model.type="independence")

 #--- for model specification for uni-dimensional models
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)

 i.setup &lt;- set.up(inData, model.type='independence')
 
 r.setup &lt;- set.up(inData, model.type='rasch', inTraitAdj,
                  inItemTraitAdj)

 g.setup &lt;- set.up(inData, model.type='gpcm', inTraitAdj,
                  inItemTraitAdj)

 n.setup &lt;- set.up(inData, model.type='nominal', inTraitAdj,
                  inItemTraitAdj)

</code></pre>

<hr>
<h2 id='StackData'>Prepares data for up-dating association parameters of a multidimensional nominal LMA</h2><span id='topic+StackData'></span>

<h3>Description</h3>

<p>Prepares data frame for input to 'mnlogit' for the stacked regression 
to obtain association parameters of the multidimensional LMA models
corresponding to the Nominal item response model. This function is
called from 'fit.nominal'. It generally would not run outside of 
either 'fit.nominal' or 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StackData(
  Master,
  item.log,
  phi.log,
  pq.mat,
  npersons,
  nitems,
  ncat,
  nless,
  ntraits,
  Maxnphi,
  PhiNames,
  LambdaNames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StackData_+3A_master">Master</code></td>
<td>
<p>Master data frame from which stacked data is created</p>
</td></tr>
<tr><td><code id="StackData_+3A_item.log">item.log</code></td>
<td>
<p>Last row contains current scale values (item.history)</p>
</td></tr>
<tr><td><code id="StackData_+3A_phi.log">phi.log</code></td>
<td>
<p>Last row contains current estimates of phi</p>
</td></tr>
<tr><td><code id="StackData_+3A_pq.mat">pq.mat</code></td>
<td>
<p>Summing array to get rest scores and totals</p>
</td></tr>
<tr><td><code id="StackData_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="StackData_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="StackData_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories per item</p>
</td></tr>
<tr><td><code id="StackData_+3A_nless">nless</code></td>
<td>
<p>Number of categories less 1 (i.e., unique lambdas and unique nus)</p>
</td></tr>
<tr><td><code id="StackData_+3A_ntraits">ntraits</code></td>
<td>
<p>Number of latent traits</p>
</td></tr>
<tr><td><code id="StackData_+3A_maxnphi">Maxnphi</code></td>
<td>
<p>Number of phis to be estimated</p>
</td></tr>
<tr><td><code id="StackData_+3A_phinames">PhiNames</code></td>
<td>
<p>Names of the Phi parameters</p>
</td></tr>
<tr><td><code id="StackData_+3A_lambdanames">LambdaNames</code></td>
<td>
<p>Names of lambdas that correspond to those in Master</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Phi.mat		Up-dated matrix of phi parameters
</p>
<p>phi.log 	History of iterations for LogLike, Lambda and phi parameters
</p>

<hr>
<h2 id='StackDataGPCM'>Prepares data for up-dating association parameters of LMA (GPCM) model</h2><span id='topic+StackDataGPCM'></span>

<h3>Description</h3>

<p>Prepares data frame for input to 'mnlogit' for the stacked regression 
to obtain association parameters of the multidimensional LMA models
corresponding to the GPCM.  This function is called from 'fit.gpcm'. 
It generally would not run outside of 'fit.nominal' or 'ple.lma'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StackDataGPCM(
  Master,
  item.log,
  starting.sv,
  npersons,
  nitems,
  ncat,
  nless,
  Maxnphi,
  pq.mat,
  LambdaNames,
  PhiNames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StackDataGPCM_+3A_master">Master</code></td>
<td>
<p>Current master data frame</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_item.log">item.log</code></td>
<td>
<p>Current history of iterations from which currenat 
a parameters are drawn</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_starting.sv">starting.sv</code></td>
<td>
<p>Fixed category scores</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_npersons">npersons</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_nitems">nitems</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_ncat">ncat</code></td>
<td>
<p>Number of categories</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_nless">nless</code></td>
<td>
<p>Number of unique lambdas</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_maxnphi">Maxnphi</code></td>
<td>
<p>Number of estimated phi parameters</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_pq.mat">pq.mat</code></td>
<td>
<p>Array needed for rest-total scores</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_lambdanames">LambdaNames</code></td>
<td>
<p>Names of lambdas in Master/Stacked data set</p>
</td></tr>
<tr><td><code id="StackDataGPCM_+3A_phinames">PhiNames</code></td>
<td>
<p>Names of phi parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stack.data	Formats data for input to mnlogit to up-date phi parameters
</p>

<hr>
<h2 id='theta.estimates'>Computes estimates of theta (values on latent trait(s)) for all LMA models</h2><span id='topic+theta.estimates'></span>

<h3>Description</h3>

<p>The final estimates of the item scale values and the conditional
covariance matrix (i.e, Phi.mat) are used to compute values on latent 
traits for each individual or case.  The estimated thetas are the 
(conditinal) mean values of response patterns. The correlations 
between the estimated thetas equal the marginal correlations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta.estimates(inData, model.fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta.estimates_+3A_indata">inData</code></td>
<td>
<p>Matrix of response patterns</p>
</td></tr>
<tr><td><code id="theta.estimates_+3A_model.fit">model.fit</code></td>
<td>
<p>Object containing output from running ple.lma</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta.est 	 A person by trait matrix of values on the latent traits
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(dass)
 inData &lt;- dass[1:250,c("d1", "d2", "d3", "a1","a2","a3","s1","s2","s3")]
 inTraitAdj  &lt;- matrix(1, nrow=1, ncol=1)
 inItemTraitAdj &lt;- matrix(1, nrow=9, ncol=1)

 r1 &lt;- ple.lma(inData, model.type="rasch", inItemTraitAdj, inTraitAdj)
 theta.r1 &lt;- theta.estimates(inData, r1)


g1 &lt;- ple.lma(inData, model.type="gpcm", inItemTraitAdj, inTraitAdj)
theta.g1 &lt;- theta.estimates(inData, g1)

n1 &lt;- ple.lma(inData, model.type="nominal", inItemTraitAdj,inTraitAdj)
theta.n1 &lt;- theta.estimates(inData, n1)


</code></pre>

<hr>
<h2 id='vocab'>Dataframe of response to vocabulary items from the 2018 General Social Survey</h2><span id='topic+vocab'></span>

<h3>Description</h3>

<p>These data are responses to 10 vocabulary items from the GSS collected
in 2018 and retrieved July 2019 from https://gss.norc.org.  These data 
are provided as an example of binary items and how the package can fit
two parameter logistic models as either a GPCM or nominal model. Both
models should give the same results. There are 10 words and responses 
to them were were either correct or incorrect. There are 1309 
respondents in the data who gave answers to all items. The specific
words used are not released due to test security reasons. The 
instructions given to answering these items are as follows:
&quot;We would like to know something about how people go about guessing words
they do not know. On this card are listed some words&ndash;you may know some of
them, and you may not know quite a few of them. On each line the first word
is in capital letters &ndash; like BEAST. Then there are five other words. Tell
me the number of the word that comes closest to the meaning of the word in
capital letters. For example, if the word in capital letters is BEAST, you
would say &quot;4&quot; since &quot;animal&quot; comes closer to BEAST than any of the other
words. If you wish, I will read the words to you. These words are difficult
for almost everyone&ndash; just give me your best guess if you are not sure of
the answer.
CIRCLE ONE CODE NUMBER FOR EACH ITEM BELOW.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vocab
</code></pre>


<h3>Format</h3>

<p>A data frame with 1309 rows and 10 columns (items):
</p>

<dl>
<dt>wordA</dt><dd><p>word A</p>
</dd>
<dt>wordB</dt><dd><p>word B</p>
</dd>
<dt>wordC</dt><dd><p>word C</p>
</dd>
<dt>wordD</dt><dd><p>word D</p>
</dd>
<dt>wordE</dt><dd><p>word E</p>
</dd>
<dt>wordF</dt><dd><p>word F</p>
</dd>
<dt>wordG</dt><dd><p>word G</p>
</dd>
<dt>wordH</dt><dd><p>word H</p>
</dd>
<dt>wordI</dt><dd><p>word I</p>
</dd>
<dt>wordJ</dt><dd><p>word J</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://gss.norc.org">https://gss.norc.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(vocab)
  head(vocab)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
