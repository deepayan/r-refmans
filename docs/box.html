<!DOCTYPE html><html lang="en"><head><title>Help for package box</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {box}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#box'><p>An alternative module system for R</p></a></li>
<li><a href='#add_comments'><p>Extend code regions to include leading comments and whitespace</p></a></li>
<li><a href='#create_export_block'><p>Collect export tag information</p></a></li>
<li><a href='#default'><p>Retrieve a value or a default</p></a></li>
<li><a href='#export'><p>Explicitly declare module exports</p></a></li>
<li><a href='#file'><p>Find the full paths of files in modules</p></a></li>
<li><a href='#find_in_path'><p>Find a module’s source location</p></a></li>
<li><a href='#fmt'><p>String formatting helpers</p></a></li>
<li><a href='#has_export_tag'><p>Find <code>@export</code> tags in code regions</p></a></li>
<li><a href='#help'><p>Display module documentation</p></a></li>
<li><a href='#help-internal'><p>Helper functions for the help functionality</p></a></li>
<li><a href='#importing'><p>Import a module or package</p></a></li>
<li><a href='#info'><p>Information about a physical module or package</p></a></li>
<li><a href='#loaded'><p>Environment of loaded modules</p></a></li>
<li><a href='#lsf'><p>Return a list of function names in an environment</p></a></li>
<li><a href='#map'><p>Apply function to elements in list</p></a></li>
<li><a href='#mod-hooks'><p>Hooks for module events</p></a></li>
<li><a href='#name'><p>Get a module’s name</p></a></li>
<li><a href='#namespace'><p>Module namespace handling</p></a></li>
<li><a href='#parse_documentation'><p>Parse a module’s documentation</p></a></li>
<li><a href='#parse_export_specs'><p>Find exported names in parsed module source</p></a></li>
<li><a href='#parse_export_tags'><p>Extract comment tags from Roxygen block comments</p></a></li>
<li><a href='#path'><p>Get a module’s path</p></a></li>
<li><a href='#paths'><p>Path related functions</p></a></li>
<li><a href='#register_S3_method'><p>Register S3 methods</p></a></li>
<li><a href='#s3'><p>Internal S3 infrastructure helpers</p></a></li>
<li><a href='#script_path'><p>Set the base path of the script</p></a></li>
<li><a href='#spec'><p>Parse a mod or pkg spec expression passed to <code>use</code></p></a></li>
<li><a href='#throw'><p>Throw informative error messages</p></a></li>
<li><a href='#topenv'><p>Get a module’s namespace environment</p></a></li>
<li><a href='#unload'><p>Unload or reload modules</p></a></li>
<li><a href='#use'><p>Import a module or package</p></a></li>
<li><a href='#wrap_unsafe_function'><p>Wrap &ldquo;unsafe calls&rdquo; functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Write Reusable, Composable and Modular R Code</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://klmr.me/box/">https://klmr.me/box/</a>, <a href="https://github.com/klmr/box">https://github.com/klmr/box</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/klmr/box/issues">https://github.com/klmr/box/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A modern module system for R. Organise code into hierarchical,
    composable, reusable modules, and use it effortlessly across projects via a
    flexible, declarative dependency loading syntax.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tools</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, knitr (&ge; 1.40), rmarkdown, R6, rlang, roxygen2 (&ge;
7.2.1), shiny, stringr, testthat (&ge; 3.1.7)</td>
</tr>
<tr>
<td>Enhances:</td>
<td>rstudioapi</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-06 23:06:27 UTC; rudolpk2</td>
</tr>
<tr>
<td>Author:</td>
<td>Konrad Rudolph <a href="https://orcid.org/0000-0002-9866-7051"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Michael Schubert <a href="https://orcid.org/0000-0002-6862-5221"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Konrad Rudolph &lt;konrad.rudolph@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-06 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='box'>An alternative module system for R</h2><span id='topic+box-package'></span><span id='topic+box'></span>

<h3>Description</h3>

<p>Use <code>box::use(prefix/mod)</code> to import a module, or <code>box::use(pkg)</code>
to import a package. Fully qualified names are supported for nested modules,
reminiscent of module systems in many other modern languages.
</p>


<h3>Using modules &amp; packages</h3>


<ul>
<li> <p><code><a href="#topic+use">box::use</a></code>
</p>
</li></ul>



<h3>Writing modules</h3>

<p>Infrastructure and utility functions that are mainly used inside modules.
</p>

<ul>
<li> <p><code><a href="#topic+file">box::file</a></code>
</p>
</li>
<li> <p><code><a href="#topic+name">box::name</a></code>
</p>
</li>
<li> <p><code><a href="#topic+register_S3_method">box::register_S3_method</a></code>
</p>
</li>
<li> <p><a href="#topic+mod-hooks">mod-hooks</a>
</p>
</li></ul>



<h3>Interactive use</h3>

<p>Functions for use in interactive sessions and for testing.
</p>

<ul>
<li> <p><code><a href="#topic+help">box::help</a></code>
</p>
</li>
<li> <p><code><a href="#topic+unload">box::unload</a></code>,
<code><a href="#topic+reload">box::reload</a></code>,
<code><a href="#topic+unload">box::purge_cache</a></code>
</p>
</li>
<li> <p><code><a href="#topic+set_script_path">box::set_script_path</a></code>
</p>
</li>
<li> <p><code><a href="#topic+script_path">box::script_path</a></code>,
<code><a href="#topic+script_path">box::set_script_path</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Konrad Rudolph <a href="mailto:konrad.rudolph@gmail.com">konrad.rudolph@gmail.com</a> (<a href="https://orcid.org/0000-0002-9866-7051">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Michael Schubert <a href="mailto:mschu.dev@gmail.com">mschu.dev@gmail.com</a> (<a href="https://orcid.org/0000-0002-6862-5221">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://klmr.me/box/">https://klmr.me/box/</a>
</p>
</li>
<li> <p><a href="https://github.com/klmr/box">https://github.com/klmr/box</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/klmr/box/issues">https://github.com/klmr/box/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_comments'>Extend code regions to include leading comments and whitespace</h2><span id='topic+add_comments'></span>

<h3>Description</h3>

<p>Extend code regions to include leading comments and whitespace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_comments(refs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_comments_+3A_refs">refs</code></td>
<td>
<p>a list of the code region <code>srcref</code>s to extend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>add_comment</code> returns a list of <code>srcref</code>s corresponding to
<code>srcref</code>, but extended to include the preceding comment block.
</p>

<hr>
<h2 id='create_export_block'>Collect export tag information</h2><span id='topic+create_export_block'></span><span id='topic+parse_object'></span><span id='topic+roxygen2_object'></span>

<h3>Description</h3>

<p>Collect export tag information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_export_block(expr, ref, info, mod_ns)

parse_object(info, expr, mod_ns)

roxygen2_object(alias, value, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_export_block_+3A_expr">expr</code></td>
<td>
<p>The unevaluated expression represented by the tag.</p>
</td></tr>
<tr><td><code id="create_export_block_+3A_ref">ref</code></td>
<td>
<p>The code reference <code>srcref</code> represented by the tag.</p>
</td></tr>
<tr><td><code id="create_export_block_+3A_alias">alias</code></td>
<td>
<p>The object name.</p>
</td></tr>
<tr><td><code id="create_export_block_+3A_value">value</code></td>
<td>
<p>The object value.</p>
</td></tr>
<tr><td><code id="create_export_block_+3A_type">type</code></td>
<td>
<p>The object type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>create_export_block</code> returns an object of type
<code>roxy_block</code> represents an exported declaration expression, along with
its source code location.
</p>


<h3>Note</h3>

<p>This could be represented much simpler but we keep compatibility with
roxygen2 — at least for the time being — to make integration with the
roxygen2 API easier, should it become necessary.
</p>

<hr>
<h2 id='default'>Retrieve a value or a default</h2><span id='topic+default'></span><span id='topic++25+7C+7C+25'></span><span id='topic++25+7C+25'></span>

<h3>Description</h3>

<p><code>a %||% b</code> returns <code>a</code> unless it is empty, in which case
<code>b</code> is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %||% b

lhs %|% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_+3A_a">a</code></td>
<td>
<p>the value to return if non-empty</p>
</td></tr>
<tr><td><code id="default_+3A_b">b</code></td>
<td>
<p>default value</p>
</td></tr>
<tr><td><code id="default_+3A_lhs">lhs</code></td>
<td>
<p>vector with potentially missing values, or <code>NULL</code></p>
</td></tr>
<tr><td><code id="default_+3A_rhs">rhs</code></td>
<td>
<p>vector with default values, same length as <code>lhs</code> unless that
is <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>a %||% b</code> returns <code>a</code>, unless it is <code>NULL</code>, empty,
<code>FALSE</code> or <code>""</code>; in which case <code>b</code> is returned.
</p>
<p><code>lhs %|% rhs</code> returns a vector of the same length as
<code>rhs</code> with all missing values in <code>lhs</code> replaced by the
corresponding values in <code>rhs</code>.
</p>

<hr>
<h2 id='export'>Explicitly declare module exports</h2><span id='topic+export'></span>

<h3>Description</h3>

<p><code>box::export</code> explicitly marks a source file as a <span class="pkg">box</span> module. If
can be used as an alternative to the <code>@export</code> tag comment to declare a
module’s exports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::export(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>zero or more unquoted names that should be exported from the
module.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>box::export</code> can be called inside a module to specify the module’s
exports. If a module contains a call to <code>box::export</code>, this call
overrides any declarations made via the <code>@export</code> tag comment. When a
module contains multiple calls to <code>box::export</code>, the union of all thus
defined names is exported.
</p>
<p>A module can also contain an argument-less call to <code>box::export</code>. This
ensures that the module does not export any names. Otherwise, a module that
defines names but does not mark them as exported would be treated as a
<em>legacy module</em>, and all default-visible names would be exported from
it. Default-visible names are names not starting with a dot (<code>.</code>).
Another use of <code>box::export()</code> is to enable a module without exports to
use <a href="#topic+mod-hooks">module event hooks</a>.
</p>


<h3>Value</h3>

<p><code>box::export</code> has no return value. It is called for its
side effect.
</p>


<h3>Note</h3>

<p>The preferred way of declaring exports is via the <code>@export</code> tag
comment. The main purpose of <code>box::export</code> is to explicitly prevent
exports, by being called without arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+use">box::use</a></code> for information on declaring exports via
<code>@export</code>.
</p>

<hr>
<h2 id='file'>Find the full paths of files in modules</h2><span id='topic+file'></span>

<h3>Description</h3>

<p>Find the full paths of files in modules
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::file(...)

box::file(..., module)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_+3A_...">...</code></td>
<td>
<p>character vectors of files or subdirectories inside a module; if
none is given, return the root directory of the module</p>
</td></tr>
<tr><td><code id="file_+3A_module">module</code></td>
<td>
<p>a module environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the absolute paths to the files
specified in <code>...</code>.
</p>


<h3>Note</h3>

<p>If called from outside a module, the current working directory is used.
</p>
<p>This function is similar to <code>system.file</code> for packages. Its semantics
differ in the presence of non-existent files: <code>box::file</code> always returns
the requested paths, even for non-existent files; whereas <code>system.file</code>
returns empty strings for non-existent files, or fails (if requested via the
argument <code>mustWork = TRUE</code>).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+system.file">system.file</a></code>
</p>

<hr>
<h2 id='find_in_path'>Find a module’s source location</h2><span id='topic+find_in_path'></span>

<h3>Description</h3>

<p>Find a module’s source location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_in_path(spec, base_paths)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_in_path_+3A_spec">spec</code></td>
<td>
<p>a <code>mod_spec</code>.</p>
</td></tr>
<tr><td><code id="find_in_path_+3A_base_paths">base_paths</code></td>
<td>
<p>a character vector of paths to search the module in, in
order of preference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A module is physically represented in the file system either by
&lsquo;<span class="file">‹spec_name(spec)›.r</span>&rsquo; or by &lsquo;<span class="file">‹spec_name(spec)›/__init__.r</span>&rsquo;, in that
order of preference in case both exist. File extensions are case insensitive
to allow for R’s obsession with capital-R extensions (but lower-case are
given preference, and upper-case file extensions are discouraged).
</p>


<h3>Value</h3>

<p><code>find_in_path</code> returns a <code>mod_info</code> that specifies the
module source location.
</p>

<hr>
<h2 id='fmt'>String formatting helpers</h2><span id='topic+fmt'></span><span id='topic+chr'></span><span id='topic+html_escape'></span><span id='topic+interleave'></span>

<h3>Description</h3>

<p>Interpolate expressions in a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmt(..., envir = parent.frame())

chr(x)

html_escape(x)

interleave(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fmt_+3A_...">...</code></td>
<td>
<p>one or more unnamed character string arguments, followed
optionally by named arguments</p>
</td></tr>
<tr><td><code id="fmt_+3A_x">x</code></td>
<td>
<p>an object to convert</p>
</td></tr>
<tr><td><code id="fmt_+3A_a">a</code></td>
<td>
<p>a character vector of length <code>n</code></p>
</td></tr>
<tr><td><code id="fmt_+3A_b">b</code></td>
<td>
<p>a character vector of length <code>n - 1</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fmt</code> interpolates embedded expressions in a string.
<code>chr</code> converts a value to a character vector; unlike
<code>as.character</code>, it correctly deparses unevaluated names and expressions.
<code>interleave</code> is a helper that interleaves two vectors <code>a = c(a[1],
..., a[n])</code> and <code>b = c(b[1], ..., b[n - 1])</code>.
</p>
<p>The general format of an interpolation expression inside a <code>fmt</code> string
is: <code>{...}</code> interpolates the expression <code>...</code>. To insert
literal braces, double them (i.e. <code>{{</code>, <code>}}</code>). Interpolated
expressions can optionally be followed by a <em>format modifier</em>: if
present, it is specified via the syntax <code>{...;modifier}</code>. The
following modifiers are supported:
</p>

<dl>
<dt><code>\"</code></dt><dd><p>like <code>dQuote(...)</code></p>
</dd>
<dt><code>\'</code></dt><dd><p>like <code>sQuote(...)</code></p>
</dd>
<dt><code>‹fmt›f</code></dt><dd><p>like <code>sprintf('%‹fmt›f', ...)</code></p>
</dd>
</dl>

<p>Vectors of length &gt; 1 will be concatenated as if using
<code><a href="base.html#topic+toString">toString</a></code> before interpolation.
</p>


<h3>Value</h3>

<p><code>fmt(...)</code> concatenates any unnamed arguments, and
interpolates all embedded expressions as explained in the &lsquo;Details&rsquo;.
Named arguments are treated as locally defined variables, and are added to
(and override, in case of name reuse) names defined in the calling scope.
</p>
<p><code>chr(x)</code> returns a string representation of a value or
unevaluated expression <code>x</code>.
</p>
<p><code>html_escape(x)</code> returns the HTML-escaped version of <code>x</code>.
</p>
<p><code>interleave(a, b)</code> returns a vector <code>c(a[1], b[1], a[2],
b[2], ..., a[n - 1], b[n - 1], a[n])</code>.
</p>

<hr>
<h2 id='has_export_tag'>Find <code>@export</code> tags in code regions</h2><span id='topic+has_export_tag'></span>

<h3>Description</h3>

<p>Find <code>@export</code> tags in code regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_export_tag(ref)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_export_tag_+3A_ref">ref</code></td>
<td>
<p>The code region <code>srcref</code> to search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the given region is annotated with a <code>@export</code>
tag, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='help'>Display module documentation</h2><span id='topic+help'></span>

<h3>Description</h3>

<p><code>box::help</code> displays help on a module’s objects and functions in much
the same way <code><a href="utils.html#topic+help">help</a></code> does for package contents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::help(topic, help_type = getOption("help_type", "text"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="help_+3A_topic">topic</code></td>
<td>
<p>either the fully-qualified name of the object or function to get
help for, in the format <code>module$function</code>; or a name that was exported
and attached from an imported module or package.</p>
</td></tr>
<tr><td><code id="help_+3A_help_type">help_type</code></td>
<td>
<p>character string specifying the output format; currently,
only <code>'text'</code> is supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette at <code>vignette('box', 'box')</code> for more information about
displaying help for modules.
</p>


<h3>Value</h3>

<p><code>box::help</code> is called for its side effect when called directly
from the command prompt.
</p>

<hr>
<h2 id='help-internal'>Helper functions for the help functionality</h2><span id='topic+help-internal'></span><span id='topic+help_topic_target'></span><span id='topic+find_env'></span><span id='topic+call_help'></span>

<h3>Description</h3>

<p><code>help_topic_target</code> parses the expression being passed to the
<code>help</code> function call to find the innermost module subset expression in
it.
<code>find_env</code> acts similarly to <code><a href="utils.html#topic+find">find</a></code>, except that it
looks in the current environment’s parents rather than in the global
environment search list, it returns only one hit (or zero), and it returns
the environment rather than a character string.
<code>call_help</code> invokes a <code>help()</code> call expression for a package help
topic, finding the first <code>help</code> function definition, ignoring the one
from this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>help_topic_target(topic, caller)

find_env(name, caller)

call_help(call, caller)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="help-internal_+3A_topic">topic</code></td>
<td>
<p>the unevaluated expression passed to <code>help</code>.</p>
</td></tr>
<tr><td><code id="help-internal_+3A_caller">caller</code></td>
<td>
<p>the environment from which <code>help</code> was called.</p>
</td></tr>
<tr><td><code id="help-internal_+3A_name">name</code></td>
<td>
<p>the name to look for.</p>
</td></tr>
<tr><td><code id="help-internal_+3A_call">call</code></td>
<td>
<p>the patched <code>help</code> call expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>help_topic_target</code> returns a list of two elements containing
the innermost module of the <code>help</code> call, as well as the name of the
object that’s the subject of the <code>help</code> call. For <code>help(a$b$c$d)</code>,
it returns <code>list(c, quote(d))</code>.
</p>

<hr>
<h2 id='importing'>Import a module or package</h2><span id='topic+importing'></span><span id='topic+use_one'></span><span id='topic+load_and_register'></span><span id='topic+register_as_import'></span><span id='topic+defer_import_finalization'></span><span id='topic+finalize_deferred'></span><span id='topic+export_and_attach'></span><span id='topic+load_from_source'></span><span id='topic+load_mod'></span><span id='topic+mod_exports'></span><span id='topic+mod_export_names'></span><span id='topic+attach_to_caller'></span><span id='topic+attach_list'></span><span id='topic+assign_alias'></span><span id='topic+assign_temp_alias'></span>

<h3>Description</h3>

<p>Actual implementation of the import process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_one(declaration, alias, caller, use_call)

load_and_register(spec, info, caller)

register_as_import(spec, info, mod_ns, caller)

defer_import_finalization(spec, info, mod_ns, caller)

finalize_deferred(info)

export_and_attach(spec, info, mod_ns, caller)

load_from_source(info, mod_ns)

load_mod(info)

mod_exports(info, spec, mod_ns)

mod_export_names(info, mod_ns)

attach_to_caller(spec, info, mod_exports, mod_ns, caller)

attach_list(spec, exports)

assign_alias(spec, mod_exports, caller)

assign_temp_alias(spec, caller)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importing_+3A_declaration">declaration</code></td>
<td>
<p>an unevaluated use declaration expression without the
surrounding <code>use</code> call</p>
</td></tr>
<tr><td><code id="importing_+3A_alias">alias</code></td>
<td>
<p>the use alias, if given, otherwise <code>NULL</code></p>
</td></tr>
<tr><td><code id="importing_+3A_caller">caller</code></td>
<td>
<p>the client’s calling environment (parent frame)</p>
</td></tr>
<tr><td><code id="importing_+3A_use_call">use_call</code></td>
<td>
<p>the <code>use</code> call which is invoking this code</p>
</td></tr>
<tr><td><code id="importing_+3A_spec">spec</code></td>
<td>
<p>a module use declaration specification</p>
</td></tr>
<tr><td><code id="importing_+3A_info">info</code></td>
<td>
<p>the physical module information</p>
</td></tr>
<tr><td><code id="importing_+3A_mod_ns">mod_ns</code></td>
<td>
<p>the module namespace environment of the newly loaded module</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>use_one</code> performs the actual import. It is invoked by <code>use</code> given
the calling context and unevaluated expressions as arguments, and only uses
standard evaluation.
</p>
<p><code>load_and_register</code> performs the loading, attaching and exporting of a
module identified by its spec and info.
</p>
<p><code>register_as_import</code> registers a <code>use</code> declaration in the calling
module so that it can be found later on, if the declaration is reexported by
the calling module.
</p>
<p><code>defer_import_finalization</code> is called by <code>load_and_register</code> to
earmark a module for deferred initialization if it hasn’t been fully loaded
yet.
</p>
<p><code>finalize_deferred</code> exports and attaches names from a module use
declaration which has been deferred due to being part of a cyclic loading
chain.
</p>
<p><code>export_and_attach</code> exports and attaches names from a given module use
declaration.
</p>
<p><code>load_from_source</code> loads a module source file into its newly created,
empty module namespace.
</p>
<p><code>load_mod</code> tests whether a module or package was already loaded and, if
not, loads it.
</p>
<p><code>mod_exports</code> returns an export environment containing a copy of the
module’s exported objects.
</p>
<p><code>attach_to_caller</code> attaches the listed names of an attach specification
for a given use declaration to the calling environment.
</p>
<p><code>assign_alias</code> creates a module/package object in calling environment,
unless it contains an attach declaration, and no explicit alias is given.
</p>
<p><code>assign_temp_alias</code> creates a placeholder object for the module in the
calling environment, to be replaced by the actual module export environment
once the module is completely loaded (which happens in the case of cyclic
imports).
</p>


<h3>Value</h3>

<p><code>use_one</code> does not currently return a value. — This might change
in the future.
</p>
<p><code>load_mod</code> returns the module or package namespace environment
of the specified module or package info.
</p>
<p><code>mod_exports</code> returns an export environment containing the
exported names of a given module.
</p>
<p><code>mode_export_names</code> returns a vector containing the same names as
<code>names(mod_exports(info, spec, mod_ns))</code> but does not create an export
environment.
</p>
<p><code>attach_list</code> returns a named character vector of the names in
an attach specification. The vector’s names are the aliases, if provided, or
the attach specification names themselves otherwise.
</p>


<h3>Note</h3>

<p>If a module is still being loaded (because it is part of a cyclic
import chain), <code>load_and_register</code> earmarks the module for deferred
registration and holds off on attaching and exporting for now, since not all
its names are available yet.
</p>

<hr>
<h2 id='info'>Information about a physical module or package</h2><span id='topic+info'></span><span id='topic+mod_info'></span><span id='topic+pkg_info'></span>

<h3>Description</h3>

<p>A <code>mod_info</code> represents an existing, installed module and its runtime
physical location (usually in the file system).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_info(spec, source_path)

pkg_info(spec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="info_+3A_spec">spec</code></td>
<td>
<p>a <code>mod_spec</code> or <code>pkg_spec</code> (for <code>mod_info</code> and
<code>pkg_info</code>, respectively)</p>
</td></tr>
<tr><td><code id="info_+3A_source_path">source_path</code></td>
<td>
<p>character string full path to the physical module
location.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mod_info</code> and <code>pkg_info</code> return a structure representing
the module/package information for the given specification/source location.
</p>

<hr>
<h2 id='loaded'>Environment of loaded modules</h2><span id='topic+loaded'></span><span id='topic+loaded_mods'></span><span id='topic+is_mod_loaded'></span><span id='topic+register_mod'></span><span id='topic+deregister_mod'></span><span id='topic+loaded_mod'></span><span id='topic+is_mod_still_loading'></span><span id='topic+mod_loading_finished'></span>

<h3>Description</h3>

<p>Each module is stored as an environment inside <code>loaded_mods</code> with the
module’s code location path as its identifier. The path rather than the
module name is used because module names are not unique: two modules called
<code>a</code> can exist nested inside modules <code>b</code> and <code>c</code>, respectively.
Yet these may be loaded at the same time and need to be distinguished.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loaded_mods

is_mod_loaded(info)

register_mod(info, mod_ns)

deregister_mod(info)

loaded_mod(info)

is_mod_still_loading(info)

mod_loading_finished(info, mod_ns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loaded_+3A_info">info</code></td>
<td>
<p>the mod info of a module</p>
</td></tr>
<tr><td><code id="loaded_+3A_mod_ns">mod_ns</code></td>
<td>
<p>module namespace environment</p>
</td></tr>
</table>


<h3>Format</h3>

<p><code>loaded_mods</code> is an environment of the loaded module and package
namespaces.
</p>


<h3>Details</h3>

<p><code>is_mod_loaded</code> tests whether a module is already loaded.
</p>
<p><code>register_mod</code> caches a module namespace and marks the module as loaded.
</p>
<p><code>deregister_mod</code> removes a module namespace from the cache, unloading
the module from memory.
</p>
<p><code>loaded_mod</code> retrieves a loaded module namespace given its info.
</p>
<p><code>is_mod_still_loading</code> tests whether a module is still being loaded.
</p>
<p><code>mod_loading_finished</code> signals that a module has been completely loaded.
</p>


<h3>Note</h3>

<p><code>is_mod_still_loading</code> and <code>mod_loading_finished</code> are used to
break cycles during the loading of modules with cyclic dependencies.
</p>

<hr>
<h2 id='lsf'>Return a list of function names in an environment</h2><span id='topic+lsf'></span>

<h3>Description</h3>

<p>Return a list of function names in an environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsf(envir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lsf_+3A_envir">envir</code></td>
<td>
<p>the environment to search in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>lsf</code> returns a vector of function names in the given environment.
</p>

<hr>
<h2 id='map'>Apply function to elements in list</h2><span id='topic+map'></span><span id='topic+flatmap'></span><span id='topic+flatmap_chr'></span><span id='topic+vmap'></span><span id='topic+map_int'></span><span id='topic+map_lgl'></span><span id='topic+map_chr'></span><span id='topic+transpose'></span>

<h3>Description</h3>

<p><code>map</code> applies a function to lists of arguments, similar to <code>Map</code> in
base R, with the argument <code>USE.NAMES</code> set to <code>FALSE</code>.
<code>flatmap</code> performs a recursive map: the return type is always a vector
of some type given by the <code>.default</code>, and if the return value of calling
<code>.f</code> is a vector, it is flattened into the enclosing vector (see
&lsquo;Examples&rsquo;).
<code>transpose</code> is a special <code>map</code> application that concatenates its
inputs to compute a transposed list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map(.f, ...)

flatmap(.f, ..., .default)

flatmap_chr(.f, ...)

vmap(.f, .x, ..., .default)

map_int(.f, ...)

map_lgl(.f, ...)

map_chr(.f, ...)

transpose(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_+3A_.f">.f</code></td>
<td>
<p>an n-ary function where n is the number of further arguments given</p>
</td></tr>
<tr><td><code id="map_+3A_...">...</code></td>
<td>
<p>lists of arguments to map over in parallel</p>
</td></tr>
<tr><td><code id="map_+3A_.default">.default</code></td>
<td>
<p>the default value returned by <code>flatmap</code> for an empty
input</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>map</code> returns a (potentially nested) list of values resulting
from applying <code>.f</code> to the arguments.
</p>
<p><code>flatmap</code> returns a vector with type given by <code>.default</code>,
or <code>.default</code>, if the input is empty.
</p>
<p><code>transpose</code> returns a list of the element-wise concatenated
input vectors; that is, a &ldquo;transposed list&rdquo; of those elements.
</p>


<h3>Examples</h3>

<pre>
flatmap_chr(identity, NULL)
# character(0)

flatmap_chr(identity, c('a', 'b'))
# [1] "a" "b"

flatmap_chr(identity, list(c('a', 'b'), 'c'))
# [1] "a" "b" "c"

transpose(1 : 2, 3 : 4)
# [[1]]
# [1] 1 3
#
# [[2]]
# [1] 2 4
</pre>

<hr>
<h2 id='mod-hooks'>Hooks for module events</h2><span id='topic+mod-hooks'></span><span id='topic+.on_load'></span><span id='topic+.on_unload'></span>

<h3>Description</h3>

<p>Modules can declare functions to be called when a module is first loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.on_load(ns)

.on_unload(ns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mod-hooks_+3A_ns">ns</code></td>
<td>
<p>the module namespace environment</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create module hooks, modules should define a function with the specified
name and signature. Module hooks should <em>not</em> be exported.
</p>
<p>When <code>.on_load</code> is called, the unlocked module namespace environment is
passed to it via its parameter <code>ns</code>. This means that code in
<code>.on_load</code> is permitted to modify the namespace by adding names to,
replacing names in, or removing names from the namespace.
</p>
<p><code>.on_unload</code> is called when modules are unloaded. The (locked) module
namespace is passed as an argument. It is primarily useful to clean up
resources used by the module. Note that, as for packages, <code>.on_unload</code>
is <em>not</em> necessarily called when R is shut down.
</p>
<p><em>Legacy modules</em> cannot use hooks. To use hooks, the module needs to
contain an export specification (if the module should not export any names,
specify an explicit, empty export list via
<code><a href="#topic+export">box::export()</a></code>.
</p>


<h3>Value</h3>

<p>Any return values of the hook functions are ignored.
</p>


<h3>Note</h3>

<p>The API for hook functions is still subject to change. In particular,
there might in the future be a way to subscribe to module events of other
modules and packages, equivalently to R package <a href="base.html#topic+userhooks">userhooks</a>.
</p>

<hr>
<h2 id='name'>Get a module’s name</h2><span id='topic+name'></span>

<h3>Description</h3>

<p>Get a module’s name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::name()
</code></pre>


<h3>Value</h3>

<p><code>box::name</code> returns a character string containing the name of
the module, or <code>NULL</code> if called from outside a module.
</p>


<h3>Note</h3>

<p>Because this function returns <code>NULL</code> if not invoked inside a
module, the function can be used to check whether a code is being imported as
a module or called directly.
</p>

<hr>
<h2 id='namespace'>Module namespace handling</h2><span id='topic+namespace'></span><span id='topic+make_namespace'></span><span id='topic+is_namespace'></span><span id='topic+namespace_info'></span><span id='topic+namespace_info+3C-'></span><span id='topic+mod_topenv'></span><span id='topic+is_mod_topenv'></span>

<h3>Description</h3>

<p><code>make_namespace</code> creates a new module namespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_namespace(info)

is_namespace(env)

namespace_info(ns, which, default = NULL)

namespace_info(ns, which) &lt;- value

mod_topenv(env = parent.frame())

is_mod_topenv(env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="namespace_+3A_info">info</code></td>
<td>
<p>the module info.</p>
</td></tr>
<tr><td><code id="namespace_+3A_env">env</code></td>
<td>
<p>an environment that may be a module namespace.</p>
</td></tr>
<tr><td><code id="namespace_+3A_ns">ns</code></td>
<td>
<p>the module namespace environment.</p>
</td></tr>
<tr><td><code id="namespace_+3A_which">which</code></td>
<td>
<p>the key (as a length 1 character string) of the info to get/set.</p>
</td></tr>
<tr><td><code id="namespace_+3A_default">default</code></td>
<td>
<p>default value to use if the key is not set.</p>
</td></tr>
<tr><td><code id="namespace_+3A_value">value</code></td>
<td>
<p>the value to assign to the specified key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The namespace contains a module’s content. This schema is very much like R
package organisation. A good resource for this is:
&lt;http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/&gt;
</p>


<h3>Value</h3>

<p><code>make_namespace</code> returns the newly created module namespace for
the module described by <code>info</code>.
</p>


<h3>Note</h3>

<p>Module namespaces aren’t actual R package namespaces. This is
intentional, since R makes strong assumptions about package namespaces that
are violated here. In particular, such namespaces would have to be registered
in R’s internal namespace registry, and their (de)serialisation is handled by
R code which assumes that they belong to actual packges that can be loaded
via 'loadNamespace'.
</p>

<hr>
<h2 id='parse_documentation'>Parse a module’s documentation</h2><span id='topic+parse_documentation'></span><span id='topic+parse_roxygen_tags'></span><span id='topic+patch_mod_doc'></span>

<h3>Description</h3>

<p>Parse a module’s documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_documentation(info, mod_ns)

parse_roxygen_tags(info, mod_ns)

patch_mod_doc(docs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_documentation_+3A_info">info</code></td>
<td>
<p>The module info.</p>
</td></tr>
<tr><td><code id="parse_documentation_+3A_mod_ns">mod_ns</code></td>
<td>
<p>The module namespace.</p>
</td></tr>
<tr><td><code id="parse_documentation_+3A_docs">docs</code></td>
<td>
<p>the list of <span class="pkg">roxygen2</span> documentation objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parse_documentation</code> returns a list of character strings with
the Rd documentation source code for each documented name in a module.
</p>

<hr>
<h2 id='parse_export_specs'>Find exported names in parsed module source</h2><span id='topic+parse_export_specs'></span><span id='topic+use_call'></span><span id='topic+static_assign_calls'></span><span id='topic+assign_calls'></span><span id='topic+is_static_assign_call'></span><span id='topic+is_assign_call'></span><span id='topic+block_is_assign'></span><span id='topic+block_is_use_call'></span><span id='topic+block_is_exported'></span><span id='topic+block_name'></span>

<h3>Description</h3>

<p>Find exported names in parsed module source
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_export_specs(info, exprs, mod_ns)

use_call

static_assign_calls

assign_calls

is_static_assign_call(call)

is_assign_call(call)

block_is_assign(block)

block_is_use_call(block)

block_is_exported(block)

block_name(block)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_export_specs_+3A_info">info</code></td>
<td>
<p>The module info.</p>
</td></tr>
<tr><td><code id="parse_export_specs_+3A_exprs">exprs</code></td>
<td>
<p>The list of expressions of the parsed module.</p>
</td></tr>
<tr><td><code id="parse_export_specs_+3A_mod_ns">mod_ns</code></td>
<td>
<p>The module namespace after evaluating the expressions.</p>
</td></tr>
<tr><td><code id="parse_export_specs_+3A_call">call</code></td>
<td>
<p>A call to test.</p>
</td></tr>
<tr><td><code id="parse_export_specs_+3A_block">block</code></td>
<td>
<p>A roxygen2 block to inspect.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>call</code> of length 3.
</p>
<p>An object of class <code>list</code> of length 4.
</p>
<p>An object of class <code>list</code> of length 6.
</p>


<h3>Value</h3>

<p><code>parse_export_specs</code> returns a potentially empty character
vector of exported names.
</p>


<h3>Note</h3>

<p>There are two situations in which the <code>@export</code> tag can be applied:
</p>

<ol>
<li><p> When applied to assignments, the assigned name is exported.
</p>
</li>
<li><p> When applied to a <code>box::use</code> call, the imported names are
exported. This can be the module name itself, any attached names, or
both. All names introduced by the <code>box::use</code> call are exported. See
<code><a href="#topic+use">use</a></code> for the rules governing what names are introduced
into the scope, and thus exported.
</p>
</li></ol>

<p>In any other situation, applying the <code>@export</code> tag is an error.
</p>

<hr>
<h2 id='parse_export_tags'>Extract comment tags from Roxygen block comments</h2><span id='topic+parse_export_tags'></span>

<h3>Description</h3>

<p>Extract comment tags from Roxygen block comments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_export_tags(info, exprs, mod_ns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_export_tags_+3A_exprs">exprs</code></td>
<td>
<p>The unevaluated expressions to parse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parse_export_tags</code> returns a list of <code>roxy_block</code>s for all
exported declarations.
</p>


<h3>Note</h3>

<p>The following code performs the same function as roxygen2 with a custom
<code>@</code> tag roclet. Unfortunately roxygen2 itself pulls in many
dependencies, making it less suitable for an infrastructure package such as
this one. Furthermore, the code license of roxygen2 is incompatible with
ours, so we cannot simply copy and paste the relevant code out. Luckily the
logic is straightforward to reimplement.
</p>

<hr>
<h2 id='path'>Get a module’s path</h2><span id='topic+path'></span><span id='topic+base_path'></span><span id='topic+module_path'></span><span id='topic+mod_path'></span><span id='topic+explicit_path'></span><span id='topic+r_path'></span><span id='topic+knitr_path'></span><span id='topic+shiny_path'></span><span id='topic+testthat_path'></span><span id='topic+rstudio_path'></span><span id='topic+wd_path'></span>

<h3>Description</h3>

<p>The following functions retrieve information about the path of the directory
that a module or script is running in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path(mod)

base_path(mod)

module_path(mod)

mod_path(mod)

explicit_path(...)

r_path(...)

knitr_path(...)

shiny_path(...)

testthat_path(...)

rstudio_path(...)

wd_path(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="path_+3A_mod">mod</code></td>
<td>
<p>a module environment or namespace</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>module_path</code> takes a best guess at a script’s path, since R does not
provide a sure-fire way for determining the path of the currently executing
code. The following calling situations are covered:
</p>

<ol>
<li><p> Path explicitly set via <code>set_script_path</code>
</p>
</li>
<li><p> Path of a running document/application (<span class="pkg">knitr</span>, <span class="pkg">Shiny</span>)
</p>
</li>
<li><p> Path of unit test cases (<span class="pkg">testthat</span>)
</p>
</li>
<li><p> Path of the currently opened source code file in RStudio
</p>
</li>
<li><p> Code invoked as <code>Rscript script.r</code>
</p>
</li>
<li><p> Code invoked as <code>R CMD BATCH script.r</code>
</p>
</li>
<li><p> Code invoked as <code>R -f script.r</code>
</p>
</li>
<li><p> Script run interactively (use <code>getwd()</code>)
</p>
</li></ol>



<h3>Value</h3>

<p><code>path</code> returns a character string containing the module’s full
path.
</p>
<p><code>base_path</code> returns a character string containing the module’s
base directory, or the current working directory if not invoked on a module.
</p>
<p><code>module_path</code> returns a character string that contains the
directory in which the calling R code is run. See &lsquo;Details&rsquo;.
</p>
<p><code>mod_path</code> returns the script path associated with a <span class="pkg">box</span>
module
</p>
<p><code>explicit_path</code> returns the script path explicitly set by the
user, if such a path was set.
</p>
<p><code>r_path</code> returns the directory in which the current script is
run via <code>Rscript</code>, <code>R CMD BATCH</code> or <code>R -f</code>.
</p>
<p><code>knitr_path</code> returns the directory in which the currently knit
document is run, or <code>NULL</code> if not called from within a <span class="pkg">knitr</span>
document.
</p>
<p><code>shiny_path</code> returns the directory in which a <span class="pkg">Shiny</span>
application is running, or <code>NULL</code> if not called from within a
<span class="pkg">Shiny</span> application.
</p>
<p><code>testthat_path</code> returns the directory in which <span class="pkg">testthat</span>
code is being executed, or <code>NULL</code> if not called from within a
<span class="pkg">testthat</span> test case.
</p>
<p><code>rstdio_path</code> returns the directory in which the currently
active RStudio script file is saved.
</p>
<p><code>wd_path</code> returns the current working directory.
</p>

<hr>
<h2 id='paths'>Path related functions</h2><span id='topic+paths'></span><span id='topic+mod_search_path'></span><span id='topic+calling_mod_path'></span><span id='topic+split_path'></span><span id='topic+merge_path'></span><span id='topic+sanitize_path_fragment'></span>

<h3>Description</h3>

<p><code>mod_search_path</code> returns the character vector of paths where module
code can be located and will be found by <span class="pkg">box</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_search_path(caller)

calling_mod_path(caller)

split_path(path)

merge_path(components)

sanitize_path_fragment(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paths_+3A_caller">caller</code></td>
<td>
<p>the environment from which <code>box::use</code> was invoked.</p>
</td></tr>
<tr><td><code id="paths_+3A_path">path</code></td>
<td>
<p>the path</p>
</td></tr>
<tr><td><code id="paths_+3A_components">components</code></td>
<td>
<p>character string vector of path components to merge</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>calling_mod_path</code> the path of the source module that is calling
<code>box::use</code>, or the script’s path if the calling code is not a module.
</p>
<p><code>split_path</code> returns a character vector of path components that
logically represent <code>path</code>.
</p>
<p><code>merge_path</code> returns a single character string that is
logically equivalent to the <code>path</code> passed to <code>split_path</code>.
logically represent <code>path</code>.
</p>


<h3>Note</h3>

<p>The search paths are ordered from highest to lowest priority.
The current module’s path always has the lowest priority.
</p>
<p>There are two ways of modifying the module search path: by default,
<code>getOption('box.path')</code> specifies the search path as a character vector.
Users can override its value by separately setting the environment variable
<span class="env">R_BOX_PATH</span> to one or more paths, separated by the platform’s path
separator (&ldquo;:&rdquo; on UNIX-like systems, &ldquo;;&rdquo; on Windows).
</p>
<p><code>merge_path</code> is the inverse function to <code>split_path</code>.
However, this does not mean that its result will be identical to the
original path. Instead, it is only guaranteed that it will refer to the same
logical path given the same working directory.
</p>

<hr>
<h2 id='register_S3_method'>Register S3 methods</h2><span id='topic+register_S3_method'></span>

<h3>Description</h3>

<p><code>box::register_S3_method</code> makes an S3 method for a given generic and
class known inside a module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::register_S3_method(name, class, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register_S3_method_+3A_name">name</code></td>
<td>
<p>the name of the generic as a character string.</p>
</td></tr>
<tr><td><code id="register_S3_method_+3A_class">class</code></td>
<td>
<p>the class name.</p>
</td></tr>
<tr><td><code id="register_S3_method_+3A_method">method</code></td>
<td>
<p>the method to register (optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>method</code> is missing, it defaults to a function named
<code>name.class</code> in the calling module. If no such function exists, an error
is raised.
</p>
<p>Methods for generics defined in the same module do not need to be registered
explicitly, and indeed <em>should not</em> be registered. However, if the user
wants to add a method for a known generic (defined outside the module, e.g.
<code><a href="base.html#topic+print">print</a></code>), then this needs to be made known explicitly.
</p>
<p>See the vignette at <code>vignette('box', 'box')</code> for more information about
defining S3 methods inside modules.
</p>


<h3>Value</h3>

<p><code>box::register_S3_method</code> is called for its side effect.
</p>


<h3>Note</h3>

<p><strong>Do not</strong> call <code><a href="base.html#topic+registerS3method">registerS3method</a></code> inside a
module, only use <code>box::register_S3_method</code>. This is important for the
module’s own book-keeping.
</p>

<hr>
<h2 id='s3'>Internal S3 infrastructure helpers</h2><span id='topic+s3'></span><span id='topic+is_S3_user_generic'></span><span id='topic+make_S3_methods_known'></span>

<h3>Description</h3>

<p>The following are internal S3 infrastructure helper functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_S3_user_generic(function_name, envir = parent.frame())

make_S3_methods_known(module)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="s3_+3A_function_name">function_name</code></td>
<td>
<p>function name as character string.</p>
</td></tr>
<tr><td><code id="s3_+3A_envir">envir</code></td>
<td>
<p>the environment this function is invoked from.</p>
</td></tr>
<tr><td><code id="s3_+3A_module">module</code></td>
<td>
<p>the module object for which to register S3 methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_S3_user_generic</code> checks whether a function given by name is a
user-defined generic. A user-defined generic is any function which, at some
point, calls <code>UseMethod</code>.
</p>
<p><code>make_S3_methods_known</code> finds and registers S3 methods inside a module.
</p>


<h3>Value</h3>

<p><code>is_S3_user_generic</code> returns <code>TRUE</code> if the specified
function is a user-defined S3 generic, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='script_path'>Set the base path of the script</h2><span id='topic+script_path'></span><span id='topic+set_script_path'></span>

<h3>Description</h3>

<p><code>box::set_script_path(path)</code> explicitly tells <span class="pkg">box</span> the path of a
given script from which it is called; <code>box::script_path()</code> returns the
previously set path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::set_script_path(path)

box::script_path()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="script_path_+3A_path">path</code></td>
<td>
<p>character string containing the relative or absolute path to the
currently executing <span class="rlang"><b>R</b></span> code file, or <code>NULL</code> to reset the path.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><span class="pkg">box</span> needs to know the base path of the topmost calling <span class="rlang"><b>R</b></span> context (i.e.
the script) to find relative import locations. In most cases, <span class="pkg">box</span> can
figure the path out automatically. However, in some cases third-party
packages load code in a way in which <span class="pkg">box</span> cannot find the correct path
of the script any more. <code>box::set_script_path</code> can be used in these
cases to set the path of the currently executing <span class="rlang"><b>R</b></span> script manually.
</p>


<h3>Value</h3>

<p>Both <code>box::script_path</code> and <code>box::set_script_path</code> return
the previously set script path, or <code>NULL</code> if none was explicitly set.
<code>box::set_script_path</code> returns its value invisibly.
</p>


<h3>Note</h3>

<p><span class="pkg">box</span> <em>should</em> be able to figure out the script path automatically.
Using <code>box::set_script_path</code> should therefore never be necessary.
<a href="https://github.com/klmr/box/issues/new?assignees=&amp;labels=%E2%9A%A0%EF%B8%8F+bug&amp;title=%5Bset_script_path%5D%20&amp;template=bug-report.yml">Please
file an issue</a> if you encounter a situation that necessitates using
<code>box::set_script_path</code>!
</p>


<h3>Examples</h3>

<pre><code class='language-R'>box::set_script_path('scripts/my_script.r')
</code></pre>

<hr>
<h2 id='spec'>Parse a mod or pkg spec expression passed to <code>use</code></h2><span id='topic+spec'></span><span id='topic+parse_spec'></span><span id='topic+mod_spec'></span><span id='topic+pkg_spec'></span><span id='topic+spec_name'></span>

<h3>Description</h3>

<p>Parse a mod or pkg spec expression passed to <code>use</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_spec(expr, alias)

mod_spec(spec, ...)

pkg_spec(spec, ...)

spec_name(spec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spec_+3A_expr">expr</code></td>
<td>
<p>the mod or pkg spec expression to parse</p>
</td></tr>
<tr><td><code id="spec_+3A_alias">alias</code></td>
<td>
<p>the mod or pkg spec alias as a character, or <code>NULL</code></p>
</td></tr>
<tr><td><code id="spec_+3A_spec">spec</code></td>
<td>
<p>named list of information the parser constructed from a given
spec expression</p>
</td></tr>
<tr><td><code id="spec_+3A_...">...</code></td>
<td>
<p>further information about a spec, not represented by the spec
expression parse tree</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>parse_spec</code> returns a named list that contains information
about the parsed mod specification. Currently it contains:
</p>

<dl>
<dt><code>name</code></dt><dd><p>the module or package name</p>
</dd>
<dt><code>prefix</code></dt><dd><p>the prefix, if the spec is a module</p>
</dd>
<dt><code>attach</code></dt><dd><p>a named vector of symbols to attach, or
<code>TRUE</code> to attach all symbols, or <code>NULL</code> to attach nothing</p>
</dd>
<dt><code>alias</code></dt><dd><p>the module or package alias</p>
</dd>
<dt><code>explicit</code></dt><dd><p>a logical value indicating whether the caller
provided an explicit alias</p>
</dd>
</dl>


<hr>
<h2 id='throw'>Throw informative error messages</h2><span id='topic+throw'></span><span id='topic+rethrow'></span><span id='topic+rethrow_on_error'></span><span id='topic+box_error'></span>

<h3>Description</h3>

<p>Helpers to generate readable and informative error messages for package
users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>throw(..., call = sys.call(sys.parent()), subclass = NULL)

rethrow(error, call = sys.call(sys.parent()))

rethrow_on_error(expr, call = sys.call(sys.parent()))

box_error(message, call = NULL, subclass = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="throw_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>fmt</code></p>
</td></tr>
<tr><td><code id="throw_+3A_call">call</code></td>
<td>
<p>the calling context from which the error is raised</p>
</td></tr>
<tr><td><code id="throw_+3A_subclass">subclass</code></td>
<td>
<p>an optional subclass name for the error condition to be
raised</p>
</td></tr>
<tr><td><code id="throw_+3A_error">error</code></td>
<td>
<p>an object of class <code>c("error", "condition")</code> to rethrow</p>
</td></tr>
<tr><td><code id="throw_+3A_expr">expr</code></td>
<td>
<p>an expression to evaluate inside <code>tryCatch</code></p>
</td></tr>
<tr><td><code id="throw_+3A_message">message</code></td>
<td>
<p>the error message</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>rethrow</code>, the <code>call</code> argument overrides the rethrown error’s
own stored call.
</p>


<h3>Value</h3>

<p>If it does not throw an error, <code>rethrow_on_error</code> returns the
value of evaluating <code>expr</code>.
</p>
<p><code>box_error</code> returns a new &lsquo;box&rsquo; error condition object
with a given message and call, and optionally a given subclass type.
</p>

<hr>
<h2 id='topenv'>Get a module’s namespace environment</h2><span id='topic+topenv'></span>

<h3>Description</h3>

<p>Called inside a module, <code>box::topenv()</code> returns the module namespace
environment. Otherwise, it behaves similarly to <code><a href="base.html#topic+topenv">topenv</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::topenv()

box::topenv(env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topenv_+3A_module">module</code></td>
<td>
<p>a module environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>box::topenv()</code> returns the top-level module environment of the
module it is called from, or the nearest top-level non-module environment
otherwise; this is usually <code>.GlobalEnv</code>.
</p>
<p><code>box::topenv(env)</code> returns the nearest top-level environment that is a
direct or indirect parent of <code>env</code>.
</p>

<hr>
<h2 id='unload'>Unload or reload modules</h2><span id='topic+unload'></span><span id='topic+reload'></span><span id='topic+purge_cache'></span>

<h3>Description</h3>

<p>Given a module which has been previously loaded and is assigned to an alias
<code>mod</code>, <code>box::unload(mod)</code> unloads it; <code>box::reload(mod)</code>
unloads and reloads it from its source. <code>box::purge_cache()</code> marks all
modules as unloaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::unload(mod)

box::reload(mod)

box::purge_cache()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unload_+3A_mod">mod</code></td>
<td>
<p>a module object to be unloaded or reloaded</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unloading a module causes it to be removed from the internal cache such that
the next subsequent <code>box::use</code> declaration will reload the module from
its source. <code>box::reload</code> unloads and reloads the specified modules and
all its transitive module dependencies. <code>box::reload</code> is <em>not</em>
merely a shortcut for calling <code>box::unload</code> followed by <code>box::use</code>,
because <code>box::unload</code> only unloads the specified module itself, not any
dependent modules.
</p>


<h3>Value</h3>

<p>These functions are called for their side effect. They do not return
anything.
</p>


<h3>Note</h3>

<p>Any other references to the loaded modules remain unchanged, and will
(usually) still work. Unloading and reloading modules is primarily useful for
testing during development, and <em>should not be used in production code:</em>
in particular, unloading may break other module references if the
<code>.on_unload</code> hook unloaded any binary shared libraries which are still
referenced.
</p>
<p>These functions come with a few restrictions.
<code>box::unload</code> attempts to detach names attached by the corresponding
<code>box::use</code> call.
<code>box::reload</code> attempts to re-attach these same names. This only works if
the corresponding <code>box::use</code> declaration is located in the same scope.
<code>box::purge_cache</code> only removes the internal cache of modules, it does
not actually invalidate any module references or names attached from loaded
modules.
</p>
<p><code>box::unload</code> will execute the <code>.on_unload</code> hook of the module, if
it exists.
<code>box::reload</code> will re-execute the <code>.on_load</code> hook of the module and
of all dependent modules during loading (after executing the corresponding
<code>.on_unload</code> hooks during unloading).
<code>box::purge_cache</code> will execute any existing <code>.on_unload</code> hooks in
all loaded modules.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+use">box::use</a></code>, <a href="#topic+mod-hooks">module hooks</a>
</p>

<hr>
<h2 id='use'>Import a module or package</h2><span id='topic+use'></span>

<h3>Description</h3>

<p><code>box::use</code> imports one or more modules and/or packages, and makes them
available in the calling environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box::use(prefix/mod, ...)

box::use(pkg, ...)

box::use(alias = prefix/mod, ...)

box::use(alias = pkg, ...)

box::use(prefix/mod[attach_list], ...)

box::use(pkg[attach_list], ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_+3A_...">...</code></td>
<td>
<p>further import declarations</p>
</td></tr>
<tr><td><code id="use_+3A_prefix+2Fmod">prefix/mod</code></td>
<td>
<p>a qualified module name</p>
</td></tr>
<tr><td><code id="use_+3A_pkg">pkg</code></td>
<td>
<p>a package name</p>
</td></tr>
<tr><td><code id="use_+3A_alias">alias</code></td>
<td>
<p>an alias name</p>
</td></tr>
<tr><td><code id="use_+3A_attach_list">attach_list</code></td>
<td>
<p>a list of names to attached, optionally witha aliases of
the form <code>alias = name</code>; or the special placeholder name <code>...</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>box::use(...)</code> specifies a list of one or more import declarations,
given as individual arguments to <code>box::use</code>, separated by comma.
<code>box::use</code> permits using a trailing comma after the last import
declaration. Each import declaration takes one of the following forms:
</p>

<dl>
<dt><code><var>prefix</var>/<var>mod</var></code>:</dt><dd>
<p>Import a module given the qualified module name
<code><var>prefix</var>/<var>mod</var></code> and make it available locally using the
name <code><var>mod</var></code>. The <code><var>prefix</var></code> itself can be a nested
name to allow importing specific submodules. <em>Local imports</em> can be
specified via the prefixes starting with <code>.</code> and <code>..</code>, to
override the search path and use the local path instead. See the
&lsquo;Search path&rsquo; below for details.
</p>
</dd>
<dt><code><var>pkg</var></code>:</dt><dd>
<p>Import a package <code><var>pkg</var></code> and make it available locally using its own
package name.
</p>
</dd>
<dt><code><var>alias</var> = <var>prefix</var>/<var>mod</var></code> or <code><var>alias</var> = <var>pkg</var></code>:</dt><dd>
<p>Import a module or package, and make it available locally using the name
<code><var>alias</var></code> instead of its regular module or package name.
</p>
</dd>
<dt><code><var>prefix</var>/<var>mod</var>[<var>attach_list</var>]</code> or <code><var>pkg</var>[<var>attach_list</var>]</code>:</dt><dd>
<p>Import a module or package and attach the exported symbols listed in
<code><var>attach_list</var></code> locally. This declaration does <em>not</em> make
the module/package itself available locally. To override this, provide
an alias, that is, use <code><var>alias</var> =
     <var>prefix</var>/<var>mod</var>[<var>attach_list</var>]</code> or <code><var>alias</var> =
     <var>pkg</var>[<var>attach_list</var>]</code>.
</p>
<p>The <code><var>attach_list</var></code> is a comma-separated list of names,
optionally with aliases assigned via <code>alias = name</code>. The list can
also contain the special symbol <code>...</code>, which causes <em>all</em>
exported names of the module/package to be imported.
</p>
</dd>
</dl>

<p>See the vignette at <code>vignette('box', 'box')</code> for detailed examples of
the different types of use declarations listed above.
</p>


<h3>Value</h3>

<p><code>box::use</code> has no return value. It is called for its
side effect.
</p>


<h3>Import semantics</h3>

<p>Modules and packages are loaded into dedicated namespace environments. Names
from a module or package can be selectively attached to the current scope as
shown above.
</p>
<p>Unlike with <code><a href="base.html#topic+library">library</a></code>, attaching happens <em>locally</em>,
i.e. in the caller’s environment: if <code>box::use</code> is executed in the
global environment, the effect is the same. Otherwise, the effect of
importing and attaching a module or package is limited to the caller’s local
scope (its <code>environment()</code>). When used <em>inside a module</em> at module
scope, the newly imported module is only available inside the module’s scope,
not outside it (nor in other modules which might be loaded).
</p>
<p>Member access of (non-attached) exported names of modules and packages
happens via the <code>$</code> operator. This operator does not perform partial
argument matching, in contrast with the behavior of the <code>$</code> operator in
base <span class="rlang"><b>R</b></span>, which matches partial names.
</p>
<p><strong>Note</strong> that replacement functions (i.e. functions of the form
<code>fun&lt;-</code>) must be <em>attached</em> to be usable, because <span class="rlang"><b>R</b></span> syntactically
does not allow assignment calls where the left-hand side of the assignment
contains <code>$</code>.
</p>


<h3>Export specification</h3>

<p>Names defined in modules can be marked as <em>exported</em> by prefixing them
with an <code>@export</code> tag comment; that is, the name needs to be immediately
prefixed by a comment that reads, verbatim, <code>#' @export</code>. That line may
optionally be part of a <span class="pkg">roxygen2</span> documentation for that name.
</p>
<p>Alternatively, exports may be specified via the
<code><a href="#topic+export">box::export</a></code> function, but using declarative
<code>@export</code> tags is generally preferred.
</p>
<p>A module which has not declared any exports is treated as a <em>legacy
module</em> and exports <em>all</em> default-visible names (that is, all names that
do not start with a dot (<code>.</code>). This usage is present only for backwards
compatibility with plain <span class="rlang"><b>R</b></span> scripts, and its usage is <em>not recommended</em>
when writing new modules.
</p>
<p>To define a module that exports no names, call <code>box::export()</code> without
arguments. This prevents the module from being treated as a legacy module.
</p>


<h3>Search path</h3>

<p>Modules are searched in the module search path, given by
<code>getOption('box.path')</code>. This is a character vector of paths to search,
from the highest to the lowest priority. The current directory is always
considered last. That is, if a file &lsquo;<span class="file">a/b.r</span>&rsquo; exists both locally in the
current directory and in a module search path, the local file &lsquo;<span class="file">./a/b.r</span>&rsquo;
will <em>not</em> be loaded, unless the import is explicitly declared as
<code>box::use(./a/b)</code>.
</p>
<p>Modules in the module search path <em>must be organised in subfolders</em>, and
must be imported fully qualified. Keep in mind that <code>box::use(name)</code>
will <em>never</em> attempt to load a module; it always attempts to load a
package. A common module organisation is by project, company or user name;
for instance, fully qualified module names could mirror repository names on
source code sharing websites (such as GitHub).
</p>
<p>Given a declaration <code>box::use(a/b)</code> and a search path &lsquo;<span class="file"><var>p</var></span>&rsquo;, if
the file &lsquo;<span class="file"><var>p</var>/a/b.r</span>&rsquo; does not exist, <span class="pkg">box</span> alternatively looks
for a nested file &lsquo;<span class="file"><var>p</var>/a/b/__init__r</span>&rsquo; to load. Module path names are
<em>case sensitive</em> (even on case insensitive file systems), but the file
extension can be spelled as either &lsquo;<span class="file">.r</span>&rsquo; or &lsquo;<span class="file">.R</span>&rsquo; (if both exist,
<code>.r</code> is given preference).
</p>
<p>The module search path can be overridden by the environment variable
<span class="env">R_BOX_PATH</span>. If set, it may consist of one or more search paths,
separated by the platform’s path separator (i.e. <code>;</code> on Windows, and
<code>:</code> on most other platforms).
</p>
<p><strong>Deprecation warning:</strong> in the next major version, <span class="pkg">box</span> will read
environment variables only <em>once</em>, at package load time. Modifying the
value of <span class="env">R_BOX_PATH</span> afterwards will have no effect, unless the package
is unloaded and reloaded.
</p>
<p>The <em>current directory</em> is context-dependent: inside a module, the
directory corresponds to the module’s directory. Inside an <span class="rlang"><b>R</b></span> code file
invoked from the command line, it corresponds to the directory containing
that file. If the code is running inside a <span class="pkg">Shiny</span> application or a
<span class="pkg">knitr</span> document, the directory of the execution is used. Otherwise (e.g.
in an interactive <span class="rlang"><b>R</b></span> session), the current working directory as given by
<code>getwd()</code> is used.
</p>
<p>Local import declarations (that is, module prefixes that start with <code>./</code>
or <code>../</code>) never use the search path to find the module. Instead,
only the current module’s directory (for <code>./</code>) or the parent module’s
directory (for <code>../</code>) is looked at. <code>../</code> can be nested:
<code>../../</code> denotes the grandparent module, etc.
</p>


<h3>S3 support</h3>

<p>Modules can contain S3 generics and methods. To override known generics
(= those defined outside the module), methods inside a module need to be
registered using <code><a href="#topic+register_S3_method">box::register_S3_method</a></code>.
See the documentation there for details.
</p>


<h3>Module names</h3>

<p>A module’s full name consists of one or more <span class="rlang"><b>R</b></span> names separated by <code>/</code>.
Since <code>box::use</code> declarations contain <span class="rlang"><b>R</b></span> expressions, the names need to
be valid <span class="rlang"><b>R</b></span> names. Non-syntactic names need to be wrapped in backticks; see
<a href="base.html#topic+Quotes">Quotes</a>.
</p>
<p>Furthermore, since module names usually correspond to file or folder names,
they should consist only of valid path name characters to ensure portability.
</p>


<h3>Encoding</h3>

<p>All module source code files are assumed to be UTF-8 encoded.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+name">box::name</a></code> and <code><a href="#topic+file">box::file</a></code> give
information about loaded modules.
<code><a href="#topic+help">box::help</a></code> displays help for a module’s exported names.
<code><a href="#topic+unload">box::unload</a></code> and <code><a href="#topic+reload">box::reload</a></code> aid
during module development by performing dynamic unloading and reloading of
modules in a running <span class="rlang"><b>R</b></span> session.
<code><a href="#topic+export">box::export</a></code> can be used as an alternative to
<code>@export</code> comments inside a module to declare module exports.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set the module search path for the example module.
old_opts = options(box.path = system.file(package = 'box'))

# Basic usage
# The file `mod/hello_world.r` exports the functions `hello` and `bye`.
box::use(mod/hello_world)
hello_world$hello('Robert')
hello_world$bye('Robert')

# Using an alias
box::use(world = mod/hello_world)
world$hello('John')

# Attaching exported names
box::use(mod/hello_world[hello])
hello('Jenny')
# Exported but not attached, thus access fails:
try(bye('Jenny'))

# Attach everything, give `hello` an alias:
box::use(mod/hello_world[hi = hello, ...])
hi('Eve')
bye('Eve')

# Reset the module search path
on.exit(options(old_opts))

## Not run: 
# The following code illustrates different import declaration syntaxes
# inside a single `box::use` declaration:

box::use(
    global/mod,
    mod2 = ./local/mod,
    purrr,
    tbl = tibble,
    dplyr = dplyr[filter, select],
    stats[st_filter = filter, ...],
)

# This declaration makes the following names available in the caller’s scope:
#
# 1. `mod`, which refers to the module environment for  `global/mod`
# 2. `mod2`, which refers to the module environment for `./local/mod`
# 3. `purrr`, which refers to the package environment for ‘purrr’
# 4. `tbl`, which refers to the package environment for ‘tibble’
# 5. `dplyr`, which refers to the package environment for ‘dplyr’
# 6. `filter` and `select`, which refer to the names exported by ‘dplyr’
# 7. `st_filter`, which refers to `stats::filter`
# 8. all other exported names from the ‘stats’ package

## End(Not run)
</code></pre>

<hr>
<h2 id='wrap_unsafe_function'>Wrap &ldquo;unsafe calls&rdquo; functions</h2><span id='topic+wrap_unsafe_function'></span>

<h3>Description</h3>

<p><code>wrap_unsafe_function</code> declares a function wrapper to a function that
causes an <code>R CMD check</code> NOTE when called directly. We should usually
not call these functions, but we need some of them because we want to
explicitly support features they provide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_unsafe_function(ns, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrap_unsafe_function_+3A_ns">ns</code></td>
<td>
<p>The namespace of the unsafe function.</p>
</td></tr>
<tr><td><code id="wrap_unsafe_function_+3A_name">name</code></td>
<td>
<p>The name of the unsafe function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wrap_unsafe_calls</code> returns a wrapper function with the same
argument as the wrapped function that can be called without causing a NOTE.
</p>


<h3>Note</h3>

<p>Using an implementation that simply aliases <code>getExportedValue</code>
does not work, since <code>R CMD check</code> sees right through this
&ldquo;ruse&rdquo;.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
