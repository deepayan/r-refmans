<!DOCTYPE html><html lang="en"><head><title>Help for package REffectivePred</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {REffectivePred}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#c_helper'><p>Contact rate function.</p></a></li>
<li><a href='#ci.curve'><p>Confidence bands</p></a></li>
<li><a href='#estimate.mle'><p>Fit the Model</p></a></li>
<li><a href='#find_ends'><p>Detect end of waves</p></a></li>
<li><a href='#find_starts'><p>Detect start of waves</p></a></li>
<li><a href='#load_config'><p>Load configuration file</p></a></li>
<li><a href='#log_lklh'><p>The likelihood function</p></a></li>
<li><a href='#modif.helper'><p>Helper function which ensures that parameters are within specified bounds. Called by the estimate.mle.</p>
Note: this is an internal function which should not be modified.</a></li>
<li><a href='#navigate_to_config'><p>Navigate to the config file</p></a></li>
<li><a href='#plot_outputs'><p>Plotting function</p></a></li>
<li><a href='#pred.curve'><p>Epidemic Curve Model</p></a></li>
<li><a href='#ranges_to_waves'><p>Utility function for range manipulation</p></a></li>
<li><a href='#re_predict'><p>Demo of main functions</p></a></li>
<li><a href='#rt_empirical'><p>Empirical estimate of <code class="reqn">R_t</code></p></a></li>
<li><a href='#serial.helper'><p>Serial interval</p></a></li>
<li><a href='#waves_1d_list'><p>Utility function for range manipulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pandemic Prediction Model in an SIRS Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of methods to fit and predict case count data using 
    a compartmental SIRS (Susceptible – Infectious – Recovered – Susceptible) 
    model, based on an assumed specification of the effective reproduction 
    number. The significance of this approach is that it relates epidemic 
    progression to the average number of contacts of infected individuals, 
    which decays as a function of the total susceptible fraction remaining 
    in the population. The main functions are pred.curve(), which computes 
    the epidemic curve for a set of parameters, and estimate.mle(), which 
    finds the best fitting curve to observed data. The easiest way to pass 
    arguments to the functions is via a config file, which contains input 
    settings required for prediction, and the package offers two methods, 
    navigate_to_config()  which points the user to the configuration file, 
    and re_predict() for starting the fit-predict process. The main model was published in
    Razvan G. Romanescu et al. &lt;<a href="https://doi.org/10.1016%2Fj.epidem.2023.100708">doi:10.1016/j.epidem.2023.100708</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>yaml, config, zoo, grDevices, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'prediction_model.v16.R' 'executions.v16.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-11 20:30:06 UTC; romanesr</td>
</tr>
<tr>
<td>Author:</td>
<td>Razvan Romanescu [aut, cre],
  Songdi Hu [aut],
  Md Ashiqul Haque [aut],
  Olivier Tremblay-Savard [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Razvan Romanescu &lt;razvan_romanescu@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-12 09:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='c_helper'>Contact rate function.</h2><span id='topic+c_helper'></span>

<h3>Description</h3>

<p>Computes the c() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_helper(
  rt_func = 1,
  st.inner = NULL,
  a1 = NULL,
  a2 = NULL,
  a3 = NULL,
  a4 = NULL,
  psi = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_helper_+3A_rt_func">rt_func</code></td>
<td>
<p>Options are:
</p>

<ul>
<li><p> 1 - Two piece exponential.
</p>
</li>
<li><p> 2 - Exponential power model adapted from Granich et al. (2009)
</p>
</li>
<li><p> 3 - Mass action.
</p>
</li>
<li><p> 4 - Shifted inverse.
</p>
</li>
<li><p> 5 - Power.
</p>
</li>
<li><p> 6 - Poisson.
</p>
</li>
<li><p> 7 - Geometric.
</p>
</li></ul>
</td></tr>
<tr><td><code id="c_helper_+3A_st.inner">st.inner</code></td>
<td>
<p>The susceptible fraction <code class="reqn">S_t</code>.</p>
</td></tr>
<tr><td><code id="c_helper_+3A_a1">a1</code>, <code id="c_helper_+3A_a2">a2</code>, <code id="c_helper_+3A_a3">a3</code>, <code id="c_helper_+3A_a4">a4</code></td>
<td>
<p>Parameters of the contact rate curve specified by <code>rt_func</code>;</p>
</td></tr>
<tr><td><code id="c_helper_+3A_psi">psi</code></td>
<td>
<p>A vector of same length as st.inner containing the corresponding psi restriction factor, or a scalar.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Romanescu et al. (2023) for the exact forms of the functions.
</p>


<h3>Value</h3>

<p>The value of the contact rate, used to compute <code class="reqn">R_t</code>.
</p>

<hr>
<h2 id='ci.curve'>Confidence bands</h2><span id='topic+ci.curve'></span>

<h3>Description</h3>

<p>Computes the pointwise confidence interval of the epidemic curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.curve(
  fit = NULL,
  H.E = NULL,
  H.W = NULL,
  scenario = NULL,
  cases = NULL,
  cfg = NULL,
  restrictions = NULL,
  restriction.starts = NULL,
  ranges = NULL,
  rt_func = 1,
  fit.t.pred = NULL,
  predict.beyond = 0,
  lt = NULL,
  adj.period = NULL,
  population = NULL,
  rho = NULL,
  serial_mean = NULL,
  serial_var = NULL,
  window_size = NULL,
  eps = .Machine$double.eps^(1/2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci.curve_+3A_fit">fit</code></td>
<td>
<p>Output from function estimate.mle.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_h.e">H.E</code></td>
<td>
<p>Mobility metrics for category Retail &amp; Entertainment. Currently unsupported.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_h.w">H.W</code></td>
<td>
<p>Mobility metrics for category Workplaces. Currently unsupported.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_scenario">scenario</code></td>
<td>
<p>A character string describing options to deal with restrictions. Currently unsupported.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_cases">cases</code></td>
<td>
<p>vector of case counts.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_cfg">cfg</code></td>
<td>
<p>The object that contains all variables from the configuration file.
<code>fit</code>, <code>H.E</code>, <code>H.W</code>, <code>scenario</code>, and <code>cases</code> are also required
for the method to execute. All other parameters will not be used if <code>cfg</code> is passed to the method.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_restrictions">restrictions</code></td>
<td>
<p>A numeric integer vector giving the severity of restrictions.
Zero means no restriction, and higher numbers means greater severity/disruption.
The ordered unique values should be consecutive integers starting from zero.
Each number (other than 0) adds a new parameter to the fit.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_restriction.starts">restriction.starts</code></td>
<td>
<p>A vector of same length as restrictions, of times when restrictions
came into effect. Note: the first index time should be 1.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_ranges">ranges</code></td>
<td>
<p>A vector of time ranges for the different waves.
The wave ranges should be contiguous, with at least one unit of time
between consecutive waves.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_rt_func">rt_func</code></td>
<td>
<p>The parametric form of function c(). Options are listed under function c_helper.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_fit.t.pred">fit.t.pred</code></td>
<td>
<p>Time from which prediction is done. If use.actual.not.predicted is TRUE, values of <code class="reqn">S_t</code> before this time will be computed using actual counts.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_predict.beyond">predict.beyond</code></td>
<td>
<p>Number of days to predict beyond the end of <code>cases</code>. See Details for usage notes.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_lt">lt</code></td>
<td>
<p>The length of cases.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_adj.period">adj.period</code></td>
<td>
<p>Adjustment period following a change in severity level. Restriction level (psi) is linearly interpolated from the old to the new value over this period.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_population">population</code></td>
<td>
<p>Total population size.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_rho">rho</code></td>
<td>
<p>A vector of under-reporting rates of the same length as cases. If a scalar is supplied, the vector will be constant with this value.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_serial_mean">serial_mean</code></td>
<td>
<p>Mean of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_serial_var">serial_var</code></td>
<td>
<p>Variance of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_window_size">window_size</code></td>
<td>
<p>The maximum value for the serial interval.</p>
</td></tr>
<tr><td><code id="ci.curve_+3A_eps">eps</code></td>
<td>
<p>The epsilon value for computing finite differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with two rows containing Wald-style confidence bounds:
</p>

<ul>
<li><p> ci_lower - lower bound of a 95% pointwise CI of the best fit curve.
</p>
</li>
<li><p> ci_upper - upper bound of a 95% pointwise CI of the best fit curve.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(REffectivePred)
## Read in the data
path_to_data &lt;- system.file("extdata/NY_OCT_4_2022.csv", package = "REffectivePred")
data &lt;- read.csv(path_to_data)
head(data)
cases &lt;- diff(c(0, data$cases)) # Convert cumulative cases into daily cases
lt &lt;- length(cases)             # Length of cases
Time &lt;- as.Date(data$date, tryFormats = c("%d-%m-%Y", "%d/%m/%Y"))

navigate_to_config() # Open the config file, make any necessary changes here.
path_to_config &lt;- system.file("config.yml", package = "REffectivePred")  # Read config file
cfg &lt;- load_config()    # Build the cfg object

# Estimate parameters
est &lt;- estimate.mle(
    cases = cases,
    cfg = cfg,
    hessian = TRUE
    )
a1 &lt;- est$a1
a2 &lt;- est$a2
a3 &lt;- est$a3
a4 &lt;- est$a4
nu &lt;- est$nu
vt &lt;- c(1, est$vt_params_est)
psi &lt;- est$Psi
betas &lt;- est$betas

# Predict curve
r1 &lt;- pred.curve(
a1 = a1,
a2 = a2,
a3 = a3,
a4 = a4,
nu = nu,
variant.transm = vt,
Psi = psi,
betas = betas,
cases = cases,
cfg = cfg
)

plot_outputs(Time = Time,
cases = cases,
cfg = cfg,
curve = r1,
option = 2
)

bounds &lt;- ci.curve(fit = est,
                   cases = cases,
                   cfg = cfg)

# Adding CI bands
# lines(c(Time, Time[length(Time)]+(1:predict.beyond)), bounds[2,], lty = 2)
# lines(c(Time, Time[length(Time)]+(1:predict.beyond)), bounds[1,], lty = 2)


</code></pre>

<hr>
<h2 id='estimate.mle'>Fit the Model</h2><span id='topic+estimate.mle'></span>

<h3>Description</h3>

<p>Estimate the parameters of the model by maximizing the likelihood function (or, rather, by minimizing the negative log likelihood).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate.mle(
  hessian = FALSE,
  H.E = NULL,
  H.W = NULL,
  cases = NULL,
  cfg = NULL,
  ini_params = NULL,
  params_limits = NULL,
  restrictions = NULL,
  restriction.starts = NULL,
  ranges = NULL,
  rt_func = 1,
  silence.errors = FALSE,
  fit.t.pred = NULL,
  param_scale = NULL,
  num.iter = NULL,
  scenario = NULL,
  adj.period = NULL,
  population = NULL,
  rho = NULL,
  serial_mean = serial_mean,
  serial_var = serial_var,
  lt = NULL,
  window_size = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate.mle_+3A_hessian">hessian</code></td>
<td>
<p>Logical. If TRUE, computes the variance-covariance matrix at the MLE.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_h.e">H.E</code></td>
<td>
<p>Mobility metrics for category Retail &amp; Entertainment. Currently unsupported.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_h.w">H.W</code></td>
<td>
<p>Mobility metrics for category Workplaces. Currently unsupported.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_cases">cases</code></td>
<td>
<p>Vector of case counts.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_cfg">cfg</code></td>
<td>
<p>The object that contains all variables from the configuration file.
This includes all function arguments except for <code>cases</code>, <code>hessian</code>, <code>H.E</code>, and <code>H.W</code>. All other
arguments are overridden if <code>cfg</code> is passed to the method.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_ini_params">ini_params</code></td>
<td>
<p>Initial parameter values to be used in optimization. Includes the following sets of parameters in a vector, in this order:
</p>

<ul>
<li><p>   (a1,a2,a3,a4) = parameters for curve c() specified by <code>rt_func</code>;
</p>
</li>
<li><p>   nu = loss of immunity rate;
</p>
</li>
<li><p>   (v2,v3,v4,v5) = transmissibility of variants in waves 2+, as relative multiplication factors compared to transmissibility in wave 1;
</p>
</li>
<li><p>   (psi1,psi2,psi3,psi4) = psi parameters for severity levels 1,2,3 and 4.
</p>
</li>
<li><p>   (u,v) = variance parameters. Only u is currently in use.
</p>
</li>
<li><p>   (beta0,beta.R,beta.E,beta.W), when restrictions = NULL. Currently unsupported.
</p>
</li></ul>
</td></tr>
<tr><td><code id="estimate.mle_+3A_params_limits">params_limits</code></td>
<td>
<p>Boundaries/limits of the ini_params.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_restrictions">restrictions</code></td>
<td>
<p>A numeric integer vector giving the severity of restrictions.
Zero means no restriction, and higher numbers means greater severity/disruption.
The ordered unique values should be consecutive integers starting from zero.
Each number (other than 0) adds a new parameter to the fit. restrictions = NULL
causes the function to use mobility data instead of the psi values (currently unsupported).</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_restriction.starts">restriction.starts</code></td>
<td>
<p>A vector of same length as restrictions, of times when restrictions
came into effect. Note: the first index time should be 1.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_ranges">ranges</code></td>
<td>
<p>An vector of time ranges for the different waves.
The waves ranges should be contiguous, with at least one unit of time
between consecutive waves.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_rt_func">rt_func</code></td>
<td>
<p>The parametric form of function c(). Options are listed under function c_helper.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_silence.errors">silence.errors</code></td>
<td>
<p>Logical. If TRUE, ignores certain errors to allow optimization to proceed. Not all errors can be ignored.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_fit.t.pred">fit.t.pred</code></td>
<td>
<p>Time from which prediction is done. If use.actual.not.predicted is TRUE, values of <code class="reqn">S_t</code> before this time will be computed using actual counts.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_param_scale">param_scale</code></td>
<td>
<p>Parameter scale. Passed as argument parscale to optim.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_num.iter">num.iter</code></td>
<td>
<p>Maximum number of iterations. Passed as argument maxit to optim.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_scenario">scenario</code></td>
<td>
<p>A character string describing options to deal with restrictions. Currently unsupported.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_adj.period">adj.period</code></td>
<td>
<p>Delays in society adjusting.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_population">population</code></td>
<td>
<p>total population size.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_rho">rho</code></td>
<td>
<p>A vector of under-reporting rates of the same length as cases. If a scalar is supplied, the vector will be constant with this value.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_serial_mean">serial_mean</code></td>
<td>
<p>Mean of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_serial_var">serial_var</code></td>
<td>
<p>Variance of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_lt">lt</code></td>
<td>
<p>The length of cases.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_window_size">window_size</code></td>
<td>
<p>The maximum value for the serial interval.</p>
</td></tr>
<tr><td><code id="estimate.mle_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, provides additional details while running the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of maximum likelihood estimates of the parameters. Includes:
</p>

<ul>
<li><p> a1
</p>
</li>
<li><p> a2
</p>
</li>
<li><p> a3
</p>
</li>
<li><p> a4
</p>
</li>
<li><p> nu
</p>
</li>
<li><p> vt_params_est
</p>
</li>
<li><p> Psi
</p>
</li>
<li><p> betas
</p>
</li>
<li><p> negative_log_lik
</p>
</li>
<li><p> mle
</p>
</li>
<li><p> hessian
</p>
</li>
<li><p> SE
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(REffectivePred)
## Read in the data
path_to_data &lt;- system.file("extdata/NY_OCT_4_2022.csv", package = "REffectivePred")
data &lt;- read.csv(path_to_data)
head(data)
cases &lt;- diff(c(0, data$cases)) # Convert cumulative cases into daily cases
lt &lt;- length(cases)             # Length of cases
Time &lt;- as.Date(data$date, tryFormats = c("%d-%m-%Y", "%d/%m/%Y"))

navigate_to_config() # Open the config file, make any necessary changes here.
path_to_config &lt;- system.file("config.yml", package = "REffectivePred")  # Read config file
cfg &lt;- load_config()    # Build the cfg object

##### Option 1: populate the global environment with args to pass to function.
population &lt;- cfg$population # Population size
window_size &lt;- cfg$window.size
adj.period &lt;- cfg$adj.period
fit.t.pred &lt;- cfg$fit.t.pred # Time of prediction
not.predict &lt;- cfg$not.predict
rt.func.num &lt;- cfg$rt.func.num # choose which Rt function you want to use
num.iter &lt;- cfg$num.iter
silence.errors &lt;- cfg$silence.errors
predict.beyond &lt;- cfg$predict.beyond
curve_params &lt;- as.double(unlist(cfg$curve_params))
vt_params &lt;- as.double(unlist(cfg$vt_params)) # The vt initial values, starting at wave 2
restriction_levels &lt;- as.double(unlist(cfg$restriction_levels)) # Psi, u, and v parameters
betas &lt;- as.double(unlist(cfg$betas)) #   betas
ini_params &lt;- c(curve_params, vt_params, restriction_levels, betas)
restrictions_params &lt;- cfg$restrictions_params
restriction_st_params &lt;- cfg$restriction_st_params
param_scale &lt;- abs(ini_params) / 10
waves_list &lt;- ranges_to_waves(cfg$waves_list)
params_limits &lt;- cfg$params_limits
num_waves &lt;- cfg$num_waves
waves &lt;- waves_1d_list(num_waves, waves_list)
rho &lt;- eval(parse(text = cfg$rho))
serial_mean &lt;- cfg$serial_mean
serial_var &lt;- cfg$serial_var

est &lt;- estimate.mle(
  ini_params = ini_params,
  params_limits = params_limits,
  restrictions = restrictions_params,
  restriction.starts = restriction_st_params,
  ranges = waves,
  rt_func = rt.func.num,
  silence.errors = silence.errors,

  fit.t.pred = fit.t.pred,
  param_scale = param_scale,
  num.iter = num.iter,
  cases = cases,
  scenario = NULL,
  H.E = NULL,
  H.W = NULL,
  adj.period = adj.period,
  population = population,
  rho = rho,
  serial_mean = serial_mean,
  serial_var = serial_var,
  lt = lt,
  window_size = window_size,
  hessian = FALSE
)
print(est)

##### Option 2: pass the cfg object instead.
est &lt;- estimate.mle(
    cases = cases,
    cfg = cfg,
    hessian = FALSE
    )
print(est)
</code></pre>

<hr>
<h2 id='find_ends'>Detect end of waves</h2><span id='topic+find_ends'></span>

<h3>Description</h3>

<p>Find the approximate end times of waves given times of peaks. This is based on local minima of <code class="reqn">R_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ends(rt_values, peaks_x, search_range)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_ends_+3A_rt_values">rt_values</code></td>
<td>
<p>A vector containing rt values for each time point.</p>
</td></tr>
<tr><td><code id="find_ends_+3A_peaks_x">peaks_x</code></td>
<td>
<p>Time points of peaks based on daily cases (one for each wave).</p>
</td></tr>
<tr><td><code id="find_ends_+3A_search_range">search_range</code></td>
<td>
<p>The range of data points to go through for filtering invalid ends (a vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This is provided for convenience only, and is not meant to replace an analyst's determination of wave bounds.
</p>


<h3>Value</h3>

<p>A list containing the detected end times of waves, as scalars.
</p>

<hr>
<h2 id='find_starts'>Detect start of waves</h2><span id='topic+find_starts'></span>

<h3>Description</h3>

<p>Find the approximate beginning times of waves given times of peaks. This is based on local maxima of <code class="reqn">R_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_starts(rt_values, peaks_x, search_range)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_starts_+3A_rt_values">rt_values</code></td>
<td>
<p>A vector containing rt values for each time point.</p>
</td></tr>
<tr><td><code id="find_starts_+3A_peaks_x">peaks_x</code></td>
<td>
<p>Time points of peaks based on daily cases (one for each wave).</p>
</td></tr>
<tr><td><code id="find_starts_+3A_search_range">search_range</code></td>
<td>
<p>The range of data points to go through for filtering invalid beginnings (a vector).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: This is provided for convenience only, and is not meant to replace an analyst's determination of wave bounds.
</p>


<h3>Value</h3>

<p>A list containing the detected start times of waves, as scalars.
</p>

<hr>
<h2 id='load_config'>Load configuration file</h2><span id='topic+load_config'></span>

<h3>Description</h3>

<p>Load the configuration file as an object in the global
environment. This can be passed to the main functions instead of the
individual arguments within, for user convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_config()
</code></pre>


<h3>Value</h3>

<p>A ’config’ object, which is a list that stores input parameters and
settings from config.yml. Variable names are imported exactly. See the
configuration file for details.
</p>

<hr>
<h2 id='log_lklh'>The likelihood function</h2><span id='topic+log_lklh'></span>

<h3>Description</h3>

<p>The negative log likelihood function of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_lklh(
  param,
  params_limits,
  restrictions = NULL,
  restriction.starts = NULL,
  ranges = NULL,
  rt_func = 1,
  silence.errors = FALSE,
  fit.t.pred,
  lt,
  cases,
  scenario = NULL,
  H.E,
  H.W,
  adj.period,
  population,
  rho,
  serial_mean,
  serial_var,
  window_size
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_lklh_+3A_param">param</code></td>
<td>
<p>Includes the following sets of parameters in a vector, in this order:
</p>

<ul>
<li><p> a1,a2,a3,a4 - Parameters for curve c() specified by <code>rt_func</code>.
</p>
</li>
<li><p> nu - Loss of Immunity rate.
</p>
</li>
<li><p> v2,v3,v4,v5 - Transmissibility of variants in waves 2+, as relative multiplication factors compared to transmissibility in wave 1.
</p>
</li>
<li><p> psi1,psi2,psi3,psi4 - Psi parameters for severity levels 1,2,3 and 4.
</p>
</li>
<li><p> u,v - Variance parameters. Only u is currently in use.
</p>
</li>
<li><p> beta0,beta.R,beta.E,beta.W - When restrictions = NULL. Currently unsupported.
</p>
</li></ul>
</td></tr>
<tr><td><code id="log_lklh_+3A_params_limits">params_limits</code></td>
<td>
<p>Boundaries/limits of the ini_params.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_restrictions">restrictions</code></td>
<td>
<p>A numeric integer vector giving the severity of restrictions.
Zero means no restriction, and higher numbers means greater severity/disruption.
The ordered unique values should be consecutive integers starting from zero.
Each number (other than 0) adds a new parameter to the fit. restrictions = NULL
causes the function to use mobility data instead of the psi values (currently unsupported).</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_restriction.starts">restriction.starts</code></td>
<td>
<p>A vector of same length as restrictions, of times when restrictions
came into effect. Note: the first index time should be 1.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_ranges">ranges</code></td>
<td>
<p>An vector of time ranges for the different waves.
The wave ranges should be contiguous, with at least one unit of time
between consecutive waves.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_rt_func">rt_func</code></td>
<td>
<p>The parametric form of function c(). Options are listed under function c_helper.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_silence.errors">silence.errors</code></td>
<td>
<p>Ignores (skips) NA or NaN values when summing up likelihood contributions over time.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_fit.t.pred">fit.t.pred</code></td>
<td>
<p>Time of prediction.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_lt">lt</code></td>
<td>
<p>Length of cases.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_cases">cases</code></td>
<td>
<p>A vector containing cases for each time-point.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_scenario">scenario</code></td>
<td>
<p>A character string describing options to deal with restrictions. Currently unsupported.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_h.e">H.E</code></td>
<td>
<p>Mobility metrics for category Retail &amp; Entertainment. Currently unsupported.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_h.w">H.W</code></td>
<td>
<p>Mobility metrics for category Workplaces. Currently unsupported.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_adj.period">adj.period</code></td>
<td>
<p>Delays in society adjusting.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_population">population</code></td>
<td>
<p>total population size.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_rho">rho</code></td>
<td>
<p>Under-reporting fraction.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_serial_mean">serial_mean</code></td>
<td>
<p>Mean of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_serial_var">serial_var</code></td>
<td>
<p>Variance of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="log_lklh_+3A_window_size">window_size</code></td>
<td>
<p>The maximum value for the serial interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predicted curve is computed based on parameters supplied, by first calling the prediction
function <code>pred.curve</code>. The probability model used to compute the likelihood assumes that observed
infection at time <code class="reqn">t</code> are <code class="reqn">\sim N(mean = I_t, sd = \sqrt{u*I_t})</code>, where <code class="reqn">I_t</code> are predicted infections, and sums the
log-likelihood contributions for each time <code class="reqn">t</code> during waves, and up to <code>fit.t.pred</code>.
</p>


<h3>Value</h3>

<p>The negative log likelihood value of the data.
</p>

<hr>
<h2 id='modif.helper'>Helper function which ensures that parameters are within specified bounds. Called by the estimate.mle.
Note: this is an internal function which should not be modified.</h2><span id='topic+modif.helper'></span>

<h3>Description</h3>

<p>Helper function which ensures that parameters are within specified bounds. Called by the estimate.mle.
Note: this is an internal function which should not be modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modif.helper(params_modif, params_limits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modif.helper_+3A_params_modif">params_modif</code></td>
<td>
<p>Raw parameter vector, in the same order as argument ini_param in estimate.mle.</p>
</td></tr>
<tr><td><code id="modif.helper_+3A_params_limits">params_limits</code></td>
<td>
<p>Boundaries/limits of the ini_params.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified parameters (bounded, if needed).
</p>

<hr>
<h2 id='navigate_to_config'>Navigate to the config file</h2><span id='topic+navigate_to_config'></span>

<h3>Description</h3>

<p>Prints the path to the config file and opens the config file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>navigate_to_config()
</code></pre>


<h3>Value</h3>

<p>The path to the configuration file.
</p>

<hr>
<h2 id='plot_outputs'>Plotting function</h2><span id='topic+plot_outputs'></span>

<h3>Description</h3>

<p>Various plots related to an epidemic curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_outputs(
  curve = NULL,
  Time = NULL,
  cases = NULL,
  cfg = NULL,
  window_size = NULL,
  serial_mean,
  serial_var,
  predict.beyond = 0,
  waves_list = NULL,
  num_waves = NULL,
  rt_func = NULL,
  restrictions = NULL,
  restriction.starts = NULL,
  a1 = NULL,
  a2 = NULL,
  a3 = NULL,
  a4 = NULL,
  rt.max = NULL,
  option = "all",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_outputs_+3A_curve">curve</code></td>
<td>
<p>The output list from the prediction function, see <code>pred.curve</code>.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_time">Time</code></td>
<td>
<p>A vector of dates corresponding to cases.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_cases">cases</code></td>
<td>
<p>A vector containing cases for each time point.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_cfg">cfg</code></td>
<td>
<p>The object that contains all variables from the configuration file.
<code>curve</code>, <code>Time</code>, and <code>cases</code> are also required
for the method to execute. All other parameters will not be used if <code>cfg</code> is passed to the method.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_window_size">window_size</code></td>
<td>
<p>The maximum value for the serial interval.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_serial_mean">serial_mean</code></td>
<td>
<p>Mean of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_serial_var">serial_var</code></td>
<td>
<p>Variance of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_predict.beyond">predict.beyond</code></td>
<td>
<p>How many days to predict beyond the end of <code>cases</code>.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_waves_list">waves_list</code></td>
<td>
<p>A two-dimensional list containing the waves' time data.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_num_waves">num_waves</code></td>
<td>
<p>Total number of waves.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_rt_func">rt_func</code></td>
<td>
<p>A flag that indicates which rt function to use. Should match the shape of <code>curve</code>.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_restrictions">restrictions</code></td>
<td>
<p>A numeric integer vector giving the severity of restrictions.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_restriction.starts">restriction.starts</code></td>
<td>
<p>A vector of same length as restrictions, of times when restrictions
came into effect. Note: the first index time should be 1.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_a1">a1</code>, <code id="plot_outputs_+3A_a2">a2</code>, <code id="plot_outputs_+3A_a3">a3</code>, <code id="plot_outputs_+3A_a4">a4</code></td>
<td>
<p>Parameters of the contact rate curve specified by <code>rt_func</code>. These override
the values given in <code>curve</code> for the last plot only. If not specified, will use the values from <code>curve</code>.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_rt.max">rt.max</code></td>
<td>
<p>An optional upper limit for the y-axis when plotting <code class="reqn">R_t</code>.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_option">option</code></td>
<td>
<p>A choice of which plot to return (1,2, or 3 - see Value for options). If set to &quot;all&quot; (the default) plots all three figures.</p>
</td></tr>
<tr><td><code id="plot_outputs_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, provides additional details while running the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. Generates a few plots: a plot of <code class="reqn">R_t</code> over time, with waves shaded (for <code>option</code> = 1); the epidemic curve
overlaid on top of observed cases (<code>option</code> = 2), where the shading reflects restriction measures; and a plot of the
theoretical <code class="reqn">R_t</code> versus <code class="reqn">S_t</code>, in a fully susceptible population with no restrictions (<code>option</code> = 3).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(REffectivePred)
## Read in the data
path_to_data &lt;- system.file("extdata/NY_OCT_4_2022.csv", package = "REffectivePred")
data &lt;- read.csv(path_to_data)
head(data)
cases &lt;- diff(c(0, data$cases)) # Convert cumulative cases into daily cases
lt &lt;- length(cases)             # Length of cases
Time &lt;- as.Date(data$date, tryFormats = c("%d-%m-%Y", "%d/%m/%Y"))

navigate_to_config() # Open the config file, make any necessary changes here.
path_to_config &lt;- system.file("config.yml", package = "REffectivePred")  # Read config file
cfg &lt;- load_config()    # Build the cfg object

# Estimate parameters
est &lt;- estimate.mle(
    cases = cases,
    cfg = cfg
    )
a1 &lt;- est$a1
a2 &lt;- est$a2
a3 &lt;- est$a3
a4 &lt;- est$a4
nu &lt;- est$nu
vt &lt;- c(1, est$vt_params_est)
psi &lt;- est$Psi
betas &lt;- est$betas

# Predict curve
r1 &lt;- pred.curve(
a1 = a1,
a2 = a2,
a3 = a3,
a4 = a4,
nu = nu,
variant.transm = vt,
Psi = psi,
betas = betas,
cases = cases,
cfg = cfg
)

plot_outputs(Time = Time,
cases = cases,
window_size = cfg$window.size,
serial_mean = cfg$serial_mean,
serial_var = cfg$serial_var,
predict.beyond = cfg$predict.beyond,
waves_list = cfg$waves_list,
num_waves = cfg$num_waves,
rt_func = cfg$rt.func.num,
curve = r1,
restrictions = cfg$restrictions_params,
restriction.starts = cfg$restriction_st_params,
rt.max = 10
)
</code></pre>

<hr>
<h2 id='pred.curve'>Epidemic Curve Model</h2><span id='topic+pred.curve'></span>

<h3>Description</h3>

<p>Computes the epidemic curve and associated quantities for a given parameter set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.curve(
  a1 = 0,
  a2 = 0,
  a3 = 0,
  a4 = 0,
  nu = 0,
  variant.transm = NULL,
  Psi = NULL,
  betas = NULL,
  cases = NULL,
  cfg = NULL,
  use.actual.not.predicted = FALSE,
  restrictions = NULL,
  restriction.starts = NULL,
  ranges = NULL,
  rt_func = 1,
  fit.t.pred = NULL,
  predict.beyond = 0,
  scenario = NULL,
  H.E = NULL,
  H.W = NULL,
  adj.period = NULL,
  population = NULL,
  rho = NULL,
  serial_mean = NULL,
  serial_var = NULL,
  lt = NULL,
  window_size = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pred.curve_+3A_a1">a1</code>, <code id="pred.curve_+3A_a2">a2</code>, <code id="pred.curve_+3A_a3">a3</code>, <code id="pred.curve_+3A_a4">a4</code></td>
<td>
<p>Parameters of the contact rate curve specified by <code>rt_func</code>.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_nu">nu</code></td>
<td>
<p>Loss of immunity rate beyond the first wave.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_variant.transm">variant.transm</code></td>
<td>
<p>Vector of transmissibility of variants in each wave,
as relative multiplication factors compared to transmissibility in wave 1. Should always be 1 for the first wave.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_psi">Psi</code></td>
<td>
<p>Vector of restriction parameters for severity levels 1 - 4.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_betas">betas</code></td>
<td>
<p>Vector containing (beta0,beta.R,beta.E,beta.W), when restrictions = NULL. Not currently implemented.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_cases">cases</code></td>
<td>
<p>vector of case counts.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_cfg">cfg</code></td>
<td>
<p>The object that contains all variables from the configuration file.
<code>a1</code>, <code>a2</code>, <code>a3</code>, <code>a4</code>, <code>nu</code>, <code>variant.transm</code>,
<code>Psi</code>, <code>betas</code>, and <code>cases</code> are also required for the method
to execute. All other parameters will not be used if <code>cfg</code> is passed
to the method.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_use.actual.not.predicted">use.actual.not.predicted</code></td>
<td>
<p>Logical; if FALSE (default), the susceptible fraction is updated using predicted cases. Otherwise updated using actual cases.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_restrictions">restrictions</code></td>
<td>
<p>A numeric integer vector giving the severity of restrictions.
Zero means no restriction, and higher numbers means greater severity/disruption.
The ordered unique values should be consecutive integers starting from zero.
Each number (other than 0) adds a new parameter to the fit.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_restriction.starts">restriction.starts</code></td>
<td>
<p>A vector of same length as restrictions, of times when restrictions
came into effect. Note: the first index time should be 1.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_ranges">ranges</code></td>
<td>
<p>A vector of time ranges for the different waves.
The wave ranges should be contiguous, with at least one unit of time
between consecutive waves.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_rt_func">rt_func</code></td>
<td>
<p>The parametric form of function c(). Options are listed under function <code>c_helper</code>.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_fit.t.pred">fit.t.pred</code></td>
<td>
<p>Time from which prediction is done. If use.actual.not.predicted is TRUE, values of <code class="reqn">S_t</code> before this time will be computed using actual counts.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_predict.beyond">predict.beyond</code></td>
<td>
<p>Number of days to predict beyond the end of <code>cases</code>. See Details for usage notes.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_scenario">scenario</code></td>
<td>
<p>A character string describing options to deal with restrictions. Currently unsupported.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_h.e">H.E</code></td>
<td>
<p>Mobility metrics for category Retail &amp; Entertainment. Currently unsupported.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_h.w">H.W</code></td>
<td>
<p>Mobility metrics for category Workplaces. Currently unsupported.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_adj.period">adj.period</code></td>
<td>
<p>Adjustment period following a change in severity level. Restriction level (psi) is linearly interpolated from the old to the new value over this period.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_population">population</code></td>
<td>
<p>Total population size.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_rho">rho</code></td>
<td>
<p>A vector of under-reporting rates of the same length as cases. If a scalar is supplied, the vector will be constant with this value.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_serial_mean">serial_mean</code></td>
<td>
<p>Mean of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_serial_var">serial_var</code></td>
<td>
<p>Variance of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_lt">lt</code></td>
<td>
<p>The length of cases.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_window_size">window_size</code></td>
<td>
<p>The maximum value for the serial interval.</p>
</td></tr>
<tr><td><code id="pred.curve_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, provides additional details while running the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each time step, <code class="reqn">R_{t}</code> is computed using the contact rate function <code class="reqn">c(S_t)</code> implemented via <a href="#topic+c_helper">c_helper</a>. Then the number of cases is estimated using formula:
</p>
<p style="text-align: center;"><code class="reqn">y_{t+1}=R_{t} \sum_{s=1}^M w_s y_{t+1-s}</code>
</p>

<p>Finally, the fraction <code class="reqn">S_{t+1}</code> is updated. This creates a curve over the entire range of <code>ranges</code>. See Romanescu R, Hu S, Nanton D, Torabi M, Tremblay-Savard O, Haque MA. The effective reproductive number:
modeling and prediction with application to the multi-wave Covid-19 pandemic. Epidemics. 2023 Jul 20:100708 <a href="https://doi.org/10.1016/j.epidem.2023.100708">doi:10.1016/j.epidem.2023.100708</a> for more details.
</p>
<p>For predicting an ongoing wave beyond the end of cases, the end of <code>ranges</code> (or <code>waves_list</code>, if using <code>cfg</code>)
should be specified to match the <code>predict.beyond</code> argument. As well, argument <code>use.actual.not.predicted</code> should be set to FALSE when predicting beyond the end of <code>cases</code>.
</p>


<h3>Value</h3>

<p>Returns list:
</p>

<ul>
<li><p> Predicted Infections - Vector of estimated infections, computed as predicted cases divided by rho.
</p>
</li>
<li><p> Predicted Cases - Vector of predicted cases.
</p>
</li>
<li><p> Predicted <code class="reqn">R_t</code> - Vector of predicted susceptible fractions
</p>
</li>
<li><p> Predicted <code class="reqn">R_t</code> - Vector of (model) predicted <code class="reqn">R_t</code>.
</p>
</li>
<li><p> Predicted Lambda t - Vector of predicted Lambda_t, which is the numerator used in computing the empirical <code class="reqn">R_t</code>.
</p>
</li>
<li><p> Psi.vec - Vector of psi values, which pastes together parameters psi over the period they apply, or 1 when there are no restrictions.
</p>
</li>
<li><p> Contact rate params - Vector of the curve parameters (a1, a2, a3, a4).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(REffectivePred)
## Read in the data
path_to_data &lt;- system.file("extdata/NY_OCT_4_2022.csv", package = "REffectivePred")
data &lt;- read.csv(path_to_data)
head(data)
cases &lt;- diff(c(0, data$cases)) # Convert cumulative cases into daily cases
lt &lt;- length(cases)             # Length of cases
Time &lt;- as.Date(data$date, tryFormats = c("%d-%m-%Y", "%d/%m/%Y"))

navigate_to_config() # Open the config file, make any necessary changes here.
path_to_config &lt;- system.file("config.yml", package = "REffectivePred")  # Read config file
cfg &lt;- load_config()    # Build the cfg object

# Example 1. Using fits from Romanescu et al. (2023)

r1 &lt;- pred.curve(
a1 = 0.58,
a2 = 1.12,
nu = 0.56,
variant.transm = c(1,1.22,0.36,0.56),
Psi = c(0.58,0.52,0.49),
cases = cases,
cfg = cfg
)

plot(cases, xlab="Day", ylab="Predicted cases")
lines(r1$'Predicted Cases', col='red')

# Example 2. Best fit curve
est &lt;- estimate.mle(
    cases = cases,
    cfg = cfg
    )
a1 &lt;- est$a1
a2 &lt;- est$a2
a3 &lt;- est$a3
a4 &lt;- est$a4
nu &lt;- est$nu
vt &lt;- c(1, est$vt_params_est)
psi &lt;- est$Psi
betas &lt;- est$betas

r1 &lt;- pred.curve(
a1 = a1,
a2 = a2,
a3 = a3,
a4 = a4,
nu = nu,
variant.transm = vt,
Psi = psi,
betas = betas,
cases = cases,
cfg = cfg
)
plot(r1$'Predicted Infections', xlab="Day", ylab="Predicted infections")

</code></pre>

<hr>
<h2 id='ranges_to_waves'>Utility function for range manipulation</h2><span id='topic+ranges_to_waves'></span>

<h3>Description</h3>

<p>Converts a list of waves to a two-dimensional list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranges_to_waves(waves_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranges_to_waves_+3A_waves_list">waves_list</code></td>
<td>
<p>A list containing ranges (start, end) of each wave.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-dimensional list with individual waves as sub-lists.
</p>

<hr>
<h2 id='re_predict'>Demo of main functions</h2><span id='topic+re_predict'></span>

<h3>Description</h3>

<p>Fits the model to an example case data and predicts the epidemic curves and plots the outputs.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="re_predict_+3A_path_to_data">path_to_data</code></td>
<td>
<p>Absolute path to the dataset in csv format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please modify the config file before invoking this method.
The config file contains all the settings and initial  parameter values
necessary for the algorithm to run. Path to the dataset (in csv format)
is also set in the config file. This file should be updated to the desired
specifications before running this demo. To open it, execute
REffectivePred::navigate_to_config().
</p>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='rt_empirical'>Empirical estimate of <code class="reqn">R_t</code></h2><span id='topic+rt_empirical'></span>

<h3>Description</h3>

<p>Compute empirical <code class="reqn">R_t</code>, via Cori et al. (2013) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rt_empirical(cases, window_size, serial_mean, serial_var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rt_empirical_+3A_cases">cases</code></td>
<td>
<p>Vector of (confirmed) cases.</p>
</td></tr>
<tr><td><code id="rt_empirical_+3A_window_size">window_size</code></td>
<td>
<p>The maximum value for the serial interval.</p>
</td></tr>
<tr><td><code id="rt_empirical_+3A_serial_mean">serial_mean</code></td>
<td>
<p>Mean of the serial interval on the log scale.</p>
</td></tr>
<tr><td><code id="rt_empirical_+3A_serial_var">serial_var</code></td>
<td>
<p>Variance of the serial interval on the log scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of same length as cases, giving the empirical estimate of the effective reproductive number over time.
</p>

<hr>
<h2 id='serial.helper'>Serial interval</h2><span id='topic+serial.helper'></span>

<h3>Description</h3>

<p>Helper function for computing weights <code>w</code> based on the serial interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serial.helper(window_size, serial_mean = log(4), serial_var = log(1.380715))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="serial.helper_+3A_window_size">window_size</code></td>
<td>
<p>The maximum value for the serial interval.</p>
</td></tr>
<tr><td><code id="serial.helper_+3A_serial_mean">serial_mean</code></td>
<td>
<p>Mean of the serial interval on the log scale. See Details.</p>
</td></tr>
<tr><td><code id="serial.helper_+3A_serial_var">serial_var</code></td>
<td>
<p>Variance of the serial interval on the log scale. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computed based on a log normal density function, as in Nishiura et al. (2020). Parameters
<code>serial_mean</code> and <code>serial_var</code> are arguments <code>meanlog</code> and <code>sdlog</code> of
function <code>dlnorm</code>. Default values are taken from the same reference.
</p>


<h3>Value</h3>

<p>A vector that stores the serial interval in reverse order. This is
meant to be multiplied to infections in chronological order.
</p>

<hr>
<h2 id='waves_1d_list'>Utility function for range manipulation</h2><span id='topic+waves_1d_list'></span>

<h3>Description</h3>

<p>Combines multiple waves into one vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waves_1d_list(num_waves, waves_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="waves_1d_list_+3A_num_waves">num_waves</code></td>
<td>
<p>Total number of waves.</p>
</td></tr>
<tr><td><code id="waves_1d_list_+3A_waves_list">waves_list</code></td>
<td>
<p>A list containing individual waves as sub-lists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the first <code>num_waves</code> waves combined.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
