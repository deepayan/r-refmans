<!DOCTYPE html><html lang="en"><head><title>Help for package UNCOVER</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {UNCOVER}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IBIS.logreg'><p>Logistic regression iterated batch importance sampling</p></a></li>
<li><a href='#IBIS.logreg.opts'><p>Additional argument generator for <code>IBIS.logreg()</code></p></a></li>
<li><a href='#plot.IBIS'><p>Plot various outputs of IBIS</p></a></li>
<li><a href='#plot.UNCOVER'><p>Plot various outputs of UNCOVER</p></a></li>
<li><a href='#predict.IBIS'><p>Prediction method for IBIS</p></a></li>
<li><a href='#predict.UNCOVER'><p>Prediction method for UNCOVER</p></a></li>
<li><a href='#print.IBIS'><p>Print IBIS</p></a></li>
<li><a href='#print.UNCOVER'><p>Print UNCOVER</p></a></li>
<li><a href='#UNCOVER'><p>Utilising Normalisation Constant Optimisation Via Edge Removal</p></a></li>
<li><a href='#UNCOVER.opts'><p>Additional argument generator for <code>UNCOVER()</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilising Normalisation Constant Optimisation via Edge Removal
(UNCOVER)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Samuel Emerson [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Samuel Emerson &lt;samuel.emerson@hotmail.co.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Model data with a suspected clustering structure (either in 
    co-variate space, regression space or both) using a Bayesian product model 
    with a logistic regression likelihood. Observations are represented 
    graphically and clusters are formed through various edge removals or 
    additions. Cluster quality is assessed through the log Bayesian evidence of 
    the overall model, which is estimated using either a Sequential Monte Carlo 
    sampler or a suitable transformation of the Bayesian Information Criterion 
    as a fast approximation of the former. The internal Iterated Batch 
    Importance Sampling scheme (Chopin (2002 &lt;<a href="https://doi.org/10.1093%2Fbiomet%2F89.3.539">doi:10.1093/biomet/89.3.539</a>&gt;)) is 
    made available as a free standing function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvnfast, igraph, crayon, memoise, GGally, ggplot2, ggpubr,
scales, stats, cachem, ggnewscale</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 12:40:06 UTC; zmxp16</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-25 13:50:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='IBIS.logreg'>Logistic regression iterated batch importance sampling</h2><span id='topic+IBIS.logreg'></span>

<h3>Description</h3>

<p>This function uses an Iterated Batch Importance Sampling (IBIS)
scheme with batch size one to go from prior to full posterior. We
assume a Bayesian logistic regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBIS.logreg(
  X,
  y,
  options = IBIS.logreg.opts(),
  prior_mean = rep(0, ncol(X) + 1),
  prior_var = diag(ncol(X) + 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IBIS.logreg_+3A_x">X</code></td>
<td>
<p>Co-variate matrix</p>
</td></tr>
<tr><td><code id="IBIS.logreg_+3A_y">y</code></td>
<td>
<p>Binary response vector</p>
</td></tr>
<tr><td><code id="IBIS.logreg_+3A_options">options</code></td>
<td>
<p>Additional arguments that can be specified for <code>IBIS.logreg</code>.
See <code><a href="#topic+IBIS.logreg.opts">IBIS.logreg.opts()</a></code> for details. Can be ignored.</p>
</td></tr>
<tr><td><code id="IBIS.logreg_+3A_prior_mean">prior_mean</code></td>
<td>
<p>Mean for the multivariate normal prior used in the SMC
sampler. See details. Defaults to the origin.</p>
</td></tr>
<tr><td><code id="IBIS.logreg_+3A_prior_var">prior_var</code></td>
<td>
<p>Variance matrix for the multivariate normal prior used in
the SMC sampler. See details. Defaults to the identity matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the internal mechanisms of the SMC sampler such as the
Metropolis-Hastings MCMC resample move can be found in Emerson and Aslett
(2023) and Chopin (2002).
</p>
<p>It is never recommended to use anything other than
<code>IBIS.logreg.opts</code> to provide the <code>options</code> argument. See
examples and <code><a href="#topic+IBIS.logreg.opts">IBIS.logreg.opts()</a></code> for more information.
</p>
<p>The prior used for the IBIS procedure will take the form of a multivariate
normal, where the parameters can be specified directly by the user. It is
however possible to override this default prior distributional form by
specifying <code>prior.override=TRUE</code> and providing the relevant prior functions
in <code>IBIS.logreg.opts</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"IBIS"</code>, which is a list consisting of:
</p>

<dl>
<dt><code>covariate_matrix</code></dt><dd><p>The co-variate matrix provided.</p>
</dd>
<dt><code>response_vector</code></dt><dd><p>The binary response vector provided.</p>
</dd>
<dt><code>samples</code></dt><dd><p>A matrix of samples from the posterior.</p>
</dd>
<dt><code>log_Bayesian_evidence</code></dt><dd><p>An estimate of the log Bayesian evidence (or
normalisation constant) of the posterior.</p>
</dd>
<dt><code>diagnostics</code></dt><dd><p>A data frame recording the features of the SMC sampler
as the observations were added.</p>
</dd>
</dl>

<p>If <code>weighted==TRUE</code> then an additional element of the list (<code>weights</code>) is
added detailing the weights of the posterior samples.
</p>


<h3>References</h3>


<ul>
<li><p> Emerson, S.R. and Aslett, L.J.M. (2023). Joint cohort and prediction
modelling through graphical structure analysis (to be released)
</p>
</li>
<li><p> Chopin, N. (2002). A sequential particle filter method for
static models. Biometrika, 89(3), 539-552, <a href="https://doi.org/10.1093/biomet/89.3.539">doi:10.1093/biomet/89.3.539</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+IBIS.logreg.opts">IBIS.logreg.opts()</a></code>, <code><a href="#topic+print.IBIS">print.IBIS()</a></code>, <code><a href="#topic+predict.IBIS">predict.IBIS()</a></code>, <code><a href="#topic+plot.IBIS">plot.IBIS()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(graphics)
# First we generate a co-variate matrix X and binary response vector y
CM &lt;- matrix(rnorm(200),100,2)
rv &lt;- sample(0:1,100,replace=TRUE)

# Now we can obtain 1000 samples from the posterior from a standard
# multivariate normal prior
out.1 &lt;- IBIS.logreg(X = CM,y = rv)
plot(out.1)
out.1$log_Bayesian_evidence

# We can specify that the samples be weighted
out.1.w &lt;- IBIS.logreg(X = CM,y = rv,
                       options = IBIS.logreg.opts(weighted = TRUE))
out.1.w$weights
plot(out.1.w)

# We can also specify different arguments for a specific prior
out.2 &lt;- IBIS.logreg(X = CM,y = rv,prior_mean = rep(-3,3),
                     prior_var = 0.1*diag(3))
samp.df &lt;- data.frame(rbind(out.1$samples,out.2$samples))
colnames(samp.df) &lt;- paste0("beta[",c(0:2),"]")
GGally::ggpairs(samp.df,
                labeller = "label_parsed",
                ggplot2::aes(color = as.factor(rep(c(1,2),each=1000))),
                upper = list(continuous = GGally::wrap("density")),
                lower = list(continuous = GGally::wrap("points",size=0.5)))
out.2$log_Bayesian_evidence
out.3 &lt;- IBIS.logreg(X = CM,y = rv,prior_mean = rep(3,3),
                     prior_var = 0.1*diag(3))
samp.df &lt;- data.frame(rbind(out.1$samples,out.2$samples,out.3$samples))
colnames(samp.df) &lt;- paste0("beta[",c(0:2),"]")
GGally::ggpairs(samp.df,
                labeller = "label_parsed",
                ggplot2::aes(color = as.factor(rep(c(1,2,3),each=1000))),
                upper = list(continuous = GGally::wrap("density")),
                lower = list(continuous = GGally::wrap("points",size=0.5)))
out.3$log_Bayesian_evidence

# We can also change the prior, for example a multivariate independent
# uniform
rmviu &lt;- function(n,a,b){
return(mapply(FUN = function(min.vec,max.vec,pn){stats::runif(pn,a,b)},
              min.vec=a,max.vec=b,MoreArgs = list(pn = n)))
}
dmviu &lt;- function(x,a,b){
for(ii in 1:ncol(x)){
  x[,ii] &lt;- dunif(x[,ii],a[ii],b[ii])
}
return(apply(x,1,prod))
}

out.4 &lt;- IBIS.logreg(X = CM,y = rv,
                     options = IBIS.logreg.opts(prior.override = TRUE,
                                                rprior = rmviu,
                                                dprior = dmviu,a=rep(0,3),
                                                b=rep(1,3)))
samp.df &lt;- data.frame(rbind(out.1$samples,out.4$samples))
colnames(samp.df) &lt;- paste0("beta[",c(0:2),"]")
GGally::ggpairs(samp.df,
                labeller = "label_parsed",
                ggplot2::aes(color = as.factor(rep(c(1,4),each=1000))),
                upper = list(continuous = GGally::wrap("points",size=0.5)),
                lower = list(continuous = GGally::wrap("points",size=0.5)))
out.4$log_Bayesian_evidence


</code></pre>

<hr>
<h2 id='IBIS.logreg.opts'>Additional argument generator for <code><a href="#topic+IBIS.logreg">IBIS.logreg()</a></code></h2><span id='topic+IBIS.logreg.opts'></span>

<h3>Description</h3>

<p>This function is used to specify additional arguments to
<code>IBIS.logreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBIS.logreg.opts(
  N = 1000,
  ess = N/2,
  n_move = 1,
  weighted = FALSE,
  prior.override = FALSE,
  rprior = NULL,
  dprior = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IBIS.logreg.opts_+3A_n">N</code></td>
<td>
<p>Number of particles for the SMC sampler. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="IBIS.logreg.opts_+3A_ess">ess</code></td>
<td>
<p>Effective Sample Size Threshold: If the effective sample size of
the particles falls below this value then a resample move step is
triggered. Defaults to <code>N/2</code>.</p>
</td></tr>
<tr><td><code id="IBIS.logreg.opts_+3A_n_move">n_move</code></td>
<td>
<p>Number of Metropolis-Hastings steps to apply each time a
resample move step is triggered. Defaults to 1.</p>
</td></tr>
<tr><td><code id="IBIS.logreg.opts_+3A_weighted">weighted</code></td>
<td>
<p>Should the outputted samples be weighted? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="IBIS.logreg.opts_+3A_prior.override">prior.override</code></td>
<td>
<p>Are you overriding the default multivariate normal
form of the prior? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="IBIS.logreg.opts_+3A_rprior">rprior</code></td>
<td>
<p>Function which produces samples from your prior if the default
prior form is to be overridden. If using the default prior form this does
not need to be specified.</p>
</td></tr>
<tr><td><code id="IBIS.logreg.opts_+3A_dprior">dprior</code></td>
<td>
<p>Function which produces your specified priors density for
inputted samples if the default prior form is to be overridden. If using the
default prior form this does not need to be specified.</p>
</td></tr>
<tr><td><code id="IBIS.logreg.opts_+3A_...">...</code></td>
<td>
<p>Additional arguments required for complete specification of the
two prior functions given, if the default prior form is to be overridden.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should only be used to provide additional control
arguments to <code>IBIS.logreg</code>.
</p>
<p>Specifying <code>rprior</code> and <code>dprior</code> will not override the default prior form
unless <code>prior.override=TRUE</code>. If a multivariate normal form is required then
the arguments for this prior should be specified in <code>IBIS.logreg</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>

<dl>
<dt><code>N</code></dt><dd><p>Number of particles for the SMC sampler</p>
</dd>
<dt><code>ess</code></dt><dd><p>Effective Sample Size Threshold</p>
</dd>
<dt><code>n_move</code></dt><dd><p>Number of Metropolis-Hastings steps</p>
</dd>
<dt><code>rprior</code></dt><dd><p>Function which produces samples from your prior. <code>NULL</code> if
<code>prior.override==FALSE</code>.</p>
</dd>
<dt><code>dprior</code></dt><dd><p>Function which produces your specified priors density for
inputted samples. <code>NULL</code> if <code>prior.override==FALSE</code>.</p>
</dd>
<dt><code>prior.override</code></dt><dd><p>Logical value indicating if the prior has been
overridden or not.</p>
</dd>
<dt><code>weighted</code></dt><dd><p>Logical value indicating if the outputted particles of
<code>IBIS.logreg</code> should be weighted or not.</p>
</dd>
<dt><code>MoreArgs</code></dt><dd><p>A list of the additional arguments required for <code>rprior</code>
and <code>dprior</code>. <code>NULL</code> if <code>prior.override==FALSE</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+IBIS.logreg">IBIS.logreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Specifying a multivariate independent uniform prior

rmviu &lt;- function(n,a,b){
return(mapply(FUN = function(min.vec,max.vec,pn){stats::runif(pn,a,b)},
              min.vec=a,max.vec=b,MoreArgs = list(pn = n)))
}
dmviu &lt;- function(x,a,b){
for(ii in 1:ncol(x)){
  x[,ii] &lt;- dunif(x[,ii],a[ii],b[ii])
}
return(apply(x,1,prod))
}

IBIS.logreg.opts(prior.override = TRUE,rprior = rmviu,
                 dprior = dmviu,a=rep(0,3),b=rep(1,3))


</code></pre>

<hr>
<h2 id='plot.IBIS'>Plot various outputs of IBIS</h2><span id='topic+plot.IBIS'></span>

<h3>Description</h3>

<p>Allows visualisation of many aspects of IBIS, including
co-variate, posterior and diagnostic plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IBIS'
plot(x, type = "samples", plot_var = NULL, diagnostic_x_axis = "full", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.IBIS_+3A_x">x</code></td>
<td>
<p>Object of class <code>"IBIS"</code></p>
</td></tr>
<tr><td><code id="plot.IBIS_+3A_type">type</code></td>
<td>
<p>Can be one of; <code>"samples"</code> for posterior visualisation,
<code>"fitted"</code> for co-variate visualisation or <code>"diagnostics"</code> for diagnostic
plots. See details. Defaults to <code>"samples"</code>.</p>
</td></tr>
<tr><td><code id="plot.IBIS_+3A_plot_var">plot_var</code></td>
<td>
<p>Vector specifying which columns (or associated logistic
regression coefficients) of the co-variate matrix should be plotted. Does not
apply when <code>type=="diagnostics"</code>. Defaults to all columns being selected.</p>
</td></tr>
<tr><td><code id="plot.IBIS_+3A_diagnostic_x_axis">diagnostic_x_axis</code></td>
<td>
<p>Only applies if <code style="white-space: pre;">&#8288;"type=="diagnostics"&#8288;</code>. Either
<code>"full"</code> (default) for all observations indices to be plotted on the x-axis
or <code>"minimal"</code> for only some observations indices to be plotted on the
x-axis.</p>
</td></tr>
<tr><td><code id="plot.IBIS_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type=="samples"</code>, the resulting plot will be a ggpairs plot
giving the coefficient densities in the diagonal, points plots of the
posterior samples in the lower triangle and contour plots in the upper
triangle.
</p>
<p>If <code style="white-space: pre;">&#8288;"type=="fitted"&#8288;</code>, the resulting plot will be a ggpairs plot. The
diagonal entries will be two density plots, one for training data predicted
to have response 0 by the model (red) and one for training data predicted
to have response 1 by the model (green). The off-diagonal elements are
scatter-plots of the observations, given a label according to their actual
response and a colour scale based on their predicted response. If
<code>length(plot_var)==1</code> then the co-variate variable is plotted against it's
index and a density plot is not provided. If <code>length(plot_var)==1</code> then the
density plot and the scatter-plot are combined. If a predicted class (0 or
</p>

<ol>
<li><p> contains less than two data points the density will not be plotted.
</p>
</li></ol>

<p>If <code>"type==diagnostics"</code>, the resulting plot will be a combination of three
plots; one tracking the log Bayesian evidence as observations are added to
the posterior, one tracking the effective sample size of the particles for
each step of the SMC sampler and one tracking the acceptance rate of the
Metropolis-Hastings step when a resample-move is triggered. See
Emerson and Aslett (2023) and Chopin (2002) for more details. Multiple
Metropolis-Hastings steps can be performed when a resample-move step is
triggered, and so for the acceptance rate plot observations are suffixed
with &quot;.&quot; and then the index of current Metropolis-Hastings step. For example
the x-axis label for the acceptance rate of the 2nd Metropolis-Hastings step
which was triggered by adding observation 1 to the posterior would be
labelled &quot;1.2&quot;. When the training data for the <code>"IBIS"</code> object created is
large setting <code>diagnostic_x_axis=="minimal"</code> is recommended as it gives a
more visually appealing output.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>References</h3>


<ul>
<li><p> Emerson, S.R. and Aslett, L.J.M. (2023). Joint cohort and prediction
modelling through graphical structure analysis (to be released)
</p>
</li>
<li><p> Chopin, N. (2002). A sequential particle filter method for
static models. Biometrika, 89(3), 539-552, <a href="https://doi.org/10.1093/biomet/89.3.539">doi:10.1093/biomet/89.3.539</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+IBIS.logreg">IBIS.logreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(graphics)
# First we generate a co-variate matrix X and binary response vector y
CM &lt;- matrix(rnorm(200),100,2)
rv &lt;- sample(0:1,100,replace=TRUE)

# Now we can obtain 1000 samples from the posterior from a standard
# multivariate normal prior and plot the results
out &lt;- IBIS.logreg(X = CM,y = rv)
plot(out,type = "samples")
plot(out,type = "fitted")
plot(out,type = "diagnostics",diagnostic_x_axis = "minimal")

# If we only wanted to view the second co-variate
plot(out,type = "samples",plot_var = 2)
plot(out,type = "fitted",plot_var = 2)


</code></pre>

<hr>
<h2 id='plot.UNCOVER'>Plot various outputs of UNCOVER</h2><span id='topic+plot.UNCOVER'></span>

<h3>Description</h3>

<p>Allows visualisation of many aspects of UNCOVER, including
co-variate, posterior and diagnostic plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'UNCOVER'
plot(
  x,
  type = "covariates",
  plot_var = x$Minimum_Spanning_Tree_Variables,
  diagnostic_x_axis = "full",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.UNCOVER_+3A_x">x</code></td>
<td>
<p>Object of class <code>"UNCOVER"</code></p>
</td></tr>
<tr><td><code id="plot.UNCOVER_+3A_type">type</code></td>
<td>
<p>Can be one of; <code>"covariates"</code> for cluster assignment
visualisation for the co-variates, <code>"fitted"</code> for co-variate visualisation
with respect to their fitted values, <code>"samples"</code> for posterior visualisation
or <code>"diagnostics"</code> for diagnostic plots. See details. Defaults to
<code>"covariates"</code>.</p>
</td></tr>
<tr><td><code id="plot.UNCOVER_+3A_plot_var">plot_var</code></td>
<td>
<p>Vector specifying which columns (or associated logistic
regression coefficients) of the co-variate matrix should be plotted. Does not
apply when <code>type=="diagnostics"</code>. Defaults to all columns being selected.</p>
</td></tr>
<tr><td><code id="plot.UNCOVER_+3A_diagnostic_x_axis">diagnostic_x_axis</code></td>
<td>
<p>Only applies if <code style="white-space: pre;">&#8288;"type=="diagnostics"&#8288;</code>. Either
<code>"full"</code> (default) for all observations indices to be plotted on the x-axis
or <code>"minimal"</code> for only some observations indices to be plotted on the
x-axis.</p>
</td></tr>
<tr><td><code id="plot.UNCOVER_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type=="covariates"</code>, the resulting plot will be a ggpairs plot.
The diagonal entries will be a plot of K density plots (K being the number
of clusters). The off-diagonal elements are scatter-plots of the
observations, given a label according to their true response and a colour
based on their assigned cluster. If <code>length(plot_var)==1</code> then the density
plot and the scatter-plot are combined. If a cluster contains less than two
data points the density will not be plotted.
</p>
<p>If <code style="white-space: pre;">&#8288;"type=="fitted"&#8288;</code>, the resulting plot will be a ggpairs plot. The
diagonal entries will be two density plots, one for data predicted to have
response 0 by the model (red) and one for training data predicted to have
response 1 by the model (green). The off-diagonal elements are
scatter-plots of the observations, given a label according to their actual
response and a colour scale based on their predicted response. If
<code>length(plot_var)==1</code> then the density plot and the scatter-plot are
combined. If a predicted class (0 or 1) contains less than two data points
the density will not be plotted.
</p>
<p>If <code>type=="samples"</code>, the resulting plot will be a ggpairs plot of the
clusters posteriors, giving the coefficient densities in the diagonal and
scatter-plots of the posterior samples in the off-diagonal. The transparency
is increased in the upper triangle for scenarios when posteriors overlap.
</p>
<p>If <code>"type==diagnostics"</code>, the resulting plot depends on the deforestation
criterion used to create the <code>"UNCOVER"</code> object:
</p>

<dl>
<dt><code>"None"</code></dt><dd><p>A plot tracking the overall log Bayesian evidence every time
an action is executed.</p>
</dd>
<dt><code>"NoC"</code></dt><dd><p>A plot tracking the overall log Bayesian evidence after every
action and a plot tracking the number of clusters after every action.</p>
</dd>
<dt><code>"SoC"</code></dt><dd><p>Three plots; one tracking the overall log Bayesian evidence
after every action, one tracking the number of criterion breaking clusters
after every action and one tracking the minimum cluster size after every
action.</p>
</dd>
<dt><code>"MaxReg"</code></dt><dd><p>A plot tracking the overall log Bayesian evidence every
time an action is executed. Actions are coloured and each action has an
associated coloured dashed line indicating the log Bayesian evidence plus
the logarithm of the maximum tolerance provided.</p>
</dd>
<dt><code>"Validation"</code></dt><dd><p>A plot tracking the overall log Bayesian evidence
after every action (for both the training data and all of the data) and a
plot tracking the robustness statistic after every deforestation action.</p>
</dd>
<dt><code>"Diverse"</code></dt><dd><p>Three plots; one tracking the overall log Bayesian
evidence after every action, one tracking the number of criterion breaking
clusters after every action and one tracking the minimum minority class
across clusters after every action.</p>
</dd>
</dl>

<p>Actions are defined as either edge removals, edge additions or edge
additions in the deforestation stage. The syntax for an action will be the
'type_of_action.edge'. For example the removal of an edge connecting
observation 1 and observation 2 will be displayed 'Rem.1-2'. If the edge was
being added this would be displayed 'Def.Add.1-2' if in the deforestation
stage and 'Add.1-2' otherwise. When the data for the <code>"UNCOVER"</code> object
created is large setting <code>diagnostic_x_axis=="minimal"</code> is recommended as it
gives a more visually appealing output.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UNCOVER">UNCOVER()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

require(graphics)
# First we generate a co-variate matrix and binary response vector
CM &lt;- matrix(rnorm(200),100,2)
rv &lt;- sample(0:1,100,replace=TRUE)

# We can then run our algorithm for each of the different deforestation
# criteria
UN.none &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "None", verbose = FALSE)
UN.noc &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "NoC",
                  options = UNCOVER.opts(max_K = 3), verbose = FALSE)
UN.soc &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "SoC",
                  options = UNCOVER.opts(min_size = 10), verbose = FALSE)
UN.maxreg &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "MaxReg",
                     options = UNCOVER.opts(reg = 1), verbose = FALSE)
UN.validation &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "Validation",
                         options = UNCOVER.opts(train_frac = 0.8),
                         verbose = FALSE)
UN.diverse &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "Diverse",
                       options = UNCOVER.opts(n_min_class = 2), verbose = FALSE)
plot(UN.none,type = "covariates")
plot(UN.none,type = "fitted")
plot(UN.none,type = "samples")
plot(UN.none,type = "diagnostics",diagnostic_x_axis = "minimal")
plot(UN.noc,type = "diagnostics",diagnostic_x_axis = "minimal")
plot(UN.soc,type = "diagnostics",diagnostic_x_axis = "minimal")
plot(UN.maxreg,type = "diagnostics",diagnostic_x_axis = "minimal")
plot(UN.validation,type = "diagnostics",diagnostic_x_axis = "minimal")
plot(UN.diverse,type = "diagnostics",diagnostic_x_axis = "minimal")

# If we only wanted to view the second co-variate
plot(UN.none,type = "covariates",plot_var=2)
plot(UN.none,type = "fitted",plot_var=2)
plot(UN.none,type = "samples",plot_var=2)


</code></pre>

<hr>
<h2 id='predict.IBIS'>Prediction method for IBIS</h2><span id='topic+predict.IBIS'></span>

<h3>Description</h3>

<p>Predicts the response of new observations using an object of
class <code>"IBIS"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IBIS'
predict(object, newX = NULL, type = "prob", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.IBIS_+3A_object">object</code></td>
<td>
<p>Object of class <code>"IBIS"</code></p>
</td></tr>
<tr><td><code id="predict.IBIS_+3A_newx">newX</code></td>
<td>
<p>Data frame containing new observations to predict. If not
specified the fitted values will be returned instead.</p>
</td></tr>
<tr><td><code id="predict.IBIS_+3A_type">type</code></td>
<td>
<p>Either <code>"prob"</code> for a probabilistic output or <code>"response"</code> for
a hard output of the predicted response</p>
</td></tr>
<tr><td><code id="predict.IBIS_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is a Bayesian prediction method as objects with
class <code>"IBIS"</code> will provide samples from a posterior.
</p>


<h3>Value</h3>

<p>Either a matrix of response probabilities for each observation or
a vector of predicted responses for each observation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IBIS.logreg">IBIS.logreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# First we generate a co-variate matrix X and binary response vector y
CM &lt;- data.frame(X1 = rnorm(100),X2 = rnorm(100))
rv &lt;- sample(0:1,100,replace=TRUE)

# Now we can obtain 1000 samples from the posterior from a standard
# multivariate normal prior
out &lt;- IBIS.logreg(X = CM,y = rv)

# The fitted values of out can be obtained
predict(out)
predict(out,type = "response")

# We can also predict the response for new data
CM.2 &lt;- data.frame(X1 = rnorm(10),X2 = rnorm(10))
cbind(CM.2,predict(out,newX = CM.2))


</code></pre>

<hr>
<h2 id='predict.UNCOVER'>Prediction method for UNCOVER</h2><span id='topic+predict.UNCOVER'></span>

<h3>Description</h3>

<p>Predicts the response of new observations and their cluster
assignment using an object of class <code>"UNCOVER"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'UNCOVER'
predict(object, newX = NULL, type = "prob", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.UNCOVER_+3A_object">object</code></td>
<td>
<p>Object of class <code>"UNCOVER"</code></p>
</td></tr>
<tr><td><code id="predict.UNCOVER_+3A_newx">newX</code></td>
<td>
<p>Data frame containing new observations to predict. If not
specified the fitted values will be returned instead.</p>
</td></tr>
<tr><td><code id="predict.UNCOVER_+3A_type">type</code></td>
<td>
<p>Either <code>"prob"</code> for a probabilistic response prediction or
<code>"response"</code> for a hard output of the predicted response</p>
</td></tr>
<tr><td><code id="predict.UNCOVER_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the predictions produced</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this is a Bayesian prediction method and so samples of
the posterior, defined by <code>"UNCOVER"</code> object provided, will be obtained
through SMC methods for prediction. See <code><a href="#topic+IBIS.logreg">IBIS.logreg()</a></code> for
more details.
</p>


<h3>Value</h3>

<p>Either a data frame of response probabilities with cluster
assignment for each observation or a data frame of predicted responses with
cluster assignment for each observation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UNCOVER">UNCOVER()</a></code>, <code><a href="#topic+IBIS.logreg">IBIS.logreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# First we generate a co-variate matrix and binary response vector
CM &lt;- data.frame(X1 = rnorm(100),X2 = rnorm(100))
rv &lt;- sample(0:1,100,replace=TRUE)

# We can then run UNCOVER with no deforestation criteria
UN.none &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "None", verbose = FALSE)

# The fitted values of UN.none can then be obtained
predict(UN.none)
predict(UN.none,type = "response")

# We can also predict the response for new data
CM.2 &lt;- data.frame(X1 = rnorm(10),X2 = rnorm(10))
cbind(CM.2,predict(UN.none,newX = CM.2))


</code></pre>

<hr>
<h2 id='print.IBIS'>Print IBIS</h2><span id='topic+print.IBIS'></span>

<h3>Description</h3>

<p>Prints summary information from an IBIS object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IBIS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.IBIS_+3A_x">x</code></td>
<td>
<p>Object of class <code>"IBIS"</code></p>
</td></tr>
<tr><td><code id="print.IBIS_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When running the function <code><a href="#topic+IBIS.logreg">IBIS.logreg()</a></code> the printed
information will contain information regarding; the number of samples, the
mean of those samples and the log Bayesian evidence of the posterior.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IBIS.logreg">IBIS.logreg()</a></code>
</p>

<hr>
<h2 id='print.UNCOVER'>Print UNCOVER</h2><span id='topic+print.UNCOVER'></span>

<h3>Description</h3>

<p>Prints summary information from an UNCOVER object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'UNCOVER'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.UNCOVER_+3A_x">x</code></td>
<td>
<p>Object of class <code>"UNCOVER"</code></p>
</td></tr>
<tr><td><code id="print.UNCOVER_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When running the function <code><a href="#topic+UNCOVER">UNCOVER()</a></code> the printed
information will contain information regarding; the number of clusters, the
cluster sizes, the sub-model log Bayesian evidences and the total model log
Bayesian evidence.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UNCOVER">UNCOVER()</a></code>
</p>

<hr>
<h2 id='UNCOVER'>Utilising Normalisation Constant Optimisation Via Edge Removal</h2><span id='topic+UNCOVER'></span>

<h3>Description</h3>

<p>Generates cohorts for a data set through removal of edges from
a graphical representation of the co-variates. Edges are removed (or
reintroduced) by considering the normalisation constant (or Bayesian
evidence) of a multiplicative Bayesian logistic regression model.
</p>
<p>The first stage of the function is concerned purely with a greedy
optimisation of the Bayesian evidence through edge manipulation. The second
stage then addresses any other criteria (known as deforestation conditions)
expressed by the user through reintroduction of edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UNCOVER(
  X,
  y,
  mst_var = NULL,
  options = UNCOVER.opts(),
  stop_criterion = 5,
  deforest_criterion = "None",
  prior_mean = rep(0, ncol(X) + 1),
  prior_var = diag(ncol(X) + 1),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UNCOVER_+3A_x">X</code></td>
<td>
<p>Co-variate matrix</p>
</td></tr>
<tr><td><code id="UNCOVER_+3A_y">y</code></td>
<td>
<p>Binary response vector</p>
</td></tr>
<tr><td><code id="UNCOVER_+3A_mst_var">mst_var</code></td>
<td>
<p>A vector specifying which variables of the co-variate matrix
will be used to form the graph. If not specified all variables will be used.</p>
</td></tr>
<tr><td><code id="UNCOVER_+3A_options">options</code></td>
<td>
<p>Additional arguments that can be specified for <code>UNCOVER</code>.
See <code><a href="#topic+UNCOVER.opts">UNCOVER.opts()</a></code> for details. Can be ignored.</p>
</td></tr>
<tr><td><code id="UNCOVER_+3A_stop_criterion">stop_criterion</code></td>
<td>
<p>What is the maximum number of clusters allowed before
we terminate the first stage and begin deforestation. Defaults to 5.</p>
</td></tr>
<tr><td><code id="UNCOVER_+3A_deforest_criterion">deforest_criterion</code></td>
<td>
<p>Constraint type which the final model must satisfy.
Can be one of <code>"NoC"</code>, <code>"SoC"</code>, <code>"MaxReg"</code>, <code>"Validation"</code>, <code>"Diverse"</code> or
<code>"None"</code>. See details. Defaults to <code>"None"</code>.</p>
</td></tr>
<tr><td><code id="UNCOVER_+3A_prior_mean">prior_mean</code></td>
<td>
<p>Mean for the multivariate normal prior used in the SMC
sampler. See details. Defaults to the origin.</p>
</td></tr>
<tr><td><code id="UNCOVER_+3A_prior_var">prior_var</code></td>
<td>
<p>Variance matrix for the multivariate normal prior used in
the SMC sampler. See details. Defaults to the identity matrix.</p>
</td></tr>
<tr><td><code id="UNCOVER_+3A_verbose">verbose</code></td>
<td>
<p>Do you want the progress of the algorithm to be shown?
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes a Bayesian logistic regression model for each cohort, with
the overall model being a product of these sub-models.
</p>
<p>A minimum spanning tree graph is first constructed from a subset of the
co-variates. Then at each iteration, each edge in the current graph is
checked to see if removal to split a cohort is beneficial, and then either
we selected the optimal edge to remove or we conclude it is not beneficial
to remove any more edges. At the end of each iteration we also check the set
of removed edges to see if it is beneficial to reintroduce any previously
removed edges. After this process has ended we then reintroduce edges in the
removed set specifically to meet the criteria set by the user in the most
optimal manner possible through a greedy approach. For more details see the
Emerson and Aslett (2023).
</p>
<p>The graph can be undergo deforestation to meet 6 possible criteria:
</p>

<ol>
<li> <p><code>"NoC"</code>: Number of Clusters - we specify a maximum number of clusters
(<code>options$max_K</code>) we can tolerate in the final output of the algorithm.
</p>
</li>
<li> <p><code>"SoC"</code>: Size of Clusters - we specify a minimum number of
observations (<code>options$min_size</code>) we can tolerate being assigned to a
cluster in the final output of the algorithm.
</p>
</li>
<li> <p><code>"MaxReg"</code>: Maximal Regret - we give a maximum tolerance
(<code>exp(options$reg)</code>) that we allow the Bayesian evidence to decrease by
reintroducing an edge.
</p>
</li>
<li> <p><code>"Validation"</code>: Validation Data - we split (using
<code>options$train_frac</code>) the data into training and validation data, apply the
first stage of the algorithm on the training data and the introduce the
validation data for the deforestation stage. Edges are reintroduced if they
lead to improved prediction of the validation data using the training data
model (i.e. we aim to maximise a robustness statistic).
</p>
</li>
<li> <p><code>"Diverse"</code>: Diverse Response Class Within Clusters - We specify a
minimum number of observations (<code>options$n_min_class</code>) in a cluster that
have the minority response class associated to them (the minimum response
class is determined for each cluster).
</p>
</li>
<li> <p><code>"None"</code>: No Criteria Specified - we do not go through the second
deforestation stage of the algorithm.
</p>
</li></ol>

<p>All deforestation criteria other than <code>"None"</code> require additional arguments
to be specified in <code>options</code>. See examples and
<code><a href="#topic+UNCOVER.opts">UNCOVER.opts()</a></code> for more information. It is never
recommended to use anything other than
<code>UNCOVER.opts</code> to provide the <code>options</code> argument.
</p>
<p>The prior used for the UNCOVER procedure will take the form of a
multivariate normal, where the parameters can be specified directly by the
user. It is however possible to override this default prior distributional
form by specifying <code>prior.override=TRUE</code> and providing the relevant prior
functions in <code>UNCOVER.opts</code>.
</p>
<p>The diagnostic data frames will track various outputs of the UNCOVER
procedure depending on the deforestation criterion. All data frames will
contain an action (removal or addition of an edge to the graph) and the
total log Bayesian evidence of the model gained through deployment of that
action (for <code>"Validation"</code> this will be two columns, one for the training
data and one for all of the data). <code>"NoC"</code> will also track the number of
clusters, <code>"SoC"</code> will track the minimum cluster size and the number of
criterion breaking clusters, <code>"Validation"</code> will track the robustness
statistic and &quot;<code style="white-space: pre;">&#8288;Diverse"&#8288;</code> will track the minimum minority class across all
clusters alongside the number of criterion breaking clusters.
</p>


<h3>Value</h3>

<p>An object of class <code>"UNCOVER"</code>, which is a list consisting of:
</p>

<dl>
<dt><code>Covariate_Matrix</code></dt><dd><p>The co-variate matrix provided.</p>
</dd>
<dt><code>Response_Vector</code></dt><dd><p>The binary response vector provided.</p>
</dd>
<dt><code>Minimum_Spanning_Tree_Variables</code></dt><dd><p>A vector of indices for the
co-variates used to construct the minimum spanning tree.</p>
</dd>
<dt><code>Control</code></dt><dd><p>A list of the additional arguments specified by <code>options</code>.</p>
</dd>
<dt><code>Deforestation_Criterion</code></dt><dd><p>The deforestation criterion specified.</p>
</dd>
<dt><code>Prior_Mean</code></dt><dd><p>The mean of multivariate normal prior. Meaningless if
prior is overridden in <code>options</code>.</p>
</dd>
<dt><code>Prior_Variance</code></dt><dd><p>The variance of multivariate normal prior.
Meaningless if prior is overridden in <code>options</code>.</p>
</dd>
<dt><code>Model</code></dt><dd><p>List containing; the cluster allocation of the training data,
the log Bayesian evidences of the sub-models, the final graph of the
clustered data, the number of clusters, the edges which were removed from
the graph and a diagnostics data frame (the contents of which vary depending
on the deforestation criterion).</p>
</dd>
</dl>

<p>If <code>deforest_criterion=="Validation"</code> then <code>Model</code> is instead a list of two
lists; one containing the model information for the training data
(<code>Training_Data</code>) and the other containing model information for all of the
data (<code>All_Data</code>). Diagnostic information is only included in the <code>All_Data</code>
list.
</p>


<h3>References</h3>


<ul>
<li><p> Emerson, S.R. and Aslett, L.J.M. (2023). Joint cohort and prediction
modelling through graphical structure analysis (to be released)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+UNCOVER.opts">UNCOVER.opts()</a></code>, <code><a href="#topic+print.UNCOVER">print.UNCOVER()</a></code>, <code><a href="#topic+predict.UNCOVER">predict.UNCOVER()</a></code>, <code><a href="#topic+plot.UNCOVER">plot.UNCOVER()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# First we generate a co-variate matrix and binary response vector
CM &lt;- matrix(rnorm(200),100,2)
rv &lt;- sample(0:1,100,replace=TRUE)

# We can then run our algorithm to see what cohorts are selected for each
# of the different deforestation criteria
UN.none &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "None",
                   verbose = FALSE)
UN.noc &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "NoC",
                  options = UNCOVER.opts(max_K = 3), verbose = FALSE)
UN.soc &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "SoC",
                  options = UNCOVER.opts(min_size = 10), verbose = FALSE)
UN.maxreg &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "MaxReg",
                     options = UNCOVER.opts(reg = 1), verbose = FALSE)
UN.validation &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "Validation",
                         options = UNCOVER.opts(train_frac = 0.8),
                         verbose = FALSE)
UN.diverse &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "Diverse",
                       options = UNCOVER.opts(n_min_class = 2),
                       verbose = FALSE)
clu_al_mat &lt;- rbind(UN.none$Model$Cluster_Allocation,
                    UN.noc$Model$Cluster_Allocation,
                    UN.soc$Model$Cluster_Allocation,
                    UN.maxreg$Model$Cluster_Allocation,
                    UN.validation$Model$All_Data$Cluster_Allocation,
                    UN.diverse$Model$Cluster_Allocation)
# We can create a matrix where each entry shows in how many of the methods
# did the indexed observations belong to the same cluster
obs_con_mat &lt;- matrix(0,100,100)
for(i in 1:100){
for(j in 1:100){
obs_con_mat[i,j] &lt;- length(which(clu_al_mat[,i]-clu_al_mat[,j]==0))/6
obs_con_mat[j,i] &lt;- obs_con_mat[i,j]
}
}
head(obs_con_mat)

# We can also view the outputted overall Bayesian evidence of the five
# models as well
c(sum(UN.none$Model$Log_Marginal_Likelihoods),
  sum(UN.noc$Model$Log_Marginal_Likelihoods),
  sum(UN.soc$Model$Log_Marginal_Likelihoods),
  sum(UN.maxreg$Model$Log_Marginal_Likelihoods),
  sum(UN.validation$Model$All_Data$Log_Marginal_Likelihoods),
  sum(UN.diverse$Model$Log_Marginal_Likelihoods))

# If we don't assume the prior for the regression coefficients is a
# standard multivariate normal but instead a multivariate normal with
# different parameters
UN.none.2 &lt;- UNCOVER(X = CM,y = rv, deforest_criterion = "None",
                     prior_mean = rep(1,3), prior_var = 0.5*diag(3),
                     verbose = FALSE)
c(sum(UN.none$Model$Log_Marginal_Likelihoods),
  sum(UN.none.2$Model$Log_Marginal_Likelihoods))
# We can also specify a completely different prior, for example a
# multivariate independent uniform
rmviu &lt;- function(n,a,b){
return(mapply(FUN = function(min.vec,max.vec,pn){
                      stats::runif(pn,a,b)},min.vec=a,max.vec=b,
                                     MoreArgs = list(pn = n)))
}
dmviu &lt;- function(x,a,b){
for(ii in 1:ncol(x)){
  x[,ii] &lt;- dunif(x[,ii],a[ii],b[ii])
}
return(apply(x,1,prod))
}
UN.none.3 &lt;- UNCOVER(X = CM,y = rv,deforest_criterion = "None",
                     options = UNCOVER.opts(prior.override = TRUE,
                                            rprior = rmviu,
                                            dprior = dmviu,a=rep(0,3),
                                            b=rep(1,3)),verbose = FALSE)
c(sum(UN.none$Model$Log_Marginal_Likelihoods),
  sum(UN.none.2$Model$Log_Marginal_Likelihoods),
  sum(UN.none.3$Model$Log_Marginal_Likelihoods))

# We may only wish to construct our minimum spanning tree based on the first
# variable
UN.none.4 &lt;- UNCOVER(X = CM,y = rv,mst_var = 1,deforest_criterion = "None",
                     verbose = FALSE)
c(sum(UN.none$Model$Log_Marginal_Likelihoods),
  sum(UN.none.4$Model$Log_Marginal_Likelihoods))

# Increasing the stop criterion may uncover more clustering structure within
# the data, but comes with a time cost
system.time(UNCOVER(X = CM,y = rv,stop_criterion = 4,verbose = FALSE))
system.time(UNCOVER(X = CM,y = rv,stop_criterion = 6,verbose = FALSE))


</code></pre>

<hr>
<h2 id='UNCOVER.opts'>Additional argument generator for <code><a href="#topic+UNCOVER">UNCOVER()</a></code></h2><span id='topic+UNCOVER.opts'></span>

<h3>Description</h3>

<p>This function is used to specify additional arguments to
<code>UNCOVER</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UNCOVER.opts(
  N = 1000,
  train_frac = 1,
  max_K = Inf,
  min_size = 0,
  reg = 0,
  n_min_class = 0,
  SMC_thres = 30,
  BIC_memo_thres = Inf,
  SMC_memo_thres = Inf,
  ess = N/2,
  n_move = 1,
  prior.override = FALSE,
  rprior = NULL,
  dprior = NULL,
  diagnostics = TRUE,
  RIBIS_thres = 30,
  BIC_cache = cachem::cache_mem(max_size = 1024 * 1024^2, evict = "lru"),
  SMC_cache = cachem::cache_mem(max_size = 1024 * 1024^2, evict = "lru"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UNCOVER.opts_+3A_n">N</code></td>
<td>
<p>Number of particles for the SMC sampler. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_train_frac">train_frac</code></td>
<td>
<p>What fraction of the data should be used for training.
Should only be directly specified if <code style="white-space: pre;">&#8288;deforest_criterion == "Validation&#8288;</code>.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_max_k">max_K</code></td>
<td>
<p>The maximum number of clusters allowed in the final output.
Should only be directly specified if <code style="white-space: pre;">&#8288;deforest_criterion == "NoC&#8288;</code>. Defaults
to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_min_size">min_size</code></td>
<td>
<p>The minimum number of observations allowed for any cluster
in the final model. Should only be directly specified if
<code style="white-space: pre;">&#8288;deforest_criterion == "SoC&#8288;</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_reg">reg</code></td>
<td>
<p>Numerical natural logarithm of the tolerance parameter. Must be
positive. Should only be directly specified if
<code style="white-space: pre;">&#8288;deforest_criterion == "MaxReg&#8288;</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_n_min_class">n_min_class</code></td>
<td>
<p>Each cluster will have an associated minority class.
<code>n_min_class</code> specifies a minimum number of observations that should have
that class for each and every cluster. Should only be directly specified if
<code style="white-space: pre;">&#8288;deforest_criterion == "Diverse&#8288;</code>. Defaults to 0.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_smc_thres">SMC_thres</code></td>
<td>
<p>The threshold for which the number of observations needs to
exceed to consider using BIC as an estimator. Defaults to 30 if not
specified.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_bic_memo_thres">BIC_memo_thres</code></td>
<td>
<p>Only used when estimating the log Bayesian evidence of
a cluster using BIC. When the number of observations exceeds <code>BIC_memo_thres</code>
the function checks for similar inputs evaluated previously. See details.
Defaults to never checking.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_smc_memo_thres">SMC_memo_thres</code></td>
<td>
<p>Only used when estimating the log Bayesian evidence of
a cluster using SMC. When the number of observations exceeds <code>SMC_memo_thres</code>
the function checks for similar inputs evaluated previously. See details.
Defaults to never checking.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_ess">ess</code></td>
<td>
<p>Effective Sample Size Threshold: If the effective sample size of
the particles falls below this value then a resample move step is
triggered. Defaults to <code>N/2</code>.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_n_move">n_move</code></td>
<td>
<p>Number of Metropolis-Hastings steps to apply each time a
resample move step is triggered. Defaults to 1.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_prior.override">prior.override</code></td>
<td>
<p>Are you overriding the default multivariate normal
form of the prior? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_rprior">rprior</code></td>
<td>
<p>Function which produces samples from your prior if the default
prior form is to be overridden. If using the default prior form this does
not need to be specified.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_dprior">dprior</code></td>
<td>
<p>Function which produces your specified priors density for
inputted samples if the default prior form is to be overridden. If using the
default prior form this does not need to be specified.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_diagnostics">diagnostics</code></td>
<td>
<p>Should diagnostic data be recorded and outputted?
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_ribis_thres">RIBIS_thres</code></td>
<td>
<p>The threshold for which the number of observations needs
to exceed to consider ever using RIBIS as an estimator. Defaults to 30 if
not specified. See details.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_bic_cache">BIC_cache</code></td>
<td>
<p>The cache for the function which estimates the log Bayesian
evidence using BIC. Defaults to a cache with standard size and least
recently used eviction policy.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_smc_cache">SMC_cache</code></td>
<td>
<p>The cache for the function which estimates the log Bayesian
evidence using SMC. Defaults to a cache with standard size and least
recently used eviction policy.</p>
</td></tr>
<tr><td><code id="UNCOVER.opts_+3A_...">...</code></td>
<td>
<p>Additional arguments required for complete specification of the
two prior functions given, if the default prior form is to be overridden.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should only be used to provide additional control
arguments to <code>UNCOVER</code>. Arguments that are for a particular deforestation
criteria should not be altered from the defaults for other deforestation
criteria.
</p>
<p>BIC refers to the Bayesian Information Criterion. The use of BIC when
estimating the log Bayesian evidence is valid assuming the number of
observations is large, and if specifying <code>SMC_thres</code> this should be balanced
with computational expense (as the function which relies
on BIC values is much faster than the SMC sampler).
</p>
<p>In an attempt to improve computational time, the SMC sampler along with the
function which uses BIC values are memoised, with the cache for each of
these memoised functions be specified by <code>SMC_cache</code> and <code>BIC_cache</code>
respectively. See <code><a href="memoise.html#topic+memoise">memoise::memoise()</a></code> for more details. If we do
not get and each match from the function input to a previously evaluated
input, we may wish to search the cache for similar inputs which could
provide a reasonable starting point. Checking the cache however takes time,
and so we allow the user to specify at which size of cluster to they deem it
worthwhile to check. Which value threshold to select to optimise run time is
problem specific, however for <code>BIC_memo_thres</code> it is almost always
beneficial to never check the cache (the exception for this being when the
cluster sizes are extremely large, for example containing a million
observations). <code>SMC_memo_thres</code> can be much lower as the SMC sampler is a
much more expensive function to run. See Emerson and Aslett (2023) for more
details.
</p>
<p><code>RIBIS_thres</code> can be specified to have a higher value to ensure that the
asymptotic properties which Reverse Iterated Batch Importance Sampling
(RIBIS) relies upon hold. See Emerson and Aslett (2023) for more details.
</p>
<p>Specifying <code>rprior</code> and <code>dprior</code> will not override the default prior form
unless <code>prior.override=TRUE</code>. If a multivariate normal form is required then
the arguments for this prior should be specified in <code>UNCOVER</code>.
</p>


<h3>Value</h3>

<p>A list consisting of:
</p>

<dl>
<dt><code>N</code></dt><dd><p>Number of particles for the SMC sampler</p>
</dd>
<dt><code>train_frac</code></dt><dd><p>Training data fraction</p>
</dd>
<dt><code>max_K</code></dt><dd><p>Maximum number of clusters allowed</p>
</dd>
<dt><code>min_size</code></dt><dd><p>Minimum size of clusters allowed</p>
</dd>
<dt><code>reg</code></dt><dd><p>Log of the maximum regret tolerance parameter</p>
</dd>
<dt><code>n_min_class</code></dt><dd><p>Minimum size of cluster minority class allowed</p>
</dd>
<dt><code>SMC_thres</code></dt><dd><p>Threshold for when estimation with BIC is attempted</p>
</dd>
<dt><code>BIC_memo_thres</code></dt><dd><p>Threshold for when we review previous inputs of the
BIC function for similarities</p>
</dd>
<dt><code>SMC_memo_thres</code></dt><dd><p>Threshold for when we review previous inputs of the
SMC function for similarities</p>
</dd>
<dt><code>ess</code></dt><dd><p>Effective Sample Size Threshold</p>
</dd>
<dt><code>n_move</code></dt><dd><p>Number of Metropolis-Hastings steps</p>
</dd>
<dt><code>rprior</code></dt><dd><p>Function which produces samples from your prior. <code>NULL</code> if
<code>prior.override==FALSE</code>.</p>
</dd>
<dt><code>dprior</code></dt><dd><p>Function which produces your specified priors density for
inputted samples. <code>NULL</code> if <code>prior.override==FALSE</code>.</p>
</dd>
<dt><code>prior.override</code></dt><dd><p>Logical value indicating if the prior has been
overridden or not</p>
</dd>
<dt><code>diagnostics</code></dt><dd><p>Logical value indicating whether diagnostic information
should be included in the output of <code>UNCOVER</code></p>
</dd>
<dt><code>RIBIS_thres</code></dt><dd><p>The threshold for allowing the use of RIBIS</p>
</dd>
<dt><code>BIC_cache</code></dt><dd><p>Cache for the memoised function which estimates the log
Bayesian evidence using BIC</p>
</dd>
<dt><code>SMC_cache</code></dt><dd><p>Cache for the memoised function which estimates the log
Bayesian evidence using SMC</p>
</dd>
<dt><code>MoreArgs</code></dt><dd><p>A list of the additional arguments required for <code>rprior</code>
and <code>dprior</code>. <code>NULL</code> if <code>prior.override==FALSE</code>.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Emerson, S.R. and Aslett, L.J.M. (2023). Joint cohort and prediction
modelling through graphical structure analysis (to be released)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+UNCOVER">UNCOVER()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Specifying a multivariate independent uniform prior

rmviu &lt;- function(n,a,b){
return(mapply(FUN = function(min.vec,max.vec,pn){stats::runif(pn,a,b)},
              min.vec=a,max.vec=b,MoreArgs = list(pn = n)))
}
dmviu &lt;- function(x,a,b){
for(ii in 1:ncol(x)){
  x[,ii] &lt;- dunif(x[,ii],a[ii],b[ii])
}
return(apply(x,1,prod))
}

UNCOVER.opts(prior.override = TRUE,rprior = rmviu,
                 dprior = dmviu,a=rep(0,3),b=rep(1,3))


# If we generate a co-variate matrix and binary response vector
CM &lt;- matrix(rnorm(200),100,2)
rv &lt;- sample(0:1,100,replace=TRUE)

# We can then run our algorithm with a SMC threshold of 50 and a SMC cache
# checking threshold of 25 to see if this is quicker than the standard
# version
system.time(UNCOVER(X = CM,y = rv,verbose = FALSE))
system.time(UNCOVER(X = CM,y = rv,
                    options = UNCOVER.opts(SMC_thres = 50),
                    verbose = FALSE))
system.time(UNCOVER(X = CM,y = rv,
                    options = UNCOVER.opts(SMC_thres = 50,
                                           SMC_memo_thres = 25),
                    verbose = FALSE))


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
