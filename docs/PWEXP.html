<!DOCTYPE html><html lang="en"><head><title>Help for package PWEXP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PWEXP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#boot.pwexp.fit'><p>Bootstrap a Piecewise Exponential Model</p></a></li>
<li><a href='#conditional+20piecewise+20exponential'><p>The Conditional Piecewise Exponential Distribution</p></a></li>
<li><a href='#cut_dat'><p>Cut Data before a Specified Time</p></a></li>
<li><a href='#cv.pwexp.fit'><p>Cross Validate a Piecewise Exponential Model</p></a></li>
<li><a href='#piecewise+20exponential'><p>The Piecewise Exponential Distribution</p></a></li>
<li><a href='#plot_event'><p>Plot Cumulative Event Curve</p></a></li>
<li><a href='#plot_survival'><p>Plot Survival Curve</p></a></li>
<li><a href='#predict'><p>Predict Events for Piecewise Exponential Model</p></a></li>
<li><a href='#pwexp.fit'><p>Fit the Piecewise Exponential Distribution</p></a></li>
<li><a href='#sim_followup'><p>Estimate follow up time and number of events by simulation</p></a></li>
<li><a href='#simdata'><p>Simulate Survival Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Piecewise Exponential Distribution Prediction Model</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, methods, utils, segmented,
foreach, doSNOW, parallel</td>
</tr>
<tr>
<td>Depends:</td>
<td>survival, fastmatch</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, RColorBrewer, rmarkdown</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Tianchen Xu [aut, cre] (&lt;https://orcid.org/0000-0002-0102-7630&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tianchen Xu &lt;zjph602xutianchen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Build piecewise exponential survival model for study design (planning) and event/timeline prediction. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zjph602xtc/PWEXP">https://github.com/zjph602xtc/PWEXP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zjph602xtc/PWEXP/issues">https://github.com/zjph602xtc/PWEXP/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-12 15:32:45 UTC; Peter</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-12 16:30:07 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='boot.pwexp.fit'>Bootstrap a Piecewise Exponential Model</h2><span id='topic+boot.pwexp.fit'></span><span id='topic+boot.pwexp.fit.default'></span><span id='topic+boot.pwexp.fit.pwexp.fit'></span>

<h3>Description</h3>

<p>Bootstrap a existing piecewise exponential model or build a piecewise exponential model with bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
boot.pwexp.fit(time, event, nsim=100, breakpoint=NULL, nbreak=0,
               exclude_int=NULL, min_pt_tail=5, max_set=1000, seed=1818,
               optimizer='mle', tol=1e-4, parallel=FALSE, mc.core=4, ...)
## S3 method for class 'pwexp.fit'
boot.pwexp.fit(time, nsim=100, max_set=1000, seed=1818,
               optimizer='mle', tol=1e-4, parallel=FALSE, mc.core=4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.pwexp.fit_+3A_time">time</code></td>
<td>
<p>observed time from randomization or a <code><a href="#topic+pwexp.fit">pwexp.fit</a></code> object.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_event">event</code></td>
<td>
<p>the status indicator. See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_nsim">nsim</code></td>
<td>
<p>the number of repeated bootstraping.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_breakpoint">breakpoint</code></td>
<td>
<p>pre-specified breakpoints. See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_nbreak">nbreak</code></td>
<td>
<p>total number of breakpoints. See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_exclude_int">exclude_int</code></td>
<td>
<p>an interval that excludes any estimated breakpoints.  See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_min_pt_tail">min_pt_tail</code></td>
<td>
<p>the minimum number of events used for estimating the tail (the hazard rate of the last piece). See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_max_set">max_set</code></td>
<td>
<p>maximum estimated combination of breakpoints. See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_seed">seed</code></td>
<td>
<p>a random seed.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_optimizer">optimizer</code></td>
<td>
<p>one of the optimizers: <code>mle</code>, <code>ols</code>, or <code>hybrid</code>. See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_tol">tol</code></td>
<td>
<p>the minimum allowed gap between two breakpoints. The gap is calculated as <code>(max(time)-min(time))*tol</code>. Keep it as default in most cases. </p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, use <span class="pkg">doSNOW</span> package to run in parallel.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_mc.core">mc.core</code></td>
<td>
<p>number of processes allowed to be run in parallel.</p>
</td></tr>
<tr><td><code id="boot.pwexp.fit_+3A_...">...</code></td>
<td>
<p>internal function reserved. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use bootstrap to repeatdly call <code><a href="#topic+pwexp.fit">pwexp.fit</a></code> to estimate the uncertainty of parameters.
</p>


<h3>Value</h3>

<p>A data frame (<code>res</code>) containing these columns:
</p>
<table role = "presentation">
<tr><td><code>brk1</code>, <code>...</code>, <code>brkx</code></td>
<td>
<p>estimated breakpoints. The <code>attr(res,'brk')</code> can extract the result of breakpoint from each bootstrap sample (<code>res</code> is the returned model from <code>boot.pwexp.fit</code>). </p>
</td></tr>
<tr><td><code>lam1</code>, <code>...</code>, <code>lamx</code></td>
<td>
<p>estimated piecewise hazard rates. The <code>attr(res,'lam')</code> can extract the result of hazard rates from bootstrap sample (<code>res</code> is the returned model from <code>boot.pwexp.fit</code>). </p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>the log-likelihood of the model.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike information criterion of the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the Bayesian information criterion of the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pwexp.fit">pwexp.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>event_dist &lt;- function(n)rpwexp(n, rate = c(0.1, 0.01, 0.2), breakpoint =  c(5,14))
dat &lt;- simdata(rand_rate = 20, drop_rate = 0.03,  total_sample = 1000,
               advanced_dist = list(event_dist=event_dist),
               add_column = c('censor_reason','event','followT','followT_abs'))

fit_res3 &lt;- pwexp.fit(dat$followT, dat$event, nbreak = 2)
fit_res_boot &lt;- boot.pwexp.fit(fit_res3, nsim = 10) # here nsim=10 is for demo purpose,
                                                    # pls increase it in practice
plot_survival(dat$followT, dat$event, xlim=c(0,40))
plot_survival(fit_res_boot, col='red', CI_par = list(col='red'))
brk_ci &lt;- apply(attr(fit_res_boot, 'brk'), 2, function(x)quantile(x,c(0.025,0.975)))
abline(v=brk_ci, col='grey', lwd=2)
</code></pre>

<hr>
<h2 id='conditional+20piecewise+20exponential'>The Conditional Piecewise Exponential Distribution</h2><span id='topic+ppwexp_conditional'></span><span id='topic+qpwexp_conditional'></span><span id='topic+rpwexp_conditional'></span>

<h3>Description</h3>

<p>Distribution function, quantile function and random generation for the piecewise exponential distribution <code class="reqn">t</code> with piecewise rate <code>rate</code> given <code class="reqn">t&gt;qT</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppwexp_conditional(q, qT, rate=1, breakpoint=NULL, lower.tail=TRUE,
                   log.p=FALSE, one_piece, safety_check=TRUE)
qpwexp_conditional(p, qT, rate=1, breakpoint=NULL, lower.tail=TRUE,
                   log.p=FALSE, one_piece, safety_check=TRUE)
rpwexp_conditional(n, qT, rate, breakpoint=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_qt">qT</code></td>
<td>
<p>the distribution is conditional on <code class="reqn">t&gt;</code><code>qT</code>. <code>qT</code> can be a scalar or a vector with the same length of <code>q</code> or <code>p</code>.</p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_n">n</code></td>
<td>
<p>number of observations. Must be a positive integer with length 1. </p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_rate">rate</code></td>
<td>
<p>a vector of rates in each piece.</p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_breakpoint">breakpoint</code></td>
<td>
<p>a vector of breakpoints. The length is <code>length(rate)-1</code>. Can be NULL if rate is a single value.</p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_log">log</code>, <code id="conditional+2B20piecewise+2B20exponential_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_one_piece">one_piece</code></td>
<td>
<p>(only required when <code>safety_check=FALSE</code>) whether the distribution only has one piece (i.e.,
rate is a single value and breakpoint=NULL).</p>
</td></tr>
<tr><td><code id="conditional+2B20piecewise+2B20exponential_+3A_safety_check">safety_check</code></td>
<td>
<p>logical; whether check the input arguments; if FALSE, function has better computing performance by skipping all safety checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See webpage <a href="https://zjph602xtc.github.io/PWEXP/">https://zjph602xtc.github.io/PWEXP/</a> for more details for its survival function, cumulative density function, quantile function.
</p>


<h3>Value</h3>

<p><code>ppwexp_conditional</code> gives the conditional distribution function, <code>qpwexp_conditional</code> gives the conditional quantile function, and <code>rpwexp_conditional</code> generates conditional random variables.
</p>
<p>The length of the result is determined by <code>q</code>, <code>p</code> or <code>n</code> for <code>ppwexp_conditional</code>, <code>qpwexp_conditional</code> or <code>rpwexp_conditional</code>. You can only specify a single piecewise exponential distribution every time you call these functions. This is different from the exponential distribution functions in package <span class="pkg">stats</span>.
</p>
<p>When the length of <code>qT</code> is 1, then all results are conditional on the same <code class="reqn">t&gt;</code><code>qT</code>.
In <code>rpwexp_conditional</code>, <code>qT</code> must be a scalar. When the length of <code>qT</code> equals to the length of <code>q</code> or <code>p</code>, then each value in the result is conditional on <code class="reqn">t&gt;</code><code>qT</code> for each value in <code>qT</code>.
</p>
<p>Arguments <code>rate</code> and <code>breakpoint</code> must match. The length of rate is the length of breakpoint + 1.
</p>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpwexp">dpwexp</a></code>,
<code><a href="#topic+ppwexp">ppwexp</a></code>,
<code><a href="#topic+qpwexp">qpwexp</a></code>,
<code><a href="#topic+rpwexp">rpwexp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># CDF and qunatile function of conditional piecewise exp with rate 2, 1, 3 given t &gt; 0.1
t &lt;- seq(0.1, 1.2, 0.01)
F2_con &lt;- ppwexp_conditional(t, qT=0.1, rate=c(2, 1, 3), breakpoint=c(0.3, 0.8))
plot(t, F2_con, type='l', col='red', lwd=2, main="CDF and Quantile Function of
    Conditional \nPiecewsie Exp Dist", xlim=c(0, 1.2), ylim=c(0, 1.2))
lines(F2_con, qpwexp_conditional(F2_con, qT=0.1, rate=c(2, 1, 3),
    breakpoint=c(0.3,0.8)), lty=2, lwd=2, col='red')

# compare with CDF and quantile function of unconditional piecewise exp with rate 2, 1, 3
t &lt;- seq(0, 1.2, 0.01)
F2 &lt;- ppwexp(t, rate=c(2, 1, 3), breakpoint=c(0.3,0.8))
lines(t, F2, lwd=2)
lines(F2, qpwexp(F2, rate=c(2, 1, 3), breakpoint=c(0.3,0.8)), lty=2, lwd=2)
abline(v=0.1, col='grey')
abline(h=0.1, col='grey')
legend('topleft', c('CDF of piecewise exp dist given t &gt; 0.1', 'quantile
    function of piecewise exp dist given t &gt; 0.1', 'CDF of piecewise exp dist',
  'quantile function of piecewise exp dist'), col=c('red', 'red', 'black', 'black'),
  lty=c(1, 2, 1, 2), lwd=2)

# use rpwexp_conditional function to generate piecewise exp samples with rate 2, 1, 3 given t &gt; 0.1
r_sample_con &lt;- rpwexp_conditional(3000, qT=0.1, rate=c(2, 1, 3), breakpoint=c(0.3,0.8))
plot(ecdf(r_sample_con), col='red', lwd=2,  main="Empirical CDF of Conditional
    Piecewsie Exp Dist", xlim=c(0, 1.2), ylim=c(0, 1))

# compare with its CDF
lines(seq(0.1, 1.2, 0.01), F2_con, lwd=2)
legend('topleft', c('empirial CDF of piecewise exp dist given t &gt; 0.1',
    'true CDF of piecewise exp dist given t &gt; 0.1'), col=c('red', 'black'), lty=c(1,2), lwd=2)
</code></pre>

<hr>
<h2 id='cut_dat'>Cut Data before a Specified Time</h2><span id='topic+cut_dat'></span>

<h3>Description</h3>

<p>Take a subset of a dataset by constraining the randomization time &lt;= cut time. Additionally, it updates the follow-up time, censor/event indicator, censor reason, accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_dat(cut, data, var_randT=NULL, var_followT=NULL, var_followT_abs=NULL,
      var_censor=NULL, var_event=NULL, var_censor_reason='status_at_end')
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_dat_+3A_cut">cut</code></td>
<td>
<p>cut time (from the beginning of the trial); only rows with randomization time &lt;= <code>cut</code> will be kept.</p>
</td></tr>
<tr><td><code id="cut_dat_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="cut_dat_+3A_var_randt">var_randT</code></td>
<td>
<p>character; the variable name of randomization time. If missing, then the randomization time will be treated as 0 and NO subjects will be filtered by <code>cut</code> time.</p>
</td></tr>
<tr><td><code id="cut_dat_+3A_var_followt">var_followT</code></td>
<td>
<p>character; the variable name of follow-up time (from randomization)</p>
</td></tr>
<tr><td><code id="cut_dat_+3A_var_followt_abs">var_followT_abs</code></td>
<td>
<p>character; the variable name of follow-up time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code id="cut_dat_+3A_var_censor">var_censor</code></td>
<td>
<p>character; the variable name of censoring (drop-out or death) indicator (1=censor, 0=event)</p>
</td></tr>
<tr><td><code id="cut_dat_+3A_var_event">var_event</code></td>
<td>
<p>character; the variable name of event indicator (1=event, 0=censor)</p>
</td></tr>
<tr><td><code id="cut_dat_+3A_var_censor_reason">var_censor_reason</code></td>
<td>
<p>character; the variable name of censoring reason (character variable). This variable will be created, if <code>data</code> does not contain it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We first filter rows that randomization time is equal to or less then <code>cut</code> time. Then we modify these columns (if provided):
</p>

<ul>
<li> <p><code>var_followT:</code> change values to (<code>cut</code> - randomization time) if (follow-up time + randomization time) &gt; <code>cut</code>
</p>
</li>
<li> <p><code>var_followT_abs:</code> change values to <code>cut</code> if (follow-up time from beginning) &gt; <code>cut</code>
</p>
</li>
<li> <p><code>var_censor:</code> change values to 1 if (follow-up time from beginning) &gt; <code>cut</code>
</p>
</li>
<li> <p><code>var_event:</code> change values to 0 if (follow-up time from beginning) &gt; <code>cut</code>
</p>
</li>
<li> <p><code>var_censor_reason:</code> change values to 'cut' if (follow-up time from beginning) &gt; <code>cut</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A subset data frame with the same columns as <code>data</code>.
</p>
<p><code>var_censor_reason</code> is the only variable that is allowed to be absent in <code>data</code>. The function will create this variable in the returned data frame and set values 'cut' to the subjects whose (follow-up time from beginning) &gt; <code>cut</code>.
</p>


<h3>Note</h3>

<p>The original dataset <code>data</code> will NOT be modified.
</p>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>event_dist &lt;- function(n)rpwexp(n, rate = c(0.1, 0.01, 0.2), breakpoint =  c(5,14))
dat &lt;- simdata(rand_rate = 20, total_sample = 1000, drop_rate = 0.03,
               advanced_dist = list(event_dist=event_dist),
               add_column = c('censor_reason','event','followT','followT_abs'))
cut &lt;- quantile(dat$randT, 0.8)
train &lt;- cut_dat(var_randT = 'randT', cut = cut, data = dat,
                 var_followT = 'followT', var_followT_abs = 'followT_abs',
                 var_event = 'event', var_censor_reason = 'censor_reason')
</code></pre>

<hr>
<h2 id='cv.pwexp.fit'>Cross Validate a Piecewise Exponential Model</h2><span id='topic+cv.pwexp.fit'></span><span id='topic+cv.pwexp.fit.default'></span><span id='topic+cv.pwexp.fit.pwexp.fit'></span>

<h3>Description</h3>

<p>Cross Validate a existing piecewise exponential model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
cv.pwexp.fit(time, event, nfold=5, nsim=100, breakpoint=NULL,
             nbreak=0, exclude_int=NULL, min_pt_tail=5, max_set=1000, seed=1818,
             optimizer='mle', tol=1e-4, parallel=FALSE, mc.core=4, ...)
## S3 method for class 'pwexp.fit'
cv.pwexp.fit(time, nfold=5, nsim=100, max_set=1000, seed=1818,
             optimizer='mle', tol=1e-4, parallel=FALSE, mc.core=4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.pwexp.fit_+3A_time">time</code></td>
<td>
<p>observed time from randomization or a <code><a href="#topic+pwexp.fit">pwexp.fit</a></code> object.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_event">event</code></td>
<td>
<p>the status indicator.  See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_nfold">nfold</code></td>
<td>
<p>the number of folds used in CV.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_breakpoint">breakpoint</code></td>
<td>
<p>pre-specified breakpoints. See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_nbreak">nbreak</code></td>
<td>
<p>total number of breakpoints.  See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_exclude_int">exclude_int</code></td>
<td>
<p>an interval that excludes any estimated breakpoints.  See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_min_pt_tail">min_pt_tail</code></td>
<td>
<p>the minimum number of events used for estimating the tail (the hazard rate of the last piece).  See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_max_set">max_set</code></td>
<td>
<p>maximum estimated combination of breakpoints.  See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_seed">seed</code></td>
<td>
<p>a random seed.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_optimizer">optimizer</code></td>
<td>
<p>one of the optimizers: <code>mle</code>, <code>ols</code>, or <code>hybrid</code>. See <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_tol">tol</code></td>
<td>
<p>the minimum allowed gap between two breakpoints. The gap is calculated as <code>(max(time)-min(time))*tol</code>. Keep it as default in most cases. </p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_parallel">parallel</code></td>
<td>
<p>logical. If <code>TRUE</code>, use <span class="pkg">doSNOW</span> package to run in parallel.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_mc.core">mc.core</code></td>
<td>
<p>number of processes allowed to be run in parallel.</p>
</td></tr>
<tr><td><code id="cv.pwexp.fit_+3A_...">...</code></td>
<td>
<p>internal function reserved. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use cross validation obtain the prediction log likelihood.
</p>


<h3>Value</h3>

<p>A vector of length <code>nsim</code> containing the CV log likelihood in each round of simulation.
</p>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pwexp.fit">pwexp.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>event_dist &lt;- function(n)rpwexp(n, rate = c(0.1, 0.01, 0.2), breakpoint =  c(5,14))
dat &lt;- simdata(rand_rate = 20, drop_rate = 0.03,  total_sample = 1000,
               advanced_dist = list(event_dist=event_dist),
               add_column = c('censor_reason','event','followT','followT_abs'))

# here nsim=10 is for demo purpose, pls increase it in practice!!

cv0 &lt;- cv.pwexp.fit(dat$followT, dat$event, nsim = 10, nbreak = 0)
cv1 &lt;- cv.pwexp.fit(dat$followT, dat$event, nsim = 10, nbreak = 1)
cv2 &lt;- cv.pwexp.fit(dat$followT, dat$event, nsim = 10, nbreak = 2)
sapply(list(cv0,cv1,cv2), median)

</code></pre>

<hr>
<h2 id='piecewise+20exponential'>The Piecewise Exponential Distribution</h2><span id='topic+dpwexp'></span><span id='topic+ppwexp'></span><span id='topic+qpwexp'></span><span id='topic+rpwexp'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the piecewise exponential distribution with piecewise rate <code>rate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpwexp(x, rate = 1, breakpoint = NULL, log = FALSE, one_piece, safety_check = TRUE)
ppwexp(q, rate = 1, breakpoint = NULL, lower.tail = TRUE, log.p = FALSE,
       one_piece, safety_check = TRUE)
qpwexp(p, rate = 1, breakpoint = NULL, lower.tail = TRUE, log.p = FALSE,
       one_piece, safety_check = TRUE)
rpwexp(n, rate = 1, breakpoint = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="piecewise+2B20exponential_+3A_x">x</code>, <code id="piecewise+2B20exponential_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="piecewise+2B20exponential_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="piecewise+2B20exponential_+3A_n">n</code></td>
<td>
<p>number of observations. Must be a positive integer with length 1. </p>
</td></tr>
<tr><td><code id="piecewise+2B20exponential_+3A_rate">rate</code></td>
<td>
<p>a vector of rates in each piece.</p>
</td></tr>
<tr><td><code id="piecewise+2B20exponential_+3A_breakpoint">breakpoint</code></td>
<td>
<p>a vector of breakpoints. The length is <code>length(rate)-1</code>. Can be NULL if rate is a single value.</p>
</td></tr>
<tr><td><code id="piecewise+2B20exponential_+3A_log">log</code>, <code id="piecewise+2B20exponential_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="piecewise+2B20exponential_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="piecewise+2B20exponential_+3A_one_piece">one_piece</code></td>
<td>
<p>(only required when <code>safety_check=FALSE</code>) whether the distribution only has one piece (i.e.,
rate is a single value and breakpoint=NULL).</p>
</td></tr>
<tr><td><code id="piecewise+2B20exponential_+3A_safety_check">safety_check</code></td>
<td>
<p>logical; whether check the input arguments; if FALSE, function has better computing performance by skipping all safety checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The piecewise distribution function with piecewise rate <code class="reqn">\lambda_1, \dots, \lambda_r</code> is
</p>
<p style="text-align: center;"><code class="reqn">f(t)=\lambda_{r+1} exp{[\sum_{i=1}^r(\lambda_{i+1}-\lambda_{i})d_i-\lambda_{r+1}t}</code>
</p>

<p>for <code class="reqn">d_{r} \le t &lt; d_{r+1}</code>.
</p>
<p>See webpage <a href="https://zjph602xtc.github.io/PWEXP/">https://zjph602xtc.github.io/PWEXP/</a> for more details for its hazard function, cumulative hazard function, survival function, cumulative density function, quantile function.
</p>


<h3>Value</h3>

<p><code>dpwexp</code> gives the density, <code>ppwexp</code> gives the distribution function, <code>qpwexp</code> gives the quantile function, and <code>rpwexp</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>x</code>, <code>q</code>, <code>p</code> or <code>n</code> for <code>dpwexp</code>, <code>ppwexp</code>, <code>qpwexp</code> or <code>rpwexp</code>. You can only specify a single piecewise exponential distribution every time you call these functions. This is different from the exponential distribution functions in package <span class="pkg">stats</span>.
</p>
<p>Arguments <code>rate</code> and <code>breakpoint</code> must match. The length of rate is the length of breakpoint + 1.
</p>


<h3>Note</h3>

<p>When <code>breakpoint=NULL</code>, the function calls exponential function in <span class="pkg">stats</span>.
</p>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppwexp_conditional">ppwexp_conditional</a></code>,
<code><a href="#topic+qpwexp_conditional">qpwexp_conditional</a></code>,
<code><a href="#topic+rpwexp_conditional">rpwexp_conditional</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use rpwexp function to generate piecewise exp samples with rate 2, 1, 3
r_sample &lt;- rpwexp(50000, rate=c(2, 1, 3), breakpoint=c(0.3, 0.8))
hist(r_sample, freq=FALSE, breaks=200, main="Density of Piecewsie Exp Dist",
    xlab='t', xlim=c(0, 1.2))

# piecewise exp density with rate 2, 1, 3
t &lt;- seq(0, 1.5, 0.01)
f2 &lt;- dpwexp(t, rate=c(2, 1, 3), breakpoint=c(0.3, 0.8))
points(t, f2, col='red', pch=16)

# exp distribution can be a special case of piecewise exp distribution
f1 &lt;- dpwexp(t, rate=2)
lines(t, f1, lwd=2)
legend('topright', c('exp dist with rate 2','piecewise exp dist with rate 2, 1,
    3','histogram of piecewise exp dist with rate 2, 1, 3'),
    col=c('black','red'), fill=c(NA, NA, 'grey'), border=c('white', 'white',
    'black'), lty=c(1, NA, NA), pch=c(NA, 16, NA), lwd=2)

# CDF of piecewise exp with rate 2, 1, 3
F2 &lt;- ppwexp(t, rate=c(2, 1, 3), breakpoint=c(0.3, 0.8), lower.tail=TRUE)
plot(t, F2, type='l', col='red', lwd=2, main="CDF and Quantile Function of
    Piecewsie Exp Dist", xlim=c(0, 1.5), ylim=c(0, 1.5))

# CDF of exp dist is compatible with our package
F1 &lt;- ppwexp(t, rate=2, lower.tail=TRUE)
lines(t, F1, lwd=2)

# plot quantile functions of both distributions
lines(F1, qpwexp(F1, rate=2, lower.tail=TRUE), lty=2, lwd=2)
lines(F2, qpwexp(F2, rate=c(2, 1, 3), breakpoint=c(0.3,0.8), lower.tail=TRUE),
    col='red', lty=2, lwd=2)

abline(0, 1, col='grey')
legend('topleft', c('CDF of piecewise exp with rate 2, 1, 3', 'quantile
    function of piecewise exp with rate 2, 1, 3', 'CDF of exp with rate 2',
    'quantile function of exp with rate 2'), col=c('red', 'red', 'black',
    'black'), lty=c(1, 2, 1, 2), lwd=2)
</code></pre>

<hr>
<h2 id='plot_event'>Plot Cumulative Event Curve</h2><span id='topic+plot_event'></span><span id='topic+plot_event.default'></span><span id='topic+plot_event.predict.pwexp.fit'></span><span id='topic+plot_event.predict.boot.pwexp.fit'></span>

<h3>Description</h3>

<p>Plot cumulative event curve with right censoring data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
plot_event(time, event, abs_time=TRUE, additional_event=0,
         add=FALSE, plot=TRUE, xyswitch=FALSE, ...)
## S3 method for class 'predict.pwexp.fit'
plot_event(time, abs_time=TRUE, add=TRUE, plot=TRUE,
         xyswitch=FALSE, eval_at=NULL, ...)
## S3 method for class 'predict.boot.pwexp.fit'
plot_event(time, abs_time=TRUE, alpha=0.1, type='confidence',
         add=TRUE, plot=TRUE, xyswitch=FALSE, eval_at=NULL,
         show_CI=TRUE, CI_par=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_event_+3A_time">time</code></td>
<td>
<p>observed/follow-up time from individual randomization time (<code>abs_time=FALSE</code>) or from the first subject randomization time (<code>abs_time=TRUE</code>); or a predicted object from <code><a href="#topic+predict.pwexp.fit">predict.pwexp.fit</a></code>, or a predicted object with bootstrapping  from <code><a href="#topic+predict.boot.pwexp.fit">predict.boot.pwexp.fit</a></code>.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_abs_time">abs_time</code></td>
<td>
<p>logical; if TRUE, <code>time</code> is the time from first randomization of the trial. if FALSE, <code>time</code> is the time from the randomization of each subject. </p>
</td></tr>
<tr><td><code id="plot_event_+3A_event">event</code></td>
<td>
<p>the status indicator, 0=censor, 1=event. Other choices are TRUE/FALSE (TRUE = event).</p>
</td></tr>
<tr><td><code id="plot_event_+3A_additional_event">additional_event</code></td>
<td>
<p>adding the cumulative number of events by a constant number from the beginning. </p>
</td></tr>
<tr><td><code id="plot_event_+3A_add">add</code></td>
<td>
<p>logical; if TRUE add lines to current plot.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_plot">plot</code></td>
<td>
<p>logical; if FALSE, do not plot any lines, but return the line data</p>
</td></tr>
<tr><td><code id="plot_event_+3A_xyswitch">xyswitch</code></td>
<td>
<p>logical; if TRUE, x-axis will be cumulative number of events and y will be the time.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_eval_at">eval_at</code></td>
<td>
<p>a vector of the time (when <code>xyswitch=FALSE</code>) or the number of events (when <code>xyswitch=TRUE</code>) that you want to make prediction on. </p>
</td></tr>
<tr><td><code id="plot_event_+3A_alpha">alpha</code></td>
<td>
<p>the significance level of the confidence interval.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_type">type</code></td>
<td>
<p>the type of prediction required. The default <code>confidence</code> returns the confidence interval without random error; the alternative <code>predictive</code> returns the predictive interval.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_show_ci">show_CI</code></td>
<td>
<p>logical; if TRUE add confidence interval of the estimated event curve. </p>
</td></tr>
<tr><td><code id="plot_event_+3A_ci_par">CI_par</code></td>
<td>
<p>a list of parameters to control the apperance of lines of confidence intervals. The values pass to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plot_event_+3A_...">...</code></td>
<td>
<p>other arguments (e.g., <code>lwd</code>, etc.) are passed over to <code><a href="base.html#topic+plot">plot</a>.</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient function to calculate and plot the cumulative number of events.
</p>
<p>Parameters in <code>...</code> are passed to <code><a href="base.html#topic+plot">plot</a></code> function to control the appearance of the event curve; parameters in <code>CI_par</code> are passed to <code><a href="graphics.html#topic+lines">lines</a></code> function to control the appearance of confidence intervals. See examples for usage.
</p>
<p>By default, <code>plot_event</code> plots a data frame in a new figure; and plots a predicted model in existing figure.
</p>


<h3>Value</h3>

<p>A data frame containing these columns:
</p>
<table role = "presentation">
<tr><td><code>time</code></td>
<td>
<p>sorted time</p>
</td></tr>
<tr><td><code>n_event</code></td>
<td>
<p>cumulative number of events</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_survival">plot_survival</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1818)
event_dist &lt;- function(n)rpwexp(n, rate = c(0.1, 0.01, 0.2), breakpoint =  c(5,14))
dat &lt;- simdata(rand_rate = 20, drop_rate = 0.03,  total_sample = 1000,
               advanced_dist = list(event_dist=event_dist),
               add_column = c('censor_reason','event','followT','followT_abs'))
cut &lt;- quantile(dat$randT, 0.8)
train &lt;- cut_dat(var_randT = 'randT', cut = cut, data = dat,
                 var_followT = 'followT', var_followT_abs = 'followT_abs',
                 var_event = 'event', var_censor_reason = 'censor_reason')

fit_res3 &lt;- pwexp.fit(train$followT, train$event, nbreak = 2)
fit_res_boot &lt;- boot.pwexp.fit(fit_res3, nsim = 8) # here nsim=8 is for demo purpose,
                                                    # pls increase it in practice

drop_indicator &lt;-  ifelse(train$censor_reason=='drop_out' &amp; !is.na(train$censor_reason),1,0)
fit_res_censor &lt;- pwexp.fit(train$followT, drop_indicator, nbreak = 0)
fit_res_censor_boot &lt;- boot.pwexp.fit(fit_res_censor, nsim = 8)

cut_indicator &lt;- train$censor_reason=='cut'
cut_indicator[is.na(cut_indicator)] &lt;- 0

predicted_boot &lt;- predict(fit_res_boot, cut_indicator = cut_indicator,
                     analysis_time = cut,  censor_model_boot=fit_res_censor_boot,
                     future_rand=list(rand_rate=20, total_sample=NROW(dat)-NROW(train)))

plot_event(dat$followT_abs, abs_time = TRUE, event=dat$event, ylim=c(0,800))
plot_event(predicted_boot, eval_at = seq(40,90,5), CI_par = list(lty=3, lwd=2))

plot_event(dat$followT_abs, xlim=c(0,800), event=dat$event, xyswitch = TRUE)
plot_event(predicted_boot, xyswitch = TRUE, eval_at = seq(600,900,50))
</code></pre>

<hr>
<h2 id='plot_survival'>Plot Survival Curve</h2><span id='topic+plot_survival'></span><span id='topic+plot_survival.default'></span><span id='topic+plot_survival.pwexp.fit'></span><span id='topic+plot_survival.boot.pwexp.fit'></span>

<h3>Description</h3>

<p>Plot KM curve with right censoring data or the survival curve of a fitted piecewise exponential model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
plot_survival(time, event, add=FALSE, conf.int=FALSE, mark.time=TRUE,
       lwd=2, xlab='Follow-up time', ylab='Survival function', ...)
## S3 method for class 'pwexp.fit'
plot_survival(time, add=TRUE, show_breakpoint=TRUE,
       breakpoint_par=NULL, ...)
## S3 method for class 'boot.pwexp.fit'
plot_survival(time, add=TRUE, alpha=0.1, show_breakpoint=TRUE,
       breakpoint_par=NULL, show_CI=TRUE, CI_par=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_survival_+3A_time">time</code></td>
<td>
<p>observed time from randomization or a <code><a href="#topic+pwexp.fit">pwexp.fit</a></code>/ <code><a href="#topic+boot.pwexp.fit">boot.pwexp.fit</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_event">event</code></td>
<td>
<p>the status indicator, normally 0=censor, 1=event. Other choices are TRUE/FALSE (TRUE = event). </p>
</td></tr>
<tr><td><code id="plot_survival_+3A_add">add</code></td>
<td>
<p>logical; if TRUE add lines to current plot.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_show_breakpoint">show_breakpoint</code></td>
<td>
<p>logical; if TRUE add vertial dashed lines to indicate breakpoints.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_breakpoint_par">breakpoint_par</code></td>
<td>
<p>a list of parameters to control the apperance of vertical lines of breakpoionts. The values pass to <code><a href="graphics.html#topic+abline">abline</a></code>.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_alpha">alpha</code></td>
<td>
<p>the significance level of the confidence interval. </p>
</td></tr>
<tr><td><code id="plot_survival_+3A_show_ci">show_CI</code></td>
<td>
<p>logical; if TRUE add confidence interval of the estimated curve. For KM esitmator, use <code>conf.int=TRUE</code> to show CI band.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_ci_par">CI_par</code></td>
<td>
<p>a list of parameters to control the apperance of lines of confidence intervals. The values pass to <code><a href="graphics.html#topic+lines">lines</a></code>.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_conf.int">conf.int</code></td>
<td>
<p>determines whether pointwise confidence intervals will be plotted. Passed over to <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_mark.time">mark.time</code></td>
<td>
<p>controls the labeling of the curves. Passed over to <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_lwd">lwd</code></td>
<td>
<p>line width of the KM curve. </p>
</td></tr>
<tr><td><code id="plot_survival_+3A_xlab">xlab</code></td>
<td>
<p>x label.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_ylab">ylab</code></td>
<td>
<p>y label.</p>
</td></tr>
<tr><td><code id="plot_survival_+3A_...">...</code></td>
<td>
<p>other arguments are passed over to <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code> (default method) or <code><a href="base.html#topic+plot">plot</a></code> (for class <code>pwexp.fit</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the default method, this a  wrapper of <code><a href="survival.html#topic+plot.survfit">plot.survfit</a></code> function to plot right censoring data.
</p>
<p>For class <code>pwexp.fit</code>, parameters in <code>...</code> are passed to <code><a href="base.html#topic+plot">plot</a></code> function to control the appearance of the survival curve; parameters in <code>breakpoint_par</code> are passed to <code><a href="graphics.html#topic+abline">abline</a></code> function to control the appearance of vertical lines of breakpoints. See examples for usage.
</p>
<p>For class <code>boot.pwexp.fit</code>, parameters in <code>...</code> are passed to <code><a href="base.html#topic+plot">plot</a></code> function to control the appearance of the survival curve; parameters in <code>breakpoint_par</code> are passed to <code><a href="graphics.html#topic+abline">abline</a></code> function to control the appearance of vertical lines of breakpoints; parameters in <code>CI_par</code> are passed to <code><a href="graphics.html#topic+lines">lines</a></code> function to control the appearance of confidence intervals. See examples for usage.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_event">plot_event</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>event_dist &lt;- function(n)rpwexp(n, rate = c(0.1, 0.01, 0.2), breakpoint =  c(5,14))
dat &lt;- simdata(rand_rate = 20, drop_rate = 0.03,  total_sample = 1000,
               advanced_dist = list(event_dist=event_dist),
               add_column = c('censor_reason','event','followT','followT_abs'))

plot_survival(dat$followT, dat$event, xlim=c(0,40))

fit_res &lt;- pwexp.fit(dat$followT, dat$event, nbreak = 2)
plot_survival(fit_res, col='red', lwd=3, breakpoint_par = list(col='grey', lwd=2.5))
</code></pre>

<hr>
<h2 id='predict'>Predict Events for Piecewise Exponential Model</h2><span id='topic+predict.pwexp.fit'></span><span id='topic+predict.boot.pwexp.fit'></span>

<h3>Description</h3>

<p>Obtians event prediction and (optionally) confidence interval from a piecewise exponential model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pwexp.fit'
predict(object, cut_indicator=NULL, analysis_time, censor_model=NULL,
      n_each=100, future_rand=NULL, seed=1818, ...)
## S3 method for class 'boot.pwexp.fit'
predict(object, cut_indicator=NULL, analysis_time,
      censor_model_boot=NULL, n_each=10, future_rand=NULL,
      seed=1818, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+pwexp.fit">pwexp.fit</a></code> or <code><a href="#topic+boot.pwexp.fit">boot.pwexp.fit</a></code> object. It is the event model for the primary endpoint. </p>
</td></tr>
<tr><td><code id="predict_+3A_cut_indicator">cut_indicator</code></td>
<td>
<p>(optional) A vector indicates which subject is censored due to the end of the trial. The length of the vector is the number of rows of the data used in <code>event_model</code>/<code>event_model_boot</code>. Value 0 means the subject had event or drop-out or death before the end of the trial; 1 means the subject didn't have any of these. See details. </p>
</td></tr>
<tr><td><code id="predict_+3A_analysis_time">analysis_time</code></td>
<td>
<p>the analysis time. This is the time length from the start of the trial to the time collecting data for the model. </p>
</td></tr>
<tr><td><code id="predict_+3A_censor_model">censor_model</code></td>
<td>
<p>an object of class <code>pwexp.fit</code> returned by the <code><a href="#topic+pwexp.fit">pwexp.fit</a></code> function. It is the censoring model for drop-out and death. </p>
</td></tr>
<tr><td><code id="predict_+3A_censor_model_boot">censor_model_boot</code></td>
<td>
<p>an object of class <code>boot.pwexp.fit</code> returned by the <code><a href="#topic+boot.pwexp.fit">boot.pwexp.fit</a></code> function. It is the censoring model with bootstrapping for drop-out and death. </p>
</td></tr>
<tr><td><code id="predict_+3A_n_each">n_each</code></td>
<td>
<p>the number of iterations for each bootstrapping sample to obtain predicitive CI. Typically, a value of 10 to 100 should be enough. </p>
</td></tr>
<tr><td><code id="predict_+3A_future_rand">future_rand</code></td>
<td>
<p>the randomization curve in the following times. Can be <code>NULL</code> if all subjects have been randomized. You can specify <b>future</b> rand rate and <b>future</b> total number of samples to be randomized by <code>list(rand_rate= ,total_sample= )</code> or specify the <b>future</b> number of randomization each month by <code>list(rand_n= )</code>. See details.</p>
</td></tr>
<tr><td><code id="predict_+3A_seed">seed</code></td>
<td>
<p>a random seed.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>internal function reserved. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The prediction will have a confidence interval only if the event model and censor model are bootstrap models.
</p>
<p><code>cut_indicator</code> indicates the status of each subject in the <code>event_model</code>/<code>event_model_boot</code> model at the end of the trial. Value 1 means the subject didn't have events, drop-out or death at the end of the trial (or say, the subject was censored due to the end of the trial). When <code>cut_indicator</code> is NOT provided, we assign value 1 to the subject who didn't have event (or drop-out, or death) in both  <code>event_model</code>/<code>event_model_boot</code> and <code>censor_model</code>/<code>censor_model_boot</code> models.
</p>
<p><code>future_rand</code> is a list determining the parameter of randomization curve in the following times. For example, you specify randomization rate=10pt/month and total sample size=1000 by <code>list(rand_rate=10 ,total_sample=1000)</code> or specify the number of randomization each month (e.g., 10,15,30,30 in four months) by <code>list(n_rand=c(10,15,30,30))</code>.
</p>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>event_fun</code> number of events vs. time curve function in each bootstrap.
</p>
</li>
<li> <p><code>time_fun</code> time vs. number of events curve function in each bootstrap.
</p>
</li></ul>

<p>This returned list should be used in <code><a href="#topic+plot_event">plot_event</a></code> function for summarizing its result.
</p>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_event">plot_event</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1818)
event_dist &lt;- function(n)rpwexp(n, rate = c(0.1, 0.2), breakpoint = 14)
dat &lt;- simdata(rand_rate = 20, drop_rate = 0.03,  total_sample = 500,
               advanced_dist = list(event_dist=event_dist),
               add_column = c('censor_reason','event','followT','followT_abs'))
cut &lt;- quantile(dat$randT, 0.8)
train &lt;- cut_dat(var_randT = 'randT', cut = cut, data = dat,
                 var_followT = 'followT', var_followT_abs = 'followT_abs',
                 var_event = 'event', var_censor_reason = 'censor_reason')

fit_res3 &lt;- pwexp.fit(train$followT, train$event, nbreak = 1)
fit_res_boot &lt;- boot.pwexp.fit(fit_res3, nsim = 8) # here nsim=8 is for demo purpose,
                                                    # pls increase it in practice

drop_indicator &lt;-  ifelse(train$censor_reason=='drop_out' &amp; !is.na(train$censor_reason),1,0)
fit_res_censor &lt;- pwexp.fit(train$followT, drop_indicator, nbreak = 0)
fit_res_censor_boot &lt;- boot.pwexp.fit(fit_res_censor, nsim = 8)

cut_indicator &lt;- train$censor_reason=='cut'
cut_indicator[is.na(cut_indicator)] &lt;- 0

predicted_boot &lt;- predict(fit_res_boot, cut_indicator = cut_indicator,
                     analysis_time = cut,  censor_model_boot=fit_res_censor_boot,
                     future_rand=list(rand_rate=20, total_sample=NROW(dat)-NROW(train)))
plot_event(train$followT_abs, train$event, xlim=c(0,69), ylim=c(0,800))
plot_event(predicted_boot, eval_at = 40:90)
plot_event(train$followT_abs, train$event, xyswitch = TRUE, ylim=c(0,69), xlim=c(0,800))
plot_event(predicted_boot, xyswitch = TRUE, eval_at = 600:900)
</code></pre>

<hr>
<h2 id='pwexp.fit'>Fit the Piecewise Exponential Distribution</h2><span id='topic+pwexp.fit'></span>

<h3>Description</h3>

<p>Fit the piecewise exponential distribution with right censoring data. User can specifity all breakpoints, some of the breakpoints or let the function estimate the breakpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pwexp.fit(time, event, breakpoint=NULL, nbreak=0, exclude_int=NULL, min_pt_tail=5,
        max_set=10000, seed=1818, trace=FALSE, optimizer='mle', tol=1e-4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pwexp.fit_+3A_time">time</code></td>
<td>
<p>observed time from randomization. For right censored data, this is the follow-up time.</p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_event">event</code></td>
<td>
<p>the status indicator, normally 0=censor, 1=event. Other choices are TRUE/FALSE (TRUE = event). </p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_breakpoint">breakpoint</code></td>
<td>
<p>fixed breakpoints. Pre-specifity some breakpionts. The maximum value must be earlier than the last event time.</p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_nbreak">nbreak</code></td>
<td>
<p>total number of breakpoints in the model. This number includes the points specified in <code>breakpoint</code>. If <code>nbreak=NULL</code>, then <code>nbreak=ceiling(8*(# unique events)^0.2)</code>.</p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_exclude_int">exclude_int</code></td>
<td>
<p>an interval that excludes any estimated breakpoints (e.g., <code>exclude_int=c(10,Inf)</code> will exclude any estimated breakpoints after t=10). See details.</p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_min_pt_tail">min_pt_tail</code></td>
<td>
<p>the minimum number of events used for estimating the tail (the hazard rate of the last piece). See details.</p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_max_set">max_set</code></td>
<td>
<p>maximum estimated combination of breakpoints. </p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_seed">seed</code></td>
<td>
<p>a random seed.</p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_trace">trace</code></td>
<td>
<p>(internal use) logical; if TRUE, the returned data frame contains the log-likelihood of all possible breakpoints instead of the one with maximum likelihood. </p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_optimizer">optimizer</code></td>
<td>
<p>one of the optimizers: <code>mle</code>, <code>ols</code>, or <code>hybrid</code>. </p>
</td></tr>
<tr><td><code id="pwexp.fit_+3A_tol">tol</code></td>
<td>
<p>the minimum allowed gap between two breakpoints. The gap is calculated as <code>(max(time)-min(time))*tol</code>. Keep it as default in most cases. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See webpage <a href="https://zjph602xtc.github.io/PWEXP/">https://zjph602xtc.github.io/PWEXP/</a> for a detailed description of the model and optimizers.
</p>
<p>If user specifies <code>breakpoint</code>, we will check the values to make the model identifiable. Any breakpoints after the last event time will be removed;  Any breakpoints before the first event time will be removed; a mid-point will be used if there are NO events between  any two concesutive breakpoints. A warning will be given.
</p>
<p>If user sets <code>nbreak=NULL</code>, then the function will automatically apply <code>nbreak=ceiling(8*(# unique events)^0.2)</code>. This empirical number of breakpoints is for the reference below, and it may be too large in many cases.
</p>
<p>Argument <code>exclude_int</code> is a vector of two values such as <code>exclude_int=c(a, b)</code> (<code>b</code> can be <code>Inf</code>). It defines an interval that excludes any estimated breakpoints. It is helpful when excluding breakpoints that are too close to the tail.
</p>
<p>In order to obtain a more robust hazard rate estimation of the tail, user can set <code>min_pt_tail</code> to the minimum number of events for estimating the tail (last piece of the piecewise exponential). It only works for <code>optimizer='mle'</code>.
</p>


<h3>Value</h3>

<p>A data frame (<code>res</code>) containing these columns:
</p>
<table role = "presentation">
<tr><td><code>brk1</code>, <code>...</code>, <code>brkx</code></td>
<td>
<p>estimated breakpoints. The <code>attr(res,'brk')</code> can extract the vector of breakpoint from the model (<code>res</code> is the returned model from <code>pwexp.fit</code>). </p>
</td></tr>
<tr><td><code>lam1</code>, <code>...</code>, <code>lamx</code></td>
<td>
<p>estimated piecewise hazard rates. The <code>attr(res,'lam')</code> can extract the vector of hazard rates from the model (<code>res</code> is the returned model from <code>pwexp.fit</code>). </p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>the log-likelihood of the model.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike information criterion of the model.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>the Bayesian information criterion of the model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>References</h3>

<p>Muller, H. G., &amp; Wang, J. L. (1994). Hazard rate estimation under random censoring with varying kernels and bandwidths. Biometrics, 61-76.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.pwexp.fit">boot.pwexp.fit</a></code>, <code><a href="#topic+cv.pwexp.fit">cv.pwexp.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>event_dist &lt;- function(n)rpwexp(n, rate=c(0.1, 0.01, 0.2), breakpoint=c(5,14))
dat &lt;- simdata(rand_rate = 20, total_sample = 1000, drop_rate = 0.03,
               advanced_dist = list(event_dist=event_dist),
               add_column = c('censor_reason','event','followT','followT_abs'))
cut &lt;- quantile(dat$randT, 0.8)
train &lt;- cut_dat(var_randT = 'randT', cut = cut, data = dat,
                 var_followT = 'followT', var_followT_abs = 'followT_abs',
                 var_event = 'event', var_censor_reason = 'censor_reason')

fit_a0 &lt;- pwexp.fit(train$followT, train$event, breakpoint = c(5,14))
fit_a1 &lt;- pwexp.fit(train$followT, train$event, nbreak = 2, breakpoint = c(14))
fit_b0 &lt;- pwexp.fit(train$followT, train$event, nbreak = 0)
fit_b1 &lt;- pwexp.fit(train$followT, train$event, nbreak = 1)
fit_b2 &lt;- pwexp.fit(train$followT, train$event, nbreak = 2)
</code></pre>

<hr>
<h2 id='sim_followup'>Estimate follow up time and number of events by simulation</h2><span id='topic+sim_followup'></span>

<h3>Description</h3>

<p><code>sim_follwup</code> is used to estimate follow-up time and number of events (given calander time, or number of randomized samples, or number of events).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_followup(at, type = 'calander', group="Group 1", strata='Strata 1',
            allocation=1, event_lambda=NA, drop_rate=NA, death_lambda=NA,
            n_rand=NULL, rand_rate=NULL, total_sample=NULL, extra_follow=0,
            by_group=FALSE, by_strata=FALSE, advanced_dist=NULL,
            stat=c(mean, median, sum), follow_up_endpoint=c('death', 'drop_out',
            'cut'), count_in_extra_follow=FALSE, count_insufficient_event=FALSE,
            start_date=NULL, rep=300, seed=1818)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_followup_+3A_at">at</code></td>
<td>
<p>specify a vector of occasions. When <code>type='calander'</code>, <code>at</code> is the time from fisrt randomization; when <code>type='event'</code>, <code>at</code> is the number of accumulated events; when <code>type='sample'</code>, <code>at</code> is  the number of randomized samples. </p>
</td></tr>
<tr><td><code id="sim_followup_+3A_type">type</code></td>
<td>
<p>specify the type of <code>at</code>. Must be <code>'calander'</code>, <code>event</code> or <code>sample</code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_group">group</code></td>
<td>
<p>a character vector of the names of each group (e.g., <code>c('treatment','control')</code>). See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_strata">strata</code></td>
<td>
<p>a character vector of the names of strata in groups (e.g., <code>c('young','old')</code>). See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_allocation">allocation</code></td>
<td>
<p>the relative ratio of sample size in each subgroup (<code>group*strata</code>).  The value will be recycled if the length is less than needed. See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_event_lambda">event_lambda</code></td>
<td>
<p>the hazard rate of the primary endpoint (event). The value will be recycled if the length is less than needed. See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_drop_rate">drop_rate</code></td>
<td>
<p>(optional) the drop-out rate (patients/month). Not hazard rate. The value will be recycled if the length is less than needed. See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_death_lambda">death_lambda</code></td>
<td>
<p>(optional) the hazard rate of death. The value will be recycled if the length is less than needed. See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_n_rand">n_rand</code></td>
<td>
<p>(required when <code>rand_rate=NULL</code>) a vector of the number of randomization each month; can be non-integers. See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_rand_rate">rand_rate</code></td>
<td>
<p>(required when <code>n_rand=NULL</code>) the randomization rate (patients/month; can be non-integer). See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_total_sample">total_sample</code></td>
<td>
<p>(required when <code>n_rand=NULL</code>) total scheduled sample size. See <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_extra_follow">extra_follow</code></td>
<td>
<p>delay the analysis time by extra time (<code>extra_follow</code>) after the time specified by <code>at</code>. See details. </p>
</td></tr>
<tr><td><code id="sim_followup_+3A_by_group">by_group</code></td>
<td>
<p>logical; if TRUE, also return results by each group. </p>
</td></tr>
<tr><td><code id="sim_followup_+3A_by_strata">by_strata</code></td>
<td>
<p>logical; if TRUE, also return results by each stratum. </p>
</td></tr>
<tr><td><code id="sim_followup_+3A_advanced_dist">advanced_dist</code></td>
<td>
<p>use user-specified distributions for event, drop-out and death. A list containing random generation functions. See details and examples in <code><a href="#topic+simdata">simdata</a></code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_stat">stat</code></td>
<td>
<p>a vector of functions to summarize the follow-up time. See example. </p>
</td></tr>
<tr><td><code id="sim_followup_+3A_follow_up_endpoint">follow_up_endpoint</code></td>
<td>
<p>Which endpoints can be regarded as the end of follow-up. Choose from 'death', 'drop_out', 'cut' (censored at the end of the trial) or 'event'.'</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_count_in_extra_follow">count_in_extra_follow</code></td>
<td>
<p>logical; whether to count subjects who are randomized after the time spcified by <code>at</code> but before the time specified by <code>at</code> + <code>extra_follow</code>.</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_count_insufficient_event">count_insufficient_event</code></td>
<td>
<p>logical; only affects the result when <code>type='event'</code>. If TRUE, for samples that cannot achieve required number of events, the last follow-up time is the analysis time. If FALSE, these samples will be dropped. </p>
</td></tr>
<tr><td><code id="sim_followup_+3A_start_date">start_date</code></td>
<td>
<p>the start date of the first randomization; in the format: &quot;2000-01-30&quot;</p>
</td></tr>
<tr><td><code id="sim_followup_+3A_rep">rep</code></td>
<td>
<p>number simulated iterations. </p>
</td></tr>
<tr><td><code id="sim_followup_+3A_seed">seed</code></td>
<td>
<p>a random seed. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the help document of <code><a href="#topic+simdata">simdata</a></code> for most arguments details.
</p>
<p>When <code>type='calander'</code>, the function estimates the follow-up time and number of events at time <code>at</code> plus <code>extra_follow</code>; when <code>type='event'</code>,  the function estimates these at the time when total number of events is <code>at</code> plus time <code>extra_follow</code>; when <code>type='sample'</code>, the function estimates these at the time when total number of randomized subjects is <code>at</code> plus time <code>extra_follow</code>.
</p>
<p>The <code>stat</code> specifies a vector of user defined functions. Each of them must take a vector of individual follow-up time as input and return a single summary value. See example.
</p>


<h3>Value</h3>

<p>A data frame containing the some of these columns:
</p>
<table role = "presentation">
<tr><td><code>ID</code></td>
<td>
<p>subject ID</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>group indicator</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p>stratum indicator</p>
</td></tr>
<tr><td><code>randT</code></td>
<td>
<p>randomization time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code>eventT</code></td>
<td>
<p>event time (from <code>randT</code>)</p>
</td></tr>
<tr><td><code>eventT_abs</code></td>
<td>
<p>event time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code>dropT</code></td>
<td>
<p>drop-out time (from <code>randT</code>)</p>
</td></tr>
<tr><td><code>dropT_abs</code></td>
<td>
<p>drop-out time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code>deathT</code></td>
<td>
<p>death time (from <code>randT</code>)</p>
</td></tr>
<tr><td><code>deathT_abs</code></td>
<td>
<p>death time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code>censor</code></td>
<td>
<p>censoring (drop-out or death) indicator</p>
</td></tr>
<tr><td><code>censor_reason</code></td>
<td>
<p>censoring reason ('drop_out','death','never_event'(followT=inf))</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code>followT</code></td>
<td>
<p>follow-up time / observed time (from <code>randT</code>)</p>
</td></tr>
<tr><td><code>followT_abs</code></td>
<td>
<p>follow-up time / observed time (from the beginning of the trial)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>event_lambda</code>, <code>drop_rate</code>, <code>death_lambda</code> can be 0, which means the corresponding subgroup will have an Inf value for each variable.
</p>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdata">simdata</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Two groups. Treatment:place=1:2. Drop rate=3%/month. Hazard ratio=0.7.

# define the piecewiese exponential event generation function
myevent_dist_trt &lt;- function(n)rpwexp(n, rate=c(0.1, 0.01, 0.2)*0.7, breakpoint=c(5,14))
myevent_dist_con &lt;- function(n)rpwexp(n, rate=c(0.1, 0.01, 0.2), breakpoint=c(5,14))

# user defined summary function, the proportion of subjects that follow more than 12 month
prop_12 &lt;- function(x)mean(x &gt;= 12)

# estimate the event curve or timeline:
# (here rep=60 is for demo purpose only, please increase this value in practice!)
event_curve &lt;- sim_followup(at=seq(20,90,10), type = 'calendar', group = c('trt','con'),
             rand_rate = 20, total_sample = 1000, drop_rate = 0.03, allocation = 1:2,
             advanced_dist = list(event_dist=c(myevent_dist_trt, myevent_dist_con)),
             by_group = TRUE, stat = c(median, mean, prop_12), start_date = "2020-01-01",
             rep=60)
time_curve &lt;- sim_followup(at=seq(200,600,100), type = 'event', group = c('trt','con'),
             rand_rate = 20, total_sample = 1000, drop_rate = 0.03, allocation = 1:2,
             advanced_dist = list(event_dist=c(myevent_dist_trt, myevent_dist_con)),
             stat = c(median, mean, prop_12), start_date = "2020-01-01", rep=60)
# plot event curve or timeline
plot(event_curve$T_all$analysis_time_c, event_curve$T_all$event, xlab='Time',
    ylab='Number of events', type='b')
plot(time_curve$T_all$event, time_curve$T_all$analysis_time_c, xlab='Number of
    events', ylab='Time', type='b')
</code></pre>

<hr>
<h2 id='simdata'>Simulate Survival Data</h2><span id='topic+simdata'></span>

<h3>Description</h3>

<p><code>simdata</code> is used to simulate a clinical trial data with time-to-event endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdata(group="Group 1", strata="Strata 1", allocation=1,
    event_lambda=NA, drop_rate=NA, death_lambda=NA, n_rand=NULL,
    rand_rate=NULL, total_sample=NULL, add_column=c('followT'),
    simplify=TRUE, advanced_dist=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simdata_+3A_group">group</code></td>
<td>
<p>a character vector of the names of each group (e.g., <code>c('treatment','control')</code>).</p>
</td></tr>
<tr><td><code id="simdata_+3A_strata">strata</code></td>
<td>
<p>a character vector of the names of strata in groups (e.g., <code>c('young','old')</code>).</p>
</td></tr>
<tr><td><code id="simdata_+3A_allocation">allocation</code></td>
<td>
<p>the relative ratio of sample size in each subgroup (<code>group*strata</code>). See details. The value will be recycled if the length is less than needed.</p>
</td></tr>
<tr><td><code id="simdata_+3A_event_lambda">event_lambda</code></td>
<td>
<p>the hazard rate of the primary endpoint (event). See details. The value will be recycled if the length is less than needed.</p>
</td></tr>
<tr><td><code id="simdata_+3A_drop_rate">drop_rate</code></td>
<td>
<p>(optional) the drop-out rate (patients/month). Not hazard rate. See details. The value will be recycled if the length is less than needed.</p>
</td></tr>
<tr><td><code id="simdata_+3A_death_lambda">death_lambda</code></td>
<td>
<p>(optional) the hazard rate of death. The value will be recycled if the length is less than needed.</p>
</td></tr>
<tr><td><code id="simdata_+3A_n_rand">n_rand</code></td>
<td>
<p>(required when <code>rand_rate=NULL</code>) a vector of the number of randomization each month; can be non-integers.</p>
</td></tr>
<tr><td><code id="simdata_+3A_rand_rate">rand_rate</code></td>
<td>
<p>(required when <code>n_rand=NULL</code>) the randomization rate (patients/month; can be non-integer).</p>
</td></tr>
<tr><td><code id="simdata_+3A_total_sample">total_sample</code></td>
<td>
<p>(required when <code>n_rand=NULL</code>) total scheduled sample size.</p>
</td></tr>
<tr><td><code id="simdata_+3A_add_column">add_column</code></td>
<td>
<p>request additional columns of the returned data frame. <br />
Valid options are:
</p>

<ul>
<li> <p><code>'eventT_abs'</code>: absolute event time from the beginning of the trial (=eventT+randT)
</p>
</li>
<li> <p><code>'dropT_abs'</code>: absolute drop-out time from the beginning of the trial (=dropT+randT)
</p>
</li>
<li> <p><code>'deathT_abs'</code>: absolute death time from the beginning of the trial (=deathT+randT)
</p>
</li>
<li> <p><code>'censor'</code>: censoring (drop-out or death) indicator
</p>
</li>
<li> <p><code>'event'</code>: event indicator
</p>
</li>
<li> <p><code>'censor_reason'</code>: censoring reason ('drop_out','death','never_event'(eventT=inf))
</p>
</li>
<li> <p><code>'followT'</code>: follow-up time (true observed time) from randT
</p>
</li>
<li> <p><code>'followT_abs'</code>: absolute follow-up time from the beginning of the trial (=followT+randT)
</p>
</li></ul>
</td></tr>
<tr><td><code id="simdata_+3A_simplify">simplify</code></td>
<td>
<p>whether drop unused columns (e.g., the group variable when there is only one group). See details.</p>
</td></tr>
<tr><td><code id="simdata_+3A_advanced_dist">advanced_dist</code></td>
<td>
<p>use user-specified distributions for event, drop-out and death. A list containing random generation functions. See details and examples. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See webpage <a href="https://zjph602xtc.github.io/PWEXP/">https://zjph602xtc.github.io/PWEXP/</a> for a diagram illustration of the relationship between returned variables.
</p>
<p>The total number of subgroups will be '# treatment groups' * '# strata'. The <code>strata</code> variable will be distributed into each treatment group. For example, if <code>group = c('trt','placebo')</code>, <code>strata=c('A','B','C')</code>, then there will be 6 subgroups: trt+A, trt+B, trt+C, placebo+A, placebo+B, placebo+C. The lengths of <code>allocation</code>, <code>event_lambda</code>, <code>drop_rate</code>, <code>death_lambda</code> should be 6 as well. Note that the values will be recycled for these variables. For example, if <code>allocation=c(1,2,3)</code>, then the proportion of 6 subgroups is actually 1:2:3:1:2:3, which means 1:1 ratio for groups, 1:2:3 ratio in each stratum.
</p>
<p>The <code>event_lambda</code> (<code class="reqn">\lambda</code>) is the hazard rate of the interested events. The density function of events is <code class="reqn">f(t)=\lambda e^{-\lambda*t}</code>. Similarly, the <code>death_lambda</code> is the hazard rate of death.
</p>
<p>The <code>drop_rate</code> is the probability of drop-out at <code class="reqn">t=1</code>, which means the hazard rate of drop-out is <code class="reqn">-log(1-drop_rate)</code> (or say, <code>drop_rate</code>=<code class="reqn">1-e^{-hazard rate}</code>.
</p>
<p>When <code>simplify=TRUE</code>, these columns will NOT be included:
</p>

<ul>
<li> <p><code>group</code> when only one group is specified
</p>
</li>
<li> <p><code>strata</code> when only one stratum is specified
</p>
</li>
<li> <p><code>eventT</code> when <code>event_lambda=NA</code>
</p>
</li>
<li> <p><code>dropT</code> when <code>drop_rate=NA</code>
</p>
</li>
<li> <p><code>deathT</code>  when <code>death_lambda=NA</code>
</p>
</li></ul>

<p><code>advanced_dist</code> is used to define non-exponential distributions for event, drop-out or death. It is a list containing at least one of the elements: <code>event_dist</code>, <code>drop_dist</code>, <code>death_dist</code>. Each element has random generation functions for each subgroups. For example, <code>advanced_dist=list(event_dist=c(function1, function2), drop_dist=c(function3, function4))</code>. Here <code>function1</code>, <code>function3</code> are the event, drop-out generation function for the first subgroup; <code>function2</code>, <code>function4</code> for the second. If there is a third subgroup, <code>function1</code>, <code>function3</code> will be reused.
Each data generation function (<code>functionX</code>) is a function with only one input argument <code>n</code> (sample size). If any of the <code>event_dist</code>, <code>drop_dist</code>, <code>death_dist</code> is missing, then we search for <code>event_lambda</code>, <code>drop_rate</code>, <code>death_lambda</code> to generate a exp distribution; if they are also missing, then corresponding variable will not be generated
.</p>


<h3>Value</h3>

<p>A data frame containing the some of these columns:
</p>
<table role = "presentation">
<tr><td><code>ID</code></td>
<td>
<p>subject ID</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>group indicator</p>
</td></tr>
<tr><td><code>strata</code></td>
<td>
<p>stratum indicator</p>
</td></tr>
<tr><td><code>randT</code></td>
<td>
<p>randomization time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code>eventT</code></td>
<td>
<p>event time (from <code>randT</code>)</p>
</td></tr>
<tr><td><code>eventT_abs</code></td>
<td>
<p>event time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code>dropT</code></td>
<td>
<p>drop-out time (from <code>randT</code>)</p>
</td></tr>
<tr><td><code>dropT_abs</code></td>
<td>
<p>drop-out time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code>deathT</code></td>
<td>
<p>death time (from <code>randT</code>)</p>
</td></tr>
<tr><td><code>deathT_abs</code></td>
<td>
<p>death time (from the beginning of the trial)</p>
</td></tr>
<tr><td><code>censor</code></td>
<td>
<p>censoring (drop-out or death) indicator</p>
</td></tr>
<tr><td><code>censor_reason</code></td>
<td>
<p>censoring reason ('drop_out','death','never_event'(followT=inf))</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>event indicator</p>
</td></tr>
<tr><td><code>followT</code></td>
<td>
<p>follow-up time / observed time (from <code>randT</code>)</p>
</td></tr>
<tr><td><code>followT_abs</code></td>
<td>
<p>follow-up time / observed time (from the beginning of the trial)</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>event_lambda</code>, <code>drop_rate</code>, <code>death_lambda</code> can be 0, which means the corresponding subgroup will have an Inf value for each variable.
</p>


<h3>Author(s)</h3>

<p>Tianchen Xu <a href="mailto:zjph602xutianchen@gmail.com">zjph602xutianchen@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpwexp">rpwexp</a></code>,
<code><a href="#topic+rpwexp_conditional">rpwexp_conditional</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two groups with two strata. In the treatment group, there is a treatment
# sensitive stratum and a non-sensitive stratum. In the placebo group, all
# subjects are the same. Treatment:place=1:2. Drop rate=1% only in treatment group.
dat &lt;- simdata(group=c('trt', 'place'), strata = c('sensitive','non-sensitive'),
               allocation = c(1,1,2,2), rand_rate = 20, total_sample = 1000,
               event_lambda = c(0.1, 0.2, 0.01, 0.01),
               drop_rate = c(0.01, 0.01, 0, 0))
# randomized subjects
table(dat$group,dat$strata)
# randomization curve
plot(sort(dat$randT), 1:1000, xlab='time', ylab='randomized subjects')
# event time in treatment group
plot(ecdf(dat$eventT[dat$group=='trt' &amp; dat$strata=='sensitive']))
lines(ecdf(dat$eventT[dat$group=='trt' &amp; dat$strata=='non-sensitive']), col='red')


# One group. Event follows a piecewise exponential distribution; drop-out follows
# a Weibull; death follows a exponential.
dist_trt &lt;- function(n)rpwexp(n, rate=c(0.01, 0.05, 0.01), breakpoint = c(30,60))
dist_placebo &lt;- function(n)rpwexp(n, rate=c(0.01, 0.005), breakpoint = c(50))
dat &lt;- simdata(group = c('trt','placebo'), n_rand = c(rep(10,50),rep(20,10)),
               death_lambda = 0.01,
               advanced_dist = list(event_dist=c(dist_trt, dist_placebo),
                                    drop_dist=function(n)rweibull(n,3,40)))
# randomized subjects
table(dat$group)
# randomization curve
plot(sort(dat$randT), 1:700, xlab='time', ylab='randomized subjects')
# event time in both groups
plot(ecdf(dat$eventT[dat$group=='trt']), xlim=c(0,100))
lines(ecdf(dat$eventT[dat$group=='placebo']), col='red')
# drop-out time
plot(ecdf(dat$dropT), xlim=c(0,100))


# mixture cure distribution, 20% of the subject are cured and will not have events
dat &lt;- simdata(strata=c('cure','non-cure'), allocation=c(20,80),
        event_lambda=c(0, 0.38), n_rand = rep(20,30),
        add_column = c('eventT_abs', 'censor', 'event',
                       'censor_reason', 'followT', 'followT_abs'))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
