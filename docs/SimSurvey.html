<!DOCTYPE html><html><head><title>Help for package SimSurvey</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimSurvey}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.Q'><p>Helper function to generate precision matrix Q for simulation</p></a></li>
<li><a href='#bathy'><p>Southern Newfoundland bathymetry</p></a></li>
<li><a href='#convert_N'><p>Convert abundance-at-age matrix to abundance-at-length</p></a></li>
<li><a href='#error_stats'><p>Calculate common error statistics</p></a></li>
<li><a href='#expand_surveys'><p>Set-up a series of surveys from all combinations of settings supplied</p></a></li>
<li><a href='#fibonacci'><p>Generate Fibonacci sequence</p></a></li>
<li><a href='#group_lengths'><p>Convert length to length group</p></a></li>
<li><a href='#icc'><p>Calculate intraclass correlation</p></a></li>
<li><a href='#land'><p>Southern Newfoundland coastline</p></a></li>
<li><a href='#make_grid'><p>Make a depth stratified survey grid</p></a></li>
<li><a href='#make_mesh'><p>Make an R-INLA mesh based off a grid</p></a></li>
<li><a href='#object_size'><p>Print object size</p></a></li>
<li><a href='#plot_trend'><p>Simple plotting functions</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#round_sim'><p>Round simulated population</p></a></li>
<li><a href='#run_strat'><p>Run stratified analysis on simulated data</p></a></li>
<li><a href='#sim_abundance'><p>Simulate basic population dynamics model</p></a></li>
<li><a href='#sim_ays_covar'><p>Simulate age-year-space covariance</p></a></li>
<li><a href='#sim_ays_covar_spde'><p>Simulate age-year-space covariance using SPDE approach</p></a></li>
<li><a href='#sim_distribution'><p>Simulate spatial and temporal distribution</p></a></li>
<li><a href='#sim_logistic'><p>Closure for simulating logistic curve</p></a></li>
<li><a href='#sim_nlf'><p>Define a non-linear relationship</p></a></li>
<li><a href='#sim_parabola'><p>Define a parabolic relationship</p></a></li>
<li><a href='#sim_R'><p>Simulate starting abundance, random recruitment and total mortality</p></a></li>
<li><a href='#sim_sets'><p>Simulate survey sets</p></a></li>
<li><a href='#sim_survey'><p>Simulate stratified-random survey</p></a></li>
<li><a href='#sim_survey_parallel'><p>Simulate stratified random surveys using parallel computation</p></a></li>
<li><a href='#sim_vonB'><p>Closure for simulating length given age using von Bertalanffy notation</p></a></li>
<li><a href='#strat_data'><p>Prepare simulated data for stratified analysis</p></a></li>
<li><a href='#strat_error'><p>Calculate error of stratified estimates</p></a></li>
<li><a href='#strat_means'><p>Calculate stratified means, variances and confidence intervals across groups</p></a></li>
<li><a href='#survey_grid'><p>Sample survey simulation grid.</p></a></li>
<li><a href='#survey_lite_mesh'><p>Lite sample survey mesh and related items</p></a></li>
<li><a href='#survey_mesh'><p>Sample survey meshes and related items</p></a></li>
<li><a href='#test_surveys'><p>Test sampling design of multiple surveys using a stratified analysis</p></a></li>
<li><a href='#vis_sim'><p>Make a flexdashboard for visualizing the simulation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Test Surveys by Simulating Spatially-Correlated Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Regular &lt;Paul.Regular@dfo-mpo.gc.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulate age-structured populations that vary in space and time and 
    explore the efficacy of a range of built-in or user-defined sampling 
    protocols to reproduce the population parameters of the known population. 
    (See Regular et al. (2020) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0232822">doi:10.1371/journal.pone.0232822</a>&gt; for more
    details).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/stable/">https://inla.r-inla-download.org/R/stable/</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paulregular.github.io/SimSurvey/">https://paulregular.github.io/SimSurvey/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PaulRegular/SimSurvey/issues">https://github.com/PaulRegular/SimSurvey/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, stars, data.table, magrittr, progress, doParallel,
parallel, foreach, plotly, rlang, lifecycle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fields, rmarkdown, flexdashboard, shiny, crosstalk,
htmltools, viridis, lme4, ggplot2, INLA, INLAspacetime, knitr,
bezier</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-18 20:13:17 UTC; RegularP</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Regular <a href="https://orcid.org/0000-0003-0318-2615"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jonathan Babyn [ctb],
  Greg Robertson [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-19 10:50:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='.Q'>Helper function to generate precision matrix Q for simulation</h2><span id='topic+.Q'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This creates the precision matrix from a mesh created by R-INLA with a
specified range. This is currently set up to support the standard spde
approach of precision matrices and the barrier model version. Similar
in purpose to .sp_covar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.Q(
  mesh,
  barrier.triangles,
  range = 50,
  range_fraction = 0.2,
  sigma_u = 1,
  model = "spde"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".Q_+3A_mesh">mesh</code></td>
<td>
<p>The mesh created by R-INLA representing spatial area</p>
</td></tr>
<tr><td><code id=".Q_+3A_barrier.triangles">barrier.triangles</code></td>
<td>
<p>the list of triangles of the mesh in the barrier, only used for barrier model</p>
</td></tr>
<tr><td><code id=".Q_+3A_range">range</code></td>
<td>
<p>decorrelation range</p>
</td></tr>
<tr><td><code id=".Q_+3A_range_fraction">range_fraction</code></td>
<td>
<p>the fraction that sets the range over the &quot;land&quot;
parts of the barrier model. Only used with the barrier model</p>
</td></tr>
<tr><td><code id=".Q_+3A_sigma_u">sigma_u</code></td>
<td>
<p>the overall variance of the spatial process</p>
</td></tr>
<tr><td><code id=".Q_+3A_model">model</code></td>
<td>
<p>'spde' for the SPDE approach, 'barrier' for barrier approach</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Q a sparse precision matrix of type dgTMatrix
</p>

<hr>
<h2 id='bathy'>Southern Newfoundland bathymetry</h2><span id='topic+bathy'></span>

<h3>Description</h3>

<p>Southern Newfoundland bathymetry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bathy
</code></pre>


<h3>Format</h3>

<p>A stars object
</p>
<p>Derived from data downloaded from http://www.gebco.net/. Details provided in
the data-raw folder for this package.
</p>

<hr>
<h2 id='convert_N'>Convert abundance-at-age matrix to abundance-at-length</h2><span id='topic+convert_N'></span>

<h3>Description</h3>

<p>Function for converting abundance-at-age matrix to abundance-at-length given
a length-age-key. Expects matrices to be named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_N(N_at_age = NULL, lak = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_N_+3A_n_at_age">N_at_age</code></td>
<td>
<p>Abundance-at-age matrix</p>
</td></tr>
<tr><td><code id="convert_N_+3A_lak">lak</code></td>
<td>
<p>Length-age-key (i.e. probability of being in a specific length group given age)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns abundance-at-length matrix.
</p>

<hr>
<h2 id='error_stats'>Calculate common error statistics</h2><span id='topic+error_stats'></span>

<h3>Description</h3>

<p>Calculate common error statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error_stats(error)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error_stats_+3A_error">error</code></td>
<td>
<p>Vector of errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named vector of error statistics including
mean error (<code>"ME"</code>),
mean absolute error (<code>"MAE"</code>),
mean squared error (<code>"MSE"</code>) and
root mean squared error (<code>"RMSE"</code>)
</p>

<hr>
<h2 id='expand_surveys'>Set-up a series of surveys from all combinations of settings supplied</h2><span id='topic+expand_surveys'></span>

<h3>Description</h3>

<p>Function is simply a wrapper for <code><a href="base.html#topic+expand.grid">expand.grid</a></code> that
adds a survey number to the returned object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_surveys(
  set_den = c(0.5, 1, 2, 5, 10)/1000,
  lengths_cap = c(5, 10, 20, 50, 100, 500, 1000),
  ages_cap = c(2, 5, 10, 20, 50)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_surveys_+3A_set_den">set_den</code></td>
<td>
<p>Vector of set densities (number of sets per grid unit squared)</p>
</td></tr>
<tr><td><code id="expand_surveys_+3A_lengths_cap">lengths_cap</code></td>
<td>
<p>Vector of maximum number of lengths measured per set</p>
</td></tr>
<tr><td><code id="expand_surveys_+3A_ages_cap">ages_cap</code></td>
<td>
<p>Vector of maximum number of otoliths to collect per length group
per division per year</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.frame including all combinations of the supplied vectors.
</p>

<hr>
<h2 id='fibonacci'>Generate Fibonacci sequence</h2><span id='topic+fibonacci'></span>

<h3>Description</h3>

<p>Generate Fibonacci sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fibonacci(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fibonacci_+3A_from">from</code>, <code id="fibonacci_+3A_to">to</code></td>
<td>
<p>Approximate start and end values of the sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a Fibonacci sequence as a vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fibonacci(2, 200)

</code></pre>

<hr>
<h2 id='group_lengths'>Convert length to length group</h2><span id='topic+group_lengths'></span>

<h3>Description</h3>

<p>Helper function for converting lengths to length groups
(Note: this isn't a general function; the output midpoints defining the
groups aligns with DFO specific method/labeling)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_lengths(length, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_lengths_+3A_length">length</code></td>
<td>
<p>Interval from <code><a href="base.html#topic+findInterval">findInterval</a></code></p>
</td></tr>
<tr><td><code id="group_lengths_+3A_group">group</code></td>
<td>
<p>Length group used to cut the length data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector indicating the mid-point of the length group.
</p>

<hr>
<h2 id='icc'>Calculate intraclass correlation</h2><span id='topic+icc'></span>

<h3>Description</h3>

<p>This is a simple function for calculating intraclass correlation. It uses
<code><a href="lme4.html#topic+lmer">lmer</a></code> to run the formula described here:
https://en.wikipedia.org/wiki/Intraclass_correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icc(x, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icc_+3A_x">x</code></td>
<td>
<p>Response variable</p>
</td></tr>
<tr><td><code id="icc_+3A_group">group</code></td>
<td>
<p>Group</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns estimate of intraclass correlation.
</p>

<hr>
<h2 id='land'>Southern Newfoundland coastline</h2><span id='topic+land'></span>

<h3>Description</h3>

<p>Southern Newfoundland coastline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>land
</code></pre>


<h3>Format</h3>

<p>A sf object (MULTIPOLYGON)
</p>
<p>Derived from global administrative boundaries data (http://gadm.org/) downloaded
using the <code><a href="nlme.html#topic+getData">getData</a></code> function. Details provided in the
data-raw folder for this package.
</p>

<hr>
<h2 id='make_grid'>Make a depth stratified survey grid</h2><span id='topic+make_grid'></span>

<h3>Description</h3>

<p>This function sets up a depth stratified survey grid. A simple gradient in depth
is simulated using <code><a href="stats.html#topic+splinefun">stats::spline</a></code> (default) with a shallow portion, shelf and
deep portion. Adding covariance to the depth simulation is an option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_grid(
  x_range = c(-140, 140),
  y_range = c(-140, 140),
  res = c(3.5, 3.5),
  shelf_depth = 200,
  shelf_width = 100,
  depth_range = c(0, 1000),
  n_div = 1,
  strat_breaks = seq(0, 1000, by = 40),
  strat_splits = 2,
  method = "spline"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_grid_+3A_x_range">x_range</code></td>
<td>
<p>Range (min x, max x) in x dimension in km</p>
</td></tr>
<tr><td><code id="make_grid_+3A_y_range">y_range</code></td>
<td>
<p>Range (min y, max y) in y dimension in km</p>
</td></tr>
<tr><td><code id="make_grid_+3A_res">res</code></td>
<td>
<p>Resolution, in km, of the grid cells</p>
</td></tr>
<tr><td><code id="make_grid_+3A_shelf_depth">shelf_depth</code></td>
<td>
<p>Approximate depth of the shelf in m</p>
</td></tr>
<tr><td><code id="make_grid_+3A_shelf_width">shelf_width</code></td>
<td>
<p>Approximate width of the shelf in km</p>
</td></tr>
<tr><td><code id="make_grid_+3A_depth_range">depth_range</code></td>
<td>
<p>Range (min depth, max depth) in depth in m</p>
</td></tr>
<tr><td><code id="make_grid_+3A_n_div">n_div</code></td>
<td>
<p>Number of divisions to include</p>
</td></tr>
<tr><td><code id="make_grid_+3A_strat_breaks">strat_breaks</code></td>
<td>
<p>Define strata given these depth breaks</p>
</td></tr>
<tr><td><code id="make_grid_+3A_strat_splits">strat_splits</code></td>
<td>
<p>Number of times to horizontally split strat (i.e. easy way to increase the number of strata)</p>
</td></tr>
<tr><td><code id="make_grid_+3A_method">method</code></td>
<td>
<p>Use a &quot;spline&quot;, &quot;loess&quot; or &quot;bezier&quot; to generate a smooth gradient or simply use &quot;linear&quot; interpolation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a stars object with 2 dimensions (x and y) and 4 attributes (depth, cell, division, strat).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survey_grid">survey_grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- make_grid(res = c(10, 10))
plot(r)

p &lt;- sf::st_as_sf(r["strat"], as_points = FALSE, merge = TRUE)
plot(p)

</code></pre>

<hr>
<h2 id='make_mesh'>Make an R-INLA mesh based off a grid</h2><span id='topic+make_mesh'></span>

<h3>Description</h3>

<p>This will make a mesh based off a given grid. Ideally the mesh
construction and validation should be done by hand, but this exists
for convenience. Meshes are used for sim_ays_covar_spde. The defaults
are designed for the default grid. Just a basic interface between the grid and inla.mesh.2d.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mesh(
  grid = make_grid(),
  max.edge = 50,
  bound.outer = 150,
  cutoff = 10,
  offset = c(max.edge, bound.outer),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mesh_+3A_grid">grid</code></td>
<td>
<p>grid object to make a mesh of</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_max.edge">max.edge</code></td>
<td>
<p>The largest allowed triangle edge length. One or two values. This is passed to inla.mesh.2d</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_bound.outer">bound.outer</code></td>
<td>
<p>The optional outer extension value given to offset.</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_cutoff">cutoff</code></td>
<td>
<p>Minimum distance allowed between points</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_offset">offset</code></td>
<td>
<p>The automatic extension distance given to inla.mesh.2d</p>
</td></tr>
<tr><td><code id="make_mesh_+3A_...">...</code></td>
<td>
<p>Other options to pass to inla.mesh.2d</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>inla.mesh</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if (requireNamespace("INLA")) {
  basic_mesh &lt;- make_mesh()
  plot(basic_mesh)
}



</code></pre>

<hr>
<h2 id='object_size'>Print object size</h2><span id='topic+object_size'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="utils.html#topic+object.size">object.size</a></code> that prints in Mb
by default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>object_size(x, units = "Mb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="object_size_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object</p>
</td></tr>
<tr><td><code id="object_size_+3A_units">units</code></td>
<td>
<p>the units to be used in printing the size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a character with the object size followed by the unit.
</p>

<hr>
<h2 id='plot_trend'>Simple plotting functions</h2><span id='topic+plot_trend'></span><span id='topic+plot_surface'></span><span id='topic+plot_grid'></span><span id='topic+plot_distribution'></span><span id='topic+plot_survey'></span><span id='topic+plot_total_strat_fan'></span><span id='topic+plot_length_strat_fan'></span><span id='topic+plot_age_strat_fan'></span><span id='topic+plot_error_surface'></span><span id='topic+plot_survey_rank'></span>

<h3>Description</h3>

<p>These functions are simple plotting helpers to get some quick
visuals of values produced by <code><a href="#topic+sim_abundance">sim_abundance</a></code>,
<code><a href="#topic+sim_distribution">sim_distribution</a></code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trend(sim, sum_ages = sim$ages, col = viridis::viridis(1), ...)

plot_surface(sim, mat = "N", xlab = "Age", ylab = "Year", zlab = mat, ...)

plot_grid(grid, ...)

plot_distribution(
  sim,
  ages = sim$ages,
  years = sim$years,
  type = "contour",
  scale = "natural",
  ...
)

plot_survey(sim, which_year = 1, which_sim = 1)

plot_total_strat_fan(sim, surveys = 1:5, quants = seq(90, 10, by = -10), ...)

plot_length_strat_fan(
  sim,
  surveys = 1:5,
  years = 1:10,
  lengths = 1:50,
  select_by = "year",
  quants = seq(90, 10, by = -10),
  ...
)

plot_age_strat_fan(
  sim,
  surveys = 1:5,
  years = 1:10,
  ages = 1:10,
  select_by = "year",
  quants = seq(90, 10, by = -10),
  ...
)

plot_error_surface(sim, plot_by = "rule")

plot_survey_rank(sim, which_strat = "age")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_trend_+3A_sim">sim</code></td>
<td>
<p>Object returned by <code><a href="#topic+sim_abundance">sim_abundance</a></code>,
<code><a href="#topic+sim_distribution">sim_distribution</a></code>, etc.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_sum_ages">sum_ages</code></td>
<td>
<p>Sum across these ages</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_col">col</code></td>
<td>
<p>Plot color</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="plotly.html#topic+plot_ly">plot_ly</a></code>.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_mat">mat</code></td>
<td>
<p>Name of matrix in <code>sim</code> list to plot.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_xlab">xlab</code>, <code id="plot_trend_+3A_ylab">ylab</code>, <code id="plot_trend_+3A_zlab">zlab</code></td>
<td>
<p>Axes labels.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_grid">grid</code></td>
<td>
<p>Grid produced by <code><a href="#topic+make_grid">make_grid</a></code>.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_ages">ages</code></td>
<td>
<p>Subset data to one or more ages.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_years">years</code></td>
<td>
<p>Subset data to one or more years.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_type">type</code></td>
<td>
<p>Plot type: &quot;contour&quot; or &quot;heatmap&quot;.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_scale">scale</code></td>
<td>
<p>Plot response on &quot;natural&quot; or &quot;log&quot; scale?</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_which_year">which_year</code></td>
<td>
<p>Subset to specific year</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_which_sim">which_sim</code></td>
<td>
<p>Subset to specific sim</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_surveys">surveys</code></td>
<td>
<p>Subset data to one or more surveys.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_quants">quants</code></td>
<td>
<p>Quantile intervals to display on fan plot</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_lengths">lengths</code></td>
<td>
<p>Subset data to one or more length groups.</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_select_by">select_by</code></td>
<td>
<p>Select plot by &quot;age&quot;, &quot;length&quot; or &quot;year&quot;?</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_plot_by">plot_by</code></td>
<td>
<p>Plot error surface by &quot;rule&quot; or &quot;samples&quot;?</p>
</td></tr>
<tr><td><code id="plot_trend_+3A_which_strat">which_strat</code></td>
<td>
<p>Which strat values to focus on? (total, length, or age)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot of class <code>plotly</code>.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='round_sim'>Round simulated population</h2><span id='topic+round_sim'></span>

<h3>Description</h3>

<p>Round simulated population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_sim(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_sim_+3A_sim">sim</code></td>
<td>
<p>Simulation from <code><a href="#topic+sim_distribution">sim_distribution</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a rounded simulation object. Largely used as a helper in <code><a href="#topic+sim_survey">sim_survey</a></code>.
</p>

<hr>
<h2 id='run_strat'>Run stratified analysis on simulated data</h2><span id='topic+run_strat'></span>

<h3>Description</h3>

<p>Run stratified analysis on simulated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_strat(
  sim,
  length_group = "inherit",
  alk_scale = "division",
  strat_data_fun = strat_data,
  strat_means_fun = strat_means
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_strat_+3A_sim">sim</code></td>
<td>
<p>Simulation from <code><a href="#topic+sim_survey">sim_survey</a></code></p>
</td></tr>
<tr><td><code id="run_strat_+3A_length_group">length_group</code></td>
<td>
<p>Size of the length frequency bins for both abundance at length calculations
and age-length-key construction. By default this value is inherited from
the value defined in <code><a href="#topic+sim_abundance">sim_abundance</a></code> from the closure supplied to
<code>sim_length</code> (&quot;inherit&quot;). A numeric value can also be supplied, however,
a mismatch in length groupings will cause issues with <code><a href="#topic+strat_error">strat_error</a></code>
as true vs. estimated length groupings will be mismatched.</p>
</td></tr>
<tr><td><code id="run_strat_+3A_alk_scale">alk_scale</code></td>
<td>
<p>Spatial scale at which to construct and apply age-length-keys:
&quot;division&quot; or &quot;strat&quot;.</p>
</td></tr>
<tr><td><code id="run_strat_+3A_strat_data_fun">strat_data_fun</code></td>
<td>
<p>Function for preparing data for stratified analysis (e.g. <code><a href="#topic+strat_data">strat_data</a></code>)</p>
</td></tr>
<tr><td><code id="run_strat_+3A_strat_means_fun">strat_means_fun</code></td>
<td>
<p>Function for calculating stratified means (e.g. <code><a href="#topic+strat_means">strat_means</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"strat_data_fun"</code> and <code>"strat_means_fun"</code> allow the use of custom
<code><a href="#topic+strat_data">strat_data</a></code> and  <code><a href="#topic+strat_means">strat_means</a></code> functions.
</p>


<h3>Value</h3>

<p>Adds stratified analysis results for the total population (<code>"total_strat"</code>)
and the population aggregated by length group and age (<code>"length_strat"</code> and
<code>"age_strat"</code>, respectively) to the <code>sim</code> list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

sim &lt;- sim_abundance(ages = 1:5, years = 1:5,
                     R = sim_R(log_mean = log(1e+7)),
                     growth = sim_vonB(length_group = 1)) %&gt;%
           sim_distribution(grid = make_grid(res = c(20, 20)),
                            ays_covar = sim_ays_covar(sd = 1)) %&gt;%
           sim_survey(n_sims = 1, q = sim_logistic(k = 2, x0 = 3)) %&gt;%
           run_strat()


</code></pre>

<hr>
<h2 id='sim_abundance'>Simulate basic population dynamics model</h2><span id='topic+sim_abundance'></span>

<h3>Description</h3>

<p>Simulate basic population dynamics model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_abundance(
  ages = 1:20,
  years = 1:20,
  Z = sim_Z(),
  R = sim_R(),
  N0 = sim_N0(),
  growth = sim_vonB()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_abundance_+3A_ages">ages</code></td>
<td>
<p>Ages to include in the simulation.</p>
</td></tr>
<tr><td><code id="sim_abundance_+3A_years">years</code></td>
<td>
<p>Years to include in the simulation.</p>
</td></tr>
<tr><td><code id="sim_abundance_+3A_z">Z</code></td>
<td>
<p>Total mortality function, like <code><a href="#topic+sim_Z">sim_Z</a></code>, for generating
mortality matrix.</p>
</td></tr>
<tr><td><code id="sim_abundance_+3A_r">R</code></td>
<td>
<p>Recruitment (i.e. abundance at <code>min(ages)</code>) function, like
<code><a href="#topic+sim_R">sim_R</a></code>, for generating recruitment vector.</p>
</td></tr>
<tr><td><code id="sim_abundance_+3A_n0">N0</code></td>
<td>
<p>Starting abundance (i.e. abundance at <code>min(years)</code>) function, like
<code><a href="#topic+sim_N0">sim_N0</a></code>, for generating starting abundance vector.</p>
</td></tr>
<tr><td><code id="sim_abundance_+3A_growth">growth</code></td>
<td>
<p>Closure, such as <code><a href="#topic+sim_vonB">sim_vonB</a></code>, for simulating length given age.
The function is used here to generate a abundance-at-age matrix and
it is carried forward for later use in <code><a href="#topic+sim_survey">sim_survey</a></code> to simulate
lengths from survey catch at age.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Abundance from is calculated using a standard population dynamics model.
An abundance-at-length matrix is generated using a growth function coded as a closure like
<code><a href="#topic+sim_vonB">sim_vonB</a></code>. The function is retained for later use in <code><a href="#topic+sim_survey">sim_survey</a></code>
to simulate lengths given simulated catch at age in a simulated survey. The ability to simulate
distributions by length is yet to be implemented.
</p>


<h3>Value</h3>

<p>A <code>list</code> of length 9:
</p>

<ul>
<li><p><code>ages</code> - Vector of ages in the simulation
</p>
</li>
<li><p><code>lengths</code> - Vector of length groups (depends on growth function)
</p>
</li>
<li><p><code>years</code> - Vector of years in the simulation
</p>
</li>
<li><p><code>R</code> - Vector of recruitment values
</p>
</li>
<li><p><code>N0</code> - Vector of starting abundance values
</p>
</li>
<li><p><code>Z</code> - Matrix of total mortality values
</p>
</li>
<li><p><code>N</code> - Matrix of abundance values
</p>
</li>
<li><p><code>N_at_length</code> - Abundance at length matrix
</p>
</li>
<li><p><code>sim_length</code> - Function for simulating lengths given ages
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
R_fun &lt;- sim_R(log_mean = log(100000), log_sd = 0.1, random_walk = TRUE, plot = TRUE)
R_fun(years = 1:100)
sim_abundance(R = sim_R(log_mean = log(100000), log_sd = 0.5))
sim_abundance(years = 1:20,
              R = sim_R(log_mean = log(c(rep(100000, 10), rep(10000, 10))), plot = TRUE))

Z_fun &lt;- sim_Z(log_mean = log(0.5), log_sd = 0.1, phi_age = 0.9, phi_year = 0.9, plot = TRUE)
Z_fun(years = 1:100, ages = 1:20)
sim_abundance(Z = sim_Z(log_mean = log(0.5), log_sd = 0.1, plot = TRUE))
Za_dev &lt;- c(-0.2, -0.1, 0, 0.1, 0.2, 0.3, 0.3, 0.2, 0.1, 0)
Zy_dev &lt;- c(-0.2, -0.2, -0.2, -0.2, -0.2, 2, 2, 2, 2, 0.2, 0.2, 0.2, 0.2, 0.2, 0, 0, 0, 0, 0, 0)
Z_mat &lt;- outer(Za_dev, Zy_dev, "+") + 0.5
sim_abundance(ages = 1:10, years = 1:20,
              Z = sim_Z(log_mean = log(Z_mat), plot = TRUE))
sim_abundance(ages = 1:10, years = 1:20,
              Z = sim_Z(log_mean = log(Z_mat), log_sd = 0, phi_age = 0, phi_year = 0, plot = TRUE))

N0_fun &lt;- sim_N0(N0 = "exp", plot = TRUE)
N0_fun(R0 = 1000, Z0 = rep(0.5, 20), ages = 1:20)
sim_abundance(N0 = sim_N0(N0 = "exp", plot = TRUE))

growth_fun &lt;- sim_vonB(Linf = 100, L0 = 5, K = 0.2, log_sd = 0.05, length_group = 1, plot = TRUE)
growth_fun(age = rep(1:15, each = 100))
growth_fun(age = 1:15, length_age_key = TRUE)
sim_abundance(growth = sim_vonB(plot = TRUE))

sim &lt;- sim_abundance()
plot_trend(sim)
plot_surface(sim, mat = "N")
plot_surface(sim, mat = "Z")
plot_surface(sim, mat = "N_at_length", xlab = "Length", zlab = "N")

</code></pre>

<hr>
<h2 id='sim_ays_covar'>Simulate age-year-space covariance</h2><span id='topic+sim_ays_covar'></span>

<h3>Description</h3>

<p>These functions return a function to use inside <code><a href="#topic+sim_distribution">sim_distribution</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ays_covar(
  sd = 2.8,
  range = 300,
  lambda = 1,
  model = "matern",
  phi_age = 0.5,
  phi_year = 0.9,
  group_ages = 5:20,
  group_years = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_ays_covar_+3A_sd">sd</code></td>
<td>
<p>Variance (can be age specific).</p>
</td></tr>
<tr><td><code id="sim_ays_covar_+3A_range">range</code></td>
<td>
<p>Decorrelation range</p>
</td></tr>
<tr><td><code id="sim_ays_covar_+3A_lambda">lambda</code></td>
<td>
<p>Controls the degree of smoothness of Matern covariance process</p>
</td></tr>
<tr><td><code id="sim_ays_covar_+3A_model">model</code></td>
<td>
<p>String indicating either &quot;exponential&quot; or &quot;matern&quot; as the correlation function</p>
</td></tr>
<tr><td><code id="sim_ays_covar_+3A_phi_age">phi_age</code></td>
<td>
<p>Defines autocorrelation through ages. Can be one value or a vector of the same
length as ages</p>
</td></tr>
<tr><td><code id="sim_ays_covar_+3A_phi_year">phi_year</code></td>
<td>
<p>Defines autocorrelation through years. Can be one value or a vector of the same
length as years</p>
</td></tr>
<tr><td><code id="sim_ays_covar_+3A_group_ages">group_ages</code></td>
<td>
<p>Make space-age-year noise equal across these ages</p>
</td></tr>
<tr><td><code id="sim_ays_covar_+3A_group_years">group_years</code></td>
<td>
<p>Make space-age-year noise equal across these years</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function for use inside <code><a href="#topic+sim_distribution">sim_distribution</a></code>.
</p>

<hr>
<h2 id='sim_ays_covar_spde'>Simulate age-year-space covariance using SPDE approach</h2><span id='topic+sim_ays_covar_spde'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Returns a function to use inside <code><a href="#topic+sim_distribution">sim_distribution</a></code> to
generate the error term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_ays_covar_spde(
  sd = 2.8,
  range = 300,
  model = "spde",
  phi_age = 0.5,
  phi_year = 0.9,
  group_ages = 5:20,
  group_years = NULL,
  mesh,
  barrier.triangles
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_ays_covar_spde_+3A_sd">sd</code></td>
<td>
<p>Variance (can be age specific)</p>
</td></tr>
<tr><td><code id="sim_ays_covar_spde_+3A_range">range</code></td>
<td>
<p>Decorrelation range</p>
</td></tr>
<tr><td><code id="sim_ays_covar_spde_+3A_model">model</code></td>
<td>
<p>String indicating &quot;barrier&quot; or &quot;spde&quot; to generate Q with</p>
</td></tr>
<tr><td><code id="sim_ays_covar_spde_+3A_phi_age">phi_age</code></td>
<td>
<p>Defines autocorrelation through ages. Can be one value or
a vector of the same length as ages.</p>
</td></tr>
<tr><td><code id="sim_ays_covar_spde_+3A_phi_year">phi_year</code></td>
<td>
<p>Defines autocorrelation through years. Can be one value
or a vector of the same length as years.</p>
</td></tr>
<tr><td><code id="sim_ays_covar_spde_+3A_group_ages">group_ages</code></td>
<td>
<p>Make space-age-year variance equal across these ages</p>
</td></tr>
<tr><td><code id="sim_ays_covar_spde_+3A_group_years">group_years</code></td>
<td>
<p>Make space-age-year variance equal across these years</p>
</td></tr>
<tr><td><code id="sim_ays_covar_spde_+3A_mesh">mesh</code></td>
<td>
<p>The mesh used to generate the precision matrix</p>
</td></tr>
<tr><td><code id="sim_ays_covar_spde_+3A_barrier.triangles">barrier.triangles</code></td>
<td>
<p>the set of triangles in the barrier of the mesh
for the barrier model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function for use in <code><a href="#topic+sim_distribution">sim_distribution</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if (requireNamespace("INLA")) {

  ## Make a grid
  my_grid &lt;- make_grid(res = c(10,10))

  ## Make a mesh based off it

  my_mesh &lt;- make_mesh(my_grid)
  sim &lt;- sim_abundance(ages = 1:10, years = 1:10) %&gt;%
          sim_distribution(grid = my_grid,
                           ays_covar = sim_ays_covar_spde(phi_age = 0.8,
                                                          phi_year = 0.1,
                                                          model = "spde",
                                                          mesh = my_mesh),
                           depth_par = sim_parabola(mu = 200,
                                                    sigma = 50))
  plot_distribution(sim, ages = 1:5, years = 1:5, type = "heatmap")

}



</code></pre>

<hr>
<h2 id='sim_distribution'>Simulate spatial and temporal distribution</h2><span id='topic+sim_distribution'></span>

<h3>Description</h3>

<p>Provided an abundance at age matrix and a survey grid to populate, this function
applies correlated space, age and year error to simulate the distribution
of the population. The ability to simulate distributions by length is yet to be implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_distribution(
  sim,
  grid = make_grid(),
  ays_covar = sim_ays_covar(),
  depth_par = sim_parabola()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_distribution_+3A_sim">sim</code></td>
<td>
<p>A list with ages, years and an abundance at age matrix like
produced by <code><a href="#topic+sim_abundance">sim_abundance</a></code>.</p>
</td></tr>
<tr><td><code id="sim_distribution_+3A_grid">grid</code></td>
<td>
<p>A stars object defining the survey grid, like <code><a href="#topic+survey_grid">survey_grid</a></code>
or one produced by <code><a href="#topic+make_grid">make_grid</a></code></p>
</td></tr>
<tr><td><code id="sim_distribution_+3A_ays_covar">ays_covar</code></td>
<td>
<p>Closure for simulating age-year-space covariance,
like <code><a href="#topic+sim_ays_covar">sim_ays_covar</a></code></p>
</td></tr>
<tr><td><code id="sim_distribution_+3A_depth_par">depth_par</code></td>
<td>
<p>Closure for defining relationship between abundance and depth,
like <code><a href="#topic+sim_parabola">sim_parabola</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the probability of simulated fish inhabiting
a cell as a function of a parabolic relationship with depth and space, age,
and year autocorrelated errors. WARNING: it make take a long time to simulate
abundance in a large grid across many ages and years - start small first.
</p>


<h3>Value</h3>

<p>Appends three objects to the <code>sim</code> list:
</p>

<ul>
<li><p><code>grid</code> - A stars object with the grid details
</p>
</li>
<li><p><code>grid_xy</code> - Grid details as a data.table in xyz format
</p>
</li>
<li><p><code>sp_N</code> - A data.table with abundance split by age, year and cell
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

sim &lt;- sim_abundance(ages = 1:5, years = 1:5) %&gt;%
           sim_distribution(grid = make_grid(res = c(20, 20)),
                            ays_covar = sim_ays_covar(phi_age = 0.8,
                                                      phi_year = 0.1),
                            depth_par = sim_parabola(mu = 200,
                                                     sigma = 50))
head(sim$sp_N)
head(sim$grid_xy)


</code></pre>

<hr>
<h2 id='sim_logistic'>Closure for simulating logistic curve</h2><span id='topic+sim_logistic'></span>

<h3>Description</h3>

<p>This closure is useful for simulating q inside the
<code><a href="#topic+sim_survey">sim_survey</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_logistic(k = 2, x0 = 3, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_logistic_+3A_k">k</code></td>
<td>
<p>The steepness of the curve</p>
</td></tr>
<tr><td><code id="sim_logistic_+3A_x0">x0</code></td>
<td>
<p>The x-value of the sigmoid's midpoint</p>
</td></tr>
<tr><td><code id="sim_logistic_+3A_plot">plot</code></td>
<td>
<p>Plot relationship</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function for use in <code><a href="#topic+sim_survey">sim_survey</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logistic_fun &lt;- sim_logistic(k = 2, x0 = 3, plot = TRUE)
logistic_fun(x = 1:10)

</code></pre>

<hr>
<h2 id='sim_nlf'>Define a non-linear relationship</h2><span id='topic+sim_nlf'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Closure to be used in <code><a href="#topic+sim_distribution">sim_distribution</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_nlf(
  formula = ~alpha - ((depth - mu)^2)/(2 * sigma^2),
  coeff = list(alpha = 0, mu = 200, sigma = 70)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_nlf_+3A_formula">formula</code></td>
<td>
<p>Formula describing parametric relationships between data and coefficients.
The data used in <code><a href="#topic+sim_distribution">sim_distribution</a></code> are grid coordinates expanded
across ages and years (i.e., includes columns <code>"x", "y", "depth", "cell",
                "division", "strat", "age", "year"</code>). Values of the coefficients must be
included in argument <code>coeff</code> as a named list.</p>
</td></tr>
<tr><td><code id="sim_nlf_+3A_coeff">coeff</code></td>
<td>
<p>Named list of coefficient values used in <code>formula</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function for use inside <code><a href="#topic+sim_distribution">sim_distribution</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Make a grid and replicate data for 5 ages and 5 years
## (This is similar to what happens inside sim_distribution)
grid &lt;- make_grid(shelf_width = 10)
grid_xy &lt;- data.frame(grid)
i &lt;- rep(seq(nrow(grid_xy)), times = 5)
a &lt;- rep(1:5, each = nrow(grid_xy))
grid_xy &lt;- grid_xy[i, ]
grid_xy$age &lt;- a
i &lt;- rep(seq(nrow(grid_xy)), times = 5)
y &lt;- rep(1:5, each = nrow(grid_xy))
grid_xy &lt;- grid_xy[i, ]
grid_xy$year &lt;- y

## Now using sim_nlf, produce a function to apply to the expanded grid_xy data
## For this firs example, the depth effect is parabolic and the vertex is deeper by age
## (i.e., to impose ontogenetic deepening)
nlf &lt;- sim_nlf(formula = ~ alpha - ((depth - mu + beta * age) ^ 2) / (2 * sigma ^ 2),
               coeff = list(alpha = 0, mu = 200, sigma = 70, beta = -70))
grid_xy$depth_effect &lt;- nlf(grid_xy)

library(plotly)
grid_xy %&gt;%
  filter(year == 1) %&gt;%
  plot_ly(x = ~depth, y = ~depth_effect, split = ~age) %&gt;%
  add_lines()

</code></pre>

<hr>
<h2 id='sim_parabola'>Define a parabolic relationship</h2><span id='topic+sim_parabola'></span>

<h3>Description</h3>

<p>Closure to be used in <code><a href="#topic+sim_distribution">sim_distribution</a></code>. Form is based on the bi-gaussian function described here: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2993707/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_parabola(
  alpha = 0,
  mu = 200,
  sigma = 70,
  sigma_right = NULL,
  log_space = FALSE,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_parabola_+3A_alpha">alpha</code>, <code id="sim_parabola_+3A_mu">mu</code>, <code id="sim_parabola_+3A_sigma">sigma</code></td>
<td>
<p>Parameters that control the shape of the parabola. Can be one value or
a vector of equal length to the number of ages in the simulation
(e.g. age-specific depth associations can be specified).</p>
</td></tr>
<tr><td><code id="sim_parabola_+3A_sigma_right">sigma_right</code></td>
<td>
<p>Optional parameter to impose asymmetry by supplying a sigma parameter for the right side.
If used, <code>sigma</code> will be used to define the width of the left side. Ignored if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_parabola_+3A_log_space">log_space</code></td>
<td>
<p>Should shape of the parabola be defined in log space? If <code>TRUE</code>, logged parameters are
assumed to be supplied and x values used in the parabola equation are log transformed.
This allows a more lognormal curve to be defined and, hence, allows a heavier tail and it
forces very low values near zero.</p>
</td></tr>
<tr><td><code id="sim_parabola_+3A_plot">plot</code></td>
<td>
<p>Produce a simple plot of the simulated values?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function for use inside <code><a href="#topic+sim_distribution">sim_distribution</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
parabola_fun &lt;- sim_parabola(mu = 50, sigma = 5, plot = TRUE)
parabola_fun(data.frame(depth = 0:100))

parabola_fun &lt;- sim_parabola(mu = log(40), sigma = 0.5, log_space = FALSE, plot = TRUE)
parabola_fun(data.frame(depth = 0:100))

parabola_fun &lt;- sim_parabola(mu = c(50, 120), sigma = c(5, 3), plot = TRUE)
parabola_fun(expand.grid(depth = 1:200, age = 1:2))

</code></pre>

<hr>
<h2 id='sim_R'>Simulate starting abundance, random recruitment and total mortality</h2><span id='topic+sim_R'></span><span id='topic+sim_Z'></span><span id='topic+sim_N0'></span>

<h3>Description</h3>

<p>These functions return a function to use inside <code><a href="#topic+sim_abundance">sim_abundance</a></code>.
Given parameters, it generates N0, R and Z values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_R(log_mean = log(3e+07), log_sd = 0.5, random_walk = TRUE, plot = FALSE)

sim_Z(
  log_mean = log(0.5),
  log_sd = 0.2,
  phi_age = 0.9,
  phi_year = 0.5,
  plot = FALSE
)

sim_N0(N0 = "exp", plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_R_+3A_log_mean">log_mean</code></td>
<td>
<p>One mean value or a vector of means, in log scale, of length equal to years for <code>sim_R</code> or a matrix of means with
rows equaling the number of ages and columns equaling the number of years for <code>sim_Z</code>.</p>
</td></tr>
<tr><td><code id="sim_R_+3A_log_sd">log_sd</code></td>
<td>
<p>Standard deviation of the variable in the log scale.</p>
</td></tr>
<tr><td><code id="sim_R_+3A_random_walk">random_walk</code></td>
<td>
<p>Simulate recruitment as a random walk?</p>
</td></tr>
<tr><td><code id="sim_R_+3A_plot">plot</code></td>
<td>
<p>produce a simple plot of the simulated values?</p>
</td></tr>
<tr><td><code id="sim_R_+3A_phi_age">phi_age</code></td>
<td>
<p>Autoregressive parameter for the age dimension.</p>
</td></tr>
<tr><td><code id="sim_R_+3A_phi_year">phi_year</code></td>
<td>
<p>Autoregressive parameter for the year dimension.</p>
</td></tr>
<tr><td><code id="sim_R_+3A_n0">N0</code></td>
<td>
<p>Either specify &quot;exp&quot; or numeric vector of starting abundance excluding the first age.
If &quot;exp&quot; is specified using sim_N0, then abundance at age are calculated using exponential decay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sim_R generates uncorrelated recruitment values or random walk values from a log normal distribution.
sim_Z does the same as sim_R when phi_age and phi_year are both 0, otherwise values are correlated
in the age and/or year dimension. The covariance structure follows that described in Cadigan (2015).
</p>


<h3>Value</h3>

<p>Returns a function for use inside <code><a href="#topic+sim_abundance">sim_abundance</a></code>.
</p>


<h3>References</h3>

<p>Cadigan, Noel G. 2015. A State-Space Stock Assessment Model for Northern Cod,
Including Under-Reported Catches and Variable Natural Mortality Rates. Canadian Journal of
Fisheries and Aquatic Sciences 73 (2): 296-308.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
R_fun &lt;- sim_R(log_mean = log(100000), log_sd = 0.1, random_walk = TRUE, plot = TRUE)
R_fun(years = 1:100)
sim_abundance(R = sim_R(log_mean = log(100000), log_sd = 0.5))
sim_abundance(years = 1:20,
              R = sim_R(log_mean = log(c(rep(100000, 10), rep(10000, 10))), plot = TRUE))

Z_fun &lt;- sim_Z(log_mean = log(0.5), log_sd = 0.1, phi_age = 0.9, phi_year = 0.9, plot = TRUE)
Z_fun(years = 1:100, ages = 1:20)
sim_abundance(Z = sim_Z(log_mean = log(0.5), log_sd = 0.1, plot = TRUE))
Za_dev &lt;- c(-0.2, -0.1, 0, 0.1, 0.2, 0.3, 0.3, 0.2, 0.1, 0)
Zy_dev &lt;- c(-0.2, -0.2, -0.2, -0.2, -0.2, 2, 2, 2, 2, 0.2, 0.2, 0.2, 0.2, 0.2, 0, 0, 0, 0, 0, 0)
Z_mat &lt;- outer(Za_dev, Zy_dev, "+") + 0.5
sim_abundance(ages = 1:10, years = 1:20,
              Z = sim_Z(log_mean = log(Z_mat), plot = TRUE))
sim_abundance(ages = 1:10, years = 1:20,
              Z = sim_Z(log_mean = log(Z_mat), log_sd = 0, phi_age = 0, phi_year = 0, plot = TRUE))

N0_fun &lt;- sim_N0(N0 = "exp", plot = TRUE)
N0_fun(R0 = 1000, Z0 = rep(0.5, 20), ages = 1:20)
sim_abundance(N0 = sim_N0(N0 = "exp", plot = TRUE))

</code></pre>

<hr>
<h2 id='sim_sets'>Simulate survey sets</h2><span id='topic+sim_sets'></span>

<h3>Description</h3>

<p>Simulate survey sets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_sets(
  sim,
  subset_cells,
  n_sims = 1,
  trawl_dim = c(1.5, 0.02),
  min_sets = 2,
  set_den = 2/1000,
  resample_cells = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_sets_+3A_sim">sim</code></td>
<td>
<p>Simulation object from <code><a href="#topic+sim_distribution">sim_distribution</a></code></p>
</td></tr>
<tr><td><code id="sim_sets_+3A_subset_cells">subset_cells</code></td>
<td>
<p>Logical expression indicating the elements (<code>x, y, depth, cell,
division, strat, year</code>) of the survey grid to keep (e.g., <code>cell
&lt; 100</code>)</p>
</td></tr>
<tr><td><code id="sim_sets_+3A_n_sims">n_sims</code></td>
<td>
<p>Number of simulations to produce</p>
</td></tr>
<tr><td><code id="sim_sets_+3A_trawl_dim">trawl_dim</code></td>
<td>
<p>Trawl width and distance (same units as grid)</p>
</td></tr>
<tr><td><code id="sim_sets_+3A_min_sets">min_sets</code></td>
<td>
<p>Minimum number of sets per strat</p>
</td></tr>
<tr><td><code id="sim_sets_+3A_set_den">set_den</code></td>
<td>
<p>Set density (number of sets per grid unit squared)</p>
</td></tr>
<tr><td><code id="sim_sets_+3A_resample_cells">resample_cells</code></td>
<td>
<p>Allow resampling of sampling units (grid cells)?
(Note: allowing resampling may create bias because
depletion is imposed at the cell level)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data.table including details of each set location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

sim &lt;- sim_abundance(ages = 1:5, years = 1:5) %&gt;%
          sim_distribution(grid = make_grid(res = c(20, 20)))

## Multiple calls can be useful for defining a custom series of sets
standard_sets &lt;- sim_sets(sim, year &lt;= 2, set_den = 2 / 1000)
reduced_sets &lt;- sim_sets(sim, year &gt; 2 &amp; !cell %in% 1:100, set_den = 1 / 1000)
sets &lt;- rbind(standard_sets, reduced_sets)
sets$set &lt;- seq(nrow(sets)) # Important - make sure set has a unique ID.

survey &lt;- sim_survey(sim, custom_sets = sets)

plot_survey(survey, which_year = 3, which_sim = 1)


</code></pre>

<hr>
<h2 id='sim_survey'>Simulate stratified-random survey</h2><span id='topic+sim_survey'></span>

<h3>Description</h3>

<p>Simulate stratified-random survey
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_survey(
  sim,
  n_sims = 1,
  q = sim_logistic(),
  trawl_dim = c(1.5, 0.02),
  resample_cells = FALSE,
  binom_error = TRUE,
  min_sets = 2,
  set_den = 2/1000,
  lengths_cap = 500,
  ages_cap = 10,
  age_sampling = "stratified",
  age_length_group = 1,
  age_space_group = "division",
  custom_sets = NULL,
  light = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_survey_+3A_sim">sim</code></td>
<td>
<p>Simulation from <code><a href="#topic+sim_distribution">sim_distribution</a></code></p>
</td></tr>
<tr><td><code id="sim_survey_+3A_n_sims">n_sims</code></td>
<td>
<p>Number of surveys to simulate over the simulated population. Note: requesting
a large number of simulations may max out your RAM. Use
<code><a href="#topic+sim_survey_parallel">sim_survey_parallel</a></code> if many simulations are required.</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_q">q</code></td>
<td>
<p>Closure, such as <code><a href="#topic+sim_logistic">sim_logistic</a></code>, for simulating catchability at age
(returned values must be between 0 and 1)</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_trawl_dim">trawl_dim</code></td>
<td>
<p>Trawl width and distance (same units as grid)</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_resample_cells">resample_cells</code></td>
<td>
<p>Allow resampling of sampling units (grid cells)? Setting to TRUE may introduce bias
because depletion is imposed at the cell level.</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_binom_error">binom_error</code></td>
<td>
<p>Impose binomial error? Setting to FALSE may introduce bias in stratified estimates
at older ages because of more frequent rounding to zero.</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_min_sets">min_sets</code></td>
<td>
<p>Minimum number of sets per strat</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_set_den">set_den</code></td>
<td>
<p>Set density (number of sets per grid unit squared). WARNING:
may return an error if <code>set_den</code> is high and
<code>resample_cells = FALSE</code> because the number of sets allocated may
exceed the number of cells in a strata.</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_lengths_cap">lengths_cap</code></td>
<td>
<p>Maximum number of lengths measured per set</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_ages_cap">ages_cap</code></td>
<td>
<p>If <code>age_sampling = "stratified"</code>, this cap represents the maximum
number of ages to sample per length group (defined using the <code>age_length_group</code>
argument) per division or strat (defined using the <code>age_space_group</code> argument)
per year. If <code>age_sampling = "random"</code>, it is the maximum number of ages to sample
from measured fish per set.</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_age_sampling">age_sampling</code></td>
<td>
<p>Should age sampling be &quot;stratified&quot; (default) or &quot;random&quot;?</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_age_length_group">age_length_group</code></td>
<td>
<p>Numeric value indicating the size of the length bins for stratified
age sampling. Ignored if <code>age_sampling = "random"</code>.</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_age_space_group">age_space_group</code></td>
<td>
<p>Should age sampling occur at the &quot;division&quot; (default), &quot;strat&quot; or &quot;set&quot; spatial scale?
That is, age sampling can be spread across each &quot;division&quot;, &quot;strat&quot; or &quot;set&quot;
in each year to a maximum number within each length bin (cap is defined using
the <code>age_cap</code> argument). Ignored if <code>age_sampling = "random"</code>.</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_custom_sets">custom_sets</code></td>
<td>
<p>Supply an object of the same structure as returned by <code><a href="#topic+sim_sets">sim_sets</a></code> which
specifies a custom series of set locations to be sampled. Set locations are
automated if <code>custom_sets = NULL</code>.</p>
</td></tr>
<tr><td><code id="sim_survey_+3A_light">light</code></td>
<td>
<p>Drop some objects from the output to keep object size low?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including rounded population simulation, set locations and details
and sampling details. Note that that N = &quot;true&quot; population, I = population available
to the survey, n = number caught by survey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

sim &lt;- sim_abundance(ages = 1:5, years = 1:5) %&gt;%
           sim_distribution(grid = make_grid(res = c(20, 20))) %&gt;%
           sim_survey(n_sims = 5, q = sim_logistic(k = 2, x0 = 3))
plot_survey(sim, which_year = 3, which_sim = 1)


</code></pre>

<hr>
<h2 id='sim_survey_parallel'>Simulate stratified random surveys using parallel computation</h2><span id='topic+sim_survey_parallel'></span>

<h3>Description</h3>

<p>This function is a wrapper for <code><a href="#topic+sim_survey">sim_survey</a></code> except it allows for
many more total iterations to be run than <code><a href="#topic+sim_survey">sim_survey</a></code> before running
into RAM limitations. Unlike <code><a href="#topic+test_surveys">test_surveys</a></code>, this function retains
the full details of the survey and it may therefore be more useful for testing
alternate approaches to a stratified analysis for obtaining survey indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_survey_parallel(
  sim,
  n_sims = 1,
  n_loops = 100,
  cores = 1,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_survey_parallel_+3A_sim">sim</code></td>
<td>
<p>Simulation from <code><a href="#topic+sim_distribution">sim_distribution</a></code></p>
</td></tr>
<tr><td><code id="sim_survey_parallel_+3A_n_sims">n_sims</code></td>
<td>
<p>Number of times to simulate a survey over the simulated population.
Requesting a large number of simulations here may max out your RAM.</p>
</td></tr>
<tr><td><code id="sim_survey_parallel_+3A_n_loops">n_loops</code></td>
<td>
<p>Number of times to run the <code><a href="#topic+sim_survey">sim_survey</a></code> function. Total
simulations run will be the product of <code>n_sims</code> and <code>n_loops</code>
arguments. Low numbers of <code>n_sims</code> and high numbers of <code>n_loops</code>
will be easier on RAM, but may be slower.</p>
</td></tr>
<tr><td><code id="sim_survey_parallel_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use in parallel. More cores should speed up the process.</p>
</td></tr>
<tr><td><code id="sim_survey_parallel_+3A_quiet">quiet</code></td>
<td>
<p>Print message on what to expect for duration?</p>
</td></tr>
<tr><td><code id="sim_survey_parallel_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+sim_survey">sim_survey</a></code>
</p>

<dl>
<dt><code>q</code></dt><dd><p>Closure, such as <code><a href="#topic+sim_logistic">sim_logistic</a></code>, for simulating catchability at age
(returned values must be between 0 and 1)</p>
</dd>
<dt><code>trawl_dim</code></dt><dd><p>Trawl width and distance (same units as grid)</p>
</dd>
<dt><code>resample_cells</code></dt><dd><p>Allow resampling of sampling units (grid cells)? Setting to TRUE may introduce bias
because depletion is imposed at the cell level.</p>
</dd>
<dt><code>binom_error</code></dt><dd><p>Impose binomial error? Setting to FALSE may introduce bias in stratified estimates
at older ages because of more frequent rounding to zero.</p>
</dd>
<dt><code>min_sets</code></dt><dd><p>Minimum number of sets per strat</p>
</dd>
<dt><code>set_den</code></dt><dd><p>Set density (number of sets per grid unit squared). WARNING:
may return an error if <code>set_den</code> is high and
<code>resample_cells = FALSE</code> because the number of sets allocated may
exceed the number of cells in a strata.</p>
</dd>
<dt><code>lengths_cap</code></dt><dd><p>Maximum number of lengths measured per set</p>
</dd>
<dt><code>ages_cap</code></dt><dd><p>If <code>age_sampling = "stratified"</code>, this cap represents the maximum
number of ages to sample per length group (defined using the <code>age_length_group</code>
argument) per division or strat (defined using the <code>age_space_group</code> argument)
per year. If <code>age_sampling = "random"</code>, it is the maximum number of ages to sample
from measured fish per set.</p>
</dd>
<dt><code>age_sampling</code></dt><dd><p>Should age sampling be &quot;stratified&quot; (default) or &quot;random&quot;?</p>
</dd>
<dt><code>age_length_group</code></dt><dd><p>Numeric value indicating the size of the length bins for stratified
age sampling. Ignored if <code>age_sampling = "random"</code>.</p>
</dd>
<dt><code>age_space_group</code></dt><dd><p>Should age sampling occur at the &quot;division&quot; (default), &quot;strat&quot; or &quot;set&quot; spatial scale?
That is, age sampling can be spread across each &quot;division&quot;, &quot;strat&quot; or &quot;set&quot;
in each year to a maximum number within each length bin (cap is defined using
the <code>age_cap</code> argument). Ignored if <code>age_sampling = "random"</code>.</p>
</dd>
<dt><code>custom_sets</code></dt><dd><p>Supply an object of the same structure as returned by <code><a href="#topic+sim_sets">sim_sets</a></code> which
specifies a custom series of set locations to be sampled. Set locations are
automated if <code>custom_sets = NULL</code>.</p>
</dd>
<dt><code>light</code></dt><dd><p>Drop some objects from the output to keep object size low?</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+sim_survey">sim_survey</a></code> is hard-wired here to be &quot;light&quot; to minimize object size.
</p>


<h3>Value</h3>

<p>Returns an object of the same structure as <code><a href="#topic+sim_survey">sim_survey</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## This call runs a total of 25 simulations of the same survey over
## the same population (Note: total number of simulations are low to
## decrease computation time for the example)
sim &lt;- sim_abundance(ages = 1:20, years = 1:5) %&gt;%
           sim_distribution(grid = make_grid(res = c(10, 10))) %&gt;%
           sim_survey_parallel(n_sims = 5, n_loops = 5, cores = 1,
                               q = sim_logistic(k = 2, x0 = 3),
                               quiet = FALSE)



</code></pre>

<hr>
<h2 id='sim_vonB'>Closure for simulating length given age using von Bertalanffy notation</h2><span id='topic+sim_vonB'></span>

<h3>Description</h3>

<p>This function outputs a function which holds the parameter values supplied and
the function either simulates lengths given ages or generates a length age key
give a sequence of ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_vonB(
  Linf = 120,
  L0 = 5,
  K = 0.1,
  log_sd = 0.1,
  length_group = 3,
  digits = 0,
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_vonB_+3A_linf">Linf</code></td>
<td>
<p>Mean asymptotic length</p>
</td></tr>
<tr><td><code id="sim_vonB_+3A_l0">L0</code></td>
<td>
<p>Length at birth</p>
</td></tr>
<tr><td><code id="sim_vonB_+3A_k">K</code></td>
<td>
<p>Growth rate parameter</p>
</td></tr>
<tr><td><code id="sim_vonB_+3A_log_sd">log_sd</code></td>
<td>
<p>Standard deviation of the relationship in log scale</p>
</td></tr>
<tr><td><code id="sim_vonB_+3A_length_group">length_group</code></td>
<td>
<p>Length group for length age key. Note that labels on the matrix produced are
midpoints using the DFO conventions; see <code><a href="#topic+group_lengths">group_lengths</a></code>. Also
note that this length group will dictate the length group used in the
stratified analysis run by <code><a href="#topic+run_strat">run_strat</a></code>.</p>
</td></tr>
<tr><td><code id="sim_vonB_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to round the values to</p>
</td></tr>
<tr><td><code id="sim_vonB_+3A_plot">plot</code></td>
<td>
<p>Produce a simple plot of the simulated values?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function for use inside <code><a href="#topic+sim_abundance">sim_abundance</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>growth_fun &lt;- sim_vonB(Linf = 100, L0 = 5, K = 0.2, log_sd = 0.05, length_group = 1, plot = TRUE)
growth_fun(age = rep(1:15, each = 100))
growth_fun(age = 1:15, length_age_key = TRUE)
sim_abundance(growth = sim_vonB(plot = TRUE))

</code></pre>

<hr>
<h2 id='strat_data'>Prepare simulated data for stratified analysis</h2><span id='topic+strat_data'></span>

<h3>Description</h3>

<p>Generate set details (setdet), length-frequency (lf)
and age-frequency (af) data for stratified analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_data(sim, length_group = 3, alk_scale = "division")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strat_data_+3A_sim">sim</code></td>
<td>
<p>Simulation from <code><a href="#topic+sim_survey">sim_survey</a></code></p>
</td></tr>
<tr><td><code id="strat_data_+3A_length_group">length_group</code></td>
<td>
<p>Size of the length frequency bins</p>
</td></tr>
<tr><td><code id="strat_data_+3A_alk_scale">alk_scale</code></td>
<td>
<p>Spatial scale at which to construct and apply age-length-keys:
&quot;division&quot;, &quot;strat&quot; or &quot;set&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list including set details (<code>setdet</code>), length-frequencies (<code>lf</code>),
and age-frequencies (<code>af</code>).
</p>

<hr>
<h2 id='strat_error'>Calculate error of stratified estimates</h2><span id='topic+strat_error'></span>

<h3>Description</h3>

<p>Calculate error of stratified estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_error(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strat_error_+3A_sim">sim</code></td>
<td>
<p>Object from <code><a href="#topic+run_strat">run_strat</a></code> (includes simulated population and
survey along with stratified analysis results)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adds details and summary stats of stratified estimate error to the
<code>sim</code> list, ending with <code>"_strat_error"</code> or
<code>"_strat_error_stats"</code>. Error statistics includes mean absolute
error (<code>"MAE"</code>), mean squared error (<code>"MSE"</code>), and
root mean squared error (<code>"RMSE"</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

sim &lt;- sim_abundance(ages = 1:5, years = 1:5,
                     R = sim_R(log_mean = log(1e+7)),
                     growth = sim_vonB(length_group = 1)) %&gt;%
           sim_distribution(grid = make_grid(res = c(20, 20)),
                            ays_covar = sim_ays_covar(sd = 1)) %&gt;%
           sim_survey(n_sims = 1, q = sim_logistic(k = 2, x0 = 3)) %&gt;%
           run_strat() %&gt;%
           strat_error()


</code></pre>

<hr>
<h2 id='strat_means'>Calculate stratified means, variances and confidence intervals across groups</h2><span id='topic+strat_means'></span>

<h3>Description</h3>

<p>Calculate stratified means, variances and confidence intervals across groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_means(
  data = NULL,
  metric = NULL,
  strat_groups = NULL,
  survey_groups = NULL,
  confidence = 95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strat_means_+3A_data">data</code></td>
<td>
<p>Expects data.table with all grouping variables in stacked format (must include
strat_area and tow_area for scaling values)</p>
</td></tr>
<tr><td><code id="strat_means_+3A_metric">metric</code></td>
<td>
<p>Variable in specified data.table. e.g. &quot;number&quot;, &quot;mass&quot;</p>
</td></tr>
<tr><td><code id="strat_means_+3A_strat_groups">strat_groups</code></td>
<td>
<p>Grouping variables for calculations of the fine-scale strat-level
means (strat and strat_area are required). e.g. c(&quot;year&quot;, &quot;species&quot;,
&quot;shiptrip&quot;, &quot;NAFOdiv&quot;, &quot;strat&quot;, &quot;strat_area&quot;,&quot;age&quot;)</p>
</td></tr>
<tr><td><code id="strat_means_+3A_survey_groups">survey_groups</code></td>
<td>
<p>Grouping variables for large-scale summary calculations. e.g. (&quot;year&quot;,&quot;species&quot;)</p>
</td></tr>
<tr><td><code id="strat_means_+3A_confidence">confidence</code></td>
<td>
<p>Percent for confidence limits</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function was mainly created for use in the <code><a href="#topic+run_strat">run_strat</a></code> function.
It first calculates strat-level statistics and then the larger-scale statistics like total abundance
</p>


<h3>Value</h3>

<p>Returns a data.table including stratified estimates of abundance.
</p>

<hr>
<h2 id='survey_grid'>Sample survey simulation grid.</h2><span id='topic+survey_grid'></span>

<h3>Description</h3>

<p>A exemplar for the structure of a survey grid object to supply to the functions
in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_grid
</code></pre>


<h3>Format</h3>

<p>A stars object with 4 attributes:
</p>

<dl>
<dt>cell</dt><dd><p>Survey cell identifier</p>
</dd>
<dt>division</dt><dd><p>NAFO division</p>
</dd>
<dt>strat</dt><dd><p>Survey strata number</p>
</dd>
<dt>depth</dt><dd><p>Mean depth of the waters under each cell, units = m</p>
</dd>
</dl>

<p>For further details on how this file was created, see the data-raw folder for
this package.
</p>

<hr>
<h2 id='survey_lite_mesh'>Lite sample survey mesh and related items</h2><span id='topic+survey_lite_mesh'></span>

<h3>Description</h3>

<p>Lite sample survey mesh and related items
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_lite_mesh
</code></pre>


<h3>Format</h3>

<p>A list containing the same items as survey_mesh, but with fewer nodes to save on computational time
</p>

<hr>
<h2 id='survey_mesh'>Sample survey meshes and related items</h2><span id='topic+survey_mesh'></span>

<h3>Description</h3>

<p>@format A list containing the R-INLA survey mesh, the set of triangles in the barrier and the barrier polygons for plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survey_mesh
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>Details</h3>

<p>An example of a mesh containing barrier information for use with
sim_ays_covar_spde. Also derived from global administrative boundaries
data (http://gadm.org). Details on creation provided in the data-raw
folder of this package in the survey_mesh.R file. Includes the set
of barrier triangles needed to use the barrier approach, barrier
polygons for plotting and the set of triangles in the barrier.
</p>

<hr>
<h2 id='test_surveys'>Test sampling design of multiple surveys using a stratified analysis</h2><span id='topic+test_surveys'></span><span id='topic+resume_test'></span>

<h3>Description</h3>

<p>This function allows a series of sampling design settings to
be set and tested on the simulated population. True population values are compared
to stratified estimates of abundance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_surveys(
  sim,
  surveys = expand_surveys(),
  keep_details = 1,
  n_sims = 1,
  n_loops = 100,
  cores = 2,
  export_dir = NULL,
  length_group = "inherit",
  alk_scale = "division",
  progress = TRUE,
  ...
)

resume_test(export_dir = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_surveys_+3A_sim">sim</code></td>
<td>
<p>Simulation from <code><a href="#topic+sim_distribution">sim_distribution</a></code>.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_surveys">surveys</code></td>
<td>
<p>A data.frame or data.table with a sequence of surveys and their settings
with a format like the data.table returned by <code><a href="#topic+expand_surveys">expand_surveys</a></code>.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_keep_details">keep_details</code></td>
<td>
<p>Survey and stratified analysis details are dropped here to minimize object
size. This argument allows the user to keep the details of one
survey by specifying the survey number in the data.frame supplied to <code>surveys</code>.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_n_sims">n_sims</code></td>
<td>
<p>Number of times to simulate a survey over the simulated population.
Requesting a large number of simulations here may max out your RAM.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_n_loops">n_loops</code></td>
<td>
<p>Number of times to run the <code><a href="#topic+sim_survey">sim_survey</a></code> function. Total
simulations run will be the product of <code>n_sims</code> and <code>n_loops</code>
arguments. Low numbers of <code>n_sims</code> and high numbers of <code>n_loops</code>
will be easier on RAM, but may be slower.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use in parallel. More cores should speed up the process.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_export_dir">export_dir</code></td>
<td>
<p>Directory for exporting results as they are generated. Main use of the export
is to allow this process to pick up where <code>test_survey</code> left off by
calling <code>resume_test</code>. If NULL, nothing is exported.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_length_group">length_group</code></td>
<td>
<p>Size of the length frequency bins for both abundance at length calculations
and age-length-key construction. By default this value is inherited from
the value defined in <code><a href="#topic+sim_abundance">sim_abundance</a></code> from the closure supplied to
<code>sim_length</code> (&quot;inherit&quot;). A numeric value can also be supplied, however,
a mismatch in length groupings will cause issues with <code><a href="#topic+strat_error">strat_error</a></code>
as true vs. estimated length groupings will be mismatched.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_alk_scale">alk_scale</code></td>
<td>
<p>Spatial scale at which to construct and apply age-length-keys:
&quot;division&quot; or &quot;strat&quot;.</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_progress">progress</code></td>
<td>
<p>Display progress bar and messages?</p>
</td></tr>
<tr><td><code id="test_surveys_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+sim_survey">sim_survey</a></code>
</p>

<dl>
<dt><code>q</code></dt><dd><p>Closure, such as <code><a href="#topic+sim_logistic">sim_logistic</a></code>, for simulating catchability at age
(returned values must be between 0 and 1)</p>
</dd>
<dt><code>trawl_dim</code></dt><dd><p>Trawl width and distance (same units as grid)</p>
</dd>
<dt><code>resample_cells</code></dt><dd><p>Allow resampling of sampling units (grid cells)? Setting to TRUE may introduce bias
because depletion is imposed at the cell level.</p>
</dd>
<dt><code>binom_error</code></dt><dd><p>Impose binomial error? Setting to FALSE may introduce bias in stratified estimates
at older ages because of more frequent rounding to zero.</p>
</dd>
<dt><code>min_sets</code></dt><dd><p>Minimum number of sets per strat</p>
</dd>
<dt><code>age_sampling</code></dt><dd><p>Should age sampling be &quot;stratified&quot; (default) or &quot;random&quot;?</p>
</dd>
<dt><code>age_length_group</code></dt><dd><p>Numeric value indicating the size of the length bins for stratified
age sampling. Ignored if <code>age_sampling = "random"</code>.</p>
</dd>
<dt><code>age_space_group</code></dt><dd><p>Should age sampling occur at the &quot;division&quot; (default), &quot;strat&quot; or &quot;set&quot; spatial scale?
That is, age sampling can be spread across each &quot;division&quot;, &quot;strat&quot; or &quot;set&quot;
in each year to a maximum number within each length bin (cap is defined using
the <code>age_cap</code> argument). Ignored if <code>age_sampling = "random"</code>.</p>
</dd>
<dt><code>custom_sets</code></dt><dd><p>Supply an object of the same structure as returned by <code><a href="#topic+sim_sets">sim_sets</a></code> which
specifies a custom series of set locations to be sampled. Set locations are
automated if <code>custom_sets = NULL</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the settings, <code>test_surveys</code> may take a long time to run.
The <code>resume_test</code> function is for resuming partial runs of <code>test_surveys</code>.
Note that progress bar time estimates will be biased here by previous completions.
<code>test_loop</code> is a helper function used in both <code>test_surveys</code> and
<code>resume_test</code>. CAUTION: while the dots construct is available in the <code>resume_test</code>
function, be careful adding arguments as it will change the simulation settings
if the arguments added were not specified in the initial <code>test_surveys</code> run.
</p>


<h3>Value</h3>

<p>Adds a table of survey designs tested. Also adds details and summary
stats of stratified estimate error to the <code>sim</code> list, ending with
<code>"_strat_error"</code> or <code>"_strat_error_stats"</code>. Error statistics
includes mean error (<code>"ME"</code>), mean absolute error (<code>"MAE"</code>),
mean squared error (<code>"MSE"</code>), and root mean squared error (<code>"RMSE"</code>).
Also adds a sample size summary table (<code>"samp_totals"</code>) to the list.
Survey and stratified analysis details are not kept to minimize object size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

pop &lt;- sim_abundance(ages = 1:20, years = 1:5) %&gt;%
           sim_distribution(grid = make_grid(res = c(10, 10)))

surveys &lt;- expand_surveys(set_den = c(1, 2) / 1000,
                          lengths_cap = c(100, 500),
                          ages_cap = c(5, 20))

## This call runs 25 simulations of 8 different surveys over the same
## population, and then runs a stratified analysis and compares true vs
## estimated values. (Note: total number of simulations are low to decrease
## computation time for the example)
tests &lt;- test_surveys(pop, surveys = surveys, keep_details = 1,
                      n_sims = 5, n_loops = 5, cores = 1)

library(plotly)
tests$total_strat_error %&gt;%
    filter(survey == 8, sim %in% 1:50) %&gt;%
    group_by(sim) %&gt;%
    plot_ly(x = ~year) %&gt;%
    add_lines(y = ~I_hat, alpha = 0.5, name = "estimated") %&gt;%
    add_lines(y = ~I, color = I("black"), name = "true") %&gt;%
    layout(xaxis = list(title = "Year"),
           yaxis = list(title = "Abundance index"))

plot_total_strat_fan(tests, surveys = 1:8)
plot_length_strat_fan(tests, surveys = 1:8)
plot_age_strat_fan(tests, surveys = 1:8)
plot_age_strat_fan(tests, surveys = 1:8, select_by = "age")

plot_error_surface(tests, plot_by = "rule")
plot_error_surface(tests, plot_by = "samples")

plot_survey_rank(tests, which_strat = "length")
plot_survey_rank(tests, which_strat = "age")



</code></pre>

<hr>
<h2 id='vis_sim'>Make a flexdashboard for visualizing the simulation</h2><span id='topic+vis_sim'></span>

<h3>Description</h3>

<p>Assumes the working directory is the project directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_sim(sim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vis_sim_+3A_sim">sim</code></td>
<td>
<p>Object produced by <code><a href="#topic+sim_abundance">sim_abundance</a></code>, <code><a href="#topic+sim_distribution">sim_distribution</a></code>,
<code><a href="#topic+sim_survey">sim_survey</a></code> or <code><a href="#topic+test_surveys">test_surveys</a></code>.</p>
</td></tr>
<tr><td><code id="vis_sim_+3A_...">...</code></td>
<td>
<p>Additional arguments to send to <a href="rmarkdown.html#topic+run">run</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value returned; function produces an interactive dashboard.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


if (interactive()) {

  pop &lt;- sim_abundance(ages = 1:20, years = 1:20)
  vis_sim(pop)

  dist &lt;- sim_distribution(pop, grid = make_grid(res = c(10, 10)))
  vis_sim(dist)

  ## Run one survey design
  survey &lt;- sim_survey(dist, n_sims = 5)
  vis_sim(survey)

  ## Run several survey designs and assess stratified estimates
  ## (Note: total number of simulations are low to decrease computation time for the example)
  surveys &lt;- expand_surveys(set_den = c(1, 2) / 1000,
                            lengths_cap = c(100, 500),
                            ages_cap = c(5, 20))
  tests &lt;- test_surveys(dist, surveys = surveys, keep_details = 1,
                        n_sims = 5, n_loops = 5, cores = 1)
  vis_sim(tests)

}


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
