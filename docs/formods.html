<!DOCTYPE html><html><head><title>Help for package formods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {formods}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#formods'><p>formods: Shiny modules for common tasks.</p></a></li>
<li><a href='#ASM_fetch_code'><p>Fetch Module Code</p></a></li>
<li><a href='#ASM_fetch_dlfn'><p>Fetch Download File Name</p></a></li>
<li><a href='#ASM_fetch_state'><p>Fetch State Manager State</p></a></li>
<li><a href='#ASM_init_state'><p>Initialize ASM Module State</p></a></li>
<li><a href='#ASM_Server'><p>Save State Server</p></a></li>
<li><a href='#ASM_test_mksession'><p>Populate Session Data for Module Testing</p></a></li>
<li><a href='#ASM_write_state'><p>Write State to File for Saving</p></a></li>
<li><a href='#autocast'><p>Automatically Cast UI Input Variable</p></a></li>
<li><a href='#DW_add_wrangling_element'><p>Adding Wrangling Element to Current Data View</p></a></li>
<li><a href='#DW_append_report'><p>Append Report Elements</p></a></li>
<li><a href='#DW_attach_ds'><p>Attach Data Set to DW State</p></a></li>
<li><a href='#dw_eval_element'><p>Evaluates Data Wrangling Generated Code</p></a></li>
<li><a href='#DW_fetch_code'><p>Fetch Module Code</p></a></li>
<li><a href='#DW_fetch_current_view'><p>Fetches Current Data View</p></a></li>
<li><a href='#DW_fetch_ds'><p>Fetch Module Datasets</p></a></li>
<li><a href='#DW_fetch_state'><p>Fetch Data Wrangling State</p></a></li>
<li><a href='#DW_init_state'><p>Initialize DW Module State</p></a></li>
<li><a href='#DW_new_view'><p>New Data Wrangling View</p></a></li>
<li><a href='#DW_Server'><p>Data Wrangling Server</p></a></li>
<li><a href='#DW_set_current_view'><p>Sets Current Data View</p></a></li>
<li><a href='#DW_test_mksession'><p>Populate Session Data for Module Testing</p></a></li>
<li><a href='#DW_update_checksum'><p>Updates DW Module Checksum</p></a></li>
<li><a href='#dwrs_builder'><p>Builds a Data Wrangling R Statement From ui Elements:</p></a></li>
<li><a href='#fers_builder'><p>Builds a Figure Element R Statement From UI Elements:</p></a></li>
<li><a href='#fetch_hold'><p>Fetches the Hold Status UI Element Supplied</p></a></li>
<li><a href='#fetch_package_version'><p>Fetches the Current Version of Pacakge</p></a></li>
<li><a href='#FG_append_report'><p>Append Report Elements</p></a></li>
<li><a href='#FG_build'><p>Evaluates Figure Generation Code</p></a></li>
<li><a href='#FG_extract_page'><p>Extracts Specific Page from Paginated Figure</p></a></li>
<li><a href='#FG_fetch_code'><p>Fetch Module Code</p></a></li>
<li><a href='#FG_fetch_current_fig'><p>Fetches Current Figure</p></a></li>
<li><a href='#FG_fetch_state'><p>Fetch Figure Generation State</p></a></li>
<li><a href='#FG_init_state'><p>Initialize FG Module State</p></a></li>
<li><a href='#FG_new_fig'><p>Initialize New Figure</p></a></li>
<li><a href='#FG_Server'><p>Figure Generation Server</p></a></li>
<li><a href='#FG_set_current_fig'><p>Sets Current Figure</p></a></li>
<li><a href='#FG_test_mksession'><p>Populate Session Data for Module Testing</p></a></li>
<li><a href='#FG_update_checksum'><p>Updates FG Module Checksum</p></a></li>
<li><a href='#FM_add_ui_tooltip'><p>Add Tooltip to UI Element</p></a></li>
<li><a href='#FM_build_comment'><p>Create RStudio Formatted Comments</p></a></li>
<li><a href='#FM_fetch_app_code'><p>Fetches the Code to Reproduce Analysis</p></a></li>
<li><a href='#FM_fetch_app_info'><p>Fetches Informaiton About the App</p></a></li>
<li><a href='#FM_fetch_app_state'><p>Fetches the App State</p></a></li>
<li><a href='#FM_fetch_current_mods'><p>Fetches Details About Current Modules</p></a></li>
<li><a href='#FM_fetch_data_format'><p>Creates Formatting Information for Datasets</p></a></li>
<li><a href='#FM_fetch_deps'><p>Fetches Dependency Information</p></a></li>
<li><a href='#FM_fetch_ds'><p>Fetches Datasets from Modules in the App</p></a></li>
<li><a href='#FM_fetch_log_path'><p>Fetches the Path to the Log File</p></a></li>
<li><a href='#FM_fetch_mdl'><p>Fetches Models from Modules in the App</p></a></li>
<li><a href='#FM_fetch_mod_state'><p>Fetch the Module State</p></a></li>
<li><a href='#FM_fetch_user_files_path'><p>Fetches the Path to the User Files</p></a></li>
<li><a href='#FM_generate_report'><p>Generate Report</p></a></li>
<li><a href='#FM_init_state'><p>Initialize a formods State Object</p></a></li>
<li><a href='#FM_le'><p>Adds Message to Log File and Displays it to the Console</p></a></li>
<li><a href='#FM_message'><p>Show Message to User</p></a></li>
<li><a href='#FM_mk_error_fig'><p>Generates 'ggplot' Object with Error Message</p></a></li>
<li><a href='#FM_notify'><p>Shiny Notification</p></a></li>
<li><a href='#FM_pause_screen'><p>Starts Modal Screen Pause</p></a></li>
<li><a href='#FM_pretty_sort'><p>Centralized Sorting Function</p></a></li>
<li><a href='#FM_proc_include'><p>Sets Message in State from UI Processing</p></a></li>
<li><a href='#FM_resume_screen'><p>Stops Modal Screen Pause</p></a></li>
<li><a href='#FM_set_app_state'><p>Set the App State</p></a></li>
<li><a href='#FM_set_mod_state'><p>Set the Module State</p></a></li>
<li><a href='#FM_set_notification'><p>Shiny Notification</p></a></li>
<li><a href='#FM_set_ui_msg'><p>Sets Message in State from UI Processing</p></a></li>
<li><a href='#FM_tc'><p>Run Try/Catch and Process Results</p></a></li>
<li><a href='#formods_check'><p>Checks 'formods' Dependencies</p></a></li>
<li><a href='#has_changed'><p>Detect if a UI element has changed</p></a></li>
<li><a href='#has_updated'><p>Detect if a UI element has updated</p></a></li>
<li><a href='#icon_link'><p>Creates Icon Link</p></a></li>
<li><a href='#is_installed'><p>Determines if a Package is Installed</p></a></li>
<li><a href='#linspace'><p>Implementation of the <code>linspace</code> Function from Matlab</p></a></li>
<li><a href='#new_module_template'><p>Makes Template Files for formods New Module</p></a></li>
<li><a href='#remove_hold'><p>Removes Hold on UI Element</p></a></li>
<li><a href='#set_hold'><p>Sets Hold on One or All UI Elements</p></a></li>
<li><a href='#UD_attach_ds'><p>Attach Data Set to UD State</p></a></li>
<li><a href='#UD_ds_read'><p>Generate Code and Load DS</p></a></li>
<li><a href='#UD_fetch_code'><p>Fetch Module Code</p></a></li>
<li><a href='#UD_fetch_ds'><p>Fetch Module Datasets</p></a></li>
<li><a href='#UD_fetch_state'><p>Fetch Upload Data State</p></a></li>
<li><a href='#UD_init_state'><p>Initialize UD Module State</p></a></li>
<li><a href='#UD_Server'><p>Data Upload Server</p></a></li>
<li><a href='#UD_test_mksession'><p>Populate Session Data for Module Testing</p></a></li>
<li><a href='#unfactor'><p>Remove Factor From Object</p></a></li>
<li><a href='#use_formods'><p>Create Module Templates in a Package Repository</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'Shiny' Modules for General Tasks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Harrold &lt;john.m.harrold@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>'Shiny' apps can often make use of the same key elements, this package provides modules for common tasks (data upload, wrangling data, figure generation and saving the app state). These modules can react and interact as well as generate code to create reproducible analyses.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/john-harrold/formods/issues">https://github.com/john-harrold/formods/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://formods.ubiquity.tools/">https://formods.ubiquity.tools/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, digest, dplyr, ggforce, ggplot2, onbrand (&ge; 1.0.3),
readr, readxl, rlang, rhandsontable, shiny, shinyAce,
shinyWidgets, stats, stringr, tools, writexl, yaml, zip</td>
</tr>
<tr>
<td>Suggests:</td>
<td>clipr, covr, devtools, DT, flextable, ggpubr, gtools, here,
janitor, knitr, plotly, prompter, rmarkdown, shinybusy,
shinydashboard, testthat (&ge; 3.0.0), utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-03 00:58:48 UTC; jmh</td>
</tr>
<tr>
<td>Author:</td>
<td>John Harrold <a href="https://orcid.org/0000-0003-2052-4373"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 04:42:58 UTC</td>
</tr>
</table>
<hr>
<h2 id='formods'>formods: Shiny modules for common tasks.</h2><span id='topic+formods-package'></span><span id='topic+formods'></span>

<h3>Description</h3>

<p>Shiny apps can often make use of the same key elements, this package
provides modules for common tasks (data upload, wrangling data, figure
generation and saving the app state). These modules can react and interact
as well as generate code to create reproducible analyses.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Harrold <a href="mailto:john.m.harrold@gmail.com">john.m.harrold@gmail.com</a> (<a href="https://orcid.org/0000-0003-2052-4373">ORCID</a>)
</p>


<h3>See Also</h3>

<p><a href="https://formods.ubiquity.tools/">https://formods.ubiquity.tools/</a>
</p>

<hr>
<h2 id='ASM_fetch_code'>Fetch Module Code</h2><span id='topic+ASM_fetch_code'></span>

<h3>Description</h3>

<p>Fetches the code to generate results seen in the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASM_fetch_code(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASM_fetch_code_+3A_state">state</code></td>
<td>
<p>ASM state from <code>ASM_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ASM module does not generate code
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a state object for testing
sess_res = ASM_test_mksession(session=list(), full_session=FALSE)
state = sess_res$state
code = ASM_fetch_code(state)
</code></pre>

<hr>
<h2 id='ASM_fetch_dlfn'>Fetch Download File Name</h2><span id='topic+ASM_fetch_dlfn'></span>

<h3>Description</h3>

<p>Gets either the file name specified by the user or the default
value if that is null
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASM_fetch_dlfn(state, extension = ".zip")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASM_fetch_dlfn_+3A_state">state</code></td>
<td>
<p>ASM state from <code>ASM_fetch_state()</code></p>
</td></tr>
<tr><td><code id="ASM_fetch_dlfn_+3A_extension">extension</code></td>
<td>
<p>File extension for the download (default: &quot;.zip&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character object with the download file name
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creating a state object for testing
sess_res = ASM_test_mksession(session=list(), full_session=FALSE)
state = sess_res$state
dlfn = ASM_fetch_dlfn(state)
dlfn
</code></pre>

<hr>
<h2 id='ASM_fetch_state'>Fetch State Manager State</h2><span id='topic+ASM_fetch_state'></span>

<h3>Description</h3>

<p>Merges default app options with the changes made in the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASM_fetch_state(id, input, session, FM_yaml_file, MOD_yaml_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASM_fetch_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="ASM_fetch_state_+3A_input">input</code></td>
<td>
<p>Shiny input variable</p>
</td></tr>
<tr><td><code id="ASM_fetch_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="ASM_fetch_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="ASM_fetch_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current state of the app including default
values from the yaml file as well as any changes made by the user. The list
has the following structure:
</p>

<ul>
<li><p>yaml: Full contents of the supplied yaml file.
</p>
</li>
<li><p>MC: Module components of the yaml file.
</p>
</li>
<li><p>ASM:
</p>

<ul>
<li><p>isgood: Boolean object indicating if the file was successfully loaded.
</p>
</li>
<li><p>checksum: This is an MD5 sum of the loaded state file
</p>
</li></ul>

</li>
<li><p>MOD_TYPE: Character data containing the type of module <code>"ASM"</code>
</p>
</li>
<li><p>id: Character data containing the module id module in the session variable.
</p>
</li>
<li><p>FM_yaml_file: App configuration file with FM as main section.
</p>
</li>
<li><p>MOD_yaml_file:  Module configuration file with MC as main section.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = ASM_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
input   = sess_res$input

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "formods", "templates", "ASM.yaml")

# We need to specify the ID of the ASM module
id = "ASM"

state = ASM_fetch_state(id           = id,
                        input        = input,
                        session      = session,
                        FM_yaml_file = FM_yaml_file,
                        MOD_yaml_file = MOD_yaml_file)

state
</code></pre>

<hr>
<h2 id='ASM_init_state'>Initialize ASM Module State</h2><span id='topic+ASM_init_state'></span>

<h3>Description</h3>

<p>Creates a list of the initialized module state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASM_init_state(FM_yaml_file, MOD_yaml_file, id, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASM_init_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="ASM_init_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="ASM_init_state_+3A_id">id</code></td>
<td>
<p>ID string for the module.</p>
</td></tr>
<tr><td><code id="ASM_init_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing an empty ASM state
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny the session variable will exist,
# this creates an example here for testing purposes:
sess_res = ASM_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
state = ASM_init_state(
   FM_yaml_file  = system.file(package = "formods",
                               "templates",
                               "formods.yaml"),
   MOD_yaml_file = system.file(package = "formods",
                               "templates",
                               "ASM.yaml"),
   id              = "ASM",
   session         = session)
state
</code></pre>

<hr>
<h2 id='ASM_Server'>Save State Server</h2><span id='topic+ASM_Server'></span>

<h3>Description</h3>

<p>Server function for the Save State Shiny Module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASM_Server(
  id,
  FM_yaml_file = system.file(package = "formods", "templates", "formods.yaml"),
  MOD_yaml_file = system.file(package = "formods", "templates", "ASM.yaml"),
  deployed = FALSE,
  react_state = NULL,
  mod_ids
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASM_Server_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="ASM_Server_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="ASM_Server_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="ASM_Server_+3A_deployed">deployed</code></td>
<td>
<p>Boolean variable indicating whether the app is deployed or not.</p>
</td></tr>
<tr><td><code id="ASM_Server_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
<tr><td><code id="ASM_Server_+3A_mod_ids">mod_ids</code></td>
<td>
<p>Vector of module IDs and order they are needed (used for code generation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>UD Server object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# These are suggested packages
library(shinydashboard)
library(ggpubr)
library(plotly)
library(shinybusy)
library(prompter)
library(utils)
library(clipr)
library(formods)

CSS &lt;- "
.wrapfig {
  float: right;
  shape-margin: 20px;
  margin-right: 20px;
  margin-bottom: 20px;
}
"

# Default to not deployed
if(!exists("deployed")){
  deployed = FALSE
}

#https://fontawesome.com/icons?from=io
data_url =
"https://github.com/john-harrold/formods/raw/master/inst/test_data/TEST_DATA.xlsx"

ui &lt;- dashboardPage(
  skin="black",
  dashboardHeader(title="formods"),
  dashboardSidebar(
     sidebarMenu(
       menuItem("Source Data",     tabName="upload",      icon=icon("table")) ,
       menuItem("Wrangle",         tabName="wrangle",     icon=icon("hat-cowboy")),
       menuItem("Plot",            tabName="plot",        icon=icon("chart-line")),
       menuItem("App State",       tabName="app_state",   icon=icon("archive")),
       menuItem("App Info",        tabName="sysinfo",     icon=icon("book-medical"))
     )
  ),
  dashboardBody(
  tags$head(
    tags$style(HTML(CSS))
  ),
    tabItems(
       tabItem(tabName="app_state",
                 box(title="Manage App State",
                     htmlOutput(NS("ASM", "ui_asm_compact")))),
       tabItem(tabName="upload",
               box(title="Load Data", width=12,
                 fluidRow(
                   prompter::use_prompt(),
                   column(width=6,
                     htmlOutput(NS("UD",  "UD_ui_compact"))),
                   column(width=6,
       tags$p(
           tags$img(
           class = "wrapfig",
           src   = "https://github.com/john-harrold/formods/raw/master/man/figures/logo.png",
           width = 100,
           alt = "formods logo" ),
         'Formods is a set of modules and an framework for developing modules
         which interact and create code to replicate analyses performed within an app.
         To experiment download this',
       tags$a("test dataset", href=data_url),
              'and upload it into the App using the form on the left.'))
                 )
               )
               ),
       tabItem(tabName="wrangle",
               box(title="Transform and Create Views of Your Data", width=12,
               htmlOutput(NS("DW",  "DW_ui_compact")))),
       tabItem(tabName="plot",
               box(title="Visualize Data", width=12,
               htmlOutput(NS("FG",  "FG_ui_compact")))),
       tabItem(tabName="sysinfo",
               box(title="System Details", width=12,
               shinydashboard::tabBox(
                 width = 12,
                 title = NULL,
                 shiny::tabPanel(id="sys_modules",
                          title=tagList(shiny::icon("ghost"),
                                        "Modules"),
                 htmlOutput(NS("ASM", "ui_asm_sys_modules"))
                 ),
                 shiny::tabPanel(id="sys_packages",
                          title=tagList(shiny::icon("ghost"),
                                        "Packages"),
                 htmlOutput(NS("ASM", "ui_asm_sys_packages"))
                 ),
                 shiny::tabPanel(id="sys_log",
                          title=tagList(shiny::icon("clipboard-list"),
                                        "App Log"),
                 verbatimTextOutput(NS("ASM", "ui_asm_sys_log"))
                 ),
                 shiny::tabPanel(id="sys_options",
                          title=tagList(shiny::icon("sliders"),
                                        "R Options"),
                 htmlOutput(NS("ASM", "ui_asm_sys_options"))
                 )
                 )
               ))
      )
    )
  )

# Main app server
server &lt;- function(input, output, session) {
  # Empty reactive object to track and react to
  # changes in the module state outside of the module
  react_FM = reactiveValues()

  # This is the list of module ids used for reproducible script generation. The
  # order here is important.
  mod_ids = c("UD", "DW", "FG")

  #Populating with test data
  FG_test_mksession(session)
  # Module servers
  formods::ASM_Server(id="ASM",
             deployed    = deployed,
             react_state = react_FM, mod_ids = mod_ids)
  formods::UD_Server( id="UD", id_ASM = "ASM",
             deployed    = deployed,
             react_state = react_FM)
  formods::DW_Server( id="DW", id_ASM = "ASM",id_UD = "UD",
             deployed    = deployed,
             react_state = react_FM)
  formods::FG_Server( id="FG", id_ASM = "ASM",id_UD = "UD", id_DW = "DW",
             deployed    = deployed,
             react_state = react_FM)
}

shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='ASM_test_mksession'>Populate Session Data for Module Testing</h2><span id='topic+ASM_test_mksession'></span>

<h3>Description</h3>

<p>Populates the supplied session variable for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASM_test_mksession(
  session,
  id = "ASM",
  id_UD = "UD",
  id_DW = "DW",
  full_session = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASM_test_mksession_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="ASM_test_mksession_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="ASM_test_mksession_+3A_id_ud">id_UD</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the UD modules UI elements</p>
</td></tr>
<tr><td><code id="ASM_test_mksession_+3A_id_dw">id_DW</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the DW modules UI elements</p>
</td></tr>
<tr><td><code id="ASM_test_mksession_+3A_full_session">full_session</code></td>
<td>
<p>Boolean to indicate if the full test session should be created (default <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood: Boolean indicating the exit status of the function.
</p>
</li>
<li><p>session: The value Shiny session variable (in app) or a list (outside of app) after initialization.
</p>
</li>
<li><p>input: The value of the shiny input at the end of the session initialization.
</p>
</li>
<li><p>state: App state.
</p>
</li>
<li><p>rsc: The <code>react_state</code> components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>sess_res = ASM_test_mksession(session=list(), full_session=FALSE)
</code></pre>

<hr>
<h2 id='ASM_write_state'>Write State to File for Saving</h2><span id='topic+ASM_write_state'></span>

<h3>Description</h3>

<p>Called from download handler and used to write a saved state
value if that is null
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ASM_write_state(state, session, file, mod_ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ASM_write_state_+3A_state">state</code></td>
<td>
<p>ASM state from <code>ASM_fetch_state()</code></p>
</td></tr>
<tr><td><code id="ASM_write_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="ASM_write_state_+3A_file">file</code></td>
<td>
<p>File name to write zipped state.</p>
</td></tr>
<tr><td><code id="ASM_write_state_+3A_mod_ids">mod_ids</code></td>
<td>
<p>Vector of module IDs and order they are needed (used for code generation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function only writes the state and has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = ASM_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
input   = sess_res$input

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "formods", "templates", "ASM.yaml")

# We need to specify the ID of the ASM module
id = "ASM"

state = ASM_fetch_state(id           = id,
                        input        = input,
                        session      = session,
                        FM_yaml_file = FM_yaml_file,
                        MOD_yaml_file = MOD_yaml_file)

ASM_write_state(state, session,
                file    = tempfile(fileext=".zip"),
                mod_ids = c("UD"))

</code></pre>

<hr>
<h2 id='autocast'>Automatically Cast UI Input Variable</h2><span id='topic+autocast'></span>

<h3>Description</h3>

<p>Takes UI input and tries to figure out if it's numeric or text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocast(ui_input, quote_char = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocast_+3A_ui_input">ui_input</code></td>
<td>
<p>UI input from a shiny form</p>
</td></tr>
<tr><td><code id="autocast_+3A_quote_char">quote_char</code></td>
<td>
<p>TRUE will include double quotes in the character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Best guess of type casting applied to the ui_input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>number = autocast('10')
text   = autocast('ten')
</code></pre>

<hr>
<h2 id='DW_add_wrangling_element'>Adding Wrangling Element to Current Data View</h2><span id='topic+DW_add_wrangling_element'></span>

<h3>Description</h3>

<p>Adds the wrangling element to the current data view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_add_wrangling_element(state, dwb_res, dwee_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_add_wrangling_element_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
<tr><td><code id="DW_add_wrangling_element_+3A_dwb_res">dwb_res</code></td>
<td>
<p>Output from <code>dwrs_builder()</code></p>
</td></tr>
<tr><td><code id="DW_add_wrangling_element_+3A_dwee_res">dwee_res</code></td>
<td>
<p>Output from <code>dw_eval_element()</code>
returned by <code>UD_fetch_state()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>state with data set attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(formods)
# The example requires a formods DW state object
state  = DW_test_mksession(session=list())$state
state[["DW"]][["ui"]][["select_dw_element"]]          = "filter"
state[["DW"]][["ui"]][["select_fds_filter_column"]]   = "EVID"
state[["DW"]][["ui"]][["select_fds_filter_operator"]] = "=="
state[["DW"]][["ui"]][["fds_filter_rhs"]]             = 0

# This builds the data wrangling statement based on
# elemets scraped from the UI
dwb_res  = dwrs_builder(state)

# Here we evaluate the resulting command:
dwee_res = dw_eval_element(state, dwb_res[["cmd"]])

# Next we add this wrangling element to the state
state    = DW_add_wrangling_element(state, dwb_res, dwee_res)

# This creates a new data view and makes it active
state = DW_new_view(state)

# Here we can pluck out that data view from the state
current_view = DW_fetch_current_view(state)

# This will update the key in this view
current_view[["key"]] = "My new view"

# And this will place it back into the state
state = DW_set_current_view(state, current_view)
</code></pre>

<hr>
<h2 id='DW_append_report'>Append Report Elements</h2><span id='topic+DW_append_report'></span>

<h3>Description</h3>

<p>Takes the current state of the app and appends data views to an
xlsx report object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_append_report(state, rpt, rpttype, gen_code_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_append_report_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
<tr><td><code id="DW_append_report_+3A_rpt">rpt</code></td>
<td>
<p>Report with the current content of the report which will be appended to in
this function. For details on the structure see the documentation for <code><a href="#topic+FM_generate_report">FM_generate_report</a></code>.</p>
</td></tr>
<tr><td><code id="DW_append_report_+3A_rpttype">rpttype</code></td>
<td>
<p>Type of report to generate (supported &quot;xlsx&quot;).</p>
</td></tr>
<tr><td><code id="DW_append_report_+3A_gen_code_only">gen_code_only</code></td>
<td>
<p>Boolean value indicating that only code should be
generated (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasrptele: Boolean indicator if the module has any reportable elements.
</p>
</li>
<li><p>code:      Code to generate reporting elements.
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>rpt:       Report with any additions passed back to the user.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+FM_generate_report">FM_generate_report</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a state object to use below
sess_res = DW_test_mksession(session=list())
state = sess_res$state

rpt = list(summary = list(), sheets=list())

rpt_res = DW_append_report(state,
 rpt     = rpt,
 rpttype = "xlsx")

# Shows if report elements are present
rpt_res$hasrptele

# Code chunk to generate report element
cat(paste(rpt_res$code, collapse="\n"))

# Tabular summary of data views
rpt_res$rpt$summary
</code></pre>

<hr>
<h2 id='DW_attach_ds'>Attach Data Set to DW State</h2><span id='topic+DW_attach_ds'></span>

<h3>Description</h3>

<p>Attaches a dataset to the DW state supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_attach_ds(state, id_UD, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_attach_ds_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
<tr><td><code id="DW_attach_ds_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to handle uploads</p>
</td></tr>
<tr><td><code id="DW_attach_ds_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>state with data set attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

# We also need a state variable
state = sess_res$state

# We need to identify the UD module with the data
id_UD = "UD"
state = DW_attach_ds(state, id_UD, session)
</code></pre>

<hr>
<h2 id='dw_eval_element'>Evaluates Data Wrangling Generated Code</h2><span id='topic+dw_eval_element'></span>

<h3>Description</h3>

<p>Takes the current state and a string containing a data
wranlging command and evaluates it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dw_eval_element(state, cmd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dw_eval_element_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
<tr><td><code id="dw_eval_element_+3A_cmd">cmd</code></td>
<td>
<p>string containing the data wrangling command</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood: Return status of the function.
</p>
</li>
<li><p>msgs:   Messages to be passed back to the user.
</p>
</li>
<li><p>DS:     Wrangled dataset.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(formods)
# The example requires a formods DW state object
state  = DW_test_mksession(session=list())$state
state[["DW"]][["ui"]][["select_dw_element"]]          = "filter"
state[["DW"]][["ui"]][["select_fds_filter_column"]]   = "EVID"
state[["DW"]][["ui"]][["select_fds_filter_operator"]] = "=="
state[["DW"]][["ui"]][["fds_filter_rhs"]]             = 0

# This builds the data wrangling statement based on
# elemets scraped from the UI
dwb_res  = dwrs_builder(state)

# Here we evaluate the resulting command:
dwee_res = dw_eval_element(state, dwb_res[["cmd"]])

# Next we add this wrangling element to the state
state    = DW_add_wrangling_element(state, dwb_res, dwee_res)

# This creates a new data view and makes it active
state = DW_new_view(state)

# Here we can pluck out that data view from the state
current_view = DW_fetch_current_view(state)

# This will update the key in this view
current_view[["key"]] = "My new view"

# And this will place it back into the state
state = DW_set_current_view(state, current_view)
</code></pre>

<hr>
<h2 id='DW_fetch_code'>Fetch Module Code</h2><span id='topic+DW_fetch_code'></span>

<h3>Description</h3>

<p>Fetches the code to generate results seen in the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_fetch_code(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_fetch_code_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
and isgood)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will create a formods DW state object for the example
sess_res = DW_test_mksession(session=list())
state   = sess_res$state
code = DW_fetch_code(state)
cat(code)
</code></pre>

<hr>
<h2 id='DW_fetch_current_view'>Fetches Current Data View</h2><span id='topic+DW_fetch_current_view'></span>

<h3>Description</h3>

<p>Takes a DW state and returns the current active view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_fetch_current_view(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_fetch_current_view_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the details of the active data view. The structure
of this list is the same as the structure of <code>state$DW$views</code> in the output of
<code>DW_fetch_state()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(formods)
# The example requires a formods DW state object
state  = DW_test_mksession(session=list())$state
state[["DW"]][["ui"]][["select_dw_element"]]          = "filter"
state[["DW"]][["ui"]][["select_fds_filter_column"]]   = "EVID"
state[["DW"]][["ui"]][["select_fds_filter_operator"]] = "=="
state[["DW"]][["ui"]][["fds_filter_rhs"]]             = 0

# This builds the data wrangling statement based on
# elemets scraped from the UI
dwb_res  = dwrs_builder(state)

# Here we evaluate the resulting command:
dwee_res = dw_eval_element(state, dwb_res[["cmd"]])

# Next we add this wrangling element to the state
state    = DW_add_wrangling_element(state, dwb_res, dwee_res)

# This creates a new data view and makes it active
state = DW_new_view(state)

# Here we can pluck out that data view from the state
current_view = DW_fetch_current_view(state)

# This will update the key in this view
current_view[["key"]] = "My new view"

# And this will place it back into the state
state = DW_set_current_view(state, current_view)
</code></pre>

<hr>
<h2 id='DW_fetch_ds'>Fetch Module Datasets</h2><span id='topic+DW_fetch_ds'></span>

<h3>Description</h3>

<p>Fetches the datasets contained in the module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_fetch_ds(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_fetch_ds_+3A_state">state</code></td>
<td>
<p>UD state from <code>UD_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
</p>
<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasds:     Boolean indicator if the module has any datasets
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>ds:        List with datasets. Each list element has the name of
the R-object for that dataset. Each element has the following structure:
</p>

<ul>
<li><p>label: Text label for the dataset
</p>
</li>
<li><p>MOD_TYPE: Short name for the type of module.
</p>
</li>
<li><p>id: module ID
</p>
</li>
<li><p>DS: Dataframe containing the actual dataset.
</p>
</li>
<li><p>DSMETA: Metadata describing DS, see <code>FM_fetch_ds()</code> for
details on the format.
</p>
</li>
<li><p>code: Complete code to build dataset.
</p>
</li>
<li><p>checksum: Module checksum.
</p>
</li>
<li><p>DSchecksum: Dataset checksum.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a state variable
sess_res = DW_test_mksession(session=list())
state = sess_res$state

ds = DW_fetch_ds(state)
</code></pre>

<hr>
<h2 id='DW_fetch_state'>Fetch Data Wrangling State</h2><span id='topic+DW_fetch_state'></span>

<h3>Description</h3>

<p>Merges default app options with the changes made in the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_fetch_state(
  id,
  input,
  session,
  FM_yaml_file,
  MOD_yaml_file,
  id_UD,
  react_state
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_fetch_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="DW_fetch_state_+3A_input">input</code></td>
<td>
<p>Shiny input variable</p>
</td></tr>
<tr><td><code id="DW_fetch_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="DW_fetch_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="DW_fetch_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="DW_fetch_state_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to handle uploads or
the name of the list element in react_state where the data set is stored.</p>
</td></tr>
<tr><td><code id="DW_fetch_state_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of
module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the current state of the DM module including default
values from the yaml file as well as any changes made by the user. The
structure of the list is defined below.
</p>

<ul>
<li><p>yaml: Contents of the yaml file.
</p>
</li>
<li><p>MC: Module components of the yaml file.
</p>
</li>
<li><p>DW: Data wrangling state
</p>

<ul>
<li><p>isgood: Boolean status of the state. FALSE if the dataset
identified by id_UD is bad.
</p>
</li>
<li><p>checksum:         MD5 sum indicating if there was a change in the
datasets within the view. Use this to trigger updates in respose to
changes in this module.
</p>
</li>
<li><p>button_counters:  List of counters to detect button clicks.
</p>
</li>
<li><p>code_previous:    Loading code from the UD field.
</p>
</li>
<li><p>current_view:     View id of the current active data wrangling view.
</p>
</li>
<li><p>UD:               Copy of the <code>"UD"</code> field of the  <code>id_UD</code> from the <code>react_state</code> input.
</p>
</li>
<li><p>ui:               Current value of form elements in the UI
</p>
</li>
<li><p>ui_hold:          List of hold elements to disable updates before a full ui referesh is complete.
</p>
</li>
<li><p>view_cntr:        Counter for tracking view ids, value contains the id of the last view created.
</p>
</li>
<li><p>views:            List of data wrangling views. Each view has the following structure:
</p>

<ul>
<li><p>checksum:            MD5 sum of WDS
</p>
</li>
<li><p>code:                Code to generate WDS from start to finish
</p>
</li>
<li><p>code_dw_only:        Code for just the wrangling portion.
</p>
</li>
<li><p>code_previous:       Code to load data and assign to view object.
</p>
</li>
<li><p>elements_table:      Table of data wrangling elements.
</p>
</li>
<li><p>id:                  Character id (<code>view_idx</code>)
</p>
</li>
<li><p>idx:                 Numeric id (<code>1</code>)
</p>
</li>
<li><p>isgood:             Boolean status of the data view. False if evaluation fails
</p>
</li>
<li><p>key:                 User key (short description)
</p>
</li>
<li><p>view_ds_object_name: Object name for this data view
</p>
</li>
<li><p>WDS:                 Current value of the data view with all of the successful commands in elements_table evaluated.
</p>
</li></ul>

</li></ul>

</li>
<li><p>MOD_TYPE: Character data containing the type of module <code>"DW"</code>
</p>
</li>
<li><p>id: Character data containing the module id
</p>
</li>
<li><p>FM_yaml_file: App configuration file with FM as main section.
</p>
</li>
<li><p>MOD_yaml_file:  Module configuration file with MC as main section.
module in the session variable.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

# Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "formods", "templates", "DW.yaml")

# We need to specify both the DW module id as well as the
# id of the UD module that feeds into it.
id    = "DW"
id_UD = "UD"

# Creating an empty state object
state = DW_fetch_state(id              = id,
                       input           = input,
                       session         = session,
                       FM_yaml_file    = FM_yaml_file,
                       MOD_yaml_file   = MOD_yaml_file,
                       id_UD           = "UD",
                       react_state     = NULL)

</code></pre>

<hr>
<h2 id='DW_init_state'>Initialize DW Module State</h2><span id='topic+DW_init_state'></span>

<h3>Description</h3>

<p>Creates a list of the initialized module state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_init_state(FM_yaml_file, MOD_yaml_file, id, id_UD, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_init_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="DW_init_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="DW_init_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="DW_init_state_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to handle uploads or
the name of the list element in react_state where the data set is stored.</p>
</td></tr>
<tr><td><code id="DW_init_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable
module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing an empty DW state
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

state = DW_init_state(
   FM_yaml_file  = system.file(package = "formods",
                               "templates",
                               "formods.yaml"),
   MOD_yaml_file = system.file(package = "formods",
                               "templates",
                               "DW.yaml"),
   id              = "DW",
   id_UD           = "UD",
   session         = session)

state
</code></pre>

<hr>
<h2 id='DW_new_view'>New Data Wrangling View</h2><span id='topic+DW_new_view'></span>

<h3>Description</h3>

<p>Appends a new empty data wrangling view to the DW state object
and makes this new view the active view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_new_view(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_new_view_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>DW state object containing a new data view and that view set as the
current active view. See the help for <code>DW_fetch_state()</code> for view
format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(formods)
# The example requires a formods DW state object
state  = DW_test_mksession(session=list())$state
state[["DW"]][["ui"]][["select_dw_element"]]          = "filter"
state[["DW"]][["ui"]][["select_fds_filter_column"]]   = "EVID"
state[["DW"]][["ui"]][["select_fds_filter_operator"]] = "=="
state[["DW"]][["ui"]][["fds_filter_rhs"]]             = 0

# This builds the data wrangling statement based on
# elemets scraped from the UI
dwb_res  = dwrs_builder(state)

# Here we evaluate the resulting command:
dwee_res = dw_eval_element(state, dwb_res[["cmd"]])

# Next we add this wrangling element to the state
state    = DW_add_wrangling_element(state, dwb_res, dwee_res)

# This creates a new data view and makes it active
state = DW_new_view(state)

# Here we can pluck out that data view from the state
current_view = DW_fetch_current_view(state)

# This will update the key in this view
current_view[["key"]] = "My new view"

# And this will place it back into the state
state = DW_set_current_view(state, current_view)
</code></pre>

<hr>
<h2 id='DW_Server'>Data Wrangling Server</h2><span id='topic+DW_Server'></span>

<h3>Description</h3>

<p>Server function for the data wrangling module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_Server(
  id,
  id_ASM = "ASM",
  id_UD = "UD",
  FM_yaml_file = system.file(package = "formods", "templates", "formods.yaml"),
  MOD_yaml_file = system.file(package = "formods", "templates", "DW.yaml"),
  deployed = FALSE,
  react_state = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_Server_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="DW_Server_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state managment module used to save and load app states</p>
</td></tr>
<tr><td><code id="DW_Server_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to handle uploads or
the name of the list element in react_state where the data set is stored.</p>
</td></tr>
<tr><td><code id="DW_Server_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="DW_Server_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with DW as main section.</p>
</td></tr>
<tr><td><code id="DW_Server_+3A_deployed">deployed</code></td>
<td>
<p>Boolean variable indicating whether the app is deployed or not.</p>
</td></tr>
<tr><td><code id="DW_Server_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of
module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>DW Server object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# These are suggested packages
library(shinydashboard)
library(ggpubr)
library(plotly)
library(shinybusy)
library(prompter)
library(utils)
library(clipr)
library(formods)

CSS &lt;- "
.wrapfig {
  float: right;
  shape-margin: 20px;
  margin-right: 20px;
  margin-bottom: 20px;
}
"

# Default to not deployed
if(!exists("deployed")){
  deployed = FALSE
}

#https://fontawesome.com/icons?from=io
data_url =
"https://github.com/john-harrold/formods/raw/master/inst/test_data/TEST_DATA.xlsx"

ui &lt;- dashboardPage(
  skin="black",
  dashboardHeader(title="formods"),
  dashboardSidebar(
     sidebarMenu(
       menuItem("Source Data",     tabName="upload",      icon=icon("table")) ,
       menuItem("Wrangle",         tabName="wrangle",     icon=icon("hat-cowboy")),
       menuItem("Plot",            tabName="plot",        icon=icon("chart-line")),
       menuItem("App State",       tabName="app_state",   icon=icon("archive")),
       menuItem("App Info",        tabName="sysinfo",     icon=icon("book-medical"))
     )
  ),
  dashboardBody(
  tags$head(
    tags$style(HTML(CSS))
  ),
    tabItems(
       tabItem(tabName="app_state",
                 box(title="Manage App State",
                     htmlOutput(NS("ASM", "ui_asm_compact")))),
       tabItem(tabName="upload",
               box(title="Load Data", width=12,
                 fluidRow(
                   prompter::use_prompt(),
                   column(width=6,
                     htmlOutput(NS("UD",  "UD_ui_compact"))),
                   column(width=6,
       tags$p(
           tags$img(
           class = "wrapfig",
           src   = "https://github.com/john-harrold/formods/raw/master/man/figures/logo.png",
           width = 100,
           alt = "formods logo" ),
         'Formods is a set of modules and an framework for developing modules
         which interact and create code to replicate analyses performed within an app.
         To experiment download this',
       tags$a("test dataset", href=data_url),
              'and upload it into the App using the form on the left.'))
                 )
               )
               ),
       tabItem(tabName="wrangle",
               box(title="Transform and Create Views of Your Data", width=12,
               htmlOutput(NS("DW",  "DW_ui_compact")))),
       tabItem(tabName="plot",
               box(title="Visualize Data", width=12,
               htmlOutput(NS("FG",  "FG_ui_compact")))),
       tabItem(tabName="sysinfo",
               box(title="System Details", width=12,
               shinydashboard::tabBox(
                 width = 12,
                 title = NULL,
                 shiny::tabPanel(id="sys_modules",
                          title=tagList(shiny::icon("ghost"),
                                        "Modules"),
                 htmlOutput(NS("ASM", "ui_asm_sys_modules"))
                 ),
                 shiny::tabPanel(id="sys_packages",
                          title=tagList(shiny::icon("ghost"),
                                        "Packages"),
                 htmlOutput(NS("ASM", "ui_asm_sys_packages"))
                 ),
                 shiny::tabPanel(id="sys_log",
                          title=tagList(shiny::icon("clipboard-list"),
                                        "App Log"),
                 verbatimTextOutput(NS("ASM", "ui_asm_sys_log"))
                 ),
                 shiny::tabPanel(id="sys_options",
                          title=tagList(shiny::icon("sliders"),
                                        "R Options"),
                 htmlOutput(NS("ASM", "ui_asm_sys_options"))
                 )
                 )
               ))
      )
    )
  )

# Main app server
server &lt;- function(input, output, session) {
  # Empty reactive object to track and react to
  # changes in the module state outside of the module
  react_FM = reactiveValues()

  # This is the list of module ids used for reproducible script generation. The
  # order here is important.
  mod_ids = c("UD", "DW", "FG")

  #Populating with test data
  FG_test_mksession(session)
  # Module servers
  formods::ASM_Server(id="ASM",
             deployed    = deployed,
             react_state = react_FM, mod_ids = mod_ids)
  formods::UD_Server( id="UD", id_ASM = "ASM",
             deployed    = deployed,
             react_state = react_FM)
  formods::DW_Server( id="DW", id_ASM = "ASM",id_UD = "UD",
             deployed    = deployed,
             react_state = react_FM)
  formods::FG_Server( id="FG", id_ASM = "ASM",id_UD = "UD", id_DW = "DW",
             deployed    = deployed,
             react_state = react_FM)
}

shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='DW_set_current_view'>Sets Current Data View</h2><span id='topic+DW_set_current_view'></span>

<h3>Description</h3>

<p>Takes a DW state and an updated view and sets that view to the
current view_id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_set_current_view(state, dw_view)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_set_current_view_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
<tr><td><code id="DW_set_current_view_+3A_dw_view">dw_view</code></td>
<td>
<p>Data view list of the format returned from <code>DW_fetch_current_view()</code>
(see the structure of <code>state$DW$views</code> in the output of <code>DW_fetch_state()</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>DW state object with the value of <code>dw_view</code> set to the current view id.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(formods)
# The example requires a formods DW state object
state  = DW_test_mksession(session=list())$state
state[["DW"]][["ui"]][["select_dw_element"]]          = "filter"
state[["DW"]][["ui"]][["select_fds_filter_column"]]   = "EVID"
state[["DW"]][["ui"]][["select_fds_filter_operator"]] = "=="
state[["DW"]][["ui"]][["fds_filter_rhs"]]             = 0

# This builds the data wrangling statement based on
# elemets scraped from the UI
dwb_res  = dwrs_builder(state)

# Here we evaluate the resulting command:
dwee_res = dw_eval_element(state, dwb_res[["cmd"]])

# Next we add this wrangling element to the state
state    = DW_add_wrangling_element(state, dwb_res, dwee_res)

# This creates a new data view and makes it active
state = DW_new_view(state)

# Here we can pluck out that data view from the state
current_view = DW_fetch_current_view(state)

# This will update the key in this view
current_view[["key"]] = "My new view"

# And this will place it back into the state
state = DW_set_current_view(state, current_view)
</code></pre>

<hr>
<h2 id='DW_test_mksession'>Populate Session Data for Module Testing</h2><span id='topic+DW_test_mksession'></span>

<h3>Description</h3>

<p>Populates the supplied session variable for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_test_mksession(session, id = "DW", id_UD = "UD")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_test_mksession_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="DW_test_mksession_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="DW_test_mksession_+3A_id_ud">id_UD</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the UD modules UI elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood: Boolean indicating the exit status of the function.
</p>
</li>
<li><p>session: The value Shiny session variable (in app) or a list (outside of app) after initialization.
</p>
</li>
<li><p>input: The value of the shiny input at the end of the session initialization.
</p>
</li>
<li><p>state: App state.
</p>
</li>
<li><p>rsc: The <code>react_state</code> components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>sess_res = DW_test_mksession(session=list())
</code></pre>

<hr>
<h2 id='DW_update_checksum'>Updates DW Module Checksum</h2><span id='topic+DW_update_checksum'></span>

<h3>Description</h3>

<p>Takes a DW state and updates the checksum used to trigger
downstream updates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DW_update_checksum(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DW_update_checksum_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>DW state object with the checksum updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

# We also need a state variable
state = sess_res$state

state = DW_update_checksum(state)
</code></pre>

<hr>
<h2 id='dwrs_builder'>Builds a Data Wrangling R Statement From ui Elements:</h2><span id='topic+dwrs_builder'></span>

<h3>Description</h3>

<p>Takes the current ui elements and constructs the appropriate
data wrangling command from the user input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwrs_builder(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwrs_builder_+3A_state">state</code></td>
<td>
<p>DW state from <code>DW_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood: Return status of the function
</p>
</li>
<li><p>cmd:    Data wrangling R command
</p>
</li>
<li><p>action: The action being performed
</p>
</li>
<li><p>desc:   Verbose description of the action
</p>
</li>
<li><p>msgs:   Messages to be passed back to the user
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(formods)
# The example requires a formods DW state object
state  = DW_test_mksession(session=list())$state
state[["DW"]][["ui"]][["select_dw_element"]]          = "filter"
state[["DW"]][["ui"]][["select_fds_filter_column"]]   = "EVID"
state[["DW"]][["ui"]][["select_fds_filter_operator"]] = "=="
state[["DW"]][["ui"]][["fds_filter_rhs"]]             = 0

# This builds the data wrangling statement based on
# elemets scraped from the UI
dwb_res  = dwrs_builder(state)

# Here we evaluate the resulting command:
dwee_res = dw_eval_element(state, dwb_res[["cmd"]])

# Next we add this wrangling element to the state
state    = DW_add_wrangling_element(state, dwb_res, dwee_res)

# This creates a new data view and makes it active
state = DW_new_view(state)

# Here we can pluck out that data view from the state
current_view = DW_fetch_current_view(state)

# This will update the key in this view
current_view[["key"]] = "My new view"

# And this will place it back into the state
state = DW_set_current_view(state, current_view)
</code></pre>

<hr>
<h2 id='fers_builder'>Builds a Figure Element R Statement From UI Elements:</h2><span id='topic+fers_builder'></span>

<h3>Description</h3>

<p>Takes the current ui elements and constructs the appropriate
ggplot commands forom the user input. The plot commands assume the existance
of a ggplot object <code>p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fers_builder(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fers_builder_+3A_state">state</code></td>
<td>
<p>FG state from <code>FG_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood: Return status of the function.
</p>
</li>
<li><p>cmd:    ggplot R command as a character string
</p>
</li>
<li><p>element: The type of element being added
</p>
</li>
<li><p>desc:   Verbose description of the element
</p>
</li>
<li><p>msgs:   Messages to be passed back to the user
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
state = sess_res$state
fb_res = fers_builder(state)

</code></pre>

<hr>
<h2 id='fetch_hold'>Fetches the Hold Status UI Element Supplied</h2><span id='topic+fetch_hold'></span>

<h3>Description</h3>

<p>When some buttons are clicked they will change the state of the
system, but other UI components will not detect that change correctly. So those
triggers are put on hold. This will fetch hold status for a specified inputId
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_hold(state, inputId = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_hold_+3A_state">state</code></td>
<td>
<p>module state with all of the current ui elements populated</p>
</td></tr>
<tr><td><code id="fetch_hold_+3A_inputid">inputId</code></td>
<td>
<p>The input ID of the UI element that was put on hold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean value with the hold status
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist, 
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

# For this example we also need a state variable
state = sess_res$state

# This sets a hold on the specified inputID. This is normally done in 
# your XX_fetch_state() function.
state = set_hold(state, inputId = "select_dw_views")

# This will fetch the hold status of the specified inputID. 
fetch_hold(state, inputId = "select_dw_views")

# This will remove the hold and is normally done in one of the UI outputs
# with a priority set to ensure it happens after the rest of the UI has
# refreshed.
state = remove_hold(state, session, inputId = "select_dw_views")
</code></pre>

<hr>
<h2 id='fetch_package_version'>Fetches the Current Version of Pacakge</h2><span id='topic+fetch_package_version'></span>

<h3>Description</h3>

<p>The specified package version is extracted and returned. This
can simply be the version installed from CRAN or if a development version
from GitHub is used details from that will be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_package_version(pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_package_version_+3A_pkgname">pkgname</code></td>
<td>
<p>Name of package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String with the version information
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This package should exist
fetch_package_version('digest')

# This package should not exist
fetch_package_version('bad package name')
</code></pre>

<hr>
<h2 id='FG_append_report'>Append Report Elements</h2><span id='topic+FG_append_report'></span>

<h3>Description</h3>

<p>Description
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_append_report(state, rpt, rpttype, gen_code_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_append_report_+3A_state">state</code></td>
<td>
<p>FG state from <code>FG_fetch_state()</code></p>
</td></tr>
<tr><td><code id="FG_append_report_+3A_rpt">rpt</code></td>
<td>
<p>Report with the current content of the report which will be appended to in
this function. For details on the structure see the documentation for <code><a href="#topic+FM_generate_report">FM_generate_report</a></code>.</p>
</td></tr>
<tr><td><code id="FG_append_report_+3A_rpttype">rpttype</code></td>
<td>
<p>Type of report to generate (supported &quot;xlsx&quot;, &quot;pptx&quot;, &quot;docx&quot;).</p>
</td></tr>
<tr><td><code id="FG_append_report_+3A_gen_code_only">gen_code_only</code></td>
<td>
<p>Boolean value indicating that only code should be
generated (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasrptele: Boolean indicator if the module has any reportable elements.
</p>
</li>
<li><p>code:      Data wrangling R command.
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>rpt:       Report with any additions passed back to the user.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+FM_generate_report">FM_generate_report</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
state = sess_res$state
# This will read in the default PowerPoint report template
rpt =
onbrand::read_template(
 template = system.file(package="onbrand","templates","report.pptx"),
 mapping  = system.file(package="onbrand","templates","report.yaml"))

rpt_res =
FG_append_report(state   = state,    rpt = rpt,
                 rpttype = "pptx", gen_code_only=TRUE)

# Shows if report elements are present
rpt_res$hasrptele

# Code chunk to generate report element
cat(paste(rpt_res$code, collapse="\n"))

</code></pre>

<hr>
<h2 id='FG_build'>Evaluates Figure Generation Code</h2><span id='topic+FG_build'></span>

<h3>Description</h3>

<p>Takes the current state and rebuilds the active figure. If the
elements table has a row flagged for deletion, it will be deleted. If the
cmd input is not NULL it will attempt to append that element to the figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_build(
  state,
  del_row = NULL,
  cmd = NULL,
  element = "unknown",
  desc = "unknown"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_build_+3A_state">state</code></td>
<td>
<p>FG state from <code>FG_fetch_state()</code></p>
</td></tr>
<tr><td><code id="FG_build_+3A_del_row">del_row</code></td>
<td>
<p>Row number to be deleted (NULL if no rows need to be deleted)</p>
</td></tr>
<tr><td><code id="FG_build_+3A_cmd">cmd</code></td>
<td>
<p>String containing the plotting command.  Set to NULL to initialize a
new figure or force a rebuild after a dataset update.</p>
</td></tr>
<tr><td><code id="FG_build_+3A_element">element</code></td>
<td>
<p>Short name for the figure element being performed, eg. point</p>
</td></tr>
<tr><td><code id="FG_build_+3A_desc">desc</code></td>
<td>
<p>Verbose description for the action being performed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood: Return status of the function.
</p>
</li>
<li><p>msgs:   Messages to be passed back to the user.
</p>
</li>
<li><p>pages:  List with each element containing a ggplot object (<code>p</code>) and the code to generate that object (<code>code</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
# Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
input   = sess_res$input

# This will create a populated FG state object:
state   = sess_res$state

# This sets the current active figure to Fig_1
state[["FG"]][["current_fig"]]  =  "Fig_1"

# This is a paginated figure, and we can access a specific
# figure using the following:
pg_1 = FG_extract_page(state, 1)
pg_2 = FG_extract_page(state, 2)

# This will give you access to the current figure directly:
current_fig = FG_fetch_current_fig(state)

# For example this will set the key for that figure:
current_fig$key = "Individual profiles by cohort (multiple pages)"

# Once you're done you can put it back into the state:
state = FG_set_current_fig(state, current_fig)

# If you made any changes to the actual figure, this will
# force a rebuild of the current figure:
state = FG_build( state=state, del_row = NULL, cmd = NULL)

# To create a new empty figure you can do this:
state = FG_new_fig(state)

</code></pre>

<hr>
<h2 id='FG_extract_page'>Extracts Specific Page from Paginated Figure</h2><span id='topic+FG_extract_page'></span>

<h3>Description</h3>

<p>Used to extract the specified page from the current figure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_extract_page(state, page)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_extract_page_+3A_state">state</code></td>
<td>
<p>FG state from <code>FG_fetch_state()</code></p>
</td></tr>
<tr><td><code id="FG_extract_page_+3A_page">page</code></td>
<td>
<p>Page number to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object with the specified page.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
# Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
input   = sess_res$input

# This will create a populated FG state object:
state   = sess_res$state

# This sets the current active figure to Fig_1
state[["FG"]][["current_fig"]]  =  "Fig_1"

# This is a paginated figure, and we can access a specific
# figure using the following:
pg_1 = FG_extract_page(state, 1)
pg_2 = FG_extract_page(state, 2)

# This will give you access to the current figure directly:
current_fig = FG_fetch_current_fig(state)

# For example this will set the key for that figure:
current_fig$key = "Individual profiles by cohort (multiple pages)"

# Once you're done you can put it back into the state:
state = FG_set_current_fig(state, current_fig)

# If you made any changes to the actual figure, this will
# force a rebuild of the current figure:
state = FG_build( state=state, del_row = NULL, cmd = NULL)

# To create a new empty figure you can do this:
state = FG_new_fig(state)

</code></pre>

<hr>
<h2 id='FG_fetch_code'>Fetch Module Code</h2><span id='topic+FG_fetch_code'></span>

<h3>Description</h3>

<p>Fetches the code to generate results seen in the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_fetch_code(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_fetch_code_+3A_state">state</code></td>
<td>
<p>UD state from <code>FG_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This will create a populated FG state object:
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
state   = sess_res$state
code  = FG_fetch_code(state)
cat(paste(code, collapse="\n"))

</code></pre>

<hr>
<h2 id='FG_fetch_current_fig'>Fetches Current Figure</h2><span id='topic+FG_fetch_current_fig'></span>

<h3>Description</h3>

<p>Takes a FG state and returns the current active figure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_fetch_current_fig(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_fetch_current_fig_+3A_state">state</code></td>
<td>
<p>FG state from <code>FG_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the details of the active figure. The structure
of this list is the same as the structure of <code>state$FG$figs</code> in the output of
<code>FG_fetch_state()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
# Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
input   = sess_res$input

# This will create a populated FG state object:
state   = sess_res$state

# This sets the current active figure to Fig_1
state[["FG"]][["current_fig"]]  =  "Fig_1"

# This is a paginated figure, and we can access a specific
# figure using the following:
pg_1 = FG_extract_page(state, 1)
pg_2 = FG_extract_page(state, 2)

# This will give you access to the current figure directly:
current_fig = FG_fetch_current_fig(state)

# For example this will set the key for that figure:
current_fig$key = "Individual profiles by cohort (multiple pages)"

# Once you're done you can put it back into the state:
state = FG_set_current_fig(state, current_fig)

# If you made any changes to the actual figure, this will
# force a rebuild of the current figure:
state = FG_build( state=state, del_row = NULL, cmd = NULL)

# To create a new empty figure you can do this:
state = FG_new_fig(state)

</code></pre>

<hr>
<h2 id='FG_fetch_state'>Fetch Figure Generation State</h2><span id='topic+FG_fetch_state'></span>

<h3>Description</h3>

<p>Merges default app options with the changes made in the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_fetch_state(
  id,
  input,
  session,
  FM_yaml_file,
  MOD_yaml_file,
  id_ASM = NULL,
  id_UD = NULL,
  id_DW = NULL,
  react_state
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_fetch_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="FG_fetch_state_+3A_input">input</code></td>
<td>
<p>Shiny input variable</p>
</td></tr>
<tr><td><code id="FG_fetch_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="FG_fetch_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="FG_fetch_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="FG_fetch_state_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state management module used to save and load app states</p>
</td></tr>
<tr><td><code id="FG_fetch_state_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to handle uploads or the name of the list element in react_state where the data set is stored.</p>
</td></tr>
<tr><td><code id="FG_fetch_state_+3A_id_dw">id_DW</code></td>
<td>
<p>ID string for the data wrangling module to process any uploaded data</p>
</td></tr>
<tr><td><code id="FG_fetch_state_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current state of the app including default
values from the yaml file as well as any changes made by the user. The
structure of the list is defined below:
</p>

<ul>
<li><p>yaml: Contents of the yaml file.
</p>
</li>
<li><p>MC: Module components of the yaml file.
</p>
</li>
<li><p>FG: Data wrangling state
</p>

<ul>
<li><p>isgood: Boolean status of the state. Currently just TRUE
</p>
</li>
<li><p>button_counters:  List of counters to detect button clicks.
</p>
</li>
<li><p>ui_msg:           Message returned when users perform actions.
</p>
</li>
<li><p>ui:               Current value of form elements in the UI.
</p>
</li>
<li><p>ui_ids:           Vector of UI elements for the module.
</p>
</li>
<li><p>ui_hold:          List of hold elements to disable updates before a full ui referesh is complete.
</p>
</li>
<li><p>checksum:          checksum of the FG module used to detect changes in the module.
</p>
</li>
<li><p>aes_elements:     Plot elements defined by aesthetics (i.e. the X in geom_X)
</p>
</li>
<li><p>current_fig:      fig_id of the currently figure.
</p>
</li>
<li><p>fig_cntr:         Counter for figures, incremented each time a new figure is created.
</p>
</li>
<li><p>DSV:              Available data sets from the UD and DW modules.
</p>
</li>
<li><p>figs:             List of figures. Each view has the following structure:
</p>

<ul>
<li><p>add_isgood:    JMH
</p>
</li>
<li><p>checksum:       Checksum of the figure used to detect changes in the figure.
</p>
</li>
<li><p>code:           Code to generate figure from start to finish.
</p>
</li>
<li><p>code_fg_only:   Code to just generate the figure.
</p>
</li>
<li><p>code_previous:  Code to load and/or wrangle the dataset.
</p>
</li>
<li><p>elements_table: Table of figure generation elements.
</p>
</li>
<li><p>fg_object_name: JMH
</p>
</li>
<li><p>fig_dsview:     Name of the dataset view for the current figure (also the R object name of the dataset view).
</p>
</li>
<li><p>fobj:           JMH
</p>
</li>
<li><p>id:             Character id (<code>fig_idx</code>)
</p>
</li>
<li><p>idx:            Numeric id (<code>1</code>)
</p>
</li>
<li><p>isgood:        Boolean status of the figure. FALSE if evaluation/build fails.
</p>
</li>
<li><p>key:            Figure key acts as a title/caption (user editable)
</p>
</li>
<li><p>msgs:           JMH
</p>
</li>
<li><p>notes:          Figure notes  (user editable)
</p>
</li>
<li><p>num_pages:      JMH
</p>
</li>
<li><p>page:           JMH
</p>
</li></ul>

</li></ul>

</li>
<li><p>MOD_TYPE: Character data containing the type of module <code>"DW"</code>
</p>
</li>
<li><p>id: Character data containing the module id module in the session variable.
</p>
</li>
<li><p>FM_yaml_file: App configuration file with FM as main section.
</p>
</li>
<li><p>MOD_yaml_file:  Module configuration file with MC as main section.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Configuration files
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "formods", "templates", "FG.yaml")

# We need to specify both the FG module id as well as the
# id of the UD module that feeds into it.
id    = "FG"
id_UD = "UD"
id_DW = "DW"

# These would be the Shiny input and session variables
input   = list()
session = list()

# Creating an empty state object
state = FG_fetch_state(id              = id,
                       input           = input,
                       session         = session,
                       FM_yaml_file    = FM_yaml_file,
                       MOD_yaml_file   = MOD_yaml_file,
                       id_UD           = id_UD,
                       id_DW           = id_DW,
                       react_state     = NULL)

state
</code></pre>

<hr>
<h2 id='FG_init_state'>Initialize FG Module State</h2><span id='topic+FG_init_state'></span>

<h3>Description</h3>

<p>Creates a list of the initialized module state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_init_state(FM_yaml_file, MOD_yaml_file, id, id_UD, id_DW, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_init_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="FG_init_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="FG_init_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="FG_init_state_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to handle uploads or the name of the list element in react_state where the data set is stored.</p>
</td></tr>
<tr><td><code id="FG_init_state_+3A_id_dw">id_DW</code></td>
<td>
<p>ID string for the data wrangling module to process any uploaded data</p>
</td></tr>
<tr><td><code id="FG_init_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing an empty app state object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These would be the Shiny input and session variables
input   = list()
session = list()

state = FG_init_state(
   FM_yaml_file  = system.file(package = "formods",
                               "templates",
                               "formods.yaml"),
   MOD_yaml_file = system.file(package = "formods",
                               "templates",
                               "FG.yaml"),
   id              = "FG",
   id_UD           = "UD",
   id_DW           = "DW",
   session         = session)

state
</code></pre>

<hr>
<h2 id='FG_new_fig'>Initialize New Figure</h2><span id='topic+FG_new_fig'></span>

<h3>Description</h3>

<p>Creates a new figure in a FG module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_new_fig(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_new_fig_+3A_state">state</code></td>
<td>
<p>FG state from <code>FG_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>FG state object containing a new empty figure  and that figure set as the
current active figure
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
# Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
input   = sess_res$input

# This will create a populated FG state object:
state   = sess_res$state

# This sets the current active figure to Fig_1
state[["FG"]][["current_fig"]]  =  "Fig_1"

# This is a paginated figure, and we can access a specific
# figure using the following:
pg_1 = FG_extract_page(state, 1)
pg_2 = FG_extract_page(state, 2)

# This will give you access to the current figure directly:
current_fig = FG_fetch_current_fig(state)

# For example this will set the key for that figure:
current_fig$key = "Individual profiles by cohort (multiple pages)"

# Once you're done you can put it back into the state:
state = FG_set_current_fig(state, current_fig)

# If you made any changes to the actual figure, this will
# force a rebuild of the current figure:
state = FG_build( state=state, del_row = NULL, cmd = NULL)

# To create a new empty figure you can do this:
state = FG_new_fig(state)

</code></pre>

<hr>
<h2 id='FG_Server'>Figure Generation Server</h2><span id='topic+FG_Server'></span>

<h3>Description</h3>

<p>Server function for the figure generation module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_Server(
  id,
  FM_yaml_file = system.file(package = "formods", "templates", "formods.yaml"),
  MOD_yaml_file = system.file(package = "formods", "templates", "FG.yaml"),
  id_ASM = "ASM",
  id_UD = "UD",
  id_DW = "DW",
  deployed = FALSE,
  react_state = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_Server_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the module's UI function</p>
</td></tr>
<tr><td><code id="FG_Server_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="FG_Server_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="FG_Server_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state management module used to save and load app states</p>
</td></tr>
<tr><td><code id="FG_Server_+3A_id_ud">id_UD</code></td>
<td>
<p>ID string for the upload data module used to handle uploads or the name of the list element in react_state where the data set is stored.</p>
</td></tr>
<tr><td><code id="FG_Server_+3A_id_dw">id_DW</code></td>
<td>
<p>ID string for the data wrangling module to process any uploaded data</p>
</td></tr>
<tr><td><code id="FG_Server_+3A_deployed">deployed</code></td>
<td>
<p>Boolean variable indicating whether the app is deployed or not.</p>
</td></tr>
<tr><td><code id="FG_Server_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>FG Server object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# These are suggested packages
library(shinydashboard)
library(ggpubr)
library(plotly)
library(shinybusy)
library(prompter)
library(utils)
library(clipr)
library(formods)

CSS &lt;- "
.wrapfig {
  float: right;
  shape-margin: 20px;
  margin-right: 20px;
  margin-bottom: 20px;
}
"

# Default to not deployed
if(!exists("deployed")){
  deployed = FALSE
}

#https://fontawesome.com/icons?from=io
data_url =
"https://github.com/john-harrold/formods/raw/master/inst/test_data/TEST_DATA.xlsx"

ui &lt;- dashboardPage(
  skin="black",
  dashboardHeader(title="formods"),
  dashboardSidebar(
     sidebarMenu(
       menuItem("Source Data",     tabName="upload",      icon=icon("table")) ,
       menuItem("Wrangle",         tabName="wrangle",     icon=icon("hat-cowboy")),
       menuItem("Plot",            tabName="plot",        icon=icon("chart-line")),
       menuItem("App State",       tabName="app_state",   icon=icon("archive")),
       menuItem("App Info",        tabName="sysinfo",     icon=icon("book-medical"))
     )
  ),
  dashboardBody(
  tags$head(
    tags$style(HTML(CSS))
  ),
    tabItems(
       tabItem(tabName="app_state",
                 box(title="Manage App State",
                     htmlOutput(NS("ASM", "ui_asm_compact")))),
       tabItem(tabName="upload",
               box(title="Load Data", width=12,
                 fluidRow(
                   prompter::use_prompt(),
                   column(width=6,
                     htmlOutput(NS("UD",  "UD_ui_compact"))),
                   column(width=6,
       tags$p(
           tags$img(
           class = "wrapfig",
           src   = "https://github.com/john-harrold/formods/raw/master/man/figures/logo.png",
           width = 100,
           alt = "formods logo" ),
         'Formods is a set of modules and an framework for developing modules
         which interact and create code to replicate analyses performed within an app.
         To experiment download this',
       tags$a("test dataset", href=data_url),
              'and upload it into the App using the form on the left.'))
                 )
               )
               ),
       tabItem(tabName="wrangle",
               box(title="Transform and Create Views of Your Data", width=12,
               htmlOutput(NS("DW",  "DW_ui_compact")))),
       tabItem(tabName="plot",
               box(title="Visualize Data", width=12,
               htmlOutput(NS("FG",  "FG_ui_compact")))),
       tabItem(tabName="sysinfo",
               box(title="System Details", width=12,
               shinydashboard::tabBox(
                 width = 12,
                 title = NULL,
                 shiny::tabPanel(id="sys_modules",
                          title=tagList(shiny::icon("ghost"),
                                        "Modules"),
                 htmlOutput(NS("ASM", "ui_asm_sys_modules"))
                 ),
                 shiny::tabPanel(id="sys_packages",
                          title=tagList(shiny::icon("ghost"),
                                        "Packages"),
                 htmlOutput(NS("ASM", "ui_asm_sys_packages"))
                 ),
                 shiny::tabPanel(id="sys_log",
                          title=tagList(shiny::icon("clipboard-list"),
                                        "App Log"),
                 verbatimTextOutput(NS("ASM", "ui_asm_sys_log"))
                 ),
                 shiny::tabPanel(id="sys_options",
                          title=tagList(shiny::icon("sliders"),
                                        "R Options"),
                 htmlOutput(NS("ASM", "ui_asm_sys_options"))
                 )
                 )
               ))
      )
    )
  )

# Main app server
server &lt;- function(input, output, session) {
  # Empty reactive object to track and react to
  # changes in the module state outside of the module
  react_FM = reactiveValues()

  # This is the list of module ids used for reproducible script generation. The
  # order here is important.
  mod_ids = c("UD", "DW", "FG")

  #Populating with test data
  FG_test_mksession(session)
  # Module servers
  formods::ASM_Server(id="ASM",
             deployed    = deployed,
             react_state = react_FM, mod_ids = mod_ids)
  formods::UD_Server( id="UD", id_ASM = "ASM",
             deployed    = deployed,
             react_state = react_FM)
  formods::DW_Server( id="DW", id_ASM = "ASM",id_UD = "UD",
             deployed    = deployed,
             react_state = react_FM)
  formods::FG_Server( id="FG", id_ASM = "ASM",id_UD = "UD", id_DW = "DW",
             deployed    = deployed,
             react_state = react_FM)
}

shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='FG_set_current_fig'>Sets Current Figure</h2><span id='topic+FG_set_current_fig'></span>

<h3>Description</h3>

<p>Takes a FG state and a figure list and sets that figure list
as the value for the active figure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_set_current_fig(state, fig)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_set_current_fig_+3A_state">state</code></td>
<td>
<p>FG state from <code>FG_fetch_state()</code></p>
</td></tr>
<tr><td><code id="FG_set_current_fig_+3A_fig">fig</code></td>
<td>
<p>Figure list from <code>FG_fetch_current_fig</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>State with the current figure updated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(formods)
# Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
input   = sess_res$input

# This will create a populated FG state object:
state   = sess_res$state

# This sets the current active figure to Fig_1
state[["FG"]][["current_fig"]]  =  "Fig_1"

# This is a paginated figure, and we can access a specific
# figure using the following:
pg_1 = FG_extract_page(state, 1)
pg_2 = FG_extract_page(state, 2)

# This will give you access to the current figure directly:
current_fig = FG_fetch_current_fig(state)

# For example this will set the key for that figure:
current_fig$key = "Individual profiles by cohort (multiple pages)"

# Once you're done you can put it back into the state:
state = FG_set_current_fig(state, current_fig)

# If you made any changes to the actual figure, this will
# force a rebuild of the current figure:
state = FG_build( state=state, del_row = NULL, cmd = NULL)

# To create a new empty figure you can do this:
state = FG_new_fig(state)

</code></pre>

<hr>
<h2 id='FG_test_mksession'>Populate Session Data for Module Testing</h2><span id='topic+FG_test_mksession'></span>

<h3>Description</h3>

<p>Populates the supplied session variable for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_test_mksession(
  session,
  id = "FG",
  id_UD = "UD",
  id_DW = "DW",
  full_session = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_test_mksession_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="FG_test_mksession_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="FG_test_mksession_+3A_id_ud">id_UD</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the UD modules UI elements</p>
</td></tr>
<tr><td><code id="FG_test_mksession_+3A_id_dw">id_DW</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the DW modules UI elements</p>
</td></tr>
<tr><td><code id="FG_test_mksession_+3A_full_session">full_session</code></td>
<td>
<p>Boolean to indicate if the full test session should be created (default <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood: Boolean indicating the exit status of the function.
</p>
</li>
<li><p>session: The value Shiny session variable (in app) or a list (outside of app) after initialization.
</p>
</li>
<li><p>input: The value of the shiny input at the end of the session initialization.
</p>
</li>
<li><p>state: App state.
</p>
</li>
<li><p>rsc: The <code>react_state</code> components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
sess_res = FG_test_mksession(session=list(), full_session=FALSE)

</code></pre>

<hr>
<h2 id='FG_update_checksum'>Updates FG Module Checksum</h2><span id='topic+FG_update_checksum'></span>

<h3>Description</h3>

<p>Called after any changes to figures, this function will update
the checksum of the module. This allows other modules to determine if there
were any changes to the figures within it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FG_update_checksum(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FG_update_checksum_+3A_state">state</code></td>
<td>
<p>FG state from <code>FG_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>state with checksum updated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will create a populated FG state object:

sess_res = FG_test_mksession(session=list(), full_session=FALSE)
state   = sess_res$state
state = FG_update_checksum(state)

</code></pre>

<hr>
<h2 id='FM_add_ui_tooltip'>Add Tooltip to UI Element</h2><span id='topic+FM_add_ui_tooltip'></span>

<h3>Description</h3>

<p>Adds a tool tip to a user element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_add_ui_tooltip(
  state,
  uiele,
  tooltip = "mytooltip",
  position = "right",
  size = "medium"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_add_ui_tooltip_+3A_state">state</code></td>
<td>
<p>Current module state after yaml file has been read.</p>
</td></tr>
<tr><td><code id="FM_add_ui_tooltip_+3A_uiele">uiele</code></td>
<td>
<p>UI element to add the toooltip to.</p>
</td></tr>
<tr><td><code id="FM_add_ui_tooltip_+3A_tooltip">tooltip</code></td>
<td>
<p>Text containing the tool tip.</p>
</td></tr>
<tr><td><code id="FM_add_ui_tooltip_+3A_position">position</code></td>
<td>
<p>Position of the tooltip.</p>
</td></tr>
<tr><td><code id="FM_add_ui_tooltip_+3A_size">size</code></td>
<td>
<p>size of the tooltip</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If tooltips are enabled and the suggested packages are installed
then a uiele with the tooltip added will be returned. Otherwise it will just
return the original uiele unchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# We need a module state object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
state = sess_res$state
uiele = shiny::textInput(inputId = "my input", label="example input")

uiele = FM_add_ui_tooltip(state, uiele)
}
</code></pre>

<hr>
<h2 id='FM_build_comment'>Create RStudio Formatted Comments</h2><span id='topic+FM_build_comment'></span>

<h3>Description</h3>

<p>Takes a character string and builds a comment so it will be
formatted as a section at the specified level in RStudio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_build_comment(level = 1, comment_str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_build_comment_+3A_level">level</code></td>
<td>
<p>Integer (1 (default),2, or 3) indicating the section level of the comment.</p>
</td></tr>
<tr><td><code id="FM_build_comment_+3A_comment_str">comment_str</code></td>
<td>
<p>Character object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted comment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FM_build_comment(1, "This is a level 1 header")

FM_build_comment(2, paste0(rep("Long string repeated.", 5), collapse=" "))

</code></pre>

<hr>
<h2 id='FM_fetch_app_code'>Fetches the Code to Reproduce Analysis</h2><span id='topic+FM_fetch_app_code'></span>

<h3>Description</h3>

<p>Takes the current state of the app and builds a script to
reproduce the analysis within the app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_app_code(session, state, mod_ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_app_code_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="FM_fetch_app_code_+3A_state">state</code></td>
<td>
<p>module state after yaml read</p>
</td></tr>
<tr><td><code id="FM_fetch_app_code_+3A_mod_ids">mod_ids</code></td>
<td>
<p>Vector of module IDs and order they are needed (used for code generation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements:
</p>

<ul>
<li><p>isgood: Boolean indicating the whether code generation was
successful
(<code>TRUE</code>)
</p>
</li>
<li><p>msgs: Any messages generated
</p>
</li>
<li><p>code: Code to regenerate the app
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a Shiny session object to use this function:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
state   = sess_res$state
app_code = FM_fetch_app_code(session = session,
                             state   = state,
                             mod_ids = c("UD", "DW"))
cat(app_code$code)
</code></pre>

<hr>
<h2 id='FM_fetch_app_info'>Fetches Informaiton About the App</h2><span id='topic+FM_fetch_app_info'></span>

<h3>Description</h3>

<p>Returns diagnostic information about the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_app_info(session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_app_info_+3A_session">session</code></td>
<td>
<p>Shiny session variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with information about the app with the following structure
</p>

<ul>
<li><p>uiele: All system information as UI elements to be used in shiny apps.
</p>
</li>
<li><p>uiele_packages: UI element for installed packages to be used in shiny apps.
</p>
</li>
<li><p>uiele_options:  UI element for current options.
</p>
</li>
<li><p>uiele_modules:  UI element for loaded formods modules to be used in shiny apps.
</p>
</li>
<li><p>msgs:  System information as text to be used in a report/terminal.
</p>
</li>
<li><p>si_packages Dataframe with currently used packages.
</p>
</li>
<li><p>si_options Dataframe with current options
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a Shiny session object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
session = sess_res$session
app_info  = FM_fetch_app_info(session)
app_info$msgs
</code></pre>

<hr>
<h2 id='FM_fetch_app_state'>Fetches the App State</h2><span id='topic+FM_fetch_app_state'></span>

<h3>Description</h3>

<p>Returns the entire state of the App
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_app_state(session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_app_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>App state or NULL if it's not defined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a Shiny session object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
session = sess_res$session
app_state = FM_fetch_app_state(session)
app_state
</code></pre>

<hr>
<h2 id='FM_fetch_current_mods'>Fetches Details About Current Modules</h2><span id='topic+FM_fetch_current_mods'></span>

<h3>Description</h3>

<p>Use this to get information about the currently supported
modules. This includes short names, UI elements,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_current_mods()
</code></pre>


<h3>Value</h3>

<p>list with details about the currently supported modules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FM_fetch_current_mods()
</code></pre>

<hr>
<h2 id='FM_fetch_data_format'>Creates Formatting Information for Datasets</h2><span id='topic+FM_fetch_data_format'></span>

<h3>Description</h3>

<p>Takes a data frame and information in the site configureation
to produce formatting information to make it easier for the user to see data
type information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_data_format(df, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_data_format_+3A_df">df</code></td>
<td>
<p>Raw dataframe to be built into an rhandsontable.</p>
</td></tr>
<tr><td><code id="FM_fetch_data_format_+3A_state">state</code></td>
<td>
<p>Current module state after yaml file has been read.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements:
</p>

<ul>
<li><p>col_heads: List (element for each column) of formatting
information for column  headers to be  use with rhandsontable.
</p>
</li>
<li><p>col_subtext: List (element for each column) of subtext to
be displayed in selections using 'pickerInput' from the 'shinyWidgets' package.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a module state object to use this function:
sess_res = UD_test_mksession(session=list())
state = sess_res$state

data_file_local =  system.file(package="formods", "test_data", "TEST_DATA.xlsx")
sheet           = "DATA"

df = readxl::read_excel(path=data_file_local, sheet=sheet)

hfmt = FM_fetch_data_format(df, state)

# Column header formatting
head(as.vector(unlist( hfmt[["col_heads"]])))

# Column select subtext
head(as.vector(unlist( hfmt[["col_subtext"]])))
</code></pre>

<hr>
<h2 id='FM_fetch_deps'>Fetches Dependency Information</h2><span id='topic+FM_fetch_deps'></span>

<h3>Description</h3>

<p>For a given state and session this function will determine the
module ids that are dependent as well as any packages the module elements
might depend on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_deps(state, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_deps_+3A_state">state</code></td>
<td>
<p>Current module state after yaml file has been read</p>
</td></tr>
<tr><td><code id="FM_fetch_deps_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements:
</p>

<ul>
<li><p>mod_ids  Dependent module ids.
</p>
</li>
<li><p>packages     List of package dependencies.
</p>
</li>
<li><p>package_code Library commands to load packages.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a Shiny session object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
session  = sess_res$session
state    = sess_res$state
mod_deps = FM_fetch_deps(state, session)
</code></pre>

<hr>
<h2 id='FM_fetch_ds'>Fetches Datasets from Modules in the App</h2><span id='topic+FM_fetch_ds'></span>

<h3>Description</h3>

<p>Loops through each specified module ID or all modules if no ID
was specified. For each ID, an attempt will be made to extract any datasets
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_ds(state, session, ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_ds_+3A_state">state</code></td>
<td>
<p>Current module state after yaml file has been read</p>
</td></tr>
<tr><td><code id="FM_fetch_ds_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="FM_fetch_ds_+3A_ids">ids</code></td>
<td>
<p>Vector of ID strings for the modules containing the datasets or
NULL for all datasets available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current dataset with the following format:
</p>

<ul>
<li><p>isgood: Boolean indicating the whether a dataset was found
(<code>FALSE</code>)
</p>
</li>
<li><p>ds: List of datasets with element names corresponding to the
R object name for that dataset. This has the following format
</p>

<ul>
<li><p>label:  Text label for the dataset (used to display to the user)
</p>
</li>
<li><p>DS:     Data frame with the dataset
</p>
</li>
<li><p>DSMETA: Data frame with metadata about the colunns of the
dataset in <code>DS</code>. The data frame should have the following columns:
</p>

<ul>
<li><p>col1: column 1
</p>
</li></ul>

</li>
<li><p>code: Code to generate the dataset.
</p>
</li>
<li><p>checksum: Module checksum when the dataset was pulled
</p>
</li>
<li><p>DSchecksum: Checksum of the dataframe in DS
</p>
</li></ul>

</li>
<li><p>catalog: Dataframe containing the a tabular catalog of the
datasets found.
</p>

<ul>
<li><p>label: Text label
</p>
</li>
<li><p>object: Name of the R Object containing the data frame
</p>
</li>
<li><p>MOD_TYPE: Short name of the type of module
</p>
</li>
<li><p>id: Module ID
</p>
</li>
<li><p>checksum: Module checksum
</p>
</li>
<li><p>DSchecksum: Checksum of the dataset
</p>
</li>
<li><p>code: Code to generate the dataset
</p>
</li></ul>

</li>
<li><p>modules: List with an entry for each module. The element name is
the short name. Each of these is a list with an entry that is the shiny module
ID. For each of these there is a checksum. For example to access the
checksum of a DW module with a  module ID of 'my_id', you would use the
following: <code>res$modules$DW$my_id</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a module state and a Shiny session variable
# to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
session = sess_res$session
state   = sess_res$state
ds = FM_fetch_ds(state, session)
ds$catalog
</code></pre>

<hr>
<h2 id='FM_fetch_log_path'>Fetches the Path to the Log File</h2><span id='topic+FM_fetch_log_path'></span>

<h3>Description</h3>

<p>Use this to get the path to the formods log file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_log_path(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_log_path_+3A_state">state</code></td>
<td>
<p>module state after yaml read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string with the path to the log file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny a session variable will exist,
# this creates one here for testing purposes:
sess_res = UD_test_mksession(session=list())
session = sess_res$session
# This function assumes that some module state exists:
state = UD_init_state(
 FM_yaml_file  = system.file(package = "formods",
                             "templates",
                             "formods.yaml"),
 MOD_yaml_file = system.file(package = "formods",
                             "templates",
                             "UD.yaml"),
 id = "UD",
 session = session)
FM_fetch_log_path(state)
</code></pre>

<hr>
<h2 id='FM_fetch_mdl'>Fetches Models from Modules in the App</h2><span id='topic+FM_fetch_mdl'></span>

<h3>Description</h3>

<p>Loops through each specified module ID or all modules if no ID
was specified. For each ID, an attempt will be made to extract any models
available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_mdl(state, session, ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_mdl_+3A_state">state</code></td>
<td>
<p>Current module state after yaml file has been read</p>
</td></tr>
<tr><td><code id="FM_fetch_mdl_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="FM_fetch_mdl_+3A_ids">ids</code></td>
<td>
<p>Vector of ID strings for the modules containing models or
NULL for all modules with models available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current dataset with the following format:
</p>

<ul>
<li><p>isgood: General logical indicator of successfully.
</p>
</li>
<li><p>hasmdl: Logical indicating if at least one model was found.
</p>
</li>
<li><p>modules: List of module checksums.
</p>
</li>
<li><p>mdl: Result of MM_fetch_mdl, see  <code>vignette("making_modules", package = "formods")</code>
</p>
</li>
<li><p>catalog: Dataframe containing the a tabular catalog of the
models found.
</p>

<ul>
<li><p>label:  Text label for the model.
</p>
</li>
<li><p>object :  Name of the object that contains the compiled rxode2 model.
</p>
</li>
<li><p>MOD_TYPE:  Type of 'formods' module the model came from.
</p>
</li>
<li><p>id: Source 'formods' Module ID.
</p>
</li>
<li><p>checksum: Checksum of the module where the model came from.
</p>
</li>
<li><p>MDLchecksum: Checksum of the model.
</p>
</li>
<li><p>code:  Code to generate the model.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># We need a module state and a Shiny session variable
# to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
session = sess_res$session
state   = sess_res$state
mdl = FM_fetch_mdl(state, session)
mdl$catalog
</code></pre>

<hr>
<h2 id='FM_fetch_mod_state'>Fetch the Module State</h2><span id='topic+FM_fetch_mod_state'></span>

<h3>Description</h3>

<p>Fetches the module state from the userdata under the specified
id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_mod_state(session, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_mod_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable.</p>
</td></tr>
<tr><td><code id="FM_fetch_mod_state_+3A_id">id</code></td>
<td>
<p>ID string for the module.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>module state or NULL if it's not defined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a Shiny session variable to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
session = sess_res$session
state = FM_fetch_mod_state(session, id)
</code></pre>

<hr>
<h2 id='FM_fetch_user_files_path'>Fetches the Path to the User Files</h2><span id='topic+FM_fetch_user_files_path'></span>

<h3>Description</h3>

<p>Use this to get the path to the temporary directory where formods stores user files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_fetch_user_files_path(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_fetch_user_files_path_+3A_state">state</code></td>
<td>
<p>module state after yaml read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string with the path to the log file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a state object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
state = sess_res$state
user_dir = FM_fetch_user_files_path(state)
user_dir
</code></pre>

<hr>
<h2 id='FM_generate_report'>Generate Report</h2><span id='topic+FM_generate_report'></span>

<h3>Description</h3>

<p>Generates a report from the states of the different modules.
The type of report is based on the file extension of file_name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_generate_report(
  state,
  session,
  file_dir,
  file_name,
  gen_code_only = FALSE,
  rpterrors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_generate_report_+3A_state">state</code></td>
<td>
<p>Module state requesting the report generation</p>
</td></tr>
<tr><td><code id="FM_generate_report_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="FM_generate_report_+3A_file_dir">file_dir</code></td>
<td>
<p>path to the location where the file should be written.</p>
</td></tr>
<tr><td><code id="FM_generate_report_+3A_file_name">file_name</code></td>
<td>
<p>base_filename (acceptable extensions are xlsx, docx, or pptx).</p>
</td></tr>
<tr><td><code id="FM_generate_report_+3A_gen_code_only">gen_code_only</code></td>
<td>
<p>Boolean value indicating that only code should be
generated (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="FM_generate_report_+3A_rpterrors">rpterrors</code></td>
<td>
<p>Boolean variable to generate reports with errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will look through the loaded modules and find those with
reporting enabbled. If reporting is enabled it will look for reporting functions
for that module. Reporting functions should be of the following format
(name and arguments):
</p>
<p><code>XX_append_report(state, rpt, rpttype)</code>
</p>
<p>Where <code>XX</code> is the module short name. The state is the current state of the
module. The rpt contains the current content of the report. This will
vary based on the report type:
</p>

<ul>
<li><p>xlsx: List with two elements. The first is <code>summary</code> a data
frame with two columns. The first column is called <code>Sheet_Name</code> and
the second column is called <code>Description</code>. This is a catalog of
sheets added to the report by the user and can be appended to using rbind.
The second element in xlsx rpt is another list with element names
corresponding to the report sheet names and the values corresponding to
dataframes to be exported in the report.
</p>
</li>
<li><p>pptx or docx: Corresponding onbrand reporting object.
</p>
</li></ul>



<h3>Value</h3>

<p>List with the following elements
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
if(interactive()){
sess_res = FG_test_mksession(session=list(), full_session=FALSE)
session = sess_res$session
input   = sess_res$input

# This will create a populated FG state object:
state   = sess_res$state


# This is the directory to write the report:
file_dir = tempdir()

# This is the file name that determines the type of report to write:
file_name = "my_report.pptx"

rpt_res =
FM_generate_report(state         = state,
                   session       = session,
                   file_dir      = file_dir,
                   file_name     = file_name,
                   gen_code_only = TRUE,
                   rpterrors     = TRUE)

# This contains the exit status of the report generation
rpt_res$isgood

# This is the underlying code that was used to generate the report
cat(paste0(rpt_res$code, collapse="\n"))
}
</code></pre>

<hr>
<h2 id='FM_init_state'>Initialize a formods State Object</h2><span id='topic+FM_init_state'></span>

<h3>Description</h3>

<p>Initializes a formods state object with common elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_init_state(
  FM_yaml_file,
  MOD_yaml_file,
  id,
  dep_mod_ids = c(),
  MT,
  button_counters,
  ui_ids,
  ui_hold,
  session
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_init_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="FM_init_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="FM_init_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID.</p>
</td></tr>
<tr><td><code id="FM_init_state_+3A_dep_mod_ids">dep_mod_ids</code></td>
<td>
<p>Vector of module ids this module depends on.</p>
</td></tr>
<tr><td><code id="FM_init_state_+3A_mt">MT</code></td>
<td>
<p>Type of module using the short name (e.g. &quot;UD&quot;, &quot;FG&quot;, etc.).</p>
</td></tr>
<tr><td><code id="FM_init_state_+3A_button_counters">button_counters</code></td>
<td>
<p>Vector of button UI elements that need to be tracked.</p>
</td></tr>
<tr><td><code id="FM_init_state_+3A_ui_ids">ui_ids</code></td>
<td>
<p>List of UI ids in the module.</p>
</td></tr>
<tr><td><code id="FM_init_state_+3A_ui_hold">ui_hold</code></td>
<td>
<p>Vector of UI elements that require holding.</p>
</td></tr>
<tr><td><code id="FM_init_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with state initialized.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny a session variable will exist,
# this creates examples here for testing purposes:
sess_res = UD_test_mksession(session=list())
session = sess_res$session
state = FM_init_state(
   FM_yaml_file  = system.file(package = "formods",
                               "templates",
                               "formods.yaml"),
   MOD_yaml_file = system.file(package = "formods",
                               "templates",
                               "UD.yaml"),
   id              = "UD",
   MT              = "UD",
   button_counters = NULL,
   ui_ids          = NULL,
   ui_hold         = NULL,
   session         = session)

state
</code></pre>

<hr>
<h2 id='FM_le'>Adds Message to Log File and Displays it to the Console</h2><span id='topic+FM_le'></span>

<h3>Description</h3>

<p>Add the supplied txt and the module type to the log file and
display it to the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_le(state, entry, escape_braces = TRUE, entry_type = "alert")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_le_+3A_state">state</code></td>
<td>
<p>Module state after yaml read</p>
</td></tr>
<tr><td><code id="FM_le_+3A_entry">entry</code></td>
<td>
<p>Text to add</p>
</td></tr>
<tr><td><code id="FM_le_+3A_escape_braces">escape_braces</code></td>
<td>
<p>Set to <code>TRUE</code> (default) to escape curly braces in the entry, set to <code>FALSE</code> to have the values interpreted.</p>
</td></tr>
<tr><td><code id="FM_le_+3A_entry_type">entry_type</code></td>
<td>
<p>Set to either &quot;alert&quot;(default), &quot;danger&quot;, &quot;info&quot;, &quot;success&quot;, or &quot;warning&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean value indicating success (<code>TRUE</code>) or failure (<code>FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a module state to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
state   = sess_res$state
FM_le(state, "This is a normal  message")
FM_le(state, "This is a danger  message", entry_type="danger")
FM_le(state, "This is a info    message", entry_type="info")
FM_le(state, "This is a success message", entry_type="success")
FM_le(state, "This is a warning message", entry_type="warning")
</code></pre>

<hr>
<h2 id='FM_message'>Show Message to User</h2><span id='topic+FM_message'></span>

<h3>Description</h3>

<p>Writes a message to the console depending on whether cli is
installed or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_message(line, escape_braces = TRUE, entry_type = "alert")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_message_+3A_line">line</code></td>
<td>
<p>Text to display</p>
</td></tr>
<tr><td><code id="FM_message_+3A_escape_braces">escape_braces</code></td>
<td>
<p>Set to <code>TRUE</code> (default) to escape curly braces in the entry, set to <code>FALSE</code> to have the values interpreted.</p>
</td></tr>
<tr><td><code id="FM_message_+3A_entry_type">entry_type</code></td>
<td>
<p>Set to either &quot;alert&quot;(default), &quot;danger&quot;, &quot;info&quot;, &quot;success&quot;, &quot;warning&quot;, &quot;h1&quot;, &quot;h2&quot;, or &quot;h3&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mr = FM_message("This is a normal  message")
mr = FM_message("This is a danger  message", entry_type="danger")
mr = FM_message("This is a info    message", entry_type="info")
mr = FM_message("This is a success message", entry_type="success")
mr = FM_message("This is a warning message", entry_type="warning")
mr = FM_message("This is an H1 header",      entry_type="h1")
mr = FM_message("This is an H2 header",      entry_type="h2")
mr = FM_message("This is an H3 header",      entry_type="h3")
</code></pre>

<hr>
<h2 id='FM_mk_error_fig'>Generates 'ggplot' Object with Error Message</h2><span id='topic+FM_mk_error_fig'></span>

<h3>Description</h3>

<p>Takes a vector of messages and returns a ggplot object with the
text in the figure. This can be used in automated figure generation to
cascade an error message to the end user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_mk_error_fig(msgs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_mk_error_fig_+3A_msgs">msgs</code></td>
<td>
<p>Vector of error messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>FM_mk_error_fig("Oh nos! You've made a mistake!")
</code></pre>

<hr>
<h2 id='FM_notify'>Shiny Notification</h2><span id='topic+FM_notify'></span>

<h3>Description</h3>

<p>Generates a notification that should only show once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_notify(state, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_notify_+3A_state">state</code></td>
<td>
<p>Module state generating the notification</p>
</td></tr>
<tr><td><code id="FM_notify_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean variable indicating if the notification was triggered
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(formods)
library(shiny)
library(shinydashboard)
#https://fontawesome.com/icons?from=io

ui &lt;- dashboardPage(
  skin="red",
  dashboardHeader(title="Test Notifications"),
  dashboardSidebar(
     sidebarMenu(
       menuItem("Notifications",    tabName="example",  icon=icon("table"))
     )
  ),
  dashboardBody(
    tabItems(
       tabItem(tabName="example",
        fluidRow(
          shiny::actionButton("set_notification", "Set Notification"),
          shiny::textInput("user_text", label="Notify Text Here", value="Notify me"),
          shiny::actionButton("show_notification", "Show Notification")
         )
       )
     )
   )
 )

# Main app server
server &lt;- function(input, output, session) {

  # Need formods state object
  sess_res = UD_test_mksession(session, id="UD")

  # Captures input and sets the notification
  observeEvent(input$set_notification, {

    state = FM_fetch_mod_state(session, id="UD")
    state = FM_set_notification(state,
                                notify_text = isolate(input$user_text),
                                notify_id   = "example")
    FM_set_mod_state(session, id="UD", state)
   })


  # Displays the notification
  observeEvent(input$show_notification, {
    state = FM_fetch_mod_state(session, id="UD")
    FM_notify(state, session)
   })
}

shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='FM_pause_screen'>Starts Modal Screen Pause</h2><span id='topic+FM_pause_screen'></span>

<h3>Description</h3>

<p>Start a modal screen pause.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_pause_screen(state, session, message)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_pause_screen_+3A_state">state</code></td>
<td>
<p>Current module state after yaml file has been read.</p>
</td></tr>
<tr><td><code id="FM_pause_screen_+3A_session">session</code></td>
<td>
<p>Shiny session variable.</p>
</td></tr>
<tr><td><code id="FM_pause_screen_+3A_message">message</code></td>
<td>
<p>Optional message for the pause.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pauses the screen and has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a module state object and Shiny session objects to use this function:
sess_res = UD_test_mksession(session=list())
session = sess_res$session
state = sess_res$state
FM_pause_screen(state, session)
FM_resume_screen(state, session)
</code></pre>

<hr>
<h2 id='FM_pretty_sort'>Centralized Sorting Function</h2><span id='topic+FM_pretty_sort'></span>

<h3>Description</h3>

<p>When displaying information in a pull down this function can
be used to sort those options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_pretty_sort(unsrt_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_pretty_sort_+3A_unsrt_data">unsrt_data</code></td>
<td>
<p>Unsorted data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is the full path to a test data file:
data_file_local  =  system.file(package="formods", "test_data", "TEST_DATA.xlsx")
# Excel files need a sheet specification:
sheet           = "DATA"
# We will also attach the sheets along with it
df = readxl::read_excel(path=data_file_local, sheet=sheet)
# Regular sorting:
sort(unique(df$Cohort))
FM_pretty_sort(unique(df$Cohort))
</code></pre>

<hr>
<h2 id='FM_proc_include'>Sets Message in State from UI Processing</h2><span id='topic+FM_proc_include'></span>

<h3>Description</h3>

<p>Any errors that need to be passed back to the user can be set
with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_proc_include(state, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_proc_include_+3A_state">state</code></td>
<td>
<p>formods State object.</p>
</td></tr>
<tr><td><code id="FM_proc_include_+3A_session">session</code></td>
<td>
<p>Shiny session variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, sets message in supplied session variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a module state object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
state = sess_res$state
session = sess_res$session
FM_proc_include(state, session)
</code></pre>

<hr>
<h2 id='FM_resume_screen'>Stops Modal Screen Pause</h2><span id='topic+FM_resume_screen'></span>

<h3>Description</h3>

<p>Stops Modal Screen Pause
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_resume_screen(state, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_resume_screen_+3A_state">state</code></td>
<td>
<p>Current module state after yaml file has been read.</p>
</td></tr>
<tr><td><code id="FM_resume_screen_+3A_session">session</code></td>
<td>
<p>Shiny session variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to disable screen pause.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a module state object and Shiny session objects to use this function:
sess_res = UD_test_mksession(session=list())
session = sess_res$session
state = sess_res$state
FM_pause_screen(state, session)
FM_resume_screen(state, session)
</code></pre>

<hr>
<h2 id='FM_set_app_state'>Set the App State</h2><span id='topic+FM_set_app_state'></span>

<h3>Description</h3>

<p>Takes a loaded app state and overwrites the current app state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_set_app_state(session, app_state, set_holds = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_set_app_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable.</p>
</td></tr>
<tr><td><code id="FM_set_app_state_+3A_app_state">app_state</code></td>
<td>
<p>Loaded app state.</p>
</td></tr>
<tr><td><code id="FM_set_app_state_+3A_set_holds">set_holds</code></td>
<td>
<p>If TRUE (default) the holds will be set for all of the
modules present in the app state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, just updates the app state in the session variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a Shiny session object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
session = sess_res$session
app_state = FM_fetch_app_state(session)
FM_set_app_state(session, app_state)
</code></pre>

<hr>
<h2 id='FM_set_mod_state'>Set the Module State</h2><span id='topic+FM_set_mod_state'></span>

<h3>Description</h3>

<p>Sets the module state from the userdata under the specified
id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_set_mod_state(session, id, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_set_mod_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="FM_set_mod_state_+3A_id">id</code></td>
<td>
<p>ID string for the module.</p>
</td></tr>
<tr><td><code id="FM_set_mod_state_+3A_state">state</code></td>
<td>
<p>Module state to set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Session variable with the module state set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a Shiny session variable and a module state
# object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
session = sess_res$session
state   = sess_res$state
FM_set_mod_state(session, id, state)
</code></pre>

<hr>
<h2 id='FM_set_notification'>Shiny Notification</h2><span id='topic+FM_set_notification'></span>

<h3>Description</h3>

<p>Generates a notification that should only show once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_set_notification(state, notify_text, notify_id, type = "info")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_set_notification_+3A_state">state</code></td>
<td>
<p>Module state generating the notification</p>
</td></tr>
<tr><td><code id="FM_set_notification_+3A_notify_text">notify_text</code></td>
<td>
<p>Text to go in the notification</p>
</td></tr>
<tr><td><code id="FM_set_notification_+3A_notify_id">notify_id</code></td>
<td>
<p>Unique string for this notification</p>
</td></tr>
<tr><td><code id="FM_set_notification_+3A_type">type</code></td>
<td>
<p>- Can be either &quot;success&quot;, &quot;failure&quot;, &quot;info&quot; (default), or
&quot;warning&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Module state with notification text set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
library(formods)
library(shiny)
library(shinydashboard)
#https://fontawesome.com/icons?from=io

ui &lt;- dashboardPage(
  skin="red",
  dashboardHeader(title="Test Notifications"),
  dashboardSidebar(
     sidebarMenu(
       menuItem("Notifications",    tabName="example",  icon=icon("table"))
     )
  ),
  dashboardBody(
    tabItems(
       tabItem(tabName="example",
        fluidRow(
          shiny::actionButton("set_notification", "Set Notification"),
          shiny::textInput("user_text", label="Notify Text Here", value="Notify me"),
          shiny::actionButton("show_notification", "Show Notification")
         )
       )
     )
   )
 )

# Main app server
server &lt;- function(input, output, session) {

  # Need formods state object
  sess_res = UD_test_mksession(session, id="UD")

  # Captures input and sets the notification
  observeEvent(input$set_notification, {

    state = FM_fetch_mod_state(session, id="UD")
    state = FM_set_notification(state,
                                notify_text = isolate(input$user_text),
                                notify_id   = "example")
    FM_set_mod_state(session, id="UD", state)
   })


  # Displays the notification
  observeEvent(input$show_notification, {
    state = FM_fetch_mod_state(session, id="UD")
    FM_notify(state, session)
   })
}

shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='FM_set_ui_msg'>Sets Message in State from UI Processing</h2><span id='topic+FM_set_ui_msg'></span>

<h3>Description</h3>

<p>Any errors that need to be passed back to the user can be set
with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_set_ui_msg(state, msgs, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_set_ui_msg_+3A_state">state</code></td>
<td>
<p>formods State object.</p>
</td></tr>
<tr><td><code id="FM_set_ui_msg_+3A_msgs">msgs</code></td>
<td>
<p>Character vector of messages.</p>
</td></tr>
<tr><td><code id="FM_set_ui_msg_+3A_append">append</code></td>
<td>
<p>When <code>TRUE</code>, msgs will be appended to any current messages. When
<code>FALSE</code> (default) msgs will replace any existing messaages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>state with ui message set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a module state object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list(), id=id)
state = sess_res$state
state = FM_set_ui_msg(state, "Something happend.")
</code></pre>

<hr>
<h2 id='FM_tc'>Run Try/Catch and Process Results</h2><span id='topic+FM_tc'></span>

<h3>Description</h3>

<p>Attempts to execute the text in cmd. This is done in a
try/catch environment to capture any errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FM_tc(cmd, tc_env, capture)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FM_tc_+3A_cmd">cmd</code></td>
<td>
<p>Character object containing the R command to evaluate in the try/catch block</p>
</td></tr>
<tr><td><code id="FM_tc_+3A_tc_env">tc_env</code></td>
<td>
<p>list of with names corresponding to object names and
corresponding Values to define in the try/catch environment</p>
</td></tr>
<tr><td><code id="FM_tc_+3A_capture">capture</code></td>
<td>
<p>Character vector of values to capture after the command is
successfully captured</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following fields:
</p>

<ul>
<li><p>isgood: Boolean indicating the whether the evaluation was
successful.
</p>
</li>
<li><p>error: If the evaluation failed this contains the error object.
</p>
</li>
<li><p>msgs: Character vector of messages and/or errors.
</p>
</li>
<li><p>capture: List with names of objects to be captured and values
corresponding to those captured objects.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Successful command
res_good = FM_tc("good_cmd=ls()", list(), c("good_cmd"))
res_good

# Failed command
res_bad = FM_tc("bad_cmd =not_a_command()", list(), c("bad_cmd"))
res_bad
</code></pre>

<hr>
<h2 id='formods_check'>Checks 'formods' Dependencies</h2><span id='topic+formods_check'></span>

<h3>Description</h3>

<p>Looks at the suggested dependencies and checks to make sure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formods_check(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formods_check_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating if messages should be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following elements:
</p>

<ul>
<li><p>all_found:    Boolean indicating if all packages were found
</p>
</li>
<li><p>found_pkgs:   Character vector of found packages
</p>
</li>
<li><p>missing_pkgs: Character vector of missing packages
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>fcres = formods_check()
</code></pre>

<hr>
<h2 id='has_changed'>Detect if a UI element has changed</h2><span id='topic+has_changed'></span>

<h3>Description</h3>

<p>Takes a UI element value and an older value and determines if
it has been modified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_changed(ui_val = NULL, old_val = NULL, init_value = c(""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_changed_+3A_ui_val">ui_val</code></td>
<td>
<p>Current value from the UI.</p>
</td></tr>
<tr><td><code id="has_changed_+3A_old_val">old_val</code></td>
<td>
<p>Last value of of the element.</p>
</td></tr>
<tr><td><code id="has_changed_+3A_init_value">init_value</code></td>
<td>
<p>Default value for reading in UI data when it has not been
defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean result of the comparison
</p>


<h3>Examples</h3>

<pre><code class='language-R'>changed_true  = has_changed(ui_val = "a", old_val = "")
changed_true
changed_false = has_changed(ui_val = "a", old_val = "a")
changed_false
</code></pre>

<hr>
<h2 id='has_updated'>Detect if a UI element has updated</h2><span id='topic+has_updated'></span>

<h3>Description</h3>

<p>Takes a UI element value and an older value and determines if
it has been modified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_updated(ui_val = NULL, old_val = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_updated_+3A_ui_val">ui_val</code></td>
<td>
<p>Current value from the UI.</p>
</td></tr>
<tr><td><code id="has_updated_+3A_old_val">old_val</code></td>
<td>
<p>Last value of of the element.
defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean result of the comparison
</p>


<h3>Examples</h3>

<pre><code class='language-R'>changed_true  = has_updated(ui_val = "a", old_val = "")
changed_true
changed_false = has_updated(ui_val = "a", old_val = "a")
changed_false
</code></pre>

<hr>
<h2 id='icon_link'>Creates Icon Link</h2><span id='topic+icon_link'></span>

<h3>Description</h3>

<p>Creates a link to a Shiny icon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>icon_link(href, target = "_blank", icon_name = "circle-info")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="icon_link_+3A_href">href</code></td>
<td>
<p>URL to link to.</p>
</td></tr>
<tr><td><code id="icon_link_+3A_target">target</code></td>
<td>
<p>New tab name.</p>
</td></tr>
<tr><td><code id="icon_link_+3A_icon_name">icon_name</code></td>
<td>
<p>Name of icon to use (arguemnt to shiny::icon, default: &quot;circle-info&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a shiny.tag class that can be converted into an HTML string via as.character() and saved to a file with save_html(). Note if href is <code>NULL</code> then <code>NULL</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>icon_link(href="https://formods.ubiquity.tools")
</code></pre>

<hr>
<h2 id='is_installed'>Determines if a Package is Installed</h2><span id='topic+is_installed'></span>

<h3>Description</h3>

<p>Determines if the specified package is installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_installed(pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_installed_+3A_pkgname">pkgname</code></td>
<td>
<p>Name of package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating if the packages is installed or not
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This package should exist
is_installed('digest')

# This package should not exist
is_installed('bad package name')
</code></pre>

<hr>
<h2 id='linspace'>Implementation of the <code>linspace</code> Function from Matlab</h2><span id='topic+linspace'></span>

<h3>Description</h3>

<p>Creates a vector of n elements equally spaced apart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linspace(a, b, n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linspace_+3A_a">a</code></td>
<td>
<p>initial number</p>
</td></tr>
<tr><td><code id="linspace_+3A_b">b</code></td>
<td>
<p>final number</p>
</td></tr>
<tr><td><code id="linspace_+3A_n">n</code></td>
<td>
<p>number of elements  (integer &gt;= 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of numbers from <code>a</code> to <code>b</code> with
<code>n</code> linearly spaced apart
</p>


<h3>Examples</h3>

<pre><code class='language-R'>linspace(0,100, 20)
</code></pre>

<hr>
<h2 id='new_module_template'>Makes Template Files for formods New Module</h2><span id='topic+new_module_template'></span>

<h3>Description</h3>

<p>If you want to create a new formods module this function will
create the template files for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_module_template(
  SN = "NM",
  Module_Name = "New Module",
  package = "pkgname",
  element = "analysis",
  file_dir = tempdir()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_module_template_+3A_sn">SN</code></td>
<td>
<p>Module short name</p>
</td></tr>
<tr><td><code id="new_module_template_+3A_module_name">Module_Name</code></td>
<td>
<p>Module long name</p>
</td></tr>
<tr><td><code id="new_module_template_+3A_package">package</code></td>
<td>
<p>Name of package that will contain the module</p>
</td></tr>
<tr><td><code id="new_module_template_+3A_element">element</code></td>
<td>
<p>What you would call the thing the module provides for example
the FG module provides &quot;figures&quot;, the DW module provides &quot;data views&quot;.</p>
</td></tr>
<tr><td><code id="new_module_template_+3A_file_dir">file_dir</code></td>
<td>
<p>Directory to save file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements:
</p>

<ul>
<li><p>mc:     Module components.
</p>
</li>
<li><p>server: Server.R file.
</p>
</li>
<li><p>yaml:   Yaml configureation file.
</p>
</li></ul>

<p>Each of these is a list with paths to the respective files:
</p>

<ul>
<li><p>source:     Template source.
</p>
</li>
<li><p>dest:       Destination file name.
</p>
</li>
<li><p>dest_full:  Full path to the destination file name.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>new_module_template()

</code></pre>

<hr>
<h2 id='remove_hold'>Removes Hold on UI Element</h2><span id='topic+remove_hold'></span>

<h3>Description</h3>

<p>When some buttons are clicked they will change the state of the
system, but other UI components will not detect that change correctly. So those
triggers are put on hold. This will remove the hold after those UI
components have updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_hold(state, session, inputId)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_hold_+3A_state">state</code></td>
<td>
<p>module state with all of the current ui elements populated</p>
</td></tr>
<tr><td><code id="remove_hold_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="remove_hold_+3A_inputid">inputId</code></td>
<td>
<p>The input ID of the UI element that was put on hold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to remove holds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist, 
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

# For this example we also need a state variable
state = sess_res$state

# This sets a hold on the specified inputID. This is normally done in 
# your XX_fetch_state() function.
state = set_hold(state, inputId = "select_dw_views")

# This will fetch the hold status of the specified inputID. 
fetch_hold(state, inputId = "select_dw_views")

# This will remove the hold and is normally done in one of the UI outputs
# with a priority set to ensure it happens after the rest of the UI has
# refreshed.
state = remove_hold(state, session, inputId = "select_dw_views")
</code></pre>

<hr>
<h2 id='set_hold'>Sets Hold on One or All UI Elements</h2><span id='topic+set_hold'></span>

<h3>Description</h3>

<p>When some buttons are clicked they will change the state of the
system, but other UI components will not detect that change correctly. So those
triggers are put on hold. This will set the hold for a specified inputId or
all ids if that value is set to NULL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_hold(state, inputId = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_hold_+3A_state">state</code></td>
<td>
<p>module state with all of the current ui elements populated</p>
</td></tr>
<tr><td><code id="set_hold_+3A_inputid">inputId</code></td>
<td>
<p>The input ID of the UI element that was put on hold or
<code>NULL</code> to hold all IDs in the module</p>
</td></tr>
</table>


<h3>Value</h3>

<p>state with hold or holds set
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny both session and input variables will exist, 
# this creates examples here for testing purposes:
sess_res = DW_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input

# For this example we also need a state variable
state = sess_res$state

# This sets a hold on the specified inputID. This is normally done in 
# your XX_fetch_state() function.
state = set_hold(state, inputId = "select_dw_views")

# This will fetch the hold status of the specified inputID. 
fetch_hold(state, inputId = "select_dw_views")

# This will remove the hold and is normally done in one of the UI outputs
# with a priority set to ensure it happens after the rest of the UI has
# refreshed.
state = remove_hold(state, session, inputId = "select_dw_views")
</code></pre>

<hr>
<h2 id='UD_attach_ds'>Attach Data Set to UD State</h2><span id='topic+UD_attach_ds'></span>

<h3>Description</h3>

<p>Attaches a dataset to the UD state supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD_attach_ds(
  state,
  clean = NULL,
  isgood = TRUE,
  load_msg = NULL,
  data_file_local = NULL,
  data_file_ext = NULL,
  data_file = NULL,
  sheet = NULL,
  sheets = NULL,
  code = "",
  object_name = NULL,
  contents = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UD_attach_ds_+3A_state">state</code></td>
<td>
<p>UD state module.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_clean">clean</code></td>
<td>
<p>Boolean switch to determine if the headers in the loaded dataset was cleaned.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_isgood">isgood</code></td>
<td>
<p>Boolean object indicating if the file was successfully loaded.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_load_msg">load_msg</code></td>
<td>
<p>Text message indicated the success or any problems encountered when uploading the file.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_data_file_local">data_file_local</code></td>
<td>
<p>Full path to the data file on the server.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_data_file_ext">data_file_ext</code></td>
<td>
<p>File extension of the uploaded file.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_data_file">data_file</code></td>
<td>
<p>Dataset file name without the path.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_sheet">sheet</code></td>
<td>
<p>If the uploaded file is an excel file, this is the currently selected sheet.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_sheets">sheets</code></td>
<td>
<p>If the uploaded file is an excel file, this is a character vector of the sheets present in that file.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_code">code</code></td>
<td>
<p>Code to load dataset.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_object_name">object_name</code></td>
<td>
<p>Name of the dataset object created when code is evaluated.</p>
</td></tr>
<tr><td><code id="UD_attach_ds_+3A_contents">contents</code></td>
<td>
<p>Data frame containting the contents of the data file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>state with data set attached
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a module state object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list())
state = sess_res$state

# This is the full path to a test data file:
data_file_local  =  system.file(package="formods", "test_data", "TEST_DATA.xlsx")

# Excel file extension
data_file_ext    = "xlsx"

# Base file name
data_file        = "TEST_DATA.xlsx"

# Excel files need a sheet specification:
sheet           = "DATA"

# We will also attach the sheets along with it
sheets = readxl::excel_sheets(data_file_local)

ds_read_res = UD_ds_read(state,
  data_file_ext   = data_file_ext,
  data_file_local = data_file_local,
  data_file       = data_file,
  sheets          = sheets,
  sheet          = sheet)

# This would contain the loading code that will cascade down
# to the other modules when generating snippets and
# reproducible scripts
code = ds_read_res$code

# This is the R Object name that is used internally
# and in generated scripts. Should be the same as in
# the code above
object_name = ds_read_res$object_name

# This is the actual dataset:
contents   = ds_read_res$contents

state =  UD_attach_ds(
         state,
         data_file_local = data_file_local,
         data_file_ext   = ".xlsx",
         data_file       = data_file,
         sheet           = sheet,
         sheets          = sheets,
         code            = code,
         object_name     = object_name,
         contents        = contents)

state
</code></pre>

<hr>
<h2 id='UD_ds_read'>Generate Code and Load DS</h2><span id='topic+UD_ds_read'></span>

<h3>Description</h3>

<p>Generates the code for loading a dataset and returns both the
code and the contents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD_ds_read(
  state,
  data_file_ext = NULL,
  data_file_local = NULL,
  data_file = NULL,
  sheets = NULL,
  sheet = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UD_ds_read_+3A_state">state</code></td>
<td>
<p>UD state from <code>UD_fetch_state()</code></p>
</td></tr>
<tr><td><code id="UD_ds_read_+3A_data_file_ext">data_file_ext</code></td>
<td>
<p>File extension of the uploaded file (e.g. &quot;xlsx&quot;,
&quot;csv&quot;, etc).</p>
</td></tr>
<tr><td><code id="UD_ds_read_+3A_data_file_local">data_file_local</code></td>
<td>
<p>Full path to the data file on the server.</p>
</td></tr>
<tr><td><code id="UD_ds_read_+3A_data_file">data_file</code></td>
<td>
<p>Dataset file name without the path.</p>
</td></tr>
<tr><td><code id="UD_ds_read_+3A_sheets">sheets</code></td>
<td>
<p>If the uploaded file is an excel file, this is a character vector of the sheets present in that file.</p>
</td></tr>
<tr><td><code id="UD_ds_read_+3A_sheet">sheet</code></td>
<td>
<p>If the uploaded file is an excel file, this is the currently selected sheet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the elements of the dataset (contents, object_name, code,
and isgood)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We need a module state object to use this function:
id="UD"
sess_res = UD_test_mksession(session=list())
state = sess_res$state

# This is the full path to a test data file:
data_file_local  =  system.file(package="formods", "test_data", "TEST_DATA.xlsx")

# Excel file extension
data_file_ext    = "xlsx"

# Base file name
data_file        = "TEST_DATA.xlsx"

# Excel files need a sheet specification:
sheet            = "DATA"

# We will also attach the sheets along with it
sheets = readxl::excel_sheets(data_file_local)

ds_read_res = UD_ds_read(state,
  data_file_ext   = data_file_ext,
  data_file_local = data_file_local,
  data_file       = data_file,
  sheets          = sheets,
  sheet          = sheet)

ds_read_res
</code></pre>

<hr>
<h2 id='UD_fetch_code'>Fetch Module Code</h2><span id='topic+UD_fetch_code'></span>

<h3>Description</h3>

<p>Fetches the code to generate results seen in the app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD_fetch_code(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UD_fetch_code_+3A_state">state</code></td>
<td>
<p>UD state from <code>UD_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This creates a session variable that will be available in Shiny
state = UD_test_mksession(session=list())$state
UD_fetch_code(state)
</code></pre>

<hr>
<h2 id='UD_fetch_ds'>Fetch Module Datasets</h2><span id='topic+UD_fetch_ds'></span>

<h3>Description</h3>

<p>Fetches the datasets contained in the module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD_fetch_ds(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UD_fetch_ds_+3A_state">state</code></td>
<td>
<p>UD state from <code>UD_fetch_state()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character object vector with the lines of code
</p>
<p>list containing the following elements
</p>

<ul>
<li><p>isgood:    Return status of the function.
</p>
</li>
<li><p>hasds:     Boolean indicator if the module has any datasets
</p>
</li>
<li><p>msgs:      Messages to be passed back to the user.
</p>
</li>
<li><p>ds:        List with datasets. Each list element has the name of
the R-object for that dataset. Each element has the following structure:
</p>

<ul>
<li><p>label: Text label for the dataset
</p>
</li>
<li><p>MOD_TYPE: Short name for the type of module.
</p>
</li>
<li><p>id: module ID
</p>
</li>
<li><p>DS: Dataframe containing the actual dataset.
</p>
</li>
<li><p>DSMETA: Metadata describing DS, see <code>FM_fetch_ds()</code> for
details on the format.
</p>
</li>
<li><p>code: Complete code to build dataset.
</p>
</li>
<li><p>checksum: Module checksum.
</p>
</li>
<li><p>DSchecksum: Dataset checksum.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># YAML configuration files from the package:
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "formods", "templates", "UD.yaml")
# This is the module id:
id = "UD"
# Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = UD_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input
state = UD_fetch_state(
           id            = id,
           input         = input,
           session       = session,
           FM_yaml_file  = FM_yaml_file,
           MOD_yaml_file = MOD_yaml_file )
  
 ds_res = UD_fetch_ds(state) 
</code></pre>

<hr>
<h2 id='UD_fetch_state'>Fetch Upload Data State</h2><span id='topic+UD_fetch_state'></span>

<h3>Description</h3>

<p>Merges default app options with the changes made in the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD_fetch_state(id, id_ASM, input, session, FM_yaml_file, MOD_yaml_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UD_fetch_state_+3A_id">id</code></td>
<td>
<p>Shiny module ID</p>
</td></tr>
<tr><td><code id="UD_fetch_state_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state management module used to save and load app states</p>
</td></tr>
<tr><td><code id="UD_fetch_state_+3A_input">input</code></td>
<td>
<p>Shiny input variable</p>
</td></tr>
<tr><td><code id="UD_fetch_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
<tr><td><code id="UD_fetch_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="UD_fetch_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the current state of the app including default
values from the yaml file as well as any changes made by the user. The list
has the following structure:
</p>

<ul>
<li><p>yaml: Full contents of the supplied yaml file.
</p>
</li>
<li><p>MC: Module components of the yaml file.
</p>
</li>
<li><p>DS: Loaded dataset with the following elements
</p>

<ul>
<li><p>isgood: Boolean object indicating if the file was successfully loaded.
</p>
</li>
<li><p>load_msg: Text message indicated the success or any problems
encountered when uploading the file.
</p>
</li>
<li><p>data_file_local: Full path to the data file on the server.
</p>
</li>
<li><p>data_file: Dataset file name without the path.
</p>
</li>
<li><p>data_file_ext: File extension of the uploaded file.
</p>
</li>
<li><p>sheet: If the uploaded file is an excel file, this is the
currently selected sheet.
</p>
</li>
<li><p>sheets: If the uploaded file is an excel file, this is a character vector of the sheets present in that file.
</p>
</li>
<li><p>contents: Data frame containting the contents of the data file.
</p>
</li>
<li><p>checksum: This is an MD5 sum of the contents element and can be
used to detect changes in the loaded file.
</p>
</li></ul>

</li>
<li><p>MOD_TYPE: Character data containing the type of module <code>"UD"</code>
</p>
</li>
<li><p>id: Character data containing the module id module in the session variable.
</p>
</li>
<li><p>FM_yaml_file: App configuration file with FM as main section.
</p>
</li>
<li><p>MOD_yaml_file:  Module configuration file with MC as main section.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># YAML configuration files from the package:
FM_yaml_file  = system.file(package = "formods", "templates", "formods.yaml")
MOD_yaml_file = system.file(package = "formods", "templates", "UD.yaml")
# This is the module id:
id = "UD"
# Within shiny both session and input variables will exist,
# this creates examples here for testing purposes:
sess_res = UD_test_mksession(session=list())
session = sess_res$session
input   = sess_res$input
state = UD_fetch_state(
           id            = id,
           input         = input,
           session       = session,
           FM_yaml_file  = FM_yaml_file,
           MOD_yaml_file = MOD_yaml_file )
</code></pre>

<hr>
<h2 id='UD_init_state'>Initialize UD Module State</h2><span id='topic+UD_init_state'></span>

<h3>Description</h3>

<p>Creates a list of the initialized module state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD_init_state(FM_yaml_file, MOD_yaml_file, id, session)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UD_init_state_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="UD_init_state_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="UD_init_state_+3A_id">id</code></td>
<td>
<p>ID string for the module.</p>
</td></tr>
<tr><td><code id="UD_init_state_+3A_session">session</code></td>
<td>
<p>Shiny session variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing an empty UD state
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Within shiny a session variable will exist,
# this creates one here for testing purposes:
sess_res = UD_test_mksession(session=list())
session = sess_res$session
state = UD_init_state(
   FM_yaml_file  = system.file(package = "formods",
                               "templates",
                               "formods.yaml"),
   MOD_yaml_file = system.file(package = "formods",
                               "templates",
                               "UD.yaml"),
   id              = "UD",
   session         = session)
state
</code></pre>

<hr>
<h2 id='UD_Server'>Data Upload Server</h2><span id='topic+UD_Server'></span>

<h3>Description</h3>

<p>Server function for the Data Uplaod Shiny Module
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD_Server(
  id,
  id_ASM = "ASM",
  FM_yaml_file = system.file(package = "formods", "templates", "formods.yaml"),
  MOD_yaml_file = system.file(package = "formods", "templates", "UD.yaml"),
  deployed = FALSE,
  react_state = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UD_Server_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
<tr><td><code id="UD_Server_+3A_id_asm">id_ASM</code></td>
<td>
<p>ID string for the app state management module used to save and load app states</p>
</td></tr>
<tr><td><code id="UD_Server_+3A_fm_yaml_file">FM_yaml_file</code></td>
<td>
<p>App configuration file with FM as main section.</p>
</td></tr>
<tr><td><code id="UD_Server_+3A_mod_yaml_file">MOD_yaml_file</code></td>
<td>
<p>Module configuration file with MC as main section.</p>
</td></tr>
<tr><td><code id="UD_Server_+3A_deployed">deployed</code></td>
<td>
<p>Boolean variable indicating whether the app is deployed or not.</p>
</td></tr>
<tr><td><code id="UD_Server_+3A_react_state">react_state</code></td>
<td>
<p>Variable passed to server to allow reaction outside of module (<code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>UD Server object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# These are suggested packages
library(shinydashboard)
library(ggpubr)
library(plotly)
library(shinybusy)
library(prompter)
library(utils)
library(clipr)
library(formods)

CSS &lt;- "
.wrapfig {
  float: right;
  shape-margin: 20px;
  margin-right: 20px;
  margin-bottom: 20px;
}
"

# Default to not deployed
if(!exists("deployed")){
  deployed = FALSE
}

#https://fontawesome.com/icons?from=io
data_url =
"https://github.com/john-harrold/formods/raw/master/inst/test_data/TEST_DATA.xlsx"

ui &lt;- dashboardPage(
  skin="black",
  dashboardHeader(title="formods"),
  dashboardSidebar(
     sidebarMenu(
       menuItem("Source Data",     tabName="upload",      icon=icon("table")) ,
       menuItem("Wrangle",         tabName="wrangle",     icon=icon("hat-cowboy")),
       menuItem("Plot",            tabName="plot",        icon=icon("chart-line")),
       menuItem("App State",       tabName="app_state",   icon=icon("archive")),
       menuItem("App Info",        tabName="sysinfo",     icon=icon("book-medical"))
     )
  ),
  dashboardBody(
  tags$head(
    tags$style(HTML(CSS))
  ),
    tabItems(
       tabItem(tabName="app_state",
                 box(title="Manage App State",
                     htmlOutput(NS("ASM", "ui_asm_compact")))),
       tabItem(tabName="upload",
               box(title="Load Data", width=12,
                 fluidRow(
                   prompter::use_prompt(),
                   column(width=6,
                     htmlOutput(NS("UD",  "UD_ui_compact"))),
                   column(width=6,
       tags$p(
           tags$img(
           class = "wrapfig",
           src   = "https://github.com/john-harrold/formods/raw/master/man/figures/logo.png",
           width = 100,
           alt = "formods logo" ),
         'Formods is a set of modules and an framework for developing modules
         which interact and create code to replicate analyses performed within an app.
         To experiment download this',
       tags$a("test dataset", href=data_url),
              'and upload it into the App using the form on the left.'))
                 )
               )
               ),
       tabItem(tabName="wrangle",
               box(title="Transform and Create Views of Your Data", width=12,
               htmlOutput(NS("DW",  "DW_ui_compact")))),
       tabItem(tabName="plot",
               box(title="Visualize Data", width=12,
               htmlOutput(NS("FG",  "FG_ui_compact")))),
       tabItem(tabName="sysinfo",
               box(title="System Details", width=12,
               shinydashboard::tabBox(
                 width = 12,
                 title = NULL,
                 shiny::tabPanel(id="sys_modules",
                          title=tagList(shiny::icon("ghost"),
                                        "Modules"),
                 htmlOutput(NS("ASM", "ui_asm_sys_modules"))
                 ),
                 shiny::tabPanel(id="sys_packages",
                          title=tagList(shiny::icon("ghost"),
                                        "Packages"),
                 htmlOutput(NS("ASM", "ui_asm_sys_packages"))
                 ),
                 shiny::tabPanel(id="sys_log",
                          title=tagList(shiny::icon("clipboard-list"),
                                        "App Log"),
                 verbatimTextOutput(NS("ASM", "ui_asm_sys_log"))
                 ),
                 shiny::tabPanel(id="sys_options",
                          title=tagList(shiny::icon("sliders"),
                                        "R Options"),
                 htmlOutput(NS("ASM", "ui_asm_sys_options"))
                 )
                 )
               ))
      )
    )
  )

# Main app server
server &lt;- function(input, output, session) {
  # Empty reactive object to track and react to
  # changes in the module state outside of the module
  react_FM = reactiveValues()

  # This is the list of module ids used for reproducible script generation. The
  # order here is important.
  mod_ids = c("UD", "DW", "FG")

  #Populating with test data
  FG_test_mksession(session)
  # Module servers
  formods::ASM_Server(id="ASM",
             deployed    = deployed,
             react_state = react_FM, mod_ids = mod_ids)
  formods::UD_Server( id="UD", id_ASM = "ASM",
             deployed    = deployed,
             react_state = react_FM)
  formods::DW_Server( id="DW", id_ASM = "ASM",id_UD = "UD",
             deployed    = deployed,
             react_state = react_FM)
  formods::FG_Server( id="FG", id_ASM = "ASM",id_UD = "UD", id_DW = "DW",
             deployed    = deployed,
             react_state = react_FM)
}

shinyApp(ui, server)
}
</code></pre>

<hr>
<h2 id='UD_test_mksession'>Populate Session Data for Module Testing</h2><span id='topic+UD_test_mksession'></span>

<h3>Description</h3>

<p>Populates the supplied session variable for testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD_test_mksession(session, id = "UD")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UD_test_mksession_+3A_session">session</code></td>
<td>
<p>Shiny session variable (in app) or a list (outside of app)</p>
</td></tr>
<tr><td><code id="UD_test_mksession_+3A_id">id</code></td>
<td>
<p>An ID string that corresponds with the ID used to call the modules UI elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with the following elements
</p>

<ul>
<li><p>isgood: Boolean indicating the exit status of the function.
</p>
</li>
<li><p>session: The value Shiny session variable (in app) or a list (outside of app) after initialization.
</p>
</li>
<li><p>input: The value of the shiny input at the end of the session initialization.
</p>
</li>
<li><p>state: App state.
</p>
</li>
<li><p>rsc: The <code>react_state</code> components.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>res = UD_test_mksession(session=list())
</code></pre>

<hr>
<h2 id='unfactor'>Remove Factor From Object</h2><span id='topic+unfactor'></span>

<h3>Description</h3>

<p>Takes an object that is a factor and returns an unfactored
vector with the same type by the value removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfactor(fctobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfactor_+3A_fctobj">fctobj</code></td>
<td>
<p>Factorized object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object with factors removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df = data.frame(
   text  = c("a", "b", "c"),
   float = c( 1 ,  2 ,  3 ))

df$float = as.factor(df$float)
# This is a factor
df$float
# This is not a factor
unfactor(df$float)
</code></pre>

<hr>
<h2 id='use_formods'>Create Module Templates in a Package Repository</h2><span id='topic+use_formods'></span>

<h3>Description</h3>

<p>If you are developing a package within a repository (i.e. git)
and want to create a new formods module this function will
create the template files for you and install them in the correct location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_formods(
  SN = "NM",
  Module_Name = "New Module",
  package = "pkgname",
  element = "analysis",
  overwrite = FALSE,
  repo_root = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_formods_+3A_sn">SN</code></td>
<td>
<p>Module short name</p>
</td></tr>
<tr><td><code id="use_formods_+3A_module_name">Module_Name</code></td>
<td>
<p>Module long name</p>
</td></tr>
<tr><td><code id="use_formods_+3A_package">package</code></td>
<td>
<p>Name of package that will contain the module</p>
</td></tr>
<tr><td><code id="use_formods_+3A_element">element</code></td>
<td>
<p>What you would call the thing the module provides for example
the FG module provides &quot;figures&quot;, the DW module provides &quot;data views&quot;</p>
</td></tr>
<tr><td><code id="use_formods_+3A_overwrite">overwrite</code></td>
<td>
<p>Boolean to indicate if you should overwrite files</p>
</td></tr>
<tr><td><code id="use_formods_+3A_repo_root">repo_root</code></td>
<td>
<p>Root of the repository.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as the return value for new_module_template()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(FALSE){
  use_formods(repo_root=tempdir())
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
