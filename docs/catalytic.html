<!DOCTYPE html><html lang="en"><head><title>Help for package catalytic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {catalytic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cat_cox'><p>Catalytic Cox Proportional Hazards Model (COX) Fitting Function with Fixed Tau</p></a></li>
<li><a href='#cat_cox_bayes'><p>Bayesian Estimation for Catalytic Cox Proportional-Hazards Model (COX) with Fixed tau</p></a></li>
<li><a href='#cat_cox_bayes_joint'><p>Bayesian Estimation for Catalytic Cox Proportional-Hazards Model (COX) with adaptive tau</p></a></li>
<li><a href='#cat_cox_initialization'><p>Initialization for Catalytic Cox proportional hazards model (COX)</p></a></li>
<li><a href='#cat_cox_tune'><p>Catalytic Cox Proportional-Hazards Model (COX) Fitting Function by Tuning tau from a Sequence of tau Values</p></a></li>
<li><a href='#cat_glm'><p>Catalytic Generalized Linear Models (GLMs) Fitting Function with Fixed Tau</p></a></li>
<li><a href='#cat_glm_bayes'><p>Bayesian Estimation for Catalytic Generalized Linear Models (GLMs) with Fixed tau</p></a></li>
<li><a href='#cat_glm_bayes_joint'><p>Bayesian Estimation for Catalytic Generalized Linear Models (GLMs)  with adaptive tau</p></a></li>
<li><a href='#cat_glm_bayes_joint_gibbs'><p>Bayesian Estimation with Gibbs Sampling for Catalytic Generalized Linear Models (GLMs) Binomial Family for Coefficients and tau</p></a></li>
<li><a href='#cat_glm_initialization'><p>Initialization for Catalytic Generalized Linear Models (GLMs)</p></a></li>
<li><a href='#cat_glm_tune'><p>Catalytic Generalized Linear Models (GLMs) Fitting Function by Tuning tau from a Sequence of tau Values</p></a></li>
<li><a href='#cat_lmm'><p>Catalytic Linear Mixed Model (LMM) Fitting Function with fixed tau</p></a></li>
<li><a href='#cat_lmm_initialization'><p>Initialization for Catalytic Linear Mixed Model (LMM)</p></a></li>
<li><a href='#cat_lmm_tune'><p>Catalytic Linear Mixed Model (LMM) Fitting Function by Tuning tau from a Sequence of tau Values</p></a></li>
<li><a href='#cross_validation'><p>Perform Cross-Validation for Model Estimation</p></a></li>
<li><a href='#cross_validation_cox'><p>Perform Cross-Validation for Catalytic Cox Proportional-Hazards Model (COX) to Select Optimal tau</p></a></li>
<li><a href='#cross_validation_lmm'><p>Perform Cross-Validation for Catalytic Linear Mixed Model (LMM) to Select Optimal tau</p></a></li>
<li><a href='#extract_coefs'><p>Extract and Format Model Coefficients</p></a></li>
<li><a href='#extract_dim'><p>Extract Dimension Information from Model Initialization</p></a></li>
<li><a href='#extract_stan_summary'><p>Extract and Format Summary of Stan Model Results</p></a></li>
<li><a href='#extract_tau_seq'><p>Extract and Format Sequence of Tau Values</p></a></li>
<li><a href='#get_adjusted_cat_init'><p>Adjusted Cat Initialization</p></a></li>
<li><a href='#get_cox_gradient'><p>Compute the Gradient for Cox Proportional Hazards Model</p></a></li>
<li><a href='#get_cox_hessian'><p>Compute the Hessian Matrix for Cox Proportional Hazards Model</p></a></li>
<li><a href='#get_cox_kappa'><p>Estimate the kappa value for the synthetic Cox proportional hazards model</p></a></li>
<li><a href='#get_cox_partial_likelihood'><p>Compute the Partial Likelihood for the Cox Proportional Hazards Model</p></a></li>
<li><a href='#get_cox_qr_solve'><p>Solve Linear System using QR Decomposition</p></a></li>
<li><a href='#get_cox_risk_and_failure_sets'><p>Calculate Risk and Failure Sets for Cox Proportional Hazards Model</p></a></li>
<li><a href='#get_cox_risk_set_idx'><p>Identify the risk set indices for Cox proportional hazards model</p></a></li>
<li><a href='#get_cox_syn_gradient'><p>Compute the gradient of the synthetic Cox proportional hazards model</p></a></li>
<li><a href='#get_cox_syn_hessian'><p>Compute the Synthetic Hessian Matrix for Cox Proportional Hazards Model</p></a></li>
<li><a href='#get_discrepancy'><p>Compute Discrepancy Measures</p></a></li>
<li><a href='#get_formula_lhs'><p>Extract Left-Hand Side of Formula as String</p></a></li>
<li><a href='#get_formula_rhs'><p>Extract the Right-Hand Side of a Formula</p></a></li>
<li><a href='#get_formula_string'><p>Convert Formula to String</p></a></li>
<li><a href='#get_glm_custom_var'><p>Get Custom Variance for Generalized Linear Model (GLM)</p></a></li>
<li><a href='#get_glm_diag_approx_cov'><p>Compute Diagonal Approximate Covariance Matrix</p></a></li>
<li><a href='#get_glm_family_string'><p>Retrieve GLM Family Name or Name with Link Function</p></a></li>
<li><a href='#get_glm_lambda'><p>Compute Lambda Based on Discrepancy Method</p></a></li>
<li><a href='#get_glm_log_density'><p>Compute Log Density Based on GLM Family</p></a></li>
<li><a href='#get_glm_log_density_grad'><p>Compute Gradient of Log Density for GLM Families</p></a></li>
<li><a href='#get_glm_mean'><p>Compute Mean Based on GLM Family</p></a></li>
<li><a href='#get_glm_sample_data'><p>Generate Sample Data for GLM</p></a></li>
<li><a href='#get_hmc_mcmc_result'><p>Run Hamiltonian Monte Carlo to Get MCMC Sample Result</p></a></li>
<li><a href='#get_linear_predictor'><p>Compute Linear Predictor</p></a></li>
<li><a href='#get_resampled_df'><p>Resampling Methods for Data Processing</p></a></li>
<li><a href='#get_stan_model'><p>Generate Stan Model Based on Specified Parameters</p></a></li>
<li><a href='#get_standardized_data'><p>Standardize Data</p></a></li>
<li><a href='#hmc_neal_2010'><p>Hamiltonian Monte Carlo (HMC) Implementation</p></a></li>
<li><a href='#is.continuous'><p>Check if a Variable is Continuous</p></a></li>
<li><a href='#mallowian_estimate'><p>Perform Mallowian Estimate for Model Risk (Only Applicable for Gaussian Family)</p></a></li>
<li><a href='#parametric_bootstrap'><p>Perform Parametric Bootstrap for Model Risk Estimation</p></a></li>
<li><a href='#plot.cat_tune'><p>Plot Likelihood or Risk Estimate vs. Tau for Tuning Model</p></a></li>
<li><a href='#predict.cat_cox'><p>Predict Linear Predictor for New Data Using a Fitted Cox Model</p></a></li>
<li><a href='#predict.cat_glm'><p>Predict Outcome for New Data Using a Fitted GLM Model</p></a></li>
<li><a href='#predict.cat_lmm'><p>Predict Linear Predictor for New Data Using a Fitted Linear Mixed Model</p></a></li>
<li><a href='#print_df_head_tail'><p>Print Data Frame with Head and Tail Rows</p></a></li>
<li><a href='#print_glm_bayes_joint_binomial_suggestion'><p>Generate Suggestions for Bayesian Joint Binomial GLM Parameter Estimation</p></a></li>
<li><a href='#print.cat'><p>Print Method for <code>cat</code> Object</p></a></li>
<li><a href='#print.cat_bayes'><p>Print Summary of <code>cat_bayes</code> Model</p></a></li>
<li><a href='#print.cat_gibbs'><p>Print Summary of <code>cat_gibbs</code> Model</p></a></li>
<li><a href='#print.cat_initialization'><p>Print Summary for Catalytic Initialization Model</p></a></li>
<li><a href='#print.cat_tune'><p>Print Method for <code>cat_tune</code> Object</p></a></li>
<li><a href='#steinian_estimate'><p>Perform Steinian Estimate for Model Risk (Only Applicable for Binomial Family)</p></a></li>
<li><a href='#swim'><p>Simulated SWIM Dataset with Binary Response</p></a></li>
<li><a href='#traceplot'><p>Traceplot for Bayesian Model Sampling</p></a></li>
<li><a href='#traceplot.cat_bayes'><p>Traceplot for Bayesian Sampling Model</p></a></li>
<li><a href='#traceplot.cat_gibbs'><p>Traceplot for Gibbs Sampling Model</p></a></li>
<li><a href='#update_lmm_variance'><p>Calculates the log-likelihood for linear mixed models (LMMs) by combining</p>
observed and synthetic log-likelihoods based on the variance parameters.</a></li>
<li><a href='#validate_cox_initialization_input'><p>Validate Inputs for Catalytic Cox proportional hazards model (COX) Initialization</p></a></li>
<li><a href='#validate_cox_input'><p>Validate Inputs for Catalytic Cox Model</p></a></li>
<li><a href='#validate_glm_initialization_input'><p>Validate Inputs for Catalytic Generalized Linear Models (GLMs) Initialization</p></a></li>
<li><a href='#validate_glm_input'><p>Validate Inputs for Catalytic Generalized Linear Models (GLMs)</p></a></li>
<li><a href='#validate_lmm_initialization_input'><p>Validate Inputs for Catalytic Linear Mixed Model (LMM) Initialization</p></a></li>
<li><a href='#validate_lmm_input'><p>Validate Inputs for Catalytic Linear Mixed Model (LMM)</p></a></li>
<li><a href='#validate_positive'><p>Validate Positive or Non-negative Parameter</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Applying Catalytic Priors in Statistical Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>To improve estimation accuracy and stability in statistical modeling, catalytic prior distributions are employed, integrating observed data with synthetic data generated from a simpler model's predictive distribution. This approach enhances model robustness, stability, and flexibility in complex data scenarios. The catalytic prior distributions are introduced by 'Huang et al.' (2020, &lt;<a href="https://doi.org/10.1073%2Fpnas.1920913117">doi:10.1073/pnas.1920913117</a>&gt;), Li and Huang (2023, &lt;<a href="https://doi.org/10.48550%2FarXiv.2312.01411">doi:10.48550/arXiv.2312.01411</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, invgamma, rlang, rstan, stats, truncnorm, MASS, lme4,
quadform, survival, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, pROC</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-17 08:57:19 UTC; rosewu</td>
</tr>
<tr>
<td>Author:</td>
<td>Yitong Wu <a href="https://orcid.org/0009-0000-8683-5129"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Dongming Huang <a href="https://orcid.org/0000-0003-4265-7708"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Weihao Li [aut],
  Ministry of Education, Singapore [fnd] (The development of this package
    is supported by the Ministry of Education, Singapore, under the
    Academic Research Fund Tier 1 A-8000466-00-00 (FY2022).)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dongming Huang &lt;huang.dongming@nus.edu.sg&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-18 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cat_cox'>Catalytic Cox Proportional Hazards Model (COX) Fitting Function with Fixed Tau</h2><span id='topic+cat_cox'></span>

<h3>Description</h3>

<p>Fits a Catalytic Cox proportional hazards model for survival data with specified variance parameters
and iterative coefficient estimation, with either <code>CRE</code> (Catalytic-regularized Estimator) or <code>WME</code> (Weighted Mixture Estimator) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_cox(
  formula,
  cat_init,
  tau = NULL,
  method = c("CRE", "WME"),
  init_coefficients = NULL,
  tol = 1e-05,
  max_iter = 25
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_cox_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the Cox model. Should at least include response variables (e.g. <code>~ .</code>).</p>
</td></tr>
<tr><td><code id="cat_cox_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_cox_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_cox_+3A_tau">tau</code></td>
<td>
<p>Optional numeric scalar controlling the weight of the synthetic data in the coefficient estimation, defaults to the number of predictors.</p>
</td></tr>
<tr><td><code id="cat_cox_+3A_method">method</code></td>
<td>
<p>The estimation method, either <code>"CRE"</code> (Catalytic-regularized Estimator) or <code>"WME"</code> (Weighted Mixture Estimator).</p>
</td></tr>
<tr><td><code id="cat_cox_+3A_init_coefficients">init_coefficients</code></td>
<td>
<p>Initial coefficient values before iteration. Defaults to zero if not provided (if using <code>CRE</code>).</p>
</td></tr>
<tr><td><code id="cat_cox_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance for iterative methods. Default is <code>1e-5</code> (if using <code>CRE</code>).</p>
</td></tr>
<tr><td><code id="cat_cox_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations allowed for convergence. Default is <code>25</code> (if using <code>CRE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated coefficient vector.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Fitted Cox model object (if using <code>WME</code>).</p>
</td></tr>
<tr><td><code>iteration_log</code></td>
<td>
<p>Matrix logging variance and coefficient values for each iteration(if using <code>CRE</code>).</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations (if using <code>CRE</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data("cancer")
cancer$status[cancer$status == 1] &lt;- 0
cancer$status[cancer$status == 2] &lt;- 1

cat_init &lt;- cat_cox_initialization(
  formula = Surv(time, status) ~ 1, # formula for simple model
  data = cancer,
  syn_size = 100, # Synthetic data size
  hazard_constant = 0.1, # Hazard rate value
  entry_points = rep(0, nrow(cancer)), # Entry points of each observation
  x_degree = rep(1, ncol(cancer) - 2), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model_cre &lt;- cat_cox(
  formula = ~.,
  cat_init = cat_init, # Only accept object generated from `cat_cox_initialization`
  tau = 1, # Weight for synthetic data
  method = "CRE", # Choose from `"CRE"` or `"WME"`
  init_coefficients = rep(0, ncol(cat_init$x)), # Initial coefficient values (Only for `CRE`)
  tol = 1e-1, # Tolerance for convergence criterion  (Only for `CRE`)
  max_iter = 3 # Maximum number of iterations for convergence  (Only for `CRE`)
)
cat_model_cre

cat_model_wme &lt;- cat_cox(
  formula = ~.,
  cat_init = cat_init, # Only accept object generated from `cat_cox_initialization`
  tau = 1, # Weight for synthetic data
  method = "WME"
)
cat_model_wme
</code></pre>

<hr>
<h2 id='cat_cox_bayes'>Bayesian Estimation for Catalytic Cox Proportional-Hazards Model (COX) with Fixed tau</h2><span id='topic+cat_cox_bayes'></span>

<h3>Description</h3>

<p>This function performs Bayesian estimation for a catalytic Cox proportional-hazards model (COX) using RStan
by given a single tau value. It allows users to estimate the coefficients and cumulative baseline hazard increments
over specified time intervals with Bayesian sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_cox_bayes(
  formula,
  cat_init,
  tau = NULL,
  hazard_beta = 2,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_cox_bayes_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the Cox model. Should at least include response variables (e.g. <code>~.</code>).</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_cox_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_+3A_tau">tau</code></td>
<td>
<p>Optional numeric scalar controlling the weight of the synthetic data in the coefficient estimation, defaults to <code>ncol(cat_init$obs_x)</code>.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_+3A_hazard_beta">hazard_beta</code></td>
<td>
<p>Numeric, default <code>2</code>. Shape parameter for the Gamma distribution in the hazard model.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_+3A_chains">chains</code></td>
<td>
<p>Integer, default <code>4</code>. Number of Markov chains to be run in the RStan sampling.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_+3A_iter">iter</code></td>
<td>
<p>Integer, default <code>2000</code>. Number of iterations per chain in the RStan sampling.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_+3A_warmup">warmup</code></td>
<td>
<p>Integer, default <code>1000</code>. Number of warm-up (or burn-in) iterations for each chain.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to RStan’s <code>rstan::sampling</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>stan_data</code></td>
<td>
<p>A data list used for fitting RStan sampling model.</p>
</td></tr>
<tr><td><code>stan_model</code></td>
<td>
<p>Compiled RStan model object for Cox regression.</p>
</td></tr>
<tr><td><code>stan_sample_model</code></td>
<td>
<p>Fitted RStan sampling model containing posterior samples.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Mean posterior estimates of model coefficients from <code>stan_sample_model</code>.</p>
</td></tr>
<tr><td><code>increment_cumulative_baseline_hazard</code></td>
<td>
<p>Mean posterior estimates of
Estimated cumulative hazard increments over time intervals from <code>stan_sample_model</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
data("cancer")
cancer$status[cancer$status == 1] &lt;- 0
cancer$status[cancer$status == 2] &lt;- 1

cat_init &lt;- cat_cox_initialization(
  formula = Surv(time, status) ~ 1, # formula for simple model
  data = cancer,
  syn_size = 100, # Synthetic data size
  hazard_constant = 0.1, # Hazard rate value
  entry_points = rep(0, nrow(cancer)), # Entry points of each observation
  x_degree = rep(1, ncol(cancer) - 2), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model &lt;- cat_cox_bayes(
  formula = ~., # Should at least include response variables
  cat_init = cat_init, # Only accept object generated from `cat_cox_initialization`
  tau = 1, # Weight for synthetic data
  hazard_beta = 2, # Shape parameter for the Gamma distribution in the hazard model
  chains = 1, # Number of Markov chains to be run in the RStan sampling
  iter = 10, # Number of iterations per chain in the RStan sampling
  warmup = 5 # Number of warm-up (or burn-in) iterations for each chain
)
cat_model

</code></pre>

<hr>
<h2 id='cat_cox_bayes_joint'>Bayesian Estimation for Catalytic Cox Proportional-Hazards Model (COX) with adaptive tau</h2><span id='topic+cat_cox_bayes_joint'></span>

<h3>Description</h3>

<p>This function performs Bayesian estimation for a catalytic Cox proportional-hazards model (COX) using RStan
by using adaptive tau. It allows users to estimate the coefficients and cumulative baseline hazard increments
over specified time intervals with Bayesian sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_cox_bayes_joint(
  formula,
  cat_init,
  hazard_beta = 2,
  tau_alpha = 2,
  tau_gamma = 1,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_cox_bayes_joint_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the Cox model. Should at least include response variables (e.g. <code>~ .</code>).</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_joint_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_cox_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_joint_+3A_hazard_beta">hazard_beta</code></td>
<td>
<p>Numeric, default <code>2</code>. Shape parameter for the Gamma distribution in the hazard model.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_joint_+3A_tau_alpha">tau_alpha</code></td>
<td>
<p>Numeric, defaults <code>2</code>. Scalar for the shape parameter of the Gamma-like function for tau.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_joint_+3A_tau_gamma">tau_gamma</code></td>
<td>
<p>Numeric, defaults <code>1</code>. Scalar for the scale parameter of the Gamma-like function for tau.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_joint_+3A_chains">chains</code></td>
<td>
<p>Integer, default <code>4</code>. Number of Markov chains to be run in the RStan sampling.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_joint_+3A_iter">iter</code></td>
<td>
<p>Integer, default <code>2000</code>. Number of iterations per chain in the RStan sampling.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_joint_+3A_warmup">warmup</code></td>
<td>
<p>Integer, default <code>1000</code>. Number of warm-up (or burn-in) iterations for each chain.</p>
</td></tr>
<tr><td><code id="cat_cox_bayes_joint_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to RStan’s <code>rstan::sampling</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>stan_data</code></td>
<td>
<p>A data list used for fitting RStan sampling model.</p>
</td></tr>
<tr><td><code>stan_model</code></td>
<td>
<p>Compiled RStan model object for Cox regression.</p>
</td></tr>
<tr><td><code>stan_sample_model</code></td>
<td>
<p>Fitted RStan sampling model containing posterior samples.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Mean posterior estimates of tau value from <code>stan_sample_model</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Mean posterior estimates of model coefficients from <code>stan_sample_model</code>.</p>
</td></tr>
<tr><td><code>increment_cumulative_baseline_hazard</code></td>
<td>
<p>Mean posterior estimates of Estimated
cumulative hazard increments over time intervals from <code>stan_sample_model</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(survival)
data("cancer")
cancer$status[cancer$status == 1] &lt;- 0
cancer$status[cancer$status == 2] &lt;- 1

cat_init &lt;- cat_cox_initialization(
  formula = Surv(time, status) ~ 1, # formula for simple model
  data = cancer,
  syn_size = 100, # Synthetic data size
  hazard_constant = 0.1, # Hazard rate value
  entry_points = rep(0, nrow(cancer)), # Entry points of each observation
  x_degree = rep(1, ncol(cancer) - 2), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model &lt;- cat_cox_bayes_joint(
  formula = ~., # Should at least include response variables
  cat_init = cat_init, # Only accept object generated from `cat_cox_initialization`
  hazard_beta = 2, # Shape parameter for the Gamma distribution in the hazard model
  tau_alpha = 2, # Shape parameter of the Gamma-like function for tau
  tau_gamma = 1, # Scale parameter of the Gamma-like function for tau
  chains = 1, # Number of Markov chains to be run in the RStan sampling
  iter = 10, # Number of iterations per chain in the RStan sampling
  warmup = 5 # Number of warm-up (or burn-in) iterations for each chain
)
cat_model

</code></pre>

<hr>
<h2 id='cat_cox_initialization'>Initialization for Catalytic Cox proportional hazards model (COX)</h2><span id='topic+cat_cox_initialization'></span>

<h3>Description</h3>

<p>This function prepares and initializes a catalytic Cox proportional hazards model by processing input data,
extracting necessary variables, generating synthetic datasets, and fitting a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_cox_initialization(
  formula,
  data,
  syn_size = NULL,
  hazard_constant = NULL,
  entry_points = NULL,
  x_degree = NULL,
  resample_only = FALSE,
  na_replace = stats::na.omit
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_cox_initialization_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the Cox model. Should include response and predictor variables.</p>
</td></tr>
<tr><td><code id="cat_cox_initialization_+3A_data">data</code></td>
<td>
<p>A data frame containing the data for modeling.</p>
</td></tr>
<tr><td><code id="cat_cox_initialization_+3A_syn_size">syn_size</code></td>
<td>
<p>An integer specifying the size of the synthetic dataset to be generated. Default is four times the number of predictor columns.</p>
</td></tr>
<tr><td><code id="cat_cox_initialization_+3A_hazard_constant">hazard_constant</code></td>
<td>
<p>A constant hazard rate for generating synthetic time data if not using a fitted Cox model. Default is NULL and will calculate in function.</p>
</td></tr>
<tr><td><code id="cat_cox_initialization_+3A_entry_points">entry_points</code></td>
<td>
<p>A numeric vector for entry points of each observation. Default is NULL.</p>
</td></tr>
<tr><td><code id="cat_cox_initialization_+3A_x_degree">x_degree</code></td>
<td>
<p>A numeric vector indicating the degree for polynomial expansion of predictors. Default is 1 for each predictor.</p>
</td></tr>
<tr><td><code id="cat_cox_initialization_+3A_resample_only">resample_only</code></td>
<td>
<p>A logical indicating whether to perform resampling only. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cat_cox_initialization_+3A_na_replace">na_replace</code></td>
<td>
<p>A function to handle NA values in the data. Default is <code>stats::na.omit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the input arguments and the following components:
</p>

<ul>
<li> <p><strong>Function Information</strong>:
</p>

<ul>
<li> <p><code>function_name</code>: The name of the function, &quot;cat_cox_initialization&quot;.
</p>
</li>
<li> <p><code>time_col_name</code>: The name of the time variable in the dataset.
</p>
</li>
<li> <p><code>status_col_name</code>: The name of the status variable (event indicator) in the dataset.
</p>
</li>
<li> <p><code>simple_model</code>: If the formula has no predictors, a constant hazard rate model is used; otherwise, a fitted Cox model object.
</p>
</li></ul>

</li>
<li> <p><strong>Observation Data Information</strong>:
</p>

<ul>
<li> <p><code>obs_size</code>: Number of observations in the original dataset.
</p>
</li>
<li> <p><code>obs_data</code>: Data frame of standardized observation data.
</p>
</li>
<li> <p><code>obs_x</code>: Predictor variables for observed data.
</p>
</li>
<li> <p><code>obs_time</code>: Observed survival times.
</p>
</li>
<li> <p><code>obs_status</code>: Event indicator for observed data.
</p>
</li></ul>

</li>
<li> <p><strong>Synthetic Data Information</strong>:
</p>

<ul>
<li> <p><code>syn_size</code>: Number of synthetic observations generated.
</p>
</li>
<li> <p><code>syn_data</code>: Data frame of synthetic predictor and response variables.
</p>
</li>
<li> <p><code>syn_x</code>: Synthetic predictor variables.
</p>
</li>
<li> <p><code>syn_time</code>: Synthetic survival times.
</p>
</li>
<li> <p><code>syn_status</code>: Event indicator for synthetic data (defaults to 1).
</p>
</li>
<li> <p><code>syn_x_resample_inform</code>: Information about resampling methods for synthetic predictors:
</p>

<ul>
<li><p> Coordinate: Preserves the original data values as reference coordinates during processing.
</p>
</li>
<li><p> Deskewing: Adjusts the data distribution to reduce skewness and enhance symmetry.
</p>
</li>
<li><p> Smoothing: Reduces noise in the data to stabilize the dataset and prevent overfitting.
</p>
</li>
<li><p> Flattening: Creates a more uniform distribution by modifying low-frequency categories in categorical variables.
</p>
</li>
<li><p> Symmetrizing: Balances the data around its mean to improve statistical properties for model fitting.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><strong>Whole Data Information</strong>:
</p>

<ul>
<li> <p><code>size</code>: Total number of combined original and synthetic observations.
</p>
</li>
<li> <p><code>data</code>: Data frame combining original and synthetic datasets.
</p>
</li>
<li> <p><code>x</code>: Combined predictor variables from original and synthetic data.
</p>
</li>
<li> <p><code>time</code>: Combined survival times from original and synthetic data.
</p>
</li>
<li> <p><code>status</code>: Combined event indicators from original and synthetic data.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data("cancer")
cancer$status[cancer$status == 1] &lt;- 0
cancer$status[cancer$status == 2] &lt;- 1

cat_init &lt;- cat_cox_initialization(
  formula = Surv(time, status) ~ 1, # formula for simple model
  data = cancer,
  syn_size = 100, # Synthetic data size
  hazard_constant = NULL, # Hazard rate value
  entry_points = rep(0, nrow(cancer)), # Entry points of each observation
  x_degree = rep(1, ncol(cancer) - 2), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)
cat_init
</code></pre>

<hr>
<h2 id='cat_cox_tune'>Catalytic Cox Proportional-Hazards Model (COX) Fitting Function by Tuning tau from a Sequence of tau Values</h2><span id='topic+cat_cox_tune'></span>

<h3>Description</h3>

<p>This function tunes a catalytic Cox proportional-hazards model (COX) by performing cross-validation
to estimate the optimal value of the tuning parameter <code>tau</code>. It finally uses the optimal tau value
in the <code>cat_cox</code> function for model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_cox_tune(
  formula,
  cat_init,
  method = c("CRE", "WME"),
  tau_seq = NULL,
  cross_validation_fold_num = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_cox_tune_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the Cox model. Should at least include response variables (e.g. <code>~.</code>).</p>
</td></tr>
<tr><td><code id="cat_cox_tune_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_cox_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_cox_tune_+3A_method">method</code></td>
<td>
<p>The estimation method, either <code>"CRE"</code> (Catalytic-regularized Estimator) or <code>"WME"</code> (Weighted Mixture Estimator).</p>
</td></tr>
<tr><td><code id="cat_cox_tune_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A numeric vector specifying the sequence of <code>tau</code> values to be tested.
If NULL, a default sequence is generated based on the number of predictors.</p>
</td></tr>
<tr><td><code id="cat_cox_tune_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>An integer representing the number of folds for cross-validation.
Defaults to 5.</p>
</td></tr>
<tr><td><code id="cat_cox_tune_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>cat_cox</code> function for model fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>tau</code></td>
<td>
<p>he optimal <code>tau</code> value determined from cross-validation.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The fitted lmer model object by using the optimal <code>tau</code> value.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Coefficients of the fitted model by using the optimal <code>tau</code> value.</p>
</td></tr>
<tr><td><code>likelihood_list</code></td>
<td>
<p>Average likelihood value for each <code>tau </code>value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(survival)
data("cancer")
cancer$status[cancer$status == 1] &lt;- 0
cancer$status[cancer$status == 2] &lt;- 1

cat_init &lt;- cat_cox_initialization(
  formula = Surv(time, status) ~ 1, # formula for simple model
  data = cancer,
  syn_size = 100, # Synthetic data size
  hazard_constant = 0.1, # Hazard rate value
  entry_points = rep(0, nrow(cancer)), # Entry points of each observation
  x_degree = rep(1, ncol(cancer) - 2), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model &lt;- cat_cox_tune(
  formula = ~., # Should at least include response variables
  cat_init = cat_init, # Only accept object generated from `cat_cox_initialization`
  tau_seq = c(1, 2), # Vector of weights for synthetic data
  cross_validation_fold_num = 5 # number of folds for cross-validation
)
cat_model
</code></pre>

<hr>
<h2 id='cat_glm'>Catalytic Generalized Linear Models (GLMs) Fitting Function with Fixed Tau</h2><span id='topic+cat_glm'></span>

<h3>Description</h3>

<p>Fits a Catalytic Generalized Linear Models (GLMs) by using observed and synthetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_glm(formula, cat_init, tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_glm_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables (e.g. <code>~ .</code>).</p>
</td></tr>
<tr><td><code id="cat_glm_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_glm_+3A_tau">tau</code></td>
<td>
<p>Optional numeric scalar controlling the weight of the synthetic data in the coefficient estimation.
Defaults to the number of predictors / 4 for Gaussian models or the number of predictors otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated coefficient vector.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Fitted GLMs object (<code>stats::glm</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gaussian_data &lt;- data.frame(
  X1 = stats::rnorm(10),
  X2 = stats::rnorm(10),
  Y = stats::rnorm(10)
)

cat_init &lt;- cat_glm_initialization(
  formula = Y ~ 1, # formula for simple model
  data = gaussian_data,
  syn_size = 100, # Synthetic data size
  custom_variance = NULL, # User customized variance value
  gaussian_known_variance = TRUE, # Indicating whether the data variance is known
  x_degree = c(1, 1), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model &lt;- cat_glm(
  formula = ~.,
  cat_init = cat_init, # Only accept object generated from `cat_glm_initialization`
  tau = 1 # Weight for synthetic data
)
cat_model
</code></pre>

<hr>
<h2 id='cat_glm_bayes'>Bayesian Estimation for Catalytic Generalized Linear Models (GLMs) with Fixed tau</h2><span id='topic+cat_glm_bayes'></span>

<h3>Description</h3>

<p>Fits a Bayesian generalized linear model using synthetic and observed data based on an initial
data structure, formula, and other model specifications. Supports only Gaussian and Binomial
distributions in the GLM family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_glm_bayes(
  formula,
  cat_init,
  tau = NULL,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  algorithm = "NUTS",
  gaussian_variance_alpha = NULL,
  gaussian_variance_beta = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_glm_bayes_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables (e.g. <code>~.</code>).</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_tau">tau</code></td>
<td>
<p>Optional numeric scalar controlling the weight of the synthetic data in the coefficient estimation.
Defaults to the number of predictors / 4 for Gaussian models or the number of predictors otherwise.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains to run. Default is 4.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_iter">iter</code></td>
<td>
<p>Total number of iterations per chain. Default is 2000.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_warmup">warmup</code></td>
<td>
<p>Number of warm-up iterations per chain (discarded from final analysis). Default is 1000.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_algorithm">algorithm</code></td>
<td>
<p>The sampling algorithm to use in <code>rstan::sampling</code>. Default is &quot;NUTS&quot;
(No-U-Turn Sampler).</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_gaussian_variance_alpha">gaussian_variance_alpha</code></td>
<td>
<p>The shape parameter for the inverse-gamma prior on
variance if the variance is unknown in Gaussian models. Defaults to the number of predictors.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_gaussian_variance_beta">gaussian_variance_beta</code></td>
<td>
<p>The scale parameter for the inverse-gamma prior on
variance if the variance is unknown in Gaussian models. Defaults to the number of predictors
times variance of observation response.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>rstan::sampling</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>stan_data</code></td>
<td>
<p>The data list used for fitting RStan sampling model.</p>
</td></tr>
<tr><td><code>stan_model</code></td>
<td>
<p>Compiled RStan model object for GLMs.</p>
</td></tr>
<tr><td><code>stan_sample_model</code></td>
<td>
<p>Fitted RStan sampling model containing posterior samples.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Mean posterior estimates of model coefficients from <code>stan_sample_model</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
gaussian_data &lt;- data.frame(
  X1 = stats::rnorm(10),
  X2 = stats::rnorm(10),
  Y = stats::rnorm(10)
)

cat_init &lt;- cat_glm_initialization(
  formula = Y ~ 1, # formula for simple model
  data = gaussian_data,
  syn_size = 100, # Synthetic data size
  custom_variance = NULL, # User customized variance value
  gaussian_known_variance = FALSE, # Indicating whether the data variance is unknown
  x_degree = c(1, 1), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model &lt;- cat_glm_bayes(
  formula = ~.,
  cat_init = cat_init, # Only accept object generated from `cat_glm_initialization`
  tau = 1, # Weight for synthetic data
  chains = 1, # Number of Markov chains to be run in the RStan sampling
  iter = 10, # Number of iterations per chain in the RStan sampling
  warmup = 5, # Number of warm-up (or burn-in) iterations for each chain
  algorithm = "NUTS", # Sampling algorithm to use in \code{rstan::sampling}
  gaussian_variance_alpha = 1, # The shape parameter for the inverse-gamma prior for variance
  gaussian_variance_beta = 2 # The scale parameter for the inverse-gamma prior for variance
)
cat_model

</code></pre>

<hr>
<h2 id='cat_glm_bayes_joint'>Bayesian Estimation for Catalytic Generalized Linear Models (GLMs)  with adaptive tau</h2><span id='topic+cat_glm_bayes_joint'></span>

<h3>Description</h3>

<p>This function performs Bayesian estimation for a catalytic Generalized Linear Models (GLMs) using RStan
by using adaptive tau. It supports both Gaussian and Binomial family models, enabling
flexibility in prior specifications and algorithm configurations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_glm_bayes_joint(
  formula,
  cat_init,
  chains = 4,
  iter = 2000,
  warmup = 1000,
  algorithm = "NUTS",
  tau_alpha = 2,
  tau_gamma = 1,
  binomial_tau_lower = 0.05,
  binomial_joint_theta = FALSE,
  binomial_joint_alpha = FALSE,
  gaussian_variance_alpha = NULL,
  gaussian_variance_beta = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_glm_bayes_joint_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables (e.g. <code>~.</code>).</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_chains">chains</code></td>
<td>
<p>Number of Markov chains to run. Default is 4.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_iter">iter</code></td>
<td>
<p>Total number of iterations per chain. Default is 2000.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_warmup">warmup</code></td>
<td>
<p>Number of warm-up iterations per chain (discarded from final analysis). Default is 1000.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_algorithm">algorithm</code></td>
<td>
<p>The sampling algorithm to use in <code>rstan::sampling</code>. Default is &quot;NUTS&quot;
(No-U-Turn Sampler).</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_tau_alpha">tau_alpha</code></td>
<td>
<p>Shape parameter of the prior for tau. Default is 2.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_tau_gamma">tau_gamma</code></td>
<td>
<p>Scale parameter of the prior for tau. Default is 1.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_binomial_tau_lower">binomial_tau_lower</code></td>
<td>
<p>A numeric lower bound for tau in Binomial models. Default is 0.05.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_binomial_joint_theta">binomial_joint_theta</code></td>
<td>
<p>Logical; if TRUE, uses joint theta (theta = 1/tau) in Binomial models. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_binomial_joint_alpha">binomial_joint_alpha</code></td>
<td>
<p>Logical; if TRUE, uses joint alpha (adaptive tau_alpha)
in Binomial models. Default is FALSE. To activate this feature, both
<code>binomial_joint_theta = TRUE</code> and <code>binomial_joint_alpha = TRUE</code> must be set.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_gaussian_variance_alpha">gaussian_variance_alpha</code></td>
<td>
<p>The shape parameter for the inverse-gamma prior on
variance if the variance is unknown in Gaussian models. Defaults to the number of predictors.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_gaussian_variance_beta">gaussian_variance_beta</code></td>
<td>
<p>The scale parameter for the inverse-gamma prior on
variance if the variance is unknown in Gaussian models. Defaults to the number of predictors
times variance of observation response.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>rstan::sampling</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>stan_data</code></td>
<td>
<p>A data list used for fitting RStan sampling model.</p>
</td></tr>
<tr><td><code>stan_model</code></td>
<td>
<p>Compiled RStan model object for GLMs.</p>
</td></tr>
<tr><td><code>stan_sample_model</code></td>
<td>
<p>Fitted RStan sampling model containing posterior samples.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Mean posterior estimates of model coefficients from <code>stan_sample_model</code>.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Mean posterior of tau (or transformed theta if applicable).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
gaussian_data &lt;- data.frame(
  X1 = stats::rnorm(10),
  X2 = stats::rnorm(10),
  Y = stats::rnorm(10)
)

cat_init &lt;- cat_glm_initialization(
  formula = Y ~ 1, # formula for simple model
  data = gaussian_data,
  syn_size = 100, # Synthetic data size
  custom_variance = NULL, # User customized variance value
  gaussian_known_variance = FALSE, # Indicating whether the data variance is unknown
  x_degree = c(1, 1), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model &lt;- cat_glm_bayes_joint(
  formula = ~.,
  cat_init = cat_init, # Only accept object generated from `cat_glm_initialization`
  chains = 1, # Number of Markov chains to be run in the RStan sampling
  iter = 10, # Number of iterations per chain in the RStan sampling
  warmup = 5, # Number of warm-up (or burn-in) iterations for each chain
  algorithm = "NUTS", # Sampling algorithm to use in \code{rstan::sampling}
  tau_alpha = 1, # Shape parameter of the prior for tau
  tau_gamma = 2, # Scale parameter of the prior for tau
  binomial_tau_lower = 0.05, # Lower bound for tau in Binomial models.
  binomial_joint_theta = FALSE, # Indicator for using joint theta for Binomial models
  binomial_joint_alpha = FALSE, # Indicator for using oint alpha for Binomial models
  gaussian_variance_alpha = 1, # The shape parameter for the inverse-gamma prior for variance
  gaussian_variance_beta = 2 # The scale parameter for the inverse-gamma prior for variance
)
cat_model

</code></pre>

<hr>
<h2 id='cat_glm_bayes_joint_gibbs'>Bayesian Estimation with Gibbs Sampling for Catalytic Generalized Linear Models (GLMs) Binomial Family for Coefficients and tau</h2><span id='topic+cat_glm_bayes_joint_gibbs'></span>

<h3>Description</h3>

<p>This function uses Gibbs sampling to estimate a Bayesian GLMs Binomial Family, where both the coefficients
and tau parameter are jointly sampled. tau is updated via a gamma distribution, while coefficients are
updated using Hamiltonian Monte Carlo (HMC) sampling. The model allows for progress updates,
warm-up iterations, and initial coefficient estimation based on initial tau value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_glm_bayes_joint_gibbs(
  formula,
  cat_init,
  iter = 1000,
  warmup = 500,
  coefs_iter = 5,
  tau_0 = NULL,
  tau_alpha = 2,
  tau_gamma = 1,
  refresh = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables (e.g. <code>~.</code>).</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_iter">iter</code></td>
<td>
<p>Integer; the number of Gibbs sampling iterations (default = 1000).</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_warmup">warmup</code></td>
<td>
<p>Integer; the number of initial iterations for warm-up (default = 500).</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_coefs_iter">coefs_iter</code></td>
<td>
<p>Integer; the number of iterations for the HMC step to update coefficients.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_tau_0">tau_0</code></td>
<td>
<p>Initial value for tau; defaults to the number of predictors / 4 if NULL.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_tau_alpha">tau_alpha</code></td>
<td>
<p>Shape parameter for the gamma distribution when updating tau. Default is 2.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_tau_gamma">tau_gamma</code></td>
<td>
<p>Scale parameter for the gamma distribution when updating tau. Default is 1.</p>
</td></tr>
<tr><td><code id="cat_glm_bayes_joint_gibbs_+3A_refresh">refresh</code></td>
<td>
<p>Logical; if TRUE, displays sampling progress. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>gibbs_iteration_log</code></td>
<td>
<p>Matrix containing the coefficients and tau values from each Gibbs iteration.</p>
</td></tr>
<tr><td><code>inform_df</code></td>
<td>
<p>Summary statistics of each parameter, including mean, standard error, quantiles, and effective sample size.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>Mean of sampled tau values.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Mean of sampled coefficient values.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
binomial_data &lt;- data.frame(
  X1 = stats::rnorm(10),
  X2 = stats::rnorm(10),
  Y = stats::rbinom(10, 1, 0.5)
)

cat_init &lt;- cat_glm_initialization(
  formula = Y ~ 1, # formula for simple model
  data = binomial_data,
  family = binomial,
  syn_size = 100, # Synthetic data size
  custom_variance = NULL, # User customized variance value
  gaussian_known_variance = FALSE, # Indicating whether the data variance is unknown
  x_degree = c(1, 1), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model &lt;- cat_glm_bayes_joint_gibbs(
  formula = ~.,
  cat_init = cat_init, # Only accept object generated from `cat_glm_initialization`
  iter = 10, # Number of Gibbs sampling iterations
  warmup = 5, # Number of warm-up (or burn-in) iterations for initial iterations
  coefs_iter = 2, # Number of iterations for the HMC step to update coefficients
  tau_alpha = 1, # Shape parameter for the gamma distribution when updating tau
  tau_gamma = 2, # Scale parameter for the gamma distribution when updating tau
  refresh = TRUE # Indicator for displaying sampling progress
)
cat_model

</code></pre>

<hr>
<h2 id='cat_glm_initialization'>Initialization for Catalytic Generalized Linear Models (GLMs)</h2><span id='topic+cat_glm_initialization'></span>

<h3>Description</h3>

<p>This function prepares and initializes a catalytic Generalized Linear Models (GLMs) by processing input data,
extracting necessary variables, generating synthetic datasets, and fitting a model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_glm_initialization(
  formula,
  family = "gaussian",
  data,
  syn_size = NULL,
  custom_variance = NULL,
  gaussian_known_variance = FALSE,
  x_degree = NULL,
  resample_only = FALSE,
  na_replace = stats::na.omit
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_glm_initialization_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should include response and predictor variables.</p>
</td></tr>
<tr><td><code id="cat_glm_initialization_+3A_family">family</code></td>
<td>
<p>The type of GLM family. Defaults to Gaussian.</p>
</td></tr>
<tr><td><code id="cat_glm_initialization_+3A_data">data</code></td>
<td>
<p>A data frame containing the data for modeling.</p>
</td></tr>
<tr><td><code id="cat_glm_initialization_+3A_syn_size">syn_size</code></td>
<td>
<p>An integer specifying the size of the synthetic dataset to be generated. Default is four times the number of predictor columns.</p>
</td></tr>
<tr><td><code id="cat_glm_initialization_+3A_custom_variance">custom_variance</code></td>
<td>
<p>A custom variance value to be applied if using a Gaussian model. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cat_glm_initialization_+3A_gaussian_known_variance">gaussian_known_variance</code></td>
<td>
<p>A logical value indicating whether the data variance is known. Defaults to <code>FALSE</code>. Only applicable to Gaussian family.</p>
</td></tr>
<tr><td><code id="cat_glm_initialization_+3A_x_degree">x_degree</code></td>
<td>
<p>A numeric vector indicating the degree for polynomial expansion of predictors. Default is 1 for each predictor.</p>
</td></tr>
<tr><td><code id="cat_glm_initialization_+3A_resample_only">resample_only</code></td>
<td>
<p>A logical indicating whether to perform resampling only. Default is FALSE.</p>
</td></tr>
<tr><td><code id="cat_glm_initialization_+3A_na_replace">na_replace</code></td>
<td>
<p>A function to handle NA values in the data. Default is <code>stats::na.omit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the input arguments and the following components:
</p>

<ul>
<li> <p><strong>Function Information</strong>
</p>

<ul>
<li> <p><code>function_name</code>: The name of the function, &quot;cat_glm_initialization&quot;.
</p>
</li>
<li> <p><code>y_col_name</code>: The name of the response variable in the dataset.
</p>
</li>
<li> <p><code>simple_model</code>: An object of class <code>stats::glm</code>, representing the fitted model for generating synthetic response from the original data.
</p>
</li></ul>

</li>
<li> <p><strong>Observation Data Information</strong>
</p>

<ul>
<li> <p><code>obs_size</code>: Number of observations in the original dataset.
</p>
</li>
<li> <p><code>obs_data</code>: Data frame of standardized observation data.
</p>
</li>
<li> <p><code>obs_x</code>: Predictor variables for observed data.
</p>
</li>
<li> <p><code>obs_y</code>: Response variable for observed data.
</p>
</li></ul>

</li>
<li> <p><strong>Synthetic Data Information</strong>
</p>

<ul>
<li> <p><code>syn_size</code>: Number of synthetic observations generated.
</p>
</li>
<li> <p><code>syn_data</code>: Data frame of synthetic predictor and response variables.
</p>
</li>
<li> <p><code>syn_x</code>: Synthetic predictor variables.
</p>
</li>
<li> <p><code>syn_y</code>: Synthetic response variable.
</p>
</li>
<li> <p><code>syn_x_resample_inform</code>: Information about resampling methods for synthetic predictors:
</p>

<ul>
<li><p> Coordinate: Preserves the original data values as reference coordinates during processing.
</p>
</li>
<li><p> Deskewing: Adjusts the data distribution to reduce skewness and enhance symmetry.
</p>
</li>
<li><p> Smoothing: Reduces noise in the data to stabilize the dataset and prevent overfitting.
</p>
</li>
<li><p> Flattening: Creates a more uniform distribution by modifying low-frequency categories in categorical variables.
</p>
</li>
<li><p> Symmetrizing: Balances the data around its mean to improve statistical properties for model fitting.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><strong>Whole Data Information</strong>
</p>

<ul>
<li> <p><code>size</code>: Total number of combined original and synthetic observations.
</p>
</li>
<li> <p><code>data</code>: Data frame combining original and synthetic datasets.
</p>
</li>
<li> <p><code>x</code>: Combined predictor variables from original and synthetic data.
</p>
</li>
<li> <p><code>y</code>: Combined response variable from original and synthetic data.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>gaussian_data &lt;- data.frame(
  X1 = stats::rnorm(10),
  X2 = stats::rnorm(10),
  Y = stats::rnorm(10)
)

cat_init &lt;- cat_glm_initialization(
  formula = Y ~ 1, # formula for simple model
  data = gaussian_data,
  syn_size = 100, # Synthetic data size
  custom_variance = NULL, # User customized variance value
  gaussian_known_variance = TRUE, # Indicating whether the data variance is known
  x_degree = c(1, 1), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)
cat_init
</code></pre>

<hr>
<h2 id='cat_glm_tune'>Catalytic Generalized Linear Models (GLMs) Fitting Function by Tuning tau from a Sequence of tau Values</h2><span id='topic+cat_glm_tune'></span>

<h3>Description</h3>

<p>This function tunes a catalytic catalytic Generalized Linear Models (GLMs) by performing specified risk estimate method
to estimate the optimal value of the tuning parameter <code>tau</code>.  The resulting <code>cat_glm_tune</code> object
encapsulates the fitted model, including estimated coefficients and family information, facilitating further analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_glm_tune(
  formula,
  cat_init,
  risk_estimate_method = c("parametric_bootstrap", "cross_validation",
    "mallowian_estimate", "steinian_estimate"),
  discrepancy_method = c("mean_square_error", "mean_classification_error",
    "logistic_deviance"),
  tau_seq = NULL,
  tau_0 = NULL,
  parametric_bootstrap_iteration_times = 100,
  cross_validation_fold_num = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_glm_tune_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables (e.g. <code>~ .</code>).</p>
</td></tr>
<tr><td><code id="cat_glm_tune_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_glm_tune_+3A_risk_estimate_method">risk_estimate_method</code></td>
<td>
<p>Method for risk estimation, chosen from &quot;parametric_bootstrap&quot;,
&quot;cross_validation&quot;, &quot;mallows_estimate&quot;, &quot;steinian_estimate&quot;. Depends on the size of the data if not provided.</p>
</td></tr>
<tr><td><code id="cat_glm_tune_+3A_discrepancy_method">discrepancy_method</code></td>
<td>
<p>Method for discrepancy calculation, chosen from &quot;mean_square_error&quot;,
&quot;mean_classification_error&quot;, &quot;logistic_deviance&quot;. Depends on the family if not provided.</p>
</td></tr>
<tr><td><code id="cat_glm_tune_+3A_tau_seq">tau_seq</code></td>
<td>
<p>Vector of numeric values for down-weighting synthetic data.
Defaults to a sequence around one fourth of the number of predictors for gaussian and
the number of predictors for binomial.</p>
</td></tr>
<tr><td><code id="cat_glm_tune_+3A_tau_0">tau_0</code></td>
<td>
<p>Initial <code>tau</code> value used for discrepancy calculation in risk estimation.
Defaults to one fourth of the number of predictors for binomial and 1 for gaussian.</p>
</td></tr>
<tr><td><code id="cat_glm_tune_+3A_parametric_bootstrap_iteration_times">parametric_bootstrap_iteration_times</code></td>
<td>
<p>Number of bootstrap iterations for &quot;parametric_bootstrap&quot; risk estimation. Defaults to 100.</p>
</td></tr>
<tr><td><code id="cat_glm_tune_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>Number of folds for &quot;cross_validation&quot; risk estimation.. Defaults to 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>tau</code></td>
<td>
<p>Optimal <code>tau</code> value determined through tuning.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Fitted GLM model object with the optimal <code>tau</code> value.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated coefficients from the <code>model</code> fitted by the optimal <code>tau</code> value.</p>
</td></tr>
<tr><td><code>risk_estimate_list</code></td>
<td>
<p>Collected risk estimates for each <code>tau</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>gaussian_data &lt;- data.frame(
  X1 = stats::rnorm(10),
  X2 = stats::rnorm(10),
  Y = stats::rnorm(10)
)

cat_init &lt;- cat_glm_initialization(
  formula = Y ~ 1, # formula for simple model
  data = gaussian_data,
  syn_size = 100, # Synthetic data size
  custom_variance = NULL, # User customized variance value
  gaussian_known_variance = TRUE, # Indicating whether the data variance is known
  x_degree = c(1, 1), # Degrees for polynomial expansion of predictors
  resample_only = FALSE, # Whether to perform resampling only
  na_replace = stats::na.omit # How to handle NA values in data
)

cat_model &lt;- cat_glm_tune(
  formula = ~.,
  cat_init = cat_init, # Only accept object generated from `cat_glm_initialization`
  risk_estimate_method = "parametric_bootstrap",
  discrepancy_method = "mean_square_error",
  tau_seq = c(1, 2), # Weight for synthetic data
  tau_0 = 2,
  parametric_bootstrap_iteration_times = 20, # Number of bootstrap iterations
  cross_validation_fold_num = 5 # Number of folds
)
cat_model
</code></pre>

<hr>
<h2 id='cat_lmm'>Catalytic Linear Mixed Model (LMM) Fitting Function with fixed tau</h2><span id='topic+cat_lmm'></span>

<h3>Description</h3>

<p>Fits a Catalytic linear mixed model (LMM) for observation and synthetic data with specified variance parameters
and iterative coefficient estimation. This function initializes model parameters,
sorts synthetic data, calculates Eigen-decomposition, and iterative optimizes
variance and coefficient values to convergence, by a single given tau value. (Only consider one random effect variance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_lmm(
  cat_init,
  tau = NULL,
  residual_variance_0 = 1,
  random_effect_variance_0 = 1,
  coefs_0 = NULL,
  optimize_domain = c(0, 30),
  max_iter = 500,
  tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_lmm_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_lmm_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_lmm_+3A_tau">tau</code></td>
<td>
<p>Optional numeric scalar controlling the weight of the synthetic data in the coefficient estimation, defaults to <code>ncol(cat_init$obs_x) / 4</code>.</p>
</td></tr>
<tr><td><code id="cat_lmm_+3A_residual_variance_0">residual_variance_0</code></td>
<td>
<p>Initial value for residual variance, default is 1.</p>
</td></tr>
<tr><td><code id="cat_lmm_+3A_random_effect_variance_0">random_effect_variance_0</code></td>
<td>
<p>Initial value for random effect variance, default is 1.</p>
</td></tr>
<tr><td><code id="cat_lmm_+3A_coefs_0">coefs_0</code></td>
<td>
<p>Optional initial coefficient vector, default is <code>NULL</code> which initializes randomly.</p>
</td></tr>
<tr><td><code id="cat_lmm_+3A_optimize_domain">optimize_domain</code></td>
<td>
<p>Numeric vector of length 2 defining optimization range for variance parameters, default is <code>c(0, 30)</code>.</p>
</td></tr>
<tr><td><code id="cat_lmm_+3A_max_iter">max_iter</code></td>
<td>
<p>Integer specifying maximum number of iterations for convergence, default is 500.</p>
</td></tr>
<tr><td><code id="cat_lmm_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence criterion, default is 1e-08.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated coefficient vector.</p>
</td></tr>
<tr><td><code>iteration_log</code></td>
<td>
<p>Matrix logging variance and coefficient values for each iteration.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
cat_init &lt;- cat_lmm_initialization(
  formula = mpg ~ wt + (1 | cyl), # formula for simple model
  data = mtcars,
  x_cols = c("wt"), # Fixed effects
  y_col = "mpg", # Response variable
  z_cols = c("disp", "hp", "drat", "qsec", "vs", "am", "gear", "carb"), # Random effects
  group_col = "cyl", # Grouping column
  syn_size = 100, # Synthetic data size
  resample_by_group = FALSE, # Resampling option
  resample_only = FALSE, # Resampling method
  na_replace = mean # NA replacement method
)

cat_model &lt;- cat_lmm(
  cat_init = cat_init, # Only accept object generated from cat_lmm_initialization
  tau = 1, # Weight for synthetic data
  residual_variance_0 = 1, # Initial value for residual variance
  random_effect_variance_0 = 1, # Initial value for random effect variance
  coefs_0 = c(1), # Initial coefficient vector
  optimize_domain = c(0, 10), # Optimization range for residual and random effect variance
  max_iter = 2, # Maximum number of iterations for convergence
  tol = 1e-01 # Tolerance for convergence criterion
)
cat_model
</code></pre>

<hr>
<h2 id='cat_lmm_initialization'>Initialization for Catalytic Linear Mixed Model (LMM)</h2><span id='topic+cat_lmm_initialization'></span>

<h3>Description</h3>

<p>This function prepares and initializes a catalytic linear mixed model by processing input data,
extracting necessary variables, generating synthetic datasets, and fitting a model.
(Only consider one random effect variance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_lmm_initialization(
  formula,
  data,
  x_cols,
  y_col,
  z_cols,
  group_col = NULL,
  syn_size = NULL,
  resample_by_group = FALSE,
  resample_only = FALSE,
  na_replace = mean
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_lmm_initialization_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the model. Should include response and predictor variables.</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_data">data</code></td>
<td>
<p>A data frame containing the data for modeling.</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_x_cols">x_cols</code></td>
<td>
<p>A character vector of column names for fixed effects (predictors).</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_y_col">y_col</code></td>
<td>
<p>A character string for the name of the response variable.</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_z_cols">z_cols</code></td>
<td>
<p>A character vector of column names for random effects.</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_group_col">group_col</code></td>
<td>
<p>A character string for the grouping variable (optional). If not given (NULL), it is extracted from the formula.</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_syn_size">syn_size</code></td>
<td>
<p>An integer specifying the size of the synthetic dataset to be generated, default is length(x_cols) * 4.</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_resample_by_group">resample_by_group</code></td>
<td>
<p>A logical indicating whether to resample by group, default is FALSE.</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_resample_only">resample_only</code></td>
<td>
<p>A logical indicating whether to perform resampling only, default is FALSE.</p>
</td></tr>
<tr><td><code id="cat_lmm_initialization_+3A_na_replace">na_replace</code></td>
<td>
<p>A function to replace NA values in the data, default is mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the input arguments and the following components:
</p>

<ul>
<li> <p><strong>Function Information</strong>:
</p>

<ul>
<li> <p><code>function_name</code>: A character string representing the name of the function, &quot;cat_lmm_initialization&quot;.
</p>
</li>
<li> <p><code>simple_model</code>: An object of class <code>lme4::lmer</code> or <code>stats::lm</code>, representing the fitted model for generating synthetic response from the original data.
</p>
</li></ul>

</li>
<li> <p><strong>Observation Data Information</strong>:
</p>

<ul>
<li> <p><code>obs_size</code>: An integer representing the number of observations in the original dataset.
</p>
</li>
<li> <p><code>obs_data</code>: The original data used for fitting the model, returned as a data frame.
</p>
</li>
<li> <p><code>obs_x</code>: A data frame containing the standardized predictor variables from the original dataset.
</p>
</li>
<li> <p><code>obs_y</code>: A numeric vector of the standardized response variable from the original dataset.
</p>
</li>
<li> <p><code>obs_z</code>: A data frame containing the standardized random effect variables from the original dataset.
</p>
</li>
<li> <p><code>obs_group</code>: A numeric vector representing the grouping variable for the original observations.
</p>
</li></ul>

</li>
<li> <p><strong>Synthetic Data Information</strong>:
</p>

<ul>
<li> <p><code>syn_size</code>: An integer representing the number of synthetic observations generated.
</p>
</li>
<li> <p><code>syn_data</code>: A data frame containing the synthetic dataset, combining synthetic predictor and response variables.
</p>
</li>
<li> <p><code>syn_x</code>: A data frame containing the synthetic predictor variables.
</p>
</li>
<li> <p><code>syn_y</code>: A numeric vector of the synthetic response variable values.
</p>
</li>
<li> <p><code>syn_z</code>: A data frame containing the synthetic random effect variables.
</p>
</li>
<li> <p><code>syn_group</code>: A numeric vector representing the grouping variable for the synthetic observations.
</p>
</li>
<li> <p><code>syn_x_resample_inform</code>: A data frame containing information about the resampling process for synthetic predictors:
</p>

<ul>
<li><p> Coordinate: Preserves the original data values as reference coordinates during processing.
</p>
</li>
<li><p> Deskewing: Adjusts the data distribution to reduce skewness and enhance symmetry.
</p>
</li>
<li><p> Smoothing: Reduces noise in the data to stabilize the dataset and prevent overfitting.
</p>
</li>
<li><p> Flattening: Creates a more uniform distribution by modifying low-frequency categories in categorical variables.
</p>
</li>
<li><p> Symmetrizing: Balances the data around its mean to improve statistical properties for model fitting.
</p>
</li></ul>

</li>
<li> <p><code>syn_z_resample_inform</code>: A data frame containing information about the resampling process for synthetic random effects. The resampling methods are the same as those from <code>syn_x_resample_inform</code>.
</p>
</li></ul>

</li>
<li> <p><strong>Whole Data Information</strong>:
</p>

<ul>
<li> <p><code>size</code>: An integer representing the total size of the combined original and synthetic datasets.
</p>
</li>
<li> <p><code>data</code>: A combined data frame of the original and synthetic datasets.
</p>
</li>
<li> <p><code>x</code>: A combined data frame of the original and synthetic predictor variables.
</p>
</li>
<li> <p><code>y</code>: A combined numeric vector of the original and synthetic response variables.
</p>
</li>
<li> <p><code>z</code>: A combined data frame of the original and synthetic random effect variables.
</p>
</li>
<li> <p><code>group</code>: A combined numeric vector representing the grouping variable for both original and synthetic datasets.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
cat_init &lt;- cat_lmm_initialization(
  formula = mpg ~ wt + (1 | cyl), # formula for simple model
  data = mtcars,
  x_cols = c("wt"), # Fixed effects
  y_col = "mpg", # Response variable
  z_cols = c("disp", "hp", "drat", "qsec", "vs", "am", "gear", "carb"), # Random effects
  group_col = "cyl", # Grouping column
  syn_size = 100, # Synthetic data size
  resample_by_group = FALSE, # Resampling option
  resample_only = FALSE, # Resampling method
  na_replace = mean # NA replacement method
)
cat_init
</code></pre>

<hr>
<h2 id='cat_lmm_tune'>Catalytic Linear Mixed Model (LMM) Fitting Function by Tuning tau from a Sequence of tau Values</h2><span id='topic+cat_lmm_tune'></span>

<h3>Description</h3>

<p>This function tunes a catalytic linear mixed model by performing cross-validation
to estimate the optimal value of the tuning parameter tau. It finally uses the optimal tau value
in the <code>lmer</code> function from the <code>lme4</code> package for model fitting. (Only consider one random effect variance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat_lmm_tune(cat_init, tau_seq = NULL, cross_validation_fold_num = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat_lmm_tune_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_lmm_initialization</code>.</p>
</td></tr>
<tr><td><code id="cat_lmm_tune_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A numeric vector specifying the sequence of tau values to be tested.
If NULL, a default sequence is generated based on the number of predictors.</p>
</td></tr>
<tr><td><code id="cat_lmm_tune_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>An integer representing the number of folds for cross-validation.
Defaults to 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the values of all the arguments and the following components:
</p>
<table role = "presentation">
<tr><td><code>tau</code></td>
<td>
<p>The optimal tau value determined from cross-validation.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The fitted lmer model object by using the optimal tau value.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Coefficients of the fitted model by using the optimal tau value.</p>
</td></tr>
<tr><td><code>risk_estimate_list</code></td>
<td>
<p>Average prediction errors for each tau value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
cat_init &lt;- cat_lmm_initialization(
  formula = mpg ~ wt + (1 | cyl), # formula for simple model
  data = mtcars,
  x_cols = c("wt"), # Fixed effects
  y_col = "mpg", # Response variable
  z_cols = c("disp", "hp", "drat", "qsec", "vs", "am", "gear", "carb"), # Random effects
  group_col = "cyl", # Grouping column
  syn_size = 100, # Synthetic data size
  resample_by_group = FALSE, # Resampling option
  resample_only = FALSE, # Resampling method
  na_replace = mean # NA replacement method
)

cat_model &lt;- cat_lmm_tune(
  cat_init = cat_init, # Only accept object generated from cat_lmm_initialization
  tau_seq = c(1, 2), # Vector of weights for synthetic data
  cross_validation_fold_num = 3 # number of folds for cross-validation
)
cat_model

</code></pre>

<hr>
<h2 id='cross_validation'>Perform Cross-Validation for Model Estimation</h2><span id='topic+cross_validation'></span>

<h3>Description</h3>

<p>This function performs cross-validation for estimating risk over a sequence
of tuning parameters (<code>tau_seq</code>) by fitting a Generalized Linear Model (GLM) to the data.
It evaluates model performance by splitting the dataset into multiple folds, training
the model on a subset of the data, and testing it on the remaining portion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_validation(
  formula,
  cat_init,
  tau_seq,
  discrepancy_method,
  cross_validation_fold_num,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_validation_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A sequence of tuning parameter values (<code>tau</code>) over which
cross-validation will be performed. Each value of <code>tau</code> is used to weight the
synthetic data during model fitting.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_discrepancy_method">discrepancy_method</code></td>
<td>
<p>A function used to calculate the discrepancy (error) between
model predictions and actual values.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>The number of folds to use in cross-validation.
The dataset will be randomly split into this number of subsets, and the model will be trained and tested on different combinations of these subsets.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li> <p><strong>Randomization of the Data</strong>: The data is randomly shuffled into <code>cross_validation_fold_num</code>
subsets to ensure that the model is evaluated across different splits of the dataset.
</p>
</li>
<li> <p><strong>Model Training and Prediction</strong>: For each fold, a training set is used to fit
a GLM with varying values of <code>tau</code> (from <code>tau_seq</code>), and the model is evaluated on a test set.
The training data consists of both the observed and synthetic data, with synthetic data weighted by <code>tau</code>.
</p>
</li>
<li> <p><strong>Risk Estimation</strong>: After fitting the model, the <code>discrepancy_method</code> is used to calculate the
prediction error for each combination of fold and <code>tau</code>. These errors are accumulated for each <code>tau</code>.
</p>
</li>
<li> <p><strong>Average Risk Estimate</strong>: After completing all folds, the accumulated prediction errors
are averaged over the number of folds to provide a final risk estimate for each value of <code>tau</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A numeric vector of averaged risk estimates, one for each value of <code>tau</code> in <code>tau_seq</code>.
</p>

<hr>
<h2 id='cross_validation_cox'>Perform Cross-Validation for Catalytic Cox Proportional-Hazards Model (COX) to Select Optimal tau</h2><span id='topic+cross_validation_cox'></span>

<h3>Description</h3>

<p>This function performs cross-validation for the catalytic Cox proportional-hazards model (COX) to
estimate the likelihood associated with different values of tau. It splits the data into
training and testing sets and computes prediction errors for model evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_validation_cox(
  formula,
  cat_init,
  method,
  tau_seq,
  cross_validation_fold_num,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_validation_cox_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the Cox model. Should at least include response variables.</p>
</td></tr>
<tr><td><code id="cross_validation_cox_+3A_cat_init">cat_init</code></td>
<td>
<p>A list containing initialized parameters for the catalytic COX.</p>
</td></tr>
<tr><td><code id="cross_validation_cox_+3A_method">method</code></td>
<td>
<p>Character string specifying the optimization method used in the Cat-Cox model fitting.</p>
</td></tr>
<tr><td><code id="cross_validation_cox_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A numeric vector of tau values for which to estimate likelihood.</p>
</td></tr>
<tr><td><code id="cross_validation_cox_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>An integer indicating the number of folds for cross-validation.</p>
</td></tr>
<tr><td><code id="cross_validation_cox_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>cat_cox</code> function for model fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the average likelihood estimates for each tau value.
</p>

<hr>
<h2 id='cross_validation_lmm'>Perform Cross-Validation for Catalytic Linear Mixed Model (LMM) to Select Optimal tau</h2><span id='topic+cross_validation_lmm'></span>

<h3>Description</h3>

<p>This function performs cross-validation for the catalytic linear mixed model (LMM) to
estimate the risk associated with different values of tau. It splits the data into
training and testing sets and computes prediction errors for model evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_validation_lmm(cat_init, tau_seq, cross_validation_fold_num = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cross_validation_lmm_+3A_cat_init">cat_init</code></td>
<td>
<p>A list containing initialized parameters for the catalytic LMM.</p>
</td></tr>
<tr><td><code id="cross_validation_lmm_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A numeric vector of tau values for which to estimate risk.</p>
</td></tr>
<tr><td><code id="cross_validation_lmm_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>An integer indicating the number of folds for cross-validation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the average risk estimates for each tau value.
</p>

<hr>
<h2 id='extract_coefs'>Extract and Format Model Coefficients</h2><span id='topic+extract_coefs'></span>

<h3>Description</h3>

<p>This function retrieves the coefficients from a <code>x</code> object, formats them
with appropriate names, and rounds each coefficient to the specified number of decimal places.
Optionally, the intercept can be included or excluded from the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_coefs(x, digit = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_coefs_+3A_x">x</code></td>
<td>
<p>A model object generated from <code>catalytic</code> that containing model coefficients.</p>
</td></tr>
<tr><td><code id="extract_coefs_+3A_digit">digit</code></td>
<td>
<p>An integer specifying the number of decimal places for rounding coefficients. Default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector of model coefficients, rounded to the specified number of decimal places.
</p>

<hr>
<h2 id='extract_dim'>Extract Dimension Information from Model Initialization</h2><span id='topic+extract_dim'></span>

<h3>Description</h3>

<p>This function retrieves and formats the dimensions of the dataset used in the model,
including the number of observed and synthetic data points and the total number of rows
and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_dim(cat_init)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_dim_+3A_cat_init">cat_init</code></td>
<td>
<p>A list containing model initialization data, expected to include
<code>obs_size</code> (observed data size), <code>syn_size</code> (synthetic data size), <code>size</code> (total data size),
and <code>x</code> (the covariate matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string summarizing the dimensions of the dataset used in the model.
</p>

<hr>
<h2 id='extract_stan_summary'>Extract and Format Summary of Stan Model Results</h2><span id='topic+extract_stan_summary'></span>

<h3>Description</h3>

<p>This function extracts the summary statistics from a fitted Stan model stored within
a <code>x</code> object, formats the parameter names, and rounds values to a specified number
of decimal places. By default, the function includes an intercept term in the summary if
present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_stan_summary(x, digit = 3, with_intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_stan_summary_+3A_x">x</code></td>
<td>
<p>A model object generated from <code>catalytic</code> that containing a fitted Stan model.</p>
</td></tr>
<tr><td><code id="extract_stan_summary_+3A_digit">digit</code></td>
<td>
<p>An integer specifying the number of decimal places to which the summary
statistics should be rounded. Default is 3.</p>
</td></tr>
<tr><td><code id="extract_stan_summary_+3A_with_intercept">with_intercept</code></td>
<td>
<p>A logical value indicating whether the intercept should be included
in the summary. If <code>TRUE</code>, the intercept is labeled and included in the formatted output.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of rounded summary statistics from the Stan model, with row names
representing parameter labels and columns containing summary values.
</p>

<hr>
<h2 id='extract_tau_seq'>Extract and Format Sequence of Tau Values</h2><span id='topic+extract_tau_seq'></span>

<h3>Description</h3>

<p>This function retrieves the sequence of tau values from a <code>x</code> object, rounds each
value to the specified number of decimal places, and formats the output as a concise string.
If the sequence contains more than 10 values, only the first 3 and last 3 values are shown,
with ellipsis (&quot;...&quot;) in between.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_tau_seq(x, digit = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_tau_seq_+3A_x">x</code></td>
<td>
<p>A model object generated from <code>catalytic</code> that containing a sequence of tau values.</p>
</td></tr>
<tr><td><code id="extract_tau_seq_+3A_digit">digit</code></td>
<td>
<p>An integer specifying the number of decimal places to which tau values should
be rounded. Default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the rounded tau values, formatted for readability.
</p>

<hr>
<h2 id='get_adjusted_cat_init'>Adjusted Cat Initialization</h2><span id='topic+get_adjusted_cat_init'></span>

<h3>Description</h3>

<p>This function adjusts the categorical initialization by creating a model frame
for the predictors specified in the right-hand side of the formula and splits
the adjusted data into observed and synthetic parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_adjusted_cat_init(cat_init, formula_rhs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_adjusted_cat_init_+3A_cat_init">cat_init</code></td>
<td>
<p>The object generated from <code>cat_glm_initialization</code>, <code>cat_cox_initialization</code> or <code>cat_lmm_initialization</code></p>
</td></tr>
<tr><td><code id="get_adjusted_cat_init_+3A_formula_rhs">formula_rhs</code></td>
<td>
<p>A formula specifying the right-hand side of the model for predictors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the original <code>cat_init</code> with added components:
- <code>adj_x</code>: The adjusted model frame for the predictors.
- <code>adj_obs_x</code>: The observed part of the adjusted predictors.
- <code>adj_syn_x</code>: The synthetic part of the adjusted predictors.
</p>

<hr>
<h2 id='get_cox_gradient'>Compute the Gradient for Cox Proportional Hazards Model</h2><span id='topic+get_cox_gradient'></span>

<h3>Description</h3>

<p>This function computes the gradient for the Cox proportional hazards model. The gradient
is calculated by considering the contributions of each observation to the gradient based on the
risk set at each event time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_gradient(X, time, status, coefs, entry_points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_gradient_+3A_x">X</code></td>
<td>
<p>A matrix of covariates (design matrix) for the Cox model.</p>
</td></tr>
<tr><td><code id="get_cox_gradient_+3A_time">time</code></td>
<td>
<p>A numeric vector of event times.</p>
</td></tr>
<tr><td><code id="get_cox_gradient_+3A_status">status</code></td>
<td>
<p>A numeric vector of event indicators (1 for event, 0 for censored).</p>
</td></tr>
<tr><td><code id="get_cox_gradient_+3A_coefs">coefs</code></td>
<td>
<p>A numeric vector of coefficients for the Cox model.</p>
</td></tr>
<tr><td><code id="get_cox_gradient_+3A_entry_points">entry_points</code></td>
<td>
<p>A numeric vector of entry times for the subjects. Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the gradient of the Cox proportional hazards model.
</p>

<hr>
<h2 id='get_cox_hessian'>Compute the Hessian Matrix for Cox Proportional Hazards Model</h2><span id='topic+get_cox_hessian'></span>

<h3>Description</h3>

<p>This function computes the Hessian matrix of the Cox proportional hazards model,
which is used for estimating the covariance matrix of the coefficients. The Hessian is calculated
by summing contributions from each event time in the risk set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_hessian(X, time, status, coefs, entry_points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_hessian_+3A_x">X</code></td>
<td>
<p>A matrix of covariates (design matrix) for the Cox model.</p>
</td></tr>
<tr><td><code id="get_cox_hessian_+3A_time">time</code></td>
<td>
<p>A numeric vector of event times.</p>
</td></tr>
<tr><td><code id="get_cox_hessian_+3A_status">status</code></td>
<td>
<p>A numeric vector of event indicators (1 for event, 0 for censored).</p>
</td></tr>
<tr><td><code id="get_cox_hessian_+3A_coefs">coefs</code></td>
<td>
<p>A numeric vector of coefficients for the Cox model.</p>
</td></tr>
<tr><td><code id="get_cox_hessian_+3A_entry_points">entry_points</code></td>
<td>
<p>A numeric vector of entry times for the subjects. Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the negative Hessian of the Cox model.
</p>

<hr>
<h2 id='get_cox_kappa'>Estimate the kappa value for the synthetic Cox proportional hazards model</h2><span id='topic+get_cox_kappa'></span>

<h3>Description</h3>

<p>This function iterative estimates the kappa value for the synthetic Cox proportional hazards model using a vectorized approach for efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_kappa(X, time, status, hazard_constant)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_kappa_+3A_x">X</code></td>
<td>
<p>A matrix of covariates with rows representing observations and columns representing features.</p>
</td></tr>
<tr><td><code id="get_cox_kappa_+3A_time">time</code></td>
<td>
<p>A vector of time-to-event data.</p>
</td></tr>
<tr><td><code id="get_cox_kappa_+3A_status">status</code></td>
<td>
<p>A vector indicating event occurrence (1 = event, 0 = censored).</p>
</td></tr>
<tr><td><code id="get_cox_kappa_+3A_hazard_constant">hazard_constant</code></td>
<td>
<p>A scalar representing the hazard constant. Defaults to NULL, in which case it's calculated internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the estimated kappa for the synthetic Cox model.
</p>

<hr>
<h2 id='get_cox_partial_likelihood'>Compute the Partial Likelihood for the Cox Proportional Hazards Model</h2><span id='topic+get_cox_partial_likelihood'></span>

<h3>Description</h3>

<p>This function calculates the partial likelihood for the Cox proportional hazards model. The partial likelihood is computed for the censored observations in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_partial_likelihood(X, time, status, coefs, entry_points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_partial_likelihood_+3A_x">X</code></td>
<td>
<p>A matrix of covariates with rows representing observations and columns representing features.</p>
</td></tr>
<tr><td><code id="get_cox_partial_likelihood_+3A_time">time</code></td>
<td>
<p>A vector of time-to-event data.</p>
</td></tr>
<tr><td><code id="get_cox_partial_likelihood_+3A_status">status</code></td>
<td>
<p>A vector indicating the event status (1 for event occurred, 0 for censored).</p>
</td></tr>
<tr><td><code id="get_cox_partial_likelihood_+3A_coefs">coefs</code></td>
<td>
<p>A vector of regression coefficients.</p>
</td></tr>
<tr><td><code id="get_cox_partial_likelihood_+3A_entry_points">entry_points</code></td>
<td>
<p>A vector of entry points (optional). Defaults to NULL, in which case a vector of zeros is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar representing the partial likelihood of the Cox model.
</p>

<hr>
<h2 id='get_cox_qr_solve'>Solve Linear System using QR Decomposition</h2><span id='topic+get_cox_qr_solve'></span>

<h3>Description</h3>

<p>This function solves the linear system defined by <code>hessian_matrix</code> and <code>gradient_vector</code>
using QR decomposition. Any NA values in the resulting solution vector are replaced with 0.0001. If there
is an error during the solution process, a vector of default values (0.0001) is returned instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_qr_solve(hessian_matrix, gradient_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_qr_solve_+3A_hessian_matrix">hessian_matrix</code></td>
<td>
<p>A matrix of coefficients representing the system of linear equations.</p>
</td></tr>
<tr><td><code id="get_cox_qr_solve_+3A_gradient_vector">gradient_vector</code></td>
<td>
<p>A numeric vector representing the constants in the linear system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the solution to the linear system. NA values in the solution
are replaced with a small value (0.0001). If an error occurs during solving, a vector of default values
(0.0001) is returned.
</p>

<hr>
<h2 id='get_cox_risk_and_failure_sets'>Calculate Risk and Failure Sets for Cox Proportional Hazards Model</h2><span id='topic+get_cox_risk_and_failure_sets'></span>

<h3>Description</h3>

<p>This function calculates the risk and failure sets for subjects in a Cox proportional hazards model based on their time-to-event data, status, and an indicator vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_risk_and_failure_sets(time_vector, status_vector, indicator_vector)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_risk_and_failure_sets_+3A_time_vector">time_vector</code></td>
<td>
<p>A numeric vector of time-to-event data for each subject.</p>
</td></tr>
<tr><td><code id="get_cox_risk_and_failure_sets_+3A_status_vector">status_vector</code></td>
<td>
<p>A numeric vector indicating event occurrence (1 = event, 0 = censored).</p>
</td></tr>
<tr><td><code id="get_cox_risk_and_failure_sets_+3A_indicator_vector">indicator_vector</code></td>
<td>
<p>A numeric vector representing the indicator times used to define risk and failure sets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing two elements:
</p>

<ul>
<li> <p><code>risk_set</code>: A matrix indicating which subjects are at risk at each time point.
</p>
</li>
<li> <p><code>failure_set</code>: A matrix indicating which subjects experienced an event at each time point.
</p>
</li></ul>


<hr>
<h2 id='get_cox_risk_set_idx'>Identify the risk set indices for Cox proportional hazards model</h2><span id='topic+get_cox_risk_set_idx'></span>

<h3>Description</h3>

<p>This function returns the indices of the risk set for a given time of interest in the Cox proportional hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_risk_set_idx(
  time_of_interest,
  entry_vector,
  time_vector,
  status_vector
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_risk_set_idx_+3A_time_of_interest">time_of_interest</code></td>
<td>
<p>A numeric value representing the time at which the risk set is calculated.</p>
</td></tr>
<tr><td><code id="get_cox_risk_set_idx_+3A_entry_vector">entry_vector</code></td>
<td>
<p>A numeric vector representing the entry times of subjects.</p>
</td></tr>
<tr><td><code id="get_cox_risk_set_idx_+3A_time_vector">time_vector</code></td>
<td>
<p>A numeric vector representing the time-to-event or censoring times of subjects.</p>
</td></tr>
<tr><td><code id="get_cox_risk_set_idx_+3A_status_vector">status_vector</code></td>
<td>
<p>A numeric vector indicating event occurrence (1) or censoring (0) for each subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of indices representing the subjects at risk at the specified time of interest.
</p>

<hr>
<h2 id='get_cox_syn_gradient'>Compute the gradient of the synthetic Cox proportional hazards model</h2><span id='topic+get_cox_syn_gradient'></span>

<h3>Description</h3>

<p>This function calculates the gradient of the synthetic Cox proportional hazards model using a vectorized approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_syn_gradient(X, time, coefs, hazard_constant)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_syn_gradient_+3A_x">X</code></td>
<td>
<p>A matrix of covariates with rows representing observations and columns representing features.</p>
</td></tr>
<tr><td><code id="get_cox_syn_gradient_+3A_time">time</code></td>
<td>
<p>A vector of time-to-event data.</p>
</td></tr>
<tr><td><code id="get_cox_syn_gradient_+3A_coefs">coefs</code></td>
<td>
<p>A vector of regression coefficients.</p>
</td></tr>
<tr><td><code id="get_cox_syn_gradient_+3A_hazard_constant">hazard_constant</code></td>
<td>
<p>A scalar representing the hazard constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the gradient of the synthetic Cox model.
</p>

<hr>
<h2 id='get_cox_syn_hessian'>Compute the Synthetic Hessian Matrix for Cox Proportional Hazards Model</h2><span id='topic+get_cox_syn_hessian'></span>

<h3>Description</h3>

<p>This function computes the synthetic Hessian matrix for the Cox proportional hazards model.
The Hessian is calculated by summing the contributions from each individual observation, scaled by
the hazard constant and the time of the event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_syn_hessian(X, time, coefs, hazard_constant)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_cox_syn_hessian_+3A_x">X</code></td>
<td>
<p>A matrix of covariates (design matrix) for the Cox model.</p>
</td></tr>
<tr><td><code id="get_cox_syn_hessian_+3A_time">time</code></td>
<td>
<p>A numeric vector of event times.</p>
</td></tr>
<tr><td><code id="get_cox_syn_hessian_+3A_coefs">coefs</code></td>
<td>
<p>A numeric vector of coefficients for the Cox model.</p>
</td></tr>
<tr><td><code id="get_cox_syn_hessian_+3A_hazard_constant">hazard_constant</code></td>
<td>
<p>A numeric value representing the hazard constant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the synthetic Hessian of the Cox model.
</p>

<hr>
<h2 id='get_discrepancy'>Compute Discrepancy Measures</h2><span id='topic+get_discrepancy'></span>

<h3>Description</h3>

<p>This function computes various discrepancy measures between observed and estimated values.
It supports different methods including logarithmic error, square error, classification error, and logistic deviance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_discrepancy(
  discrepancy_method = c("mean_logarithmic_error", "mean_square_error",
    "mean_classification_error", "logistic_deviance"),
  family_string = NULL,
  X = NULL,
  Y = NULL,
  coefs = NULL,
  est_Y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_discrepancy_+3A_discrepancy_method">discrepancy_method</code></td>
<td>
<p>A character string specifying the discrepancy method to use. Options are:
</p>

<dl>
<dt>&quot;logarithmic_error&quot;</dt><dd><p>Logarithmic error, suitable for probabilities.</p>
</dd>
<dt>&quot;mean_square_error&quot;</dt><dd><p>Mean squared error.</p>
</dd>
<dt>&quot;mean_classification_error&quot;</dt><dd><p>Mean of classification error, suitable for binary outcomes.</p>
</dd>
<dt>&quot;logistic_deviance&quot;</dt><dd><p>Logistic deviance, computed using a GLM model.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_discrepancy_+3A_family_string">family_string</code></td>
<td>
<p>A GLM family in string (e.g., &quot;binomial&quot;) used to compute logistic deviance.</p>
</td></tr>
<tr><td><code id="get_discrepancy_+3A_x">X</code></td>
<td>
<p>A matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="get_discrepancy_+3A_y">Y</code></td>
<td>
<p>A vector or data frame of observed values.</p>
</td></tr>
<tr><td><code id="get_discrepancy_+3A_coefs">coefs</code></td>
<td>
<p>A vector of coefficients for the GLM model.</p>
</td></tr>
<tr><td><code id="get_discrepancy_+3A_est_y">est_Y</code></td>
<td>
<p>A vector of estimated values. If not provided, it will be computed using <code>get_glm_mean</code> with the specified <code>family</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the discrepancy between observed and estimated values.
</p>

<hr>
<h2 id='get_formula_lhs'>Extract Left-Hand Side of Formula as String</h2><span id='topic+get_formula_lhs'></span>

<h3>Description</h3>

<p>This function extracts the left-hand side (LHS) of a formula object and converts it to a character string. It uses <code>get_formula_string</code> to ensure consistent formatting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formula_lhs(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_formula_lhs_+3A_formula">formula</code></td>
<td>
<p>A formula object from which the LHS will be extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the left-hand side of the formula.
</p>

<hr>
<h2 id='get_formula_rhs'>Extract the Right-Hand Side of a Formula</h2><span id='topic+get_formula_rhs'></span>

<h3>Description</h3>

<p>This function extracts the right-hand side (RHS) of a formula and returns it as a character string.
Optionally, it can include a tilde (<code>~</code>) at the beginning of the RHS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formula_rhs(formula, with_tilde = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_formula_rhs_+3A_formula">formula</code></td>
<td>
<p>A formula object from which to extract the RHS.</p>
</td></tr>
<tr><td><code id="get_formula_rhs_+3A_with_tilde">with_tilde</code></td>
<td>
<p>Logical, indicating whether to include a tilde (<code>~</code>) at the beginning of the RHS.
Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the right-hand side of the formula. If <code>with_tilde</code> is <code>TRUE</code>,
the string includes a leading tilde.
</p>

<hr>
<h2 id='get_formula_string'>Convert Formula to String</h2><span id='topic+get_formula_string'></span>

<h3>Description</h3>

<p>This function converts a formula object to a character string. It removes extra whitespace and formats the formula as a single line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formula_string(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_formula_string_+3A_formula">formula</code></td>
<td>
<p>A formula object to be converted to a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the formula.
</p>

<hr>
<h2 id='get_glm_custom_var'>Get Custom Variance for Generalized Linear Model (GLM)</h2><span id='topic+get_glm_custom_var'></span>

<h3>Description</h3>

<p>This function calculates a custom variance for a Generalized Linear Model (GLM) based on the specified formula,
the model initialization object, and a scaling factor <code>tau</code>. The custom variance is computed by adjusting
the residuals of the fitted model and returning a weighted sum of squared residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_glm_custom_var(formula, cat_init, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_glm_custom_var_+3A_formula">formula</code></td>
<td>
<p>A formula object specifying the GLM model to be fitted, such as <code>response ~ predictors</code>.</p>
</td></tr>
<tr><td><code id="get_glm_custom_var_+3A_cat_init">cat_init</code></td>
<td>
<p>A list object containing the initialization data for the model. Generated from <code>cat_initialization</code></p>
</td></tr>
<tr><td><code id="get_glm_custom_var_+3A_tau">tau</code></td>
<td>
<p>A numeric value representing a scaling factor for down-weighting synthetic data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the custom variance for the GLM model.
</p>

<hr>
<h2 id='get_glm_diag_approx_cov'>Compute Diagonal Approximate Covariance Matrix</h2><span id='topic+get_glm_diag_approx_cov'></span>

<h3>Description</h3>

<p>This function computes the diagonal elements of the approximate covariance matrix
for the coefficients in a generalized linear model (GLM). The covariance is derived
from the second derivative (Hessian) of the log-likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_glm_diag_approx_cov(X, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_glm_diag_approx_cov_+3A_x">X</code></td>
<td>
<p>Matrix. The design matrix (predictors) for the GLM.</p>
</td></tr>
<tr><td><code id="get_glm_diag_approx_cov_+3A_model">model</code></td>
<td>
<p>A fitted GLM model object. The object should contain the fitted values
and prior weights necessary for computing the Hessian.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector. The diagonal elements of the approximate covariance matrix.
</p>

<hr>
<h2 id='get_glm_family_string'>Retrieve GLM Family Name or Name with Link Function</h2><span id='topic+get_glm_family_string'></span>

<h3>Description</h3>

<p>This function retrieves the name of a GLM family or, optionally, the family name with the associated link function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_glm_family_string(family, with_link = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_glm_family_string_+3A_family">family</code></td>
<td>
<p>Character or function. The name of the GLM family (as a string) or a function that returns a GLM family object.</p>
</td></tr>
<tr><td><code id="get_glm_family_string_+3A_with_link">with_link</code></td>
<td>
<p>Logical. If TRUE, returns the family name along with the link function in the format &quot;family \[link\]&quot;.
If FALSE, only the family name is returned. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string. The name of the GLM family, or the name with the link function if <code>with_link</code> is TRUE.
</p>

<hr>
<h2 id='get_glm_lambda'>Compute Lambda Based on Discrepancy Method</h2><span id='topic+get_glm_lambda'></span>

<h3>Description</h3>

<p>This function calculates a lambda value based on the selected discrepancy method
for a generalized linear model (GLM). The discrepancy method determines the
type of error or deviance used in the calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_glm_lambda(
  discrepancy_method = c("mean_square_error", "mean_classification_error",
    "logistic_deviance"),
  X,
  coefs
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_glm_lambda_+3A_discrepancy_method">discrepancy_method</code></td>
<td>
<p>Character. A string specifying the type of discrepancy method
to use. Options are <code>"mean_square_error"</code>, <code>"mean_classification_error"</code>, or <code>"logistic_deviance"</code>.
Default is <code>"mean_square_error"</code>.</p>
</td></tr>
<tr><td><code id="get_glm_lambda_+3A_x">X</code></td>
<td>
<p>Matrix. The design matrix (predictors) for the GLM.</p>
</td></tr>
<tr><td><code id="get_glm_lambda_+3A_coefs">coefs</code></td>
<td>
<p>Numeric vector. The coefficients for the GLM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. The computed lambda value based on the selected discrepancy method.
</p>

<hr>
<h2 id='get_glm_log_density'>Compute Log Density Based on GLM Family</h2><span id='topic+get_glm_log_density'></span>

<h3>Description</h3>

<p>This function calculates the log density of the response variable given a generalized linear model (GLM)
based on the specified family. The log density is computed differently for binomial and gaussian families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_glm_log_density(family_string, X, Y, coefs, weights = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_glm_log_density_+3A_family_string">family_string</code></td>
<td>
<p>Character. The GLM family to use. Options are <code>"binomial"</code> or <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="get_glm_log_density_+3A_x">X</code></td>
<td>
<p>Matrix. The design matrix (predictors) for the GLM.</p>
</td></tr>
<tr><td><code id="get_glm_log_density_+3A_y">Y</code></td>
<td>
<p>Vector or data frame. The response variable for the GLM. If a data frame, it is converted to a numeric vector.</p>
</td></tr>
<tr><td><code id="get_glm_log_density_+3A_coefs">coefs</code></td>
<td>
<p>Numeric vector. The coefficients for the GLM.</p>
</td></tr>
<tr><td><code id="get_glm_log_density_+3A_weights">weights</code></td>
<td>
<p>Numeric vector. Weights for the observations. Default is <code>1</code> (no weighting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric. The computed log density of the response variable based on the specified family.
</p>

<hr>
<h2 id='get_glm_log_density_grad'>Compute Gradient of Log Density for GLM Families</h2><span id='topic+get_glm_log_density_grad'></span>

<h3>Description</h3>

<p>This function calculates the gradient of the log density with respect to the coefficients
for a given GLM family based on the provided predictors, response variable, and weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_glm_log_density_grad(family_string, X, Y, coefs, weights = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_glm_log_density_grad_+3A_family_string">family_string</code></td>
<td>
<p>Character. The GLM family to use. Options are <code>"binomial"</code> or <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="get_glm_log_density_grad_+3A_x">X</code></td>
<td>
<p>Matrix. The design matrix (predictors) for the GLM.</p>
</td></tr>
<tr><td><code id="get_glm_log_density_grad_+3A_y">Y</code></td>
<td>
<p>Vector. The response variable.</p>
</td></tr>
<tr><td><code id="get_glm_log_density_grad_+3A_coefs">coefs</code></td>
<td>
<p>Numeric vector. The coefficients for the GLM.</p>
</td></tr>
<tr><td><code id="get_glm_log_density_grad_+3A_weights">weights</code></td>
<td>
<p>Numeric vector. The weights for the GLM. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector. The gradient of the log density with respect to the coefficients
</p>

<hr>
<h2 id='get_glm_mean'>Compute Mean Based on GLM Family</h2><span id='topic+get_glm_mean'></span>

<h3>Description</h3>

<p>This function calculates the mean of the response variable for a generalized linear model (GLM)
based on the specified family. The calculation depends on whether the family is binomial or gaussian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_glm_mean(family_string, X, coefs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_glm_mean_+3A_family_string">family_string</code></td>
<td>
<p>Character. The GLM family to use. Options are <code>"binomial"</code> or <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="get_glm_mean_+3A_x">X</code></td>
<td>
<p>Matrix. The design matrix (predictors) for the GLM.</p>
</td></tr>
<tr><td><code id="get_glm_mean_+3A_coefs">coefs</code></td>
<td>
<p>Numeric vector. The coefficients for the GLM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector. The computed mean of the response variable based on the specified family.
</p>

<hr>
<h2 id='get_glm_sample_data'>Generate Sample Data for GLM</h2><span id='topic+get_glm_sample_data'></span>

<h3>Description</h3>

<p>This function generates sample data for a specified GLM family. It can generate
binomial or Gaussian distributed data based on the provided parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_glm_sample_data(family_string, n = 10, mean = 0, sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_glm_sample_data_+3A_family_string">family_string</code></td>
<td>
<p>Character. The family of the GLM. Options are <code>"binomial"</code> or <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="get_glm_sample_data_+3A_n">n</code></td>
<td>
<p>Integer. The number of samples to generate.</p>
</td></tr>
<tr><td><code id="get_glm_sample_data_+3A_mean">mean</code></td>
<td>
<p>Numeric. The mean of the distribution (used for both binomial and Gaussian).</p>
</td></tr>
<tr><td><code id="get_glm_sample_data_+3A_sd">sd</code></td>
<td>
<p>Numeric. The standard deviation of the distribution (used only for Gaussian).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of generated sample data.
</p>

<hr>
<h2 id='get_hmc_mcmc_result'>Run Hamiltonian Monte Carlo to Get MCMC Sample Result</h2><span id='topic+get_hmc_mcmc_result'></span>

<h3>Description</h3>

<p>This function uses Hamiltonian Monte Carlo (HMC) to generate samples for Markov Chain Monte Carlo (MCMC)
sampling from a target distribution specified by <code>neg_log_den_func</code>. Each iteration performs a full HMC update
to generate a new sample position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hmc_mcmc_result(
  neg_log_den_func,
  neg_log_den_grad_func,
  coefs_0,
  iter = 5,
  hmc_scale = 0.01,
  hmc_steps = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_hmc_mcmc_result_+3A_neg_log_den_func">neg_log_den_func</code></td>
<td>
<p>A function that computes the negative log-density of the target distribution at a given position.</p>
</td></tr>
<tr><td><code id="get_hmc_mcmc_result_+3A_neg_log_den_grad_func">neg_log_den_grad_func</code></td>
<td>
<p>A function that computes the gradient of <code>neg_log_den_func</code> at a given position.</p>
</td></tr>
<tr><td><code id="get_hmc_mcmc_result_+3A_coefs_0">coefs_0</code></td>
<td>
<p>A numeric vector specifying the initial position of the chain in the parameter space.</p>
</td></tr>
<tr><td><code id="get_hmc_mcmc_result_+3A_iter">iter</code></td>
<td>
<p>An integer specifying the number of HMC sampling iterations. Defaults to 5.</p>
</td></tr>
<tr><td><code id="get_hmc_mcmc_result_+3A_hmc_scale">hmc_scale</code></td>
<td>
<p>A numeric value representing the scale factor for the leapfrog step size in the HMC update. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="get_hmc_mcmc_result_+3A_hmc_steps">hmc_steps</code></td>
<td>
<p>An integer specifying the number of leapfrog steps in each HMC update. Defaults to 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the final position in the parameter space after the specified number of iterations.
</p>

<hr>
<h2 id='get_linear_predictor'>Compute Linear Predictor</h2><span id='topic+get_linear_predictor'></span>

<h3>Description</h3>

<p>This function computes the linear predictor from a matrix of predictor variables and a vector of coefficients.
It handles cases with and without an intercept term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_linear_predictor(X, coefs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_linear_predictor_+3A_x">X</code></td>
<td>
<p>A matrix of predictor variables.</p>
</td></tr>
<tr><td><code id="get_linear_predictor_+3A_coefs">coefs</code></td>
<td>
<p>A vector of coefficients. It should be either the same length as the number of columns in X
(for models without an intercept) or one more than the number of columns in X (for models with an intercept).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of linear predictor values.
</p>

<hr>
<h2 id='get_resampled_df'>Resampling Methods for Data Processing</h2><span id='topic+get_resampled_df'></span>

<h3>Description</h3>

<p>This function includes various resampling methods applied to input data for each column to prepare it
for analysis. These methods help to transform the data distribution and improve model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_resampled_df(
  data,
  resample_size,
  data_degree = NULL,
  resample_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_resampled_df_+3A_data">data</code></td>
<td>
<p>A data frame to be resampled.</p>
</td></tr>
<tr><td><code id="get_resampled_df_+3A_resample_size">resample_size</code></td>
<td>
<p>An integer specifying the size of the resample.</p>
</td></tr>
<tr><td><code id="get_resampled_df_+3A_data_degree">data_degree</code></td>
<td>
<p>A numeric vector indicating the degree of each column in the data (optional).</p>
</td></tr>
<tr><td><code id="get_resampled_df_+3A_resample_only">resample_only</code></td>
<td>
<p>A logical value indicating whether to return only the resampled data (default is FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><strong>Coordinate</strong>: This method refers to the preservation of the original data values as reference coordinates during processing.
It ensures that the transformations applied are based on the initial structure of the data.
</p>
</li>
<li> <p><strong>Deskewing</strong>:Deskewing is the process of adjusting the data distribution to reduce skewness, making it more symmetric.
If the absolute value of skewness is greater than or equal to 1, deskewing techniques will be applied
to normalize the distribution, which can enhance model performance.
</p>
</li>
<li> <p><strong>Smoothing</strong>: Smoothing techniques reduce noise in the data by averaging or modifying data points.
This is especially useful when there are many unique values in the original data column, as it helps
to stabilize the dataset and prevent overfitting during model training.
</p>
</li>
<li> <p><strong>Flattening</strong>: Flattening modifies the data to create a more uniform distribution across its range.
This method is employed when the frequency of certain categories in categorical variables is low,
replacing some original values with randomly selected unique values from the dataset to reduce sparsity.
</p>
</li>
<li> <p><strong>Symmetrizing</strong>: Symmetrizing adjusts the data so that it becomes more balanced around its mean.
This is crucial for achieving better statistical properties and improving the robustness of the model
fitting process.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>resampled_df</code></td>
<td>
<p>A data frame of resampled data.</p>
</td></tr>
<tr><td><code>resampled_df_log</code></td>
<td>
<p>A data frame recording the resampling process for each column.</p>
</td></tr>
</table>

<hr>
<h2 id='get_stan_model'>Generate Stan Model Based on Specified Parameters</h2><span id='topic+get_stan_model'></span>

<h3>Description</h3>

<p>This function retrieves a Stan model file based on a combination of input parameters,
constructs the file path, and loads the Stan model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stan_model(
  type = c("glm", "cox"),
  glm_family_string = c("gaussian", "binomial"),
  joint_tau = FALSE,
  glm_binomial_joint_theta = FALSE,
  glm_binomial_joint_alpha = FALSE,
  glm_gaussian_known_variance = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_stan_model_+3A_type">type</code></td>
<td>
<p>Character, either <code>"glm"</code> or <code>"cox"</code>, specifying the type of model to load.</p>
</td></tr>
<tr><td><code id="get_stan_model_+3A_glm_family_string">glm_family_string</code></td>
<td>
<p>Character, specifying the family for GLM models, either <code>"binomial"</code> or <code>"gaussian"</code>.
Required for <code>"glm"</code> models, ignored for <code>"cox"</code> models.</p>
</td></tr>
<tr><td><code id="get_stan_model_+3A_joint_tau">joint_tau</code></td>
<td>
<p>Logical, if <code>TRUE</code>, includes &quot;joint&quot; in the file name to indicate a joint model with tau parameter.</p>
</td></tr>
<tr><td><code id="get_stan_model_+3A_glm_binomial_joint_theta">glm_binomial_joint_theta</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>glm_family_string</code> is <code>"binomial"</code>, includes &quot;theta&quot; in the
file name for joint theta parameter.</p>
</td></tr>
<tr><td><code id="get_stan_model_+3A_glm_binomial_joint_alpha">glm_binomial_joint_alpha</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>glm_family_string</code> is <code>"binomial"</code>, includes &quot;alpha&quot; in the
file name for joint alpha parameter.</p>
</td></tr>
<tr><td><code id="get_stan_model_+3A_glm_gaussian_known_variance">glm_gaussian_known_variance</code></td>
<td>
<p>Logical, if <code>TRUE</code> and <code>glm_family_string</code> is <code>"gaussian"</code>, includes
&quot;known_variance&quot; in the file name to specify known variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compiled Stan model loaded by <code>rstan::stan_model</code>.
</p>

<hr>
<h2 id='get_standardized_data'>Standardize Data</h2><span id='topic+get_standardized_data'></span>

<h3>Description</h3>

<p>This function standardizes a dataset by converting columns to numeric or factor types and replacing NA values.
For continuous variables, NA values are replaced with either a specific numeric value or a computed statistic.
For categorical variables, NA values are replaced with the mode of the column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_standardized_data(data, na_replace = stats::na.omit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_standardized_data_+3A_data">data</code></td>
<td>
<p>A data frame to be standardized.</p>
</td></tr>
<tr><td><code id="get_standardized_data_+3A_na_replace">na_replace</code></td>
<td>
<p>A function or numeric value used to replace NA values. If a function, it should take a vector and return a replacement value.
If a numeric value, it is used directly to replace NA values in continuous columns.
The default is <code>stats::na.omit</code>, which omits rows with NA values (used as an indicator here, not the actual replacement value).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where columns have been converted to numeric or factor types, and NA values have been replaced according to the method specified.
</p>

<hr>
<h2 id='hmc_neal_2010'>Hamiltonian Monte Carlo (HMC) Implementation</h2><span id='topic+hmc_neal_2010'></span>

<h3>Description</h3>

<p>This function implements the Hamiltonian Monte Carlo algorithm as
described by Radford M. Neal (2010) in &quot;MCMC using Hamiltonian dynamics&quot;,
which is a part of the Handbook of Markov Chain Monte Carlo. The method uses
Hamiltonian dynamics to propose new positions and then applies the Metropolis
criterion to decide whether to accept or reject the new position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hmc_neal_2010(
  neg_log_den_func,
  neg_log_den_grad_func,
  leapfrog_stepsize,
  leapfrog_step,
  current_pos
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hmc_neal_2010_+3A_neg_log_den_func">neg_log_den_func</code></td>
<td>
<p>A function that evaluates the negative log of the density
(potential energy) of the distribution to be sampled,
including any constants.</p>
</td></tr>
<tr><td><code id="hmc_neal_2010_+3A_neg_log_den_grad_func">neg_log_den_grad_func</code></td>
<td>
<p>A function that computes the gradient of
<code>neg_log_den_func</code>.</p>
</td></tr>
<tr><td><code id="hmc_neal_2010_+3A_leapfrog_stepsize">leapfrog_stepsize</code></td>
<td>
<p>A numeric value specifying the step size for the
leapfrog integration method.</p>
</td></tr>
<tr><td><code id="hmc_neal_2010_+3A_leapfrog_step">leapfrog_step</code></td>
<td>
<p>A numeric value specifying the number of leapfrog steps
to take to propose a new state.</p>
</td></tr>
<tr><td><code id="hmc_neal_2010_+3A_current_pos">current_pos</code></td>
<td>
<p>A numeric vector representing the current position (state)
of the system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written for illustrative purposes. More elaborate
on Radford M. Neal's personal webpage (http://www.cs.utoronto.ca/~radford/).
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>position</code>: The position of the system after the leapfrog steps, which is
the proposed new position if accepted, or the current position
if rejected.
</p>
</li>
<li> <p><code>potential_energy</code>: The potential energy of the proposed position.
</p>
</li>
<li> <p><code>accepted</code>: A logical value indicating whether the proposal was accepted
(TRUE) or rejected (FALSE).
</p>
</li></ul>



<h3>References</h3>

<p>Neal, R. M. (2012). MCMC using Hamiltonian dynamics.
arXiv:1206.1901. Available at: <a href="https://arxiv.org/pdf/1206.1901">https://arxiv.org/pdf/1206.1901</a>
</p>

<hr>
<h2 id='is.continuous'>Check if a Variable is Continuous</h2><span id='topic+is.continuous'></span>

<h3>Description</h3>

<p>This function checks whether a given vector represents a continuous variable. A continuous variable is numeric and has more than two unique values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.continuous(lst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.continuous_+3A_lst">lst</code></td>
<td>
<p>A vector to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether the input vector is considered continuous. Returns <code>TRUE</code> if the vector is numeric and has more than two unique values; otherwise, returns <code>FALSE</code>.
</p>

<hr>
<h2 id='mallowian_estimate'>Perform Mallowian Estimate for Model Risk (Only Applicable for Gaussian Family)</h2><span id='topic+mallowian_estimate'></span>

<h3>Description</h3>

<p>This function calculates the Mallowian estimate for model risk by fitting a sequence of
Generalized Linear Models (GLMs) with varying values of <code>tau</code>. It uses the in-sample prediction
error along with a regularized projection matrix to estimate the model risk. The <code>tau</code> parameter
influences the weighting of synthetic data during model fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mallowian_estimate(formula, cat_init, tau_seq, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mallowian_estimate_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables.</p>
</td></tr>
<tr><td><code id="mallowian_estimate_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="mallowian_estimate_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A sequence of tuning parameter values (<code>tau</code>) over which
the Mallowian estimate will be computed. Each value of <code>tau</code> is used to weight the
synthetic data during model fitting.</p>
</td></tr>
<tr><td><code id="mallowian_estimate_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li> <p><strong>Model Fitting</strong>: For each value of <code>tau</code> in <code>tau_seq</code>, the function fits a GLM model
using the observed and synthetic data. The synthetic data is weighted by the corresponding
<code>tau</code> value during the fitting process.
</p>
</li>
<li> <p><strong>In-sample Prediction Error</strong>: After fitting the model, the function computes the
in-sample prediction error (Mean Squared Error) to assess the model's performance.
</p>
</li>
<li> <p><strong>Regularized Projection Matrix</strong>: The function calculates a regularized projection matrix
using the observed and synthetic data, which influences the covariance matrix used in risk estimation.
</p>
</li>
<li> <p><strong>Mallowian Risk Estimate</strong>: The final Mallowian risk estimate is computed by combining the
in-sample prediction error with a penalty term involving the projection matrix and a variance term.
This estimate is calculated for each value of <code>tau</code> in <code>tau_seq</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A numeric vector of Mallowian risk estimates, one for each value of <code>tau</code> in <code>tau_seq</code>.
</p>

<hr>
<h2 id='parametric_bootstrap'>Perform Parametric Bootstrap for Model Risk Estimation</h2><span id='topic+parametric_bootstrap'></span>

<h3>Description</h3>

<p>This function performs parametric bootstrapping to estimate model risk. It fits a sequence
of Generalized Linear Models (GLMs) with different values of <code>tau</code>, calculates the in-sample
prediction error, and incorporates deviations from the bootstrap response samples. The final
risk estimate is obtained by combining the in-sample error and the covariance penalty derived
from the bootstrap samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametric_bootstrap(
  formula,
  cat_init,
  tau_seq,
  tau_0,
  discrepancy_method,
  parametric_bootstrap_iteration_times,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parametric_bootstrap_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables.</p>
</td></tr>
<tr><td><code id="parametric_bootstrap_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="parametric_bootstrap_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A sequence of tuning parameter values (<code>tau</code>) over which
the model risk will be estimated. Each <code>tau</code> value is used to weight the synthetic data during model fitting.</p>
</td></tr>
<tr><td><code id="parametric_bootstrap_+3A_tau_0">tau_0</code></td>
<td>
<p>A reference value for <code>tau</code> used in the preliminary estimate model and variance calculation.</p>
</td></tr>
<tr><td><code id="parametric_bootstrap_+3A_discrepancy_method">discrepancy_method</code></td>
<td>
<p>The method used to calculate the discrepancy (e.g., logistic deviance).</p>
</td></tr>
<tr><td><code id="parametric_bootstrap_+3A_parametric_bootstrap_iteration_times">parametric_bootstrap_iteration_times</code></td>
<td>
<p>The number of bootstrap iterations to perform.</p>
</td></tr>
<tr><td><code id="parametric_bootstrap_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li> <p><strong>Preliminary Estimate Model</strong>: The function first fits a GLM model using the observed
and synthetic data with an initial value of <code>tau_0</code> for the synthetic data weights.
</p>
</li>
<li> <p><strong>Bootstrap Samples</strong>: The function generates bootstrap response samples based on the
mean and standard deviation of the preliminary estimate model, using parametric bootstrapping.
</p>
</li>
<li> <p><strong>In-sample Prediction Error</strong>: For each value of <code>tau</code> in <code>tau_seq</code>, the function computes
the in-sample prediction error (e.g., using logistic deviance).
</p>
</li>
<li> <p><strong>Bootstrap Models</strong>: For each bootstrap iteration, the function fits a GLM using the
bootstrap response samples and calculates the corresponding lambda values.
</p>
</li>
<li> <p><strong>Covariance Penalty</strong>: The function approximates the covariance penalty using the weighted
deviations across all bootstrap iterations.
</p>
</li>
<li> <p><strong>Final Risk Estimate</strong>: The final model risk estimate is calculated by summing the in-sample
prediction error and the average weighted deviations from the bootstrap response samples.
</p>
</li></ol>



<h3>Value</h3>

<p>A numeric vector containing the risk estimates for each <code>tau</code> in <code>tau_seq</code>.
</p>

<hr>
<h2 id='plot.cat_tune'>Plot Likelihood or Risk Estimate vs. Tau for Tuning Model</h2><span id='topic+plot.cat_tune'></span>

<h3>Description</h3>

<p>This function generates a plot showing the relationship between
the tuning parameter <code>tau</code> and either the likelihood score (for a <code>cat_cox_tune</code> model)
or the risk estimate (for other models) during cross-validation or other model evaluation methods.
The plot highlights the optimal <code>tau</code> value and provides visual cues for
the best tuning parameter based on the specified method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_tune'
plot(x, digit = 2, legend_pos = "topright", text_pos = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cat_tune_+3A_x">x</code></td>
<td>
<p>A fitted model object of class <code>cat_tune</code> that contains the
results of the tuning process. This object includes the likelihood or risk estimate lists,
the tuning sequence (<code>tau_seq</code>), and the selected optimal <code>tau</code>.</p>
</td></tr>
<tr><td><code id="plot.cat_tune_+3A_digit">digit</code></td>
<td>
<p>An integer specifying the number of decimal places to round the
displayed values (default is 2).</p>
</td></tr>
<tr><td><code id="plot.cat_tune_+3A_legend_pos">legend_pos</code></td>
<td>
<p>A character string specifying the position of the legend on
the plot (default is <code>"topright"</code>).</p>
</td></tr>
<tr><td><code id="plot.cat_tune_+3A_text_pos">text_pos</code></td>
<td>
<p>An integer specifying the position of the text label on the
plot (default is 3, which places the text above the point).</p>
</td></tr>
<tr><td><code id="plot.cat_tune_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a line plot with <code>tau_seq</code> on the x-axis and either
the likelihood score or risk estimate on the y-axis. If the model is of class
<code>cat_cox_tune</code>, the plot shows the likelihood score, while for other models,
it shows the risk estimates. The optimal <code>tau</code> is marked with a red cross,
and red dashed lines are drawn to highlight the optimal point on the plot.
</p>


<h3>Value</h3>

<p>A plot with the specified y-values plotted against <code>tau_seq</code>,
including a highlighted optimal <code>tau</code> point.
</p>

<hr>
<h2 id='predict.cat_cox'>Predict Linear Predictor for New Data Using a Fitted Cox Model</h2><span id='topic+predict.cat_cox'></span>

<h3>Description</h3>

<p>This function calculates the linear predictor (LP) for new data points based on a fitted Cox proportional hazards model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_cox'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cat_cox_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>cat_cox</code>, containing the COX fit and model details.</p>
</td></tr>
<tr><td><code id="predict.cat_cox_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame with new predictor values. If <code>NULL</code>,
the function uses the observation data from the model's initialization object.</p>
</td></tr>
<tr><td><code id="predict.cat_cox_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of linear predictor values for the specified new data.
</p>

<hr>
<h2 id='predict.cat_glm'>Predict Outcome for New Data Using a Fitted GLM Model</h2><span id='topic+predict.cat_glm'></span>

<h3>Description</h3>

<p>This function generates predictions for new data points based on a fitted categorical Generalized Linear Model (GLM) object.
Depending on the type of model, it either uses <code>stats::predict.glm</code> or calculates predictions based on the model coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_glm'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cat_glm_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>cat_glm</code>, containing the GLM fit and model details.</p>
</td></tr>
<tr><td><code id="predict.cat_glm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame containing new predictor values. If <code>NULL</code>,
the function uses the observation data from the model's initialization object.</p>
</td></tr>
<tr><td><code id="predict.cat_glm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>stats::predict.glm</code>, if applicable.
User should input <code>type = c("link", "response", "terms")</code> for different regression models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted values for the specified new data.
</p>

<hr>
<h2 id='predict.cat_lmm'>Predict Linear Predictor for New Data Using a Fitted Linear Mixed Model</h2><span id='topic+predict.cat_lmm'></span>

<h3>Description</h3>

<p>This function calculates the linear predictor (LP) for new data points based on a fitted linear mixed model (LMM) stored in <code>object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_lmm'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.cat_lmm_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>cat_lmm</code>, containing the LMM fit and model details.</p>
</td></tr>
<tr><td><code id="predict.cat_lmm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame with new predictor values. If <code>NULL</code>,
the function uses the observation data from the model's initialization object.</p>
</td></tr>
<tr><td><code id="predict.cat_lmm_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of linear predictor values for the specified new data.
</p>

<hr>
<h2 id='print_df_head_tail'>Print Data Frame with Head and Tail Rows</h2><span id='topic+print_df_head_tail'></span>

<h3>Description</h3>

<p>This function displays the first 5 and last 5 rows of a data frame.
Column names are displayed only for the first 5 rows, with ellipses (<code>...</code>)
in the middle to indicate additional rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_df_head_tail(df, digit = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_df_head_tail_+3A_df">df</code></td>
<td>
<p>A data frame to display.</p>
</td></tr>
<tr><td><code id="print_df_head_tail_+3A_digit">digit</code></td>
<td>
<p>An integer specifying the number of decimal places to which the summary
statistics should be rounded. Default is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the original data frame.
</p>

<hr>
<h2 id='print_glm_bayes_joint_binomial_suggestion'>Generate Suggestions for Bayesian Joint Binomial GLM Parameter Estimation</h2><span id='topic+print_glm_bayes_joint_binomial_suggestion'></span>

<h3>Description</h3>

<p>This function provides suggestions for improving the parameter estimation process
in Bayesian joint Binomial GLM modeling based on the diagnostic output from a Stan model.
It evaluates the results and suggests adjustments to improve model fit and convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_glm_bayes_joint_binomial_suggestion(
  alpha,
  stan_iter,
  stan_sample_model,
  binomial_joint_theta,
  binomial_joint_alpha,
  binomial_tau_lower
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_glm_bayes_joint_binomial_suggestion_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. The alpha parameter used in the prior distribution.</p>
</td></tr>
<tr><td><code id="print_glm_bayes_joint_binomial_suggestion_+3A_stan_iter">stan_iter</code></td>
<td>
<p>Integer. The number of iterations used in Stan sampling.</p>
</td></tr>
<tr><td><code id="print_glm_bayes_joint_binomial_suggestion_+3A_stan_sample_model">stan_sample_model</code></td>
<td>
<p>Stan model object containing sampling results.</p>
</td></tr>
<tr><td><code id="print_glm_bayes_joint_binomial_suggestion_+3A_binomial_joint_theta">binomial_joint_theta</code></td>
<td>
<p>Logical. Whether to use theta in the binomial model.</p>
</td></tr>
<tr><td><code id="print_glm_bayes_joint_binomial_suggestion_+3A_binomial_joint_alpha">binomial_joint_alpha</code></td>
<td>
<p>Logical. Whether to use joint alpha in the binomial model.</p>
</td></tr>
<tr><td><code id="print_glm_bayes_joint_binomial_suggestion_+3A_binomial_tau_lower">binomial_tau_lower</code></td>
<td>
<p>Numeric. The lower bound for tau in the binomial model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL. The function prints suggestions to the console based on the model diagnostics.
</p>

<hr>
<h2 id='print.cat'>Print Method for <code>cat</code> Object</h2><span id='topic+print.cat'></span>

<h3>Description</h3>

<p>The <code>print.cat</code> function provides a detailed summary of the <code>cat</code> object, displaying key information about the model and its settings,
including model type, covariates, formula, tau values, and relevant coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat'
print(x, digit = 3, detail = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cat_+3A_x">x</code></td>
<td>
<p>An object of class <code>cat</code>, representing a fitted model.</p>
</td></tr>
<tr><td><code id="print.cat_+3A_digit">digit</code></td>
<td>
<p>An integer indicating the number of decimal places for printing
coefficient estimates. Default is 3.</p>
</td></tr>
<tr><td><code id="print.cat_+3A_detail">detail</code></td>
<td>
<p>A logical indicating whether to print additional details for interpreting the output. Default is TRUE.</p>
</td></tr>
<tr><td><code id="print.cat_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function customizes the output based on the model type stored within the <code>x</code> object, such as GLM, Cox, or other types of models.
</p>
<p>The <code>print.cat</code> function prints a summary of the model stored in the <code>x</code> object. It will display different information
depending on the model's type (GLM, Cox, etc.). It will show:
</p>

<ul>
<li><p> The model's function name.
</p>
</li>
<li><p> The dimensions of the covariates used in the model.
</p>
</li>
<li><p> The tau values.
</p>
</li>
<li><p> Model-specific details such as family for GLMs or method and iteration info for Cox models.
</p>
</li>
<li><p> Coefficients related to the model.
</p>
</li></ul>



<h3>Value</h3>

<p>The <code>x</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.cat_bayes'>Print Summary of <code>cat_bayes</code> Model</h2><span id='topic+print.cat_bayes'></span>

<h3>Description</h3>

<p>This function prints a formatted summary of a <code>cat_bayes</code> model object, displaying
key parameters and settings of the fitted model, including the formula,
covariate dimensions, tau (if applicable), family, and algorithm settings,
as well as the coefficients' summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_bayes'
print(x, digit = 3, detail = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cat_bayes_+3A_x">x</code></td>
<td>
<p>An object of class <code>cat_tune</code>, typically resulting from a tuning process, including
<code>cat_glm_bayes</code>, <code>cat_glm_bayes_joint</code>, <code>cat_cox_bayes</code> and <code>cat_cox_bayes_joint</code>.</p>
</td></tr>
<tr><td><code id="print.cat_bayes_+3A_digit">digit</code></td>
<td>
<p>An integer indicating the number of decimal places for printing
coefficient estimates. Default is 3.</p>
</td></tr>
<tr><td><code id="print.cat_bayes_+3A_detail">detail</code></td>
<td>
<p>A logical value indicating whether to include additional detailed output at the end of the summary.
If <code>TRUE</code>, it will print additional interpretation help.</p>
</td></tr>
<tr><td><code id="print.cat_bayes_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an organized printout of essential details from a Bayesian
model fit. It includes the model formula, dimensionality of covariates, model
family, Stan algorithm settings, and summary of the model coefficients. If
<code>detail</code> is set to <code>TRUE</code>, additional information on interpreting the
output is included.
</p>


<h3>Value</h3>

<p>The <code>x</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.cat_gibbs'>Print Summary of <code>cat_gibbs</code> Model</h2><span id='topic+print.cat_gibbs'></span>

<h3>Description</h3>

<p>This function prints a summary of the <code>cat_gibbs</code> model, displaying details about the formula, covariate dimensions,
family, coefficients, and Gibbs sampling settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_gibbs'
print(x, digit = 3, detail = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cat_gibbs_+3A_x">x</code></td>
<td>
<p>A <code>cat_gibbs</code> model object containing the results of a Bayesian GLM fitted using Gibbs sampling.</p>
</td></tr>
<tr><td><code id="print.cat_gibbs_+3A_digit">digit</code></td>
<td>
<p>An integer indicating the number of decimal places for printing
coefficient estimates. Default is 3.</p>
</td></tr>
<tr><td><code id="print.cat_gibbs_+3A_detail">detail</code></td>
<td>
<p>A logical value indicating whether to include additional detailed output at the end of the summary.
If <code>TRUE</code>, it will print additional interpretation help.</p>
</td></tr>
<tr><td><code id="print.cat_gibbs_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The summary includes:
</p>

<ul>
<li><p> The function name and formula used in the model.
</p>
</li>
<li><p> Dimensions of the covariate matrix.
</p>
</li>
<li><p> Family and link function details.
</p>
</li>
<li><p> Sampling information, including the total iterations, warm-up iterations, and effective Gibbs sampling post-warmup.
</p>
</li>
<li><p> Coefficients with summary statistics and effective sample size.
</p>
</li></ul>

<p>If <code>detail</code> is set to TRUE, additional guidance for interpreting the printed output is provided.
</p>


<h3>Value</h3>

<p>The <code>x</code> object is returned invisibly.
</p>

<hr>
<h2 id='print.cat_initialization'>Print Summary for Catalytic Initialization Model</h2><span id='topic+print.cat_initialization'></span>

<h3>Description</h3>

<p>This function provides a comprehensive summary of a catalytic initialization model object (<code>cat_init</code>),
including formula details, data dimensions, and sample data previews.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_initialization'
print(x, show_data = TRUE, detail = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cat_initialization_+3A_x">x</code></td>
<td>
<p>A catalytic initialization model object containing formula, family, data dimensions, and sampling details.</p>
</td></tr>
<tr><td><code id="print.cat_initialization_+3A_show_data">show_data</code></td>
<td>
<p>Logical, default <code>TRUE</code>. If <code>TRUE</code>, previews the head of both observation and synthetic data (up to the first 10 columns).</p>
</td></tr>
<tr><td><code id="print.cat_initialization_+3A_detail">detail</code></td>
<td>
<p>Logical, default <code>TRUE</code>. If <code>TRUE</code>, adds guidance for interpreting the output.</p>
</td></tr>
<tr><td><code id="print.cat_initialization_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides a detailed overview of the initialization process for the <code>cat_initialization</code> model,
including:
</p>

<ul>
<li><p> The formula used in the model.
</p>
</li>
<li><p> The type of model (if Gaussian, the known or unknown variance is specified).
</p>
</li>
<li><p> The family of the Generalized Linear Model (GLM), along with the associated link function.
</p>
</li>
<li><p> The dimensions of the observation and synthetic data sets, with an option to display the first few rows.
</p>
</li>
<li><p> Information on the data generation process if available.
</p>
</li></ul>

<p>The <code>show_data</code> parameter controls whether the first few rows of the data are printed, while the <code>detail</code>
parameter controls whether additional help for interpreting the printed output is displayed.
</p>


<h3>Value</h3>

<p>Invisibly returns the <code>x</code> object.
</p>

<hr>
<h2 id='print.cat_tune'>Print Method for <code>cat_tune</code> Object</h2><span id='topic+print.cat_tune'></span>

<h3>Description</h3>

<p>This function prints a summary of the <code>cat_tune</code> object, displaying key details such as
the function name, dimensions of covariates, tau sequence, optimal tau, likelihood or risk
estimate, and the model's coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_tune'
print(x, digit = 3, detail = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cat_tune_+3A_x">x</code></td>
<td>
<p>An object of class <code>cat_tune</code>, typically resulting from a tuning process, including
<code>cat_glm_tune</code>, <code>cat_cox_tune</code> and <code>cat_lmm_tune</code>.</p>
</td></tr>
<tr><td><code id="print.cat_tune_+3A_digit">digit</code></td>
<td>
<p>An integer indicating the number of decimal places for printing
coefficient estimates. Default is 3.</p>
</td></tr>
<tr><td><code id="print.cat_tune_+3A_detail">detail</code></td>
<td>
<p>A logical value indicating whether to include additional detailed output at the end of the summary.
If <code>TRUE</code>, it will print additional interpretation help.</p>
</td></tr>
<tr><td><code id="print.cat_tune_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method provides a comprehensive overview of the tuning process for the model,
including the tau sequence and optimal tau, along with either the maximum likelihood (for Cox models)
or minimum risk estimate (for other models). It also displays the coefficients of the model.
</p>
<p>The function also checks if the <code>x</code> is a Cox model (<code>cat_cox_tune</code>) to adjust the interpretation
of the output.
</p>


<h3>Value</h3>

<p>The <code>x</code> object is returned invisibly.
</p>

<hr>
<h2 id='steinian_estimate'>Perform Steinian Estimate for Model Risk (Only Applicable for Binomial Family)</h2><span id='topic+steinian_estimate'></span>

<h3>Description</h3>

<p>This function computes the Steinian estimate for model risk by fitting a sequence of
Generalized Linear Models (GLMs) with varying values of <code>tau</code>. It combines the preliminary
estimate from a model fitted with an initial <code>tau_0</code> value with a penalty term that incorporates
the in-sample prediction error and a covariance penalty, which is based on models fitted by inverting
the response of individual observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steinian_estimate(formula, cat_init, tau_seq, tau_0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="steinian_estimate_+3A_formula">formula</code></td>
<td>
<p>A formula specifying the GLMs. Should at least include response variables.</p>
</td></tr>
<tr><td><code id="steinian_estimate_+3A_cat_init">cat_init</code></td>
<td>
<p>A list generated from <code>cat_glm_initialization</code>.</p>
</td></tr>
<tr><td><code id="steinian_estimate_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A sequence of tuning parameter values (<code>tau</code>) over which
the Steinian estimate will be computed. Each value of <code>tau</code> is used to weight the
synthetic data during model fitting.</p>
</td></tr>
<tr><td><code id="steinian_estimate_+3A_tau_0">tau_0</code></td>
<td>
<p>A reference value for <code>tau</code> that is used in the calculation of the
preliminary estimate model and the variance term.</p>
</td></tr>
<tr><td><code id="steinian_estimate_+3A_...">...</code></td>
<td>
<p>Other arguments passed to other internal functions.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li> <p><strong>Preliminary Estimate Model</strong>: The function first fits a GLM model using the observed and
synthetic data with an initial value of <code>tau_0</code> for the synthetic data weights.
</p>
</li>
<li> <p><strong>In-sample Prediction Error</strong>: For each value of <code>tau</code> in <code>tau_seq</code>, the function computes
the in-sample prediction error (logistic deviance).
</p>
</li>
<li> <p><strong>Steinian Penalty</strong>: The function calculates the Steinian covariance penalty for each observation
by fitting a modified model that inverts one observation at a time. The penalty is added to the
in-sample prediction error to obtain the final risk estimate.
</p>
</li>
<li> <p><strong>Steinian Risk Estimate</strong>: The final Steinian risk estimate is calculated by summing the
in-sample prediction error and the Steinian penalty term for each value of <code>tau</code> in <code>tau_seq</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A numeric vector of Steinian risk estimates, one for each value of <code>tau</code> in <code>tau_seq</code>.
</p>

<hr>
<h2 id='swim'>Simulated SWIM Dataset with Binary Response</h2><span id='topic+swim'></span>

<h3>Description</h3>

<p>Simulated SWIM Dataset with Binary Response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(swim)
</code></pre>


<h3>Format</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt>x</dt><dd><p>A 3211 by 12 matrix of numeric values.</p>
</dd>
<dt>female</dt><dd><p>Binary variable indicating gender (1 = Female, 0 = Male).</p>
</dd>
<dt>agege35</dt><dd><p>Binary variable indicating if the individual is aged 35 or older (1 = Age 35 or older, 0 = Younger than 35).</p>
</dd>
<dt>hsdip</dt><dd><p>Binary variable indicating if the individual has a high school diploma (1 = Has diploma, 0 = No diploma).</p>
</dd>
<dt>nevmar</dt><dd><p>Binary variable indicating if the individual has never been married (1 = Never married, 0 = Ever married).</p>
</dd>
<dt>divwid</dt><dd><p>Binary variable indicating if the individual is divorced or widowed (1 = Divorced or widowed, 0 = Otherwise).</p>
</dd>
<dt>numchild</dt><dd><p>Numerical variable indicating the number of children the individual has.</p>
</dd>
<dt>childlt6</dt><dd><p>Binary variable indicating if the individual has children under the age of 6 (1 = Has children under 6, 0 = No children under 6).</p>
</dd>
<dt>blknh</dt><dd><p>Binary variable indicating if the individual is black non-Hispanic (1 = Black Non-Hispanic, 0 = Otherwise).</p>
</dd>
<dt>hisp</dt><dd><p>Binary variable indicating if the individual is Hispanic (1 = Newly Hispanic, 0 = Otherwise).</p>
</dd>
<dt>earnyrm1</dt><dd><p>Numerical variable indicating the individual's earnings one year prior to the study (possibly negative earnings or debt).</p>
</dd>
<dt>empyrm1</dt><dd><p>Binary variable indicating if the individual was employed one year prior to the study (1 = Employed, 0 = Unemployed).</p>
</dd>
<dt>enrol</dt><dd><p>Binary variable indicating if the individual was enrolled the job hunting training session (1 = Enrolled, 0 = Unenrolled).</p>
</dd>
<dt>y</dt><dd><p>A 3211 by 1 matrix containing zeros and ones.</p>
</dd>
<dt>empyr1</dt><dd><p>Binary variable indicating if the individual was employed one year after the start of the study (1 = Employed, 0 = Unemployed).</p>
</dd>
</dl>



<h3>Note</h3>

<p>The dataset used in this study was simulated based on the patterns and results described
in &quot;The Saturation Work Initiative Model in San Diego: A Five-Year Follow-up Study&quot;.
This data is not directly extracted from the book but was generated to emulate a similar structure
for research and educational purposes.
</p>


<h3>References</h3>

<p>Friedlander, D., &amp; Hamilton, G. (1993). The Saturation Work Initiative Model in San Diego: A Five-Year Follow-up Study.
</p>

<hr>
<h2 id='traceplot'>Traceplot for Bayesian Model Sampling</h2><span id='topic+traceplot'></span>

<h3>Description</h3>

<p>The <code>traceplot</code> function is a generic function used to generate traceplots for Bayesian model sampling,
primarily for assessing the convergence and mixing of Markov Chain Monte Carlo (MCMC) chains. This function
dispatches specific traceplot methods depending on the class of the <code>object</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>traceplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traceplot_+3A_object">object</code></td>
<td>
<p>An object representing a Bayesian model, typically generated by the
<code>cat_glm_bayes</code> or <code>cat_cox_bayes</code> functions, or similar models with Bayesian sampling results.
The function uses S3 method dispatch to apply the appropriate <code>traceplot</code> method based on
the class of <code>object</code>.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to specific <code>traceplot</code> methods for customization, such as
selecting parameters to plot or setting display options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generic <code>traceplot</code> function allows for flexible visualization of MCMC chains across
different types of Bayesian models. Specific <code>traceplot</code> methods, such as <code>traceplot.cat_bayes</code>,
are dispatched based on the <code>object</code> class to produce tailored traceplots, providing insights
into the sampling progress and convergence diagnostics of each chain.
</p>


<h3>Value</h3>

<p>A traceplot displaying the MCMC sampling chains for each parameter, assisting in convergence analysis.
The exact output format depends on the specific <code>traceplot</code> method applied.
</p>

<hr>
<h2 id='traceplot.cat_bayes'>Traceplot for Bayesian Sampling Model</h2><span id='topic+traceplot.cat_bayes'></span>

<h3>Description</h3>

<p>This function generates a traceplot for the Bayesian sampling model fitted
using <code>rstan</code>. It utilizes the <code>traceplot</code> function from the <code>rstan</code> package
to visualize the sampling progress and convergence of the Markov Chain Monte Carlo (MCMC) chains
for the given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_bayes'
traceplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traceplot.cat_bayes_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>cat_bayes</code> that contains
the Stan sampling model. The object should include the <code>stan_sample_model</code>,
which is the result of fitting the model using the <code>rstan</code> package.</p>
</td></tr>
<tr><td><code id="traceplot.cat_bayes_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>rstan::traceplot</code> function.
These can include customization options for the traceplot, such as <code>pars</code>
for selecting specific parameters or <code>inc_warmup</code> for including or excluding warmup iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls <code>rstan::traceplot</code> on the <code>stan_sample_model</code> contained
within the <code>x</code> object. The resulting plot displays the trace of each parameter
across MCMC iterations, helping to assess the convergence and mixing of the chains.
</p>


<h3>Value</h3>

<p>A traceplot displaying the MCMC chains' trace for each parameter,
helping to assess convergence.
</p>

<hr>
<h2 id='traceplot.cat_gibbs'>Traceplot for Gibbs Sampling Model</h2><span id='topic+traceplot.cat_gibbs'></span>

<h3>Description</h3>

<p>This function generates a traceplot for the Gibbs sampling model, which is
typically used for posterior sampling in a Bayesian context. The traceplot
visualizes the evolution of parameter values across Gibbs sampling iterations.
It helps to diagnose the convergence and mixing of the chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cat_gibbs'
traceplot(object, pars = NULL, inc_warmup = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="traceplot.cat_gibbs_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>cat_gibbs</code> that contains
Gibbs sampling results. The object must include <code>gibbs_iteration_log</code>,
which holds the iteration logs for all sampled parameters, and <code>warmup</code> and <code>iter</code>
which indicate the warmup and total iteration counts, respectively.</p>
</td></tr>
<tr><td><code id="traceplot.cat_gibbs_+3A_pars">pars</code></td>
<td>
<p>A character vector specifying the parameter names to plot.
If <code>NULL</code>, the function will select the first 9 parameters automatically.</p>
</td></tr>
<tr><td><code id="traceplot.cat_gibbs_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>A logical value indicating whether to include warmup iterations
in the traceplot. If <code>TRUE</code>, warmup iterations are included, otherwise they are excluded.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="traceplot.cat_gibbs_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to other functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates a series of line plots for the selected parameters,
displaying their values over the iterations of the Gibbs sampling process.
If <code>inc_warmup</code> is set to <code>TRUE</code>, the traceplot includes the warmup period,
otherwise, it starts after the warmup. The traceplots are arranged in a 3x3 grid,
and no more than 9 parameters can be selected for plotting at once.
</p>


<h3>Value</h3>

<p>A series of traceplots for the selected parameters,
showing their evolution over the Gibbs sampling iterations.
</p>

<hr>
<h2 id='update_lmm_variance'>Calculates the log-likelihood for linear mixed models (LMMs) by combining
observed and synthetic log-likelihoods based on the variance parameters.</h2><span id='topic+update_lmm_variance'></span>

<h3>Description</h3>

<p>This function evaluates the log-likelihood of observed and synthetic data,
using residual and random-effect variance terms to determine the fit
of variance parameters in the mixed model context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_lmm_variance(
  residual_variance,
  random_effect_variance,
  obs_z_eigenvalues,
  syn_z_eigenvalues,
  obs_adjusted_residuals,
  syn_adjusted_residuals,
  tau
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_lmm_variance_+3A_residual_variance">residual_variance</code></td>
<td>
<p>Numeric, the variance associated with the residual errors.</p>
</td></tr>
<tr><td><code id="update_lmm_variance_+3A_random_effect_variance">random_effect_variance</code></td>
<td>
<p>Numeric, the variance associated with random effects.</p>
</td></tr>
<tr><td><code id="update_lmm_variance_+3A_obs_z_eigenvalues">obs_z_eigenvalues</code></td>
<td>
<p>Vector, eigenvalues of the observed Z matrix of data.</p>
</td></tr>
<tr><td><code id="update_lmm_variance_+3A_syn_z_eigenvalues">syn_z_eigenvalues</code></td>
<td>
<p>Vector, eigenvalues of the synthetic Z matrix of data.</p>
</td></tr>
<tr><td><code id="update_lmm_variance_+3A_obs_adjusted_residuals">obs_adjusted_residuals</code></td>
<td>
<p>Vector, adjusted residuals of observed data.</p>
</td></tr>
<tr><td><code id="update_lmm_variance_+3A_syn_adjusted_residuals">syn_adjusted_residuals</code></td>
<td>
<p>Vector, adjusted residuals of synthetic data.</p>
</td></tr>
<tr><td><code id="update_lmm_variance_+3A_tau">tau</code></td>
<td>
<p>Numeric, weight factor for the synthetic data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sum of observed and synthetic log-likelihoods.
</p>

<hr>
<h2 id='validate_cox_initialization_input'>Validate Inputs for Catalytic Cox proportional hazards model (COX) Initialization</h2><span id='topic+validate_cox_initialization_input'></span>

<h3>Description</h3>

<p>This function performs validation checks on input parameters for initializing a catalytic Cox proportional hazards model.
It ensures that essential parameters meet requirements, such as being of the correct type, appropriate length, and having valid values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_cox_initialization_input(
  formula,
  data,
  syn_size,
  hazard_constant,
  entry_points,
  x_degree
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_cox_initialization_input_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code>. The model formula specifying the Cox model structure. It must contain a <code>Surv</code> object to indicate survival analysis.</p>
</td></tr>
<tr><td><code id="validate_cox_initialization_input_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the dataset to be used for model fitting. It should include all variables referenced in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="validate_cox_initialization_input_+3A_syn_size">syn_size</code></td>
<td>
<p>A positive integer indicating the size of the synthetic dataset. It is recommended that this value is at least four times the number of columns in <code>data</code>.</p>
</td></tr>
<tr><td><code id="validate_cox_initialization_input_+3A_hazard_constant">hazard_constant</code></td>
<td>
<p>A positive numeric value representing the hazard constant for the Cox model.</p>
</td></tr>
<tr><td><code id="validate_cox_initialization_input_+3A_entry_points">entry_points</code></td>
<td>
<p>A numeric vector representing entry times for observations. This vector should be non-negative and have a length equal to the number of rows in <code>data</code>.</p>
</td></tr>
<tr><td><code id="validate_cox_initialization_input_+3A_x_degree">x_degree</code></td>
<td>
<p>A numeric vector indicating degrees for each covariate. It should be non-negative and match the number of covariates (i.e., <code>ncol(data) - 2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks:
</p>

<ul>
<li><p> That <code>syn_size</code>, <code>hazard_constant</code>, <code>entry_points</code>, and <code>x_degree</code> are positive values.
</p>
</li>
<li><p> That <code>formula</code> includes a <code>Surv</code> object to be suitable for Cox models.
</p>
</li>
<li><p> That <code>data</code> is a <code>data.frame</code>.
</p>
</li>
<li><p> The complexity of <code>formula</code> to ensure it has fewer terms than the number of columns in <code>data</code>.
</p>
</li>
<li><p> The length of <code>x_degree</code> and <code>entry_points</code> to match the dimensions of <code>data</code>.
If the conditions are not met, descriptive error messages are returned.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns nothing if all checks pass; otherwise, raises an error.
</p>

<hr>
<h2 id='validate_cox_input'>Validate Inputs for Catalytic Cox Model</h2><span id='topic+validate_cox_input'></span>

<h3>Description</h3>

<p>This function validates the parameters provided for setting up a catalytic Cox proportional hazards model
with an initialization object created by <code>cat_cox_initialization</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_cox_input(
  formula,
  cat_init,
  tau = NULL,
  tau_seq = NULL,
  init_coefficients = NULL,
  tol = NULL,
  max_iter = NULL,
  cross_validation_fold_num = NULL,
  hazard_beta = NULL,
  tau_alpha = NULL,
  tau_gamma = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_cox_input_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code>. Specifies the model structure for the Cox model, including a <code>Surv</code> object for survival analysis. Should at least include response variance.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_cat_init">cat_init</code></td>
<td>
<p>An initialization object generated by <code>cat_cox_initialization</code>. This object should contain necessary information about the dataset, including the time and status column names.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_tau">tau</code></td>
<td>
<p>Optional. A numeric scalar, the regularization parameter for the Cox model. Must be positive.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_tau_seq">tau_seq</code></td>
<td>
<p>Optional. A numeric vector for specifying a sequence of regularization parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_init_coefficients">init_coefficients</code></td>
<td>
<p>Optional. A numeric vector of initial coefficients for the Cox model. Should match the number of predictors in the dataset.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_tol">tol</code></td>
<td>
<p>Optional. A positive numeric value indicating the tolerance level for convergence in iterative fitting.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_max_iter">max_iter</code></td>
<td>
<p>Optional. A positive integer indicating the maximum number of iterations allowed in the model fitting.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>Optional. A positive integer specifying the number of folds for cross-validation. Should be greater than 1 and less than or equal to the size of the dataset.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_hazard_beta">hazard_beta</code></td>
<td>
<p>Optional. A positive numeric value representing a constant for adjusting the hazard rate in the Cox model.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_tau_alpha">tau_alpha</code></td>
<td>
<p>Optional. A positive numeric value controlling the influence of <code>tau</code>.</p>
</td></tr>
<tr><td><code id="validate_cox_input_+3A_tau_gamma">tau_gamma</code></td>
<td>
<p>Optional. A positive numeric value controlling the influence of <code>tau_seq</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks:
</p>

<ul>
<li><p> That <code>tau</code>, <code>tol</code>, <code>max_iter</code>, <code>cross_validation_fold_num</code>, <code>hazard_beta</code>, <code>tau_alpha</code>, and <code>tau_gamma</code> are positive.
</p>
</li>
<li><p> That <code>tau_seq</code> is a non-negative vector.
</p>
</li>
<li><p> That <code>cat_init</code> is generated from <code>cat_cox_initialization</code>.
</p>
</li>
<li><p> That <code>formula</code> uses the same time and status column names as those in <code>cat_init</code>.
</p>
</li>
<li><p> That <code>init_coefficients</code> has the correct length for the number of predictors.
</p>
</li>
<li><p> That <code>cross_validation_fold_num</code> is between 2 and the dataset size.
</p>
</li>
<li><p> That the dataset is sufficiently large for cross-validation, recommending fewer folds if it is not.
If any conditions are not met, the function will raise an error or warning.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns nothing if all checks pass; otherwise, raises an error or warning.
</p>

<hr>
<h2 id='validate_glm_initialization_input'>Validate Inputs for Catalytic Generalized Linear Models (GLMs) Initialization</h2><span id='topic+validate_glm_initialization_input'></span>

<h3>Description</h3>

<p>This function validates the input parameters required for initializing a catalytic Generalized Linear Model (GLM).
It ensures the appropriate structure and compatibility of the formula, family, data, and additional parameters
before proceeding with further modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_glm_initialization_input(
  formula,
  family,
  data,
  syn_size,
  custom_variance,
  gaussian_known_variance,
  x_degree
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_glm_initialization_input_+3A_formula">formula</code></td>
<td>
<p>A formula object specifying the <code>stats::glm</code> model to be fitted. It must not contain random effects or survival terms.</p>
</td></tr>
<tr><td><code id="validate_glm_initialization_input_+3A_family">family</code></td>
<td>
<p>A character or family object specifying the error distribution and link function. Valid values are &quot;binomial&quot; and &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="validate_glm_initialization_input_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the data to be used in the GLM.</p>
</td></tr>
<tr><td><code id="validate_glm_initialization_input_+3A_syn_size">syn_size</code></td>
<td>
<p>A positive integer specifying the sample size used for the synthetic data.</p>
</td></tr>
<tr><td><code id="validate_glm_initialization_input_+3A_custom_variance">custom_variance</code></td>
<td>
<p>A positive numeric value for the custom variance used in the model (only applicable for Gaussian family).</p>
</td></tr>
<tr><td><code id="validate_glm_initialization_input_+3A_gaussian_known_variance">gaussian_known_variance</code></td>
<td>
<p>A logical indicating whether the variance is known for the Gaussian family.</p>
</td></tr>
<tr><td><code id="validate_glm_initialization_input_+3A_x_degree">x_degree</code></td>
<td>
<p>A numeric vector specifying the degree of the predictors. Its length should match the number of predictors (excluding the response variable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the following checks:
</p>

<ul>
<li><p> Ensures that <code>syn_size</code>, <code>custom_variance</code>, and <code>x_degree</code> are positive values.
</p>
</li>
<li><p> Verifies that the provided <code>formula</code> is suitable for GLMs, ensuring no random effects or survival terms.
</p>
</li>
<li><p> Checks that the provided <code>data</code> is a <code>data.frame</code>.
</p>
</li>
<li><p> Confirms that the <code>formula</code> does not contain too many terms relative to the number of columns in <code>data</code>.
</p>
</li>
<li><p> Ensures that the <code>family</code> is either &quot;binomial&quot; or &quot;gaussian&quot;.
</p>
</li>
<li><p> Validates that <code>x_degree</code> has the correct length relative to the number of predictors in <code>data</code>.
</p>
</li>
<li><p> Warns if <code>syn_size</code> is too small relative to the number of columns in <code>data</code>.
</p>
</li>
<li><p> Issues warnings if <code>custom_variance</code> or <code>gaussian_known_variance</code> are used with incompatible families.
If any of these conditions are not met, the function raises an error or warning to guide the user.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns nothing if all checks pass; otherwise, raises an error or warning.
</p>

<hr>
<h2 id='validate_glm_input'>Validate Inputs for Catalytic Generalized Linear Models (GLMs)</h2><span id='topic+validate_glm_input'></span>

<h3>Description</h3>

<p>This function validates the input parameters for initializing a catalytic Generalized
Linear Models (GLMs). It ensures that the provided model formula, family, and
additional parameters are suitable for further analysis. The function performs
various checks on the input values to confirm they meet expected criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_glm_input(
  formula,
  cat_init,
  tau = NULL,
  tau_seq = NULL,
  tau_0 = NULL,
  parametric_bootstrap_iteration_times = NULL,
  cross_validation_fold_num = NULL,
  risk_estimate_method = NULL,
  discrepancy_method = NULL,
  binomial_joint_theta = FALSE,
  binomial_joint_alpha = FALSE,
  binomial_tau_lower = NULL,
  tau_alpha = NULL,
  tau_gamma = NULL,
  gibbs_iter = NULL,
  gibbs_warmup = NULL,
  coefs_iter = NULL,
  gaussian_variance_alpha = NULL,
  gaussian_variance_beta = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_glm_input_+3A_formula">formula</code></td>
<td>
<p>A formula object specifying the GLM to be fitted. The left-hand
side of the formula should at least contains the response variable.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_cat_init">cat_init</code></td>
<td>
<p>An object of class <code>cat_initialization</code> generated by
<code>cat_glm_initialization</code>. It contains model initialization details,
such as the response variable name and the GLM family.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_tau">tau</code></td>
<td>
<p>A positive numeric value for the tau parameter in the model.
It represents a regularization or scaling factor and must be greater
than zero.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A numeric vector specifying a sequence of tau values.
This is used for parameter tuning and must contain positive values.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_tau_0">tau_0</code></td>
<td>
<p>A positive numeric value for the initial tau parameter,
which must be greater than zero.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_parametric_bootstrap_iteration_times">parametric_bootstrap_iteration_times</code></td>
<td>
<p>An integer specifying the
number of iterations for the parametric bootstrap method. It must be
greater than zero.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>An integer for the number of folds in
cross-validation. It must be greater than 1 and less than or equal to
the number of observations.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_risk_estimate_method">risk_estimate_method</code></td>
<td>
<p>A character string specifying the method for
estimating risk, such as &quot;parametric_bootstrap&quot; or other options,
depending on the family of the GLM.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_discrepancy_method">discrepancy_method</code></td>
<td>
<p>A character string specifying the method for
calculating discrepancy. The valid options depend on the GLM family
and risk estimation method.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_binomial_joint_theta">binomial_joint_theta</code></td>
<td>
<p>Logical; if TRUE, uses joint theta (theta = 1/tau) in Binomial models.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_binomial_joint_alpha">binomial_joint_alpha</code></td>
<td>
<p>Logical; if TRUE, uses joint alpha (adaptive tau_alpha) in Binomial models.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_binomial_tau_lower">binomial_tau_lower</code></td>
<td>
<p>A positive numeric value specifying the lower
bound for tau in binomial GLMs. It must be greater than zero.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_tau_alpha">tau_alpha</code></td>
<td>
<p>A positive numeric value for the tau alpha parameter.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_tau_gamma">tau_gamma</code></td>
<td>
<p>A positive numeric value for the tau gamma parameter.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_gibbs_iter">gibbs_iter</code></td>
<td>
<p>An integer for the number of Gibbs iterations in the
sampling process. It must be greater than zero.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_gibbs_warmup">gibbs_warmup</code></td>
<td>
<p>An integer for the number of warm-up iterations in the
Gibbs sampling. It must be positive and less than the total number
of iterations.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_coefs_iter">coefs_iter</code></td>
<td>
<p>An integer specifying the number of iterations for the
coefficient update in the Gibbs sampling. It must be positive.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_gaussian_variance_alpha">gaussian_variance_alpha</code></td>
<td>
<p>The shape parameter for the inverse-gamma prior on
variance if the variance is unknown in Gaussian models. It must be positive.</p>
</td></tr>
<tr><td><code id="validate_glm_input_+3A_gaussian_variance_beta">gaussian_variance_beta</code></td>
<td>
<p>The scale parameter for the inverse-gamma prior on
variance if the variance is unknown in Gaussian models. It must be positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs several checks to ensure the validity of the input
parameters:
</p>

<ul>
<li><p> Ensures that <code>tau</code>, <code>tau_0</code>, <code>parametric_bootstrap_iteration_times</code>,
<code>binomial_tau_lower</code>, <code>tau_alpha</code>, <code>tau_gamma</code>, <code>gibbs_iter</code>,
<code>gibbs_warmup</code>, and <code>coefs_iter</code> are positive values.
</p>
</li>
<li><p> Verifies that <code>cat_init</code> is an object generated by
<code>cat_glm_initialization</code>.
</p>
</li>
<li><p> Checks that the <code>formula</code> response name matches the response name
used in the <code>cat_init</code> object.
</p>
</li>
<li><p> Verifies that <code>risk_estimate_method</code> and <code>discrepancy_method</code> are
compatible with the GLM family and that no invalid combinations are
used.
</p>
</li>
<li><p> Warns if the dataset size is too large for the specified risk
estimation method.
If any of these conditions are not met, the function raises an error or warning to guide the user.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns nothing if all checks pass; otherwise, raises an error or warning.
</p>

<hr>
<h2 id='validate_lmm_initialization_input'>Validate Inputs for Catalytic Linear Mixed Model (LMM) Initialization</h2><span id='topic+validate_lmm_initialization_input'></span>

<h3>Description</h3>

<p>This function validates the parameters needed for initializing a catalytic Linear Mixed Model (LMM) or Generalized Linear Model (GLM)
based on the input formula, data, and column specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_lmm_initialization_input(
  formula,
  data,
  x_cols,
  y_col,
  z_cols,
  group_col,
  syn_size
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_lmm_initialization_input_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>formula</code> representing the model formula, typically including fixed and random effects for LMMs or for GLMs.</p>
</td></tr>
<tr><td><code id="validate_lmm_initialization_input_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the data for model fitting. This should include all columns specified in <code>x_cols</code>, <code>y_col</code>, <code>z_cols</code>, and <code>group_col</code>.</p>
</td></tr>
<tr><td><code id="validate_lmm_initialization_input_+3A_x_cols">x_cols</code></td>
<td>
<p>A character vector of column names to be used as predictor variables in the model.</p>
</td></tr>
<tr><td><code id="validate_lmm_initialization_input_+3A_y_col">y_col</code></td>
<td>
<p>A single character string specifying the name of the response variable column.</p>
</td></tr>
<tr><td><code id="validate_lmm_initialization_input_+3A_z_cols">z_cols</code></td>
<td>
<p>A character vector of column names to be used as additional predictors or grouping factors, depending on the model structure.</p>
</td></tr>
<tr><td><code id="validate_lmm_initialization_input_+3A_group_col">group_col</code></td>
<td>
<p>A single character string specifying the name of the grouping variable for random effects.</p>
</td></tr>
<tr><td><code id="validate_lmm_initialization_input_+3A_syn_size">syn_size</code></td>
<td>
<p>Optional. A positive integer indicating the synthetic data size, typically for use in data augmentation or model diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the following checks:
</p>

<ul>
<li><p> Ensures <code>syn_size</code> is a positive integer.
</p>
</li>
<li><p> Verifies that <code>formula</code> is not for survival analysis (e.g., does not contain <code>Surv</code> terms).
</p>
</li>
<li><p> Checks that the formula is not overly complex by confirming it has fewer terms than the total columns in <code>data</code>.
</p>
</li>
<li><p> Ensures <code>y_col</code> and <code>group_col</code> each contain only one column name.
</p>
</li>
<li><p> Confirms <code>data</code> is a <code>data.frame</code>.
</p>
</li>
<li><p> Validates that all specified columns in <code>x_cols</code>, <code>y_col</code>, <code>z_cols</code>, and <code>group_col</code> exist in <code>data</code> without overlap or missing values.
</p>
</li>
<li><p> Warns if <code>syn_size</code> is set too small relative to the data dimensions, recommending a larger value.
If any of these conditions are not met, the function raises an error or warning to guide the user.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns nothing if all checks pass; otherwise, raises an error or warning.
</p>

<hr>
<h2 id='validate_lmm_input'>Validate Inputs for Catalytic Linear Mixed Model (LMM)</h2><span id='topic+validate_lmm_input'></span>

<h3>Description</h3>

<p>This function validates the parameters needed for fitting a catalytic Linear Mixed Model (LMM) or Generalized Linear Model (GLM),
specifically for the use with the categorical initialization from <code>cat_lmm_initialization</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_lmm_input(
  cat_init,
  tau = NULL,
  residual_variance_0 = NULL,
  random_effect_variance_0 = NULL,
  coefs_0 = NULL,
  optimize_domain = NULL,
  max_iter = NULL,
  tol = NULL,
  tau_seq = NULL,
  cross_validation_fold_num = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_lmm_input_+3A_cat_init">cat_init</code></td>
<td>
<p>An object of class <code>cat_initialization</code>, typically generated from the <code>cat_lmm_initialization</code> function.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_tau">tau</code></td>
<td>
<p>A positive numeric value specifying the penalty parameter for the model.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_residual_variance_0">residual_variance_0</code></td>
<td>
<p>A positive numeric value for the initial residual variance estimate.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_random_effect_variance_0">random_effect_variance_0</code></td>
<td>
<p>A positive numeric value for the initial random effect variance estimate.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_coefs_0">coefs_0</code></td>
<td>
<p>A numeric vector of length equal to the number of columns in the observation matrix. This represents the initial values for the model coefficients.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_optimize_domain">optimize_domain</code></td>
<td>
<p>A numeric vector of length 2 specifying the domain for the optimization procedure.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_max_iter">max_iter</code></td>
<td>
<p>A positive integer specifying the maximum number of iterations for the optimization.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_tol">tol</code></td>
<td>
<p>A positive numeric value indicating the tolerance level for convergence.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_tau_seq">tau_seq</code></td>
<td>
<p>A numeric vector representing a sequence of values for the penalty parameter.</p>
</td></tr>
<tr><td><code id="validate_lmm_input_+3A_cross_validation_fold_num">cross_validation_fold_num</code></td>
<td>
<p>A positive integer specifying the number of folds for cross-validation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the following checks:
</p>

<ul>
<li><p> Ensures that <code>tau</code>, <code>tau_seq</code>, <code>residual_variance_0</code>, <code>random_effect_variance_0</code>, <code>optimize_domain</code>, <code>max_iter</code>, and <code>tol</code> are positive values.
</p>
</li>
<li><p> Verifies that <code>cat_init</code> is an object generated by <code>cat_lmm_initialization</code>.
</p>
</li>
<li><p> Checks if <code>coefs_0</code> has the same length as the number of columns in the observation matrix of <code>cat_init</code>.
</p>
</li>
<li><p> Ensures <code>optimize_domain</code> is a numeric vector of length 2.
</p>
</li>
<li><p> Confirms that <code>cross_validation_fold_num</code> is greater than 1 and less than the number of observations in <code>cat_init</code>.
If any of these conditions are not met, the function raises an error to guide the user.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns nothing if all checks pass; otherwise, raises an error.
</p>

<hr>
<h2 id='validate_positive'>Validate Positive or Non-negative Parameter</h2><span id='topic+validate_positive'></span>

<h3>Description</h3>

<p>This function checks whether a parameter value is positive (or non-negative if <code>incl_0</code> is set to <code>TRUE</code>).
It can handle both single numeric values and vectors, and it raises an error with an informative
message if the validation fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_positive(param_name, param_value, incl_0 = FALSE, is_vector = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_positive_+3A_param_name">param_name</code></td>
<td>
<p>A string representing the name of the parameter. Used in the error message.</p>
</td></tr>
<tr><td><code id="validate_positive_+3A_param_value">param_value</code></td>
<td>
<p>The parameter value to validate, either a single numeric or a numeric vector.</p>
</td></tr>
<tr><td><code id="validate_positive_+3A_incl_0">incl_0</code></td>
<td>
<p>Logical, if <code>TRUE</code>, allows non-negative values (larger or equal to 0); if <code>FALSE</code>, requires positive values (larger than 0).</p>
</td></tr>
<tr><td><code id="validate_positive_+3A_is_vector">is_vector</code></td>
<td>
<p>Logical, if <code>TRUE</code>, treats <code>param_value</code> as a vector; otherwise, expects a single numeric value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if validation passes; otherwise, an error is raised.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
