<!DOCTYPE html><html><head><title>Help for package GROAN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GROAN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addRegressor'><p>Add an extra regressor to a Workbench</p></a></li>
<li><a href='#are.compatible'><p>Check two GROAN.NoisyDataSet for dimension compatibility</p></a></li>
<li><a href='#artificialGenotypes'><p>Create a set of artificial genotypes</p></a></li>
<li><a href='#artificialPhenotypes'><p>Create a set of artificial phenotypes</p></a></li>
<li><a href='#createNoisyDataset'><p>Noisy Data Set Constructor</p></a></li>
<li><a href='#createRunId'><p>Generate a random run id</p></a></li>
<li><a href='#createWorkbench'><p>Workbench constructor</p></a></li>
<li><a href='#dummy.function'><p>Dummy function for import management</p></a></li>
<li><a href='#getExtraCovariatesNames'><p>String of extra covariates names</p></a></li>
<li><a href='#getNoisyPhenotype'><p>Generate an instance of noisy phenotypes</p></a></li>
<li><a href='#GROAN.AI'><p>Example data for pea AI lines</p></a></li>
<li><a href='#GROAN.KI'><p>Example data for pea KI lines</p></a></li>
<li><a href='#GROAN.pea.kinship'><p>[DEPRECATED]</p></a></li>
<li><a href='#GROAN.pea.SNPs'><p>[DEPRECATED]</p></a></li>
<li><a href='#GROAN.pea.yield'><p>[DEPRECATED]</p></a></li>
<li><a href='#GROAN.run'><p>Compare Genomic Regressors on a Noisy Dataset</p></a></li>
<li><a href='#is.boolean'><p>Is a boolean?</p></a></li>
<li><a href='#is.in.range'><p>Is in the passed numeric range</p></a></li>
<li><a href='#is.naturalnumber'><p>Is a positive integer?</p></a></li>
<li><a href='#is.single.slot'><p>Is a single slot thing?</p></a></li>
<li><a href='#is.string'><p>Is a string?</p></a></li>
<li><a href='#measurePredictionPerformance'><p>Measure Performance of a Prediction</p></a></li>
<li><a href='#ndcg'><p>Function to calculate mean Normalized Discounted Cumulative Gain (NDCG)</p></a></li>
<li><a href='#noiseInjector.dummy'><p>Noise Injector dummy function</p></a></li>
<li><a href='#noiseInjector.norm'><p>Inject Normal Noise</p></a></li>
<li><a href='#noiseInjector.swapper'><p>Swap phenotypes between samples</p></a></li>
<li><a href='#noiseInjector.unif'><p>Inject Uniform Noise</p></a></li>
<li><a href='#phenoRegressor.BGLR'><p>Regression using BGLR package</p></a></li>
<li><a href='#phenoregressor.BGLR.multikinships'><p>Multi-matrix GBLUP using BGLR</p></a></li>
<li><a href='#phenoRegressor.dummy'><p>Regression dummy function</p></a></li>
<li><a href='#phenoRegressor.RFR'><p>Random Forest Regression using package randomForest</p></a></li>
<li><a href='#phenoRegressor.rrBLUP'><p>SNP-BLUP or G-BLUP using rrBLUP package</p></a></li>
<li><a href='#phenoRegressor.rrBLUP.G'><p>G-BLUP using rrBLUP library</p></a></li>
<li><a href='#phenoRegressor.rrBLUP.SNP'><p>SNP-BLUP using rrBLUP library</p></a></li>
<li><a href='#phenoRegressor.SVR'><p>Support Vector Regression using package e1071</p></a></li>
<li><a href='#plotResult'><p>Plot results of a run</p></a></li>
<li><a href='#print.GROAN.NoisyDataset'><p>Print a GROAN Noisy Dataset object</p></a></li>
<li><a href='#print.GROAN.Workbench'><p>Print a GROAN Workbench object</p></a></li>
<li><a href='#stratified_crossvalidation_folds'><p>Assignments for stratified crossvalidation</p></a></li>
<li><a href='#summary.GROAN.NoisyDataset'><p>Summary for GROAN Noisy Dataset object</p></a></li>
<li><a href='#summary.GROAN.Result'><p>Summary of GROAN.Result</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genomic Regression Workbench</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Nelson Nazzicari &amp; Filippo Biscarini</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nelson Nazzicari &lt;nelson.nazzicari@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Workbench for testing genomic regression accuracy on
    (optionally noisy) phenotypes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, rrBLUP</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BGLR, e1071, ggplot2, knitr, randomForest, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-28 12:15:16 UTC; nelson</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-28 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addRegressor'>Add an extra regressor to a Workbench</h2><span id='topic+addRegressor'></span>

<h3>Description</h3>

<p>This function adds a regressor to an existing <a href="#topic+createWorkbench">GROAN.Workbench</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addRegressor(wb, regressor, regressor.name = regressor, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addRegressor_+3A_wb">wb</code></td>
<td>
<p>the GROAN.Workbench instance to be updated</p>
</td></tr>
<tr><td><code id="addRegressor_+3A_regressor">regressor</code></td>
<td>
<p>regressor function</p>
</td></tr>
<tr><td><code id="addRegressor_+3A_regressor.name">regressor.name</code></td>
<td>
<p>string that will be used in reports. Keep in mind that when deciding names.</p>
</td></tr>
<tr><td><code id="addRegressor_+3A_...">...</code></td>
<td>
<p>extra parameters are passed to the regressor function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated instance of the original GROAN.Workbench
</p>


<h3>See Also</h3>

<p><a href="#topic+createWorkbench">createWorkbench</a> <a href="#topic+GROAN.run">GROAN.run</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating a Workbench with all default arguments
wb = createWorkbench()
#adding a second regressor
wb = addRegressor(wb, regressor = phenoRegressor.dummy, regressor.name = 'dummy')

## Not run: 
#trying to add again a regressor with the same name would result in a naming conflict error
wb = addRegressor(wb, regressor = phenoRegressor.dummy, regressor.name = 'dummy')
## End(Not run)
</code></pre>

<hr>
<h2 id='are.compatible'>Check two GROAN.NoisyDataSet for dimension compatibility</h2><span id='topic+are.compatible'></span>

<h3>Description</h3>

<p>This function verifies that the two passed GROAN.NoisyDataSet objects have
the same dimensions and can thus be used in the same experiment (typically training
models on one and testing on the other). The function returns a TRUE/FALSE. In <code>verbose</code>
mode the function also prints messages detailing the comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>are.compatible(nds1, nds2, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="are.compatible_+3A_nds1">nds1</code></td>
<td>
<p>the first GROAN.NoisyDataSet to be tested</p>
</td></tr>
<tr><td><code id="are.compatible_+3A_nds2">nds2</code></td>
<td>
<p>the second GROAN.NoisyDataSet to be tested</p>
</td></tr>
<tr><td><code id="are.compatible_+3A_verbose">verbose</code></td>
<td>
<p>boolean, if TRUE the function prints messages detailing the comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the passed GROAN.NoisyDataSet are dimensionally compatible, FALSE otherwise
</p>

<hr>
<h2 id='artificialGenotypes'>Create a set of artificial genotypes</h2><span id='topic+artificialGenotypes'></span>

<h3>Description</h3>

<p>This function return a matrix of 0/1/2... up to ploidy level.
Nothing fancy, each data point is sampled from an equally
probable distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artificialGenotypes(samples = 50, markers = 200, ploidy = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artificialGenotypes_+3A_samples">samples</code></td>
<td>
<p>number of individuals (rows)</p>
</td></tr>
<tr><td><code id="artificialGenotypes_+3A_markers">markers</code></td>
<td>
<p>number of SNPs (columns)</p>
</td></tr>
<tr><td><code id="artificialGenotypes_+3A_ploidy">ploidy</code></td>
<td>
<p>number of alleles per SNP</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a samples x markers matrix
</p>

<hr>
<h2 id='artificialPhenotypes'>Create a set of artificial phenotypes</h2><span id='topic+artificialPhenotypes'></span>

<h3>Description</h3>

<p>Each marker is assigned an effect based on the passed distribution.
Heritability (h2) controls how much GEBV are close to phenotypes (h2=1 means
no distinction, h2=0 means no correlation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artificialPhenotypes(
  genotypes,
  mu = 0,
  h2 = 0.8,
  markersEffectDistr = "rnorm",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artificialPhenotypes_+3A_genotypes">genotypes</code></td>
<td>
<p>a samples x markers matrix of 0/1/2...ploidy</p>
</td></tr>
<tr><td><code id="artificialPhenotypes_+3A_mu">mu</code></td>
<td>
<p>intercept (added to everything)</p>
</td></tr>
<tr><td><code id="artificialPhenotypes_+3A_h2">h2</code></td>
<td>
<p>heritability (must be greater than zero, an less than or equal to one)</p>
</td></tr>
<tr><td><code id="artificialPhenotypes_+3A_markerseffectdistr">markersEffectDistr</code></td>
<td>
<p>name of the random generation function of
the selected distribution for markers effects. It must
accept n as argument indicating the number of elements
to be returned.</p>
</td></tr>
<tr><td><code id="artificialPhenotypes_+3A_...">...</code></td>
<td>
<p>further parameters are passed to markersEffectDistr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of three elements: $GEBV is an array of genetic breeding values,
$phenotypes is the array of phenotypes, and $markerEffects is an array of
marker effects
</p>

<hr>
<h2 id='createNoisyDataset'>Noisy Data Set Constructor</h2><span id='topic+createNoisyDataset'></span>

<h3>Description</h3>

<p>This function creates a GROAN.NoisyDataset object (or fails trying). The
class will contain all noisy data set components: genotypes and/or covariance matrix,
phenotypes, strata (optional), a noise injector function and its parameters.<br />
You can have a general description of the created object using the overridden <a href="#topic+print.GROAN.NoisyDataset">print.GROAN.NoisyDataset</a>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createNoisyDataset(
  name,
  genotypes = NULL,
  covariance = NULL,
  phenotypes,
  strata = NULL,
  extraCovariates = NULL,
  ploidy = 2,
  allowFractionalGenotypes = FALSE,
  noiseInjector = noiseInjector.dummy,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createNoisyDataset_+3A_name">name</code></td>
<td>
<p>A string defining the dataset name, used later do identify this
particular instance in reports and result files. It is advisable for
it to be it somewhat meaningful (to you, GROAN simply reports it as it is)</p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_genotypes">genotypes</code></td>
<td>
<p>Matrix or dataframe containing SNP genotypes, one row per sample (N), one column per marker (M), 0/1/2 format (for diploids)
or 0/1/2.../ploidy in case of polyploids</p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_covariance">covariance</code></td>
<td>
<p>matrix of covariances between samples of this dataset. It is usually a square (NxN) matrix,
but rectangular matrices (NxW) are accepted to incapsulate covariances between samples in
this set and samples of other sets. Please note that some regression models expect the
covariance to be square and will fail on rectangular ones</p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_phenotypes">phenotypes</code></td>
<td>
<p>numeric array, N slots</p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_strata">strata</code></td>
<td>
<p>array of M slots, describing the strata each data point belongs to. This is
used for stratified crossvalidation (see <code><a href="#topic+createWorkbench">createWorkbench</a></code>)</p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>dataframe of optional extra covariates (N lines, one column per extra covariate).
Numeric ones will be normalized, string and categorical ones will be transformed
in stub TRUE/FALSE variables (one per possible value, see <a href="stats.html#topic+model.matrix">model.matrix</a>).</p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_ploidy">ploidy</code></td>
<td>
<p>number of haploid sets in the cell. Defaults to 2 (diploid).</p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_allowfractionalgenotypes">allowFractionalGenotypes</code></td>
<td>
<p>if TRUE non-integer values for genotypes can be allowed. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_noiseinjector">noiseInjector</code></td>
<td>
<p>name of a noise injector function, defaults to <a href="#topic+noiseInjector.dummy">noiseInjector.dummy</a></p>
</td></tr>
<tr><td><code id="createNoisyDataset_+3A_...">...</code></td>
<td>
<p>further arguments are passed along to noiseInjector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a GROAN.NoisyDataset object.
</p>


<h3>See Also</h3>

<p><a href="#topic+GROAN.run">GROAN.run</a> <a href="#topic+createWorkbench">createWorkbench</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#For more complete examples see the package vignette
#creating a noisy dataset with normal noise
nds = createNoisyDataset(
  name = 'PEA, normal noise',
  genotypes = GROAN.KI$SNPs,
  phenotypes = GROAN.KI$yield,
  noiseInjector = noiseInjector.norm,
  mean = 0,
  sd = sd(GROAN.KI$yield) * 0.5
)
</code></pre>

<hr>
<h2 id='createRunId'>Generate a random run id</h2><span id='topic+createRunId'></span>

<h3>Description</h3>

<p>This function returns a partially random alphanumeric string that can be
used to identify a single run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRunId()
</code></pre>


<h3>Value</h3>

<p>a partially random alphanumeric string
</p>

<hr>
<h2 id='createWorkbench'>Workbench constructor</h2><span id='topic+createWorkbench'></span>

<h3>Description</h3>

<p>This function creates a GROAN.Workbench instance (or fails trying). The created object contains:<br />
a) one regressor with its own specific configuration<br />
b) the experiment parameters (number of repetitions, number of folds in case of crossvalidation, stratification...)<br />
You can have a general description of the created object using the overridden <a href="#topic+print.GROAN.Workbench">print.GROAN.Workbench</a>
function.<br />
It is possible to add other regressors to the created <code>GROAN.Workbench</code> object using <a href="#topic+addRegressor">addRegressor</a>.
Once the <code>GROAN.Workbench</code> is created it must be passed to <a href="#topic+GROAN.run">GROAN.run</a> to start the experiment.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createWorkbench(
  folds = 10,
  reps = 5,
  stratified = FALSE,
  outfolder = NULL,
  outfile.name = "accuracy.csv",
  saveHyperParms = FALSE,
  saveExtraData = FALSE,
  regressor = phenoRegressor.rrBLUP,
  regressor.name = "default regressor",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createWorkbench_+3A_folds">folds</code></td>
<td>
<p>number of folds for crossvalidation, defaults to 10. If <code>NULL</code> no crossvalidation happens and
all training data will be used. In this case a second dataset, for test, is needed (see <a href="#topic+GROAN.run">GROAN.run</a>
for details)</p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_reps">reps</code></td>
<td>
<p>number of times the whole test must be repeated, defaults to 5</p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_stratified">stratified</code></td>
<td>
<p>boolean indicating whether GROAN should take into account data strata. This have two
effects. First, the crossvalidation becomes stratified, meaning that folds will be
split so that training and test sets will contain the same proportions of each data stratum.
Second, prediction accuracy will be assessed (also) by strata.
If no strata are present in the <a href="#topic+createNoisyDataset">GROAN.NoisyDataSet</a>
object and <code>stratified==TRUE</code> all samples will be considered belonging to the
same strata (&quot;dummyStrata&quot;).
If <code>stratified</code> is FALSE (the default) GROAN will simply ignore the
strata, even if present in the <a href="#topic+createNoisyDataset">GROAN.NoisyDataSet</a>.</p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_outfolder">outfolder</code></td>
<td>
<p>folder where to save the data. If <code>NULL</code> (the default)
nothing will be saved. Filenames are standardized. If existing,
accuracy and hyperparameter files will be updated, otherwise are created. ExtraData
cannot be updated, so unique filenames will be generated using runId (see <a href="#topic+GROAN.run">GROAN.run</a>)</p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_outfile.name">outfile.name</code></td>
<td>
<p>file name to be used to save the accuracies in a text file. Defaults to &quot;accuracy.csv&quot;.
Ignored if <code>outfolder</code> is <code>NULL</code></p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_savehyperparms">saveHyperParms</code></td>
<td>
<p>boolean indicating if the hyperparameters from regressor training should be
saved in <code>outfolder</code>. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_saveextradata">saveExtraData</code></td>
<td>
<p>boolean indicating if extradata from regressor training should be
saved in <code>outfolder</code> as R objects (using the <a href="base.html#topic+save">save</a> function). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_regressor">regressor</code></td>
<td>
<p>regressor function. Defaults to <code><a href="#topic+phenoRegressor.rrBLUP">phenoRegressor.rrBLUP</a></code></p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_regressor.name">regressor.name</code></td>
<td>
<p>string that will be used in reports. Keep that in mind when deciding names. Defaults to &quot;default regressor&quot;</p>
</td></tr>
<tr><td><code id="createWorkbench_+3A_...">...</code></td>
<td>
<p>extra parameter are passed to regressor function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of GROAN.Workbench
</p>


<h3>See Also</h3>

<p><a href="#topic+addRegressor">addRegressor</a> <a href="#topic+GROAN.run">GROAN.run</a> <a href="#topic+createNoisyDataset">createNoisyDataset</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#creating a Workbench with all default arguments
wb1 = createWorkbench()
#another Workbench, with different crossvalidation
wb2 = createWorkbench(folds=5, reps=20)
#a third one, with a different regressor and extra parameters passed to regressor function
wb3 = createWorkbench(regressor=phenoRegressor.BGLR, regressor.name='Bayesian Lasso', type='BL')
</code></pre>

<hr>
<h2 id='dummy.function'>Dummy function for import management</h2><span id='topic+dummy.function'></span>

<h3>Description</h3>

<p>This function allows to have a single place where to place all the generic @import.
Usually only a couple are required, but for things used all over the places (like stats package)
there is no real single place where to put the import. It's cleaner in this way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy.function()
</code></pre>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='getExtraCovariatesNames'>String of extra covariates names</h2><span id='topic+getExtraCovariatesNames'></span>

<h3>Description</h3>

<p>Given a <code>Noisy Dataset</code> object, this function
returns a representation of the extra covariates
present in the object. If no extra covariates are
present an empty string is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExtraCovariatesNames(nds, separator = " ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExtraCovariatesNames_+3A_nds">nds</code></td>
<td>
<p>a <code>Noisy Dataset</code> object.</p>
</td></tr>
<tr><td><code id="getExtraCovariatesNames_+3A_separator">separator</code></td>
<td>
<p>used for string concatenation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string representation of extra covariates names.
</p>

<hr>
<h2 id='getNoisyPhenotype'>Generate an instance of noisy phenotypes</h2><span id='topic+getNoisyPhenotype'></span>

<h3>Description</h3>

<p>Given a <code>Noisy Dataset</code> object, this function
applies the noise injector to the data and returns
a noisy version of it.
It is useful for inspecting the noisy injector effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNoisyPhenotype(nds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNoisyPhenotype_+3A_nds">nds</code></td>
<td>
<p>a <code>Noisy Dataset</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the phenotypes contained in <code>nds</code> with added noise.
</p>

<hr>
<h2 id='GROAN.AI'>Example data for pea AI lines</h2><span id='topic+GROAN.AI'></span>

<h3>Description</h3>

<p>This list contains all data required to run GROAN examples. It refers to a pea experiment
with 105 lines coming from a biparental Attika x Isard cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GROAN.AI
</code></pre>


<h3>Format</h3>

<p>A list with the following fields:
</p>

<ul>
<li><p><em>&quot;GROAN.AI$yield&quot;</em>: named array with 105 slots, containing data on grain yield [t/ha]
</p>
</li>
<li><p><em>&quot;GROAN.AI$SNPs&quot;</em>: data frame with 105 rows and 647 variables. Each row is
a pea AI line, each column a SNP marker. Values can either be 0, 1, or 2,
representing the three possible genotypes (AA, Aa, and aa, respectively).
</p>
</li>
<li><p><em>&quot;GROAN.AI$kinship&quot;</em>: square dataframe containing the realized kinships between
all pairs of each of the 105 pea AI lines. Values were computed following the
<a href="https://www.jstor.org/stable/25681325">Astle &amp; Balding metric</a>.
Higher values represent a higher degree of genetic similarity between
lines. This metric mainly accounts for additive genetic contributions
(as an alternative to dominant contributions).
</p>
</li></ul>



<h3>Source</h3>

<p>Annicchiarico et al., <em>GBS-Based Genomic Selection
for Pea Grain Yield under Severe Terminal Drought</em>, The Plant Genome,
Volume 10. doi: <a href="https://doi.org/10.3835/plantgenome2016.07.0072">10.3835/plantgenome2016.07.0072</a>
</p>

<hr>
<h2 id='GROAN.KI'>Example data for pea KI lines</h2><span id='topic+GROAN.KI'></span>

<h3>Description</h3>

<p>This list contains all data required to run GROAN examples. It refers to a pea experiment
with 103 lines coming from a biparental Kaspa x Isard cross.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GROAN.KI
</code></pre>


<h3>Format</h3>

<p>A list with the following fields:
</p>

<ul>
<li><p><em>&quot;GROAN.KI$yield&quot;</em>: named array with 103 slots, containing data on grain yield [t/ha]
</p>
</li>
<li><p><em>&quot;GROAN.KI$SNPs&quot;</em>: data frame with 103 rows and 647 variables. Each row is
a pea KI line, each column a SNP marker. Values can either be 0, 1, or 2,
representing the three possible genotypes (AA, Aa, and aa, respectively).
</p>
</li>
<li><p><em>&quot;GROAN.KI$kinship&quot;</em>: square dataframe containing the realized kinships between
all pairs of each of the 103 pea KI lines. Values were computed following the
<a href="https://www.jstor.org/stable/25681325">Astle &amp; Balding metric</a>.
Higher values represent a higher degree of genetic similarity between
lines. This metric mainly accounts for additive genetic contributions
(as an alternative to dominant contributions).
</p>
</li></ul>



<h3>Source</h3>

<p>Annicchiarico et al., <em>GBS-Based Genomic Selection
for Pea Grain Yield under Severe Terminal Drought</em>, The Plant Genome,
Volume 10. doi: <a href="https://doi.org/10.3835/plantgenome2016.07.0072">10.3835/plantgenome2016.07.0072</a>
</p>

<hr>
<h2 id='GROAN.pea.kinship'>[DEPRECATED]</h2><span id='topic+GROAN.pea.kinship'></span>

<h3>Description</h3>

<p>This piece of data is deprecated and will be dismissed in next
release. Please use <a href="#topic+GROAN.KI">GROAN.KI</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GROAN.pea.kinship
</code></pre>


<h3>Format</h3>

<p>A data frame with 103 rows and 103 variables. Row and
column names are pea KI lines.
</p>


<h3>Source</h3>

<p>Annicchiarico et al., <em>GBS-Based Genomic Selection
for Pea Grain Yield under Severe Terminal Drought</em>, The Plant Genome,
Volume 10. doi: <a href="https://doi.org/10.3835/plantgenome2016.07.0072">10.3835/plantgenome2016.07.0072</a>
</p>

<hr>
<h2 id='GROAN.pea.SNPs'>[DEPRECATED]</h2><span id='topic+GROAN.pea.SNPs'></span>

<h3>Description</h3>

<p>This piece of data is deprecated and will be dismissed in next
release. Please use <a href="#topic+GROAN.KI">GROAN.KI</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GROAN.pea.SNPs
</code></pre>


<h3>Format</h3>

<p>A data frame with 103 rows and 647 variables. Each
row represent a pea KI line, each column a SNP marker
</p>


<h3>Source</h3>

<p>Annicchiarico et al., <em>GBS-Based Genomic Selection
for Pea Grain Yield under Severe Terminal Drought</em>, The Plant Genome,
Volume 10. doi: <a href="https://doi.org/10.3835/plantgenome2016.07.0072">10.3835/plantgenome2016.07.0072</a>
</p>

<hr>
<h2 id='GROAN.pea.yield'>[DEPRECATED]</h2><span id='topic+GROAN.pea.yield'></span>

<h3>Description</h3>

<p>This piece of data is deprecated and will be dismissed in next
release. Please use <a href="#topic+GROAN.KI">GROAN.KI</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GROAN.pea.yield
</code></pre>


<h3>Format</h3>

<p>A named array with 103 slots.
</p>


<h3>Source</h3>

<p>Annicchiarico et al., <em>GBS-Based Genomic Selection
for Pea Grain Yield under Severe Terminal Drought</em>, The Plant Genome,
Volume 10. doi: <a href="https://doi.org/10.3835/plantgenome2016.07.0072">10.3835/plantgenome2016.07.0072</a>
</p>

<hr>
<h2 id='GROAN.run'>Compare Genomic Regressors on a Noisy Dataset</h2><span id='topic+GROAN.run'></span>

<h3>Description</h3>

<p>This function runs the experiment described in a <a href="#topic+createWorkbench">GROAN.Workbench</a> object,
training regressor(s) on the data contained in a <a href="#topic+createNoisyDataset">GROAN.NoisyDataSet</a> object
via parameter <code>nds</code>. The prediction accuracy is estimated either through crossvalidation
or on separate test dataset supplied via parameter <code>nds.test</code>.
It returns a <code>GROAN.Result</code> object, which have a <a href="#topic+summary.GROAN.Result">summary</a>
function for quick inspection and can be fed to <a href="#topic+plotResult">plotResult</a> for visual comparisons.
In case of crossvalidation the test dataset in the result object will report the <code>[CV]</code>
suffix.<br />
The experiment statistics are computed via <a href="#topic+measurePredictionPerformance">measurePredictionPerformance</a>.<br />
Each time this function is invoked it will refer to a <code>runId</code> - an alphanumeric string identifying
each specific run. The <code>runId</code> is usually generated internally, but it is possible to pass it if
the intention is to join results from different runs for analysis purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GROAN.run(nds, wb, nds.test = NULL, run.id = createRunId())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GROAN.run_+3A_nds">nds</code></td>
<td>
<p>a GROAN.NoisyDataSet object, containing the data (genotypes, phenotypes and so forth) plus a <code>noiseInjector</code> function</p>
</td></tr>
<tr><td><code id="GROAN.run_+3A_wb">wb</code></td>
<td>
<p>a GROAN.Workbench object, containing the regressors to be tested together with the description of the experiment</p>
</td></tr>
<tr><td><code id="GROAN.run_+3A_nds.test">nds.test</code></td>
<td>
<p>either a GROAN.NoisyDataSet or a list of GROAN.NoisyDataSet. The regression model(s) trained
on <code>nds</code> will be tested on <code>nds.test</code></p>
</td></tr>
<tr><td><code id="GROAN.run_+3A_run.id">run.id</code></td>
<td>
<p>an alphanumeric string identifying this specific run. If not passed it is generated using <a href="#topic+createRunId">createRunId</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>GROAN.Result</code> object
</p>


<h3>See Also</h3>

<p><a href="#topic+measurePredictionPerformance">measurePredictionPerformance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Complete examples are found in the vignette
vignette('GROAN.vignette', package='GROAN')

#Minimal example
#1) creating a noisy dataset with normal noise
nds = createNoisyDataset(
  name = 'PEA KI, normal noise',
  genotypes = GROAN.KI$SNPs,
  phenotypes = GROAN.KI$yield,
  noiseInjector = noiseInjector.norm,
  mean = 0,
  sd = sd(GROAN.KI$yield) * 0.5
)

#2) creating a GROAN.WorkBench using default regressor and crossvalidation preset
wb = createWorkbench()

#3) running the experiment
res = GROAN.run(nds, wb)

#4) examining results
summary(res)
plotResult(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='is.boolean'>Is a boolean?</h2><span id='topic+is.boolean'></span>

<h3>Description</h3>

<p>Returns TRUE if the passed x variable is a length one variable
containing a valid TRUE/FALSE value. This test is stricter than
function <code>is.logical</code>, since NA, NULL and NaN all return FALSE.
Moreover, only single cell (length one) array admitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.boolean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.boolean_+3A_x">x</code></td>
<td>
<p>the variable to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean
</p>

<hr>
<h2 id='is.in.range'>Is in the passed numeric range</h2><span id='topic+is.in.range'></span>

<h3>Description</h3>

<p>Function returns TRUE if the passed variable is numeric and all its content
is in the passed range (defined by <code>min</code> and <code>max</code>). Works also in
array (in that case all values must be in the range).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.in.range(x, min = 0, max = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.in.range_+3A_x">x</code></td>
<td>
<p>value to be tested</p>
</td></tr>
<tr><td><code id="is.in.range_+3A_min">min</code></td>
<td>
<p>minimum admitted value</p>
</td></tr>
<tr><td><code id="is.in.range_+3A_max">max</code></td>
<td>
<p>maximum admitted value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if x is a numeric completely in the specified range, FALSE otherwise
</p>

<hr>
<h2 id='is.naturalnumber'>Is a positive integer?</h2><span id='topic+is.naturalnumber'></span>

<h3>Description</h3>

<p><code>is.naturalnumber</code> returns true if the passed argument
is a positive integer, false otherwise.
Implementation taken from Marcog's answer
<a href="https://stackoverflow.com/questions/4562257/what-is-the-fastest-way-to-check-if-a-number-is-a-positive-natural-number-in-r">to this question</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.naturalnumber(x, low.Limit = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.naturalnumber_+3A_x">x</code></td>
<td>
<p>the value(s) to be tested</p>
</td></tr>
<tr><td><code id="is.naturalnumber_+3A_low.limit">low.Limit</code></td>
<td>
<p>the greatest value not accepted. Defaults to zero, meaning that
one is the smallest integer that returns true.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the value is a positive integer, FALSE otherwise (or NA)
</p>

<hr>
<h2 id='is.single.slot'>Is a single slot thing?</h2><span id='topic+is.single.slot'></span>

<h3>Description</h3>

<p>Checks if the passed variable is a single slot thing, meaning it contains only a single
value (numeric, character, whatever) and nothing more.
Works with array, vectors, matrix, data.frame...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.single.slot(x, NULL.is.single = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.single.slot_+3A_x">x</code></td>
<td>
<p>the thing to be tested</p>
</td></tr>
<tr><td><code id="is.single.slot_+3A_null.is.single">NULL.is.single</code></td>
<td>
<p>should NULL be considered a single slot or not (default: not)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if is single slot, FALSE otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.single.slot(5)   #TRUE
is.single.slot('foobar')   #TRUE
is.single.slot(NULL)       #depends on NULL.is.single
is.single.slot(NA)         #TRUE
is.single.slot(c(1,2,5))   #FALSE
is.single.slot(matrix(0, 10, 5))   #FALSE
is.single.slot(matrix(0, 1, 1))   #TRUE
</code></pre>

<hr>
<h2 id='is.string'>Is a string?</h2><span id='topic+is.string'></span>

<h3>Description</h3>

<p>Returns TRUE if the passed x variable is a length one variable
containing characters values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.string(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.string_+3A_x">x</code></td>
<td>
<p>the variable to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean
</p>

<hr>
<h2 id='measurePredictionPerformance'>Measure Performance of a Prediction</h2><span id='topic+measurePredictionPerformance'></span>

<h3>Description</h3>

<p>This method returns several performance metrics for the passed
predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measurePredictionPerformance(truevals, predvals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measurePredictionPerformance_+3A_truevals">truevals</code></td>
<td>
<p>true values</p>
</td></tr>
<tr><td><code id="measurePredictionPerformance_+3A_predvals">predvals</code></td>
<td>
<p>predicted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named array with the following fields:
</p>

<dl>
<dt>pearson</dt><dd><p>Pearson's correlation</p>
</dd>
<dt>spearman</dt><dd><p>Spearmans' correlation (order based)</p>
</dd>
<dt>rmse</dt><dd><p>Root Mean Square Error</p>
</dd>
<dt>mae</dt><dd><p>Mean Absolute Error</p>
</dd>
<dt>coeff_det</dt><dd><p>Coefficient of determination</p>
</dd>
<dt>ndcg10, ndcg20, ndcg50, ndcg100</dt><dd><p>mean Normalized Discounted Cumulative Gain with k equal to 0.1, 0.2, 0.5 and 1</p>
</dd>
</dl>


<hr>
<h2 id='ndcg'>Function to calculate mean Normalized Discounted Cumulative Gain (NDCG)</h2><span id='topic+ndcg'></span>

<h3>Description</h3>

<p>This function calculates NDCG from the vectors of observed
and predicted values and the chosen proportion k of top
observations (rank).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndcg(y, y_hat, k = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndcg_+3A_y">y</code></td>
<td>
<p>true values</p>
</td></tr>
<tr><td><code id="ndcg_+3A_y_hat">y_hat</code></td>
<td>
<p>predicted values</p>
</td></tr>
<tr><td><code id="ndcg_+3A_k">k</code></td>
<td>
<p>relevant proportion of rank (top)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a real value in [0,1]
</p>

<hr>
<h2 id='noiseInjector.dummy'>Noise Injector dummy function</h2><span id='topic+noiseInjector.dummy'></span>

<h3>Description</h3>

<p>This noise injector does not add any noise. Passed <code>phenotypes</code> are
simply returned. This function is useful when comparing different
regressors on the same dataset without the effect of extra injected noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noiseInjector.dummy(phenotypes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noiseInjector.dummy_+3A_phenotypes">phenotypes</code></td>
<td>
<p>input phenotypes. This object will be returned without checks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same passed <code>phenotypes</code>
</p>


<h3>See Also</h3>

<p>Other noiseInjectors: 
<code><a href="#topic+noiseInjector.norm">noiseInjector.norm</a>()</code>,
<code><a href="#topic+noiseInjector.swapper">noiseInjector.swapper</a>()</code>,
<code><a href="#topic+noiseInjector.unif">noiseInjector.unif</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>phenos = rnorm(10)
all(phenos == noiseInjector.dummy(phenos)) #TRUE
</code></pre>

<hr>
<h2 id='noiseInjector.norm'>Inject Normal Noise</h2><span id='topic+noiseInjector.norm'></span>

<h3>Description</h3>

<p>This function adds to the passed <code>phenotypes</code> array noise sampled from
a normal distribution with the specified mean and standard deviation.<br />
The function can interest the totality of the passed phenotype array or
a random subset of it (commanded by <code>subset</code> parameter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noiseInjector.norm(phenotypes, mean = 0, sd = 1, subset = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noiseInjector.norm_+3A_phenotypes">phenotypes</code></td>
<td>
<p>an array of numbers.</p>
</td></tr>
<tr><td><code id="noiseInjector.norm_+3A_mean">mean</code></td>
<td>
<p>mean of the normal distribution.</p>
</td></tr>
<tr><td><code id="noiseInjector.norm_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the normal distribution.</p>
</td></tr>
<tr><td><code id="noiseInjector.norm_+3A_subset">subset</code></td>
<td>
<p>integer in [0,1], the proportion of original dataset to be injected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array, of the same size as phenotypes, where normal noise has been added to
the original phenotype values.
</p>


<h3>See Also</h3>

<p>Other noiseInjectors: 
<code><a href="#topic+noiseInjector.dummy">noiseInjector.dummy</a>()</code>,
<code><a href="#topic+noiseInjector.swapper">noiseInjector.swapper</a>()</code>,
<code><a href="#topic+noiseInjector.unif">noiseInjector.unif</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#a sinusoid signal
phenos = sin(seq(0,5, 0.1))
plot(phenos, type='p', pch=16, main='Original (black) vs. Injected (red), 100% affected')

#adding normal noise to all samples
phenos.noise = noiseInjector.norm(phenos, sd = 0.2)
points(phenos.noise, type='p', col='red')

#adding noise only to 30% of the samples
plot(phenos, type='p', pch=16, main='Original (black) vs. Injected (red), 30% affected')
phenos.noise.subset = noiseInjector.norm(phenos, sd = 0.2, subset = 0.3)
points(phenos.noise.subset, type='p', col='red')
</code></pre>

<hr>
<h2 id='noiseInjector.swapper'>Swap phenotypes between samples</h2><span id='topic+noiseInjector.swapper'></span>

<h3>Description</h3>

<p>This function introduces swap noise, i.e. a number of couples of
samples will have their phenotypes swapped.<br />
The number of couples is computed so that the total fraction of
interested phenotypes approximates <code>subset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noiseInjector.swapper(phenotypes, subset = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noiseInjector.swapper_+3A_phenotypes">phenotypes</code></td>
<td>
<p>an array of numbers</p>
</td></tr>
<tr><td><code id="noiseInjector.swapper_+3A_subset">subset</code></td>
<td>
<p>fraction of phenotypes to be interested by noise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same passed <code>phenotypes</code>, but with some elements swapped
</p>


<h3>See Also</h3>

<p>Other noiseInjectors: 
<code><a href="#topic+noiseInjector.dummy">noiseInjector.dummy</a>()</code>,
<code><a href="#topic+noiseInjector.norm">noiseInjector.norm</a>()</code>,
<code><a href="#topic+noiseInjector.unif">noiseInjector.unif</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#a set of phenotypes
phenos = 1:10
#swapping two elements
phenos.sw2 = noiseInjector.swapper(phenos, 0.2)
#swapping four elements
phenos.sw4 = noiseInjector.swapper(phenos, 0.4)
#swapping four elements again, since 30% of 10 elements
#is rounded to 4 (two couples)
phenos.sw4.again = noiseInjector.swapper(phenos, 0.3)
</code></pre>

<hr>
<h2 id='noiseInjector.unif'>Inject Uniform Noise</h2><span id='topic+noiseInjector.unif'></span>

<h3>Description</h3>

<p>This function adds to the passed <code>phenotypes</code> array noise sampled from
a uniform distribution with the specified range.<br />
The function can interest the totality of the passed phenotype array or
a random subset of it (commanded by <code>subset</code> parameter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noiseInjector.unif(phenotypes, min = 0, max = 1, subset = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noiseInjector.unif_+3A_phenotypes">phenotypes</code></td>
<td>
<p>an array of numbers.</p>
</td></tr>
<tr><td><code id="noiseInjector.unif_+3A_min">min</code>, <code id="noiseInjector.unif_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution. Must be finite.</p>
</td></tr>
<tr><td><code id="noiseInjector.unif_+3A_subset">subset</code></td>
<td>
<p>integer in [0,1], the proportion of original dataset to be injected</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array, of the same size as phenotypes, where uniform noise has been added to
the original phenotype values.
</p>


<h3>See Also</h3>

<p>Other noiseInjectors: 
<code><a href="#topic+noiseInjector.dummy">noiseInjector.dummy</a>()</code>,
<code><a href="#topic+noiseInjector.norm">noiseInjector.norm</a>()</code>,
<code><a href="#topic+noiseInjector.swapper">noiseInjector.swapper</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#a sinusoid signal
phenos = sin(seq(0,5, 0.1))
plot(phenos, type='p', pch = 16, main='Original (black) vs. Injected (red), 100% affected')

#adding normal noise to all samples
phenos.noise = noiseInjector.unif(phenos, min=0.1, max=0.3)
points(phenos.noise, type='p', col='red')

#adding noise only to 30% of the samples
plot(phenos, type='p', pch = 16, main='Original (black) vs. Injected (red), 30% affected')
phenos.noise.subset = noiseInjector.unif(phenos, min=0.1, max=0.3, subset = 0.3)
points(phenos.noise.subset, type='p', col='red')
</code></pre>

<hr>
<h2 id='phenoRegressor.BGLR'>Regression using BGLR package</h2><span id='topic+phenoRegressor.BGLR'></span>

<h3>Description</h3>

<p>This is a wrapper around <code><a href="BGLR.html#topic+BGLR">BGLR</a></code>. As such, it won't work if BGLR package
is not installed.<br />
Genotypes are modeled using the specified <code>type</code>. If <code>type</code> is 'RKHS' (and only
in this case) the covariance/kinship matrix <code>covariances</code> is required, and it will be modeled
as matrix K in BGLR terms. In all other cases genotypes and covariances are put in the model
as X matrices.<br />
Extra covariates, if present, are modeled as FIXED effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoRegressor.BGLR(
  phenotypes,
  genotypes,
  covariances,
  extraCovariates,
  type = c("FIXED", "BRR", "BL", "BayesA", "BayesB", "BayesC", "RKHS"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoRegressor.BGLR_+3A_phenotypes">phenotypes</code></td>
<td>
<p>phenotypes, a numeric array (n x 1), missing values are predicted</p>
</td></tr>
<tr><td><code id="phenoRegressor.BGLR_+3A_genotypes">genotypes</code></td>
<td>
<p>SNP genotypes, one row per phenotype (n), one column per marker (m), values in 0/1/2 for
diploids or 0/1/2/...ploidy for polyploids. Can be NULL if <code>covariances</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.BGLR_+3A_covariances">covariances</code></td>
<td>
<p>square matrix (n x n) of covariances. Can be NULL if <code>genotypes</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.BGLR_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>extra covariates set, one row per phenotype (n), one column per covariate (w).
If NULL no extra covariates are considered.</p>
</td></tr>
<tr><td><code id="phenoRegressor.BGLR_+3A_type">type</code></td>
<td>
<p>character literal, one of the following: FIXED (Flat prior), BRR (Gaussian prior),
BL (Double-Exponential prior), BayesA (scaled-t prior),
BayesB (two component mixture prior with a point of mass at zero and a scaled-t slab),
BayesC (two component mixture prior with a point of mass at zero and a Gaussian slab)</p>
</td></tr>
<tr><td><code id="phenoRegressor.BGLR_+3A_...">...</code></td>
<td>
<p>extra parameters are passed to <code><a href="BGLR.html#topic+BGLR">BGLR</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following fields:
</p>

<ul>
<li> <p><code>predictions</code> : an array of (n) predicted phenotypes, with NAs filled and all other positions repredicted (useful for calculating residuals)
</p>
</li>
<li> <p><code>hyperparams</code> : empty, returned for compatibility
</p>
</li>
<li> <p><code>extradata</code>   : list with information on trained model, coming from <code><a href="BGLR.html#topic+BGLR">BGLR</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="BGLR.html#topic+BGLR">BGLR</a>
</p>
<p>Other phenoRegressors: 
<code><a href="#topic+phenoRegressor.RFR">phenoRegressor.RFR</a>()</code>,
<code><a href="#topic+phenoRegressor.SVR">phenoRegressor.SVR</a>()</code>,
<code><a href="#topic+phenoRegressor.dummy">phenoRegressor.dummy</a>()</code>,
<code><a href="#topic+phenoRegressor.rrBLUP">phenoRegressor.rrBLUP</a>()</code>,
<code><a href="#topic+phenoregressor.BGLR.multikinships">phenoregressor.BGLR.multikinships</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#using the GROAN.KI dataset, we regress on the dataset and predict the first ten phenotypes
phenos = GROAN.KI$yield
phenos[1:10]  = NA

#calling the regressor with Bayesian Lasso
results = phenoRegressor.BGLR(
  phenotypes = phenos,
  genotypes = GROAN.KI$SNPs,
  covariances = NULL,
  extraCovariates = NULL,
  type = 'BL', nIter = 2000 #BGLR-specific parameters
)

#examining the predictions
plot(GROAN.KI$yield, results$predictions,
     main = 'Train set (black) and test set (red) regressions',
     xlab = 'Original phenotypes', ylab = 'Predicted phenotypes')
points(GROAN.KI$yield[1:10], results$predictions[1:10], pch=16, col='red')

#printing correlations
test.set.correlation  = cor(GROAN.KI$yield[1:10], results$predictions[1:10])
train.set.correlation = cor(GROAN.KI$yield[-(1:10)], results$predictions[-(1:10)])
writeLines(paste(
  'test-set correlation :', test.set.correlation,
  '\ntrain-set correlation:', train.set.correlation
))

## End(Not run)
</code></pre>

<hr>
<h2 id='phenoregressor.BGLR.multikinships'>Multi-matrix GBLUP using BGLR</h2><span id='topic+phenoregressor.BGLR.multikinships'></span>

<h3>Description</h3>

<p>This regressor implements Genomic BLUP using Bayesian methods from <a href="BGLR.html#topic+BGLR">BGLR</a> package,
but allows to use more than one covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoregressor.BGLR.multikinships(
  phenotypes,
  genotypes = NULL,
  covariances,
  extraCovariates,
  type = "RKHS",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoregressor.BGLR.multikinships_+3A_phenotypes">phenotypes</code></td>
<td>
<p>phenotypes, a numeric array (n x 1), missing values are predicted</p>
</td></tr>
<tr><td><code id="phenoregressor.BGLR.multikinships_+3A_genotypes">genotypes</code></td>
<td>
<p>added for compatibility with the other GROAN regressors, must be NULL</p>
</td></tr>
<tr><td><code id="phenoregressor.BGLR.multikinships_+3A_covariances">covariances</code></td>
<td>
<p>square matrix (n x n) of covariances.</p>
</td></tr>
<tr><td><code id="phenoregressor.BGLR.multikinships_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>the extra covariance matrices to be added in the GBLUP model,
collated in a single matrix-like structure, with optionally first column
as an ignored intercept (supported for compatibility). See details, below.</p>
</td></tr>
<tr><td><code id="phenoregressor.BGLR.multikinships_+3A_type">type</code></td>
<td>
<p>character literal, one of the following: FIXED (Flat prior), BRR (Gaussian prior),
BL (Double-Exponential prior), BayesA (scaled-t prior),
BayesB (two component mixture prior with a point of mass at zero and a scaled-t slab),
BayesC (two component mixture prior with a point of mass at zero and a Gaussian slab),
RKHS (Gaussian processes, default)</p>
</td></tr>
<tr><td><code id="phenoregressor.BGLR.multikinships_+3A_...">...</code></td>
<td>
<p>extra parameters are passed to <code><a href="BGLR.html#topic+BGLR">BGLR</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In its simplest form, GBLUP is defined as:
</p>
<p style="text-align: center;"><code class="reqn">y = 1\mu + Z u + e</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">var(y) =  K \sigma_u^2 + I\sigma_e^2</code>
</p>

<p>Where <code class="reqn">\mu</code> is the overall mean, <code class="reqn">K</code> is the incidence matrix
relating individual weights <code class="reqn">u</code> to <code class="reqn">y</code>, and <code class="reqn">e</code> is a
vector of residuals with zero mean and covariance matrix <code class="reqn">I\sigma_e^2</code>
</p>
<p>It is possible to extend the above model to include different types of
kinship matrices, each capturing different links between genotypes and phenotypes:
</p>
<p style="text-align: center;"><code class="reqn">y = 1\mu + Z1 u1 + Z2 u2 + \dots + e</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">var(y) =  K1 \sigma_u1^2 + K2 \sigma_u2^2 + \dots + I\sigma_e^2</code>
</p>

<p>This function receives the first kinship matrix <code class="reqn">K1</code> via the <code>covariances</code>
argument and an arbitrary number of extra matrices via the <code>extraCovariates</code>
built as follow:
</p>
<pre>#given the following defined variables
y = &lt;some values, Nx1 array&gt;
K1 = &lt;NxN kinship matrix&gt;
K2 = &lt;another NxN kinship matrix&gt;
K3 = &lt;a third NxN kinship matrix&gt;

#invoking the multi kinship GBLUP
y_hat = phenoregressor.BGLR.multikinships(
  phenotypes = y,
  covariances = K1,
  extraCovariates = cbind(K2, K3)
)
</pre>


<h3>Value</h3>

<p>The function returns a list with the following fields:
</p>

<ul>
<li> <p><code>predictions</code> : an array of (n) predicted phenotypes, with NAs filled and all other positions repredicted (useful for calculating residuals)
</p>
</li>
<li> <p><code>hyperparams</code> : empty, returned for compatibility
</p>
</li>
<li> <p><code>extradata</code>   : list with information on trained model, coming from <code><a href="BGLR.html#topic+BGLR">BGLR</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="BGLR.html#topic+BGLR">BGLR</a>
</p>
<p>Other phenoRegressors: 
<code><a href="#topic+phenoRegressor.BGLR">phenoRegressor.BGLR</a>()</code>,
<code><a href="#topic+phenoRegressor.RFR">phenoRegressor.RFR</a>()</code>,
<code><a href="#topic+phenoRegressor.SVR">phenoRegressor.SVR</a>()</code>,
<code><a href="#topic+phenoRegressor.dummy">phenoRegressor.dummy</a>()</code>,
<code><a href="#topic+phenoRegressor.rrBLUP">phenoRegressor.rrBLUP</a>()</code>
</p>

<hr>
<h2 id='phenoRegressor.dummy'>Regression dummy function</h2><span id='topic+phenoRegressor.dummy'></span>

<h3>Description</h3>

<p>This function is for development purposes. It returns, as &quot;predictions&quot;, an array of
random numbers. It accept the standard inputs and produces a formally correct output. It
is, obviously, quite fast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoRegressor.dummy(phenotypes, genotypes, covariances, extraCovariates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoRegressor.dummy_+3A_phenotypes">phenotypes</code></td>
<td>
<p>phenotypes, numeric array (n x 1), missing values are predicted</p>
</td></tr>
<tr><td><code id="phenoRegressor.dummy_+3A_genotypes">genotypes</code></td>
<td>
<p>SNP genotypes, one row per phenotype (n), one column per marker (m), values in 0/1/2 for
diploids or 0/1/2/...ploidy for polyploids. Can be NULL if <code>covariances</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.dummy_+3A_covariances">covariances</code></td>
<td>
<p>square matrix (n x n) of covariances. Can be NULL if <code>genotypes</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.dummy_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>extra covariates set, one row per phenotype (n), one column per covariate (w).
If NULL no extra covariates are considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function should return a list with the following fields:
</p>

<ul>
<li> <p><code>predictions</code> : an array of (k) predicted phenotypes
</p>
</li>
<li> <p><code>hyperparams</code> : named array of hyperparameters selected during training
</p>
</li>
<li> <p><code>extradata</code>   : any extra information
</p>
</li></ul>



<h3>See Also</h3>

<p>Other phenoRegressors: 
<code><a href="#topic+phenoRegressor.BGLR">phenoRegressor.BGLR</a>()</code>,
<code><a href="#topic+phenoRegressor.RFR">phenoRegressor.RFR</a>()</code>,
<code><a href="#topic+phenoRegressor.SVR">phenoRegressor.SVR</a>()</code>,
<code><a href="#topic+phenoRegressor.rrBLUP">phenoRegressor.rrBLUP</a>()</code>,
<code><a href="#topic+phenoregressor.BGLR.multikinships">phenoregressor.BGLR.multikinships</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#genotypes are not really investigated. Only
#number of test phenotypes is used.
phenoRegressor.dummy(
  phenotypes = c(1:10, NA, NA, NA),
  genotypes = matrix(nrow = 13, ncol=30)
)
</code></pre>

<hr>
<h2 id='phenoRegressor.RFR'>Random Forest Regression using package randomForest</h2><span id='topic+phenoRegressor.RFR'></span>

<h3>Description</h3>

<p>This is a wrapper around <a href="randomForest.html#topic+randomForest">randomForest</a> and related functions.
As such, this function will not work if randomForest package is not installed.
There is no distinction between regular covariates (genotypes) and extra
covariates (fixed effects) in random forest. If extra covariates are passed, they are
put together with genotypes, side by side. Same thing happens with covariances matrix. This
can bring to the scientifically questionable but technically correct situation of regressing
on a big matrix made of SNP genotypes, covariances and other covariates, all collated side by side.
The function makes no distinction, and it's up to the user understand what is correct in each
specific experiment.<br />
<br />
<strong>WARNING</strong>: this function can be *very* slow, especially when called on thousands of SNPs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoRegressor.RFR(
  phenotypes,
  genotypes,
  covariances,
  extraCovariates,
  ntree = ceiling(length(phenotypes)/5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoRegressor.RFR_+3A_phenotypes">phenotypes</code></td>
<td>
<p>phenotypes, a numeric array (n x 1), missing values are predicted</p>
</td></tr>
<tr><td><code id="phenoRegressor.RFR_+3A_genotypes">genotypes</code></td>
<td>
<p>SNP genotypes, one row per phenotype (n), one column per marker (m), values in 0/1/2 for
diploids or 0/1/2/...ploidy for polyploids. Can be NULL if <code>covariances</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.RFR_+3A_covariances">covariances</code></td>
<td>
<p>square matrix (n x n) of covariances. Can be NULL if <code>genotypes</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.RFR_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>extra covariates set, one row per phenotype (n), one column per covariate (w).
If NULL no extra covariates are considered.</p>
</td></tr>
<tr><td><code id="phenoRegressor.RFR_+3A_ntree">ntree</code></td>
<td>
<p>number of trees to grow, defaults to a fifth of the number of samples (rounded
up). As per <code>randomForest</code> documentation, it should not be set to too
small a number, to ensure that every input row gets predicted at least a few times</p>
</td></tr>
<tr><td><code id="phenoRegressor.RFR_+3A_...">...</code></td>
<td>
<p>any extra parameter is passed to <code>randomForest::randomForest()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following fields:
</p>

<ul>
<li> <p><code>predictions</code> : an array of (k) predicted phenotypes
</p>
</li>
<li> <p><code>hyperparams</code> : named vector with the following keys: ntree (number of grown trees)
and mtry (number of variables randomly sampled as candidates at each split)
</p>
</li>
<li> <p><code>extradata</code>   : the object returned by <code>randomForest::randomForest()</code>, containing the
full trained forest and the used parameters
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="randomForest.html#topic+randomForest">randomForest</a>
</p>
<p>Other phenoRegressors: 
<code><a href="#topic+phenoRegressor.BGLR">phenoRegressor.BGLR</a>()</code>,
<code><a href="#topic+phenoRegressor.SVR">phenoRegressor.SVR</a>()</code>,
<code><a href="#topic+phenoRegressor.dummy">phenoRegressor.dummy</a>()</code>,
<code><a href="#topic+phenoRegressor.rrBLUP">phenoRegressor.rrBLUP</a>()</code>,
<code><a href="#topic+phenoregressor.BGLR.multikinships">phenoregressor.BGLR.multikinships</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#using the GROAN.KI dataset, we regress on the dataset and predict the first ten phenotypes
phenos = GROAN.KI$yield
phenos[1:10]  = NA

#calling the regressor with random forest
results = phenoRegressor.RFR(
  phenotypes = phenos,
  genotypes = GROAN.KI$SNPs,
  covariances = NULL,
  extraCovariates = NULL,
  ntree = 20,
  mtry = 200 #randomForest-specific parameters
)

#examining the predictions
plot(GROAN.KI$yield, results$predictions,
     main = 'Train set (black) and test set (red) regressions',
     xlab = 'Original phenotypes', ylab = 'Predicted phenotypes')
points(GROAN.KI$yield[1:10], results$predictions[1:10], pch=16, col='red')

#printing correlations
test.set.correlation  = cor(GROAN.KI$yield[1:10], results$predictions[1:10])
train.set.correlation = cor(GROAN.KI$yield[-(1:10)], results$predictions[-(1:10)])
writeLines(paste(
  'test-set correlation :', test.set.correlation,
  '\ntrain-set correlation:', train.set.correlation
))

## End(Not run)
</code></pre>

<hr>
<h2 id='phenoRegressor.rrBLUP'>SNP-BLUP or G-BLUP using rrBLUP package</h2><span id='topic+phenoRegressor.rrBLUP'></span>

<h3>Description</h3>

<p>This is a wrapper around <code>rrBLUP</code> function <code><a href="rrBLUP.html#topic+mixed.solve">mixed.solve</a></code>.
It can either work with genotypes (in form of a SNP matrix) or with kinships (in form of a covariance
matrix). In the first case the function will implement a SNP-BLUP, in the second a G-BLUP. An error is
returned if both SNPs and covariance matrix are passed.<br />
In rrBLUP terms, genotypes are modeled as random effects (matrix Z), covariances as matrix K, and
extra covariates, if present, as fixed effects (matrix X).<br />
Please note that this function won't work if rrBLUP package is not installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoRegressor.rrBLUP(
  phenotypes,
  genotypes = NULL,
  covariances = NULL,
  extraCovariates = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoRegressor.rrBLUP_+3A_phenotypes">phenotypes</code></td>
<td>
<p>phenotypes, a numeric array (n x 1), missing values are predicted</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP_+3A_genotypes">genotypes</code></td>
<td>
<p>SNP genotypes, one row per phenotype (n), one column per marker (m), values in 0/1/2 for
diploids or 0/1/2/...ploidy for polyploids. Can be NULL if <code>covariances</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP_+3A_covariances">covariances</code></td>
<td>
<p>square matrix (n x n) of covariances.</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>optional extra covariates set, one row per phenotype (n), one column per covariate (w).
If NULL no extra covariates are considered.</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP_+3A_...">...</code></td>
<td>
<p>extra parameters are passed to rrBLUP::mixed.solve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following fields:
</p>

<ul>
<li> <p><code>predictions</code> : an array of (k) predicted phenotypes
</p>
</li>
<li> <p><code>hyperparams</code> : named vector with the following keys: Vu, Ve, beta, LL
</p>
</li>
<li> <p><code>extradata</code>   : list with information on trained model, coming from <code><a href="rrBLUP.html#topic+mixed.solve">mixed.solve</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="rrBLUP.html#topic+mixed.solve">mixed.solve</a>
</p>
<p>Other phenoRegressors: 
<code><a href="#topic+phenoRegressor.BGLR">phenoRegressor.BGLR</a>()</code>,
<code><a href="#topic+phenoRegressor.RFR">phenoRegressor.RFR</a>()</code>,
<code><a href="#topic+phenoRegressor.SVR">phenoRegressor.SVR</a>()</code>,
<code><a href="#topic+phenoRegressor.dummy">phenoRegressor.dummy</a>()</code>,
<code><a href="#topic+phenoregressor.BGLR.multikinships">phenoregressor.BGLR.multikinships</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#using the GROAN.KI dataset, we regress on the dataset and predict the first ten phenotypes
phenos = GROAN.KI$yield
phenos[1:10]  = NA

#calling the regressor with ridge regression BLUP on SNPs and kinship
results.SNP.BLUP = phenoRegressor.rrBLUP(
  phenotypes = phenos,
  genotypes = GROAN.KI$SNPs,
  SE = TRUE, return.Hinv = TRUE #rrBLUP-specific parameters
)
results.G.BLUP = phenoRegressor.rrBLUP(
  phenotypes = phenos,
  covariances = GROAN.KI$kinship,
  SE = TRUE, return.Hinv = TRUE #rrBLUP-specific parameters
)

#examining the predictions
plot(GROAN.KI$yield, results.SNP.BLUP$predictions,
     main = '[SNP-BLUP] Train set (black) and test set (red) regressions',
     xlab = 'Original phenotypes', ylab = 'Predicted phenotypes')
abline(a=0, b=1)
points(GROAN.KI$yield[1:10], results.SNP.BLUP$predictions[1:10], pch=16, col='red')

plot(GROAN.KI$yield, results.G.BLUP$predictions,
     main = '[G-BLUP] Train set (black) and test set (red) regressions',
     xlab = 'Original phenotypes', ylab = 'Predicted phenotypes')
abline(a=0, b=1)
points(GROAN.KI$yield[1:10], results.G.BLUP$predictions[1:10], pch=16, col='red')

#printing correlations
correlations = data.frame(
  model = 'SNP-BLUP',
  test_set_correlations = cor(GROAN.KI$yield[1:10], results.SNP.BLUP$predictions[1:10]),
  train_set_correlations = cor(GROAN.KI$yield[-(1:10)], results.SNP.BLUP$predictions[-(1:10)])
)
correlations = rbind(correlations, data.frame(
  model = 'G-BLUP',
  test_set_correlations = cor(GROAN.KI$yield[1:10], results.G.BLUP$predictions[1:10]),
  train_set_correlations = cor(GROAN.KI$yield[-(1:10)], results.G.BLUP$predictions[-(1:10)])
))
print(correlations)

## End(Not run)
</code></pre>

<hr>
<h2 id='phenoRegressor.rrBLUP.G'>G-BLUP using rrBLUP library</h2><span id='topic+phenoRegressor.rrBLUP.G'></span>

<h3>Description</h3>

<p>This function implements G-BLUP using rrBLUP library. Not to be exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoRegressor.rrBLUP.G(phenotypes, covariances, extraCovariates = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoRegressor.rrBLUP.G_+3A_phenotypes">phenotypes</code></td>
<td>
<p>phenotypes, a numeric array (n x 1), missing values are predicted</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP.G_+3A_covariances">covariances</code></td>
<td>
<p>square matrix (n x n) of covariances.</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP.G_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>optional extra covariates set, one row per phenotype (n), one column per covariate (w).
If NULL no extra covariates are considered.</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP.G_+3A_...">...</code></td>
<td>
<p>extra parameters are passed to rrBLUP::mixed.solve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following fields:
</p>

<ul>
<li> <p><code>predictions</code> : an array of (k) predicted phenotypes
</p>
</li>
<li> <p><code>hyperparams</code> : named vector with the following keys: Vu, Ve, beta, LL
</p>
</li>
<li> <p><code>extradata</code>   : list with information on trained model, coming from <code><a href="rrBLUP.html#topic+mixed.solve">mixed.solve</a></code>
</p>
</li></ul>


<hr>
<h2 id='phenoRegressor.rrBLUP.SNP'>SNP-BLUP using rrBLUP library</h2><span id='topic+phenoRegressor.rrBLUP.SNP'></span>

<h3>Description</h3>

<p>Implementation of SNP-BLUP using rrBLUP library. Not to be exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoRegressor.rrBLUP.SNP(phenotypes, genotypes, extraCovariates = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoRegressor.rrBLUP.SNP_+3A_phenotypes">phenotypes</code></td>
<td>
<p>phenotypes, a numeric array (n x 1), missing values are predicted</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP.SNP_+3A_genotypes">genotypes</code></td>
<td>
<p>SNP genotypes, one row per phenotype (n), one column per marker (m), values in 0/1/2 for
diploids or 0/1/2/...ploidy for polyploids. Can be NULL if <code>covariances</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP.SNP_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>optional extra covariates set, one row per phenotype (n), one column per covariate (w).
If NULL no extra covariates are considered.</p>
</td></tr>
<tr><td><code id="phenoRegressor.rrBLUP.SNP_+3A_...">...</code></td>
<td>
<p>extra parameters are passed to rrBLUP::mixed.solve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following fields:
</p>

<ul>
<li> <p><code>predictions</code> : an array of (k) predicted phenotypes
</p>
</li>
<li> <p><code>hyperparams</code> : named vector with the following keys: Vu, Ve, beta, LL
</p>
</li>
<li> <p><code>extradata</code>   : list with information on trained model, coming from <code><a href="rrBLUP.html#topic+mixed.solve">mixed.solve</a></code>
</p>
</li></ul>


<hr>
<h2 id='phenoRegressor.SVR'>Support Vector Regression using package e1071</h2><span id='topic+phenoRegressor.SVR'></span>

<h3>Description</h3>

<p>This is a wrapper around several functions from <code>e1071</code> package (as such, it won't work if
e1071 package is not installed).
This function implements Support Vector Regressions, meaning that the data points are projected in
a transformed higher dimensional space where linear regression is possible.<br />
<br />
<code>phenoRegressor.SVR</code> can operate in three modes: run, train and tune.<br />
In <strong>run</strong> mode you need to pass the function an already tuned/trained SVR model, typically
obtained either directly from e1071 functions (e.g. from <a href="e1071.html#topic+svm">svm</a>, <a href="e1071.html#topic+best.svm">best.svm</a> and so forth)
or from a previous run of <code>phenoRegressor.SVR</code> in a different mode. The passed model is applied
to the passed dataset and predictions are returned.<br />
In <strong>train</strong> mode a SVR model will be trained on the passed dataset using the passed hyper
parameters. The trained model will then be used for predictions.<br />
In <strong>tune</strong> mode you need to pass one or more sets of hyperparameters. The best combination of
hyperparameters will be selected through crossvalidation. The best performing SVR model will be used
for final predictions. This mode can be very slow.<br />
<br />
There is no distinction between regular covariates (genotypes) and extra
covariates (fixed effects) in Support Vector Regression. If extra covariates are passed, they are
put together with genotypes, side by side. Same thing happens with covariances matrix. This
can bring to the scientifically questionable but technically correct situation of regressing
on a big matrix made of SNP genotypes, covariances and other covariates, all collated side by side.
The function makes no distinction, and it's up to the user understand what is correct in each
specific experiment.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phenoRegressor.SVR(
  phenotypes,
  genotypes,
  covariances,
  extraCovariates,
  mode = c("tune", "train", "run"),
  tuned.model = NULL,
  scale.pheno = TRUE,
  scale.geno = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phenoRegressor.SVR_+3A_phenotypes">phenotypes</code></td>
<td>
<p>phenotypes, a numeric array (n x 1), missing values are predicted</p>
</td></tr>
<tr><td><code id="phenoRegressor.SVR_+3A_genotypes">genotypes</code></td>
<td>
<p>SNP genotypes, one row per phenotype (n), one column per marker (m), values in 0/1/2 for
diploids or 0/1/2/...ploidy for polyploids. Can be NULL if <code>covariances</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.SVR_+3A_covariances">covariances</code></td>
<td>
<p>square matrix (n x n) of covariances. Can be NULL if <code>genotypes</code> is present.</p>
</td></tr>
<tr><td><code id="phenoRegressor.SVR_+3A_extracovariates">extraCovariates</code></td>
<td>
<p>extra covariates set, one row per phenotype (n), one column per covariate (w).
If NULL no extra covariates are considered.</p>
</td></tr>
<tr><td><code id="phenoRegressor.SVR_+3A_mode">mode</code></td>
<td>
<p>this parameter decides what will happen with the passed dataset
</p>

<ul>
<li> <p><code>mode = "tune"</code> : hyperparameters will be tuned on a grid (you may want to specify
its values using extra params) with a call to <code>e1071::tune.svm</code>. Use this option if
you have no idea about the optimal choice of hyperparameters. This mode can be very slow.
</p>
</li>
<li> <p><code>mode = "train"</code> : an SVR will be trained on the train dataset using the passed hyperparameters
(if you know them). This more invokes <code>e1071::train</code>
</p>
</li>
<li> <p><code>mode = "run"</code> : you already have a tuned and trained SVR (put it into <code>tuned.model</code>) and
want to use it. The fastest mode.
</p>
</li></ul>
</td></tr>
<tr><td><code id="phenoRegressor.SVR_+3A_tuned.model">tuned.model</code></td>
<td>
<p>a tuned and trained SVR to be used for prediction. This object is only used if
<code>mode</code> is equal to &quot;run&quot;.</p>
</td></tr>
<tr><td><code id="phenoRegressor.SVR_+3A_scale.pheno">scale.pheno</code></td>
<td>
<p>if TRUE (default) the phenotypes will be scaled and centered (before tuning or before
applying the passed tuned model).</p>
</td></tr>
<tr><td><code id="phenoRegressor.SVR_+3A_scale.geno">scale.geno</code></td>
<td>
<p>if TRUE the genotypes will be scaled and centered (before tuning or before
applying the passed tuned model. It is usually not a good idea, since it leads to
worse results. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="phenoRegressor.SVR_+3A_...">...</code></td>
<td>
<p>all extra parameters are passed to <code>e1071::svm</code> or <code>e1071::tune.svm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list with the following fields:
</p>

<ul>
<li> <p><code>predictions</code> : an array of (n) predicted phenotypes
</p>
</li>
<li> <p><code>hyperparams</code> : named vector with the following keys: gamma, cost, coef0, nu, epsilon. Some
of the values may not make sense given the selected model, and will contain
default values from e1071 library.
</p>
</li>
<li> <p><code>extradata</code>   : depending on <code>mode</code> parameter, <code>extradata</code> will contain one of the
following:
1) a SVM object returned by e1071::tune.svm, containing both
the best performing model and the description of the training process
2) a newly trained SVR model
3) the same object passed as <code>tuned.model</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="e1071.html#topic+svm">svm</a>, <a href="e1071.html#topic+tune.svm">tune.svm</a>, <a href="e1071.html#topic+best.svm">best.svm</a> from e1071 package
</p>
<p>Other phenoRegressors: 
<code><a href="#topic+phenoRegressor.BGLR">phenoRegressor.BGLR</a>()</code>,
<code><a href="#topic+phenoRegressor.RFR">phenoRegressor.RFR</a>()</code>,
<code><a href="#topic+phenoRegressor.dummy">phenoRegressor.dummy</a>()</code>,
<code><a href="#topic+phenoRegressor.rrBLUP">phenoRegressor.rrBLUP</a>()</code>,
<code><a href="#topic+phenoregressor.BGLR.multikinships">phenoregressor.BGLR.multikinships</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### WARNING ###
#The 'tuning' part of the example can take quite some time to run,
#depending on the computational power.

#using the GROAN.KI dataset, we regress on the dataset and predict the first ten phenotypes
phenos = GROAN.KI$yield
phenos[1:10] = NA

#--------- TUNE ---------
#tuning the SVR on a grid of hyperparameters
results.tune = phenoRegressor.SVR(
  phenotypes = phenos,
  genotypes = GROAN.KI$SNPs,
  covariances = NULL,
  extraCovariates = NULL,
  mode = 'tune',
  kernel = 'linear', cost = 10^(-3:+3) #SVR-specific parameters
)

#examining the predictions
plot(GROAN.KI$yield, results.tune$predictions,
     main = 'Mode = TUNING\nTrain set (black) and test set (red) regressions',
     xlab = 'Original phenotypes', ylab = 'Predicted phenotypes')
points(GROAN.KI$yield[1:10], results.tune$predictions[1:10], pch=16, col='red')

#printing correlations
test.set.correlation  = cor(GROAN.KI$yield[1:10], results.tune$predictions[1:10])
train.set.correlation = cor(GROAN.KI$yield[-(1:10)], results.tune$predictions[-(1:10)])
writeLines(paste(
  'test-set correlation :', test.set.correlation,
  '\ntrain-set correlation:', train.set.correlation
))

#--------- TRAIN ---------
#training the SVR, hyperparameters are given
results.train = phenoRegressor.SVR(
  phenotypes = phenos,
  genotypes = GROAN.KI$SNPs,
  covariances = NULL,
  extraCovariates = NULL,
  mode = 'train',
  kernel = 'linear', cost = 0.01 #SVR-specific parameters
)

#examining the predictions
plot(GROAN.KI$yield, results.train$predictions,
     main = 'Mode = TRAIN\nTrain set (black) and test set (red) regressions',
     xlab = 'Original phenotypes', ylab = 'Predicted phenotypes')
points(GROAN.KI$yield[1:10], results.train$predictions[1:10], pch=16, col='red')

#printing correlations
test.set.correlation  = cor(GROAN.KI$yield[1:10], results.train$predictions[1:10])
train.set.correlation = cor(GROAN.KI$yield[-(1:10)], results.train$predictions[-(1:10)])
writeLines(paste(
  'test-set correlation :', test.set.correlation,
  '\ntrain-set correlation:', train.set.correlation
))

#--------- RUN ---------
#we recover the trained model from previous run, predictions will be exactly the same
results.run = phenoRegressor.SVR(
  phenotypes = phenos,
  genotypes = GROAN.KI$SNPs,
  covariances = NULL,
  extraCovariates = NULL,
  mode = 'run',
  tuned.model = results.train$extradata
)

#examining the predictions
plot(GROAN.KI$yield, results.run$predictions,
     main = 'Mode = RUN\nTrain set (black) and test set (red) regressions',
     xlab = 'Original phenotypes', ylab = 'Predicted phenotypes')
points(GROAN.KI$yield[1:10], results.run$predictions[1:10], pch=16, col='red')

#printing correlations
test.set.correlation  = cor(GROAN.KI$yield[1:10], results.run$predictions[1:10])
train.set.correlation = cor(GROAN.KI$yield[-(1:10)], results.run$predictions[-(1:10)])
writeLines(paste(
  'test-set correlation :', test.set.correlation,
  '\ntrain-set correlation:', train.set.correlation
))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotResult'>Plot results of a run</h2><span id='topic+plotResult'></span>

<h3>Description</h3>

<p>This function uses ggplot2 package (which must be installed) to
graphically render the result of a run. The function receive as
input the output of GROAN.run and returns a ggplot2 object (that
can be further customized).
Currently implemented types of plot are:
</p>

<ul>
<li> <p><code>box</code> : boxplot, showing the distribution of repetitions. See <a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a>
</p>
</li>
<li> <p><code>bar</code> : barplot, showing the average over repetitions. See <a href="ggplot2.html#topic+stat_summary">stat_summary</a>
</p>
</li>
<li> <p><code>bar_conf95</code> : same as 'bar', but with 95% confidence intervals
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>plotResult(
  res,
  variable = c("pearson", "spearman", "rmse", "time_per_fold", "coeff_det", "mae"),
  x.label = c("both", "train_only", "test_only"),
  plot.type = c("box", "bar", "bar_conf95"),
  strata = c("no_strata", "avg_strata", "single")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotResult_+3A_res">res</code></td>
<td>
<p>a result data frame containing the output of GROAN.run</p>
</td></tr>
<tr><td><code id="plotResult_+3A_variable">variable</code></td>
<td>
<p>name of the variable to be used as y values</p>
</td></tr>
<tr><td><code id="plotResult_+3A_x.label">x.label</code></td>
<td>
<p>select what to put on x-axis between both train and test dataset (default), train dataset only or test dataset only</p>
</td></tr>
<tr><td><code id="plotResult_+3A_plot.type">plot.type</code></td>
<td>
<p>a string indicating the type of plot to be obtained</p>
</td></tr>
<tr><td><code id="plotResult_+3A_strata">strata</code></td>
<td>
<p>string determining behaviour toward strata. If <code>'no_strata'</code> will plot
accuracies not considering strata. If <code>'avg_strata'</code> will average single
strata accuracies. If <code>'single'</code> each strata will be represented separately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>

<hr>
<h2 id='print.GROAN.NoisyDataset'>Print a GROAN Noisy Dataset object</h2><span id='topic+print.GROAN.NoisyDataset'></span>

<h3>Description</h3>

<p>Short description for class GROAN.NoisyDataset, created with <a href="#topic+createNoisyDataset">createNoisyDataset</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GROAN.NoisyDataset'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GROAN.NoisyDataset_+3A_x">x</code></td>
<td>
<p>object of class GROAN.NoisyDataset.</p>
</td></tr>
<tr><td><code id="print.GROAN.NoisyDataset_+3A_...">...</code></td>
<td>
<p>ignored, put here to match S3 function signature</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the original <code>GROAN.NoisyDataset</code> object invisibly (via <a href="base.html#topic+invisible">invisible(x)</a>)
</p>

<hr>
<h2 id='print.GROAN.Workbench'>Print a GROAN Workbench object</h2><span id='topic+print.GROAN.Workbench'></span>

<h3>Description</h3>

<p>Short description for class GROAN.Workbench, created with <a href="#topic+createWorkbench">createWorkbench</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GROAN.Workbench'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GROAN.Workbench_+3A_x">x</code></td>
<td>
<p>object of class GROAN.Workbench.</p>
</td></tr>
<tr><td><code id="print.GROAN.Workbench_+3A_...">...</code></td>
<td>
<p>ignored, put here to match S3 function signature</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the original <code>GROAN.Workbench</code> object invisibly (via <a href="base.html#topic+invisible">invisible(x)</a>)
</p>

<hr>
<h2 id='stratified_crossvalidation_folds'>Assignments for stratified crossvalidation</h2><span id='topic+stratified_crossvalidation_folds'></span>

<h3>Description</h3>

<p>This function creates the assignments to perform a
stratified crossvalidation. It requires, for each
element of the set, a label describing the strata it
belongs to. It also requires the number of folds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratified_crossvalidation_folds(strata, folds.num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratified_crossvalidation_folds_+3A_strata">strata</code></td>
<td>
<p>an array of strata (will be treated as a factor)</p>
</td></tr>
<tr><td><code id="stratified_crossvalidation_folds_+3A_folds.num">folds.num</code></td>
<td>
<p>the number of folds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A warning is triggered if the number of folds is greater than the number of
elements of any stratum.
</p>


<h3>Value</h3>

<p>an array, same length as <code>strata</code>, of numbers in the 1:<code>folds.num</code> set
</p>

<hr>
<h2 id='summary.GROAN.NoisyDataset'>Summary for GROAN Noisy Dataset object</h2><span id='topic+summary.GROAN.NoisyDataset'></span>

<h3>Description</h3>

<p>Returns a dataframe with some description of an object created with <a href="#topic+createNoisyDataset">createNoisyDataset</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GROAN.NoisyDataset'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.GROAN.NoisyDataset_+3A_object">object</code></td>
<td>
<p>instance of class GROAN.NoisyDataset.</p>
</td></tr>
<tr><td><code id="summary.GROAN.NoisyDataset_+3A_...">...</code></td>
<td>
<p>additional arguments ignored, added for compatibility to generic <code>summary</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with GROAN.NoisyDataset stats.
</p>

<hr>
<h2 id='summary.GROAN.Result'>Summary of GROAN.Result</h2><span id='topic+summary.GROAN.Result'></span>

<h3>Description</h3>

<p>Performance metrics are averaged over repetitions, so that a data.frame is produced
with one row per dataset/regressor/extra_covariates/strata/samples/markers/folds combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GROAN.Result'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.GROAN.Result_+3A_object">object</code></td>
<td>
<p>an object returned from <a href="#topic+GROAN.run">GROAN.run</a></p>
</td></tr>
<tr><td><code id="summary.GROAN.Result_+3A_...">...</code></td>
<td>
<p>additional arguments ignored, added for compatibility to generic <code>summary</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with averaged statistics
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
