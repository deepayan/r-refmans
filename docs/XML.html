<!DOCTYPE html><html><head><title>Help for package XML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {XML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+5B.XMLNode'><p>Convenience accessors for the children of XMLNode objects.</p></a></li>
<li><a href='#+5B+26lt+3B-.XMLNode'><p>Assign sub-nodes to an XML node</p></a></li>
<li><a href='#addChildren'><p>Add child nodes to an XML node</p></a></li>
<li><a href='#addNode'><p>Add a node to a tree</p></a></li>
<li><a href='#append.xmlNode'><p>Add children to an XML node</p></a></li>
<li><a href='#asXMLNode'><p>Converts non-XML node objects to XMLTextNode objects</p></a></li>
<li><a href='#asXMLTreeNode'><p>Convert a regular XML node to one for use in a &quot;flat&quot; tree</p></a></li>
<li><a href='#catalogLoad'><p>Manipulate XML catalog contents</p></a></li>
<li><a href='#catalogResolve'><p>Look up an element via the XML catalog mechanism</p></a></li>
<li><a href='#coerceNodes'><p>Transform between XML representations</p></a></li>
<li><a href='#compareXMLDocs'><p>Indicate differences between two XML documents</p></a></li>
<li><a href='#docName'><p>Accessors for name of XML document</p></a></li>
<li><a href='#Doctype'><p>Constructor for DTD reference</p></a></li>
<li><a href='#Doctype-class'><p>Class to describe a reference to an XML DTD</p></a></li>
<li><a href='#dtdElement'><p>Gets the definition of an element or entity from a DTD.</p></a></li>
<li><a href='#dtdElementValidEntry'><p>Determines whether an XML element allows a particular type of sub-element.</p></a></li>
<li><a href='#dtdIsAttribute'><p>Query if a name is a valid attribute of a DTD element.</p></a></li>
<li><a href='#dtdValidElement'><p>Determines whether an XML tag is valid within another.</p></a></li>
<li><a href='#ensureNamespace'><p>Ensure that the node has a definition for particular XML namespaces</p></a></li>
<li><a href='#findXInclude'><p>Find the XInclude node associated with an XML node</p></a></li>
<li><a href='#free'><p>Release the specified object and clean up its memory usage</p></a></li>
<li><a href='#genericSAXHandlers'><p>SAX generic callback handler list</p></a></li>
<li><a href='#getChildrenStrings'><p>Get the individual</p></a></li>
<li><a href='#getEncoding'><p>Determines the encoding for an XML document or node</p></a></li>
<li><a href='#getHTMLLinks'><p>Get links or names of external files in HTML document</p></a></li>
<li><a href='#getLineNumber'><p>Determine the location - file &amp; line number of an (internal) XML node</p></a></li>
<li><a href='#getNodeSet'><p>Find matching nodes in an internal XML tree/DOM</p></a></li>
<li><a href='#getRelativeURL'><p>Compute name of URL relative to a base URL</p></a></li>
<li><a href='#getSibling'><p>Manipulate sibling XML nodes</p></a></li>
<li><a href='#getXIncludes'><p>Find the documents that are XInclude'd in an XML document</p></a></li>
<li><a href='#getXMLErrors'><p>Get XML/HTML document parse errors</p></a></li>
<li><a href='#isXMLString'><p>Facilities for working with XML strings</p></a></li>
<li><a href='#length.XMLNode'><p>Determine the number of children in an XMLNode object.</p></a></li>
<li><a href='#libxmlVersion'><p>Query the version and available features of the libxml library.</p></a></li>
<li><a href='#makeClassTemplate'><p>Create S4 class definition based on XML node(s)</p></a></li>
<li><a href='#names.XMLNode'><p>Get the names of an XML nodes children.</p></a></li>
<li><a href='#newXMLDoc'><p>Create internal XML node or document object</p></a></li>
<li><a href='#newXMLNamespace'><p>Add a namespace definition to an XML node</p></a></li>
<li><a href='#parseDTD'><p>Read a Document Type Definition (DTD)</p></a></li>
<li><a href='#parseURI'><p>Parse a URI string into its elements</p></a></li>
<li><a href='#parseXMLAndAdd'><p>Parse XML content and add it to a node</p></a></li>
<li><a href='#print.XMLAttributeDef'><p>Methods for displaying XML objects</p></a></li>
<li><a href='#processXInclude'><p>Perform the XInclude substitutions</p></a></li>
<li><a href='#readHTMLList'><p>Read data in an HTML list or all lists in a document</p></a></li>
<li><a href='#readHTMLTable'><p>Read data from one or more HTML tables</p></a></li>
<li><a href='#readKeyValueDB'><p>Read an XML property-list style document</p></a></li>
<li><a href='#readSolrDoc'><p>Read the data from a Solr document</p></a></li>
<li><a href='#removeXMLNamespaces'><p>Remove namespace definitions from a XML node or document</p></a></li>
<li><a href='#replaceNodeWithChildren'><p>Replace an XML node with it child nodes</p></a></li>
<li><a href='#saveXML'><p>Output internal XML Tree</p></a></li>
<li><a href='#SAXState-class'><p>A virtual base class defining methods for SAX parsing</p></a></li>
<li><a href='#schema-class'><p>Classes for working with XML Schema</p></a></li>
<li><a href='#setXMLNamespace'><p>Set the name space on a node</p></a></li>
<li><a href='#startElement.SAX'><p>Generic Methods for SAX callbacks</p></a></li>
<li><a href='#supportsExpat'><p> Determines which native XML parsers are being used.</p></a></li>
<li><a href='#toHTML'><p>Create an HTML representation of the given R object, using</p>
internal C-level nodes</a></li>
<li><a href='#toString.XMLNode'><p>Creates string representation of XML node</p></a></li>
<li><a href='#xmlApply'><p>Applies a function to each of the children of an XMLNode</p></a></li>
<li><a href='#XMLAttributes-class'><p>Class <code>"XMLAttributes"</code></p></a></li>
<li><a href='#xmlAttributeType'><p>The type of an XML attribute for element from the DTD</p></a></li>
<li><a href='#xmlAttrs'><p> Get the list of attributes of an XML node.</p></a></li>
<li><a href='#xmlChildren'><p> Gets the sub-nodes within an XMLNode object.</p></a></li>
<li><a href='#xmlCleanNamespaces'><p>Remove redundant namespaces on an XML document</p></a></li>
<li><a href='#xmlClone'><p>Create a copy of an internal XML document or node</p></a></li>
<li><a href='#XMLCodeFile-class'><p>Simple classes for identifying an XML document containing R code</p></a></li>
<li><a href='#xmlContainsEntity'><p>Checks if an entity is defined within a DTD.</p></a></li>
<li><a href='#xmlDOMApply'><p>Apply function to nodes in an XML tree/DOM.</p></a></li>
<li><a href='#xmlElementsByTagName'><p>Retrieve the children of an XML node with a specific tag name</p></a></li>
<li><a href='#xmlElementSummary'><p>Frequency table of names of elements and attributes in XML content</p></a></li>
<li><a href='#xmlEventHandler'><p>Default handlers for the SAX-style event XML parser</p></a></li>
<li><a href='#xmlEventParse'><p> XML Event/Callback element-wise Parser</p></a></li>
<li><a href='#xmlGetAttr'><p>Get the value of an attribute in an XML node</p></a></li>
<li><a href='#xmlHandler'><p> Example XML Event Parser Handler Functions</p></a></li>
<li><a href='#xmlHashTree'><p>Constructors for trees stored as flat list of nodes with</p>
information about parents and children.</a></li>
<li><a href='#XMLInternalDocument-class'><p>Class to represent reference to C-level data structure for an XML</p>
document</a></li>
<li><a href='#xmlName'><p> Extraces the tag name of an XMLNode object.</p></a></li>
<li><a href='#xmlNamespace'><p>Retrieve the namespace value of an XML node.</p></a></li>
<li><a href='#xmlNamespaceDefinitions'><p>Get definitions of any namespaces defined in this XML node</p></a></li>
<li><a href='#xmlNode'><p>Create an XML node</p></a></li>
<li><a href='#XMLNode-class'><p>Classes to describe an XML node object.</p></a></li>
<li><a href='#xmlOutputBuffer'><p>XML output streams</p></a></li>
<li><a href='#xmlParent'><p>Get parent node of XMLInternalNode or ancestor nodes</p></a></li>
<li><a href='#xmlParseDoc'><p>Parse an XML document with options controlling the parser.</p></a></li>
<li><a href='#xmlParserContextFunction'><p>Identifies function as expecting an xmlParserContext argument</p></a></li>
<li><a href='#xmlRoot'><p>Get the top-level XML node.</p></a></li>
<li><a href='#xmlSchemaValidate'><p>Validate an XML document relative to an XML schema</p></a></li>
<li><a href='#xmlSearchNs'><p>Find a namespace definition object by searching ancestor nodes</p></a></li>
<li><a href='#xmlSerializeHook'><p>Functions that help serialize and deserialize XML internal objects</p></a></li>
<li><a href='#xmlSize'><p>The number of sub-elements within an XML node.</p></a></li>
<li><a href='#xmlSource'><p>Source the R code, examples, etc. from an XML document</p></a></li>
<li><a href='#xmlStopParser'><p>Terminate an XML parser</p></a></li>
<li><a href='#xmlStructuredStop'><p>Condition/error handler functions for XML parsing</p></a></li>
<li><a href='#xmlToDataFrame'><p>Extract data from a simple XML document</p></a></li>
<li><a href='#xmlToList'><p>Convert an XML node/document to a more R-like list</p></a></li>
<li><a href='#xmlToS4'><p>General mechanism for mapping an XML node to an S4 object</p></a></li>
<li><a href='#xmlTree'><p>An internal, updatable DOM object for building XML trees</p></a></li>
<li><a href='#xmlTreeParse'><p>XML Parser</p></a></li>
<li><a href='#xmlValue'><p>Extract or set the contents of a leaf XML node</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.99-0.16.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Parsing and Generating XML Within R and S-Plus</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bitops, RCurl</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libxml2 (&gt;= 2.6.3)</td>
</tr>
<tr>
<td>Description:</td>
<td>Many approaches for both reading and
        creating XML (and HTML) documents (including DTDs), both local
        and accessible via HTTP or FTP.  Also offers access to an
        'XPath' "interpreter".</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Collate:</td>
<td>AAA.R DTD.R DTDClasses.R DTDRef.R SAXMethods.R XMLClasses.R
applyDOM.R assignChild.R catalog.R createNode.R dynSupports.R
error.R flatTree.R nodeAccessors.R parseDTD.R schema.R
summary.R tangle.R toString.R tree.R version.R xmlErrorEnums.R
xmlEventHandler.R xmlEventParse.R xmlHandler.R
xmlInternalSource.R xmlOutputDOM.R xmlNodes.R xmlOutputBuffer.R
xmlTree.R xmlTreeParse.R htmlParse.R hashTree.R zzz.R
supports.R parser.R libxmlFeatures.R xmlString.R saveXML.R
namespaces.R readHTMLTable.R reflection.R xmlToDataFrame.R
bitList.R compare.R encoding.R fixNS.R xmlRoot.R serialize.R
xmlMemoryMgmt.R keyValueDB.R solrDocs.R XMLRErrorInfo.R
xincludes.R namespaceHandlers.R tangle1.R htmlLinks.R
htmlLists.R getDependencies.R getRelativeURL.R xmlIncludes.R
simplifyPath.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-22 12:29:38 UTC; ripley</td>
</tr>
<tr>
<td>Author:</td>
<td>CRAN Team [ctb, cre] (de facto maintainer since 2013),
  Duncan Temple Lang
    <a href="https://orcid.org/0000-0003-0159-1546"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Tomas Kalibera [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>CRAN Team &lt;CRAN@r-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-22 13:30:59</td>
</tr>
</table>
<hr>
<h2 id='+5B.XMLNode'>Convenience accessors for the children of XMLNode objects.</h2><span id='topic++5B.XMLNode'></span><span id='topic++5B+5B.XMLNode'></span><span id='topic++5B+5B.XMLInternalElementNode'></span><span id='topic++5B+5B.XMLDocumentContent'></span>

<h3>Description</h3>

<p>These provide a simplified syntax for extracting the children
of an XML node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XMLNode'
x[..., all = FALSE]
## S3 method for class 'XMLNode'
x[[...]]
## S3 method for class 'XMLDocumentContent'
x[[...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.XMLNode_+3A_x">x</code></td>
<td>
<p>the XML node or the top-level document content in which the children are to be accessed.
The <code>XMLDocumentContent</code> is the container for the top-level node that also contains information
such as the URI/filename and XML version. This accessor method is merely a convenience to get 
access to children of the top-level node.</p>
</td></tr>
<tr><td><code id="+2B5B.XMLNode_+3A_...">...</code></td>
<td>
<p>the identifiers for the children to be retrieved,
given as integer indices, names, etc. in the usual format for the
generic <code>link{[}</code> and <code>link{[[}</code> operators</p>
</td></tr>
<tr><td><code id="+2B5B.XMLNode_+3A_all">all</code></td>
<td>
<p>logical value.  When ... is a character vector, a value
of <code>TRUE</code> for <code>all</code> means to retrieve all of the
nodes with those names rather than just the first one.
<code>FALSE</code> gives the usual result of subsetting a list by name
which gives just the first element.
This allows us to avoid the  idiom
<code>node[ names(node) == "bob" ]</code>
which is complicated when node is the result of an inline
computation
and instead we use
<code>node["bob", all = TRUE]</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or single element containing the
children of the XML node given by <code>obj</code>
and identified by ....
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlAttrs">xmlAttrs</a></code>
<code><a href="#topic++5B+3C-.XMLNode">[&lt;-.XMLNode</a></code>
<code><a href="#topic++5B+5B+3C-.XMLNode">[[&lt;-.XMLNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 f = system.file("exampleData", "gnumeric.xml", package = "XML")

 top = xmlRoot(xmlTreeParse(f))

  # Get the first RowInfo element.
 top[["Sheets"]][[1]][["Rows"]][["RowInfo"]]

  # Get a list containing only the first row element
 top[["Sheets"]][[1]][["Rows"]]["RowInfo"]
 top[["Sheets"]][[1]][["Rows"]][1]

  # Get all of the RowInfo elements by position
 top[["Sheets"]][[1]][["Rows"]][1:xmlSize(top[["Sheets"]][[1]][["Rows"]])]

  # But more succinctly and accurately, get all of the RowInfo elements
 top[["Sheets"]][[1]][["Rows"]]["RowInfo", all = TRUE]

</code></pre>

<hr>
<h2 id='+5B+26lt+3B-.XMLNode'>Assign sub-nodes to an XML node</h2><span id='topic++5B+3C-.XMLNode'></span><span id='topic++5B+5B+3C-.XMLNode'></span>

<h3>Description</h3>

<p>These functions allow one to assign a sub-node
to an existing XML node by name or index.
These are the assignment equivalents of the 
subsetting accessor functions.
They are typically called indirectly
via the assignment operator, such as 
<code>x[["myTag"]] &lt;- xmlNode("mySubTag")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'XMLNode'
x[i] &lt;- value
## S3 replacement method for class 'XMLNode'
x[i] &lt;-  value
## S3 replacement method for class 'XMLNode'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B26lt+2B3B-.XMLNode_+3A_x">x</code></td>
<td>
<p>the <code>XMLNode</code> object to which the sub-node is to be assigned.</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.XMLNode_+3A_i">i</code></td>
<td>
<p>the identifier for the position  in the list of children
of <code>x</code> into which the right-hand-side node(s) should be assigned.
These can be either numbers or names.</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.XMLNode_+3A_value">value</code></td>
<td>
<p>one or more <code>XMLNode</code> objects which are to be the sub-nodes
of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The XML node <code>x</code> containing the new or modified
nodes.
</p>


<h3>Author(s)</h3>

<p>Duncan Templle Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org">https://www.w3.org</a>, <a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic++5B.XMLNode">[.XMLNode</a></code>
<code><a href="#topic++5B+5B.XMLNode">[[.XMLNode</a></code>
<code><a href="#topic+append.xmlNode">append.xmlNode</a></code>
<code><a href="#topic+xmlSize">xmlSize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> top &lt;- xmlNode("top", xmlNode("next","Some text"))
 top[["second"]] &lt;- xmlCDataNode("x &lt;- 1:10")
 top[[3]] &lt;- xmlNode("tag",attrs=c(id="name"))
</code></pre>

<hr>
<h2 id='addChildren'>Add child nodes to an XML node</h2><span id='topic+addChildren'></span><span id='topic+xmlParent+3C-'></span><span id='topic+removeChildren'></span><span id='topic+removeNodes'></span><span id='topic+removeNodes.list'></span><span id='topic+removeNodes.XMLNodeSet'></span><span id='topic+removeNodes.XMLNodeList'></span><span id='topic+removeNodes.XMLInternalNode'></span><span id='topic+replaceNodes'></span><span id='topic+addAttributes'></span><span id='topic+removeAttributes'></span><span id='topic+addChildren+2CXMLInternalNode-method'></span><span id='topic+addChildren+2CXMLNode-method'></span><span id='topic+addAttributes+2CXMLInternalElementNode-method'></span><span id='topic+addAttributes+2CXMLNode-method'></span><span id='topic+removeAttributes+2CXMLInternalElementNode-method'></span><span id='topic+removeAttributes+2CXMLNode-method'></span>

<h3>Description</h3>

<p>This collection of functions
allow us to add, remove and replace children from an XML node
and also to and and remove attributes on an XML node.
These are generic functions that work on
both internal C-level <code>XMLInternalElementNode</code> objects
and regular R-level  <code>XMLNode</code> objects.
</p>
<p><code>addChildren</code> is similar to <code><a href="#topic+addNode">addNode</a></code>
and the two may be consolidated into a single generic
function and methods in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addChildren(node, ..., kids = list(...), at = NA, cdata = FALSE, append = TRUE)
removeChildren(node, ..., kids = list(...), free = FALSE)
removeNodes(node, free = rep(FALSE, length(node)))
replaceNodes(oldNode, newNode, ...)
addAttributes(node, ..., .attrs = NULL, 
               suppressNamespaceWarning = getOption("suppressXMLNamespaceWarning", FALSE),
                append = TRUE)
removeAttributes(node, ..., .attrs = NULL, .namespace = FALSE,
                  .all = (length(list(...)) + length(.attrs)) == 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addChildren_+3A_node">node</code></td>
<td>
<p>the XML node whose state is to be modified,
i.e. to which the child nodes are to be added or whose attribute list
is to be changed.</p>
</td></tr>
<tr><td><code id="addChildren_+3A_...">...</code></td>
<td>
<p>This is for use in interactive settings when specifying a collection of
values individuall. In programming contexts when one obtains the
collection as a vector or list from another call, use the
<code>kids</code> or <code>.attrs</code> parameter.
</p>
</td></tr>
<tr><td><code id="addChildren_+3A_kids">kids</code></td>
<td>
<p>when adding children to a node, this is a list of
children nodes which should be of
the same &quot;type&quot; (i.e. internal or R-level nodes)
as the <code>node</code> argument. However, they can also be
regular strings in which case they are converted to
XML text nodes.
</p>
<p>For <code>removeChildren</code>, this is again a list
which identifies the child nodes to be
removed using 
the integer identifier of the child, or
the name of the XML node (but this will only remove the first such
node and not necessarily do what you expect when there are
multiple nodes with the same name),
or the <code>XMLInternalNode</code> object itself.
</p>
</td></tr>
<tr><td><code id="addChildren_+3A_at">at</code></td>
<td>
<p>if specified, an integer identifying
the position in the original
list of children at which the new children should be added.
The children are added after that child.
This can also be a vector of indices which is as long
as the number of children being added and specifies the position
for each child being added. If the vector is shorter than the
number of children being added, it is padded with NAs
and so the corresponding children are added at the end of the
list.
</p>
<p>This parameter is only implemented for internal nodes at present.
</p>
</td></tr>
<tr><td><code id="addChildren_+3A_cdata">cdata</code></td>
<td>
<p>a logical value which controls whether children that
are specified as strings/text are enclosed within a CDATA node
when converted to actual nodes.  This value is passed on to the
relevant function that creates the text nodes, e.g. 
<code><a href="#topic+xmlTextNode">xmlTextNode</a></code> and <code><a href="#topic+newXMLTextNode">newXMLTextNode</a></code>.
</p>
</td></tr>
<tr><td><code id="addChildren_+3A_.attrs">.attrs</code></td>
<td>
<p>a character vector identifying the names of the
attributes.  These strings can have name space prefixes,
e.g. <code>r:length</code>
and the namespaces will be resolved relative to the
list supported by <code>node</code> to ensure those namespaces  are defined.
</p>
</td></tr>
<tr><td><code id="addChildren_+3A_.namespace">.namespace</code></td>
<td>
<p>This is currently ignored and may never be
supported.
The intent is to identify on which set of attributes the operation is
to perform  - the name space declarations or the regular
node attributes.
This is a logical value indicating
if  <code>TRUE</code> that  the attributes of interested are name space declarations,
i.e. of the form <code>xmlns:prefix</code> or <code>xmlns</code>.
If a value of  <code>FALSE</code> is supplied this indicates that we
are identifying regular attributes.
Note that we can still identify attributes with a name space
prefix as, e.g., <code>ns:attr</code> without this value
</p>
</td></tr>
<tr><td><code id="addChildren_+3A_free">free</code></td>
<td>
<p>a logical value indicating whether to free the C-level
memory associated with the  child      nodes that were removed.
<code>TRUE</code> means to free that memory.
This is only applicable for the internal nodes created
with <code>xmlTree</code> and <code>newXMLNode</code> and related functions.
It is necessary as automated garbage collection is tricky in this
tree-based context spanning both R and C data structures and
memory managers. 
</p>
</td></tr>
<tr><td><code id="addChildren_+3A_.all">.all</code></td>
<td>
<p>a logical value indicating whether to remove all of the
attributes within the XML node without having to specify them by
name.</p>
</td></tr>
<tr><td><code id="addChildren_+3A_oldnode">oldNode</code></td>
<td>
<p>the node which is to be replaced</p>
</td></tr>
<tr><td><code id="addChildren_+3A_newnode">newNode</code></td>
<td>
<p>the node which is to take the place of
<code>oldNode</code> in the list of children of the parent of
<code>oldNode</code></p>
</td></tr>
<tr><td><code id="addChildren_+3A_suppressnamespacewarning">suppressNamespaceWarning</code></td>
<td>
<p>a logical value or a character string. 
This is used to control the situation when an  XML node
or attribute is created with a name space prefix that currently has no
definition for that node. 
This is not necessarily an error but can lead to one.
This argument controls whether a warning is issued
or if a separate function is called.
A value of <code>FALSE</code> means not to suppress the warning and 
so it is issued. A value of <code>TRUE</code> causes the potential
problem to be ignored assuming that the namespace will be added
to this node or one of its ancestors at a later point.
And if this value is a character string, we search for a
function of that name and invoke it. 
</p>
</td></tr>
<tr><td><code id="addChildren_+3A_append">append</code></td>
<td>
<p>a logical value that indicates whether (<code>TRUE</code>) the specified
attributes or children should be added to the existing  attributes on the XML node
(if any exist), or, if <code>FALSE</code> these should replace any existing attributes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each of these functions returns the modified node.
For an internal node, this is the same R object   and
only the C-level data structures have changed.
For an R <code>XMLNode</code> object, this is is an entirely
separate object from the original node.
It must be inserted back into its parent &quot;node&quot; or context if the changes are to be
seen in that wider context. 
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libxml2 <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTree">xmlTree</a></code>
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
b = newXMLNode("bob",
              namespace = c(r = "http://www.r-project.org",
                            omg = "https://www.omegahat.net"))

cat(saveXML(b), "\n")

addAttributes(b, a = 1, b = "xyz", "r:version" = "2.4.1", "omg:len" = 3)
cat(saveXML(b), "\n")

removeAttributes(b, "a", "r:version")
cat(saveXML(b), "\n")


removeAttributes(b, .attrs = names(xmlAttrs(b)))


addChildren(b, newXMLNode("el", "Red", "Blue", "Green",
                           attrs = c(lang ="en")))

k = lapply(letters, newXMLNode)
addChildren(b, kids = k)

cat(saveXML(b), "\n")

removeChildren(b, "a", "b", "c", "z")

  # can mix numbers and names
removeChildren(b, 2, "e")  # d and e

cat(saveXML(b), "\n")


i = xmlChildren(b)[[5]]
xmlName(i)

 # have the identifiers
removeChildren(b, kids = c("m", "n", "q"))



x &lt;- xmlNode("a", 
               xmlNode("b", "1"),
               xmlNode("c", "1"),
	       "some basic text")

v = removeChildren(x, "b")

  # remove c and b
v = removeChildren(x, "c", "b")

  # remove the text and "c" leaving just b
v = removeChildren(x, 3, "c")

## Not run: 
    # this won't work as the 10 gets coerced to a 
    # character vector element to be combined with 'w'
    # and there is no node name 10.
 removeChildren(b, kids = c(10, "w"))

## End(Not run)


 # for R-level nodes (not internal)

z = xmlNode("arg", attrs = c(default="TRUE"),
              xmlNode("name", "foo"), xmlNode("defaultValue","1:10"))

o = addChildren(z,
                "some text",
                xmlNode("a", "a link",
                         attrs = c(href = "https://www.omegahat.net/RSXML")))
o


  # removing nodes

 doc = xmlParse("&lt;top&gt;&lt;a/&gt;&lt;b/&gt;&lt;c&gt;&lt;d/&gt;&lt;e&gt;bob&lt;/e&gt;&lt;/c&gt;&lt;/top&gt;")
 top = xmlRoot(doc)
 top
 
 removeNodes(list(top[[1]], top[[3]]))

    # a and c have disappeared.
 top

</code></pre>

<hr>
<h2 id='addNode'>Add a node to a tree</h2><span id='topic+addNode'></span><span id='topic+addNode.XMLHashTree'></span>

<h3>Description</h3>

<p>This generic function allows us to add a node to a tree
for different types of trees.
Currently it just works for XMLHashTree, but it could
be readily extended to the more general XMLFlatTree class.
However, the concept in this function is to change the tree
and return the node. This does not work unless the tree
is directly mutable without requiring reassignment,
i.e. the changes do not induce a new copy of the original tree object.
DOM trees which are lists of lists of lists do not fall into this category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNode(node, parent, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNode_+3A_node">node</code></td>
<td>
<p>the node to be added as a child of the parent.</p>
</td></tr>
<tr><td><code id="addNode_+3A_parent">parent</code></td>
<td>
<p>the parent node or identifier</p>
</td></tr>
<tr><td><code id="addNode_+3A_to">to</code></td>
<td>
<p>the tree object</p>
</td></tr>
<tr><td><code id="addNode_+3A_...">...</code></td>
<td>
<p>additional arguments that are understood by the different methods for the different types of 
trees/nodes. These can include <code>attrs</code>, <code>namespace</code>, <code>namespaceDefinitions</code>,
<code>.children</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new node object.
For flat trees, this will be the <code>node</code> after it has been
coerced to be compatible with a flat tree, i.e. has an id and the
host tree added to it.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org">https://www.w3.org</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlHashTree">xmlHashTree</a></code>
<code><a href="#topic+asXMLTreeNode">asXMLTreeNode</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  tt = xmlHashTree()

  top = addNode(xmlNode("top"), character(), tt)
  addNode(xmlNode("a"), top, tt)
  b = addNode(xmlNode("b"), top, tt)
  c = addNode(xmlNode("c"), b, tt)
  addNode(xmlNode("c"), top, tt)
  addNode(xmlNode("c"), b, tt)    
  addNode(xmlTextNode("Some text"), c, tt)

  xmlElementsByTagName(tt$top, "c")

  tt
</code></pre>

<hr>
<h2 id='append.xmlNode'>Add children to an XML node</h2><span id='topic+append.xmlNode'></span><span id='topic+append.XMLNode'></span>

<h3>Description</h3>

<p>This appends one or more XML nodes as children of an existing node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append.XMLNode(to, ...)
append.xmlNode(to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append.xmlNode_+3A_to">to</code></td>
<td>
<p>the XML node to which the sub-nodes are to be added.</p>
</td></tr>
<tr><td><code id="append.xmlNode_+3A_...">...</code></td>
<td>
<p>the sub-nodes which are to be added to the <code>to</code> node.
If this is a <code>list</code> of <code>XMLNode</code> objects (e.g. create by a call to 
<code><a href="base.html#topic+lapply">lapply</a></code>), then that list is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>append.xmlNode</code> is a generic function with method <code>append.XMLNode</code>
for class <code>"XMLNode"</code> and default method <code>base::append</code>.
</p>
<p>This seems historical and users may as well use <code>append.XMLNode</code>
directly.
</p>


<h3>Value</h3>

<p>The original <code>to</code> node containing its new children nodes.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic++5B+3C-.XMLNode">[&lt;-.XMLNode</a></code>
<code><a href="#topic++5B+5B+3C-.XMLNode">[[&lt;-.XMLNode</a></code>
<code><a href="#topic++5B.XMLNode">[.XMLNode</a></code>
<code><a href="#topic++5B+5B.XMLNode">[[.XMLNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Create a very simple representation of a simple dataset.
  # This is just an example. The result is
   # &lt;data numVars="2" numRecords="3"&gt;
   # &lt;varNames&gt;
   #  &lt;string&gt;
   #   A
   #  &lt;/string&gt;
   #  &lt;string&gt;
   #   B
   #  &lt;/string&gt;
   # &lt;/varNames&gt;
   # &lt;record&gt;
   #  1.2 3.5
   # &lt;/record&gt;
   # &lt;record&gt;
   #  20.2 13.9
   # &lt;/record&gt;
   # &lt;record&gt;
   #  10.1 5.67
   # &lt;/record&gt;
   # &lt;/data&gt;


 n = xmlNode("data", attrs = c("numVars" = 2, numRecords = 3))
 n = append.xmlNode(n, xmlNode("varNames", xmlNode("string", "A"), xmlNode("string", "B")))
 n = append.xmlNode(n, xmlNode("record", "1.2 3.5"))
 n = append.xmlNode(n, xmlNode("record", "20.2 13.9"))
 n = append.xmlNode(n, xmlNode("record", "10.1 5.67"))

 print(n)


## Not run: 
   tmp &lt;-  lapply(references, function(i) {
                                  if(!inherits(i, "XMLNode"))
                                    i &lt;- xmlNode("reference", i)
                                  i
                              })

   r &lt;- xmlNode("references")
   r[["references"]] &lt;- append.xmlNode(r[["references"]], tmp)

## End(Not run)
</code></pre>

<hr>
<h2 id='asXMLNode'>Converts non-XML node objects to XMLTextNode objects</h2><span id='topic+asXMLNode'></span><span id='topic+coerce+2CXMLInternalNode+2CXMLNode-method'></span>

<h3>Description</h3>

<p>This function is used to convert S objects that
are not already <code>XMLNode</code> objects
into objects of that class. Specifically,
it treats  the object as a string and creates
an <code>XMLTextNode</code> object.
</p>
<p>Also, there is a method for converting an XMLInternalNode
- the C-level libxml representation of a node - to 
an explicit R-only object which contains the R values
of the data in the internal node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asXMLNode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asXMLNode_+3A_x">x</code></td>
<td>
<p>the object to be converted to an <code>XMLNode</code> object.
This is typically alread an object that inherits from <code>XMLNode</code>
or a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class XMLNode.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+xmlNode">xmlNode</a></code>
<code><a href="#topic+xmlTextNode">xmlTextNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # creates an XMLTextNode.
 asXMLNode("a text node")

   # unaltered.
 asXMLNode(xmlNode("p"))
</code></pre>

<hr>
<h2 id='asXMLTreeNode'>Convert a regular XML node to one for use in a &quot;flat&quot; tree</h2><span id='topic+asXMLTreeNode'></span>

<h3>Description</h3>

<p>This coerces a regular R-based XML node (i.e. not an internal C-level
node) to a form that can be inserted into a flat tree, i.e.
one that stores the nodes in a non-hierarchical manner.
It is thus used in conjunction with
<code><a href="#topic+xmlHashTree">xmlHashTree</a></code>
It adds <code>id</code> and <code>env</code> fields to the
node and specializes the class by prefixing <code>className</code>
to the class attribute.
</p>
<p>This is not used very much anymore as we use the internal nodes for
most purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asXMLTreeNode(node, env, id = get(".nodeIdGenerator", env)(xmlName(node)),
              className = "XMLTreeNode")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asXMLTreeNode_+3A_node">node</code></td>
<td>
<p>the original XML node</p>
</td></tr>
<tr><td><code id="asXMLTreeNode_+3A_env">env</code></td>
<td>
<p>the <code>XMLFlatTree</code> object into which this node will be inserted.</p>
</td></tr>
<tr><td><code id="asXMLTreeNode_+3A_id">id</code></td>
<td>
<p>the identifier for the node in the flat tree. If this is not
specified, we consult the tree itself and its built-in identifier
generator.  By default, the name of the node is used as its
identifier unless there is another node with that name.
</p>
</td></tr>
<tr><td><code id="asXMLTreeNode_+3A_classname">className</code></td>
<td>
<p>a vector of class names to be prefixed to the
existing class vector of the node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>className</code>, i.e. by default
<code>"XMLTreeNode"</code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlHashTree">xmlHashTree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  txt = '&lt;foo a="123" b="an attribute"&gt;&lt;bar&gt;some text&lt;/bar&gt;other text&lt;/foo&gt;'
  doc = xmlTreeParse(txt)

  class(xmlRoot(doc))

  as(xmlRoot(doc), "XMLInternalNode")
</code></pre>

<hr>
<h2 id='catalogLoad'>Manipulate XML catalog contents</h2><span id='topic+catalogLoad'></span><span id='topic+catalogClearTable'></span><span id='topic+catalogAdd'></span><span id='topic+catalogDump'></span>

<h3>Description</h3>

<p>These functions allow the R user to programmatically control the 
XML catalog table used in the XML parsing tools in the
C-level libxml2 library and hence in R packages that use these, e.g.
the XML and Sxslt packages.
Catalogs are consulted whenever an external document needs to be loaded.
XML catalogs allow one to influence how such a document is loaded
by mapping document identifiers to 
alternative locations, for example to refer to locally 
available versions.
They support mapping URI prefixes to local file directories/files,
resolving both SYSTEM and PUBLIC identifiers used in DOCTYPE declarations at the 
top of an XML/HTML document, and delegating resolution to other catalog files.
Catalogs are written using an XML format.
</p>
<p>Catalogs allow resources used in XInclude nodes and XSL templates
to refer to generic network URLs and have these be mapped to local files
and so avoid potentially slow network retrieval. 
Catalog files are written in XML 
We might have a catalog file that contains the XML
In the XDynDocs package, we  refer to OmegahatXSL files and 
DocBook XSL files have a catalog file of the form 
</p>
<p>The functions provided here allow the R programmer to 
empty the current contents of the global catalog table and so 
start from scratch (
<code>catalogClearTable</code>
), 
load the contents of a catalog file into the global catalog table (
<code>catalogLoad</code>
),
and to add individual entries programmatically without the need for a catalog table.
</p>
<p>In addition to controlling the catalogs via these functions, we can 
use <code><a href="#topic+catalogResolve">catalogResolve</a></code> to use the catalog
to resolve the name of a resource and map it to a local resource.
</p>
<p><code>catalogDump</code> allows us to retrieve an XML document representing the current
contents of the in-memory catalog .
</p>
<p>More information can be found at
<a href="http://xmlsoft.org/catalog.html">http://xmlsoft.org/catalog.html</a>
and <a href="http://www.sagehill.net/docbookxsl/Catalogs.html">http://www.sagehill.net/docbookxsl/Catalogs.html</a>
among many resources and the specification for the catalog format at
<a href="https://www.oasis-open.org/committees/entity/spec-2001-08-06.html">https://www.oasis-open.org/committees/entity/spec-2001-08-06.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catalogLoad(fileNames)
catalogClearTable()
catalogAdd(orig, replace, type = "rewriteURI")
catalogDump(fileName = tempfile(), asText = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catalogLoad_+3A_orig">orig</code></td>
<td>
<p>a character vector of identifiers, e.g. URIs, that are to be mapped to a different 
name via the catalog.
This can be a named character vector where the names are the original URIs and the values are the 
corresponding rewritten values.
</p>
</td></tr>
<tr><td><code id="catalogLoad_+3A_replace">replace</code></td>
<td>
<p>a character vector of the rewritten or resolved values for the
identifiers given in orig. Often this omitted and the 
original-rewrite pairs are given as a named vector via orig.
</p>
</td></tr>
<tr><td><code id="catalogLoad_+3A_type">type</code></td>
<td>
<p>a character vector with the same length as
orig (or recycled to have the same length) which specifies
the type of the resources in the elements of orig.
Valid values are rewriteURI, rewriteSystem, system, public.
</p>
</td></tr>
<tr><td><code id="catalogLoad_+3A_filenames">fileNames</code></td>
<td>
<p>a character vector giving the names of the 
catalog files to load.</p>
</td></tr>
<tr><td><code id="catalogLoad_+3A_filename">fileName</code></td>
<td>
<p>the name of the file in which to place the contents of the current catalog</p>
</td></tr>
<tr><td><code id="catalogLoad_+3A_astext">asText</code></td>
<td>
<p>a logical value which indicates whether to write the catalog
as a character string if <code>filename</code> is not specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions are used for their side effects on the global
catalog table maintained in C by libxml2. Their return values are
logical values/vectors indicating whether the particular operation
were successful or not.
</p>


<h3>References</h3>

<p>This provides an R-like interface to a small subset of the catalog API
made available in libxml2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+catalogResolve">catalogResolve</a></code>
</p>
<p>XInclude, XSL and import/include directives.
</p>
<p>In addition to these functions, there is an un-exported, undocumented
function named <code>catalogDump</code> that can be used to 
get the contents of the (first) catalog table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Add a rewrite rule
# 
# 	
catalogAdd(c("https://www.omegahat.net/XML" = system.file("XML", package
= "XML")))
catalogAdd("https://www.omegahat.net/XML", system.file("XML", package =
"XML"))
catalogAdd("http://www.r-project.org/doc/",
           paste(R.home(), "doc", "", sep = .Platform$file.sep))
	
#
#          This shows how we can load a catalog and then resolve a
#          systemidentifier that it maps.
# 	
catalogLoad(system.file("exampleData", "catalog.xml", package = "XML"))
catalogResolve("docbook4.4.dtd", "system")
catalogResolve("-//OASIS//DTD DocBook XML V4.4//EN", "public")
</code></pre>

<hr>
<h2 id='catalogResolve'>Look up an element via the XML catalog mechanism</h2><span id='topic+catalogResolve'></span>

<h3>Description</h3>

<p>XML parsers use a catalog to map generic system and public addresses
to actual local files or potentially different remote files.
We can use a catalog to map a reference such as
<code>https://www.omegahat.net/XSL/</code> to a particular
directory on our local machine and then not have to
modify any of the documents if we move the local files to another
directory, e.g. install a new version in an alternate directory.
</p>
<p>This function provides a mechanism to query the catalog to
resolve a URI, PUBLIC or SYSTEM identifier.
</p>
<p>This is now vectorized, so accepts a character vector of
URIs and recycles <code>type</code> to have the same length.
</p>
<p>If an entry is not resolved via the catalog system,
a <code>NA</code> is returned for that element.
To leave the value unaltered in this case, use <code>asIs = TRUE</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catalogResolve(id, type = "uri", asIs = FALSE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catalogResolve_+3A_id">id</code></td>
<td>
<p>the name of the (generic) element to be resolved</p>
</td></tr>
<tr><td><code id="catalogResolve_+3A_type">type</code></td>
<td>
<p>a string, specifying whether the lookup is for a uri,
system or public element</p>
</td></tr>
<tr><td><code id="catalogResolve_+3A_asis">asIs</code></td>
<td>
<p>a logical. If <code>TRUE</code> any element of <code>id</code> which
is not resolved by the catalog system will be left as given in the
call. If <code>FALSE</code>, such unresolved elements are identified
by <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="catalogResolve_+3A_debug">debug</code></td>
<td>
<p>logical value indicating whether to turn on debugging
output written to the console (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector. If the element was resolved,
the single element is the resolved value.
Otherwise, the character vector will contain no elements.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a>
<a href="http://www.sagehill.net/docbookxsl/Catalogs.html">http://www.sagehill.net/docbookxsl/Catalogs.html</a> provides a short, succinct tutorial on catalogs. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(!exists("Sys.setenv")) Sys.setenv = Sys.putenv

Sys.setenv("XML_CATALOG_FILES" = system.file("exampleData", "catalog.xml", package = "XML"))



catalogResolve("-//OASIS//DTD DocBook XML V4.4//EN", "public")

catalogResolve("https://www.omegahat.net/XSL/foo.xsl")

catalogResolve("https://www.omegahat.net/XSL/article.xsl", "uri")
catalogResolve("https://www.omegahat.net/XSL/math.xsl", "uri")


  # This one does not resolve anything, returning an empty value.
catalogResolve("http://www.oasis-open.org/docbook/xml/4.1.2/foo.xsl", "uri")


   # Vectorized and returns NA for the first and /tmp/html.xsl
   # for the second.

 catalogAdd("http://made.up.domain", "/tmp")
 catalogResolve(c("ddas", "http://made.up.domain/html.xsl"), asIs = TRUE)
</code></pre>

<hr>
<h2 id='coerceNodes'>Transform between XML representations</h2><span id='topic+coerce+2CXMLHashTreeNode+2CXMLHashTree-method'></span><span id='topic+coerce+2CXMLInternalDocument+2CXMLHashTree-method'></span><span id='topic+coerce+2CXMLInternalNode+2CXMLHashTree-method'></span><span id='topic+coerce+2CXMLNode+2CXMLInternalNode-method'></span><span id='topic+coerce+2CXMLAbstractDocument+2CXMLAbstractNode-method'></span>

<h3>Description</h3>

<p>This collection of coercion methods (i.e. <code>as(obj, "type")</code>)
allows users of the <code>XML</code> package to switch between different
representations of XML nodes and to map from an XML document to
the root node and from a node to the document. 
This helps to manage the nodes 
</p>


<h3>Value</h3>

<p>An object of the target type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+xmlParse">xmlParse</a></code>
</p>

<hr>
<h2 id='compareXMLDocs'>Indicate differences between two XML documents</h2><span id='topic+compareXMLDocs'></span>

<h3>Description</h3>

<p>This function is an attempt to provide some assistance
in determining if two XML documents are the same and if
not, how they differ.  Rather than comparing
the tree structure, this function compares
the frequency distributions of the names of the
node. It omits position, attributes, simple content
from the comparison. Those are left to the functions
that have more contextual information to compare two documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareXMLDocs(a, b, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareXMLDocs_+3A_a">a</code>, <code id="compareXMLDocs_+3A_b">b</code></td>
<td>
<p>two parsed XML documents that must be internal documents, i.e. created with
<code><a href="#topic+xmlParse">xmlParse</a></code> or created with <code><a href="#topic+newXMLNode">newXMLNode</a></code>.</p>
</td></tr>
<tr><td><code id="compareXMLDocs_+3A_...">...</code></td>
<td>
<p>additional parameters that are passed on to the <code>summary</code> method for an internal document.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>inA</code></td>
<td>
<p>the names and counts of the XML elements that only appear in the first document</p>
</td></tr>
<tr><td><code>inB</code></td>
<td>
<p>the names and counts of the XML elements that only appear in the second document</p>
</td></tr>
<tr><td><code>countDiffs</code></td>
<td>
<p>a vector giving the difference in number of nodes with a particular name.</p>
</td></tr>
</table>
<p>These give a description of what is missing from one document relative to the other.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getNodeSet">getNodeSet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tt = 
 '&lt;x&gt;
     &lt;a&gt;text&lt;/a&gt;
     &lt;b foo="1"/&gt;
     &lt;c bar="me"&gt;
        &lt;d&gt;a phrase&lt;/d&gt;
     &lt;/c&gt;
  &lt;/x&gt;'

  a = xmlParse(tt, asText = TRUE)
  b = xmlParse(tt, asText = TRUE)
  d = getNodeSet(b, "//d")[[1]]
  xmlName(d) = "bob"
  addSibling(xmlParent(d), newXMLNode("c"))
  
  compareXMLDocs(a, b)
</code></pre>

<hr>
<h2 id='docName'>Accessors for name of XML document</h2><span id='topic+docName'></span><span id='topic+docName+2CXMLDocument-method'></span><span id='topic+docName+2CXMLDocumentContent-method'></span><span id='topic+docName+2CXMLHashTree-method'></span><span id='topic+docName+2CXMLInternalDocument-method'></span><span id='topic+docName+2CXMLInternalNode-method'></span><span id='topic+docName+2CXMLHashTreeNode-method'></span><span id='topic+docName+2CNULL-method'></span><span id='topic+docName+2CXMLNode-method'></span><span id='topic+docName+3C-'></span><span id='topic+docName+3C-+2CXMLInternalDocument-method'></span><span id='topic+docName+3C-+2CXMLHashTree-method'></span>

<h3>Description</h3>

<p>These functions and methods allow us to query and set the 
&ldquo;name&rdquo; of an XML document. This is intended to be
its URL or file name or a description of its origin if
raw XML content provided as a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docName(doc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docName_+3A_doc">doc</code></td>
<td>
<p>the XML document object, of class
<code>XMLInternalDocument</code> or <code>XMLDocument</code>.
</p>
</td></tr>
<tr><td><code id="docName_+3A_...">...</code></td>
<td>
<p>additional methods for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string giving the name.
If the document was created from text, this is <code>NA</code>
(of class character).
</p>
<p>The assignment function returns the updated object,
but the R assignment operation will return the value
on the right of the assignment!
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+xmlInternalTreeParse">xmlInternalTreeParse</a></code>
<code><a href="#topic+newXMLDoc">newXMLDoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f = system.file("exampleData", "catalog.xml",  package = "XML")
  doc = xmlInternalTreeParse(f)
  docName(doc)

  doc = xmlInternalTreeParse("&lt;a&gt;&lt;b/&gt;&lt;/a&gt;", asText = TRUE)
      # an NA
  docName(doc)
  docName(doc) = "Simple XML example"
  docName(doc)
</code></pre>

<hr>
<h2 id='Doctype'>Constructor for DTD reference</h2><span id='topic+Doctype'></span><span id='topic+coerce+2CDoctype+2Ccharacter-method'></span>

<h3>Description</h3>

<p>This is a constructor for the <code>Doctype</code> class
that can be provided at the top of an XML document
to provide information about the class of document,
i.e. its DTD or schema.
Also, there is a method for converting such a <code>Doctype</code>
object to a character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Doctype(system = character(), public = character(), name = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Doctype_+3A_system">system</code></td>
<td>
<p>the system URI that locates the DTD. </p>
</td></tr>
<tr><td><code id="Doctype_+3A_public">public</code></td>
<td>
<p>the identifier for locating the DTD in a catalog, for
example. This should be a character vector of length 2, giving
the public identifier and a URI.  If just the public identifier
is given and a string is given for <code>system</code> argument,
the <code>system</code> value is used as the second element of
<code>public</code>.
The public identifer should be of the form
<code>+//creator//name//language</code>
where the first element is either + or -, and
the language is described by a code in the ISO 639 document.
</p>
</td></tr>
<tr><td><code id="Doctype_+3A_name">name</code></td>
<td>
<p>the name of the root element in the document.
This should be the first parameter, but is left this way
for backward compatability.  And </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>Doctype</code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>
XML Elements of Style, Simon St. Laurent.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveXML">saveXML</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  d = Doctype(name = "section",
              public = c("-//OASIS//DTD DocBook XML V4.2//EN",
                         "http://oasis-open.org/docbook/xml/4.2/docbookx.dtd"))
  as(d, "character")

   # this call switches the system to the URI associated with the PUBLIC element.
  d = Doctype(name = "section",
              public = c("-//OASIS//DTD DocBook XML V4.2//EN"),
              system = "http://oasis-open.org/docbook/xml/4.2/docbookx.dtd")
</code></pre>

<hr>
<h2 id='Doctype-class'>Class to describe a reference to an XML DTD</h2><span id='topic+Doctype-class'></span>

<h3>Description</h3>

<p>This class is intended to identify a DTD by SYSTEM file and/or PUBLIC 
catalog identifier.  This is used in the DOCTYPE element of an XML document.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to the constructor function <code><a href="#topic+Doctype">Doctype</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code>. This is the name of the 
top-level element in the XML document.</p>
</dd>
<dt><code>system</code>:</dt><dd><p>Object of class <code>"character"</code>. This is the name of the file on the
system where the DTD document can be found. Can this be a URI?</p>
</dd>
<dt><code>public</code>:</dt><dd><p>Object of class <code>"character"</code>. This gives the PUBLIC 
identifier for the DTD that can be searched for in a catalog, for example to map the
DTD reference to a local system element.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>There is a constructor function
and also methods for <code><a href="methods.html#topic+coerce">coerce</a></code> to convert an object
of this class to a character.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Doctype">Doctype</a></code>
<code><a href="#topic+saveXML">saveXML</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d = Doctype(name = "section",
             public = c("-//OASIS//DTD DocBook XML V4.2//EN",
                       "http://oasis-open.org/docbook/xml/4.2/docbookx.dtd"))  
</code></pre>

<hr>
<h2 id='dtdElement'>Gets the definition of an element or entity from a DTD.</h2><span id='topic+dtdElement'></span><span id='topic+dtdEntity'></span>

<h3>Description</h3>

<p>A DTD in R consists of both element and entity definitions.
These two functions provide simple access to 
individual elements of these two lists, using the name
of the element or entity.
The DTD is provided to determine where to look for the
entry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtdElement(name,dtd)
dtdEntity(name,dtd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtdElement_+3A_name">name</code></td>
<td>
<p>The name of the element being retrieved/acessed.</p>
</td></tr>
<tr><td><code id="dtdElement_+3A_dtd">dtd</code></td>
<td>
<p>The DTD from which the element is to be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An element within a DTD  contains
both the list of sub-elements it can contain and a list of attributes
that can be used within this tag type.  
<code>dtdElement</code> retrieves the
element by name from the specified DTD definition.
Entities within a DTD are like macros or text substitutes used
within a DTD and/or XML documents that use it.
Each consists of a name/label and a definition, the text
that is substituted when the entity is referenced.
<code>dtdEntity</code> retrieves the entity definition
from the DTD.
\
One can read a DTD
directly (using <code><a href="#topic+parseDTD">parseDTD</a></code>) or implicitly when reading a
document (using <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>) 
The names of all available elements can be obtained from the expression
<code>names(dtd$elements)</code>.
This function is simply a convenience for
indexing this <code>elements</code> list.
</p>


<h3>Value</h3>

<p>An object of class <code>XMLElementDef</code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

 
<p><code><a href="#topic+parseDTD">parseDTD</a></code>,
<code><a href="#topic+dtdValidElement">dtdValidElement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dtdFile &lt;- system.file("exampleData","foo.dtd", package="XML")
 foo.dtd &lt;- parseDTD(dtdFile)
 
   # Get the definition of the `entry1' element
 tmp &lt;- dtdElement("variable", foo.dtd)
 xmlAttrs(tmp)

 tmp &lt;- dtdElement("entry1", foo.dtd)

  # Get the definition of the `img' entity
 dtdEntity("img", foo.dtd)
</code></pre>

<hr>
<h2 id='dtdElementValidEntry'>Determines whether an XML element allows a particular type of sub-element.</h2><span id='topic+dtdElementValidEntry.character'></span><span id='topic+dtdElementValidEntry.XMLElementContent'></span><span id='topic+dtdElementValidEntry.XMLElementDef'></span><span id='topic+dtdElementValidEntry.XMLOrContent'></span><span id='topic+dtdElementValidEntry.XMLSequenceContent'></span><span id='topic+dtdElementValidEntry'></span>

<h3>Description</h3>

<p>This tests whether <code>name</code> is a legitimate tag to use as a
direct sub-element of the <code>element</code> tag according to the
definition of the <code>element</code> element in the specified DTD.  This
is a generic function that dispatches on the element type, so that
different version take effect for <code>XMLSequenceContent</code>,
<code>XMLOrContent</code>, <code>XMLElementContent</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtdElementValidEntry(element, name, pos=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtdElementValidEntry_+3A_element">element</code></td>
<td>
<p>The <code>XMLElementDef</code> defining the tag
in which we are asking whether the sub-element can be used. </p>
</td></tr>
<tr><td><code id="dtdElementValidEntry_+3A_name">name</code></td>
<td>
<p>The name of the sub-element about which we are 
querying the list of sub-tags within <code>element</code>.
</p>
</td></tr>
<tr><td><code id="dtdElementValidEntry_+3A_pos">pos</code></td>
<td>
<p>An optional argument which, if supplied,
queries whether the <code>name</code> sub-element is valid
as the <code>pos</code>-th child of <code>element</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is not intended to be called directly, but
indirectly by the 
<code><a href="#topic+dtdValidElement">dtdValidElement</a></code> function.
</p>


<h3>Value</h3>

<p>Logical value indicating whether the sub-element
can appear in an <code>element</code> tag or not.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+parseDTD">parseDTD</a></code>,
<code><a href="#topic+dtdValidElement">dtdValidElement</a></code>,
<code><a href="#topic+dtdElement">dtdElement</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dtdFile &lt;- system.file("exampleData", "foo.dtd",package="XML")
 dtd &lt;- parseDTD(dtdFile) 
 
  dtdElementValidEntry(dtdElement("variables",dtd), "variable")
</code></pre>

<hr>
<h2 id='dtdIsAttribute'>Query if a name is a valid attribute of a DTD element.</h2><span id='topic+dtdIsAttribute'></span>

<h3>Description</h3>

<p>Examines the definition of the DTD element definition identified
by <code>element</code> to see if it supports an attribute named
<code>name</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtdIsAttribute(name, element, dtd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtdIsAttribute_+3A_name">name</code></td>
<td>
<p>The name of the attribute being queried</p>
</td></tr>
<tr><td><code id="dtdIsAttribute_+3A_element">element</code></td>
<td>
<p>The name of the element whose definition is to be used
to obtain the list of valid attributes.</p>
</td></tr>
<tr><td><code id="dtdIsAttribute_+3A_dtd">dtd</code></td>
<td>
<p>The DTD containing the definition of the elements,
specifically <code>element</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating if the
list of attributes suppported by the 
specified element has an entry named
<code>name</code>.
This does indicate what type of value
that attribute has, whether it is required, implied,
fixed, etc.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+parseDTD">parseDTD</a></code>,
<code><a href="#topic+dtdElement">dtdElement</a></code>,
<code><a href="#topic+xmlAttrs">xmlAttrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dtdFile &lt;- system.file("exampleData", "foo.dtd", package="XML")
 foo.dtd &lt;- parseDTD(dtdFile)

    # true
  dtdIsAttribute("numRecords", "dataset", foo.dtd)

    # false
  dtdIsAttribute("date", "dataset", foo.dtd)
</code></pre>

<hr>
<h2 id='dtdValidElement'>Determines whether an XML tag is valid within another.</h2><span id='topic+dtdValidElement'></span>

<h3>Description</h3>

<p>This tests whether <code>name</code> is a legitimate tag 
to use as a direct sub-element of the <code>within</code> tag
according to the definition of the <code>within</code>
element in the specified DTD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtdValidElement(name, within, dtd, pos=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtdValidElement_+3A_name">name</code></td>
<td>
<p>The name of the tag which is to be inserted inside the
<code>within</code> tag.</p>
</td></tr>
<tr><td><code id="dtdValidElement_+3A_within">within</code></td>
<td>
<p>The name of the parent tag the definition of which we are checking
to determine if it contains <code>name</code>.</p>
</td></tr>
<tr><td><code id="dtdValidElement_+3A_dtd">dtd</code></td>
<td>
<p>The DTD in which the elements <code>name</code> and <code>within</code> are defined. </p>
</td></tr>
<tr><td><code id="dtdValidElement_+3A_pos">pos</code></td>
<td>
<p> An optional position at which we might add the
<code>name</code> element inside <code>within</code>. If this is specified, we have a stricter
test that accounds for sequences in which elements must appear in order.
These are comma-separated entries in the element definition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This applies to direct sub-elements
or children of the <code>within</code> tag and not tags nested 
within children of that tag, i.e. descendants.
</p>


<h3>Value</h3>

<p>Returns a logical value.
TRUE indicates that a <code>name</code> element
can be used inside a <code>within</code> element.
FALSE indicates that it cannot.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+parseDTD">parseDTD</a></code>,
<code><a href="#topic+dtdElement">dtdElement</a></code>,
<code><a href="#topic+dtdElementValidEntry">dtdElementValidEntry</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dtdFile &lt;- system.file("exampleData", "foo.dtd", package="XML")
 foo.dtd &lt;- parseDTD(dtdFile)

  # The following are true.
 dtdValidElement("variable","variables", dtd = foo.dtd)
 dtdValidElement("record","dataset", dtd = foo.dtd)

  # This is false.
 dtdValidElement("variable","dataset", dtd = foo.dtd)
</code></pre>

<hr>
<h2 id='ensureNamespace'>Ensure that the node has a definition for particular XML namespaces</h2><span id='topic+ensureNamespace'></span>

<h3>Description</h3>

<p>This function is a helper function for use in creating XML content.
We often want to create a node that will be part of a larger XML tree
and use a particular namespace for that node name. Rather than
defining the namespace in each  new node, we want to ensure that
it is define on an ancestor node.  This function aids in that task.
We call the function with  the ancestor node or top-level document
and have it check whether the namespace is already defined or have
it add it to the node and return.
</p>
<p>This is intended for use with <code>XMLInternalNode</code> objects
which are direclty mutable (rather than changing a copy of the node
and having to insert that back into the larger tree.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensureNamespace(doc, what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensureNamespace_+3A_doc">doc</code></td>
<td>
<p>an <code>XMLInternalDocument</code> or <code>XMLInternalNode</code> on
which the namespace is to be defined.  If this is a documentm, we use
the root node.</p>
</td></tr>
<tr><td><code id="ensureNamespace_+3A_what">what</code></td>
<td>
<p>a named character vector giving the URIs for the namespace
definitions and the names giving the desired prefixes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is used for the potential side effects of modifying the
XML node to add (some of) the namespaces as needed.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>XML namespaces</p>


<h3>See Also</h3>

<p><code><a href="#topic+newXMLNamespace">newXMLNamespace</a></code>
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  doc = newXMLDoc()
  top = newXMLNode("article", doc = doc)
  ensureNamespace(top, c(r = "http://www.r-project.org"))
  b = newXMLNode("r:code", parent = top)
  print(doc)
</code></pre>

<hr>
<h2 id='findXInclude'>Find the XInclude node associated with an XML node</h2><span id='topic+findXInclude'></span>

<h3>Description</h3>

<p>This function is used to traverse the ancestors of an 
internal XML node to find the associated XInclude 
node that identifies it as being an XInclude'd node.
Each top-level node that results from an include href=... in the libxml2 parser
is sandwiched between nodes of class
XMLXIncludeStartNode and XMLXIncludeStartNode.
These are the sibling nodes.
</p>
<p>Another approach to finding the origin of the XInclude for a given
node is to search for an attribute xml:base. This only works if the
document being XInclude'd is in a different directory than the base document.
If this is the case, we can use an XPath query to find the node
containing the attribute via <code>"./ancestor::*[@xml:base]"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findXInclude(x, asNode = FALSE, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findXInclude_+3A_x">x</code></td>
<td>
<p>the node whose XInclude &quot;ancestor&quot; is to be found</p>
</td></tr>
<tr><td><code id="findXInclude_+3A_asnode">asNode</code></td>
<td>
<p>a logical value indicating whether to return the node itself or
the attributes of the node which are typically the immediately interesting 
aspect of the node.</p>
</td></tr>
<tr><td><code id="findXInclude_+3A_recursive">recursive</code></td>
<td>
<p>a logical value that controls whether the 
full path of the nested includes is returned or just the
path in the immediate XInclude element.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Either <code>NULL</code> if there was no node of class XMLXIncludeStartNode
found.
Otherwise, if <code>asNode</code> is <code>TRUE</code>, that  XMLXIncludeStartNode
node is returned, or alternatively its attribute character vector.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>www.libxml.org</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlParse">xmlParse</a></code> and the <code>xinclude</code> parameter.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 f = system.file("exampleData", "functionTemplate.xml", package = "XML")

 cat(readLines(f), "\n")

 doc = xmlParse(f)

  # Get all the para nodes
  # We just want to look at the 2nd and 3rd which are repeats of the
  # first one.
 a = getNodeSet(doc, "//author")
 findXInclude(a[[1]])

 i = findXInclude(a[[1]], TRUE)
 top = getSibling(i)

   # Determine the top-level included nodes
 tmp = getSibling(i)
 nodes = list()
 while(!inherits(tmp, "XMLXIncludeEndNode")) {
   nodes = c(nodes, tmp)
   tmp = getSibling(tmp)
 }
</code></pre>

<hr>
<h2 id='free'>Release the specified object and clean up its memory usage</h2><span id='topic+free'></span><span id='topic+free+2CXMLInternalDocument-method'></span>

<h3>Description</h3>

<p>This generic function is available for explicitly releasing
the memory associated with the given object.
It is intended for use on external pointer objects
which do not have an automatic  finalizer
function/routine that cleans up the memory that is used
by the native object.
This is the case, for example, for an XMLInternalDocument.
We cannot free it with a finalizer in all cases as we may have
a reference to a node in the associated document tree.
So the user must explicitly release the XMLInternalDocument object
to free the memory it occupies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>free(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="free_+3A_obj">obj</code></td>
<td>
<p> the object whose memory is to be released,
typically an external pointer object or object
that contains a slot that is an external pointer.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods will generally call a C routine to free the native
memory.
</p>


<h3>Value</h3>

<p>An updated version of the object with the external address set to NIL.
This is up to the individual methods. 
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code> with <code>useInternalNodes = TRUE</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> f = system.file("exampleData", "boxplot.svg", package = "XML")
 doc = xmlParse(f)
 nodes = getNodeSet(doc, "//path")
 rm(nodes)
 # free(doc)
</code></pre>

<hr>
<h2 id='genericSAXHandlers'>SAX generic callback handler list</h2><span id='topic+genericSAXHandlers'></span>

<h3>Description</h3>

<p>This is a convenience function to get the collection
of generic functions that make up the callbacks
for the SAX parser.
The return value can be used directly
as the value of the <code>handlers</code>
argument in <code><a href="#topic+xmlEventParse">xmlEventParse</a></code>.
One can easily specify a  subset
of the handlers by giving the names of
the elements to include or exclude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genericSAXHandlers(include, exclude, useDotNames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genericSAXHandlers_+3A_include">include</code></td>
<td>
<p>if supplied, this gives the names of the subset of elements to
return.
</p>
</td></tr>
<tr><td><code id="genericSAXHandlers_+3A_exclude">exclude</code></td>
<td>
<p>if supplied (and <code>include</code> is not),
this gives the names of the elements to remove from the list of
functions.
</p>
</td></tr>
<tr><td><code id="genericSAXHandlers_+3A_usedotnames">useDotNames</code></td>
<td>
<p> a logical value.
If this is <code>TRUE</code>, the names of the elements in the list of
handler functions are prefixed with '.'. This is the newer format
used to differentiate general element handlers and node-name-specific handlers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of functions.
By default, the elements are named
startElement, endElement, comment, text,
processingInstruction, entityDeclaration
and contain the corresponding
generic SAX callback function, i.e. given by
the element name with the .SAX suffix.
</p>
<p>If <code>include</code> or <code>exclude</code> is specified,
a subset of this list is returned.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlEventParse">xmlEventParse</a></code>
<code><a href="#topic+startElement.SAX">startElement.SAX</a></code>
<code><a href="#topic+endElement.SAX">endElement.SAX</a></code>
<code><a href="#topic+comment.SAX">comment.SAX</a></code>
<code><a href="#topic+processingInstruction.SAX">processingInstruction.SAX</a></code>
<code><a href="#topic+entityDeclaration.SAX">entityDeclaration.SAX</a></code>
<code><a href="#topic+.InitSAXMethods">.InitSAXMethods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
</code></pre>

<hr>
<h2 id='getChildrenStrings'>Get the individual </h2><span id='topic+getChildrenStrings'></span>

<h3>Description</h3>

<p>This is different from <code>xmlValue</code> applied to the node.
That concatenates all of the text in the child nodes (and their descendants)
This is a faster version of <code>xmlSApply(node, xmlValue)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChildrenStrings(node, encoding = getEncoding(node),
                    asVector = TRUE, len = xmlSize(node), addNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getChildrenStrings_+3A_node">node</code></td>
<td>
<p>the parent node whose child nodes we want to process</p>
</td></tr>
<tr><td><code id="getChildrenStrings_+3A_encoding">encoding</code></td>
<td>
<p>the encoding to use for the text. This should come
from the document itself. However, it can be useful to specify it if
the encoding has not been set for the document (e.g. if we are
constructing it node-by-node).</p>
</td></tr>
<tr><td><code id="getChildrenStrings_+3A_asvector">asVector</code></td>
<td>
<p>a logical value that controls whether the result is
returned as a character vector or as a list (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="getChildrenStrings_+3A_len">len</code></td>
<td>
<p>an integer giving the number of elements we expect
returned. This is best left unspecified but can be provided if the
caller already knows the number of child nodes. This avoids
recomputing this and so provides a marginal speedup.</p>
</td></tr>
<tr><td><code id="getChildrenStrings_+3A_addnames">addNames</code></td>
<td>
<p>a logical value that controls whether we add the
element names to each element of the resulting vector. This makes it
easier to identify from which element each string came.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlValue">xmlValue</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>doc = xmlParse("&lt;doc&gt;&lt;a&gt;a string&lt;/a&gt; some text &lt;b&gt;another&lt;/b&gt;&lt;/doc&gt;")
getChildrenStrings(xmlRoot(doc))

doc = xmlParse("&lt;doc&gt;&lt;a&gt;a string&lt;/a&gt; some text &lt;b&gt;another&lt;/b&gt;&lt;c/&gt;&lt;d&gt;abc&lt;e&gt;xyz&lt;/e&gt;&lt;/d&gt;&lt;/doc&gt;")
getChildrenStrings(xmlRoot(doc))
</code></pre>

<hr>
<h2 id='getEncoding'>Determines the encoding for an XML document or node</h2><span id='topic+getEncoding'></span><span id='topic+getEncoding+2CXMLInternalDocument-method'></span><span id='topic+getEncoding+2CXMLInternalNode-method'></span><span id='topic+getEncoding+2CANY-method'></span>

<h3>Description</h3>

<p>This function and its methods are intended to return the
encoding of n XML .
It is similar to <code><a href="base.html#topic+Encoding">Encoding</a></code> but currently
restricted to  XML nodes and documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEncoding(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEncoding_+3A_obj">obj</code></td>
<td>
<p>the object whose encoding is being queried.</p>
</td></tr>
<tr><td><code id="getEncoding_+3A_...">...</code></td>
<td>
<p>any additional parameters which can be customized by the methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1 giving the encoding of the XML document.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f = system.file("exampleData", "charts.svg", package = "XML")
  doc = xmlParse(f)
  getEncoding(doc)
  n = getNodeSet(doc, "//g/text")[[1]]
  getEncoding(n)

  f = system.file("exampleData", "iTunes.plist", package = "XML")
  doc = xmlParse(f)
  getEncoding(doc)
</code></pre>

<hr>
<h2 id='getHTMLLinks'>Get links or names of external files in HTML document</h2><span id='topic+getHTMLLinks'></span><span id='topic+getHTMLExternalFiles'></span>

<h3>Description</h3>

<p>These functions allow us to retrieve either the links
within an HTML document, or the collection of names of
external files referenced in an HTML document.
The external files include images, JavaScript and CSS documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getHTMLLinks(doc, externalOnly = TRUE, xpQuery = "//a/@href",
               baseURL = docName(doc), relative = FALSE)
getHTMLExternalFiles(doc, xpQuery = c("//img/@src", "//link/@href",
                                      "//script/@href", "//embed/@src"),
                     baseURL = docName(doc), relative = FALSE,
                     asNodes = FALSE, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getHTMLLinks_+3A_doc">doc</code></td>
<td>
<p>the HTML document as a URL, local file name, parsed
document or an XML/HTML node</p>
</td></tr>
<tr><td><code id="getHTMLLinks_+3A_externalonly">externalOnly</code></td>
<td>
<p>a logical value that indicates whether we should
only return links to external documents and not references to
internal anchors/nodes within this document, i.e. those that of the
form <code>#foo</code>.</p>
</td></tr>
<tr><td><code id="getHTMLLinks_+3A_xpquery">xpQuery</code></td>
<td>
<p>a vector of XPath elements which match the elements of interest</p>
</td></tr>
<tr><td><code id="getHTMLLinks_+3A_baseurl">baseURL</code></td>
<td>
<p>the URL of the container document. This is used
to resolve relative references/links.
</p>
</td></tr>
<tr><td><code id="getHTMLLinks_+3A_relative">relative</code></td>
<td>
<p>a logical value indicating whether to leave the
references as relative to the base URL or to expand them to their full paths.
</p>
</td></tr>
<tr><td><code id="getHTMLLinks_+3A_asnodes">asNodes</code></td>
<td>
<p>a logical value that indicates whether we want the actual
HTML/XML   nodes in the document that reference external documents
or just the names of the external documents.</p>
</td></tr>
<tr><td><code id="getHTMLLinks_+3A_recursive">recursive</code></td>
<td>
<p>a logical value that controls whether we recursively
process the external documents we find in the top-level document
examining them for their external files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getHTMLLinks</code> returns a character vector of the links.
</p>
<p><code>getHTMLExternalFiles</code> returns a character vector.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getXIncludes">getXIncludes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # site is flaky
  try(getHTMLLinks("https://www.omegahat.net"))

  try(getHTMLLinks("https://www.omegahat.net/RSXML"))

  try(unique(getHTMLExternalFiles("https://www.omegahat.net")))
</code></pre>

<hr>
<h2 id='getLineNumber'>Determine the location - file &amp; line number of an (internal) XML node</h2><span id='topic+getNodeLocation'></span><span id='topic+getNodePosition'></span><span id='topic+getLineNumber'></span>

<h3>Description</h3>

<p>The <code>getLineNumber</code> function is used to query the location of an internal/C-level
XML node within its original &quot;file&quot;. This gives us the line number.
<code>getNodeLocation</code> gives both the line number and the name of the
file in which the node is located, handling XInclude files in a
top-level document  and identifying the included file, as appropriate.
<code>getNodePosition</code> returns a simplified version of
<code>getNodeLocation</code>,
combining the file and line number into a string and ignoring the
<code>XPointer</code> component.
</p>
<p>This is useful when we identify a node with a particular charactestic
and want to view/edit the original document, e.g. when authoring an
Docbook article.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLineNumber(node, ...)
getNodeLocation(node, recursive = TRUE, fileOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLineNumber_+3A_node">node</code></td>
<td>
<p>the node whose location or line number is of interest</p>
</td></tr>
<tr><td><code id="getLineNumber_+3A_...">...</code></td>
<td>
<p>additional parameters for methods should they be defined.</p>
</td></tr>
<tr><td><code id="getLineNumber_+3A_recursive">recursive</code></td>
<td>
<p>a logical value that controls whether the 
full path of the nested includes is returned or just the
path in the immediate XInclude element.</p>
</td></tr>
<tr><td><code id="getLineNumber_+3A_fileonly">fileOnly</code></td>
<td>
<p>a logical value which if <code>TRUE</code> means that only
the name of the file is returned, and not the <code>xpointer</code> attribute or
line number .</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getLineNumber</code> returns an integer.
<code>getNodeLocation</code> returns a list with two elements -
<code>file</code> and <code>line</code> which are a character string
and the integer line number.
</p>
<p>For text nodes, the line number is taken from the previous sibling
nodes or the parent node.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libxml2 </p>


<h3>See Also</h3>

<p><code><a href="#topic+findXInclude">findXInclude</a></code>
<code><a href="#topic+xmlParse">xmlParse</a></code>
<code><a href="#topic+getNodeSet">getNodeSet</a></code>
<code><a href="#topic+xpathApply">xpathApply</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = system.file("exampleData", "xysize.svg", package = "XML")
doc = xmlParse(f)
e = getNodeSet(doc, "//ellipse")
sapply(e, getLineNumber)
</code></pre>

<hr>
<h2 id='getNodeSet'>Find matching nodes in an internal XML tree/DOM</h2><span id='topic+getNodeSet'></span><span id='topic+xpathApply'></span><span id='topic+xpathSApply'></span><span id='topic+matchNamespaces'></span>

<h3>Description</h3>

<p>These functions provide a way to find XML nodes that match a particular
criterion. It uses the XPath syntax and allows very powerful
expressions to identify nodes of interest within a document both
clearly and efficiently.  The XPath language requires some
knowledge, but tutorials are available on the Web and in books.
XPath queries can result in different types of values such as numbers,
strings, and node sets. It allows simple identification of nodes
by name, by path (i.e. hierarchies or sequences of
node-child-child...), with a particular attribute  or matching
a particular attribute with a given value. It also supports
functionality for navigating nodes in the tree within a query
(e.g. <code>ancestor()</code>, <code>child()</code>, <code>self()</code>),
and also for manipulating the content of one or more nodes
(e.g. <code>text</code>).
And it allows for criteria identifying nodes by position, etc.
using some counting operations.  Combining  XPath with R
allows for quite flexible node identification and manipulation.
XPath offers an alternative way to find nodes of interest 
than recursively or iteratively navigating the entire tree in R
and performing the navigation explicitly.
</p>
<p>One can search an entire document or start the search from a
particular node.  Such node-based searches can even search up the tree
as well as within the sub-tree that the node parents.  Node specific
XPath expressions are typically started with a &quot;.&quot; to indicate the
search is relative to that node.
</p>
<p>You can use several XPath 2.0 functions in the XPath
query. Furthermore, you can also register additional XPath
functions that are implemented either with R functions or C routines.
(See <code>xpathFuns</code>.)
</p>
<p>The set of matching nodes corresponding to an XPath expression
are returned in R as a list.  One can then  iterate over these elements to process the 
nodes in whatever way one wants. Unfortunately, this involves two loops -
one in the XPath query over the entire tree, and another in R.
Typically, this is fine as the number of matching nodes is reasonably small.
However, if repeating this on numerous files, speed may become an issue.
We can avoid the second loop (i.e. the one in R) by applying a function to each node
before it is returned to R as part of the node set.  The result of the function
call is then returned, rather than the node itself.
</p>
<p>One can provide an R expression rather than an R function for <code>fun</code>. This is expected to be a call
and the first argument of the call will be replaced with the node.
</p>
<p>Dealing with expressions that relate to the default namespaces in the
XML document can be confusing. 
</p>
<p><code>xpathSApply</code> is a version of <code>xpathApply</code>
which attempts to simplify the result if it can be converted
to a vector or matrix rather than left as a list.
In this way, it has the same relationship to  <code>xpathApply</code>
as <code><a href="base.html#topic+sapply">sapply</a></code> has to  <code><a href="base.html#topic+lapply">lapply</a></code>.
</p>
<p><code>matchNamespaces</code> is a separate function that is used to
facilitate
specifying the mappings from namespace prefix  used in the
XPath expression and their definitions, i.e. URIs,
and connecting these with the namespace definitions in the
target XML document in which the XPath expression will be evaluated.
</p>
<p><code>matchNamespaces</code> uses rules that are very slightly awkard or
specifically involve a special case. This is because this mapping of
namespaces from  XPath to XML targets is difficult, involving
prefixes in the XPath expression, definitions in the XPath evaluation
context and matches of URIs with those in the XML document.
The function aims to avoid having to specify all the prefix=uri pairs
by using &quot;sensible&quot; defaults and also matching the prefixes in the
XPath expression to the  corresponding definitions in the XML
document.
</p>
<p>The rules are as follows.
<code>namespaces</code> is a character vector. Any element that has a
non-trivial name (i.e. other than &quot;&quot;) is left as is and the name
and value define the prefix = uri mapping.
Any elements that have a trivial name (i.e. no name at all or &quot;&quot;)
are resolved by first matching the prefix to those of the defined
namespaces anywhere within the target document, i.e. in any node and
not just the root one.
If there is no match for the first element of the <code>namespaces</code>
vector, this is treated specially and is mapped to the
default namespace of the target document. If there is no default
namespace defined, an error occurs.
</p>
<p>It is best to give explicit the argument in the form
<code>c(prefix = uri, prefix = uri)</code>.
However, one can use the same namespace prefixes as in the document
if one wants.  And one can use an arbitrary namespace prefix
for the default namespace URI of the target document provided it is
the first element of <code>namespaces</code>.
</p>
<p>See the 'Details' section below for some more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getNodeSet(doc, path, namespaces = xmlNamespaceDefinitions(doc, simplify = TRUE), 
                    fun = NULL, sessionEncoding = CE_NATIVE, addFinalizer = NA, ...)
xpathApply(doc, path, fun, ... ,
            namespaces =  xmlNamespaceDefinitions(doc, simplify = TRUE),
              resolveNamespaces = TRUE, addFinalizer = NA, xpathFuns = list())
xpathSApply(doc, path, fun = NULL, ... ,
             namespaces = xmlNamespaceDefinitions(doc, simplify = TRUE),
               resolveNamespaces = TRUE, simplify = TRUE,
                addFinalizer = NA)
matchNamespaces(doc, namespaces,
                nsDefs = xmlNamespaceDefinitions(doc, recursive = TRUE, simplify = FALSE),
                defaultNs = getDefaultNamespace(doc, simplify = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNodeSet_+3A_doc">doc</code></td>
<td>
<p>an object of class <code>XMLInternalDocument</code></p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_path">path</code></td>
<td>
<p>a string (character vector of length 1) giving the
XPath expression to evaluate.</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_namespaces">namespaces</code></td>
<td>
<p> a named character vector giving the
namespace prefix and URI pairs that are to be used
in the XPath expression and matching of nodes.
The prefix is just a simple string that acts as a short-hand 
or alias for the URI that is the unique identifier for the
namespace.
The URI is the element in this vector and the prefix is the
corresponding element name.
One only needs to specify the namespaces in the XPath expression and
for the nodes of interest rather than requiring all the
namespaces for the entire document.
Also note that the prefix used in this vector is local only to the
path. It does not have to be the same as the prefix used in the
document to identify the namespace. However, the URI in this
argument must be identical to the target namespace URI in the
document.  It is the namespace URIs that are matched (exactly)
to find correspondence. The prefixes are used only to refer to
that URI.
</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_fun">fun</code></td>
<td>
<p>a function object, or an expression or call, which is used when the result is a node set
and evaluated for each node element in the node set.  If this is a call, the first argument is replaced 
with the current node.
</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_...">...</code></td>
<td>
<p>any additional arguments to be passed to <code>fun</code> for each
node in the node set.</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_resolvenamespaces">resolveNamespaces</code></td>
<td>
<p>a logical value indicating whether
to process the collection of namespaces and resolve those that have
no name by looking in the default namespace and the namespace
definitions within the target document to match by prefix.</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_nsdefs">nsDefs</code></td>
<td>
<p>a list giving the namespace definitions in which to match
any prefixes. This is typically computed directly from the target
document and the default value is most appropriate.</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_defaultns">defaultNs</code></td>
<td>
<p>the default namespace prefix-URI mapping given as a
named character vector. This is not a namespace definition object.
This is used when matching a simple prefix that has no corresponding
entry in <code>nsDefs</code> and is the first element in the
<code>namespaces</code> vector.
</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_simplify">simplify</code></td>
<td>
<p>a logical value indicating whether the function
should attempt to perform the simplification of the result
into a vector rather  than leaving it as a list.
This is the same as <code><a href="base.html#topic+sapply">sapply</a></code> does
in comparison to <code><a href="base.html#topic+lapply">lapply</a></code>.
</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_sessionencoding">sessionEncoding</code></td>
<td>
<p>experimental functionality and parameter related
to encoding.</p>
</td></tr>
<tr><td><code id="getNodeSet_+3A_addfinalizer">addFinalizer</code></td>
<td>
<p>a logical value or identifier for a C routine
that controls whether we register finalizers on the intenal
node.</p>
</td></tr> 
<tr><td><code id="getNodeSet_+3A_xpathfuns">xpathFuns</code></td>
<td>
<p>a list containing either character strings, functions
or named elements containing the address of a C routine.
These identify functions that can be used in the XPath expression.
A character string identifies the name of the XPath function and the
R function of the same name (and located on the R search path).
A C routine to implement an XPath function is specified via a call
to <code><a href="base.html#topic+getNativeSymbolInfo">getNativeSymbolInfo</a></code> and passing just the
address field.  This is provided in the <code>list()</code> with a name which is
used as the name of the XPath function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a namespace is defined on a node in the XML document,
an XPath expressions must use a namespace, even if it is the default
namespace for the XML document/node.
For example, suppose we have an XML document
<code>&lt;help xmlns="http://www.r-project.org/Rd"&gt;&lt;topic&gt;...&lt;/topic&gt;&lt;/help&gt;</code>  
To find all the topic nodes, we might want to use
the XPath expression <code>"/help/topic"</code>.
However, we must use an explicit namespace prefix that is associated
with the URI <code>http://www.r-project.org/Rd</code> corresponding to the one in
the XML document.
So we would use
<code>getNodeSet(doc, "/r:help/r:topic", c(r = "http://www.r-project.org/Rd"))</code>.
</p>
<p>As described above, the functions attempt to allow
the namespaces to be specified easily by the R user
and matched to the namespace definitions in the
target document.
</p>
<p>This calls the libxml routine <code>xmlXPathEval</code>.
</p>


<h3>Value</h3>

<p>The results can currently be different
based on the returned value from the XPath expression evaluation:
</p>
<table>
<tr><td><code>list</code></td>
<td>
<p>a node set</p>
</td></tr>
<tr><td><code>numeric</code></td>
<td>
<p>a number</p>
</td></tr>
<tr><td><code>logical</code></td>
<td>
<p>a boolean</p>
</td></tr>
<tr><td><code>character</code></td>
<td>
<p>a string, i.e. a single character element.</p>
</td></tr>
</table>
<p>If <code>fun</code> is supplied and the result of the XPath query is a node set, 
the result in R is a list.
</p>


<h3>Note</h3>

<p>In order to match nodes in the default name space for
documents with a non-trivial default namespace, e.g. given as
<code>xmlns="https://www.omegahat.net"</code>, you will need to use a prefix
for the default namespace in this call.
When specifying the namespaces, give a name - any name - to the
default namespace URI and then use this as the prefix in the
XPath expression, e.g.
<code>getNodeSet(d, "//d:myNode", c(d = "https://www.omegahat.net"))</code>
to match myNode in the default name space
<code>https://www.omegahat.net</code>.
</p>
<p>This default namespace of the document is now computed for us and
is the default value for the namespaces argument.
It can be referenced using the prefix 'd',
standing for default but sufficiently short to be
easily used within the XPath expression.
</p>
<p>More of the XPath functionality provided by libxml can and may be
made available to the R package.
Facilities such as compiled XPath expressions, functions, ordered node
information are examples.
</p>
<p>Please send requests to the package maintainer.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang &lt;duncan@wald.ucdavis.edu&gt;</p>


<h3>References</h3>

<p><a href="http://xmlsoft.org">http://xmlsoft.org</a>, 
<a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>
<a href="https://www.w3.org/TR/xpath/">https://www.w3.org/TR/xpath/</a>
<a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code> with <code>useInternalNodes</code> as <code>TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> doc = xmlParse(system.file("exampleData", "tagnames.xml", package = "XML"))
 
 els = getNodeSet(doc, "/doc//a[@status]")
 sapply(els, function(el) xmlGetAttr(el, "status"))

   # use of namespaces on an attribute.
 getNodeSet(doc, "/doc//b[@x:status]", c(x = "https://www.omegahat.net"))
 getNodeSet(doc, "/doc//b[@x:status='foo']", c(x = "https://www.omegahat.net"))

   # Because we know the namespace definitions are on /doc/a
   # we can compute them directly and use them.
 nsDefs = xmlNamespaceDefinitions(getNodeSet(doc, "/doc/a")[[1]])
 ns = structure(sapply(nsDefs, function(x) x$uri), names = names(nsDefs))
 getNodeSet(doc, "/doc//b[@omegahat:status='foo']", ns)[[1]]

 # free(doc) 

 #####
 f = system.file("exampleData", "eurofxref-hist.xml.gz", package = "XML") 
 e = xmlParse(f)
 ans = getNodeSet(e, "//o:Cube[@currency='USD']", "o")
 sapply(ans, xmlGetAttr, "rate")

  # or equivalently
 ans = xpathApply(e, "//o:Cube[@currency='USD']", xmlGetAttr, "rate", namespaces = "o")
 # free(e)



  # Using a namespace
 f = system.file("exampleData", "SOAPNamespaces.xml", package = "XML") 
 z = xmlParse(f)
 getNodeSet(z, "/a:Envelope/a:Body", c("a" = "http://schemas.xmlsoap.org/soap/envelope/"))
 getNodeSet(z, "//a:Body", c("a" = "http://schemas.xmlsoap.org/soap/envelope/"))
 # free(z)


  # Get two items back with namespaces
 f = system.file("exampleData", "gnumeric.xml", package = "XML") 
 z = xmlParse(f)
 getNodeSet(z, "//gmr:Item/gmr:name", c(gmr="http://www.gnome.org/gnumeric/v2"))

 #free(z)

 #####
 # European Central Bank (ECB) exchange rate data

  # Data is available from "http://www.ecb.int/stats/eurofxref/eurofxref-hist.xml"
  # or locally.

 uri = system.file("exampleData", "eurofxref-hist.xml.gz", package = "XML")
 doc = xmlParse(uri)

   # The default namespace for all elements is given by
 namespaces &lt;- c(ns="http://www.ecb.int/vocabulary/2002-08-01/eurofxref")


     # Get the data for Slovenian currency for all time periods.
     # Find all the nodes of the form &lt;Cube currency="SIT"...&gt;

 slovenia = getNodeSet(doc, "//ns:Cube[@currency='SIT']", namespaces )

    # Now we have a list of such nodes, loop over them 
    # and get the rate attribute
 rates = as.numeric( sapply(slovenia, xmlGetAttr, "rate") )
    # Now put the date on each element
    # find nodes of the form &lt;Cube time=".." ... &gt;
    # and extract the time attribute
 names(rates) = sapply(getNodeSet(doc, "//ns:Cube[@time]", namespaces ), 
                      xmlGetAttr, "time")

    #  Or we could turn these into dates with strptime()
 strptime(names(rates), "%Y-%m-%d")


   #  Using xpathApply, we can do
 rates = xpathApply(doc, "//ns:Cube[@currency='SIT']",
                   xmlGetAttr, "rate", namespaces = namespaces )
 rates = as.numeric(unlist(rates))

   # Using an expression rather than  a function and ...
 rates = xpathApply(doc, "//ns:Cube[@currency='SIT']",
                   quote(xmlGetAttr(x, "rate")), namespaces = namespaces )

 #free(doc)

   #
  uri = system.file("exampleData", "namespaces.xml", package = "XML")
  d = xmlParse(uri)
  getNodeSet(d, "//c:c", c(c="http://www.c.org"))

  getNodeSet(d, "/o:a//c:c", c("o" = "https://www.omegahat.net", "c" = "http://www.c.org"))

   # since https://www.omegahat.net is the default namespace, we can
   # just the prefix "o" to map to that.
  getNodeSet(d, "/o:a//c:c", c("o", "c" = "http://www.c.org"))


   # the following, perhaps unexpectedly but correctly, returns an empty
   # with no matches
   
  getNodeSet(d, "//defaultNs", "https://www.omegahat.net")

   # But if we create our own prefix for the evaluation of the XPath
   # expression and use this in the expression, things work as one
   # might hope.
  getNodeSet(d, "//dummy:defaultNs", c(dummy = "https://www.omegahat.net"))

   # And since the default value for the namespaces argument is the
   # default namespace of the document, we can refer to it with our own
   # prefix given as 
  getNodeSet(d, "//d:defaultNs", "d")

   # And the syntactic sugar is 
  d["//d:defaultNs", namespace = "d"]


   # this illustrates how we can use the prefixes in the XML document
   # in our query and let getNodeSet() and friends map them to the
   # actual namespace definitions.
   # "o" is used to represent the default namespace for the document
   # i.e. https://www.omegahat.net, and "r" is mapped to the same
   # definition that has the prefix "r" in the XML document.

  tmp = getNodeSet(d, "/o:a/r:b/o:defaultNs", c("o", "r"))
  xmlName(tmp[[1]])


  #free(d)


   # Work with the nodes and their content (not just attributes) from the node set.
   # From bondsTables.R in examples/

## Not run: ## fails to download as from May 2017
  doc =
 htmlTreeParse("http://finance.yahoo.com/bonds/composite_bond_rates?bypass=true",
               useInternalNodes = TRUE)
  if(is.null(xmlRoot(doc))) 
     doc = htmlTreeParse("http://finance.yahoo.com/bonds?bypass=true",
			 useInternalNodes = TRUE)

     # Use XPath expression to find the nodes 
     #  &lt;div&gt;&lt;table class="yfirttbl"&gt;..
     # as these are the ones we want.

  if(!is.null(xmlRoot(doc))) {

   o = getNodeSet(doc, "//div/table[@class='yfirttbl']")
}

    # Write a function that will extract the information out of a given table node.
   readHTMLTable =
   function(tb)
    {
          # get the header information.
      colNames = sapply(tb[["thead"]][["tr"]]["th"], xmlValue)
      vals = sapply(tb[["tbody"]]["tr"],  function(x) sapply(x["td"], xmlValue))
      matrix(as.numeric(vals[-1,]),
              nrow = ncol(vals),
              dimnames = list(vals[1,], colNames[-1]),
              byrow = TRUE
            )
    }  


     # Now process each of the table nodes in the o list.
    tables = lapply(o, readHTMLTable)
    names(tables) = lapply(o, function(x) xmlValue(x[["caption"]]))
  
## End(Not run)


     # this illustrates an approach to doing queries on a sub tree
     # within the document.
     # Note that there is a memory leak incurred here as we create a new
     # XMLInternalDocument in the getNodeSet().

    f = system.file("exampleData", "book.xml", package = "XML")
    doc = xmlParse(f)
    ch = getNodeSet(doc, "//chapter")
    xpathApply(ch[[2]], "//section/title", xmlValue)

      # To fix the memory leak, we explicitly create a new document for
      # the subtree, perform the query and then free it _when_ we are done
      # with the resulting nodes.
    subDoc = xmlDoc(ch[[2]])
    xpathApply(subDoc, "//section/title", xmlValue)
    free(subDoc)


    txt =
'&lt;top xmlns="http://www.r-project.org" xmlns:r="http://www.r-project.org"&gt;&lt;r:a&gt;&lt;b/&gt;&lt;/r:a&gt;&lt;/top&gt;'
    doc = xmlInternalTreeParse(txt, asText = TRUE)

## Not run: 
     # Will fail because it doesn't know what the namespace x is
     # and we have to have one eventhough it has no prefix in the document.
    xpathApply(doc, "//x:b")

## End(Not run)    
      # So this is how we do it - just  say x is to be mapped to the
      # default unprefixed namespace which we shall call x!
    xpathApply(doc, "//x:b", namespaces = "x")

       # Here r is mapped to the the corresponding definition in the document.
    xpathApply(doc, "//r:a", namespaces = "r")
       # Here, xpathApply figures this out for us, but will raise a warning.
    xpathApply(doc, "//r:a")

       # And here we use our own binding.
    xpathApply(doc, "//x:a", namespaces = c(x = "http://www.r-project.org"))



       # Get all the nodes in the entire tree.
    table(unlist(sapply(doc["//*|//text()|//comment()|//processing-instruction()"],
    class)))


       
     ## Use of XPath 2.0 functions min() and max()
     doc = xmlParse('&lt;doc&gt;&lt;p age="10"/&gt;&lt;p age="12"/&gt;&lt;p age="7"/&gt;&lt;/doc&gt;')
     getNodeSet(doc, "//p[@age  = min(//p/@age)]")
     getNodeSet(doc, "//p[@age  = max(//p/@age)]")

     avg = function(...) {
             mean(as.numeric(unlist(...)))
           }
     getNodeSet(doc, "//p[@age &gt; avg(//p/@age)]", xpathFuns = "avg")


  doc = xmlParse('&lt;doc&gt;&lt;ev date="2010-12-10"/&gt;&lt;ev date="2011-3-12"/&gt;&lt;ev date="2015-10-4"/&gt;&lt;/doc&gt;')
  getNodeSet(doc, "//ev[month-from-date(@date) &gt; 7]",
              xpathFuns = list("month-from-date" =
                                function(node) {
                                  match(months(as.Date(as.character(node[[1]]))), month.name)
                                }))
</code></pre>

<hr>
<h2 id='getRelativeURL'>Compute name of URL relative to a base URL</h2><span id='topic+getRelativeURL'></span>

<h3>Description</h3>

<p>This function is a convenience function for 
computing the fullly qualified URI of a document
relative to a base URL. 
It handles the case where the document is 
already fully qualified and so ignores the base URL
or, alternatively, is a relative document name and so
prepends the base URL.
It does not (yet) try to be clever by collapsing
relative directories such as &quot;..&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRelativeURL(u, baseURL, sep = "/", addBase = TRUE,
               simplify = TRUE, escapeQuery = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRelativeURL_+3A_u">u</code></td>
<td>
<p>the location of the target document whose fully qualified URI is to be determined.</p>
</td></tr>
<tr><td><code id="getRelativeURL_+3A_baseurl">baseURL</code></td>
<td>
<p>the base URL relative to which the value of <code>u</code> should be interpreted.</p>
</td></tr>
<tr><td><code id="getRelativeURL_+3A_sep">sep</code></td>
<td>
<p>the separator to use to separate elements of the path. For external URLs (e.g. 
accessed via HTTP, HTTPS, FTP), / should be used. For local files on Windows machines 
one might use <code>.Platform$file.sep</code>, but this is incorrect unless one knows that the
resulting file is to be accessed using Windows file system notation, i.e. 
<code>C:\\my\\folder\\file</code>.
</p>
</td></tr>
<tr><td><code id="getRelativeURL_+3A_addbase">addBase</code></td>
<td>
<p>a logical controlling whether we prepend the base URL
to  the  result.</p>
</td></tr>
<tr><td><code id="getRelativeURL_+3A_simplify">simplify</code></td>
<td>
<p>a logical value that controls whether we attempt to
simplify/normalize the path to remove <code>..</code> and <code>.</code></p>
</td></tr>
<tr><td><code id="getRelativeURL_+3A_escapequery">escapeQuery</code></td>
<td>
<p>a logical value. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses the function <code>parseURI</code> to compute the components
of the different URIs.
</p>


<h3>Value</h3>

<p>A character string giving the fully qualified URI for
<code>u</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+parseURI">parseURI</a></code> which uses the libxml2 facilities for parsing URIs.
</p>
<p><code><a href="#topic+xmlParse">xmlParse</a></code>,  <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>,  <code><a href="#topic+xmlInternalTreeParse">xmlInternalTreeParse</a></code>.
XInclude and XML Schema import/include elements for computing relative locations of included/imported files..
</p>


<h3>Examples</h3>

<pre><code class='language-R'> getRelativeURL("https://www.omegahat.net", "http://www.r-project.org")

 getRelativeURL("bar.html", "http://www.r-project.org/")

 getRelativeURL("../bar.html", "http://www.r-project.org/")
</code></pre>

<hr>
<h2 id='getSibling'>Manipulate sibling XML nodes</h2><span id='topic+getSibling'></span><span id='topic+addSibling'></span>

<h3>Description</h3>

 
<p>These functions allow us to both access the sibling node
to the left or right of a given node and so walk the chain
of siblings, and also to insert a new sibling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSibling(node, after = TRUE, ...)
addSibling(node, ..., kids = list(...), after = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSibling_+3A_node">node</code></td>
<td>
<p>the internal XML node (XMLInternalNode) 
whose siblings are of interest</p>
</td></tr>
<tr><td><code id="getSibling_+3A_...">...</code></td>
<td>
<p>the XML nodes to add as siblings or children to node.</p>
</td></tr>
<tr><td><code id="getSibling_+3A_kids">kids</code></td>
<td>
<p>a list containing the XML nodes to add as siblings.
This is equivalent to ... but used when we already have the
nodes in a list rather than as individual objects. This is used in programmatic
calls to 
<code>addSibling</code>
rather interactive use where we more commonly have
the individual node objects.
</p>
</td></tr>
<tr><td><code id="getSibling_+3A_after">after</code></td>
<td>
<p>a logical value indicating whether to retrieve or add the 
nodes to the right (<code>TRUE</code>) or to the left (<code>FALSE</code>) of this sibling.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getSibling</code>
returns an object of class
XMLInternalNode (or some derived S3 class, e.g. XMLInternalTextNode)
</p>
<p><code>addSibling</code>
returns a list whose elements are the newly added
XML (internal) nodes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlChildren">xmlChildren</a></code>,
<code><a href="#topic+addChildren">addChildren</a></code>
<code><a href="#topic+removeNodes">removeNodes</a></code>
<code><a href="#topic+replaceNodes">replaceNodes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
          # Reading Apple's iTunes files
     # 
     #           Here we read  a "censored" "database" of songs from Apple's  iTune application
     #           which is stored in a property list.  The format is quite generic and 
     #            the fields for each song are given in the form
     #           
     #             &lt;key&gt;Artist&lt;/key&gt;&lt;string&gt;Person's name&lt;/string&gt;
     # 	  
     #           So to find the names of the artists for all the songs, we want to 
     #           find all the &lt;key&gt;Artist&lt;key&gt; nodes and then get their next sibling
     #           which has the actual value.
     #         
     #           More information can be found in .
     # 	
           fileName = system.file("exampleData", "iTunes.plist", package = "XML")

           doc = xmlParse(fileName)
           nodes = getNodeSet(doc, "//key[text() = 'Artist']")
           sapply(nodes, function(x)  xmlValue(getSibling(x)))
	

      f = system.file("exampleData", "simple.xml", package = "XML")
      tt = as(xmlParse(f), "XMLHashTree") 

       tt

      e = getSibling(xmlRoot(tt)[[1]])
        # and back to the first one again by going backwards along the sibling list.
      getSibling(e, after = FALSE)


         # This also works for multiple top-level "root" nodes
      f = system.file("exampleData", "job.xml", package = "XML")
      tt = as(xmlParse(f), "XMLHashTree")
       x = xmlRoot(tt, skip = FALSE)
       getSibling(x)
       getSibling(getSibling(x), after = FALSE)
</code></pre>

<hr>
<h2 id='getXIncludes'>Find the documents that are XInclude'd in an XML document</h2><span id='topic+getXIncludes'></span><span id='topic+xmlXIncludes'></span>

<h3>Description</h3>

<p>The <code>getXMLIncludes</code> function finds the names of the  documents
that are XIncluded in a given XML document,
optionally processing these documents recursively.
</p>
<p><code>xmlXIncludes</code> returns the hierarchy of included documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getXIncludes(filename, recursive = TRUE, skip = character(),
             omitPattern = "\\.(js|html?|txt|R|c)$",
             namespace = c(xi = "https://www.w3.org/2003/XInclude"),
            duplicated = TRUE)
xmlXIncludes(filename, recursive = TRUE,
         omitPattern = "\\.(js|html?|txt|R|c)$",
         namespace = c(xi = "https://www.w3.org/2003/XInclude"),
         addNames = TRUE,
         clean = NULL, ignoreTextParse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getXIncludes_+3A_filename">filename</code></td>
<td>
<p>the name of the XML document's URL or file or the
parsed document itself.</p>
</td></tr>
<tr><td><code id="getXIncludes_+3A_recursive">recursive</code></td>
<td>
<p>a logical value controlling whether to recursively
process the XInclude'd files for their XInclude'd files</p>
</td></tr>
<tr><td><code id="getXIncludes_+3A_skip">skip</code></td>
<td>
<p>a character vector of file names to ignore or skip over</p>
</td></tr>
<tr><td><code id="getXIncludes_+3A_omitpattern">omitPattern</code></td>
<td>
<p>a regular expression for indentifying files that
are included that we do not want to recursively process</p>
</td></tr>
<tr><td><code id="getXIncludes_+3A_namespace">namespace</code></td>
<td>
<p>the namespace to use for the XInclude. There are two
that are in use 2001 and 2003.</p>
</td></tr>
<tr><td><code id="getXIncludes_+3A_duplicated">duplicated</code></td>
<td>
<p>a logical value that controls whether only the
unique names of the files are returned, or if we get all references
to all files.</p>
</td></tr>
<tr><td><code id="getXIncludes_+3A_addnames">addNames</code></td>
<td>
<p>a logical that controls whether we add the name of
the parent file as the names vector for the collection of included
file names. This is useful, but sometimes we want to disable this,
e.g. to create a <code>JSON</code> representation of the hierarchy for use
in, e.g., D3.</p>
</td></tr>
<tr><td><code id="getXIncludes_+3A_clean">clean</code></td>
<td>
<p>how to process the names of the files. This can be a
function or a character vector of two regular expressions passed to
<code>gsub</code>.
The function is called with a vector of file names. The regular
expressions are used in a call to <code>gsub</code>.</p>
</td></tr>
<tr><td><code id="getXIncludes_+3A_ignoretextparse">ignoreTextParse</code></td>
<td>
<p>if <code>TRUE</code>, ignore the XIncluded files that
are identified as text and not XML with <code>parse="text"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>recursive</code> is <code>FALSE</code>, a character vector giving the
names of the included files.
</p>
<p>For <code>recursive</code> is <code>TRUE</code>, currently the same character
vector form. However, this will be a hierarchical list.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getHTMLExternalFiles">getHTMLExternalFiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  f = system.file("exampleData", "xinclude", "a.xml", package = "XML")

  getXIncludes(f, recursive = FALSE)

</code></pre>

<hr>
<h2 id='getXMLErrors'>Get XML/HTML document parse errors</h2><span id='topic+getXMLErrors'></span>

<h3>Description</h3>

<p>This function is intended to be a convenience for 
finding all the errors in an XML or HTML document due
to being malformed, i.e. missing quotes on attributes,
non-terminated elements/nodes, incorrectly terminated
nodes, missing entities, etc.
The document is parsed and a list of the errors is returned
along with information about the file, line and column number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getXMLErrors(filename, parse = xmlParse, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getXMLErrors_+3A_filename">filename</code></td>
<td>
<p> the identifier for the  document to be parsed, one of
a local file name,  a URL or the XML/HTML content itself</p>
</td></tr>
<tr><td><code id="getXMLErrors_+3A_parse">parse</code></td>
<td>
<p> the function to use to parse the document, usually
either  <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code> or  <code><a href="#topic+htmlTreeParse">htmlTreeParse</a></code>.
</p>
</td></tr>
<tr><td><code id="getXMLErrors_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the function given by <code>parse</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of S3-style  <code>XMLError</code> objects.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libxml2 (<a href="http://xmlsoft.org">http://xmlsoft.org</a>)</p>


<h3>See Also</h3>

<p><code>error</code> argument for <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code> and related functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     # Get the "errors" in the HTML that was generated from this Rd file
  getXMLErrors(system.file("html", "getXMLErrors.html", package = "XML"))

## Not run: 
  getXMLErrors("https://www.omegahat.net/index.html")

## End(Not run)

</code></pre>

<hr>
<h2 id='isXMLString'>Facilities for working with XML strings</h2><span id='topic+isXMLString'></span><span id='topic+xml'></span><span id='topic+xmlParseString'></span><span id='topic+XMLString-class'></span>

<h3>Description</h3>

<p>These functions and classes are used to represent and parse a
string whose content is known to be XML.
<code>xml</code> allows us to mark a character vector as containing XML,
i.e. of class <code>XMLString</code>.
</p>
<p><code>xmlParseString</code> is a convenience routine for converting an
XML string into an XML node/tree.
</p>
<p><code>isXMLString</code> is examines a strings content and heuristically 
determines whether it is XML.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isXMLString(str)
xmlParseString(content, doc = NULL, namespaces = RXMLNamespaces,
                clean = TRUE, addFinalizer = NA) 
xml(x) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isXMLString_+3A_str">str</code>, <code id="isXMLString_+3A_x">x</code>, <code id="isXMLString_+3A_content">content</code></td>
<td>
<p>the string containing the XML material.</p>
</td></tr>
<tr><td><code id="isXMLString_+3A_doc">doc</code></td>
<td>
<p>if specified, an <code>XMLInternalDocument</code> object which is
used to &quot;house&quot; the new nodes. Specifically, when the nodes are
created, they are made as part of this document. This may not be as
relevant now with the garbage collection being done at a node and
document level. But it still potentially of some value.</p>
</td></tr>
<tr><td><code id="isXMLString_+3A_namespaces">namespaces</code></td>
<td>
<p>a character vector giving the URIs for the XML namespaces which are to be removed if <code>clean</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="isXMLString_+3A_clean">clean</code></td>
<td>
<p>a logical value that controls whether namespaces are removed after the document is parsed..</p>
</td></tr>
<tr><td><code id="isXMLString_+3A_addfinalizer">addFinalizer</code></td>
<td>
<p>a logical value or identifier for a C routine
that controls whether we register finalizers on the intenal node.</p>
</td></tr>   
</table>


<h3>Value</h3>

<p><code>isXMLString</code> returns a logical value.
</p>
<p><code>xmlParseString</code> returns an object of class
<code>XMLInternalElementNode</code>.
</p>
<p><code>xml</code> returns an object of class <code>XMLString</code>
identifying the  text as <code>XML</code>.
</p>


<h3>Author(s)</h3>

<p>Dncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlParse">xmlParse</a></code>
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> isXMLString("a regular string &lt; 20 characters long")
 isXMLString("&lt;a&gt;&lt;b&gt;c&lt;/b&gt;&lt;/a&gt;")

 xmlParseString("&lt;a&gt;&lt;b&gt;c&lt;/b&gt;&lt;/a&gt;")

  # We can lie!
 isXMLString(xml("foo"))
</code></pre>

<hr>
<h2 id='length.XMLNode'>Determine the number of children in an XMLNode object.</h2><span id='topic+length.XMLNode'></span>

<h3>Description</h3>

<p>This function is a simple way to compute the number
of sub-nodes (or children) an <code>XMLNode</code> object
possesses.
It is provided as a convenient form of calling the
<code><a href="#topic+xmlSize">xmlSize</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XMLNode'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.XMLNode_+3A_x">x</code></td>
<td>
<p>the <code>XMLNode</code> object whose length is to be queried.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer giving the number of sub-nodes
of this node.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlSize">xmlSize</a></code>
<code><a href="#topic+xmlChildren">xmlChildren</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  doc &lt;- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
  r &lt;- xmlRoot(doc, skip=TRUE)
  length(r)
    # get the last entry
  r[[length(r)]]
</code></pre>

<hr>
<h2 id='libxmlVersion'>Query the version and available features of the libxml library.</h2><span id='topic+libxmlVersion'></span><span id='topic+libxmlFeatures'></span>

<h3>Description</h3>

<p><code>libxmlVersion</code> retrieves the version of the libxml
library used when installing this XML package.
<code>libxmlFeatures</code> returns a named logical vector
indicating which features are enabled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>libxmlVersion(runTime = FALSE)
libxmlFeatures()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="libxmlVersion_+3A_runtime">runTime</code></td>
<td>
<p>a logical value indicating whether to retrieve the version information
describing libxml  when the R package was compiled or the run-time version.
These may be different if a) a new version of libxml2 is installed after the package is installed,
b) if the package was installed as a binary package built on a different machine.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>libxmlVersion</code> returns a named list with
fields
</p>
<table>
<tr><td><code>major</code></td>
<td>
<p>the major version number, either 1 or 2
indicating the old or new-style library.</p>
</td></tr>
<tr><td><code>minor</code></td>
<td>
<p>the within version release number.</p>
</td></tr>
<tr><td><code>patch</code></td>
<td>
<p>the within minor release version number</p>
</td></tr>
</table>
<p><code>libxmlFeatures</code> returns a logical vector with names given by:
<code>
 [1] "THREAD"     "TREE"       "OUTPUT"     "PUSH"       "READER"    
 [6] "PATTERN"    "WRITER"     "SAX1"       "FTP"        "HTTP"      
[11] "VALID"      "HTML"       "LEGACY"     "C14N"       "CATALOG"   
[16] "XPATH"      "XPTR"       "XINCLUDE"   "ICONV"      "ISO8859X"  
[21] "UNICODE"    "REGEXP"     "AUTOMATA"   "EXPR"       "SCHEMAS"   
[26] "SCHEMATRON" "MODULES"    "DEBUG"      "DEBUG_MEM"  "DEBUG_RUN" 
[31] "ZLIB"      
</code>
Elements are either <code>TRUE</code> or <code>FALSE</code> indicating whether support
was activatd for that feature, or <code>NA</code> if that feature is not
part of the particular version of libcurl.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>Examples</h3>

<pre><code class='language-R'> ver &lt;- libxmlVersion()
 if(is.null(ver)) {
   cat("Relly old version of libxml\n")
 } else {
   if(ver$major &gt; 1) {
     cat("Using libxml2\n")
   }
 }
</code></pre>

<hr>
<h2 id='makeClassTemplate'>Create S4 class definition based on XML node(s)</h2><span id='topic+makeClassTemplate'></span>

<h3>Description</h3>

<p>This function is used to create an S4 class definition
by examining an XML node and  mapping the sub-elements
to S4 classes. This works very simply with child nodes
being mapped to other S4 classes that are defined recursively in the
same manner. Simple text elements are mapped to a generic character string.
Types can be mapped to more specific types (e.g. boolean, Date, integer)
by the caller (via the <code>types</code>) parameter.
The function also generates a coercion method from an
<code>XMLAbstractNode</code> to an instance of this new class.
</p>
<p>This function can either return the code that defines the class
or it can define the new class in the R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeClassTemplate(xnode, types = character(), default = "ANY",
                   className = xmlName(xnode), where = globalenv())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeClassTemplate_+3A_xnode">xnode</code></td>
<td>
<p>the XML node to analyze</p>
</td></tr>
<tr><td><code id="makeClassTemplate_+3A_types">types</code></td>
<td>
<p>a character vector mapping XML elements to R classes</p>
</td></tr>
<tr><td><code id="makeClassTemplate_+3A_default">default</code></td>
<td>
<p>the default class to map an element to</p>
</td></tr>
<tr><td><code id="makeClassTemplate_+3A_classname">className</code></td>
<td>
<p>the name of the new top-level class to be defined.
This is the name of the XML node (without the name space)</p>
</td></tr>
<tr><td><code id="makeClassTemplate_+3A_where">where</code></td>
<td>
<p> typically either an environment or NULL.
This is used to control where the class and coercion method are
defined
or if <code>NULL</code> inhibits the code being evaluated. In this
case, the code is returned as strings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 4 elements:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>the name of the new class</p>
</td></tr>
<tr><td><code>slots</code></td>
<td>
<p>a character vector giving the slot name and type name pairs</p>
</td></tr>
<tr><td><code>def</code></td>
<td>
<p>code for defining the class</p>
</td></tr>
<tr><td><code>coerce</code></td>
<td>
<p>code for defining the coercion method from an
XMLAbstractNode to an instance of the new class</p>
</td></tr>
</table>
<p>If <code>where</code> is not <code>NULL</code>, the class and coercion code
is actually evaluated and the class and method will be defined
in the R session as a side effect.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlToS4">xmlToS4</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>txt = paste0("&lt;doc&gt;&lt;part&gt;&lt;name&gt;ABC&lt;/name&gt;&lt;type&gt;XYZ&lt;/type&gt;",
            "&lt;cost&gt;3.54&lt;/cost&gt;&lt;status&gt;available&lt;/status&gt;&lt;/part&gt;&lt;/doc&gt;")
 doc = xmlParse(txt)

 code = makeClassTemplate(xmlRoot(doc)[[1]], types = c(cost = "numeric"))

 as(xmlRoot(doc)[["part"]], "part")
</code></pre>

<hr>
<h2 id='names.XMLNode'>Get the names of an XML nodes children.</h2><span id='topic+names.XMLNode'></span>

<h3>Description</h3>

<p>This is a convenient way to obtain the XML tag name
of each of the sub-nodes of a given 
<code>XMLNode</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XMLNode'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.XMLNode_+3A_x">x</code></td>
<td>
<p>the <code>XMLNode</code> whose sub-node tag names are being
queried.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector returning the
tag names of the sub-nodes of the given
<code>XMLNode</code> argument.
</p>


<h3>Note</h3>

<p> This overrides the regular names method
which would display the names of the internal
fields of an <code>XMLNode</code> object.
Since these are intended to be invisible and
queried via the accessor methods (<code><a href="#topic+xmlName">xmlName</a></code>,
<code><a href="#topic+xmlAttrs">xmlAttrs</a></code>, etc.), this should not
be a problem. If you really need the names
of the fields, use <code>names(unclass(x))</code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlApply">xmlApply</a></code>
<code><a href="#topic+xmlSApply">xmlSApply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> doc &lt;- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
 names(xmlRoot(doc))

 r &lt;- xmlRoot(doc)
 r[names(r) == "variables"]
</code></pre>

<hr>
<h2 id='newXMLDoc'>Create internal XML node or document object</h2><span id='topic+newXMLDoc'></span><span id='topic+newHTMLDoc'></span><span id='topic+newXMLNode'></span><span id='topic+newXMLPINode'></span><span id='topic+newXMLCDataNode'></span><span id='topic+newXMLCommentNode'></span><span id='topic+newXMLTextNode'></span><span id='topic+newXMLDTDNode'></span><span id='topic+xmlDoc'></span><span id='topic+coerce+2Cvector+2CXMLInternalNode-method'></span>

<h3>Description</h3>

<p>These are used to create internal &lsquo;libxml&rsquo; nodes and top-level document objects 
that are used to write XML trees.  While the functions are available,
their direct use is not encouraged. Instead, use <code><a href="#topic+xmlTree">xmlTree</a></code>
as the functions need to be used within a strict regime to avoid
corrupting C level structures.
</p>
<p><code>xmlDoc</code> creates a new XMLInternalDocument
object by copying the given node and all of its
descendants and putting them into a new document.
This is useful when we want to work with sub-trees
with general tools that work on documents, e.g. XPath queries.
</p>
<p><code>newXMLDoc</code> allows one to create a regular XML node
with a name and attributes.
One can provide new namespace definitions via
<code>namespaceDefinitions</code>. While these might also
be given in the attributes in the slightly more verbose
form of <code>c('xmlns:prefix' = 'http://...')</code>,
the result is that the XML node does not interpret that
as a namespace definition but merely an attribute with
a name 'xmlns:prefix'.
Instead, one should specify the namespace definitions via
the <code>namespaceDefinitions</code> parameter.
</p>
<p>In addition to namespace definitions, a node name can also have a
namespace definition.  This can be specified in the <code>name</code> argument
as <code>prefix:name</code> and <code>newXMLDoc</code> will do the right thing in
separating this into the namespace and regular name.  Alternatively, one
can specify a namespace separately via the <code>namespace</code> argument.
This can be either a simple name or an internal namespace object defined
earlier.
</p>
<p>How do we define a default namespace?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlDoc(node, addFinalizer = TRUE)
newXMLDoc(dtd = "", namespaces=NULL, addFinalizer = TRUE, 
           name = character(), node = NULL, isHTML = FALSE)
newHTMLDoc(dtd = "loose", addFinalizer = TRUE, name = character(), 
            node = newXMLNode("html",
                               newXMLNode("head", addFinalizer = FALSE), 
                               newXMLNode("body", addFinalizer = FALSE),
                              addFinalizer = FALSE)) 
newXMLNode(name, ..., attrs = NULL, namespace = character(),
            namespaceDefinitions = character(),
             doc = NULL, .children = list(...), parent = NULL,
	     at = NA, cdata = FALSE,
             suppressNamespaceWarning =
                 getOption("suppressXMLNamespaceWarning", FALSE),
             sibling = NULL, addFinalizer = NA,
              noNamespace = length(namespace) == 0 &amp;&amp; !missing(namespace),
               fixNamespaces = c(dummy = TRUE, default = TRUE))
newXMLTextNode(text, parent = NULL, doc = NULL, cdata = FALSE, 
                escapeEntities = is(text, "AsIs"), addFinalizer = NA)
newXMLCDataNode(text, parent = NULL, doc = NULL, at = NA, sep = "\n",
                   addFinalizer = NA)
newXMLCommentNode(text, parent = NULL, doc = NULL, at = NA, addFinalizer = NA)
newXMLPINode(name, text, parent = NULL, doc = NULL, at = NA, addFinalizer = NA)
newXMLDTDNode(nodeName, externalID = character(),
              systemID = character(), doc = NULL, addFinalizer = NA)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newXMLDoc_+3A_node">node</code></td>
<td>
<p>a <code>XMLInternalNode</code> object that will be copied to
create a subtree for a new document.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_dtd">dtd</code></td>
<td>
<p>the name of the DTD to use for the XML document.
Currently ignored!</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_namespaces">namespaces</code></td>
<td>
<p>a named character vector
with each element specifying a name space identifier and the
corresponding URI for that namespace
that are to be declared and used in the XML document, \
e.g. <code>c(shelp = "https://www.omegahat.net/XML/SHelp")</code></p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_addfinalizer">addFinalizer</code></td>
<td>
<p>a logical value indicating whether the
default finalizer routine should be registered to
free the internal xmlDoc when R no longer has a reference to this
external pointer object.
This can also be the name of a C routine or a reference
to a C routine retrieved using
<code><a href="base.html#topic+getNativeSymbolInfo">getNativeSymbolInfo</a></code>. </p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_name">name</code></td>
<td>
<p>the tag/element name for the XML node and
the for a Processing Instruction (PI) node, this is the &quot;target&quot;,
e.g. the identifier for the system for whose attention this PI node is intended.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_...">...</code></td>
<td>
<p>the children of this node. These can be other nodes created
earlier or R strings that are converted to text nodes and added as children
to this newly created node.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_attrs">attrs</code></td>
<td>
<p>a named list of name-value pairs to be used as 
attributes for the XML node.
One should not use this argument to define namespaces,
i.e. attributes of the form <code>xmlns:prefix='http:/...'</code>.
Instead, such definitions should be specified
ideally via the <code>namespaceDefinitions</code> argument,
or even the <code>namespace</code> argument.
The reason is that namespace definitions are special attributes
that are shared across nodes wherease regular attributes are
particular to a node. So a namespace needs to be explicitly defined
so that the XML representation can recognize it as such.
</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_namespace">namespace</code></td>
<td>
<p>a character vector specifying the namespace for this
new node.
Typically this is used to specify  i) the prefix
of the namespace to use, or ii) one or more namespace definitions,
or iii) a combination of both.
If this is a character vector with a) one element
and b) with an empty <code>names</code> attribute
and c) whose value does not start with <code>http:/</code> or
<code>ftp:/</code>, then it is assumed that the value is a
namespace prefix for a namespace defined in an ancestor node.
To be able to resolve this prefix to a namespace definition,
<code>parent</code> must be specified so that we can traverse the chain of ancestor nodes.
However, if c) does not hold, i.e. the string starts with <code>http:/</code> or
<code>ftp:/</code>,
then we take this single element to be a namespace definition and
the since it has no name b), this is the definition for the default namespace for this
new node, i.e. corresponding to <code>xmlns='http:/...'</code>.
It is cumbersome to specify <code>""</code> as a  name for an element in a
character vector (as <code>c('' = 'value') gives an unnecessary
      error!</code>.
Elements with names are expanded to namespace definitions
with the name as the prefix and the value as the namespace URI.
</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_doc">doc</code></td>
<td>
<p>the <code>XMLInternalDocument</code> object created with
<code>newXMLDoc</code> that is used to root the node.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_.children">.children</code></td>
<td>
<p>a list containing XML node elements or content.
This is an alternative form of specifying the child nodes than ...
which is useful for programmatic interaction when the &quot;sub&quot;-content is
already in a list rather than a loose collection of values.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_text">text</code></td>
<td>
<p>the text content for the new XML node</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_nodename">nodeName</code></td>
<td>
<p>the name of the node to put in the DOCTYPE element
that will appear as the top-most node in the XML document.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_externalid">externalID</code></td>
<td>
<p>the PUBLIC identifier for the document type.
This is a string of the form <code>A//B//C//D</code>.
A is either + or -; B identifies the person or insitution that defined
the format (i.e. the &quot;creator&quot;);
C is the name of the format; and language is an encoding for the
language that comes from the ISO 639 document.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_systemid">systemID</code></td>
<td>
<p>the SYSTEM identifier for the DTD for the document.
This is a URI</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_namespacedefinitions">namespaceDefinitions</code></td>
<td>
<p>a character vector or a list
with each element being a string.
These give the URIs identifying the namespaces uniquely.
The elements should have names which are used as prefixes.
A default namespace has &quot;&quot; as the name.
This argument can be used to remove any ambiguity
that arises when specifying a single string
with no names attribute as the value for <code>namespace</code>.
The values here are used only for defining new namespaces
and not for determining the namespace to use for this
particular node.
</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_parent">parent</code></td>
<td>
<p>the node which will act as the parent of this newly
created node. This need not be specified and one can add the new node
to another node in a separate operation via
<code><a href="#topic+addChildren">addChildren</a></code>.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_sibling">sibling</code></td>
<td>
<p>if this is specified (rather than <code>parent</code>)
this should be an <code>XMLInternalNode</code> and the new node is added as
a sibling of this node, after this node, i.e. to the right.
This is just a convenient form of <code>parent = xmlParent(node)</code>.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_cdata">cdata</code></td>
<td>
<p>a logical value indicating whether to enclose the text
within a CDATA node (<code>TRUE</code>) or not (<code>FALSE</code>). This is a
convenience mechanism to avoid having to create the text node and
then the CDATA node.  If one is not certain what characters are in
the text,  it is useful to use <code>TRUE</code> to ensure that they are
&ldquo;escaped&rdquo;.
</p>
<p>It is an argument for <code>newXMLNode</code> as the child nodes can be
given as simple strings and are converted to text nodes. This
<code>cdata</code> value is passed to the calls to create these text nodes
and so controls whether they are enclosed within CDATA nodes.
</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_suppressnamespacewarning">suppressNamespaceWarning</code></td>
<td>
<p>see <code><a href="#topic+addChildren">addChildren</a></code></p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_at">at</code></td>
<td>
<p>this allows one to control the position in the list of children at which the node should be
added. The default means at the end and this can be any position
from 0 to the current number of children.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_sep">sep</code></td>
<td>
<p>when adding text nodes, this is used as an additional separator text to insert between the specified strings.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_escapeentities">escapeEntities</code></td>
<td>
<p>a logical value indicating whether to mark the 
internal text node in such a way that protects characters in its contents from
being escaped as entities when being serialized via
<code><a href="#topic+saveXML">saveXML</a></code></p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_nonamespace">noNamespace</code></td>
<td>
<p>a logical value that allows the caller to specify
that the new node has no namespace. This can avoid searching parent
and ancestor nodes up the tree for the default namespace.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_ishtml">isHTML</code></td>
<td>
<p>a logical value that indicates whether the XML document
being created is HTML or generic XML. This helps to create an object
that is identified as an HTML document.</p>
</td></tr>
<tr><td><code id="newXMLDoc_+3A_fixnamespaces">fixNamespaces</code></td>
<td>
<p>a logical vector controlling how namespaces in
child nodes are to be processed. The two entries should be named
<code>dummy</code> and <code>default</code>.  The <code>dummy</code> element controls
whether we process child nodes that have a namespace which was not
defined when the node was created. These are created as &ldquo;dummy&rdquo;
namespaces and can be resolved now that the parent node is defined and
the name space may be defined. When we know it is not yet defined, but
will be defined in an ancestor node, we can turn off this processing
with a value of <code>FALSE</code>.
</p>
<p>The <code>default</code> element controls how we process the child nodes
and give them the default name space defined in the parent or ancestor nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These create internal C level objects/structure instances
that can be added to a libxml DOM and subsequently
inserted into other document objects or &ldquo;serialized&rdquo;
to textual form.
</p>


<h3>Value</h3>

<p>Each function returns an R object that points to the
C-level structure instance.
These are of class <code>XMLInternalDocument</code>
and <code>XMLInternalNode</code>, respectively
</p>


<h3>Note</h3>

<p>These functions are used to build up an internal XML tree.
This can be used in the Sxslt package (<a href="https://www.omegahat.net/Sxslt/">https://www.omegahat.net/Sxslt/</a>)
when creating content in R that is to be dynamically inserted into an XML
document.</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTree">xmlTree</a></code>
<code>saveXML</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
doc = newXMLDoc()

 # Simple creation of an XML tree using these functions
top = newXMLNode("a")
newXMLNode("b", attrs = c(x = 1, y = 'abc'), parent = top)
newXMLNode("c", "With some text", parent = top)
d = newXMLNode("d", newXMLTextNode("With text as an explicit node"), parent = top)
newXMLCDataNode("x &lt;- 1\n x &gt; 2", parent = d)

newXMLPINode("R", "library(XML)", top)
newXMLCommentNode("This is a comment", parent = top)

o = newXMLNode("ol", parent = top)

kids = lapply(letters[1:3],
               function(x)
                  newXMLNode("li", x))
addChildren(o, kids)

cat(saveXML(top))


x = newXMLNode("block", "xyz", attrs = c(id = "bob"),
                      namespace = "fo",
                      namespaceDefinitions = c("fo" = "http://www.fo.org"))

xmlName(x, TRUE) == "fo"

  # a short cut to define a name space and make it the prefix for the
  # node, thus avoiding repeating the prefix via the namespace argument.
x = newXMLNode("block", "xyz", attrs = c(id = "bob"),
                      namespace = c("fo" = "http://www.fo.org"))


 # name space on the attribute
x = newXMLNode("block", attrs = c("fo:id" = "bob"),
                      namespaceDefinitions = c("fo" = "http://www.fo.org"))




x = summary(rnorm(1000))
d = xmlTree()
d$addNode("table", close = FALSE)

d$addNode("tr", .children = sapply(names(x), function(x) d$addNode("th", x)))
d$addNode("tr", .children = sapply(x, function(x) d$addNode("td", format(x))))

d$closeNode()


# Just doctype
z = xmlTree("people", dtd = "people")
# no public element
z = xmlTree("people", dtd = c("people", "", "https://www.omegahat.net/XML/types.dtd"))
# public and system
z = xmlTree("people", dtd = c("people", "//a//b//c//d", "https://www.omegahat.net/XML/types.dtd"))

# Using a DTD node directly.
dtd = newXMLDTDNode(c("people", "", "https://www.omegahat.net/XML/types.dtd"))
z = xmlTree("people", dtd = dtd)


x = rnorm(3)
z = xmlTree("r:data", namespaces = c(r = "http://www.r-project.org"))
z$addNode("numeric", attrs = c("r:length" = length(x)), close = FALSE)
lapply(x, function(v) z$addNode("el", x))
z$closeNode()
# should give   &lt;r:data&gt;&lt;numeric r:length="3"/&gt;&lt;/r:data&gt;


# shows namespace prefix on an attribute, and different from the one on the node.
z = xmlTree()
z$addNode("r:data",
         namespace = c(r = "http://www.r-project.org",
                       omg = "https://www.omegahat.net"),
         close = FALSE)
x = rnorm(3)
z$addNode("r:numeric", attrs = c("omg:length" = length(x)))


z = xmlTree("people", namespaces = list(r = "http://www.r-project.org"))
z$setNamespace("r")

z$addNode("person", attrs = c(id = "123"), close = FALSE)
z$addNode("firstname", "Duncan")
z$addNode("surname", "Temple Lang")
z$addNode("title", "Associate Professor")
z$addNode("expertize", close = FALSE)
z$addNode("topic", "Data Technologies")
z$addNode("topic", "Programming Language Design")
z$addNode("topic", "Parallel Computing")
z$addNode("topic", "Data Visualization")
z$closeTag()
z$addNode("address", "4210 Mathematical Sciences Building, UC Davis")



   # 
txt = newXMLTextNode("x &amp;lt; 1")
txt # okay
saveXML(txt) # x &amp;amp;lt; 1

   # By escaping the text, we ensure the entities don't
   # get expanded, i.e. &amp;lt; doesn't become &amp;amp;lt;
txt = newXMLTextNode(I("x &amp;lt; 1"))
txt # okay
saveXML(txt) # x &amp;lt; 1


newXMLNode("r:expr", newXMLTextNode(I("x &lt; 1")),
            namespaceDefinitions = c(r = "http://www.r-project.org"))

</code></pre>

<hr>
<h2 id='newXMLNamespace'>Add a namespace definition to an XML node</h2><span id='topic+newXMLNamespace'></span>

<h3>Description</h3>

<p>This function, and associated methods,
define a name space <code>prefix = URI</code> combination for the
given XML node.
It can also optionally make this name space the
default namespace for the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newXMLNamespace(node, namespace, prefix = names(namespace), set = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newXMLNamespace_+3A_node">node</code></td>
<td>
<p>the XML node for which the name space is to be defined.</p>
</td></tr>
<tr><td><code id="newXMLNamespace_+3A_namespace">namespace</code></td>
<td>
<p>the namespace(s).
This can be a simple character vector giving the URI,
a named character vector giving the prefix = URI pairs, with the prefixes being the names 
of the character vector,
or one or more (a list) of <code>XMLNamespace</code> objects, e.g. returned from a call to 
<code><a href="#topic+xmlNamespaceDefinitions">xmlNamespaceDefinitions</a></code></p>
</td></tr>
<tr><td><code id="newXMLNamespace_+3A_prefix">prefix</code></td>
<td>
 
<p>the prefixes to be associated with the URIs given in <code>namespace</code>.
</p>
</td></tr>
<tr><td><code id="newXMLNamespace_+3A_set">set</code></td>
<td>
<p>  a logical value indicating whether to 
set the  namespace for this node to this newly created name space definition.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An name space definition object whose class corresponds 
to the type of XML node given in <code>node</code>.
</p>


<h3>Note</h3>

<p>Currently, this only applies to XMLInternalNodes. This will be rectified shortly
and apply to RXMLNode and its non-abstract classes.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p> ~put references to the literature/web site here ~ </p>


<h3>See Also</h3>

<p>Constructors for different XML node types - <code>newXMLNode</code>
<code>xmlNode</code>.
<code><a href="#topic+newXMLNamespace">newXMLNamespace</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> foo = newXMLNode("foo")
 ns = newXMLNamespace(foo, "http://www.r-project.org", "r")
 as(ns, "character")
</code></pre>

<hr>
<h2 id='parseDTD'>Read a Document Type Definition (DTD)</h2><span id='topic+parseDTD'></span>

<h3>Description</h3>

<p>Represents the contents of a DTD as a user-level object containing the element and entity definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseDTD(extId, asText=FALSE, name="", isURL=FALSE, error = xmlErrorCumulator())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseDTD_+3A_extid">extId</code></td>
<td>
<p>The name of the file containing the DTD to be processed.</p>
</td></tr>
<tr><td><code id="parseDTD_+3A_astext">asText</code></td>
<td>
<p>logical indicating whether the value of &lsquo;extId&rsquo; is the name of a file
or the DTD content itself. Use this when the DTD is read as a character vector, before being parsed 
and handed to the parser as content only.</p>
</td></tr>
<tr><td><code id="parseDTD_+3A_name">name</code></td>
<td>
<p>Optional name to provide to the parsing mechanism.</p>
</td></tr>
<tr><td><code id="parseDTD_+3A_isurl">isURL</code></td>
<td>
<p>A logical value indicating whether the input source is to be
considred a URL or a regular file or string containing the XML.</p>
</td></tr>
<tr><td><code id="parseDTD_+3A_error">error</code></td>
<td>
<p>an R function that is called when an error is
encountered. This can report it and continue or terminate by raising
an error in R.  See the error parameter for <code>link{xmlTreeParse}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parses and converts the contents of the DTD in the specified file 
into a user-level object containing all the information about the DTD.
</p>


<h3>Value</h3>

<p>A list with two entries, one for the entities and the other for the elements
defined within the DTD.
</p>
<table>
<tr><td><code>entities</code></td>
<td>
<p>a named list of the entities defined in the DTD. 
Each entry is indexed by the name of the corresponding entity.
Each is an object of class <code>XMLEntity</code>
or alternatively <code>XMLExternalEntity</code> if the entity refers
to an external definition.
The fields of these types of objects are 
</p>

<dl>
<dt>name</dt><dd><p>the name of the entity by which users refer to it.</p>
</dd>
<dt>content</dt><dd><p>the expanded value or definition of the entity</p>
</dd>
<dt>original</dt><dd><p>the value of the entity, but with references to other entities not expanded, but
maintained in symbolic form.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>elements</code></td>
<td>
<p>a named list of the elements defined in the DTD, with the name of each element being
the identifier of the element being defined.
Each entry is an object of class <code>XMLElementDef</code>
which has 4 fields.
</p>

<dl>
<dt>name</dt><dd><p>the name of the element.</p>
</dd>
<dt>type</dt><dd><p>a named integer indicating the type of entry in the DTD, usually
either <code>element</code> or <code>mixed</code>.
The name of the value is a user-level type. The value is used for programming, both
internally and externally.
</p>
</dd>
<dt>contents</dt><dd><p>a description of the elements that can be nested within this element.
This is an object of class <code>XMLElementContent</code>
or one of its specializations - <code>XMLSequenceContent</code>, <code>XMLOrContent</code>.
Each of these encodes the number of such elements permitted 
(one, one or more, zero or one, or zero or more);
the type indicating whether the contents consist of a single element type,
an ordered sequence of elements, or one of a set of elements.
Finally, the actual contents description is described in the
<code>elements</code> field. This is a list of
one or more <code>XMLElementContent</code>, <code>XMLSequenceContent</code> and <code>XMLOrContent</code> 
objects.
</p>
</dd>
<dt>attributes</dt><dd><p>a named list of the attributes defined for this element in the DTD.
Each element is of class <code>XMLAttributeDef</code> which has 4 fields.
</p>
   
<dl>
<dt>name</dt><dd><p>name of the attribute, i.e. the left hand side</p>
</dd>
<dt>type</dt><dd><p>the type of the value, e.g. an CDATA, Id, Idref(s), Entity(s), NMToken(s),  Enumeration, Notation</p>
</dd>
<dt>defaultType</dt><dd><p>the defined type, one of  None, Implied, Fixed or Required.</p>
</dd>
<dt>defaultValue</dt><dd><p>the default value if it is specified, or the enumerated values as a character vector, if the type is Enumeration.</p>
</dd>
</dl>

</dd>
</dl>

</td></tr>
</table>


<h3>WARNING</h3>

<p>Errors in the DTD are stored as warnings for programmatic access.</p>


<h3>Note</h3>

<p>Needs libxml (currently version 1.8.7)</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang &lt;duncan@wald.ucdavis.edu&gt;</p>


<h3>References</h3>

 <p><a href="https://www.w3.org">https://www.w3.org</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>, 
WritingXML.html in the distribution.</p>


<h3>Examples</h3>

<pre><code class='language-R'> dtdFile &lt;- system.file("exampleData", "foo.dtd",package="XML")
 parseDTD(dtdFile)

txt &lt;- readLines(dtdFile)
txt &lt;- paste(txt,  collapse="\n")
d &lt;- parseDTD(txt, asText=TRUE)


## Not run: 
 url &lt;- "https://www.omegahat.net/XML/DTDs/DatasetByRecord.dtd"
 d &lt;- parseDTD(url, asText=FALSE)  

## End(Not run)
</code></pre>

<hr>
<h2 id='parseURI'>Parse a URI string into its elements</h2><span id='topic+parseURI'></span><span id='topic+URI-class'></span><span id='topic+coerce+2CURI+2Ccharacter-method'></span>

<h3>Description</h3>

<p>This breaks a URI given as a string into its different elements such as
protocol/scheme, host, port, file name, query.
This information can be used, for example, when constructing URIs
relative to a base URI.
</p>
<p>The return value is an S3-style object of class <code>URI</code>.
</p>
<p>This function uses libxml routines to perform the parsing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseURI(uri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseURI_+3A_uri">uri</code></td>
<td>
<p>a single string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 8 elements
</p>
<table>
<tr><td><code>scheme</code></td>
<td>
<p>the name of the protocol being used, http, ftp as a string.</p>
</td></tr>
<tr><td><code>authority</code></td>
<td>
<p>a string represeting a rarely used aspect of URIs</p>
</td></tr>
<tr><td><code>server</code></td>
<td>
<p>a string identifying the host, e.g. www.omegahat.net</p>
</td></tr>
<tr><td><code>user</code></td>
<td>
<p>a string giving the name of the user, e.g. in FTP
&quot;ftp://duncan@www.omegahat.net&quot;, this would yield &quot;duncan&quot;</p>
</td></tr>
<tr><td><code>path</code></td>
<td>
<p>a string identifying the path of the target file</p>
</td></tr>
<tr><td><code>query</code></td>
<td>
<p>the CGI query part of the string, e.g.
the bit after '?' of the form <code>name=value&amp;name=value</code></p>
</td></tr>
<tr><td><code>fragment</code></td>
<td>
<p>a string giving the coo</p>
</td></tr>
<tr><td><code>port</code></td>
<td>
<p>an integer identifying the port number on which the
connection is to be made</p>
</td></tr>    
</table>


<h3>See Also</h3>

<p><code><a href="#topic+getRelativeURL">getRelativeURL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  ## site is flaky
  parseURI("https://www.omegahat.net:8080/RCurl/index.html")
  parseURI("ftp://duncan@www.omegahat.net:8080/RCurl/index.html")

  parseURI("ftp://duncan@www.omegahat.net:8080/RCurl/index.html#my_anchor")

  as(parseURI("http://duncan@www.omegahat.net:8080/RCurl/index.html#my_anchor"), "character")

  as(parseURI("ftp://duncan@www.omegahat.net:8080/RCurl/index.html?foo=1&amp;bar=axd"), "character")

## End(Not run)</code></pre>

<hr>
<h2 id='parseXMLAndAdd'>Parse XML content and add it to a node</h2><span id='topic+parseXMLAndAdd'></span>

<h3>Description</h3>

<p>This function parses the given XML content as a string
by putting it inside a top-level node and then returns
the document or adds the children to the specified parent.
The motivation for this function is when we can use
string manipulation to efficiently create the  XML content
by using vectorized operations in R, but then
converting that content into parsed nodes.
</p>
<p>Generating XML/HTML content by glueing strings together
is a poor approach. It is often convenient, but rarely
good general software design. It makes for bad software that is not
very extensible and difficult to maintain and enhance.
Structure that it is
programmatically accessible is much better. The tree
approach provides this structure.
Using strings is convenient and somewhat appropriate when done
atomically for large amounts of highly regular content.
But then the results should be converted to the structured tree
so that they can be modified and extended.
This function facilitates using strings and returning structured content.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseXMLAndAdd(txt, parent = NULL, top = "tmp", nsDefs = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseXMLAndAdd_+3A_txt">txt</code></td>
<td>
<p>the XML content to parse</p>
</td></tr>
<tr><td><code id="parseXMLAndAdd_+3A_parent">parent</code></td>
<td>
<p>an XMLInternalNode to which the top-level nodes in
<code>txt</code> will be added as children</p>
</td></tr>
<tr><td><code id="parseXMLAndAdd_+3A_top">top</code></td>
<td>
<p>the name for the top-level node. If <code>parent</code> is
specified, this is used but irrelevant.</p>
</td></tr>
<tr><td><code id="parseXMLAndAdd_+3A_nsdefs">nsDefs</code></td>
<td>
<p>a character vector of name = value pairs giving
namespace definitions to be added to the top node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>parent</code> is <code>NULL</code>, the root node of the
parsed document is returned.  This will be an element
whose name is given by <code>top</code> unless the XML content in <code>txt</code>
is AsIs or <code>code</code> is empty.
</p>
<p>If <code>parent</code> is non-<code>NULL</code>, .
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newXMLNode">newXMLNode</a></code>
<code><a href="#topic+xmlParse">xmlParse</a></code>  
<code><a href="#topic+addChildren">addChildren</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  long = runif(10000, -122, -80)
  lat = runif(10000, 25, 48)

  txt = sprintf("&lt;Placemark&gt;&lt;Point&gt;&lt;coordinates&gt;%.3f,%.3f,0&lt;/coordinates&gt;&lt;/Point&gt;&lt;/Placemark&gt;",
                  long, lat)
  f = newXMLNode("Folder")
  parseXMLAndAdd(txt, f)
  xmlSize(f)


## Not run: 
      # this version is much slower as i) we don't vectorize the
      #  creation of the XML nodes, and ii) the parsing of the XML
      # as a string is very fast as it is done in C.
  f = newXMLNode("Folder")
  mapply(function(a, b) {
           newXMLNode("Placemark", 
                       newXMLNode("Point", 
                                   newXMLNode("coordinates", 
                                               paste(a, b, "0", collapse = ","))), 
		       parent = f)
           },
         long, lat) 
  xmlSize(f)


  o = c("&lt;x&gt;dog&lt;/x&gt;", "&lt;omg:x&gt;cat&lt;/omg:x&gt;")
  node = parseXMLAndAdd(o, nsDefs  = c("http://cran.r-project.org",
                                       omg = "https://www.omegahat.net"))
  xmlNamespace(node[[1]])
  xmlNamespace(node[[2]])

  tt = newXMLNode("myTop")
  node = parseXMLAndAdd(o, tt, nsDefs  = c("http://cran.r-project.org",
                                           omg = "https://www.omegahat.net"))
  tt

## End(Not run)


</code></pre>

<hr>
<h2 id='print.XMLAttributeDef'>Methods for displaying XML objects</h2><span id='topic+print.XMLAttributeDef'></span><span id='topic+print.XMLCDataNode'></span><span id='topic+print.XMLElementContent'></span><span id='topic+print.XMLElementDef'></span><span id='topic+print.XMLEntity'></span><span id='topic+print.XMLEntityRef'></span><span id='topic+print.XMLNode'></span><span id='topic+print.XMLTextNode'></span><span id='topic+print.XMLComment'></span><span id='topic+print.XMLOrContent'></span><span id='topic+print.XMLSequenceContent'></span><span id='topic+print.XMLProcessingInstruction'></span>

<h3>Description</h3>

<p>These different methods attempt to provide a convenient
way to display R objects representing XML elements
when they are printed in the usual manner on
the console, files, etc. via the <code><a href="base.html#topic+print">print</a></code>
function.
Each typically outputs its contents in the way
that they would appear in an XML document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XMLNode'
print(x, ..., indent= "", tagSeparator = "\n")
## S3 method for class 'XMLComment'
print(x, ..., indent = "", tagSeparator = "\n")
## S3 method for class 'XMLTextNode'
print(x, ..., indent = "", tagSeparator = "\n")
## S3 method for class 'XMLCDataNode'
print(x, ..., indent="", tagSeparator = "\n")
## S3 method for class 'XMLProcessingInstruction'
print(x, ..., indent="", tagSeparator = "\n")
## S3 method for class 'XMLAttributeDef'
print(x, ...)
## S3 method for class 'XMLElementContent'
print(x, ...)
## S3 method for class 'XMLElementDef'
print(x, ...)
## S3 method for class 'XMLEntity'
print(x, ...)
## S3 method for class 'XMLEntityRef'
print(x, ..., indent= "", tagSeparator = "\n")
## S3 method for class 'XMLOrContent'
print(x, ...)
## S3 method for class 'XMLSequenceContent'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.XMLAttributeDef_+3A_x">x</code></td>
<td>
<p>the XML object to be displayed</p>
</td></tr>
<tr><td><code id="print.XMLAttributeDef_+3A_...">...</code></td>
<td>
<p>additional arguments for controlling the output from
print. Currently unused.</p>
</td></tr>
<tr><td><code id="print.XMLAttributeDef_+3A_indent">indent</code></td>
<td>
<p>a prefix that is emitted before the node to indent it relative to its
parent and child nodes. This is appended with a space at each
succesive level of the tree.
If no indentation is desired (e.g. when <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
is called with <code>trim</code> and <code>ignoreBlanks</code>
being <code>FALSE</code>) and <code>TRUE</code> respectively,
one can pass the value <code>FALSE</code> for this <code>indent</code> argument.
</p>
</td></tr>
<tr><td><code id="print.XMLAttributeDef_+3A_tagseparator">tagSeparator</code></td>
<td>
<p>when printing nodes, successive nodes and children
are by default displayed on new lines for easier reading.
One can specify a string for this argument to control how the
elements are separated in the output.  The primary purpose of this
argument is to allow no space between the elements, i.e. a value of <code>""</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Currently, <code>NULL</code>.
</p>


<h3>Note</h3>

<p>We could make the node classes self describing with information
about whether <code>ignoreBlanks</code> was <code>TRUE</code> or <code>FALSE</code> and
if trim was TRUE or FALSE.
This could then be used to determine the appropriate values for
<code>indent</code> and <code>tagSeparator</code>. Adding an S3 class element
would allow this to be done without the addition of an excessive
number of classes.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org">https://www.w3.org</a>, <a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fileName &lt;- system.file("exampleData", "event.xml", package ="XML")

     # Example of how to get faithful copy of the XML.
  doc = xmlRoot(xmlTreeParse(fileName, trim = FALSE, ignoreBlanks = FALSE))
  print(doc, indent = FALSE, tagSeparator = "")

     # And now the default mechanism
  doc = xmlRoot(xmlTreeParse(fileName))
  print(doc)
</code></pre>

<hr>
<h2 id='processXInclude'>Perform the XInclude substitutions</h2><span id='topic+processXInclude'></span><span id='topic+processXInclude.list'></span><span id='topic+processXInclude.XMLInternalDocument'></span><span id='topic+processXInclude.XMLInternalElement'></span>

<h3>Description</h3>

<p>This function and its methods process the XInclude directives
within the document of the form <code>&lt;xi:include href="..."
    xpointer=".."</code>
and perform the actual substitution.
</p>
<p>These are only relevant for &quot;internal nodes&quot; as generated
via <code><a href="#topic+xmlInternalTreeParse">xmlInternalTreeParse</a></code> and
<code><a href="#topic+newXMLNode">newXMLNode</a></code> and their related functions.
When dealing with XML documents via <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
or <code><a href="#topic+xmlEventParse">xmlEventParse</a></code>, the XInclude nodes are controlled
during the parsing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processXInclude(node, flags = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processXInclude_+3A_node">node</code></td>
<td>
<p>an XMLInternalDocument object or an XMLInternalElement
node or a list of such internal nodes,
e.g. returned from <code><a href="#topic+xpathApply">xpathApply</a></code>.</p>
</td></tr>
<tr><td><code id="processXInclude_+3A_flags">flags</code></td>
<td>
<p>an integer value that provides information to control
how the XInclude substitutions are done, i.e. how they are parsed. This is a bitwise OR'ing
of some or all of the xmlParserOption values.
This will be turned into an enum in R in the future.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions are used for their side-effect to modify the
document and its nodes.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libxml2 <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a>
XInclude
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlInternalTreeParse">xmlInternalTreeParse</a></code>
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  f = system.file("exampleData", "include.xml", package = "XML")
  doc = xmlInternalTreeParse(f, xinclude = FALSE)

  cat(saveXML(doc))
  sects = getNodeSet(doc, "//section")
  sapply(sects, function(x) xmlName(x[[2]]))
  processXInclude(doc)

  cat(saveXML(doc))

  f = system.file("exampleData", "include.xml", package = "XML")
  doc = xmlInternalTreeParse(f, xinclude = FALSE)
  section1 = getNodeSet(doc, "//section")[[1]]

     # process 
  processXInclude(section1[[2]])
</code></pre>

<hr>
<h2 id='readHTMLList'>Read data in an HTML list or all lists in a document</h2><span id='topic+readHTMLList'></span><span id='topic+readHTMLList+2CHTMLInternalDocument-method'></span><span id='topic+readHTMLList+2CXMLInternalNode-method'></span><span id='topic+readHTMLList+2Ccharacter-method'></span>

<h3>Description</h3>

<p>This function and its methods are somewhat similar to
<code><a href="#topic+readHTMLTable">readHTMLTable</a></code> but read the contents of
lists in an HTML document.
We can specify the URL of the document or
an already parsed document or an individual node within the document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readHTMLList(doc, trim = TRUE, elFun = xmlValue, which = integer(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readHTMLList_+3A_doc">doc</code></td>
<td>
<p>the URL of the document or the parsed HTML document
or an individual node.</p>
</td></tr>
<tr><td><code id="readHTMLList_+3A_trim">trim</code></td>
<td>
<p>a logical value indicating whether we should
remove leading and trailing white space in each list item when
returning it</p>
</td></tr>
<tr><td><code id="readHTMLList_+3A_elfun">elFun</code></td>
<td>
<p>a function that is used to process each list item node
(<code>li</code>).
This provides an opportunity to customize how each node is processed,
for example accessing attributes on the list item or on its contents
such as links in the items.</p>
</td></tr>
<tr><td><code id="readHTMLList_+3A_which">which</code></td>
<td>
<p>an index or name which or vector of same which identifies
which list nodes to process in the overall document. This is for
subsetting particular lists rather than processing them all.</p>
</td></tr>
<tr><td><code id="readHTMLList_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+htmlParse">htmlParse</a></code>
and for the specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors or lists,
with one element for each list in the document.
If only one list is being read (by specifying <code>which</code> as a single
identifier), that is  returned as is.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readHTMLTable">readHTMLTable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  try(readHTMLList("https://www.omegahat.net"))
</code></pre>

<hr>
<h2 id='readHTMLTable'>Read data from one or more HTML tables</h2><span id='topic+readHTMLTable'></span><span id='topic+readHTMLTable+2Ccharacter-method'></span><span id='topic+readHTMLTable+2CHTMLInternalDocument-method'></span><span id='topic+readHTMLTable+2CXMLInternalElementNode-method'></span><span id='topic+coerce+2Ccharacter+2CFormattedInteger-method'></span><span id='topic+coerce+2Ccharacter+2CFormattedNumber-method'></span><span id='topic+coerce+2Ccharacter+2CPercent-method'></span><span id='topic+coerce+2Ccharacter+2CCurrency-method'></span><span id='topic+FormattedInteger-class'></span><span id='topic+FormattedNumber-class'></span><span id='topic+Percent-class'></span>

<h3>Description</h3>

<p>This function and its methods provide somewhat robust methods for
extracting data from HTML tables in an HTML document.
One can read all the tables in a document given by filename or (<code>http:</code>
or <code>ftp:</code>) URL,
or having already parsed the document via <code><a href="#topic+htmlParse">htmlParse</a></code>.
Alternatively, one can specify an individual <code>&lt;table&gt;</code>
node in the document.
</p>
<p>The methods attempt to do some heuristic computations to determine
the header labels for the columns, the name of the table, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readHTMLTable(doc, header = NA,
              colClasses = NULL, skip.rows = integer(), trim = TRUE,
              elFun = xmlValue, as.data.frame = TRUE, which = integer(),
               ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readHTMLTable_+3A_doc">doc</code></td>
<td>
<p>the HTML document which can be a file name or a URL
or an already parsed <code>HTMLInternalDocument</code>, or
an HTML node of class <code>XMLInternalElementNode</code>,
or a character vector containing the HTML content to parse and process.</p>
</td></tr>
<tr><td><code id="readHTMLTable_+3A_header">header</code></td>
<td>
<p>either a logical value indicating whether the table has
column labels, e.g. the first row or a <code>thead</code>, or alternatively
a character vector giving the names to use for the resulting columns.
This can be a logical vector and the individual values will be used
in turn for the different tables. This allows the caller to control
whether individual tables are processed as having column names.
Alternatively, one can read a specific table via the <code>which</code>
parameter and control how that is processed with a single scalar logical.
</p>
</td></tr>
<tr><td><code id="readHTMLTable_+3A_colclasses">colClasses</code></td>
<td>
<p>either a list or a vector that gives the names of
the data types for the different columns in the table, or
alternatively a function used to convert the string values to the
appropriate type.  A value of <code>NULL</code> means that we should drop
that column from the result.
Note that currently the conversion occurs before the
vectors are converted to a data frame (if <code>as.data.frame</code> is
<code>TRUE</code>).
As a result, to ensure that character vectors remain as characters
and not factors, use <code>stringsAsFactors = FALSE</code>.
This typically applies only to an individual table and so for the
method applied to a <code>XMLInternalElementNode</code> object.
</p>
<p>In addition to the usual &quot;integer&quot;, &quot;numeric&quot;, &quot;logical&quot;, &quot;character&quot;, etc.
names of R data types, one can use
&quot;FormattedInteger&quot;, &quot;FormattedNumber&quot; and &quot;Percent&quot; to specify that
format of the values are numbers possibly with commas (,) separating
groups of digits or a number followed by a percent sign (%).
This mechanism allows one to introduce new classes and specify these
as targets in <code>colClasses</code>.
</p>
</td></tr>
<tr><td><code id="readHTMLTable_+3A_skip.rows">skip.rows</code></td>
<td>
<p>an integer vector indicating which rows to ignore.</p>
</td></tr>
<tr><td><code id="readHTMLTable_+3A_trim">trim</code></td>
<td>
<p>a logical value indicating whether to remove leading and
trailing white space from the content cells.</p>
</td></tr>
<tr><td><code id="readHTMLTable_+3A_elfun">elFun</code></td>
<td>
<p>a function which, if specified, is called when converting
each cell. Currently, only the node is specified. In the future, we might 
additionally pass the index of the column so that the function has
some context, e.g. whether the value is a row label or a regular
value, or if the caller knows the type of columns.
</p>
</td></tr>
<tr><td><code id="readHTMLTable_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>a logical value indicating whether to turn the
resluting table(s) into data frames or leave them as matrices.
</p>
</td></tr>
<tr><td><code id="readHTMLTable_+3A_which">which</code></td>
<td>
<p>an integer vector identifying which tables to return from
within the document. This applies to the method for the document, not
individual tables.</p>
</td></tr>
<tr><td><code id="readHTMLTable_+3A_...">...</code></td>
<td>
<p>currently additional parameters that are passed on to
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> if <code>as.data.frame</code> is <code>TRUE</code>.
We may change this to use these as additional arguments for calls to
<code>elFun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the document (either by name or parsed tree) is specified,
the return vale is a list of data frames or matrices.
If a single HTML node is provided
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>HTML4.0 specification  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+htmlParse">htmlParse</a></code>
<code><a href="#topic+getNodeSet">getNodeSet</a></code>
<code><a href="#topic+xpathSApply">xpathSApply</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This changed to using https: in June 2015, and that is unsupported.
# u = "http://en.wikipedia.org/wiki/World_population"
 u = "https://en.wikipedia.org/wiki/List_of_countries_and_dependencies_by_population"

 tables = readHTMLTable(u)
 names(tables)

 tables[[2]]
  # Print the table. Note that the values are all characters
  # not numbers. Also the column names have a preceding X since
  # R doesn't allow the variable names to start with digits.
 tmp = tables[[2]]


   # Let's just read the second table directly by itself.
 doc = htmlParse(u)
 tableNodes = getNodeSet(doc, "//table")
 tb = readHTMLTable(tableNodes[[2]])

  # Let's try to adapt the values on the fly.
  # We'll create a function that turns a th/td node into a val
 tryAsInteger = function(node) {
                  val = xmlValue(node)
                  ans = as.integer(gsub(",", "", val))
                  if(is.na(ans))
                      val
                  else
                      ans
                }

 tb = readHTMLTable(tableNodes[[2]], elFun = tryAsInteger)

 tb = readHTMLTable(tableNodes[[2]], elFun = tryAsInteger,
                       colClasses = c("character", rep("integer", 9)))

## End(Not run)

zz =
  readHTMLTable("https://www.inflationdata.com/Inflation/Consumer_Price_Index/HistoricalCPI.aspx")
if(any(i &lt;- sapply(zz, function(x) if(is.null(x)) 0 else ncol(x)) == 14)) {
  # guard against the structure of the page changing.
    zz = zz[[which(i)[1]]]  # 4th table
    # convert columns to numeric.  Could use colClasses in the call to readHTMLTable()
    zz[-1] = lapply(zz[-1], function(x) as.numeric(gsub(".* ", "", as.character(x))))
    matplot(1:12, t(zz[-c(1, 14)]), type = "l")
}


# From Marsh Feldman on R-help, possibly
# https://stat.ethz.ch/pipermail/r-help/2010-March/232586.html
# That site was non-responsive in June 2015,
# and this does not do a good job on the current table.

## Not run: 
doc &lt;- "http://www.nber.org/cycles/cyclesmain.html"
# The  main table is the second one because it's embedded in the page table.
tables &lt;- getNodeSet(htmlParse(doc), "//table")
xt &lt;- readHTMLTable(tables[[2]],
                    header = c("peak","trough","contraction",
                               "expansion","trough2trough","peak2peak"),
                    colClasses = c("character","character","character",
                                   "character","character","character"),
                    trim = TRUE, stringsAsFactors = FALSE
                   )

## End(Not run)
if(FALSE) {
 # Here is a totally different way of reading tables from HTML documents.
 # The data are formatted using PRE and so can be read via read.table
 u = "http://tidesonline.nos.noaa.gov/data_read.shtml?station_info=9414290+San+Francisco,+CA"
 h = htmlParse(u)
 p = getNodeSet(h, "//pre")
 con = textConnection(xmlValue(p[[2]]))
 tides = read.table(con)
}

## Not run: 
## This is not accessible without authentication ...
u = "https://www.omegahat.net/RCurl/testPassword/table.html"
if(require(RCurl) &amp;&amp; url.exists(u)) {
  tt =  getURL(u, userpwd = "bob:duncantl")
  readHTMLTable(tt)
}
## End(Not run)
</code></pre>

<hr>
<h2 id='readKeyValueDB'>Read an XML property-list style document</h2><span id='topic+readKeyValueDB'></span><span id='topic+readKeyValueDB+2Ccharacter-method'></span><span id='topic+readKeyValueDB+2CXMLInternalDocument-method'></span><span id='topic+readKeyValueDB+2CXMLInternalNode-method'></span><span id='topic+readKeyValueDB+2CAsIs-method'></span>

<h3>Description</h3>

<p>This function and its methods reads an XML document
that is in the format of name-value or key-value
pairs made up of a <code>plist</code> and
<code>dict</code> nodes, each of which is made up <code>key</code>, and value node
pairs.  These used to be used for property lists on OS X and
can represetn arbitrary data relatively conveniently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readKeyValueDB(doc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readKeyValueDB_+3A_doc">doc</code></td>
<td>
<p>the object containing the data. This can be the name of a
file, a parsed XML document or an XML node.</p>
</td></tr>
<tr><td><code id="readKeyValueDB_+3A_...">...</code></td>
<td>
<p>additional parameters for the methods.
One can pass <code>dropComments</code> as a logical value to control
whether comment nodes are processed or ignored (<code>TRUE</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R object representing the data read from the XML content.
This is typically a named list or vector where the names are the keys
and the values are collected into an R &quot;container&quot;.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>Property lists.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readSolrDoc">readSolrDoc</a></code>,
<code><a href="#topic+xmlToList">xmlToList</a></code>,
<code><a href="#topic+xmlToDataFrame">xmlToDataFrame</a></code>,
<code><a href="#topic+xmlParse">xmlParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> if(file.exists("/usr/share/hiutil/Stopwords.plist")) {
  o = readKeyValueDB("/usr/share/hiutil/Stopwords.plist")
 }

 if(file.exists("/usr/share/java/Tools/Applet Launcher.app/Contents/Info.plist"))
    javaInfo = readKeyValueDB('/usr/share/java/Tools/Applet Launcher.app/Contents/Info.plist')
</code></pre>

<hr>
<h2 id='readSolrDoc'>Read the data from a Solr document</h2><span id='topic+readSolrDoc'></span><span id='topic+readSolrDoc+2CXMLInternalDocument-method'></span><span id='topic+readSolrDoc+2CXMLInternalNode-method'></span><span id='topic+readSolrDoc+2Ccharacter-method'></span><span id='topic+readSolrDoc+2CAsIs-method'></span>

<h3>Description</h3>

<p>Solr documents are used to represent
general data in a reasonably simple format
made up of lists, integers, logicals, longs,
doubles, dates, etc. each with an optional name.
These correspond very naturally to R objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSolrDoc(doc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSolrDoc_+3A_doc">doc</code></td>
<td>
<p>the object containing the data. This can be the name of a
file, a parsed XML document or an XML node.</p>
</td></tr>
<tr><td><code id="readSolrDoc_+3A_...">...</code></td>
<td>
<p>additional parameters for the methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An R object representing the data in the Solr document,
typically a named vector or named list.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>Lucene text search system.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+readKeyValueDB">readKeyValueDB</a></code>,
<code><a href="#topic+xmlToList">xmlToList</a></code>,
<code><a href="#topic+xmlToDataFrame">xmlToDataFrame</a></code>,
<code><a href="#topic+xmlParse">xmlParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = system.file("exampleData", "solr.xml", package = "XML")
readSolrDoc(f)
</code></pre>

<hr>
<h2 id='removeXMLNamespaces'>Remove namespace definitions from a XML node or document</h2><span id='topic+removeXMLNamespaces'></span><span id='topic+removeXMLNamespaces+2CXMLInternalNode-method'></span><span id='topic+removeXMLNamespaces+2CXMLInternalElementNode-method'></span><span id='topic+removeXMLNamespaces+2CXMLInternalDocument-method'></span>

<h3>Description</h3>

<p>This function and its methods allow one to remove one
or more XML namespace definitions on XML nodes within a document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeXMLNamespaces(node, ..., all = FALSE, .els = unlist(list(...)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeXMLNamespaces_+3A_node">node</code></td>
<td>
<p>an XMLInternalNode or XMLInternalDocument object</p>
</td></tr>
<tr><td><code id="removeXMLNamespaces_+3A_...">...</code></td>
<td>
<p>the names of the namespaces to remove or an
XMLNamespaceRef object returned via <code><a href="#topic+getNodeSet">getNodeSet</a></code> or <code><a href="#topic+xpathApply">xpathApply</a></code>.</p>
</td></tr>
<tr><td><code id="removeXMLNamespaces_+3A_all">all</code></td>
<td>
<p>a logical value indicating whether to remove all the
namespace definitions on a node.</p>
</td></tr>
<tr><td><code id="removeXMLNamespaces_+3A_.els">.els</code></td>
<td>
<p>a list which is sometimes a convenient way to specify the
namespaces to remove.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is used for its side-effects and changing the internal node.</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newXMLNamespace">newXMLNamespace</a></code>
</p>

<hr>
<h2 id='replaceNodeWithChildren'>Replace an XML node with it child nodes</h2><span id='topic+replaceNodeWithChildren'></span>

<h3>Description</h3>

<p>This function can be used to flatten parts of an XML tree.
This takes a node and removes itself from the tree, but places
its kids in it place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replaceNodeWithChildren(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replaceNodeWithChildren_+3A_node">node</code></td>
<td>
<p>an <code>XMLInternalNode</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>. The purpose of this function is to modify the internal document.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>libxml2 documentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>doc = xmlParse('&lt;doc&gt;
                 &lt;page&gt;
                  &lt;p&gt;A&lt;/p&gt;
                  &lt;p&gt;B&lt;/p&gt;
                  &lt;p&gt;C&lt;/p&gt;
                 &lt;/page&gt;
                 &lt;page&gt;
                  &lt;p&gt;D&lt;/p&gt;
                  &lt;p&gt;E&lt;/p&gt;
                  &lt;p&gt;F&lt;/p&gt;
                 &lt;/page&gt;
                &lt;/doc&gt;')

pages = getNodeSet(doc, "//page")
invisible(lapply(pages, replaceNodeWithChildren))
doc
</code></pre>

<hr>
<h2 id='saveXML'>Output internal XML Tree</h2><span id='topic+saveXML'></span><span id='topic+saveXML.XMLInternalDocument'></span><span id='topic+saveXML.XMLInternalDOM'></span><span id='topic+saveXML.XMLInternalNode'></span><span id='topic+saveXML.XMLNode'></span><span id='topic+saveXML.XMLOutputStream'></span><span id='topic+coerce+2CXMLInternalDocument+2Ccharacter-method'></span><span id='topic+coerce+2CXMLInternalDOM+2Ccharacter-method'></span><span id='topic+coerce+2CXMLInternalNode+2Ccharacter-method'></span><span id='topic+saveXML+2CXMLFlatTree-method'></span><span id='topic+saveXML+2CXMLInternalDocument-method'></span><span id='topic+saveXML+2CXMLInternalDOM-method'></span><span id='topic+saveXML+2CXMLInternalNode-method'></span><span id='topic+saveXML+2CXMLNode-method'></span><span id='topic+saveXML+2CXMLOutputStream-method'></span><span id='topic+saveXML+2CHTMLInternalDocument-method'></span>

<h3>Description</h3>

<p>Methods for writing the representation of an XML tree to a string or
file.
Originally this was intended to be used only for
DOMs (Document Object Models) stored in internal memory
created via <code><a href="#topic+xmlTree">xmlTree</a></code>, but methods for
<code>XMLNode</code>, <code>XMLInternalNode</code> and <code>XMLOutputStream</code>
objects
(and others)
allow it to be generic for different representations of the
XML tree.
</p>
<p>Note that the indentation when writing an internal C-based node
(XMLInternalNode) may not be as expected if there are text nodes
within the node.
</p>
<p>Also, not all the parameters are meaningful for all methods.
For example, compressing when writing to a string is not
supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveXML(doc, file=NULL, compression=0, indent=TRUE, prefix = '&lt;?xml version="1.0"?&gt;\n',
        doctype = NULL, encoding = getEncoding(doc), ...)
## S3 method for class 'XMLInternalDocument'
saveXML(doc, file=NULL, compression=0, indent=TRUE, prefix = '&lt;?xml version="1.0"?&gt;\n',
                            doctype = NULL, encoding =  getEncoding(doc), ...)
## S3 method for class 'XMLInternalDOM'
saveXML(doc, file=NULL, compression=0, indent=TRUE, prefix = '&lt;?xml version="1.0"?&gt;\n',
                       doctype = NULL, encoding =  getEncoding(doc), ...)
## S3 method for class 'XMLNode'
saveXML(doc, file=NULL, compression=0, indent=TRUE, prefix = '&lt;?xml version="1.0"?&gt;\n',
                 doctype = NULL, encoding = getEncoding(doc), ...)
## S3 method for class 'XMLOutputStream'
saveXML(doc, file=NULL, compression=0, indent=TRUE, prefix = '&lt;?xml version="1.0"?&gt;\n',
                         doctype = NULL, encoding = getEncoding(doc), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveXML_+3A_doc">doc</code></td>
<td>
<p>the document object representing the XML document.</p>
</td></tr>
<tr><td><code id="saveXML_+3A_file">file</code></td>
<td>
<p>the name of the file to which the contents of the XML
nodes will be serialized.</p>
</td></tr>
<tr><td><code id="saveXML_+3A_compression">compression</code></td>
<td>
<p>an integer value between 0 and 9 indicating the
level of compression to use when saving the file. Higher values
indicate increased compression and hence smaller files
at the expense of computational time to do the compression and decompression.</p>
</td></tr>
<tr><td><code id="saveXML_+3A_indent">indent</code></td>
<td>
<p>a logical value indicating whether to indent
the nested nodes when serializing to the stream.</p>
</td></tr>
<tr><td><code id="saveXML_+3A_prefix">prefix</code></td>
<td>
<p>a string that is written to the stream/connection before
the XML is output. If this is NULL, it is ignored. This allows us to
put the XML introduction/preamble at the beginning of the document
while allowing it to be omitted when we are outputting multiple
&quot;documents&quot; within a single stream.</p>
</td></tr>
<tr><td><code id="saveXML_+3A_doctype">doctype</code></td>
<td>
<p>an object identifying the elements for the DOCTYPE in the output.
This can be a string or an object of class <code>Doctype</code>.</p>
</td></tr>
<tr><td><code id="saveXML_+3A_encoding">encoding</code></td>
<td>
<p>a string indicating which encoding style to use.  This
is currently ignored except in the method in <code>Sxslt</code> for saving a
document generated by applying an XSL style sheet to an XML document.</p>
</td></tr>
<tr><td><code id="saveXML_+3A_...">...</code></td>
<td>
<p>extra parameters for specific methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One can create an internal XML tree (or DOM)
using <code><a href="#topic+newXMLDoc">newXMLDoc</a></code> and <code><a href="#topic+newXMLNode">newXMLNode</a></code>.
<code>saveXML</code> allows one to generate a textual representation of
that DOM in human-readable and reusable XML format.
<code>saveXML</code> is a generic function that allows one to call
the rendering operation with either the top-level node
of the DOM or of the document object (of class <code>XMLInternalDocument</code>
that is used to 
accumulate the nodes and with which the developer 
adds nodes.
</p>


<h3>Value</h3>

<p>If <code>file</code> is not specified, the result is a character string containing
the resulting XML content.
If <code>file</code> is passed in the call, 
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+newXMLDoc">newXMLDoc</a></code>
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
<code><a href="#topic+xmlOutputBuffer">xmlOutputBuffer</a></code>
<code><a href="#topic+xmlOutputDOM">xmlOutputDOM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 b = newXMLNode("bob")
 saveXML(b)

 f = tempfile()
 saveXML(b, f)
 doc = xmlInternalTreeParse(f)
 saveXML(doc)


con &lt;- xmlOutputDOM()
con$addTag("author", "Duncan Temple Lang")
con$addTag("address",  close=FALSE)
con$addTag("office", "2C-259")
con$addTag("street", "Mountain Avenue.")
con$addTag("phone", close=FALSE)
con$addTag("area", "908", attrs=c(state="NJ"))
con$addTag("number", "582-3217")
con$closeTag() # phone
con$closeTag() # address

saveXML(con$value(), file=file.path(tempdir(), "out.xml"))


# Work with entities

 f = system.file("exampleData", "test1.xml", package = "XML")
 doc = xmlRoot(xmlTreeParse(f))
 outFile = tempfile()
 saveXML(doc, outFile)
 alt = xmlRoot(xmlTreeParse(outFile))
 if(! identical(doc, alt) )
  stop("Problems handling entities!")

 con = textConnection("test1.xml", "w")
 saveXML(doc, con)
 close(con)
 alt = get("test1.xml")
 identical(doc, alt)



 x = newXMLNode("a", "some text", newXMLNode("c", "sub text"), "more text")

 cat(saveXML(x), "\n")

 cat(as(x, "character"), "\n")


     # Showing the prefix parameter
  doc = newXMLDoc()
  n = newXMLNode("top", doc = doc)
  b = newXMLNode("bar", parent = n)

     # suppress the &lt;?xml ...?&gt;
  saveXML(doc, prefix = character())

     # put our own comment in
  saveXML(doc, prefix = "&lt;!-- This is an alternative prefix --&gt;")
     # or use a comment node.
  saveXML(doc, prefix = newXMLCommentNode("This is an alternative prefix"))
</code></pre>

<hr>
<h2 id='SAXState-class'>A virtual base class defining methods for SAX parsing</h2><span id='topic+SAXState-class'></span>

<h3>Description</h3>

<p>This is a degenerate virtual class which others are
expected to sub-class  when they want to
use S4 methods as handler functions for SAX-based XML parsing.
The idea is that one can pass both i)  a collection of handlers
to <code><a href="#topic+xmlEventParse">xmlEventParse</a></code> which are simply 
the generic functions for the different SAX actions,
and ii) a suitable object to maintain state across
the different SAX calls.
This is used to perform the method dispatching to get
the appropriate behavior for the action.
Each of these methods is expected to return the
updated state object and the SAX parser
will pass this in the next callback.
</p>
<p>We define this class here so that we can provide
default methods for each of the different handler
actions. This allows other programmers to define
new classes to maintain state that are sub-class
of <code>SAXState</code> and then they do not have to
implement methods for each of the
different handlers.
</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>comment.SAX</dt><dd><p><code>signature(content = "ANY", .state = "SAXState")</code>: ... </p>
</dd>
<dt>endElement.SAX</dt><dd><p><code>signature(name = "ANY", .state = "SAXState")</code>: ... </p>
</dd>
<dt>entityDeclaration.SAX</dt><dd><p><code>signature(name = "ANY", base = "ANY", sysId = "ANY", publicId = "ANY", notationName = "ANY", .state = "SAXState")</code>: ... </p>
</dd>
<dt>processingInstruction.SAX</dt><dd><p><code>signature(target = "ANY", content = "ANY", .state = "SAXState")</code>: ... </p>
</dd>
<dt>startElement.SAX</dt><dd><p><code>signature(name = "ANY", atts = "ANY", .state = "SAXState")</code>: ... </p>
</dd>
<dt>text.SAX</dt><dd><p><code>signature(content = "ANY", .state = "SAXState")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlEventParse">xmlEventParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# For each element in the document, grab the node name
# and increment the count in an vector for this name.

# We define an S4 class named ElementNameCounter which
# holds the vector of frequency counts for the node names.

 setClass("ElementNameCounter",
             representation(elements = "integer"), contains = "SAXState")

# Define a method for handling the opening/start of any XML node
# in the SAX streams.

 setMethod("startElement.SAX",  c(.state = "ElementNameCounter"),
           function(name, atts, .state = NULL) {

             if(name %in% names(.state@elements))
                 .state@elements[name] = as.integer(.state@elements[name] + 1)
             else
                 .state@elements[name] = as.integer(1)
             .state
           })

 filename = system.file("exampleData", "eurofxref-hist.xml.gz", package = "XML")

# Parse the file, arranging to have our startElement.SAX method invoked.
 z = xmlEventParse(filename, genericSAXHandlers(),
                   state = new("ElementNameCounter"), addContext = FALSE)

 z@elements

  # Get the contents of all the comments in a character vector.

 setClass("MySAXState",
             representation(comments = "character"), contains = "SAXState")

 setMethod("comment.SAX",  c(.state = "MySAXState"),
           function(content, .state = NULL) {
             cat("comment.SAX called for MySAXState\n")
             .state@comments &lt;- c(.state@comments, content)
             .state
           })

 filename = system.file("exampleData", "charts.svg", package = "XML")
 st = new("MySAXState")
 z = xmlEventParse(filename, genericSAXHandlers(useDotNames = TRUE), state = st)
 z@comments


</code></pre>

<hr>
<h2 id='schema-class'>Classes for working with XML Schema</h2><span id='topic+ExternalReference-class'></span><span id='topic+SchemaAttributeGroupTable-class'></span><span id='topic+SchemaAttributeTable-class'></span><span id='topic+SchemaElementTable-class'></span><span id='topic+SchemaNotationTable-class'></span><span id='topic+SchemaTypeTable-class'></span><span id='topic+libxmlTypeTable-class'></span><span id='topic+xmlSchemaAttributeGroupRef-class'></span><span id='topic+xmlSchemaAttributeRef-class'></span><span id='topic+xmlSchemaElementRef-class'></span><span id='topic+xmlSchemaNotationRef-class'></span><span id='topic+xmlSchemaRef-class'></span><span id='topic+xmlSchemaTypeRef-class'></span><span id='topic+names+2CxmlSchemaRef-method'></span><span id='topic++24+2CxmlSchemaRef-method'></span><span id='topic+names+2ClibxmlTypeTable-method'></span><span id='topic++24+2ClibxmlTypeTable-method'></span><span id='topic++24+3C-+2ClibxmlTypeTable-method'></span><span id='topic+coerce+2ClibxmlTypeTable+2Clist-method'></span><span id='topic+show+2CXMLSchemaValidationResults-method'></span>

<h3>Description</h3>

<p>These are classes used when working with XML schema
and using them to validate a document or querying the
schema for its elements.
The basic representation is an external/native object stored in the
<code>ref</code> slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlSchemaValidate">xmlSchemaValidate</a></code>
</p>

<hr>
<h2 id='setXMLNamespace'>Set the name space on a node</h2><span id='topic+setXMLNamespace'></span>

<h3>Description</h3>

<p>This function sets the name space for an XML node, typically
an internal node. We can use it to either define a new namespace
and use that, or refer to a name space definition in an ancestor
of the current node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setXMLNamespace(node, namespace, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setXMLNamespace_+3A_node">node</code></td>
<td>
<p>the node on which the name space is to be set</p>
</td></tr>
<tr><td><code id="setXMLNamespace_+3A_namespace">namespace</code></td>
<td>
<p>the name space to use for the node. This can be a
name space prefix (string) defined in an ancestor node, or a named
character vector of the form <code>c(prefix = URI)</code> that defines a
new namespace on this node, or we can use a name space object
created with <code><a href="#topic+newXMLNamespace">newXMLNamespace</a></code>.</p>
</td></tr>
<tr><td><code id="setXMLNamespace_+3A_append">append</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>XMLNamespaceRef</code> which is a reference to the
native/internal/C-level name space object.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newXMLNamespace">newXMLNamespace</a></code>
</p>
<p><code><a href="#topic+removeXMLNamespaces">removeXMLNamespaces</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # define a new namespace
 e = newXMLNode("foo")
 setXMLNamespace(e, c("r" = "http://www.r-project.org"))

  # use an existing namespace on an ancestor node
 e = newXMLNode("top", namespaceDefinitions = c("r" = "http://www.r-project.org"))
 setXMLNamespace(e, "r")
 e

 
</code></pre>

<hr>
<h2 id='startElement.SAX'>Generic Methods for SAX callbacks</h2><span id='topic+startElement.SAX'></span><span id='topic+endElement.SAX'></span><span id='topic+text.SAX'></span><span id='topic+comment.SAX'></span><span id='topic+processingInstruction.SAX'></span><span id='topic+entityDeclaration.SAX'></span><span id='topic+.InitSAXMethods'></span><span id='topic+text.SAX+2CANY+2CSAXState-method'></span><span id='topic+comment.SAX+2CANY+2CSAXState-method'></span><span id='topic+endElement.SAX+2CANY+2CSAXState-method'></span><span id='topic+startElement.SAX+2CANY+2CANY+2CSAXState-method'></span><span id='topic+processingInstruction.SAX+2CANY+2CANY+2CSAXState-method'></span><span id='topic+entityDeclaration.SAX+2CANY+2CANY+2CANY+2CANY+2CANY+2CSAXState-method'></span>

<h3>Description</h3>

<p>This is a collection of generic functions
for which one can write methods
so that they are called in repsonse to
different SAX events.
The idea is that one defines methods for different
classes of the <code>.state</code> argument
and dispatch to different methods based on that
argument.
The functions represent the different SAX events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startElement.SAX(name, atts, .state = NULL)
endElement.SAX(name, .state = NULL)
comment.SAX(content, .state = NULL)
processingInstruction.SAX(target, content, .state = NULL)
text.SAX(content, .state = NULL)
entityDeclaration.SAX(name, base, sysId, publicId, notationName,  .state = NULL)
.InitSAXMethods(where = "package:XML")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="startElement.SAX_+3A_name">name</code></td>
<td>
<p>the name of the XML element or entity being declared</p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_atts">atts</code></td>
<td>
<p>named character vector of XML attributes</p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_content">content</code></td>
<td>
<p>the value/string in the processing instruction or comment</p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_target">target</code></td>
<td>
<p>the target of the processing instruction, e.g. the R in
<code>&lt;?R....&gt;</code></p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_base">base</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_sysid">sysId</code></td>
<td>
<p>the system identifier for this entity</p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_publicid">publicId</code></td>
<td>
<p>the public identifier for the entity</p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_notationname">notationName</code></td>
<td>
<p>name of the notation specification</p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_.state">.state</code></td>
<td>
<p>the state object on which the user-defined methods
should dispatch.</p>
</td></tr>
<tr><td><code id="startElement.SAX_+3A_where">where</code></td>
<td>
<p>the package in which the class and method definitions
should be defined. This is almost always unspecified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Each method should return the (potentially modified)
state value.
</p>


<h3>Note</h3>

<p> This no longer requires the Expat XML parser to be installed.
Instead, we use libxml's SAX parser.</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlEventParse">xmlEventParse</a></code>
</p>

<hr>
<h2 id='supportsExpat'> Determines which native XML parsers are being used.</h2><span id='topic+supportsExpat'></span><span id='topic+supportsLibxml'></span>

<h3>Description</h3>

<p>Use of the Gnome libxml and Expat parsers is supported
in this R/S XML package, but both need not be used when
compiling the package. These functions determine whether
each is available in the underlying native code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supportsExpat()
supportsLibxml()
</code></pre>


<h3>Details</h3>

<p>One might to use different parsers to test 
validity of a document in different ways and
to get different error messages. Additionally,
one parser may be more efficient than the other.
These methods allow one to write code in such
a way that one parser is preferred and is used
if it is available, but the other is used
if the first is not available.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the corresponding library
has been linked into the package.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlEventParse">xmlEventParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>     # use Expat if possible, otherwise libxml
  fileName &lt;- system.file("exampleData", "mtcars.xml", package="XML")
  xmlEventParse(fileName, useExpat = supportsExpat())
</code></pre>

<hr>
<h2 id='toHTML'>Create an HTML representation of the given R object, using
internal C-level nodes</h2><span id='topic+toHTML'></span><span id='topic+toHTML+2Cvector-method'></span><span id='topic+toHTML+2Cmatrix-method'></span><span id='topic+toHTML+2Ccall-method'></span>

<h3>Description</h3>

<p>This generic function and the associated methods are
intended to create an HTML tree that represents the
R object in some intelligent manner.
For example, we represent a vector as a table
and we represent a matrix also as a table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toHTML(x, context = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toHTML_+3A_x">x</code></td>
<td>
<p> the R object which is to be represented via an HTML tree </p>
</td></tr>
<tr><td><code id="toHTML_+3A_context">context</code></td>
<td>
<p>an object which provides context in which the node will
be used. This is currently arbitrary. It may be used, for example,
when creating HTML for R documentation and providing information
about variabes and functions that are available on that page
and so have internal links.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It would be nicer if we could pass additional arguments
to control whether the outer/parent layer is created,
e.g. when reusing code for a vector for a row of a matrix.
</p>


<h3>Value</h3>

<p>an object of class <code>XMLInternalNode</code>
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p>The <code>R2HTML</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> cat(as(toHTML(rnorm(10)), "character"))
</code></pre>

<hr>
<h2 id='toString.XMLNode'>Creates string representation of XML node</h2><span id='topic+toString.XMLNode'></span>

<h3>Description</h3>

<p>This creates a string from a hierarchical XML node and its children
just as it prints on the console or one might see it in
a document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'XMLNode'
toString(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toString.XMLNode_+3A_x">x</code></td>
<td>
<p>an object of class <code>XMLNode</code>.</p>
</td></tr>
<tr><td><code id="toString.XMLNode_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses a textConnection object using the name
.tempXMLOutput. Since this is global, it will overwrite
any existing object of that name! As a result, this
function cannot be used recursively in its present form.
</p>


<h3>Value</h3>

<p>A character vector with one element, that being the
string corresponding to the XML node's contents.
</p>


<h3>Note</h3>

<p> This requires the Expat XML parser to be installed. </p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlNode">xmlNode</a></code>
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- xmlRoot(xmlTreeParse(system.file("exampleData", "gnumeric.xml", package = "XML")))

 toString(x)
</code></pre>

<hr>
<h2 id='xmlApply'>Applies a function to each of the children of an XMLNode</h2><span id='topic+xmlApply'></span><span id='topic+xmlApply.XMLNode'></span><span id='topic+xmlApply.XMLDocument'></span><span id='topic+xmlApply.XMLDocumentContent'></span><span id='topic+xmlSApply'></span><span id='topic+xmlSApply.XMLNode'></span><span id='topic+xmlSApply.XMLDocument'></span><span id='topic+xmlSApply.XMLDocumentContent'></span>

<h3>Description</h3>

<p>These methods are simple wrappers for the 
<code><a href="base.html#topic+lapply">lapply</a></code> and <code><a href="base.html#topic+sapply">sapply</a></code> functions.
They operate on the 
sub-nodes of the XML node, and not on the fields of the node object itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlApply(X, FUN, ...)
## S3 method for class 'XMLNode'
xmlApply(X, FUN, ...)
## S3 method for class 'XMLDocument'
xmlApply(X, FUN, ...)
## S3 method for class 'XMLDocumentContent'
xmlApply(X, FUN, ...)
xmlSApply(X, FUN, ...)
## S3 method for class 'XMLNode'
xmlSApply(X, FUN, ...)
## S3 method for class 'XMLDocument'
xmlSApply(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlApply_+3A_x">X</code></td>
<td>
<p>the <code>XMLNode</code> on whose children the regular
<code><a href="base.html#topic+apply">apply</a></code> or <code><a href="base.html#topic+sapply">sapply</a></code> is to be performed</p>
</td></tr>
<tr><td><code id="xmlApply_+3A_fun">FUN</code></td>
<td>
<p>the function to apply to each child node. This is passed
directly to the relevant <code><a href="base.html#topic+apply">apply</a></code> function.</p>
</td></tr>
<tr><td><code id="xmlApply_+3A_...">...</code></td>
<td>
<p>additional arguments to be given to each invocation of
<code>FUN</code>. This is passed directly to the relevant <code><a href="base.html#topic+apply">apply</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is that obtained from calling 
the <code><a href="base.html#topic+apply">apply</a></code> or <code><a href="base.html#topic+sapply">sapply</a></code>
on <code>xmlChildren(x)</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>,
<a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlChildren">xmlChildren</a></code>
<code><a href="#topic+xmlRoot">xmlRoot</a></code>
<code><a href="#topic++5B.XMLNode">[.XMLNode</a></code>
<code><a href="base.html#topic+sapply">sapply</a></code>
<code><a href="base.html#topic+lapply">lapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> doc &lt;- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
 r &lt;- xmlRoot(doc)
 xmlSApply(r[[2]], xmlName)

 xmlApply(r[[2]], xmlAttrs)

 xmlSApply(r[[2]], xmlSize)

</code></pre>

<hr>
<h2 id='XMLAttributes-class'>Class <code>"XMLAttributes"</code></h2><span id='topic+XMLAttributes-class'></span><span id='topic++5B+2CXMLAttributes-method'></span><span id='topic+show+2CXMLAttributes-method'></span>

<h3>Description</h3>

<p>A simple class to represent a named character vector of XML
attributes some of which may have a namespace.
This maintains the name space</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("XMLAttributes", ...)</code>.
These are typically generated via a call to <code><a href="#topic+xmlAttrs">xmlAttrs</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+character-class">character</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;character&quot;, distance 2.
Class <code>"<a href="methods.html#topic+data.frameRowLabels-class">data.frameRowLabels</a>"</code>, by class &quot;character&quot;, distance 2.
Class <code>"<a href="methods.html#topic+SuperClassMethod-class">SuperClassMethod</a>"</code>, by class &quot;character&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "XMLAttributes")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "XMLAttributes")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlAttrs">xmlAttrs</a></code>
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
<code><a href="#topic+xmlParse">xmlParse</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  nn = newXMLNode("foo", attrs = c(a = "123", 'r:show' = "true"),
                   namespaceDefinitions = c(r = "http://www.r-project.org"))
  a = xmlAttrs(nn)
  a["show"]
</code></pre>

<hr>
<h2 id='xmlAttributeType'>The type of an XML attribute for element from the DTD</h2><span id='topic+xmlAttributeType'></span>

<h3>Description</h3>

<p>This examines the definition of the 
attribute, usually returned by parsing the DTD with
<code><a href="#topic+parseDTD">parseDTD</a></code> and determines 
its type from the possible values:
Fixed, string data, implied, 
required,  an identifier, 
an identifier reference, a list of identifier references,
an entity, a list of entities, 
a name, a list of names, an element of enumerated set, 
a notation entity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlAttributeType(def, defaultType=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlAttributeType_+3A_def">def</code></td>
<td>
<p>the attribute definition object, usually retrieved from
the DTD via <code><a href="#topic+parseDTD">parseDTD</a></code>.</p>
</td></tr>
<tr><td><code id="xmlAttributeType_+3A_defaulttype">defaultType</code></td>
<td>
<p>whether to return the default value
if this attribute is defined as being a value from an enumerated set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string identifying the type for the sspecified attributed.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+parseDTD">parseDTD</a></code>
</p>

<hr>
<h2 id='xmlAttrs'> Get the list of attributes of an XML node. </h2><span id='topic+xmlAttrs'></span><span id='topic+xmlAttrs+3C-'></span><span id='topic+xmlAttrs.XMLElementDef'></span><span id='topic+xmlAttrs+3C-+2CXMLNode'></span><span id='topic+xmlAttrs+3C-+2CXMLInternalNode'></span><span id='topic+xmlAttrs+3C-+2CXMLNode-method'></span><span id='topic+xmlAttrs+3C-+2CXMLInternalElementNode-method'></span><span id='topic+xmlAttrs.XMLNode'></span><span id='topic+xmlAttrs.XMLInternalNode'></span>

<h3>Description</h3>

<p>This returns a named character vector giving the 
name-value pairs of attributes of an XMLNode object which is part of
an XML document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> xmlAttrs(node, ...)
 'xmlAttrs&lt;-'(node, append = TRUE, suppressNamespaceWarning =
              getOption("suppressXMLNamespaceWarning", FALSE), value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlAttrs_+3A_node">node</code></td>
<td>
<p>The <code>XMLNode</code> object
whose attributes are to be extracted. </p>
</td></tr>
<tr><td><code id="xmlAttrs_+3A_append">append</code></td>
<td>
<p>a logical value indicating whether to add the attributes in <code>value</code> to the existing attributes 
within the XML node, or to replace the set of any existing attributes with this new set, i.e. remove the existing ones and 
then set the attributes with the contents of <code>value</code>.</p>
</td></tr>
<tr><td><code id="xmlAttrs_+3A_...">...</code></td>
<td>
<p>additional arguments for the specific methods. For XML
internal nodes, these are <code>addNamespacePrefix</code> and
<code>addNamespaceURLs</code>. These are both logical values and indicate
whether to prepend the name of the attribute with the namespace
prefix and also whether to return the namespace prefix and URL as a
vector in the  <code>namespaces</code> attribute.</p>
</td></tr>
<tr><td><code id="xmlAttrs_+3A_value">value</code></td>
<td>
<p>a named character vector giving the new attributes to be
added to the node.</p>
</td></tr>
<tr><td><code id="xmlAttrs_+3A_suppressnamespacewarning">suppressNamespaceWarning</code></td>
<td>
<p>see <code><a href="#topic+addChildren">addChildren</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector, where the names
are the attribute names and the 
elements are the corresponding values.
This corresponds to the (attr&lt;i&gt;, &quot;value&lt;i&gt;&quot;)
pairs in the XML tag
<code>&lt;tag attr1="value1"  attr2="value2"</code>
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org">https://www.w3.org</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+xmlChildren">xmlChildren</a></code>, <code><a href="#topic+xmlSize">xmlSize</a></code>,
<code><a href="#topic+xmlName">xmlName</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> fileName &lt;- system.file("exampleData", "mtcars.xml", package="XML") 
 doc &lt;- xmlTreeParse(fileName)

 xmlAttrs(xmlRoot(doc))

 xmlAttrs(xmlRoot(doc)[["variables"]])


 doc &lt;- xmlParse(fileName)
 d = xmlRoot(doc)

 xmlAttrs(d)
 xmlAttrs(d) &lt;- c(name = "Motor Trend fuel consumption data",
                  author = "Motor Trends")
 xmlAttrs(d)

   # clear all the attributes and then set new ones.
 removeAttributes(d)
 xmlAttrs(d) &lt;- c(name = "Motor Trend fuel consumption data",
                  author = "Motor Trends")


     # Show how to get the attributes with and without the prefix and
     # with and without the URLs for the namespaces.
  doc = xmlParse('&lt;doc xmlns:r="http://www.r-project.org"&gt;
                    &lt;el r:width="10" width="72"/&gt;
                    &lt;el width="46"/&gt;
                    &lt;/doc&gt;')

  xmlAttrs(xmlRoot(doc)[[1]], TRUE, TRUE)
  xmlAttrs(xmlRoot(doc)[[1]], FALSE, TRUE)
  xmlAttrs(xmlRoot(doc)[[1]], TRUE, FALSE)
  xmlAttrs(xmlRoot(doc)[[1]], FALSE, FALSE)
</code></pre>

<hr>
<h2 id='xmlChildren'> Gets the sub-nodes within an XMLNode object. </h2><span id='topic+xmlChildren'></span><span id='topic+xmlChildren+3C-'></span><span id='topic+xmlChildren.XMLNode'></span><span id='topic+xmlChildren.XMLInternalNode'></span><span id='topic+xmlChildren.XMLInternalDocument'></span><span id='topic+xmlChildren+3C-+2CXMLInternalNode-method'></span><span id='topic+xmlChildren+3C-+2CANY-method'></span>

<h3>Description</h3>

<p>These functions provide access to the children of the given
XML node.
The simple accessor returns a list of child XMLNode objects within an
XMLNode object.
</p>
<p>The assignment operator (<code>xmlChildren&lt;-</code>) sets the
children of the node to the given value and returns the
updated/modified node.  No checking is currently done
on the type and values of the right hand side. This allows
the children of the node to be arbitrary R objects.  This can
be useful but means that one cannot rely on any structure in a node
being present..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlChildren(x, addNames= TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlChildren_+3A_x">x</code></td>
<td>
<p>an object of class XMLNode.</p>
</td></tr>
<tr><td><code id="xmlChildren_+3A_addnames">addNames</code></td>
<td>
<p>a logical value indicating whether to add the XML
names of the nodes as names of the R list.
This is only relevant for XMLInternalNode objects as XMLNode objects
in R already have R-level names.
</p>
</td></tr>
<tr><td><code id="xmlChildren_+3A_...">...</code></td>
<td>
<p>additional arguments for the particular methods,
e.g. <code>omitTypes</code> for an XMLInternalNode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose elements are sub-nodes of the user-specified
XMLNode. These are also of class XMLNode.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlChildren">xmlChildren</a></code>,<code><a href="#topic+xmlSize">xmlSize</a></code>,
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fileName &lt;- system.file("exampleData", "mtcars.xml", package="XML")
  doc &lt;- xmlTreeParse(fileName)
  names(xmlChildren(doc$doc$children[["dataset"]]))
</code></pre>

<hr>
<h2 id='xmlCleanNamespaces'>Remove redundant namespaces on an XML document</h2><span id='topic+xmlCleanNamespaces'></span>

<h3>Description</h3>

<p>This is a convenience function that removes redundant
repeated namespace definitions in an XML node.
It removes namespace definitions in nodes
where an ancestor node also has that definition.
It does not remove unused namespace definitions.
</p>
<p>This uses the <code>NSCLEAN</code> option for <code><a href="#topic+xmlParse">xmlParse</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlCleanNamespaces(doc, options = integer(), out = docName(doc), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlCleanNamespaces_+3A_doc">doc</code></td>
<td>
<p>either the name of an XML documentor the XML content
itself, or an already parsed document</p>
</td></tr>
<tr><td><code id="xmlCleanNamespaces_+3A_options">options</code></td>
<td>
<p>options for the XML parser. <code>NSCLEAN</code> is added to this.</p>
</td></tr>
<tr><td><code id="xmlCleanNamespaces_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+xmlParse">xmlParse</a></code></p>
</td></tr>
<tr><td><code id="xmlCleanNamespaces_+3A_out">out</code></td>
<td>
<p>the name of a file to which to write the resulting XML
document, or an empty character vector or logical value <code>FALSE</code>
to avoid writing the new document.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the new document is written to a file, the name of the file is
returned.
Otherwise, the new parsed XML document is returned.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>libxml2 documentation <a href="http://xmlsoft.org/html/libxml-parser.html">http://xmlsoft.org/html/libxml-parser.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlParse">xmlParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = system.file("exampleData", "redundantNS.xml", package = "XML")
doc = xmlParse(f)
print(doc)
newDoc = xmlCleanNamespaces(f, out = FALSE)
</code></pre>

<hr>
<h2 id='xmlClone'>Create a copy of an internal XML document or node</h2><span id='topic+xmlClone'></span><span id='topic+xmlClone+2CXMLInternalNode-method'></span><span id='topic+xmlClone+2CXMLInternalDocument-method'></span>

<h3>Description</h3>

<p>These methods allow the caller to create a copy of
an XML internal node.  This is useful, for example, if we want to use
the node or document in an  additional context, e.g.
put the node into another document while leaving it in the
existing document.  Similarly, if we want to remove nodes to simplify
processing, we probably want to copy it so that the changes are not
reflected in the original document.
</p>
<p>At present, the newly created object is not garbage collected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlClone(node, recursive = TRUE, addFinalizer = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlClone_+3A_node">node</code></td>
<td>
<p>the object to be cloned</p>
</td></tr>
<tr><td><code id="xmlClone_+3A_recursive">recursive</code></td>
<td>
<p>a logical value indicating whether the
entire object and all its descendants should be duplicated/cloned (<code>TRUE</code>)
or just the top-level object (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="xmlClone_+3A_addfinalizer">addFinalizer</code></td>
<td>
<p>typically a logical value indicating whether to bring this
new object under R's regular garbage collection.
This can also be a reference to a C routine which is to be used as
the finalizer. See <code><a href="base.html#topic+getNativeSymbolInfo">getNativeSymbolInfo</a></code>.
</p>
</td></tr>
<tr><td><code id="xmlClone_+3A_...">...</code></td>
<td>
<p>additional parameters for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new R object representing the object.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libxml2</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlParse">xmlParse</a></code>  
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
<code><a href="#topic+newXMLDoc">newXMLDoc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>doc =
xmlParse(paste0('&lt;doc&gt;&lt;author id="dtl"&gt;&lt;firstname&gt;Duncan&lt;/firstname&gt;',
               '&lt;surname&gt;Temple Lang&lt;/surname&gt;&lt;/author&gt;&lt;/doc&gt;'))

  au = xmlRoot(doc)[[1]]
     # make a copy
  other = xmlClone(au)
     # change it slightly
  xmlAttrs(other) = c(id = "dtl2")
     # add it to the children
  addChildren(xmlRoot(doc), other)
</code></pre>

<hr>
<h2 id='XMLCodeFile-class'>Simple classes for identifying an XML document containing R code</h2><span id='topic+XMLCodeFile-class'></span><span id='topic+XMLCodeDoc-class'></span><span id='topic+xmlCodeFile'></span><span id='topic++5B+5B+2CXMLCodeFile-method'></span><span id='topic++5B+5B+2CXMLCodeFile+2CANY-method'></span><span id='topic+coerce+2CXMLCodeFile+2CXMLCodeDoc-method'></span><span id='topic+coerce+2Ccharacter+2CXMLCodeDoc-method'></span><span id='topic+coerce+2Ccharacter+2CXMLCodeFile-method'></span><span id='topic+source+2CXMLCodeFile-method'></span>

<h3>Description</h3>

<p>These two classes allow the user to identify an XML document or file
as containing R code (amongst other content). Objects of either of these
classes can then be passed to <code><a href="base.html#topic+source">source</a></code> to read the 
code into R and also used in <code>link{xmlSource}</code> to read just parts of it.
<code>XMLCodeFile</code> represents the file by its name;
<code>XMLCodeDoc</code> parses the contents of the file when the R object is created.
Therefore, an <code>XMLCodeDoc</code> is a snapshot of the contents at a moment in time
while an <code>XMLCodeFile</code> object re-reads the file each time and so reflects
any &quot;asynchronous&quot; changes.
</p>


<h3>Objects from the Class</h3>

<p>One can create these objects using coercion methods, e.g
<code>as("file/name", "XMLCodeFile")</code>
or  <code>as("file/name", "XMLCodeDoc")</code>.
One can also use  <code>xmlCodeFile</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+character-class">character</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;character&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>[[</dt><dd><p><code>signature(x = "XMLCodeFile", i = "ANY", j = "ANY")</code>: 
this method allows one to retrieve/access an individual R code element
in the XML document. This is typically done by specifying the value of the XML element's 
&quot;id&quot; attribute.
</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "XMLCodeFile", to = "XMLCodeDoc")</code>:
parse the XML document from the &quot;file&quot; and treat the result as a
<code>XMLCodeDoc</code> object. 
</p>
</dd>
<dt>source</dt><dd><p><code>signature(file = "XMLCodeFile")</code>: read and evaluate all the
R code in the XML document. For more control, use <code><a href="#topic+xmlSource">xmlSource</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlSource">xmlSource</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> src =  system.file("exampleData", "Rsource.xml", package = "XML")
   # mark the string as an XML file containing R code
 k = xmlCodeFile(src)

   # read and parse the code, but don't evaluate it.
 code = xmlSource(k, eval = FALSE)

   # read and evaluate the code in a special environment.
 e = new.env()
 ans = xmlSource(k, envir = e)
 ls(e)
</code></pre>

<hr>
<h2 id='xmlContainsEntity'>Checks if an entity is defined within a DTD.</h2><span id='topic+xmlContainsEntity'></span><span id='topic+xmlContainsElement'></span>

<h3>Description</h3>

<p>A DTD contains entity and element definitions.
These functions test whether a DTD contains a definition
for a particular named element or entity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlContainsEntity(name, dtd)
xmlContainsElement(name, dtd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlContainsEntity_+3A_name">name</code></td>
<td>
<p> The name of the element
or entity being queried.</p>
</td></tr>
<tr><td><code id="xmlContainsEntity_+3A_dtd">dtd</code></td>
<td>
<p> The DTD in which to search for the entry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+parseDTD">parseDTD</a></code> for more information about
DTDs, entities and elements.
</p>


<h3>Value</h3>

<p>A logical value indicating whether the entry
was found in the appropriate list of 
entitiy or element definitions.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

 <p><code><a href="#topic+parseDTD">parseDTD</a></code>,
<code><a href="#topic+dtdEntity">dtdEntity</a></code>,
<code><a href="#topic+dtdElement">dtdElement</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'> dtdFile &lt;- system.file("exampleData", "foo.dtd", package="XML")
 foo.dtd &lt;- parseDTD(dtdFile)
 
  # Look for entities.
 xmlContainsEntity("foo", foo.dtd)
 xmlContainsEntity("bar", foo.dtd)

  # Now look for an element
 xmlContainsElement("record", foo.dtd)
</code></pre>

<hr>
<h2 id='xmlDOMApply'>Apply function to nodes in an XML tree/DOM.</h2><span id='topic+xmlDOMApply'></span>

<h3>Description</h3>

<p>This recursively applies the specified function to each node in an
XML tree, creating a new tree,
parallel to the original input tree.
Each  element in the new tree is the return
value obtained from invoking the specified function
on the corresponding element
of the original tree.
The order in which the function is recursively applied
is &quot;bottom-up&quot;. In other words, 
function is first applied to each of the children
nodes first and then to the  parent node
containing the newly computed results for the children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlDOMApply(dom, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlDOMApply_+3A_dom">dom</code></td>
<td>
<p>a node in the XML tree or DOM on which to recursively
apply the given function.
This should not be the <code>XMLDocument</code>
itself returned from
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
but an object of class <code>XMLNode</code>.
This is typically obtained by
calling <code><a href="#topic+xmlRoot">xmlRoot</a></code> on the
return value from <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>.
</p>
</td></tr>
<tr><td><code id="xmlDOMApply_+3A_func">func</code></td>
<td>
 
<p>the function to be applied to each node in the XML tree.
This is passed the node object for the and the return
value is inserted into the new tree that is to be returned
in the corresponding position as the node being processed.
If the return value is <code>NULL</code>, this node is dropped from the tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a native (C code) implementation that 
understands the structure of an XML DOM returned
from <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code> and iterates
over the nodes in that tree.
</p>


<h3>Value</h3>

<p>A tree that parallels the structure in the 
<code>dom</code> object passed to it.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><a href="#topic+xmlTreeParse">xmlTreeParse</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> dom &lt;- xmlTreeParse(system.file("exampleData","mtcars.xml", package="XML"))
 tagNames &lt;- function() {
    tags &lt;- character(0)
    add &lt;- function(x) {
      if(inherits(x, "XMLNode")) {
        if(is.na(match(xmlName(x), tags)))
           tags &lt;&lt;- c(tags, xmlName(x))
      }

      NULL
    }

    return(list(add=add, tagNames = function() {return(tags)}))
 }

 h &lt;- tagNames()
 xmlDOMApply(xmlRoot(dom), h$add) 
 h$tagNames()
</code></pre>

<hr>
<h2 id='xmlElementsByTagName'>Retrieve the children of an XML node with a specific tag name</h2><span id='topic+xmlElementsByTagName'></span>

<h3>Description</h3>

<p>This returns a list of the children or sub-elements of
an XML node whose tag name matches the one specified by
the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlElementsByTagName(el, name, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlElementsByTagName_+3A_el">el</code></td>
<td>
<p>the node whose matching children are to be retrieved.</p>
</td></tr>
<tr><td><code id="xmlElementsByTagName_+3A_name">name</code></td>
<td>
<p>a string giving the name of the tag to match in each of 
<code>el</code>'s children.</p>
</td></tr>
<tr><td><code id="xmlElementsByTagName_+3A_recursive">recursive</code></td>
<td>
<p>a logical value. If this is <code>FALSE</code>, the
default, only the direct child nodes are searched.
Alternatively, if this is <code>TRUE</code>,  all sub-nodes
at all levels  are searched. In other words,
we find all descendants of the node <code>el</code>
and return a list with the nodes having the given name.
The relationship between the nodes in the resulting list
cannot be determined. This is a set of nodes. See the note. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This does a simple matching of names and subsets the XML node's
children list.
If <code>recursive</code> is <code>TRUE</code>, then the function is applied
recursively to the children of the given node and so on.
</p>


<h3>Value</h3>

<p>A list containing those child nodes of <code>el</code> whose
tag name matches that specified by the user.
</p>


<h3>Note</h3>

<p>The addition of the <code>recursive</code> argument makes this
function behave like the <code>getElementsByTagName</code>
in other language APIs such as Java, C#.
However, one should be careful to understand that
in those languages, one would get back a set of
node objects. These nodes have references to their
parents and children. Therefore one can navigate the
tree from each node, find its relations, etc.
In the current version of this package (and for the forseeable
future),  the node set is a &ldquo;copy&rdquo; of the
nodes in the original tree. And these have no facilities
for finding their siblings or parent.
Additionally, one can consume a large amount of memory by taking
a copy of numerous large nodes using this facility.
If one does not modify the nodes, the extra memory may be small. But
modifying them means that the contents will be copied.
</p>
<p>Alternative implementations of the tree, e.g. using unique identifiers
for nodes or via internal data structures from libxml can allow us to
implement this function with different semantics, more similar to
the other APIs.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a>,
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlChildren">xmlChildren</a></code>
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 doc &lt;- xmlTreeParse("https://www.omegahat.net/Scripts/Data/mtcars.xml")
 xmlElementsByTagName(doc$children[[1]], "variable")

## End(Not run)

 doc &lt;- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
 xmlElementsByTagName(xmlRoot(doc)[[1]], "variable")
</code></pre>

<hr>
<h2 id='xmlElementSummary'>Frequency table of names of elements and attributes in XML content</h2><span id='topic+xmlElementSummary'></span>

<h3>Description</h3>

<p>This function is used to get an understanding of the use
of element and attribute names in an XML document.
It uses a collection of handler functions to gather 
the information via a SAX-style parser.  
The distribution of attribute names is done within each
&quot;type&quot; of element (i.e. element name)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlElementSummary(url, handlers = xmlElementSummaryHandlers(url))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlElementSummary_+3A_url">url</code></td>
<td>
<p>the source of the XML content, e.g. a file, a URL,  a
compressed file, or a character string</p>
</td></tr>
<tr><td><code id="xmlElementSummary_+3A_handlers">handlers</code></td>
<td>
<p>the list of handler functions used to collect the
information. These are passed to the function
<code><a href="#topic+xmlEventParse">xmlEventParse</a></code>
as the value for the <code>handlers</code> parameter.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements
</p>
<table>
<tr><td><code>nodeCounts</code></td>
<td>
<p>a named vector of counts where the names are the
(XML namespace qualified) element names in the XML content</p>
</td></tr>
<tr><td><code>attributes</code></td>
<td>
<p>a list with as many elements as there are elements
in the <code>nodeCounts</code> element of the result. Each element of this
sub-list gives the frequency counts for the different attributes seen within
the XML elements with that name.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlEventParse">xmlEventParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  xmlElementSummary(system.file("exampleData", "eurofxref-hist.xml.gz", package = "XML"))
</code></pre>

<hr>
<h2 id='xmlEventHandler'>Default handlers for the SAX-style event XML parser</h2><span id='topic+xmlEventHandler'></span>

<h3>Description</h3>

<p>This is a function that returns a closure instance 
containing the default handlers for use with 
<code><a href="#topic+xmlEventParse">xmlEventParse</a></code> for parsing XML documents
via the SAX-style parsing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlEventHandler()
</code></pre>


<h3>Details</h3>

<p>These handlers simply build up the DOM tree and thus 
perform the same job as <code>xmlTreeParse</code>.
It is here more as an example, reference and a base
that users can extend.
</p>


<h3>Value</h3>

<p>The return value is a list of functions
which are used as callbacks by the internal XML parser
when it encounters certain XML elements/structures.
These include items such as the start of an element,
end of an element, processing instruction, 
text node, comment, entity references and definitions, etc.
</p>
<table>
<tr><td><code>startElement</code></td>
<td>
</td></tr>
<tr><td><code>endElement</code></td>
<td>
</td></tr>
<tr><td><code>processingInstruction</code></td>
<td>
</td></tr>
<tr><td><code>text</code></td>
<td>
</td></tr>
<tr><td><code>comment</code></td>
<td>
</td></tr>
<tr><td><code>externalEntity</code></td>
<td>
</td></tr>
<tr><td><code>entityDeclaration</code></td>
<td>
</td></tr>
<tr><td><code>cdata</code></td>
<td>
</td></tr>
<tr><td><code>dom</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlEventParse">xmlEventParse</a></code>
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> xmlEventParse(system.file("exampleData", "mtcars.xml", package="XML"),
               handlers=xmlEventHandler())
</code></pre>

<hr>
<h2 id='xmlEventParse'> XML Event/Callback element-wise Parser</h2><span id='topic+xmlEventParse'></span>

<h3>Description</h3>

<p>This is the event-driven or SAX (Simple API for XML)
style parser which process XML without building the tree
but rather identifies tokens in the stream of characters
and passes them to handlers which can make sense of them
in context.
This reads and processes the contents of an XML file or string by
invoking user-level functions associated with different
components of the XML tree. These components include
the beginning and end  of XML elements, e.g
<code>&lt;myTag x="1"&gt;</code>
and <code>&lt;/myTag&gt;</code> respectively,
comments, CDATA (escaped character data), entities, processing
instructions, etc.
This allows the caller to create the appropriate data structure from the
XML document contents rather than the default tree (see
<a href="#topic+xmlTreeParse">xmlTreeParse</a>)
and so avoids having the entire document in memory.
This is important for large documents and where we would end up with
essentially 2 copies of the data in memory at once, i.e
the tree and the R data structure containing the information taken
from the tree.
When dealing with classes of XML documents whose instances could be large,
this approach is desirable but a little more cumbersome to program
than the standard DOM (Document Object Model) approach provided
by <code>XMLTreeParse</code>.
</p>
<p>Note that <code>xmlTreeParse</code> does  allow a hybrid style of
processing that allows us to apply handlers to nodes in the tree
as they are being converted to R objects.  This is a style of
event-driven or asynchronous calling
</p>
<p>In addition to the generic token event handlers such as
&quot;begin an XML element&quot; (the <code>startElement</code> handler), one can 
also provide handler functions for specific tags/elements such
as <code>&lt;myTag&gt;</code> with handler elements  with the same name as the
XML element of interest, i.e. <code>"myTag" = function(x, attrs)</code>.
</p>
<p>When the event parser is reading text nodes,
it may call the text handler function with different
sub-strings  of the text within the node.
Essentially, the parser collects up n characters into a buffer and
passes this as a single string the text handler and then continues
collecting more text until the buffer is full or there is no more text.
It passes each sub-string to the text handler.
If <code>trim</code> is <code>TRUE</code>, it removes leading and trailing white
space from the substring before calling the text handler. If the
resulting text is empty and <code>ignoreBlanks</code> is <code>TRUE</code>,
then we don't bother calling the text handler function.
</p>
<p>So the key thing to remember about dealing with text is that the
entire text of a node may come in multiple separate calls
to the text handler. A common idiom is to have the text handler
concatenate the values it is passed in separate calls and
to have the end element handler process the entire text and reset
the text variable to be empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlEventParse(file, handlers = xmlEventHandler(), 
               ignoreBlanks = FALSE, addContext=TRUE,
                useTagName = TRUE, asText = FALSE, trim=TRUE, 
                 useExpat=FALSE, isURL = FALSE,
                  state = NULL, replaceEntities = TRUE, validate = FALSE,
                   saxVersion = 1, branches = NULL,
                    useDotNames = length(grep("^\\.", names(handlers))) &gt; 0,
                     error = xmlErrorCumulator(), addFinalizer = NA,
                      encoding = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlEventParse_+3A_file">file</code></td>
<td>
<p>the source of the XML content.
This can be a string giving the name of a file or remote URL,
the XML itself, a connection object, or a function.
If this is a string, and <code>asText</code> is <code>TRUE</code>,
the value is the XML content.
This allows one to read the content separately from parsing
without having to write it to a file.
If <code>asText</code> is <code>FALSE</code> and a string is passed
for <code>file</code>, this is taken as the name of a
file or remote URI. If one is using the libxml parser (i.e. not expat),
this can be a URI accessed via HTTP or FTP or a compressed local file.
If it is the name of a local file,
it can include <code>~</code>, environment variables, etc. which will be expanded by R.
(Note this is not the case in S-Plus, as far as I know.)
</p>
<p>If a connection is given, the parser incrementally reads one line at
a time by calling the function <code><a href="base.html#topic+readLines">readLines</a></code> with
the connection as the first argument (and <code>1</code> as the number of
lines to read).  The parser calls this function each time it needs
more input.
</p>
<p>If invoking the <code>readLines</code> function to get each line is
excessively slow or is inappropriate, one can provide a function as the value
of <code>fileName</code>. Again, when the XML parser needs more content
to process, it invokes this function to get a string.
This function is called with a single argument, the maximum size
of the string that can be returned.
The function is responsible for accessing the correct connection(s),
etc. which is typically done via lexical scoping/environments.
This mechanism allows the user to control how the XML content
is retrieved in very general ways. For example, one might
read from a set of files, starting one when the contents
of the previous file have been consumed. This allows for the
use of hybrid connection objects.
</p>
<p>Support for connections and functions in this form is only
provided if one is using libxml2 and not libxml version 1.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_handlers">handlers</code></td>
<td>
<p> a closure object that contains  functions which will be invoked
as the XML components in the document are encountered by the parser. 
The standard function or handler names are
<code>startElement()</code>, <code>endElement()</code>
<code>comment()</code>, <code>getEntity</code>,
<code>entityDeclaration()</code>, <code>processingInstruction()</code>,
<code>text()</code>, <code>cdata()</code>,
<code>startDocument()</code>, and <code>endDocument()</code>,
or alternatively and preferrably,
these names  prefixed with a '.',
i.e. .startElement, .comment, ...
</p>
<p>The call signature for the entityDeclaration function was changed in
version 1.7-0.  Note that in earlier versions, the C routine did not
invoke any R function and so no code will actually break.
Also, we have renamed <code>externalEntity</code> to <code>getEntity</code>.
These were based on the expat parser.
</p>
<p>The new signature is
<code>c(name = "character",
        type = "integer",
	content = "",
        system = "character",
        public = "character"
)</code>
<code>name</code> gives the name of the entity being
defined.
The <code>type</code> identifies
the type of the entity using the value
of a C-level enumerated constant used in libxml2,
but also gives the human-readable form
as the name of the single element in the integer vector.
The possible values are
<code>"Internal_General"</code>,
<code>"External_General_Parsed"</code>,
<code>"External_General_Unparsed"</code>, <code>"Internal_Parameter"</code>,
<code>"External_Parameter"</code>, <code>"Internal_Predefined"</code>.
</p>
<p>If we are dealing with an internal entity,
the content will be the string containing
the value of the entity.
If we are dealing with an external entity,
then <code>content</code> will be a character vector of length
0, i.e. empty.
Instead, either or both of the system and public
arguments will be non-empty and identify the
location of the external content.
<code>system</code> will be a string containing a URI, if non-empty,
and <code>public</code> corresponds to the PUBLIC identifier used
to identify content using an SGML-like approach.
The use of PUBLIC identifiers is less common.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_ignoreblanks">ignoreBlanks</code></td>
<td>
<p>a logical value indicating whether
text elements made up entirely of white space should be included
in the resulting &lsquo;tree&rsquo;. </p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_addcontext">addContext</code></td>
<td>
<p> logical value indicating whether the callback functions 
in &lsquo;handlers&rsquo; should be invoked with contextual  information about
the parser and the position in the tree, such as node depth, 
path indices for the node relative the root, etc.
If this is True, each callback function  should support 
....
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_usetagname">useTagName</code></td>
<td>
<p> a logical value.
If this is <code>TRUE</code>, when the SAX parser signals an event for the
start of an XML element, it will first look for an element in the
list of handler functions whose name matches (exactly) the name of
the XML element.  If such an element is found, that function is
invoked.  Otherwise, the generic <code>startElement</code> handler function
is invoked.  The benefit of this is that the author of the handler
functions can write node-specific handlers for the different element
names in a document and not have to establish a mechanism to invoke
these functions within the <code>startElement</code> function. This is done
by the XML package directly.
</p>
<p>If the value is <code>FALSE</code>, then the <code>startElement</code> handler
function will be called without any effort to find a node-specific
handler.  If there are no node-specific handlers, specifying
<code>FALSE</code> for this parameter will make the computations very
slightly faster.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_astext">asText</code></td>
<td>
<p>logical value indicating that the first argument,
&lsquo;file&rsquo;, 
should be treated as the XML text to parse, not the name of 
a file. This allows the contents of documents to be retrieved 
from different sources (e.g. HTTP servers, XML-RPC, etc.) and still
use this parser.</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_trim">trim</code></td>
<td>

<p>whether to strip white space from the beginning and end of text strings.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_useexpat">useExpat</code></td>
<td>

<p>a logical value indicating whether to use the expat SAX parser,
or to default to the libxml.
If this is TRUE, the library must have been compiled with support for expat.
See <a href="#topic+supportsExpat">supportsExpat</a>.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_isurl">isURL</code></td>
<td>

<p>indicates whether the <code>file</code>  argument refers to a URL
(accessible via ftp or http) or a regular file on the system.
If <code>asText</code> is TRUE, this should not be specified.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_state">state</code></td>
<td>
<p>an optional S object that is passed to the
callbacks and can be modified to communicate state between
the callbacks. If this is given, the callbacks should accept
an argument  named <code>.state</code> and it should return an object
that will be used as the updated value of this state object.
The new value can be any S object and will be passed to the next 
callback where again it will be updated by that functions return
value, and so on. 
If this not specified in the call to <code>xmlEventParse</code>,
no <code>.state</code> argument is passed to the callbacks. This makes the
interface compatible with previous releases.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_replaceentities">replaceEntities</code></td>
<td>

<p>logical value indicating whether to substitute entity references
with their text directly. This should be left as False.
The text still appears as the value of the node, but there
is more information about its source, allowing the parse to be reversed
with full reference information.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_saxversion">saxVersion</code></td>
<td>
<p>an integer value which should be either 1 or 2.
This specifies which SAX interface to use in the C code.
The essential difference is the number of arguments passed to the
<code>startElement</code> handler function(s).  Under SAX 2, in addition to the name of
the element and the named-attributes vector, two additional arguments
are provided.
The first identifies the namespace of the element.
This is a named character vector of length 1,
with the value being the URI of the namespace and the name
being the prefix that identifies that namespace within the document.
For example, <code>xmlns:r="http://www.r-project.org"</code>
would be passed as <code>c(r = "http://www.r-project.org")</code>.
If there is no prefix because the namespace is being used as the
default, the result of calling <code><a href="base.html#topic+names">names</a></code> on
the string is <code>""</code>.
The second additional argument (the fourth in total) gives the collection of all the namespaces
defined within this element.
Again, this is a named character vector.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_validate">validate</code></td>
<td>

<p>Currently, this has no effect as the libxml2 parser uses a
document structure to do validation.
a logical indicating whether to use a validating parser or not, or in other words
check the contents against the DTD specification. If this is true, warning
messages will be displayed about errors in the DTD and/or document, but the parsing 
will proceed except for the presence of terminal errors.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_branches">branches</code></td>
<td>
<p>a named list of functions.
Each element identifies an XML element name.
If an XML element of that name is encountered in
the SAX stream, the stream is processed until the
end of that element and an internal node (see
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code> and its <code>useInternalNodes</code> parameter)
is created. The function in our branches list corresponding to this
XML element is then invoked with the (internal) node as the only
argument.
This allows one to use the DOM model on a sub-tree of the entire
document and thus use both SAX and DOM together to get the
efficiency of SAX and the simpler programming model of DOM.
</p>
<p>Note that the branches mechanism works top-down and does not
work for nested tags. If one specifies an element name in the
<code>branches</code> argument, e.g. myNode, and
there is a nested myNode instance within a branch, the branches
handler will not be called for that nested instance.
If there is an instance where this is problematic, please
contact the maintainer of this package.
</p>
<p>One can cause the parser to collect a branch without identifying
the  node within the <code>branches</code> list. Specifically, within
a  regular start-element handler, one can return a function 
whose class is <code>SAXBranchFunction</code>.
The SAX parser recognizes this and collects up the branch
starting at the current node being processed  and when it is
complete, invokes this function. 
This allows us to dynamically determine which nodes to treat as
branches rather than just matching names. This is necessary when
a node name has different meanings in different parts of the XML
hierarchy, e.g. dict in an iTunes song list.
</p>
<p>See the file <code>itunesSax2.R</code> inthe examples for an example of this.
</p>
<p>This is a two step process. In the future, we might make it so that
the R function handling the start-element event could directly
collect  the branch and continue its operations without having
to call another function asynchronously.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_usedotnames">useDotNames</code></td>
<td>
<p>a logical value
indicating whether to use the
newer format for identifying general element function handlers
with the '.' prefix, e.g. .text, .comment, .startElement.
If this is <code>FALSE</code>, then the older format
text, comment, startElement, ...
are used. This causes problems when there are indeed nodes
named text or comment or startElement as a
node-specific handler are confused with the corresponding
general handler of the same name. Using <code>TRUE</code>
means that your list of handlers should have names that use
the '.' prefix for these general element handlers.
This is the preferred way to write new code.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_error">error</code></td>
<td>
<p>a function that is called when an XML error is encountered.
This is called with 6 arguments and is described in <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>.
</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_addfinalizer">addFinalizer</code></td>
<td>
<p>a logical value or identifier for a C routine
that controls whether we register finalizers on the intenal node.</p>
</td></tr>
<tr><td><code id="xmlEventParse_+3A_encoding">encoding</code></td>
<td>
<p> a character string (scalar) giving the encoding for the
document.  This is optional as the document should contain its own
encoding information. However, if it doesn't, the caller can specify
this for the parser.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is now implemented using the libxml parser.
Originally, this was implemented via the Expat XML parser by
Jim Clark (<a href="http://www.jclark.com/">http://www.jclark.com/</a>).
</p>


<h3>Value</h3>

<p>The return value is the &lsquo;handlers&rsquo;
argument. It is assumed that this is a closure and that
the callback functions have manipulated variables
local to it and that the caller knows how to extract this.
</p>


<h3>Note</h3>

<p>The libxml parser can read URLs via http or ftp.
It does not require the support of <code>wget</code> as used
in other parts of <span class="rlang"><b>R</b></span>, but uses its own facilities
to connect to remote servers.
</p>
<p>The idea for the hybrid SAX/DOM mode where we consume tokens in the
stream to create an entire node for a sub-tree of the document was
first suggested to me by Seth Falcon at the Fred Hutchinson Cancer
Research Center.  It is similar to the  XML::Twig module in Perl
by Michel Rodriguez.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+xmlStopParser">xmlStopParser</a></code>
XMLParserContextFunction
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fileName &lt;- system.file("exampleData", "mtcars.xml", package="XML")

   # Print the name of each XML tag encountered at the beginning of each
   # tag.
   # Uses the libxml SAX parser.
 xmlEventParse(fileName,
                list(startElement=function(name, attrs){
                                    cat(name,"\n")
                                  }),
                useTagName=FALSE, addContext = FALSE)


## Not run: 
  # Parse the text rather than a file or URL by reading the URL's contents
  # and making it a single string. Then call xmlEventParse
xmlURL &lt;- "https://www.omegahat.net/Scripts/Data/mtcars.xml"
xmlText &lt;- paste(scan(xmlURL, what="",sep="\n"),"\n",collapse="\n")
xmlEventParse(xmlText, asText=TRUE)

## End(Not run)

    # Using a state object to share mutable data across callbacks
f &lt;- system.file("exampleData", "gnumeric.xml", package = "XML")
zz &lt;- xmlEventParse(f,
                    handlers = list(startElement=function(name, atts, .state) {
                                                     .state = .state + 1
                                                     print(.state)
                                                     .state
                                                 }), state = 0)
print(zz)




    # Illustrate the startDocument and endDocument handlers.
xmlEventParse(fileName,
               handlers = list(startDocument = function() {
                                                 cat("Starting document\n")
                                               },
                               endDocument = function() {
                                                 cat("ending document\n")
                                             }),
               saxVersion = 2)




if(libxmlVersion()$major &gt;= 2) {


 startElement = function(x, ...) cat(x, "\n")

 xmlEventParse(ff &lt;- file(f), handlers = list(startElement = startElement))
 close(ff)

 # Parse with a function providing the input as needed.
 xmlConnection = 
  function(con) {

   if(is.character(con))
     con = file(con, "r")
  
   if(isOpen(con, "r"))
     open(con, "r")

   function(len) {

     if(len &lt; 0) {
        close(con)
        return(character(0))
     }

      x = character(0)
      tmp = ""
    while(length(tmp) &gt; 0 &amp;&amp; nchar(tmp) == 0) {
      tmp = readLines(con, 1)
      if(length(tmp) == 0)
        break
      if(nchar(tmp) == 0)
        x = append(x, "\n")
      else
        x = tmp
    }
    if(length(tmp) == 0)
      return(tmp)
  
    x = paste(x, collapse="")

    x
  }
 }

 ## this leaves a connection open
 ## xmlConnection would need amending to return the connection.
 ff = xmlConnection(f)
 xmlEventParse(ff, handlers = list(startElement = startElement))
 

  # Parse from a connection. Each time the parser needs more input, it
  # calls readLines(&lt;con&gt;, 1)
 xmlEventParse(ff &lt;-file(f),  handlers = list(startElement = startElement))
 close(ff)

  # using SAX 2
 h = list(startElement = function(name, attrs, namespace, allNamespaces){ 
                                 cat("Starting", name,"\n")
                                 if(length(attrs))
                                     print(attrs)
                                 print(namespace)
                                 print(allNamespaces)
                         },
          endElement = function(name, uri) {
                          cat("Finishing", name, "\n")
            }) 
 xmlEventParse(system.file("exampleData", "namespaces.xml", package="XML"),
               handlers = h, saxVersion = 2)


 # This example is not very realistic but illustrates how to use the
 # branches argument. It forces the creation of complete nodes for
 # elements named &lt;b&gt; and extracts the id attribute.
 # This could be done directly on the startElement, but this just
 # illustrates the mechanism.
 filename = system.file("exampleData", "branch.xml", package="XML")
 b.counter = function() {
                nodes &lt;- character()
                f = function(node) { nodes &lt;&lt;- c(nodes, xmlGetAttr(node, "id"))}
                list(b = f, nodes = function() nodes)
             }

  b = b.counter()
  invisible(xmlEventParse(filename, branches = b["b"]))
  b$nodes()


  filename = system.file("exampleData", "branch.xml", package="XML")
   
  invisible(xmlEventParse(filename, branches = list(b = function(node) {
                          print(names(node))})))
  invisible(xmlEventParse(filename, branches = list(b = function(node) {
                          print(xmlName(xmlChildren(node)[[1]]))})))
}

  
  ############################################
  # Stopping the parser mid-way and an example of using XMLParserContextFunction.

  startElement =
  function(ctxt, name, attrs, ...)  {
    print(ctxt)
      print(name)
      if(name == "rewriteURI") {
           cat("Terminating parser\n")
	   xmlStopParser(ctxt)
      }
  }
  class(startElement) = "XMLParserContextFunction"  
  endElement =
  function(name, ...) 
    cat("ending", name, "\n")

  fileName = system.file("exampleData", "catalog.xml", package = "XML")
  xmlEventParse(fileName, handlers = list(startElement = startElement,
                                          endElement = endElement))
</code></pre>

<hr>
<h2 id='xmlGetAttr'>Get the value of an attribute in an XML node</h2><span id='topic+xmlGetAttr'></span>

<h3>Description</h3>

<p>This is a convenience function that retrieves
the value of a named attribute in an XML node,
taking care of checking for its existence.
It also allows the caller to provide a default
value to use as the return value if the
attribute is not present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlGetAttr(node, name, default = NULL, converter = NULL,
            namespaceDefinition = character(),
             addNamespace = length(grep(":", name)) &gt; 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlGetAttr_+3A_node">node</code></td>
<td>
<p>the XML node</p>
</td></tr>
<tr><td><code id="xmlGetAttr_+3A_name">name</code></td>
<td>
<p>the name of the attribute</p>
</td></tr>
<tr><td><code id="xmlGetAttr_+3A_default">default</code></td>
<td>
<p>a value to use as the default return if the attribute
is not present in the XML node. </p>
</td></tr>
<tr><td><code id="xmlGetAttr_+3A_converter">converter</code></td>
<td>
<p>an optional function which if supplied is invoked
with the attribute value and the value returned.
This can be used to convert the string to an arbitrary
value which is useful if it is, for example, a number.
This is only called if the attribute exists within the node.
In other words, it is not applied to the <code>default</code> value.</p>
</td></tr>
<tr><td><code id="xmlGetAttr_+3A_namespacedefinition">namespaceDefinition</code></td>
<td>
<p>a named character vector giving
name space prefixes and URIs to use when resolving for the
the attribute with a namespace.
The values are used to compare the name space prefix used in
the <code>name</code> given by the user to the name space 
definition in the node to ensure they match.
This is important as we might ask for an attribute named
<code>r:width</code> assuming that the prefix <code>r</code> corresponded to the
URI <code>http://www.r-project.org</code>. However, there may 
be a name space prefix <code>r</code> defined on the node that points
to  a different URI and so this would be an erroneous match.
</p>
</td></tr>
<tr><td><code id="xmlGetAttr_+3A_addnamespace">addNamespace</code></td>
<td>
<p>a logical value that indicates whether we should put the 
namespace prefix on the resulting name.
This is passed on to <code><a href="#topic+xmlAttrs">xmlAttrs</a></code> and so controls whether the resulting
attribute names  have the prefix attached. 
So one specifies <code>TRUE</code> for this argument if the attribute identifier
has a namespace prefix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This just checks that the attribute list is
non-NULL and that there is an element with
the specified name.
</p>


<h3>Value</h3>

<p>If the
attribute is present,
the return value is  a string which is the value of the attribute.
Otherwise, the value of <code>default</code> is returned.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlAttrs">xmlAttrs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> node &lt;- xmlNode("foo", attrs=c(a="1", b="my name"))

 xmlGetAttr(node, "a")
 xmlGetAttr(node, "doesn't exist", "My own default value")

 xmlGetAttr(node, "b", "Just in case")
</code></pre>

<hr>
<h2 id='xmlHandler'> Example XML Event Parser Handler Functions</h2><span id='topic+xmlHandler'></span>

<h3>Description</h3>

<p>A closure containing simple functions for the different
types of events potentially called by the <a href="#topic+xmlEventParse">xmlEventParse</a>,
and some tag-specific functions to illustrate how one can
add functions for specific DTDs and XML element types.
Contains a local <a href="base.html#topic+list">list</a> which can be mutated
by invocations of the closure's function. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlHandler()
</code></pre>


<h3>Value</h3>

<p>List containing the functions enumerated
in the closure definition along with the
<a href="base.html#topic+list">list</a>.
</p>


<h3>Note</h3>

<p>This is just an example.</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><a href="#topic+xmlEventParse">xmlEventParse</a>, <a href="#topic+xmlTreeParse">xmlTreeParse</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
xmlURL &lt;- "https://www.omegahat.net/Scripts/Data/mtcars.xml"
xmlText &lt;- paste(scan(xmlURL, what="", sep="\n"),"\n",collapse="\n")

## End(Not run)

xmlURL &lt;- system.file("exampleData", "mtcars.xml", package="XML")
xmlText &lt;- paste(readLines(xmlURL), "\n", collapse="")
xmlEventParse(xmlText, handlers = NULL, asText=TRUE)
xmlEventParse(xmlText, xmlHandler(), useTagName=TRUE, asText=TRUE)
</code></pre>

<hr>
<h2 id='xmlHashTree'>Constructors for trees stored as flat list of nodes with
information about parents and children.</h2><span id='topic+xmlHashTree'></span>

<h3>Description</h3>

<p>These (and related internal) functions allow us to represent trees as
a simple, non-hierarchical collection of nodes along with
corresponding tables that identify the parent and child relationships.
This is different from representing a tree as a list of lists of lists
...  in which each node has a list of its own children. In a
functional language like R, it is not possible then for the children
to be able to identify their parents.
</p>
<p>We use an environment to represent these flat trees.  Since these are
mutable without requiring the change to be reassigned, we can modify a
part of the tree locally without having to reassign the top-level
object.
</p>
<p>We can use either a list (with names) to store the nodes or a hash
table/associative array that uses names. There is a non-trivial
performance difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlHashTree(nodes = list(), parents = character(), children = list(), 
             env = new.env(TRUE, parent = emptyenv()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlHashTree_+3A_nodes">nodes</code></td>
<td>
<p> a collection of existing nodes that are to be added to
the tree. These are used to initialize the tree. If this is
specified, you must also specify <code>children</code> and <code>parents</code>.
</p>
</td></tr>
<tr><td><code id="xmlHashTree_+3A_parents">parents</code></td>
<td>
<p> the parent relationships for the nodes given by <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="xmlHashTree_+3A_children">children</code></td>
<td>
<p>the children relationships for the nodes given by <code>nodes</code>.</p>
</td></tr>
<tr><td><code id="xmlHashTree_+3A_env">env</code></td>
<td>
<p>an environment in which the information for the tree  will
be stored. This is essentially the tree object as it allows us to
modify parts of the tree without having to reassign the top-level
object.    Unlike most R data types, environments are mutable.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>xmlHashTree</code> object has an accessor method via
<code>$</code> for accessing individual  nodes within the tree.
One can use the node name/identifier in an expression such as
<code>tt$myNode</code> to obtain the element.
The name of a node is either its XML node name or if that is already
present in the tree, a machine generated name.
</p>
<p>One can find the names of all the nodes using the
<code>objects</code> function since these trees are regular
environments in R.
Using the <code>all = TRUE</code> argument, one can also find the
&ldquo;hidden&rdquo; elements that make define the tree's structure.
These are <code>.children</code> and <code>.parents</code>.
The former is an (hashed) environment. Each element is identified by the
node in the tree by the node's identifier (corresponding to the
name of the node in the tree's environment).
The value of that element is simply a character vector giving the
identifiers of all of the children of that node.
</p>
<p>The <code>.parents</code> element is also an environemnt.
Each element in this gives the pair of node and parent identifiers
with the parent identifier being the value of the variable in the
environment. In other words, we look up the parent of a node
named 'kid' by retrieving the value of the variable 'kid' in the
<code>.parents</code> environment of this hash tree.
</p>
<p>The function <code>.addNode</code> is used to insert a new node into the
tree.
</p>
<p>The structure of this tree allows one to easily travers all nodes,
navigate up the tree from a node via its parent.  Certain tasks are
more complex as the hierarchy is not implicit within a node.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+xmlTree">xmlTree</a></code>
<code><a href="#topic+xmlOutputBuffer">xmlOutputBuffer</a></code>
<code><a href="#topic+xmlOutputDOM">xmlOutputDOM</a></code>    
</p>


<h3>Examples</h3>

<pre><code class='language-R'> f = system.file("exampleData", "dataframe.xml", package = "XML")
 tr  = xmlHashTree()
 xmlTreeParse(f, handlers = list(.startElement = tr[[".addNode"]]))

 tr # print the tree on the screen

  # Get the two child nodes of the dataframe node.
 xmlChildren(tr$dataframe)

  # Find the names of all the nodes.
 objects(tr)
  # Which nodes have children
 objects(tr$.children)

  # Which nodes are leaves, i.e. do not have children
 setdiff(objects(tr), objects(tr$.children))

  # find the class of each of these leaf nodes.
 sapply(setdiff(objects(tr), objects(tr$.children)),
         function(id) class(tr[[id]]))

  # distribution of number of children
 sapply(tr$.children, length)


  # Get the first A node
 tr$A

  # Get is parent node.
 xmlParent(tr$A)


 f = system.file("exampleData", "allNodeTypes.xml", package = "XML")

   # Convert the document
 r = xmlInternalTreeParse(f, xinclude = TRUE)
 ht = as(r, "XMLHashTree")
 ht
 
  # work on the root node, or any node actually
 as(xmlRoot(r), "XMLHashTree")

  # Example of making copies of an XMLHashTreeNode object to create a separate tree.
 f = system.file("exampleData", "simple.xml", package = "XML")
 tt = as(xmlParse(f), "XMLHashTree")

 xmlRoot(tt)[[1]]
 xmlRoot(tt)[[1, copy = TRUE]]

 table(unlist(eapply(tt, xmlName)))
 # if any of the nodes had any attributes
 # table(unlist(eapply(tt, xmlAttrs)))
</code></pre>

<hr>
<h2 id='XMLInternalDocument-class'>Class to represent reference to C-level data structure for an XML
document</h2><span id='topic+XMLAbstractDocument-class'></span><span id='topic+XMLInternalDocument-class'></span><span id='topic+HTMLInternalDocument-class'></span><span id='topic+coerce+2CXMLInternalNode+2CXMLInternalDocument-method'></span><span id='topic+coerce+2CXMLInternalDocument+2CXMLInternalNode-method'></span><span id='topic+coerce+2CXMLDocument+2CXMLInternalDocument-method'></span>

<h3>Description</h3>

<p>This class is used to provide a handle/reference to a C-level
data structure that contains the information from parsing 
parsing XML content.
This leaves the nodes in the DOM or tree as C-level nodes
rather than converting them to explicit R <code>XMLNode</code>
objects.  One can then operate on this tree in much the same
way as one can the <code>XMLNode</code> representations,
but we a) avoid copying the nodes to R, and b) can navigate
the tree both down and up using <code><a href="#topic+xmlParent">xmlParent</a></code>
giving greater flexibility.
Most importantly, one can use an <code>XMLInternalDocument</code>
class object with an XPath expression to easily and relatively efficiently
find nodes within a document that satisfy some criterion.
See <code><a href="#topic+getNodeSet">getNodeSet</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects of this type are created via
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
and   <code><a href="#topic+htmlTreeParse">htmlTreeParse</a></code>
with the argument  <code>useInternalNodes</code> given as <code>TRUE</code>.
</p>


<h3>Extends</h3>

<p>Class <code><a href="methods.html#topic+oldClass-class">oldClass</a></code>, directly.
</p>


<h3>Methods</h3>

<p>There are methods to serialize (dump) a document to a file or as a
string, and to coerce it to a node by finding the top-level node of
the document.
There are functions to search the document for nodes specified by
an XPath expression.
</p>


<h3>References</h3>

<p>XPath  <a href="https://www.w3.org/TR/xpath/">https://www.w3.org/TR/xpath/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+htmlTreeParse">htmlTreeParse</a></code>
<code><a href="#topic+getNodeSet">getNodeSet</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 f = system.file("exampleData", "mtcars.xml", package="XML")
 doc = xmlParse(f)
 getNodeSet(doc, "//variables[@count]")
 getNodeSet(doc, "//record")

 getNodeSet(doc, "//record[@id='Mazda RX4']")

 # free(doc)
</code></pre>

<hr>
<h2 id='xmlName'> Extraces the tag name of an XMLNode object.</h2><span id='topic+xmlName'></span><span id='topic+xmlName+3C-'></span><span id='topic+xmlName.XMLComment'></span><span id='topic+xmlName.XMLNode'></span><span id='topic+xmlName.XMLInternalNode'></span>

<h3>Description</h3>

<p>Each XMLNode object has an element or tag name introduced
in the <code>&lt;name ...&gt;</code> entry in an XML document.
This function returns that name.
</p>
<p>We can also set that name using <code>xmlName(node) &lt;- "name"</code>
and the value can have an XML name space prefix, e.g.
<code>"r:name"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlName(node, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlName_+3A_node">node</code></td>
<td>
<p>The XMLNode object whose tag name is being requested.</p>
</td></tr>
<tr><td><code id="xmlName_+3A_full">full</code></td>
<td>
<p>a logical value indicating whether to prepend the
namespace prefix, if there is one, or return just the
name of the XML element/node. <code>TRUE</code> means prepend the prefix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1
which is the <code>node$name</code> entry.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlChildren">xmlChildren</a></code>,
<code><a href="#topic+xmlAttrs">xmlAttrs</a></code>,
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fileName &lt;- system.file("exampleData", "test.xml", package="XML") 
 doc &lt;- xmlTreeParse(fileName)
 xmlName(xmlRoot(doc)[[1]])

 tt = xmlRoot(doc)[[1]]
 xmlName(tt)
 xmlName(tt) &lt;- "bob"


  # We can set the node on an internal object also.
 n = newXMLNode("x")

 xmlName(n)
 xmlName(n) &lt;- "y"

 
 xmlName(n) &lt;- "r:y"

</code></pre>

<hr>
<h2 id='xmlNamespace'>Retrieve the namespace value of an XML node.</h2><span id='topic+xmlNamespace'></span><span id='topic+xmlNamespace.XMLNode'></span><span id='topic+xmlNamespace.XMLInternalNode'></span><span id='topic+xmlNamespace.character'></span><span id='topic+XMLNamespace-class'></span><span id='topic+xmlNamespace+3C-'></span><span id='topic+xmlNamespace+3C-+2CXMLInternalNode-method'></span>

<h3>Description</h3>

<p>Each XML node has a namespace identifier which is a string indicating
in which DTD (Document Type Definition) the definition of that element
can be found.  This avoids the problem of having different document
definitions using the same names for XML elements that have different
meaning.
To resolve the name space, i.e. 
i.e. find out to where the identifier points,
one can use the
expression <code>xmlNamespace(xmlRoot(doc))</code>.
</p>
<p>The class of the result is
is an S3-style object of class <code>XMLNamespace</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlNamespace(x)
xmlNamespace(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlNamespace_+3A_x">x</code></td>
<td>
<p>the object whose namespace is to be computed</p>
</td></tr>
<tr><td><code id="xmlNamespace_+3A_value">value</code></td>
<td>
<p>the prefix for a namespace that is defined in the node or
any of the ancestors.</p>
</td></tr>
<tr><td><code id="xmlNamespace_+3A_...">...</code></td>
<td>
<p>additional arguments for setting the name space</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For non-root nodes, this returns a string giving the identifier
of the name space for this node.
For the root node,
this returns a list with 2 elements:
</p>
<table>
<tr><td><code>id</code></td>
<td>
<p>the identifier by which other nodes refer to this
namespace.</p>
</td></tr>
<tr><td><code>uri</code></td>
<td>
<p>the URI or location that defines this namespace.</p>
</td></tr>
<tr><td><code>local</code></td>
<td>
<p>? (can't remember off-hand).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlName">xmlName</a></code>
<code><a href="#topic+xmlChildren">xmlChildren</a></code>
<code><a href="#topic+xmlAttrs">xmlAttrs</a></code>
<code><a href="#topic+xmlValue">xmlValue</a></code>
<code><a href="#topic+xmlNamespaceDefinitions">xmlNamespaceDefinitions</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  doc &lt;- xmlTreeParse(system.file("exampleData", "job.xml", package="XML"))
  xmlNamespace(xmlRoot(doc))
  xmlNamespace(xmlRoot(doc)[[1]][[1]])


  doc &lt;- xmlInternalTreeParse(system.file("exampleData", "job.xml", package="XML"))
     # Since the first node, xmlRoot() will skip that, by default.
  xmlNamespace(xmlRoot(doc))
  xmlNamespace(xmlRoot(doc)[[1]][[1]])

  node &lt;- xmlNode("arg", xmlNode("name", "foo"), namespace="R")
  xmlNamespace(node)


   doc = xmlParse('&lt;top xmlns:r="http://www.r-project.org"&gt;&lt;bob&gt;&lt;code&gt;a = 1:10&lt;/code&gt;&lt;/bob&gt;&lt;/top&gt;')
   node = xmlRoot(doc)[[1]][[1]]
   xmlNamespace(node) = "r"
   node


   doc = xmlParse('&lt;top xmlns:r="http://www.r-project.org"&gt;&lt;bob&gt;&lt;code&gt;a = 1:10&lt;/code&gt;&lt;/bob&gt;&lt;/top&gt;')
   node = xmlRoot(doc)[[1]][[1]]
   xmlNamespaces(node, set = TRUE) = c(omg = "https://www.omegahat.net")
   node
</code></pre>

<hr>
<h2 id='xmlNamespaceDefinitions'>Get definitions of any namespaces defined in this XML node</h2><span id='topic+xmlNamespaceDefinitions'></span><span id='topic+getDefaultNamespace'></span><span id='topic+xmlNamespaces'></span><span id='topic+xmlNamespaces+3C-'></span><span id='topic+xmlNamespaces+3C-+2CXMLInternalNode-method'></span><span id='topic+xmlNamespaces+3C-+2CXMLNode-method'></span><span id='topic+coerce+2CNULL+2CXMLNamespaceDefinitions-method'></span><span id='topic+coerce+2CXMLNamespace+2Ccharacter-method'></span><span id='topic+coerce+2CXMLNamespaceDefinition+2Ccharacter-method'></span><span id='topic+coerce+2CXMLNamespaceDefinitions+2Ccharacter-method'></span><span id='topic+coerce+2Ccharacter+2CXMLNamespaceDefinitions-method'></span>

<h3>Description</h3>

<p>If the given node has any namespace definitions declared within it,
i.e. of the form <code>xmlns:myNamespace="http://www.myNS.org"</code>,
<code>xmlNamespaceDefinitions</code> provides access to these definitions.
While they appear in the XML node in the document as attributes,
they are treated differently by the parser and so do not show up
in the nodes attributes via <code><a href="#topic+xmlAttrs">xmlAttrs</a></code>.
</p>
<p><code>getDefaultNamespace</code> is used to get the default namespace
for the top-level node in a document.
</p>
<p>The <code>recursive</code> parameter allows one to   conveniently find all the namespace
definitions in a document or sub-tree without having to examine the file.
This can be useful when working with XPath queries via
<code><a href="#topic+getNodeSet">getNodeSet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlNamespaceDefinitions(x, addNames = TRUE, recursive = FALSE, simplify = FALSE, ...)
xmlNamespaces(x, addNames = TRUE, recursive = FALSE,  simplify = FALSE, ...)
getDefaultNamespace(doc, ns = xmlNamespaceDefinitions(doc, simplify = simplify),  
                      simplify = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlNamespaceDefinitions_+3A_x">x</code></td>
<td>
<p>the <code>XMLNode</code> object in which to find any namespace
definitions</p>
</td></tr>
<tr><td><code id="xmlNamespaceDefinitions_+3A_addnames">addNames</code></td>
<td>
<p>a logical indicating whether to compute the names for
the elements in the resulting list. The names are convenient, but
one can avoid the (very small) overhead of computing these with this
parameter.</p>
</td></tr>
<tr><td><code id="xmlNamespaceDefinitions_+3A_doc">doc</code></td>
<td>
<p>the XMLInternalDocument object obtained from a call to
<code><a href="#topic+xmlParse">xmlParse</a></code>
</p>
</td></tr>
<tr><td><code id="xmlNamespaceDefinitions_+3A_recursive">recursive</code></td>
<td>
<p>a logical value indicating whether to extract the
namespace definitions for just this node (<code>FALSE</code>)
or all of the descendant nodes as well (<code>TRUE</code>).
If this is <code>TRUE</code>, all the namespace definitions are
collected into a single &quot;flat&quot; list and so there may be duplicate
names.
</p>
</td></tr>
<tr><td><code id="xmlNamespaceDefinitions_+3A_simplify">simplify</code></td>
<td>
<p>a logical value. If this is <code>TRUE</code>, 
a character vector of prefix-URI pairs is returned.
This can be used directly in calls to functions such as
<code><a href="#topic+xpathApply">xpathApply</a></code>  and <code><a href="#topic+getNodeSet">getNodeSet</a></code>.
The default value of <code>FALSE</code> returns a list
of name space definitions which also identify 
whether the definition is local to the particular node or inherited
from an ancestor.
</p>
</td></tr>
<tr><td><code id="xmlNamespaceDefinitions_+3A_ns">ns</code></td>
<td>
<p>the collection of namespaces. This is typically omitted
but can be specified if it has been computed in an earlier step.</p>
</td></tr>
<tr><td><code id="xmlNamespaceDefinitions_+3A_...">...</code></td>
<td>
<p>additional parameters for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with as many elements as there are namespace definitions.
Each element is an object of class XMLNameSpace,
containing fields giving the local identifier, the associated defining
URI and a logical value indicating whether the definition is local to
this node.
The name of each element is the prefix or alias used  for that
namespace definition, i.e. the value of the <code>id</code> field in the
namespace definition. For default namespaces, i.e. those that have no
prefix/alias, the name is <code>""</code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+xmlAttrs">xmlAttrs</a></code>
<code><a href="#topic+xmlGetAttr">xmlGetAttr</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f = system.file("exampleData", "longitudinalData.xml", package = "XML")
  n = xmlRoot(xmlTreeParse(f))
  xmlNamespaceDefinitions(n)
  xmlNamespaceDefinitions(n, recursive = TRUE)


    # Now using internal nodes.
  f = system.file("exampleData", "namespaces.xml", package = "XML")
  doc = xmlInternalTreeParse(f)
  n = xmlRoot(doc)
  xmlNamespaceDefinitions(n)

  xmlNamespaceDefinitions(n, recursive = TRUE)
</code></pre>

<hr>
<h2 id='xmlNode'>Create an XML node</h2><span id='topic+xmlNode'></span><span id='topic+xmlTextNode'></span><span id='topic+xmlPINode'></span><span id='topic+xmlCDataNode'></span><span id='topic+xmlCommentNode'></span>

<h3>Description</h3>

<p>These functions allow one to create XML nodes
as are created in C code when reading XML documents.
Trees of XML nodes can be constructed and 
integrated with other trees generated manually
or with via the parser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlNode(name, ..., attrs=NULL, namespace="", namespaceDefinitions = NULL,
        .children = list(...))
xmlTextNode(value, namespace="", entities = XMLEntities, cdata = FALSE)
xmlPINode(sys, value, namespace="")
xmlCDataNode(...)
xmlCommentNode(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlNode_+3A_name">name</code></td>
<td>
<p>The tag or element name of the XML node. This is what appears
in the elements as <code>&lt;name&gt; .. &lt;/name&gt;</code></p>
</td></tr>
<tr><td><code id="xmlNode_+3A_...">...</code></td>
<td>
<p>The children nodes of this XML node.
These can be objects of class <code>XMLNode</code>
or arbitrary values that will be converted to a string
to form an <code>XMLTextNode</code> object.</p>
</td></tr>
<tr><td><code id="xmlNode_+3A_.children">.children</code></td>
<td>
<p>an alternative mechanism to specifying the children
which is useful for programmatic use when one has the children
in an existing list.  The ... mechanism is for use when the
children are specified directly and individually.
</p>
</td></tr>
<tr><td><code id="xmlNode_+3A_attrs">attrs</code></td>
<td>
<p>A named character vector giving the 
name, value pairs of attributes for this XML node.</p>
</td></tr>
<tr><td><code id="xmlNode_+3A_value">value</code></td>
<td>
<p>This is the text that is to be used when forming
an <code>XMLTextNode</code>.</p>
</td></tr>
<tr><td><code id="xmlNode_+3A_cdata">cdata</code></td>
<td>
<p>a logical value which controls whether the text 
being used for the child node is to be first
enclosed within a CDATA node to escape special characters such
as <code>&gt;</code> and <code>&amp;</code>.
</p>
</td></tr>
<tr><td><code id="xmlNode_+3A_namespace">namespace</code></td>
<td>
<p>The XML namespace identifier for this node.</p>
</td></tr>
<tr><td><code id="xmlNode_+3A_namespacedefinitions">namespaceDefinitions</code></td>
<td>
<p>a collection of name space definitions, containing the prefixes and the corresponding URIs.
This is most conveniently specified as a character vector whose names attribute is the vector of prefixes
and whose values are the URIs.  Alternatively, one can provide a list of name space definition objects 
such as those returned</p>
</td></tr>
<tr><td><code id="xmlNode_+3A_sys">sys</code></td>
<td>
<p>the name of the system for which the processing instruction
is targeted. This is the value that appears in the
<code>&lt;?sys value?&gt;</code></p>
</td></tr>
<tr><td><code id="xmlNode_+3A_text">text</code></td>
<td>
<p>character string giving the contents of the comment.</p>
</td></tr>
<tr><td><code id="xmlNode_+3A_entities">entities</code></td>
<td>
<p>a character vector giving the mapping
from special characters to their entity equivalent.
This provides the  character-expanded
entity pairings of 'character = entity' , e.g. '&lt;' = &quot;lt&quot; which are
used to make the content valid XML
so that it can be used within a text node.  
The text searched sequentially
for instances of each character in the names and each instance is
replaced with the corresponding '&amp;entity;' </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>XMLNode</code>.
In the case of <code>xmlTextNode</code>,
this also inherits from <code>XMLTextNode</code>.
The fields or slots that objects
of these classes have
include
<code>name</code>, <code>attributes</code>, <code>children</code> and <code>namespace</code>.
However, one should 
the accessor functions
<code><a href="#topic+xmlName">xmlName</a></code>,
<code><a href="#topic+xmlAttrs">xmlAttrs</a></code>,
<code><a href="#topic+xmlChildren">xmlChildren</a></code>
and
<code><a href="#topic+xmlNamespace">xmlNamespace</a></code>
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+addChildren">addChildren</a></code>  
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+asXMLNode">asXMLNode</a></code>
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
<code><a href="#topic+newXMLPINode">newXMLPINode</a></code>
<code><a href="#topic+newXMLCDataNode">newXMLCDataNode</a></code>
<code><a href="#topic+newXMLCommentNode">newXMLCommentNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # node named arg with two children: name and defaultValue
 # Both of these have a text node as their child.
 n &lt;- xmlNode("arg", attrs = c(default="TRUE"),
               xmlNode("name", "foo"), xmlNode("defaultValue","1:10"))


  # internal C-level node.
 a = newXMLNode("arg", attrs = c(default = "TRUE"),
                newXMLNode("name", "foo"),
                newXMLNode("defaultValue", "1:10"))

 xmlAttrs(a) = c(a = 1, b = "a string")

 xmlAttrs(a) = c(a = 1, b = "a string", append = FALSE)

 newXMLNamespace(a, c("r" = "http://www.r-project.org"))
 xmlAttrs(a) = c("r:class" = "character") 


 xmlAttrs(a[[1]]) = c("r:class" = "character") 


  # Using a character vector as a namespace definitions
 x = xmlNode("bob",
             namespaceDefinitions = c(r = "http://www.r-project.org",
                                      omg = "https://www.omegahat.net"))
</code></pre>

<hr>
<h2 id='XMLNode-class'>Classes to describe an XML node object.</h2><span id='topic+XMLAbstractNode-class'></span><span id='topic+XMLAbstractNode-class'></span><span id='topic+RXMLNode-class'></span><span id='topic+XMLNode-class'></span><span id='topic+XMLTreeNode-class'></span><span id='topic+XMLInternalNode-class'></span><span id='topic+XMLInternalTextNode-class'></span><span id='topic+XMLInternalElementNode-class'></span><span id='topic+XMLInternalCommentNode-class'></span><span id='topic+XMLInternalPINode-class'></span><span id='topic+XMLInternalCDataNode-class'></span><span id='topic+XMLAttributeDeclNode-class'></span><span id='topic+XMLDocumentFragNode-class'></span><span id='topic+XMLDocumentNode-class'></span><span id='topic+XMLDocumentTypeNode-class'></span><span id='topic+XMLEntityDeclNode-class'></span><span id='topic+XMLNamespaceDeclNode-class'></span><span id='topic+XMLXIncludeStartNode-class'></span><span id='topic+XMLXIncludeEndNode-class'></span><span id='topic+XMLDTDNode-class'></span><span id='topic+coerce+2CXMLAbstractNode+2CDate-method'></span><span id='topic+coerce+2CXMLAbstractNode+2CPOSIXct-method'></span><span id='topic+coerce+2CXMLAbstractNode+2CURL-method'></span><span id='topic+coerce+2CXMLAbstractNode+2Ccharacter-method'></span><span id='topic+coerce+2CXMLAbstractNode+2Cinteger-method'></span><span id='topic+coerce+2CXMLAbstractNode+2Clogical-method'></span><span id='topic+coerce+2CXMLAbstractNode+2Cnumeric-method'></span><span id='topic+XMLNamespaceDefinitions-class'></span>

<h3>Description</h3>

<p>These classes are intended to 
represent an XML node, either directly in S or a reference to an internal
libxml node.  Such nodes respond to queries about 
their name, attributes, namespaces and children.  
These are old-style, S3 class definitions at present.
</p>


<h3>Slots</h3>

<p>These are old-style S3 class definitions and do not have
formal slots
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;XMLNode&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+xmlTree">xmlTree</a></code>
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
<code><a href="#topic+xmlNode">xmlNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
           # An R-level XMLNode object
   a &lt;- xmlNode("arg", attrs = c(default="T"),
                 xmlNode("name", "foo"), xmlNode("defaultValue","1:10"))

  xmlAttrs(a) = c(a = 1, b = "a string")
</code></pre>

<hr>
<h2 id='xmlOutputBuffer'>XML output streams</h2><span id='topic+xmlOutputBuffer'></span><span id='topic+xmlOutputDOM'></span>

<h3>Description</h3>

<p>These two functions provide different ways to construct XML documents
incrementally.  They provide a single, common interface for adding and
closing tags, and inserting nodes.  The buffer version stores the XML
representation as a string.  The DOM version builds the tree of XML
node objects entirely within R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlOutputBuffer(dtd=NULL, nameSpace="", buf=NULL,
                             nsURI=NULL, header="&lt;?xml version=\"1.0\"?&gt;")

xmlOutputDOM(tag="doc", attrs = NULL, dtd=NULL,
                          nameSpace=NULL, nsURI=character(0),
                          xmlDeclaration = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlOutputBuffer_+3A_dtd">dtd</code></td>
<td>
<p>a DTD object (see <code><a href="#topic+parseDTD">parseDTD</a></code> and
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>) which contains specifications about
what elements are valid within other elements and what attributes
are supported by different elements. This can be used to validate the
document as it is being constructed incrementally.</p>
</td></tr>
<tr><td><code id="xmlOutputBuffer_+3A_attrs">attrs</code></td>
<td>
<p>attributes for the top-level node, in the form of a named
vector or list.</p>
</td></tr>
<tr><td><code id="xmlOutputBuffer_+3A_namespace">nameSpace</code></td>
<td>
<p>the default namespace identifier to be used when
an element is created without an explicit namespace.
This provides a convenient way to specify the default name space that appers in tags throughout the resulting document.</p>
</td></tr>
<tr><td><code id="xmlOutputBuffer_+3A_buf">buf</code></td>
<td>
<p>a connection object or a string into which the XML content is written.
This is currently a simplistic implementation since we will use the OOP-style classes
from the Omegahat projects in the future.</p>
</td></tr>
<tr><td><code id="xmlOutputBuffer_+3A_nsuri">nsURI</code></td>
<td>
<p>the URI or value for the name space which is used
when declaring the namespace.
For <code>xmlOuputDOM</code>, this is a named character vector with each
element giving the name space identifier and the
corresponding URI, \
e.g <code>c(shelp = "https://www.omegahat.net/XML/SHelp")</code>
</p>
</td></tr>
<tr><td><code id="xmlOutputBuffer_+3A_header">header</code></td>
<td>
<p>if non-NULL, this is immediately written to the output stream allowing
one to control the initial section of the XML document.</p>
</td></tr>
<tr><td><code id="xmlOutputBuffer_+3A_tag">tag</code></td>
<td>
<p>the name of the top-level node/element in the DOM being
created.</p>
</td></tr>
<tr><td><code id="xmlOutputBuffer_+3A_xmldeclaration">xmlDeclaration</code></td>
<td>
<p> a logical value or a string.
If this is a logical value and <code>TRUE</code>, the default &lt;?xml version='1.0'?&gt;
processing instruction is emitted at the top of the document.  
If it is <code>FALSE</code>, no xml declaration is emitted at the top of
the document.
If this is provided as a string, the contents of this is added
as the content of the processing instruction.   A version='1.0' is
added if there is no  'version=' content within the given string.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions create a closure instance which provides methods or
functions that operate on shared data used to represent the contents
of the XML document being created and the current state of that
creation.
</p>


<h3>Value</h3>

<p>Both of these functions return  a list
of functions which operate on the XML data in a shared environment.
</p>
<table>
<tr><td><code>value</code></td>
<td>
<p>get the contents of the XML document as they are currently 
defined.</p>
</td></tr>
<tr><td><code>addTag</code></td>
<td>
<p>add a new element to the document, specifying its name and attributes.
This allows the tag to be left open so that new elements will be added as children
of it.</p>
</td></tr>
<tr><td><code>closeTag</code></td>
<td>
<p>close the currently open tag, indicating that new elements will be added,
by default,  as siblings of this one.</p>
</td></tr>
<tr><td><code>reset</code></td>
<td>
<p>discard the current contents of the document so that we can start over
and free the resources (memory) associated with this document.</p>
</td></tr>
</table>
<p>The following are specific to <code>xmlOutputDOM</code>:
</p>
<table>
<tr><td><code>addNode</code></td>
<td>
<p>insert an complete <code>XMLNode</code> object
into the currently active (i.e. open)  node.</p>
</td></tr>
<tr><td><code>current</code></td>
<td>
<p>obtain the path or collection of indices to 
to the currently active/open node from the root node.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p><a href="https://www.omegahat.net/RSXML/">https://www.omegahat.net/RSXML/</a>,
<a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTree">xmlTree</a></code> for a native/internal (C-level) representation of the tree,
<code><a href="#topic+xmlNode">xmlNode</a></code>,
<code><a href="#topic+xmlTextNode">xmlTextNode</a></code>,
<code><a href="#topic+append.xmlNode">append.xmlNode</a></code>
</p>
<p>And a different representation of a tree is available
via <code><a href="#topic+xmlHashTree">xmlHashTree</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> con &lt;- xmlOutputDOM()
con$addTag("author", "Duncan Temple Lang")
con$addTag("address",  close=FALSE)
 con$addTag("office", "2C-259")
 con$addTag("street", "Mountain Avenue.")
 con$addTag("phone", close = FALSE)
   con$addTag("area", "908", attrs=c(state="NJ"))
   con$addTag("number", "582-3217")
 con$closeTag() # phone
con$closeTag() # address

con$addTag("section", close = FALSE)
 con$addNode(xmlTextNode("This is some text "))
 con$addTag("a","and a link", attrs=c(href="https://www.omegahat.net"))
 con$addNode(xmlTextNode("and some follow up text"))

 con$addTag("subsection", close = FALSE)
   con$addNode(xmlTextNode("some addtional text "))
   con$addTag("a", attrs=c(href="https://www.omegahat.net"), close=FALSE)
     con$addNode(xmlTextNode("the content of the link"))
   con$closeTag() # a
 con$closeTag() # "subsection"
con$closeTag() # section


 d &lt;- xmlOutputDOM()
 d$addPI("S", "plot(1:10)")
 d$addCData('x &lt;- list(1, a="&amp;");\nx[[2]]')
 d$addComment("A comment")
 print(d$value())
 print(d$value(), indent = FALSE, tagSeparator = "")


 d = xmlOutputDOM("bob", xmlDeclaration = TRUE)
 print(d$value())

 d = xmlOutputDOM("bob", xmlDeclaration = "encoding='UTF-8'")
 print(d$value())


 d = xmlOutputBuffer("bob", header = "&lt;?xml version='1.0' encoding='UTF-8'?&gt;", 
                      dtd = "foo.dtd")
 d$addTag("bob")
 cat(d$value())
</code></pre>

<hr>
<h2 id='xmlParent'>Get parent node of XMLInternalNode or ancestor nodes</h2><span id='topic+xmlParent'></span><span id='topic+xmlAncestors'></span><span id='topic+xmlParent.XMLInternalNode'></span><span id='topic+xmlParent+2CXMLInternalNode-method'></span><span id='topic+xmlParent+2CXMLHashTreeNode-method'></span><span id='topic+xmlParent+2CXMLTreeNode-method'></span>

<h3>Description</h3>

<p><code>xmlParent</code> operates on an XML node
and returns a reference to its parent node 
within the document tree.
This works for an internal, C-level
<code>XMLInternalNode</code> object
created, for examply, using <code><a href="#topic+newXMLNode">newXMLNode</a></code>
and related functions or <code><a href="#topic+xmlTree">xmlTree</a></code>
or  from <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code> with the
<code>useInternalNodes</code> parameter.
</p>
<p>It is possible to find the parent of an R-level
XML node when using a tree
created with, for example,  <code><a href="#topic+xmlHashTree">xmlHashTree</a></code>
as the parent information is stored separately.
</p>
<p><code>xmlAncestors</code> walks the chain of parens to the
top of the document and either returns a list of those
nodes, or alternatively a list of the values obtained
by applying a function to each of the nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlParent(x, ...)
xmlAncestors(x, fun = NULL, ..., addFinalizer = NA, count = -1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlParent_+3A_x">x</code></td>
<td>
<p>an object of class <code>XMLInternalNode</code> whose parent is being requested. </p>
</td></tr>
<tr><td><code id="xmlParent_+3A_fun">fun</code></td>
<td>
<p>an R function which is invoked for each  node as we walk up
the tree.</p>
</td></tr>
<tr><td><code id="xmlParent_+3A_...">...</code></td>
<td>
<p>any additional arguments that are passed in calls to
<code>fun</code> after the node object and for <code>xmlParent</code> this allows methods to define their
own additional parameters.</p>
</td></tr>
<tr><td><code id="xmlParent_+3A_addfinalizer">addFinalizer</code></td>
<td>
<p>a logical value indicating whether the
default finalizer routine should be registered to
free the internal xmlDoc when R no longer has a reference to this
external pointer object.
This can also be the name of a C routine or a reference
to a C routine retrieved using
<code><a href="base.html#topic+getNativeSymbolInfo">getNativeSymbolInfo</a></code>.
</p>
</td></tr>
<tr><td><code id="xmlParent_+3A_count">count</code></td>
<td>
<p>an integer that indicates how many levels of the hierarchy
to traverse. This allows us to get the <code>count</code> most recent
ancestors of the node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses the internal libxml structures to access the parent in the DOM tree. 
This function is generic so that we can add methods for other types of nodes
if we so want in the future.
</p>


<h3>Value</h3>

<p><code>xmlParent</code> returns object of class <code>XMLInternalNode</code>.
</p>
<p>If <code>fun</code> is <code>NULL</code>, <code>xmlAncestors</code> returns a list of the nodes in order of
top-most node or root of the tree, then its child, then the child of
that child, etc. This is the reverse order in which the nodes are
visited/found.
</p>
<p>If <code>fun</code> is a function, <code>xmlAncestors</code> returns a list
whose elements are the results of calling that function for
each node. Again, the order is top down.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlChildren">xmlChildren</a></code>
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+xmlNode">xmlNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  top = newXMLNode("doc")
  s = newXMLNode("section", attr = c(title = "Introduction"))
  a = newXMLNode("article", s)
  addChildren(top, a)

  xmlName(xmlParent(s))
  xmlName(xmlParent(xmlParent(s)))


    # Find the root node.
  root = a
  while(!is.null(xmlParent(root)))
      root = xmlParent(root)

   # find the names of the parent nodes of each 'h' node.
   # use a global variable to "simplify" things and not use a closure.

  filename = system.file("exampleData", "branch.xml", package = "XML")
  parentNames &lt;- character()
  xmlParse(filename,
                handlers =
                  list(h = function(x) {
                   parentNames &lt;&lt;- c(parentNames, xmlName(xmlParent(x)))
                  }))

  table(parentNames)
</code></pre>

<hr>
<h2 id='xmlParseDoc'>Parse an XML document with options controlling the parser.</h2><span id='topic+xmlParseDoc'></span><span id='topic+COMPACT'></span><span id='topic+DTDATTR'></span><span id='topic+DTDLOAD'></span><span id='topic+DTDVALID'></span><span id='topic+HUGE'></span><span id='topic+NOBASEFIX'></span><span id='topic+NOBLANKS'></span><span id='topic+NOCDATA'></span><span id='topic+NODICT'></span><span id='topic+NOENT'></span><span id='topic+NOERROR'></span><span id='topic+NONET'></span><span id='topic+NOWARNING'></span><span id='topic+NOXINCNODE'></span><span id='topic+NSCLEAN'></span><span id='topic+OLDSAX'></span><span id='topic+PEDANTIC'></span><span id='topic+RECOVER'></span><span id='topic+XINCLUDE'></span><span id='topic+OLD10'></span><span id='topic+SAX1'></span>

<h3>Description</h3>

<p>This function is a generalization of <code><a href="#topic+xmlParse">xmlParse</a></code>
that parses an XML document.  With this function, we can specify
a combination of different options that control the operation of the
parser. The options control many different aspects the parsing process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlParseDoc(file, options = 1L, encoding = character(),
            asText = !file.exists(file), baseURL = file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlParseDoc_+3A_file">file</code></td>
<td>
<p>the name of the file or URL or the XML content itself</p>
</td></tr>
<tr><td><code id="xmlParseDoc_+3A_options">options</code></td>
<td>
<p>options controlling the behavior of the parser.
One specifies the different options as elements of an integer
vector. These are then bitwised OR'ed together. The possible options are
<code>RECOVER</code>, <code>NOENT</code>, <code>DTDLOAD</code>,
<code>DTDATTR</code>, <code>DTDVALID</code>, <code>NOERROR</code>, <code>NOWARNING</code>,
<code>PEDANTIC</code>, <code>NOBLANKS</code>, <code>SAX1</code>, <code>XINCLUDE</code>,
<code>NONET</code>, <code>NODICT</code>, <code>NSCLEAN</code>, <code>NOCDATA</code>,
<code>NOXINNODE</code>, <code>COMPACT</code>, <code>OLD10</code>, <code>NOBASEFIX</code>,
<code>HUGE</code>, <code>OLDSAX</code>.
( These options are also listed in the (non-exported) variable
<code>parserOptions</code>.)
</p>
</td></tr>
<tr><td><code id="xmlParseDoc_+3A_encoding">encoding</code></td>
<td>
<p>character string that provides the encoding of the
document if it is not explicitly contained within the document itself.</p>
</td></tr>
<tr><td><code id="xmlParseDoc_+3A_astext">asText</code></td>
<td>
<p>a logical value indicating whether <code>file</code> is the
XML content (<code>TRUE</code>) or the name of a file or URL (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="xmlParseDoc_+3A_baseurl">baseURL</code></td>
<td>
<p>the base URL used for resolving relative documents,
e.g. XIncludes. This is important if <code>file</code> is the actual XML
content rather than a URL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>XMLInternalDocument</code>.  
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libxml2</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlParse">xmlParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> f = system.file("exampleData", "mtcars.xml", package="XML")
     # Same as xmlParse()
 xmlParseDoc(f)

 txt =
     '&lt;top xmlns:r="http://www.r-project.org"&gt;
        &lt;b xmlns:r="http://www.r-project.org"&gt;
          &lt;c xmlns:omg="http:/www.omegahat.net"/&gt;
        &lt;/b&gt;
      &lt;/top&gt;'

 xmlParseDoc(txt,  NSCLEAN, asText = TRUE)

 txt =
     '&lt;top xmlns:r="http://www.r-project.org"  xmlns:r="http://www.r-project.org"&gt;
        &lt;b xmlns:r="http://www.r-project.org"&gt;
          &lt;c xmlns:omg="http:/www.omegahat.net"/&gt;
        &lt;/b&gt;
      &lt;/top&gt;'

 xmlParseDoc(txt, c(NSCLEAN, NOERROR), asText = TRUE)
</code></pre>

<hr>
<h2 id='xmlParserContextFunction'>Identifies function as expecting an xmlParserContext argument</h2><span id='topic+xmlParserContextFunction'></span>

<h3>Description</h3>

<p>This is a convenience function for setting the class of the
specified function to include <code>"XMLParserContextFunction"</code>.
This identifies it as expecting an 
<code>xmlParserCtxt</code> object as its first argument.
The resulting function can be passed to the
internal/native XML parser as a handler/callback function.
When the parser calls it, it recognizes this class information
and includes a reference to the C-level <code>xmlParserCtxt</code> 
object as the first argument in the call.
</p>
<p>This <code>xmlParserCtxt</code> object can be used to gracefully
terminate the parsing (without an error), 
and in the future will also provide access to details
about the current state of the parser,
e.g. the encoding of the file, the XML version, 
whether entities are being replaced, 
line and column number for each node processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> xmlParserContextFunction(f, class = "XMLParserContextFunction")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlParserContextFunction_+3A_f">f</code></td>
<td>
<p>the function whose class information is to be augmented.</p>
</td></tr>
<tr><td><code id="xmlParserContextFunction_+3A_class">class</code></td>
<td>
<p>the name of the class which is to be added to the <code>class</code>
attribute of the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function object <code>f</code> whose class attribute has been prepended
with the value of <code>class</code>.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlInternalTreeParse">xmlInternalTreeParse</a></code>/<code><a href="#topic+xmlParse">xmlParse</a></code>
and the <code>branches</code> parameter of  <code><a href="#topic+xmlEventParse">xmlEventParse</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  fun = function(context, ...) {
             # do things to parse the node
             # using the context if necessary.
           cat("In XMLParserContextFunction\n")
           xmlStopParser(context)
         }
  fun = xmlParserContextFunction(fun)

  txt = "&lt;doc&gt;&lt;a/&gt;&lt;/doc&gt;"
  # doesn't work for xmlTreeParse()
  #   xmlTreeParse(txt, handlers = list(a = fun))

  #  but does in xmlEventParse().
  xmlEventParse(txt, handlers = list(startElement = fun), asText = TRUE)

</code></pre>

<hr>
<h2 id='xmlRoot'>Get the top-level XML node.</h2><span id='topic+xmlRoot'></span><span id='topic+xmlRoot.XMLDocument'></span><span id='topic+xmlRoot.XMLInternalDocument'></span><span id='topic+xmlRoot.XMLInternalDOM'></span><span id='topic+xmlRoot.XMLDocumentRoot'></span><span id='topic+xmlRoot.XMLDocumentContent'></span><span id='topic+xmlRoot.HTMLDocument'></span>

<h3>Description</h3>

<p>These are a collection of methods for providing easy access to the
top-level <code>XMLNode</code> object resulting from parsing an XML
document.  They simplify accessing this node in the presence of
auxillary information such as DTDs, file name and version information
that is returned as part of the parsing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlRoot(x, skip = TRUE, ...)
## S3 method for class 'XMLDocumentContent'
xmlRoot(x, skip = TRUE, ...)
## S3 method for class 'XMLInternalDocument'
xmlRoot(x, skip = TRUE, addFinalizer = NA, ...)
## S3 method for class 'HTMLDocument'
xmlRoot(x, skip = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlRoot_+3A_x">x</code></td>
<td>
<p>the object whose root/top-level XML node is to be returned.</p>
</td></tr>
<tr><td><code id="xmlRoot_+3A_skip">skip</code></td>
<td>
<p>a logical value that controls whether DTD nodes and/or
XMLComment objects that appear
before the &ldquo;real&rdquo; top-level node of the document should be ignored (<code>TRUE</code>)
or not (<code>FALSE</code>) when returning the root node.</p>
</td></tr>
<tr><td><code id="xmlRoot_+3A_...">...</code></td>
<td>
<p>arguments that are passed by the generic to the different specialized 
methods of this generic.</p>
</td></tr>
<tr><td><code id="xmlRoot_+3A_addfinalizer">addFinalizer</code></td>
<td>
<p>a logical value or identifier for a C routine
that controls whether we register finalizers on the intenal node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>XMLNode</code>.
</p>


<h3>Note</h3>

<p>One cannot obtain the parent or top-level node
of an XMLNode object in S. This is different from 
languages like C, Java, Perl, etc. and is primarily 
because S does not provide support for references.</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic++5B+5B.XMLNode">[[.XMLNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  doc &lt;- xmlTreeParse(system.file("exampleData", "mtcars.xml", package="XML"))
  xmlRoot(doc)
   # Note that we cannot use getSibling () on a regular R-level XMLNode object
   # since we cannot go back up or across the tree from that node, but
   # only down to the children.

    # Using an internal node via xmlParse (== xmlInternalTreeParse())
  doc &lt;- xmlParse(system.file("exampleData", "mtcars.xml", package="XML"))
  n = xmlRoot(doc, skip = FALSE)
     # skip over the DTD and the comment
  d = getSibling(getSibling(n))
</code></pre>

<hr>
<h2 id='xmlSchemaValidate'>Validate an XML document relative to an XML schema</h2><span id='topic+xmlSchemaValidate'></span><span id='topic+schemaValidationErrorHandler'></span>

<h3>Description</h3>

<p>This function validates an XML document relative to an
XML schema to ensure that it has the correct structure,
i.e. valid sub-nodes, attributes, etc.
</p>
<p>The <code>xmlSchemaValidationErrorHandler</code> is a function
that returns a list of functions which can be used to cumulate or
collect the errors and warnings from the schema validation  operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlSchemaValidate(schema, doc, 
                                 errorHandler = xmlErrorFun(),
                                  options = 0L)

schemaValidationErrorHandler()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlSchemaValidate_+3A_schema">schema</code></td>
<td>
<p>an object of class <code>xmlSchemaRef</code> which is
usually the result of a call to <code><a href="#topic+xmlInternalTreeParse">xmlInternalTreeParse</a></code>
with <code>isSchema = TRUE</code>, or <code><a href="#topic+xmlSchemaParse">xmlSchemaParse</a></code>.</p>
</td></tr>
<tr><td><code id="xmlSchemaValidate_+3A_doc">doc</code></td>
<td>
<p>an XML document which has already been parsed into
a <code>XMLInternalDocument</code> or which is a file name or string
which is coerced to an <code><a href="#topic+XMLInternalDocument-class">XMLInternalDocument-class</a></code> object</p>
</td></tr>
<tr><td><code id="xmlSchemaValidate_+3A_options">options</code></td>
<td>
<p>an integer giving the options controlling the
validation.  At present, this is either 0 or 1 and is essentially
irrelevant to us. It may be of value in the future.
</p>
</td></tr>
<tr><td><code id="xmlSchemaValidate_+3A_errorhandler">errorHandler</code></td>
<td>
<p> a function or a list whose first element is a function
which is then used as the collector for the warning and error
messages reported during the validation. For each warning or error,
this function is invoked and the class of the message is either
<code>XMLSchemaWarning</code> or <code>XMLSchemaError</code> respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Typically, a list with 3 elements:
</p>
<table>
<tr><td><code>status</code></td>
<td>
<p>0 for validated, and non-zero for invalid</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code>warnings</code></td>
<td>
<p>a character vector</p>
</td></tr>
</table>
<p>If an empty error handler is provided (i.e. <code>NULL</code>)
just an integer indicating the status of the validation
is returned.  0 indicates everything was okay; a non-zero
value indicates a validation error. (-1 indicates an internal error
in libxml2)
</p>


<h3>References</h3>

<p>libxml2 www.xmlsoft.org </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlSchemaParse">xmlSchemaParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(FALSE) {
  xsd = xmlParse(system.file("exampleData", "author.xsd", package = "XML"), isSchema =TRUE)
  doc = xmlInternalTreeParse(system.file("exampleData", "author.xml",  package = "XML"))
  xmlSchemaValidate(xsd, doc)
}
</code></pre>

<hr>
<h2 id='xmlSearchNs'>Find a namespace definition object by searching ancestor nodes</h2><span id='topic+xmlSearchNs'></span><span id='topic+coerce+2CXMLNamespaceRef+2Ccharacter-method'></span>

<h3>Description</h3>

<p>This function allows one to search an XML tree from a particular node
and find the namespace definition for a given namespace prefix or URL.
This namespace definition can then be used to set it on a node to
make it the effective namespace for that node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlSearchNs(node, ns, asPrefix = TRUE, doc = as(node, "XMLInternalDocument"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlSearchNs_+3A_node">node</code></td>
<td>
<p>an <code>XMLInternaElementNode</code></p>
</td></tr>
<tr><td><code id="xmlSearchNs_+3A_ns">ns</code></td>
<td>
<p>a character string (vector of length 1).
If <code>asPrefix</code> is <code>TRUE</code>, this is the namespace
alias/prefix.
If <code>asPrefix</code> is <code>FALSE</code>, this is the URL of the namespace definition</p>
</td></tr>
<tr><td><code id="xmlSearchNs_+3A_asprefix">asPrefix</code></td>
<td>
<p>a logical value. See <code>ns</code>.</p>
</td></tr>
<tr><td><code id="xmlSearchNs_+3A_doc">doc</code></td>
<td>
<p>the XML document in which the node(s) are located</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class XMLNamespaceRef.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>libxml2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newXMLNode">newXMLNode</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> txt = '&lt;top xmlns:r="http://www.r-project.org"&gt;&lt;section&gt;&lt;bottom/&gt;&lt;/section&gt;&lt;/top&gt;'

 doc = xmlParse(txt)
 bottom = xmlRoot(doc)[[1]][[1]]
 xmlSearchNs(bottom, "r")
</code></pre>

<hr>
<h2 id='xmlSerializeHook'>Functions that help serialize and deserialize XML internal objects</h2><span id='topic+xmlSerializeHook'></span><span id='topic+xmlDeserializeHook'></span>

<h3>Description</h3>

<p>These functions can be used to control
how the C-level data structures associated with XML documents, nodes,
XPath queries, etc. are serialized to a a file or connection
and deserialized back into an R session.
Since these C-level data structures are represented
in R as external pointers, they would normally be serialized
and deserialized in a way that loses all the information about
the contents of the memory being referenced.
<code>xmlSerializeHook</code> arranges to serialize these pointers
by saving the corresponding XML content as a string
and also the class of the object.
The deserialize function converts such objects back to their
original form.
</p>
<p>These functions are used in calls to <code><a href="base.html#topic+saveRDS">saveRDS</a></code>
and <code><a href="base.html#topic+readRDS">readRDS</a></code> via the
<code>refhook</code> argument.
<code>
saveRDS(obj, filename, refhook = xmlSerializeHook)
readRDS(filename, refhook = xmlDeserializeHook)
</code>  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlSerializeHook(x)
xmlDeserializeHook(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlSerializeHook_+3A_x">x</code></td>
<td>
<p>the object to be deserialized, and the character vector to be
deserialized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>xmlSerializeHook</code> returns a character version of the XML
document or node, along with the basic class.
If it is called with an object that is not an native/internal XML
object, it returns <code>NULL</code>
</p>
<p><code>xmlDeserializeHook</code> returns the parsed XML object, either a
document or a node.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang
</p>


<h3>References</h3>

<p>The R Internals Manual.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+saveRDS">saveRDS</a></code>  and <code><a href="base.html#topic+readRDS">readRDS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z = newXMLNode("foo")
f = system.file("exampleData", "tides.xml", package = "XML")
doc = xmlParse(f)
hdoc = as(doc, "XMLHashTree")

nodes = getNodeSet(doc, "//pred")

ff &lt;- file.path(tempdir(), "tmp.rda")
saveRDS(list(a = 1:10, z = z, doc = doc, hdoc = hdoc, nodes = nodes), ff,
          refhook = xmlSerializeHook)

v = readRDS(ff, refhook = xmlDeserializeHook)
unlink(ff)
</code></pre>

<hr>
<h2 id='xmlSize'>The number of sub-elements within an XML node.</h2><span id='topic+xmlSize'></span><span id='topic+xmlSize.default'></span><span id='topic+xmlSize.XMLDocument'></span><span id='topic+xmlSize.XMLNode'></span>

<h3>Description</h3>

<p>XML elements can contain other, nested sub-elements.
This generic function determines the number of
such elements within a specified node.
It applies to an object of class XMLNode or XMLDocument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlSize(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlSize_+3A_obj">obj</code></td>
<td>
<p> An an object of class XMLNode
or XMLDocument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer which is the <code><a href="base.html#topic+length">length</a></code>
of the value from <code><a href="#topic+xmlChildren">xmlChildren</a></code>.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlChildren">xmlChildren</a></code>,
<code><a href="#topic+xmlAttrs">xmlAttrs</a></code>,
<code><a href="#topic+xmlName">xmlName</a></code>,
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fileName &lt;- system.file("exampleData", "mtcars.xml", package="XML") 
  doc &lt;- xmlTreeParse(fileName)
  xmlSize(doc)
  xmlSize(doc$doc$children[["dataset"]][["variables"]])
</code></pre>

<hr>
<h2 id='xmlSource'>Source the R code, examples, etc. from an XML document</h2><span id='topic+xmlSource'></span><span id='topic+xmlSource+2Ccharacter-method'></span><span id='topic+xmlSource+2CXMLNodeSet-method'></span><span id='topic+xmlSource+2CXMLInternalDocument-method'></span><span id='topic+xmlSourceFunctions'></span><span id='topic+xmlSourceFunctions+2Ccharacter-method'></span><span id='topic+xmlSourceFunctions+2CXMLInternalDocument-method'></span><span id='topic+xmlSourceSection'></span><span id='topic+xmlSourceSection+2Ccharacter-method'></span><span id='topic+xmlSourceSection+2CXMLInternalDocument-method'></span><span id='topic+xmlSourceThread'></span><span id='topic+xmlSourceThread+2CXMLInternalDocument-method'></span><span id='topic+xmlSourceThread+2Ccharacter-method'></span><span id='topic+xmlSourceThread+2Clist-method'></span>

<h3>Description</h3>

<p>This is the equivalent of a smart <code><a href="base.html#topic+source">source</a></code>
for extracting the R code elements from an XML document and
evaluating them. This allows for a &ldquo;simple&rdquo; way to collect
R functions definitions or a sequence of (annotated) R code segments in an XML
document along with other material such as notes, documentation,
data, FAQ entries, etc.,  and still  be able to
access the R code directly from within an R session.
The approach enables one to use the XML document as a container for
a heterogeneous collection of related material, some of which
is R code.
In the literate programming parlance, this function essentially
dynamically &quot;tangles&quot; the document within R, but can work on
small subsets of it that are easily specified in the
<code>xmlSource</code> function call.
This is a convenient way to annotate code in a rich way
and work with source files in a new and potentially more effective
manner.
</p>
<p><code>xmlSourceFunctions</code> provides a convenient way to read only
the function definitions, i.e. the <code>&lt;r:function&gt;</code> nodes.
We can restrict to a subset by specifying the node ids of interest.
</p>
<p><code>xmlSourceSection</code> allows us to evaluate the code in one or more
specific sections.
</p>
<p>This style of authoring code supports mixed language support
in which we put, for example, C and R code together in the same
document.
Indeed, one can use the document to store arbitrary content
and still retrieve the R code.  The more structure there is,
the easier it is to create tools to extract that information
using XPath expressions.
</p>
<p>We can identify individual <code>r:code</code> nodes in the document to
process, i.e. evaluate. We do this using their <code>id</code> attribute
and specifying which to process via the <code>ids</code> argument.
Alternatively, if a document has a node <code>r:codeIds</code> as a child of
the top-level node (or within an invisible node), we read its contents as  a sequence of line
separated <code>id</code> values as if they had been specified via the
argument <code>ids</code> to this function.
</p>
<p>We can also use XSL to extract the code. See <code>getCode.xsl</code>
in the Omegahat XSL collection.
</p>
<p>This particular version (as opposed to other implementations) uses
XPath to conveniently find the nodes of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlSource(url, ...,
          envir = globalenv(),
          xpath = character(),
          ids = character(),
          omit = character(),
          ask = FALSE,
          example = NA,
          fatal = TRUE, verbose = TRUE, echo = verbose, print = echo,
          xnodes = DefaultXMLSourceXPath,
          namespaces = DefaultXPathNamespaces, section = character(),
          eval = TRUE, init = TRUE, setNodeNames = FALSE, parse = TRUE,
          force = FALSE)
xmlSourceFunctions(doc, ids = character(), parse = TRUE, ...)
xmlSourceSection(doc, ids = character(),
                 xnodes = c(".//r:function", ".//r:init[not(@eval='false')]", 
                            ".//r:code[not(@eval='false')]",
                            ".//r:plot[not(@eval='false')]"),
                 namespaces = DefaultXPathNamespaces, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlSource_+3A_url">url</code></td>
<td>
<p>the name of the file, URL  containing the XML document, or
an XML string. This is passed to <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
which is called with <code>useInternalNodes = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code></p>
</td></tr>
<tr><td><code id="xmlSource_+3A_envir">envir</code></td>
<td>
<p>the environment in which the code elements of the XML
document are to be evaluated. By default, they are evaluated
in the global environment so that assignments take place there.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_xpath">xpath</code></td>
<td>
<p>a string giving an XPath expression which is used after
parsing the document to filter the document to a particular subset of
nodes.  This allows one to restrict the evaluation to a subset of
the original document. One can do this directly by
parsing the XML document, applying the XPath query and then passing
the resulting node set to this <code>xmlSource</code> function's
appropriate method.  This argument merely allows for a more
convenient form of those steps, collapsing it into one action.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_ids">ids</code></td>
<td>
<p>a character vector.  XML nodes containing R code
(e.g. <code>r:code</code>, <code>r:init</code>, <code>r:function</code>,
<code>r:plot</code>) can have an id attribute. This vector
allows the caller to specify the subset of these nodes
to process, i.e. whose code will be evaluated.
The order is currently not important. It may be used
in the future to specify the order in which the nodes are evaluated.
</p>
<p>If this is not specified and the document has a node
<code>r:codeIds</code> as an immediate child of the top-most node,
the contents of this node or contained within an <code>invisible</code>
node (so that it doesn't have to be filtered when rendering the
document), the names of the r:code id values to process are taken
as the individual lines from the body of this node.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_omit">omit</code></td>
<td>
<p>a character vector. The values of the id attributes of the
nodes that we want to skip or omit from the evaluation. This allows
us to specify the set that we don't want evaluated, in contrast to the
<code>ids</code> argument.
The order is not important.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_ask">ask</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_example">example</code></td>
<td>
<p>a character or numeric vector specifying the values of the id
attributes of any <code>r:example</code> nodes in the document.
A single document may contain numerous, separate examples
and these can be marked uniquely using an <code>id</code> attribute,
e.g. <code>&lt;r:example id=''</code>.  This argument allows the caller to
specify which example (or examples) to run.
If this is not specified by the caller and there are r:example
nodes in the document, the user is prompted to select an example via
a (text-based) menu.
If a character vector is given by the caller, we use
partial matching against the collection of <code>id</code> attributes
of the r:example nodes to identify the examples of interest.
Alternatively, one can specify the example(s) to run by number.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_fatal">fatal</code></td>
<td>
<p>(currently unused) a logical value. The idea is to
control how we handle errors when evaluating individual code
segments.  We could recover from errors and continue processing
subsequent nodes.</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_verbose">verbose</code></td>
<td>
<p>a logical value. If <code>TRUE</code>, information about what
code segments are being evaluated is displayed on the console.
<code>echo</code> controls whether code is displayed, but this controls
whether additional informatin is also displayed.
See <code><a href="base.html#topic+source">source</a></code>.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_xnodes">xnodes</code></td>
<td>
<p>a character vector.  This is a collection of xpath
expressions given as individual strings which find the
nodes whose contents we evaluate.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_echo">echo</code></td>
<td>
<p>a logical value indicating whether to display the code
before it is evaluated.</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_namespaces">namespaces</code></td>
<td>
<p>a named character vector (i.e. name = value pairs of
strings) giving the prefix - URI pairings for the namespaces used in
the XPath expressions. The URIs must match those in the document,
but the prefixes are local to the XPath expression.
The default provides mappings for the prefixes &quot;r&quot;, &quot;omg&quot;,
&quot;perl&quot;, &quot;py&quot;, and so on. See <code>XML:::DefaultXPathNamespaces</code>.
</p>
</td></tr>    
<tr><td><code id="xmlSource_+3A_section">section</code></td>
<td>
<p>a vector of numbers or  strings.  This allows the caller to 
specify that the function should only look for R-related 
nodes within the specified section(s). This is useful
for being able to easily  process only the code in a particular subset of the document
identified by a DocBook <code>section</code> node.  A string value is used to
match  the <code>id</code> attribute of the <code>section</code> node.
A number (assumed to be an integer) is used to index the set of 
<code>section</code> nodes. These amount to XPath expressions of the form
<code>//section[number]</code> and <code>//section[@id = string]</code>.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_print">print</code></td>
<td>
<p>a logical value indicating whether to print the results</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_eval">eval</code></td>
<td>
<p>a logical value indicating whether to evaluate the code in
the specified nodes or to just return the result of parsing the text
in each node.</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_init">init</code></td>
<td>
<p>a logical controlling whether to run the R code in any
r:init nodes.</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_doc">doc</code></td>
<td>
<p>the XML document, either a file name, the content of the document or the parsed document.</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_parse">parse</code></td>
<td>
<p>a logical value that controls whether we parse the code or
just return the text representation from the XML without parsing it.
This allows us to get just the code.</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_setnodenames">setNodeNames</code></td>
<td>
<p>a logical value that controls whether we compute
the name for each node (or result) by finding is id or name
attribute or enclosing task node.
</p>
</td></tr>
<tr><td><code id="xmlSource_+3A_force">force</code></td>
<td>
<p>a logical value. If this is <code>TRUE</code>, the function
will evaluate the code in a node even if it is explicitly marked
as not to be evaluated with <code>eval = "false"</code>, either on the node
itself or an ancestor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This evaluates the <code>code</code>, <code>function</code> and <code>example</code>
elements in the XML content that have the appropriate namespace
(i.e. r, s, or no namespace)
and discards all others. It also discards r:output nodes
from the text, along with processing instructions and comments.
And it resolves <code>r:frag</code> or <code>r:code</code> nodes with a <code>ref</code>
attribute by identifying the corresponding <code>r:code</code> node with the
same value for its <code>id</code> attribute and then evaluating that node
in place of the <code>r:frag</code> reference.
</p>


<h3>Value</h3>

<p>An R object (typically a list) that contains the results of
evaluating the content of the different selected code segments
in the XML document.  We use <code><a href="base.html#topic+sapply">sapply</a></code> to
iterate over the nodes and so If the results of all the nodes
A list giving the pairs of expressions and evaluated objects
for each of the different XML elements processed.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang &lt;duncan@wald.ucdavis.edu&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> xmlSource(system.file("exampleData", "Rsource.xml", package="XML"))

  # This illustrates using r:frag nodes.
  # The r:frag nodes are not processed directly, but only
  # if referenced in the contents/body of a r:code node
 f = system.file("exampleData", "Rref.xml", package="XML")
 xmlSource(f)
</code></pre>

<hr>
<h2 id='xmlStopParser'>Terminate an XML parser</h2><span id='topic+xmlStopParser'></span>

<h3>Description</h3>

<p>This function allows an R-level function to terminate an
XML parser before it completes the processing of the XML content.
This might be useful, for example, in event-driven parsing
with <code><a href="#topic+xmlEventParse">xmlEventParse</a></code>  when we want 
to read through an XML file until we find a record of interest.
Then, having retrieved the necessary information, we want to 
terminate the parsing rather than let it pointlessly continue.
Instead of raising an error in our handler function, we can call
<code>xmlStopParser</code> and return. The parser will then take control
again and terminate and return back to the original R function from
which it was invoked. 
</p>
<p>The only argument to this function is a reference to internal C-level 
which identifies the parser.   This is passed by the R-XML parser
mechanism to a function invoked by the parser if that function
inherits (in the S3 sense) from the class <code>XMLParserContextFunction</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlStopParser(parser)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlStopParser_+3A_parser">parser</code></td>
<td>
<p> an object of class <code>XMLParserContext</code>
which must have been obtained by via an
<code>XMLParserContextFunction</code> function
called by the parser. This is just a handler function whose class
includes <code>XMLParserContextFunction</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if it succeeded and an error is raised 
if the <code>parser</code> object  is not valid.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>References</h3>

<p>libxml2 <a href="http://xmlsoft.org">http://xmlsoft.org</a></p>


<h3>See Also</h3>

 
<p><code><a href="#topic+xmlEventParse">xmlEventParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  ############################################
  # Stopping the parser mid-way and an example of using XMLParserContextFunction.

  startElement =
  function(ctxt, name, attrs, ...)  {
    print(ctxt)
      print(name)
      if(name == "rewriteURI") {
           cat("Terminating parser\n")
	   xmlStopParser(ctxt)
      }
  }
  class(startElement) = "XMLParserContextFunction"  
  endElement =
  function(name, ...) 
    cat("ending", name, "\n")

  fileName = system.file("exampleData", "catalog.xml", package = "XML")
  xmlEventParse(fileName, handlers = list(startElement = startElement, endElement = endElement))
</code></pre>

<hr>
<h2 id='xmlStructuredStop'>Condition/error handler functions for XML parsing</h2><span id='topic+xmlStructuredStop'></span><span id='topic+xmlErrorCumulator'></span>

<h3>Description</h3>

<p>These functions provide basic error handling for the XML parser in
R. They also illustrate the basics which will allow others to
provide customized error handlers that make more use of the
information provided in each error reported.
</p>
<p>The <code>xmlStructuredStop</code> function provides a simple R-level handler for errors
raised by the XML parser.
It collects the information provided by the XML parser and
raises an R error.
This is only used if <code>NULL</code> is specified for the
<code>error</code> argument of <code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>,
<code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code> and <code><a href="#topic+htmlTreeParse">htmlTreeParse</a></code>.
</p>
<p>The default is to use the function returned by a call to 
<code>xmlErrorCumulator</code> as the error handler.
This, as the name suggests, cumulates errors.
The idea is to catch each error and let the parser continue
and then report them all.
As each error is encountered, it is collected by the function.
If <code>immediate</code> is <code>TRUE</code>, the error is also reported on
the console.
When the parsing is complete and has failed, this function is
invoked again with a zero-length character vector as the 
message (first argument) and then it raises an error.
This function will then raise an R condition of class <code>class</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlStructuredStop(msg, code, domain, line, col, level, filename, 
                    class = "XMLError") 
xmlErrorCumulator(class = "XMLParserErrorList", immediate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlStructuredStop_+3A_msg">msg</code></td>
<td>
<p>character string, the text of the message being reported</p>
</td></tr>
<tr><td><code id="xmlStructuredStop_+3A_code">code</code></td>
<td>
<p>     an integer code giving an identifier for the error (see
xmlerror.h) for the moment,</p>
</td></tr>
<tr><td><code id="xmlStructuredStop_+3A_domain">domain</code></td>
<td>
<p>     an integer domain indicating in which &quot;module&quot; or part of the
parsing the error occurred, e.g. name space, parser, tree, xinclude, etc.</p>
</td></tr>
<tr><td><code id="xmlStructuredStop_+3A_line">line</code></td>
<td>
<p>    an integer giving the line number in the XML content
being processed corresponding to the error,  </p>
</td></tr>
<tr><td><code id="xmlStructuredStop_+3A_col">col</code></td>
<td>
<p>    an integer giving the column position of the error,  </p>
</td></tr>
<tr><td><code id="xmlStructuredStop_+3A_level">level</code></td>
<td>
<p>     an integer giving the severity of the error ranging from 1 to 3 in
increasing severity (warning, error, fatal),</p>
</td></tr>
<tr><td><code id="xmlStructuredStop_+3A_filename">filename</code></td>
<td>
<p>character string,   the name of the document being processed, i.e. its file name or
URL.</p>
</td></tr>
<tr><td><code id="xmlStructuredStop_+3A_class">class</code></td>
<td>
<p> character vector,  any classes to prepend to the class
attribute to make the error/condition. These are prepended to those
returned via <code><a href="base.html#topic+simpleError">simpleError</a></code>.</p>
</td></tr>
<tr><td><code id="xmlStructuredStop_+3A_immediate">immediate</code></td>
<td>
<p>logical value,  if  <code>TRUE</code> errors are
displayed on the R console as they are encountered. Otherwise, the
errors are collected and displayed at the end of the XML parsing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This calls <code><a href="base.html#topic+stop">stop</a></code> and so does not return a value.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang</p>


<h3>References</h3>

<p>libxml2 and its error handling facilities (<a href="http://xmlsoft.org">http://xmlsoft.org</a></p>


<h3>See Also</h3>

 
<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+xmlInternalTreeParse">xmlInternalTreeParse</a></code>
<code><a href="#topic+htmlTreeParse">htmlTreeParse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  tryCatch( xmlTreeParse("&lt;a&gt;&lt;b&gt;&lt;/a&gt;", asText = TRUE, error = NULL),
                 XMLError = function(e) {
                    cat("There was an error in the XML at line", 
                          e$line, "column", e$col, "\n",
                         e$message, "\n")
                })
</code></pre>

<hr>
<h2 id='xmlToDataFrame'>Extract data from a simple XML document</h2><span id='topic+xmlToDataFrame'></span><span id='topic+xmlToDataFrame+2Ccharacter+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+xmlToDataFrame+2CXMLInternalDocument+2CANY+2CANY+2CANY+2Cmissing-method'></span><span id='topic+xmlToDataFrame+2CANY+2CANY+2CANY+2CANY+2CXMLNodeSet-method'></span><span id='topic+xmlToDataFrame+2CANY+2CANY+2CANY+2CANY+2CXMLInternalNodeList-method'></span><span id='topic+xmlToDataFrame+2CANY+2CANY+2CANY+2CANY+2Clist-method'></span><span id='topic+xmlToDataFrame+2CXMLInternalNodeList+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+xmlToDataFrame+2CXMLInternalElementNode+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+xmlToDataFrame+2CXMLNodeSet+2CANY+2CANY+2CANY+2CANY-method'></span><span id='topic+xmlToDataFrame+2Clist+2CANY+2CANY+2CANY+2CANY-method'></span>

<h3>Description</h3>

<p>This function can be used to extract data from
an XML document (or sub-document) that has a simple, shallow structure
that does appear reasonably commonly.
The idea is that there is a collection of nodes which have
the same fields (or a subset of common fields)
which contain primitive values, i.e. numbers, strings, etc.
Each node corresponds to an &quot;observation&quot; and each of its
sub-elements correspond to a variable.
This function then builds the corresponding data frame,
using the union of the variables in the different observation nodes.
This can handle the case where the nodes do not all have all of the variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlToDataFrame(doc, colClasses = NULL, homogeneous = NA,
               collectNames = TRUE, nodes = list(),
               stringsAsFactors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlToDataFrame_+3A_doc">doc</code></td>
<td>
<p>the XML content. This can be the name of a file containing
the XML, the parsed XML document. If one wants to work on a subset
of nodes, specify these via the <code>nodes</code> parameter.</p>
</td></tr>
<tr><td><code id="xmlToDataFrame_+3A_colclasses">colClasses</code></td>
<td>
<p>a list/vector giving the names of the R types for the
corresponding variables and this is used to coerce the resulting
column in the data frame to this type. These can be named. This is similar to
the <code>colClasses</code> parameter for <code><a href="utils.html#topic+read.table">read.table</a></code>.
If this is given as a list, columns in the data frame
corresponding to elements that are <code>NULL</code> are omitted from the
answer.
This can be slightly complex to specify if the
different nodes have the &quot;variables&quot; in quite different order
as there is not a well defined order for the variables
corresponding to <code>colClasses</code>.
</p>
</td></tr>
<tr><td><code id="xmlToDataFrame_+3A_homogeneous">homogeneous</code></td>
<td>
<p>a logical value that indicates whether each of the
nodes contains all of the variables (<code>TRUE</code>) or if there
may be some nodes which have only a subset of them.
The function determines this if the caller does not specify
<code>homogeneous</code> or uses <code>NA</code> as the value.
It is a parameter to allow  the caller to specify this information
and avoid these &quot;extra&quot; computations. If the caller knows this
information it is more efficient to specify it.
</p>
</td></tr>
<tr><td><code id="xmlToDataFrame_+3A_collectnames">collectNames</code></td>
<td>
<p>a logical value indicating whether we compute the
names by explicitly computing the union of all variable names
or, if <code>FALSE</code>, we use the names from the node with the most
children.
This latter case is useful when the caller knows that the
there is at least one node with all the variables.
</p>
</td></tr>
<tr><td><code id="xmlToDataFrame_+3A_nodes">nodes</code></td>
<td>
<p>a list of XML nodes which are to be processed</p>
</td></tr>
<tr><td><code id="xmlToDataFrame_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>a logical value that controls whether
character vectors are converted to factor objects in the resulting
data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlParse">xmlParse</a></code>
<code><a href="#topic+getNodeSet">getNodeSet</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> f = system.file("exampleData", "size.xml", package = "XML")
 xmlToDataFrame(f, c("integer", "integer", "numeric"))

   # Drop the middle variable.
 z = xmlToDataFrame(f, colClasses = list("integer", NULL, "numeric"))


   #  This illustrates how we can get a subset of nodes and process
   #  those as the "data nodes", ignoring the others.
  f = system.file("exampleData", "tides.xml", package = "XML")
  doc = xmlParse(f)
  xmlToDataFrame(nodes = xmlChildren(xmlRoot(doc)[["data"]]))

    # or, alternatively
  xmlToDataFrame(nodes = getNodeSet(doc, "//data/item"))


  f = system.file("exampleData", "kiva_lender.xml", package = "XML")
  doc = xmlParse(f)
  dd = xmlToDataFrame(getNodeSet(doc, "//lender"))
</code></pre>

<hr>
<h2 id='xmlToList'>Convert an XML node/document to a more R-like list</h2><span id='topic+xmlToList'></span>

<h3>Description</h3>

<p>This function is an early and simple approach to converting
an XML node or document into a more typical R list containing
the data values directly (rather than as XML nodes).
It is useful for dealing with data that is returned from
REST requests or other Web queries or generally when parsing
XML and wanting to  be able to access the content
as elements in a list indexed by the name of the node.
For example, if given a node of the form
<code>
  &lt;x&gt;
     &lt;a&gt;text&lt;/a&gt;
     &lt;b foo="1"/&gt;
     &lt;c bar="me"&gt;
        &lt;d&gt;a phrase&lt;/d&gt;
     &lt;/c&gt;
  &lt;/x&gt;
</code>
We would end up with a list with elements named &quot;a&quot;, &quot;b&quot; and &quot;c&quot;.
&quot;a&quot; would be the string &quot;text&quot;, b would contain the named character
vector <code>c(foo = "1")</code> (i.e. the attributes) and &quot;c&quot; would
contain the list with two elements named &quot;d&quot; and &quot;.attrs&quot;.
The element corresponding to &quot;d&quot; is a
character vector with the single element &quot;a phrase&quot;. 
The &quot;.attrs&quot; element of the list is the character vector of
attributes from the node <code>&lt;c&gt;...&lt;/c&gt;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlToList(node, addAttributes = TRUE, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlToList_+3A_node">node</code></td>
<td>
<p>the XML node or document to be converted to an R list.
This can be an &quot;internal&quot; or C-level node (i.e. <code><a href="#topic+XMLInternalNode-class">XMLInternalNode-class</a></code>)
or a regular R-level node (either <code><a href="#topic+XMLNode-class">XMLNode-class</a></code> or <code>XMLHashNode</code>).</p>
</td></tr>
<tr><td><code id="xmlToList_+3A_addattributes">addAttributes</code></td>
<td>
<p>a logical value which controls whether the attributes of an empty node
are added to the </p>
</td></tr>
<tr><td><code id="xmlToList_+3A_simplify">simplify</code></td>
<td>
<p>a logical value that controls whether we collapse
the list to a vector if the elements all have a common compatible
type. Basically, this controls whether we use <code>sapply</code> or <code>lapply</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list whose elements correspond to the children of the top-level nodes.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlTreeParse">xmlTreeParse</a></code>
<code><a href="#topic+getNodeSet">getNodeSet</a></code> and <code><a href="#topic+xpathApply">xpathApply</a></code>
<code><a href="#topic+xmlRoot">xmlRoot</a></code>,  <code><a href="#topic+xmlChildren">xmlChildren</a></code>,  <code><a href="#topic+xmlApply">xmlApply</a></code>, <code>[[</code>, etc. for
accessing the content of XML nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tt = 
 '&lt;x&gt;
     &lt;a&gt;text&lt;/a&gt;
     &lt;b foo="1"/&gt;
     &lt;c bar="me"&gt;
        &lt;d&gt;a phrase&lt;/d&gt;
     &lt;/c&gt;
  &lt;/x&gt;'

  doc = xmlParse(tt)
  xmlToList(doc)

   # use an R-level node representation
  doc = xmlTreeParse(tt)
  xmlToList(doc)
</code></pre>

<hr>
<h2 id='xmlToS4'>General mechanism for mapping an XML node to an S4 object</h2><span id='topic+xmlToS4'></span><span id='topic+xmlToS4+2CXMLInternalNode-method'></span>

<h3>Description</h3>

<p>This generic function  and its methods recursively process
an XML node and its child nodes ( and theirs and so on)
to map the nodes to S4 objects.
</p>
<p>This is the run-time function that corresponds to the
<code><a href="#topic+makeClassTemplate">makeClassTemplate</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlToS4(node, obj = new(xmlName(node)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlToS4_+3A_node">node</code></td>
<td>
<p>the top-level XML node to convert to an S4 object</p>
</td></tr>
<tr><td><code id="xmlToS4_+3A_obj">obj</code></td>
<td>
<p>the object whose slots are to be filled from the
information in the XML node</p>
</td></tr>
<tr><td><code id="xmlToS4_+3A_...">...</code></td>
<td>
<p>additional parameters for methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object <code>obj</code> whose slots have been modified.
</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeClassTemplate">makeClassTemplate</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> txt = paste0("&lt;doc&gt;&lt;part&gt;&lt;name&gt;ABC&lt;/name&gt;&lt;type&gt;XYZ&lt;/type&gt;',
              &lt;cost&gt;3.54&lt;/cost&gt;&lt;status&gt;available&lt;/status&gt;&lt;/part&gt;&lt;/doc&gt;")
 doc = xmlParse(txt)

 setClass("part", representation(name = "character",
                                 type = "character",
                                 cost = "numeric",
                                 status= "character"))
 xmlToS4(xmlRoot(doc)[["part"]])
</code></pre>

<hr>
<h2 id='xmlTree'>An internal, updatable DOM object for building XML trees</h2><span id='topic+xmlTree'></span>

<h3>Description</h3>

<p>This is a mutable object (implemented via a closure)
for representing an XML tree, in the same
spirit as <code><a href="#topic+xmlOutputBuffer">xmlOutputBuffer</a></code>
and <code><a href="#topic+xmlOutputDOM">xmlOutputDOM</a></code>
but that uses the internal structures of
libxml.
This can be used to create a DOM that can be 
constructed in R and exported to another system
such as XSLT (<a href="https://www.omegahat.net/Sxslt/">https://www.omegahat.net/Sxslt/</a>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlTree(tag, attrs = NULL, dtd=NULL, namespaces=list(),
          doc = newXMLDoc(dtd, namespaces))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlTree_+3A_tag">tag</code></td>
<td>
<p>the node or element name to use to create the new top-level node in the tree
or alternatively, an <code>XMLInternalNode</code> that was already
created.
This is optional. If it is not specified, no top-most node is
created but can be added using <code>addNode</code>.
If a top-level tag is added in the call to
<code>xmlTree</code>,  that becomes the currently active or open
node (e.g. same as <code>addNode( ..., close = FALSE)</code>)
and nodes subsequently added to this
</p>
</td></tr>
<tr><td><code id="xmlTree_+3A_attrs">attrs</code></td>
<td>
<p>attributes for the top-level node, in the form of a named
character vector.</p>
</td></tr>
<tr><td><code id="xmlTree_+3A_dtd">dtd</code></td>
<td>
<p>the name of the external DTD for this document.
If specified, this adds the DOCTYPE node to the resulting document.
This can be a node created earlier with a call to 
<code><a href="#topic+newXMLDTDNode">newXMLDTDNode</a></code>, or alternatively it can be a
character vector with 1, 2 or 3 elements
giving the name of the top-level node, and the public identifier
and the system identifier for the DTD in that order.
</p>
</td></tr>
<tr><td><code id="xmlTree_+3A_namespaces">namespaces</code></td>
<td>
<p>a named character vector with each element giving the name space identifier and the
corresponding URI, \
e.g <code>c(shelp = "https://www.omegahat.net/XML/SHelp")</code>
If <code>tag</code> is specified as a character vector, these name spaces
are defined within that new node.
</p>
</td></tr>
<tr><td><code id="xmlTree_+3A_doc">doc</code></td>
<td>
<p>an internal XML document object, typically created with
<code><a href="#topic+newXMLDoc">newXMLDoc</a></code>. This is used as the host document for all
the new nodes that will be created  as part of this document.
If one wants to create nodes without an internal document ancestor,
one can alternatively specify this is as  <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This creates a collection of functions that manipulate a shared
state to build and maintain an XML tree in C-level code.
</p>


<h3>Value</h3>

<p>An object of class
<code>XMLInternalDOM</code>
that extends <code>XMLOutputStream</code>
and has the same interface (i.e. &ldquo;methods&rdquo;) as
<code><a href="#topic+xmlOutputBuffer">xmlOutputBuffer</a></code> 
and <code><a href="#topic+xmlOutputDOM">xmlOutputDOM</a></code>.
Each object has methods for 
adding a new XML tag, 
closing a tag, adding an XML comment,
and retrieving the contents of the tree.
</p>
<table>
<tr><td><code>addTag</code></td>
<td>
<p>create a new tag at the current position,
optionally leaving it as the active open tag to which
new nodes will be added as children</p>
</td></tr>
<tr><td><code>closeTag</code></td>
<td>
<p>close the currently active tag
making its parent the active element into
which new nodes will be added.</p>
</td></tr>
<tr><td><code>addComment</code></td>
<td>
<p>add an XML comment node
as a child of the active node in the document.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>retrieve an object representing the 
XML tree. See <code><a href="#topic+saveXML">saveXML</a></code> to serialize the
contents of the tree.</p>
</td></tr>
<tr><td><code>add</code></td>
<td>
<p>degenerate method in this context.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is an early version of this function and I need to iron out some
of the minor details.</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.xmlsoft.org">http://www.xmlsoft.org</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+saveXML">saveXML</a></code>
<code><a href="#topic+newXMLDoc">newXMLDoc</a></code>
<code><a href="#topic+newXMLNode">newXMLNode</a></code>
<code><a href="#topic+xmlOutputBuffer">xmlOutputBuffer</a></code>
<code><a href="#topic+xmlOutputDOM">xmlOutputDOM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z = xmlTree("people", namespaces = list(r = "http://www.r-project.org"))
z$setNamespace("r")

z$addNode("person", attrs = c(id = "123"), close = FALSE)
  z$addNode("firstname", "Duncan")
  z$addNode("surname", "Temple Lang")
  z$addNode("title", "Associate Professor")
  z$addNode("expertize", close = FALSE)
     z$addNode("topic", "Data Technologies")
     z$addNode("topic", "Programming Language Design")
     z$addNode("topic", "Parallel Computing")
     z$addNode("topic", "Data Visualization")
     z$addNode("topic", "Meta-Computing")
     z$addNode("topic", "Inter-system interfaces")
  z$closeTag()
  z$addNode("address", "4210 Mathematical Sciences Building, UC Davis")
z$closeTag()

  tr &lt;- xmlTree("CDataTest")
  tr$addTag("top", close=FALSE)
  tr$addCData("x &lt;- list(1, a='&amp;');\nx[[2]]")
  tr$addPI("S", "plot(1:10)")
  tr$closeTag()
  cat(saveXML(tr$value()))


  f = tempfile()
  saveXML(tr, f, encoding = "UTF-8")


  # Creating a node
x = rnorm(3)
z = xmlTree("r:data", namespaces = c(r = "http://www.r-project.org"))
z$addNode("numeric", attrs = c("r:length" = length(x)))


  # shows namespace prefix on an attribute, and different from the one on the node.
  z = xmlTree()
z$addNode("r:data",  namespace = c(r = "http://www.r-project.org",
                                   omg = "https://www.omegahat.net"),
         close = FALSE)
x = rnorm(3)
z$addNode("r:numeric", attrs = c("omg:length" = length(x)))


z = xmlTree("examples")
z$addNode("example", namespace = list(r = "http://www.r-project.org"), close = FALSE)
z$addNode("code", "mean(rnorm(100))", namespace = "r")


x = summary(rnorm(1000))
d = xmlTree()
d$addNode("table", close = FALSE)

d$addNode("tr", .children = sapply(names(x), function(x) d$addNode("th", x)))
d$addNode("tr", .children = sapply(x, function(x) d$addNode("td", format(x))))

d$closeNode()
cat(saveXML(d))

# Dealing with DTDs and system and public identifiers for DTDs.
# Just doctype
za = xmlTree("people", dtd = "people")
### www.omegahat.net is flaky
# no public element
zb = xmlTree("people",
             dtd = c("people", "", "https://www.omegahat.net/XML/types.dtd"))
# public and system
zc = xmlTree("people",
             dtd = c("people", "//a//b//c//d",
                     "https://www.omegahat.net/XML/types.dtd"))
</code></pre>

<hr>
<h2 id='xmlTreeParse'>XML Parser</h2><span id='topic+xmlTreeParse'></span><span id='topic+htmlTreeParse'></span><span id='topic+htmlParse'></span><span id='topic+xmlInternalTreeParse'></span><span id='topic+xmlNativeTreeParse'></span><span id='topic+xmlParse'></span><span id='topic+xmlSchemaParse'></span>

<h3>Description</h3>

<p>Parses an XML or HTML file or string containing XML/HTML content, and generates an R 
structure representing the XML/HTML tree.  Use <code>htmlTreeParse</code> when the content is known
to be (potentially malformed) HTML.
This function has numerous parameters/options and operates quite differently
based on  their values.
It can create trees in R or using internal C-level nodes, both of
which are useful in different contexts.
It can perform conversion of the nodes into R objects using
caller-specified  handler functions and this can be used to 
map the XML document directly into R data structures,
by-passing the conversion to an R-level tree which would then
be processed recursively or with multiple descents to extract the
information of interest.
</p>
<p><code>xmlParse</code> and <code>htmlParse</code> are equivalent to the
<code>xmlTreeParse</code> and <code>htmlTreeParse</code> respectively,
except they both use a default value for the <code>useInternalNodes</code> parameter 
of <code>TRUE</code>, i.e. they working with and return internal
nodes/C-level nodes.  These can then be searched using
XPath expressions via <code><a href="#topic+xpathApply">xpathApply</a></code> and 
<code><a href="#topic+getNodeSet">getNodeSet</a></code>.
</p>
<p><code>xmlSchemaParse</code> is a convenience function for parsing an XML schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlTreeParse(file, ignoreBlanks=TRUE, handlers=NULL, replaceEntities=FALSE,
             asText=FALSE, trim=TRUE, validate=FALSE, getDTD=TRUE,
             isURL=FALSE, asTree = FALSE, addAttributeNamespaces = FALSE,
             useInternalNodes = FALSE, isSchema = FALSE,
             fullNamespaceInfo = FALSE, encoding = character(),
             useDotNames = length(grep("^\\.", names(handlers))) &gt; 0,
             xinclude = TRUE, addFinalizer = TRUE, error = xmlErrorCumulator(),
             isHTML = FALSE, options = integer(), parentFirst = FALSE)

xmlInternalTreeParse(file, ignoreBlanks=TRUE, handlers=NULL, replaceEntities=FALSE,
             asText=FALSE, trim=TRUE, validate=FALSE, getDTD=TRUE,
             isURL=FALSE, asTree = FALSE, addAttributeNamespaces = FALSE,
             useInternalNodes = TRUE, isSchema = FALSE,
             fullNamespaceInfo = FALSE, encoding = character(),
             useDotNames = length(grep("^\\.", names(handlers))) &gt; 0,
             xinclude = TRUE, addFinalizer = TRUE, error = xmlErrorCumulator(),
             isHTML = FALSE, options = integer(), parentFirst = FALSE)

xmlNativeTreeParse(file, ignoreBlanks=TRUE, handlers=NULL, replaceEntities=FALSE,
             asText=FALSE, trim=TRUE, validate=FALSE, getDTD=TRUE,
             isURL=FALSE, asTree = FALSE, addAttributeNamespaces = FALSE,
             useInternalNodes = TRUE, isSchema = FALSE,
             fullNamespaceInfo = FALSE, encoding = character(),
             useDotNames = length(grep("^\\.", names(handlers))) &gt; 0,
             xinclude = TRUE, addFinalizer = TRUE, error = xmlErrorCumulator(),
             isHTML = FALSE, options = integer(), parentFirst = FALSE)


htmlTreeParse(file, ignoreBlanks=TRUE, handlers=NULL, replaceEntities=FALSE,
             asText=FALSE, trim=TRUE, validate=FALSE, getDTD=TRUE,
             isURL=FALSE, asTree = FALSE, addAttributeNamespaces = FALSE,
             useInternalNodes = FALSE, isSchema = FALSE,
             fullNamespaceInfo = FALSE, encoding = character(),
             useDotNames = length(grep("^\\.", names(handlers))) &gt; 0,
             xinclude = TRUE, addFinalizer = TRUE, error = htmlErrorHandler,
             isHTML = TRUE, options = integer(), parentFirst = FALSE)

htmlParse(file, ignoreBlanks = TRUE, handlers = NULL, replaceEntities = FALSE, 
          asText = FALSE, trim = TRUE, validate = FALSE, getDTD = TRUE, 
           isURL = FALSE, asTree = FALSE, addAttributeNamespaces = FALSE, 
            useInternalNodes = TRUE, isSchema = FALSE, fullNamespaceInfo = FALSE, 
             encoding = character(), 
             useDotNames = length(grep("^\\.", names(handlers))) &gt; 0, 
              xinclude = TRUE, addFinalizer = TRUE, 
               error = htmlErrorHandler, isHTML = TRUE,
                options = integer(), parentFirst = FALSE) 

xmlSchemaParse(file, asText = FALSE, xinclude = TRUE, error = xmlErrorCumulator())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlTreeParse_+3A_file">file</code></td>
<td>
<p> The name of the file containing the XML contents.
This can contain ~ which is expanded to the user's
home directory.
It can also be a URL. See <code>isURL</code>.
Additionally, the file can be compressed (gzip)
and is read directly without the user having
to de-compress (gunzip) it.</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_ignoreblanks">ignoreBlanks</code></td>
<td>
<p> logical value indicating whether
text elements made up entirely of white space should be included
in the resulting &lsquo;tree&rsquo;. </p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_handlers">handlers</code></td>
<td>
<p>Optional collection of functions
used to map the different XML nodes to R
objects. Typically, this is a named list of functions,
and a closure can be used to provide local data.
This provides a way of filtering the tree as it is being
created in R, adding or removing nodes, and generally processing
them as they are constructed in the C code.
</p>
<p>In a recent addition to the package (version 0.99-8),
if this is specified as a single function object,
we call that function for each node (of any type) in the underlying DOM tree.
It is invoked with the new node and its parent node.
This applies to regular nodes and also comments, processing
instructions, CDATA nodes, etc.  So this function must be
sufficiently general to handle them all.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_replaceentities">replaceEntities</code></td>
<td>

<p>logical value indicating whether to substitute entity references
with their text directly. This should be left as False.
The text still appears as the value of the node, but there
is more information about its source, allowing the parse to be reversed
with full reference information.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_astext">asText</code></td>
<td>
<p>logical value indicating that the first argument,
<code>file</code>, 
should be treated as the XML text to parse, not the name of 
a file. This allows the contents of documents to be retrieved 
from different sources (e.g. HTTP servers, XML-RPC, etc.) and still
use this parser.</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_trim">trim</code></td>
<td>

<p>whether to strip white space from the beginning and end of text strings.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_validate">validate</code></td>
<td>

<p>logical indicating whether to use a validating parser or not, or in other words
check the contents against the DTD specification. If this is true, warning
messages will be displayed about errors in the DTD and/or document, but the parsing 
will proceed except for the presence of terminal errors.
This is ignored when parsing an HTML document.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_getdtd">getDTD</code></td>
<td>

<p>logical flag indicating whether the DTD (both internal and external)
should be returned along with the document nodes. This changes the 
return type.
This is ignored when parsing an HTML document.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_isurl">isURL</code></td>
<td>

<p>indicates whether the <code>file</code>  argument refers to a URL
(accessible via ftp or http) or a regular file on the system.
If <code>asText</code> is TRUE, this should not be specified.
The function attempts to determine whether the 
data source is a URL by using <code><a href="base.html#topic+grep">grep</a></code>
to look for http or ftp at the start of the string.
The libxml parser handles the connection to servers,
not the R facilities (e.g. <code><a href="base.html#topic+scan">scan</a></code>).
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_astree">asTree</code></td>
<td>
<p>this only applies when on passes a value for
the  <code>handlers</code> argument and is used then to determine
whether the DOM tree should be returned or the <code>handlers</code>
object.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_addattributenamespaces">addAttributeNamespaces</code></td>
<td>
<p>a logical value indicating whether to
return the namespace in the names of the attributes within a node
or to omit them. If this is <code>TRUE</code>, an attribute such as
<code>xsi:type="xsd:string"</code> is reported with the name
<code>xsi:type</code>.
If it is <code>FALSE</code>, the name of the attribute is <code>type</code>.</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_useinternalnodes">useInternalNodes</code></td>
<td>
<p>a logical value indicating whether 
to call the converter functions with objects of class
<code>XMLInternalNode</code> rather than <code>XMLNode</code>.
This should make things faster as we do not convert  the 
contents of the internal nodes to R explicit objects.
Also, it allows one to access the parent and ancestor nodes.
However, since the objects refer to volatile C-level objects,
one cannot store these nodes for use in further computations within R.
They &ldquo;disappear&rdquo; after the processing the XML document is completed.
</p>
<p>If this argument is <code>TRUE</code> and no handlers are provided, the
return value is a reference to the internal C-level document pointer.
This can be used to do post-processing via XPath expressions using
<code><a href="#topic+getNodeSet">getNodeSet</a></code>.
</p>
<p>This is ignored when parsing an HTML document.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_isschema">isSchema</code></td>
<td>
<p>a logical value indicating whether the document
is an XML schema (<code>TRUE</code>) and should be parsed as such using
the built-in schema parser in libxml.</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_fullnamespaceinfo">fullNamespaceInfo</code></td>
<td>
<p>a logical value indicating whether
to provide the namespace URI and prefix on each node
or just the prefix.  The latter (<code>FALSE</code>) is
currently the default as that was the original way the
package behaved.   However, using
<code>TRUE</code> is more informative and we will make this
the default in the future.
</p>
<p>This is ignored when parsing an HTML document.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_encoding">encoding</code></td>
<td>
<p> a character string (scalar) giving the encoding for the
document.  This is optional as the document should contain its own
encoding information. However, if it doesn't, the caller can specify
this for the parser.  If the XML/HTML document does specify its own
encoding that value is used regardless of any value specified by the
caller. (That's just the way it goes!) So this is to be used
as a safety net in case the document does not have an encoding and
the caller happens to know theactual encoding.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_usedotnames">useDotNames</code></td>
<td>
<p>a logical value
indicating whether to use the
newer format for identifying general element function handlers
with the '.' prefix, e.g. .text, .comment, .startElement.
If this is <code>FALSE</code>, then the older format
text, comment, startElement, ...
are used. This causes problems when there are indeed nodes
named text or comment or startElement as a
node-specific handler are confused with the corresponding
general handler of the same name. Using <code>TRUE</code>
means that your list of handlers should have names that use
the '.' prefix for these general element handlers.
This is the preferred way to write new code.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_xinclude">xinclude</code></td>
<td>
<p>a logical value indicating whether
to process nodes of the form <code>&lt;xi:include xmlns:xi="https://www.w3.org/2001/XInclude"&gt;</code>
to insert content from other parts of (potentially different)
documents. <code>TRUE</code> means resolve the external references;
<code>FALSE</code> means leave the node as is.
Of course, one can process these nodes oneself after document has
been parse using handler functions or working on the DOM.
Please note that the syntax for inclusion using XPointer
is not the same as XPath and the results can be a little
unexpected and confusing. See the libxml2 documentation for more details.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_addfinalizer">addFinalizer</code></td>
<td>
<p>a logical value indicating whether the
default finalizer routine should be registered to
free the internal xmlDoc when R no longer has a reference to this
external pointer object. This is only relevant when
<code>useInternalNodes</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_error">error</code></td>
<td>
<p>a function that is invoked when the XML parser reports
an error.
When an error is encountered, this is called with 7 arguments.
See <code><a href="#topic+xmlStructuredStop">xmlStructuredStop</a></code> for information about these
</p>
<p>If parsing completes and no document is generated, this function is
called again with only argument which is a character vector of
length 0.  This gives the function an opportunity to report all the 
errors and raise an exception rather than doing this when it sees
th first one.
</p>
<p>This function can do what it likes with the information.
It can raise an R error or let parser continue and potentially
find further errors.
</p>
<p>The default value of this argument supplies a function that 
cumulates the errors
</p>
<p>If this is <code>NULL</code>, the default error handler function in the
package  <code><a href="#topic+xmlStructuredStop">xmlStructuredStop</a></code> is invoked and this will 
raise an error in R at that time in R.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_ishtml">isHTML</code></td>
<td>
<p>a logical value that allows this function to be used for parsing HTML documents.
This causes validation and processing of a DTD to be turned off.
This is currently experimental so that we can implement
<code>htmlParse</code> with this same function.</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_options">options</code></td>
<td>
<p>an integer value or vector of values that are combined
(OR'ed) together
to specify options for the XML parser. This is the same as the
<code>options</code> parameter for <code><a href="#topic+xmlParseDoc">xmlParseDoc</a></code>.
</p>
</td></tr>
<tr><td><code id="xmlTreeParse_+3A_parentfirst">parentFirst</code></td>
<td>
<p>a logical value for use when we have handler
functions and are traversing the tree.
This controls whether we process
the node before processing its children, or process the children
before their parent node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>handlers</code> argument is used similarly
to those specified in <a href="#topic+xmlEventParse">xmlEventParse</a>.
When an XML tag (element) is processed,
we look for a function in this collection 
with the same name as the tag's name. 
If this is not found, we look for one named
<code>startElement</code>. If this is not found, we use the default
built in converter.
The same works for comments, entity references, cdata, processing instructions,
etc.
The default entries should be named
<code>comment</code>, <code>startElement</code>,
<code>externalEntity</code>,
<code>processingInstruction</code>,
<code>text</code>, <code>cdata</code> and <code>namespace</code>.
All but the last should take the XMLnode as their first argument.
In the future, other information may be passed via ...,
for example, the depth in the tree, etc.
Specifically, the second argument will be the parent node into which they
are being added, but this is not currently implemented,
so should have a default value (<code>NULL</code>).
</p>
<p>The <code>namespace</code> function is called with a single argument which
is an object of class <code>XMLNameSpace</code>.  This contains
</p>
 
<dl>
<dt>id</dt><dd><p>the namespace identifier as used to
qualify tag names;</p>
</dd> 
<dt>uri</dt><dd><p>the value of the namespace identifier,
i.e. the URI
identifying the namespace.</p>
</dd>
<dt>local</dt><dd><p>a logical value indicating whether the definition
is local to the document being parsed.</p>
</dd>
</dl>

<p>One should note that the <code>namespace</code> handler is called before the
node in which the namespace definition occurs and its children are
processed.  This is different than the other handlers which are called
after the child nodes have been processed.
</p>
<p>Each of these functions can return arbitrary values that are then
entered into the tree in place of the default node passed to the
function as the first argument.  This allows the caller to generate
the nodes of the resulting document tree exactly as they wish.  If the
function returns <code>NULL</code>, the node is dropped from the resulting
tree. This is a convenient way to discard nodes having processed their
contents.
</p>


<h3>Value</h3>

<p>By default ( when <code>useInternalNodes</code> is <code>FALSE</code>, 
<code>getDTD</code> is <code>TRUE</code>,  and no
handler functions are provided), the return value is, an object of
(S3) class <code>XMLDocument</code>.
This has two fields named <code>doc</code> and <code>dtd</code>
and are of class <code>DTDList</code> and <code>XMLDocumentContent</code> respectively.
</p>
<p>If <code>getDTD</code> is <code>FALSE</code>,  only the <code>doc</code> object is returned.
</p>
<p>The <code>doc</code> object has three fields of its own:
<code>file</code>, <code>version</code> and <code>children</code>.
</p>
<table>
<tr><td><code>file</code></td>
<td>
<p>The (expanded) name of the file  containing the XML.</p>
</td></tr>
<tr><td><code>version</code></td>
<td>
<p>A string identifying the  version of XML used by the document.</p>
</td></tr>
<tr><td><code>children</code></td>
<td>

<p>A list of the XML nodes at the top of the document.
Each of these is of class <code>XMLNode</code>.
These are made up of 4 fields.
</p>

<dl>
<dt><code>name</code></dt><dd><p>The name of the element.</p>
</dd>
<dt><code>attributes</code></dt><dd><p>For regular elements, a named list
of XML attributes converted from the 
&lt;tag x=&quot;1&quot; y=&quot;abc&quot;&gt;</p>
</dd>
<dt><code>children</code></dt><dd><p>List of sub-nodes.</p>
</dd>
<dt><code>value</code></dt><dd><p>Used only for text entries.</p>
</dd>
</dl>

<p>Some nodes specializations of <code>XMLNode</code>, such as 
<code>XMLComment</code>, <code>XMLProcessingInstruction</code>,
<code>XMLEntityRef</code> are used.
</p>
<p>If the value of the argument getDTD is TRUE and the document refers
to a DTD via a top-level DOCTYPE element, the DTD and its information
will be available in the <code>dtd</code> field.  The second element is a
list containing the external and internal DTDs. Each of these
contains 2 lists - one for element definitions and another for entities. See
<code><a href="#topic+parseDTD">parseDTD</a></code>. 
</p>
<p>If a list of functions is given via <code>handlers</code>, 
this list is returned. Typically, these handler functions
share state via a closure and the resulting updated data structures
which contain the extracted and processed values from the XML
document can be retrieved via a function in this handler list.
</p>
<p>If <code>asTree</code> is <code>TRUE</code>, then the converted tree is returned.
What form this takes depends on what the handler functions have
done to process the XML tree.
</p>
<p>If <code>useInternalNodes</code> is <code>TRUE</code> and no handlers are
specified, an object of S3 class <code>XMLInternalDocument</code> is
returned. This can be used in much the same ways as an
<code>XMLDocument</code>, e.g. with <code><a href="#topic+xmlRoot">xmlRoot</a></code>,
<code><a href="#topic+docName">docName</a></code> and so on to traverse the tree.
It can also be used with XPath queries via <code><a href="#topic+getNodeSet">getNodeSet</a></code>,
<code><a href="#topic+xpathApply">xpathApply</a></code> and <code>doc["xpath-expression"]</code>.
</p>
<p>If internal nodes are used and the internal tree returned directly,
all the nodes are returned as-is and no attempt to 
trim white space, remove &ldquo;empty&rdquo; nodes (i.e. containing only white
space), etc. is done. This is potentially quite expensive and so is
not done generally, but should  be done during the processing
of the nodes.  When using XPath queries, such nodes are easily
identified and/or ignored and so do not cause any difficulties.
They do become an issue when dealing with a node's chidren
directly and so one can use simple filtering techniques such as
<code> xmlChildren(node)[!xmlSApply(node, inherits,  "XMLInternalTextNode")]</code>
and even check the <code><a href="#topic+xmlValue">xmlValue</a></code> to determine if it contains only
white space.
<code> xmlChildren(node)[!xmlSApply(node, function(x) inherit(x,
              "XMLInternalTextNode")] &amp;&amp; trim(xmlValue(x)) == "")</code>
</p>
</td></tr> </table>


<h3>Note</h3>

<p>Make sure  that the necessary 3rd party libraries are available.</p>


<h3>Author(s)</h3>

<p>Duncan Temple Lang &lt;duncan@wald.ucdavis.edu&gt;</p>


<h3>References</h3>

<p><a href="http://xmlsoft.org">http://xmlsoft.org</a>, <a href="https://www.w3.org/XML//">https://www.w3.org/XML//</a></p>


<h3>See Also</h3>

 <p><a href="#topic+xmlEventParse">xmlEventParse</a>,
<code><a href="#topic+free">free</a></code> for releasing the memory when
an <code>XMLInternalDocument</code> object is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> fileName &lt;- system.file("exampleData", "test.xml", package="XML")
   # parse the document and return it in its standard format.

 xmlTreeParse(fileName)

   # parse the document, discarding comments.
  
 xmlTreeParse(fileName, handlers=list("comment"=function(x,...){NULL}), asTree = TRUE)

   # print the entities
 invisible(xmlTreeParse(fileName,
            handlers=list(entity=function(x) {
                                    cat("In entity",x$name, x$value,"\n")
                                    x}
                                  ), asTree = TRUE
                          )
          )

 # Parse some XML text.
 # Read the text from the file
 xmlText &lt;- paste(readLines(fileName), "\n", collapse="")

 print(xmlText)
 xmlTreeParse(xmlText, asText=TRUE)


    # with version 1.4.2 we can pass the contents of an XML
    # stream without pasting them.
 xmlTreeParse(readLines(fileName), asText=TRUE)


 # Read a MathML document and convert each node
 # so that the primary class is 
 #   &lt;name of tag&gt;MathML
 # so that we can use method  dispatching when processing
 # it rather than conditional statements on the tag name.
 # See plotMathML() in examples/.
 fileName &lt;- system.file("exampleData", "mathml.xml",package="XML")
m &lt;- xmlTreeParse(fileName, 
                  handlers=list(
                   startElement = function(node){
                   cname &lt;- paste(xmlName(node),"MathML", sep="",collapse="")
                   class(node) &lt;- c(cname, class(node)); 
                   node
                }))



  # In this example, we extract _just_ the names of the
  # variables in the mtcars.xml file. 
  # The names are the contents of the &lt;variable&gt;
  # tags. We discard all other tags by returning NULL
  # from the startElement handler.
  #
  # We cumulate the names of variables in a character
  # vector named 'vars'.
  # We define this within a closure and define the 
  # variable function within that closure so that it
  # will be invoked when the parser encounters a &lt;variable&gt;
  # tag.
  # This is called with 2 arguments: the XMLNode object (containing
  # its children) and the list of attributes.
  # We get the variable name via call to xmlValue().

  # Note that we define the closure function in the call and then 
  # create an instance of it by calling it directly as
  #   (function() {...})()

  # Note that we can get the names by parsing
  # in the usual manner and the entire document and then executing
  # xmlSApply(xmlRoot(doc)[[1]], function(x) xmlValue(x[[1]]))
  # which is simpler but is more costly in terms of memory.
 fileName &lt;- system.file("exampleData", "mtcars.xml", package="XML")
 doc &lt;- xmlTreeParse(fileName,  handlers = (function() { 
                                 vars &lt;- character(0) ;
                                list(variable=function(x, attrs) { 
                                                vars &lt;&lt;- c(vars, xmlValue(x[[1]])); 
                                                NULL}, 
                                     startElement=function(x,attr){
                                                   NULL
                                                  }, 
                                     names = function() {
                                                 vars
                                             }
                                    )
                               })()
                     )

  # Here we just print the variable names to the console
  # with a special handler.
 doc &lt;- xmlTreeParse(fileName, handlers = list(
                                  variable=function(x, attrs) {
                                             print(xmlValue(x[[1]])); TRUE
                                           }), asTree=TRUE)


  # This should raise an error.
  try(xmlTreeParse(
            system.file("exampleData", "TestInvalid.xml", package="XML"),
            validate=TRUE))

## Not run: 
 # Parse an XML document directly from a URL.
 # Requires Internet access.
 xmlTreeParse("https://www.omegahat.net/Scripts/Data/mtcars.xml", asText=TRUE)

## End(Not run)

  counter = function() {
              counts = integer(0)
              list(startElement = function(node) {
                                     name = xmlName(node)
                                     if(name %in% names(counts))
                                          counts[name] &lt;&lt;- counts[name] + 1
                                     else
                                          counts[name] &lt;&lt;- 1
                                  },
                    counts = function() counts)
            }

   h = counter()
   xmlParse(system.file("exampleData", "mtcars.xml", package="XML"),  handlers = h)
   h$counts()



 f = system.file("examples", "index.html", package = "XML")
 htmlTreeParse(readLines(f), asText = TRUE)
 htmlTreeParse(readLines(f))

  # Same as 
 htmlTreeParse(paste(readLines(f), collapse = "\n"), asText = TRUE)


 getLinks = function() { 
       links = character() 
       list(a = function(node, ...) { 
                   links &lt;&lt;- c(links, xmlGetAttr(node, "href"))
                   node 
                }, 
            links = function()links)
     }

 h1 = getLinks()
 htmlTreeParse(system.file("examples", "index.html", package = "XML"),
               handlers = h1)
 h1$links()

 h2 = getLinks()
 htmlTreeParse(system.file("examples", "index.html", package = "XML"),
              handlers = h2, useInternalNodes = TRUE)
 all(h1$links() == h2$links())

  # Using flat trees
 tt = xmlHashTree()
 f = system.file("exampleData", "mtcars.xml", package="XML")
 xmlTreeParse(f, handlers = list(.startElement = tt[[".addNode"]]))
 xmlRoot(tt)



 doc = xmlTreeParse(f, useInternalNodes = TRUE)

 sapply(getNodeSet(doc, "//variable"), xmlValue)
         
 #free(doc) 


  # character set encoding for HTML
 f = system.file("exampleData", "9003.html", package = "XML")
   # we specify the encoding
 d = htmlTreeParse(f, encoding = "UTF-8")
   # get a different result if we do not specify any encoding
 d.no = htmlTreeParse(f)
   # document with its encoding in the HEAD of the document.
 d.self = htmlTreeParse(system.file("exampleData", "9003-en.html",package = "XML"))
   # XXX want to do a test here to see the similarities between d and
   # d.self and differences between d.no


  # include
 f = system.file("exampleData", "nodes1.xml", package = "XML")
 xmlRoot(xmlTreeParse(f, xinclude = FALSE))
 xmlRoot(xmlTreeParse(f, xinclude = TRUE))

 f = system.file("exampleData", "nodes2.xml", package = "XML")
 xmlRoot(xmlTreeParse(f, xinclude = TRUE))

  # Errors
  try(xmlTreeParse("&lt;doc&gt;&lt;a&gt; &amp; &lt; &lt;?pi &gt; &lt;/doc&gt;"))

    # catch the error by type.
 tryCatch(xmlTreeParse("&lt;doc&gt;&lt;a&gt; &amp; &lt; &lt;?pi &gt; &lt;/doc&gt;"),
                "XMLParserErrorList" = function(e) {
                     cat("Errors in XML document\n", e$message, "\n")
                                                    })

    #  terminate on first error            
  try(xmlTreeParse("&lt;doc&gt;&lt;a&gt; &amp; &lt; &lt;?pi &gt; &lt;/doc&gt;", error = NULL))

    #  see xmlErrorCumulator in the XML package 


  f = system.file("exampleData", "book.xml", package = "XML")
  doc.trim = xmlInternalTreeParse(f, trim = TRUE)
  doc = xmlInternalTreeParse(f, trim = FALSE)
  xmlSApply(xmlRoot(doc.trim), class)
      # note the additional XMLInternalTextNode objects
  xmlSApply(xmlRoot(doc), class)


  top = xmlRoot(doc)
  textNodes = xmlSApply(top, inherits, "XMLInternalTextNode")
  sapply(xmlChildren(top)[textNodes], xmlValue)


     # Storing nodes
   f = system.file("exampleData", "book.xml", package = "XML")
   titles = list()
   xmlTreeParse(f, handlers = list(title = function(x)
                                  titles[[length(titles) + 1]] &lt;&lt;- x))
   sapply(titles, xmlValue)
   rm(titles)
</code></pre>

<hr>
<h2 id='xmlValue'>Extract or set the contents of a leaf XML node</h2><span id='topic+xmlValue'></span><span id='topic+xmlValue.XMLCDataNode'></span><span id='topic+xmlValue.XMLNode'></span><span id='topic+xmlValue.XMLProcessingInstruction'></span><span id='topic+xmlValue.XMLTextNode'></span><span id='topic+xmlValue.XMLComment'></span><span id='topic+xmlValue+3C-'></span><span id='topic+xmlValue+3C-+2CXMLAbstractNode-method'></span><span id='topic+xmlValue+3C-+2CXMLInternalTextNode-method'></span><span id='topic+xmlValue+3C-+2CXMLTextNode-method'></span><span id='topic+coerce+2CXMLInternalTextNode+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Some types of XML nodes have no children nodes, but are leaf nodes and
simply contain text. Examples are <code>XMLTextMode</code>, <code>XMLProcessingInstruction</code>.
This function provides access to their raw contents.
This has been extended to operate recursivel on arbitrary XML nodes
that contain a single text node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmlValue(x, ignoreComments = FALSE, recursive = TRUE,
          encoding = getEncoding(x), trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmlValue_+3A_x">x</code></td>
<td>
<p>the <code>XMLNode</code> object whose
contents are to be  returned.</p>
</td></tr>
<tr><td><code id="xmlValue_+3A_ignorecomments">ignoreComments</code></td>
<td>
<p>a logical value which, if <code>TRUE</code>
does not include the text in XML comment nodes.
If this is <code>FALSE</code>, the text in the comments is part
of the return value.
</p>
</td></tr>
<tr><td><code id="xmlValue_+3A_recursive">recursive</code></td>
<td>
<p>a logical value indicating whether to process all
sub-nodes (<code>TRUE</code>) or only the text nodes within the node <code>x</code>.
</p>
</td></tr>
<tr><td><code id="xmlValue_+3A_encoding">encoding</code></td>
<td>
<p>experimental functionality and parameter related to
encoding.</p>
</td></tr>
<tr><td><code id="xmlValue_+3A_trim">trim</code></td>
<td>
<p>a logical value controlling whether we remove leading or
trailing white space when returning the string value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object stored in the 
<code>value</code> slot of the <code>XMLNode</code> object.
This is typically a string.
</p>


<h3>Author(s)</h3>

<p> Duncan Temple Lang </p>


<h3>References</h3>

<p><a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>, <a href="http://www.jclark.com/xml/">http://www.jclark.com/xml/</a>,
<a href="https://www.omegahat.net">https://www.omegahat.net</a>  </p>


<h3>See Also</h3>

<p><code><a href="#topic+xmlChildren">xmlChildren</a></code>
<code><a href="#topic+xmlName">xmlName</a></code>
<code><a href="#topic+xmlAttrs">xmlAttrs</a></code>
<code><a href="#topic+xmlNamespace">xmlNamespace</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> node &lt;- xmlNode("foo", "Some text")
 xmlValue(node)

 xmlValue(xmlTextNode("some more raw text"))

  # Setting the xmlValue().
 a = newXMLNode("a")
 xmlValue(a) = "the text"
 xmlValue(a) = "different text"

 a = newXMLNode("x", "bob")
 xmlValue(a) = "joe"

 b = xmlNode("bob")
 xmlValue(b) = "Foo"
 xmlValue(b) = "again"

 b = newXMLNode("bob", "some text")
 xmlValue(b[[1]]) = "change"
 b
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
