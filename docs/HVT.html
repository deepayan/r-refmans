<!DOCTYPE html><html><head><title>Help for package HVT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HVT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#displayTable'><p>Table for displaying summary</p></a></li>
<li><a href='#edaPlots'><p>plots for data analysis</p></a></li>
<li><a href='#getCellId'><p>Cell ID</p></a></li>
<li><a href='#getOptimalCentroids'><p>getOptimalCentroids</p></a></li>
<li><a href='#getTransitionProbability'><p>Creating Transition Probabilities list</p></a></li>
<li><a href='#hvq'><p>hvq</p></a></li>
<li><a href='#madPlot'><p>Mean Absolute Deviation Plot</p></a></li>
<li><a href='#plotAnimatedFlowmap'><p>Generating flow maps and animations based on transition probabilities</p></a></li>
<li><a href='#plotHVT'><p>Plot the hierarchical tessellations.</p></a></li>
<li><a href='#plotModelDiagnostics'><p>Make the diagnostic plots for hierarchical voronoi tessellations</p></a></li>
<li><a href='#plotNovelCells'><p>Plot the identified outlier cell(s) in the voronoi tessellation map.</p></a></li>
<li><a href='#plotQuantErrorHistogram'><p>Make the quantization error plots for training and scoring.</p></a></li>
<li><a href='#plotStateTransition'><p>Creating State Transition Plot</p></a></li>
<li><a href='#reconcileTransitionProbability'><p>Reconciliation of Transition Probability</p></a></li>
<li><a href='#removeNovelty'><p>Remove identified novelty cell(s)</p></a></li>
<li><a href='#scoreHVT'><p>Score which cell each point in the test dataset belongs to.</p></a></li>
<li><a href='#scoreLayeredHVT'><p>Score which cell and what layer each data point in the test dataset belongs to</p></a></li>
<li><a href='#trainHVT'><p>Constructing Hierarchical Voronoi Tessellations</p></a></li>
<li><a href='#VQ_codebookSplit'><p>VQ_codebookSplit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Constructing Hierarchical Voronoi Tessellations and Overlay
Heatmaps for Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>24.5.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates building topology preserving maps for rich multivariate data. 
             Credits to Mu Sigma for their continuous support throughout the development of the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, deldir, grDevices, splancs, conf.design, stats, dplyr,
purrr, magrittr, polyclip, ggplot2, tidyr, scales, cluster,
reshape2,data.table, ggforce, plyr, rlang, gganimate, gifski,
markovchain, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Mu-Sigma/HVT/issues">https://github.com/Mu-Sigma/HVT/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Mu-Sigma/HVT">https://github.com/Mu-Sigma/HVT</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, testthat, geozoo, plotly, DT, patchwork, sp,
Hmisc, gridExtra, gtable, htmlwidgets, installr, skimr, tibble,
devtools, tidyverse, DataExplorer, htmltools,
corrplot,knitr,kableExtra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-14 08:50:48 UTC; vishwavani</td>
</tr>
<tr>
<td>Author:</td>
<td>Zubin Dowlaty [aut],
  Mu Sigma, Inc. [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>"Mu Sigma, Inc." &lt;ird.experiencelab@mu-sigma.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-15 08:50:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='displayTable'>Table for displaying summary</h2><span id='topic+displayTable'></span>

<h3>Description</h3>

<p>This is the main function for displaying summary from model training and scoring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayTable(
  data,
  columnName,
  value,
  tableType = "summary",
  scroll = TRUE,
  limit = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="displayTable_+3A_data">data</code></td>
<td>
<p>List. A listed object from trainHVT or scoreHVT</p>
</td></tr>
<tr><td><code id="displayTable_+3A_columnname">columnName</code></td>
<td>
<p>Character. Name of the column that needs highlighting.</p>
</td></tr>
<tr><td><code id="displayTable_+3A_value">value</code></td>
<td>
<p>Numeric. The value above will be highlighted in red or green.</p>
</td></tr>
<tr><td><code id="displayTable_+3A_tabletype">tableType</code></td>
<td>
<p>Character. Type of table to generate ('summary', 'compression')</p>
</td></tr>
<tr><td><code id="displayTable_+3A_scroll">scroll</code></td>
<td>
<p>Logical. A value to have a scroll or not in the table.</p>
</td></tr>
<tr><td><code id="displayTable_+3A_limit">limit</code></td>
<td>
<p>Numeric. A value to indicate how many rows to display.
Applicable for summary tableType.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A consolidated table of results
</p>


<h3>Author(s)</h3>

<p>Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                      DAX = EuStockMarkets[, "DAX"],
                      SMI = EuStockMarkets[, "SMI"],
                      CAC = EuStockMarkets[, "CAC"],
                      FTSE = EuStockMarkets[, "FTSE"])
hvt.results&lt;- trainHVT(dataset,n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
displayTable(data = hvt.results[[3]]$compression_summary,
columnName = 'percentOfCellsBelowQuantizationErrorThreshold', 
value = 0.8, tableType = "compression")

displayTable(data =hvt.results[[3]][['summary']], columnName= 'Quant.Error',
 value = 0.1, tableType = "summary")
</code></pre>

<hr>
<h2 id='edaPlots'>plots for data analysis</h2><span id='topic+edaPlots'></span>

<h3>Description</h3>

<p>This is the main function that provides exploratory data analysis plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaPlots(df, time_series = FALSE, time_column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edaPlots_+3A_df">df</code></td>
<td>
<p>Dataframe. A data frame object.</p>
</td></tr>
<tr><td><code id="edaPlots_+3A_time_series">time_series</code></td>
<td>
<p>Logical. A value to indicate whether the dataset is time_series or not.</p>
</td></tr>
<tr><td><code id="edaPlots_+3A_time_column">time_column</code></td>
<td>
<p>Character. The name of the time column in the data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Five objects which include time series plots, data distribution plots, 
box plots, correlation plot and a descriptive statistics table.
</p>


<h3>Author(s)</h3>

<p>Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                      DAX = EuStockMarkets[, "DAX"],
                      SMI = EuStockMarkets[, "SMI"],
                      CAC = EuStockMarkets[, "CAC"],
                      FTSE = EuStockMarkets[, "FTSE"])
edaPlots(dataset, time_series = TRUE, time_column = 'date')
</code></pre>

<hr>
<h2 id='getCellId'>Cell ID</h2><span id='topic+getCellId'></span>

<h3>Description</h3>

<p>Function to generate cell ID based on 1D sammons projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCellId(hvt.results, seed = 123)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCellId_+3A_hvt.results">hvt.results</code></td>
<td>
<p>List. A list of hvt.results obtained from the trainHVT function.</p>
</td></tr>
<tr><td><code id="getCellId_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To generate cell id for the multivariate data, the data is being projected from n-dimensions to 1-dimension 
and the cell id is being assigned by ordering these values and finding the corresponding indexes. The output Cell id gets
appended to the HVT model.
</p>


<h3>Value</h3>

<p>Object containing Cell.ID mappings for the given hvt.results list.
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>

<hr>
<h2 id='getOptimalCentroids'>getOptimalCentroids</h2><span id='topic+getOptimalCentroids'></span>

<h3>Description</h3>

<p>Get Optimal Centroids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOptimalCentroids(
  x,
  iter.max,
  algorithm,
  n_cells,
  seed = 100,
  function_to_calculate_distance_metric,
  function_to_calculate_error_metric = c("mean", "max"),
  quant.err,
  distance_metric = "L1_Norm",
  quant_method = c("kmeans", "kmedoids"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOptimalCentroids_+3A_x">x</code></td>
<td>
<p>Data Frame. A dataframe of multivariate data. Each row corresponds to an
observation, and each column corresponds to a variable. Missing values are
not accepted.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_algorithm">algorithm</code></td>
<td>
<p>String. The type of algorithm used for quantization.
Available algorithms are Hartigan and Wong, &quot;Lloyd&quot;, &quot;Forgy&quot;, &quot;MacQueen&quot;.
(default is &quot;Hartigan-Wong&quot;)</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_n_cells">n_cells</code></td>
<td>
<p>Numeric. Indicating the number of nodes per hierarchy.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_function_to_calculate_distance_metric">function_to_calculate_distance_metric</code></td>
<td>
<p>Function. The function is to find 'L1_Norm&quot; or &quot;L2_Norm&quot; distances. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_function_to_calculate_error_metric">function_to_calculate_error_metric</code></td>
<td>
<p>Character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. The quantization error for the algorithm.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric to calculate inter point distance. It can be 'L1_Norm&quot; or &quot;L2_Norm&quot;. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_quant_method">quant_method</code></td>
<td>
<p>Character. The quant_method can be &quot;kmeans&quot; or &quot;kmedoids&quot;. kmeans is selected by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw data is first scaled and this scaled data is supplied as input to
the vector quantization algorithm. Vector quantization technique uses a
parameter called quantization error. This parameter acts as a threshold and
determines the number of levels in the hierarchy. It means that, if there
are 'n' number of levels in the hierarchy, then all the clusters formed till
this level will have quantization error equal or greater than the threshold
quantization error. The user can define the number of clusters in the first
level of hierarchy and then each cluster in first level is sub-divided into
the same number of clusters as there are in the first level. This process
continues and each group is divided into smaller clusters as long as the
threshold quantization error is met. The output of this technique will be
hierarchically arranged vector quantized data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>values</code></td>
<td>
<p> List. A list showing observations assigned to a cluster.</p>
</td></tr>
<tr><td><code>maxQE</code></td>
<td>
<p> List. A list corresponding to maximum QE values for each cell. </p>
</td></tr>
<tr><td><code>meanQE</code></td>
<td>
<p> List. A list corresponding to mean QE values for each cell. </p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p> List. A list of quantization error for all levels and nodes. </p>
</td></tr> 
<tr><td><code>nsize</code></td>
<td>
<p> List. A list corresponding to number of observations in respective groups. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>

<hr>
<h2 id='getTransitionProbability'>Creating Transition Probabilities list</h2><span id='topic+getTransitionProbability'></span>

<h3>Description</h3>

<p>This is the main function to create transition probabilities list.
The transition probability table quantifies the likelihood of transitioning from one state to another. 
States: The table includes the current states and the possible next states.
Probabilities: For each current state, it lists the probability of transitioning to each of the next possible states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransitionProbability(df, cellid_column, time_column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransitionProbability_+3A_df">df</code></td>
<td>
<p>Data frame. The input data frame should contain two columns, 
cell ID from scoreHVT function and time stamp of that dataset.</p>
</td></tr>
<tr><td><code id="getTransitionProbability_+3A_cellid_column">cellid_column</code></td>
<td>
<p>Character. Name of the column containing cell IDs.</p>
</td></tr>
<tr><td><code id="getTransitionProbability_+3A_time_column">time_column</code></td>
<td>
<p>Character. Name of the column containing time stamps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints and stores a nested list of data frames with transition probabilities.
</p>


<h3>Author(s)</h3>

<p>PonAnuReka Seenivasan &lt;ponanureka.s@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+scoreHVT">scoreHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                      DAX = EuStockMarkets[, "DAX"],
                      SMI = EuStockMarkets[, "SMI"],
                      CAC = EuStockMarkets[, "CAC"],
                      FTSE = EuStockMarkets[, "FTSE"])
hvt.results&lt;- trainHVT(dataset,n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$date
dataset &lt;- data.frame(cell_id, time_stamp)
table &lt;- getTransitionProbability(dataset, cellid_column = "cell_id",time_column = "time_stamp")
</code></pre>

<hr>
<h2 id='hvq'>hvq</h2><span id='topic+hvq'></span>

<h3>Description</h3>

<p>Hierarchical Vector Quantization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hvq(
  x,
  min_compression_perc = NA,
  n_cells = NA,
  depth = 3,
  quant.err = 10,
  seed = 300,
  algorithm = "Hartigan-Wong",
  distance_metric = c("L1_Norm", "L2_Norm"),
  error_metric = c("mean", "max"),
  quant_method = c("kmeans", "kmedoids")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hvq_+3A_x">x</code></td>
<td>
<p>Data Frame. A dataframe of multivariate data. Each row corresponds to an
observation, and each column corresponds to a variable. Missing values are
not accepted.</p>
</td></tr>
<tr><td><code id="hvq_+3A_min_compression_perc">min_compression_perc</code></td>
<td>
<p>Numeric. An integer indicating the minimum percent compression rate to
be achieved for the dataset</p>
</td></tr>
<tr><td><code id="hvq_+3A_n_cells">n_cells</code></td>
<td>
<p>Numeric. Indicating the number of nodes per hierarchy.</p>
</td></tr>
<tr><td><code id="hvq_+3A_depth">depth</code></td>
<td>
<p>Numeric. Indicating the hierarchy depth (or) the depth of the
tree (1 = no hierarchy, 2 = 2 levels, etc..)</p>
</td></tr>
<tr><td><code id="hvq_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. The quantization error for the algorithm.</p>
</td></tr>
<tr><td><code id="hvq_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="hvq_+3A_algorithm">algorithm</code></td>
<td>
<p>String. The type of algorithm used for quantization.
Available algorithms are Hartigan and Wong, &quot;Lloyd&quot;, &quot;Forgy&quot;, &quot;MacQueen&quot;.
(default is &quot;Hartigan-Wong&quot;)</p>
</td></tr>
<tr><td><code id="hvq_+3A_distance_metric">distance_metric</code></td>
<td>
<p>character. The distance metric can be 'L1_Norm&quot; or &quot;L2_Norm&quot;. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="hvq_+3A_error_metric">error_metric</code></td>
<td>
<p>character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="hvq_+3A_quant_method">quant_method</code></td>
<td>
<p>character. The quant_method can be &quot;kmeans&quot; or &quot;kmedoids&quot;. kmeans is selected by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw data is first scaled and this scaled data is supplied as input to
the vector quantization algorithm. Vector quantization technique uses a
parameter called quantization error. This parameter acts as a threshold and
determines the number of levels in the hierarchy. It means that, if there
are 'n' number of levels in the hierarchy, then all the clusters formed till
this level will have quantization error equal or greater than the threshold
quantization error. The user can define the number of clusters in the first
level of hierarchy and then each cluster in first level is sub-divided into
the same number of clusters as there are in the first level. This process
continues and each group is divided into smaller clusters as long as the
threshold quantization error is met. The output of this technique will be
hierarchically arranged vector quantized data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>clusters</code></td>
<td>
<p> List. A list showing each ID assigned to a cluster.
</p>
</td></tr> <tr><td><code>nodes.clust</code></td>
<td>
<p> List. A list corresponding to nodes' details. </p>
</td></tr>
<tr><td><code>idnodes</code></td>
<td>
<p> List. A list of ID and segments similar to 
<code>nodes.clust</code> with additional columns for nodes ID. </p>
</td></tr>
<tr><td><code>error.quant</code></td>
<td>
<p> List. A list of quantization error for all levels and
nodes. </p>
</td></tr> <tr><td><code>plt.clust</code></td>
<td>
<p> List. A list of logical values indicating if the
quantization error was met. </p>
</td></tr> <tr><td><code>summary</code></td>
<td>
<p> Summary. Output table with
summary. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
DAX = EuStockMarkets[, "DAX"],
SMI = EuStockMarkets[, "SMI"],
CAC = EuStockMarkets[, "CAC"],
FTSE = EuStockMarkets[, "FTSE"])
dataset_hvt &lt;- dataset[,-c(1)]
hvqOutput = hvq(dataset_hvt, n_cells = 5, depth = 2, quant.err = 0.2,
distance_metric='L1_Norm',error_metric='mean',quant_method="kmeans")
</code></pre>

<hr>
<h2 id='madPlot'>Mean Absolute Deviation Plot</h2><span id='topic+madPlot'></span>

<h3>Description</h3>

<p>Function to create Mean Absolute Deviation Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>madPlot(hvt.scoring, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="madPlot_+3A_hvt.scoring">hvt.scoring</code></td>
<td>
<p>List. A list of hvt.scoring obtained from the scoreHVT
function.</p>
</td></tr>
<tr><td><code id="madPlot_+3A_...">...</code></td>
<td>
<p>The ellipsis is passed to it as additional argument. (Used internally)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots percentage anomalies vs mean absolute deviation for test data. The plot helps in
deciding an optimal MAD value for the use case.
</p>


<h3>Value</h3>

<p>Mean Absolute Deviation Plot
</p>
<table>
<tr><td><code>mad_plot</code></td>
<td>
<p>ggplot plot. A plot with percentage anomalies on y axis and mean absolute deviation values on xaxis. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scoreHVT">scoreHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
#adding this step especially for this function
rownames(EuStockMarkets) &lt;- dataset$date
train &lt;- EuStockMarkets[1:1302, ]
test &lt;- EuStockMarkets[1303:1860, ]
hvt_summary &lt;- list()
hvt_summary&lt;- trainHVT(train,n_cells = 15, depth = 1, quant.err = 0.2,
                      distance_metric = "L1_Norm", error_metric = "mean",
                      projection.scale = 10, normalize = TRUE,seed = 123,
                      quant_method = "kmeans")
score_var &lt;- scoreHVT(test, hvt_summary, child.level = 2, mad.threshold = 0.2)
madPlot(hvt.scoring=score_var)
</code></pre>

<hr>
<h2 id='plotAnimatedFlowmap'>Generating flow maps and animations based on transition probabilities</h2><span id='topic+plotAnimatedFlowmap'></span>

<h3>Description</h3>

<p>This is the main function for generating flow maps and animations based on transition probabilities
including self states and excluding self states.
Flow maps are a type of data visualization used to represent the transition probability of different states. 
Animations are the gifs used to represent the movement of data through the cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAnimatedFlowmap(
  hvt_model_output,
  transition_probability_df,
  df,
  animation = NULL,
  flow_map = NULL,
  fps_time = 1,
  fps_state = 1,
  time_duration = 2,
  state_duration = 2,
  cellid_column,
  time_column
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAnimatedFlowmap_+3A_hvt_model_output">hvt_model_output</code></td>
<td>
<p>List. Output from a trainHVT function.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_transition_probability_df">transition_probability_df</code></td>
<td>
<p>List. Output from getTransitionProbability function</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_df">df</code></td>
<td>
<p>Data frame. The input dataframe should contain two columns, 
cell ID from scoreHVT function and time stamp of that dataset.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_animation">animation</code></td>
<td>
<p>Character. Type of animation ('state_based', 'time_based', 'All' or  NULL)</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_flow_map">flow_map</code></td>
<td>
<p>Character. Type of flow map ('self_state', 'without_self_state', 'All' or NULL)</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_fps_time">fps_time</code></td>
<td>
<p>Numeric. A numeric value for the frames per second of the time transition gif.
(Must be a numeric value and a factor of 100). Default value is 1.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_fps_state">fps_state</code></td>
<td>
<p>Numeric. A numeric value for the frames per second of the state transition gif.
(Must be a numeric value and a factor of 100). Default value is 1.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_time_duration">time_duration</code></td>
<td>
<p>Numeric. A numeric value for the duration of the time transition gif.
Default value is 2.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_state_duration">state_duration</code></td>
<td>
<p>Numeric. A numeric value for the duration of the state transition gif.
Default value is 2.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_cellid_column">cellid_column</code></td>
<td>
<p>Character. Name of the column containing cell IDs.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_time_column">time_column</code></td>
<td>
<p>Character. Name of the column containing time stamps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of flow maps and animation gifs.
</p>


<h3>Author(s)</h3>

<p>PonAnuReka Seenivasan &lt;ponanureka.s@mu-sigma.com&gt;, Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+scoreHVT">scoreHVT</a></code> <br /> <code><a href="#topic+getTransitionProbability">getTransitionProbability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                      DAX = EuStockMarkets[, "DAX"],
                      SMI = EuStockMarkets[, "SMI"],
                      CAC = EuStockMarkets[, "CAC"],
                      FTSE = EuStockMarkets[, "FTSE"])
                      
hvt.results&lt;- trainHVT(dataset,n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
                       
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$date
dataset &lt;- data.frame(cell_id, time_stamp)

table &lt;- getTransitionProbability(dataset, cellid_column = "cell_id",time_column = "time_stamp")
plots &lt;- plotAnimatedFlowmap(hvt_model_output = hvt.results, transition_probability_df = table,
df = dataset, animation = 'All', flow_map = 'All',fps_time = 1,fps_state =  1,time_duration = 2,
state_duration = 2,cellid_column = "cell_id", time_column = "time_stamp")
</code></pre>

<hr>
<h2 id='plotHVT'>Plot the hierarchical tessellations.</h2><span id='topic+plotHVT'></span>

<h3>Description</h3>

<p>This is the main plotting function to construct hierarchical voronoi tessellations in 1D,2D or
Interactive surface plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHVT(
  hvt.results,
  line.width = 0.5,
  color.vec = "black",
  pch1 = 21,
  centroid.size = 1.5,
  title = NULL,
  maxDepth = NULL,
  child.level,
  hmap.cols,
  quant.error.hmap = NULL,
  cell_id = FALSE,
  n_cells.hmap = NULL,
  label.size = 0.5,
  sepration_width = 7,
  layer_opacity = c(0.5, 0.75, 0.99),
  dim_size = 1000,
  plot.type = "2Dhvt"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHVT_+3A_hvt.results">hvt.results</code></td>
<td>
<p>(2DProj/2Dhvt/2Dheatmap/surface_plot) List. A list containing the output of <code>trainHVT</code> function
which has the details of the tessellations to be plotted.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_line.width">line.width</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Numeric Vector. A vector indicating the line widths of the
tessellation boundaries for each level.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_color.vec">color.vec</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Vector. A vector indicating the colors of the boundaries of
the tessellations at each level.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_pch1">pch1</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Numeric. Symbol of the centroids of the tessellations
(parent levels). Default value is 21.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_centroid.size">centroid.size</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Numeric. Size of centroids of first level
tessellations.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_title">title</code></td>
<td>
<p>(2Dhvt) Character. Set a title for the plot. (default = NULL)</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_maxdepth">maxDepth</code></td>
<td>
<p>(2Dhvt) Numeric. An integer indicating the number of levels. (default = NULL)</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_child.level">child.level</code></td>
<td>
<p>(2Dheatmap/surface_plot) Numeric. Indicating the level for which the heat map is
to be plotted.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_hmap.cols">hmap.cols</code></td>
<td>
<p>(2Dheatmap/surface_plot) Numeric or Character. The column number or column name from
the dataset indicating the variables for which the heat map is to be
plotted.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_quant.error.hmap">quant.error.hmap</code></td>
<td>
<p>(2Dheatmap) Numeric. A number indicating the quantization error
threshold.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_cell_id">cell_id</code></td>
<td>
<p>(2Dhvt) Logical. To indicate whether the plot should have Cell IDs or not for the first layer. 
(default = FALSE)</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_n_cells.hmap">n_cells.hmap</code></td>
<td>
<p>(2Dheatmap/surface_plot) Numeric. An integer indicating the number of
cells/clusters per hierarchy (level)</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_label.size">label.size</code></td>
<td>
<p>(2Dheatmap) Numeric. The size by which the tessellation labels should
be scaled. (default = 0.5)</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_sepration_width">sepration_width</code></td>
<td>
<p>(surface_plot) Numeric. An integer indicating the width between two levels</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_layer_opacity">layer_opacity</code></td>
<td>
<p>(surface_plot) Numeric. A vector indicating the opacity of each layer/ level</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_dim_size">dim_size</code></td>
<td>
<p>(surface_plot) Numeric. An integer indicating the dimension size used to create the matrix for the plot</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_plot.type">plot.type</code></td>
<td>
<p>Character. An option to indicate which type of plot should be generated. Accepted entries are 
'1D','2Dproj','2Dhvt','2Dheatmap'and 'surface_plot'. Default value is '2Dhvt'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot object containing the visualizations of reduced dimension(1D/2D) for the given dataset.
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans")
                       
#change the 'plot.type' argument to '2Dproj' or '2DHVT' to visualize respective plots.                      
plotHVT(hvt.results, plot.type='1D')

#change the 'plot.type' argument to 'surface_plot' to visualize the Interactive surface plot                   
plotHVT(hvt.results,child.level = 1, 
hmap.cols = "DAX", plot.type = '2Dheatmap')

</code></pre>

<hr>
<h2 id='plotModelDiagnostics'>Make the diagnostic plots for hierarchical voronoi tessellations</h2><span id='topic+plotModelDiagnostics'></span>

<h3>Description</h3>

<p>This is the main function that generates diagnostic plots for 
hierarchical voronoi tessellations models and scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModelDiagnostics(model_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotModelDiagnostics_+3A_model_obj">model_obj</code></td>
<td>
<p>List. A list obtained from the trainHVT
function or scoreHVT function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For trainHVT, Minimum Intra-DataPoint Distance Plot, Minimum Intra-Centroid Distance Plot
Mean Absolute Deviation Plot, Distribution of Number of Observations in Cells, for Training Data and
Mean Absolute Deviation Plot for Validation Data are plotted.
For scoreHVT Mean Absolute Deviation Plot for Training Data and Validation Data are plotted
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans",diagnose = TRUE, 
                       hvt_validation = TRUE)
plotModelDiagnostics(hvt.results)
</code></pre>

<hr>
<h2 id='plotNovelCells'>Plot the identified outlier cell(s) in the voronoi tessellation map.</h2><span id='topic+plotNovelCells'></span>

<h3>Description</h3>

<p>This is the main plotting function to construct hierarchical voronoi tessellations 
and highlight the outlier cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNovelCells(
  plot.cells,
  hvt.map,
  line.width = c(0.6),
  color.vec = c("#141B41"),
  pch = 21,
  centroid.size = 0.5,
  title = NULL,
  maxDepth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotNovelCells_+3A_plot.cells">plot.cells</code></td>
<td>
<p>Vector. A vector indicating the cells to be highlighted in the map</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_hvt.map">hvt.map</code></td>
<td>
<p>List. A list containing the output of <code>trainHVT</code> function
which has the details of the tessellations to be plotted</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_line.width">line.width</code></td>
<td>
<p>Numeric Vector. A vector indicating the line widths of the
tessellation boundaries for each level</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A vector indicating the colors of the boundaries of
the tessellations at each level</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_pch">pch</code></td>
<td>
<p>Numeric. Symbol of the centroids of the tessellations
(parent levels) Default value is 21.</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_centroid.size">centroid.size</code></td>
<td>
<p>Numeric. Size of centroids of first level
tessellations. Default value is 0.5</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_title">title</code></td>
<td>
<p>String. Set a title for the plot. (default = NULL)</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_maxdepth">maxDepth</code></td>
<td>
<p>Numeric. An integer indicating the number of levels. (default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object containing hierarchical voronoi tessellation plot
highlighting the outlier cells
</p>


<h3>Author(s)</h3>

<p>Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans")
#selected 55,58 are for demo purpose
plotNovelCells(c(55,58),hvt.results)
</code></pre>

<hr>
<h2 id='plotQuantErrorHistogram'>Make the quantization error plots for training and scoring.</h2><span id='topic+plotQuantErrorHistogram'></span>

<h3>Description</h3>

<p>This is the function that produces histograms displaying the distribution of Quantization Error (QE) values 
for both train and test datasets, highlighting mean values with dashed lines for quick evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQuantErrorHistogram(hvt.results, hvt.scoring)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotQuantErrorHistogram_+3A_hvt.results">hvt.results</code></td>
<td>
<p>List. A list of hvt.results obtained from the trainHVT function.</p>
</td></tr>
<tr><td><code id="plotQuantErrorHistogram_+3A_hvt.scoring">hvt.scoring</code></td>
<td>
<p>List. A list of hvt.scoring obtained from the scoreHVT function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ggplot object containing the quantization error distribution plots for 
the given HVT results of training and scoring
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
rownames(EuStockMarkets) &lt;- dataset$date
#Split in train and test
train &lt;- EuStockMarkets[1:1302, ]
test &lt;- EuStockMarkets[1303:1860, ]

hvt.results&lt;- trainHVT(train,n_cells = 60, depth = 1, quant.err = 0.1,
                      distance_metric = "L1_Norm", error_metric = "max",
                      normalize = TRUE, quant_method = "kmeans")
scoring &lt;- scoreHVT(test, hvt.results)
plotQuantErrorHistogram(hvt.results, scoring) 
</code></pre>

<hr>
<h2 id='plotStateTransition'>Creating State Transition Plot</h2><span id='topic+plotStateTransition'></span>

<h3>Description</h3>

<p>This is the main function to create a state transition plot from a data frame.
A state transition plot is a type of data visualization used to represent 
the changes or transitions in states over time for a given system. 
State refers to a particular condition or status of a cell at a specific point in time. 
Transition refers to the change of state for a cell from one condition to another over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStateTransition(
  df,
  sample_size = NULL,
  line_plot = NULL,
  cellid_column,
  time_column
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotStateTransition_+3A_df">df</code></td>
<td>
<p>Data frame. The Input data frame should contain two columns. 
Cell ID from scoreHVT function and time stamp of that dataset.</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_sample_size">sample_size</code></td>
<td>
<p>Numeric. An integer indicating the fraction of the data frame to visualize in the plot.
Default value is 0.2</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_line_plot">line_plot</code></td>
<td>
<p>Logical. A logical value indicating to create a line plot. Default value is NULL.</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_cellid_column">cellid_column</code></td>
<td>
<p>Character. Name of the column containing cell IDs.</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_time_column">time_column</code></td>
<td>
<p>Character. Name of the column containing time stamps.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotly object representing the state transition plot for the given data frame.
</p>


<h3>Author(s)</h3>

<p>PonAnuReka Seenivasan &lt;ponanureka.s@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+scoreHVT">scoreHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
DAX = EuStockMarkets[, "DAX"],
SMI = EuStockMarkets[, "SMI"],
CAC = EuStockMarkets[, "CAC"],
FTSE = EuStockMarkets[, "FTSE"])

hvt.results&lt;- trainHVT(dataset,n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$date
dataset &lt;- data.frame(cell_id, time_stamp)

plotStateTransition(dataset, sample_size = 1, cellid_column = "cell_id",time_column = "time_stamp")
</code></pre>

<hr>
<h2 id='reconcileTransitionProbability'>Reconciliation of Transition Probability</h2><span id='topic+reconcileTransitionProbability'></span>

<h3>Description</h3>

<p>This is the main function for creating reconciliation plots and tables which 
helps in comparing the transition probabilities calculated manually and from markovchain function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconcileTransitionProbability(
  df,
  hmap_type = NULL,
  cellid_column,
  time_column
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconcileTransitionProbability_+3A_df">df</code></td>
<td>
<p>Data frame. The input data frame should contain two columns, cell ID from scoreHVT function and timestamp of that dataset.</p>
</td></tr>
<tr><td><code id="reconcileTransitionProbability_+3A_hmap_type">hmap_type</code></td>
<td>
<p>Character. ('self_state', 'without_self_state', or 'All')</p>
</td></tr>
<tr><td><code id="reconcileTransitionProbability_+3A_cellid_column">cellid_column</code></td>
<td>
<p>Character. Name of the column containing cell IDs.</p>
</td></tr>
<tr><td><code id="reconcileTransitionProbability_+3A_time_column">time_column</code></td>
<td>
<p>Character. Name of the column containing timestamps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of plotly heatmap objects and tables representing the transition probability heatmaps.
</p>


<h3>Author(s)</h3>

<p>PonAnuReka Seenivasan &lt;ponanureka.s@mu-sigma.com&gt;, Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+scoreHVT">scoreHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                      DAX = EuStockMarkets[, "DAX"],
                      SMI = EuStockMarkets[, "SMI"],
                      CAC = EuStockMarkets[, "CAC"],
                      FTSE = EuStockMarkets[, "FTSE"])

hvt.results&lt;- trainHVT(dataset,n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$date
dataset &lt;- data.frame(cell_id, time_stamp)

reconcileTransitionProbability(dataset, hmap_type = "All", 
cellid_column = "cell_id", time_column = "time_stamp")
</code></pre>

<hr>
<h2 id='removeNovelty'>Remove identified novelty cell(s)</h2><span id='topic+removeNovelty'></span>

<h3>Description</h3>

<p>This function is used to remove the identified novelty cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeNovelty(outlier_cells, hvt_results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeNovelty_+3A_outlier_cells">outlier_cells</code></td>
<td>
<p>Vector. A vector with the cell number of the identified novelty</p>
</td></tr>
<tr><td><code id="removeNovelty_+3A_hvt_results">hvt_results</code></td>
<td>
<p>List. A list having the results of the compressed map i.e. output of <code>trainHVT</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two items
</p>
<table>
<tr><td><code>[[1]]</code></td>
<td>
<p>Dataframe of novelty cell(s)</p>
</td></tr>
<tr><td><code>[[2]]</code></td>
<td>
<p>Dataframe without the novelty cell(s) from the dataset used in model training</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+scoreLayeredHVT">scoreLayeredHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans")
identified_Novelty_cells &lt;&lt;- c(2, 10)
output_list &lt;- removeNovelty(identified_Novelty_cells, hvt.results) 
data_with_novelty &lt;- output_list[[1]]
data_without_novelty &lt;- output_list[[2]]                      
</code></pre>

<hr>
<h2 id='scoreHVT'>Score which cell each point in the test dataset belongs to.</h2><span id='topic+scoreHVT'></span>

<h3>Description</h3>

<p>This function scores each data point in the test dataset based on a trained hierarchical Voronoi tessellations model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreHVT(
  data,
  hvt.results.model,
  child.level = 1,
  mad.threshold = 0.2,
  line.width = c(0.6, 0.4, 0.2),
  color.vec = c("navyblue", "slateblue", "lavender"),
  normalize = TRUE,
  seed = 300,
  distance_metric = "L1_Norm",
  error_metric = "max",
  yVar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreHVT_+3A_data">data</code></td>
<td>
<p>Data frame. A data frame containing the test dataset.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_hvt.results.model">hvt.results.model</code></td>
<td>
<p>List. A list obtained from the trainHVT function</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_child.level">child.level</code></td>
<td>
<p>Numeric. A number indicating the depth for which the heat map is to be plotted.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_mad.threshold">mad.threshold</code></td>
<td>
<p>Numeric. A numeric value indicating the permissible Mean Absolute Deviation.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_line.width">line.width</code></td>
<td>
<p>Vector. A vector indicating the line widths of the tessellation boundaries for each layer.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A vector indicating the colors of the tessellation boundaries at each layer.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the dataset should be normalized. When set to TRUE,
the data (testing dataset) is standardized by ‘mean’ and ‘sd’ of the training dataset referred from the trainHVT(). 
When set to FALSE, the data is used as such without any changes.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed to preserve the repeatability</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric can be L1_Norm(Manhattan) or L2_Norm(Eucledian). L1_Norm is selected by default.
The distance metric is used to calculate the distance between an n dimensional point and centroid.
The distance metric can be different from the one used during training.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>Character. The error metric can be mean or max. max is selected by default. 
max will return the max of m values and mean will take mean of m values where
each value is a distance between a point and centroid of the cell.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_yvar">yVar</code></td>
<td>
<p>Character. A character or a vector representing the name of the dependent variable(s)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing scored data, plots and summary
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
rownames(EuStockMarkets) &lt;- dataset$date
# Split in train and test
train &lt;- EuStockMarkets[1:1302, ]
test &lt;- EuStockMarkets[1303:1860, ]
#model training
hvt.results&lt;- trainHVT(train,n_cells = 60, depth = 1, quant.err = 0.1,
                      distance_metric = "L1_Norm", error_metric = "max",
                      normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(test, hvt.results)
data_scored &lt;- scoring$scoredPredictedData
</code></pre>

<hr>
<h2 id='scoreLayeredHVT'>Score which cell and what layer each data point in the test dataset belongs to</h2><span id='topic+scoreLayeredHVT'></span>

<h3>Description</h3>

<p>This function that scores the cell and corresponding layer for each data point in a test dataset using three 
hierarchical vector quantization (HVT) models (Map A, Map B, Map C) and returns a data frame containing the scored layer output. 
The function incorporates the scored results from each map and merges them to provide a comprehensive result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreLayeredHVT(
  data,
  hvt_mapA,
  hvt_mapB,
  hvt_mapC,
  mad.threshold = 0.2,
  normalize = TRUE,
  seed = 300,
  distance_metric = "L1_Norm",
  error_metric = "max",
  child.level = 1,
  yVar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoreLayeredHVT_+3A_data">data</code></td>
<td>
<p>Data Frame. A data frame containing test dataset. 
The data frame should have all the variable(features) used for training.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_hvt_mapa">hvt_mapA</code></td>
<td>
<p>A list of hvt.results.model obtained from trainHVT function while performing
'trainHVT()' on train data</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_hvt_mapb">hvt_mapB</code></td>
<td>
<p>A list of hvt.results.model obtained from trainHVT function while performing 
'trainHVT()' on data with novelty(s)</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_hvt_mapc">hvt_mapC</code></td>
<td>
<p>A list of hvt.results.model obtained from trainHVT function while performing
'trainHVT()' on data without novelty(s)</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_mad.threshold">mad.threshold</code></td>
<td>
<p>Numeric. A number indicating the permissible Mean Absolute Deviation</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the dataset should be normalized. 
When set to TRUE, the data (testing dataset) is standardized by 'mean' and 'sd' of the training dataset 
referred from the trainHVT(). When set to FALSE, the data is used as such without any changes.
(Default value is TRUE).</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric can be L1_Norm(Manhattan) or L2_Norm(Eucledian). L1_Norm is selected by default.
The distance metric is used to calculate the distance between an n dimensional point and centroid.
The distance metric can be different from the one used during training.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>Character. The error metric can be mean or max. max is selected by default. 
max will return the max of m values and mean will take mean of m values where
each value is a distance between a point and centroid of the cell.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_child.level">child.level</code></td>
<td>
<p>Numeric. A number indicating the level for which the heat map is to be plotted.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_yvar">yVar</code></td>
<td>
<p>Character. A character or a vector representing the name of the dependent variable(s)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing scored layer output
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;, Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;,Somya Shambhawi &lt;somya.shambhawi@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
rownames(EuStockMarkets) &lt;- dataset$date

train &lt;- EuStockMarkets[1:1302, ]
test &lt;- EuStockMarkets[1303:1860, ]

###MAP-A
hvt_mapA &lt;- trainHVT(train, n_cells = 150, depth = 1, quant.err = 0.1,
                    distance_metric = "L1_Norm", error_metric = "max",
                    normalize = TRUE,quant_method = "kmeans")
                    
identified_Novelty_cells &lt;- c(127,55,83,61,44,35,27,77)
output_list &lt;- removeNovelty(identified_Novelty_cells, hvt_mapA)
data_with_novelty &lt;- output_list[[1]] 
data_with_novelty &lt;- data_with_novelty[, -c(1,2)]

### MAP-B
hvt_mapB &lt;- trainHVT(data_with_novelty,n_cells = 10, depth = 1, quant.err = 0.1,
                    distance_metric = "L1_Norm", error_metric = "max",
                    normalize = TRUE,quant_method = "kmeans")
data_without_novelty &lt;- output_list[[2]]

### MAP-C
hvt_mapC &lt;- trainHVT(data_without_novelty,n_cells = 135,
                    depth = 1, quant.err = 0.1, distance_metric = "L1_Norm",
                    error_metric = "max", quant_method = "kmeans",
                    normalize = TRUE)
                    
##SCORE LAYERED
data_scored &lt;- scoreLayeredHVT(test, hvt_mapA, hvt_mapB, hvt_mapC)
</code></pre>

<hr>
<h2 id='trainHVT'>Constructing Hierarchical Voronoi Tessellations</h2><span id='topic+trainHVT'></span>

<h3>Description</h3>

<p>This is the main function to construct hierarchical voronoi tessellations.
This is done using hierarchical vector quantization(hvq). The data is represented in 2D
coordinates and the tessellations are plotted using these coordinates as
centroids. For subsequent levels, transformation is performed on the 2D
coordinates to get all the points within its parent tile. Tessellations are
plotted using these transformed points as centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainHVT(
  dataset,
  min_compression_perc = NA,
  n_cells = NA,
  depth = 1,
  quant.err = 0.2,
  projection.scale = 10,
  normalize = FALSE,
  seed = 279,
  distance_metric = c("L1_Norm", "L2_Norm"),
  error_metric = c("mean", "max"),
  quant_method = c("kmeans", "kmedoids"),
  scale_summary = NA,
  diagnose = FALSE,
  hvt_validation = FALSE,
  train_validation_split_ratio = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trainHVT_+3A_dataset">dataset</code></td>
<td>
<p>Data frame. A data frame, with numeric columns (features) will be used for training the model.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_min_compression_perc">min_compression_perc</code></td>
<td>
<p>Numeric. An integer, indicating the minimum compression percentage to be achieved for the dataset. 
It indicates the desired level of reduction in dataset size compared to its original size.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_n_cells">n_cells</code></td>
<td>
<p>Numeric. An integer, indicating the number of cells per hierarchy (level).</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_depth">depth</code></td>
<td>
<p>Numeric. An integer, indicating the number of levels. A depth of 1 means no hierarchy (single level), 
while higher values indicate multiple levels (hierarchy).</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. A number indicating the quantization error threshold.
A cell will only breakdown into further cells if the quantization error of the cell is 
above the defined quantization error threshold.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_projection.scale">projection.scale</code></td>
<td>
<p>Numeric. A number indicating the scale factor for the tessellations to visualize the sub-tessellations
well enough. It helps in adjusting the visual representation of the hierarchy to make the sub-tessellations more visible.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the dataset should be normalized. When set to TRUE, 
scales the values of all features to have a mean of 0 and a standard deviation of 1 (Z-score).</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_seed">seed</code></td>
<td>
<p>Numeric. A Random Numeric Seed to preserve the repeatability.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric can be L1_Norm(Manhattan) or L2_Norm(Eucledian). L1_Norm is selected by default.
The distance metric is used to calculate the distance between an n dimensional point and centroid.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>Character. The error metric can be mean or max. max is selected by default. 
max will return the max of m values and mean will take mean of m values where
each value is a distance between a point and centroid of the cell.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_quant_method">quant_method</code></td>
<td>
<p>Character. The quantization method can be kmeans or kmedoids. Kmeans uses means (centroids) as cluster centers
while Kmedoids uses actual data points (medoids) as cluster centers. kmeans is selected by default.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_scale_summary">scale_summary</code></td>
<td>
<p>List. A list with user-defined mean and standard deviation values for all the features in the dataset. 
Pass the scale summary when normalize is set to FALSE.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_diagnose">diagnose</code></td>
<td>
<p>Logical. A logical value indicating whether user wants to perform diagnostics on the model. 
Default value is FALSE.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_hvt_validation">hvt_validation</code></td>
<td>
<p>Logical. A logical value indicating whether user wants to holdout a validation set and find 
mean absolute deviation of the validation points from the centroid. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_train_validation_split_ratio">train_validation_split_ratio</code></td>
<td>
<p>Numeric. A numeric value indicating train validation split ratio. 
This argument is only used when hvt_validation has been set to TRUE. Default value for the argument is 0.8</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Nested list that contains the hierarchical tessellation information. This
list has to be given as input argument to plot the tessellations.
</p>
<table>
<tr><td><code>[[1]]</code></td>
<td>
<p>A list containing information related to plotting tessellations. 
This information will include coordinates, boundaries, and other details necessary for visualizing the tessellations</p>
</td></tr> 
<tr><td><code>[[2]]</code></td>
<td>
<p>A list containing information related to Sammon’s projection coordinates of the data points
in the reduced-dimensional space.</p>
</td></tr>
<tr><td><code>[[3]]</code></td>
<td>
<p>A list containing detailed information about the hierarchical vector quantized data along with 
a summary section containing no of points, Quantization Error and the centroids for each cell.</p>
</td></tr>
<tr><td><code>[[4]]</code></td>
<td>
<p>A list that contains all the diagnostics information of the model when diagnose is set to TRUE. 
Otherwise NA.</p>
</td></tr>
<tr><td><code>[[5]]</code></td>
<td>
<p>A list that contains all the information required to generates a Mean Absolute Deviation (MAD) plot, 
if hvt_validation is set to TRUE. Otherwise NA</p>
</td></tr>
<tr><td><code>[[6]]</code></td>
<td>
<p>A list containing detailed information about the hierarchical vector quantized data along with a
summary section containing no of points, Quantization Error and the centroids for each cell which is the output of 'hvq'</p>
</td></tr>
<tr><td><code>[[7]]</code></td>
<td>
<p>model info: A list that contains model-generated timestamp, input parameters passed to the model 
and the validation results</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;, Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans")
</code></pre>

<hr>
<h2 id='VQ_codebookSplit'>VQ_codebookSplit</h2><span id='topic+VQ_codebookSplit'></span>

<h3>Description</h3>

<p>Vector Quantization by codebook split method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VQ_codebookSplit(dataset, quant.err = 0.5, epsilon = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VQ_codebookSplit_+3A_dataset">dataset</code></td>
<td>
<p>Matrix. A matrix of multivariate data. Each row corresponds
to an observation, and each column corresponds to a variable. Missing values
are not accepted.</p>
</td></tr>
<tr><td><code id="VQ_codebookSplit_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. The quantization error for the algorithm.</p>
</td></tr>
<tr><td><code id="VQ_codebookSplit_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric. The value to offset the codebooks during the
codebook split. Default is NULL, in which case the value is set to quant.err
parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs Vector Quantization by codebook split method. Initially, the entire
dataset is considered to be one cluster where the codebook is the mean of
the cluster. The quantization criteria is checked and the codebook is split
such that the new codebooks are (codebook+epsilon) and (codebook-epsilon).
The observations are reassigned to these new codebooks based on the nearest
neighbour condition and the means recomputed for the new clusters. This is
done iteratively until all the clusters meet the quantization criteria.
</p>


<h3>Value</h3>

<table>
<tr><td><code>clusters</code></td>
<td>
<p> List. A list showing each ID assigned to a cluster.
</p>
</td></tr> <tr><td><code>nodes.clust</code></td>
<td>
<p> List. A list corresponding to nodes' details. </p>
</td></tr>
<tr><td><code>idnodes</code></td>
<td>
<p> List. A list of ID and segments similar to
<code>nodes.clust</code> with additional columns for nodes ID. </p>
</td></tr>
<tr><td><code>error.quant</code></td>
<td>
<p> List. A list of quantization error for all levels and
nodes. </p>
</td></tr> <tr><td><code>plt.clust</code></td>
<td>
<p> List. A list of logical values indicating if the
quantization error was met. </p>
</td></tr> <tr><td><code>summary</code></td>
<td>
<p> Summary. Output table with
summary. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("iris", package = "datasets")
iris &lt;- iris[, 1:2]

vqOutput &lt;- VQ_codebookSplit(iris, quant.err = 0.5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
