<!DOCTYPE html><html lang="en"><head><title>Help for package HVT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HVT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clustHVT'><p>Performing Hierarchical Clustering Analysis</p></a></li>
<li><a href='#displayTable'><p>function for displaying table</p></a></li>
<li><a href='#edaPlots'><p>plots for data analysis</p></a></li>
<li><a href='#getOptimalCentroids'><p>getOptimalCentroids</p></a></li>
<li><a href='#getTransitionProbability'><p>Creating Transition Probability Matrix</p></a></li>
<li><a href='#msm'><p>Performing Monte Carlo Simulations of Markov Chain</p></a></li>
<li><a href='#plotAnimatedFlowmap'><p>Generating flow maps and animations based on transition probabilities</p></a></li>
<li><a href='#plotHVT'><p>Plot the hierarchical tessellations.</p></a></li>
<li><a href='#plotModelDiagnostics'><p>Make the diagnostic plots for hierarchical voronoi tessellations</p></a></li>
<li><a href='#plotNovelCells'><p>Plot the identified outlier cells in the voronoi tessellation map.</p></a></li>
<li><a href='#plotQuantErrorHistogram'><p>Make the quantization error plots for training and scoring.</p></a></li>
<li><a href='#plotStateTransition'><p>Creating State Transition Plot</p></a></li>
<li><a href='#plotZscore'><p>Plots of z scores</p></a></li>
<li><a href='#reconcileTransitionProbability'><p>Reconciliation of Transition Probability</p></a></li>
<li><a href='#removeNovelty'><p>Remove identified novelty cell(s)</p></a></li>
<li><a href='#scoreHVT'><p>Score which cell each point in the test dataset belongs to.</p></a></li>
<li><a href='#scoreLayeredHVT'><p>Score which cell and what layer each data point in the test dataset belongs to</p></a></li>
<li><a href='#summary'><p>Table for displaying summary</p></a></li>
<li><a href='#trainHVT'><p>Constructing Hierarchical Voronoi Tessellations</p></a></li>
<li><a href='#VQ_codebookSplit'><p>VQ_codebookSplit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Constructing Hierarchical Voronoi Tessellations and Overlay
Heatmaps for Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>25.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates building topology preserving maps for data analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, grDevices, splancs, stats, dplyr, NbClust, purrr,
magrittr, ggplot2, tidyr, scales, cluster, reshape2,
FNN,Rtsne,umap, plyr, gganimate, markovchain, methods,deldir,
gridExtra</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Mu-Sigma/HVT/issues">https://github.com/Mu-Sigma/HVT/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Mu-Sigma/HVT">https://github.com/Mu-Sigma/HVT</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,rmarkdown,testthat,geozoo,plotly,
DT,patchwork,sp,Hmisc,data.table,gtable,
htmlwidgets,installr,skimr,tibble,devtools,gifski,
tidyverse,DataExplorer,htmltools,corrplot,kableExtra,polyclip,conf.design</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-05 09:15:45 UTC; vishwavani</td>
</tr>
<tr>
<td>Author:</td>
<td>Zubin Dowlaty [aut],
  Mu Sigma, Inc. [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>"Mu Sigma, Inc." &lt;ird.experiencelab@mu-sigma.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-05 12:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clustHVT'>Performing Hierarchical Clustering Analysis</h2><span id='topic+clustHVT'></span>

<h3>Description</h3>

<p>This is the main function to perform hierarchical clustering
analysis which determines optimal number of clusters, perform AGNES clustering
and plot the 2D cluster hvt plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustHVT(
  data,
  trainHVT_results,
  scoreHVT_results,
  clustering_method = "ward.D2",
  indices,
  clusters_k = "champion",
  type = "default",
  domains.column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clustHVT_+3A_data">data</code></td>
<td>
<p>Data frame. A data frame intended for performing hierarchical clustering analysis.</p>
</td></tr>
<tr><td><code id="clustHVT_+3A_trainhvt_results">trainHVT_results</code></td>
<td>
<p>List.  A list object which is obtained as a result of trainHVT function.</p>
</td></tr>
<tr><td><code id="clustHVT_+3A_scorehvt_results">scoreHVT_results</code></td>
<td>
<p>List. A list object which is obtained as a result of scoreHVT function.</p>
</td></tr>
<tr><td><code id="clustHVT_+3A_clustering_method">clustering_method</code></td>
<td>
<p>Character. The method used for clustering in both NbClust and hclust function. Defaults to ‘ward.D2’.</p>
</td></tr>
<tr><td><code id="clustHVT_+3A_indices">indices</code></td>
<td>
<p>Character. The indices used for determining the optimal number of clusters in NbClust function.
By default it uses 20 different indices.</p>
</td></tr>
<tr><td><code id="clustHVT_+3A_clusters_k">clusters_k</code></td>
<td>
<p>Character.  A parameter that specifies the number of clusters for the provided data. 
The options include “champion,” “challenger,” or any integer between 1 and 20. 
Selecting “champion” will use the highest number of clusters recommended by the ‘NbClust’ function,
while “challenger” will use the second-highest recommendation. If a numerical value from 1 to 20
is provided, that exact number will be used as the number of clusters.</p>
</td></tr>
<tr><td><code id="clustHVT_+3A_type">type</code></td>
<td>
<p>Character. The type of output required. Default is 'default'. Other option is 'plot' which
will return only the clustered heatmap.</p>
</td></tr>
<tr><td><code id="clustHVT_+3A_domains.column">domains.column</code></td>
<td>
<p>Character. A vector of cluster names for the clustered heatmap.
Used only when type is 'plot'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object that contains the hierarchical clustering results.
</p>
<table role = "presentation">
<tr><td><code>[[1]]</code></td>
<td>
<p>Summary of k suggested by all indices with plots</p>
</td></tr> 
<tr><td><code>[[2]]</code></td>
<td>
<p>A dendogram plot with the selected number of clusters</p>
</td></tr> 
<tr><td><code>[[3]]</code></td>
<td>
<p>A 2D Cluster HVT Plotly visualization that colors cells according to clusters derived from AGNES clustering results. 
It is interactive, allowing users to view cell contents by hovering over them</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(t = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
rownames(EuStockMarkets) &lt;- dataset$t
hvt.results&lt;- trainHVT(dataset[-1],n_cells = 30, depth = 1, quant.err = 0.1,
                      distance_metric = "L1_Norm", error_metric = "max",
                      normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results, analysis.plots = TRUE, names.column = dataset[,1])
centroid_data &lt;- scoring$centroidData
hclust_data_1 &lt;- centroid_data[,2:3]
clust.results &lt;- clustHVT(data = hclust_data_1, 
                         trainHVT_results = hvt.results,
                         scoreHVT_results = scoring, 
                         clusters_k = 'champion', indices = 'hartigan')
</code></pre>

<hr>
<h2 id='displayTable'>function for displaying table</h2><span id='topic+displayTable'></span>

<h3>Description</h3>

<p>This is the main function for displaying data in table format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayTable(data, scroll = TRUE, limit = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="displayTable_+3A_data">data</code></td>
<td>
<p>Data frame. The dataframe to be displayed in table format.</p>
</td></tr>
<tr><td><code id="displayTable_+3A_scroll">scroll</code></td>
<td>
<p>Logical. A value to have a scroll or not in the table. 
Default is TRUE.</p>
</td></tr>
<tr><td><code id="displayTable_+3A_limit">limit</code></td>
<td>
<p>Numeric. A value to indicate how many rows to display.
Default is 20.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with proper formatting for html notebook
</p>


<h3>Author(s)</h3>

<p>Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- datasets::EuStockMarkets
dataset &lt;- as.data.frame(data)
displayTable(dataset)
</code></pre>

<hr>
<h2 id='edaPlots'>plots for data analysis</h2><span id='topic+edaPlots'></span>

<h3>Description</h3>

<p>This is the main function that provides exploratory data analysis plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edaPlots(
  df,
  time_column,
  output_type = "summary",
  n_cols = -1,
  grey_bars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edaPlots_+3A_df">df</code></td>
<td>
<p>Dataframe. A data frame object.</p>
</td></tr>
<tr><td><code id="edaPlots_+3A_time_column">time_column</code></td>
<td>
<p>Character. The name of the time column in the data frame.
Can be given only when the data is time series</p>
</td></tr>
<tr><td><code id="edaPlots_+3A_output_type">output_type</code></td>
<td>
<p>Character. The name of the output to be displayed. Options are 'summary',
'histogram', 'boxplot', 'timeseries' &amp; 'correlation'. Default value is summary.</p>
</td></tr>
<tr><td><code id="edaPlots_+3A_n_cols">n_cols</code></td>
<td>
<p>Numeric. A value to indicate how many columns to be included in the output.</p>
</td></tr>
<tr><td><code id="edaPlots_+3A_grey_bars">grey_bars</code></td>
<td>
<p>List. A list of timestamps where each list contains two elements: start and end period,
which will be highlighted in gray in the time series plot. Default value is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Five objects which include time series plots, data distribution plots, 
box plots, correlation plot and a descriptive statistics table.
</p>


<h3>Author(s)</h3>

<p>Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
DAX = as.numeric(EuStockMarkets[, "DAX"]),
SMI = as.numeric(EuStockMarkets[, "SMI"]),
CAC = as.numeric(EuStockMarkets[, "CAC"]),
FTSE = as.numeric(EuStockMarkets[, "FTSE"]))
edaPlots(dataset)
edaPlots(dataset, time_column = 'date', output_type = 'timeseries', n_cols = 4)
</code></pre>

<hr>
<h2 id='getOptimalCentroids'>getOptimalCentroids</h2><span id='topic+getOptimalCentroids'></span>

<h3>Description</h3>

<p>Get Optimal Centroids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOptimalCentroids(
  x,
  iter.max,
  algorithm,
  n_cells,
  seed = 100,
  function_to_calculate_distance_metric,
  function_to_calculate_error_metric = c("mean", "max"),
  quant.err,
  distance_metric = "L1_Norm",
  quant_method = c("kmeans", "kmedoids"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getOptimalCentroids_+3A_x">x</code></td>
<td>
<p>Data Frame. A dataframe of multivariate data. Each row corresponds to an
observation, and each column corresponds to a variable. Missing values are
not accepted.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_algorithm">algorithm</code></td>
<td>
<p>String. The type of algorithm used for quantization.
Available algorithms are Hartigan and Wong, &quot;Lloyd&quot;, &quot;Forgy&quot;, &quot;MacQueen&quot;.
(default is &quot;Hartigan-Wong&quot;)</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_n_cells">n_cells</code></td>
<td>
<p>Numeric. Indicating the number of nodes per hierarchy.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_function_to_calculate_distance_metric">function_to_calculate_distance_metric</code></td>
<td>
<p>Function. The function is to find 'L1_Norm&quot; or &quot;L2_Norm&quot; distances. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_function_to_calculate_error_metric">function_to_calculate_error_metric</code></td>
<td>
<p>Character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. The quantization error for the algorithm.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric to calculate inter point distance. It can be 'L1_Norm&quot; or &quot;L2_Norm&quot;. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_quant_method">quant_method</code></td>
<td>
<p>Character. The quant_method can be &quot;kmeans&quot; or &quot;kmedoids&quot;. kmeans is selected by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw data is first scaled and this scaled data is supplied as input to
the vector quantization algorithm. Vector quantization technique uses a
parameter called quantization error. This parameter acts as a threshold and
determines the number of levels in the hierarchy. It means that, if there
are 'n' number of levels in the hierarchy, then all the clusters formed till
this level will have quantization error equal or greater than the threshold
quantization error. The user can define the number of clusters in the first
level of hierarchy and then each cluster in first level is sub-divided into
the same number of clusters as there are in the first level. This process
continues and each group is divided into smaller clusters as long as the
threshold quantization error is met. The output of this technique will be
hierarchically arranged vector quantized data.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p> List. A list showing observations assigned to a cluster.</p>
</td></tr>
<tr><td><code>maxQE</code></td>
<td>
<p> List. A list corresponding to maximum QE values for each cell. </p>
</td></tr>
<tr><td><code>meanQE</code></td>
<td>
<p> List. A list corresponding to mean QE values for each cell. </p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p> List. A list of quantization error for all levels and nodes. </p>
</td></tr> 
<tr><td><code>nsize</code></td>
<td>
<p> List. A list corresponding to number of observations in respective groups. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>

<hr>
<h2 id='getTransitionProbability'>Creating Transition Probability Matrix</h2><span id='topic+getTransitionProbability'></span>

<h3>Description</h3>

<p>This is the main function to create transition probability matrix
The transition probability matrix quantifies the likelihood of transitioning from one state to another. 
States: The table includes the current states and the possible next states.
Probabilities: For each current state, it lists the probability of transitioning to each of the next possible states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransitionProbability(
  df,
  cellid_column,
  time_column,
  type = "with_self_state"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getTransitionProbability_+3A_df">df</code></td>
<td>
<p>Data frame. The input data frame should contain two columns, 
cell ID from scoreHVT function and time stamp of that dataset.</p>
</td></tr>
<tr><td><code id="getTransitionProbability_+3A_cellid_column">cellid_column</code></td>
<td>
<p>Character. Name of the column containing cell IDs.</p>
</td></tr>
<tr><td><code id="getTransitionProbability_+3A_time_column">time_column</code></td>
<td>
<p>Character. Name of the column containing time stamps.</p>
</td></tr>
<tr><td><code id="getTransitionProbability_+3A_type">type</code></td>
<td>
<p>Character. A character value indicating the type of transition probability table to create.
Accepted entries are &quot;with_self_state&quot; and &quot;without_self_state&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stores a data frames with transition probabilities.
</p>


<h3>Author(s)</h3>

<p>PonAnuReka Seenivasan &lt;ponanureka.s@mu-sigma.com&gt;, Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(t = as.numeric(time(EuStockMarkets)),
                      DAX = EuStockMarkets[, "DAX"],
                      SMI = EuStockMarkets[, "SMI"],
                      CAC = EuStockMarkets[, "CAC"],
                      FTSE = EuStockMarkets[, "FTSE"])
hvt.results&lt;- trainHVT(dataset[-1],n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$t
dataset &lt;- data.frame(cell_id, time_stamp)
table &lt;- getTransitionProbability(dataset, cellid_column = "cell_id",time_column = "time_stamp")
</code></pre>

<hr>
<h2 id='msm'>Performing Monte Carlo Simulations of Markov Chain</h2><span id='topic+msm'></span>

<h3>Description</h3>

<p>This is the main function to perform Monte Carlo simulations of Markov Chain on
the dynamic forecasting of HVT States of a time series dataset. It includes both ex-post and ex-ante analysis 
offering valuable insights into future trends while resolving state transition 
challenges through clustering and nearest-neighbor methods to enhance simulation accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msm(
  state_time_data,
  forecast_type = "ex-post",
  initial_state,
  n_ahead_ante,
  transition_probability_matrix,
  num_simulations = 100,
  trainHVT_results,
  scoreHVT_results,
  actual_data = NULL,
  raw_dataset,
  k = 5,
  handle_problematic_states = FALSE,
  n_nearest_neighbor = 1,
  show_simulation = TRUE,
  mae_metric = "median"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msm_+3A_state_time_data">state_time_data</code></td>
<td>
<p>DataFrame. A dataframe containing state transitions over time(cell id and timestamp)</p>
</td></tr>
<tr><td><code id="msm_+3A_forecast_type">forecast_type</code></td>
<td>
<p>Character. A character to indicate the type of forecasting.
Accepted values are &quot;ex-post&quot; or &quot;ex-ante&quot;.</p>
</td></tr>
<tr><td><code id="msm_+3A_initial_state">initial_state</code></td>
<td>
<p>Numeric. An integer indicatiog the state at t0.</p>
</td></tr>
<tr><td><code id="msm_+3A_n_ahead_ante">n_ahead_ante</code></td>
<td>
<p>Numeric. A vector of n ahead points to be predicted further in ex-ante analyzes.</p>
</td></tr>
<tr><td><code id="msm_+3A_transition_probability_matrix">transition_probability_matrix</code></td>
<td>
<p>DataFrame. A dataframe of transition probabilities/ output of 
'getTransitionProbability' function</p>
</td></tr>
<tr><td><code id="msm_+3A_num_simulations">num_simulations</code></td>
<td>
<p>Integer. A number indicating the total number of simulations to run.
Default is 100.</p>
</td></tr>
<tr><td><code id="msm_+3A_trainhvt_results">trainHVT_results</code></td>
<td>
<p>List.'trainHVT' function output</p>
</td></tr>
<tr><td><code id="msm_+3A_scorehvt_results">scoreHVT_results</code></td>
<td>
<p>List. 'scoreHVT' function output</p>
</td></tr>
<tr><td><code id="msm_+3A_actual_data">actual_data</code></td>
<td>
<p>Dataframe. A dataFrame for ex-post prediction period with teh actual raw data values</p>
</td></tr>
<tr><td><code id="msm_+3A_raw_dataset">raw_dataset</code></td>
<td>
<p>DataFrame. A dataframe of input raw dataset from the mean and standard deviation will 
be calculated to scale up the predicted values</p>
</td></tr>
<tr><td><code id="msm_+3A_k">k</code></td>
<td>
<p>Integer. A number of optimal clusters when handling problematic states. 
Default is 5.</p>
</td></tr>
<tr><td><code id="msm_+3A_handle_problematic_states">handle_problematic_states</code></td>
<td>
<p>Logical. To indicate whether to handle problematic states or not.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="msm_+3A_n_nearest_neighbor">n_nearest_neighbor</code></td>
<td>
<p>Integer. A number of nearest neighbors to consider when handling problematic states.
Default is 1.</p>
</td></tr>
<tr><td><code id="msm_+3A_show_simulation">show_simulation</code></td>
<td>
<p>Logical. To indicate whether to show the simulation lines in plots or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="msm_+3A_mae_metric">mae_metric</code></td>
<td>
<p>Character. A character to indicate which metric to calculate Mean Absolute Error. 
Accepted entries are &quot;mean&quot;, &quot;median&quot;, or &quot;mode&quot;. Default is &quot;median&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object that contains the forecasting plots and MAE values.
</p>
<table role = "presentation">
<tr><td><code>[[1]]</code></td>
<td>
<p>Simulation plots and MAE values for state and centroids plot</p>
</td></tr> 
<tr><td><code>[[2]]</code></td>
<td>
<p>Summary Table, Dendogram plot and Clustered Heatmap when handle_problematic_states is TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(t = as.numeric(time(EuStockMarkets)),
DAX = EuStockMarkets[, "DAX"],
SMI = EuStockMarkets[, "SMI"],
CAC = EuStockMarkets[, "CAC"],
FTSE = EuStockMarkets[, "FTSE"])
hvt.results&lt;- trainHVT(dataset[,-1],n_cells = 60, depth = 1, quant.err = 0.1,
                      distance_metric = "L1_Norm", error_metric = "max",
                      normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$t
temporal_data &lt;- data.frame(cell_id, time_stamp)
table &lt;- getTransitionProbability(temporal_data, 
cellid_column = "cell_id",time_column = "time_stamp")
colnames(temporal_data) &lt;- c("Cell.ID","t")
ex_post_forecasting &lt;- dataset[1800:1860,]
ex_post &lt;- msm(state_time_data = temporal_data,
              forecast_type = "ex-post",
              transition_probability_matrix = table,
              initial_state = 2,
              num_simulations = 100,
              scoreHVT_results = scoring,
              trainHVT_results = hvt.results,
              actual_data = ex_post_forecasting,
              raw_dataset = dataset,
             mae_metric = "median",
             show_simulation = FALSE)
</code></pre>

<hr>
<h2 id='plotAnimatedFlowmap'>Generating flow maps and animations based on transition probabilities</h2><span id='topic+plotAnimatedFlowmap'></span>

<h3>Description</h3>

<p>This is the main function for generating flow maps and animations based on transition probabilities
including self states and excluding self states.
Flow maps are a type of data visualization used to represent the transition probability of different states. 
Animations are the gifs used to represent the movement of data through the cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAnimatedFlowmap(
  hvt_model_output,
  transition_probability_df,
  df,
  animation = "All",
  flow_map = "All",
  fps_time = 1,
  fps_state = 1,
  time_duration = 2,
  state_duration = 2,
  cellid_column,
  time_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotAnimatedFlowmap_+3A_hvt_model_output">hvt_model_output</code></td>
<td>
<p>List. Output from a trainHVT function.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_transition_probability_df">transition_probability_df</code></td>
<td>
<p>List. Output from getTransitionProbability function</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_df">df</code></td>
<td>
<p>Data frame. The input dataframe should contain two columns, 
cell ID from scoreHVT function and time stamp of that dataset.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_animation">animation</code></td>
<td>
<p>Character. Type of animation ('state_based', 'time_based', 'All' or  NULL)</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_flow_map">flow_map</code></td>
<td>
<p>Character. Type of flow map ('self_state', 'without_self_state', 'All' or NULL)</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_fps_time">fps_time</code></td>
<td>
<p>Numeric. A numeric value for the frames per second of the time transition gif.
(Must be a numeric value and a factor of 100). Default value is 1.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_fps_state">fps_state</code></td>
<td>
<p>Numeric. A numeric value for the frames per second of the state transition gif.
(Must be a numeric value and a factor of 100). Default value is 1.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_time_duration">time_duration</code></td>
<td>
<p>Numeric. A numeric value for the duration of the time transition gif.
Default value is 2.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_state_duration">state_duration</code></td>
<td>
<p>Numeric. A numeric value for the duration of the state transition gif.
Default value is 2.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_cellid_column">cellid_column</code></td>
<td>
<p>Character. Name of the column containing cell IDs.</p>
</td></tr>
<tr><td><code id="plotAnimatedFlowmap_+3A_time_column">time_column</code></td>
<td>
<p>Character. Name of the column containing time stamps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of flow maps and animation gifs.
</p>


<h3>Author(s)</h3>

<p>PonAnuReka Seenivasan &lt;ponanureka.s@mu-sigma.com&gt;, Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+scoreHVT">scoreHVT</a></code> <br /> <code><a href="#topic+getTransitionProbability">getTransitionProbability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                      DAX = EuStockMarkets[, "DAX"],
                      SMI = EuStockMarkets[, "SMI"],
                      CAC = EuStockMarkets[, "CAC"],
                      FTSE = EuStockMarkets[, "FTSE"])
hvt.results&lt;- trainHVT(dataset,n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$date
dataset &lt;- data.frame(cell_id, time_stamp)
table &lt;- getTransitionProbability(dataset, cellid_column = "cell_id",time_column = "time_stamp")
plots &lt;- plotAnimatedFlowmap(hvt_model_output = hvt.results, transition_probability_df = table,
df = dataset, animation = 'All', flow_map = 'All',fps_time = 1,fps_state =  1,time_duration = 3,
state_duration = 3,cellid_column = "cell_id", time_column = "time_stamp")
</code></pre>

<hr>
<h2 id='plotHVT'>Plot the hierarchical tessellations.</h2><span id='topic+plotHVT'></span>

<h3>Description</h3>

<p>This is the main plotting function to construct hierarchical voronoi tessellations in 1D,2D or
Interactive surface plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHVT(
  hvt.results,
  line.width = 0.5,
  color.vec = "black",
  centroid.size = 0.6,
  centroid.color = "black",
  child.level = 1,
  hmap.cols,
  separation_width = 7,
  layer_opacity = c(0.5, 0.75, 0.99),
  dim_size = 1000,
  plot.type = "2Dhvt",
  quant.error.hmap = NULL,
  cell_id = FALSE,
  cell_id_position = "bottom",
  cell_id_size = 2.6
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHVT_+3A_hvt.results">hvt.results</code></td>
<td>
<p>(1D/2DProj/2Dhvt/2Dheatmap/surface_plot) List. A list containing the output of <code>trainHVT</code> function
which has the details of the tessellations to be plotted.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_line.width">line.width</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Numeric Vector. A vector indicating the line widths of the
tessellation boundaries for each level.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_color.vec">color.vec</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Vector. A vector indicating the colors of the boundaries of
the tessellations at each level.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_centroid.size">centroid.size</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Numeric Vector. A vector indicating the size of centroids
for each level.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_centroid.color">centroid.color</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Numeric Vector. A vector indicating the color of centroids
for each level.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_child.level">child.level</code></td>
<td>
<p>(2Dheatmap/surface_plot) Numeric. Indicating the level for which the plot should
be displayed</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_hmap.cols">hmap.cols</code></td>
<td>
<p>(2Dheatmap/surface_plot) Numeric or Character. The column number or column name from
the dataset indicating the variables for which the heat map is to be plotted.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_separation_width">separation_width</code></td>
<td>
<p>(surface_plot) Numeric. An integer indicating the width between hierarchical levels in surface plot</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_layer_opacity">layer_opacity</code></td>
<td>
<p>(surface_plot) Numeric. A vector indicating the opacity of each hierarchical levels in surface plot</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_dim_size">dim_size</code></td>
<td>
<p>(surface_plot) Numeric. An integer controls the resolution or granularity of the 3D surface grid</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_plot.type">plot.type</code></td>
<td>
<p>Character. An option to indicate which type of plot should be generated. Accepted entries are 
'1D','2Dproj','2Dhvt','2Dheatmap'and 'surface_plot'. Default value is '2Dhvt'.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_quant.error.hmap">quant.error.hmap</code></td>
<td>
<p>(2Dheatmap) Numeric. A number representing the quantization error threshold to be highlighted in the heatmap. 
When a value is provided, it will emphasize cells with quantization errors equal or less than the specified threshold,
indicating that these cells cannot be further subdivided in the next depth layer. The default value is NULL,
meaning all cells will be colored in the heatmap across various depths.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_cell_id">cell_id</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Logical. A logical indicating whether the cell IDs should be displayed</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_cell_id_position">cell_id_position</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Character. A character indicating the position of the cell IDs. Accepted entries are 'top' , 
'bottom', 'left' and 'right'.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_cell_id_size">cell_id_size</code></td>
<td>
<p>(2Dhvt/2Dheatmap) Numeric. A numeric vector indicating the size of the cell IDs for all levels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot object containing the visualizations of reduced dimension(1D/2D) for the given dataset.
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;, Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans")
                       
#change the 'plot.type' argument to '2Dproj' or '2DHVT' to visualize respective plots.                      
plotHVT(hvt.results, plot.type='1D')

#change the 'plot.type' argument to 'surface_plot' to visualize the Interactive surface plot                   
plotHVT(hvt.results,child.level = 1, 
hmap.cols = "DAX", plot.type = '2Dheatmap')
</code></pre>

<hr>
<h2 id='plotModelDiagnostics'>Make the diagnostic plots for hierarchical voronoi tessellations</h2><span id='topic+plotModelDiagnostics'></span>

<h3>Description</h3>

<p>This is the main function that generates diagnostic plots for 
hierarchical voronoi tessellations models and scoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModelDiagnostics(model_obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotModelDiagnostics_+3A_model_obj">model_obj</code></td>
<td>
<p>List. A list obtained from the trainHVT
function or scoreHVT function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For trainHVT, Minimum Intra-DataPoint Distance Plot, Minimum Intra-Centroid Distance Plot
Mean Absolute Deviation Plot, Distribution of Number of Observations in Cells, for Training Data and
Mean Absolute Deviation Plot for Validation Data are plotted.
For scoreHVT Mean Absolute Deviation Plot for Training Data and Validation Data are plotted
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE, quant_method="kmeans", diagnose = TRUE, 
                       hvt_validation = TRUE)
plotModelDiagnostics(hvt.results)
</code></pre>

<hr>
<h2 id='plotNovelCells'>Plot the identified outlier cells in the voronoi tessellation map.</h2><span id='topic+plotNovelCells'></span>

<h3>Description</h3>

<p>This is the main plotting function to construct hierarchical voronoi tessellations 
and highlight the outlier cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNovelCells(
  plot.cells,
  hvt.map,
  line.width = c(0.6),
  color.vec = c("#141B41"),
  pch = 21,
  centroid.size = 0.5,
  title = NULL,
  maxDepth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotNovelCells_+3A_plot.cells">plot.cells</code></td>
<td>
<p>Vector. A vector indicating the cells to be highlighted in the map</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_hvt.map">hvt.map</code></td>
<td>
<p>List. A list containing the output of <code>trainHVT</code> function
which has the details of the tessellations to be plotted</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_line.width">line.width</code></td>
<td>
<p>Numeric Vector. A vector indicating the line widths of the
tessellation boundaries for each level</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A vector indicating the colors of the boundaries of
the tessellations at each level</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_pch">pch</code></td>
<td>
<p>Numeric. Symbol of the centroids of the tessellations
(parent levels) Default value is 21.</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_centroid.size">centroid.size</code></td>
<td>
<p>Numeric. Size of centroids of first level
tessellations. Default value is 0.5</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_title">title</code></td>
<td>
<p>String. Set a title for the plot. (default = NULL)</p>
</td></tr>
<tr><td><code id="plotNovelCells_+3A_maxdepth">maxDepth</code></td>
<td>
<p>Numeric. An integer indicating the number of levels. (default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot object containing hierarchical voronoi tessellation plot
highlighting the outlier cells
</p>


<h3>Author(s)</h3>

<p>Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans")
#selected 55,58 are for demo purpose
plotNovelCells(c(55,58),hvt.results)
</code></pre>

<hr>
<h2 id='plotQuantErrorHistogram'>Make the quantization error plots for training and scoring.</h2><span id='topic+plotQuantErrorHistogram'></span>

<h3>Description</h3>

<p>This is the function that produces histograms displaying the distribution of Quantization Error (QE) values 
for both train and test datasets, highlighting mean values with dashed lines for quick evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQuantErrorHistogram(hvt.results, hvt.scoring)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotQuantErrorHistogram_+3A_hvt.results">hvt.results</code></td>
<td>
<p>List. A list of hvt.results obtained from the trainHVT function.</p>
</td></tr>
<tr><td><code id="plotQuantErrorHistogram_+3A_hvt.scoring">hvt.scoring</code></td>
<td>
<p>List. A list of hvt.scoring obtained from the scoreHVT function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ggplot object containing the quantization error distribution plots for 
the given HVT results of training and scoring
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
rownames(EuStockMarkets) &lt;- dataset$date
#Split in train and test
train &lt;- EuStockMarkets[1:1302, ]
test &lt;- EuStockMarkets[1303:1860, ]

hvt.results&lt;- trainHVT(train,n_cells = 60, depth = 1, quant.err = 0.1,
                      distance_metric = "L1_Norm", error_metric = "max",
                      normalize = TRUE, quant_method = "kmeans")
scoring &lt;- scoreHVT(test, hvt.results)
plotQuantErrorHistogram(hvt.results, scoring) 
</code></pre>

<hr>
<h2 id='plotStateTransition'>Creating State Transition Plot</h2><span id='topic+plotStateTransition'></span>

<h3>Description</h3>

<p>This is the main function to create a state transition plot from a data frame.
A state transition plot is a type of data visualization used to represent 
the changes or transitions in states over time for a given system. 
State refers to a particular condition or status of a cell at a specific point in time. 
Transition refers to the change of state for a cell from one condition to another over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotStateTransition(
  df,
  sample_size = NULL,
  line_plot = NULL,
  cellid_column,
  time_column,
  v_intercept = NULL,
  time_periods = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotStateTransition_+3A_df">df</code></td>
<td>
<p>Data frame. The Input data frame should contain two columns. 
Cell ID from scoreHVT function and time stamp of that dataset.</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_sample_size">sample_size</code></td>
<td>
<p>Numeric. An integer indicating the fraction of the data frame to visualize in the plot.
Default value is 0.2</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_line_plot">line_plot</code></td>
<td>
<p>Logical. A logical value indicating to create a line plot. Default value is NULL.</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_cellid_column">cellid_column</code></td>
<td>
<p>Character. Name of the column containing cell IDs.</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_time_column">time_column</code></td>
<td>
<p>Character. Name of the column containing time stamps.</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_v_intercept">v_intercept</code></td>
<td>
<p>Numeric. A numeric value indicating the time stamp to draw a vertical line on the plot.</p>
</td></tr>
<tr><td><code id="plotStateTransition_+3A_time_periods">time_periods</code></td>
<td>
<p>List. A list of vectors, each containing start and end times for highlighting time periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plotly object representing the state transition plot for the given data frame.
</p>


<h3>Author(s)</h3>

<p>PonAnuReka Seenivasan &lt;ponanureka.s@mu-sigma.com&gt;, Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
DAX = EuStockMarkets[, "DAX"],
SMI = EuStockMarkets[, "SMI"],
CAC = EuStockMarkets[, "CAC"],
FTSE = EuStockMarkets[, "FTSE"])

hvt.results&lt;- trainHVT(dataset,n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$date
dataset &lt;- data.frame(cell_id, time_stamp)
plotStateTransition(dataset, sample_size = 1, cellid_column = "cell_id",time_column = "time_stamp")
</code></pre>

<hr>
<h2 id='plotZscore'>Plots of z scores</h2><span id='topic+plotZscore'></span>

<h3>Description</h3>

<p>This is the main function to plot the z scores against cell ids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotZscore(
  data,
  cell_range = NULL,
  segment_size = 2,
  reference_lines = c(-1.65, 1.65)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotZscore_+3A_data">data</code></td>
<td>
<p>Data frame. A data frame of cell id and features.</p>
</td></tr>
<tr><td><code id="plotZscore_+3A_cell_range">cell_range</code></td>
<td>
<p>Vector. A numeric vector of cell id range for which the plot should be displayed. 
Default is NULL, which plots all the cells.</p>
</td></tr>
<tr><td><code id="plotZscore_+3A_segment_size">segment_size</code></td>
<td>
<p>Integer.  A numeric value to indicate the size of the bars in the plot. 
Default is 2.</p>
</td></tr>
<tr><td><code id="plotZscore_+3A_reference_lines">reference_lines</code></td>
<td>
<p>Vector. A numeric vector of confidence interval values for the 
reference lines in the plot. Default is c(-1.65, 1.65).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid of plots of z score against cell id of teh given features.
</p>


<h3>Author(s)</h3>

<p>Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(t = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
rownames(EuStockMarkets) &lt;- dataset$t
hvt.results&lt;- trainHVT(dataset[-1],n_cells = 60, depth = 1, quant.err = 0.1,
                      distance_metric = "L1_Norm", error_metric = "max",
                      normalize = TRUE,quant_method = "kmeans")
col_names &lt;- c("Cell.ID","DAX","SMI","CAC","FTSE")
data &lt;- dplyr::arrange(dplyr::select(hvt.results[[3]][["summary"]],col_names),Cell.ID)
data &lt;- round(data, 2)
plotZscore(data)
</code></pre>

<hr>
<h2 id='reconcileTransitionProbability'>Reconciliation of Transition Probability</h2><span id='topic+reconcileTransitionProbability'></span>

<h3>Description</h3>

<p>This is the main function for creating reconciliation plots and tables which 
helps in comparing the transition probabilities calculated manually and from markovchain function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconcileTransitionProbability(
  df,
  hmap_type = NULL,
  cellid_column,
  time_column
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconcileTransitionProbability_+3A_df">df</code></td>
<td>
<p>Data frame. The input data frame should contain two columns, cell ID from scoreHVT function and timestamp of that dataset.</p>
</td></tr>
<tr><td><code id="reconcileTransitionProbability_+3A_hmap_type">hmap_type</code></td>
<td>
<p>Character. ('self_state', 'without_self_state', or 'All')</p>
</td></tr>
<tr><td><code id="reconcileTransitionProbability_+3A_cellid_column">cellid_column</code></td>
<td>
<p>Character. Name of the column containing cell IDs.</p>
</td></tr>
<tr><td><code id="reconcileTransitionProbability_+3A_time_column">time_column</code></td>
<td>
<p>Character. Name of the column containing timestamps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of plotly heatmap objects and tables representing the transition probability heatmaps.
</p>


<h3>Author(s)</h3>

<p>PonAnuReka Seenivasan &lt;ponanureka.s@mu-sigma.com&gt;, Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                      DAX = EuStockMarkets[, "DAX"],
                      SMI = EuStockMarkets[, "SMI"],
                      CAC = EuStockMarkets[, "CAC"],
                      FTSE = EuStockMarkets[, "FTSE"])
hvt.results&lt;- trainHVT(dataset,n_cells = 60, depth = 1, quant.err = 0.1,
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(dataset, hvt.results)
cell_id &lt;- scoring$scoredPredictedData$Cell.ID
time_stamp &lt;- dataset$date
dataset &lt;- data.frame(cell_id, time_stamp)
reconcileTransitionProbability(dataset, hmap_type = "All", 
cellid_column = "cell_id", time_column = "time_stamp")
</code></pre>

<hr>
<h2 id='removeNovelty'>Remove identified novelty cell(s)</h2><span id='topic+removeNovelty'></span>

<h3>Description</h3>

<p>This function is used to remove the identified novelty cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeNovelty(outlier_cells, hvt_results)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeNovelty_+3A_outlier_cells">outlier_cells</code></td>
<td>
<p>Vector. A vector with the cell number of the identified novelty</p>
</td></tr>
<tr><td><code id="removeNovelty_+3A_hvt_results">hvt_results</code></td>
<td>
<p>List. A list having the results of the compressed map i.e. output of <code>trainHVT</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two items
</p>
<table role = "presentation">
<tr><td><code>[[1]]</code></td>
<td>
<p>Dataframe of novelty cell(s)</p>
</td></tr>
<tr><td><code>[[2]]</code></td>
<td>
<p>Dataframe without the novelty cell(s) from the dataset used in model training</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+scoreLayeredHVT">scoreLayeredHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans")
identified_Novelty_cells &lt;&lt;- c(2, 10)
output_list &lt;- removeNovelty(identified_Novelty_cells, hvt.results) 
data_with_novelty &lt;- output_list[[1]]
data_without_novelty &lt;- output_list[[2]]                      
</code></pre>

<hr>
<h2 id='scoreHVT'>Score which cell each point in the test dataset belongs to.</h2><span id='topic+scoreHVT'></span>

<h3>Description</h3>

<p>This function scores each data point in the test dataset based on a trained hierarchical Voronoi tessellations model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreHVT(
  dataset,
  hvt.results.model,
  child.level = 1,
  mad.threshold = 0.2,
  line.width = 0.6,
  color.vec = c("navyblue", "slateblue", "lavender"),
  normalize = TRUE,
  distance_metric = "L1_Norm",
  error_metric = "max",
  yVar = NULL,
  analysis.plots = FALSE,
  names.column = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreHVT_+3A_dataset">dataset</code></td>
<td>
<p>Data frame. A data frame which to be scored. Can have categorical columns if 'analysis.plots' are required.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_hvt.results.model">hvt.results.model</code></td>
<td>
<p>List. A list obtained from the trainHVT function</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_child.level">child.level</code></td>
<td>
<p>Numeric. A number indicating the depth for which the heat map is to be plotted.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_mad.threshold">mad.threshold</code></td>
<td>
<p>Numeric. A numeric value indicating the permissible Mean Absolute Deviation.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_line.width">line.width</code></td>
<td>
<p>Vector. A vector indicating the line widths of the tessellation boundaries for each layer.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A vector indicating the colors of the tessellation boundaries at each layer.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the dataset should be normalized. When set to TRUE,
the data (testing dataset) is standardized by ‘mean’ and ‘sd’ of the training dataset referred from the trainHVT(). 
When set to FALSE, the data is used as such without any changes.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric can be L1_Norm(Manhattan) or L2_Norm(Eucledian). L1_Norm is selected by default.
The distance metric is used to calculate the distance between an n dimensional point and centroid.
The distance metric can be different from the one used during training.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>Character. The error metric can be mean or max. max is selected by default. 
max will return the max of m values and mean will take mean of m values where
each value is a distance between a point and centroid of the cell.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_yvar">yVar</code></td>
<td>
<p>Character. A character or a vector representing the name of the dependent variable(s)</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_analysis.plots">analysis.plots</code></td>
<td>
<p>Logical. A logical value indicating that the scored plot should be plotted or not. If TRUE, 
the identifier column(character column) name should be supplied in 'names.column' argument. The output will
be a 2D heatmap plotly which gives info on the cell id and the observations of a cell.</p>
</td></tr>
<tr><td><code id="scoreHVT_+3A_names.column">names.column</code></td>
<td>
<p>Character. A character or a vector representing the name of the identifier column/character column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing scored data, plots and summary
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt; ,
Vishwavani &lt;vishwavani@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
rownames(EuStockMarkets) &lt;- dataset$date
# Split in train and test
train &lt;- EuStockMarkets[1:1302, ]
test &lt;- EuStockMarkets[1303:1860, ]
#model training
hvt.results&lt;- trainHVT(train,n_cells = 60, depth = 1, quant.err = 0.1,
                      distance_metric = "L1_Norm", error_metric = "max",
                      normalize = TRUE,quant_method = "kmeans")
scoring &lt;- scoreHVT(test, hvt.results)
data_scored &lt;- scoring$scoredPredictedData
</code></pre>

<hr>
<h2 id='scoreLayeredHVT'>Score which cell and what layer each data point in the test dataset belongs to</h2><span id='topic+scoreLayeredHVT'></span>

<h3>Description</h3>

<p>This function that scores the cell and corresponding layer for each data point in a test dataset using three 
hierarchical vector quantization (HVT) models (Map A, Map B, Map C) and returns a data frame containing the scored layer output. 
The function incorporates the scored results from each map and merges them to provide a comprehensive result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoreLayeredHVT(
  data,
  hvt_mapA,
  hvt_mapB,
  hvt_mapC,
  mad.threshold = 0.2,
  normalize = TRUE,
  seed = 300,
  distance_metric = "L1_Norm",
  error_metric = "max",
  child.level = 1,
  yVar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoreLayeredHVT_+3A_data">data</code></td>
<td>
<p>Data Frame. A data frame containing test dataset. 
The data frame should have all the variable(features) used for training.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_hvt_mapa">hvt_mapA</code></td>
<td>
<p>A list of hvt.results.model obtained from trainHVT function while performing
'trainHVT()' on train data</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_hvt_mapb">hvt_mapB</code></td>
<td>
<p>A list of hvt.results.model obtained from trainHVT function while performing 
'trainHVT()' on data with novelty(s)</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_hvt_mapc">hvt_mapC</code></td>
<td>
<p>A list of hvt.results.model obtained from trainHVT function while performing
'trainHVT()' on data without novelty(s)</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_mad.threshold">mad.threshold</code></td>
<td>
<p>Numeric. A number indicating the permissible Mean Absolute Deviation</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the dataset should be normalized. 
When set to TRUE, the data (testing dataset) is standardized by 'mean' and 'sd' of the training dataset 
referred from the trainHVT(). When set to FALSE, the data is used as such without any changes.
(Default value is TRUE).</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric can be L1_Norm(Manhattan) or L2_Norm(Eucledian). L1_Norm is selected by default.
The distance metric is used to calculate the distance between an n dimensional point and centroid.
The distance metric can be different from the one used during training.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>Character. The error metric can be mean or max. max is selected by default. 
max will return the max of m values and mean will take mean of m values where
each value is a distance between a point and centroid of the cell.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_child.level">child.level</code></td>
<td>
<p>Numeric. A number indicating the level for which the heat map is to be plotted.</p>
</td></tr>
<tr><td><code id="scoreLayeredHVT_+3A_yvar">yVar</code></td>
<td>
<p>Character. A character or a vector representing the name of the dependent variable(s)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing scored layer output
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;, Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;,Somya Shambhawi &lt;somya.shambhawi@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainHVT">trainHVT</a></code> <br /> <code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
dataset &lt;- data.frame(date = as.numeric(time(EuStockMarkets)),
                     DAX = EuStockMarkets[, "DAX"],
                     SMI = EuStockMarkets[, "SMI"],
                     CAC = EuStockMarkets[, "CAC"],
                     FTSE = EuStockMarkets[, "FTSE"])
rownames(EuStockMarkets) &lt;- dataset$date

train &lt;- EuStockMarkets[1:1302, ]
test &lt;- EuStockMarkets[1303:1860, ]

###MAP-A
hvt_mapA &lt;- trainHVT(train, n_cells = 150, depth = 1, quant.err = 0.1,
                    distance_metric = "L1_Norm", error_metric = "max",
                    normalize = TRUE,quant_method = "kmeans")
                    
identified_Novelty_cells &lt;- c(127,55,83,61,44,35,27,77)
output_list &lt;- removeNovelty(identified_Novelty_cells, hvt_mapA)
data_with_novelty &lt;- output_list[[1]] 
data_with_novelty &lt;- data_with_novelty[, -c(1,2)]

### MAP-B
hvt_mapB &lt;- trainHVT(data_with_novelty,n_cells = 10, depth = 1, quant.err = 0.1,
                    distance_metric = "L1_Norm", error_metric = "max",
                    normalize = TRUE,quant_method = "kmeans")
data_without_novelty &lt;- output_list[[2]]

### MAP-C
hvt_mapC &lt;- trainHVT(data_without_novelty,n_cells = 135,
                    depth = 1, quant.err = 0.1, distance_metric = "L1_Norm",
                    error_metric = "max", quant_method = "kmeans",
                    normalize = TRUE)
                    
##SCORE LAYERED
data_scored &lt;- scoreLayeredHVT(test, hvt_mapA, hvt_mapB, hvt_mapC)
</code></pre>

<hr>
<h2 id='summary'>Table for displaying summary</h2><span id='topic+summary'></span>

<h3>Description</h3>

<p>This is the main function for displaying summary from model training and scoring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary(data, limit = 20, scroll = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_data">data</code></td>
<td>
<p>List. A listed object from trainHVT or scoreHVT</p>
</td></tr>
<tr><td><code id="summary_+3A_limit">limit</code></td>
<td>
<p>Numeric. A value to indicate how many rows to display.</p>
</td></tr>
<tr><td><code id="summary_+3A_scroll">scroll</code></td>
<td>
<p>Logical. A value to indicate whether to display scroll bar or not. Default value is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A consolidated table of summary for training, scoring and forecasting
</p>


<h3>Author(s)</h3>

<p>Vishwavani &lt;vishwavani@mu-sigma.com&gt;, Alimpan Dey &lt;alimpan.dey@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- datasets::EuStockMarkets
dataset &lt;- as.data.frame(data)
#model training
hvt.results &lt;- trainHVT(dataset, n_cells = 60, depth = 1, quant.err = 0.1,
                      distance_metric = "L1_Norm", error_metric = "max",
                      normalize = TRUE, quant_method = "kmeans", dim_reduction_method = 'sammon')
summary(data =  hvt.results)
</code></pre>

<hr>
<h2 id='trainHVT'>Constructing Hierarchical Voronoi Tessellations</h2><span id='topic+trainHVT'></span>

<h3>Description</h3>

<p>This is the main function to construct hierarchical voronoi tessellations.
This is done using hierarchical vector quantization(hvq). The data is represented in 2D
coordinates and the tessellations are plotted using these coordinates as
centroids. For subsequent levels, transformation is performed on the 2D
coordinates to get all the points within its parent tile. Tessellations are
plotted using these transformed points as centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainHVT(
  dataset,
  min_compression_perc = NA,
  n_cells = NA,
  depth = 1,
  quant.err = 0.2,
  normalize = FALSE,
  distance_metric = "L1_Norm",
  error_metric = "max",
  quant_method = "kmeans",
  scale_summary = NA,
  diagnose = FALSE,
  hvt_validation = FALSE,
  train_validation_split_ratio = 0.8,
  dim_reduction_method = "sammon",
  tsne_theta = 0.2,
  tsne_eta = 200,
  tsne_perplexity = 30,
  tsne_verbose = TRUE,
  tsne_max_iter = 500,
  umap_n_neighbors = 60,
  umap_n_components = 2,
  umap_min_dist = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trainHVT_+3A_dataset">dataset</code></td>
<td>
<p>Data frame. A data frame, with numeric columns (features) will be used for training the model.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_min_compression_perc">min_compression_perc</code></td>
<td>
<p>Numeric. An integer, indicating the minimum compression percentage to be achieved for the dataset. 
It indicates the desired level of reduction in dataset size compared to its original size.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_n_cells">n_cells</code></td>
<td>
<p>Numeric. An integer, indicating the number of cells per hierarchy (level).</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_depth">depth</code></td>
<td>
<p>Numeric. An integer, indicating the number of levels. A depth of 1 means no hierarchy (single level), 
while higher values indicate multiple levels (hierarchy).</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. A number indicating the quantization error threshold.
A cell will only breakdown into further cells if the quantization error of the cell is 
above the defined quantization error threshold.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the dataset should be normalized. When set to TRUE, 
scales the values of all features to have a mean of 0 and a standard deviation of 1 (Z-score).</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric can be L1_Norm(Manhattan) or L2_Norm(Eucledian). L1_Norm is selected by default.
The distance metric is used to calculate the distance between an n dimensional point and centroid.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>Character. The error metric can be mean or max. max is selected by default. 
max will return the max of m values and mean will take mean of m values where
each value is a distance between a point and centroid of the cell.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_quant_method">quant_method</code></td>
<td>
<p>Character. The quantization method can be kmeans or kmedoids. Kmeans uses means (centroids) as cluster centers
while Kmedoids uses actual data points (medoids) as cluster centers. kmeans is selected by default.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_scale_summary">scale_summary</code></td>
<td>
<p>List. A list with user-defined mean and standard deviation values for all the features in the dataset. 
Pass the scale summary when normalize is set to FALSE.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_diagnose">diagnose</code></td>
<td>
<p>Logical. A logical value indicating whether user wants to perform diagnostics on the model. 
Default value is FALSE.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_hvt_validation">hvt_validation</code></td>
<td>
<p>Logical. A logical value indicating whether user wants to holdout a validation set and find 
mean absolute deviation of the validation points from the centroid. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_train_validation_split_ratio">train_validation_split_ratio</code></td>
<td>
<p>Numeric. A numeric value indicating train validation split ratio. 
This argument is only used when hvt_validation has been set to TRUE. Default value for the argument is 0.8.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_dim_reduction_method">dim_reduction_method</code></td>
<td>
<p>Character.The dim_reduction_method can be one of &quot;tsne&quot;, &quot;umap&quot;, &quot;sammon&quot;.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_tsne_theta">tsne_theta</code></td>
<td>
<p>Numeric.The tsne_theta is only used when dim_reduction_method is set to &quot;tsne&quot;.
Default value is 0.5 and common values are between 0.2 and 0.5.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_tsne_eta">tsne_eta</code></td>
<td>
<p>Numeric.The tsne_eta are used only when dim_reduction method is set to &quot;tsne&quot;.
Default value is 200.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_tsne_perplexity">tsne_perplexity</code></td>
<td>
<p>Numeric.The tsne_perplexity is only used when dim_reduction_method is set to &quot;tsne&quot;.
Default value is 30 and common values are between between 30 and 50.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_tsne_verbose">tsne_verbose</code></td>
<td>
<p>Logical. A logical value which indicates the t-SNE algorithm to print 
detailed information about its progress to the console.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_tsne_max_iter">tsne_max_iter</code></td>
<td>
<p>Numeric.The tsne_max_iter is used only when dim_reduction_method is set to &quot;tsne&quot;.
Default value is 1000.More iterations can improve results but increase computation time.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_umap_n_neighbors">umap_n_neighbors</code></td>
<td>
<p>Integer.The umap_n_neighbors is used only when dim_reduction_method is set to &quot;umap&quot;.
Default value is 15.Controls the balance between local and global structure in data.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_umap_n_components">umap_n_components</code></td>
<td>
<p>Integer.The umap_n_components is used only when dim_reduction_method is set to &quot;umap&quot;.
Default value is 2.Indicates the number of dimensions for embedding.</p>
</td></tr>
<tr><td><code id="trainHVT_+3A_umap_min_dist">umap_min_dist</code></td>
<td>
<p>Numeric.The umap_map_dist is used only when dim_reduction_method is set to &quot;umap&quot;.
Default value is 0.1.Controls how tightly UMAP packs points together.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Nested list that contains the hierarchical tessellation information. This
list has to be given as input argument to plot the tessellations.
</p>
<table role = "presentation">
<tr><td><code>[[1]]</code></td>
<td>
<p>A list containing information related to plotting tessellations. 
This information will include coordinates, boundaries, and other details necessary for visualizing the tessellations</p>
</td></tr> 
<tr><td><code>[[2]]</code></td>
<td>
<p>A list containing information related to Sammon’s projection coordinates of the data points
in the reduced-dimensional space.</p>
</td></tr>
<tr><td><code>[[3]]</code></td>
<td>
<p>A list containing detailed information about the hierarchical vector quantized data along with 
a summary section containing no of points, Quantization Error and the centroids for each cell.</p>
</td></tr>
<tr><td><code>[[4]]</code></td>
<td>
<p>A list that contains all the diagnostics information of the model when diagnose is set to TRUE. 
Otherwise NA.</p>
</td></tr>
<tr><td><code>[[5]]</code></td>
<td>
<p>A list that contains all the information required to generates a Mean Absolute Deviation (MAD) plot, 
if hvt_validation is set to TRUE. Otherwise NA</p>
</td></tr>
<tr><td><code>[[6]]</code></td>
<td>
<p>A list containing detailed information about the hierarchical vector quantized data along with a
summary section containing no of points, Quantization Error and the centroids for each cell which is the output of 'hvq'</p>
</td></tr>
<tr><td><code>[[7]]</code></td>
<td>
<p>model info: A list that contains model-generated timestamp, input parameters passed to the model ,
the validation results and the dimensionality reduction evaluation metrics table.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;, Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;,Bidesh Ghosh &lt;bidesh.gosh@mu-sigma.com&gt;,Alimpan Dey &lt;alimpan.dey@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("EuStockMarkets")
hvt.results &lt;- trainHVT(EuStockMarkets, n_cells = 60, depth = 1, quant.err = 0.1, 
                       distance_metric = "L1_Norm", error_metric = "max",
                       normalize = TRUE,quant_method="kmeans")
</code></pre>

<hr>
<h2 id='VQ_codebookSplit'>VQ_codebookSplit</h2><span id='topic+VQ_codebookSplit'></span>

<h3>Description</h3>

<p>Vector Quantization by codebook split method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VQ_codebookSplit(dataset, quant.err = 0.5, epsilon = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VQ_codebookSplit_+3A_dataset">dataset</code></td>
<td>
<p>Matrix. A matrix of multivariate data. Each row corresponds
to an observation, and each column corresponds to a variable. Missing values
are not accepted.</p>
</td></tr>
<tr><td><code id="VQ_codebookSplit_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. The quantization error for the algorithm.</p>
</td></tr>
<tr><td><code id="VQ_codebookSplit_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric. The value to offset the codebooks during the
codebook split. Default is NULL, in which case the value is set to quant.err
parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs Vector Quantization by codebook split method. Initially, the entire
dataset is considered to be one cluster where the codebook is the mean of
the cluster. The quantization criteria is checked and the codebook is split
such that the new codebooks are (codebook+epsilon) and (codebook-epsilon).
The observations are reassigned to these new codebooks based on the nearest
neighbour condition and the means recomputed for the new clusters. This is
done iteratively until all the clusters meet the quantization criteria.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusters</code></td>
<td>
<p> List. A list showing each ID assigned to a cluster.
</p>
</td></tr> <tr><td><code>nodes.clust</code></td>
<td>
<p> List. A list corresponding to nodes' details. </p>
</td></tr>
<tr><td><code>idnodes</code></td>
<td>
<p> List. A list of ID and segments similar to
<code>nodes.clust</code> with additional columns for nodes ID. </p>
</td></tr>
<tr><td><code>error.quant</code></td>
<td>
<p> List. A list of quantization error for all levels and
nodes. </p>
</td></tr> <tr><td><code>plt.clust</code></td>
<td>
<p> List. A list of logical values indicating if the
quantization error was met. </p>
</td></tr> <tr><td><code>summary</code></td>
<td>
<p> Summary. Output table with
summary. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("iris", package = "datasets")
iris &lt;- iris[, 1:2]

vqOutput &lt;- VQ_codebookSplit(iris, quant.err = 0.5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
