<!DOCTYPE html><html><head><title>Help for package HVT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HVT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#diagPlot'><p>Diagnosis Plot</p></a></li>
<li><a href='#exploded_hmap'><p>Function to construct an interactive 3D heatmap overlay for each HVT Level</p></a></li>
<li><a href='#get_cell_id'><p>Function to generate cell ID based on 1D sammons projection</p></a></li>
<li><a href='#getOptimalCentroids'><p>getOptimalCentroids</p></a></li>
<li><a href='#hvq'><p>hvq</p></a></li>
<li><a href='#HVT'><p>Constructing Hierarchical Voronoi Tessellations</p></a></li>
<li><a href='#hvtHmap'><p>Heat Map over Hierarchical Voronoi Tessellations</p></a></li>
<li><a href='#madPlot'><p>Mean Absolute Deviation Plot</p></a></li>
<li><a href='#mlayerHVT'><p>Predict which cell and what level each point in the test dataset belongs to</p></a></li>
<li><a href='#multiNormalDist'><p>Multivariate normal distribution</p></a></li>
<li><a href='#plotCells'><p>Plot the identified outlier cell(s) in the voronoi tessellations map.</p>
</p>
<p>Plotting function to construct hierarchical voronoi tessellations and highlight the cells using the</p>
compressed HVT map.</a></li>
<li><a href='#plotDiag'><p>Make the diagnostic plots for hierarchical voronoi tessellations model.</p></a></li>
<li><a href='#plotHVT'><p>Plot the hierarchical tesselations.</p>
</p>
<p>Main plotting function to construct hierarchical voronoi tessellations.</p></a></li>
<li><a href='#predictHVT'><p>Predict which cell and what level each point in the test dataset belongs to</p></a></li>
<li><a href='#predictLayerHVT'><p>Predict which cell and what level each point in the test dataset belongs to</p></a></li>
<li><a href='#qeHistPlot'><p>plotDiag</p>
</p>
<p>Make the diagnostic plots for hierarchical voronoi tessellations model.</p></a></li>
<li><a href='#removeNovelty'><p>removeNovelty</p></a></li>
<li><a href='#removeOutliers'><p>removeOutliers</p></a></li>
<li><a href='#sammonsProjection'><p>sammonsProjection</p></a></li>
<li><a href='#VQ_codebookSplit'><p>VQ_codebookSplit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Constructing Hierarchical Voronoi Tessellations and Overlay
Heatmaps for Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>23.11.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates building topology preserving maps for rich multivariate data. See <a href="https://en.wikipedia.org/wiki/Voronoi_diagram">https://en.wikipedia.org/wiki/Voronoi_diagram</a> for more information. Credits to Mu Sigma for their continuous support throughout the development of the package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, deldir, grDevices, splancs, sp, conf.design, Hmisc,
stats, dplyr, purrr, magrittr, polyclip, ggplot2, tidyr,
scales, cluster, reshape2, plyr, data.table</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Mu-Sigma/HVT/issues">https://github.com/Mu-Sigma/HVT/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Mu-Sigma/HVT">https://github.com/Mu-Sigma/HVT</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, geozoo, kableExtra, plotly, DT,
gridExtra, gtable, htmlwidgets, installr, skimr, tibble,
devtools, tidyverse, DataExplorer, htmltools, corrplot,
gganimate</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-18 10:35:22 UTC; gopi</td>
</tr>
<tr>
<td>Author:</td>
<td>Zubin Dowlaty [aut],
  Mu Sigma, Inc. [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>"Mu Sigma, Inc." &lt;ird.experiencelab@mu-sigma.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-19 15:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='diagPlot'>Diagnosis Plot</h2><span id='topic+diagPlot'></span>

<h3>Description</h3>

<p>Function to construct Diagnosis Plots for HVT Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagPlot(
  hvt.results,
  data,
  level,
  quant.err,
  distance_metric = "L1_Norm",
  error_metric = "max",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagPlot_+3A_hvt.results">hvt.results</code></td>
<td>
<p>A list of hvt.results obtained from HVT function while performing hierarchical vector quantization on train data</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_data">data</code></td>
<td>
<p>Data frame. A data frame with different columns is given as input. The dataframe should be the same dataframe used to train the HVT Model</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_level">level</code></td>
<td>
<p>Numeric. Indicating the level for which the heat map is
to be plotted.</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. A number indicating the quantization error threshold.</p>
</td></tr>
<tr><td><code id="diagPlot_+3A_...">...</code></td>
<td>
<p>The ellipsis is passed to it as additional argument. (Used internally)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates Diagnosis Plots for HVT Model. The output of the functions contains a Minimum Intra-Centroid distance plot, a Minimum Intra-DataPoint Distance Plot,
Distribution of number of cells,  a Minimum Intra-DataPoint Distance Plot,
Distribution of number of cells and count of singletons(segments with single observation)
</p>


<h3>Value</h3>

<p>A list that contains  a Minimum Inter-Centroid distance plot, a Minimum Intra-DataPoint Distance Plot,
Distribution of number of cells and count of singletons(segments with single observation)
</p>
<table>
<tr><td><code>cent_plot</code></td>
<td>
<p>Plot. a Minimum Intra-Centroid distance plot</p>
</td></tr>
<tr><td><code>datapoint_plot</code></td>
<td>
<p>Plot. a Minimum Intra-Datapoints distance plot</p>
</td></tr> 
<tr><td><code>number_plot</code></td>
<td>
<p>Plot. a Distribution of number of cells</p>
</td></tr> 
<tr><td><code>singleton_count</code></td>
<td>
<p>Numeric. Count of singletons(segments with single observation)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictHVT">predictHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
hvt.results &lt;- list()
hvt.results &lt;- HVT(USArrests, n_cells = 15, depth = 1, quant.err = 0.2, 
                   distance_metric = "L1_Norm", error_metric = "mean",
                   projection.scale = 10, normalize = TRUE,
                   quant_method="kmeans",diagnose=TRUE)
diagPlot(hvt.results = hvt.results,
data = USArrests,
level = 1,
quant.err = 0.2)

</code></pre>

<hr>
<h2 id='exploded_hmap'>Function to construct an interactive 3D heatmap overlay for each HVT Level</h2><span id='topic+exploded_hmap'></span>

<h3>Description</h3>

<p>Function to construct an interactive 3D heatmap overlay for each HVT Level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exploded_hmap(
  hvt.results,
  child.level = NULL,
  hmap.cols = NULL,
  n_cells.hmap = NULL,
  sepration_width = 7,
  layer_opacity = c(0.5, 0.75, 0.99),
  dim_size = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exploded_hmap_+3A_hvt.results">hvt.results</code></td>
<td>
<p>List. A list of hvt.results obtained from the HVT
function.</p>
</td></tr>
<tr><td><code id="exploded_hmap_+3A_child.level">child.level</code></td>
<td>
<p>Numeric. Indicating the level for which the heat map is
to be plotted.</p>
</td></tr>
<tr><td><code id="exploded_hmap_+3A_hmap.cols">hmap.cols</code></td>
<td>
<p>Numeric or Character. The column number of column name from
the dataset indicating the variables for which the heat map is to be
plotted.</p>
</td></tr>
<tr><td><code id="exploded_hmap_+3A_n_cells.hmap">n_cells.hmap</code></td>
<td>
<p>Numeric. An integer indicating the number of clusters per
hierarchy (level)</p>
</td></tr>
<tr><td><code id="exploded_hmap_+3A_sepration_width">sepration_width</code></td>
<td>
<p>Numeric. An integer indicating the width between two Levels</p>
</td></tr>
<tr><td><code id="exploded_hmap_+3A_layer_opacity">layer_opacity</code></td>
<td>
<p>Numeric. A vector indicating the opacity of each layer/ level</p>
</td></tr>
<tr><td><code id="exploded_hmap_+3A_dim_size">dim_size</code></td>
<td>
<p>Numeric. An integer indicating the dimension size used to create the matrix for the plot</p>
</td></tr>
<tr><td><code id="exploded_hmap_+3A_...">...</code></td>
<td>
<p>color.vec and line.width can be passed from here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot object containing Hierarchical Voronoi Tessellation 3D Surface plot with Heatmap Overlay
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>

<hr>
<h2 id='get_cell_id'>Function to generate cell ID based on 1D sammons projection</h2><span id='topic+get_cell_id'></span>

<h3>Description</h3>

<p>To generate cell id for the multivariate data, the data is being projected from n-dimensions to 1-dimension 
and the cell id is being assigned by ordering these values and finding the corresponding indexes. The output CellID gets
appended to the HVT model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cell_id(hvt.results, seed = 123)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cell_id_+3A_hvt.results">hvt.results</code></td>
<td>
<p>List. A list of hvt.results obtained from the HVT function.</p>
</td></tr>
<tr><td><code id="get_cell_id_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cell ID
</p>


<h3>Value</h3>

<p>Object containing Cell.ID mappings for the given hvt.results list.
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
hvt.results &lt;- list()
hvt.results &lt;- HVT(USArrests, n_cells = 15, depth = 1, quant.err = 0.2, 
                   distance_metric = "L1_Norm", error_metric = "mean",
                   projection.scale = 10, normalize = TRUE, seed = 123,
                   quant_method="kmeans",diagnose=TRUE)
plotHVT(hvt.results, line.width = c(0.8), color.vec = c('#141B41'), 
        maxDepth = 1)
get_cell_id (hvt.results)
</code></pre>

<hr>
<h2 id='getOptimalCentroids'>getOptimalCentroids</h2><span id='topic+getOptimalCentroids'></span>

<h3>Description</h3>

<p>Get Optimal Centroids
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOptimalCentroids(
  x,
  iter.max,
  algorithm,
  n_cells,
  seed = 100,
  function_to_calculate_distance_metric,
  function_to_calculate_error_metric = c("mean", "max"),
  quant.err,
  distance_metric = "L1_Norm",
  quant_method = c("kmeans", "kmedoids"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOptimalCentroids_+3A_x">x</code></td>
<td>
<p>Data Frame. A dataframe of multivariate data. Each row corresponds to an
observation, and each column corresponds to a variable. Missing values are
not accepted.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_algorithm">algorithm</code></td>
<td>
<p>String. The type of algorithm used for quantization.
Available algorithms are Hartigan and Wong, &quot;Lloyd&quot;, &quot;Forgy&quot;, &quot;MacQueen&quot;.
(default is &quot;Hartigan-Wong&quot;)</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_n_cells">n_cells</code></td>
<td>
<p>Numeric. Indicating the number of nodes per hierarchy.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_function_to_calculate_distance_metric">function_to_calculate_distance_metric</code></td>
<td>
<p>Function. The function is to find 'L1_Norm&quot; or &quot;L2_Norm&quot; distances. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_function_to_calculate_error_metric">function_to_calculate_error_metric</code></td>
<td>
<p>Character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. The quantization error for the algorithm.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_distance_metric">distance_metric</code></td>
<td>
<p>Character. The distance metric to calculate inter point distance. It can be 'L1_Norm&quot; or &quot;L2_Norm&quot;. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="getOptimalCentroids_+3A_quant_method">quant_method</code></td>
<td>
<p>Character. The quant_method can be &quot;kmeans&quot; or &quot;kmedoids&quot;. kmeans is selected by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw data is first scaled and this scaled data is supplied as input to
the vector quantization algorithm. Vector quantization technique uses a
parameter called quantization error. This parameter acts as a threshold and
determines the number of levels in the hierarchy. It means that, if there
are 'n' number of levels in the hierarchy, then all the clusters formed till
this level will have quantization error equal or greater than the threshold
quantization error. The user can define the number of clusters in the first
level of hierarchy and then each cluster in first level is sub-divided into
the same number of clusters as there are in the first level. This process
continues and each group is divided into smaller clusters as long as the
threshold quantization error is met. The output of this technique will be
hierarchically arranged vector quantized data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>values</code></td>
<td>
<p> List. A list showing observations assigned to a cluster.</p>
</td></tr>
<tr><td><code>maxQE</code></td>
<td>
<p> List. A list corresponding to maximum QE values for each cell. </p>
</td></tr>
<tr><td><code>meanQE</code></td>
<td>
<p> List. A list corresponding to mean QE values for each cell. </p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p> List. A list of quantization error for all levels and nodes. </p>
</td></tr> 
<tr><td><code>nsize</code></td>
<td>
<p> List. A list corresponding to number of observations in respective groups. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>

<hr>
<h2 id='hvq'>hvq</h2><span id='topic+hvq'></span>

<h3>Description</h3>

<p>Hierarchical Vector Quantization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hvq(
  x,
  min_compression_perc = NA,
  n_cells = NA,
  depth = 3,
  quant.err = 10,
  seed = 300,
  algorithm = "Hartigan-Wong",
  distance_metric = c("L1_Norm", "L2_Norm"),
  error_metric = c("mean", "max"),
  quant_method = c("kmeans", "kmedoids")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hvq_+3A_x">x</code></td>
<td>
<p>Data Frame. A dataframe of multivariate data. Each row corresponds to an
observation, and each column corresponds to a variable. Missing values are
not accepted.</p>
</td></tr>
<tr><td><code id="hvq_+3A_min_compression_perc">min_compression_perc</code></td>
<td>
<p>Numeric. An integer indicating the minimum percent compression rate to
be achieved for the dataset</p>
</td></tr>
<tr><td><code id="hvq_+3A_n_cells">n_cells</code></td>
<td>
<p>Numeric. Indicating the number of nodes per hierarchy.</p>
</td></tr>
<tr><td><code id="hvq_+3A_depth">depth</code></td>
<td>
<p>Numeric. Indicating the hierarchy depth (or) the depth of the
tree (1 = no hierarchy, 2 = 2 levels, etc..)</p>
</td></tr>
<tr><td><code id="hvq_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. The quantization error for the algorithm.</p>
</td></tr>
<tr><td><code id="hvq_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="hvq_+3A_algorithm">algorithm</code></td>
<td>
<p>String. The type of algorithm used for quantization.
Available algorithms are Hartigan and Wong, &quot;Lloyd&quot;, &quot;Forgy&quot;, &quot;MacQueen&quot;.
(default is &quot;Hartigan-Wong&quot;)</p>
</td></tr>
<tr><td><code id="hvq_+3A_distance_metric">distance_metric</code></td>
<td>
<p>character. The distance metric can be 'L1_Norm&quot; or &quot;L2_Norm&quot;. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="hvq_+3A_error_metric">error_metric</code></td>
<td>
<p>character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="hvq_+3A_quant_method">quant_method</code></td>
<td>
<p>character. The quant_method can be &quot;kmeans&quot; or &quot;kmedoids&quot;. kmeans is selected by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw data is first scaled and this scaled data is supplied as input to
the vector quantization algorithm. Vector quantization technique uses a
parameter called quantization error. This parameter acts as a threshold and
determines the number of levels in the hierarchy. It means that, if there
are 'n' number of levels in the hierarchy, then all the clusters formed till
this level will have quantization error equal or greater than the threshold
quantization error. The user can define the number of clusters in the first
level of hierarchy and then each cluster in first level is sub-divided into
the same number of clusters as there are in the first level. This process
continues and each group is divided into smaller clusters as long as the
threshold quantization error is met. The output of this technique will be
hierarchically arranged vector quantized data.
</p>


<h3>Value</h3>

<table>
<tr><td><code>clusters</code></td>
<td>
<p> List. A list showing each ID assigned to a cluster.
</p>
</td></tr> <tr><td><code>nodes.clust</code></td>
<td>
<p> List. A list corresponding to nodes' details. </p>
</td></tr>
<tr><td><code>idnodes</code></td>
<td>
<p> List. A list of ID and segments similar to
<code>nodes.clust</code> with additional columns for nodes ID. </p>
</td></tr>
<tr><td><code>error.quant</code></td>
<td>
<p> List. A list of quantization error for all levels and
nodes. </p>
</td></tr> <tr><td><code>plt.clust</code></td>
<td>
<p> List. A list of logical values indicating if the
quantization error was met. </p>
</td></tr> <tr><td><code>summary</code></td>
<td>
<p> Summary. Output table with
summary. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hvtHmap">hvtHmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("USArrests",package="datasets")
hvqOutput = hvq(USArrests, n_cells = 5, depth = 2, quant.err = 0.2,
distance_metric='L1_Norm',error_metric='mean',quant_method="kmeans")

</code></pre>

<hr>
<h2 id='HVT'>Constructing Hierarchical Voronoi Tessellations</h2><span id='topic+HVT'></span>

<h3>Description</h3>

<p>Main function to construct hierarchical voronoi tessellations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HVT(
  dataset,
  min_compression_perc = NA,
  n_cells = NA,
  depth = 1,
  quant.err = 0.2,
  projection.scale = 10,
  normalize = FALSE,
  seed = 279,
  distance_metric = c("L1_Norm", "L2_Norm"),
  error_metric = c("mean", "max"),
  quant_method = c("kmeans", "kmedoids"),
  scale_summary = NA,
  diagnose = FALSE,
  hvt_validation = FALSE,
  train_validation_split_ratio = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HVT_+3A_dataset">dataset</code></td>
<td>
<p>Data frame. A data frame with different columns is given as
input.</p>
</td></tr>
<tr><td><code id="HVT_+3A_min_compression_perc">min_compression_perc</code></td>
<td>
<p>Numeric. An integer indicating the minimum percent compression rate to
be achieved for the dataset</p>
</td></tr>
<tr><td><code id="HVT_+3A_n_cells">n_cells</code></td>
<td>
<p>Numeric. An integer indicating the number of cells per
hierarchy (level)</p>
</td></tr>
<tr><td><code id="HVT_+3A_depth">depth</code></td>
<td>
<p>Numeric. An integer indicating the number of levels. (1 = No
hierarchy, 2 = 2 levels, etc ...)</p>
</td></tr>
<tr><td><code id="HVT_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. A number indicating the quantization error
treshold.</p>
</td></tr>
<tr><td><code id="HVT_+3A_projection.scale">projection.scale</code></td>
<td>
<p>Numeric. A number indicating the scale factor for
the tesselations so as to visualize the sub-tesselations well enough.</p>
</td></tr>
<tr><td><code id="HVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the columns in your
dataset should be normalized. Default value is TRUE.</p>
</td></tr>
<tr><td><code id="HVT_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="HVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>character. The distance metric can be &quot;L1_Norm&quot; or &quot;Manhattan&quot;. L1_Norm is selected by default.</p>
</td></tr>
<tr><td><code id="HVT_+3A_error_metric">error_metric</code></td>
<td>
<p>character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="HVT_+3A_quant_method">quant_method</code></td>
<td>
<p>character. The quant_method can be &quot;kmeans&quot; or &quot;kmedoids&quot;. kmeans is selected by default</p>
</td></tr>
<tr><td><code id="HVT_+3A_scale_summary">scale_summary</code></td>
<td>
<p>List. A list with mean and standard deviation values for all the features in the dataset. 
Pass the scale summary when the input dataset is already scaled or normalize is set to False.</p>
</td></tr>
<tr><td><code id="HVT_+3A_diagnose">diagnose</code></td>
<td>
<p>Logical. A logical value indicating if the diagnose is required. Default value is TRUE.</p>
</td></tr>
<tr><td><code id="HVT_+3A_hvt_validation">hvt_validation</code></td>
<td>
<p>Logical. A logical value indicating if the MAD values are to tested for validation set. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="HVT_+3A_train_validation_split_ratio">train_validation_split_ratio</code></td>
<td>
<p>Numeric. A numeric value indicating the train and validation split ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function to construct hierarchical voronoi tessellations.
The <code>hvq</code> function is called from this function. The output of the
<code>hvq</code> function is hierarchical clustered data which will be the input
for constructing tessellations. The data is then represented in 2d
coordinates and the tessellations are plotted using these coordinates as
centroids. For subsequent levels, transformation is performed on the 2d
coordinates to get all the points within its parent tile. Tessellations are
plotted using these transformed points as centroids. The lines in the
tessellations are chopped in places so that they do not protrude outside the
parent polygon. This is done for all the subsequent levels.
</p>


<h3>Value</h3>

<p>A list that contains the hierarchical tesselation information. This
list has to be given as input argument to plot the tessellations.
</p>
<table>
<tr><td><code>[[1]]</code></td>
<td>
<p>List. Information about the tesselation co-ordinates - level
wise</p>
</td></tr> <tr><td><code>[[2]]</code></td>
<td>
<p>List. Information about the polygon co-ordinates - level
wise</p>
</td></tr> 
<tr><td><code>[[3]]</code></td>
<td>
<p>List. Information about the hierarchical vector quantized data - level wise</p>
</td></tr>
<tr><td><code>[[4]]</code></td>
<td>
<p>List. Information about the model diagnosis- selected level</p>
</td></tr>
<tr><td><code>[[5]]</code></td>
<td>
<p>List. Information about the MAD values and percentage anomalies for validation dataset</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;, Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code> <br /> <code><a href="#topic+hvtHmap">hvtHmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
hvt.results &lt;- list()
hvt.results &lt;- HVT(USArrests, min_compression_perc = 70, quant.err = 0.2, 
                   distance_metric = "L1_Norm", error_metric = "mean",
                   projection.scale = 10, normalize = TRUE, seed = 279,
                   quant_method="kmeans")
plotHVT(hvt.results, line.width = c(0.8), color.vec = c('#141B41'), 
        maxDepth = 1)

hvt.results &lt;- list()
hvt.results &lt;- HVT(USArrests, n_cells = 15, depth = 3, quant.err = 0.2, 
                   distance_metric = "L1_Norm", error_metric = "mean",
                   projection.scale = 10, normalize = TRUE, seed = 279,
                   quant_method="kmeans")
plotHVT(hvt.results, line.width = c(1.2,0.8,0.4), color.vec = c('#141B41','#0582CA','#8BA0B4'), 
        maxDepth = 3)
</code></pre>

<hr>
<h2 id='hvtHmap'>Heat Map over Hierarchical Voronoi Tessellations</h2><span id='topic+hvtHmap'></span>

<h3>Description</h3>

<p>Main function to construct heatmap overlay for hierarchical voronoi tessellations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hvtHmap(
  hvt.results,
  dataset,
  child.level,
  hmap.cols,
  color.vec = NULL,
  line.width = NULL,
  centroid.size = 3,
  pch = 21,
  palette.color = 6,
  previous_level_heatmap = TRUE,
  show.points = FALSE,
  asp = 1,
  ask = TRUE,
  tess.label = NULL,
  quant.error.hmap = NULL,
  n_cells.hmap = NULL,
  label.size = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hvtHmap_+3A_hvt.results">hvt.results</code></td>
<td>
<p>List. A list of hvt.results obtained from the HVT
function.</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_dataset">dataset</code></td>
<td>
<p>Data frame. The input data set.</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_child.level">child.level</code></td>
<td>
<p>Numeric. Indicating the level for which the heat map is
to be plotted.</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_hmap.cols">hmap.cols</code></td>
<td>
<p>Numeric or Character. The column number of column name from
the dataset indicating the variables for which the heat map is to be
plotted.</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A color vector such that length(color.vec) =
(child.level - 1). (default = NULL)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_line.width">line.width</code></td>
<td>
<p>Vector. A line width vector such that length(line.width) =
(child.level - 1). (default = NULL)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_centroid.size">centroid.size</code></td>
<td>
<p>Numeric. Indicating the centroid size of the first
level. (default = 3)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_pch">pch</code></td>
<td>
<p>Numeric. Indicating the centroid's symbol type.
(default = 21)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_palette.color">palette.color</code></td>
<td>
<p>Numeric. Indicating the heat map color palette. 1 -
rainbow, 2 - heat.colors, 3 - terrain.colors, 4 - topo.colors, 5 -
cm.colors, 6 - seas color. (default = 6)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_previous_level_heatmap">previous_level_heatmap</code></td>
<td>
<p>Logical. If TRUE, the heatmap of previous level
will be overlayed on the heatmap of selected level. If #' FALSE, the heatmap
of only selected level will be plotted</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_show.points">show.points</code></td>
<td>
<p>Logical. Indicating if the centroids should
be plotted on the tessellations. (default = FALSE)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_asp">asp</code></td>
<td>
<p>Numeric. Indicating the aspect ratio type. For flexible aspect
ratio set, asp = NA. (default = 1)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_ask">ask</code></td>
<td>
<p>Logical. If TRUE (and the R session is interactive) the user is
asked for input, before a new figure is drawn. (default = TRUE)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_tess.label">tess.label</code></td>
<td>
<p>Vector. A vector for labelling the tessellations. (default
= NULL)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_quant.error.hmap">quant.error.hmap</code></td>
<td>
<p>Numeric. A number indicating the quantization error
threshold.</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_n_cells.hmap">n_cells.hmap</code></td>
<td>
<p>Numeric. An integer indicating the number of
cells/clusters per hierarchy (level)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_label.size">label.size</code></td>
<td>
<p>Numeric. The size by which the tessellation labels should
be scaled. (default = 0.5)</p>
</td></tr>
<tr><td><code id="hvtHmap_+3A_...">...</code></td>
<td>
<p>The ellipsis is passed to it as additional argument. (Used internally)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of the <code>HVT</code> function has all the required information about
the HVT. Now a heat map is overlayed over this HVT. The user defines the
level and also those variables of the data for which the heat map is to be
plotted. Now for each variable a separate heat map is plotted. The plot area
is divided into 2 screens where the first screen is relatively large and
will have the heat map. The second screen is small and contains the gradient
scale. To plot the heat map, the data is first normalized. The gradient
scale is divided into 'n' regions(500 is the set default). Using the
normalized data, the different regions into which the data items fall are
found. Each data item is now having a region on the gradient scale. This
color is filled in the tile corresponding to the data item. This procedure
is done for all the tiles for that level to get the complete heat map. Once
the heat map is ready, the higher level tessellations are plotted to
represent the hierarchies. The size of the centroids, the thickness of the
lines and the color of the tessellation lines can be given as input by the
user. Appropriate values for these parameters should be given to identify
the hierarchies properly. In the second screen the gradient scale is
plotted. The heat maps and hierarchical tessellations are obtained for all
the desired variables.
</p>


<h3>Value</h3>

<p>Returns the ggplot object containing scatter plot for the selected
depth level containing the centroids of each cell
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
hvt.results &lt;- list()
hvt.results &lt;- HVT(USArrests,
  n_cells = 15, depth = 1, quant.err = 0.2,
  distance_metric = "L1_Norm", error_metric = "mean",
  projection.scale = 10, normalize = TRUE,
  quant_method = "kmeans", diagnose = TRUE
)
hvtHmap(hvt.results, USArrests,
  child.level = 1, hmap.cols = "Murder",
  line.width = c(0.2), color.vec = c("#141B41"), palette.color = 6,
  quant.error.hmap = 0.2, n_cells.hmap = 6
)
</code></pre>

<hr>
<h2 id='madPlot'>Mean Absolute Deviation Plot</h2><span id='topic+madPlot'></span>

<h3>Description</h3>

<p>Function to create Mean Absolute Deviation Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>madPlot(hvt.prediction, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="madPlot_+3A_hvt.prediction">hvt.prediction</code></td>
<td>
<p>List. A list of hvt.prediction obtained from the predictHVT
function.</p>
</td></tr>
<tr><td><code id="madPlot_+3A_...">...</code></td>
<td>
<p>The ellipsis is passed to it as additional argument. (Used internally)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots percentage anomalies vs mean absolute deviation for test data. The plot helps in
deciding an optimal MAD value for the use case.
</p>


<h3>Value</h3>

<p>Mean Absolute Deviation Plot
</p>
<table>
<tr><td><code>mad_plot</code></td>
<td>
<p>ggplot plot. A plot with percentage anomalies on y axis and mean absolute deviation values on xaxis. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictHVT">predictHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
#Split in train and test

train &lt;- USArrests[1:40,]
test &lt;- USArrests[41:50,]

hvt.results &lt;- list()
hvt.results &lt;- HVT(train, n_cells = 15, depth = 1, quant.err = 0.2,
                   distance_metric = "L1_Norm", error_metric = "mean",
                   projection.scale = 10, normalize = TRUE,
                   quant_method="kmeans",diagnose=TRUE)

predictions &lt;- predictHVT(test,hvt.results, child.level=2,mad.threshold = 0.2)
print(predictions$scoredPredictedData)
madPlot(hvt.prediction=predictions)
</code></pre>

<hr>
<h2 id='mlayerHVT'>Predict which cell and what level each point in the test dataset belongs to</h2><span id='topic+mlayerHVT'></span>

<h3>Description</h3>

<p>Predict which cell and what level each point in the test dataset belongs to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlayerHVT(
  data,
  hvt_mapA,
  hvt_mapB,
  hvt_mapC,
  mad.threshold = 0.2,
  normalize = TRUE,
  seed = 300,
  distance_metric = "L1_Norm",
  error_metric = "max",
  child.level = 1,
  line.width = c(0.6, 0.4, 0.2),
  color.vec = c("#141B41", "#6369D1", "#D8D2E1"),
  yVar = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlayerHVT_+3A_data">data</code></td>
<td>
<p>Data Frame. A dataframe containing test dataset. The dataframe should have atleast one variable used while training. The variables from
this dataset can also be used to overlay as heatmap</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_hvt_mapa">hvt_mapA</code></td>
<td>
<p>A list of hvt.results.model obtained from HVT function while performing hierarchical vector quantization on train data</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_hvt_mapb">hvt_mapB</code></td>
<td>
<p>A list of removed outlier rows using removedOutliers function</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_hvt_mapc">hvt_mapC</code></td>
<td>
<p>A list of hvt.results.model obtained from HVT function while performing hierarchical vector quantization on train data without outlier(s)</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_mad.threshold">mad.threshold</code></td>
<td>
<p>A numeric values indicating the permissible Mean Absolute Deviation</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the columns in your
dataset should be normalized. Default value is TRUE.</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>character. The distance metric can be 'Euclidean&quot; or &quot;Manhattan&quot;. Euclidean is selected by default.</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_child.level">child.level</code></td>
<td>
<p>A number indicating the level for which the heat map is to be plotted.(Only used if hmap.cols is not NULL)</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_line.width">line.width</code></td>
<td>
<p>Vector. A line width vector</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A color vector</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_yvar">yVar</code></td>
<td>
<p>character. Name of the dependent variable(s)</p>
</td></tr>
<tr><td><code id="mlayerHVT_+3A_...">...</code></td>
<td>
<p>color.vec and line.width can be passed from here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing Cell.ID predictions for the given test/validation dataset
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;, Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HVT">HVT</a></code> <br /> <code><a href="#topic+hvtHmap">hvtHmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)

# Split in train and test
train &lt;- USArrests[1:40, ]
test &lt;- USArrests[41:50, ]

hvt_mapA &lt;- list()
hvt_mapA &lt;- HVT(train,
  min_compression_perc = 70, quant.err = 0.2,
  distance_metric = "L1_Norm", error_metric = "mean",
  projection.scale = 10, normalize = TRUE,
  quant_method = "kmeans"
)


identified_outlier_cells &lt;- c(2, 10)
output_list &lt;- removeOutliers(identified_outlier_cells, hvt_mapA)
hvt_mapB &lt;- output_list[[1]]
dataset_without_outliers &lt;- output_list[[2]]


mapA_scale_summary &lt;- hvt_mapA[[3]]$scale_summary
hvt_mapC &lt;- list()
hvt_mapC &lt;- HVT(dataset_without_outliers,
  n_cells = 15,
  depth = 2, quant.err = 0.2, distance_metric = "L1_Norm",
  error_metric = "max", quant_method = "kmeans",
  projection.scale = 10, normalize = FALSE, scale_summary = mapA_scale_summary
)

predictions &lt;- list()
predictions &lt;- mlayerHVT(test, hvt_mapA, hvt_mapB, hvt_mapC)

</code></pre>

<hr>
<h2 id='multiNormalDist'>Multivariate normal distribution</h2><span id='topic+multiNormalDist'></span>

<h3>Description</h3>

<p>Function to generate multivariate normal distribution where each variable has a standard normal distribution N(0,1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiNormalDist(sample.size = 2500, ncol = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiNormalDist_+3A_sample.size">sample.size</code></td>
<td>
<p>Numeric. Indicating the sample size for distribution</p>
</td></tr>
<tr><td><code id="multiNormalDist_+3A_ncol">ncol</code></td>
<td>
<p>Numeric. Indicating the number of columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate normal distribution, multivariate Gaussian distribution, or
joint normal distribution is a generalization of the one-dimensional (univariate)
normal distribution to higher dimensions. It is a vector in multiple normally distributed variables,
such that any linear combination of the variables is also normally distributed.
</p>


<h3>Value</h3>

<p>Datafrakme containing multinomial distribution with the given sample size and number of columns
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>multiNormalDist(2500, 2)
x &lt;- multiNormalDist(2500, 2)
hist(x[, 1])
</code></pre>

<hr>
<h2 id='plotCells'>Plot the identified outlier cell(s) in the voronoi tessellations map.
Plotting function to construct hierarchical voronoi tessellations and highlight the cells using the
compressed HVT map.</h2><span id='topic+plotCells'></span>

<h3>Description</h3>

<p>Plot the identified outlier cell(s) in the voronoi tessellations map.
</p>
<p>Plotting function to construct hierarchical voronoi tessellations and highlight the cells using the
compressed HVT map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCells(
  plot.cells,
  hvt.map,
  line.width = c(0.6),
  color.vec = c("#141B41"),
  pch1 = 21,
  centroid.size = 0.5,
  title = NULL,
  maxDepth = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCells_+3A_plot.cells">plot.cells</code></td>
<td>
<p>Vector. A vector indicating the cells to be highlighted in the map</p>
</td></tr>
<tr><td><code id="plotCells_+3A_hvt.map">hvt.map</code></td>
<td>
<p>List. A list containing the output of <code>HVT</code> function
which has the details of the tessellations to be plotted.</p>
</td></tr>
<tr><td><code id="plotCells_+3A_line.width">line.width</code></td>
<td>
<p>Numeric Vector. A vector indicating the line widths of the
tessellation boundaries for each level.</p>
</td></tr>
<tr><td><code id="plotCells_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A vector indicating the colors of the boundaries of
the tessellations at each level.</p>
</td></tr>
<tr><td><code id="plotCells_+3A_pch1">pch1</code></td>
<td>
<p>Numeric. Symbol type of the centroids of the tessellations
(parent levels). Refer <code><a href="graphics.html#topic+points">points</a></code>. (default = 21)</p>
</td></tr>
<tr><td><code id="plotCells_+3A_centroid.size">centroid.size</code></td>
<td>
<p>Numeric. Size of centroids of first level
tessellations. (default = 3)</p>
</td></tr>
<tr><td><code id="plotCells_+3A_title">title</code></td>
<td>
<p>String. Set a title for the plot. (default = NULL)</p>
</td></tr>
<tr><td><code id="plotCells_+3A_maxdepth">maxDepth</code></td>
<td>
<p>Numeric. An integer indicating the number of levels. (default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object containing hierarchical voronoi tessellations plot
highlighting the outlier cells in the map
</p>


<h3>Author(s)</h3>

<p>Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HVT">HVT</a></code> <br /> <code><a href="#topic+hvtHmap">hvtHmap</a></code>
</p>

<hr>
<h2 id='plotDiag'>Make the diagnostic plots for hierarchical voronoi tessellations model.</h2><span id='topic+plotDiag'></span>

<h3>Description</h3>

<p>Make the diagnostic plots for hierarchical voronoi tessellations model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiag(model_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiag_+3A_model_obj">model_obj</code></td>
<td>
<p>List. A list of model_obj obtained from the HVT
function or prediction object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plot object containing Diagnostics plots for the HVT model or HVT predictions.
for HVT model, Minimum Intra-DataPoint Distance Plot, Minimum Intra-Centroid Distance Plot
Mean Absolute Deviation Plot,Distribution of Number of Observations in Cells, for Training Data and
Mean Absolute Deviation Plot for Validation Data are plotted.
for HVT Predictions, &quot;Mean Absolute Deviation Plot for Training Data and Validation Data are plotted
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>

<hr>
<h2 id='plotHVT'>Plot the hierarchical tesselations.
Main plotting function to construct hierarchical voronoi tessellations.</h2><span id='topic+plotHVT'></span>

<h3>Description</h3>

<p>Plot the hierarchical tesselations.
</p>
<p>Main plotting function to construct hierarchical voronoi tessellations.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotHVT_+3A_hvt.results">hvt.results</code></td>
<td>
<p>List. A list containing the ouput of <code>HVT</code> function
which has the details of the tessellations to be plotted.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_line.width">line.width</code></td>
<td>
<p>Numeric Vector. A vector indicating the line widths of the
tessellation boundaries for each level.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A vector indicating the colors of the boundaries of
the tessellations at each level.</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_pch1">pch1</code></td>
<td>
<p>Numeric. Symbol type of the centroids of the tessellations
(parent levels). Refer <code><a href="graphics.html#topic+points">points</a></code>. (default = 21)</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_centroid.size">centroid.size</code></td>
<td>
<p>Numeric. Size of centroids of first level
tessellations. (default = 3)</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_title">title</code></td>
<td>
<p>String. Set a title for the plot. (default = NULL)</p>
</td></tr>
<tr><td><code id="plotHVT_+3A_maxdepth">maxDepth</code></td>
<td>
<p>Numeric. An integer indicating the number of levels. (default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object containing the main HVT plot for the given HVT results
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HVT">HVT</a></code> <br /> <code><a href="#topic+hvtHmap">hvtHmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("USArrests", package = "datasets")

hvt.results &lt;- list()
hvt.results &lt;- HVT(USArrests,
  n_cells = 15, depth = 1, quant.err = 0.2,
  distance_metric = "L1_Norm", error_metric = "mean",
  projection.scale = 10, normalize = TRUE,
  quant_method = "kmeans", diagnose = TRUE
)
plotHVT(hvt.results,
  line.width = c(0.8), color.vec = c("#141B41"),
  maxDepth = 1
)

</code></pre>

<hr>
<h2 id='predictHVT'>Predict which cell and what level each point in the test dataset belongs to</h2><span id='topic+predictHVT'></span>

<h3>Description</h3>

<p>Predict which cell and what level each point in the test dataset belongs to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictHVT(
  data,
  hvt.results.model,
  child.level = 1,
  mad.threshold = 0.2,
  line.width = c(0.6, 0.4, 0.2),
  color.vec = c("#141B41", "#6369D1", "#D8D2E1"),
  normalize = TRUE,
  seed = 300,
  distance_metric = "L1_Norm",
  error_metric = "max",
  yVar = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictHVT_+3A_data">data</code></td>
<td>
<p>List. A dataframe containing test dataset. The dataframe should have atleast one variable used while training. The variables from
this dataset can also be used to overlay as heatmap</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_hvt.results.model">hvt.results.model</code></td>
<td>
<p>A list of hvt.results.model obtained from HVT function while performing hierarchical vector quantization on train data</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_child.level">child.level</code></td>
<td>
<p>A number indicating the level for which the heat map is to be plotted.(Only used if hmap.cols is not NULL)</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_mad.threshold">mad.threshold</code></td>
<td>
<p>A numeric values indicating the permissible Mean Absolute Deviation</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_line.width">line.width</code></td>
<td>
<p>Vector. A line width vector</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A color vector</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the columns in your
dataset should be normalized. Default value is TRUE.</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>character. The distance metric can be 'Euclidean&quot; or &quot;Manhattan&quot;. Euclidean is selected by default.</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_yvar">yVar</code></td>
<td>
<p>character. Name of the dependent variable(s)</p>
</td></tr>
<tr><td><code id="predictHVT_+3A_...">...</code></td>
<td>
<p>color.vec and line.width can be passed from here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing scored predicted data, prediction plots and mean absolute deviation plots
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HVT">HVT</a></code> <br /> <code><a href="#topic+hvtHmap">hvtHmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
# Split in train and test

train &lt;- USArrests[1:40, ]
test &lt;- USArrests[41:50, ]

hvt.results &lt;- list()
hvt.results &lt;- HVT(train,
  n_cells = 15, depth = 1, quant.err = 0.2,
  distance_metric = "L1_Norm", error_metric = "mean",
  projection.scale = 10, normalize = TRUE,
  quant_method = "kmeans", diagnose = TRUE
)

predictions &lt;- predictHVT(test, hvt.results, child.level = 2, mad.threshold = 0.2)
print(predictions$scoredPredictedData)
</code></pre>

<hr>
<h2 id='predictLayerHVT'>Predict which cell and what level each point in the test dataset belongs to</h2><span id='topic+predictLayerHVT'></span>

<h3>Description</h3>

<p>Predict which cell and what level each point in the test dataset belongs to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictLayerHVT(
  data,
  hvt_mapA,
  hvt_mapB,
  hvt_mapC,
  mad.threshold = 0.2,
  normalize = TRUE,
  seed = 300,
  distance_metric = "L1_Norm",
  error_metric = "max",
  child.level = 1,
  line.width = c(0.6, 0.4, 0.2),
  color.vec = c("#141B41", "#6369D1", "#D8D2E1"),
  yVar = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictLayerHVT_+3A_data">data</code></td>
<td>
<p>Data Frame. A dataframe containing test dataset. The dataframe should have atleast one variable used while training. The variables from
this dataset can also be used to overlay as heatmap</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_hvt_mapa">hvt_mapA</code></td>
<td>
<p>A list of hvt.results.model obtained from HVT function while performing hierarchical vector quantization on train data</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_hvt_mapb">hvt_mapB</code></td>
<td>
<p>A list of hvt.results.model obtained from HVT function while performing hierarchical vector quantization on train data with novelty(s)</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_hvt_mapc">hvt_mapC</code></td>
<td>
<p>A list of hvt.results.model obtained from HVT function while performing hierarchical vector quantization on train data without novelty(s)</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_mad.threshold">mad.threshold</code></td>
<td>
<p>A numeric values indicating the permissible Mean Absolute Deviation</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_normalize">normalize</code></td>
<td>
<p>Logical. A logical value indicating if the columns in your
dataset should be normalized. Default value is TRUE.</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_seed">seed</code></td>
<td>
<p>Numeric. Random Seed.</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_distance_metric">distance_metric</code></td>
<td>
<p>character. The distance metric can be 'Euclidean&quot; or &quot;Manhattan&quot;. Euclidean is selected by default.</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_error_metric">error_metric</code></td>
<td>
<p>character. The error metric can be &quot;mean&quot; or &quot;max&quot;. mean is selected by default</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_child.level">child.level</code></td>
<td>
<p>A number indicating the level for which the heat map is to be plotted.(Only used if hmap.cols is not NULL)</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_line.width">line.width</code></td>
<td>
<p>Vector. A line width vector</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_color.vec">color.vec</code></td>
<td>
<p>Vector. A color vector</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_yvar">yVar</code></td>
<td>
<p>character. Name of the dependent variable(s)</p>
</td></tr>
<tr><td><code id="predictLayerHVT_+3A_...">...</code></td>
<td>
<p>color.vec and line.width can be passed from here</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing scored predicted layer output
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;, Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;, Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;,Somya Shambhawi &lt;somya.shambhawi@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HVT">HVT</a></code> <br /> <code><a href="#topic+hvtHmap">hvtHmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
library("dplyr")

# Split in train and test
train &lt;- USArrests[1:40, ]
test &lt;- USArrests[41:50, ]

hvt_mapA &lt;- list()
hvt_mapA &lt;- HVT(train,
  min_compression_perc = 70, quant.err = 0.2,
  distance_metric = "L1_Norm", error_metric = "mean",
  projection.scale = 10, normalize = TRUE,
  quant_method = "kmeans"
)


identified_Novelty_cells &lt;&lt;- c(2, 10)
output_list &lt;- removeNovelty(identified_Novelty_cells, hvt_mapA)

data_with_novelty &lt;- output_list[[1]] %&gt;% dplyr::select(!c("Cell.ID", "Cell.Number"))


hvt_mapB &lt;- HVT(data_with_novelty,
  n_cells = 3, quant.err = 0.2,
  distance_metric = "L1_Norm", error_metric = "mean",
  projection.scale = 10, normalize = TRUE,
  quant_method = "kmeans"
)

dataset_without_novelty &lt;- output_list[[2]]


mapA_scale_summary &lt;- hvt_mapA[[3]]$scale_summary
hvt_mapC &lt;- list()
hvt_mapC &lt;- HVT(dataset_without_novelty,
  n_cells = 15,
  depth = 2, quant.err = 0.2, distance_metric = "L1_Norm",
  error_metric = "max", quant_method = "kmeans",
  projection.scale = 10, normalize = FALSE, scale_summary = mapA_scale_summary
)

predictions &lt;- list()
predictions &lt;- predictLayerHVT(test, hvt_mapA, hvt_mapB, hvt_mapC)

</code></pre>

<hr>
<h2 id='qeHistPlot'>plotDiag
Make the diagnostic plots for hierarchical voronoi tessellations model.</h2><span id='topic+qeHistPlot'></span>

<h3>Description</h3>

<p>plotDiag
</p>
<p>Make the diagnostic plots for hierarchical voronoi tessellations model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qeHistPlot(hvt.results, hvt.predictions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qeHistPlot_+3A_hvt.results">hvt.results</code></td>
<td>
<p>List. A list of hvt.results obtained from the HVT
function.</p>
</td></tr>
<tr><td><code id="qeHistPlot_+3A_hvt.predictions">hvt.predictions</code></td>
<td>
<p>List. A list of hvt.predictions obtained from the Predict
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the ggplot object containing the Quantized Error distribution plots for the given HVT results and predictions
</p>


<h3>Author(s)</h3>

<p>Shubhra Prakash &lt;shubhra.prakash@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotHVT">plotHVT</a></code>
</p>

<hr>
<h2 id='removeNovelty'>removeNovelty</h2><span id='topic+removeNovelty'></span>

<h3>Description</h3>

<p>Remove identified outlier cell(s) from the dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeNovelty(outlier_cells, hvt_results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeNovelty_+3A_outlier_cells">outlier_cells</code></td>
<td>
<p>Vector. A vector with the cell number of the identified outliers</p>
</td></tr>
<tr><td><code id="removeNovelty_+3A_hvt_results">hvt_results</code></td>
<td>
<p>List. A list having the results of the compressed map i.e. output of <code>HVT</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to remove the identified outlier cell(s) from the dataset.
It is recommended to run the <code>HVT</code> function before running this function. It takes input in the form 
of cell number of the outlier cell(s) identified using the output of the <code>HVT</code> function and
the compressed map (hvt_mapA) generated using the <code>HVT</code> function. The output of this function is
a list of two items: a new map having the data of removed outlier cell(s) and the subset of dataset without outliers.
</p>


<h3>Value</h3>

<p>A list of two items: a map having the data of removed outlier cells and the subset of  the dataset without outlier(s) which
has to be passed as input argument to <code>HVT</code> function to generate another map
</p>
<table>
<tr><td><code>[[1]]</code></td>
<td>
<p>Dataframe. Information about the removed outlier cell(s)</p>
</td></tr>
<tr><td><code>[[2]]</code></td>
<td>
<p>Dataframe. Subset of dataset without the outlier cell(s)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HVT">HVT</a></code> <br /> <code><a href="#topic+predictLayerHVT">predictLayerHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
hvt_mapA &lt;- list()
hvt_mapA &lt;- HVT(USArrests, min_compression_perc = 70, quant.err = 0.2, 
                   distance_metric = "L1_Norm", error_metric = "mean",
                   projection.scale = 10, normalize = TRUE,
                   quant_method="kmeans")
plotHVT(hvt_mapA, line.width = c(0.8), color.vec = c('#141B41'), 
        maxDepth = 1)
        
identified_Novelty_cells &lt;&lt;- c(2, 10)
output_list &lt;- removeNovelty(identified_Novelty_cells, hvt_mapA)
hvt_mapB &lt;- output_list[[1]]
dataset_without_novelty &lt;- output_list[[2]]

</code></pre>

<hr>
<h2 id='removeOutliers'>removeOutliers</h2><span id='topic+removeOutliers'></span>

<h3>Description</h3>

<p>Remove identified outlier cell(s) from the dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeOutliers(outlier_cells, hvt_results)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeOutliers_+3A_outlier_cells">outlier_cells</code></td>
<td>
<p>Vector. A vector with the cell number of the identified outliers</p>
</td></tr>
<tr><td><code id="removeOutliers_+3A_hvt_results">hvt_results</code></td>
<td>
<p>List. A list having the results of the compressed map i.e. output of <code>HVT</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to remove the identified outlier cell(s) from the dataset.
It is recommended to run the <code>HVT</code> function before running this function. It takes input in the form 
of cell number of the outlier cell(s) identified using the output of the <code>HVT</code> function and
the compressed map (hvt_mapA) generated using the <code>HVT</code> function. The output of this function is
a list of two items: a new map having the data of removed outlier cell(s) and the subset of dataset without outliers.
</p>


<h3>Value</h3>

<p>A list of two items: a map having the data of removed outlier cells and the subset of  the dataset without outlier(s) which
has to be passed as input argument to <code>HVT</code> function to generate another map
</p>
<table>
<tr><td><code>[[1]]</code></td>
<td>
<p>Dataframe. Information about the removed outlier cell(s)</p>
</td></tr>
<tr><td><code>[[2]]</code></td>
<td>
<p>Dataframe. Subset of dataset without the outlier cell(s)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Shantanu Vaidya &lt;shantanu.vaidya@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HVT">HVT</a></code> <br /> <code><a href="#topic+mlayerHVT">mlayerHVT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USArrests)
hvt_mapA &lt;- list()
hvt_mapA &lt;- HVT(USArrests, min_compression_perc = 70, quant.err = 0.2, 
                   distance_metric = "L1_Norm", error_metric = "mean",
                   projection.scale = 10, normalize = TRUE,
                   quant_method="kmeans")
plotHVT(hvt_mapA, line.width = c(0.8), color.vec = c('#141B41'), 
        maxDepth = 1)
        
identified_outlier_cells &lt;- c(2, 10)
output_list &lt;- removeOutliers(identified_outlier_cells, hvt_mapA)
hvt_mapB &lt;- output_list[[1]]
dataset_without_outliers &lt;- output_list[[2]]

</code></pre>

<hr>
<h2 id='sammonsProjection'>sammonsProjection</h2><span id='topic+sammonsProjection'></span>

<h3>Description</h3>

<p>This is a wrapper for the sammon function of the MASS package for non-metric
multidimensional scaling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sammonsProjection(
  d,
  y = stats::cmdscale(d, k),
  k = 2,
  niter = 100,
  trace = TRUE,
  magic = 0.2,
  tol = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sammonsProjection_+3A_d">d</code></td>
<td>
<p>distance structure of the form returned by dist, or a full,
symmetric matrix. Data are assumed to be dissimilarities or relative
distances, but must be positive except for self-distance. This can contain
missing values.</p>
</td></tr>
<tr><td><code id="sammonsProjection_+3A_y">y</code></td>
<td>
<p>An initial configuration. If none is supplied, cmdscale is used to
provide the classical solution. (If there are missing values in d, an
initial configuration must be provided.) This must not have duplicates.</p>
</td></tr>
<tr><td><code id="sammonsProjection_+3A_k">k</code></td>
<td>
<p>The dimension of the configuration.</p>
</td></tr>
<tr><td><code id="sammonsProjection_+3A_niter">niter</code></td>
<td>
<p>The maximum number of iterations.</p>
</td></tr>
<tr><td><code id="sammonsProjection_+3A_trace">trace</code></td>
<td>
<p>Logical for tracing optimization. Default TRUE.</p>
</td></tr>
<tr><td><code id="sammonsProjection_+3A_magic">magic</code></td>
<td>
<p>initial value of the step size constant in diagonal Newton
method.</p>
</td></tr>
<tr><td><code id="sammonsProjection_+3A_tol">tol</code></td>
<td>
<p>Tolerance for stopping, in units of stress.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This chooses a two-dimensional configuration to minimize the stress, the sum
of squared differences between the input distances and those of the
configuration, weighted by the distances, the whole sum being divided by the
sum of input distances to make the stress scale-free.
</p>
<p>An iterative algorithm is used, which will usually converge in around 50
iterations. As this is necessarily an O(n^2) calculation, it is slow for
large datasets. Further, since the configuration is only determined up to
rotations and reflections (by convention the centroid is at the origin), the
result can vary considerably from machine to machine. In this release the
algorithm has been modified by adding a step-length search (magic) to ensure
that it always goes downhill.
</p>


<h3>Value</h3>

<table>
<tr><td><code>points</code></td>
<td>
<p> A two-column vector of the fitted configuration. </p>
</td></tr>
<tr><td><code>stress</code></td>
<td>
<p> The final stress achieved. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
require(MASS)
swiss.x &lt;- as.matrix(swiss[, -1])
swiss.sam &lt;- sammonsProjection(dist(swiss.x))

</code></pre>

<hr>
<h2 id='VQ_codebookSplit'>VQ_codebookSplit</h2><span id='topic+VQ_codebookSplit'></span>

<h3>Description</h3>

<p>Vector Quantization by codebook split method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VQ_codebookSplit(dataset, quant.err = 0.5, epsilon = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VQ_codebookSplit_+3A_dataset">dataset</code></td>
<td>
<p>Matrix. A matrix of multivariate data. Each row corresponds
to an observation, and each column corresponds to a variable. Missing values
are not accepted.</p>
</td></tr>
<tr><td><code id="VQ_codebookSplit_+3A_quant.err">quant.err</code></td>
<td>
<p>Numeric. The quantization error for the algorithm.</p>
</td></tr>
<tr><td><code id="VQ_codebookSplit_+3A_epsilon">epsilon</code></td>
<td>
<p>Numeric. The value to offset the codebooks during the
codebook split. Default is NULL, in which case the value is set to quant.err
parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs Vector Quantization by codebook split method. Initially, the entire
dataset is considered to be one cluster where the codebook is the mean of
the cluster. The quantization criteria is checked and the codebook is split
such that the new codebooks are (codebook+epsilon) and (codebook-epsilon).
The observations are reassigned to these new codebooks based on the nearest
neighbour condition and the means recomputed for the new clusters. This is
done iteratively until all the clusters meet the quantization criteria.
</p>


<h3>Value</h3>

<table>
<tr><td><code>clusters</code></td>
<td>
<p> List. A list showing each ID assigned to a cluster.
</p>
</td></tr> <tr><td><code>nodes.clust</code></td>
<td>
<p> List. A list corresponding to nodes' details. </p>
</td></tr>
<tr><td><code>idnodes</code></td>
<td>
<p> List. A list of ID and segments similar to
<code>nodes.clust</code> with additional columns for nodes ID. </p>
</td></tr>
<tr><td><code>error.quant</code></td>
<td>
<p> List. A list of quantization error for all levels and
nodes. </p>
</td></tr> <tr><td><code>plt.clust</code></td>
<td>
<p> List. A list of logical values indicating if the
quantization error was met. </p>
</td></tr> <tr><td><code>summary</code></td>
<td>
<p> Summary. Output table with
summary. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sangeet Moy Das &lt;sangeet.das@mu-sigma.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hvtHmap">hvtHmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data("iris", package = "datasets")
iris &lt;- iris[, 1:2]

vqOutput &lt;- VQ_codebookSplit(iris, quant.err = 0.5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
