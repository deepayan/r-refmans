<!DOCTYPE html><html><head><title>Help for package jsonlite</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jsonlite}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#base64'><p>Encode/decode base64</p></a></li>
<li><a href='#flatten'><p>Flatten nested data frames</p></a></li>
<li><a href='#gzjson'><p>Gzipped JSON</p></a></li>
<li><a href='#prettify+2C+20minify'><p>Prettify or minify a JSON string</p></a></li>
<li><a href='#rbind_pages'><p>Combine pages into a single data frame</p></a></li>
<li><a href='#read_json'><p>Read/write JSON</p></a></li>
<li><a href='#serializeJSON'><p>serialize R objects to JSON</p></a></li>
<li><a href='#stream_in+2C+20stream_out'><p>Streaming JSON input/output</p></a></li>
<li><a href='#toJSON+2C+20fromJSON'><p>Convert <span class="rlang"><b>R</b></span> objects to/from JSON</p></a></li>
<li><a href='#unbox'><p>Unbox a vector or data frame</p></a></li>
<li><a href='#validate'><p>Validate JSON</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.8.8</td>
</tr>
<tr>
<td>Title:</td>
<td>A Simple and Robust JSON Parser and Generator for R</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jeroen.r-universe.dev/jsonlite">https://jeroen.r-universe.dev/jsonlite</a>
<a href="https://arxiv.org/abs/1403.2805">https://arxiv.org/abs/1403.2805</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jeroen/jsonlite/issues">https://github.com/jeroen/jsonlite/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeroen Ooms &lt;jeroen@berkeley.edu&gt;</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>A reasonably fast JSON parser and generator, optimized for statistical 
    data and the web. Offers simple, flexible tools for working with JSON in R, and
    is particularly powerful for building pipelines and interacting with a web API. 
    The implementation is based on the mapping described in the vignette (Ooms, 2014).
    In addition to converting JSON data from/to R objects, 'jsonlite' contains 
    functions to stream, validate, and prettify JSON data. The unit tests included 
    with the package verify that all edge cases are encoded and decoded consistently 
    for use with dynamic data in systems and applications.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>httr, vctrs, testthat, knitr, rmarkdown, R.rsp, sf</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-04 12:57:12 UTC; jeroen</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeroen Ooms <a href="https://orcid.org/0000-0002-4035-0289"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Duncan Temple Lang [ctb],
  Lloyd Hilaiel [cph] (author of bundled libyajl)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='base64'>Encode/decode base64</h2><span id='topic+base64'></span><span id='topic+base64_dec'></span><span id='topic+base64_enc'></span><span id='topic+base64url_enc'></span><span id='topic+base64url_dec'></span>

<h3>Description</h3>

<p>Simple in-memory base64 encoder and decoder. Used internally for converting
raw vectors to text. Interchangeable with encoder from <code>base64enc</code> or
<code>openssl</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64_dec(input)

base64_enc(input)

base64url_enc(input)

base64url_dec(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64_+3A_input">input</code></td>
<td>
<p>string or raw vector to be encoded/decoded</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+base64url_enc">base64url_enc</a> and <a href="#topic+base64url_dec">base64url_dec</a> functions use a variation of base64
that substitute characters <code style="white-space: pre;">&#8288;+/&#8288;</code>  for <code style="white-space: pre;">&#8288;-_&#8288;</code> respectively, such that the output
does not require URL-encoding. See also section 5 of rfc4648.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str &lt;- base64_enc(serialize(iris, NULL))
out &lt;- unserialize(base64_dec(str))
stopifnot(identical(out, iris))
</code></pre>

<hr>
<h2 id='flatten'>Flatten nested data frames</h2><span id='topic+flatten'></span>

<h3>Description</h3>

<p>In a nested data frame, one or more of the columns consist of another data
frame. These structures frequently appear when parsing JSON data from the web.
We can flatten such data frames into a regular 2 dimensional tabular structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten(x, recursive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="flatten_+3A_recursive">recursive</code></td>
<td>
<p>flatten recursively</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>options(stringsAsFactors=FALSE)
x &lt;- data.frame(driver = c("Bowser", "Peach"), occupation = c("Koopa", "Princess"))
x$vehicle &lt;- data.frame(model = c("Piranha Prowler", "Royal Racer"))
x$vehicle$stats &lt;- data.frame(speed = c(55, 34), weight = c(67, 24), drift = c(35, 32))
str(x)
str(flatten(x))
str(flatten(x, recursive = FALSE))

## Not run: 
data1 &lt;- fromJSON("https://api.github.com/users/hadley/repos")
colnames(data1)
colnames(data1$owner)
colnames(flatten(data1))

# or for short:
data2 &lt;- fromJSON("https://api.github.com/users/hadley/repos", flatten = TRUE)
colnames(data2)

## End(Not run)

</code></pre>

<hr>
<h2 id='gzjson'>Gzipped JSON</h2><span id='topic+gzjson'></span><span id='topic+as_gzjson_raw'></span><span id='topic+as_gzjson_b64'></span><span id='topic+parse_gzjson_raw'></span><span id='topic+parse_gzjson_b64'></span>

<h3>Description</h3>

<p>Wrapper to generate and parse gzipped JSON, in order to save some disk or
network space. This is mainly effective for larger json objects with many
repeated keys, as is common in serialized data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_gzjson_raw(x, ...)

as_gzjson_b64(x, ...)

parse_gzjson_raw(buf, ...)

parse_gzjson_b64(b64, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gzjson_+3A_x">x</code></td>
<td>
<p>R data object to be converted to JSON</p>
</td></tr>
<tr><td><code id="gzjson_+3A_...">...</code></td>
<td>
<p>passed down to <a href="#topic+toJSON">toJSON</a> or <a href="#topic+fromJSON">fromJSON</a></p>
</td></tr>
<tr><td><code id="gzjson_+3A_buf">buf</code></td>
<td>
<p>raw vector with gzip compressed data</p>
</td></tr>
<tr><td><code id="gzjson_+3A_b64">b64</code></td>
<td>
<p>base64 encoded string containing gzipped json data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <a href="#topic+as_gzjson_raw">as_gzjson_raw</a> and <a href="#topic+parse_gzjson_raw">parse_gzjson_raw</a> functions work with raw (binary)
vectors of compressed data. To use this in a place where only text is allowed
you can wrap the output again in <a href="#topic+base64">base64</a> as done by <a href="#topic+as_gzjson_b64">as_gzjson_b64</a> and
<a href="#topic+parse_gzjson_b64">parse_gzjson_b64</a>. This increases the size again with about 33%.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str &lt;- as_gzjson_b64(iris[1:5,])
cat(str)
parse_gzjson_b64(str)
</code></pre>

<hr>
<h2 id='prettify+2C+20minify'>Prettify or minify a JSON string</h2><span id='topic+prettify+2C+20minify'></span><span id='topic+prettify'></span><span id='topic+minify'></span>

<h3>Description</h3>

<p>Prettify adds indentation to a JSON string; minify removes all indentation/whitespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettify(txt, indent = 4)

minify(txt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prettify+2B2C+2B20minify_+3A_txt">txt</code></td>
<td>
<p>JSON string</p>
</td></tr>
<tr><td><code id="prettify+2B2C+2B20minify_+3A_indent">indent</code></td>
<td>
<p>number of spaces to indent</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>myjson &lt;- toJSON(cars)
cat(myjson)
prettify(myjson)
minify(myjson)
</code></pre>

<hr>
<h2 id='rbind_pages'>Combine pages into a single data frame</h2><span id='topic+rbind_pages'></span>

<h3>Description</h3>

<p>The <code>rbind_pages</code> function is used to combine a list of data frames into a single
data frame. This is often needed when working with a JSON API that limits the amount
of data per request. If we need more data than what fits in a single request, we need to
perform multiple requests that each retrieve a fragment of data, not unlike pages in a
book. In practice this is often implemented using a <code>page</code> parameter in the API. The
<code>rbind_pages</code> function can be used to combine these pages back into a single dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_pages(pages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_pages_+3A_pages">pages</code></td>
<td>
<p>a list of data frames, each representing a <em>page</em> of data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>rbind_pages</code> function uses <code><a href="vctrs.html#topic+vec_bind">vctrs::vec_rbind()</a></code>
to bind the pages together. This generalizes <code><a href="base.html#topic+cbind">base::rbind()</a></code> in two
ways:
</p>

<ul>
<li><p> Not each column has to be present in each of the individual data frames; missing
columns will be filled up in <code>NA</code> values.
</p>
</li>
<li><p> Data frames can be nested (can contain other data frames).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Basic example
x &lt;- data.frame(foo = rnorm(3), bar = c(TRUE, FALSE, TRUE))
y &lt;- data.frame(foo = rnorm(2), col = c("blue", "red"))
rbind_pages(list(x, y))


baseurl &lt;- "https://projects.propublica.org/nonprofits/api/v2/search.json"
pages &lt;- list()
for(i in 0:20){
  mydata &lt;- fromJSON(paste0(baseurl, "?order=revenue&amp;sort_order=desc&amp;page=", i))
  message("Retrieving page ", i)
  pages[[i+1]] &lt;- mydata$organizations
}
organizations &lt;- rbind_pages(pages)
nrow(organizations)
colnames(organizations)

</code></pre>

<hr>
<h2 id='read_json'>Read/write JSON</h2><span id='topic+read_json'></span><span id='topic+parse_json'></span><span id='topic+write_json'></span>

<h3>Description</h3>

<p>These functions are similar to <code><a href="#topic+toJSON">toJSON()</a></code> and <code><a href="#topic+fromJSON">fromJSON()</a></code> except they
explicitly distinguish between path and literal input, and do not simplify
by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_json(path, simplifyVector = FALSE, ...)

parse_json(json, simplifyVector = FALSE, ...)

write_json(x, path, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_json_+3A_path">path</code></td>
<td>
<p>file on disk</p>
</td></tr>
<tr><td><code id="read_json_+3A_simplifyvector">simplifyVector</code></td>
<td>
<p>simplifies nested lists into vectors and data frames. See <code><a href="#topic+fromJSON">fromJSON()</a></code>.</p>
</td></tr>
<tr><td><code id="read_json_+3A_...">...</code></td>
<td>
<p>additional conversion arguments, see also <code><a href="#topic+toJSON">toJSON()</a></code> or <code><a href="#topic+fromJSON">fromJSON()</a></code></p>
</td></tr>
<tr><td><code id="read_json_+3A_json">json</code></td>
<td>
<p>string with literal json or connection object to read from</p>
</td></tr>
<tr><td><code id="read_json_+3A_x">x</code></td>
<td>
<p>an object to be serialized to JSON</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fromJSON">fromJSON()</a></code>, <code><a href="#topic+stream_in">stream_in()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- tempfile()
write_json(iris, tmp)

# Nested lists
read_json(tmp)

# A data frame
read_json(tmp, simplifyVector = TRUE)
</code></pre>

<hr>
<h2 id='serializeJSON'>serialize R objects to JSON</h2><span id='topic+serializeJSON'></span><span id='topic+unserializeJSON'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+serializeJSON">serializeJSON()</a></code> and <code><a href="#topic+unserializeJSON">unserializeJSON()</a></code> functions convert between
<span class="rlang"><b>R</b></span> objects to JSON data. Instead of using a class based mapping like
<code><a href="#topic+toJSON">toJSON()</a></code> and <code><a href="#topic+fromJSON">fromJSON()</a></code>, the serialize functions base the encoding
schema on the storage type, and capture all data and attributes from any object.
Thereby the object can be restored almost perfectly from its JSON representation, but
the resulting JSON output is very verbose. Apart from environments, all standard storage
types are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serializeJSON(x, digits = 8, pretty = FALSE)

unserializeJSON(txt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serializeJSON_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object to be serialized</p>
</td></tr>
<tr><td><code id="serializeJSON_+3A_digits">digits</code></td>
<td>
<p>max number of digits (after the dot) to print for numeric values</p>
</td></tr>
<tr><td><code id="serializeJSON_+3A_pretty">pretty</code></td>
<td>
<p>add indentation/whitespace to JSON output. See <code><a href="#topic+prettify">prettify()</a></code></p>
</td></tr>
<tr><td><code id="serializeJSON_+3A_txt">txt</code></td>
<td>
<p>a JSON string which was created using <code>serializeJSON</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>JSON is a text based format which leads to loss of precision when printing numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jsoncars &lt;- serializeJSON(mtcars)
mtcars2 &lt;- unserializeJSON(jsoncars)
identical(mtcars, mtcars2)

set.seed('123')
myobject &lt;- list(
  mynull = NULL,
  mycomplex = lapply(eigen(matrix(-rnorm(9),3)), round, 3),
  mymatrix = round(matrix(rnorm(9), 3),3),
  myint = as.integer(c(1,2,3)),
  mydf = cars,
  mylist = list(foo='bar', 123, NA, NULL, list('test')),
  mylogical = c(TRUE,FALSE,NA),
  mychar = c('foo', NA, 'bar'),
  somemissings = c(1,2,NA,NaN,5, Inf, 7 -Inf, 9, NA),
  myrawvec = charToRaw('This is a test')
);
identical(unserializeJSON(serializeJSON(myobject)), myobject);
</code></pre>

<hr>
<h2 id='stream_in+2C+20stream_out'>Streaming JSON input/output</h2><span id='topic+stream_in+2C+20stream_out'></span><span id='topic+stream_in'></span><span id='topic+stream_out'></span>

<h3>Description</h3>

<p>The <code>stream_in</code> and <code>stream_out</code> functions implement line-by-line processing
of JSON data over a <a href="base.html#topic+connection">connection</a>, such as a socket, url, file or pipe. JSON
streaming requires the <a href="https://ndjson.org">ndjson</a> format, which slightly differs
from <code><a href="#topic+fromJSON">fromJSON()</a></code> and <code><a href="#topic+toJSON">toJSON()</a></code>, see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stream_in(con, handler = NULL, pagesize = 500, verbose = TRUE, ...)

stream_out(x, con = stdout(), pagesize = 500, verbose = TRUE, prefix = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stream_in+2B2C+2B20stream_out_+3A_con">con</code></td>
<td>
<p>a <a href="base.html#topic+connection">connection</a> object. If the connection is not open,
<code>stream_in</code> and <code>stream_out</code> will automatically open
and later close (and destroy) the connection. See details.</p>
</td></tr>
<tr><td><code id="stream_in+2B2C+2B20stream_out_+3A_handler">handler</code></td>
<td>
<p>a custom function that is called on each page of JSON data. If not specified,
the default handler stores all pages and binds them into a single data frame that will be
returned by <code>stream_in</code>. See details.</p>
</td></tr>
<tr><td><code id="stream_in+2B2C+2B20stream_out_+3A_pagesize">pagesize</code></td>
<td>
<p>number of lines to read/write from/to the connection per iteration.</p>
</td></tr>
<tr><td><code id="stream_in+2B2C+2B20stream_out_+3A_verbose">verbose</code></td>
<td>
<p>print some information on what is going on.</p>
</td></tr>
<tr><td><code id="stream_in+2B2C+2B20stream_out_+3A_...">...</code></td>
<td>
<p>arguments for <code><a href="#topic+fromJSON">fromJSON()</a></code> and <code><a href="#topic+toJSON">toJSON()</a></code> that
control JSON formatting/parsing where applicable. Use with caution.</p>
</td></tr>
<tr><td><code id="stream_in+2B2C+2B20stream_out_+3A_x">x</code></td>
<td>
<p>object to be streamed out. Currently only data frames are supported.</p>
</td></tr>
<tr><td><code id="stream_in+2B2C+2B20stream_out_+3A_prefix">prefix</code></td>
<td>
<p>string to write before each line (use <code>"\u001e"</code> to write rfc7464 text sequences)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because parsing huge JSON strings is difficult and inefficient, JSON streaming is done
using <strong>lines of minified JSON records</strong>, a.k.a. <a href="https://ndjson.org">ndjson</a>.
This is pretty standard: JSON databases such as MongoDB use the same format to
import/export datasets. Note that this means that the
total stream combined is not valid JSON itself; only the individual lines are. Also note
that because line-breaks are used as separators, prettified JSON is not permitted: the
JSON lines <em>must</em> be minified. In this respect, the format is a bit different from
<code><a href="#topic+fromJSON">fromJSON()</a></code> and <code><a href="#topic+toJSON">toJSON()</a></code> where all lines are part of a single JSON
structure with optional line breaks.
</p>
<p>The <code>handler</code> is a callback function which is called for each page (batch) of
JSON data with exactly one argument (usually a data frame with <code>pagesize</code> rows).
If <code>handler</code> is missing or <code>NULL</code>, a default handler is used which stores all
intermediate pages of data, and at the very end binds all pages together into one single
data frame that is returned by <code>stream_in</code>. When a custom <code>handler</code> function
is specified, <code>stream_in</code> does not store any intermediate results and always returns
<code>NULL</code>. It is then up to the <code>handler</code> to process or store data pages.
A <code>handler</code> function that does not store intermediate results in memory (for
example by writing output to another connection) results in a pipeline that can process an
unlimited amount of data. See example.
</p>
<p>Note that a vector of JSON strings already in R can parsed with <code>stream_in</code> by
creating a connection to it with <code><a href="base.html#topic+textConnection">textConnection()</a></code>.
</p>
<p>If a connection is not opened yet, <code>stream_in</code> and <code>stream_out</code>
will automatically open and later close the connection. Because R destroys connections
when they are closed, they cannot be reused. To use a single connection for multiple
calls to <code>stream_in</code> or <code>stream_out</code>, it needs to be opened
beforehand. See example.
</p>


<h3>Value</h3>

<p>The <code>stream_out</code> function always returns <code>NULL</code>.
When no custom handler is specified, <code>stream_in</code> returns a data frame of all pages binded together.
When a custom handler function is specified, <code>stream_in</code> always returns <code>NULL</code>.
</p>


<h3>References</h3>

<p>MongoDB export format: <a href="https://docs.mongodb.com/manual/reference/program/mongoexport/">https://docs.mongodb.com/manual/reference/program/mongoexport/</a>
</p>
<p>Documentation for the JSON Lines text file format: <a href="https://jsonlines.org/">https://jsonlines.org/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fromJSON">fromJSON()</a></code>, <code><a href="#topic+read_json">read_json()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compare formats
x &lt;- iris[1:3,]
toJSON(x)
stream_out(x)

# Trivial example
mydata &lt;- stream_in(url("https://jeroen.github.io/data/iris.json"))

## Not run: 
#stream large dataset to file and back
library(nycflights13)
stream_out(flights, file(tmp &lt;- tempfile()))
flights2 &lt;- stream_in(file(tmp))
unlink(tmp)
all.equal(flights2, as.data.frame(flights))

# stream over HTTP
diamonds2 &lt;- stream_in(url("https://jeroen.github.io/data/diamonds.json"))

# stream over HTTP with gzip compression
flights3 &lt;- stream_in(gzcon(url("https://jeroen.github.io/data/nycflights13.json.gz")))
all.equal(flights3, as.data.frame(flights))

# stream over HTTPS (HTTP+SSL) via curl
library(curl)
flights4 &lt;- stream_in(gzcon(curl("https://jeroen.github.io/data/nycflights13.json.gz")))
all.equal(flights4, as.data.frame(flights))

# or alternatively:
flights5 &lt;- stream_in(gzcon(pipe("curl https://jeroen.github.io/data/nycflights13.json.gz")))
all.equal(flights5, as.data.frame(flights))

# Full JSON IO stream from URL to file connection.
# Calculate delays for flights over 1000 miles in batches of 5k
library(dplyr)
con_in &lt;- gzcon(url("https://jeroen.github.io/data/nycflights13.json.gz"))
con_out &lt;- file(tmp &lt;- tempfile(), open = "wb")
stream_in(con_in, handler = function(df){
  df &lt;- dplyr::filter(df, distance &gt; 1000)
  df &lt;- dplyr::mutate(df, delta = dep_delay - arr_delay)
  stream_out(df, con_out, pagesize = 1000)
}, pagesize = 5000)
close(con_out)

# stream it back in
mydata &lt;- stream_in(file(tmp))
nrow(mydata)
unlink(tmp)

# Data from http://openweathermap.org/current#bulk
# Each row contains a nested data frame.
daily14 &lt;- stream_in(gzcon(url("http://78.46.48.103/sample/daily_14.json.gz")), pagesize=50)
subset(daily14, city$name == "Berlin")$data[[1]]

# Or with dplyr:
library(dplyr)
daily14f &lt;- flatten(daily14)
filter(daily14f, city.name == "Berlin")$data[[1]]

# Stream import large data from zip file
tmp &lt;- tempfile()
download.file("http://jsonstudio.com/wp-content/uploads/2014/02/companies.zip", tmp)
companies &lt;- stream_in(unz(tmp, "companies.json"))

## End(Not run)
</code></pre>

<hr>
<h2 id='toJSON+2C+20fromJSON'>Convert <span class="rlang"><b>R</b></span> objects to/from JSON</h2><span id='topic+toJSON+2C+20fromJSON'></span><span id='topic+fromJSON'></span><span id='topic+toJSON'></span><span id='topic+jsonlite'></span>

<h3>Description</h3>

<p>These functions are used to convert between JSON data and <span class="rlang"><b>R</b></span> objects. The <code><a href="#topic+toJSON">toJSON()</a></code> and <code><a href="#topic+fromJSON">fromJSON()</a></code>
functions use a class based mapping, which follows conventions outlined in this paper:  <a href="https://arxiv.org/abs/1403.2805">https://arxiv.org/abs/1403.2805</a> (also available as vignette).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromJSON(
  txt,
  simplifyVector = TRUE,
  simplifyDataFrame = simplifyVector,
  simplifyMatrix = simplifyVector,
  flatten = FALSE,
  ...
)

toJSON(
  x,
  dataframe = c("rows", "columns", "values"),
  matrix = c("rowmajor", "columnmajor"),
  Date = c("ISO8601", "epoch"),
  POSIXt = c("string", "ISO8601", "epoch", "mongo"),
  factor = c("string", "integer"),
  complex = c("string", "list"),
  raw = c("base64", "hex", "mongo", "int", "js"),
  null = c("list", "null"),
  na = c("null", "string"),
  auto_unbox = FALSE,
  digits = 4,
  pretty = FALSE,
  force = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_txt">txt</code></td>
<td>
<p>a JSON string, URL or file</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_simplifyvector">simplifyVector</code></td>
<td>
<p>coerce JSON arrays containing only primitives into an atomic vector</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_simplifydataframe">simplifyDataFrame</code></td>
<td>
<p>coerce JSON arrays containing only records (JSON objects) into a data frame</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_simplifymatrix">simplifyMatrix</code></td>
<td>
<p>coerce JSON arrays containing vectors of equal mode and dimension into matrix or array</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_flatten">flatten</code></td>
<td>
<p>automatically <code><a href="#topic+flatten">flatten()</a></code> nested data frames into a single non-nested data frame</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_...">...</code></td>
<td>
<p>arguments passed on to class specific <code>print</code> methods</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_x">x</code></td>
<td>
<p>the object to be encoded</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_dataframe">dataframe</code></td>
<td>
<p>how to encode data.frame objects: must be one of 'rows', 'columns' or 'values'</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_matrix">matrix</code></td>
<td>
<p>how to encode matrices and higher dimensional arrays: must be one of 'rowmajor' or 'columnmajor'.</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_date">Date</code></td>
<td>
<p>how to encode Date objects: must be one of 'ISO8601' or 'epoch'</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_posixt">POSIXt</code></td>
<td>
<p>how to encode POSIXt (datetime) objects: must be one of 'string', 'ISO8601', 'epoch' or 'mongo'</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_factor">factor</code></td>
<td>
<p>how to encode factor objects: must be one of 'string' or 'integer'</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_complex">complex</code></td>
<td>
<p>how to encode complex numbers: must be one of 'string' or 'list'</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_raw">raw</code></td>
<td>
<p>how to encode raw objects: must be one of 'base64', 'hex' or 'mongo'</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_null">null</code></td>
<td>
<p>how to encode NULL values within a list: must be one of 'null' or 'list'</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_na">na</code></td>
<td>
<p>how to print NA values: must be one of 'null' or 'string'. Defaults are class specific</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_auto_unbox">auto_unbox</code></td>
<td>
<p>automatically <code><a href="#topic+unbox">unbox()</a></code> all atomic vectors of length 1. It is usually safer to avoid this and instead use the <code><a href="#topic+unbox">unbox()</a></code> function to unbox individual elements.
An exception is that objects of class <code>AsIs</code> (i.e. wrapped in <code><a href="base.html#topic+I">I()</a></code>) are not automatically unboxed. This is a way to mark single values as length-1 arrays.</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_digits">digits</code></td>
<td>
<p>max number of decimal digits to print for numeric values. Use <code><a href="base.html#topic+I">I()</a></code> to specify significant digits. Use <code>NA</code> for max precision.</p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_pretty">pretty</code></td>
<td>
<p>adds indentation whitespace to JSON output. Can be TRUE/FALSE or a number specifying the number of spaces to indent. See <code><a href="#topic+prettify">prettify()</a></code></p>
</td></tr>
<tr><td><code id="toJSON+2B2C+2B20fromJSON_+3A_force">force</code></td>
<td>
<p>unclass/skip objects of classes with no defined JSON mapping</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+toJSON">toJSON()</a></code> and <code><a href="#topic+fromJSON">fromJSON()</a></code> functions are drop-in replacements for the identically named functions
in packages <code>rjson</code> and <code>RJSONIO</code>. Our implementation uses an alternative, somewhat more consistent mapping
between <span class="rlang"><b>R</b></span> objects and JSON strings.
</p>
<p>The <code><a href="#topic+serializeJSON">serializeJSON()</a></code> and <code><a href="#topic+unserializeJSON">unserializeJSON()</a></code> functions in this package use an
alternative system to convert between <span class="rlang"><b>R</b></span> objects and JSON, which supports more classes but is much more verbose.
</p>
<p>A JSON string is always unicode, using <code>UTF-8</code> by default, hence there is usually no need to escape any characters.
However, the JSON format does support escaping of unicode characters, which are encoded using a backslash followed by
a lower case <code>"u"</code> and 4 hex characters, for example: <code>"Z\u00FCrich"</code>. The <code>fromJSON</code> function
will parse such escape sequences but it is usually preferable to encode unicode characters in JSON using native
<code>UTF-8</code> rather than escape sequences.
</p>


<h3>References</h3>

<p>Jeroen Ooms (2014). The <code>jsonlite</code> Package: A Practical and Consistent Mapping Between JSON Data and <span class="rlang"><b>R</b></span> Objects. <em>arXiv:1403.2805</em>. <a href="https://arxiv.org/abs/1403.2805">https://arxiv.org/abs/1403.2805</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_json">read_json()</a></code>, <code><a href="#topic+stream_in">stream_in()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Stringify some data
jsoncars &lt;- toJSON(mtcars, pretty=TRUE)
cat(jsoncars)

# Parse it back
fromJSON(jsoncars)

# Parse escaped unicode
fromJSON('{"city" : "Z\\u00FCrich"}')

# Decimal vs significant digits
toJSON(pi, digits=3)
toJSON(pi, digits=I(3))

## Not run: 
#retrieve data frame
data1 &lt;- fromJSON("https://api.github.com/users/hadley/orgs")
names(data1)
data1$login

# Nested data frames:
data2 &lt;- fromJSON("https://api.github.com/users/hadley/repos")
names(data2)
names(data2$owner)
data2$owner$login

# Flatten the data into a regular non-nested dataframe
names(flatten(data2))

# Flatten directly (more efficient):
data3 &lt;- fromJSON("https://api.github.com/users/hadley/repos", flatten = TRUE)
identical(data3, flatten(data2))

## End(Not run)
</code></pre>

<hr>
<h2 id='unbox'>Unbox a vector or data frame</h2><span id='topic+unbox'></span>

<h3>Description</h3>

<p>This function marks an atomic vector or data frame as a
<a href="https://en.wikipedia.org/wiki/Singleton_(mathematics)">singleton</a>, i.e.
a set with exactly 1 element. Thereby, the value will not turn into an
<code>array</code> when encoded into JSON. This can only be done for
atomic vectors of length 1, or data frames with exactly 1 row. To automatically
unbox all vectors of length 1 within an object, use the <code>auto_unbox</code> argument
in <code><a href="#topic+toJSON">toJSON()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unbox(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbox_+3A_x">x</code></td>
<td>
<p>atomic vector of length 1, or data frame with 1 row.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is usually recommended to avoid this function and stick with the default
encoding schema for the various <span class="rlang"><b>R</b></span> classes. The only use case for this function
is if you are bound to some specific predefined JSON structure (e.g. to
submit to an API), which has no natural <span class="rlang"><b>R</b></span> representation. Note that the default
encoding for data frames naturally results in a collection of key-value pairs,
without using <code>unbox</code>.
</p>


<h3>Value</h3>

<p>Returns a singleton version of <code>x</code>.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Singleton_(mathematics)">https://en.wikipedia.org/wiki/Singleton_(mathematics)</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toJSON(list(foo=123))
toJSON(list(foo=unbox(123)))

# Auto unbox vectors of length one:
x = list(x=1:3, y = 4, z = "foo", k = NULL)
toJSON(x)
toJSON(x, auto_unbox = TRUE)

x &lt;- iris[1,]
toJSON(list(rec=x))
toJSON(list(rec=unbox(x)))
</code></pre>

<hr>
<h2 id='validate'>Validate JSON</h2><span id='topic+validate'></span>

<h3>Description</h3>

<p>Test if a string contains valid JSON. Characters vectors will be collapsed into a single string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate(txt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_+3A_txt">txt</code></td>
<td>
<p>JSON string</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#Output from toJSON and serializeJSON should pass validation
myjson &lt;- toJSON(mtcars)
validate(myjson) #TRUE

#Something bad happened
truncated &lt;- substring(myjson, 1, 100)
validate(truncated) #FALSE
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
