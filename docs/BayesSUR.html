<!DOCTYPE html><html lang="en"><head><title>Help for package BayesSUR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesSUR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BayesSUR'><p>Fitting BayesSUR models</p></a></li>
<li><a href='#BayesSUR_internal'><p>BayesSUR_internal</p></a></li>
<li><a href='#coef.BayesSUR'><p>coef method for class <code>BayesSUR</code></p></a></li>
<li><a href='#elpd'><p>expected log pointwise predictive density</p></a></li>
<li><a href='#exampleEQTL'><p>Simulated data set to mimic a small expression quantitative trait loci (eQTL) example</p></a></li>
<li><a href='#exampleGDSC'><p>Preprocessed data set to mimic a small pharmacogenomic example</p></a></li>
<li><a href='#fitted.BayesSUR'><p>get fitted responses</p></a></li>
<li><a href='#getEstimator'><p>extract the posterior mean of parameters</p></a></li>
<li><a href='#plot.BayesSUR'><p>create a selection of plots</p></a></li>
<li><a href='#plotCPO'><p>plot conditional predictive ordinate</p></a></li>
<li><a href='#plotEstimator'><p>plot heatmap of estimators</p></a></li>
<li><a href='#plotGraph'><p>plot graph for response variables</p></a></li>
<li><a href='#plotManhattan'><p>plot Manhattan-like plots</p></a></li>
<li><a href='#plotMCMCdiag'><p>plot MCMC diagnostic plots</p></a></li>
<li><a href='#plotNetwork'><p>plot network representation of the associations between responses and predictors</p></a></li>
<li><a href='#predict.BayesSUR'><p>predict method for class <code>BayesSUR</code></p></a></li>
<li><a href='#print.BayesSUR'><p>print method for class <code>BayesSUR</code></p></a></li>
<li><a href='#summary.BayesSUR'><p>summary method for class <code>BayesSUR</code></p></a></li>
<li><a href='#targetGene'><p>targetGene</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Seemingly Unrelated Regression Models in
High-Dimensional Settings</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-30</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mbant/BayesSUR">https://github.com/mbant/BayesSUR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mbant/BayesSUR/issues">https://github.com/mbant/BayesSUR/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian seemingly unrelated regression with general variable selection and dense/sparse covariance matrix. The sparse seemingly unrelated regression is described in Bottolo et al. (2021) &lt;<a href="https://doi.org/10.1111%2Frssc.12490">doi:10.1111/rssc.12490</a>&gt;, the software paper is in Zhao et al. (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i11">doi:10.18637/jss.v100.i11</a>&gt;, and the model with random effects is described in Zhao et al. (2024) &lt;<a href="https://doi.org/10.1093%2Fjrsssc%2Fqlad102">doi:10.1093/jrsssc/qlad102</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Copyright:</td>
<td>The C++ files pugixml.cpp, pugixml.hpp and pugiconfig.hpp
are used with Copyright (C) 2006-2018 from Arseny Kapoulkine
and Copyright (C) 2003 from Kristen Wegner. The R function
vertical.image.legend() is used with Copyright (C) 2013 from
Jenise Swall.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, xml2, igraph, Matrix, tikzDevice, stats, utils,
grDevices, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, knitr, rmarkdown, BDgraph, data.table, plyr, scrime</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-30 07:17:43 UTC; zhiz</td>
</tr>
<tr>
<td>Author:</td>
<td>Marco Banterle [aut],
  Zhi Zhao [aut, cre],
  Leonardo Bottolo [ctb],
  Sylvia Richardson [ctb],
  Waldir Leoncio [ctb],
  Alex Lewin [aut],
  Manuela Zucknick [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zhi Zhao &lt;zhi.zhao@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-30 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BayesSUR'>Fitting BayesSUR models</h2><span id='topic+BayesSUR'></span><span id='topic+BayesSUR-package'></span>

<h3>Description</h3>

<p>Main function of the package. Fits a range of models introduced in the 
package vignette <code>BayesSUR.pdf</code>. Returns an object of S3 class 
<code>BayesSUR</code>. There are three options for the prior on the residual 
covariance matrix (i.e., independent inverse-Gamma, inverse-Wishart and 
hyper-inverse Wishart) and three options for the prior on the latent 
indicator variable (i.e., independent Bernoulli, hotspot and Markov random 
field). So there are nine models in total. See details for their combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BayesSUR(
  data = NULL,
  Y,
  X,
  X_0 = NULL,
  covariancePrior = "HIW",
  gammaPrior = "hotspot",
  betaPrior = "independent",
  nIter = 10000,
  burnin = 5000,
  nChains = 2,
  outFilePath = "",
  gammaSampler = "bandit",
  gammaInit = "R",
  mrfG = NULL,
  standardize = TRUE,
  standardize.response = TRUE,
  maxThreads = 1,
  tick = 1000,
  output_gamma = TRUE,
  output_beta = TRUE,
  output_Gy = TRUE,
  output_sigmaRho = TRUE,
  output_pi = TRUE,
  output_tail = TRUE,
  output_model_size = TRUE,
  output_model_visit = FALSE,
  output_CPO = FALSE,
  output_Y = TRUE,
  output_X = TRUE,
  hyperpar = list(),
  tmpFolder = "tmp/"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesSUR_+3A_data">data</code></td>
<td>
<p>a numeric matrix with variables on the columns and observations 
on the rows, if arguments <code>Y</code> and <code>X</code> (and possibly <code>X_0</code>) 
are vectors. Can be <code>NULL</code> if arguments <code>Y</code> and <code>X</code> (and 
possibly <code>X_0</code>) are numeric matrices</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_y">Y</code>, <code id="BayesSUR_+3A_x">X</code></td>
<td>
<p>vectors of indices (with respect to the data matrix) for the 
outcomes (<code>Y</code>) and the predictors to select (<code>X</code>) respectively; 
if the <code>data</code> argument is <code>NULL</code>, these needs to be numeric 
matrices containing the data instead, with variables on the columns and 
observations on the rows</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_x_0">X_0</code></td>
<td>
<p>vectors of indices (with respect to the data matrix) for the 
fixed predictors that are not selected, i.e. always included in the model; 
if the data argument is not provided, this needs to be a numeric matrix 
containing the data instead, with variables on the columns and observations 
on the rows</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_covarianceprior">covariancePrior</code></td>
<td>
<p>string indicating the prior for the covariance $C$; 
it has to be either <code>HIW</code> for the hyper-inverse-Wishar (which will 
result in a sparse covariance matrix), <code>IW</code> for the inverse-Wishart 
prior (dense covariance) or <code>IG</code> for independent inverse-Gamma on all 
the diagonal elements and 0 otherwise. See the details for the model 
specification</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_gammaprior">gammaPrior</code></td>
<td>
<p>string indicating the gamma prior to use, either 
<code>hotspot</code> (default) for the Hotspot prior of Bottolo (2011), <code>MRF</code> 
for the Markov Random Field prior or <code>hierarchical</code> for a simpler 
hierarchical prior. See the details for the model specification</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_betaprior">betaPrior</code></td>
<td>
<p>string indicating the prior for regression coefficients; it 
has to be either <code>independent</code> for independent spike-and-slab priors 
(only slab part for <code>X_0</code> if specified), or <code>reGroup</code> for weakly 
normal priors for mandatory variables (random effects) and spike-and-slab 
priors for other variables of Zhao (2023)</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_niter">nIter</code></td>
<td>
<p>number of iterations for the MCMC procedure. Default 10000</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations to discard at the start of the chain. 
Default is 5000</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_nchains">nChains</code></td>
<td>
<p>number of parallel tempered chains to run (default 2). The 
temperature is adapted during the burnin phase</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_outfilepath">outFilePath</code></td>
<td>
<p>path to where the output files are to be written</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_gammasampler">gammaSampler</code></td>
<td>
<p>string indicating the type of sampler for gamma, either 
<code>bandit</code> for the Thompson sampling inspired samper or <code>MC3</code> for 
the usual MC^3 sampler.  See Russo et al.(2018) or Madigan and York (1995) 
for details</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_gammainit">gammaInit</code></td>
<td>
<p>gamma initialisation to either all-zeros (<code>0</code>), all 
ones (<code>1</code>), MLE-informed (<code>MLE</code>) or (default) randomly (<code>R</code>)</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_mrfg">mrfG</code></td>
<td>
<p>either a matrix or a path to the file containing (the edge list 
of) the G matrix for the MRF prior on gamma (if necessary)</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_standardize">standardize</code></td>
<td>
<p>logical flag for X variable standardization. Default is 
<code>standardize=TRUE</code>. Coefficients are returned on the standardized scale</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_standardize.response">standardize.response</code></td>
<td>
<p>logical flag for Y standardization. Default is 
<code>standardize.response=TRUE</code></p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_maxthreads">maxThreads</code></td>
<td>
<p>maximum threads used for parallelization. Default is 1. 
Reproducibility of results with <code>set.seed()</code> is only guaranteed if 
<code>maxThreads=1</code></p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_tick">tick</code></td>
<td>
<p>an integer used for printing the iteration index and some updated 
parameters every tick-th iteration. Default is 1000</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_gamma">output_gamma</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the 
output for  gamma. See the return value below for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_beta">output_beta</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the output 
for beta. See the return value below for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_gy">output_Gy</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the output 
for Gy. See the return value below for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_sigmarho">output_sigmaRho</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the 
output for sigmaRho. See the return value below for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_pi">output_pi</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the output 
for pi. See the return value below for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_tail">output_tail</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the output 
for tail (hotspot tail probability). See the return value below for more 
information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_model_size">output_model_size</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the 
output for model_size. See the return value below for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_model_visit">output_model_visit</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the 
output for all visited models over the MCMC iterations. Default is 
<code>FALSE</code>. See the return value below for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_cpo">output_CPO</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the output 
for (scaled) conditional predictive ordinates (<code>*_CPO_out.txt</code>),
CPO with joint posterior predictive of the response variables 
(<code>*_CPOsumy_out.txt</code>) and widely applicable information criterion 
(<code>*_WAIC_out.txt</code>). See the return value below for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_y">output_Y</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the output 
for responses dataset Y</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_output_x">output_X</code></td>
<td>
<p>allow (<code>TRUE</code>) or suppress (<code>FALSE</code>) the output 
for predictors dataset X</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_hyperpar">hyperpar</code></td>
<td>
<p>a list of named hypeparameters to use instead of the default 
values. Valid names are mrf_d, mrf_e, a_sigma, b_sigma, a_tau, b_tau, nu, 
a_eta, b_eta, a_o, b_o, a_pi, b_pi, a_w and b_w. Their default values are 
a_w=2, b_w=5, a_omega=2, b_omega=1, a_o=2, b_o=p-2, a_pi=2, b_pi=1, nu=s+2, 
a_tau=0.1, b_tau=10, a_eta=0.1, b_eta=1, a_sigma=1, b_sigma=1, mrf_d=-3 and 
mrf_e=0.03. See the vignette for more information</p>
</td></tr>
<tr><td><code id="BayesSUR_+3A_tmpfolder">tmpFolder</code></td>
<td>
<p>the path to a temporary folder where intermediate data 
files are stored (will be erased at the end of the chain). It is specified 
relative to <code>outFilePath</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments <code>covariancePrior</code> and <code>gammaPrior</code> specify 
the model HRR, dSUR or SSUR with different gamma prior. Let 
<code class="reqn">\gamma_{jk}</code> be latent indicator variable of each coefficient and 
<code class="reqn">C</code> be covariance matrix of response variables. The nine models 
specified through the arguments <code>covariancePrior</code> and 
<code>gammaPrior</code> are as follows.
</p>

<table>
<tr>
 <td style="text-align: center;">
                </td><td style="text-align: center;"> <code class="reqn">\gamma_{jk}</code>~Bernoulli </td><td style="text-align: center;"> <code class="reqn">\gamma_{jk}</code>~hotspot </td><td style="text-align: center;"> <code class="reqn">\gamma</code>~MRF </td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">C</code>~indep </td><td style="text-align: center;"> HRR-B                       </td><td style="text-align: center;"> HRR-H                     </td><td style="text-align: center;"> HRR-M           </td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">C</code>~IW   </td><td style="text-align: center;"> dSUR-B                      </td><td style="text-align: center;"> dSUR-H                    </td><td style="text-align: center;"> dSUR-M          </td>
</tr>
<tr>
 <td style="text-align: center;">
  <code class="reqn">C</code>~HIW   </td><td style="text-align: center;"> SSUR-B                      </td><td style="text-align: center;"> SSUR-H                    </td><td style="text-align: center;"> SSUR-M
</td>
</tr>

</table>



<h3>Value</h3>

<p>An object of class <code>BayesSUR</code> is saved as 
<code>obj_BayesSUR.RData</code> in the output file, including the following 
components:
</p>

<ul>
<li><p> status - the running status
</p>
</li>
<li><p> input - a list of all input parameters by the user
</p>
</li>
<li><p> output - a list of the all output filenames:
</p>

<ul>
<li><p> &quot;<code>*_logP_out.txt</code>&quot; - contains each row for the <code class="reqn">1000t</code>-th iteration's log-likelihoods of parameters, i.e., Tau, Eta, JunctionTree, SigmaRho, O, Pi, Gamma, W, Beta and data conditional log-likelihood depending on the models.
</p>
</li>
<li><p> &quot;<code>*_gamma_out.txt</code>&quot; - posterior mean of the latent indicator matrix.
</p>
</li>
<li><p> &quot;<code>*_pi_out.txt</code>&quot; - posterior mean of the predictor effects (prospensity) by decomposing the probability of the latent indicator.
</p>
</li>
<li><p> &quot;<code>*_hotspot_tail_p_out.txt</code>&quot; - posterior mean of the hotspot tail probability. Only available for the hotspot prior on the gamma.
</p>
</li>
<li><p> &quot;<code>*_beta_out.txt</code>&quot; - posterior mean of the coefficients matrix.
</p>
</li>
<li><p> &quot;<code>*_Gy_out.txt</code>&quot; - posterior mean of the response graph. Only available for the HIW prior on the covariance.
</p>
</li>
<li><p> &quot;<code>*_sigmaRho_out.txt</code>&quot; - posterior mean of the transformed parameters. Not available for the IG prior on the covariance.
</p>
</li>
<li><p> &quot;<code>*_model_size_out.txt</code>&quot; - contains each row for the<code class="reqn">1000t</code>-th iteration's model sizes of the multiple response variables.
</p>
</li>
<li><p> &quot;<code>*_model_visit_gy_out.txt</code>&quot; - contains each row for the nonzero indices of the vectorized estimated graph matrix for each iteration.
</p>
</li>
<li><p> &quot;<code>*_model_visit_gamma_out.txt</code>&quot; - contains each row for the nonzero indices of the vectorized estimated gamma matrix for each iteration.
</p>
</li>
<li><p> &quot;<code>*_CPO_out.txt</code>&quot; - the (scaled) conditional predictive ordinates (CPO).
</p>
</li>
<li><p> &quot;<code>*_CPOsumy_out.txt</code>&quot; - the (scaled) conditional predictive ordinates (CPO) with joint posterior predictive of the response variables.
</p>
</li>
<li><p> &quot;<code>*_WAIC_out.txt</code>&quot; - the widely applicable information criterion (WAIC).
</p>
</li>
<li><p> &quot;<code>*_Y.txt</code>&quot; - responses dataset.
</p>
</li>
<li><p> &quot;<code>*_X.txt</code>&quot; - predictors dataset.
</p>
</li>
<li><p> &quot;<code>*_X0.txt</code>&quot; - fixed predictors dataset.
</p>
</li></ul>

</li>
<li><p> call - the matched call.
</p>
</li></ul>



<h3>References</h3>

<p>Russo D, Van Roy B, Kazerouni A, Osband I, Wen Z (2018). <em>A tutorial on Thompson sampling.</em> Foundations and Trends in Machine Learning, 11: 1-96.
</p>
<p>Madigan D, York J (1995). <em>Bayesian graphical models for discrete data.</em> International Statistical Review, 63: 215–232.
</p>
<p>Bottolo L, Banterle M, Richardson S, Ala-Korpela M, Jarvelin MR, Lewin A (2020). <em>A computationally efficient Bayesian seemingly unrelated regressions model for high-dimensional quantitative trait loci discovery.</em> Journal of Royal Statistical Society: Series C, 70: 886-908.
</p>
<p>Zhao Z, Banterle M, Bottolo L, Richardson S, Lewin A, Zucknick M (2021). <em>BayesSUR: An R package for high-dimensional multivariate Bayesian variable and covariance selection in linear regression.</em> Journal of Statistical Software, 100: 1–32.
</p>
<p>Zhao Z, Banterle M, Lewin A, Zucknick M (2023). <em>Multivariate Bayesian structured variable selection for pharmacogenomic studies.</em> Journal of the Royal Statistical Society: Series C (Applied Statistics), qlad102.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)
set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 5, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/", output_CPO = TRUE
)

## check output
# show the summary information
summary(fit)

# show the estimated beta, gamma and graph of responses Gy
plot(fit, estimator = c("beta", "gamma", "Gy"), type = "heatmap")

## Not run: 
## Set up temporary work directory for saving a pdf figure
# td &lt;- tempdir()
# oldwd &lt;- getwd()
# setwd(td)

## Produce authentic math formulas in the graph
# plot(fit, estimator = c("beta", "gamma", "Gy"), type = "heatmap", fig.tex = TRUE)
# system(paste(getOption("pdfviewer"), "ParamEstimator.pdf"))
# setwd(oldwd)

## End(Not run)

</code></pre>

<hr>
<h2 id='BayesSUR_internal'>BayesSUR_internal</h2><span id='topic+BayesSUR_internal'></span>

<h3>Description</h3>

<p>Run a SUR Bayesian sampler &ndash; internal function
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BayesSUR_internal_+3A_datafile">dataFile</code></td>
<td>
<p>path to data file</p>
</td></tr>
<tr><td><code id="BayesSUR_internal_+3A_outfilepath">outFilePath</code></td>
<td>
<p>path to where the output is to be written</p>
</td></tr>
<tr><td><code id="BayesSUR_internal_+3A_niter">nIter</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="BayesSUR_internal_+3A_nchains">nChains</code></td>
<td>
<p>number of parallel chains to run
</p>
<p>NOTE THAT THIS IS BASICALLY JUST A WRAPPER</p>
</td></tr>
</table>

<hr>
<h2 id='coef.BayesSUR'>coef method for class <code>BayesSUR</code></h2><span id='topic+coef.BayesSUR'></span>

<h3>Description</h3>

<p>Extract the posterior mean of the coefficients of a <code>BayesSUR</code> class object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesSUR'
coef(object, beta.type = "marginal", Pmax = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.BayesSUR_+3A_object">object</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="coef.BayesSUR_+3A_beta.type">beta.type</code></td>
<td>
<p>type of output beta. Default is <code>marginal</code>, giving 
marginal beta estimation. If <code>beta.type="conditional"</code>, it gives beta 
estimation conditional on gamma=1.</p>
</td></tr>
<tr><td><code id="coef.BayesSUR_+3A_pmax">Pmax</code></td>
<td>
<p>If <code>Pmax=0.5</code> and <code>beta.type="conditional"</code>, it gives 
median probability model betas. Default is 0.</p>
</td></tr>
<tr><td><code id="coef.BayesSUR_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated coefficients are from an object of class <code>BayesSUR</code>. 
If the <code>BayesSUR</code> specified data standardization, the fitted values 
are base based on standardized data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check prediction
beta.hat &lt;- coef(fit)

</code></pre>

<hr>
<h2 id='elpd'>expected log pointwise predictive density</h2><span id='topic+elpd'></span>

<h3>Description</h3>

<p>Measure the prediction accuracy by the elpd (expected log pointwise 
predictive density). The out-of-sample predictive fit can either be 
estimated by Bayesian leave-one-out cross-validation (LOO) or by widely 
applicable information criterion (WAIC) (Vehtari et al. 2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elpd(object, method = "LOO")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elpd_+3A_object">object</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="elpd_+3A_method">method</code></td>
<td>
<p>the name of the prediction accuracy index. Default is the 
<code>"LOO"</code> (Bayesian LOO estimate of out-of-sample predictive fit). The 
other index is the <code>"WAIC"</code> (widely applicable information criterion).
For the HRR models, both &quot;<code>LOO</code>&quot; and &quot;<code>WAIC</code>&quot; are computed based 
on the multivate t-distribution of the posterior predictive rather than 
approximation of importance sampling.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the predictiion accuracy measure from an object of class 
<code>BayesSUR</code>. It is elpd.loo if the argumnet <code>method="LOO"</code> and 
elpd.WAIC if <code>method="WAIC"</code>.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., Gabry, J. (2017). <em>Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.</em> Statistics and Computing, 27(5): 1413–1432.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/", output_CPO = TRUE
)

## check output
# print prediction accuracy elpd (expected log pointwise predictive density)
# by the Bayesian LOO estimate of out-of-sample predictive fit
elpd(fit, method = "LOO")

</code></pre>

<hr>
<h2 id='exampleEQTL'>Simulated data set to mimic a small expression quantitative trait loci (eQTL) example</h2><span id='topic+exampleEQTL'></span>

<h3>Description</h3>

<p>Simulated data set to mimic a small expression quantitative trait loci 
(eQTL) example, with p=150 single nucleotide polymorphisms (SNPs) as 
explanatory variables, s=10 gene expression features as response variables 
and data for n=100 observations. Loading the data will load the associated 
blockList object needed to fit the model with BayesSUR(). The R code for 
generating the simulated data is given in the Examples paragraph.
</p>
<p>#importFrom BDgraph rgwish
#importFrom gRbase mcsMAT
#importFrom scrime simulateSNPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleEQTL
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the eQTL sample dataset
data("exampleEQTL", package = "BayesSUR")
str(exampleEQTL)

## Not run: 
# ===============
# The code below is to show how to generate the dataset "exampleEQTL.rda" above
# ===============

requireNamespace("BDgraph", quietly = TRUE)
requireNamespace("gRbase", quietly = TRUE)
requireNamespace("scrime", quietly = TRUE)

########################### Problem Dimensions
n &lt;- 100
p &lt;- 150
s &lt;- 10

############################ Select a set of n x p (SNPs) covariates

## The synthetic data in the paper use a subset of the real SNPs as covariates,
# but as the NFBC66 dataset is confidential we'll use scrime to sample similar data

x &lt;- scrime::simulateSNPs(c(n, 10), p, c(3, 2), prop.explain = c(0.9, 0.95))$data[1:n, ]
x &lt;- cbind(rep(1, n), x)

####################################################################

graph_pattern &lt;- 2

snr &lt;- 25

corr_param &lt;- 0.9

### Create the underlying graph
if (graph_pattern == 1) {
  ### 1) Random but full
  G &lt;- matrix(1, s, s)
  Prime &lt;- list(c(1:s))
  Res &lt;- Prime
  Sep &lt;- list()
} else if (graph_pattern == 2) {
  ### 2) Block Diagonal structure
  Prime &lt;- list(
    c(1:floor(s * 2 / 3)),
    c((floor(s * 2 / 3) + 1):(ceiling(s * 4 / 5) - 1)),
    c(ceiling(s * 4 / 5):s)
  )

  Res &lt;- Prime
  Sep &lt;- lapply(Res, function(x) which(x == -99))

  G &lt;- matrix(0, s, s)
  for (i in Prime) {
    G[i, i] &lt;- 1
  }
} else if (graph_pattern == 3) {
  ### 3) Decomposable model
  Prime &lt;- list(
    c(1:floor(s * 5 / 12), ceiling(s * 9 / 10):s),
    c(floor(s * 2 / 9):(ceiling(s * 2 / 3) - 1)),
    c(ceiling(s * 2 / 3):(ceiling(s * 4 / 5) - 1)),
    c(ceiling(s * 4 / 5):s)
  )

  Sep &lt;- list()
  H &lt;- list()
  for (i in 2:length(Prime)) {
    H &lt;- union(H, Prime[[i - 1]])
    Sep[[i - 1]] &lt;- intersect(H, Prime[[i]])
  }

  Res &lt;- list()
  Res[[1]] &lt;- Prime[[1]]
  for (i in 2:length(Prime)) {
    Res[[i]] &lt;- setdiff(Prime[[i]], Sep[[i - 1]])
  }

  G &lt;- matrix(0, s, s)
  for (i in Prime) {
    G[i, i] &lt;- 1
  }

  ## decomp check
  dimnames(G) &lt;- list(1:s, 1:s)
  length(gRbase::mcsMAT(G - diag(s))) &gt; 0
} else if (graph_pattern == 4) {
  ### 4) Non-decomposable model
  nblocks &lt;- 5
  nElemPerBlock &lt;- c(
    floor(s / 4), floor(s / 2) - 1 - floor(s / 4),
    ceiling(s * 2 / 3) - 1 - floor(s / 2), 7
  )
  nElemPerBlock &lt;- c(nElemPerBlock, s - sum(nElemPerBlock))
  res &lt;- 1:s
  blockIdx &lt;- list()
  for (i in 1:nblocks) {
    # blockIdx[[i]] = sample(res,nElemPerBlock[i])
    blockIdx[[i]] &lt;- res[1:nElemPerBlock[i]]
    res &lt;- setdiff(res, blockIdx[[i]])
  }

  G &lt;- matrix(0, s, s)
  ## add diagonal
  for (i in 1:nblocks) {
    G[blockIdx[[i]], blockIdx[[i]]] &lt;- 1
  }
  ## add cycle
  G[blockIdx[[1]], blockIdx[[2]]] &lt;- 1
  G[blockIdx[[2]], blockIdx[[1]]] &lt;- 1
  G[blockIdx[[1]], blockIdx[[5]]] &lt;- 1
  G[blockIdx[[5]], blockIdx[[1]]] &lt;- 1
  G[blockIdx[[2]], blockIdx[[3]]] &lt;- 1
  G[blockIdx[[3]], blockIdx[[2]]] &lt;- 1
  G[blockIdx[[3]], blockIdx[[5]]] &lt;- 1
  G[blockIdx[[5]], blockIdx[[3]]] &lt;- 1

  ## decomp check
  dimnames(G) &lt;- list(1:s, 1:s)
  length(gRbase::mcsMAT(G - diag(s))) &gt; 0

  # Prime = blockIdx
  Res &lt;- blockIdx ## this is not correct but not used in the non-decomp case
}

### Gamma Pattern
gamma &lt;- matrix(0, p + 1, s)
gamma[1, ] &lt;- 1


### 2) Extra Patterns

## outcomes (correlated in the decomp model) have some predictors in common
gamma[6:10, 6:9] &lt;- 1

## outcomes (correlated in the decomp model) have some predictors in common
# gamma[16:20,14:15] = 1

## outcomes (sort-of correlated [pair-wise] in the decomp model)
# have predictors in common 6:15
gamma[26:30, 4:8] &lt;- 1

## outcomes (NOT correlated in the decomp model) have predictors in common 16:17
gamma[36:40, c(3:5, 9:10)] &lt;- 1

## these predictors are associated with ALL the outcomes
gamma[46:50, ] &lt;- 1

combn11 &lt;- combn(rep((6:9 - 1) * p, each = length(6:10 - 1)) + rep(6:10 - 1, 
                  times = length(6:9)), 2)
combn31 &lt;- combn(rep((4:8 - 1) * p, each = length(26:30 - 1)) + rep(26:30 - 1, 
                  times = length(4:8)), 2)
combn32 &lt;- combn(rep((4:8 - 1) * p, each = length(46:50 - 1)) + rep(46:50 - 1, 
                  times = length(4:8)), 2)
combn41 &lt;- combn(rep((3:5 - 1) * p, each = length(36:40 - 1)) + rep(36:40 - 1, 
                  times = length(3:5)), 2)
combn42 &lt;- combn(rep((3:5 - 1) * p, each = length(46:50 - 1)) + rep(46:50 - 1, 
                  times = length(3:5)), 2)
combn51 &lt;- combn(rep((9:10 - 1) * p, each = length(36:40 - 1)) + rep(36:40 - 1, 
                  times = length(9:10)), 2)
combn52 &lt;- combn(rep((9:10 - 1) * p, each = length(46:50 - 1)) + rep(46:50 - 1, 
                  times = length(9:10)), 2)

Gmrf &lt;- rbind(t(combn11), t(combn31), t(combn32), t(combn41), t(combn42), t(combn51), t(combn52))

## get for every correlated bunch in the decomposable model,

if (graph_pattern &lt; 4) {
  # a different set of predictors
  for (i in 1:length(Prime)) {
    gamma[6:10 + (i + 6) * 10, Prime[[i]]] &lt;- 1
  } ## for each Prime component

  ## for every Residual instead
  for (i in 1:length(Res)) {
    gamma[6:10 + (i + 10) * 10, Res[[i]]] &lt;- 1
  }
} else {
  for (i in 1:length(Prime)) {
    gamma[6:10 + (i + 4) * 10, Prime[[i]]] &lt;- 1
  } ## for each Prime component

  ## for every Residual instead
  for (i in 1:length(Res)) {
    gamma[6:10 + (i + 9) * 10, Res[[i]]] &lt;- 1
  }
}

#### Sample the betas
sd_b &lt;- 1
b &lt;- matrix(rnorm((p + 1) * s, 0, sd_b), p + 1, s)

xb &lt;- matrix(NA, n, s)

for (i in 1:s) {
  if (sum(gamma[, i]) &gt; 1) {
    xb[, i] &lt;- x[, gamma[, i] == 1] %*% b[gamma[, i] == 1, i]
  } else {
    xb[, i] &lt;- rep(1, n) * b[1, i]
  }
}

## Sample the variance
v_r &lt;- mean(diag(var(xb))) / snr

nu &lt;- s + 1

M &lt;- matrix(corr_param, s, s)
diag(M) &lt;- rep(1, s)

P &lt;- BDgraph::rgwish(n = 1, adj = G, b = 3, D = v_r * M)

var &lt;- solve(P)

factor &lt;- 10
factor_min &lt;- 0.01
factor_max &lt;- 1000
count &lt;- 0
maxit &lt;- 10000

factor_prev &lt;- 1

repeat{
  var &lt;- var / factor * factor_prev

  ### Sample the errors and the Ys
  cVar &lt;- chol(as.matrix(var))
  # err = matrix(rnorm(n*s),n,s) %*% cVar
  err &lt;- matrix(rnorm(n * s, sd = 0.5), n, s) %*% cVar
  y &lt;- xb + err

  ## Reparametrisation ( assuming PEO is 1:s )
  cVar &lt;- t(cVar) # make it lower-tri
  S &lt;- diag(diag(cVar))
  sigma &lt;- S * S
  L &lt;- cVar %*% solve(S)
  rho &lt;- diag(s) - solve(L)

  ### S/N Ratio
  emp_snr &lt;- mean(diag(var(xb) %*% solve(sigma)))
  emp_g_snr &lt;- mean(diag(var((err) %*% t(rho)) %*% solve(sigma)))

  ##############

  if (abs(emp_snr - snr) &lt; (snr / 10) | count &gt; maxit) {
    break
  } else {
    if (emp_snr &lt; snr) { # increase factor
      factor_min &lt;- factor
    } else { # decrease factor
      factor_max &lt;- factor
    }
    factor_prev &lt;- factor
    factor &lt;- (factor_min + factor_max) / 2
  }
  count &lt;- count + 1
}

#################
colnames(y) &lt;- paste("GEX", 1:ncol(y), sep = "")
colnames(G) &lt;- colnames(y)
Gy &lt;- G
gamma &lt;- gamma[-1, ]
mrfG &lt;- Gmrf[!duplicated(Gmrf), ]
data &lt;- cbind(y, x[, -1]) # leave out the intercept because is coded inside already

exampleEQTL &lt;- list(data = data, blockList = list(1:s, s + 1:p))

## Write data file to the user's directory by save()

## End(Not run)

</code></pre>

<hr>
<h2 id='exampleGDSC'>Preprocessed data set to mimic a small pharmacogenomic example</h2><span id='topic+exampleGDSC'></span>

<h3>Description</h3>

<p>Preprocessed data set to mimic a small pharmacogenetic example from the 
Genomics of Drug Sensitivity in Cancer (GDSC) database, with p=850 gene 
features as explanatory variables, s=7 drugs sensitivity data as response 
variables and data for n=498 cell lines. Gene features include p1=343 gene 
expression features (GEX), p2=426 by copy number variations (CNV) and p3=68 
mutated genes (MUT). Loading the data will load the associated blockList 
(and mrfG) objects needed to fit the model with BayesSUR(). The R code for 
generating the simulated data is given in the Examples paragraph.
</p>
<p>#importFrom plyr mapvalues
#importFrom data.table like
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleGDSC
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the GDSC sample dataset
data("exampleGDSC", package = "BayesSUR")
str(exampleGDSC)

## Not run: 
# ===============
# This code below is to do preprocessing of GDSC data and obtain the complete dataset
# "exampleGDSC.rda" above. The user needs load the datasets from
# https://www.cancerrxgene.org release 5.
# But downloading and transforming the three used datasets below to *.csv files first.
# ===============

requireNamespace("plyr", quietly = TRUE)
requireNamespace("data.table", quietly = TRUE)


features &lt;- data.frame(read.csv("/gdsc_en_input_w5.csv", head = T))
names.fea &lt;- strsplit(rownames(features), "")
features &lt;- t(features)
p &lt;- c(13321, 13747 - 13321, 13818 - 13747)
Cell.Line &lt;- rownames(features)
features &lt;- data.frame(Cell.Line, features)

ic50_00 &lt;- data.frame(read.csv("gdsc_drug_sensitivity_fitted_data_w5.csv", head = T))
ic50_0 &lt;- ic50_00[, c(1, 4, 7)]
drug.id &lt;- data.frame(read.csv("gdsc_tissue_output_w5.csv", head = T))[, c(1, 3)]
drug.id2 &lt;- drug.id[!duplicated(drug.id$drug.id), ]
# delete drug.id=1066 since ID1066 and ID156 both correspond drug AZD6482,
# and no ID1066 in the "suppl.Data1" by Garnett et al. (2012)
drug.id2 &lt;- drug.id2[drug.id2$drug.id != 1066, ]
drug.id2$drug.name &lt;- as.character(drug.id2$drug.name)
drug.id2$drug.name &lt;- substr(drug.id2$drug.name, 1, nchar(drug.id2$drug.name) - 6)
drug.id2$drug.name &lt;- gsub(" ", "-", drug.id2$drug.name)

ic50 &lt;- ic50_0
# mapping the drug_id to drug names in drug sensitivity data set
ic50$drug_id &lt;- plyr::mapvalues(ic50$drug_id, from = drug.id2[, 2], to = drug.id2[, 1])
colnames(ic50) &lt;- c("Cell.Line", "compound", "IC50")

# transform drug sensitivity overall cell lines to a data matrix
y0 &lt;- reshape(ic50, v.names = "IC50", timevar = "compound", 
              idvar = "Cell.Line", direction = "wide")
y0$Cell.Line &lt;- gsub("-", ".", y0$Cell.Line)

# ===============
# select nonmissing pharmacological data
# ===============
y00 &lt;- y0
m0 &lt;- dim(y0)[2] - 1
eps &lt;- 0.05
# r1.na is better to be not smaller than r2.na
r1.na &lt;- 0.3
r2.na &lt;- 0.2
k &lt;- 1
while (sum(is.na(y0[, 2:(1 + m0)])) &gt; 0) {
  r1.na &lt;- r1.na - eps / k
  r2.na &lt;- r1.na - eps / k
  k &lt;- k + 1
  ## select drugs with &lt;30% (decreasing with k) missing data overall cell lines
  na.y &lt;- apply(y0[, 2:(1 + m0)], 2, function(xx) sum(is.na(xx)) / length(xx))
  while (sum(na.y &lt; r1.na) &lt; m0) {
    y0 &lt;- y0[, -c(1 + which(na.y &gt;= r1.na))]
    m0 &lt;- sum(na.y &lt; r1.na)
    na.y &lt;- apply(y0[, 2:(1 + m0)], 2, function(xx) sum(is.na(xx)) / length(xx))
  }

  ## select cell lines with treatment of at least 80% (increasing with k) drugs
  na.y0 &lt;- apply(y0[, 2:(1 + m0)], 1, function(xx) sum(is.na(xx)) / length(xx))
  while (sum(na.y0 &lt; r2.na) &lt; (dim(y0)[1])) {
    y0 &lt;- y0[na.y0 &lt; r2.na, ]
    na.y0 &lt;- apply(y0[, 2:(1 + m0)], 1, function(xx) sum(is.na(xx)) / length(xx))
  }
  num.na &lt;- sum(is.na(y0[, 2:(1 + m0)]))
  message("#{NA}=", num.na, "\n", "r1.na =", r1.na, ", r2.na =", r2.na, "\n")
}

# ===============
# combine drug sensitivity, tissues and molecular features
# ===============
yx &lt;- merge(y0, features, by = "Cell.Line")
names.cell.line &lt;- yx$Cell.Line
names.drug &lt;- colnames(yx)[2:(dim(y0)[2])]
names.drug &lt;- substr(names.drug, 6, nchar(names.drug))
# numbers of gene expression features, copy number festures and muatation features
p &lt;- c(13321, 13747 - 13321, 13818 - 13747)
num.nonpen &lt;- 13
yx &lt;- data.matrix(yx[, -1])
y &lt;- yx[, 1:(dim(y0)[2] - 1)]
x &lt;- cbind(yx[, dim(y0)[2] - 1 + sum(p) + 1:num.nonpen], yx[, dim(y0)[2] - 1 + 1:sum(p)])

# delete genes with only one mutated cell line
x &lt;- x[, 
  -c(num.nonpen + p[1] + p[2] + which(colSums(x[, num.nonpen + p[1] + p[2] + 1:p[3]]) &lt;= 1))]
p[3] &lt;- ncol(x) - num.nonpen - p[1] - p[2]

GDSC &lt;- list(
  y = y, x = x, p = p, num.nonpen = num.nonpen, names.cell.line = names.cell.line,
  names.drug = names.drug
)


## ================
## ================
## select a small set of drugs
## ================
## ================

name_drugs &lt;- c(
  "Methotrexate", "RDEA119", "PD-0325901", "CI-1040", "AZD6244", "Nilotinib",
  "Axitinib"
)

# extract the drugs' pharmacological profiling and tissue dummy
YX0 &lt;- cbind(GDSC$y[, colnames(GDSC$y) %in% paste("IC50.", name_drugs, sep = "")]
[, c(1, 3, 6, 4, 7, 2, 5)], GDSC$x[, 1:GDSC$num.nonpen])
colnames(YX0) &lt;- c(name_drugs, colnames(GDSC$x)[1:GDSC$num.nonpen])
# extract the genetic information of CNV &amp; MUT
X23 &lt;- GDSC$x[, GDSC$num.nonpen + GDSC$p[1] + 1:(p[2] + p[3])]
colnames(X23)[1:p[2]] &lt;- paste(substr(
  colnames(X23)[1:p[2]], 1,
  nchar(colnames(X23)[1:p[2]]) - 3
), ".CNV", sep = "")

# locate all genes with CNV or MUT information
name_genes_duplicate &lt;- c(
  substr(colnames(X23)[1:p[2]], 1, nchar(colnames(X23)[1:p[2]]) - 4),
  substr(colnames(X23)[p[2] + 1:p[3]], 1, nchar(colnames(X23)[p[2] + 1:p[3]]) - 4)
)
name_genes &lt;- name_genes_duplicate[!duplicated(name_genes_duplicate)]

# select the GEX which have the common genes with CNV or MUT
X1 &lt;- 
  GDSC$x[, GDSC$num.nonpen + which(colnames(GDSC$x)[GDSC$num.nonpen + 1:p[1]] %in% name_genes)]

p[1] &lt;- ncol(X1)
X1 &lt;- log(X1)

# summary the data information
exampleGDSC &lt;- list(data = cbind(YX0, X1, X23))
exampleGDSC$blockList &lt;- list(
  1:length(name_drugs), length(name_drugs) + 1:GDSC$num.nonpen,
  ncol(YX0) + 1:sum(p)
)

# ========================
# construct the G matrix: edge potentials in the MRF prior
# ========================

# edges between drugs: Group1 ("RDEA119","17-AAG","PD-0325901","CI-1040" and "AZD6244")
# indexed as (2:5)
# http://software.broadinstitute.org/gsea/msigdb/cards/KEGG_MAPK_SIGNALING_PATHWAY
pathway_genes &lt;- read.table("MAPK_pathway.txt")[[1]]
Idx_Pathway1 &lt;- which(c(colnames(X1), name_genes_duplicate) %in% pathway_genes)
Gmrf_Group1Pathway1 &lt;- t(combn(rep(Idx_Pathway1, each = length(2:5)) +
  rep((2:5 - 1) * sum(p), times = length(Idx_Pathway1)), 2))

# edges between drugs: Group2 ("Nilotinib","Axitinib") indexed as (6:7)
# delete gene ABL2
Idx_Pathway2 &lt;- which(c(colnames(X1), name_genes_duplicate) %like% "BCR" |
  c(colnames(X1), name_genes_duplicate) %like% "ABL")[-c(3, 5)]
Gmrf_Group2Pathway2 &lt;- t(combn(rep(Idx_Pathway2, each = length(6:7)) +
  rep((6:7 - 1) * sum(p), times = length(Idx_Pathway2)), 2))

# edges between the common gene in different data sources
Gmrf_CommonGene &lt;- NULL
list_CommonGene &lt;- list(0)
k &lt;- 1
for (i in 1:length(name_genes)) {
  Idx_CommonGene &lt;- which(c(colnames(X1), name_genes_duplicate) == name_genes[i])
  if (length(Idx_CommonGene) &gt; 1) {
    Gmrf_CommonGene &lt;- rbind(Gmrf_CommonGene, 
    t(combn(rep(Idx_CommonGene, each = length(name_drugs))
    + rep((1:length(name_drugs) - 1) * sum(p), times = length(Idx_CommonGene)), 2)))
    k &lt;- k + 1
  }
}
Gmrf_duplicate &lt;- rbind(Gmrf_Group1Pathway1, Gmrf_Group2Pathway2, Gmrf_CommonGene)
Gmrf &lt;- Gmrf_duplicate[!duplicated(Gmrf_duplicate), ]
exampleGDSC$mrfG &lt;- Gmrf

# create the target gene names of the two groups of drugs
targetGenes1 &lt;- matrix(Idx_Pathway1, nrow = 1)
colnames(targetGenes1) &lt;- colnames(exampleGDSC$data)[seq_along(targetGene$group1)]
targetGenes2 &lt;- matrix(Idx_Pathway2, nrow = 1)
colnames(targetGenes2) &lt;- colnames(exampleGDSC$data)[seq_along(targetGene$group2)]

targetGene &lt;- list(group1 = targetGenes1, group2 = targetGenes2)

## Write data file exampleGDSC.rda to the user's directory by save()

## End(Not run)

</code></pre>

<hr>
<h2 id='fitted.BayesSUR'>get fitted responses</h2><span id='topic+fitted.BayesSUR'></span>

<h3>Description</h3>

<p>Return the fitted response values that correspond to the posterior mean 
estimates from a <code>BayesSUR</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesSUR'
fitted(object, Pmax = 0, beta.type = "marginal", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.BayesSUR_+3A_object">object</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="fitted.BayesSUR_+3A_pmax">Pmax</code></td>
<td>
<p>valid if <code>beta.type="conditional"</code>. If 
<code>beta.type="conditional"</code> and <code>Pmax=0.5</code>, it gives median 
probability model betas. Default is 0</p>
</td></tr>
<tr><td><code id="fitted.BayesSUR_+3A_beta.type">beta.type</code></td>
<td>
<p>type of estimated beta for the fitted model. Default is 
<code>marginal</code>, giving marginal beta estimation. If 
<code>beta.type="conditional"</code>, it gives beta estimation conditional 
on gamma=1</p>
</td></tr>
<tr><td><code id="fitted.BayesSUR_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fitted values extracted from an object of class <code>BayesSUR</code>. If 
the <code>BayesSUR</code> specified data standardization, the fitted values are 
base based on standardized data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check fitted values
fitted.val &lt;- fitted(fit)

</code></pre>

<hr>
<h2 id='getEstimator'>extract the posterior mean of parameters</h2><span id='topic+getEstimator'></span>

<h3>Description</h3>

<p>Extract the posterior mean of the parameters of a <code>BayesSUR</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEstimator(object, estimator = "gamma", Pmax = 0, beta.type = "marginal")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getEstimator_+3A_object">object</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="getEstimator_+3A_estimator">estimator</code></td>
<td>
<p>the name of one estimator. Default is the latent indicator 
estimator &quot;<code>gamma</code>&quot;. Other options &quot;<code>beta</code>&quot;, &quot;<code>Gy</code>&quot;, 
&quot;<code>CPO</code>&quot; and &quot;<code>logP</code>&quot;
correspond the marginal (conditional) coefficient matrix if 
<code>beta.type="marginal"</code>(<code>"conditional"</code>), response graph and 
conditional predictive ordinate (CPO) respectively</p>
</td></tr>
<tr><td><code id="getEstimator_+3A_pmax">Pmax</code></td>
<td>
<p>threshold that truncate the estimator &quot;<code>gamma</code>&quot; or 
&quot;<code>Gy</code>&quot;. Default is <code>0</code>. If <code>Pmax=0.5</code> and 
<code>beta.type="conditional"</code>, it gives median probability model betas</p>
</td></tr>
<tr><td><code id="getEstimator_+3A_beta.type">beta.type</code></td>
<td>
<p>the type of output beta. Default is <code>marginal</code>, giving 
marginal beta estimation. If <code>beta.type="conditional"</code>, it gives beta 
estimation conditional on gamma=1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the estimator from an object of class <code>BayesSUR</code>. It is 
a matrix if the length of argument <code>marginal</code> is greater than 1. 
Otherwise, it is a list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check output
# extract the posterior mean of the coefficients matrix
beta_hat &lt;- getEstimator(fit, estimator = "beta")

</code></pre>

<hr>
<h2 id='plot.BayesSUR'>create a selection of plots</h2><span id='topic+plot.BayesSUR'></span>

<h3>Description</h3>

<p>plot method for class <code>BayesSUR</code>. This is the main plot function to be 
called by the user. This function calls one or several of the following 
functions: <code>plotEstimator()</code>, <code>plotGraph()</code>, <code>plotMCMCdiag()</code>, 
<code>plotManhattan()</code>, <code>plotNetwork()</code>, <code>plotCPO()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesSUR'
plot(x, estimator = NULL, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.BayesSUR_+3A_x">x</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="plot.BayesSUR_+3A_estimator">estimator</code></td>
<td>
<p>It is in <code>c(NULL, 'beta', 'gamma', 'Gy', 'logP', 'CPO')</code> 
and works by combining with argument <code>type</code>.
</p>

<ul>
<li><p> If <code>estimator</code> is in <code>c("beta", "gamma", "Gy")</code> and 
argument <code>type="heatmap"</code>, it prints heatmaps of the specified 
estimator in <code>estimator</code> by a call to to function 
<code>plotEstimator()</code> for more other arguments.
</p>
</li>
<li><p> If <code>estimator="Gy"</code> and argument <code>type="graph"</code>, it prints 
a structure graph of <code>"Gy"</code> by a call to function <code>plotGraph()</code> 
for more other arguments.
</p>
</li>
<li><p> If <code>estimator=c("gamma", "Gy")</code> and argument 
<code>type="network"</code>, it prints the estimated network between the 
response variables and predictors with nonzero coefficients by a call to 
function <code>plotMCMCdiag()</code> for more other arguments.
</p>
</li>
<li><p> If <code>estimator=NULL</code> (default) and <code>type=NULL</code> (default), 
it interactively prints the plots of estimators (i.e., beta, gamma 
and (or) Gy), response graph Gy, network, Manhattan and MCMC diagnostics.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.BayesSUR_+3A_type">type</code></td>
<td>
<p>It is one of <code>NULL</code>, <code>"heatmap"</code>, <code>"graph"</code>, 
<code>"network"</code>, <code>"Manhattan"</code> and <code>"diagnostics"</code>, and works by 
combining with argument <code>estimator</code>.
</p>

<ul>
<li><p> If <code>type="Manhattan"</code> and argument <code>estimator="gamma"</code>, 
it prints Manhattan-like plots for marginal posterior inclusion 
probabilities (mPIP) and numbers of associated response variables for 
individual predictors by a call to function <code>plotManhattan()</code> for 
more other arguments.
</p>
</li>
<li><p> If <code>type="diagnostics"</code> and argument <code>estimator="logP"</code> 
it shows trace plots and diagnostic density plots of a fitted model by a 
call to function <code>plotMCMCdiag()</code> for more other arguments.
</p>
</li>
<li><p> If <code>type="diagnostics"</code> and argument <code>estimator="CPO"</code>, 
it shows the conditional predictive ordinate (CPO) for each individual of 
a fitted model by a call to function <code>plotCPO()</code> for more other arguments.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.BayesSUR_+3A_...">...</code></td>
<td>
<p>other arguments, see functions <code>plotEstimator()</code>, 
<code>plotGraph()</code>, <code>plotNetwork()</code>, <code>plotManhattan()</code>, 
<code>plotMCMCdiag()</code> or <code>plotCPO()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 2, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check output
## Not run: 
## Show the interactive plots. Note that it needs at least 2000*(nbloc+1) iterations
## for the diagnostic plots where nbloc=3 by default
# plot(fit)

## End(Not run)

## plot heatmaps of the estimated beta, gamma and Gy
plot(fit, estimator = c("beta", "gamma", "Gy"), type = "heatmap")

## plot estimated graph of responses Gy
plot(fit, estimator = "Gy", type = "graph")

## plot network between response variables and associated predictors
plot(fit, estimator = c("gamma", "Gy"), type = "network")

## print Manhattan-like plots
plot(fit, estimator = "gamma", type = "Manhattan")

## print MCMC diagnostic plots
#plot(fit, estimator = "logP", type = "diagnostics")

</code></pre>

<hr>
<h2 id='plotCPO'>plot conditional predictive ordinate</h2><span id='topic+plotCPO'></span>

<h3>Description</h3>

<p>Plot the conditional predictive ordinate (CPO) for each individual of a 
fitted model generated by <code>BayesSUR</code> which is a <code>BayesSUR</code> object. 
CPO is a handy posterior predictive check because it may be used to identify 
outliers, influential observations, and for hypothesis testing across 
different non-nested models (Gelfand 1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCPO(
  x,
  outlier.mark = TRUE,
  outlier.thresh = 0.01,
  scale.CPO = TRUE,
  x.loc = FALSE,
  axis.label = NULL,
  las = 0,
  cex.axis = 1,
  mark.pos = c(0, -0.01),
  mark.color = 2,
  mark.cex = 0.8,
  xlab = "Observations",
  ylab = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCPO_+3A_x">x</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="plotCPO_+3A_outlier.mark">outlier.mark</code></td>
<td>
<p>mark the outliers with the response names. 
The default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotCPO_+3A_outlier.thresh">outlier.thresh</code></td>
<td>
<p>threshold for the CPOs. The default is 0.01.</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_scale.cpo">scale.CPO</code></td>
<td>
<p>scaled CPOs which is divided by their maximum. 
The default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plotCPO_+3A_x.loc">x.loc</code></td>
<td>
<p>a vector of features distance</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_axis.label">axis.label</code></td>
<td>
<p>a vector of predictor names which are shown in CPO plot. 
The default is <code>NULL</code> only showing the indices. The value <code>"auto"</code> 
show the predictor names from the original data.</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_las">las</code></td>
<td>
<p>graphical parameter of plot.default</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_cex.axis">cex.axis</code></td>
<td>
<p>graphical parameter of plot.default</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_mark.pos">mark.pos</code></td>
<td>
<p>location of the marked text relative to the point</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_mark.color">mark.color</code></td>
<td>
<p>color of the marked text. The default color is red</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_mark.cex">mark.cex</code></td>
<td>
<p>font size of the marked text. The default font size is 0.8</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis</p>
</td></tr>
<tr><td><code id="plotCPO_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default threshold for the CPOs to detect the outliers is 0.01 
by Congdon (2005). It can be tuned by the argument <code>outlier.thresh</code>.
</p>


<h3>References</h3>

<p>Statisticat, LLC (2013). <em>Bayesian Inference.</em> Farmington, CT: Statisticat, LLC.
</p>
<p>Gelfand A. (1996). <em>Model Determination Using Sampling Based Methods</em>. In Gilks W., Richardson S., Spiegelhalter D. (eds.), Markov Chain Monte Carlo in Practice, pp. 145–161. Chapman &amp; Hall, Boca Raton, FL.
</p>
<p>Congdon P. (2005). <em>Bayesian Models for Categorical Data</em>. John Wiley &amp; Sons, West Sussex, England.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/", output_CPO = TRUE
)

## check output
# plot the conditional predictive ordinate (CPO)
plotCPO(fit)

</code></pre>

<hr>
<h2 id='plotEstimator'>plot heatmap of estimators</h2><span id='topic+plotEstimator'></span>

<h3>Description</h3>

<p>Plot the posterior mean estimators from a <code>BayesSUR</code> class object, 
including the coefficients beta, latent indicator variable gamma and 
graph of responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEstimator(
  x,
  estimator = NULL,
  colorScale.gamma = grey((100:0)/100),
  colorScale.beta = c("blue", "white", "red"),
  legend.cex.axis = 1,
  name.responses = NA,
  name.predictors = NA,
  xlab = "",
  ylab = "",
  fig.tex = FALSE,
  output = "ParamEstimator",
  header = "",
  header.cex = 2,
  tick = FALSE,
  mgp = c(2.5, 1, 0),
  cex.main = 1.5,
  title.beta = NA,
  title.gamma = NA,
  title.Gy = NA,
  beta.type = "marginal",
  Pmax = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotEstimator_+3A_x">x</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_estimator">estimator</code></td>
<td>
<p>print the heatmap of estimators. The value &quot;beta&quot; is for 
the estimated coefficients matrix, &quot;gamma&quot; for the latent indicator matrix 
and &quot;Gy&quot; for the graph of responses</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_colorscale.gamma">colorScale.gamma</code></td>
<td>
<p>value palette for gamma</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_colorscale.beta">colorScale.beta</code></td>
<td>
<p>a vector of three colors for diverging color schemes</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_legend.cex.axis">legend.cex.axis</code></td>
<td>
<p>magnification of axis annotation relative to cex</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_name.responses">name.responses</code></td>
<td>
<p>a vector of the response names. The default is 
<code>NA</code> only to show the locations. The value <code>"auto"</code> show the 
response names from the orginal data.</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_name.predictors">name.predictors</code></td>
<td>
<p>a vector of the predictor names. The default is 
<code>NA</code> only to show the locations. The value <code>"auto"</code> show the 
predictor names from the orginal data.</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_fig.tex">fig.tex</code></td>
<td>
<p>print the figure through LaTex. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_output">output</code></td>
<td>
<p>the file name of printed figure</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_header">header</code></td>
<td>
<p>the main title</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_header.cex">header.cex</code></td>
<td>
<p>size of the main title for all estimators</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_tick">tick</code></td>
<td>
<p>a logical value specifying whether tickmarks and an axis line 
should be drawn. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_mgp">mgp</code></td>
<td>
<p>the margin line (in mex units) for the axis title, axis labels 
and axis line</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_cex.main">cex.main</code></td>
<td>
<p>size of the title for each estimator</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_title.beta">title.beta</code></td>
<td>
<p>a title for the printed &quot;beta&quot;</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_title.gamma">title.gamma</code></td>
<td>
<p>a title for the printed &quot;gamma&quot;</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_title.gy">title.Gy</code></td>
<td>
<p>a title for the printed &quot;Gy&quot;</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_beta.type">beta.type</code></td>
<td>
<p>the type of output beta. Default is <code>marginal</code>, giving 
marginal beta estimation. If <code>beta.type="conditional"</code>, it gives beta 
estimation conditional on gamma=1</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_pmax">Pmax</code></td>
<td>
<p>threshold that truncate the estimator &quot;<code>gamma</code>&quot; or 
&quot;<code>Gy</code>&quot;. Default is <code>0</code>. If <code>Pmax=0.5</code> and 
<code>beta.type="conditional"</code>, it gives median probability model betas</p>
</td></tr>
<tr><td><code id="plotEstimator_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check output
# Plot the estimators from the fitted object
plotEstimator(fit, estimator = c("beta", "gamma", "Gy"))

## Not run: 
## Set up temporary work directory for saving a pdf figure
# td &lt;- tempdir()
# oldwd &lt;- getwd()
# setwd(td)

## Produce authentic math formulas in the graph
# plotEstimator(fit, estimator = c("beta", "gamma", "Gy"), fig.tex = TRUE)
# system(paste(getOption("pdfviewer"), "ParamEstimator.pdf"))
# setwd(oldwd)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotGraph'>plot graph for response variables</h2><span id='topic+plotGraph'></span>

<h3>Description</h3>

<p>Plot the estimated graph for multiple response variables from a 
<code>BayesSUR</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGraph(
  x,
  Pmax = 0.5,
  main = "Estimated graph of responses",
  edge.width = 2,
  edge.weight = FALSE,
  vertex.label = NULL,
  vertex.label.color = "black",
  vertex.size = 30,
  vertex.color = "dodgerblue",
  vertex.frame.color = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGraph_+3A_x">x</code></td>
<td>
<p>either an object of class <code>BayesSUR</code> (default) or a symmetric 
numeric matrix representing an adjacency matrix for a given graph structure.
If x is an adjacency matrix, argument <code>main="Given graph of responses"</code> 
by default.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_pmax">Pmax</code></td>
<td>
<p>a value for thresholding the learning structure matrix of 
multiple response variables. Default is 0.5</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_main">main</code></td>
<td>
<p>an overall title for the plot</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_edge.width">edge.width</code></td>
<td>
<p>edge width. Default is 2</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_edge.weight">edge.weight</code></td>
<td>
<p>draw weighted edges after thresholding at 0.5. The 
default value <code>FALSE</code> is not to draw weighted edges</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_vertex.label">vertex.label</code></td>
<td>
<p>character vector used to label the nodes</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>label color. Default is <code>"black"</code></p>
</td></tr>
<tr><td><code id="plotGraph_+3A_vertex.size">vertex.size</code></td>
<td>
<p>node size. Default is 30</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_vertex.color">vertex.color</code></td>
<td>
<p>node color. Default is <code>"dodgerblue"</code></p>
</td></tr>
<tr><td><code id="plotGraph_+3A_vertex.frame.color">vertex.frame.color</code></td>
<td>
<p>node color. Default is <code>"NA"</code></p>
</td></tr>
<tr><td><code id="plotGraph_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check output
# show the graph relationship between responses
plotGraph(fit, estimator = "Gy")

</code></pre>

<hr>
<h2 id='plotManhattan'>plot Manhattan-like plots</h2><span id='topic+plotManhattan'></span>

<h3>Description</h3>

<p>Plot Manhattan-like plots for marginal posterior inclusion probabilities 
(mPIP) and numbers of responses of association for predictors of a 
<code>BayesSUR</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotManhattan(
  x,
  manhattan = c("mPIP", "numResponse"),
  x.loc = FALSE,
  axis.label = "auto",
  mark.responses = NULL,
  xlab1 = "Predictors",
  ylab1 = "mPIP",
  xlab2 = "Predictors",
  ylab2 = "No. of responses",
  threshold = 0.5,
  las = 0,
  cex.axis = 1,
  mark.pos = c(0, 0),
  mark.color = 2,
  mark.cex = 0.8,
  header = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotManhattan_+3A_x">x</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_manhattan">manhattan</code></td>
<td>
<p>value(s) in <code>c('mPIP', 'numResponse')</code>. 
<code>manhattan='mPIP'</code> shows the Manhattan-like plot of the marginal 
posterior inclusion probabilities (mPIP). <code>manhattan='numResponse'</code> 
shows the Manhattan-like plot of the number of responses. The default is 
to show both figures.</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_x.loc">x.loc</code></td>
<td>
<p>a vector of features distance</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_axis.label">axis.label</code></td>
<td>
<p>a vector of predictor names which are shown in the 
Manhattan-like plot. The value <code>"NULL"</code> only showing the indices. The 
default <code>"auto"</code> show the predictor names from the original data.</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_mark.responses">mark.responses</code></td>
<td>
<p>a vector of response names which are shown in the 
Manhattan-like plot for the mPIP</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_xlab1">xlab1</code></td>
<td>
<p>a title for the x axis of Manhattan-like plot for the mPIP</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_ylab1">ylab1</code></td>
<td>
<p>a title for the y axis of Manhattan-like plot for the mPIP</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_xlab2">xlab2</code></td>
<td>
<p>a title for the x axis of Manhattan-like plot for the numbers of responses</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_ylab2">ylab2</code></td>
<td>
<p>a title for the y axis of Manhattan-like plot for the numbers of responses</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_threshold">threshold</code></td>
<td>
<p>threshold for showing number of response variables 
significantly associated with each feature</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_las">las</code></td>
<td>
<p>graphical parameter of plot.default</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_cex.axis">cex.axis</code></td>
<td>
<p>graphical parameter of plot.default</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_mark.pos">mark.pos</code></td>
<td>
<p>the location of the marked text relative to the point</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_mark.color">mark.color</code></td>
<td>
<p>the color of the marked text. The default color is red.</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_mark.cex">mark.cex</code></td>
<td>
<p>the fontsize of the marked text. The default fontsize is 0.8</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_header">header</code></td>
<td>
<p>the main title</p>
</td></tr>
<tr><td><code id="plotManhattan_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check output
# show the Manhattan-like plots
plotManhattan(fit)

</code></pre>

<hr>
<h2 id='plotMCMCdiag'>plot MCMC diagnostic plots</h2><span id='topic+plotMCMCdiag'></span>

<h3>Description</h3>

<p>Show trace plots and diagnostic density plots of a fitted model object of class <code>BayesSUR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMCMCdiag(x, nbloc = 3, HIWg = NULL, header = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMCMCdiag_+3A_x">x</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="plotMCMCdiag_+3A_nbloc">nbloc</code></td>
<td>
<p>number of splits for the last half iterations after substracting 
burn-in length</p>
</td></tr>
<tr><td><code id="plotMCMCdiag_+3A_hiwg">HIWg</code></td>
<td>
<p>diagnostic plot of the response graph. Default is <code>NULL</code>. 
<code>HIW="degree"</code> prints the diagnostic of the degrees of response nodes. 
<code>HIW="edges"</code> prints the diagnostic of every edge between two responses. 
<code>HIW="lik"</code> prints the diagnostic of the posterior likelihoods of the 
hyperparameters related to the response relationships</p>
</td></tr>
<tr><td><code id="plotMCMCdiag_+3A_header">header</code></td>
<td>
<p>the main title</p>
</td></tr>
<tr><td><code id="plotMCMCdiag_+3A_...">...</code></td>
<td>
<p>other arguments for the plots of the log-likelihood and model size</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check output
plotMCMCdiag(fit)

</code></pre>

<hr>
<h2 id='plotNetwork'>plot network representation of the associations between responses and predictors</h2><span id='topic+plotNetwork'></span>

<h3>Description</h3>

<p>Plot the network representation of the associations between responses and 
predictors, based on the estimated gamma matrix and graph of responses 
from a &quot;BayesSUR&quot; class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotNetwork(
  x,
  includeResponse = NULL,
  excludeResponse = NULL,
  includePredictor = NULL,
  excludePredictor = NULL,
  MatrixGamma = NULL,
  PmaxPredictor = 0.5,
  PmaxResponse = 0.5,
  nodesizePredictor = 2,
  nodesizeResponse = 15,
  no.isolates = FALSE,
  lineup = 1.2,
  gray.alpha = 0.6,
  edgewith.response = 5,
  edgewith.predictor = 2,
  edge.weight = FALSE,
  label.predictor = NULL,
  label.response = NULL,
  color.predictor = NULL,
  color.response = NULL,
  name.predictors = NULL,
  name.responses = NULL,
  vertex.frame.color = NA,
  layoutInCircle = FALSE,
  header = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotNetwork_+3A_x">x</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_includeresponse">includeResponse</code></td>
<td>
<p>A vector of the response names which are shown in the network</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_excluderesponse">excludeResponse</code></td>
<td>
<p>A vector of the response names which are not shown in the network</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_includepredictor">includePredictor</code></td>
<td>
<p>A vector of the predictor names which are shown in the network</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_excludepredictor">excludePredictor</code></td>
<td>
<p>A vector of the predictor names which are not shown in the network</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_matrixgamma">MatrixGamma</code></td>
<td>
<p>A matrix or dataframe of the latent indicator variable. 
Default is <code>NULL</code> and to extrate it from object of class inheriting 
from an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_pmaxpredictor">PmaxPredictor</code></td>
<td>
<p>cutpoint for thresholding the estimated latent 
indicator variable. Default is 0.5</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_pmaxresponse">PmaxResponse</code></td>
<td>
<p>cutpoint for thresholding the learning structure matrix 
of multiple response variables. Default is 0.5</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_nodesizepredictor">nodesizePredictor</code></td>
<td>
<p>node size of Predictors in the output graph. 
Default is 15</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_nodesizeresponse">nodesizeResponse</code></td>
<td>
<p>node size of response variables in the output graph. 
Default is 25</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_no.isolates">no.isolates</code></td>
<td>
<p>remove isolated nodes from responses graph and full 
graph, may get problem if there are also isolated Predictors</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_lineup">lineup</code></td>
<td>
<p>A ratio of the heights between responses' area and predictors'</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_gray.alpha">gray.alpha</code></td>
<td>
<p>the opacity. The default is 0.6</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_edgewith.response">edgewith.response</code></td>
<td>
<p>the edge width between response nodes</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_edgewith.predictor">edgewith.predictor</code></td>
<td>
<p>the edge width between the predictor and response node</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_edge.weight">edge.weight</code></td>
<td>
<p>draw weighted edges after thresholding at 0.5. The 
default value <code>FALSE</code> is not to draw weighted edges</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_label.predictor">label.predictor</code></td>
<td>
<p>A vector of the names of predictors</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_label.response">label.response</code></td>
<td>
<p>A vector of the names of response variables</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_color.predictor">color.predictor</code></td>
<td>
<p>color of the predictor nodes</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_color.response">color.response</code></td>
<td>
<p>color of the response nodes</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_name.predictors">name.predictors</code></td>
<td>
<p>A subtitle for the predictors</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_name.responses">name.responses</code></td>
<td>
<p>A subtitle for the responses</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_vertex.frame.color">vertex.frame.color</code></td>
<td>
<p>color of the frame of the vertices. If you don't 
want vertices to have a frame, supply NA as the color name</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_layoutincircle">layoutInCircle</code></td>
<td>
<p>place vertices on a circle, in the order of their 
vertex ids. The default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_header">header</code></td>
<td>
<p>the main title</p>
</td></tr>
<tr><td><code id="plotNetwork_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check output
# draw network representation of the associations between responses and covariates
plotNetwork(fit)

</code></pre>

<hr>
<h2 id='predict.BayesSUR'>predict method for class <code>BayesSUR</code></h2><span id='topic+predict.BayesSUR'></span>

<h3>Description</h3>

<p>Predict responses corresponding to the posterior mean of the coefficients, 
return posterior mean of coefficients or indices of nonzero coefficients of 
a <code>BayesSUR</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesSUR'
predict(object, newx, type = "response", beta.type = "marginal", Pmax = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.BayesSUR_+3A_object">object</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="predict.BayesSUR_+3A_newx">newx</code></td>
<td>
<p>Matrix of new values for x at which predictions are to be made</p>
</td></tr>
<tr><td><code id="predict.BayesSUR_+3A_type">type</code></td>
<td>
<p>Type of prediction required. <code>type="response"</code> gives the 
fitted responses; <code>type="coefficients"</code> returns the estimated 
coefficients depending on the arguments <code>beta.type</code> and <code>Pmax</code>.
<code>type="nonzero"</code> returns a list of the indices of the nonzero 
coefficients corresponding to the estimated latent indicator variable 
thresholding at <code>Pmax</code></p>
</td></tr>
<tr><td><code id="predict.BayesSUR_+3A_beta.type">beta.type</code></td>
<td>
<p>the type of estimated coefficients beta for prediction. 
Default is <code>marginal</code>, giving marginal beta estimation. If 
<code>beta.type="conditional"</code>, it gives conditional beta estimation</p>
</td></tr>
<tr><td><code id="predict.BayesSUR_+3A_pmax">Pmax</code></td>
<td>
<p>If <code>type="nonzero"</code>, it is a threshold for the estimated 
latent indicator variable. If <code>type="coefficients"</code>, 
<code>beta.type="conditional"</code> and <code>Pmax=0.5</code>, it gives median 
probability model betas. Default is 0</p>
</td></tr>
<tr><td><code id="predict.BayesSUR_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted values extracted from an object of class <code>BayesSUR</code>. 
If the <code>BayesSUR</code> specified data standardization, the fitted values 
are base based on standardized data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 20, burnin = 10, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/"
)

## check prediction
predict.val &lt;- predict(fit, newx = exampleEQTL[["blockList"]][[2]])

</code></pre>

<hr>
<h2 id='print.BayesSUR'>print method for class <code>BayesSUR</code></h2><span id='topic+print.BayesSUR'></span>

<h3>Description</h3>

<p>Print a short summary of a <code>BayesSUR</code> class object. It includes the 
argument matching information, number of selected predictors based on 
thresholding the posterior mean of the latent indicator variable at 0.5 
by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesSUR'
print(x, Pmax = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.BayesSUR_+3A_x">x</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="print.BayesSUR_+3A_pmax">Pmax</code></td>
<td>
<p>threshold that truncates the estimated coefficients based on 
thresholding the estimated latent indicator variable. Default is 0.5</p>
</td></tr>
<tr><td><code id="print.BayesSUR_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a short summary from an object of class <code>BayesSUR</code>, 
including the number of selected predictors with mPIP&gt;<code>Pmax</code> and the 
expected log pointwise predictive density estimates (i.e., elpd.LOO and 
elpd.WAIC).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("exampleEQTL", package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/", output_CPO = TRUE
)

## check output
# show the print information
print(fit)

</code></pre>

<hr>
<h2 id='summary.BayesSUR'>summary method for class <code>BayesSUR</code></h2><span id='topic+summary.BayesSUR'></span>

<h3>Description</h3>

<p>Summary method for class <code>BayesSUR</code>. It includes the argument matching 
information, Top predictors/responses on average mPIP across all 
responses/predictors, elpd estimates, MCMC specification, model 
specification and hyper-parameters. The summarized number of the selected 
variable corresponds to the posterior mean of the latent indicator variable 
thresholding at 0.5 by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BayesSUR'
summary(object, Pmax = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.BayesSUR_+3A_object">object</code></td>
<td>
<p>an object of class <code>BayesSUR</code></p>
</td></tr>
<tr><td><code id="summary.BayesSUR_+3A_pmax">Pmax</code></td>
<td>
<p>threshold that truncates the estimated coefficients based on 
thresholding the estimated latent indicator variable. Default is 0.5</p>
</td></tr>
<tr><td><code id="summary.BayesSUR_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a result summary from an object of class <code>BayesSUR</code>, 
including the CPOs, number of selected predictors with mPIP&gt;<code>Pmax</code>, 
top 10 predictors on average mPIP across all responses, top 10 responses on 
average mPIP across all predictors, Expected log pointwise predictive 
density (elpd) estimates, MCMC specification, model specification (i.e., 
covariance prior and gamma prior) and hyper-parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(exampleEQTL, package = "BayesSUR")
hyperpar &lt;- list(a_w = 2, b_w = 5)

set.seed(9173)
fit &lt;- BayesSUR(
  Y = exampleEQTL[["blockList"]][[1]],
  X = exampleEQTL[["blockList"]][[2]],
  data = exampleEQTL[["data"]], outFilePath = tempdir(),
  nIter = 10, burnin = 0, nChains = 1, gammaPrior = "hotspot",
  hyperpar = hyperpar, tmpFolder = "tmp/", output_CPO = TRUE
)

## check output
# show the summary information
summary(fit)

</code></pre>

<hr>
<h2 id='targetGene'>targetGene</h2><span id='topic+targetGene'></span>

<h3>Description</h3>

<p>Indices list of target genes corresponding the <code>example_GDSC</code> data set. 
It has two components representing the gene indices of the MAPK/ERK pathway and 
BCR-ABL gene fusion in the <code>example_GDSC</code> data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>targetGene
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the indices of gene targets from the GDSC sample dataset
data("targetGene", package = "BayesSUR")
str(targetGene)

## Not run: 
# ===============
# This code below is to do preprocessing of GDSC data and obtain the complete dataset
# "targetGene.rda" above. The user needs load the datasets from
# https://www.cancerrxgene.org release 5.
# But downloading and transforming the three used datasets below to *.csv files first.
# ===============

requireNamespace("plyr", quietly = TRUE)
requireNamespace("data.table", quietly = TRUE)


features &lt;- data.frame(read.csv("/gdsc_en_input_w5.csv", head = T))
names.fea &lt;- strsplit(rownames(features), "")
features &lt;- t(features)
p &lt;- c(13321, 13747 - 13321, 13818 - 13747)
Cell.Line &lt;- rownames(features)
features &lt;- data.frame(Cell.Line, features)

ic50_00 &lt;- data.frame(read.csv("gdsc_drug_sensitivity_fitted_data_w5.csv", head = T))
ic50_0 &lt;- ic50_00[, c(1, 4, 7)]
drug.id &lt;- data.frame(read.csv("gdsc_tissue_output_w5.csv", head = T))[, c(1, 3)]
drug.id2 &lt;- drug.id[!duplicated(drug.id$drug.id), ]
# delete drug.id=1066 since ID1066 and ID156 both correspond drug AZD6482,
# and no ID1066 in the "suppl.Data1" by Garnett et al. (2012)
drug.id2 &lt;- drug.id2[drug.id2$drug.id != 1066, ]
drug.id2$drug.name &lt;- as.character(drug.id2$drug.name)
drug.id2$drug.name &lt;- substr(drug.id2$drug.name, 1, nchar(drug.id2$drug.name) - 6)
drug.id2$drug.name &lt;- gsub(" ", "-", drug.id2$drug.name)

ic50 &lt;- ic50_0
# mapping the drug_id to drug names in drug sensitivity data set
ic50$drug_id &lt;- plyr::mapvalues(ic50$drug_id, from = drug.id2[, 2], to = drug.id2[, 1])
colnames(ic50) &lt;- c("Cell.Line", "compound", "IC50")

# transform drug sensitivity overall cell lines to a data matrix
y0 &lt;- reshape(ic50, v.names = "IC50", timevar = "compound", 
                    idvar = "Cell.Line", direction = "wide")
y0$Cell.Line &lt;- gsub("-", ".", y0$Cell.Line)

# ===============
# select nonmissing pharmacological data
# ===============
y00 &lt;- y0
m0 &lt;- dim(y0)[2] - 1
eps &lt;- 0.05
# r1.na is better to be not smaller than r2.na
r1.na &lt;- 0.3
r2.na &lt;- 0.2
k &lt;- 1
while (sum(is.na(y0[, 2:(1 + m0)])) &gt; 0) {
  r1.na &lt;- r1.na - eps / k
  r2.na &lt;- r1.na - eps / k
  k &lt;- k + 1
  ## select drugs with &lt;30% (decreasing with k) missing data overall cell lines
  na.y &lt;- apply(y0[, 2:(1 + m0)], 2, function(xx) sum(is.na(xx)) / length(xx))
  while (sum(na.y &lt; r1.na) &lt; m0) {
    y0 &lt;- y0[, -c(1 + which(na.y &gt;= r1.na))]
    m0 &lt;- sum(na.y &lt; r1.na)
    na.y &lt;- apply(y0[, 2:(1 + m0)], 2, function(xx) sum(is.na(xx)) / length(xx))
  }

  ## select cell lines with treatment of at least 80% (increasing with k) drugs
  na.y0 &lt;- apply(y0[, 2:(1 + m0)], 1, function(xx) sum(is.na(xx)) / length(xx))
  while (sum(na.y0 &lt; r2.na) &lt; (dim(y0)[1])) {
    y0 &lt;- y0[na.y0 &lt; r2.na, ]
    na.y0 &lt;- apply(y0[, 2:(1 + m0)], 1, function(xx) sum(is.na(xx)) / length(xx))
  }
  num.na &lt;- sum(is.na(y0[, 2:(1 + m0)]))
  message("#{NA}=", num.na, "\n", "r1.na =", r1.na, ", r2.na =", r2.na, "\n")
}

# ===============
# combine drug sensitivity, tissues and molecular features
# ===============
yx &lt;- merge(y0, features, by = "Cell.Line")
names.cell.line &lt;- yx$Cell.Line
names.drug &lt;- colnames(yx)[2:(dim(y0)[2])]
names.drug &lt;- substr(names.drug, 6, nchar(names.drug))
# numbers of gene expression features, copy number festures and muatation features
p &lt;- c(13321, 13747 - 13321, 13818 - 13747)
num.nonpen &lt;- 13
yx &lt;- data.matrix(yx[, -1])
y &lt;- yx[, 1:(dim(y0)[2] - 1)]
x &lt;- cbind(yx[, dim(y0)[2] - 1 + sum(p) + 1:num.nonpen], yx[, dim(y0)[2] - 1 + 1:sum(p)])

# delete genes with only one mutated cell line
x &lt;- x[, -c(num.nonpen + p[1] + p[2] + 
            which(colSums(x[, num.nonpen + p[1] + p[2] + 1:p[3]]) &lt;= 1))]
p[3] &lt;- ncol(x) - num.nonpen - p[1] - p[2]

GDSC &lt;- list(
  y = y, x = x, p = p, num.nonpen = num.nonpen, names.cell.line = names.cell.line,
  names.drug = names.drug
)


## ================
## ================
## select a small set of drugs
## ================
## ================

name_drugs &lt;- c(
  "Methotrexate", "RDEA119", "PD-0325901", "CI-1040", "AZD6244", "Nilotinib",
  "Axitinib"
)

# extract the drugs' pharmacological profiling and tissue dummy
YX0 &lt;- cbind(GDSC$y[, colnames(GDSC$y) %in% paste("IC50.", name_drugs, sep = "")]
[, c(1, 3, 6, 4, 7, 2, 5)], GDSC$x[, 1:GDSC$num.nonpen])
colnames(YX0) &lt;- c(name_drugs, colnames(GDSC$x)[1:GDSC$num.nonpen])
# extract the genetic information of CNV &amp; MUT
X23 &lt;- GDSC$x[, GDSC$num.nonpen + GDSC$p[1] + 1:(p[2] + p[3])]
colnames(X23)[1:p[2]] &lt;- paste(substr(
  colnames(X23)[1:p[2]], 1,
  nchar(colnames(X23)[1:p[2]]) - 3
), ".CNV", sep = "")

# locate all genes with CNV or MUT information
name_genes_duplicate &lt;- c(
  substr(colnames(X23)[1:p[2]], 1, nchar(colnames(X23)[1:p[2]]) - 4),
  substr(colnames(X23)[p[2] + 1:p[3]], 1, nchar(colnames(X23)[p[2] + 1:p[3]]) - 4)
)
name_genes &lt;- name_genes_duplicate[!duplicated(name_genes_duplicate)]

# select the GEX which have the common genes with CNV or MUT
X1 &lt;- GDSC$x[, GDSC$num.nonpen + 
            which(colnames(GDSC$x)[GDSC$num.nonpen + 1:p[1]] %in% name_genes)]

p[1] &lt;- ncol(X1)
X1 &lt;- log(X1)

# summary the data information
example_GDSC &lt;- list(data = cbind(YX0, X1, X23))
example_GDSC$blockList &lt;- list(
  1:length(name_drugs), length(name_drugs) + 1:GDSC$num.nonpen,
  ncol(YX0) + 1:sum(p))

# ========================
# construct the G matrix: edge potentials in the MRF prior
# ========================

# edges between drugs: Group1 ("RDEA119","17-AAG","PD-0325901","CI-1040" and "AZD6244")
# indexed as (2:5)
# http://software.broadinstitute.org/gsea/msigdb/cards/KEGG_MAPK_SIGNALING_PATHWAY
pathway_genes &lt;- read.table("MAPK_pathway.txt")[[1]]
Idx_Pathway1 &lt;- which(c(colnames(X1), name_genes_duplicate) %in% pathway_genes)
Gmrf_Group1Pathway1 &lt;- t(combn(rep(Idx_Pathway1, each = length(2:5)) +
  rep((2:5 - 1) * sum(p), times = length(Idx_Pathway1)), 2))

# edges between drugs: Group2 ("Nilotinib","Axitinib") indexed as (6:7)
# delete gene ABL2
Idx_Pathway2 &lt;- which(c(colnames(X1), name_genes_duplicate) %like% "BCR" |
  c(colnames(X1), name_genes_duplicate) %like% "ABL")[-c(3, 5)]
Gmrf_Group2Pathway2 &lt;- t(combn(rep(Idx_Pathway2, each = length(6:7)) +
  rep((6:7 - 1) * sum(p), times = length(Idx_Pathway2)), 2))

# edges between the common gene in different data sources
Gmrf_CommonGene &lt;- NULL
list_CommonGene &lt;- list(0)
k &lt;- 1
for (i in 1:length(name_genes)) {
  Idx_CommonGene &lt;- which(c(colnames(X1), name_genes_duplicate) == name_genes[i])
  if (length(Idx_CommonGene) &gt; 1) {
    Gmrf_CommonGene &lt;- 
    rbind(Gmrf_CommonGene, t(combn(rep(Idx_CommonGene, each = length(name_drugs)) + 
    rep((1:length(name_drugs) - 1) * sum(p), times = length(Idx_CommonGene)), 2)))
    k &lt;- k + 1
  }
}
Gmrf_duplicate &lt;- rbind(Gmrf_Group1Pathway1, Gmrf_Group2Pathway2, Gmrf_CommonGene)
Gmrf &lt;- Gmrf_duplicate[!duplicated(Gmrf_duplicate), ]
example_GDSC$mrfG &lt;- Gmrf

# create the target gene names of the two groups of drugs
targetGenes1 &lt;- matrix(Idx_Pathway1, nrow = 1)
colnames(targetGenes1) &lt;- colnames(example_GDSC$data)[seq_along(targetGene$group1)]
targetGenes2 &lt;- matrix(Idx_Pathway2, nrow = 1)
colnames(targetGenes2) &lt;- colnames(example_GDSC$data)[seq_along(targetGene$group2)]

targetGene &lt;- list(group1 = targetGenes1, group2 = targetGenes2)

## Write data file targetGene.rda to the user's directory by save()

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
