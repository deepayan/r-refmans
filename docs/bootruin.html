<!DOCTYPE html><html lang="en"><head><title>Help for package bootruin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bootruin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bootruin-package'><p>A Bootstrap Test for the Probability of Ruin in the Compound Poisson Risk process</p></a></li>
<li><a href='#pvaldens'><p>Density Estimation of Data in the Unit Interval</p></a></li>
<li><a href='#pvaldistance'><p>Distance Measures of Empirical Probability Functions</p></a></li>
<li><a href='#rpdataboot'><p>Creating Bootstrap Replications from an Matrix of Observations</p></a></li>
<li><a href='#rpdataconv'><p>Convert a List of Numerics to a Matrix</p></a></li>
<li><a href='#rpdatasim'><p>Simulating Data, Shaped into a Matrix</p></a></li>
<li><a href='#rpjack'><p>A Jackknife Estimator of the Standard Error of the Probability of Ruin</p></a></li>
<li><a href='#rppvalue'><p>P-values for the Test of the Probability of Ruin</p></a></li>
<li><a href='#rpteststat'><p>Computation of the Test Statistic for the Probability of Ruin</p></a></li>
<li><a href='#ruinprob'><p>The Probability of Ruin in the Classical Risk Process</p></a></li>
<li><a href='#ruinprob.test'><p>A Bootstrap Test for the Probability of Ruin in the Classical Risk Process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Bootstrap Test for the Probability of Ruin in the Classical
Risk Process</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-12-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Baumgartner &lt;benjamin@baumgrt.com&gt;, Riccardo Gatto &lt;gatto@stat.unibe.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Baumgartner &lt;benjamin@baumgrt.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a framework for testing the probability of ruin in the classical (compound Poisson) risk process. It also includes some procedures for assessing and comparing the performance between the bootstrap test and the test using asymptotic normality.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-12-30 16:36:44 UTC; benjamin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-12-30 19:39:15</td>
</tr>
</table>
<hr>
<h2 id='bootruin-package'>A Bootstrap Test for the Probability of Ruin in the Compound Poisson Risk process</h2><span id='topic+bootruin-package'></span>

<h3>Description</h3>

<p>This package provides a bootstrap test for the probability of ruin in the classical (compound
Poisson) risk process and some procedures for comparing the performance of the bootstrap test and
the test using the asymptotic normal approximation.
</p>


<h3>Details</h3>

<p>See the reference for more information.
</p>


<h3>Author(s)</h3>

<p>Benjamin Baumgartner <a href="mailto:benjamin@baumgrt.com">benjamin@baumgrt.com</a>,<br />
Riccardo Gatto <a href="mailto:gatto@stat.unibe.ch">gatto@stat.unibe.ch</a>
</p>


<h3>References</h3>

<p>Baumgartner, B. and Gatto, R. (2010) <em>A Bootstrap Test for the Probability of Ruin in the
Compound Poisson Risk Process</em>. ASTIN Bulletin, <b>40</b>(1), pp. 241&ndash;255.
</p>

<hr>
<h2 id='pvaldens'>Density Estimation of Data in the Unit Interval</h2><span id='topic+pvaldens'></span>

<h3>Description</h3>

<p>This function computes density estimators for densities with the unit interval as support.  One
example of data with such a density are p-values.  Currently, two methods are implemented that
differ in the kernel function used for estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvaldens(x, bw, rho, method = c("jh", "chen"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pvaldens_+3A_x">x</code></td>
<td>
<p>a numeric vector of data points between 0 and 1.</p>
</td></tr>
<tr><td><code id="pvaldens_+3A_bw">bw</code></td>
<td>
<p>a number indicating the bandwidth used for the density estimation.</p>
</td></tr>
<tr><td><code id="pvaldens_+3A_rho">rho</code></td>
<td>
<p>a number determining the correlation coefficient, only used if <code>method = "jh"</code></p>
</td></tr>
<tr><td><code id="pvaldens_+3A_method">method</code></td>
<td>
<p>a character string determining the kernel function that is used, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on which <code>method</code> is selected, a different kernel function is used for the
estimation.  Since the support of the estimated function is bounded, those kernel functions are
location-dependent.
</p>
<p>If <code>method = "jh"</code>, a Gaussian copula-based kernel function according to Jones and Henderson
(2007) is used. In this case the bandwidth can either be specified directly or as correlation
coefficient: if <code class="reqn">\rho&gt;0</code> denotes the correlation coefficient and <code class="reqn">h&gt;0</code> the
bandwidth, then <code class="reqn">h^2=1-\rho</code>. Note that <code>rho</code> and <code>bw</code> are mutually
exclusive.
</p>
<p>For <code>method = "chen"</code>, the kernel function is based on a beta density, according to Chen
(1999).
</p>
<p>See the cited articles for more details.
</p>


<h3>Value</h3>

<p>A function with a single vector-valued argument that returns the estimated density at any given
point(s).
</p>


<h3>References</h3>

<p>Jones, M. C. and Henderson, D. A. (2007) <em>Kernel-Type Density Estimation on the Unit
Interval</em>. Biometrika, <b>94</b>(4), pp. 977&ndash;984.
</p>
<p>Chen, S. X. (1999) <em>A Beta Kernel Estimation for Density Functions</em>. Computational Statistics
and Data Analysis, <b>31</b>(2), pp. 131&ndash;145.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

x &lt;- rbeta(100, 2, 5)
fhat &lt;- pvaldens(x, rho = 0.9, method = "jh")

hist(x, freq = FALSE, xlim = c(0, 1))
curve(fhat(x), from = 0, to = 1, add = TRUE, col = 2)
box()
</code></pre>

<hr>
<h2 id='pvaldistance'>Distance Measures of Empirical Probability Functions</h2><span id='topic+pvaldistance'></span>

<h3>Description</h3>

<p>This function provides a framework to evaluate various measures of distance between an empirical
distribution (induced by the dataset provided) and a theoretical probability distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pvaldistance(x, method = c("ks", "cvm"), dist.to = c("uniform"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pvaldistance_+3A_x">x</code></td>
<td>
<p>a numeric vector containing a data sample.</p>
</td></tr>
<tr><td><code id="pvaldistance_+3A_method">method</code></td>
<td>
<p>a character string indicating which measure of distance is computed.</p>
</td></tr>
<tr><td><code id="pvaldistance_+3A_dist.to">dist.to</code></td>
<td>
<p>a character string determining the (theoretical) probability distribution that is
used as a reference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method = "ks"</code> gives the Kolmogorov-Smirnov distance.
</p>
<p><code>method = "cvm"</code> yields the Cram√©r-von-Mises criterion (scaled with the sample size).
</p>


<h3>Value</h3>

<p>A positive real number giving the distance measure.
</p>


<h3>Note</h3>

<p>At the moment, <code>dist.to = "uniform"</code> (the uniform distribution on the unit interval) is the
only valid option for the theoretical distribution, and hence the members of <code>x</code> have to lie in
the unit interval.
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+ks.test">ks.test</a></code> for the Kolmogorov-Smirnov test.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A sample from the standard uniform distribution
x &lt;- runif(100, 0, 1)

# Distance to uniformity should be small
pvaldistance(x, "ks")
pvaldistance(x, "cvm")

# A sample from the Beta(2, 7) distribution
y &lt;- rbeta(100, 2, 7)

# Distance to uniformity should be much larger here
pvaldistance(y, "ks")
pvaldistance(y, "cvm")
</code></pre>

<hr>
<h2 id='rpdataboot'>Creating Bootstrap Replications from an Matrix of Observations</h2><span id='topic+rpdataboot'></span>

<h3>Description</h3>

<p>This function provides a simple way to create bootstrap replications of a dataset. The replication
is either non-parametrical or parametrical (for exponential or logarithmic normal data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpdataboot(x, b, method = c("nonp", "exp", "lnorm"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpdataboot_+3A_x">x</code></td>
<td>
<p>A matrix containing numeric values</p>
</td></tr>
<tr><td><code id="rpdataboot_+3A_b">b</code></td>
<td>
<p>The number of bootstrap replications</p>
</td></tr>
<tr><td><code id="rpdataboot_+3A_method">method</code></td>
<td>
<p>The replication method applied to the data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input matrix <code>x</code> is supposed to contain (independent) observations in each column. The
bootstrap replication take this into account is done column-wise.
</p>
<p>Depending on how the boostrap replications are further processed, the boostrap resampling should be
done either non-parametrically (<code>method = "nonp"</code>) or parametrically.
</p>
<p>In the non-parametrical case, the bootstrap replications are samples drawn from the empirical
distribution of the original observation, this is equivalent to drawing with replacement.
</p>
<p>For the parametrical bootstrap replications there are currently two options: With <code>method =
"exp"</code> each bootstrap replication is a vector simulated from an exponential distribution function
whose parameter is estimated by the original observation. For <code>method = "lnorm"</code> the resampling
is done by simulating from a logarithmic normal distribution whose log-mean and log-variance are
estimated from the original observation.
</p>


<h3>Value</h3>

<p>An array of dimension <code>c(dim(x), b)</code> containing column-wise bootstrap replications of <code>x</code>
</p>


<h3>Note</h3>

<p><code>NA</code>'s are propagated consistently. More precisely, only the non-<code>NA</code> values undergo the
resampling and thus, missing values remain unchanged in the bootstrap replications.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rpdataconv">rpdataconv</a></code> for creating a suitable data matrix from a list of observation vectors, and
<code><a href="#topic+rpdatasim">rpdatasim</a></code> for creating such a matrix by simulation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data matrix of 5 samples with 10 observations each.
x &lt;- matrix(rexp(50), nrow = 10, ncol = 5)

# Create (parametric) bootstrap replications
x.boot.par &lt;- bootruin:::rpdataboot(x, b = 50, method = "exp")

# Create (non-parametric) bootstrap replications
x.boot.nonp &lt;- bootruin:::rpdataboot(x, b = 50, method = "nonp")
</code></pre>

<hr>
<h2 id='rpdataconv'>Convert a List of Numerics to a Matrix</h2><span id='topic+rpdataconv'></span>

<h3>Description</h3>

<p>This function converts a list whose members are numeric vectors (possibly of different length) to a
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpdataconv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpdataconv_+3A_x">x</code></td>
<td>
<p>A list of numerics, a numeric vector or a matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the list entries do not have the same length, the shorter elements are <em>not</em> recycled, but
filled with <code>NA</code> instead.
</p>


<h3>Value</h3>

<p>A matrix whose columns contain the members of <code>x</code>.
</p>


<h3>Note</h3>

<p>For consistency, <code>x</code> can also be a numeric vector or matrix. The return value is then the same
as the one of <code><a href="base.html#topic+as.matrix">as.matrix</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+rpdatasim">rpdatasim</a></code> for creating a similar data matrix with simulated data, and
<code><a href="#topic+rpdataboot">rpdataboot</a></code> for creating boostrap replications of such a data matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gemerate samples of different size from an
# exponential distribution with different parameters
x &lt;- list(rexp(10, 0.2), rexp(7, 0.1), rexp(12, 0.5))

# Write x into a matrix that can be further processed
x.rp &lt;- bootruin:::rpdataconv(x)
</code></pre>

<hr>
<h2 id='rpdatasim'>Simulating Data, Shaped into a Matrix</h2><span id='topic+rpdatasim'></span>

<h3>Description</h3>

<p>This is a wrapper function for simulating data that have the correct structure for further
processing with <code><a href="#topic+rpdataboot">rpdataboot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpdatasim(n, replications, rdist, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpdatasim_+3A_n">n</code></td>
<td>
<p>The number of observations per sample</p>
</td></tr>
<tr><td><code id="rpdatasim_+3A_replications">replications</code></td>
<td>
<p>the number of samples/replications</p>
</td></tr>
<tr><td><code id="rpdatasim_+3A_rdist">rdist</code></td>
<td>
<p>A function for simulating random variables</p>
</td></tr>
<tr><td><code id="rpdatasim_+3A_...">...</code></td>
<td>
<p>Further arguments for <code>rdist</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with <code>n</code> rows and <code>replications</code> columns.
</p>


<h3>Note</h3>

<p>Typical choices for <code>rdist</code> are <code><a href="stats.html#topic+rexp">rexp</a></code> or <code><a href="stats.html#topic+rlnorm">rlnorm</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+rpdataconv">rpdataconv</a></code> for converting an existing dataset to a matrix, and
<code><a href="#topic+rpdataboot">rpdataboot</a></code> for creating boostrap replications of such a data matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 5 independent samples of size 10 from
# an exponential distribution with mean 10
x &lt;- bootruin:::rpdatasim(n = 10, replications = 5, rexp, rate = 1/10)
</code></pre>

<hr>
<h2 id='rpjack'>A Jackknife Estimator of the Standard Error of the Probability of Ruin</h2><span id='topic+rpjack'></span>

<h3>Description</h3>

<p>This function computes the jackknife estimator of the standard error of the estimator of the
probability of ruin given observed claims.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpjack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpjack_+3A_x">x</code></td>
<td>
<p>A vector or a matrix of numeric data.</p>
</td></tr>
<tr><td><code id="rpjack_+3A_...">...</code></td>
<td>
<p>Further options that are passed on to <code><a href="#topic+ruinprob">ruinprob</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a vector of observed claims, for each element of <code>x</code> the probability of ruin is
estimated with said element of <code>x</code> left out. The resulting vector of ruin probabilities has the
same length as <code>x</code>, and its standard error, properly rescaled, is used to approximate the
standard error of the estimator of the probability of ruin of <code>x</code>.
</p>
<p>This procedure is applied column-wise if <code>x</code> is a matrix.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>ncol(as.matrix(x))</code>.
</p>


<h3>Note</h3>

<p>The calculation of the jackknife standard error can be computationally intensive. In most cases the
computation time can be drastically reduced at the price of a slightly lower accuracy, viz. a higher
value for the <code>interval</code> argument of <code>ruinprob</code>.
</p>


<h3>References</h3>

<p>Efron, B. and Tibshirani, R. (1993) <em>An Introduction to the Bootstrap</em>. Chapman and Hall.
</p>
<p>Tukey, J. W. (1958) <em>Bias and Confidence in Not Quite Large Samples</em>. The Annals of
Mathematical Statistics, <b>29</b>(2), p. 614.
</p>
<p>Quenouille, M. H. (1956) <em>Note on Bias in Estimation</em>. Biometrika, <b>43</b>, pp. 353&ndash;360.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ruinprob">ruinprob</a></code> for valid options that can be used for <code>...</code>.
</p>

<hr>
<h2 id='rppvalue'>P-values for the Test of the Probability of Ruin</h2><span id='topic+rppvalue'></span>

<h3>Description</h3>

<p>This function provides p-values for the test of the probability of ruin using one of two different
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rppvalue(x, method = c("bootstrap", "normal"), x.boot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rppvalue_+3A_x">x</code></td>
<td>
<p>The observed values of the test statistic as numeric vector or matrix, see Details.</p>
</td></tr>
<tr><td><code id="rppvalue_+3A_method">method</code></td>
<td>
<p>A character string determining the method used.</p>
</td></tr>
<tr><td><code id="rppvalue_+3A_x.boot">x.boot</code></td>
<td>
<p>The bootstrap replications that <code>x</code> should be compared with, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is not intended to be used by itself, but rather in combination with
<code><a href="#topic+rpteststat">rpteststat</a></code>. Hence, ideally, both <code>x</code> and <code>x.boot</code> stem from a call of the
latter.
</p>
<p>If <code>method = "bootstrap"</code>, then bootstrap p-values are computed. The values of <code>x</code> are
compared to those of <code>x.boot</code>. The number of rows of <code>x.boot</code> has to match the number of
columns of <code>x</code> (or its length if it is a vector). For most applications, however, <code>x</code> will
be a single number and <code>x.boot</code> will be the bootstrap replications of <code>x</code>
</p>
<p>For <code>method = "normal"</code> the p-values are computed using the asymptotic normal approximation of
the test statistic. <code>x</code> can be a vector, a matrix or an array of numerics.
</p>
<p>The elements of <code>x</code> are interpreted as statistics of separate, independent tests, and adjusting
the p-values for multiple comparison may be necessary.
</p>


<h3>Value</h3>

<p>A numeric (vector, matrix or array) with the same dimension as <code>x</code>.
</p>


<h3>Note</h3>

<p>If <code>method = "normal"</code>, the argument <code>x.boot</code> is not used and a warning is issued if it is
still provided.
</p>


<h3>References</h3>

<p>Baumgartner, B. and Gatto, R. (2010) <em>A Bootstrap Test for the Probability of Ruin in the
Compound Poisson Risk Process</em>. ASTIN Bulletin, <b>40</b>(1), pp. 241&ndash;255.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+rpteststat">rpteststat</a></code> for the computation of the test statistics, <code><a href="#topic+ruinprob">ruinprob</a></code> for
computating the probability of ruin, and <code><a href="#topic+rpjack">rpjack</a></code> for the computation of the standard
errors.
</p>
<p><code><a href="stats.html#topic+p.adjust">p.adjust</a></code> from the package <span class="pkg">stats</span> provides methods to adjust p-values for
multiple testing.
</p>

<hr>
<h2 id='rpteststat'>Computation of the Test Statistic for the Probability of Ruin</h2><span id='topic+rpteststat'></span>

<h3>Description</h3>

<p>This function computes the test statistic for the test of the probability of ruin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rpteststat(x, x.null, se)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rpteststat_+3A_x">x</code></td>
<td>
<p>The observed/estimated probability of ruin</p>
</td></tr>
<tr><td><code id="rpteststat_+3A_x.null">x.null</code></td>
<td>
<p>The null probability of ruin</p>
</td></tr>
<tr><td><code id="rpteststat_+3A_se">se</code></td>
<td>
<p>The standard error of <code>x</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function studentizes (i.e., centers and rescales) the observed probabilities of ruin in a way
that they can be further processed by <code><a href="#topic+rppvalue">rppvalue</a></code>. This latter computes p-values for the
test with the null hypothesis that the probability of ruin is equal to <code>x.null</code> versus the
one-sided alternative that probability of ruin is smaller than <code>x.null</code>
</p>
<p>There are two possible scenarios how to use this function:
</p>
<p>The first one is to compute the test statistic for vector of estimated probabilities of ruin (where
each element corresponds to an independent sample of observed claims) using a pre-determined value
of <code>x.null</code>. In this case the output is a matrix with <code>length(x)</code> columns and
<code>length(x.null)</code> rows.
</p>
<p>The second use is to compute the bootstrap replications of the test statistic. In that case the
estimated probabilities of ruin are used for <code>x.null</code>, and the numbers of rows of <code>x</code> has
to match the length of <code>x.null</code>, i.e. there is one row of bootstrap replications of the
probability of ruin for each sample of claim sizes.
</p>


<h3>Value</h3>

<p>A numeric matrix that contains the test statistic. Its dimension depends on the input, see Details.
</p>


<h3>Note</h3>

<p>The dimensions (or lengths) of <code>x</code> and <code>se</code> have to be the same.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ruinprob">ruinprob</a></code> on how to obtain the estimators of the probabilities of ruin,
<code><a href="#topic+rpjack">rpjack</a></code> on how to get approximate standard errors of the former, and
<code><a href="#topic+rppvalue">rppvalue</a></code> on how to compute the p-values of the test described here.
</p>

<hr>
<h2 id='ruinprob'>The Probability of Ruin in the Classical Risk Process</h2><span id='topic+ruinprob'></span>

<h3>Description</h3>

<p>This function calculates or estimates the probability of ruin in the
classical (compund Poisson) risk process using several different methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruinprob(x, param.list, compmethod = c("dg", "exp"),
    flmethod = c("nonp", "exp", "lnorm", "custom"),
    reserve, loading, fl = NA, interval = 0.5,
    implementation = c("R", "C"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ruinprob_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix or array of individual claims.</p>
</td></tr>
<tr><td><code id="ruinprob_+3A_param.list">param.list</code></td>
<td>
<p>a named list of parameters. It might contain any of the
arguments except <code>x</code> and <code>...</code></p>
</td></tr>
<tr><td><code id="ruinprob_+3A_compmethod">compmethod</code></td>
<td>
<p>a character string determining the algorithm for the
computation.</p>
</td></tr>
<tr><td><code id="ruinprob_+3A_flmethod">flmethod</code></td>
<td>
<p>a character string indicating what cumulative probability
distribution function is used for the increments of the running
maximum of the aggregate loss process if <code>compmethod = "dg"</code>, see
also Details and References.</p>
</td></tr>
<tr><td><code id="ruinprob_+3A_reserve">reserve</code></td>
<td>
<p>a number indicating the initial surplus.</p>
</td></tr>
<tr><td><code id="ruinprob_+3A_loading">loading</code></td>
<td>
<p>a number determining the relative security loading.</p>
</td></tr>
<tr><td><code id="ruinprob_+3A_fl">fl</code></td>
<td>
<p>a function that is used as custom cumulative probability
distribution to be used for the discretization if
<code>flmethod = "custom"</code>.</p>
</td></tr>
<tr><td><code id="ruinprob_+3A_interval">interval</code></td>
<td>
<p>a number determining the approximation precision, viz. the
mesh width of the discretization if <code>compmethod = "dg"</code>, see
Details and References.</p>
</td></tr>
<tr><td><code id="ruinprob_+3A_implementation">implementation</code></td>
<td>
<p>a character string determining whether to use the
native implementation in R or the one in C.</p>
</td></tr>
<tr><td><code id="ruinprob_+3A_...">...</code></td>
<td>
<p>further arguments are passed to <code>fl</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classical risk process, also called Cram√©r-Lundberg risk process, is
a stochastic model for an insurer's surplus over time and, for any
<code class="reqn">t\ge0</code>, it is given by
</p>
<p style="text-align: center;"><code class="reqn">Y_{t} = r_{0} + ct - Z_{t},</code>
</p>

<p>where <code class="reqn">Z_{t}</code> is a compund Poisson process,
<code class="reqn">r_{0} \ge 0</code> is the initial surplus and <code class="reqn">c &gt; 0</code> is the
constant premium rate.
</p>
<p>This function calculates, approximates or estimates (depending on what
options are given) the probability of ruin in the infinite time horizon,
i.e. the probability that <code class="reqn">Y_{t}</code> ever falls below 0.
</p>
<p>Currently there are two options for the <code>compmethod</code> argument. If
<code>compmethod = "exp"</code>, the claims are assumed to be from an
exponential distribution. In that case, the probability of ruin is given
by
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{1 + \beta} \exp\left\{-\frac{\beta}{1+\beta} \frac{r_{0}}{\mu}\right\},</code>
</p>

<p>where <code class="reqn">\mu</code> is the mean claim size (estimated from <code>x</code>) and
<code class="reqn">\beta</code> is the relative security loading.
</p>
<p>For <code>compmethod = "dg"</code>, the recursive algorithm due to Dufresne and
Gerber (1989) is used.  In this case, the parameter <code>flmethod</code>
determines what cumulative distribution function is used for the
discretization. The possible choices are either a non-parametric
estimator, parametric estimators for exponential or log-normal claims, or
a user-supplied function (in which the argument <code>fl</code> must be
specified).  See the reference for more details on how this algorithm
works.
</p>


<h3>Value</h3>

<p>The estimated or calculated probability of ruin. The shape and dimension
of the output depends on the specifics of the claim data <code>x</code>. If
<code>x</code> is a vector, the output is a single numeric value. In general,
the dimension of the output is one less than that of <code>x</code>. More
precisely, if <code>x</code> is an array, then the output value is an array of
dimension <code>dim(x)[-1]</code>, see the note below.
</p>


<h3>Note</h3>

<p>If <code>x</code> is an array rather than a vector, the function acts as if it
was called through <code><a href="base.html#topic+apply">apply</a></code> with
<code>MARGIN = 2:length(dim(x))</code>
</p>
<p>If an option is given both explicitly and as part of the <code>param.list</code>
argument, then the value given explicitly takes precedence. This way the
parameter list, saved as a variable, can be reused, but modifications of
one or more parameter values are still possible.
</p>


<h3>References</h3>

<p>Dufresne, F. and Gerber, H.-U. (1989)
<em>Three Methods to Calculate the Probability of Ruin</em>.
ASTIN Bulletin, <b>19</b>(1), pp. 71&ndash;90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ruinprob.test">ruinprob.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Claims have an exponential distribution with mean 10
x &lt;- rexp(10, 0.1)
print(x)

# The estimated probability of ruin
ruinprob(x, reserve = 100, loading = 0.2, interval = 0.25)

# The true probability of ruin of the risk process
ruinprob(
    10, reserve = 100, loading = 0.2,
    flmethod = "exp", compmethod = "exp"
)
</code></pre>

<hr>
<h2 id='ruinprob.test'>A Bootstrap Test for the Probability of Ruin in the Classical Risk Process</h2><span id='topic+ruinprob.test'></span>

<h3>Description</h3>

<p>This function provides a testing framework for the probability of ruin in
the classical, compound Poisson risk process. The test can be performed
using the bootstrap method or using normal approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ruinprob.test(x, prob.null, type = c("bootstrap", "normal"),
    nboot, bootmethod = c("nonp", "exp", "lnorm"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ruinprob.test_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values (claims)</p>
</td></tr>
<tr><td><code id="ruinprob.test_+3A_prob.null">prob.null</code></td>
<td>
<p>a number indicating the hypothesized true probability of
ruin.</p>
</td></tr>
<tr><td><code id="ruinprob.test_+3A_type">type</code></td>
<td>
<p>a character string determining the type of test that is
performed.</p>
</td></tr>
<tr><td><code id="ruinprob.test_+3A_nboot">nboot</code></td>
<td>
<p>a number indicating the number of bootstrap replications.</p>
</td></tr>
<tr><td><code id="ruinprob.test_+3A_bootmethod">bootmethod</code></td>
<td>
<p>a character string determining how the bootstrap
replications are created.</p>
</td></tr>
<tr><td><code id="ruinprob.test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+ruinprob">ruinprob</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis is that the probability of ruin is equal to
<code>prob.null</code> versus the one-sided alternative that probability of ruin
is smaller than <code>prob.null</code>.
</p>
<p>If <code>type = "bootstrap"</code>, a bootstrap test is performed. The arguments
<code>nboot</code> and <code>bootmethod</code> have to be specified. <code>bootmethod</code>
determines the kind of bootstrap: <code>"nonp"</code> creates the usual
nonparametric bootstrap replications, while <code>"exp"</code> and
<code>"lnorm"</code> create parametric bootstrap replications, the former
assuming exponentially distributed claims, the latter log-normally
distributed ones.
</p>
<p><code>type = "normal"</code> makes use of an asymptotic normal approximation.
The computations are a lot faster, but from a theoretical point of view
the bootstrap method is more accurate, see References.
</p>
<p>For details about the necessary and valid arguments that might have to be
supplied for <code>...</code>, see <code><a href="#topic+ruinprob">ruinprob</a></code>.
</p>


<h3>Value</h3>

<p>A list with class <code>"htest"</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>the value of the studentized probability of ruin,
i.e. the test statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>the estimated probability of ruin.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the probability
of ruin.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was
performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Using the bootstrap method is computationally intensive. Values for
<code>nboot</code> should not be too large, usually numbers between 50 and 200
are reasonable choices.
</p>


<h3>References</h3>

<p>Baumgartner, B. and Gatto, R. (2010) <em>A Bootstrap Test for the
Probability of Ruin in the Compound Poisson Risk Process</em>. ASTIN
Bulletin, <b>40</b>(1), pp. 241&ndash;255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ruinprob">ruinprob</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a sample of 50 exponentially distributed claims with mean 10
x &lt;- rexp(50, 0.1)

## Not run: 
# Given this sample, test whether the probability of ruin is smaller than
# 0.1 using a bootstrap test with 100 bootstrap replications.
ruinprob.test(
    x = x, prob.null = 0.10, type = "bootstrap",
    loading = 0.2, reserve = 100, interval = 1,
    bootmethod = "nonp", nboot = 100
)

## End(Not run)

# The same test using normal approximation. This is a lot faster.
ruinprob.test(
    x = x, prob.null = 0.15, type = "normal",
    loading = 0.2, reserve = 100, interval = 1
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
