<!DOCTYPE html><html><head><title>Help for package CDMConnector</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CDMConnector}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#appendPermanent'><p>Run a dplyr query and add the result set to an existing</p></a></li>
<li><a href='#asDate'><p>as.Date dbplyr translation wrapper</p></a></li>
<li><a href='#assert_tables'><p>Assert that tables exist in a cdm object</p></a></li>
<li><a href='#assert_write_schema'><p>Assert that cdm has a writable schema</p></a></li>
<li><a href='#cdm_from_con'><p>Create a CDM reference object from a database connection</p></a></li>
<li><a href='#cdm_from_environment'><p>Create a CDM object from a pre-defined set of environment variables</p></a></li>
<li><a href='#cdm_from_files'><p>Create a CDM reference from a folder containing parquet, csv, or feather</p>
files</a></li>
<li><a href='#cdm_select_tbl'><p>Select a subset of tables in a cdm reference object</p></a></li>
<li><a href='#cdmCon'><p>Get underlying database connection</p></a></li>
<li><a href='#CDMConnector-package'><p>CDMConnector: Connect to an OMOP Common Data Model</p></a></li>
<li><a href='#cdmDisconnect'><p>Disconnect the connection of the cdm object</p></a></li>
<li><a href='#cdmFlatten'><p>Flatten a cdm into a single observation table</p></a></li>
<li><a href='#cdmName'><p>Get the CDM name</p></a></li>
<li><a href='#cdmSample'><p>Subset a cdm object to a random sample of individuals</p></a></li>
<li><a href='#cdmSubset'><p>Subset a cdm object to a set of persons</p></a></li>
<li><a href='#cdmSubsetCohort'><p>Subset a cdm to the individuals in one or more cohorts</p></a></li>
<li><a href='#cdmWriteSchema'><p>Get cdm write schema</p></a></li>
<li><a href='#cohort_count'><p>Get cohort counts from a generated_cohort_set object.</p></a></li>
<li><a href='#cohort_erafy'><p>Collapse cohort records within a certain number of days</p></a></li>
<li><a href='#cohort_union'><p>Union all cohorts in a cohort set with cohorts in a second cohort set</p></a></li>
<li><a href='#cohortAttrition'><p>Get attrition table from a cohort_table object</p></a></li>
<li><a href='#cohortSet'><p>Get cohort settings from a cohort_table object</p></a></li>
<li><a href='#computeQuery'><p>Execute dplyr query and save result in remote database</p></a></li>
<li><a href='#copy_cdm_to'><p>Copy a cdm object from one database to another</p></a></li>
<li><a href='#dateadd'><p>Add days or years to a date in a dplyr query</p></a></li>
<li><a href='#datediff'><p>Compute the difference between two days</p></a></li>
<li><a href='#datepart'><p>Extract the day, month or year of a date in a dplyr pipeline</p></a></li>
<li><a href='#dbms'><p>Get the database management system (dbms) from a cdm_reference or DBI</p>
connection</a></li>
<li><a href='#dbSource'><p>Create a source for a cdm in a database.</p></a></li>
<li><a href='#downloadEunomiaData'><p>Download Eunomia data files</p></a></li>
<li><a href='#eunomia_is_available'><p>Has the Eunomia dataset been cached?</p></a></li>
<li><a href='#eunomiaDir'><p>Create a copy of an example OMOP CDM dataset</p></a></li>
<li><a href='#exampleDatasets'><p>List the available example CDM datasets</p></a></li>
<li><a href='#generateCohortSet'><p>Generate a cohort set on a cdm object</p></a></li>
<li><a href='#generateConceptCohortSet'><p>Create a new generated cohort set from a list of concept sets</p></a></li>
<li><a href='#inSchema'><p>Helper for working with compound schemas</p></a></li>
<li><a href='#intersect_cohorts'><p>Intersect all cohorts in a single cohort table</p></a></li>
<li><a href='#list_tables'><p>List tables in a schema</p></a></li>
<li><a href='#new_generated_cohort_set'><p>Constructor for cohort_table objects</p></a></li>
<li><a href='#read_cohort_set'><p>Read a set of cohort definitions into R</p></a></li>
<li><a href='#recordCohortAttrition'><p>Add attrition reason to a cohort_table object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#snapshot'><p>Extract CDM metadata</p></a></li>
<li><a href='#stow'><p>Collect a list of lazy queries and save the results as files</p></a></li>
<li><a href='#summarise_quantile'><p>Quantile calculation using dbplyr</p></a></li>
<li><a href='#tbl_group'><p>CDM table selection helper</p></a></li>
<li><a href='#union_cohorts'><p>Union all cohorts in a single cohort table</p></a></li>
<li><a href='#uniqueTableName'><p>Create a unique table name for temp tables</p></a></li>
<li><a href='#validate_cdm'><p>Validation report for a CDM</p></a></li>
<li><a href='#version'><p>Get the CDM version</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Connect to an OMOP Common Data Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for working with observational health data in the 
  Observational Medical Outcomes Partnership (OMOP) Common Data Model format with a pipe friendly syntax.
  Common data model database table references are stored in a single compound object along with metadata.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://darwin-eu.github.io/CDMConnector/">https://darwin-eu.github.io/CDMConnector/</a>,
<a href="https://github.com/darwin-eu/CDMConnector">https://github.com/darwin-eu/CDMConnector</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/darwin-eu/CDMConnector/issues">https://github.com/darwin-eu/CDMConnector/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, DBI (&ge; 0.3.0), checkmate, dbplyr (&ge; 2.4.0), cli,
purrr, rlang, tidyselect, readr, glue, waldo, methods, withr,
lifecycle, jsonlite, stringr, stringi, fs, generics, tidyr,
omopgenerics (&ge; 0.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SqlRender, rJava, covr, knitr, rmarkdown, duckdb, RSQLite,
RPostgres, odbc, ggplot2, bigrquery, DatabaseConnector,
lubridate, tibble, testthat (&ge; 3.0.0), pool, snakecase, visR</td>
</tr>
<tr>
<td>Enhances:</td>
<td>arrow, CirceR, Capr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://OHDSI.github.io/drat">https://OHDSI.github.io/drat</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'CDMConnector-package.R' 'Eunomia.R' 'cdm.R' 'cdmSubset.R'
'cdm_from_environment.R' 'cohortTransformations.R'
'cohort_ddl.R' 'compute.R' 'copy_cdm_to.R' 'dateadd.R'
'dbSource.R' 'reexports-omopgenerics.R' 'generateCohortSet.R'
'generateConceptCohortSet.R' 'summariseQuantile.R' 'utils.R'
'validate.R' 'zzz-deprecated.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 11:26:42 UTC; adamblack</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Black <a href="https://orcid.org/0000-0001-5576-8701"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Artem Gorbachev [aut],
  Edward Burn [aut],
  Marti Catala Sabate [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Black &lt;black@ohdsi.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 14:20:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='appendPermanent'>Run a dplyr query and add the result set to an existing</h2><span id='topic+appendPermanent'></span><span id='topic+append_permanent'></span>

<h3>Description</h3>

<p>Run a dplyr query and add the result set to an existing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendPermanent(x, name, schema = NULL)

append_permanent(x, name, schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="appendPermanent_+3A_x">x</code></td>
<td>
<p>A dplyr query</p>
</td></tr>
<tr><td><code id="appendPermanent_+3A_name">name</code></td>
<td>
<p>Name of the table to be appended. If it does not already exist it
will be created.</p>
</td></tr>
<tr><td><code id="appendPermanent_+3A_schema">schema</code></td>
<td>
<p>Schema where the table exists. Can be a length 1 or 2 vector.
(e.g. schema = &quot;my_schema&quot;, schema = c(&quot;my_schema&quot;, &quot;dbo&quot;))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dplyr reference to the newly created table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)

con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())
concept &lt;- dplyr::tbl(con, "concept")

# create a table
rxnorm_count &lt;- concept %&gt;%
  dplyr::filter(domain_id == "Drug") %&gt;%
  dplyr::mutate(isRxnorm = (vocabulary_id == "RxNorm")) %&gt;%
  dplyr::count(domain_id, isRxnorm) %&gt;%
  compute("rxnorm_count")

# append to an existing table
rxnorm_count &lt;- concept %&gt;%
  dplyr::filter(domain_id == "Procedure") %&gt;%
  dplyr::mutate(isRxnorm = (vocabulary_id == "RxNorm")) %&gt;%
  dplyr::count(domain_id, isRxnorm) %&gt;%
  appendPermanent("rxnorm_count")

DBI::dbDisconnect(con, shutdown = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='asDate'>as.Date dbplyr translation wrapper</h2><span id='topic+asDate'></span><span id='topic+as_date'></span>

<h3>Description</h3>

<p>This is a workaround for using as.Date inside dplyr verbs against a database
backend. This function should only be used inside dplyr verbs where the first
argument is a database table reference. <code>asDate</code> must be unquoted with !! inside
dplyr verbs (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asDate(x)

as_date(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asDate_+3A_x">x</code></td>
<td>
<p>an R expression</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(odbc::odbc(), "Oracle")
date_tbl &lt;- dplyr::copy_to(con,
                           data.frame(y = 2000L, m = 10L, d = 10L),
                           name = "tmp",
                           temporary = TRUE)

df &lt;- date_tbl %&gt;%
  dplyr::mutate(date_from_parts = !!asDate(paste0(
    .data$y, "/",
    .data$m, "/",
    .data$d
  ))) %&gt;%
  dplyr::collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='assert_tables'>Assert that tables exist in a cdm object</h2><span id='topic+assert_tables'></span><span id='topic+assertTables'></span>

<h3>Description</h3>

<p>A cdm object is a list of references to a subset of tables in the
OMOP Common Data Model.
If you write a function that accepts a cdm object as a parameter
<code>assert_tables</code>/<code>assertTables</code> will help you check that the tables you need
are in the cdm object, have the correct columns/fields,
and (optionally) are not empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_tables(cdm, tables, empty.ok = FALSE, add = NULL)

assertTables(cdm, tables, empty.ok = FALSE, add = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_tables_+3A_cdm">cdm</code></td>
<td>
<p>A cdm object</p>
</td></tr>
<tr><td><code id="assert_tables_+3A_tables">tables</code></td>
<td>
<p>A character vector of table names to check.</p>
</td></tr>
<tr><td><code id="assert_tables_+3A_empty.ok">empty.ok</code></td>
<td>
<p>Should an empty table (0 rows) be considered an error?
TRUE or FALSE (default)</p>
</td></tr>
<tr><td><code id="assert_tables_+3A_add">add</code></td>
<td>
<p>An optional AssertCollection created by
<code>checkmate::makeAssertCollection()</code> that errors should be added to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the cdm object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Use assertTables inside a function to check that tables exist
countDrugsByGender &lt;- function(cdm) {
  assertTables(cdm, tables = c("person", "drug_era"), empty.ok = FALSE)

  cdm$person %&gt;%
    dplyr::inner_join(cdm$drug_era, by = "person_id") %&gt;%
    dplyr::count(.data$gender_concept_id, .data$drug_concept_id) %&gt;%
    dplyr::collect()
}

library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())
cdm &lt;- cdm_from_con(con)

countDrugsByGender(cdm)

DBI::dbDisconnect(con, shutdown = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='assert_write_schema'>Assert that cdm has a writable schema</h2><span id='topic+assert_write_schema'></span><span id='topic+assertWriteSchema'></span>

<h3>Description</h3>

<p>A cdm object can optionally contain a single schema in a database with
write access. assert_write_schema checks that the cdm contains the
&quot;write_schema&quot; attribute and tests that local dataframes can be written
to tables in this schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_write_schema(cdm, add = NULL)

assertWriteSchema(cdm, add = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_write_schema_+3A_cdm">cdm</code></td>
<td>
<p>A cdm object</p>
</td></tr>
<tr><td><code id="assert_write_schema_+3A_add">add</code></td>
<td>
<p>An optional AssertCollection created by
<code>checkmate::makeAssertCollection()</code> that errors should be added to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the cdm object
</p>

<hr>
<h2 id='cdm_from_con'>Create a CDM reference object from a database connection</h2><span id='topic+cdm_from_con'></span><span id='topic+cdmFromCon'></span>

<h3>Description</h3>

<p>Create a CDM reference object from a database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdm_from_con(
  con,
  cdm_schema,
  write_schema,
  cohort_tables = NULL,
  cdm_version = "5.3",
  cdm_name = NULL,
  achilles_schema = NULL
)

cdmFromCon(
  con,
  cdmSchema,
  writeSchema,
  cohortTables = NULL,
  cdmVersion = "5.3",
  cdmName = NULL,
  achillesSchema = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdm_from_con_+3A_con">con</code></td>
<td>
<p>A DBI database connection to a database where an OMOP CDM v5.4 or
v5.3 instance is located.</p>
</td></tr>
<tr><td><code id="cdm_from_con_+3A_cdm_schema">cdm_schema</code>, <code id="cdm_from_con_+3A_cdmschema">cdmSchema</code></td>
<td>
<p>The schema where the OMOP CDM tables are located. Defaults
to NULL.</p>
</td></tr>
<tr><td><code id="cdm_from_con_+3A_write_schema">write_schema</code>, <code id="cdm_from_con_+3A_writeschema">writeSchema</code></td>
<td>
<p>An optional schema in the CDM database that the user has
write access to.</p>
</td></tr>
<tr><td><code id="cdm_from_con_+3A_cohort_tables">cohort_tables</code>, <code id="cdm_from_con_+3A_cohorttables">cohortTables</code></td>
<td>
<p>A character vector listing the cohort table names to be
included in the CDM object.</p>
</td></tr>
<tr><td><code id="cdm_from_con_+3A_cdm_version">cdm_version</code>, <code id="cdm_from_con_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>The version of the OMOP CDM: &quot;5.3&quot; (default), &quot;5.4&quot;,
&quot;auto&quot;. &quot;auto&quot; attempts to automatically determine the cdm version using
heuristics. Cohort tables must be in the write_schema.</p>
</td></tr>
<tr><td><code id="cdm_from_con_+3A_cdm_name">cdm_name</code>, <code id="cdm_from_con_+3A_cdmname">cdmName</code></td>
<td>
<p>The name of the CDM. If NULL (default) the cdm_source_name
.  field in the CDM_SOURCE table will be used.</p>
</td></tr>
<tr><td><code id="cdm_from_con_+3A_achilles_schema">achilles_schema</code>, <code id="cdm_from_con_+3A_achillesschema">achillesSchema</code></td>
<td>
<p>An optional schema in the CDM database
that contains achilles tables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dplyr database table references pointing to CDM tables
</p>

<hr>
<h2 id='cdm_from_environment'>Create a CDM object from a pre-defined set of environment variables</h2><span id='topic+cdm_from_environment'></span>

<h3>Description</h3>

<p>This function is intended to be used with the Darwin execution engine. The execution engine
runs OHDSI studies in a pre-defined runtime environment and makes several environment
variables available for connecting to a CDM database. Programmer writing code to run
on the execution engine and simply use <code>cdm &lt;- cdm_from_environment()</code> to create a cdm reference
object to use for their analysis and the database connection and cdm object should be
automatically created. This obviates the need for site specific code for connecting
to the database and creating the cdm reference object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdm_from_environment(write_prefix = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdm_from_environment_+3A_write_prefix">write_prefix</code></td>
<td>
<p>(string) An optional prefix to use for all tables written to the CDM.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The environment variables used by this function and provided by the execution engine are listed below.
</p>

<ul>
<li><p>DBMS_TYPE: one of &quot;postgresql&quot;, &quot;sql server&quot;, &quot;redshift&quot;, &quot;duckdb&quot;, &quot;snowflake&quot;.
</p>
</li>
<li><p>DATA_SOURCE_NAME: a free text name for the CDM given by the person running the study.
</p>
</li>
<li><p>CDM_VERSION: one of &quot;5.3&quot;, &quot;5.4&quot;.
</p>
</li>
<li><p>DBMS_CATALOG: The database catalog. Important primarily for compound schema names used in SQL Server and Snowflake.
</p>
</li>
<li><p>DBMS_SERVER: The database server URL.
</p>
</li>
<li><p>DBMS_NAME: The database name used for creating the connection.
</p>
</li>
<li><p>DBMS_PORT: The database port number.
</p>
</li>
<li><p>DBMS_USERNAME: The database username needed to authenticate.
</p>
</li>
<li><p>DBMS_PASSWORD: The database password needed to authenticate.
</p>
</li>
<li><p>CDM_SCHEMA: The schema name where the OMOP CDM is located in the database.
</p>
</li>
<li><p>WRITE_SCHEMA: The shema where the user has write access and tables will be created during study execution.
</p>
</li></ul>



<h3>Value</h3>

<p>A cdm_reference object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(CDMConnector)

# This will only work in an evironment where the proper variables are present.
cdm &lt;- cdm_from_environment()

# Proceed with analysis using the cdm object.

# Close the database connection when done.
cdm_disconnect(cdm)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdm_from_files'>Create a CDM reference from a folder containing parquet, csv, or feather
files</h2><span id='topic+cdm_from_files'></span><span id='topic+cdmFromFiles'></span>

<h3>Description</h3>

<p>Create a CDM reference from a folder containing parquet, csv, or feather
files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdm_from_files(
  path,
  format = "auto",
  cdm_version = "5.3",
  cdm_name = NULL,
  as_data_frame = TRUE
)

cdmFromFiles(
  path,
  format = "auto",
  cdmVersion = "5.3",
  cdmName = NULL,
  asDataFrame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdm_from_files_+3A_path">path</code></td>
<td>
<p>A folder where an OMOP CDM v5.4 instance is located.</p>
</td></tr>
<tr><td><code id="cdm_from_files_+3A_format">format</code></td>
<td>
<p>What is the file format to be read in? Must be &quot;auto&quot;
(default), &quot;parquet&quot;, &quot;csv&quot;, &quot;feather&quot;.</p>
</td></tr>
<tr><td><code id="cdm_from_files_+3A_cdm_version">cdm_version</code>, <code id="cdm_from_files_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>The version of the cdm (5.3 or 5.4)</p>
</td></tr>
<tr><td><code id="cdm_from_files_+3A_cdm_name">cdm_name</code>, <code id="cdm_from_files_+3A_cdmname">cdmName</code></td>
<td>
<p>A name to use for the cdm.</p>
</td></tr>
<tr><td><code id="cdm_from_files_+3A_as_data_frame">as_data_frame</code>, <code id="cdm_from_files_+3A_asdataframe">asDataFrame</code></td>
<td>
<p>TRUE (default) will read files into R as dataframes.
FALSE will read files into R as Arrow Datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dplyr database table references pointing to CDM tables
</p>

<hr>
<h2 id='cdm_select_tbl'>Select a subset of tables in a cdm reference object</h2><span id='topic+cdm_select_tbl'></span>

<h3>Description</h3>

<p>This function uses syntax similar to <code>dplyr::select</code> and can be used to
subset a cdm reference object to a specific tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdm_select_tbl(cdm, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdm_select_tbl_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>cdm_from_con</code></p>
</td></tr>
<tr><td><code id="cdm_select_tbl_+3A_...">...</code></td>
<td>
<p>One or more table names of the tables of the <code>cdm</code> object.
<code>tidyselect</code> is supported, see <code>dplyr::select()</code> for details on the semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cdm reference object containing the selected tables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())

cdm &lt;- cdm_from_con(con, "main")

cdm_select_tbl(cdm, person)
cdm_select_tbl(cdm, person, observation_period)
cdm_select_tbl(cdm, tbl_group("vocab"))
cdm_select_tbl(cdm, "person")

DBI::dbDisconnect(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmCon'>Get underlying database connection</h2><span id='topic+cdmCon'></span>

<h3>Description</h3>

<p>Get underlying database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmCon(cdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmCon_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>cdm_from_con</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reference to the database containing tables in the cdm reference
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())

cdm &lt;- cdm_from_con(con = con, cdm_name = "Eunomia",
                    cdm_schema =  "main", write_schema = "main")

cdmCon(cdm)

DBI::dbDisconnect(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='CDMConnector-package'>CDMConnector: Connect to an OMOP Common Data Model</h2><span id='topic+CDMConnector'></span><span id='topic+CDMConnector-package'></span>

<h3>Description</h3>

<p>Provides tools for working with observational health data in the Observational Medical Outcomes Partnership (OMOP) Common Data Model format with a pipe friendly syntax. Common data model database table references are stored in a single compound object along with metadata.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Adam Black <a href="mailto:black@ohdsi.org">black@ohdsi.org</a> (<a href="https://orcid.org/0000-0001-5576-8701">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Artem Gorbachev <a href="mailto:artem.gorbachev@odysseusinc.com">artem.gorbachev@odysseusinc.com</a>
</p>
</li>
<li><p> Edward Burn <a href="mailto:edward.burn@ndorms.ox.ac.uk">edward.burn@ndorms.ox.ac.uk</a>
</p>
</li>
<li><p> Marti Catala Sabate <a href="mailto:marti.catalasabate@ndorms.ox.ac.uk">marti.catalasabate@ndorms.ox.ac.uk</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://darwin-eu.github.io/CDMConnector/">https://darwin-eu.github.io/CDMConnector/</a>
</p>
</li>
<li> <p><a href="https://github.com/darwin-eu/CDMConnector">https://github.com/darwin-eu/CDMConnector</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/darwin-eu/CDMConnector/issues">https://github.com/darwin-eu/CDMConnector/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cdmDisconnect'>Disconnect the connection of the cdm object</h2><span id='topic+cdmDisconnect'></span><span id='topic+cdm_disconnect'></span>

<h3>Description</h3>

<p>Disconnect the connection of the cdm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmDisconnect(cdm)

cdm_disconnect(cdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmDisconnect_+3A_cdm">cdm</code></td>
<td>
<p>cdm reference</p>
</td></tr>
</table>

<hr>
<h2 id='cdmFlatten'>Flatten a cdm into a single observation table</h2><span id='topic+cdmFlatten'></span><span id='topic+cdm_flatten'></span>

<h3>Description</h3>

<p>This experimental function transforms the OMOP CDM into a single observation
table. This is only recommended for use with a filtered CDM or a cdm that is
small in size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmFlatten(
  cdm,
  domain = c("condition", "drug", "procedure"),
  includeConceptName = TRUE
)

cdm_flatten(
  cdm,
  domain = c("condition", "drug", "procedure"),
  include_concept_name = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmFlatten_+3A_cdm">cdm</code></td>
<td>
<p>A cdm_reference object</p>
</td></tr>
<tr><td><code id="cdmFlatten_+3A_domain">domain</code></td>
<td>
<p>Domains to include. Must be a subset of &quot;condition&quot;, &quot;drug&quot;,
&quot;procedure&quot;, &quot;measurement&quot;, &quot;visit&quot;, &quot;death&quot;, &quot;observation&quot;.</p>
</td></tr>
<tr><td><code id="cdmFlatten_+3A_include_concept_name">include_concept_name</code>, <code id="cdmFlatten_+3A_includeconceptname">includeConceptName</code></td>
<td>
<p>Should concept_name and type_concept_name be
include in the output table? TRUE (default) or FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Value</h3>

<p>A lazy query that when evaluated will result in a single cdm table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())

cdm &lt;- cdm_from_con(con, cdm_schema = "main")

all_observations &lt;- cdmSubset(cdm, personId = c(2, 18, 42)) %&gt;%
  cdmFlatten() %&gt;%
  collect()

all_observations
#&gt; # A tibble: 213 × 8
#&gt;    person_id observation_.  start_date end_date   type_.  domain obser.  type_.
#&gt;        &lt;dbl&gt;          &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;
#&gt;  1         2       40213201 1986-09-09 1986-09-09  5.81e5 drug   pneumo  &lt;NA&gt;
#&gt;  2        18        4116491 1997-11-09 1998-01-09  3.20e4 condi  Escher  &lt;NA&gt;
#&gt;  3        18       40213227 2017-01-04 2017-01-04  5.81e5 drug   tetanu  &lt;NA&gt;
#&gt;  4        42        4156265 1974-06-13 1974-06-27  3.20e4 condi  Facial  &lt;NA&gt;
#&gt;  5        18       40213160 1966-02-23 1966-02-23  5.81e5 drug   poliov  &lt;NA&gt;
#&gt;  6        42        4198190 1933-10-29 1933-10-29  3.80e7 proce  Append  &lt;NA&gt;
#&gt;  7         2        4109685 1952-07-13 1952-07-27  3.20e4 condi  Lacera  &lt;NA&gt;
#&gt;  8        18       40213260 2017-01-04 2017-01-04  5.81e5 drug   zoster  &lt;NA&gt;
#&gt;  9        42        4151422 1985-02-03 1985-02-03  3.80e7 proce  Sputum  &lt;NA&gt;
#&gt; 10         2        4163872 1993-03-29 1993-03-29  3.80e7 proce  Plain   &lt;NA&gt;
#&gt; # ... with 203 more rows, and abbreviated variable names observation_concept_id,
#&gt; #   type_concept_id, observation_concept_name, type_concept_name

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmName'>Get the CDM name</h2><span id='topic+cdmName'></span><span id='topic+cdm_name'></span>

<h3>Description</h3>

<p>Extract the CDM name attribute from a cdm_reference object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmName(cdm)

cdm_name(cdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmName_+3A_cdm">cdm</code></td>
<td>
<p>A cdm object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the CDM as a character string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())
cdm &lt;- cdm_from_con(con, "eunomia", "main")
cdmName(cdm)
#&gt; [1] "eunomia"

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmSample'>Subset a cdm object to a random sample of individuals</h2><span id='topic+cdmSample'></span><span id='topic+cdm_sample'></span>

<h3>Description</h3>

<p><code>cdmSample</code> takes a cdm object and returns a new cdm that includes only a
random sample of persons in the cdm. Only <code>person_id</code>s in both the person
table and observation_period table will be considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmSample(cdm, n)

cdm_sample(cdm, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmSample_+3A_cdm">cdm</code></td>
<td>
<p>A cdm_reference object</p>
</td></tr>
<tr><td><code id="cdmSample_+3A_n">n</code></td>
<td>
<p>Number of persons to include in the cdm</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Value</h3>

<p>A modified cdm_reference object where all clinical tables are lazy
queries pointing to subset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())

cdm &lt;- cdm_from_con(con, cdm_schema = "main")

cdmSampled &lt;- cdmSample(cdm, n = 2)

cdmSampled$person %&gt;%
  select(person_id)
#&gt; # Source:   SQL [2 x 1]
#&gt; # Database: DuckDB 0.6.1
#&gt;   person_id
#&gt;       &lt;dbl&gt;
#&gt; 1       155
#&gt; 2      3422

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmSubset'>Subset a cdm object to a set of persons</h2><span id='topic+cdmSubset'></span><span id='topic+cdm_subset'></span>

<h3>Description</h3>

<p><code>cdmSubset</code> takes a cdm object and a list of person IDs as input. It
returns a new cdm that includes data only for persons matching the provided
person IDs. Generated cohorts in the cdm will also be subset to
the IDs provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmSubset(cdm, personId)

cdm_subset(cdm, person_id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmSubset_+3A_cdm">cdm</code></td>
<td>
<p>A cdm_reference object</p>
</td></tr>
<tr><td><code id="cdmSubset_+3A_person_id">person_id</code>, <code id="cdmSubset_+3A_personid">personId</code></td>
<td>
<p>A numeric vector of person IDs to include in the cdm</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Value</h3>

<p>A modified cdm_reference object where all clinical tables are lazy
queries pointing to subset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())

cdm &lt;- cdm_from_con(con, cdm_schema = "main")

cdm2 &lt;- cdmSubset(cdm, personId = c(2, 18, 42))

cdm2$person %&gt;%
  select(1:3)
#&gt; # Source:   SQL [3 x 3]
#&gt; # Database: DuckDB 0.6.1
#&gt;   person_id gender_concept_id year_of_birth
#&gt;       &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;
#&gt; 1         2              8532          1920
#&gt; 2        18              8532          1965
#&gt; 3        42              8532          1909

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmSubsetCohort'>Subset a cdm to the individuals in one or more cohorts</h2><span id='topic+cdmSubsetCohort'></span><span id='topic+cdm_subset_cohort'></span>

<h3>Description</h3>

<p><code>cdmSubset</code> will return a new cdm object that contains lazy queries pointing
to each of the cdm tables but subset to individuals in a generated cohort.
Since the cdm tables are lazy queries, the subset operation will only be
done when the tables are used. <code>computeQuery</code> can be used to run the SQL
used to subset a cdm table and store it as a new table in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmSubsetCohort(cdm, cohortTable = "cohort", cohortId = NULL, verbose = FALSE)

cdm_subset_cohort(
  cdm,
  cohort_table = "cohort",
  cohort_id = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmSubsetCohort_+3A_cdm">cdm</code></td>
<td>
<p>A cdm_reference object</p>
</td></tr>
<tr><td><code id="cdmSubsetCohort_+3A_cohorttable">cohortTable</code>, <code id="cdmSubsetCohort_+3A_cohort_table">cohort_table</code></td>
<td>
<p>The name of a cohort table in the cdm reference</p>
</td></tr>
<tr><td><code id="cdmSubsetCohort_+3A_cohortid">cohortId</code>, <code id="cdmSubsetCohort_+3A_cohort_id">cohort_id</code></td>
<td>
<p>IDs of the cohorts that we want to subset from the cohort
table. If NULL (default) all cohorts in cohort table are considered.</p>
</td></tr>
<tr><td><code id="cdmSubsetCohort_+3A_verbose">verbose</code></td>
<td>
<p>Should subset messages be printed? TRUE or FALSE (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Value</h3>

<p>A modified cdm_reference with all clinical tables subset
to just the persons in the selected cohorts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())

cdm &lt;- cdm_from_con(con, cdm_schema = "main", write_schema = "main")

# generate a cohort
path &lt;- system.file("cohorts2", mustWork = TRUE, package = "CDMConnector")

cohortSet &lt;- readCohortSet(path) %&gt;%
  filter(cohort_name == "GIBleed_male")

# subset cdm to persons in the generated cohort
cdm &lt;- generateCohortSet(cdm, cohortSet = cohortSet, name = "gibleed")

cdmGiBleed &lt;- cdmSubsetCohort(cdm, cohortTable = "gibleed")

cdmGiBleed$person %&gt;%
  tally()
#&gt; # Source:   SQL [1 x 1]
#&gt; # Database: DuckDB 0.6.1
#&gt;       n
#&gt;   &lt;dbl&gt;
#&gt; 1   237

cdm$person %&gt;%
  tally()
#&gt; # Source:   SQL [1 x 1]
#&gt; # Database: DuckDB 0.6.1
#&gt;       n
#&gt;   &lt;dbl&gt;
#&gt; 1  2694


DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmWriteSchema'>Get cdm write schema</h2><span id='topic+cdmWriteSchema'></span>

<h3>Description</h3>

<p>Get cdm write schema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmWriteSchema(cdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdmWriteSchema_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>cdm_from_con</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The database write schema
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())

cdm &lt;- cdm_from_con(con = con, cdm_name = "Eunomia",
                    cdm_schema =  "main", write_schema = "main")

cdmWriteSchema(cdm)

DBI::dbDisconnect(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='cohort_count'>Get cohort counts from a generated_cohort_set object.</h2><span id='topic+cohort_count'></span>

<h3>Description</h3>

<p>Get cohort counts from a generated_cohort_set object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohort_count(cohort)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohort_count_+3A_cohort">cohort</code></td>
<td>
<p>A generated_cohort_set object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with the counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())
cdm &lt;- cdm_from_con(con = con, cdm_schema = "main", write_schema = "main")
cdm &lt;- generateConceptCohortSet(
  cdm = cdm, conceptSet = list(pharyngitis = 4112343), name = "new_cohort"
)
cohort_count(cdm$new_cohort)

## End(Not run)
</code></pre>

<hr>
<h2 id='cohort_erafy'>Collapse cohort records within a certain number of days</h2><span id='topic+cohort_erafy'></span><span id='topic+cohortErafy'></span>

<h3>Description</h3>

<p>Collapse cohort records within a certain number of days
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohort_erafy(x, gap)

cohortErafy(x, gap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohort_erafy_+3A_x">x</code></td>
<td>
<p>A generated cohort set</p>
</td></tr>
<tr><td><code id="cohort_erafy_+3A_gap">gap</code></td>
<td>
<p>When two cohort records are 'gap' days apart or less the periods will be
collapsed into a single record</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lazy query on a generated cohort set
</p>

<hr>
<h2 id='cohort_union'>Union all cohorts in a cohort set with cohorts in a second cohort set</h2><span id='topic+cohort_union'></span><span id='topic+cohortUnion'></span>

<h3>Description</h3>

<p>Union all cohorts in a cohort set with cohorts in a second cohort set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohort_union(x, y)

cohortUnion(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohort_union_+3A_x">x</code></td>
<td>
<p>A tbl reference to a cohort table with one or more generated cohorts</p>
</td></tr>
<tr><td><code id="cohort_union_+3A_y">y</code></td>
<td>
<p>A tbl reference to a cohort table with one generated cohort</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lazy query that when executed will resolve to a new cohort table with
one the same cohort_definitions_ids in x resulting from the union of all cohorts
in x with the single cohort in y cohort table
</p>

<hr>
<h2 id='cohortAttrition'>Get attrition table from a cohort_table object</h2><span id='topic+cohortAttrition'></span><span id='topic+cohort_attrition'></span>

<h3>Description</h3>

<p>Get attrition table from a cohort_table object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohortAttrition(x)

cohort_attrition(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohortAttrition_+3A_x">x</code></td>
<td>
<p>A cohort_table object</p>
</td></tr>
</table>

<hr>
<h2 id='cohortSet'>Get cohort settings from a cohort_table object</h2><span id='topic+cohortSet'></span><span id='topic+cohort_set'></span>

<h3>Description</h3>

<p>Get cohort settings from a cohort_table object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohortSet(x)

cohort_set(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohortSet_+3A_x">x</code></td>
<td>
<p>A cohort_table object</p>
</td></tr>
</table>

<hr>
<h2 id='computeQuery'>Execute dplyr query and save result in remote database</h2><span id='topic+computeQuery'></span><span id='topic+compute_query'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code>dplyr::compute</code> that is tested on several
database systems. It is needed to handle edge cases where <code>dplyr::compute</code>
does not produce correct SQL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeQuery(
  x,
  name = uniqueTableName(),
  temporary = TRUE,
  schema = NULL,
  overwrite = TRUE,
  ...
)

compute_query(
  x,
  name = uniqueTableName(),
  temporary = TRUE,
  schema = NULL,
  overwrite = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeQuery_+3A_x">x</code></td>
<td>
<p>A dplyr query</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_name">name</code></td>
<td>
<p>The name of the table to create.</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_temporary">temporary</code></td>
<td>
<p>Should the table be temporary: TRUE (default) or FALSE</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_schema">schema</code></td>
<td>
<p>The schema where the table should be created. Ignored if
temporary = TRUE.</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the table be overwritten if it already exists: TRUE (default)
or FALSE Ignored if temporary = TRUE.</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the <code>dplyr::compute</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dplyr::tbl()</code> reference to the newly created table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)

con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())
cdm &lt;- cdm_from_con(con, "main")

# create a temporary table in the remote database from a dplyr query
drugCount &lt;- cdm$concept %&gt;%
  dplyr::count(domain_id == "Drug") %&gt;%
  computeQuery()

# create a permanent table in the remote database from a dplyr query
drugCount &lt;- cdm$concept %&gt;%
  dplyr::count(domain_id == "Drug") %&gt;%
  computeQuery("tmp_table", temporary = FALSE, schema = "main")

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='copy_cdm_to'>Copy a cdm object from one database to another</h2><span id='topic+copy_cdm_to'></span><span id='topic+copyCdmTo'></span>

<h3>Description</h3>

<p>It may be helpful to be able to easily copy a small test cdm from a local
database to a remote for testing. copy_cdm_to takes a cdm object and a connection.
It copies the cdm to the remote database connection. CDM tables can be prefixed
in the new database allowing for multiple cdms in a single shared database
schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_cdm_to(con, cdm, schema, overwrite = FALSE)

copyCdmTo(con, cdm, schema, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_cdm_to_+3A_con">con</code></td>
<td>
<p>A DBI datbase connection created by <code>DBI::dbConnect</code></p>
</td></tr>
<tr><td><code id="copy_cdm_to_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>CDMConnector::cdmFromCon</code> or <code>CDMConnector::cdm_from_con</code></p>
</td></tr>
<tr><td><code id="copy_cdm_to_+3A_schema">schema</code></td>
<td>
<p>schema name in the remote database where the user has write permission</p>
</td></tr>
<tr><td><code id="copy_cdm_to_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the cohort table be overwritten if it already exists? TRUE or FALSE (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Value</h3>

<p>A cdm reference object pointing to the newly created cdm in the remote database
</p>

<hr>
<h2 id='dateadd'>Add days or years to a date in a dplyr query</h2><span id='topic+dateadd'></span>

<h3>Description</h3>

<p>This function must be &quot;unquoted&quot; using the &quot;bang bang&quot; operator (!!). See example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateadd(date, number, interval = "day")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dateadd_+3A_date">date</code></td>
<td>
<p>The name of a date column in the database table as a character string</p>
</td></tr>
<tr><td><code id="dateadd_+3A_number">number</code></td>
<td>
<p>The number of units to add. Can be a positive or negative whole number.</p>
</td></tr>
<tr><td><code id="dateadd_+3A_interval">interval</code></td>
<td>
<p>The units to add. Must be either &quot;day&quot; (default) or &quot;year&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Platform specific SQL that can be used in a dplyr query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb())
date_tbl &lt;- dplyr::copy_to(con, data.frame(date1 = as.Date("1999-01-01")),
                           name = "tmpdate", overwrite = TRUE, temporary = TRUE)

df &lt;- date_tbl %&gt;%
  dplyr::mutate(date2 = !!dateadd("date1", 1, interval = "year")) %&gt;%
  dplyr::collect()

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='datediff'>Compute the difference between two days</h2><span id='topic+datediff'></span>

<h3>Description</h3>

<p>This function must be &quot;unquoted&quot; using the &quot;bang bang&quot; operator (!!). See example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datediff(start, end, interval = "day")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datediff_+3A_start">start</code></td>
<td>
<p>The name of the start date column in the database as a string.</p>
</td></tr>
<tr><td><code id="datediff_+3A_end">end</code></td>
<td>
<p>The name of the end date column in the database as a string.</p>
</td></tr>
<tr><td><code id="datediff_+3A_interval">interval</code></td>
<td>
<p>The units to use for difference calculation. Must be either &quot;day&quot; (default) or &quot;year&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Platform specific SQL that can be used in a dplyr query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb())
date_tbl &lt;- dplyr::copy_to(con, data.frame(date1 = as.Date("1999-01-01")),
                           name = "tmpdate", overwrite = TRUE, temporary = TRUE)

df &lt;- date_tbl %&gt;%
  dplyr::mutate(date2 = !!dateadd("date1", 1, interval = "year")) %&gt;%
  dplyr::mutate(dif_years = !!datediff("date1", "date2", interval = "year")) %&gt;%
  dplyr::collect()

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='datepart'>Extract the day, month or year of a date in a dplyr pipeline</h2><span id='topic+datepart'></span>

<h3>Description</h3>

<p>Extract the day, month or year of a date in a dplyr pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datepart(date, interval = "year", dbms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datepart_+3A_date">date</code></td>
<td>
<p>Character string that represents to a date column.</p>
</td></tr>
<tr><td><code id="datepart_+3A_interval">interval</code></td>
<td>
<p>Interval to extract from a date. Valid options are &quot;year&quot;, &quot;month&quot;, or &quot;day&quot;.</p>
</td></tr>
<tr><td><code id="datepart_+3A_dbms">dbms</code></td>
<td>
<p>Database system, if NULL it is auto detected.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), ":memory:")
date_tbl &lt;- dplyr::copy_to(con,
                           data.frame(birth_date = as.Date("1993-04-19")),
                           name = "tmp",
                           temporary = TRUE)
df &lt;- date_tbl %&gt;%
  dplyr::mutate(year = !!datepart("birth_date", "year")) %&gt;%
  dplyr::mutate(month = !!datepart("birth_date", "month")) %&gt;%
  dplyr::mutate(day = !!datepart("birth_date", "day")) %&gt;%
  dplyr::collect()
DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dbms'>Get the database management system (dbms) from a cdm_reference or DBI
connection</h2><span id='topic+dbms'></span>

<h3>Description</h3>

<p>Get the database management system (dbms) from a cdm_reference or DBI
connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbms(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbms_+3A_con">con</code></td>
<td>
<p>A DBI connection or cdm_reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the dbms that can be used with
SqlRender
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())
cdm &lt;- cdm_from_con(con)
dbms(cdm)
dbms(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='dbSource'>Create a source for a cdm in a database.</h2><span id='topic+dbSource'></span>

<h3>Description</h3>

<p>Create a source for a cdm in a database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbSource(con, writeSchema)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbSource_+3A_con">con</code></td>
<td>
<p>Connection to a database.</p>
</td></tr>
<tr><td><code id="dbSource_+3A_writeschema">writeSchema</code></td>
<td>
<p>Schema where cohort tables are. You must have read and
write access to it.</p>
</td></tr>
</table>

<hr>
<h2 id='downloadEunomiaData'>Download Eunomia data files</h2><span id='topic+downloadEunomiaData'></span><span id='topic+download_eunomia_data'></span>

<h3>Description</h3>

<p>Download the Eunomia data files from https://github.com/darwin-eu/EunomiaDatasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadEunomiaData(
  datasetName = "GiBleed",
  cdmVersion = "5.3",
  pathToData = Sys.getenv("EUNOMIA_DATA_FOLDER"),
  overwrite = FALSE
)

download_eunomia_data(
  dataset_name = "GiBleed",
  cdm_version = "5.3",
  path_to_data = Sys.getenv("EUNOMIA_DATA_FOLDER"),
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downloadEunomiaData_+3A_overwrite">overwrite</code></td>
<td>
<p>Control whether the existing archive file will be overwritten should it already exist.</p>
</td></tr>
<tr><td><code id="downloadEunomiaData_+3A_dataset_name">dataset_name</code>, <code id="downloadEunomiaData_+3A_datasetname">datasetName</code></td>
<td>
<p>The data set name as found on https://github.com/darwin-eu/EunomiaDatasets. The
data set name corresponds to the folder with the data set ZIP files</p>
</td></tr>
<tr><td><code id="downloadEunomiaData_+3A_cdm_version">cdm_version</code>, <code id="downloadEunomiaData_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>The OMOP CDM version. This version will appear in the suffix of the data file,
for example: synpuf_5.3.zip. Default: '5.3'</p>
</td></tr>
<tr><td><code id="downloadEunomiaData_+3A_path_to_data">path_to_data</code>, <code id="downloadEunomiaData_+3A_pathtodata">pathToData</code></td>
<td>
<p>The path where the Eunomia data is stored on the file system., By default the
value of the environment variable &quot;EUNOMIA_DATA_FOLDER&quot; is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the destination if the download was successful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
downloadEunomiaData("GiBleed")

## End(Not run)
</code></pre>

<hr>
<h2 id='eunomia_is_available'>Has the Eunomia dataset been cached?</h2><span id='topic+eunomia_is_available'></span><span id='topic+eunomiaIsAvailable'></span>

<h3>Description</h3>

<p>Has the Eunomia dataset been cached?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eunomia_is_available(dataset_name = "GiBleed", cdm_version = "5.3")

eunomiaIsAvailable(datasetName = "GiBleed", cdmVersion = "5.3")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eunomia_is_available_+3A_dataset_name">dataset_name</code>, <code id="eunomia_is_available_+3A_datasetname">datasetName</code></td>
<td>
<p>Name of the Eunomia dataset to check. Defaults to &quot;GiBleed&quot;.</p>
</td></tr>
<tr><td><code id="eunomia_is_available_+3A_cdm_version">cdm_version</code>, <code id="eunomia_is_available_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>Version of the Eunomia dataset to check. Must be &quot;5.3&quot; or &quot;5.4&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the eunomia example dataset is available and FASLE otherwise
</p>

<hr>
<h2 id='eunomiaDir'>Create a copy of an example OMOP CDM dataset</h2><span id='topic+eunomiaDir'></span><span id='topic+eunomia_dir'></span>

<h3>Description</h3>

<p>Creates a copy of a Eunomia database, and returns the path to the new database file.
If the dataset does not yet exist on the user's computer it will attempt to download the source data
to the the path defined by the EUNOMIA_DATA_FOLDER environment variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eunomiaDir(
  datasetName = "GiBleed",
  cdmVersion = "5.3",
  databaseFile = tempfile(fileext = ".duckdb")
)

eunomia_dir(
  dataset_name = "GiBleed",
  cdm_version = "5.3",
  database_file = tempfile(fileext = ".duckdb")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eunomiaDir_+3A_datasetname">datasetName</code>, <code id="eunomiaDir_+3A_dataset_name">dataset_name</code></td>
<td>
<p>One of &quot;GiBleed&quot; (default),
&quot;synthea-allergies-10k&quot;,
&quot;synthea-anemia-10k&quot;,
&quot;synthea-breast_cancer-10k&quot;,
&quot;synthea-contraceptives-10k&quot;,
&quot;synthea-covid19-10k&quot;,
&quot;synthea-covid19-200k&quot;,
&quot;synthea-dermatitis-10k&quot;,
&quot;synthea-heart-10k&quot;,
&quot;synthea-hiv-10k&quot;,
&quot;synthea-lung_cancer-10k&quot;,
&quot;synthea-medications-10k&quot;,
&quot;synthea-metabolic_syndrome-10k&quot;,
&quot;synthea-opioid_addiction-10k&quot;,
&quot;synthea-rheumatoid_arthritis-10k&quot;,
&quot;synthea-snf-10k&quot;,
&quot;synthea-surgery-10k&quot;,
&quot;synthea-total_joint_replacement-10k&quot;,
&quot;synthea-veteran_prostate_cancer-10k&quot;,
&quot;synthea-veterans-10k&quot;,
&quot;synthea-weight_loss-10k&quot;</p>
</td></tr>
<tr><td><code id="eunomiaDir_+3A_cdmversion">cdmVersion</code>, <code id="eunomiaDir_+3A_cdm_version">cdm_version</code></td>
<td>
<p>The OMOP CDM version. Currently only &quot;5.3&quot; is supported.</p>
</td></tr>
<tr><td><code id="eunomiaDir_+3A_databasefile">databaseFile</code>, <code id="eunomiaDir_+3A_database_file">database_file</code></td>
<td>
<p>The full path to the new copy of the example CDM dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The file path to the new Eunomia dataset copy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir("GiBleed"))
 DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='exampleDatasets'>List the available example CDM datasets</h2><span id='topic+exampleDatasets'></span><span id='topic+example_datasets'></span>

<h3>Description</h3>

<p>List the available example CDM datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleDatasets()

example_datasets()
</code></pre>


<h3>Value</h3>

<p>A character vector with example CDM dataset identifiers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
exampleDatasets()[1]
#&gt; [1] "GiBleed"

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir("GiBleed"))
cdm &lt;- cdm_from_con(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='generateCohortSet'>Generate a cohort set on a cdm object</h2><span id='topic+generateCohortSet'></span><span id='topic+generate_cohort_set'></span>

<h3>Description</h3>

<p>A &quot;chort_table&quot; object consists of four components
</p>

<ul>
<li><p>A remote table reference to an OHDSI cohort table with at least
the columns: cohort_definition_id, subject_id, cohort_start_date,
cohort_end_date. Additional columns are optional and some analytic
packages define additional columns specific to certain analytic
cohorts.
</p>
</li>
<li><p>A <strong>settings attribute</strong> which points to a remote table containing
cohort settings including the names of the cohorts.
</p>
</li>
<li><p>An <strong>attrition attribute</strong> which points to a remote table with
attrition information recorded during generation. This attribute is
optional. Since calculating attrition takes additional compute it
can be skipped resulting in a NULL attrition attribute.
</p>
</li>
<li><p>A <strong>cohortCounts attribute</strong> which points to a remote table
containing cohort counts
</p>
</li></ul>

<p>Each of the three attributes are tidy tables. The implementation of this
object is experimental and user feedback is welcome.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>One key design principle is that cohort_table objects are created once
and can persist across analysis execution but should not be modified after
creation. While it is possible to modify a cohort_table object doing
so will invalidate it and it's attributes may no longer be accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCohortSet(
  cdm,
  cohortSet,
  name,
  computeAttrition = TRUE,
  overwrite = TRUE
)

generate_cohort_set(
  cdm,
  cohort_set,
  name = "cohort",
  compute_attrition = TRUE,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateCohortSet_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference created by CDMConnector. write_schema must be
specified.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_name">name</code></td>
<td>
<p>Name of the cohort table to be created. This will also be used
as a prefix for the cohort attribute tables.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the cohort table be overwritten if it already
exists? TRUE (default) or FALSE</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_cohort_set">cohort_set</code>, <code id="generateCohortSet_+3A_cohortset">cohortSet</code></td>
<td>
<p>Can be a cohortSet object created with <code>readCohortSet()</code>,
a single Capr cohort definition,
or a named list of Capr cohort definitions.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_compute_attrition">compute_attrition</code>, <code id="generateCohortSet_+3A_computeattrition">computeAttrition</code></td>
<td>
<p>Should attrition be computed? TRUE (default) or FALSE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())
cdm &lt;- cdm_from_con(con,
                    cdm_schema = "main",
                    write_schema = "main")

cohortSet &lt;- readCohortSet(system.file("cohorts2", package = "CDMConnector"))
cdm &lt;- generateCohortSet(cdm, cohortSet, name = "cohort")

print(cdm$cohort)

attrition(cdm$cohort)
settings(cdm$cohort)
cohortCount(cdm$cohort)

## End(Not run)
</code></pre>

<hr>
<h2 id='generateConceptCohortSet'>Create a new generated cohort set from a list of concept sets</h2><span id='topic+generateConceptCohortSet'></span><span id='topic+generate_concept_cohort_set'></span>

<h3>Description</h3>

<p>Generate a new cohort set from one or more concept sets. Each
concept set will result in one cohort and represent the time during which
the concept was observed for each subject/person. Concept sets can be
passed to this function as:
</p>

<ul>
<li><p>A named list of numeric vectors, one vector per concept set
</p>
</li>
<li><p>A named list of Capr concept sets
</p>
</li></ul>

<p>Clinical observation records will be looked up in the respective domain tables
using the vocabulary in the CDM. If a required domain table does not exist in
the cdm object a warning will be given.
Concepts that are not in the vocabulary or in the data will be silently ignored.
If end dates are missing or do not exist, as in the case of the procedure and
observation domains, the the start date will be used as the end date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateConceptCohortSet(
  cdm,
  conceptSet = NULL,
  name,
  limit = "first",
  requiredObservation = c(0, 0),
  end = "observation_period_end_date",
  subsetCohort = NULL,
  subsetCohortId = NULL,
  overwrite = TRUE
)

generate_concept_cohort_set(
  cdm,
  concept_set = NULL,
  name = "cohort",
  limit = "first",
  required_observation = c(0, 0),
  end = "observation_period_end_date",
  subset_cohort = NULL,
  subset_cohort_id = NULL,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateConceptCohortSet_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>CDMConnector::cdmFromCon</code> or <code>CDMConnector::cdm_from_con</code></p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_conceptset">conceptSet</code>, <code id="generateConceptCohortSet_+3A_concept_set">concept_set</code></td>
<td>
<p>A named list of numeric vectors or Capr concept sets</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_name">name</code></td>
<td>
<p>The name of the new generated cohort table as a character string</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_limit">limit</code></td>
<td>
<p>Include &quot;first&quot; (default) or &quot;all&quot; occurrences of events in the cohort
</p>

<ul>
<li><p>&quot;first&quot; will include only the first occurrence of any event in the concept set in the cohort.
</p>
</li>
<li><p>&quot;all&quot; will include all occurrences of the events defined by the concept set in the cohort.
</p>
</li></ul>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_requiredobservation">requiredObservation</code>, <code id="generateConceptCohortSet_+3A_required_observation">required_observation</code></td>
<td>
<p>A numeric vector of length 2 that specifies the number of days of
required observation time prior to index and post index for an event to be included in the cohort.</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_end">end</code></td>
<td>
<p>How should the <code>cohort_end_date</code> be defined?
</p>

<ul>
<li><p>&quot;observation_period_end_date&quot; (default): The earliest observation_period_end_date after the event start date
</p>
</li>
<li><p>numeric scalar: A fixed number of days from the event start date
</p>
</li>
<li><p>&quot;event_end_date&quot;: The event end date. If the event end date is not populated then the event start date will be used
</p>
</li></ul>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_subsetcohort">subsetCohort</code>, <code id="generateConceptCohortSet_+3A_subset_cohort">subset_cohort</code></td>
<td>
<p>A cohort table containing the individuals for which to
generate cohorts for. Only individuals in the cohort table will appear in
the created generated cohort set.</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_subsetcohortid">subsetCohortId</code>, <code id="generateConceptCohortSet_+3A_subset_cohort_id">subset_cohort_id</code></td>
<td>
<p>A set of cohort IDs from the cohort table for which
to include. If none are provided, all cohorts in the cohort table will
be included.</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the cohort table be overwritten if it already exists? TRUE (default) or FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cdm reference object with the new generated cohort set table added
</p>

<hr>
<h2 id='inSchema'>Helper for working with compound schemas</h2><span id='topic+inSchema'></span><span id='topic+in_schema'></span>

<h3>Description</h3>

<p>This is similar to dbplyr::in_schema but has been tested across multiple
database platforms. It only exists to work around some of the limitations
of dbplyr::in_schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inSchema(schema, table, dbms = NULL)

in_schema(schema, table, dbms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inSchema_+3A_schema">schema</code></td>
<td>
<p>A schema name as a character string</p>
</td></tr>
<tr><td><code id="inSchema_+3A_table">table</code></td>
<td>
<p>A table name as character string</p>
</td></tr>
<tr><td><code id="inSchema_+3A_dbms">dbms</code></td>
<td>
<p>The name of the database management system as returned
by <code>dbms(connection)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DBI::Id that represents a qualified table and schema
</p>

<hr>
<h2 id='intersect_cohorts'>Intersect all cohorts in a single cohort table</h2><span id='topic+intersect_cohorts'></span><span id='topic+intersectCohorts'></span>

<h3>Description</h3>

<p>Intersect all cohorts in a single cohort table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersect_cohorts(x, cohort_definition_id = 1L)

intersectCohorts(x, cohort_definition_id = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_cohorts_+3A_x">x</code></td>
<td>
<p>A tbl reference to a cohort table</p>
</td></tr>
<tr><td><code id="intersect_cohorts_+3A_cohort_definition_id">cohort_definition_id</code></td>
<td>
<p>A number to use for the new cohort_definition_id
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lazy query that when executed will resolve to a new cohort table with
one cohort_definition_id resulting from the intersection of all cohorts in the original
cohort table
</p>

<hr>
<h2 id='list_tables'>List tables in a schema</h2><span id='topic+list_tables'></span><span id='topic+listTables'></span>

<h3>Description</h3>

<p>DBI::dbListTables can be used to get all tables in a database but not always in a
specific schema. <code>listTables</code> will list tables in a schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_tables(con, schema = NULL)

listTables(con, schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_tables_+3A_con">con</code></td>
<td>
<p>A DBI connection to a database</p>
</td></tr>
<tr><td><code id="list_tables_+3A_schema">schema</code></td>
<td>
<p>The name of a schema in a database. If NULL, returns DBI::dbListTables(con).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of table names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())
listTables(con, schema = "main")

## End(Not run)
</code></pre>

<hr>
<h2 id='new_generated_cohort_set'>Constructor for cohort_table objects</h2><span id='topic+new_generated_cohort_set'></span><span id='topic+newGeneratedCohortSet'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_generated_cohort_set(
  cohort_ref,
  cohort_set_ref = NULL,
  cohort_attrition_ref = NULL,
  cohort_count_ref = NULL,
  overwrite
)

newGeneratedCohortSet(
  cohortRef,
  cohortSetRef = NULL,
  cohortAttritionRef = NULL,
  cohortCountRef = NULL,
  overwrite
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_generated_cohort_set_+3A_cohort_ref">cohort_ref</code>, <code id="new_generated_cohort_set_+3A_cohortref">cohortRef</code></td>
<td>
<p>A <code>tbl_sql</code> object that points to a remote cohort table
with the following first four columns: cohort_definition_id,
subject_id, cohort_start_date, cohort_end_date. Additional columns are
optional.</p>
</td></tr>
<tr><td><code id="new_generated_cohort_set_+3A_cohort_set_ref">cohort_set_ref</code>, <code id="new_generated_cohort_set_+3A_cohortsetref">cohortSetRef</code></td>
<td>
<p>A <code>tbl_sql</code> object that points to a remote table
with the following first two columns: cohort_definition_id, cohort_name.
Additional columns are optional. cohort_definition_id should be a primary
key on this table and uniquely identify rows.</p>
</td></tr>
<tr><td><code id="new_generated_cohort_set_+3A_cohort_attrition_ref">cohort_attrition_ref</code>, <code id="new_generated_cohort_set_+3A_cohortattritionref">cohortAttritionRef</code></td>
<td>
<p>A <code>tbl_sql</code> object that points to an attrition
table in a remote database with the first column being cohort_definition_id.</p>
</td></tr>
<tr><td><code id="new_generated_cohort_set_+3A_cohort_count_ref">cohort_count_ref</code>, <code id="new_generated_cohort_set_+3A_cohortcountref">cohortCountRef</code></td>
<td>
<p>A <code>tbl_sql</code> object that points to a cohort_count
table in a remote database with columns cohort_definition_id, cohort_entries,
cohort_subjects.</p>
</td></tr>
<tr><td><code id="new_generated_cohort_set_+3A_overwrite">overwrite</code></td>
<td>
<p>Should tables be overwritten if they already exist? TRUE or FALSE (default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please use <code>omopgenerics::newCohortTable()</code> instead.
</p>
<p>This constructor function is to be used by analytic package developers to
create <code>cohort_table</code> objects.
</p>
<p>A <code>cohort_table</code> is a set of person-time from an OMOP CDM database.
A <code>cohort_table</code> can be represented by a table with three columns:
subject_id, cohort_start_date, cohort_end_date. Subject_id is the same as
person_id in the OMOP CDM. A <code>cohort_table</code> is a collection of one
or more <code>cohort_table</code> and can be represented as a table with four
columns: cohort_definition_id, subject_id, cohort_start_date,
cohort_end_date.
</p>
<p>This constructor function defines the <code>cohort_table</code> object in R.
</p>
<p>The object is an extension of a <code>tbl_sql</code> object defined in dplyr. This is
a lazy database query that points to a cohort table in the database with
at least the columns cohort_definition_id, subject_id, cohort_start_date,
cohort_end_date. The table could optionally have more columns as well.
</p>
<p>In addition the <code>cohort_table</code> object has three optional attributes.
These are: cohort_set, cohort_attrition, cohort_count.
Each of these attributes is also a lazy SQL query (<code>tbl_sql</code>) that points
to a table in a database and is described below.
</p>


<h4>cohort_set</h4>

<p>cohort_set is a table with one row per cohort_definition_id. The first
two columns of the cohort_set table are: cohort_definition_id, and
cohort_name. Additional columns can be added. The cohort_set table is meant
to store metadata about the cohort definition. Since this table is required it
will be created if it it is not supplied.
</p>



<h4>cohort_attrition</h4>

<p>cohort_attrition is an optional table that stores attrition information
recorded during the cohort generation process such as how many persons were
dropped at each step of inclusion rule application. The first column of this
table should be <code>cohort_definition_id</code> but all other columns currently
have no constraints.
</p>



<h4>cohort_count</h4>

<p>cohort_count is a option attribute table that records the number of records
and the number of unique persons in each cohort in a <code>cohort_table</code>.
It is derived metadata that can be re-derived as long as cohort_set,
the complete list of cohorts in the set, is available. Column names of
cohort_count are: cohort_definition_id, number_records,
number_subjects. This table is required for cohort_table objects and
will be created if not supplied.
</p>



<h3>Value</h3>

<p>A <code>cohort_table</code> object that is a <code>tbl_sql</code> reference
to a cohort table in the write_schema of an OMOP CDM
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 # This function is for developers who are creating cohort_table
 # objects in their packages. The function should accept a cdm_reference
 # object as the first argument and return a cdm_reference object with the
 # cohort table added. The second argument should be `name` which will be
 # the prefix for the database tables, the name of the cohort table in the
 # database and the name of the cohort table in the cdm object.
 # Other optional arguments can be added after the first two.

 generateCustomCohort &lt;- function(cdm, name, ...) {

   # accept a cdm_reference object as input
   checkmate::assertClass(cdm, "cdm_reference")
   con &lt;- attr(cdm, "dbcon")

   # Create the tables in the database however you like
   # All the tables should be prefixed with `name`
   # The cohort table should be called `name` in the database

   # Create the dplyr table references
   cohort_ref &lt;- dplyr::tbl(con, name)
   cohort_set &lt;- dplyr::tbl(con, paste0(name, "_set"))
   cohort_attrition_ref &lt;- dplyr::tbl(con, paste0(name, "_attrition"))
   cohort_count_ref &lt;- dplyr::tbl(con, paste0(name, "_count"))

   # add to the cdm
   cdm[[name]] &lt;- cohort_ref

   # create the generated cohort set object using the constructor
   cdm[[name]] &lt;- new_generated_cohort_set(
      cdm[[name]],
      cohort_set_ref = cohort_set_ref,
      cohort_attrition_ref = cohort_attrition_ref,
      cohort_count_ref = cohort_count_ref)

   return(cdm)
 }

## End(Not run)
</code></pre>

<hr>
<h2 id='read_cohort_set'>Read a set of cohort definitions into R</h2><span id='topic+read_cohort_set'></span><span id='topic+readCohortSet'></span>

<h3>Description</h3>

<p>A &quot;cohort set&quot; is a collection of cohort definitions. In R this is stored in
a dataframe with cohort_definition_id, cohort_name, and cohort columns.
On disk this is stored as a folder with a CohortsToCreate.csv file and
one or more json files.
If the CohortsToCreate.csv file is missing then all of the json files in the
folder will be used, cohort_definition_id will be automatically assigned
in alphabetical order, and cohort_name will match the file names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_cohort_set(path)

readCohortSet(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_cohort_set_+3A_path">path</code></td>
<td>
<p>The path to a folder containing Circe cohort definition
json files and optionally a csv file named CohortsToCreate.csv with columns
cohortId, cohortName, and jsonPath.</p>
</td></tr>
</table>

<hr>
<h2 id='recordCohortAttrition'>Add attrition reason to a cohort_table object</h2><span id='topic+recordCohortAttrition'></span><span id='topic+record_cohort_attrition'></span>

<h3>Description</h3>

<p>Update the cohort attrition table with new counts and a reason for attrition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recordCohortAttrition(cohort, reason, cohortId = NULL)

record_cohort_attrition(cohort, reason, cohortId = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recordCohortAttrition_+3A_cohort">cohort</code></td>
<td>
<p>A generated cohort set</p>
</td></tr>
<tr><td><code id="recordCohortAttrition_+3A_reason">reason</code></td>
<td>
<p>The reason for attrition as a character string</p>
</td></tr>
<tr><td><code id="recordCohortAttrition_+3A_cohortid">cohortId</code></td>
<td>
<p>Cohort definition id of the cohort you want to update the
attrition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort object with the attributes created or updated.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())
cdm &lt;- cdm_from_con(con = con, cdm_schema = "main", write_schema = "main")
cdm &lt;- generateConceptCohortSet(
  cdm = cdm, conceptSet = list(pharyngitis = 4112343), name = "new_cohort"
)

settings(cdm$new_cohort)
cohortCount(cdm$new_cohort)
cohortAttrition(cdm$new_cohort)

cdm$new_cohort &lt;- cdm$new_cohort %&gt;%
  filter(cohort_start_date &gt;= as.Date("2010-01-01"))

cdm$new_cohort &lt;- updateCohortAttributes(
  cohort = cdm$new_cohort, reason = "Only events after 2010"
)

settings(cdm$new_cohort)
cohortCount(cdm$new_cohort)
cohortAttrition(cdm$new_cohort)

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+cohortCount'></span><span id='topic+settings'></span><span id='topic+attrition'></span><span id='topic+newCohortTable'></span><span id='topic+insertTable'></span><span id='topic+dropTable'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>omopgenerics</dt><dd><p><code><a href="omopgenerics.html#topic+attrition">attrition</a></code>, <code><a href="omopgenerics.html#topic+cohortCount">cohortCount</a></code>, <code><a href="omopgenerics.html#topic+dropTable">dropTable</a></code>, <code><a href="omopgenerics.html#topic+insertTable">insertTable</a></code>, <code><a href="omopgenerics.html#topic+newCohortTable">newCohortTable</a></code>, <code><a href="omopgenerics.html#topic+settings">settings</a></code></p>
</dd>
</dl>

<hr>
<h2 id='snapshot'>Extract CDM metadata</h2><span id='topic+snapshot'></span>

<h3>Description</h3>

<p>Extract the name, version, and selected record counts from a cdm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snapshot(cdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snapshot_+3A_cdm">cdm</code></td>
<td>
<p>A cdm object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of attributes about the cdm including selected fields
from the cdm_source table and record counts from the person and
observation_period tables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())
cdm &lt;- cdm_from_con(con, "main")
snapshot(cdm)

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='stow'>Collect a list of lazy queries and save the results as files</h2><span id='topic+stow'></span>

<h3>Description</h3>

<p>Collect a list of lazy queries and save the results as files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stow(cdm, path, format = "parquet")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stow_+3A_cdm">cdm</code></td>
<td>
<p>A cdm object</p>
</td></tr>
<tr><td><code id="stow_+3A_path">path</code></td>
<td>
<p>A folder to save the cdm object to</p>
</td></tr>
<tr><td><code id="stow_+3A_format">format</code></td>
<td>
<p>The file format to use: &quot;parquet&quot; (default), &quot;csv&quot;, &quot;feather&quot; or &quot;duckdb&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the cdm input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomia_dir())
vocab &lt;- cdm_from_con(con, "main") %&gt;%
  cdm_select_tbl("concept", "concept_ancestor")
stow(vocab, here::here("vocab_tables"))
DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='summarise_quantile'>Quantile calculation using dbplyr</h2><span id='topic+summarise_quantile'></span><span id='topic+summarize_quantile'></span><span id='topic+summariseQuantile'></span><span id='topic+summarizeQuantile'></span>

<h3>Description</h3>

<p>This function provides DBMS independent syntax for quantiles estimation.
Can be used by itself or in combination with <code>mutate()</code>
when calculating other aggregate metrics (min, max, mean).
</p>
<p><code>summarise_quantile()</code>, <code>summarize_quantile()</code>, <code>summariseQuantile()</code> and <code>summarizeQuantile()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_quantile(.data, x = NULL, probs, name_suffix = "value")

summarize_quantile(.data, x = NULL, probs, name_suffix = "value")

summariseQuantile(.data, x = NULL, probs, nameSuffix = "value")

summarizeQuantile(.data, x = NULL, probs, nameSuffix = "value")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_quantile_+3A_.data">.data</code></td>
<td>
<p>lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="summarise_quantile_+3A_x">x</code></td>
<td>
<p>column name whose sample quantiles are wanted.</p>
</td></tr>
<tr><td><code id="summarise_quantile_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1].</p>
</td></tr>
<tr><td><code id="summarise_quantile_+3A_name_suffix">name_suffix</code>, <code id="summarise_quantile_+3A_namesuffix">nameSuffix</code></td>
<td>
<p>character; is appended to numerical quantile value as a column name part.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented quantiles estimation algorithm returns values analogous to
<code style="white-space: pre;">&#8288;quantile{stats}&#8288;</code> with argument <code>type = 1</code>.
See discussion in Hyndman and Fan (1996).
Results differ from <code>PERCENTILE_CONT</code> natively implemented in various DBMS,
where returned values are equal to <code style="white-space: pre;">&#8288;quantile{stats}&#8288;</code> with default argument <code>type = 7</code>
</p>


<h3>Value</h3>

<p>An object of the same type as '.data'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb())
mtcars_tbl &lt;- dplyr::copy_to(con, mtcars, name = "tmp", overwrite = TRUE, temporary = TRUE)

df &lt;- mtcars_tbl %&gt;%
 dplyr::group_by(cyl) %&gt;%
 dplyr::mutate(mean = mean(mpg, na.rm = TRUE)) %&gt;%
 summarise_quantile(mpg, probs = c(0, 0.2, 0.4, 0.6, 0.8, 1),
                    name_suffix = "quant") %&gt;%
 dplyr::collect()

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='tbl_group'>CDM table selection helper</h2><span id='topic+tbl_group'></span><span id='topic+tblGroup'></span>

<h3>Description</h3>

<p>The OMOP CDM tables are grouped together and the <code>tbl_group</code> function allows
users to easily create a CDM reference including one or more table groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_group(group)

tblGroup(group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_group_+3A_group">group</code></td>
<td>
<p>A character vector of CDM table groups: &quot;vocab&quot;, &quot;clinical&quot;,
&quot;all&quot;, &quot;default&quot;, &quot;derived&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><img src="../help/figures/cdm54.png" width="100%" alt="CDM 5.4" />
</p>
<p>The &quot;default&quot; table group is meant to capture the most commonly used set
of CDM tables. Currently the &quot;default&quot; group is: person,
observation_period, visit_occurrence,
visit_detail, condition_occurrence, drug_exposure, procedure_occurrence,
device_exposure, measurement, observation, death, note, note_nlp, specimen,
fact_relationship, location, care_site, provider, payer_plan_period,
cost, drug_era, dose_era, condition_era, concept, vocabulary,
concept_relationship, concept_ancestor, concept_synonym, drug_strength
</p>


<h3>Value</h3>

<p>A character vector of CDM tables names in the groups
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(RPostgres::Postgres(),
                      dbname = "cdm",
                      host = "localhost",
                      user = "postgres",
                      password = Sys.getenv("PASSWORD"))

cdm &lt;- cdm_from_con(con, cdm_name = "test", cdm_schema = "public") %&gt;%
  cdm_select_tbl(tbl_group("vocab"))

## End(Not run)
</code></pre>

<hr>
<h2 id='union_cohorts'>Union all cohorts in a single cohort table</h2><span id='topic+union_cohorts'></span><span id='topic+unionCohorts'></span>

<h3>Description</h3>

<p>Union all cohorts in a single cohort table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>union_cohorts(x, cohort_definition_id = 1L)

unionCohorts(x, cohort_definition_id = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union_cohorts_+3A_x">x</code></td>
<td>
<p>A tbl reference to a cohort table</p>
</td></tr>
<tr><td><code id="union_cohorts_+3A_cohort_definition_id">cohort_definition_id</code></td>
<td>
<p>A number to use for the new cohort_definition_id
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lazy query that when executed will resolve to a new cohort table with
one cohort_definition_id resulting from the union of all cohorts in the original
cohort table
</p>

<hr>
<h2 id='uniqueTableName'>Create a unique table name for temp tables</h2><span id='topic+uniqueTableName'></span><span id='topic+unique_table_name'></span>

<h3>Description</h3>

<p>Create a unique table name for temp tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniqueTableName()

unique_table_name()
</code></pre>


<h3>Value</h3>

<p>A string that can be used as a dbplyr temp table name
</p>

<hr>
<h2 id='validate_cdm'>Validation report for a CDM</h2><span id='topic+validate_cdm'></span><span id='topic+validateCdm'></span>

<h3>Description</h3>

<p>Print a short validation report for a cdm object. The validation includes
checking that column names are correct and that no tables are empty. A short
report is printed to the console. This function is meant for interactive use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_cdm(cdm)

validateCdm(cdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_cdm_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the cdm input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())
cdm &lt;- cdm_from_con(con, cdm_schema = "main")
validate_cdm(cdm)
DBI::dbDisconnect(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='version'>Get the CDM version</h2><span id='topic+version'></span>

<h3>Description</h3>

<p>Extract the CDM version attribute from a cdm_reference object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version(cdm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="version_+3A_cdm">cdm</code></td>
<td>
<p>A cdm object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;5.3&quot; or &quot;5.4&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomia_dir())
cdm &lt;- cdm_from_con(con, "eunomia", "main")
version(cdm)

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
