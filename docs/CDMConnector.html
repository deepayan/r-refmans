<!DOCTYPE html><html lang="en"><head><title>Help for package CDMConnector</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CDMConnector}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CDMConnector-package'><p>CDMConnector: Connect to an OMOP Common Data Model</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#appendPermanent'><p>Run a dplyr query and add the result set to an existing</p></a></li>
<li><a href='#asDate'><p>as.Date dbplyr translation wrapper</p></a></li>
<li><a href='#benchmarkCDMConnector'><p>Run benchmark of tasks using CDMConnector</p></a></li>
<li><a href='#cdmCon'><p>Get underlying database connection</p></a></li>
<li><a href='#cdmDisconnect.db_cdm'><p>Disconnect the connection of the cdm object</p></a></li>
<li><a href='#cdmFlatten'><p>Flatten a cdm into a single observation table</p></a></li>
<li><a href='#cdmFromCon'><p>Create a CDM reference object from a database connection</p></a></li>
<li><a href='#cdmSample'><p>Subset a cdm object to a random sample of individuals</p></a></li>
<li><a href='#cdmSubset'><p>Subset a cdm object to a set of persons</p></a></li>
<li><a href='#cdmSubsetCohort'><p>Subset a cdm to the individuals in one or more cohorts</p></a></li>
<li><a href='#cdmWriteSchema'><p>Get cdm write schema</p></a></li>
<li><a href='#computeQuery'><p>Execute dplyr query and save result in remote database</p></a></li>
<li><a href='#copyCdmTo'><p>Copy a cdm object from one database to another</p></a></li>
<li><a href='#dateadd'><p>Add days or years to a date in a dplyr query</p></a></li>
<li><a href='#datediff'><p>Compute the difference between two days</p></a></li>
<li><a href='#datepart'><p>Extract the day, month or year of a date in a dplyr pipeline</p></a></li>
<li><a href='#dbms'><p>Get the database management system (dbms) from a cdm_reference or DBI</p>
connection</a></li>
<li><a href='#dbSource'><p>Create a source for a cdm in a database.</p></a></li>
<li><a href='#downloadEunomiaData'><p>Download Eunomia data files</p></a></li>
<li><a href='#dropTable.db_cdm'><p>Drop table from a database backed cdm object</p></a></li>
<li><a href='#eunomiaDir'><p>Create a copy of an example OMOP CDM dataset</p></a></li>
<li><a href='#eunomiaIsAvailable'><p>Has the Eunomia dataset been cached?</p></a></li>
<li><a href='#exampleDatasets'><p>List the available example CDM datasets</p></a></li>
<li><a href='#generateCohortSet'><p>Generate a cohort set on a cdm object</p></a></li>
<li><a href='#generateConceptCohortSet'><p>Create a new generated cohort set from a list of concept sets</p></a></li>
<li><a href='#inSchema'><p>Helper for working with compound schemas</p></a></li>
<li><a href='#listTables'><p>List tables in a schema</p></a></li>
<li><a href='#readCohortSet'><p>Read a set of cohort definitions into R</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#requireEunomia'><p>Require eunomia to be available. The function makes sure that you can later</p>
create a eunomia database with <code>eunomiaDir()</code>.</a></li>
<li><a href='#snapshot'><p>Extract CDM metadata</p></a></li>
<li><a href='#summariseQuantile'><p>Quantile calculation using dbplyr</p></a></li>
<li><a href='#tblGroup'><p>CDM table selection helper</p></a></li>
<li><a href='#version'><p>Get the CDM version</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Connect to an OMOP Common Data Model</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for working with observational health data in the 
  Observational Medical Outcomes Partnership (OMOP) Common Data Model format with a pipe friendly syntax.
  Common data model database table references are stored in a single compound object along with metadata.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://darwin-eu.github.io/CDMConnector/">https://darwin-eu.github.io/CDMConnector/</a>,
<a href="https://github.com/darwin-eu/CDMConnector">https://github.com/darwin-eu/CDMConnector</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/darwin-eu/CDMConnector/issues">https://github.com/darwin-eu/CDMConnector/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, dbplyr (&ge; 2.5.0), DBI (&ge; 0.3.0), checkmate, cli,
purrr, rlang, tidyselect, glue, methods, withr, lifecycle,
stringr, stringi, generics, tidyr, jsonlite, readr,
omopgenerics (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SqlRender, CirceR, rJava, covr, knitr, rmarkdown, duckdb,
RSQLite, RPostgres, DatabaseConnector, odbc, ggplot2,
bigrquery, lubridate, clock, tibble, testthat (&ge; 3.0.0), pool,
snakecase, palmerpenguins</td>
</tr>
<tr>
<td>Enhances:</td>
<td>arrow</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-21 11:13:45 UTC; ablack</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam Black <a href="https://orcid.org/0000-0001-5576-8701"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Artem Gorbachev [aut],
  Edward Burn [aut],
  Marti Catala Sabate [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Black &lt;black@ohdsi.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-22 00:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='CDMConnector-package'>CDMConnector: Connect to an OMOP Common Data Model</h2><span id='topic+CDMConnector'></span><span id='topic+CDMConnector-package'></span>

<h3>Description</h3>

<p>Provides tools for working with observational health data in the Observational Medical Outcomes Partnership (OMOP) Common Data Model format with a pipe friendly syntax. Common data model database table references are stored in a single compound object along with metadata.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Adam Black <a href="mailto:black@ohdsi.org">black@ohdsi.org</a> (<a href="https://orcid.org/0000-0001-5576-8701">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Artem Gorbachev <a href="mailto:artem.gorbachev@odysseusinc.com">artem.gorbachev@odysseusinc.com</a>
</p>
</li>
<li><p> Edward Burn <a href="mailto:edward.burn@ndorms.ox.ac.uk">edward.burn@ndorms.ox.ac.uk</a>
</p>
</li>
<li><p> Marti Catala Sabate <a href="mailto:marti.catalasabate@ndorms.ox.ac.uk">marti.catalasabate@ndorms.ox.ac.uk</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://darwin-eu.github.io/CDMConnector/">https://darwin-eu.github.io/CDMConnector/</a>
</p>
</li>
<li> <p><a href="https://github.com/darwin-eu/CDMConnector">https://github.com/darwin-eu/CDMConnector</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/darwin-eu/CDMConnector/issues">https://github.com/darwin-eu/CDMConnector/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='appendPermanent'>Run a dplyr query and add the result set to an existing</h2><span id='topic+appendPermanent'></span>

<h3>Description</h3>

<p>Run a dplyr query and add the result set to an existing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>appendPermanent(x, name, schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="appendPermanent_+3A_x">x</code></td>
<td>
<p>A dplyr query</p>
</td></tr>
<tr><td><code id="appendPermanent_+3A_name">name</code></td>
<td>
<p>Name of the table to be appended. If it does not already exist it
will be created.</p>
</td></tr>
<tr><td><code id="appendPermanent_+3A_schema">schema</code></td>
<td>
<p>Schema where the table exists. Can be a length 1 or 2 vector.
(e.g. schema = &quot;my_schema&quot;, schema = c(&quot;my_schema&quot;, &quot;dbo&quot;))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dplyr reference to the newly created table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)

con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomiaDir())
concept &lt;- dplyr::tbl(con, "concept")

# create a table
rxnorm_count &lt;- concept %&gt;%
  dplyr::filter(domain_id == "Drug") %&gt;%
  dplyr::mutate(isRxnorm = (vocabulary_id == "RxNorm")) %&gt;%
  dplyr::count(domain_id, isRxnorm) %&gt;%
  compute("rxnorm_count")

# append to an existing table
rxnorm_count &lt;- concept %&gt;%
  dplyr::filter(domain_id == "Procedure") %&gt;%
  dplyr::mutate(isRxnorm = (vocabulary_id == "RxNorm")) %&gt;%
  dplyr::count(domain_id, isRxnorm) %&gt;%
  appendPermanent("rxnorm_count")

DBI::dbDisconnect(con, shutdown = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='asDate'>as.Date dbplyr translation wrapper</h2><span id='topic+asDate'></span>

<h3>Description</h3>

<p>This is a workaround for using as.Date inside dplyr verbs against a database
backend. This function should only be used inside dplyr verbs where the first
argument is a database table reference. <code>asDate</code> must be unquoted with !! inside
dplyr verbs (see example).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asDate(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="asDate_+3A_x">x</code></td>
<td>
<p>an R expression</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(odbc::odbc(), "Oracle")
date_tbl &lt;- dplyr::copy_to(con,
                           data.frame(y = 2000L, m = 10L, d = 10L),
                           name = "tmp",
                           temporary = TRUE)

df &lt;- date_tbl %&gt;%
  dplyr::mutate(date_from_parts = !!asDate(paste0(
    .data$y, "/",
    .data$m, "/",
    .data$d
  ))) %&gt;%
  dplyr::collect()

## End(Not run)
</code></pre>

<hr>
<h2 id='benchmarkCDMConnector'>Run benchmark of tasks using CDMConnector</h2><span id='topic+benchmarkCDMConnector'></span>

<h3>Description</h3>

<p>Run benchmark of tasks using CDMConnector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkCDMConnector(cdm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkCDMConnector_+3A_cdm">cdm</code></td>
<td>
<p>A CDM reference object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with time taken for different analyses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())
cdm &lt;- cdmFromCon(con, cdmSchema = "main", writeSchema = "main")
benchmarkCDMConnector(cdm)

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmCon'>Get underlying database connection</h2><span id='topic+cdmCon'></span>

<h3>Description</h3>

<p>Get underlying database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmCon(cdm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdmCon_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>cdmFromCon</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reference to the database containing tables in the cdm reference
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomiaDir())

cdm &lt;- cdmFromCon(con = con, cdmName = "Eunomia",
                  cdmSchema =  "main", writeSchema = "main")

cdmCon(cdm)

DBI::dbDisconnect(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmDisconnect.db_cdm'>Disconnect the connection of the cdm object</h2><span id='topic+cdmDisconnect.db_cdm'></span>

<h3>Description</h3>

<p>This function will disconnect from the database as well as drop
&quot;temporary&quot; tables that were created on database systems that do not support
actual temporary tables. Currently temp tables are emulated on
Spark/Databricks systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'db_cdm'
cdmDisconnect(cdm, dropWriteSchema = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdmDisconnect.db_cdm_+3A_cdm">cdm</code></td>
<td>
<p>cdm reference</p>
</td></tr>
<tr><td><code id="cdmDisconnect.db_cdm_+3A_dropwriteschema">dropWriteSchema</code></td>
<td>
<p>Whether to drop tables in the writeSchema</p>
</td></tr>
<tr><td><code id="cdmDisconnect.db_cdm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>

<hr>
<h2 id='cdmFlatten'>Flatten a cdm into a single observation table</h2><span id='topic+cdmFlatten'></span>

<h3>Description</h3>

<p>This experimental function transforms the OMOP CDM into a single observation
table. This is only recommended for use with a filtered CDM or a cdm that is
small in size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmFlatten(
  cdm,
  domain = c("condition_occurrence", "drug_exposure", "procedure_occurrence"),
  includeConceptName = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdmFlatten_+3A_cdm">cdm</code></td>
<td>
<p>A cdm_reference object</p>
</td></tr>
<tr><td><code id="cdmFlatten_+3A_domain">domain</code></td>
<td>
<p>Domains to include. Must be a subset of &quot;condition_occurrence&quot;, &quot;drug_exposure&quot;,
&quot;procedure_occurrence&quot;, &quot;measurement&quot;, &quot;visit_occurrence&quot;, &quot;death&quot;, &quot;observation&quot;</p>
</td></tr>
<tr><td><code id="cdmFlatten_+3A_includeconceptname">includeConceptName</code></td>
<td>
<p>Should concept_name and type_concept_name be
include in the output table? TRUE (default) or FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lazy query that when evaluated will result in a single table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())

cdm &lt;- cdmFromCon(con, cdmSchema = "main")

all_observations &lt;- cdmSubset(cdm, personId = c(2, 18, 42)) %&gt;%
  cdmFlatten() %&gt;%
  collect()

all_observations
#&gt; # A tibble: 213 × 8
#&gt;    person_id observation_.  start_date end_date   type_.  domain obser.  type_.
#&gt;        &lt;dbl&gt;          &lt;dbl&gt; &lt;date&gt;     &lt;date&gt;       &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;
#&gt;  1         2       40213201 1986-09-09 1986-09-09  5.81e5 drug   pneumo  &lt;NA&gt;
#&gt;  2        18        4116491 1997-11-09 1998-01-09  3.20e4 condi  Escher  &lt;NA&gt;
#&gt;  3        18       40213227 2017-01-04 2017-01-04  5.81e5 drug   tetanu  &lt;NA&gt;
#&gt;  4        42        4156265 1974-06-13 1974-06-27  3.20e4 condi  Facial  &lt;NA&gt;
#&gt;  5        18       40213160 1966-02-23 1966-02-23  5.81e5 drug   poliov  &lt;NA&gt;
#&gt;  6        42        4198190 1933-10-29 1933-10-29  3.80e7 proce  Append  &lt;NA&gt;
#&gt;  7         2        4109685 1952-07-13 1952-07-27  3.20e4 condi  Lacera  &lt;NA&gt;
#&gt;  8        18       40213260 2017-01-04 2017-01-04  5.81e5 drug   zoster  &lt;NA&gt;
#&gt;  9        42        4151422 1985-02-03 1985-02-03  3.80e7 proce  Sputum  &lt;NA&gt;
#&gt; 10         2        4163872 1993-03-29 1993-03-29  3.80e7 proce  Plain   &lt;NA&gt;
#&gt; # ... with 203 more rows, and abbreviated variable names observation_concept_id,
#&gt; #   type_concept_id, observation_concept_name, type_concept_name

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmFromCon'>Create a CDM reference object from a database connection</h2><span id='topic+cdmFromCon'></span>

<h3>Description</h3>

<p>Create a CDM reference object from a database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmFromCon(
  con,
  cdmSchema,
  writeSchema,
  cohortTables = NULL,
  cdmVersion = NULL,
  cdmName = NULL,
  achillesSchema = NULL,
  .softValidation = FALSE,
  writePrefix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdmFromCon_+3A_con">con</code></td>
<td>
<p>A DBI database connection to a database where an OMOP CDM v5.4 or
v5.3 instance is located.</p>
</td></tr>
<tr><td><code id="cdmFromCon_+3A_cdmschema">cdmSchema</code></td>
<td>
<p>The schema where the OMOP CDM tables are located. Defaults
to NULL.</p>
</td></tr>
<tr><td><code id="cdmFromCon_+3A_writeschema">writeSchema</code></td>
<td>
<p>An optional schema in the CDM database that the user has
write access to.</p>
</td></tr>
<tr><td><code id="cdmFromCon_+3A_cohorttables">cohortTables</code></td>
<td>
<p>A character vector listing the cohort table names to be
included in the CDM object.</p>
</td></tr>
<tr><td><code id="cdmFromCon_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>The version of the OMOP CDM. Cam be &quot;5.3&quot;, &quot;5.4&quot;, or NULL (default).
If NULL we will attempt to automatically determine the cdm version using
the cdm_source table and heuristics.</p>
</td></tr>
<tr><td><code id="cdmFromCon_+3A_cdmname">cdmName</code></td>
<td>
<p>The name of the CDM. If NULL (default) the cdm_source_name
.  field in the CDM_SOURCE table will be used.</p>
</td></tr>
<tr><td><code id="cdmFromCon_+3A_achillesschema">achillesSchema</code></td>
<td>
<p>An optional schema in the CDM database
that contains achilles tables.</p>
</td></tr>
<tr><td><code id="cdmFromCon_+3A_.softvalidation">.softValidation</code></td>
<td>
<p>Normally the observation period table should not
have overlapping observation periods for a single person. If <code>.softValidation</code> is <code>TRUE</code> the
validation check that looks for overlapping observation periods will be skipped.
Other analytic packages may break or produce incorrect results if <code>softValidation</code> is <code>TRUE</code> and
the observation period table contains overlapping observation periods.</p>
</td></tr>
<tr><td><code id="cdmFromCon_+3A_writeprefix">writePrefix</code></td>
<td>
<p>A prefix that will be added to all tables created in the write_schema. This
can be used to create namespace in your database write_schema for your tables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cdmFromCon creates a new cdm reference object from a DBI database connection.
In addition to the connection the user needs to pass in the schema in the database where the cdm data can
be found as well as another schema where the user has write access to create tables. Nearly all
downstream analytic packages need the ability to create temporary data in the database so the
write_schema is required.
</p>
<p>Some database systems have the idea of a catalog or a compound schema with two components.
See examples below for how to pass in catalogs and schemas.
</p>
<p>You can also specify a <code>writePrefix</code>. This is a short character string that will be added
to any tables created in the <code>writeSchema</code> effectively a namespace in the schema just for your
analysis. If the write_schema is a shared between multiple users setting a unique write_prefix
ensures you do not overwrite existing tables and allows you to easily clean up tables by
dropping all tables that start with the prefix.
</p>


<h3>Value</h3>

<p>A list of dplyr database table references pointing to CDM tables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())

# minimal example
cdm &lt;- cdmFromCon(con,
                  cdmSchema = "main",
                  writeSchema = "scratch")

# write prefix is optional but recommended if write_schema is shared
cdm &lt;- cdmFromCon(con,
                  cdmSchema = "main",
                  writeSchema = "scratch",
                  writePrefix = "tmp_")

# Some database systems use catalogs or compound schemas.
# These can be specified as follows:
cdm &lt;- cdmFromCon(con,
                  cdmSchema = "catalog.main",
                  writeSchema = "catalog.scratch",
                  writePrefix = "tmp_")

cdm &lt;- cdmFromCon(con,
                  cdmSchema = c("my_catalog", "main"),
                  writeSchema = c("my_catalog", "scratch"),
                  writePrefix = "tmp_")

cdm &lt;- cdmFromCon(con,
                  cdmSchema = c(catalog = "my_catalog", schema = "main"),
                  writeSchema = c(catalog = "my_catalog", schema = "scratch"),
                  writePrefix = "tmp_")

 DBI::dbDisconnect(con)

## End(Not run)


</code></pre>

<hr>
<h2 id='cdmSample'>Subset a cdm object to a random sample of individuals</h2><span id='topic+cdmSample'></span>

<h3>Description</h3>

<p><code>cdmSample</code> takes a cdm object and returns a new cdm that includes only a
random sample of persons in the cdm. Only <code>person_id</code>s in both the person
table and observation_period table will be considered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmSample(cdm, n, seed = sample.int(1e+06, 1), name = "person_sample")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdmSample_+3A_cdm">cdm</code></td>
<td>
<p>A cdm_reference object.</p>
</td></tr>
<tr><td><code id="cdmSample_+3A_n">n</code></td>
<td>
<p>Number of persons to include in the cdm.</p>
</td></tr>
<tr><td><code id="cdmSample_+3A_seed">seed</code></td>
<td>
<p>Seed for the random number generator.</p>
</td></tr>
<tr><td><code id="cdmSample_+3A_name">name</code></td>
<td>
<p>Name of the table that will contain the sample of persons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified cdm_reference object where all clinical tables are lazy
queries pointing to subset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())

cdm &lt;- cdmFromCon(con, cdmSchema = "main")

cdmSampled &lt;- cdmSample(cdm, n = 2)

cdmSampled$person %&gt;%
  select(person_id)
#&gt; # Source:   SQL [2 x 1]
#&gt; # Database: DuckDB 0.6.1
#&gt;   person_id
#&gt;       &lt;dbl&gt;
#&gt; 1       155
#&gt; 2      3422

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmSubset'>Subset a cdm object to a set of persons</h2><span id='topic+cdmSubset'></span>

<h3>Description</h3>

<p><code>cdmSubset</code> takes a cdm object and a list of person IDs as input. It
returns a new cdm that includes data only for persons matching the provided
person IDs. Generated cohorts in the cdm will also be subset to
the IDs provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmSubset(cdm, personId)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdmSubset_+3A_cdm">cdm</code></td>
<td>
<p>A cdm_reference object</p>
</td></tr>
<tr><td><code id="cdmSubset_+3A_personid">personId</code></td>
<td>
<p>A numeric vector of person IDs to include in the cdm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified cdm_reference object where all clinical tables are lazy
queries pointing to subset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())

cdm &lt;- cdmFromCon(con, cdmSchema = "main")

cdm2 &lt;- cdmSubset(cdm, personId = c(2, 18, 42))

cdm2$person %&gt;%
  select(1:3)
#&gt; # Source:   SQL [3 x 3]
#&gt; # Database: DuckDB 0.6.1
#&gt;   person_id gender_concept_id year_of_birth
#&gt;       &lt;dbl&gt;             &lt;dbl&gt;         &lt;dbl&gt;
#&gt; 1         2              8532          1920
#&gt; 2        18              8532          1965
#&gt; 3        42              8532          1909

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmSubsetCohort'>Subset a cdm to the individuals in one or more cohorts</h2><span id='topic+cdmSubsetCohort'></span>

<h3>Description</h3>

<p><code>cdmSubset</code> will return a new cdm object that contains lazy queries pointing
to each of the cdm tables but subset to individuals in a generated cohort.
Since the cdm tables are lazy queries, the subset operation will only be
done when the tables are used. <code>computeQuery</code> can be used to run the SQL
used to subset a cdm table and store it as a new table in the database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmSubsetCohort(cdm, cohortTable = "cohort", cohortId = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdmSubsetCohort_+3A_cdm">cdm</code></td>
<td>
<p>A cdm_reference object</p>
</td></tr>
<tr><td><code id="cdmSubsetCohort_+3A_cohorttable">cohortTable</code></td>
<td>
<p>The name of a cohort table in the cdm reference</p>
</td></tr>
<tr><td><code id="cdmSubsetCohort_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts that we want to subset from the cohort
table. If NULL (default) all cohorts in cohort table are considered.</p>
</td></tr>
<tr><td><code id="cdmSubsetCohort_+3A_verbose">verbose</code></td>
<td>
<p>Should subset messages be printed? TRUE or FALSE (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified cdm_reference with all clinical tables subset
to just the persons in the selected cohorts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
library(dplyr, warn.conflicts = FALSE)

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())

cdm &lt;- cdmFromCon(con, cdmSchema = "main", writeSchema = "main")

# generate a cohort
path &lt;- system.file("cohorts2", mustWork = TRUE, package = "CDMConnector")

cohortSet &lt;- readCohortSet(path) %&gt;%
  filter(cohort_name == "GIBleed_male")

# subset cdm to persons in the generated cohort
cdm &lt;- generateCohortSet(cdm, cohortSet = cohortSet, name = "gibleed")

cdmGiBleed &lt;- cdmSubsetCohort(cdm, cohortTable = "gibleed")

cdmGiBleed$person %&gt;%
  tally()
#&gt; # Source:   SQL [1 x 1]
#&gt; # Database: DuckDB 0.6.1
#&gt;       n
#&gt;   &lt;dbl&gt;
#&gt; 1   237

cdm$person %&gt;%
  tally()
#&gt; # Source:   SQL [1 x 1]
#&gt; # Database: DuckDB 0.6.1
#&gt;       n
#&gt;   &lt;dbl&gt;
#&gt; 1  2694


DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cdmWriteSchema'>Get cdm write schema</h2><span id='topic+cdmWriteSchema'></span>

<h3>Description</h3>

<p>Get cdm write schema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdmWriteSchema(cdm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdmWriteSchema_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>cdmFromCon</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The database write schema
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomiaDir())

cdm &lt;- cdmFromCon(con = con, cdmName = "Eunomia",
                  cdmSchema =  "main", writeSchema = "main")

cdmWriteSchema(cdm)

DBI::dbDisconnect(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='computeQuery'>Execute dplyr query and save result in remote database</h2><span id='topic+computeQuery'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code>dplyr::compute</code> that is tested on several
database systems. It is needed to handle edge cases where <code>dplyr::compute</code>
does not produce correct SQL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeQuery(
  x,
  name = uniqueTableName(),
  temporary = TRUE,
  schema = NULL,
  overwrite = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeQuery_+3A_x">x</code></td>
<td>
<p>A dplyr query</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_name">name</code></td>
<td>
<p>The name of the table to create.</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_temporary">temporary</code></td>
<td>
<p>Should the table be temporary: TRUE (default) or FALSE</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_schema">schema</code></td>
<td>
<p>The schema where the table should be created. Ignored if
temporary = TRUE.</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the table be overwritten if it already exists: TRUE (default)
or FALSE Ignored if temporary = TRUE.</p>
</td></tr>
<tr><td><code id="computeQuery_+3A_...">...</code></td>
<td>
<p>Further arguments passed on the <code>dplyr::compute</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dplyr::tbl()</code> reference to the newly created table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)

con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomiaDir())
cdm &lt;- cdmFromCon(con, "main")

# create a temporary table in the remote database from a dplyr query
drugCount &lt;- cdm$concept %&gt;%
  dplyr::count(domain_id == "Drug") %&gt;%
  computeQuery()

# create a permanent table in the remote database from a dplyr query
drugCount &lt;- cdm$concept %&gt;%
  dplyr::count(domain_id == "Drug") %&gt;%
  computeQuery("tmp_table", temporary = FALSE, schema = "main")

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='copyCdmTo'>Copy a cdm object from one database to another</h2><span id='topic+copyCdmTo'></span>

<h3>Description</h3>

<p>It may be helpful to be able to easily copy a small test cdm from a local
database to a remote for testing. copyCdmTo takes a cdm object and a connection.
It copies the cdm to the remote database connection. CDM tables can be prefixed
in the new database allowing for multiple cdms in a single shared database
schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copyCdmTo(con, cdm, schema, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copyCdmTo_+3A_con">con</code></td>
<td>
<p>A DBI datbase connection created by <code>DBI::dbConnect</code></p>
</td></tr>
<tr><td><code id="copyCdmTo_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>CDMConnector::cdmFromCon</code> or <code>CDMConnector::cdm_from_con</code></p>
</td></tr>
<tr><td><code id="copyCdmTo_+3A_schema">schema</code></td>
<td>
<p>schema name in the remote database where the user has write permission</p>
</td></tr>
<tr><td><code id="copyCdmTo_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the cohort table be overwritten if it already exists? TRUE or FALSE (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cdm reference object pointing to the newly created cdm in the remote database
</p>

<hr>
<h2 id='dateadd'>Add days or years to a date in a dplyr query</h2><span id='topic+dateadd'></span>

<h3>Description</h3>

<p>This function must be &quot;unquoted&quot; using the &quot;bang bang&quot; operator (!!). See example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dateadd(date, number, interval = "day")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dateadd_+3A_date">date</code></td>
<td>
<p>The name of a date column in the database table as a character string</p>
</td></tr>
<tr><td><code id="dateadd_+3A_number">number</code></td>
<td>
<p>The number of units to add. Can be a positive or negative whole number.</p>
</td></tr>
<tr><td><code id="dateadd_+3A_interval">interval</code></td>
<td>
<p>The units to add. Must be either &quot;day&quot; (default) or &quot;year&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Platform specific SQL that can be used in a dplyr query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb())
date_tbl &lt;- dplyr::copy_to(con, data.frame(date1 = as.Date("1999-01-01")),
                           name = "tmpdate", overwrite = TRUE, temporary = TRUE)

df &lt;- date_tbl %&gt;%
  dplyr::mutate(date2 = !!dateadd("date1", 1, interval = "year")) %&gt;%
  dplyr::collect()

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='datediff'>Compute the difference between two days</h2><span id='topic+datediff'></span>

<h3>Description</h3>

<p>This function must be &quot;unquoted&quot; using the &quot;bang bang&quot; operator (!!). See example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datediff(start, end, interval = "day")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="datediff_+3A_start">start</code></td>
<td>
<p>The name of the start date column in the database as a string.</p>
</td></tr>
<tr><td><code id="datediff_+3A_end">end</code></td>
<td>
<p>The name of the end date column in the database as a string.</p>
</td></tr>
<tr><td><code id="datediff_+3A_interval">interval</code></td>
<td>
<p>The units to use for difference calculation. Must be either &quot;day&quot; (default) or &quot;year&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Platform specific SQL that can be used in a dplyr query.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb())
date_tbl &lt;- dplyr::copy_to(con, data.frame(date1 = as.Date("1999-01-01")),
                           name = "tmpdate", overwrite = TRUE, temporary = TRUE)

df &lt;- date_tbl %&gt;%
  dplyr::mutate(date2 = !!dateadd("date1", 1, interval = "year")) %&gt;%
  dplyr::mutate(dif_years = !!datediff("date1", "date2", interval = "year")) %&gt;%
  dplyr::collect()

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='datepart'>Extract the day, month or year of a date in a dplyr pipeline</h2><span id='topic+datepart'></span>

<h3>Description</h3>

<p>Extract the day, month or year of a date in a dplyr pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datepart(date, interval = "year", dbms = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="datepart_+3A_date">date</code></td>
<td>
<p>Character string that represents to a date column.</p>
</td></tr>
<tr><td><code id="datepart_+3A_interval">interval</code></td>
<td>
<p>Interval to extract from a date. Valid options are &quot;year&quot;, &quot;month&quot;, or &quot;day&quot;.</p>
</td></tr>
<tr><td><code id="datepart_+3A_dbms">dbms</code></td>
<td>
<p>Database system, if NULL it is auto detected.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), ":memory:")
date_tbl &lt;- dplyr::copy_to(con,
                           data.frame(birth_date = as.Date("1993-04-19")),
                           name = "tmp",
                           temporary = TRUE)
df &lt;- date_tbl %&gt;%
  dplyr::mutate(year = !!datepart("birth_date", "year")) %&gt;%
  dplyr::mutate(month = !!datepart("birth_date", "month")) %&gt;%
  dplyr::mutate(day = !!datepart("birth_date", "day")) %&gt;%
  dplyr::collect()
DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dbms'>Get the database management system (dbms) from a cdm_reference or DBI
connection</h2><span id='topic+dbms'></span>

<h3>Description</h3>

<p>Get the database management system (dbms) from a cdm_reference or DBI
connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbms(con)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbms_+3A_con">con</code></td>
<td>
<p>A DBI connection or cdm_reference</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string representing the dbms that can be used with
SqlRender
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomiaDir())
cdm &lt;- cdmFromCon(con)
dbms(cdm)
dbms(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='dbSource'>Create a source for a cdm in a database.</h2><span id='topic+dbSource'></span>

<h3>Description</h3>

<p>Create a source for a cdm in a database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbSource(con, writeSchema)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dbSource_+3A_con">con</code></td>
<td>
<p>Connection to a database.</p>
</td></tr>
<tr><td><code id="dbSource_+3A_writeschema">writeSchema</code></td>
<td>
<p>Schema where cohort tables are. You must have read and
write access to it.</p>
</td></tr>
</table>

<hr>
<h2 id='downloadEunomiaData'>Download Eunomia data files</h2><span id='topic+downloadEunomiaData'></span>

<h3>Description</h3>

<p>Download the Eunomia data files from https://github.com/darwin-eu/EunomiaDatasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadEunomiaData(
  datasetName = "GiBleed",
  cdmVersion = "5.3",
  pathToData = Sys.getenv("EUNOMIA_DATA_FOLDER"),
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="downloadEunomiaData_+3A_datasetname">datasetName</code></td>
<td>
<p>The data set name as found on https://github.com/darwin-eu/EunomiaDatasets. The
data set name corresponds to the folder with the data set ZIP files</p>
</td></tr>
<tr><td><code id="downloadEunomiaData_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>The OMOP CDM version. This version will appear in the suffix of the data file,
for example: synpuf_5.3.zip. Must be '5.3' (default) or '5.4'.</p>
</td></tr>
<tr><td><code id="downloadEunomiaData_+3A_pathtodata">pathToData</code></td>
<td>
<p>The path where the Eunomia data is stored on the file system., By default the
value of the environment variable &quot;EUNOMIA_DATA_FOLDER&quot; is used.</p>
</td></tr>
<tr><td><code id="downloadEunomiaData_+3A_overwrite">overwrite</code></td>
<td>
<p>Control whether the existing archive file will be overwritten should it already exist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the destination if the download was successful.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
downloadEunomiaData("GiBleed")

## End(Not run)
</code></pre>

<hr>
<h2 id='dropTable.db_cdm'>Drop table from a database backed cdm object</h2><span id='topic+dropTable.db_cdm'></span>

<h3>Description</h3>

<p>Tables will be dropped from the write schema of the cdm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropTable.db_cdm(cdm, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropTable.db_cdm_+3A_cdm">cdm</code></td>
<td>
<p>a cdm_reference object</p>
</td></tr>
<tr><td><code id="dropTable.db_cdm_+3A_name">name</code></td>
<td>
<p>A character vector of table names to be dropped</p>
</td></tr>
</table>

<hr>
<h2 id='eunomiaDir'>Create a copy of an example OMOP CDM dataset</h2><span id='topic+eunomiaDir'></span>

<h3>Description</h3>

<p>Eunomia is an OHDSI project that provides several example OMOP CDM datasets for testing and development.
This function creates a copy of a Eunomia database in <a href="https://duckdb.org/">duckdb</a> and returns
the path to the new database file. If the dataset does not yet exist on the user's computer it
will attempt to download the source data to the the path defined by the EUNOMIA_DATA_FOLDER environment variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eunomiaDir(
  datasetName = "GiBleed",
  cdmVersion = "5.3",
  databaseFile = tempfile(fileext = ".duckdb")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eunomiaDir_+3A_datasetname">datasetName</code></td>
<td>
<p>One of &quot;GiBleed&quot; (default),
&quot;synthea-allergies-10k&quot;,
&quot;synthea-anemia-10k&quot;,
&quot;synthea-breast_cancer-10k&quot;,
&quot;synthea-contraceptives-10k&quot;,
&quot;synthea-covid19-10k&quot;,
&quot;synthea-covid19-200k&quot;,
&quot;synthea-dermatitis-10k&quot;,
&quot;synthea-heart-10k&quot;,
&quot;synthea-hiv-10k&quot;,
&quot;synthea-lung_cancer-10k&quot;,
&quot;synthea-medications-10k&quot;,
&quot;synthea-metabolic_syndrome-10k&quot;,
&quot;synthea-opioid_addiction-10k&quot;,
&quot;synthea-rheumatoid_arthritis-10k&quot;,
&quot;synthea-snf-10k&quot;,
&quot;synthea-surgery-10k&quot;,
&quot;synthea-total_joint_replacement-10k&quot;,
&quot;synthea-veteran_prostate_cancer-10k&quot;,
&quot;synthea-veterans-10k&quot;,
&quot;synthea-weight_loss-10k&quot;,
&quot;empty_cdm&quot;,
&quot;synpuf-1k&quot;</p>
</td></tr>
<tr><td><code id="eunomiaDir_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>The OMOP CDM version. Must be &quot;5.3&quot; or &quot;5.4&quot;.</p>
</td></tr>
<tr><td><code id="eunomiaDir_+3A_databasefile">databaseFile</code></td>
<td>
<p>The full path to the new copy of the example CDM dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the Eunomia datasets available in CDMConnector are from the Synthea project. Synthea is an open-source
synthetic patient generator that models the medical history of synthetic patients. The Synthea datasets are
generated using the Synthea tool and then converted to the OMOP CDM format using the OHDSI
ETL-Synthea project <a href="https://ohdsi.github.io/ETL-Synthea/">https://ohdsi.github.io/ETL-Synthea/</a>. Currently the synthea datasets
are only available in the OMOP CDM v5.3 format. See <a href="https://synthetichealth.github.io/synthea/">https://synthetichealth.github.io/synthea/</a>
for details on the Synthea project.
</p>
<p>In addition to Synthea, the Eunomia project provides the CMS Synthetic Public Use Files (SynPUFs) in both
5.3 and 5.4 OMOP CDM formats. This data is synthetic US Medicare claims data mapped to OMOP CDM format.
The OMOP CDM has a set of optional metadata tables, called Achilles tables, that
include pre-computed analytics about the entire dataset such as record and person counts.
The Eunomia Synpuf datasets include the Achilles tables.
</p>
<p>Eunomia also provides empty cdms that can be used as a starting point for creating a new example CDM.
This is useful for creating test data for studies or analytic packages.
The empty CDM includes the vocabulary tables and all OMOP CDM tables but
the clinical tables are empty and need to be populated with data. For additional information on
creating small test CDM datasets see <a href="https://ohdsi.github.io/omock/">https://ohdsi.github.io/omock/</a> and
<a href="https://darwin-eu.github.io/TestGenerator/">https://darwin-eu.github.io/TestGenerator/</a>.
</p>
<p>To contribute synthetic observational health data to the Eunomia project please
open an issue at <a href="https://github.com/OHDSI/Eunomia/issues/">https://github.com/OHDSI/Eunomia/issues/</a>
</p>
<p>Setup: To use the <code>eunomiaDir</code> function please set the <code>EUNOMIA_DATA_FOLDER</code> in your .Renviron file
to a folder on your computer where the datasets will be downloaded to. This file can
be opened by calling <code>usethis::edit_r_environ()</code>.
</p>


<h3>Value</h3>

<p>The file path to the new Eunomia dataset copy
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

 # The defaults GiBleed dataset is a small dataset that is useful for testing
 library(CDMConnector)
 con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())
 cdm &lt;- cdmFromCon(con, "main", "main")
 cdmDisconnect(cdm)

 # Synpuf datasets include the Achilles tables
 con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir("synpuf-1k", "5.3"))
 cdm &lt;- cdmFromCon(con, "main", "main", achillesSchema = "main")
 cdmDisconnect(cdm)

 # Currently the only 5.4 dataset is synpuf-1k
 con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir("synpuf-1k", "5.4"))
 cdm &lt;- cdmFromCon(con, "main", "main", achillesSchema = "main")
 cdmDisconnect(cdm)


## End(Not run)
</code></pre>

<hr>
<h2 id='eunomiaIsAvailable'>Has the Eunomia dataset been cached?</h2><span id='topic+eunomiaIsAvailable'></span>

<h3>Description</h3>

<p>Has the Eunomia dataset been cached?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eunomiaIsAvailable(datasetName = "GiBleed", cdmVersion = "5.3")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eunomiaIsAvailable_+3A_datasetname">datasetName</code></td>
<td>
<p>Name of the Eunomia dataset to check. Defaults to &quot;GiBleed&quot;.</p>
</td></tr>
<tr><td><code id="eunomiaIsAvailable_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>Version of the Eunomia dataset to check. Must be &quot;5.3&quot; or &quot;5.4&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the eunomia example dataset is available and FASLE otherwise
</p>

<hr>
<h2 id='exampleDatasets'>List the available example CDM datasets</h2><span id='topic+exampleDatasets'></span>

<h3>Description</h3>

<p>List the available example CDM datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exampleDatasets()
</code></pre>


<h3>Value</h3>

<p>A character vector with example CDM dataset identifiers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
exampleDatasets()[1]
#&gt; [1] "GiBleed"

con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir("GiBleed"))
cdm &lt;- cdmFromCon(con)

## End(Not run)
</code></pre>

<hr>
<h2 id='generateCohortSet'>Generate a cohort set on a cdm object</h2><span id='topic+generateCohortSet'></span>

<h3>Description</h3>

<p>A &quot;chort_table&quot; object consists of four components
</p>

<ul>
<li><p>A remote table reference to an OHDSI cohort table with at least
the columns: cohort_definition_id, subject_id, cohort_start_date,
cohort_end_date. Additional columns are optional and some analytic
packages define additional columns specific to certain analytic
cohorts.
</p>
</li>
<li><p>A <strong>settings attribute</strong> which points to a remote table containing
cohort settings including the names of the cohorts.
</p>
</li>
<li><p>An <strong>attrition attribute</strong> which points to a remote table with
attrition information recorded during generation. This attribute is
optional. Since calculating attrition takes additional compute it
can be skipped resulting in a NULL attrition attribute.
</p>
</li>
<li><p>A <strong>cohortCounts attribute</strong> which points to a remote table
containing cohort counts
</p>
</li></ul>

<p>Each of the three attributes are tidy tables. The implementation of this
object is experimental and user feedback is welcome.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
One key design principle is that cohort_table objects are created once
and can persist across analysis execution but should not be modified after
creation. While it is possible to modify a cohort_table object doing
so will invalidate it and it's attributes may no longer be accurate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCohortSet(
  cdm,
  cohortSet,
  name,
  computeAttrition = TRUE,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateCohortSet_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference created by CDMConnector. write_schema must be
specified.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_cohortset">cohortSet</code></td>
<td>
<p>A cohortSet dataframe created with <code>readCohortSet()</code></p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_name">name</code></td>
<td>
<p>Name of the cohort table to be created. This will also be used
as a prefix for the cohort attribute tables. This must be a lowercase character string
that starts with a letter and only contains letters, numbers, and underscores.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_computeattrition">computeAttrition</code></td>
<td>
<p>Should attrition be computed? TRUE (default) or FALSE</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the cohort table be overwritten if it already
exists? TRUE (default) or FALSE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())
cdm &lt;- cdmFromCon(con,
                  cdmSchema = "main",
                  writeSchema = "main")

cohortSet &lt;- readCohortSet(system.file("cohorts2", package = "CDMConnector"))
cdm &lt;- generateCohortSet(cdm, cohortSet, name = "cohort")

print(cdm$cohort)

attrition(cdm$cohort)
settings(cdm$cohort)
cohortCount(cdm$cohort)

## End(Not run)
</code></pre>

<hr>
<h2 id='generateConceptCohortSet'>Create a new generated cohort set from a list of concept sets</h2><span id='topic+generateConceptCohortSet'></span>

<h3>Description</h3>

<p>Generate a new cohort set from one or more concept sets. Each
concept set will result in one cohort and represent the time during which
the concept was observed for each subject/person. Concept sets can be
passed to this function as:
</p>

<ul>
<li><p>A named list of numeric vectors, one vector per concept set
</p>
</li>
<li><p>A named list of Capr concept sets
</p>
</li></ul>

<p>Clinical observation records will be looked up in the respective domain tables
using the vocabulary in the CDM. If a required domain table does not exist in
the cdm object a warning will be given.
Concepts that are not in the vocabulary or in the data will be silently ignored.
If end dates are missing or do not exist, as in the case of the procedure and
observation domains, the the start date will be used as the end date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateConceptCohortSet(
  cdm,
  conceptSet = NULL,
  name,
  limit = "first",
  requiredObservation = c(0, 0),
  end = "observation_period_end_date",
  subsetCohort = NULL,
  subsetCohortId = NULL,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateConceptCohortSet_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference object created by <code>CDMConnector::cdmFromCon</code> or <code>CDMConnector::cdm_from_con</code></p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_conceptset">conceptSet</code></td>
<td>
<p>A named list of numeric vectors or a Concept Set Expression created
<code>omopgenerics::newConceptSetExpression</code></p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_name">name</code></td>
<td>
<p>The name of the new generated cohort table as a character string</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_limit">limit</code></td>
<td>
<p>Include &quot;first&quot; (default) or &quot;all&quot; occurrences of events in the cohort
</p>

<ul>
<li><p>&quot;first&quot; will include only the first occurrence of any event in the concept set in the cohort.
</p>
</li>
<li><p>&quot;all&quot; will include all occurrences of the events defined by the concept set in the cohort.
</p>
</li></ul>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_requiredobservation">requiredObservation</code></td>
<td>
<p>A numeric vector of length 2 that specifies the number of days of
required observation time prior to index and post index for an event to be included in the cohort.</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_end">end</code></td>
<td>
<p>How should the <code>cohort_end_date</code> be defined?
</p>

<ul>
<li><p>&quot;observation_period_end_date&quot; (default): The earliest observation_period_end_date after the event start date
</p>
</li>
<li><p>numeric scalar: A fixed number of days from the event start date
</p>
</li>
<li><p>&quot;event_end_date&quot;: The event end date. If the event end date is not populated then the event start date will be used
</p>
</li></ul>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_subsetcohort">subsetCohort</code></td>
<td>
<p>A cohort table containing the individuals for which to
generate cohorts for. Only individuals in the cohort table will appear in
the created generated cohort set.</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_subsetcohortid">subsetCohortId</code></td>
<td>
<p>A set of cohort IDs from the cohort table for which
to include. If none are provided, all cohorts in the cohort table will
be included.</p>
</td></tr>
<tr><td><code id="generateConceptCohortSet_+3A_overwrite">overwrite</code></td>
<td>
<p>Should the cohort table be overwritten if it already exists? TRUE (default) or FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cdm reference object with the new generated cohort set table added
</p>

<hr>
<h2 id='inSchema'>Helper for working with compound schemas</h2><span id='topic+inSchema'></span>

<h3>Description</h3>

<p>This is similar to dbplyr::in_schema but has been tested across multiple
database platforms. It only exists to work around some of the limitations
of dbplyr::in_schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inSchema(schema, table, dbms = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inSchema_+3A_schema">schema</code></td>
<td>
<p>A schema name as a character string</p>
</td></tr>
<tr><td><code id="inSchema_+3A_table">table</code></td>
<td>
<p>A table name as character string</p>
</td></tr>
<tr><td><code id="inSchema_+3A_dbms">dbms</code></td>
<td>
<p>The name of the database management system as returned
by <code>dbms(connection)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DBI::Id that represents a qualified table and schema
</p>

<hr>
<h2 id='listTables'>List tables in a schema</h2><span id='topic+listTables'></span>

<h3>Description</h3>

<p>DBI::dbListTables can be used to get all tables in a database but not always in a
specific schema. <code>listTables</code> will list tables in a schema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listTables(con, schema = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listTables_+3A_con">con</code></td>
<td>
<p>A DBI connection to a database</p>
</td></tr>
<tr><td><code id="listTables_+3A_schema">schema</code></td>
<td>
<p>The name of a schema in a database. If NULL, returns DBI::dbListTables(con).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of table names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb(), dbdir = eunomiaDir())
listTables(con, schema = "main")

## End(Not run)
</code></pre>

<hr>
<h2 id='readCohortSet'>Read a set of cohort definitions into R</h2><span id='topic+readCohortSet'></span>

<h3>Description</h3>

<p>A &quot;cohort set&quot; is a collection of cohort definitions. In R this is stored in
a dataframe with cohort_definition_id, cohort_name, and cohort columns.
On disk this is stored as a folder with a CohortsToCreate.csv file and
one or more json files.
If the CohortsToCreate.csv file is missing then all of the json files in the
folder will be used, cohort_definition_id will be automatically assigned
in alphabetical order, and cohort_name will match the file names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCohortSet(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readCohortSet_+3A_path">path</code></td>
<td>
<p>The path to a folder containing Circe cohort definition
json files and optionally a csv file named CohortsToCreate.csv with columns
cohortId, cohortName, and jsonPath.</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+compute'></span><span id='topic+cohortCount'></span><span id='topic+settings'></span><span id='topic+attrition'></span><span id='topic+newCohortTable'></span><span id='topic+cdmDisconnect'></span><span id='topic+insertTable'></span><span id='topic+insertCdmTo'></span><span id='topic+dropTable'></span><span id='topic+readSourceTable'></span><span id='topic+dropSourceTable'></span><span id='topic+listSourceTables'></span><span id='topic+bind'></span><span id='topic+cdmVersion'></span><span id='topic+cdmFromTables'></span><span id='topic+cohortCodelist'></span><span id='topic+cdmName'></span><span id='topic+recordCohortAttrition'></span><span id='topic+uniqueTableName'></span><span id='topic+cdmSelect'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+compute">compute</a></code></p>
</dd>
<dt>omopgenerics</dt><dd><p><code><a href="omopgenerics.html#topic+attrition">attrition</a></code>, <code><a href="omopgenerics.html#topic+bind">bind</a></code>, <code><a href="omopgenerics.html#topic+cdmDisconnect">cdmDisconnect</a></code>, <code><a href="omopgenerics.html#topic+cdmFromTables">cdmFromTables</a></code>, <code><a href="omopgenerics.html#topic+cdmName">cdmName</a></code>, <code><a href="omopgenerics.html#topic+cdmSelect">cdmSelect</a></code>, <code><a href="omopgenerics.html#topic+cdmVersion">cdmVersion</a></code>, <code><a href="omopgenerics.html#topic+cohortCodelist">cohortCodelist</a></code>, <code><a href="omopgenerics.html#topic+cohortCount">cohortCount</a></code>, <code><a href="omopgenerics.html#topic+dropSourceTable">dropSourceTable</a></code>, <code><a href="omopgenerics.html#topic+dropTable">dropTable</a></code>, <code><a href="omopgenerics.html#topic+insertCdmTo">insertCdmTo</a></code>, <code><a href="omopgenerics.html#topic+insertTable">insertTable</a></code>, <code><a href="omopgenerics.html#topic+listSourceTables">listSourceTables</a></code>, <code><a href="omopgenerics.html#topic+newCohortTable">newCohortTable</a></code>, <code><a href="omopgenerics.html#topic+readSourceTable">readSourceTable</a></code>, <code><a href="omopgenerics.html#topic+recordCohortAttrition">recordCohortAttrition</a></code>, <code><a href="omopgenerics.html#topic+settings">settings</a></code>, <code><a href="omopgenerics.html#topic+uniqueTableName">uniqueTableName</a></code></p>
</dd>
</dl>

<hr>
<h2 id='requireEunomia'>Require eunomia to be available. The function makes sure that you can later
create a eunomia database with <code>eunomiaDir()</code>.</h2><span id='topic+requireEunomia'></span>

<h3>Description</h3>

<p>Require eunomia to be available. The function makes sure that you can later
create a eunomia database with <code>eunomiaDir()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireEunomia(datasetName = "GiBleed", cdmVersion = "5.3")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="requireEunomia_+3A_datasetname">datasetName</code></td>
<td>
<p>Name of the Eunomia dataset to check. Defaults to &quot;GiBleed&quot;.</p>
</td></tr>
<tr><td><code id="requireEunomia_+3A_cdmversion">cdmVersion</code></td>
<td>
<p>Version of the Eunomia dataset to check. Must be &quot;5.3&quot; or &quot;5.4&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Path to eunomia database.
</p>

<hr>
<h2 id='snapshot'>Extract CDM metadata</h2><span id='topic+snapshot'></span>

<h3>Description</h3>

<p>Extract the name, version, and selected record counts from a cdm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snapshot(cdm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snapshot_+3A_cdm">cdm</code></td>
<td>
<p>A cdm object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of attributes about the cdm including selected fields
from the cdm_source table and record counts from the person and
observation_period tables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())
cdm &lt;- cdmFromCon(con, "main")
snapshot(cdm)

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='summariseQuantile'>Quantile calculation using dbplyr</h2><span id='topic+summariseQuantile'></span>

<h3>Description</h3>

<p>This function provides DBMS independent syntax for quantiles estimation.
Can be used by itself or in combination with <code>mutate()</code>
when calculating other aggregate metrics (min, max, mean).
</p>
<p><code>summarise_quantile()</code>, <code>summarize_quantile()</code>, <code>summariseQuantile()</code> and <code>summarizeQuantile()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summariseQuantile(.data, x = NULL, probs, nameSuffix = "value")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summariseQuantile_+3A_.data">.data</code></td>
<td>
<p>lazy data frame backed by a database query.</p>
</td></tr>
<tr><td><code id="summariseQuantile_+3A_x">x</code></td>
<td>
<p>column name whose sample quantiles are wanted.</p>
</td></tr>
<tr><td><code id="summariseQuantile_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1].</p>
</td></tr>
<tr><td><code id="summariseQuantile_+3A_namesuffix">nameSuffix</code></td>
<td>
<p>character; is appended to numerical quantile value as a column name part.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented quantiles estimation algorithm returns values analogous to
<code style="white-space: pre;">&#8288;quantile{stats}&#8288;</code> with argument <code>type = 1</code>.
See discussion in Hyndman and Fan (1996).
Results differ from <code>PERCENTILE_CONT</code> natively implemented in various DBMS,
where returned values are equal to <code style="white-space: pre;">&#8288;quantile{stats}&#8288;</code> with default argument <code>type = 7</code>
</p>


<h3>Value</h3>

<p>An object of the same type as '.data'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(duckdb::duckdb())
mtcars_tbl &lt;- dplyr::copy_to(con, mtcars, name = "tmp", overwrite = TRUE, temporary = TRUE)

df &lt;- mtcars_tbl %&gt;%
 dplyr::group_by(cyl) %&gt;%
 dplyr::mutate(mean = mean(mpg, na.rm = TRUE)) %&gt;%
 summariseQuantile(mpg, probs = c(0, 0.2, 0.4, 0.6, 0.8, 1),
                   nameSuffix = "quant") %&gt;%
 dplyr::collect()

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='tblGroup'>CDM table selection helper</h2><span id='topic+tblGroup'></span>

<h3>Description</h3>

<p>The OMOP CDM tables are grouped together and the <code>tblGroup</code> function allows
users to easily create a CDM reference including one or more table groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tblGroup(group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tblGroup_+3A_group">group</code></td>
<td>
<p>A character vector of CDM table groups: &quot;vocab&quot;, &quot;clinical&quot;,
&quot;all&quot;, &quot;default&quot;, &quot;derived&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><img src="../help/figures/cdm54.png" width="100%" alt="CDM 5.4" />
</p>
<p>The &quot;default&quot; table group is meant to capture the most commonly used set
of CDM tables. Currently the &quot;default&quot; group is: person,
observation_period, visit_occurrence,
visit_detail, condition_occurrence, drug_exposure, procedure_occurrence,
device_exposure, measurement, observation, death, note, note_nlp, specimen,
fact_relationship, location, care_site, provider, payer_plan_period,
cost, drug_era, dose_era, condition_era, concept, vocabulary,
concept_relationship, concept_ancestor, concept_synonym, drug_strength
</p>


<h3>Value</h3>

<p>A character vector of CDM tables names in the groups
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
con &lt;- DBI::dbConnect(RPostgres::Postgres(),
                      dbname = "cdm",
                      host = "localhost",
                      user = "postgres",
                      password = Sys.getenv("PASSWORD"))

cdm &lt;- cdmFromCon(con, cdmName = "test", cdmSchema = "public") %&gt;%
  cdmSelectTbl(tblGroup("vocab"))

## End(Not run)
</code></pre>

<hr>
<h2 id='version'>Get the CDM version</h2><span id='topic+version'></span>

<h3>Description</h3>

<p>Extract the CDM version attribute from a cdm_reference object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version(cdm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="version_+3A_cdm">cdm</code></td>
<td>
<p>A cdm object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;5.3&quot; or &quot;5.4&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(CDMConnector)
con &lt;- DBI::dbConnect(duckdb::duckdb(), eunomiaDir())
cdm &lt;- cdmFromCon(con, cdmSchema = "main", writeSchema = "main")
version(cdm)

DBI::dbDisconnect(con, shutdown = TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
