<!DOCTYPE html><html><head><title>Help for package CKMRpop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CKMRpop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#amm2tibble'><p>convert an ancestry-matching matrix to a ggplot-able tibble</p></a></li>
<li><a href='#anc_match_masks'><p>Return ancestry-matrix-zone masks for different relationship types</p></a></li>
<li><a href='#ancestor_abbrvs'><p>Return a string of ancestor abbreviations in the order of the ancestor vectors</p></a></li>
<li><a href='#ancestor_vectors_cpp'><p>Function to make a vector of all the ancestors of an individual out to n generations.</p></a></li>
<li><a href='#basic_amm_plot'><p>here is a function to plot a basic ancestry match matrix</p></a></li>
<li><a href='#cat_dom_relat'><p>Categorize the dominant relationship from an ancestry match matrix</p></a></li>
<li><a href='#compile_related_pairs'><p>compile pairwise relationships from the samples</p></a></li>
<li><a href='#count_and_plot_ancestry_matrices'><p>Count up the number of different kinds of related pairs and make a plot</p></a></li>
<li><a href='#count_and_plot_mate_distribution'><p>Count and plot the number of mates each individuals has produced offspring with</p></a></li>
<li><a href='#downsample_pairs'><p>downsample the number of individuals sampled</p></a></li>
<li><a href='#example_amms'><p>a list of examples of ancestry-match matrices</p></a></li>
<li><a href='#find_ancestors_and_relatives_of_samples'><p>Find ancestors and relative of each sampled member of a pedigree</p></a></li>
<li><a href='#gg_add_generation_bands'><p>Add bands of transparent colors to denote generations on plots of ancestor-match matrices</p></a></li>
<li><a href='#gg_add_zone_perimeters'><p>Add perimeters around the relationship zones</p></a></li>
<li><a href='#ggplot_census_by_year_age_sex'><p>Just a simple plot function</p></a></li>
<li><a href='#half_first_cousin_amm'><p>A half-first cousin ancestry match matrix</p></a></li>
<li><a href='#install_spip'><p>Download the spip binary and install it where CKMRpop expects it</p></a></li>
<li><a href='#int_pow2'><p>Exponentiation function for integer arguments</p></a></li>
<li><a href='#leslie_from_spip'><p>Return a Leslie-like matrix from the spip parameters</p></a></li>
<li><a href='#plot_amm_from_matrix'><p>plot an ancestry matrix (or multiple such matrices) from its (their) matrix form</p></a></li>
<li><a href='#plot_conn_comps'><p>plot the graph showing the connected components</p></a></li>
<li><a href='#prepare_for_dfs'><p>Prepare input for the DFS relative-finding algorithm</p></a></li>
<li><a href='#primary_ancestor_pairs'><p>Return a list of the indices of the primary shared ancestors</p></a></li>
<li><a href='#rcpp_ancestors_and_relatives'><p>function to test and use DFS stuff</p></a></li>
<li><a href='#recapture_pairs'><p>Return the recaptures from amongst the samples</p></a></li>
<li><a href='#relationship_zone_names'><p>relationship zone names</p></a></li>
<li><a href='#relationship_zone_perimeters'><p>Return the perimeters of all the relationship zones</p></a></li>
<li><a href='#relpair_conn_comps'><p>Find connected components amongst the related pairs</p></a></li>
<li><a href='#run_spip'><p>Run spip in a user-specified directory</p></a></li>
<li><a href='#search_down'><p>Depth first search down the pedigree to N generations.</p></a></li>
<li><a href='#search_up'><p>Depth first search up the pedigree to N generations.</p></a></li>
<li><a href='#slurp_spip'><p>Read in the pedigree, census, and sampling information from the spip run</p></a></li>
<li><a href='#species_1_life_history'><p>a list of life-history / life-table data for a hypothetical species</p></a></li>
<li><a href='#species_1_slurped_results'><p>The result of running spip in the species_1_simulation vignette.</p></a></li>
<li><a href='#species_1_slurped_results_100_loci'><p>The result of running spip in the species_1_simulation vignette with 100 loci.</p></a></li>
<li><a href='#species_1_slurped_results_1gen'><p>The result of running spip in the species_1_simulation vignette and slurping out with num_generations = 1.</p></a></li>
<li><a href='#species_2_life_history'><p>a list of life-history / life-table data for another hypothetical species</p></a></li>
<li><a href='#spip_binary'><p>file path to be used in a call to spip</p></a></li>
<li><a href='#spip_binary_path'><p>return the path where spip should be in the R system paths</p></a></li>
<li><a href='#spip_exists'><p>return TRUE if spip exists where it should be installed.</p></a></li>
<li><a href='#spip_help'><p>print the abbreviated usage information from spip</p></a></li>
<li><a href='#spip_help_full'><p>print the full usage information from spip</p></a></li>
<li><a href='#summarize_offspring_and_mate_numbers'><p>Summarize the distribution of number of offspring and number of mates</p></a></li>
<li><a href='#summarize_survival_from_census'><p>Summarize annual sex-and-age-specific survival rates from the census information</p></a></li>
<li><a href='#three_pops_no_mig_slurped_results'><p>The result of running spip and slurping the output in the three population case with no migration</p></a></li>
<li><a href='#three_pops_with_mig_slurped_results'><p>The result of running spip and slurping the output in the three population case with migration</p></a></li>
<li><a href='#uncooked_spaghetti'><p>Summarise kin-pair information and use it to create uncooked spaghetti plots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Forward-in-Time Simulation and Tallying of Pairwise
Relationships</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an R wrapper around the program 'spip'
    (<a href="https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1471-8286.2005.00884.x">https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1471-8286.2005.00884.x</a>), a C
    program for the simulation of pedigrees within age-structured populations
    with user-specified life histories.  Also includes a variety
    of functions to parse 'spip' output to compile information about
    related pairs amongst simulated, sampled individuals, to assess
    the feasibility and potential accuracy of close-kin mark-recapture (CKMR).
    Full documentation
    and vignettes are mirrored at <a href="https://eriqande.github.io/CKMRpop/index.html">https://eriqande.github.io/CKMRpop/index.html</a>
    and can be read online there.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggforce, ggplot2, ggraph, igraph, magrittr, purrr, Rcpp
(&ge; 1.0.4), readr, stats, stringr, tibble, tidygraph, tidyr,
vroom</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tidyverse</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-13 19:13:18 UTC; eriq</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric C. Anderson <a href="https://orcid.org/0000-0003-1326-0840"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric C. Anderson &lt;eric.anderson@noaa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-17 10:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='amm2tibble'>convert an ancestry-matching matrix to a ggplot-able tibble</h2><span id='topic+amm2tibble'></span>

<h3>Description</h3>

<p>This merely converts a matrix to a tibble that can be plotted
easily using ggplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amm2tibble(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amm2tibble_+3A_m">M</code></td>
<td>
<p>an ancestry-match matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>amm2tibble()</code> returns a tibble with three columns:
</p>

<ul>
<li> <p><code>x</code>: the 1-based index of the row of input matrix,
</p>
</li>
<li> <p><code>y</code>: the 1-based index of the column of the input matrix,
</p>
</li>
<li> <p><code>amm</code>: the logical value (TRUE/FALSE) of the (x,y)-th cell of the input matrix.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># convert one of the simple example AMMs to a tibble
amm2tibble(example_amms$Father_Offspring_2gen)
</code></pre>

<hr>
<h2 id='anc_match_masks'>Return ancestry-matrix-zone masks for different relationship types</h2><span id='topic+anc_match_masks'></span>

<h3>Description</h3>

<p>This returns a list of two logical matrices.  The first catches the
zone that is above the diagonal (when plotted with ind_1 on the x-axis
and ind_2 on the y-axis).  These correspond to ind_2 being the &quot;older&quot;
member of the pair than ind_1.  The second catches the zone on the
lower diagonal.  If the zone spans the diagonal, then each matrix
returned in the list is the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anc_match_masks(num_generations, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anc_match_masks_+3A_num_generations">num_generations</code></td>
<td>
<p>the number of generations to go back. 0 = self;
1 = to the parents; 2 = to the grandparents; 3 = to the great grandparents,
etc.</p>
</td></tr>
<tr><td><code id="anc_match_masks_+3A_r">R</code></td>
<td>
<p>the relationship whose zones you want to mask with TRUEs in the
output matrices.  See below for the possible choices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relationships whose zones we are equipped to deal with go out to n=4 generation,
and are named (and ordered) as follows, which is the order in which they
appear in the package data vector <code>relationship_zone_names</code>:
</p>

<ul>
<li> <p><code>Se</code>: self.  This is as far as it goes with num_generations = 0
</p>
</li>
<li> <p><code>PO</code>: parent-offspring
</p>
</li>
<li> <p><code>Si</code>: sibling. This is as far as it goes with num_generations = 1.
</p>
</li>
<li> <p><code>GP</code>: grandparental
</p>
</li>
<li> <p><code>A</code> : avuncular (aunt-niece)
</p>
</li>
<li> <p><code>FC</code>: first cousin. This is as far as it goes with num_generations = 2.
</p>
</li>
<li> <p><code>GGP</code>: great-grandparental
</p>
</li>
<li> <p><code>GA</code>: great-avuncular (great-aunt/great-niece, etc).
</p>
</li>
<li> <p><code>FCr1</code>: first-cousin once removed
</p>
</li>
<li> <p><code>SC</code>: second cousin. This is as far as it goes with num_generations = 3
</p>
</li>
<li> <p><code>GGGP</code>: great-great-grandparental
</p>
</li>
<li> <p><code>GGA</code>: great-great-avuncular
</p>
</li>
<li> <p><code>FCr2</code>: first cousin twice removed
</p>
</li>
<li> <p><code>SCr1</code>: second cousin once removed
</p>
</li>
<li> <p><code>TC</code>: third cousin
At this point the additional zones for num_generations = 3 have not been
implemented.
</p>
</li></ul>



<h3>Value</h3>

<p>This function returns a list of two matrices.  Each one has FALSEs everywhere
except in the zones corresponding to the relationship, where it has TRUEs.  As mentioned
above, the first matrix captures the zones where ind_2 is the &quot;older&quot; one and the
second matrix captures the zones where ind_1 is the &quot;older&quot; one.  For the symmetrical
relationships (Se, Si, FC, etc.) the two matrices in the list are identical.
</p>

<hr>
<h2 id='ancestor_abbrvs'>Return a string of ancestor abbreviations in the order of the ancestor vectors</h2><span id='topic+ancestor_abbrvs'></span>

<h3>Description</h3>

<p>Use this to put axis labels on plots, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestor_abbrvs(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancestor_abbrvs_+3A_l">L</code></td>
<td>
<p>desired length of the output</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ancestor_abbrvs(15)
</code></pre>

<hr>
<h2 id='ancestor_vectors_cpp'>Function to make a vector of all the ancestors of an individual out to n generations.</h2><span id='topic+ancestor_vectors_cpp'></span>

<h3>Description</h3>

<p>This is a replacement for the R implementation of
<code>ancestor_vectors()</code> which was too slow. This will get called
from with a C function in which the pedigree has been assembled.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancestor_vectors_cpp_+3A_sv">sv</code></td>
<td>
<p>vector of sample indexes</p>
</td></tr>
<tr><td><code id="ancestor_vectors_cpp_+3A_nv">nv</code></td>
<td>
<p>vector of names of all samples</p>
</td></tr>
<tr><td><code id="ancestor_vectors_cpp_+3A_ped">Ped</code></td>
<td>
<p>pedigree struct</p>
</td></tr>
<tr><td><code id="ancestor_vectors_cpp_+3A_n">n</code></td>
<td>
<p>the number of generations.  0 = self, 1 = parent, 2 = grandparent, etc.</p>
</td></tr>
</table>

<hr>
<h2 id='basic_amm_plot'>here is a function to plot a basic ancestry match matrix</h2><span id='topic+basic_amm_plot'></span>

<h3>Description</h3>

<p>It is primarily for internal use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basic_amm_plot(ATP, add_imps = FALSE, perimeter_width = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basic_amm_plot_+3A_atp">ATP</code></td>
<td>
<p>a tibble that has ind_1, ind_2, and an ID column</p>
</td></tr>
</table>

<hr>
<h2 id='cat_dom_relat'>Categorize the dominant relationship from an ancestry match matrix</h2><span id='topic+cat_dom_relat'></span>

<h3>Description</h3>

<p>This function takes an ancestry match matrix (AMM) and it returns what the
&quot;dominant&quot; relationship is.  It doesn't try to capture all the nuances
that might be present in the AMM.  For example, it does not note inbreeding
and other such things.  However this is useful for categorizing what type
of relationship is the &quot;closest&quot; relationship type amongst all the ways a
pair is related.
Currently for num_generations == 2, the function goes through in this order,
to identify relationships:
</p>

<ul>
<li> <p><code>Se</code>: self.  This is as far as it goes with num_generations = 0
</p>
</li>
<li> <p><code>PO</code>: parent-offspring
</p>
</li>
<li> <p><code>Si</code>: sibling. This is as far as it goes with num_generations = 1
</p>
</li>
<li> <p><code>GP</code>: grandparental
</p>
</li>
<li> <p><code>A</code> : avuncular (aunt-niece)
</p>
</li>
<li> <p><code>FC</code>: first cousin.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cat_dom_relat(AMM)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cat_dom_relat_+3A_amm">AMM</code></td>
<td>
<p>The ancestry match matrix to categorize</p>
</td></tr>
</table>


<h3>Details</h3>

<p>And so forth.  This has been implemented out to 3 generations
using the relationship zones in package data object
<code>relationship_zone_names</code>.
</p>


<h3>Value</h3>

<p>This returns a list with two components:
</p>

<ul>
<li> <p><code>type</code>: a string saying what type of relationship (i.e., &quot;Si&quot;, or &quot;A&quot;).
</p>
</li>
<li> <p><code>hits</code>: a two vector of the number of TRUEs in each &quot;relationship zone&quot; on the
upper or the lower diagonal of the AMM.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>cat_dom_relat(half_first_cousin_amm)
</code></pre>

<hr>
<h2 id='compile_related_pairs'>compile pairwise relationships from the samples</h2><span id='topic+compile_related_pairs'></span>

<h3>Description</h3>

<p>Run this on some of the output from <code>slurp_spip()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compile_related_pairs(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compile_related_pairs_+3A_s">S</code></td>
<td>
<p>a tibble. In the context of this package this tibble is
typically going to often be the
<code>samples</code> component of the output slurped up from spip with <code>slurp_spip()</code>.
More generally, it is a tibble that must have the columns:
</p>

<ul>
<li> <p><code>ID</code>: the id of the sample
</p>
</li>
<li> <p><code>ancestors</code>: a list column of the ancestor vectors of each individual
</p>
</li>
<li> <p><code>relatives</code>: a list column of the vectors of individual samples (including self)
that each individual is related to.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble with columns <code>id_1</code> and <code>id_2</code> for each pair.  Any additional
columns outside of <code>relatives</code> will be joined with <code style="white-space: pre;">&#8288;_1&#8288;</code> and
<code style="white-space: pre;">&#8288;_2&#8288;</code> suffixes.  In a typical run slurped up from spip this leads to the following
columns:
</p>

<ul>
<li> <p><code>id_1</code>: the id of the first sample of the pair,
</p>
</li>
<li> <p><code>id_2</code>: the id of the 2nd sample of the pair,
</p>
</li>
<li> <p><code>conn_comp</code>: the index of the connected component to which the pair belongs,
</p>
</li>
<li> <p><code>dom_relat</code>: the dominant relationship that the pair shares,
</p>
</li>
<li> <p><code>max_hit</code>: the number of shared ancestors at the level of the dominant relationship
</p>
</li>
<li> <p><code>dr_hits</code>: a list column of two-vectors&mdash;the number of shared ancestors at the level
of the dominant relationship in the upper and lower quadrants, respectively of the
ancestry match matrix. If the relationship is symmetrical, the two values are the same.
</p>
</li>
<li> <p><code>upper_member</code>: for non-symmetrical relationships, a 1 or a 2 indicating which member of the
pair is the one that is typically older (i.e. the uncle in an uncle-nephew relationship), or
NA if the relationship is symmetrical.
</p>
</li>
<li> <p><code>times_encountered</code>: the number of times this pair was encountered when processing the
output of the depth first search algorithm that found these pairs.  Not typically used for
downstream analyses.
</p>
</li>
<li> <p><code>primary_shared_ancestors</code>: a list columns of two-vectors.  The first element of each is the
the position in the ancestry vector of id_1's primary shared ancestor.  The second element is
the same for id_2.
</p>
</li>
<li> <p><code>psa_tibs</code>: like <code>primary_shared_ancestor</code> but a list column of tibbles.
</p>
</li>
<li> <p><code>pop_pre_1</code>, <code>pop_post_1</code>, <code>pop_dur_1</code>: the population from which the id_1 individual
was sampled during the prekill, postkill, or during-reproduction sampling episodes,
respectively.  NA for episodes in which the individual was not sampled
</p>
</li>
<li> <p><code>pop_pre_2</code>, <code>pop_post_2</code>, <code>pop_dur_2</code>: same as above for the id_2 individual.
</p>
</li>
<li> <p><code>sex_1</code>: sex of the id_1 individual,
</p>
</li>
<li> <p><code>sex_2</code>: sex of the id_2 individual,
</p>
</li>
<li> <p><code>born_year_1</code>: birth year of the id_1 individual,
</p>
</li>
<li> <p><code>born_year_2</code>: birth year of the id_2 individual,
</p>
</li>
<li> <p><code>samp_years_list_pre_1</code>: list column of years during which the id_1 individual was sampled
during the prekill episode.
</p>
</li>
<li> <p><code>samp_years_list_dur_1</code>: list column of years during which the id_1 individual was sampled
during reproduction.
</p>
</li>
<li> <p><code>samp_years_list_post_1</code>: list column of years during which the id_1 individual was sampled
during the postkill episode.
</p>
</li>
<li> <p><code>samp_years_list_1</code>: by default this column is identical to <code>samp_years_list_post_1</code> and is the
column used in downstream plotting by some functions.  If you want to use a different column,
for example <code>samp_years_list_pre_1</code> for the downstream plotting, then set the value of
<code>samp_years_list_1</code> to the same values,
</p>
</li>
<li> <p><code>samp_years_list_pre_2</code>, <code>samp_years_list_dur_2</code>, <code>samp_years_list_post_2</code>, <code>samp_years_list_2</code>: same
as above but for individual with id_2,
</p>
</li>
<li> <p><code>born_pop_1</code>: index of population in which id_1 was born,
</p>
</li>
<li> <p><code>ancestors_1</code>: ancestry vector of id_1,
</p>
</li>
<li> <p><code>born_pop_2</code>: index of population in which id_2 was born,
</p>
</li>
<li> <p><code>ancestors_2</code>: ancestry vector of id_2,
</p>
</li>
<li> <p><code>anc_match_matrix</code>: the ancestry match matrix (a logical matrix) for the pair.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- compile_related_pairs(three_pops_with_mig_slurped_results$samples)
</code></pre>

<hr>
<h2 id='count_and_plot_ancestry_matrices'>Count up the number of different kinds of related pairs and make a plot</h2><span id='topic+count_and_plot_ancestry_matrices'></span>

<h3>Description</h3>

<p>This counts up all the different types of pairwise relationships and
makes a plot (or multiple pages of them). For an example, see
the Vignette: <code>vignette("species_1_simulation", package = "CKMRpop")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_and_plot_ancestry_matrices(
  Pairs,
  nrow = 6,
  ncol = 5,
  white_ball_size = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_and_plot_ancestry_matrices_+3A_pairs">Pairs</code></td>
<td>
<p>a tibble like that returned by <code>compile_related_pairs()</code>.</p>
</td></tr>
<tr><td><code id="count_and_plot_ancestry_matrices_+3A_nrow">nrow</code></td>
<td>
<p>the number of rows to plot per page</p>
</td></tr>
<tr><td><code id="count_and_plot_ancestry_matrices_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns to plot per page</p>
</td></tr>
<tr><td><code id="count_and_plot_ancestry_matrices_+3A_white_ball_size">white_ball_size</code></td>
<td>
<p>the size of the white dot plotted on top of the
primary shared ancestors' cells.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>

<ul>
<li> <p><code>highly_summarised</code>: a tibble reporting counts of different types of relationships with
the columns:
</p>

<ul>
<li> <p><code>dom_relat</code>: The name of the dominant relationship (e.g. Si, PO, A, etc).
</p>
</li>
<li> <p><code>max_hit</code>: The number of primary shared ancestors.
</p>
</li>
<li> <p><code>n</code>: The number of occurrences of this type of relationship.
</p>
</li></ul>

</li>
<li> <p><code>dr_counts</code>: A tibble with the counts of all the different, unique ancestry match matrices
observed, with the following columns:
</p>

<ul>
<li> <p><code>dom_relat</code>: The dominant relationship type
</p>
</li>
<li> <p><code>dr_hits</code>: list column with the number of primary shared ancestors in the upper and lower quadrants
of the ancestry match matrix (values are repeated for symmetrical relationships).
</p>
</li>
<li> <p><code>max_hit</code>: the number of primary shared ancestors.
</p>
</li>
<li> <p><code>anc_match_matrix</code>: a list column of ancestry match matrices.
</p>
</li>
<li> <p><code>n</code>: The number of pairs with this type of ancestry match matrix
</p>
</li>
<li> <p><code>tot_dom</code>: The total number of pairs within the given dominant relationship category.
</p>
</li>
<li> <p><code>ID</code>: A unique, properly sorting name for this category for placing a title on
facets of plots of these ancestry match matrices.
</p>
</li></ul>

</li>
<li> <p><code>dr_plots</code>: a list named by the dominant relationship. Each component is a ggplot
object which is a plot of the ancestry match matrices, faceted by their <code>ID</code>'s as
given in <code>dr_counts</code>.
</p>
</li>
<li> <p><code>anc_mat_counts</code>: A tibble summarizing the counts of different ancestry match matrices
without regard to dominant relationship type, etc. Rows are arranged in descending order
of number of pairs observed with each ancestry match matrix. It has the columns:
</p>

<ul>
<li> <p><code>anc_match_matrix</code>: a list column of ancestry match matrices.
</p>
</li>
<li> <p><code>n</code>:  the number of such matrices observed.
</p>
</li></ul>

</li>
<li> <p><code>anc_mat_plots</code>: a list of ggplot pages.  These are plots faceted by ancestry match
matrix of all ancestry match matrices observed, ordered by number of occurrences (as
given in <code>anc_mat_counts</code>).
</p>
</li></ul>


<hr>
<h2 id='count_and_plot_mate_distribution'>Count and plot the number of mates each individuals has produced offspring with</h2><span id='topic+count_and_plot_mate_distribution'></span>

<h3>Description</h3>

<p>This just tallies up the information from the pedigree.  It will plot things
faceted by pop (over rows) and sexes (over columns).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_and_plot_mate_distribution(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_and_plot_mate_distribution_+3A_p">P</code></td>
<td>
<p>the pedigree from the simulation, like that returned in the <code>pedigree</code> component
of the list returned by <code>slurp_spip()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components with names:
</p>

<ul>
<li> <p><code>mate_counts</code>: A tibble with information about the number of mates with which
a parent produced offspring each year.  It has the columns:
</p>

<ul>
<li> <p><code>sex</code>: the sex of this parent
</p>
</li>
<li> <p><code>year</code>: the year during which the mating occurred
</p>
</li>
<li> <p><code>pop</code>: the population this parent was in
</p>
</li>
<li> <p><code>parent</code>: the ID of the parent
</p>
</li>
<li> <p><code>num_offs</code>: the number of offspring this parent had in total
</p>
</li>
<li> <p><code>num_mates</code>: the number of mates this parent had
</p>
</li></ul>

</li>
<li> <p><code>plot_mate_counts</code>: a ggplot object, faceted on a grid by population in columns
and sex in rows. The x-axis is the number of offspring (in a season), the y-axis is the
number of mates in a season, and the fill color of the grid gives the number of parents
with that number of offspring and mates.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- count_and_plot_mate_distribution(three_pops_no_mig_slurped_results$pedigree)

# have a look at the results:
result$mate_counts

result$plot_mate_counts

</code></pre>

<hr>
<h2 id='downsample_pairs'>downsample the number of individuals sampled</h2><span id='topic+downsample_pairs'></span>

<h3>Description</h3>

<p>This discards individuals from the sample, randomly, until
the desired number of samples is achieved, then it
returns only those pairs in which both members are part of
the retained samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample_pairs(S, P, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_pairs_+3A_s">S</code></td>
<td>
<p>the tibble of samples with columns at least of <code>ID</code> and <code>samp_years_list</code>. Typically
this will be what is returned in the <code>samples</code> component from <code>slurp_spip()</code>.</p>
</td></tr>
<tr><td><code id="downsample_pairs_+3A_p">P</code></td>
<td>
<p>the tibble of pairs. Typically this will be what has been returned from
<code>compile_related_pairs()</code>.</p>
</td></tr>
<tr><td><code id="downsample_pairs_+3A_n">n</code></td>
<td>
<p>The desired number of individuals (or instances, really, see below) to
retain in the sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a list with two components as follows:
</p>

<ul>
<li> <p><code>ds_samples</code>: A tibble like <code>S</code> except having randomly removed individuals
so as to only have n left.
</p>
</li>
<li> <p><code>ds_pairs</code>: A tibble like <code>P</code> except having removed any pairs that
include individuals that were not retained in the sample.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># prepare some input
S &lt;- three_pops_with_mig_slurped_results$samples
P &lt;- compile_related_pairs(three_pops_with_mig_slurped_results$samples)
result &lt;- downsample_pairs(S, P, n = 500)

# print the result
result
</code></pre>

<hr>
<h2 id='example_amms'>a list of examples of ancestry-match matrices</h2><span id='topic+example_amms'></span>

<h3>Description</h3>

<p>This is a list of matrices with names that describe what they
represent. The names are Relationship_Number-of-Generations, like:
&quot;Unrelated_2gen&quot;, &quot;Self_2gen&quot;, &quot;Unrelated_3gen&quot;, &quot;Unrelated_4gen&quot;,
&quot;Unrelated_1gen&quot;, &quot;Father_Offspring_2gen&quot;, &quot;FullSibling_2gen&quot;, &quot;PatHalfSibling_2gen&quot;,
&quot;FullCousin_2gen&quot;, &quot;HalfAuntNiece_2gen&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_amms
</code></pre>


<h3>Source</h3>

<p>I just made these for some illustrative figures in the manuscript about this
R package.
</p>

<hr>
<h2 id='find_ancestors_and_relatives_of_samples'>Find ancestors and relative of each sampled member of a pedigree</h2><span id='topic+find_ancestors_and_relatives_of_samples'></span>

<h3>Description</h3>

<p>This is a fairly general function that can be applied to pedigree output
from any simulation program.  It calls a function written in C++ to
do all the recursive pedigree searching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_ancestors_and_relatives_of_samples(P, S, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_ancestors_and_relatives_of_samples_+3A_p">P</code></td>
<td>
<p>a tibble that gives the pedigree.  It must have the columns <code>kid</code>, <code>pa</code>, <code>ma</code>.
These columns must be character vectors of the unique IDs for each individual in
the pedigree.
Every individual in the pedigree must appear exactly once in the <code>kid</code> column.  When founders
appear in the pedigree, their <code>pa</code> and <code>ma</code> entries must be &quot;0&quot; (i.e. character zero).</p>
</td></tr>
<tr><td><code id="find_ancestors_and_relatives_of_samples_+3A_s">S</code></td>
<td>
<p>a vector of the IDs of the sampled individuals.  Obviously, all members of S must appear
in P.</p>
</td></tr>
<tr><td><code id="find_ancestors_and_relatives_of_samples_+3A_n">n</code></td>
<td>
<p>number of generations back from the sampled individuals to return in each
individual's ancestor vector. 0 = self, 1 =  back to and including the parents,
2 = back to and including the grandparents, and so on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with three columns:
</p>

<ul>
<li> <p><code>sample_id</code>: the ID names of the sampled individuals
</p>
</li>
<li> <p><code>ancestors</code>: a list column.  Each element is a vector of the ids of the ancestors of the
sampled individual in the 2^(n+1) - 1 positions.  The first is the sampled individual, the second
is pa, third is ma, fourth is pa's pa, fifth is pa's ma, sixth is ma's pa, and so forth.
</p>
</li>
<li> <p><code>relatives</code>: a list column. Each element is a vector of the ids of the individuals that are <em>sampled</em> relatives
within the n generations.  The first element is the sampled individual itself, and the remaining
ones are all the relatives of that individual whom were also sampled.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># get some input variables
P &lt;- three_pops_with_mig_slurped_results$pedigree
S &lt;- three_pops_with_mig_slurped_results$samples$ID
n &lt;- 2
result &lt;- find_ancestors_and_relatives_of_samples(P, S, n)
result
</code></pre>

<hr>
<h2 id='gg_add_generation_bands'>Add bands of transparent colors to denote generations on plots of ancestor-match matrices</h2><span id='topic+gg_add_generation_bands'></span>

<h3>Description</h3>

<p>Pass it the original ggplot, and this will return it, with the bands added
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_add_generation_bands(
  g,
  L,
  alpha = 0.2,
  colors = c("red", "orange", "yellow", "green", "blue"),
  add_impossibles = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_add_generation_bands_+3A_g">g</code></td>
<td>
<p>the original ggplot</p>
</td></tr>
<tr><td><code id="gg_add_generation_bands_+3A_l">L</code></td>
<td>
<p>the number of rows (or columns) in the ancestor-match matrices</p>
</td></tr>
<tr><td><code id="gg_add_generation_bands_+3A_alpha">alpha</code></td>
<td>
<p>the transparency to use for these color-bands</p>
</td></tr>
<tr><td><code id="gg_add_generation_bands_+3A_colors">colors</code></td>
<td>
<p>the colors in order of self, parent, grandparent, etc.  By default it
is just rainbow order starting from red.</p>
</td></tr>
<tr><td><code id="gg_add_generation_bands_+3A_add_impossibles">add_impossibles</code></td>
<td>
<p>pass TRUE if you want to blot out the cells that are not possible
because they conflict with the sex of the individuals.  You set the fill of the
impossibles with a <code>scale_fill_manual()</code> in the main ggplot call.  i.e.,</p>
<pre>scale_fill_manual(values = c(`FALSE` = NA, Impossible = "white", `TRUE` = "black"))
</pre></td></tr>
</table>

<hr>
<h2 id='gg_add_zone_perimeters'>Add perimeters around the relationship zones</h2><span id='topic+gg_add_zone_perimeters'></span>

<h3>Description</h3>

<p>Pass it the original ggplot, and this will return it, with the perimeters added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_add_zone_perimeters(g, L, perisize = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_add_zone_perimeters_+3A_g">g</code></td>
<td>
<p>the original ggplot</p>
</td></tr>
<tr><td><code id="gg_add_zone_perimeters_+3A_l">L</code></td>
<td>
<p>the number of rows (or columns) in the ancestor-match matrices</p>
</td></tr>
<tr><td><code id="gg_add_zone_perimeters_+3A_perisize">perisize</code></td>
<td>
<p>the size of the line to color in the perimeters</p>
</td></tr>
</table>

<hr>
<h2 id='ggplot_census_by_year_age_sex'>Just a simple plot function</h2><span id='topic+ggplot_census_by_year_age_sex'></span>

<h3>Description</h3>

<p>Easy to do, but quicker to have it wrapped up in a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_census_by_year_age_sex(census)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_census_by_year_age_sex_+3A_census">census</code></td>
<td>
<p>a tibble of census counts with columns <code>year</code> and
<code>age</code>, and then the counts of the different sexes in columns
named <code>male</code>, and <code>female</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot_census_by_year_age_sex()</code> returns a ggplot object which is a
stacked barplot with year on the x-axis,
counts on the y-axis with fill mapped to age.  It is facet-gridded
with sex in the columns and populations in the rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A single population example
g &lt;- ggplot_census_by_year_age_sex(species_1_slurped_results$census_postkill)

# a three-population example
g3 &lt;- ggplot_census_by_year_age_sex(three_pops_with_mig_slurped_results$census_postkill)
</code></pre>

<hr>
<h2 id='half_first_cousin_amm'>A half-first cousin ancestry match matrix</h2><span id='topic+half_first_cousin_amm'></span>

<h3>Description</h3>

<p>Just a simple AMM to use in some examples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>half_first_cousin_amm
</code></pre>


<h3>Source</h3>

<p>Simply wrote this down.
</p>

<hr>
<h2 id='install_spip'>Download the spip binary and install it where CKMRpop expects it</h2><span id='topic+install_spip'></span>

<h3>Description</h3>

<p>This checks the operating system and installs the correct version
(either Darwin or Linux for Mac or Linux, respectively.)  To install
the spip binary this function downloads it from its GitHub site.  It also
installs a windows implementation of awk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_spip(Dir = tempfile())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="install_spip_+3A_dir">Dir</code></td>
<td>
<p>the directory to install spip into.  Because of restrictions
on functions writing to the user's home filespace, this is set, by default,
to a temporary directory.  But to really use this function to install spip,
this parameter must be set to <code>system.file(package = "CKMRpop")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.  Called for side effect of installing the 'spip' binary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
install_spip(Dir = system.file(package = "CKMRpop"))

## End(Not run)
</code></pre>

<hr>
<h2 id='int_pow2'>Exponentiation function for integer arguments</h2><span id='topic+int_pow2'></span>

<h3>Description</h3>

<p>Solaris' compiler freaked hard on the pow function&mdash;couldn't figure
out whether it should return an int or a float or something, when
I used it to get very small powers of two. So I
am going to write a silly, simple function (that only gets used a couple
of times in an entire execution, and only with very
small arguments, so the fact that it is not super efficient
should not be a big problem).
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_pow2_+3A_x">x</code></td>
<td>
<p>the integer to raise 2 to.</p>
</td></tr>
</table>

<hr>
<h2 id='leslie_from_spip'>Return a Leslie-like matrix from the spip parameters</h2><span id='topic+leslie_from_spip'></span>

<h3>Description</h3>

<p>Here we take the survival rates for females and males and the sex ratio,
as well as the annual new cohort size (assumed constant),
and we make a leslie-like matrix
to compute the stable age distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leslie_from_spip(P, C)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leslie_from_spip_+3A_p">P</code></td>
<td>
<p>a named list of the spip parameters.</p>
</td></tr>
<tr><td><code id="leslie_from_spip_+3A_c">C</code></td>
<td>
<p>the constant size of the newborn cohort each year</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list with the following components:
</p>

<ul>
<li> <p><code>stable_age_distro_fem</code>: a vector of the expected number of females in each age
group of 0 up to MaxAge-1 once the stable age distribution has been reached.  Note that
this corresponds to the PREKILL_CENSUS from spip. In this vector, the size of the
MaxAge group is left out because this is how it is needed to be to insert into
the <code>--initial-males</code> and <code>--initial-females</code> options in spip().  If you want the
size of all age classes, use the output list component
<code>stable_age_distro_fem_with_max_age_class</code>, described below.
</p>
</li>
<li> <p><code>stable_age_distro_male</code>: same as above, but for males.
</p>
</li>
<li> <p><code>stable_age_distro_fem_with_max_age_class</code>: The expected number of females from age 0 to
MaxAge once the stable age distribution has been reached.
</p>
</li>
<li> <p><code>stable_age_distro_male_with_max_age_class</code>: same as above, but for females.
</p>
</li>
<li> <p><code>female_leslie_matrix</code>: The Leslie matrix implied by the spip parameters in P.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- leslie_from_spip(species_1_life_history, 300)

# print the result list:
result
</code></pre>

<hr>
<h2 id='plot_amm_from_matrix'>plot an ancestry matrix (or multiple such matrices) from its (their) matrix form</h2><span id='topic+plot_amm_from_matrix'></span>

<h3>Description</h3>

<p>For illustration purposes, if you want to simply plot an ancestry
matrix (or several) to show particular values, then this is the
handy function for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_amm_from_matrix(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_amm_from_matrix_+3A_x">X</code></td>
<td>
<p>input tibble with a factor or character column <code>ID</code> that gives
the &quot;name&quot; of the ancestry matrix that will be used if you want to facet
over the values in <code>ID</code>. And also <code>X</code> must have a list column <code>anc_match_matrix</code> each
element of which is a logical ancestry match matrix.  <code>X</code> may have a list column
of tibbles called <code>psa_tibs</code> that says which cells are the primary shared ancestors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot_amm_from_matrix()</code> returns a ggplot object: each facet is an image of the
ancestry match matrix.  It is facet-wrapped over the values in the ID column of <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get some input: all the 2-generation AMMs in `example_amms`
X &lt;- example_amms[stringr::str_detect(names(example_amms), "2gen$")] %&gt;%
    tibble::enframe(name = "ID", value = "anc_match_matrix")

# plot those
g &lt;- plot_amm_from_matrix(X) +
    ggplot2::facet_wrap(~ ID)

</code></pre>

<hr>
<h2 id='plot_conn_comps'>plot the graph showing the connected components</h2><span id='topic+plot_conn_comps'></span>

<h3>Description</h3>

<p>This is a simple wrapper for some tidygraph/ggraph functions
that will let you find the connected components of a graph in which
the related pairs are connected by edges.  It also makes
a plot of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_conn_comps(Pairs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_conn_comps_+3A_pairs">Pairs</code></td>
<td>
<p>the tibble that comes out of <code>compile_related_pairs()</code>.
For this function it must have, at least the
columns <code>id_1</code>, <code>id_2</code>, and <code>dom_relat</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that it appears that the 'ggraph' package must be loaded
for the plot output of this function to print correctly.
</p>


<h3>Value</h3>

<p>This returns a list with two components:
</p>

<ul>
<li> <p><code>conn_comps</code>: a tibble with three columns:
</p>

<ul>
<li> <p><code>name</code>: the name of the sample
</p>
</li>
<li> <p><code>cluster</code>: the index of the connected component the sample belongs to
</p>
</li>
<li> <p><code>cluster_size</code>: the number of samples belonging
to that cluster
</p>
</li></ul>

</li>
<li> <p><code>plot</code>: a ggraph/ggplot plot object showing the connected components as vertices with
edges between them.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># get a Pairs tibble from the stored data
Pairs &lt;- compile_related_pairs(species_1_slurped_results_1gen$samples)
PCC &lt;-  plot_conn_comps(Pairs)

# look at the conn_comps:
head(PCC$conn_comps)

# if you want to print the plot, that seems to require
# loading the ggraph library
library(ggraph)
PCC$plot
</code></pre>

<hr>
<h2 id='prepare_for_dfs'>Prepare input for the DFS relative-finding algorithm</h2><span id='topic+prepare_for_dfs'></span>

<h3>Description</h3>

<p>Uses the pedigree to convert individual IDs into indexes and
compile information to make the data structures for the DFS
algorithm to find relatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_for_dfs(ped, samp_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_for_dfs_+3A_ped">ped</code></td>
<td>
<p>the pedigree.  A tibble with columns <code>kid</code>, <code>pa</code>, and <code>ma</code></p>
</td></tr>
<tr><td><code id="prepare_for_dfs_+3A_samp_vec">samp_vec</code></td>
<td>
<p>A character vector with the names of the individuals that were sampled</p>
</td></tr>
</table>

<hr>
<h2 id='primary_ancestor_pairs'>Return a list of the indices of the primary shared ancestors</h2><span id='topic+primary_ancestor_pairs'></span>

<h3>Description</h3>

<p>This operates on an ancestry match matrix and uses a simple, divide-by_two
relationship between an ancestor and its descendants in the ordering
of an ancestry vector to determine which of the matching ancestors are secondary,
and then return the ones that are primary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primary_ancestor_pairs(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="primary_ancestor_pairs_+3A_m">M</code></td>
<td>
<p>an ancestry match matrix (it is a logical matrix)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of pairs.  Each pair is the 1-based index of ancestor of ind_1, then
ind_2 of the primary shared ancestors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># find primary ancestor pairs of example AMMs
lapply(example_amms, primary_ancestor_pairs)
</code></pre>

<hr>
<h2 id='rcpp_ancestors_and_relatives'>function to test and use DFS stuff</h2><span id='topic+rcpp_ancestors_and_relatives'></span>

<h3>Description</h3>

<p>function to test and use DFS stuff
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcpp_ancestors_and_relatives(L, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcpp_ancestors_and_relatives_+3A_l">L</code></td>
<td>
<p>list of inputs</p>
</td></tr>
<tr><td><code id="rcpp_ancestors_and_relatives_+3A_n">n</code></td>
<td>
<p>the number of generations back to go when computing the ancestor vectors
and finding relatives.</p>
</td></tr>
</table>

<hr>
<h2 id='recapture_pairs'>Return the recaptures from amongst the samples</h2><span id='topic+recapture_pairs'></span>

<h3>Description</h3>

<p>Given the tibble of sampled individuals
return a tibble of all the recaptures.
This is a somewhat complicated operation
that expands recaptures to all possible pairs of recaptures. (i.e. if the
individual was caught on 3 different occasions there will be three separate pairs).
The column pair_type shows RC for recapture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recapture_pairs(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recapture_pairs_+3A_s">S</code></td>
<td>
<p>the samples tibble with columns ID, sex, born_year, sampling_year</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is broken now that sampling in different life episodes is
demarcated as such. But I have left it in here unexported and internal
in case I want to pick it up at some point.
</p>

<hr>
<h2 id='relationship_zone_names'>relationship zone names</h2><span id='topic+relationship_zone_names'></span>

<h3>Description</h3>

<p>A simple character vector of 15 relationship zones in the order they
are encountered when traversing an ancestry match matrix out to four
generations
</p>


<h3>Source</h3>

<p>I simply defined these
</p>

<hr>
<h2 id='relationship_zone_perimeters'>Return the perimeters of all the relationship zones</h2><span id='topic+relationship_zone_perimeters'></span>

<h3>Description</h3>

<p>This is primarily for plotting a figure in the paper about this package,
showing where all the relationship zones are.  It merely cycles over the
possible relationships in <code><a href="#topic+relationship_zone_names">relationship_zone_names</a></code> and produces one or
two rows in a tibble for each that has the corners of the rectangle of that
zone in the columns xmin, xmax, ymin, and ymax.  It is designed to be overlaid
upon the ancestry_match_matrix plots. There are some additional columns that give
us the midpoint of the area, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relationship_zone_perimeters()
</code></pre>


<h3>Value</h3>

<p>Returns a tibble with the following columns:
</p>

<ul>
<li> <p><code>which_matrix</code>: a column of values <code>M1</code> or <code>M2</code>.  M1 denotes that the row's values
are for the relationship zone found in or below the lower diagonal of the ancestry match matrix
and M2 denotes that the row's value are of the zone found in the upper part of the
ancestry match matrix.  Symmetrical relationships are considered to be M1.
</p>
</li>
<li> <p><code>zone</code>: The abbreviation for the relationship (e.g., Se, PO, Si, etc.)
</p>
</li>
<li> <p><code>xmin</code>: The left-hand x value of the zone.
</p>
</li>
<li> <p><code>xmax</code>: The right-hand x value of the zone.
</p>
</li>
<li> <p><code>ymin</code>: The bottom y value of the zone.
</p>
</li>
<li> <p><code>ymax</code>: The top y value of the zone.
</p>
</li>
<li> <p><code>area</code>: The area in unit squares of the zone.
</p>
</li>
<li> <p><code>xmid</code>: The x midpoint of the zone.
</p>
</li>
<li> <p><code>ymid</code>: The y midpoint of the zone.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>relationship_zone_perimeters()
</code></pre>

<hr>
<h2 id='relpair_conn_comps'>Find connected components amongst the related pairs</h2><span id='topic+relpair_conn_comps'></span>

<h3>Description</h3>

<p>This is a little utility function that actually gets called from
within <code>compile_related_pairs()</code> so we leave it as an internal function.
This takes in the tibble Pairs, and then spits out a tibble that looks
just the same, except that after the id_1 and id_2 columns it now has a
column called <code>conn_comp</code> that gives the connected component index of the
two pair members.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relpair_conn_comps(Pairs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relpair_conn_comps_+3A_pairs">Pairs</code></td>
<td>
<p>a tibble with the related pairs.  It must have columns id_1 and
id_2</p>
</td></tr>
</table>

<hr>
<h2 id='run_spip'>Run spip in a user-specified directory</h2><span id='topic+run_spip'></span>

<h3>Description</h3>

<p>This runs it in a directory and the output from stdout
goes into a big file spip_out.txt in that directory. Currently
this is pretty bare bones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_spip(
  pars,
  dir = tempfile(),
  spip_seeds = ceiling(runif(2, 1, 1e+09)),
  num_pops = 1,
  allele_freqs = list(c(0.5, 0.5))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_spip_+3A_pars">pars</code></td>
<td>
<p>A named list of parameter values.</p>
</td></tr>
<tr><td><code id="run_spip_+3A_dir">dir</code></td>
<td>
<p>The directory to run it in.  Defaults to a temp directory,
which will be unique every time it is run.</p>
</td></tr>
<tr><td><code id="run_spip_+3A_spip_seeds">spip_seeds</code></td>
<td>
<p>a vector of two positive integers. These get written to the
file spip_seeds, which is used by spip to seed its random number generator.  By
default, R supplies these two integers from its own random number generator.  This
way reproducible results from spip can be obtained by calling <code>set.seed()</code> from within
R before calling <code>run_spip()</code>.  For the most part, the user should never really have
to directly supply a value for spip_seeds.</p>
</td></tr>
<tr><td><code id="run_spip_+3A_num_pops">num_pops</code></td>
<td>
<p>the number of demes that are being simulated.  This is still being
implemented...</p>
</td></tr>
<tr><td><code id="run_spip_+3A_allele_freqs">allele_freqs</code></td>
<td>
<p>a list of allele frequencies provided if you want
to simulate unlinked genotypes for the sampled individuals. The default
is simply a single locus with two alleles at frequencies 0.5, 0.5, which
is provided because spip has to be given some allele frequencies if sampling
is to be carried out.  Note that a user-specified value to this option should
only be given if you want to actually simulate some genetic data from the
sampled individuals. The length of the list should be the number of loci
desired, and the length of each element should be the number of alleles.
For examples for three loci with 2, 3, and 4 equifrequent alleles, respectively,
you would provide <code>list(c(0.5, 0.5), c(0.3333, 0.3333, 0.3333), c(0.25, 0.25, 0.25, 0.25))</code>.
Note that allele frequencies will be normalized to sum to one within each locus.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This creates a temporary directory and runs spip in that directory, redirecting
stdout and stderr to files.  It then processes the output using awk to create a collection
of files.  If spip throws an error, the contents of stderr are written to the screen to notify
the user of how to correct their input.
</p>
<p>For a full example of its use see the Vignette:
<code>vignette("species_1_simulation", package = "CKMRpop")</code>.
</p>


<h3>Value</h3>

<p>Returns the path to the temporary directory were <code>spip</code> was run and where the
processed output files can be found to be read in using <code>slurp_spip()</code>.
</p>

<hr>
<h2 id='search_down'>Depth first search down the pedigree to N generations.</h2><span id='topic+search_down'></span>

<h3>Description</h3>

<p>When you call this
from within search_up(), c should be set at 0,
and the algorithm will run down for, n generations from there.
Unlike in R, this is 0-based.  So, n = 0 is self, n = 1 is kids,
n = 2 is grandkids, and so forth.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_down_+3A_i">i</code></td>
<td>
<p>the index of the node to call this on</p>
</td></tr>
<tr><td><code id="search_down_+3A_c">c</code></td>
<td>
<p>the current generation level.  0 = the first (i.e. the starting individual).</p>
</td></tr>
<tr><td><code id="search_down_+3A_n">n</code></td>
<td>
<p>the number of generations back to down.  1 means go no further than the offspring.
2 means go no further than the grandkids.</p>
</td></tr>
<tr><td><code id="search_down_+3A_p">P</code></td>
<td>
<p>the pedigree structure</p>
</td></tr>
<tr><td><code id="search_down_+3A_c">C</code></td>
<td>
<p>a reference to a character vector to which sampled individuals' IDs will get
pushed on.  At the end, we can unique them.</p>
</td></tr>
</table>

<hr>
<h2 id='search_up'>Depth first search up the pedigree to N generations.</h2><span id='topic+search_up'></span>

<h3>Description</h3>

<p>Call this
with c = 0 for the original individual, and it will go back, n generations.
Unlike in R, this is 0-based.  So, n = 1 is parents, n = 2 is grandparents
and so on.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="search_up_+3A_i">i</code></td>
<td>
<p>the index of the node to call this on</p>
</td></tr>
<tr><td><code id="search_up_+3A_c">c</code></td>
<td>
<p>the current generation level.  0 = the first (i.e. the sampled individual)</p>
</td></tr>
<tr><td><code id="search_up_+3A_n">n</code></td>
<td>
<p>the number of generations back to go.  1 means go no further than the parents.
2 means go no further than the grandparents.</p>
</td></tr>
<tr><td><code id="search_up_+3A_p">P</code></td>
<td>
<p>the pedigree structure</p>
</td></tr>
<tr><td><code id="search_up_+3A_c">C</code></td>
<td>
<p>a reference to a character vector to which sampled individuals' IDs will get
pushed on.  At the end, we can unique them.</p>
</td></tr>
</table>

<hr>
<h2 id='slurp_spip'>Read in the pedigree, census, and sampling information from the spip run</h2><span id='topic+slurp_spip'></span>

<h3>Description</h3>

<p>This function is run after <code>run_spip()</code>.  It assumes that <code>run_spip()</code>
has left the files: <code>spip_pedigree.tsv</code>, <code>spip_prekill_census.tsv</code>, and
<code>spip_samples.tsv</code>, <code>spip_postkill_census.tsv</code>, <code>spip_deaths.tsv</code>,
<code>spip_genotypes.tsv</code>, and <code>spip_migrants.tsv</code>
inside the directory where <code>run_spip()</code> was run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slurp_spip(dir, num_generations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slurp_spip_+3A_dir">dir</code></td>
<td>
<p>the path to the directory where spip was run.  This is
returned by <code>run_spip()</code>.</p>
</td></tr>
<tr><td><code id="slurp_spip_+3A_num_generations">num_generations</code></td>
<td>
<p>how many generations back do you wish to consider
for find relatives of
each sampled individual.  0 means just the individual themselves (so, not very
interesting, and you likely wouldn't ever use it. 1 means up to
and including the parents; 2 means up to and including the grandparents; 3 means up to
and including the great grandparents; and so forth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an example of its use, see the Vignette:
<code>vignette("species_1_simulation", package = "CKMRpop")</code>.
</p>


<h3>Value</h3>

<p>A list of tibbles.  Each tibble is a named component of
the return list.  The names are as follows:
</p>

<ul>
<li> <p><code>pedigree</code>
</p>
</li>
<li> <p><code>census_prekill</code>,
</p>
</li>
<li> <p><code>census_postkill</code>,
</p>
</li>
<li> <p><code>samples</code>,
</p>
</li>
<li> <p><code>deaths</code>,
</p>
</li>
<li> <p><code>genotypes</code>,
</p>
</li>
<li> <p><code>migrants</code>
</p>
</li></ul>

<p>You can inspect some example output in
the package data object <code>three_pops_with_mig_slurped_results</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see Vignette: vignette("species_1_simulation", package = "CKMRpop")
</code></pre>

<hr>
<h2 id='species_1_life_history'>a list of life-history / life-table data for a hypothetical species</h2><span id='topic+species_1_life_history'></span>

<h3>Description</h3>

<p>species_1 for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_1_life_history
</code></pre>


<h3>Source</h3>

<p>Just values that might be typical of a fish.
</p>

<hr>
<h2 id='species_1_slurped_results'>The result of running spip in the species_1_simulation vignette.</h2><span id='topic+species_1_slurped_results'></span>

<h3>Description</h3>

<p>This is stored as package data so that the vignette can be written
even if spip is not installed on the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_1_slurped_results
</code></pre>


<h3>Source</h3>

<p>Simulation results
</p>

<hr>
<h2 id='species_1_slurped_results_100_loci'>The result of running spip in the species_1_simulation vignette with 100 loci.</h2><span id='topic+species_1_slurped_results_100_loci'></span>

<h3>Description</h3>

<p>This is stored as package data so that the vignette can be written
even if spip is not installed on the system. This particular version
stores the results of running <code>run_spip()</code> calling for 100 loci segregating
in the population, then slurping the results up with <code>slurp_spip()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_1_slurped_results_100_loci
</code></pre>


<h3>Source</h3>

<p>Simulation results
</p>

<hr>
<h2 id='species_1_slurped_results_1gen'>The result of running spip in the species_1_simulation vignette and slurping out with num_generations = 1.</h2><span id='topic+species_1_slurped_results_1gen'></span>

<h3>Description</h3>

<p>This is stored as package data so that the vignette can be written
even if spip is not installed on the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_1_slurped_results_1gen
</code></pre>


<h3>Source</h3>

<p>Simulation results
</p>

<hr>
<h2 id='species_2_life_history'>a list of life-history / life-table data for another hypothetical species</h2><span id='topic+species_2_life_history'></span>

<h3>Description</h3>

<p>species_2 for examples.  Note that I just set the male and female
rates and parameters similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>species_2_life_history
</code></pre>


<h3>Source</h3>

<p>This is something used for simulation testing
</p>

<hr>
<h2 id='spip_binary'>file path to be used in a call to spip</h2><span id='topic+spip_binary'></span>

<h3>Description</h3>

<p>This version checks to make sure it is there and throws an
error with a suggestion of how to get it if it is not there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spip_binary()
</code></pre>

<hr>
<h2 id='spip_binary_path'>return the path where spip should be in the R system paths</h2><span id='topic+spip_binary_path'></span>

<h3>Description</h3>

<p>It expects it to be in the R package directory after external installation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spip_binary_path()
</code></pre>

<hr>
<h2 id='spip_exists'>return TRUE if spip exists where it should be installed.</h2><span id='topic+spip_exists'></span>

<h3>Description</h3>

<p>This just checks for the file where it gets installed with
<code>install_spip()</code>. This is exported so it can be used to control
the flow in the vignettes, so that vignettes can still be
written using saved results when spip is not installed (i.e.,
at CRAN, etc.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spip_exists()
</code></pre>


<h3>Value</h3>

<p>A single logical scalar, either TRUE or FALSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will be FALSE unless spip has been externally installed
spip_exists()
</code></pre>

<hr>
<h2 id='spip_help'>print the abbreviated usage information from spip</h2><span id='topic+spip_help'></span>

<h3>Description</h3>

<p>This simply calls spip with the <code>--help</code> option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spip_help()
</code></pre>


<h3>Value</h3>

<p>This returns the exit status of <code>spip</code> if spip is installed,
but the return value is of little use.  Mainly this is run for the side
effect of printing the <code>spip</code> help menu to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: spip_help()
</code></pre>

<hr>
<h2 id='spip_help_full'>print the full usage information from spip</h2><span id='topic+spip_help_full'></span>

<h3>Description</h3>

<p>This simply calls spip with the <code>--help-full</code> option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spip_help_full()
</code></pre>


<h3>Value</h3>

<p>This returns the exit status of <code>spip</code> if spip is installed,
but the return value is of little use.  Mainly this is run for the side
effect of printing the <code>spip</code> full help menu to the console.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: spip_help()
</code></pre>

<hr>
<h2 id='summarize_offspring_and_mate_numbers'>Summarize the distribution of number of offspring and number of mates</h2><span id='topic+summarize_offspring_and_mate_numbers'></span>

<h3>Description</h3>

<p>More later
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_offspring_and_mate_numbers(
  census_postkill,
  pedigree,
  deaths,
  lifetime_hexbin_width = c(1, 1),
  contrib_bin_width = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_offspring_and_mate_numbers_+3A_census_postkill">census_postkill</code></td>
<td>
<p>a tibble with the postkill numbers of individuals.  This
is here so we know the total number of individuals that could have reproduced in a given
year.</p>
</td></tr>
<tr><td><code id="summarize_offspring_and_mate_numbers_+3A_pedigree">pedigree</code></td>
<td>
<p>a tibble with columns of <code>year</code>, <code>kid</code>, <code>pa</code>, and <code>ma</code>. The IDs of the'
individuals must by like MX_Y where M means male, X is the birth year, and Y is the unique
ID number.</p>
</td></tr>
<tr><td><code id="summarize_offspring_and_mate_numbers_+3A_deaths">deaths</code></td>
<td>
<p>a tibble with columns of <code>ID</code>, <code>year</code>, and <code>age</code>, giving the years and ages at which
different individuals died.</p>
</td></tr>
<tr><td><code id="summarize_offspring_and_mate_numbers_+3A_lifetime_hexbin_width">lifetime_hexbin_width</code></td>
<td>
<p>a vector of length two.  The first element is the width in the
age direction of each hexbin and the second is the width in the lifetime number of offspring
direction for the <code>plot_lifetime_output_vs_age_at_death</code> output plot.</p>
</td></tr>
<tr><td><code id="summarize_offspring_and_mate_numbers_+3A_contrib_bin_width">contrib_bin_width</code></td>
<td>
<p>width of bins of histogram of contribution of parents of
each age and sex to the offspring.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three components, each of them a ggplot object:
</p>

<ul>
<li> <p><code>plot_age_specific_number_of_offspring</code>: a ggplot object that plots boxplots and jittered points.
The x-axis are the ages of the individuals; the y-axis shows the number of offspring. Summarized
over the entire spip simulation. This is faceted by sex.
</p>
</li>
<li> <p><code>plot_lifetime_output_vs_age_at_death</code>: a ggplot object.  This is a hexbin plot. The x-axis
are age-at-death bins, the y axis are bins of total number of offspring produced in a lifetime.
The fill color of each bin gives the number of individuals with that age at death and number
of offspring encountered over the whole simulation.  Plot is faceted by sex.
</p>
</li>
<li> <p><code>plot_fraction_of_offspring_from_each_age_class</code>: a ggplot object. This shows the distribution
over all years of the simulation, of the fraction of offspring produced each year that were
produced by males or females of a given age (the plots are facet-wrapped by both age and sex).
The blue vertical line gives the mean.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># get stored slurped output for an example
X &lt;- species_1_slurped_results
g &lt;- summarize_offspring_and_mate_numbers(
  X$census_postkill,
  X$pedigree,
  X$deaths
)

# Now g is a list holding three plots, accessible like this:

# g$plot_age_specific_number_of_offspring

# g$plot_lifetime_output_vs_age_at_death

# g$plot_fraction_of_offspring_from_each_age_class

</code></pre>

<hr>
<h2 id='summarize_survival_from_census'>Summarize annual sex-and-age-specific survival rates from the census information</h2><span id='topic+summarize_survival_from_census'></span>

<h3>Description</h3>

<p>The prekill census in year t+1 is the post-kill census in year t, so
we can use the prekill census to record the realized fraction of individuals
of each age and sex that survived the death episode in each year.  In the
output survival in year t is the fraction of j-year olds in year t that
survive to be j+1 year-olds in year t+1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_survival_from_census(
  census,
  fem_surv_probs = NULL,
  male_surv_probs = NULL,
  nbins = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_survival_from_census_+3A_census">census</code></td>
<td>
<p>a tibble of census counts with columns <code>year</code> and
<code>age</code>, and then the counts of the different sexes in columns
named <code>male</code>, and <code>female</code>.</p>
</td></tr>
<tr><td><code id="summarize_survival_from_census_+3A_fem_surv_probs">fem_surv_probs</code></td>
<td>
<p>a vector of the parameters used for the simulation.  If present
these are put on the histogram plots. If you provide one of these, you have to provide both.</p>
</td></tr>
<tr><td><code id="summarize_survival_from_census_+3A_male_surv_probs">male_surv_probs</code></td>
<td>
<p>a vector of the parameters used for the simulation.  If present
these are put on the histogram plots.</p>
</td></tr>
<tr><td><code id="summarize_survival_from_census_+3A_nbins">nbins</code></td>
<td>
<p>number of bins for the histograms</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not track migrants.  Another one is eventually
in order that accounts for migrants out of the population.  Also,
the plots here might not play well with multiple populations.
</p>


<h3>Value</h3>

<p>A list with components:
</p>

<ul>
<li> <p><code>survival_tibble</code>:  A tibble with the following columns:
</p>

<ul>
<li> <p><code>year</code>: The year
</p>
</li>
<li> <p><code>pop</code>: The population whose census is being counted
</p>
</li>
<li> <p><code>age</code>: The age of individuals
</p>
</li>
<li> <p><code>sex</code>: The sex of individuals
</p>
</li>
<li> <p><code>n</code>: The number of individuals alive and present of sex <code>sex</code> and age <code>age</code> in year
<code>year</code> in pop <code>pop</code>.
</p>
</li>
<li> <p><code>cohort</code>: The birth year of these individuals
</p>
</li>
<li> <p><code>surv_fract</code>: The fraction of the n individuals that survive to have age <code>age + 1</code> in
year <code>year + 1</code>.
</p>
</li></ul>

</li>
<li> <p><code>plot_histos_by_age_and_sex</code>: A ggplot object of histograms of observed survival fractions
facet-wrapped by age and sex.  Blue vertical lines are the observed means and dashed vertical
red lines are the expected values given the simulation parameters.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- summarize_survival_from_census(
  species_1_slurped_results$census_prekill,
  species_1_life_history$`fem-surv-probs`,
  species_1_life_history$`male-surv-probs`
)

# print the results if you want
result$survival_tibble
result$plot_histos_by_age_and_sex

</code></pre>

<hr>
<h2 id='three_pops_no_mig_slurped_results'>The result of running spip and slurping the output in the three population case with no migration</h2><span id='topic+three_pops_no_mig_slurped_results'></span>

<h3>Description</h3>

<p>This is stored as package data so that the vignette can be written
even if spip is not installed on the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>three_pops_no_mig_slurped_results
</code></pre>


<h3>Source</h3>

<p>Simulation results
</p>

<hr>
<h2 id='three_pops_with_mig_slurped_results'>The result of running spip and slurping the output in the three population case with migration</h2><span id='topic+three_pops_with_mig_slurped_results'></span>

<h3>Description</h3>

<p>This is stored as package data so that the vignette can be written
even if spip is not installed on the system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>three_pops_with_mig_slurped_results
</code></pre>


<h3>Source</h3>

<p>Simulation results
</p>

<hr>
<h2 id='uncooked_spaghetti'>Summarise kin-pair information and use it to create uncooked spaghetti plots</h2><span id='topic+uncooked_spaghetti'></span>

<h3>Description</h3>

<p>This gives a nice graphical summary of all the kin pairs along with when they
were sampled and their age at the time of sampling and their sex.
#'  In order to visually summarize all the kin pairs that were found,
with specific reference to their age, time of sampling, and sex, I find it
helpful to use what I have named the &quot;Uncooked Spaghetti Plot&quot;.  There are multiple
subpanels on this plot.  Here is how to read/view these plots:
</p>

<ul>
<li><p> Each row of subpanels is for a different dominant relationship, going from
closer relationships near the top and more distant ones further down.  You can
find the abbreviation for the dominant relationship at the right edge of the panels.
</p>
</li>
<li><p> In each row, there are four subpanels: <code>F-&gt;F</code>, <code>F-&gt;M</code>, <code>M-&gt;F</code>, and <code>M-&gt;M</code>.  These
refer to the different possible combinations of sexes of the individuals in the pair.
</p>

<ul>
<li><p> For the non-symmetrical relationships these are naturally defined with the
first letter (<code>F</code> for female or <code>M</code> for male) denoting the sex of the &quot;upper_member&quot;
of the relationship.  That is, if it is PO, then the sex of the parent is the first letter.
The sex of the non-upper-member is the second letter.  Thus a <code>PO</code> pair that consists of
a father and a daughter would appear in a plot that is in the <code>PO</code> row in the <code>M-&gt;F</code> column.
</p>
</li>
<li><p> For the symmetrical relationships, there isn't a comparably natural way of
ordering the individuals' sexes for presentation.  For these relationships, the
first letter refers to the sex of the individual that was sampled in the earliest
year.  If both individuals were sampled in the same year, and they are of different
sexes, then the female is considered the first one, so those all go on the <code>F-&gt;M</code> subpanel.
</p>
</li></ul>

</li>
<li><p> On the subpanels, each straight line (i.e., each piece of uncooked spaghetti) represents
a single kin pair.  The two endpoints represent the year/time of sampling (on the x-axis)
and the age of the individual when it was sampled (on the y-axis) of the two members of
the pair.
</p>

<ul>
<li><p> If the relationship is non-symmetrical, then the line is drawn as an arrow pointing
from the upper member to the lower member.
</p>
</li>
<li><p> The color of the line gives the number of shared ancestors (<code>max_hit</code>) at the level
of the dominant relationship. This is how you can distinguish full-sibs from half-sibs, etc.
</p>
</li></ul>

</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>uncooked_spaghetti(Pairs, Samples, jitter_age = 0.2, jitter_year = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncooked_spaghetti_+3A_pairs">Pairs</code></td>
<td>
<p>The tibble of kin pairs that comes out of <code>compile_related_pairs()</code>.</p>
</td></tr>
<tr><td><code id="uncooked_spaghetti_+3A_samples">Samples</code></td>
<td>
<p>The tibble of samples that comes out of <code>slurp_spip()</code>.</p>
</td></tr>
<tr><td><code id="uncooked_spaghetti_+3A_jitter_age">jitter_age</code></td>
<td>
<p>half the width of the uniform jitter window around age</p>
</td></tr>
<tr><td><code id="uncooked_spaghetti_+3A_jitter_year">jitter_year</code></td>
<td>
<p>half the width of the uniform jitter window around sampling year</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>uncooked_spaghetti()</code> returns a list with two components: <code>input_data</code> and <code>plot</code>.
<code>plot</code> is a ggplot object of the plot described above in &quot;Description.&quot;  <code>input_data</code> is,
itself, another list with the following named components:
</p>

<ul>
<li> <p><code>P5</code>: A tibble that is a processed version of the <code>Pairs</code> input.  This is what
goes into making the ggplot.
</p>
</li>
<li> <p><code>age_grid</code>: A tibble giving the coordinates for placing the alternating pink and white
horizontal background rectangles on the plot.
</p>
</li>
<li> <p><code>year_grid</code>: A tibble giving the coordinates for placing the alternating pink and white
vertical background rectangles on the plot.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># get the input variables
# only take the first 50 samples to reduce time for example
Samples &lt;- species_1_slurped_results$samples[1:50, ]
Pairs &lt;- compile_related_pairs(Samples)
result &lt;- uncooked_spaghetti(Pairs, Samples)

# produce the plot with:
# result$plot
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
