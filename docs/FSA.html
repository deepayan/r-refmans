<!DOCTYPE html><html><head><title>Help for package FSA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FSA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.onAttach'><p>Internal functions.</p></a></li>
<li><a href='#addZeroCatch'><p>Adds zeros for catches of species not collected in some sampling events.</p></a></li>
<li><a href='#ageBias'><p>Compute and view possible differences between paired sets of ages.</p></a></li>
<li><a href='#agePrecision'><p>Compute measures of precision among sets of ages.</p></a></li>
<li><a href='#alkAgeDist'><p>Proportions-at-age from an age-length key</p></a></li>
<li><a href='#alkIndivAge'><p>Use an age-length key to assign age to individuals in the unaged sample.</p></a></li>
<li><a href='#alkMeanVar'><p>Mean Values-at-age from an age-length key</p></a></li>
<li><a href='#alkPlot'><p>Plots to visualize age-length keys.</p></a></li>
<li><a href='#binCI'><p>Confidence intervals for binomial probability of success.</p></a></li>
<li><a href='#BluegillJL'><p>Capture histories (2 samples) of Bluegill from Jewett Lake, MI.</p></a></li>
<li><a href='#BrookTroutTH'><p>Catch-at-age for Tobin Harbor, Isle Royale Brook Trout.</p></a></li>
<li><a href='#capFirst'><p>Capitalizes the first letter of first or all words in a string.</p></a></li>
<li><a href='#capHistConvert'><p>Convert between capture history data.frame formats.</p></a></li>
<li><a href='#capHistSum'><p>Summarize capture histories in individual fish format.</p></a></li>
<li><a href='#catchCurve'><p>Mortality estimates from the descending limb of a catch curve.</p></a></li>
<li><a href='#chapmanRobson'><p>Computes Chapman-Robson estimates of S and Z.</p></a></li>
<li><a href='#ChinookArg'><p>Lengths and weights for Chinook Salmon from three locations in Argentina.</p></a></li>
<li><a href='#CodNorwegian'><p>Stock and recruitment data for Norwegian cod, 1937-1960.</p></a></li>
<li><a href='#col2rgbt'><p>Converts an R color to RGB (red/green/blue) including a transparency (alpha channel).</p></a></li>
<li><a href='#confint.boot'><p>Associated S3 methods for bootstrap results from car::Boot.</p></a></li>
<li><a href='#CutthroatAL'><p>Capture histories (9 samples) of Cutthroat Trout from Auke Lake.</p></a></li>
<li><a href='#depletion'><p>Computes the Leslie or DeLury population estimate from catch and effort data.</p></a></li>
<li><a href='#dunnTest'><p>Dunn's Kruskal-Wallis Multiple Comparisons.</p></a></li>
<li><a href='#Ecoli'><p>Population growth of Escherichia coli.</p></a></li>
<li><a href='#expandCounts'><p>Repeat individual fish data (including lengths) from tallied counts.</p></a></li>
<li><a href='#expandLenFreq'><p>Expands a length frequency based on a subsample.</p></a></li>
<li><a href='#extraTests'><p>Likelihood ratio and extra sum-of-squares tests.</p></a></li>
<li><a href='#fact2num'><p>Converts &quot;numeric&quot; factor levels to numeric values.</p></a></li>
<li><a href='#fishR'><p>Opens web pages associated with the fishR website.</p></a></li>
<li><a href='#FSA'><p>Fisheries stock assessment methods and data.</p></a></li>
<li><a href='#FSA-defunct'><p>DEFUNCT functions.</p></a></li>
<li><a href='#geomean'><p>Calculates the geometric mean or geometric standard deviation.</p></a></li>
<li><a href='#growthModels'><p>Creates a function for a specific parameterization of the von Bertalanffy, Gompertz, Richards, and logistic growth functions.</p></a></li>
<li><a href='#headtail'><p>Shows rows from the head and tail of a data frame or matrix.</p></a></li>
<li><a href='#hist.formula'><p>Creates separate histograms by levels.</p></a></li>
<li><a href='#histFromSum'><p>Create a histogram from a frequency table.</p></a></li>
<li><a href='#hyperCI'><p>Confidence interval for population size (N) in hypergeometric distribution.</p></a></li>
<li><a href='#is.odd'><p>Determine if a number is odd or even.</p></a></li>
<li><a href='#jolly'><p>Jolly-Seber analysis from multiple mark-recapture events from an open population.</p></a></li>
<li><a href='#kCounts'><p>Specific utilities for use in a knitr document.</p></a></li>
<li><a href='#ksTest'><p>Kolmogorov-Smirnov Tests.</p></a></li>
<li><a href='#lagratio'><p>Ratio of lagged observations.</p></a></li>
<li><a href='#lencat'><p>Constructs length class/category variable.</p></a></li>
<li><a href='#logbtcf'><p>Constructs the correction-factor used when back-transforming log-transformed values.</p></a></li>
<li><a href='#lwCompPreds'><p>Constructs plots of predicted weights at given lengths among different groups.</p></a></li>
<li><a href='#Mirex'><p>Mirex concentration, weight, capture year, and species of Lake Ontario salmon.</p></a></li>
<li><a href='#Mmethods'><p>Estimate natural mortality from a variety of empirical methods.</p></a></li>
<li><a href='#mrClosed'><p>Estimate initial population size for single or multiple census mark-recapture data.</p></a></li>
<li><a href='#nlsBoot'><p>Associated S3 methods for nlsBoot from nlstools.</p></a></li>
<li><a href='#nlsTracePlot'><p>Adds model fits from nls iterations to active plot.</p></a></li>
<li><a href='#peek'><p>Peek into (show a subset of) a data frame or matrix.</p></a></li>
<li><a href='#perc'><p>Computes the percentage of values in a vector less than or greater than (and equal to) some value.</p></a></li>
<li><a href='#PikeNY'><p>Summarized multiple mark-recapture data for all Northern Pike from Buckhorn Marsh, NY.</p></a></li>
<li><a href='#PikeNYPartial1'><p>Capture histories (4 samples), in capture history format, of a subset of Northern Pike from Buckhorn Marsh, NY.</p></a></li>
<li><a href='#plotAB'><p>Construct traditional (Campana-like) age-bias plots.</p></a></li>
<li><a href='#poiCI'><p>Confidence interval for Poisson counts.</p></a></li>
<li><a href='#psdAdd'><p>Creates a vector of Gabelhouse lengths for each species in an entire data frame.</p></a></li>
<li><a href='#psdCalc'><p>Convenience function for calculating PSD-X and PSD X-Y values.</p></a></li>
<li><a href='#psdCI'><p>Compute confidence intervals for PSD-X and PSD X-Y values.</p></a></li>
<li><a href='#PSDlit'><p>Gabelhouse five-cell length categories for various species.</p></a></li>
<li><a href='#psdPlot'><p>Length-frequency histogram with Gabelhouse lengths highlighted.</p></a></li>
<li><a href='#psdVal'><p>Finds Gabelhouse lengths (for PSD calculations) for a species.</p></a></li>
<li><a href='#rcumsum'><p>Computes the prior to or reverse cumulative sum of a vector.</p></a></li>
<li><a href='#removal'><p>Population estimates for k-, 3-, or 2-pass removal data.</p></a></li>
<li><a href='#repeatedRows2Keep'><p>Find non-repeated consecutive rows in a data.frame.</p></a></li>
<li><a href='#rSquared'><p>Extract the coefficient of determination from a linear model object.</p></a></li>
<li><a href='#Schnute'><p>The four-parameter growth function from Schnute (1981).</p></a></li>
<li><a href='#SchnuteRichards'><p>The five-parameter growth function from Schnute and Richards (1990).</p></a></li>
<li><a href='#se'><p>Computes standard error of the mean.</p></a></li>
<li><a href='#SMBassLS'><p>Catch-effort data for Little Silver Lake (Ont) Smallmouth Bass.</p></a></li>
<li><a href='#SMBassWB'><p>Growth increment data for West Bearskin Lake, MN, Smallmouth Bass.</p></a></li>
<li><a href='#SpotVA1'><p>Age and length of spot.</p></a></li>
<li><a href='#srFuns'><p>Creates a function for a specific parameterization of a common stock-recruitment function .</p></a></li>
<li><a href='#srStarts'><p>Finds reasonable starting values for parameters in specific parameterizations of common stock-recruitment models.</p></a></li>
<li><a href='#Summarize'><p>Summary statistics for a numeric variable.</p></a></li>
<li><a href='#sumTable'><p>Creates a one- or two-way table of summary statistics.</p></a></li>
<li><a href='#tictactoe'><p>Construct a base tic-tac-toe plot for presenting predator-prey PSD values.</p></a></li>
<li><a href='#validn'><p>Finds the number of valid (non-NA) values in a vector.</p></a></li>
<li><a href='#vbStarts'><p>Find reasonable starting values for a von Bertalanffy growth function.</p></a></li>
<li><a href='#WhitefishLC'><p>Assigned ages from two readers on three structures for Lake Whitefish from Lake Champlain.</p></a></li>
<li><a href='#WR79'><p>Ages and lengths for a hypothetical sample from Westerheim and Ricker (1979).</p></a></li>
<li><a href='#wrAdd'><p>Computes a vector of relative weights specific to a species in an entire data frame.</p></a></li>
<li><a href='#WSlit'><p>All known standard weight equations.</p></a></li>
<li><a href='#wsVal'><p>Finds standard weight equation coefficients for a particular species.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.9.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-8-25</td>
</tr>
<tr>
<td>Title:</td>
<td>Simple Fisheries Stock Assessment Methods</td>
</tr>
<tr>
<td>Description:</td>
<td>A variety of simple fish stock assessment methods.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://fishr-core-team.github.io/FSA/">https://fishr-core-team.github.io/FSA/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fishR-Core-Team/FSA/issues">https://github.com/fishR-Core-Team/FSA/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, tools, utils, car, dunn.test,
lmtest, plotrix, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DescTools, dplyr, fishmethods, FSAdata, knitr, marked, nlme,
nlstools, pkgdown, plyr, psych, Rcapture, rmarkdown, testthat,
tibble, covr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-26 18:16:51 UTC; derek</td>
</tr>
<tr>
<td>Author:</td>
<td>Derek H. Ogle <a href="https://orcid.org/0000-0002-0370-9299"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jason C. Doll [aut],
  A. Powell Wheeler [aut],
  Alexis Dinno [aut] (Provided base functionality of dunnTest())</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Derek H. Ogle &lt;DerekOgle51@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-26 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.onAttach'>Internal functions.</h2><span id='topic+.onAttach'></span><span id='topic+iAddLoessLine'></span><span id='topic+iCheckALK'></span><span id='topic+iCheckMultColor'></span><span id='topic+iCheckStartcatW'></span><span id='topic+iCILabel'></span><span id='topic+iGetDecimals'></span><span id='topic+iGetVarFromFormula'></span><span id='topic+iHndlCols2UseIgnore'></span><span id='topic+iHndlFormula'></span><span id='topic+iHndlMultWhat'></span><span id='topic+iLegendHelp'></span><span id='topic+iListSpecies'></span><span id='topic+iMakeColor'></span><span id='topic+iPlotExists'></span><span id='topic+is.wholenumber'></span><span id='topic+iTypeoflm'></span><span id='topic+STOP'></span><span id='topic+WARN'></span>

<h3>Description</h3>

<p>Internal functions that are common to several functions in FSA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(lib, pkg, ...)
</code></pre>

<hr>
<h2 id='addZeroCatch'>Adds zeros for catches of species not collected in some sampling events.</h2><span id='topic+addZeroCatch'></span>

<h3>Description</h3>

<p>Adds zeros for catches of species that were not captured in a sampling event but were captured in at least one other sampling event (i.e., adds zeros to the data.frame for capture events where a species was not observed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addZeroCatch(df, eventvar, specvar, zerovar, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addZeroCatch_+3A_df">df</code></td>
<td>
<p>A data.frame that contains the capture summary data as described in the details.</p>
</td></tr>
<tr><td><code id="addZeroCatch_+3A_eventvar">eventvar</code></td>
<td>
<p>A string for the variable that identifies unique capture events.</p>
</td></tr>
<tr><td><code id="addZeroCatch_+3A_specvar">specvar</code></td>
<td>
<p>A string or vector of strings for the variable(s) that identify the &ldquo;species&rdquo; (if multiple variables, could be species, sex, and life stage, for example) captured. See examples.</p>
</td></tr>
<tr><td><code id="addZeroCatch_+3A_zerovar">zerovar</code></td>
<td>
<p>A string or vector of strings for the variable(s) that should be set equal to zero. See details and examples.</p>
</td></tr>
<tr><td><code id="addZeroCatch_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical that indicates if rows where <code>specvar</code> that are <code>NA</code> should be removed after adding the zeros. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data.frame in <code>df</code> must contain a column that identifies a unique capture event (given in <code>eventvar</code>), a column with the name for the species captured (given in <code>specvar</code>), and a column that contains the number of that species captured (potentially given to <code>zerovar</code>; see details). All sampling event and species combinations where catch information does not exist is identified and a new data.frame that contains a zero for the catch for all of these combinations is created. This new data.frame is appended to the original data.frame to construct a data.frame that contains complete catch information &ndash; i.e., including zeros for species in events where that species was not captured.
</p>
<p>The data.frame may contain other information related to the catch, such as number of recaptured fish, number of fish released, etc. These additional variables can be included in <code>zerovar</code> so that zeros will be added to these variables as well (e.g., if the catch of the species is zero, then the number of recaptures must also be zero). All variables not given in <code>eventvar</code>, <code>specvar</code>, or <code>zerovar</code> will be assumed to be related to <code>eventvar</code> and <code>specvar</code> (e.g., date, gear type, and habitat) and, thus, will be repeated with these variables.
</p>
<p>In situations where no fish were captured in some events, the <code>df</code> may contain rows that have a value for <code>eventvar</code> but not for <code>specvar</code>. These rows are important because zeros need to be added for each observed species for these events. However, in these situations, a <code>&lt;NA&gt;</code> species will appear in the resulting data.frame. It is unlikely that these &ldquo;missing&rdquo; species are needed so they will be removed if <code>na.rm=TRUE</code> (DEFAULT) is used.
</p>
<p>One should test the results of this function by creating a frequency table of the <code>eventvar</code> or <code>specvar</code>. In either case, the table should contain the same value in each cell of the table. See the examples.
</p>


<h3>Value</h3>

<p>A data.frame with the same structure as <code>df</code> but with rows of zero observation data appended.
</p>


<h3>IFAR Chapter</h3>

<p>2-Basic Data Manipulations
</p>


<h3>Note</h3>

<p>An error will be returned if either <code>specvar</code> or <code>eventvar</code> are factors with any <code>NA</code> levels. This usually arises if the data.frame was subsetted/filtered prior to using <code>addZeroCatch</code>. See <code><a href="base.html#topic+droplevels">droplevels</a></code> for descriptions of how to drop unused levels.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p><code>complete</code> in <span class="pkg">tidyr</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example Data #1 (some nets missing some fish, ancillary net data)
df1 &lt;- data.frame(net=c(1,1,1,2,2,3),
                  eff=c(1,1,1,1,1,1),
                  species=c("BKT","LKT","RBT","BKT","LKT","RBT"),
                  catch=c(3,4,5,5,4,3))
df1
# not all 1s
xtabs(~net+species,data=df1)

df1mod1 &lt;- addZeroCatch(df1,"net","species",zerovar="catch")
df1mod1
# check, should all be 3
xtabs(~net,data=df1mod1)
# check, should all be 1
xtabs(~net+species,data=df1mod1)
# correct mean/sd of catches
Summarize(catch~species,data=df1mod1)
# incorrect mean/sd of catches (no zeros)
Summarize(catch~species,data=df1)

# Same as example 1 but with no ancillary data specific to the net number
df2 &lt;- df1[,-2]
df2
df1mod2 &lt;- addZeroCatch(df2,"net","species",zerovar="catch")
df1mod2
# check, should all be 1
xtabs(~net+species,data=df1mod2)

## Example Data #3 (All nets have same species ... no zeros needed)
df3 &lt;- data.frame(net=c(1,1,1,2,2,2,3,3,3),
                  eff=c(1,1,1,1,1,1,1,1,1),
                  species=c("BKT","LKT","RBT","BKT","LKT",
                            "RBT","BKT","LKT","RBT"),
                  catch=c(3,4,5,5,4,3,3,2,7))
df3
# should all be 1 for this example
xtabs(~net+species,data=df3)

# should receive a warning and table should still all be 1
df3mod1 &lt;- addZeroCatch(df3,"net","species",zerovar="catch")
xtabs(~net+species,data=df3mod1)

## Example Data #4 (another variable that needs zeros)
df4 &lt;- df1
df4$recaps &lt;- c(0,0,0,1,2,1)
df4
# not all 1s
xtabs(~net+species,data=df4)

df4mod1 &lt;- addZeroCatch(df4,"net","species",zerovar=c("catch","recaps"))
# note zeros in both variables
df4mod1
# check, should all be 1
xtabs(~net+species,data=df4mod1)
# observe difference from next
Summarize(catch~species,data=df4)
Summarize(catch~species,data=df4mod1)
# observe difference from next
Summarize(recaps~species,data=df4)
Summarize(recaps~species,data=df4mod1)

## Example Data #5 (two "specvar"s)
df5 &lt;- df1
df5$sex &lt;- c("m","m","f","m","f","f")
df5
# not all 1s
xtabs(~sex+species+net,data=df5)

df5mod1 &lt;- addZeroCatch(df5,"net",c("species","sex"),zerovar="catch")
df5mod1
# all 1s
xtabs(~sex+species+net,data=df5mod1)
str(df5mod1) 

## Example Data #6 (three "specvar"s)
df6 &lt;- df5
df6$size &lt;- c("lrg","lrg","lrg","sm","lrg","sm")
df6

df6mod1 &lt;- addZeroCatch(df6,"net",c("species","sex","size"),zerovar="catch")
df6mod1
 
</code></pre>

<hr>
<h2 id='ageBias'>Compute and view possible differences between paired sets of ages.</h2><span id='topic+ageBias'></span><span id='topic+plot.ageBias'></span><span id='topic+summary.ageBias'></span>

<h3>Description</h3>

<p>Constructs age-agreement tables, statistical tests to detect differences, and plots to visualize potential differences in paired age estimates. Ages may be from, for example, two readers of the same structure, one reader at two times, two structures (e.g., scales, spines, otoliths), or one structure and known ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ageBias(
  formula,
  data,
  ref.lab = tmp$Enames,
  nref.lab = tmp$Rname,
  method = stats::p.adjust.methods,
  sig.level = 0.05,
  min.n.CI = 3
)

## S3 method for class 'ageBias'
summary(
  object,
  what = c("table", "symmetry", "Bowker", "EvansHoenig", "McNemar", "bias", "diff.bias",
    "n"),
  flip.table = FALSE,
  zero.print = "-",
  digits = 3,
  cont.corr = c("none", "Yates", "Edwards"),
  ...
)

## S3 method for class 'ageBias'
plot(
  x,
  xvals = c("reference", "mean"),
  xlab = ifelse(xvals == "reference", x$ref.lab, "Mean Age"),
  ylab = paste(x$nref.lab, "-", x$ref.lab),
  xlim = NULL,
  ylim = NULL,
  yaxt = graphics::par("yaxt"),
  xaxt = graphics::par("xaxt"),
  col.agree = "gray60",
  lwd.agree = lwd,
  lty.agree = 2,
  lwd = 1,
  sfrac = 0,
  show.pts = NULL,
  pch.pts = 20,
  cex.pts = ifelse(xHist | yHist, 1.5, 1),
  col.pts = "black",
  transparency = 1/10,
  show.CI = FALSE,
  col.CI = "black",
  col.CIsig = "red",
  lwd.CI = lwd,
  sfrac.CI = sfrac,
  show.range = NULL,
  col.range = ifelse(show.CI, "gray70", "black"),
  lwd.range = lwd,
  sfrac.range = sfrac,
  pch.mean = 19,
  pch.mean.sig = ifelse(show.CI | show.range, 21, 19),
  cex.mean = lwd,
  yHist = TRUE,
  xHist = NULL,
  hist.panel.size = 1/7,
  col.hist = "gray90",
  allowAdd = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ageBias_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>nrefvar~refvar</code>, where <code>nrefvar</code> and <code>refvar</code> generically represent variables that contain the paired &ldquo;nonreference&rdquo; and &ldquo;reference&rdquo; age estimates, respectively. See details.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains the paired age estimates given in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_ref.lab">ref.lab</code></td>
<td>
<p>A string label for the reference age estimates.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_nref.lab">nref.lab</code></td>
<td>
<p>A string label for the nonreference age estimates.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_method">method</code></td>
<td>
<p>A string for which method to use to adjust p-values for multiple comparisons. See <code>?p.adjust.methods</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_sig.level">sig.level</code></td>
<td>
<p>A numeric value to determine whether a p-value indicates a significant result. The confidence level used in <code>plot</code> is 100*(1-<code>sig.level</code>).</p>
</td></tr>
<tr><td><code id="ageBias_+3A_min.n.ci">min.n.CI</code></td>
<td>
<p>A numeric value (default is 3) that is the smallest sample size for which a confidence interval will be computed.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_what">what</code></td>
<td>
<p>A string that indicates what type of summary to print or plot to construct. See details.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_flip.table">flip.table</code></td>
<td>
<p>A logical that indicates whether the age-agreement table should be &lsquo;flipped&rsquo; (i.e., rows are reversed so that younger ages are at the bottom of the table). This makes the table more directly comparable to the age bias plot.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_zero.print">zero.print</code></td>
<td>
<p>A string for what should be printed in place of the zeros on an age-agreement table. The default is to print a single dash.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_digits">digits</code></td>
<td>
<p>A numeric for the minimum number of digits to print when showing <code>what="bias"</code> or <code>what="diff.bias"</code> in <code>summary</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_cont.corr">cont.corr</code></td>
<td>
<p>A string that indicates the continuity correction method to be used with (only) McNemar test. If <code>"none"</code> (default) then no continuity correction is used, if <code>"Yates"</code> then 0.5 is used, and if <code>"Edwards"</code> then 1 is used.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_x">x</code>, <code id="ageBias_+3A_object">object</code></td>
<td>
<p>An object of class <code>ageBias</code>, usually a result from <code>ageBias</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_xvals">xvals</code></td>
<td>
<p>A string for whether the x-axis values are reference ages or mean of the reference and nonreference ages.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_xlab">xlab</code>, <code id="ageBias_+3A_ylab">ylab</code></td>
<td>
<p>A string label for the x-axis (reference) or y-axis (non-reference) age estimates, respectively.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_xlim">xlim</code>, <code id="ageBias_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 that contains the limits of the x-axis (reference ages) or y-axis (non-reference ages), respectively.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_xaxt">xaxt</code>, <code id="ageBias_+3A_yaxt">yaxt</code></td>
<td>
<p>A string which specifies the x- and y-axis types. Specifying &ldquo;n&rdquo; suppresses plotting of the axis. See <code>?par</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_col.agree">col.agree</code></td>
<td>
<p>A string or numeric for the color of the 1:1 or zero (if <code>difference=TRUE</code>) reference line.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_lwd.agree">lwd.agree</code></td>
<td>
<p>A numeric for the line width of the 1:1 or zero (if <code>difference=TRUE</code>) reference line.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_lty.agree">lty.agree</code></td>
<td>
<p>A numeric for the line type of the 1:1 or zero (if <code>difference=TRUE</code>) reference line.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_lwd">lwd</code></td>
<td>
<p>A numeric that controls the separate &lsquo;lwd&rsquo; argument (e.g., <code>lwd.CI</code> and <code>lwd.range</code>).</p>
</td></tr>
<tr><td><code id="ageBias_+3A_sfrac">sfrac</code></td>
<td>
<p>A numeric that controls the separate &lsquo;sfrac&rsquo; arguments (e.g., <code>sfrac.CI</code> and <code>sfrac.range</code>). See <code>sfrac</code> in <code><a href="plotrix.html#topic+plotCI">plotCI</a></code> of <span class="pkg">plotrix</span>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_show.pts">show.pts</code></td>
<td>
<p>A logical for whether or not the raw data points are plotted.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_pch.pts">pch.pts</code></td>
<td>
<p>A numeric for the plotting character of the raw data points.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_cex.pts">cex.pts</code></td>
<td>
<p>A character expansion value for the size of the symbols for <code>pch.pts</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_col.pts">col.pts</code></td>
<td>
<p>A string or numeric for the color of the raw data points. The default is to use black with the transparency found in <code>transparency</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_transparency">transparency</code></td>
<td>
<p>A numeric (between 0 and 1) for the level of transparency of the raw data points. This number of points plotted on top of each other will represent the color in <code>col.pts</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_show.ci">show.CI</code></td>
<td>
<p>A logical for whether confidence intervals should be plotted or not.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_col.ci">col.CI</code></td>
<td>
<p>A string or numeric for the color of confidence interval bars that are considered non-significant.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_col.cisig">col.CIsig</code></td>
<td>
<p>A string or numeric for the color of confidence interval bars that are considered significant.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_lwd.ci">lwd.CI</code></td>
<td>
<p>A numeric for the line width of the confidence interval bars.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_sfrac.ci">sfrac.CI</code></td>
<td>
<p>A numeric for the size of the ends of the confidence interval bars. See <code>sfrac</code> in <code><a href="plotrix.html#topic+plotCI">plotCI</a></code> of <span class="pkg">plotrix</span>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_show.range">show.range</code></td>
<td>
<p>A logical for whether or not vertical bars that represent the range of the data points are plotted.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_col.range">col.range</code></td>
<td>
<p>A string or numeric for the color of the range intervals.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_lwd.range">lwd.range</code></td>
<td>
<p>A numeric for the line width of the range intervals.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_sfrac.range">sfrac.range</code></td>
<td>
<p>A numeric for the size of the ends of the range intervals. See <code>sfrac</code> in <code><a href="plotrix.html#topic+plotCI">plotCI</a></code> of <span class="pkg">plotrix</span>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_pch.mean">pch.mean</code></td>
<td>
<p>A numeric for the plotting character used for the mean values when the means are considered insignificant.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_pch.mean.sig">pch.mean.sig</code></td>
<td>
<p>A numeric for the plotting character for the mean values when the means are considered significant.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_cex.mean">cex.mean</code></td>
<td>
<p>A character expansion value for the size of the mean symbol in <code>pch.mean</code> and <code>pch.mean.sig</code>.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_yhist">yHist</code></td>
<td>
<p>A logical for whether a histogram of the y-axis variable should be added to the right margin of the age bias plot. See details.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_xhist">xHist</code></td>
<td>
<p>A logical for whether a histogram of the x-axis variable should be added to the top margin of the age bias plot. See details.</p>
</td></tr>
<tr><td><code id="ageBias_+3A_hist.panel.size">hist.panel.size</code></td>
<td>
<p>A numeric between 0 and 1 that indicates the proportional size of histograms (relative to the entire plotting pane) in the plot margins (only used if <code>xHist=TRUE</code> or <code>yHist=TRUE</code>).</p>
</td></tr>
<tr><td><code id="ageBias_+3A_col.hist">col.hist</code></td>
<td>
<p>A string for the color of the bars in the marginal histograms (only used if <code>xHist=TRUE</code> or <code>yHist=TRUE</code>).</p>
</td></tr>
<tr><td><code id="ageBias_+3A_allowadd">allowAdd</code></td>
<td>
<p>A logical that will allow the user to add items to the main (i.e., not the marginal histograms) plot panel (if <code>TRUE</code>). Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generally, one of the two age estimates will be identified as the &ldquo;reference&rdquo; set. In some cases this may be the true ages, the ages from the more experienced reader, the ages from the first reading, or the ages from the structure generally thought to provide the most accurate results. In other cases, such as when comparing two novice readers, the choice may be arbitrary. The reference ages will form the columns of the age-agreement table and will be the &ldquo;constant&rdquo; age used in the t-tests and age bias plots (i.e., the x-axis). See further details below.
</p>
<p>The age-agreement table is constructed with  <code>what="table"</code> in <code>summary</code>. The agreement table can be &ldquo;flipped&rdquo; (i.e., the rows in descending rather than ascending order) with <code>flip.table=TRUE</code>. By default, the tables are shown with zeros replaced by dashes. This behavior can be changed with <code>zero.print</code>.
</p>
<p>Three statistical tests of symmetry for the age-agreement table can be computed with <code>what=</code> in <code>summary</code>. The &ldquo;unpooled&rdquo; or Bowker test as described in Hoenig <em>et al.</em> (1995) is constructed with <code>what="Bowker"</code>, the &ldquo;semi-pooled&rdquo; or Evans-Hoenig test as described in Evans and Hoenig (1998) is constructed with <code>what="EvansHoenig"</code>, and the &ldquo;pooled&rdquo; or McNemar test as described in Evans and Hoenig (1998) is constructed with <code>what="McNemar"</code>. All three tests are computed with <code>what="symmetry"</code>.
</p>
<p>The age bias plot introduced by Campana <em>et al.</em> (1995) can be constructed with <code><a href="#topic+plotAB">plotAB</a></code>. Muir <em>et al.</em> (2008) modified the original age bias plot by plotting the difference between the two ages on the y-axis (still against a reference age on the x-axis). McBride (2015) introduced the Bland-Altman plot for comparing fish ages where the difference in ages is plotted on the y-axis versus the mean of the ages on the x-axis. Modifications of these plots are created with <code>plot</code> (rather than <code><a href="#topic+plotAB">plotAB</a></code>) using <code>xvals=</code> to control what is plotted on the x-axis (i.e., <code>xvals="reference"</code> uses the reference ages, whereas <code>xvals="mean"</code> uses the mean of the two ages for the x-axis). In both plots, a horizontal agreement line at a difference of zero is shown for comparative purposes. In addition, a histogram of the differences is shown in the right margin (can be excluded with <code>yHist=FALSE</code>.) A histogram of the reference ages is shown by default in the top margin for the modified age bias plot, but not for the modified Bland-Altman-like plot (the presence of this histogram is controlled with <code>xHist=</code>).
</p>
<p>By default, the modified age bias plot shows the mean and range for the nonreference ages at each of the reference ages. Means shown with an open dot are mean age differences that are significantly different from zero. The ranges of differences in ages at each reference age can be removed with <code>show.range=FALSE</code>. A confidence interval for difference in ages can be added with <code>show.CI=FALSE</code>. Confidence intervals are only shown if the sample size is greater than the value in <code>min.n.CI=</code> (also from the original call to <code><a href="#topic+ageBias">ageBias</a></code>). Confidence intervals plotted in red with an open dot (by default; these can be changed with <code>col.CIsig</code> and <code>pch.mean.sig</code>, respectively) do not contain the reference age (see discussion of t-tests below). Individual points are plotted if <code>show.pts=TRUE</code>, where there color is controlled by <code>col.pts=</code> and <code>transparency=</code>. See examples for use of these arguments.
</p>
<p>The main (i.e., not the marginal histograms) can be &quot;added to&quot; after the plot is constructed if <code>allowAdd=TRUE</code> is used. For example, the Bland-Altman-like plot can be augmented with a horizontal line at the mean difference in ages, a line for the regression between the differences and the means, or a generalized additive model that describes the relationship between the differences and the means. See the examples for use of <code>allowAdd=TRUE</code>. It is recommended to save the plotting parameters (e.g., <code>op &lt;- par(no.readonly=TRUE)</code>) before using <code>plot</code> with <code>allowAdd=TRUE</code> so that the original parameters can be reset (e.g., <code>par(op)</code>); see the examples.
</p>
<p>Individual t-tests to determine if the mean age of the nonreference set at a particular age of the reference set is equal to the reference age (e.g., is the mean age of the nonreference set at age-3 of the reference set statistically different from 3?) are shown with <code>what="bias"</code> in <code>summary</code>. The results provide a column that indicates whether the difference is significant or not as determined by adjusted p-values from the t-tests and using the significance level provided in <code>sig.level</code> (defaults to 0.05). Similar results for the difference in ages (e.g., is the mean reference age minus nonreference age at a nonreference age of 3 different from 0?) are constructed with <code>what="diff.bias"</code> in <code>summary</code>.
</p>
<p>The sample size present in the age-agreement table is found with <code>what="n"</code>.
</p>


<h3>Value</h3>

<p><code>ageBias</code> returns a list with the following items:
</p>

<ul>
<li><p> data A data.frame with the original paired age estimates and the difference between those estimates.
</p>
</li>
<li><p> agree The age-agreement table.
</p>
</li>
<li><p> bias A data.frame that contains the bias statistics.
</p>
</li>
<li><p> bias.diff A data.frame that contains the bias statistics for the differences.
</p>
</li>
<li><p> ref.lab A string that contains an optional label for the age estimates in the columns (reference) of the age-agreement table.
</p>
</li>
<li><p> nref.lab A string that contains an optional label for the age estimates in the rows (non-reference) of the age-agreement table.
</p>
</li></ul>

<p><code>summary</code> returns the result if <code>what=</code> contains one item, otherwise it returns nothing. Nothing is returned by <code>plot</code> or <code>plotAB</code>, but see details for a description of the plot that is produced.
</p>


<h3>Testing</h3>

<p>Tested all symmetry test results against results in Evans and Hoenig (2008), the McNemar and Evans-Hoenig results against results from <code><a href="fishmethods.html#topic+compare2">compare2</a></code> in <span class="pkg">fishmethods</span>, and all results using the <code><a href="FSAdata.html#topic+AlewifeLH">AlewifeLH</a></code> data set from <span class="pkg">FSAdata</span> against results from the online resource at http://www.nefsc.noaa.gov/fbp/age-prec/.
</p>


<h3>IFAR Chapter</h3>

<p>4-Age Comparisons. <b>Note that <code>plot</code> has changed since IFAR was published. Some of the original functionality is in <code><a href="#topic+plotAB">plotAB</a></code>.</b>
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Campana, S.E., M.C. Annand, and J.I. McMillan. 1995. Graphical and statistical methods for determining the consistency of age determinations. Transactions of the American Fisheries Society 124:131-138. [Was (is?) available from http://www.bio.gc.ca/otoliths/documents/Campana%20et%20al%201995%20TAFS.pdf.]
</p>
<p>Evans, G.T. and J.M. Hoenig. 1998. Testing and viewing symmetry in contingency tables, with application to readers of fish ages. Biometrics 54:620-629.
</p>
<p>Hoenig, J.M., M.J. Morgan, and C.A. Brown. 1995. Analysing differences between two age determination methods by tests of symmetry. Canadian Journal of Fisheries and Aquatic Sciences 52:364-368.
</p>
<p>McBride, R.S. 2015. Diagnosis of paired age agreement: A simulation approach of accuracy and precision effects. ICES Journal of Marine Science 72:2149-2167.
</p>
<p>Muir, A.M., M.P. Ebener, J.X. He, and J.E. Johnson. 2008. A comparison of the scale and otolith methods of age estimation for lake whitefish in Lake Huron. North American Journal of Fisheries Management 28:625-635. [Was (is?) available from http://www.tandfonline.com/doi/abs/10.1577/M06-160.1]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+agePrecision">agePrecision</a></code> for measures of precision between pairs of age estimates. See <code><a href="fishmethods.html#topic+compare2">compare2</a></code> in <span class="pkg">fishmethods</span> for similar functionality. See <code><a href="#topic+plotAB">plotAB</a></code> for a more traditional age-bias plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ab1 &lt;- ageBias(scaleC~otolithC,data=WhitefishLC,
               ref.lab="Otolith Age",nref.lab="Scale Age")
summary(ab1)
summary(ab1,what="symmetry")
summary(ab1,what="Bowker")
summary(ab1,what="EvansHoenig")
summary(ab1,what="McNemar")
summary(ab1,what="McNemar",cont.corr="Yates")
summary(ab1,what="bias")
summary(ab1,what="diff.bias")
summary(ab1,what="n")
summary(ab1,what=c("n","symmetry","table"))
# flip table (easy to compare to age bias plot) and show zeroes (not dashes)
summary(ab1,what="table",flip.table=TRUE,zero.print="0")


#############################################################
## Differences Plot (inspired by Muir et al. (2008))
# Default (ranges, open circles for sig diffs, marginal hists)
plot(ab1)
# Show CIs for means (with and without ranges)
plot(ab1,show.CI=TRUE)
plot(ab1,show.CI=TRUE,show.range=FALSE)
# show points (with and without CIs)
plot(ab1,show.CI=TRUE,show.range=FALSE,show.pts=TRUE)
plot(ab1,show.range=FALSE,show.pts=TRUE)
# Use same symbols for all means (with ranges)
plot(ab1,pch.mean.sig=19)
# Use same symbols/colors for all means/CIs (without ranges)
plot(ab1,show.range=FALSE,show.CI=TRUE,pch.mean.sig=19,col.CIsig="black")
# Remove histograms
plot(ab1,xHist=FALSE)
plot(ab1,yHist=FALSE)
plot(ab1,xHist=FALSE,yHist=FALSE)
## Suppress confidence intervals for n &lt; a certain value
##   must set this in the original ageBias() call
ab2 &lt;- ageBias(scaleC~otolithC,data=WhitefishLC,min.n.CI=8,
               ref.lab="Otolith Age",nref.lab="Scale Age")
plot(ab2,show.CI=TRUE,show.range=FALSE)

 
#############################################################
## Differences Plot ( inspired by Bland-Altman plots in McBride (2015))
plot(ab1,xvals="mean")
## Modify axis limits
plot(ab1,xvals="mean",xlim=c(1,17))
## Add and remove histograms
plot(ab1,xvals="mean",xHist=TRUE)
plot(ab1,xvals="mean",xHist=TRUE,yHist=FALSE)
plot(ab1,xvals="mean",yHist=FALSE)

#############################################################
## Adding post hoc analyses to the main plot
# get original graphing parameters to be reset at the end
op &lt;- par(no.readonly=TRUE)

# get raw data
tmp &lt;- ab1$d
head(tmp)

# Add mean difference (w/ approx. 95% CI)
bias &lt;- mean(tmp$diff)+c(-1.96,0,1.96)*se(tmp$diff)
plot(ab1,xvals="mean",xlim=c(1,17),allowAdd=TRUE)
abline(h=bias,lty=2,col="red")
par(op)

# Same as above, but without marginal histogram, and with
#   95% agreement lines as well (1.96SDs)
#   (this is nearly a replicate of a Bland-Altman plot)
bias &lt;- mean(tmp$diff)+c(-1.96,0,1.96)*se(tmp$diff)
agline &lt;- mean(tmp$diff)+c(-1.96,1.96)*sd(tmp$diff)
plot(ab1,xvals="mean",yHist=FALSE,allowAdd=TRUE)
abline(h=bias,lty=2,col="red")
abline(h=agline,lty=3,lwd=2,col="blue")
par(op)

# Add linear regression line of differences on means (w/ approx. 95% CI)
lm1 &lt;- lm(diff~mean,data=tmp)
xval &lt;- seq(0,19,0.1)
pred1 &lt;- predict(lm1,data.frame(mean=xval),interval="confidence")
bias1 &lt;- data.frame(xval,pred1)
head(bias1)
plot(ab1,xvals="mean",xlim=c(1,17),allowAdd=TRUE)
lines(lwr~xval,data=bias1,lty=2,col="red")
lines(upr~xval,data=bias1,lty=2,col="red")
lines(fit~xval,data=bias1,lty=2,col="red")
par(op)

# Add loess of differences on means (w/ approx. 95% CI as a polygon)
lo2 &lt;- loess(diff~mean,data=tmp)
xval &lt;- seq(min(tmp$mean),max(tmp$mean),0.1)
pred2 &lt;- predict(lo2,data.frame(mean=xval),se=TRUE)
bias2 &lt;- data.frame(xval,pred2)
bias2$lwr &lt;- bias2$fit-1.96*bias2$se.fit
bias2$upr &lt;- bias2$fit+1.96*bias2$se.fit
head(bias2)
plot(ab1,xvals="mean",xlim=c(1,17),allowAdd=TRUE)
with(bias2,polygon(c(xval,rev(xval)),c(lwr,rev(upr)),
                   col=col2rgbt("red",1/10),border=NA))
lines(fit~xval,data=bias2,lty=2,col="red")
par(op)
                  
# Same as above, but polygon and line behind the points
plot(ab1,xvals="mean",xlim=c(1,17),col.pts="white",allowAdd=TRUE)
with(bias2,polygon(c(xval,rev(xval)),c(lwr,rev(upr)),
                   col=col2rgbt("red",1/10),border=NA))
lines(fit~xval,data=bias2,lty=2,col="red")
points(diff~mean,data=tmp,pch=19,col=col2rgbt("black",1/8))
par(op)

# Can also be made with the reference ages on the x-axis
lo3 &lt;- loess(diff~otolithC,data=tmp)
xval &lt;- seq(min(tmp$otolithC),max(tmp$otolithC),0.1)
pred3 &lt;- predict(lo3,data.frame(otolithC=xval),se=TRUE)
bias3 &lt;- data.frame(xval,pred3)
bias3$lwr &lt;- bias3$fit-1.96*bias3$se.fit
bias3$upr &lt;- bias3$fit+1.96*bias3$se.fit
plot(ab1,show.range=FALSE,show.pts=TRUE,col.pts="white",allowAdd=TRUE)
with(bias3,polygon(c(xval,rev(xval)),c(lwr,rev(upr)),
                   col=col2rgbt("red",1/10),border=NA))
lines(fit~xval,data=bias3,lty=2,col="red")
points(diff~otolithC,data=tmp,pch=19,col=col2rgbt("black",1/8))
par(op)

</code></pre>

<hr>
<h2 id='agePrecision'>Compute measures of precision among sets of ages.</h2><span id='topic+agePrecision'></span><span id='topic+plot.agePrec'></span><span id='topic+summary.agePrec'></span>

<h3>Description</h3>

<p>Computes overall measures of precision for multiple age estimates made on the same individuals. Ages may be from two or more readers of the same structure, one reader at two or more times, or two or more structures (e.g., scales, spines, otoliths). Measures of precision include ACV (Average Coefficient of Variation), APE (Average Percent Error), AAD (Average Absolute Deviation), and ASD (Average Standard Deviation), and various percentage difference values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agePrecision(formula, data)

## S3 method for class 'agePrec'
summary(
  object,
  what = c("precision", "difference", "absolute difference", "details"),
  percent = TRUE,
  trunc.diff = NULL,
  digits = 4,
  show.prec2 = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agePrecision_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>~var1+var2+var3+...</code> or, alternatively, <code>var1~var2+var3+...</code>, where the <code>varX</code> generically represent the variables that contain the age estimates. The alternative formula allows for similar code as used in <code><a href="#topic+ageBias">ageBias</a></code> and can have only one variable on the left-hand side.</p>
</td></tr>
<tr><td><code id="agePrecision_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="agePrecision_+3A_object">object</code></td>
<td>
<p>An object of class <code>agePrec</code>, usually from <code>agePrecision</code>.</p>
</td></tr>
<tr><td><code id="agePrecision_+3A_what">what</code></td>
<td>
<p>A string (or vector of strings) that indicates what type of summary to print. See details.</p>
</td></tr>
<tr><td><code id="agePrecision_+3A_percent">percent</code></td>
<td>
<p>A logical that indicates whether the difference table (see details) should be represented as percentages (<code>TRUE</code>; default) or frequency (<code>FALSE</code>) of fish.</p>
</td></tr>
<tr><td><code id="agePrecision_+3A_trunc.diff">trunc.diff</code></td>
<td>
<p>A single integer that identifies the age for which all values that age and greater are combined into one category. See the examples.</p>
</td></tr>
<tr><td><code id="agePrecision_+3A_digits">digits</code></td>
<td>
<p>A single numeric that indicates the minimum number of digits to print when using <code>summary</code>.</p>
</td></tr>
<tr><td><code id="agePrecision_+3A_show.prec2">show.prec2</code></td>
<td>
<p>A logical that indicates whether the precision metrics that use the median (i.e., ACV2 and APE2) should be shown when only two age estimates were made (in this instance they will be exactly equal to ACV and APE). Default is to not show these values in this situation.</p>
</td></tr>
<tr><td><code id="agePrecision_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>what="precision"</code> in <code>summary</code> then a summary table that contains the following items will be printed:
</p>

<ul>
<li><p> n Number of fish in <code>data</code>.
</p>
</li>
<li><p> validn Number of fish in <code>data</code> that have non-<code>NA</code> data for all R age estimates.
</p>
</li>
<li><p> R Number of age estimates given in <code>formula</code>.
</p>
</li>
<li><p> PercAgree The percentage of fish for which all age estimates perfectly agree.
</p>
</li>
<li><p> ASD The average (across all fish) standard deviation of ages within a fish.
</p>
</li>
<li><p> ACV The average (across all fish) coefficient of variation of ages within a fish using the <b>mean</b> as the divisor. See the <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">IFAR chapter</a> for calculation details.
</p>
</li>
<li><p> ACV2 The average (across all fish) coefficient of variation of ages within a fish using the <b>median</b> as the divisor. This will only be shown if R&gt;2 or <code>show.prec2=TRUE</code>.
</p>
</li>
<li><p> AAD The average (across all fish) absolute deviation of ages within a fish.
</p>
</li>
<li><p> APE The average (across all fish) percent error of ages within a fish using the <b>mean</b> as the divisor. See the <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">IFAR chapter</a> for calculation details.
</p>
</li>
<li><p> APE2 The average (across all fish) percent error of ages within a fish using the <b>median</b> as the divisor. This will only be shown if R&gt;2 or <code>show.prec2=TRUE</code>.
</p>
</li>
<li><p> AD The average (across all fish) index of precision (D).
</p>
</li></ul>

<p>Note that ACV2 and APE2 will not be printed when <code>what="precision"</code> if only two sets of ages are given (because mean=median such that ACV=ACV2 and APE=APE2).
If <code>what="difference"</code> is used in <code>summary</code>, then a table that describes either the percentage (if <code>percent=TRUE</code>, DEFAULT) or frequency of fish by the difference in paired age estimates. This table has one row for each possible pair of age estimates.
</p>
<p>If <code>what="absolute difference"</code> is used in <code>summary</code>, then a table that describes either the percentage (if <code>percent=TRUE</code>, DEFAULT) or frequency of fish by the absolute value of the difference in paired age estimates. This table has one row for each possible pair of age estimates. The &ldquo;1&rdquo; column, for example, represents age estimates that disagree by one year (in either direction).
</p>
<p>If <code>what="detail"</code> is used in <code>summary</code>, then a data.frame of the original <code>data</code> along with the intermediate calculations of the mean age, median age, modal age (will be <code>NA</code> if a mode does not exist (e.g., all different ages) or multiple modes exist), standard deviation of age (SD), coefficient of variation using the mean as the divisor (CV), coefficient of variation using the median as the divisor (CV2), absolute deviation using the mean as the divisor (AD), absolute deviation using the median as the divisor (AD2), average percent error (PE), and index of precision (D) for each individual will be printed.
</p>
<p>All percentage calculations above use the <code>validn</code> value in the denominator.
</p>


<h3>Value</h3>

<p>The main function returns a list with the following items:
</p>

<ul>
<li><p> detail A data.frame with all data given in <code>data</code> and intermediate calculations for each fish. See details
</p>
</li>
<li><p> rawdiff A frequency table of fish by differences for each pair of ages.
</p>
</li>
<li><p> absdiff A frequency table of fish by absolute differences for each pair of ages.
</p>
</li>
<li><p> AAD The average absolute deviation.
</p>
</li>
<li><p> APE The average percent error (using the <b>mean</b> age as the divisor).
</p>
</li>
<li><p> APE2 The average percent error (using the <b>median</b> age as the divisor).
</p>
</li>
<li><p> ASD The average standard deviation.
</p>
</li>
<li><p> ACV The average coefficient of variation (using the <b>mean</b> age as the divisor).
</p>
</li>
<li><p> ACV2 The average coefficient of variation (using the <b>median</b> age as the divisor).
</p>
</li>
<li><p> AD The average index of precision.
</p>
</li>
<li><p> R The number of readings for each individual fish.
</p>
</li>
<li><p> n Number of fish in <code>data</code>.
</p>
</li>
<li><p> validn Number of fish in <code>data</code> that have non-<code>NA</code> data for all R age estimates.
</p>
</li></ul>

<p>The <code>summary</code> returns the result if <code>what=</code> contains only one item, otherwise it returns nothing. See details for what is printed.
</p>


<h3>Testing</h3>

<p>Tested all precision results against published results in Herbst and Marsden (2011) for the <code><a href="#topic+WhitefishLC">WhitefishLC</a></code> data and the results for the <code><a href="FSAdata.html#topic+AlewifeLH">AlewifeLH</a></code> data set from <span class="pkg">FSAdata</span> against results from the online resource at http://www.nefsc.noaa.gov/fbp/age-prec/.
</p>


<h3>IFAR Chapter</h3>

<p>4-Age Comparisons.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Beamish, R.J. and D.A. Fournier. 1981. A method for comparing the precision of a set of age determinations. Canadian Journal of Fisheries and Aquatic Sciences 38:982-983. [Was (is?) available from http://www.pac.dfo-mpo.gc.ca/science/people-gens/beamish/PDF_files/compareagecjfas1981.pdf.]
</p>
<p>Campana, S.E. 1982. Accuracy, precision and quality control in age determination, including a review of the use and abuse of age validation methods. Journal of Fish Biology 59:197-242. [Was (is?) available from http://www.denix.osd.mil/nr/crid/Coral_Reef_Iniative_Database/References_for_Reef_Assessment_files/Campana,%202001.pdf.]
</p>
<p>Campana, S.E., M.C. Annand, and J.I. McMillan. 1995. Graphical and statistical methods for determining the consistency of age determinations. Transactions of the American Fisheries Society 124:131-138. [Was (is?) available from http://www.bio.gc.ca/otoliths/documents/Campana%20et%20al%201995%20TAFS.pdf.]
</p>
<p>Chang, W.Y.B. 1982. A statistical method for evaluating the reproducibility of age determination. Canadian Journal of Fisheries and Aquatic Sciences 39:1208-1210. [Was (is?) available from http://www.nrcresearchpress.com/doi/abs/10.1139/f82-158.]
</p>
<p>McBride, R.S. 2015. Diagnosis of paired age agreement: A simulation approach of accuracy and precision effects. ICES Journal of Marine Science, 72:2149-2167.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ageBias">ageBias</a></code> for computation of the full age agreement table, along with tests and plots of age bias.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example with just two age estimates
ap1 &lt;- agePrecision(~otolithC+scaleC,data=WhitefishLC)
summary(ap1)
summary(ap1,what="precision")
summary(ap1,what="difference")
summary(ap1,what="difference",percent=FALSE)
summary(ap1,what="absolute")
summary(ap1,what="absolute",percent=FALSE)
summary(ap1,what="absolute",trunc.diff=4)
summary(ap1,what=c("precision","difference"))
summary(ap1,what="detail")

barplot(ap1$rawdiff,ylab="Frequency",xlab="Otolith - Scale Age")
plot(AD~mean,data=ap1$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Mean Age",ylab="Absolute Deviation Age")
plot(SD~mean,data=ap1$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Mean Age",ylab="Standard deviation Age")
plot(SD~AD,data=ap1$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Absolute Deviation Age",ylab="Standard deviation Age")
plot(CV~PE,data=ap1$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Percent Error Age",ylab="Coefficient of Variation Age")

## Example with three age estimates
ap2 &lt;- agePrecision(~otolithC+finrayC+scaleC,data=WhitefishLC)
summary(ap2,digits=3)
summary(ap2,what="precision")
summary(ap2,what="difference")
summary(ap2,what="absolute",percent=FALSE,trunc.diff=4)
summary(ap2,what="detail",digits=3)

plot(AD~mean,data=ap2$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Mean Age",ylab="Absolute Deviation Age")
plot(SD~mean,data=ap2$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Mean Age",ylab="Standard Deviation Age")
plot(SD~AD,data=ap2$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Absolute Deviation Age",ylab="Standard Deviation Age")
plot(CV~PE,data=ap2$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Percent Error Age",ylab="Coefficient of Variation Age")
plot(median~mean,data=ap2$detail,pch=19,col=col2rgbt("black",1/5),
     xlab="Mean Age",ylab="Median Age")

</code></pre>

<hr>
<h2 id='alkAgeDist'>Proportions-at-age from an age-length key</h2><span id='topic+alkAgeDist'></span>

<h3>Description</h3>

<p>Computes the proportions-at-age (with standard errors) in a larger sample based on an age-length-key created from a subsample of ages through a two-stage random sampling design. Follows the methods in Quinn and Deriso (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alkAgeDist(key, lenA.n, len.n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alkAgeDist_+3A_key">key</code></td>
<td>
<p>A numeric matrix that contains the age-length key. See details.</p>
</td></tr>
<tr><td><code id="alkAgeDist_+3A_lena.n">lenA.n</code></td>
<td>
<p>A numeric vector of sample sizes for each length interval in the <em>aged sample</em>.</p>
</td></tr>
<tr><td><code id="alkAgeDist_+3A_len.n">len.n</code></td>
<td>
<p>A numeric vector of sample sizes for each length interval in the <em>complete sample</em> (i.e., all fish regardless of whether they were aged or not).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The age-length key in <code>key</code> must have length intervals as rows and ages as columns. The row names of <code>key</code> (i.e., <code>rownames(key)</code>) must contain the minimum values of each length interval (e.g., if an interval is 100-109 then the corresponding row name must be 100). The column names of <code>key</code> (i.e., <code>colnames(key)</code>) must contain the age values (e.g., the columns can NOT be named with &ldquo;age.1&rdquo;, for example).
</p>
<p>The length intervals in the rows of <code>key</code> must contain all of the length intervals present in the larger sample. Thus, the length of <code>len.n</code> must, at least, equal the number of rows in <code>key</code>. If this constraint is not met, then the function will stop with an error message.
</p>
<p>The values in <code>lenA.n</code> are equal to what the row sums of <code>key</code> would have been before <code>key</code> was converted to a row proportions table. Thus, the length of <code>lenA.n</code> must also be equal to the number of rows in <code>key</code>. If this constraint is not met, then the function will stop with an error message.
</p>


<h3>Value</h3>

<p>A data.frame with as many rows as ages (columns) present in <code>key</code> and the following three variables:
</p>

<ul>
<li><p> age The ages.
</p>
</li>
<li><p> prop The proportion of fish at each age.
</p>
</li>
<li><p> se The SE for the proportion of fish at each age.
</p>
</li></ul>



<h3>Testing</h3>

<p>The results from this function perfectly match the results in Table 8.4 (left) of Quinn and Deriso (1999) using <code><a href="FSAdata.html#topic+SnapperHG2">SnapperHG2</a></code> from <span class="pkg">FSAdata</span>. The results also perfectly match the results from using <code><a href="fishmethods.html#topic+alkprop">alkprop</a></code> in <span class="pkg">fishmethods</span>.
</p>


<h3>IFAR Chapter</h3>

<p>5-Age-Length Key.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Lai, H.-L. 1987. Optimum allocation for estimating age composition using age-length key. Fishery Bulletin, 85:179-185.
</p>
<p>Lai, H.-L. 1993. Optimum sampling design for using the age-length key to estimate age composition of a fish population. Fishery Bulletin, 92:382-388.
</p>
<p>Quinn, T. J. and R. B. Deriso. 1999. Quantitative Fish Dynamics. Oxford University Press, New York, New York. 542 pages.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+alkIndivAge">alkIndivAge</a></code> and related functions for a completely different methodology. See <code><a href="fishmethods.html#topic+alkprop">alkprop</a></code> from <span class="pkg">fishmethods</span> for the exact same methodology but with a different format for the inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example -- Even breaks for length categories
WR1 &lt;- WR79
# add length intervals (width=5)
WR1$LCat &lt;- lencat(WR1$len,w=5)
# get number of fish in each length interval in the entire sample
len.n &lt;- xtabs(~LCat,data=WR1)
# isolate aged sample and get number in each length interval
WR1.age &lt;- subset(WR1, !is.na(age))
lenA.n &lt;- xtabs(~LCat,data=WR1.age)
# create age-length key
raw &lt;- xtabs(~LCat+age,data=WR1.age)
( WR1.key &lt;- prop.table(raw, margin=1) )

# use age-length key to estimate age distribution of all fish
alkAgeDist(WR1.key,lenA.n,len.n)

</code></pre>

<hr>
<h2 id='alkIndivAge'>Use an age-length key to assign age to individuals in the unaged sample.</h2><span id='topic+alkIndivAge'></span>

<h3>Description</h3>

<p>Use either the semi- or completely-random methods from Isermann and Knight (2005) to assign ages to individual fish in the unaged sample according to the information in an age-length key supplied by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alkIndivAge(
  key,
  formula,
  data,
  type = c("SR", "CR"),
  breaks = NULL,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alkIndivAge_+3A_key">key</code></td>
<td>
<p>A numeric matrix that contains the age-length key. The format of this matrix is important. See details.</p>
</td></tr>
<tr><td><code id="alkIndivAge_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>age~length</code> where <code>age</code> generically represents the variable that will contain the estimated ages once the key is applied (i.e., should currently contain no values) and <code>length</code> generically represents the variable that contains the known length measurements. If only <code>~length</code> is used, then a new variable called &ldquo;age&rdquo; will be created in the resulting data frame.</p>
</td></tr>
<tr><td><code id="alkIndivAge_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains the length measurements and possibly contains a variable that will receive the age assignments as given in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="alkIndivAge_+3A_type">type</code></td>
<td>
<p>A string that indicates whether to use the semi-random (<code>type="SR"</code>, default) or completely-random (<code>type="CR"</code>) methods for assigning ages to individual fish. See the <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">IFAR chapter</a> for more details.</p>
</td></tr>
<tr><td><code id="alkIndivAge_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of lower values that define the length intervals. See details.</p>
</td></tr>
<tr><td><code id="alkIndivAge_+3A_seed">seed</code></td>
<td>
<p>A single numeric that is given to <code>set.seed</code> to set the random seed. This allows repeatability of results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The age-length key in <code>key</code> must have length intervals as rows and ages as columns. The row names of <code>key</code> (i.e., <code>rownames(key)</code>) must contain the minimum values of each length interval (e.g., if an interval is 100-109, then the corresponding row name must be 100). The column names of <code>key</code> (i.e., <code>colnames(key)</code>) must contain the age values (e.g., the columns can NOT be named with &ldquo;age.1&rdquo;, for example).
</p>
<p>The length intervals in the rows of <code>key</code> must contain all of the length intervals present in the unaged sample to which the age-length key is to be applied (i.e., sent in the <code>length</code> portion of the <code>formula</code>). If this constraint is not met, then the function will stop with an error message.
</p>
<p>If <code>breaks=NULL</code>, then the length intervals for the unaged sample will be determined with a starting interval at the minimum value of the row names in <code>key</code> and a width of the length intervals as determined by the minimum difference in adjacent row names of <code>key</code>. If length intervals of differing widths were used when constructing <code>key</code>, then those breaks should be supplied to <code>breaks=</code>. Use of <code>breaks=</code> may be useful when &ldquo;uneven&rdquo; length interval widths were used because the lengths in the unaged sample are not fully represented in the aged sample. See the examples.
</p>
<p>Assigned ages will be stored in the column identified on the left-hand-side of <code>formula</code> (if the formula has both a left- and right-hand-side). If this variable is missing in <code>formula</code>, then the new column will be labeled with <code>age</code>.
</p>


<h3>Value</h3>

<p>The original data.frame in <code>data</code> with assigned ages added to the column supplied in <code>formula</code> or in an additional column labeled as <code>age</code>. See details.
</p>


<h3>Testing</h3>

<p>The <code>type="SR"</code> method worked perfectly on a small example. The <code>type="SR"</code> method provides results that reasonably approximate the results from <code><a href="#topic+alkAgeDist">alkAgeDist</a></code> and <code><a href="#topic+alkMeanVar">alkMeanVar</a></code>, which suggests that the age assessments are reasonable.
</p>


<h3>IFAR Chapter</h3>

<p>5-Age-Length Key.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>. This is largely an R version of the SAS code provided by Isermann and Knight (2005).
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Isermann, D.A. and C.T. Knight. 2005. A computer program for age-length keys incorporating age assignment to individual fish. North American Journal of Fisheries Management, 25:1153-1160. [Was (is?) from http://www.tandfonline.com/doi/abs/10.1577/M04-130.1.]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+alkAgeDist">alkAgeDist</a></code> and <code><a href="#topic+alkMeanVar">alkMeanVar</a></code> for alternative methods to derived age distributions and mean (and SD) values for each age. See <code><a href="#topic+alkPlot">alkPlot</a></code> for methods to visualize age-length keys.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First Example -- Even breaks for length categories
WR1 &lt;- WR79
# add length categories (width=5)
WR1$LCat &lt;- lencat(WR1$len,w=5)
# isolate aged and unaged samples
WR1.age &lt;- subset(WR1, !is.na(age))
WR1.len &lt;- subset(WR1, is.na(age))
# note no ages in unaged sample
head(WR1.len)
# create age-length key
raw &lt;- xtabs(~LCat+age,data=WR1.age)
( WR1.key &lt;- prop.table(raw, margin=1) )
# apply the age-length key
WR1.len &lt;- alkIndivAge(WR1.key,age~len,data=WR1.len)
# now there are ages
head(WR1.len)
# combine orig age &amp; new ages
WR1.comb &lt;- rbind(WR1.age, WR1.len)
# mean length-at-age
Summarize(len~age,data=WR1.comb,digits=2)
# age frequency distribution
( af &lt;- xtabs(~age,data=WR1.comb) )
# proportional age distribution
( ap &lt;- prop.table(af) )

## Second Example -- length sample does not have an age variable
WR2 &lt;- WR79
# isolate age and unaged samples
WR2.age &lt;- subset(WR2, !is.na(age))
WR2.len &lt;- subset(WR2, is.na(age))
# remove age variable (for demo only)
WR2.len &lt;- WR2.len[,-3]
# add length categories to aged sample
WR2.age$LCat &lt;- lencat(WR2.age$len,w=5)
# create age-length key
raw &lt;- xtabs(~LCat+age,data=WR2.age)
( WR2.key &lt;- prop.table(raw, margin=1) )
# apply the age-length key
WR2.len &lt;- alkIndivAge(WR2.key,~len,data=WR2.len)
# add length cat to length sample
WR2.len$LCat &lt;- lencat(WR2.len$len,w=5)
head(WR2.len)
# combine orig age &amp; new ages
WR2.comb &lt;- rbind(WR2.age, WR2.len)
Summarize(len~age,data=WR2.comb,digits=2)

## Third Example -- Uneven breaks for length categories
WR3 &lt;- WR79
# set up uneven breaks
brks &lt;- c(seq(35,100,5),110,130)
WR3$LCat &lt;- lencat(WR3$len,breaks=brks)
WR3.age &lt;- subset(WR3, !is.na(age))
WR3.len &lt;- subset(WR3, is.na(age))
head(WR3.len)
raw &lt;- xtabs(~LCat+age,data=WR3.age)
( WR3.key &lt;- prop.table(raw, margin=1) )
WR3.len &lt;- alkIndivAge(WR3.key,age~len,data=WR3.len,breaks=brks)
head(WR3.len)
WR3.comb &lt;- rbind(WR3.age, WR3.len)
Summarize(len~age,data=WR3.comb,digits=2)

</code></pre>

<hr>
<h2 id='alkMeanVar'>Mean Values-at-age from an age-length key</h2><span id='topic+alkMeanVar'></span>

<h3>Description</h3>

<p>Computes the mean value-at-age in a larger sample based on an age-length-key created from a subsample of ages through a two-stage random sampling design. The mean values could be mean length-, weight-, or fecundity-at-age, for example. The methods of Bettoli and Miranda (2001) or Quinn and Deriso (1999) are used. A standard deviation is computed for the Bettoli and Miranda (2001) method and standard error for the Quinn and Deriso (1999) method. See the testing section notes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alkMeanVar(
  key,
  formula,
  data,
  len.n,
  method = c("BettoliMiranda", "QuinnDeriso")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alkMeanVar_+3A_key">key</code></td>
<td>
<p>A numeric matrix that contains the age-length key. See details.</p>
</td></tr>
<tr><td><code id="alkMeanVar_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>var~lencat+age</code> where <code>var</code> generically represents the variable to be summarized (e.g., length, weight, fecundity), <code>lencat</code> generically represents the variable that contains the length intervals, and <code>age</code> generically represents the variable that contains the assigned ages.</p>
</td></tr>
<tr><td><code id="alkMeanVar_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains the length intervals, assessed ages, and the variable to be summarized (i.e., this should be the aged sample) as given in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="alkMeanVar_+3A_len.n">len.n</code></td>
<td>
<p>A vector of sample sizes for each length interval in the <em>complete sample</em> (i.e., all fish regardless of whether they were aged or not).</p>
</td></tr>
<tr><td><code id="alkMeanVar_+3A_method">method</code></td>
<td>
<p>A string that indicates which method of calculation should be used. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The age-length key <code>key</code> must have length intervals as rows and ages as columns. The row names of <code>key</code> (i.e., <code>rownames(key)</code>) must contain the minimum values of each length interval (e.g., if an interval is 100-109, then the corresponding row name must be 100). The column names of <code>key</code> (i.e., <code>colnames(key)</code>) must contain the age values (e.g., the columns can NOT be named with &ldquo;age.1&rdquo;, for example).
</p>
<p>The length intervals in the rows of <code>key</code> must contain all of the length intervals present in the larger sample. Thus, the length of <code>len.n</code> must, at least, equal the number of rows in <code>key</code>. If this constraint is not met, then the function will stop with an error message.
</p>
<p>Note that the function will stop with an error if the formula in <code>formula</code> does not meet the specific criteria outlined in the parameter list above.
</p>


<h3>Value</h3>

<p>A data.frame with as many rows as ages (columns) present in <code>key</code> and the following three variables:
</p>

<ul>
<li><p> age The ages.
</p>
</li>
<li><p> mean The mean value at each age.
</p>
</li>
<li><p> sd,se The SD if <code>method="BettoliMiranda"</code> or SE of the mean if <code>method="QuinnDeriso"</code> for the value at each age.
</p>
</li></ul>



<h3>Testing</h3>

<p>The results of these functions have not yet been rigorously tested. The Bettoli and Miranda (2001) results appear, at least, approximately correct when compared to the results from <code><a href="#topic+alkIndivAge">alkIndivAge</a></code>. The Quinn and Deriso (1999) results appear at least approximately correct for the mean values, but do not appear to be correct for the SE values. Thus, a note is returned with the Quinn and Deriso (1999) results that the SE should not be trusted.
</p>


<h3>IFAR Chapter</h3>

<p>5-Age-Length Key.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Bettoli, P. W. and Miranda, L. E. 2001. A cautionary note about estimating mean length at age with subsampled data. North American Journal of Fisheries Management, 21:425-428.
</p>
<p>Quinn, T. J. and R. B. Deriso. 1999. Quantitative Fish Dynamics. Oxford University Press, New York, New York. 542 pages
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+alkIndivAge">alkIndivAge</a></code> and related functions for a completely different methodology. See <code><a href="#topic+alkAgeDist">alkAgeDist</a></code> for a related method of determining the proportion of fish at each age. See the <span class="pkg">ALKr</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example -- Even breaks for length categories
WR1 &lt;- WR79
# add length intervals (width=5)
WR1$LCat &lt;- lencat(WR1$len,w=5)
# get number of fish in each length interval in the entire sample
len.n &lt;- xtabs(~LCat,data=WR1)
# isolate aged sample
WR1.age &lt;- subset(WR1, !is.na(age))
# create age-length key
raw &lt;- xtabs(~LCat+age,data=WR1.age)
( WR1.key &lt;- prop.table(raw, margin=1) )

## use age-length key to estimate mean length-at-age of all fish
# Bettoli-Miranda method
alkMeanVar(WR1.key,len~LCat+age,WR1.age,len.n)

# Quinn-Deriso method
alkMeanVar(WR1.key,len~LCat+age,WR1.age,len.n,method="QuinnDeriso")

</code></pre>

<hr>
<h2 id='alkPlot'>Plots to visualize age-length keys.</h2><span id='topic+alkPlot'></span>

<h3>Description</h3>

<p>Various plots to visualize the proportion of fish of certain ages within length intervals in an age-length key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alkPlot(
  key,
  type = c("barplot", "area", "lines", "splines", "bubble"),
  xlab = "Length",
  ylab = ifelse(type != "bubble", "Proportion", "Age"),
  xlim = NULL,
  ylim = NULL,
  showLegend = FALSE,
  lbl.cex = 1.25,
  leg.cex = 1,
  lwd = 2,
  span = 0.25,
  grid = TRUE,
  col = NULL,
  buf = 0.45,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alkPlot_+3A_key">key</code></td>
<td>
<p>A numeric matrix that contains the age-length key.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_type">type</code></td>
<td>
<p>A string that indicates the type of plot to construct. See details.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_xlab">xlab</code>, <code id="alkPlot_+3A_ylab">ylab</code></td>
<td>
<p>A string that contains the label for the x- or y-axis.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_xlim">xlim</code>, <code id="alkPlot_+3A_ylim">ylim</code></td>
<td>
<p>A numeric of length 2 that provide the limits for the x-axis or y-axis.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_showlegend">showLegend</code></td>
<td>
<p>A logical that indicates whether a legend should be displayed (not implemented for <code>type="bubble"</code>). See examples.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_lbl.cex">lbl.cex</code></td>
<td>
<p>A numeric character expansion value for labels inside the bars when <code>type="barplot"</code> or on the lines when <code>type="lines"</code> or <code>type="splines"</code>. Only used if <code>showLegend=FALSE</code>.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_leg.cex">leg.cex</code></td>
<td>
<p>A numeric character expansion value for labels on the legend when <code>showLegend=TRUE</code>.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_lwd">lwd</code></td>
<td>
<p>A numeric that indicates the line width when <code>type="lines"</code> or <code>type="splines"</code>.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_span">span</code></td>
<td>
<p>A numeric that indicates the span value to use in <code>loess</code> when <code>type="splines"</code>.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_grid">grid</code></td>
<td>
<p>A logical that indicates whether a grid should be placed under the bubbles when <code>type="bubble"</code> or a character or appropriate vector that identifies a color for the grid. See examples.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_col">col</code></td>
<td>
<p>A single character string that is a palette from <code><a href="grDevices.html#topic+hcl.pals">hcl.pals</a></code> or a vector of character strings containing colors for the bars, areas, lines, or spline lines of different ages; defaults to the &quot;viridis&quot; palette in <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code>. A single string that indicates the color of the bubbles when <code>type="bubble"</code>.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_buf">buf</code></td>
<td>
<p>A single numeric that indicates the relative width of the bubbles when <code>type="bubble"</code>. A value of 0.5 means that two full-width bubbles would touch each other either in the x- or y-direction (i.e., this would represent half of the minimum of the physical distance between values one-unit apart on the x- and y-axes). Set this to a value less than 0.5 so that the bubbles will not touch (the default is 0.45).</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_add">add</code></td>
<td>
<p>A logical that indicates whether the data should be added to an already existing plot. May be useful for visually comparing age-length keys. Only implemented when <code>type="bubble"</code>.</p>
</td></tr>
<tr><td><code id="alkPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plot</code> or <code>barplot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A variety of plots can be used to visualize the proportion of fish of certain ages within length intervals of an age-length key. The types of plots are described below and illustrated in the examples.
</p>

<ul>
<li><p> A &ldquo;stacked&rdquo; bar chart where vertical bars over length intervals sum to 1 but are segmented by the proportion of each age in that length interval is constructed with <code>type="barplot"</code>. The ages will be labeled in the bar segments unless <code>showLegend=TRUE</code> is used.
</p>
</li>
<li><p> A &ldquo;stacked&rdquo; area chart similar to the bar chart described above is constructed with <code>type="area"</code>.
</p>
</li>
<li><p> A plot with (differently colored) lines that connect the proportions of ages within each length interval is constructed with <code>type="lines"</code>.
</p>
</li>
<li><p> A plot with (differently colored) lines, as estimated by loess splines, that connect the proportions of ages within each length interval is constructed with <code>type="splines"</code>.
</p>
</li>
<li><p> A &ldquo;bubble&rdquo; plot where circles whose size is proportional to the proportion of fish of each age in each length interval is constructed with <code>type="bubble"</code>. The color of the bubbles can be controlled with <code>col=</code> and an underlying grid for ease of seeing the age and length interval for each bubble can be controlled with <code>grid=</code>. Bubbles from a second age-length key can be overlaid on an already constructed bubble plot by using <code>add=TRUE</code> in a second call to <code>alkPlot</code>.
</p>
</li></ul>

<p>Note that all plots are &ldquo;vertically conditional&rdquo; &ndash; i.e., each represents the proportional ages WITHIN each length interval.
</p>


<h3>Value</h3>

<p>None, but a plot is constructed.
</p>


<h3>IFAR Chapter</h3>

<p>5-Age-Length Key.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+alkIndivAge">alkIndivAge</a></code> for using an age-length key to assign ages to individual fish. See <code><a href="grDevices.html#topic+hcl.colors">hcl.colors</a></code> for a simple way to choose other colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Make an example age-length key
WR.age &lt;- droplevels(subset(WR79, !is.na(age)))
WR.age$LCat &lt;- lencat(WR.age$len,w=5)
raw &lt;- xtabs(~LCat+age,data=WR.age)
WR.key &lt;- prop.table(raw, margin=1)
round(WR.key,3)

## Various visualizations of the age-length key
alkPlot(WR.key,"barplot")
alkPlot(WR.key,"barplot",col="Cork")
alkPlot(WR.key,"barplot",col=heat.colors(8))
alkPlot(WR.key,"barplot",showLegend=TRUE)
alkPlot(WR.key,"area")
alkPlot(WR.key,"lines")
alkPlot(WR.key,"splines")
alkPlot(WR.key,"splines",span=0.2)
alkPlot(WR.key,"bubble")
alkPlot(WR.key,"bubble",col=col2rgbt("black",0.5))

</code></pre>

<hr>
<h2 id='binCI'>Confidence intervals for binomial probability of success.</h2><span id='topic+binCI'></span>

<h3>Description</h3>

<p>Uses one of three methods to compute a confidence interval for the probability of success (p) in a binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binCI(
  x,
  n,
  conf.level = 0.95,
  type = c("wilson", "exact", "asymptotic"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binCI_+3A_x">x</code></td>
<td>
<p>A single or vector of numbers that contains the number of observed successes.</p>
</td></tr>
<tr><td><code id="binCI_+3A_n">n</code></td>
<td>
<p>A single or vector of numbers that contains the sample size.</p>
</td></tr>
<tr><td><code id="binCI_+3A_conf.level">conf.level</code></td>
<td>
<p>A single number that indicates the level of confidence (default is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="binCI_+3A_type">type</code></td>
<td>
<p>A string that identifies the type of method to use for the calculations. See details.</p>
</td></tr>
<tr><td><code id="binCI_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates whether <code>x</code>, <code>n</code>, and <code>x/n</code> should be included in the returned matrix (<code>=TRUE</code>) or not (<code>=FALSE</code>; DEFAULT).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will compute confidence interval for three possible methods chosen with the <code>type</code> argument.
</p>

<table>
<tr>
 <td style="text-align: left;">
 <code>type="wilson"</code> </td><td style="text-align: left;"> Wilson's (Journal of the American Statistical Association, 1927) confidence interval for a proportion. This is the score CI, based on inverting the asymptotic normal test using the null standard error. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>type="exact"</code> </td><td style="text-align: left;"> Computes the Clopper/Pearson exact CI for a binomial success probability. </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>type="asymptotic"</code> </td><td style="text-align: left;"> This uses the normal distribution approximation. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that Agresti and Coull (2000) suggest that the Wilson interval is the preferred method and is, thus, the default <code>type</code>.
</p>


<h3>Value</h3>

<p>A #x2 matrix that contains the lower and upper confidence interval bounds as columns and, if <code>verbose=TRUE</code> <code>x</code>, <code>n</code>, and <code>x/n</code> .
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>, though this is largely based on <code>binom.exact</code>, <code>binom.wilson</code>, and <code>binom.approx</code> from the old epitools package.
</p>


<h3>References</h3>

<p>Agresti, A. and B.A. Coull. 1998. Approximate is better than &ldquo;exact&rdquo; for interval estimation of binomial proportions. American Statistician, 52:119-126.
</p>


<h3>See Also</h3>

<p>See <code><a href="stats.html#topic+binom.test">binom.test</a></code>; <code>binconf</code> in <span class="pkg">Hmisc</span>; and functions in <span class="pkg">binom</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## All types at once
binCI(7,20)

## Individual types
binCI(7,20,type="wilson")
binCI(7,20,type="exact")
binCI(7,20,type="asymptotic")
binCI(7,20,type="asymptotic",verbose=TRUE)

## Multiple types
binCI(7,20,type=c("exact","asymptotic"))
binCI(7,20,type=c("exact","asymptotic"),verbose=TRUE)

## Use with multiple inputs
binCI(c(7,10),c(20,30),type="wilson")
binCI(c(7,10),c(20,30),type="wilson",verbose=TRUE)

</code></pre>

<hr>
<h2 id='BluegillJL'>Capture histories (2 samples) of Bluegill from Jewett Lake, MI.</h2><span id='topic+BluegillJL'></span>

<h3>Description</h3>

<p>Each line consists of the capture history over two samples of Bluegill (<em>Lepomis macrochirus</em>) in Jewett Lake (MI). This file contains the capture histories for only Bluegill larger than 6-in.
</p>


<h3>Format</h3>

<p>A data frame with 277 observations on the following 2 variables.
</p>

<dl>
<dt>first</dt><dd><p>a numeric vector of indicator variables for the first sample (1=captured)</p>
</dd>
<dt>second</dt><dd><p>a numeric vector of indicator variables for the second sample (1=captured)</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Population Size
</p>
</li>
<li><p> Abundance
</p>
</li>
<li><p> Mark-Recapture
</p>
</li>
<li><p> Capture-Recapture
</p>
</li>
<li><p> Petersen
</p>
</li>
<li><p> Capture History
</p>
</li></ul>



<h3>Source</h3>

<p>From example 8.1 in Schneider, J.C. 1998. Lake fish population estimates by mark-and-recapture methods. Chapter 8 in Schneider, J.C. (ed.) 2000. Manual of fisheries survey methods II: with periodic updates. Michigan Department of Natural Resources, Fisheries Special Report 25, Ann Arbor. [Was (is?) from http://www.michigandnr.com/publications/pdfs/IFR/manual/SMII%20Chapter08.pdf.] <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/BluegillJL.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+mrClosed">mrClosed</a></code> examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(BluegillJL)
head(BluegillJL)

</code></pre>

<hr>
<h2 id='BrookTroutTH'>Catch-at-age for Tobin Harbor, Isle Royale Brook Trout.</h2><span id='topic+BrookTroutTH'></span>

<h3>Description</h3>

<p>Catch-at-age in fyke nets from 1996-1998 for &ldquo;Coaster&rdquo; Brook Trout (<em>Salvelinus fontinalis</em>) in Tobin Harbor, Isle Royale, Lake Superior.
</p>


<h3>Format</h3>

<p>A data frame with 7 observations on the following 2 variables.
</p>

<dl>
<dt>age</dt><dd><p>A numeric vector of assigned ages</p>
</dd>
<dt>catch</dt><dd><p>A numeric vector of number of Brook Trout caught</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Mortality
</p>
</li>
<li><p> Catch Curve
</p>
</li>
<li><p> Chapman-Robson 
</p>
</li></ul>



<h3>Source</h3>

<p>Quinlan, H.R. 1999. Biological Characteristics of Coaster Brook Trout at Isle Royale National Park, Michigan, 1996-98. U.S. Fish and Wildlife Service Ashland Fishery Resources Office report. November 1999. <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/BrookTroutTH.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+catchCurve">catchCurve</a></code> and <code><a href="#topic+chapmanRobson">chapmanRobson</a></code> examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(BrookTroutTH)
head(BrookTroutTH)
plot(log(catch)~age,data=BrookTroutTH)

</code></pre>

<hr>
<h2 id='capFirst'>Capitalizes the first letter of first or all words in a string.</h2><span id='topic+capFirst'></span>

<h3>Description</h3>

<p>Capitalizes the first letter of first or all words in a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capFirst(x, which = c("all", "first"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capFirst_+3A_x">x</code></td>
<td>
<p>A single string.</p>
</td></tr>
<tr><td><code id="capFirst_+3A_which">which</code></td>
<td>
<p>A single string that indicates whether all (the default) or only the first words should be capitalized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single string with the first letter of the first or all words capitalized.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Capitalize first letter of all words (the default)
capFirst("Derek Ogle")
capFirst("derek ogle")
capFirst("derek")

## Capitalize first letter of only the first words
capFirst("Derek Ogle",which="first")
capFirst("derek ogle",which="first")
capFirst("derek",which="first")
## apply to all elements in a vector
vec &lt;- c("Derek Ogle","derek ogle","Derek ogle","derek Ogle","DEREK OGLE")
capFirst(vec)
capFirst(vec,which="first")

## check class types
class(vec)
vec1 &lt;- capFirst(vec)
class(vec1)
fvec &lt;- factor(vec)
fvec1 &lt;- capFirst(fvec)
class(fvec1)

</code></pre>

<hr>
<h2 id='capHistConvert'>Convert between capture history data.frame formats.</h2><span id='topic+capHistConvert'></span>

<h3>Description</h3>

<p>Use to convert between simple versions of several capture history data.frame formats &ndash; &ldquo;individual&rdquo;, &ldquo;frequency&rdquo;, &ldquo;event&rdquo;, &ldquo;MARK&rdquo;, and &ldquo;RMark&rdquo;. The primary use is to convert to the &ldquo;individual&rdquo; format for use in <code><a href="#topic+capHistSum">capHistSum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capHistConvert(
  df,
  cols2use = NULL,
  cols2ignore = NULL,
  in.type = c("frequency", "event", "individual", "MARK", "marked", "RMark"),
  out.type = c("individual", "event", "frequency", "MARK", "marked", "RMark"),
  id = NULL,
  event.ord = NULL,
  freq = NULL,
  var.lbls = NULL,
  var.lbls.pre = "event",
  include.id = ifelse(is.null(id), FALSE, TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capHistConvert_+3A_df">df</code></td>
<td>
<p>A data.frame that contains the capture histories and, perhaps, a unique fish identifier or frequency variable. See details.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_cols2use">cols2use</code></td>
<td>
<p>A string or numeric vector that indicates columns in <code>df</code> to use. Negative numeric values will not use those columns. Cannot use both <code>cols2use</code> and <code>col2ignore</code>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_cols2ignore">cols2ignore</code></td>
<td>
<p>A string or numeric vector that indicates columns in <code>df</code> to ignore. Typical columns to ignore are those that are not either in <code>id=</code> or <code>freq=</code> or part of the capture history data. Cannot use both <code>cols2use</code> and <code>col2ignore</code>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_in.type">in.type</code></td>
<td>
<p>A single string that indicates the type of capture history format to convert <b>FROM</b>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_out.type">out.type</code></td>
<td>
<p>A single string that indicates the type of capture history format to convert <b>TO</b>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_id">id</code></td>
<td>
<p>A string or numeric that indicates the column in <code>df</code> that contains the unique identifier for an individual fish. This argument is only used if <code>in.type="event"</code>, <code>in.type="individual"</code>, or, possibly, <code>in.type="RMark"</code>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_event.ord">event.ord</code></td>
<td>
<p>A string that contains a vector of ordered levels to be used when <code>in.type="event"</code>. The default is to order alphabetically which may not be desirable if, for example, the events are labeled as &lsquo;first&rsquo;, &lsquo;second&rsquo;, &lsquo;third&rsquo;, and &lsquo;fourth&rsquo;. In this case, use <code>event.ord=c("first","second","third","fourth")</code>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_freq">freq</code></td>
<td>
<p>A string or numeric that indicates the column in <code>df</code> that contains the frequency of individual fish corresponding to a capture history. This argument is only used if <code>in.type="MARK"</code>, <code>in.type="frequency"</code>, or, possibly, <code>in.type="RMark"</code>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_var.lbls">var.lbls</code></td>
<td>
<p>A string vector of labels for the columns that contain the returned individual or frequency capture histories. If <code>var.lbls=NULL</code> or the length is different then the number of events then default labels using <code>var.lbls.pre</code> will be used. This argument is only used if <code>out.type="frequency"</code> or <code>out.type="individual"</code>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_var.lbls.pre">var.lbls.pre</code></td>
<td>
<p>A single string used as a prefix for the labels of the columns that contain the returned individual or frequency capture histories. This prefix will be appended with a number corresponding to the sample event. This argument is only used if <code>out.type="frequency"</code> or <code>out.type="individual"</code> and will be ignored if a proper vector is given in <code>var.lbls</code>.</p>
</td></tr>
<tr><td><code id="capHistConvert_+3A_include.id">include.id</code></td>
<td>
<p>A logical that indicates whether a unique fish identifier variable/column should be included in the output data.frame. This argument is only used if <code>out.type="individual"</code> or <code>out.type="RMark"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+capHistSum">capHistSum</a></code> requires capture histories to be recorded in the &ldquo;individual&rdquo; format. In this format, the data frame contains (at least) as many columns as sample events and as many rows as individually tagged fish. Optionally, the data.frame may also contain a column with unique fish identifiers (e.g., tag numbers). Each cell in the capture history portion of the data.frame contains a &lsquo;0&rsquo; if the fish of that row was NOT seen in the event of that column and a &lsquo;1&rsquo; if the fish of that row WAS seen in the event of that column. For example, suppose that five fish were marked on four sampling events; fish &lsquo;17&rsquo; was captured on the first two events; fish &lsquo;18&rsquo; was captured on the first and third events; fish &lsquo;19&rsquo; was captured on only the third event; fish &lsquo;20&rsquo; was captured on only the fourth event; and fish &lsquo;21&rsquo; was captured on the first and second events. The &ldquo;individual&rdquo; capture history date.frame for these data looks like:
</p>

<table>
<tr>
 <td style="text-align: center;">
fish </td><td style="text-align: center;"> event1 </td><td style="text-align: center;"> event2 </td><td style="text-align: center;"> event3 </td><td style="text-align: center;"> event4 </td>
</tr>
<tr>
 <td style="text-align: center;">
17 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td>
</tr>
<tr>
 <td style="text-align: center;">
18 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td>
</tr>
<tr>
 <td style="text-align: center;">
19 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td>
</tr>
<tr>
 <td style="text-align: center;">
20 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;"> 
21 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>The &ldquo;frequency&rdquo; format data.frame (this format is used in <span class="pkg">Rcapture</span>) has unique capture histories in separate columns, as in the &ldquo;individual&rdquo; format, but also includes a column with the frequency of individuals that had the capture history of that row. It will not contain a fish identifier variable. The same data from above looks like:
</p>

<table>
<tr>
 <td style="text-align: center;">
event1 </td><td style="text-align: center;"> event2 </td><td style="text-align: center;"> event3 </td><td style="text-align: center;"> event4 </td><td style="text-align: center;"> freq </td>
</tr>
<tr>
 <td style="text-align: center;">
1 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 0 </td><td style="text-align: center;"> 1 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>The &ldquo;event&rdquo; format data.frame has a column with the unique fish identifier and a column with the event in which the fish of that row was observed. The same data from above looks like:
</p>

<table>
<tr>
 <td style="text-align: center;">
fish </td><td style="text-align: center;"> event </td>
</tr>
<tr>
 <td style="text-align: center;">
17 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
18 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
21 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
17 </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
21 </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
18 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;">
19 </td><td style="text-align: center;"> 3 </td>
</tr>
<tr>
 <td style="text-align: center;">
20 </td><td style="text-align: center;"> 4 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>MARK (http://www.phidot.org/software/mark/index.html) is the &ldquo;gold-standard&rdquo; software for analyzing complex capture history information. In the &ldquo;MARK&rdquo; format the 0s and 1s of the capture histories are combined together as a string without any spaces. Thus, the &ldquo;MARK&rdquo; format has the capture history strings in one column with an additional column that contains the frequency of individuals that exhibited the capture history of that row. The final column ends with a semi-colon. The same data from above looks like:
</p>

<table>
<tr>
 <td style="text-align: center;">
ch </td><td style="text-align: center;"> freq </td>
</tr>
<tr>
 <td style="text-align: center;">
0001 </td><td style="text-align: center;"> 1; </td>
</tr>
<tr>
 <td style="text-align: center;">
0010 </td><td style="text-align: center;"> 1; </td>
</tr>
<tr>
 <td style="text-align: center;">
1010 </td><td style="text-align: center;"> 1; </td>
</tr>
<tr>
 <td style="text-align: center;">
1100 </td><td style="text-align: center;"> 2; </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>The <code>RMark</code> and <span class="pkg">marked</span> are packages used to replace some of the functionality of MARK or to interact with MARK. The &ldquo;RMark&rdquo; or &ldquo;marked&rdquo; format requires the capture histories as one string (must be a character string and called &lsquo;ch&rsquo;), as in the &ldquo;MARK&rdquo; format, but without the semicolon. The data.frame may be augmented with an identifier for individual fish OR with a frequency variable. If augmented with a unique fish identification variable then the same data from above looks like:
</p>

<table>
<tr>
 <td style="text-align: center;">
fish </td><td style="text-align: center;"> ch </td>
</tr>
<tr>
 <td style="text-align: center;">
17 </td><td style="text-align: center;"> 1100 </td>
</tr>
<tr>
 <td style="text-align: center;">
18 </td><td style="text-align: center;"> 1010 </td>
</tr>
<tr>
 <td style="text-align: center;">
19 </td><td style="text-align: center;"> 0010 </td>
</tr>
<tr>
 <td style="text-align: center;">
20 </td><td style="text-align: center;"> 0001 </td>
</tr>
<tr>
 <td style="text-align: center;"> 
21 </td><td style="text-align: center;"> 1100 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>However, if augmented with a frequency variable then the same data from above looks like:
</p>

<table>
<tr>
 <td style="text-align: center;">
ch </td><td style="text-align: center;"> freq </td>
</tr>
<tr>
 <td style="text-align: center;">
0001 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
0010 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
1010 </td><td style="text-align: center;"> 1 </td>
</tr>
<tr>
 <td style="text-align: center;">
1100 </td><td style="text-align: center;"> 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>

<p>Each of the formats can be used to convert from (i.e., in <code>in.type=</code>) or to convert to (i.e., in <code>out.type=</code>) with the exception that only the individual fish identifier version can be converted to when <code>out.type="RMark"</code>.
</p>


<h3>Value</h3>

<p>A data frame of the proper type given in <code>out.type</code> is returned. See details.
</p>


<h3>Warning</h3>

<p><code>capHistConvert</code> may give unwanted results if the data are <code>in.type="event"</code> but there are unused levels for the variable, as would result if the data.frame had been subsetted on the event variable. The unwanted results can be corrected by using <code>droplevels</code> before <code>capHistConvert</code>. See the last example for an example.
</p>


<h3>IFAR Chapter</h3>

<p>9-Abundance from Capture-Recapture Data.
</p>


<h3>Note</h3>

<p>The formats as used here are simple in the sense that one is only allowed to have the individual fish identifier or the frequency variable in addition to the capture history information. More complex analyses may use a number of covariates. For these more complex analyses, one should work directly with the <span class="pkg">Rcapture</span>, <code>RMark</code>, or <span class="pkg">marked</span> packages.
</p>
<p>This function also assumes that all unmarked captured fish are marked and returned to the population (i.e., no losses at the time of marking are allowed).
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+capHistSum">capHistSum</a></code> to summarize &ldquo;individual&rdquo; capture histories into a format usable in <code><a href="#topic+mrClosed">mrClosed</a></code> and <code><a href="#topic+mrOpen">mrOpen</a></code>. Also see <span class="pkg">Rcapture</span>, <code>RMark</code>, or <span class="pkg">marked</span> packages for handling more complex analyses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A small example of 'event' format
( ex1 &lt;- data.frame(fish=c(17,18,21,17,21,18,19,20),yr=c(1987,1987,1987,1988,1988,1989,1989,1990)) )
# convert to 'individual' format
( ex1.E2I &lt;- capHistConvert(ex1,id="fish",in.type="event") )
# convert to 'frequency' format
( ex1.E2F &lt;- capHistConvert(ex1,id="fish",in.type="event",out.type="frequency") )
# convert to 'MARK' format
( ex1.E2M &lt;- capHistConvert(ex1,id="fish",in.type="event",out.type="MARK") )
# convert to 'RMark' format
( ex1.E2R &lt;- capHistConvert(ex1,id="fish",in.type="event",out.type="RMark") )

## convert converted 'individual' format ...
# to 'frequency' format (must ignore "id")
( ex1.I2F &lt;- capHistConvert(ex1.E2I,id="fish",in.type="individual",out.type="frequency") )
# to 'MARK' format
( ex1.I2M &lt;- capHistConvert(ex1.E2I,id="fish",in.type="individual",out.type="MARK") )
# to 'RMark' format
( ex1.I2R &lt;- capHistConvert(ex1.E2I,id="fish",in.type="individual",out.type="RMark") )
# to 'event' format
( ex1.I2E &lt;- capHistConvert(ex1.E2I,id="fish",in.type="individual",out.type="event") )

#' ## convert converted 'frequency' format ...
# to 'individual' format
( ex1.F2I &lt;- capHistConvert(ex1.E2F,freq="freq",in.type="frequency") )
( ex1.F2Ia &lt;- capHistConvert(ex1.E2F,freq="freq",in.type="frequency",include.id=TRUE) )
# to 'Mark' format
( ex1.F2M &lt;- capHistConvert(ex1.E2F,freq="freq",in.type="frequency",
                            out.type="MARK") )
# to 'RMark' format
( ex1.F2R &lt;- capHistConvert(ex1.E2F,freq="freq",in.type="frequency",
                            out.type="RMark") )
( ex1.F2Ra &lt;- capHistConvert(ex1.E2F,freq="freq",in.type="frequency",
                             out.type="RMark",include.id=TRUE) )
# to 'event' format
( ex1.F2E &lt;- capHistConvert(ex1.E2F,freq="freq",in.type="frequency",
                            out.type="event") )

## convert converted 'MARK' format ...
# to 'individual' format
( ex1.M2I &lt;- capHistConvert(ex1.E2M,freq="freq",in.type="MARK") )
( ex1.M2Ia &lt;- capHistConvert(ex1.E2M,freq="freq",in.type="MARK",include.id=TRUE) )
# to 'frequency' format
( ex1.M2F &lt;- capHistConvert(ex1.E2M,freq="freq",in.type="MARK",out.type="frequency") )
# to 'RMark' format
( ex1.M2R &lt;- capHistConvert(ex1.E2M,freq="freq",in.type="MARK",out.type="RMark") )
( ex1.M2Ra &lt;- capHistConvert(ex1.E2M,freq="freq",in.type="MARK",out.type="RMark",include.id=TRUE) )
# to 'event' format
( ex1.M2E &lt;- capHistConvert(ex1.E2M,freq="freq",in.type="MARK",out.type="event") )
 
## convert converted 'RMark' format ...
# to 'individual' format
( ex1.R2I &lt;- capHistConvert(ex1.E2R,id="fish",in.type="RMark") )
# to 'frequency' format
( ex1.R2F &lt;- capHistConvert(ex1.E2R,id="fish",in.type="RMark",out.type="frequency") )
# to 'MARK' format
( ex1.R2M &lt;- capHistConvert(ex1.E2R,id="fish",in.type="RMark",out.type="MARK") )
# to 'event' format
( ex1.R2E &lt;- capHistConvert(ex1.E2R,id="fish",in.type="RMark",out.type="event") )

## Remove semi-colon from MARK format to make a RMark 'frequency' format
ex1.E2R1 &lt;- ex1.E2M
ex1.E2R1$freq &lt;- as.numeric(sub(";","",ex1.E2R1$freq))
ex1.E2R1
# convert this to 'individual' format
( ex1.R2I1 &lt;- capHistConvert(ex1.E2R1,freq="freq",in.type="RMark") )
( ex1.R2I1a &lt;- capHistConvert(ex1.E2R1,freq="freq",in.type="RMark",include.id=TRUE) )
# convert this to 'frequency' format
( ex1.R2F1 &lt;- capHistConvert(ex1.E2R1,freq="freq",in.type="RMark",out.type="frequency") )
# convert this to 'MARK' format
( ex1.R2M1 &lt;- capHistConvert(ex1.E2R1,freq="freq",in.type="RMark",out.type="MARK") )
# convert this to 'event' format
( ex1.R2E1 &lt;- capHistConvert(ex1.E2R1,freq="freq",in.type="RMark",out.type="event") )


########################################################################
## A small example using character ids
( ex2 &lt;- data.frame(fish=c("id17","id18","id21","id17","id21","id18","id19","id20"),
                    yr=c(1987,1987,1987,1988,1988,1989,1989,1990)) )
# convert to 'individual' format
( ex2.E2I &lt;- capHistConvert(ex2,id="fish",in.type="event") )
# convert to 'frequency' format
( ex2.E2F &lt;- capHistConvert(ex2,id="fish",in.type="event",out.type="frequency") )
# convert to 'MARK' format
( ex2.E2M &lt;- capHistConvert(ex2,id="fish",in.type="event",out.type="MARK") )
# convert to 'RMark' format
( ex2.E2R &lt;- capHistConvert(ex2,id="fish",in.type="event",out.type="RMark") )

## convert converted 'individual' format ...
# to 'frequency' format
( ex2.I2F &lt;- capHistConvert(ex2.E2I,id="fish",in.type="individual",out.type="frequency") )
# to 'MARK' format
( ex2.I2M &lt;- capHistConvert(ex2.E2I,id="fish",in.type="individual",out.type="MARK") )
# to 'RMark' format
( ex2.I2R &lt;- capHistConvert(ex2.E2I,id="fish",in.type="individual",out.type="RMark") )
# to 'event' format
( ex2.I2E &lt;- capHistConvert(ex2.E2I,id="fish",in.type="individual",out.type="event") )

## demo use of var.lbls
( ex2.E2Ia &lt;- capHistConvert(ex2,id="fish",in.type="event",var.lbls.pre="Sample") )
( ex2.E2Ib &lt;- capHistConvert(ex2,id="fish",in.type="event",
              var.lbls=c("first","second","third","fourth")) )

## demo use of event.ord
( ex2.I2Ea &lt;- capHistConvert(ex2.E2Ib,id="fish",in.type="individual",out.type="event") )
( ex2.E2Ibad &lt;- capHistConvert(ex2.I2Ea,id="fish",in.type="event") )
( ex2.E2Igood &lt;- capHistConvert(ex2.I2Ea,id="fish",in.type="event",
                 event.ord=c("first","second","third","fourth")) )

## ONLY RUN IN INTERACTIVE MODE
if (interactive()) {

########################################################################
## A larger example of 'frequency' format (data from Rcapture package)
data(bunting,package="Rcapture")
head(bunting)
# convert to 'individual' format
bun.F2I &lt;- capHistConvert(bunting,in.type="frequency",freq="freq")
head(bun.F2I)
# convert to 'MARK' format
bun.F2M &lt;- capHistConvert(bunting,id="id",in.type="frequency",freq="freq",out.type="MARK")
head(bun.F2M)
# convert converted 'individual' back to 'MARK' format
bun.I2M &lt;- capHistConvert(bun.F2I,id="id",in.type="individual",out.type="MARK")
head(bun.I2M)
# convert converted 'individual' back to 'frequency' format
bun.I2F &lt;- capHistConvert(bun.F2I,id="id",in.type="individual",
           out.type="frequency",var.lbls.pre="Sample")
head(bun.I2F)


########################################################################
## A larger example of 'marked' or 'RMark' format, but with a covariate
##   and when the covariate is removed there is no frequency or individual
##   fish identifier.
data(dipper,package="marked")
head(dipper)
# isolate males and females
dipperF &lt;- subset(dipper,sex=="Female")
dipperM &lt;- subset(dipper,sex=="Male")
# convert females to 'individual' format
dipF.R2I &lt;- capHistConvert(dipperF,cols2ignore="sex",in.type="RMark")
head(dipF.R2I)
# convert males to 'individual' format
dipM.R2I &lt;- capHistConvert(dipperM,cols2ignore="sex",in.type="RMark")
head(dipM.R2I)
# add sex variable to each data.frame and then combine
dipF.R2I$sex &lt;- "Female"
dipM.R2I$sex &lt;- "Male"
dip.R2I &lt;- rbind(dipF.R2I,dipM.R2I)
head(dip.R2I)
tail(dip.R2I)

} # end interactive


## An example of problem with unused levels
## Create a set of test data with several groups
( df &lt;- data.frame(fish=c("id17","id18","id21","id17","id21","id18","id19","id20","id17"),
                   group=c("B1","B1","B1","B2","B2","B3","B4","C1","C1")) )
#  Let's assume the user wants to subset the data from the "B" group
( df1 &lt;- subset(df,group %in% c("B1","B2","B3","B4")) )
#  Looks like capHistConvert() is still using the unused factor
#  level from group C
capHistConvert(df1,id="fish",in.type="event")
# use droplevels() to remove the unused groups and no problem
df1 &lt;- droplevels(df1)
capHistConvert(df1,id="fish",in.type="event")

</code></pre>

<hr>
<h2 id='capHistSum'>Summarize capture histories in individual fish format.</h2><span id='topic+capHistSum'></span><span id='topic+plot.CapHist'></span><span id='topic+is.CapHist'></span>

<h3>Description</h3>

<p>Use to summarize a capture history data file that is in the &ldquo;individual&rdquo; fish format (see <code><a href="#topic+capHistConvert">capHistConvert</a></code> for a discussion of data file format types). Summarized capture history results may be used in the Lincoln-Petersen, Schnabel, Schumacher-Eschmeyer, or Jolly-Seber methods for estimating population abundance (see <code><a href="#topic+mrClosed">mrClosed</a></code> and <code><a href="#topic+mrOpen">mrOpen</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capHistSum(df, cols2use = NULL, cols2ignore = NULL)

is.CapHist(x)

## S3 method for class 'CapHist'
plot(x, what = c("u", "f"), pch = 19, cex.pch = 0.7, lwd = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capHistSum_+3A_df">df</code></td>
<td>
<p>A data.frame that contains the capture histories (and, perhaps, other information) in &ldquo;individual&rdquo; fish format. See details.</p>
</td></tr>
<tr><td><code id="capHistSum_+3A_cols2use">cols2use</code></td>
<td>
<p>A string or numeric vector that indicates columns in <code>df</code> that contain the capture histories. Negative numeric values will not use those columns. Cannot use both <code>cols2use</code> and <code>col2ignore</code>. See details.</p>
</td></tr>
<tr><td><code id="capHistSum_+3A_cols2ignore">cols2ignore</code></td>
<td>
<p>A string or numeric vector that indicates columns in <code>df</code> that do not contain the capture histories and should be ignored. Cannot use both <code>cols2use</code> and <code>col2ignore</code>.</p>
</td></tr>
<tr><td><code id="capHistSum_+3A_x">x</code></td>
<td>
<p>An object from <code>capHistSum</code>.</p>
</td></tr>
<tr><td><code id="capHistSum_+3A_what">what</code></td>
<td>
<p>A string that indicates what type of diagnostic plot to construct with <code>plot</code>. See details.</p>
</td></tr>
<tr><td><code id="capHistSum_+3A_pch">pch</code></td>
<td>
<p>A numeric that indicates the plotting character for the diagnostic plot.</p>
</td></tr>
<tr><td><code id="capHistSum_+3A_cex.pch">cex.pch</code></td>
<td>
<p>A numeric that indicates the character expansion value for the plotting characters in the diagnostic plot. The default is to be &ldquo;slightly smaller&rdquo; (i.e., <code>cex.pch=0.7</code>).</p>
</td></tr>
<tr><td><code id="capHistSum_+3A_lwd">lwd</code></td>
<td>
<p>A numeric that indicates the line width in the diagnostic plot.</p>
</td></tr>
<tr><td><code id="capHistSum_+3A_...">...</code></td>
<td>
<p>Optional arguments to send to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the capture history data file to be in the &ldquo;individual&rdquo; fish format. See <code><a href="#topic+capHistConvert">capHistConvert</a></code> for a description of this (and other) formats and for methods to convert from other formats to the &ldquo;individual&rdquo; fish format. In addition, this function requires only the capture history portion of the data file. Thus, if <code>df</code> contains columns with non-capture history information (e.g., fish ID, length, location, etc.) then use <code>cols2use=</code> to identify which columns contain only the capture history information. Columns to use can be identified by listing the column numbers (e.g., columns 2 through 7 could be included with <code>cols2use=2:7</code>). In many instances it may be easier to identify columns to <em>exclude</em> which can be done by preceding the column number by a negative sign (e.g., columns 1 through 3 are excluded with <code>cols2use=-(1:3)</code>).
</p>
<p>The object returned from this function can be used directly in <code><a href="#topic+mrClosed">mrClosed</a></code> and <code><a href="#topic+mrOpen">mrOpen</a></code>. See examples of this functionality on the help pages for those functions.
</p>
<p>The <code>plot</code> function can be used to construct the two diagnostic plots described by Baillargeon and Rivest (2007). The <code>what="f"</code> plot will plot the log of the number of fish seen i times divided by <code>choose(t,i)</code> against i. The <code>what="u"</code> plot will plot the log of the number of fish seen for the first time on event i against i. Baillargeon and Rivest (2007) provide a table that can be used to diagnosed types of heterogeneities in capture probabilities from these plots.
</p>


<h3>Value</h3>

<p>If the capture history data file represents only two samples, then a list with the following two components is returned.
</p>

<ul>
<li> <p><code>caphist</code> A vector summarizing the frequency of fish with each capture history.
</p>
</li>
<li> <p><code>sum</code> A data.frame that contains the number of marked fish from the first sample (<code>M</code>), the number of captured fish in the second sample (<code>n</code>), and the number of recaptured (i.e. previously marked) fish in the second sample (<code>m</code>).
</p>
</li></ul>

<p>If the capture history data file represents more than two samples, then a list with the following five components is returned
</p>

<ul>
<li> <p><code>caphist</code> A vector summarizing the frequency of fish with each capture history.
</p>
</li>
<li> <p><code>sum</code> A data frame that contains the the number of captured fish in the ith sample (<code>n</code>), the number of recaptured (i.e. previously marked) fish in the ith sample (<code>m</code>), the number of marked fish returned to the population following the ith sample (<code>R</code>; this will equal <code>n</code> as the function currently does not handle mortalities); the number of marked fish in the population prior to the ith sample (<code>M</code>); the number of fish first seen in the ith sample (<code>u</code>); the number of fish last seen in the ith sample (<code>v</code>); and the number of fish seen i times (<code>f</code>).
</p>
</li>
<li> <p><code>methodB.top</code> A matrix that contains the top of the Method B table used for the Jolly-Seber method (i.e., a contingency table of capture sample (columns) and last seen sample (rows)).
</p>
</li>
<li> <p><code>methodB.bot</code> A data.frame that contains the bottom of the Method B table used for the Jolly-Seber method (i.e., the number of marked fish in the sample (<code>m</code>), the number of unmarked fish in the sample (<code>u</code>), the total number of fish in the sample (<code>n</code>), and the number of marked fish returned to the population following the sample (<code>R</code>).
</p>
</li>
<li> <p><code>m.array</code> A matrix that contains the the so-called &ldquo;m-array&rdquo;. The first column contains the number of fish captured on the ith event. The columns labeled with &ldquo;cX&rdquo; prefix show the number of fish originally captured in the ith row that were captured in the Xth event. The last column shows the number of fish originally captured in the ith row that were never recaptured.
</p>
</li></ul>



<h3>IFAR Chapter</h3>

<p>9-Abundance from Capture-Recapture Data.
</p>


<h3>Note</h3>

<p>This function assumes that all unmarked captured fish are marked and returned to the population (i.e., no losses at the time of marking are allowed).
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Baillargeon, S. and Rivest, L.-P. (2007). Rcapture: Loglinear models for capture-recapture in R. Journal of Statistical Software, 19(5):1-31.
</p>


<h3>See Also</h3>

<p>See <code><a href="Rcapture.html#topic+descriptive">descriptive</a></code> in <span class="pkg">Rcapture</span> for <code>m.array</code> and some of the same values in <code>sum</code>. See <code><a href="#topic+capHistConvert">capHistConvert</a></code> for a descriptions of capture history data file formats and how to convert between them. See <code><a href="#topic+mrClosed">mrClosed</a></code> and <code><a href="#topic+mrOpen">mrOpen</a></code> for how to estimate abundance from the summarized capture history information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data.frame with IDs in the first column
head(PikeNYPartial1)

# Three ways to ignore first column of ID numbers
( ch1 &lt;- capHistSum(PikeNYPartial1,cols2use=-1) )
( ch1 &lt;- capHistSum(PikeNYPartial1,cols2ignore=1) )
( ch1 &lt;- capHistSum(PikeNYPartial1,cols2ignore="id") )

# diagnostic plots
plot(ch1)
plot(ch1,what="f")
plot(ch1,what="u")

# An examle with only two sample events (for demonstration only)
( ch2 &lt;- capHistSum(PikeNYPartial1,cols2use=-c(1,4:5)) )
( ch2 &lt;- capHistSum(PikeNYPartial1,cols2use=2:3) )
( ch2 &lt;- capHistSum(PikeNYPartial1,cols2ignore=c(1,4:5)) )

</code></pre>

<hr>
<h2 id='catchCurve'>Mortality estimates from the descending limb of a catch curve.</h2><span id='topic+catchCurve'></span><span id='topic+catchCurve.default'></span><span id='topic+catchCurve.formula'></span><span id='topic+plot.catchCurve'></span><span id='topic+summary.catchCurve'></span><span id='topic+coef.catchCurve'></span><span id='topic+anova.catchCurve'></span><span id='topic+confint.catchCurve'></span><span id='topic+rSquared.catchCurve'></span>

<h3>Description</h3>

<p>Fits a linear model to the user-defined descending limb of a catch curve. Method functions extract estimates of the instantaneous (Z) and total annual (A) mortality rates with associated standard errors and confidence intervals. A plot method highlights the descending limb, shows the linear model on the descending limb, and, optionally, prints the estimated Z and A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catchCurve(x, ...)

## Default S3 method:
catchCurve(
  x,
  catch,
  ages2use = age,
  weighted = FALSE,
  negWeightReplace = 0,
  ...
)

## S3 method for class 'formula'
catchCurve(
  x,
  data,
  ages2use = age,
  weighted = FALSE,
  negWeightReplace = 0,
  ...
)

## S3 method for class 'catchCurve'
summary(object, parm = c("both", "all", "Z", "A", "lm"), ...)

## S3 method for class 'catchCurve'
coef(object, parm = c("all", "both", "Z", "A", "lm"), ...)

## S3 method for class 'catchCurve'
anova(object, ...)

## S3 method for class 'catchCurve'
confint(
  object,
  parm = c("all", "both", "Z", "A", "lm"),
  level = conf.level,
  conf.level = 0.95,
  ...
)

## S3 method for class 'catchCurve'
rSquared(object, digits = getOption("digits"), percent = FALSE, ...)

## S3 method for class 'catchCurve'
plot(
  x,
  pos.est = "topright",
  cex.est = 0.95,
  round.est = c(3, 1),
  ylab = "log(Catch)",
  xlab = "Age",
  ylim = NULL,
  col.pt = "gray30",
  col.mdl = "black",
  lwd = 2,
  lty = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catchCurve_+3A_x">x</code></td>
<td>
<p>A numerical vector of assigned ages in the catch curve or a formula of the form <code>catch~age</code> when used in <code>catchCurve</code>. An object saved from <code>catchCurve</code> (i.e., of class <code>catchCurve</code>) when used in the methods.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_catch">catch</code></td>
<td>
<p>A numerical vector of catches or CPUEs for the ages in the catch curve. Not used if <code>x</code> is a formula.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_ages2use">ages2use</code></td>
<td>
<p>A numerical vector of ages that define the descending limb of the catch curve.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_weighted">weighted</code></td>
<td>
<p>A logical that indicates whether a weighted regression should be used. See details.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_negweightreplace">negWeightReplace</code></td>
<td>
<p>A single non-negative numeric that will replace negative weights (defaults to 0). Only used when <code>weighted=TRUE</code>. See details.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_data">data</code></td>
<td>
<p>A data.frame from which the variables in the <code>x</code> formula can be found. Not used if <code>x</code> is not a formula.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_object">object</code></td>
<td>
<p>An object saved from the <code>catchCurve</code> call (i.e., of class <code>catchCurve</code>).</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_parm">parm</code></td>
<td>
<p>A numeric or string (of parameter names) vector that specifies which parameters are to be given confidence intervals. If <code>parm="lm"</code> then confidence intervals for the underlying linear model are returned.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_level">level</code></td>
<td>
<p>Same as <code>conf.level</code>. Used for compatibility with the generic <code>confint</code> function.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_conf.level">conf.level</code></td>
<td>
<p>A number representing the level of confidence to use for constructing confidence intervals.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_digits">digits</code></td>
<td>
<p>The number of digits to round the <code>rSquared</code> result to.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_percent">percent</code></td>
<td>
<p>A logical that indicates if the <code>rSquared</code> result should be returned as a percentage (<code>=TRUE</code>) or as a proportion (<code>=FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_pos.est">pos.est</code></td>
<td>
<p>A string to identify where to place the estimated mortality rates on the plot. Can be set to one of <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code> or <code>"center"</code> for positioning the estimated mortality rates on the plot. Typically <code>"bottomleft"</code> (DEFAULT) and <code>"topright"</code> will be &ldquo;out-of-the-way&rdquo; placements. Set <code>pos.est</code> to <code>NULL</code> to remove the estimated mortality rates from the plot.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_cex.est">cex.est</code></td>
<td>
<p>A single numeric character expansion value for the estimated mortality rates on the plot.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_round.est">round.est</code></td>
<td>
<p>A numeric that indicates the number of decimal place to which Z (first value) and A (second value) should be rounded. If only one value then it will be used for both Z and A.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y-axis (<code>"log(Catch)"</code> is the default).</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x-axis (<code>"Age"</code> is the default).</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_ylim">ylim</code></td>
<td>
<p>A numeric for the limits of the y-axis. If <code>NULL</code> then will default to a minimum of 0 or the lowest negative log catch and a maximum of the maximum log catch. If a single value then it will be the maximum of the y-axis. If two values then these will the minimum and maximum values of the y-axis.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_col.pt">col.pt</code></td>
<td>
<p>A string that indicates the color of the plotted points.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_col.mdl">col.mdl</code></td>
<td>
<p>A string that indicates the color of the fitted line.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_lwd">lwd</code></td>
<td>
<p>A numeric that indicates the line width of the fitted line.</p>
</td></tr>
<tr><td><code id="catchCurve_+3A_lty">lty</code></td>
<td>
<p>A numeric that indicates the type of line used for the fitted line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default is to use all ages in the age vector. This is appropriate only when the age and catch vectors contain only the ages and catches on the descending limb of the catch curve. Use <code>ages2use</code> to isolate only the catch and ages on the descending limb.
</p>
<p>If <code>weighted=TRUE</code> then a weighted regression is used where the weights are the log(number) at each age predicted from the unweighted regression of log(number) on age (as proposed by Maceina and Bettoli (1998)). If a negative weight is computed it will be changed to the value in <code>negWeightReplace</code> and a warning will be issued.
</p>


<h3>Value</h3>

<p>A list that contains the following items:
</p>

<ul>
<li><p> age The original vector of assigned ages.
</p>
</li>
<li><p> catch The original vector of observed catches or CPUEs.
</p>
</li>
<li><p> age.e A vector of assigned ages for which the catch curve was fit.
</p>
</li>
<li><p> log.catch.e A vector of log catches or CPUEs for which the catch curve was fit.
</p>
</li>
<li><p> W A vector of weights used in the catch curve fit. Will be <code>NULL</code> unless <code>weighted=TRUE</code>.
</p>
</li>
<li><p> lm An <code>lm</code> object from the fit to the ages and log catches or CPUEs on the descending limb (i.e., in age.e and log.catch.e).
</p>
</li></ul>



<h3>Testing</h3>

<p>Tested the results of catch curve, both unweighted and weighted, against the results in Miranda and Bettoli (2007). Results for Z and the SE of Z matched perfectly. Tested the unweighted results against the results from <code>agesurv</code> in <span class="pkg">fishmethods</span> using the <code>rockbass</code> data.frame in <span class="pkg">fishmethods</span>. Results for Z and the SE of Z matched perfectly.
</p>


<h3>IFAR Chapter</h3>

<p>11-Mortality.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Maceina, M.J., and P.W. Bettoli. 1998. Variation in Largemouth Bass recruitment in four mainstream impoundments on the Tennessee River. North American Journal of Fisheries Management 18:998-1003.
</p>
<p>Ricker, W.E. 1975. Computation and interpretation of biological statistics of fish populations. Technical Report Bulletin 191, Bulletin of the Fisheries Research Board of Canada. [Was (is?) from http://www.dfo-mpo.gc.ca/Library/1485.pdf.]
</p>


<h3>See Also</h3>

<p>See <code><a href="fishmethods.html#topic+agesurv">agesurv</a></code> in <span class="pkg">fishmethods</span> for similar functionality. See <code><a href="#topic+chapmanRobson">chapmanRobson</a></code> and <code><a href="fishmethods.html#topic+agesurvcl">agesurvcl</a></code> in <span class="pkg">fishmethods</span> for alternative methods to estimate mortality rates. See <code><a href="#topic+metaM">metaM</a></code> for empirical methods to estimate natural mortality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(catch~age,data=BrookTroutTH,pch=19)

## demonstration of formula notation
cc1 &lt;- catchCurve(catch~age,data=BrookTroutTH,ages2use=2:6)
summary(cc1)
cbind(Est=coef(cc1),confint(cc1))
rSquared(cc1)
plot(cc1)
summary(cc1,parm="Z")
cbind(Est=coef(cc1,parm="Z"),confint(cc1,parm="Z"))

## demonstration of excluding ages2use
cc2 &lt;- catchCurve(catch~age,data=BrookTroutTH,ages2use=-c(0,1))
summary(cc2)
plot(cc2)

## demonstration of using weights
cc3 &lt;- catchCurve(catch~age,data=BrookTroutTH,ages2use=2:6,weighted=TRUE)
summary(cc3)
plot(cc3)

## demonstration of returning the linear model results
summary(cc3,parm="lm")
cbind(Est=coef(cc3,parm="lm"),confint(cc3,parm="lm"))

## demonstration of ability to work with missing age classes
df &lt;- data.frame(age=c(  2, 3, 4, 5, 7, 9,12),
                 ct= c(100,92,83,71,56,35, 1))
cc4 &lt;- catchCurve(ct~age,data=df,ages2use=4:12)
summary(cc4)
plot(cc4)

## demonstration of ability to work with missing age classes
## evein if catches are recorded as NAs
df &lt;- data.frame(age=c(  2, 3, 4, 5, 6, 7, 8, 9,10,11,12),
                 ct= c(100,92,83,71,NA,56,NA,35,NA,NA, 1))
cc5 &lt;- catchCurve(ct~age,data=df,ages2use=4:12)
summary(cc5)
plot(cc5)

</code></pre>

<hr>
<h2 id='chapmanRobson'>Computes Chapman-Robson estimates of S and Z.</h2><span id='topic+chapmanRobson'></span><span id='topic+chapmanRobson.default'></span><span id='topic+chapmanRobson.formula'></span><span id='topic+plot.chapmanRobson'></span><span id='topic+summary.chapmanRobson'></span><span id='topic+confint.chapmanRobson'></span><span id='topic+coef.chapmanRobson'></span>

<h3>Description</h3>

<p>Computes the Chapman-Robson estimates of annual survival rate (S) and instantaneous mortality rate (Z) from catch-at-age data on the descending limb of a catch-curve. Method functions extract estimates with associated standard errors and confidence intervals. A plot method highlights the descending-limb, shows the linear model on the descending limb, and, optionally, prints the estimated Z and A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chapmanRobson(x, ...)

## Default S3 method:
chapmanRobson(
  x,
  catch,
  ages2use = age,
  zmethod = c("Smithetal", "Hoenigetal", "original"),
  ...
)

## S3 method for class 'formula'
chapmanRobson(
  x,
  data,
  ages2use = age,
  zmethod = c("Smithetal", "Hoenigetal", "original"),
  ...
)

## S3 method for class 'chapmanRobson'
summary(object, parm = c("all", "both", "Z", "S"), verbose = FALSE, ...)

## S3 method for class 'chapmanRobson'
coef(object, parm = c("all", "both", "Z", "S"), ...)

## S3 method for class 'chapmanRobson'
confint(
  object,
  parm = c("all", "both", "S", "Z"),
  level = conf.level,
  conf.level = 0.95,
  ...
)

## S3 method for class 'chapmanRobson'
plot(
  x,
  pos.est = "topright",
  cex.est = 0.95,
  round.est = c(3, 1),
  ylab = "Catch",
  xlab = "Age",
  ylim = NULL,
  col.pt = "gray30",
  axis.age = c("both", "age", "recoded age"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chapmanRobson_+3A_x">x</code></td>
<td>
<p>A numerical vector of the assigned ages in the catch curve or a formula of the form <code>catch~age</code> when used in <code>chapmanRobson</code>. An object saved from <code>chapmanRobson</code> (i.e., of class <code>chapmanRobson</code>) when used in the methods.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_catch">catch</code></td>
<td>
<p>A numerical vector of the catches or CPUEs for the ages in the catch curve. Not used if <code>x</code> is a formula.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_ages2use">ages2use</code></td>
<td>
<p>A numerical vector of the ages that define the descending limb of the catch curve.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_zmethod">zmethod</code></td>
<td>
<p>A string that indicates the method to use for estimating Z. See details.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_data">data</code></td>
<td>
<p>A data frame from which the variables in the <code>x</code> formula can be found. Not used if <code>x</code> is not a formula.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_object">object</code></td>
<td>
<p>An object saved from the <code>chapmanRobson</code> call (i.e., of class <code>chapmanRobson</code>).</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_parm">parm</code></td>
<td>
<p>A numeric or string (of parameter names) vector that specifies which parameters are to be given confidence intervals  If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates whether the method should return just the estimate (<code>FALSE</code>; default) or a more verbose statement.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_level">level</code></td>
<td>
<p>Same as <code>conf.level</code>. Used for compatibility with the generic <code>confint</code> function.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_conf.level">conf.level</code></td>
<td>
<p>A number representing the level of confidence to use for constructing confidence intervals.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_pos.est">pos.est</code></td>
<td>
<p>A string to identify where to place the estimated mortality rates on the plot. Can be set to one of <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code> or <code>"center"</code> for positioning the estimated mortality rates on the plot. Typically <code>"bottomleft"</code> (DEFAULT) and <code>"topright"</code> will be &ldquo;out-of-the-way&rdquo; placements. Set <code>pos.est</code> to <code>NULL</code> to remove the estimated mortality rates from the plot.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_cex.est">cex.est</code></td>
<td>
<p>A single numeric character expansion value for the estimated mortality rates on the plot.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_round.est">round.est</code></td>
<td>
<p>A numeric that indicates the number of decimal place to which Z (first value) and S (second value) should be rounded. If only one value then it will be used for both Z and S.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y-axis (<code>"Catch"</code> is the default).</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x-axis (<code>"Age"</code> is the default).</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_ylim">ylim</code></td>
<td>
<p>A numeric for the limits of the y-axis. If <code>NULL</code> then will default to 0 or the lowest catch and a maximum of the maximum catch. If a single value then it will be the maximum of the y-axis. If two values then these will the minimum and maximum values of the y-axis.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_col.pt">col.pt</code></td>
<td>
<p>A string that indicates the color of the plotted points.</p>
</td></tr>
<tr><td><code id="chapmanRobson_+3A_axis.age">axis.age</code></td>
<td>
<p>A string that indicates the type of x-axis to display. The <code>age</code> will display only the original ages, <code>recoded age</code> will display only the recoded ages, and <code>both</code> (DEFAULT) displays the original ages on the main axis and the recoded ages on the secondary axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default is to use all ages in the age vector. This is only appropriate if the age and catch vectors contain only the ages and catches on the descending limb of the catch curve. Use <code>ages2use</code> to isolate only the catch and ages on the descending limb.
</p>
<p>The Chapman-Robson method provides an estimate of the annual survival rate, with the annual mortality rate (A) determined by 1-S. The instantaneous mortality rate is often computed as -log(S). However, Hoenig <em>et al.</em> (1983) showed that this produced a biased (over)estimate of Z and provided a correction. The correction is applied by setting <code>zmethod="Hoenigetal"</code>. Smith <em>et al.</em> (2012) showed that the Hoenig <em>et al.</em> method should be corrected for a variance inflation factor. This correction is applied by setting <code>zmethod="Smithetal"</code> (which is the default behavior). Choose <code>zmethod="original"</code> to use the original estimates for Z and it's SE as provided by Chapman and Robson.
</p>


<h3>Value</h3>

<p>A list with the following items:
</p>

<ul>
<li><p> age the original vector of assigned ages.
</p>
</li>
<li><p> catch the original vector of observed catches or CPUEs.
</p>
</li>
<li><p> age.e a vector of assigned ages used to estimate mortalities.
</p>
</li>
<li><p> catch.e a vector of catches or CPUEs used to estimate mortalities.
</p>
</li>
<li><p> age.r a vector of recoded ages used to estimate mortalities. See references.
</p>
</li>
<li><p> n a numeric holding the intermediate calculation of n. See references.
</p>
</li>
<li><p> T a numeric holding the intermediate calculation of T. See references.
</p>
</li>
<li><p> est A 2x2 matrix that contains the estimates and standard errors for S and Z.
</p>
</li></ul>



<h3>Testing</h3>

<p>Tested the results of chapmanRobson against the results in Miranda and Bettoli (2007). The point estimates of S matched perfectly but the SE of S did not because Miranda and Bettoli used a rounded estimate of S in the calculation of the SE of S but chapmanRobson does not.
</p>
<p>Tested the results against the results from <code>agesurv</code> in <span class="pkg">fishmethods</span> using the <code>rockbass</code> data.frame in <span class="pkg">fishmethods</span>. Results for Z and the SE of Z matched perfectly for non-bias-corrected results. The estimate of Z, but not the SE of Z, matched for the bias-corrected (following Smith <em>et al.</em> (2012)) results. <span class="pkg">FSA</span> uses equation 2 from Smith <em>et al.</em> (2012) whereas <span class="pkg">fishmethods</span> appears to use equation 5 from the same source to estimate the SE of Z.
</p>


<h3>IFAR Chapter</h3>

<p>11-Mortality.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Chapman, D.G. and D.S. Robson. 1960. The analysis of a catch curve. Biometrics. 16:354-368.
</p>
<p>Hoenig, J.M. and W.D. Lawing, and N.A. Hoenig. 1983. Using mean age, mean length and median length data to estimate the total mortality rate. International Council for the Exploration of the Sea, CM 1983/D:23, Copenhagen.
</p>
<p>Ricker, W.E. 1975. Computation and interpretation of biological statistics of fish populations. Technical Report Bulletin 191, Bulletin of the Fisheries Research Board of Canada. [Was (is?) from http://www.dfo-mpo.gc.ca/Library/1485.pdf.]
</p>
<p>Robson, D.S. and D.G. Chapman. 1961. Catch curves and mortality rates. Transactions of the American Fisheries Society. 90:181-189.
</p>
<p>Smith, M.W., A.Y. Then, C. Wor, G. Ralph, K.H. Pollock, and J.M. Hoenig. 2012. Recommendations for catch-curve analysis. North American Journal of Fisheries Management. 32:956-967.
</p>


<h3>See Also</h3>

<p>See <code><a href="fishmethods.html#topic+agesurv">agesurv</a></code> in <span class="pkg">fishmethods</span> for similar functionality. See <code><a href="#topic+catchCurve">catchCurve</a></code> and <code><a href="fishmethods.html#topic+agesurvcl">agesurvcl</a></code> in <span class="pkg">fishmethods</span> for alternative methods. See <code><a href="#topic+metaM">metaM</a></code> for empirical methods to estimate natural mortality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(catch~age,data=BrookTroutTH,pch=19)

## demonstration of formula notation
cr1 &lt;- chapmanRobson(catch~age,data=BrookTroutTH,ages2use=2:6)
summary(cr1)
summary(cr1,verbose=TRUE)
cbind(Est=coef(cr1),confint(cr1))
plot(cr1)
plot(cr1,axis.age="age")
plot(cr1,axis.age="recoded age")
summary(cr1,parm="Z")
cbind(Est=coef(cr1,parm="Z"),confint(cr1,parm="Z"))

## demonstration of excluding ages2use
cr2 &lt;- chapmanRobson(catch~age,data=BrookTroutTH,ages2use=-c(0,1))
summary(cr2)
plot(cr2)

## demonstration of ability to work with missing age classes
age &lt;- c(  2, 3, 4, 5, 7, 9,12)
ct  &lt;- c(100,92,83,71,56,35, 1)
cr3 &lt;- chapmanRobson(age,ct,4:12)
summary(cr3)
plot(cr3)

</code></pre>

<hr>
<h2 id='ChinookArg'>Lengths and weights for Chinook Salmon from three locations in Argentina.</h2><span id='topic+ChinookArg'></span>

<h3>Description</h3>

<p>Lengths and weights for Chinook Salmon from three locations in Argentina.
</p>


<h3>Format</h3>

<p>A data frame with 112 observations on the following 3 variables:
</p>

<dl>
<dt>tl</dt><dd><p>Total length (cm)</p>
</dd>
<dt>w</dt><dd><p>Weight (kg)</p>
</dd>
<dt>loc</dt><dd><p>Capture location (<code>Argentina</code>, <code>Petrohue</code>, <code>Puyehue</code>)</p>
</dd> 
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Weight-Length 
</p>
</li></ul>



<h3>Source</h3>

<p>From Figure 4 in Soto, D., I. Arismendi, C. Di Prinzio, and F. Jara. 2007. Establishment of Chinook Salmon (<em>Oncorhynchus tshawytscha</em>) in Pacific basins of southern South America and its potential ecosystem implications. Revista Chilena d Historia Natural, 80:81-98. [Was (is?) from http://www.scielo.cl/pdf/rchnat/v80n1/art07.pdf.] <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/ChinookArg.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+lwCompPreds">lwCompPreds</a></code> examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(ChinookArg)
head(ChinookArg)
op &lt;- par(mfrow=c(2,2),pch=19,mar=c(3,3,0.5,0.5),mgp=c(1.9,0.5,0),tcl=-0.2)
plot(w~tl,data=ChinookArg,subset=loc=="Argentina")
plot(w~tl,data=ChinookArg,subset=loc=="Petrohue")
plot(w~tl,data=ChinookArg,subset=loc=="Puyehue")
par(op)

</code></pre>

<hr>
<h2 id='CodNorwegian'>Stock and recruitment data for Norwegian cod, 1937-1960.</h2><span id='topic+CodNorwegian'></span>

<h3>Description</h3>

<p>Norwegian cod (<em>Gadus morhua</em>) stock and recruitment by year, 1937-1960.
</p>


<h3>Format</h3>

<p>A data frame of 24 observations on the following 3 variables:
</p>

<dl>
<dt>year</dt><dd><p>Year of data</p>
</dd>
<dt>recruits</dt><dd><p>Recruits &ndash; year-class strength index</p>
</dd>
<dt>stock</dt><dd><p>Spawning stock index</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Stock-Recruit
</p>
</li>
<li><p> Recruitment
</p>
</li></ul>



<h3>Source</h3>

<p>From Garrod, D.J. 1967. Population dynamics of the Arcto-Norwegian Cod. Journal of the Fisheries Research Board of Canada, 24:145-190. <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/CodNorwegian.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+srStarts">srStarts</a></code>, <code><a href="#topic+srFuns">srFuns</a></code>, and <code><a href="#topic+nlsTracePlot">nlsTracePlot</a></code> examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(CodNorwegian)
head(CodNorwegian)
op &lt;- par(mfrow=c(1,2),pch=19,mar=c(3,3,0.5,0.5),mgp=c(1.9,0.5,0),tcl=-0.2)
plot(recruits~year,data=CodNorwegian,type="l")
plot(recruits~stock,data=CodNorwegian)
par(op)

</code></pre>

<hr>
<h2 id='col2rgbt'>Converts an R color to RGB (red/green/blue) including a transparency (alpha channel).</h2><span id='topic+col2rgbt'></span>

<h3>Description</h3>

<p>Converts an R color to RGB (red/green/blue) including a transparency (alpha channel). Similar to <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code> except that a transparency (alpha channel) can be included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2rgbt(col, transp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col2rgbt_+3A_col">col</code></td>
<td>
<p>A vector of any of the three kinds of R color specifications (i.e., either a color name (as listed by <code><a href="grDevices.html#topic+colors">colors</a></code>()), a hexadecimal string of the form &quot;#rrggbb&quot; or &quot;#rrggbbaa&quot; (see <code><a href="grDevices.html#topic+rgb">rgb</a></code>), or a positive integer i meaning <code><a href="grDevices.html#topic+palette">palette</a></code>()[i].</p>
</td></tr>
<tr><td><code id="col2rgbt_+3A_transp">transp</code></td>
<td>
<p>A numeric vector that indicates the transparency level for the color. The transparency values must be greater than 0. Transparency values greater than 1 are interpreted as the number of points plotted on top of each other before the transparency is lost and is, thus, transformed to the inverse of the transparency value provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of hexadecimal strings of the form &quot;#rrggbbaa&quot; as would be returned by <code><a href="grDevices.html#topic+rgb">rgb</a></code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code> for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col2rgbt("black")
col2rgbt("black",1/4)
clrs &lt;- c("black","blue","red","green")
col2rgbt(clrs)
col2rgbt(clrs,1/4)
trans &lt;- (1:4)/5
col2rgbt(clrs,trans)

</code></pre>

<hr>
<h2 id='confint.boot'>Associated S3 methods for bootstrap results from car::Boot.</h2><span id='topic+confint.boot'></span><span id='topic+boot'></span><span id='topic+htest.boot'></span><span id='topic+hist.boot'></span><span id='topic+plot.boot'></span><span id='topic+predict.boot'></span>

<h3>Description</h3>

<p>S3 methods are provided to construct non-parametric bootstrap confidence intervals, predictions with non-parametric confidence intervals, hypothesis tests, and plots of the parameter estimates for objects returned from <code><a href="car.html#topic+Boot">Boot</a></code> from <span class="pkg">car</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'boot'
confint(
  object,
  parm = NULL,
  level = conf.level,
  conf.level = 0.95,
  type = c("bca", "norm", "basic", "perc"),
  plot = FALSE,
  err.col = "black",
  err.lwd = 2,
  rows = NULL,
  cols = NULL,
  ...
)

## S3 method for class 'boot'
htest(
  object,
  parm = NULL,
  bo = 0,
  alt = c("two.sided", "less", "greater"),
  plot = FALSE,
  ...
)

## S3 method for class 'boot'
predict(object, FUN, conf.level = 0.95, digits = NULL, ...)

## S3 method for class 'boot'
hist(
  x,
  same.ylim = TRUE,
  ymax = NULL,
  rows = round(sqrt(ncol(x$t))),
  cols = ceiling(sqrt(ncol(x$t))),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.boot_+3A_object">object</code>, <code id="confint.boot_+3A_x">x</code></td>
<td>
<p>An object of class <code>boot</code> from <code><a href="car.html#topic+Boot">Boot</a></code>.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_parm">parm</code></td>
<td>
<p>A number or string that indicates which column of <code>object</code> contains the parameter estimates to use for the confidence interval or hypothesis test.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_level">level</code></td>
<td>
<p>Same as <code>conf.level</code>.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_conf.level">conf.level</code></td>
<td>
<p>A level of confidence as a proportion.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_type">type</code></td>
<td>
<p>Confidence interval type; types implemented are the &quot;percentile&quot; method, which uses the function quantile to return the appropriate quantiles for the confidence limit specified, the default bca which uses the bias-corrected and accelerated method presented by Efron and Tibshirani (1993, Chapter 14). For the other types, see the documentation for <code><a href="boot.html#topic+boot">boot</a></code>.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_plot">plot</code></td>
<td>
<p>A logical that indicates whether a plot should be constructed. If <code>confint</code> then a histogram of the <code>parm</code> parameters from the bootstrap samples with error bars that illustrate the bootstrapped confidence intervals will be constructed. If codehtest then a histogram of the <code>parm</code> parameters with a vertical line illustrating the <code>bo</code> value will be constructed.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_err.col">err.col</code></td>
<td>
<p>A single numeric or character that identifies the color for the error bars on the plot.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_err.lwd">err.lwd</code></td>
<td>
<p>A single numeric that identifies the line width for the error bars on the plot.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_rows">rows</code></td>
<td>
<p>A single numeric that contains the number of rows to use on the graphic.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_cols">cols</code></td>
<td>
<p>A single numeric that contains the number of columns to use on the graphic.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_...">...</code></td>
<td>
<p>Additional items to send to functions. See details.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_bo">bo</code></td>
<td>
<p>The null hypothesized parameter value.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_alt">alt</code></td>
<td>
<p>A string that indicates the &ldquo;direction&rdquo; of the alternative hypothesis. See details.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied for the prediction. See the examples.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_digits">digits</code></td>
<td>
<p>A single numeric that indicates the number of digits for the result.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_same.ylim">same.ylim</code></td>
<td>
<p>A logical that indicates whether the same limits for the y-axis should be used on each histogram. Defaults to <code>TRUE</code>. Ignored if <code>ylmts</code> is non-null.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_ymax">ymax</code></td>
<td>
<p>A single value that sets the maximum y-axis limit for each histogram or a vector of length equal to the number of groups that sets the maximum y-axis limit for each histogram separately.</p>
</td></tr>
<tr><td><code id="confint.boot_+3A_col">col</code></td>
<td>
<p>A named color for the histogram bars.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint</code> is largely a wrapper for <code><a href="car.html#topic+Confint">Confint</a></code> from <span class="pkg">car</span> (see its manual page).
</p>
<p><code>predict</code> applies a user-supplied function to each row of <code>object</code> and then finds the median and the two quantiles that have the proportion (1-<code>conf.level</code>)/2 of the bootstrapped predictions below and above. The median is returned as the predicted value and the quantiles are returned as an approximate 100<code>conf.level</code>% confidence interval for that prediction. Values for the independent variable in <code>FUN</code> must be a named argument sent in the ... argument (see examples). Note that if other arguments are needed in <code>FUN</code> besides values for the independent variable, then these are included in the ... argument AFTER the values for the independent variable.
</p>
<p>In <code>htest</code> the &ldquo;direction&rdquo; of the alternative hypothesis is identified by a string in the <code>alt=</code> argument. The strings may be <code>"less"</code> for a &ldquo;less than&rdquo; alternative, <code>"greater"</code> for a &ldquo;greater than&rdquo; alternative, or <code>"two.sided"</code> for a &ldquo;not equals&rdquo; alternative (the DEFAULT). In the one-tailed alternatives the p-value is the proportion of bootstrapped parameter estimates in <code>object$coefboot</code> that are extreme of the null hypothesized parameter value in <code>bo</code>. In the two-tailed alternative the p-value is twice the smallest of the proportion of bootstrapped parameter estimates above or below the null hypothesized parameter value in <code>bo</code>.
</p>


<h3>Value</h3>

<p>If <code>object</code> is a matrix, then <code>confint</code> returns a matrix with as many rows as columns (i.e., parameter estimates) in <code>object</code> and two columns of the quantiles that correspond to the approximate confidence interval. If <code>object</code> is a vector, then <code>confint</code> returns a vector with the two quantiles that correspond to the approximate confidence interval.
</p>
<p><code>htest</code> returns a two-column matrix with the first column containing the hypothesized value sent to this function and the second column containing the corresponding p-value.
</p>
<p><code>hist</code> constructs histograms of the bootstrapped parameter estimates.
</p>
<p><code>plot</code> constructs scatterplots of all pairs of bootstrapped parameter estimates.
</p>
<p><code>predict</code> returns a matrix with one row and three columns, with the first column holding the predicted value (i.e., the median prediction) and the last two columns holding the approximate confidence interval.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>S. Weisberg (2005). <em>Applied Linear Regression</em>, third edition. New York: Wiley, Chapters 4 and 11.
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Boot">Boot</a></code> in <span class="pkg">car</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fnx &lt;- function(days,B1,B2,B3) {
  if (length(B1) &gt; 1) {
    B2 &lt;- B1[2]
    B3 &lt;- B1[3]
    B1 &lt;- B1[1]
  }
  B1/(1+exp(B2+B3*days))
}
nl1 &lt;- nls(cells~fnx(days,B1,B2,B3),data=Ecoli,
           start=list(B1=6,B2=7.2,B3=-1.45))

if (require(car)) {
  nl1.bootc &lt;- car::Boot(nl1,f=coef,R=99)  # R=99 too few to be useful
  confint(nl1.bootc,"B1")
  confint(nl1.bootc,c(2,3))
  confint(nl1.bootc,conf.level=0.90)
  confint(nl1.bootc,"B1",plot=TRUE)
  htest(nl1.bootc,1,bo=6,alt="less")
  htest(nl1.bootc,1,bo=6,alt="less",plot=TRUE)
  predict(nl1.bootc,fnx,days=1:3)
  predict(nl1.bootc,fnx,days=3)
  hist(nl1.bootc)
}

</code></pre>

<hr>
<h2 id='CutthroatAL'>Capture histories (9 samples) of Cutthroat Trout from Auke Lake.</h2><span id='topic+CutthroatAL'></span>

<h3>Description</h3>

<p>Individual capture histories of Cutthroat Trout (<em>Oncorhynchus clarki</em>) in Auke Lake, Alaska, from samples taken in 1998-2006.
</p>


<h3>Format</h3>

<p>A data frame with 1684 observations on the following 10 variables.
</p>

<dl>
<dt>id</dt><dd><p>Unique identification numbers for each fish</p>
</dd>
<dt>y1998</dt><dd><p>Indicator variable for whether the fish was captured in 1998 (<code>1</code>=captured)</p>
</dd>
<dt>y1999</dt><dd><p>Indicator variable for whether the fish was captured in 1999 (<code>1</code>=captured)</p>
</dd>
<dt>y2000</dt><dd><p>Indicator variable for whether the fish was captured in 2000 (<code>1</code>=captured)</p>
</dd>
<dt>y2001</dt><dd><p>Indicator variable for whether the fish was captured in 2001 (<code>1</code>=captured)</p>
</dd>
<dt>y2002</dt><dd><p>Indicator variable for whether the fish was captured in 2002 (<code>1</code>=captured)</p>
</dd>
<dt>y2003</dt><dd><p>Indicator variable for whether the fish was captured in 2003 (<code>1</code>=captured)</p>
</dd>
<dt>y2004</dt><dd><p>Indicator variable for whether the fish was captured in 2004 (<code>1</code>=captured)</p>
</dd>
<dt>y2005</dt><dd><p>Indicator variable for whether the fish was captured in 2005 (<code>1</code>=captured)</p>
</dd>
<dt>y2006</dt><dd><p>Indicator variable for whether the fish was captured in 2006 (<code>1</code>=captured)</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Population Size
</p>
</li>
<li><p> Abundance
</p>
</li>
<li><p> Mark-Recapture
</p>
</li>
<li><p> Capture-Recapture
</p>
</li>
<li><p> Jolly-Seber
</p>
</li>
<li><p> Capture History 
</p>
</li></ul>



<h3>Note</h3>

<p>Entered into &ldquo;RMark&rdquo; format (see <code><a href="FSAdata.html#topic+CutthroatALf">CutthroatALf</a></code> in <span class="pkg">FSAdata</span>) and then converted to individual format with <code><a href="#topic+capHistConvert">capHistConvert</a></code>
</p>


<h3>Source</h3>

<p>From Appendix A.3 of Harding, R.D., C.L. Hoover, and R.P. Marshall. 2010. Abundance of Cutthroat Trout in Auke Lake, Southeast Alaska, in 2005 and 2006. Alaska Department of Fish and Game Fisheries Data Series No. 10-82. [Was (is?) from http://www.sf.adfg.state.ak.us/FedAidPDFs/FDS10-82.pdf.] <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/CutthroatAL.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+mrOpen">mrOpen</a></code> examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(CutthroatAL)
head(CutthroatAL)

</code></pre>

<hr>
<h2 id='depletion'>Computes the Leslie or DeLury population estimate from catch and effort data.</h2><span id='topic+depletion'></span><span id='topic+plot.depletion'></span><span id='topic+summary.depletion'></span><span id='topic+coef.depletion'></span><span id='topic+anova.depletion'></span><span id='topic+confint.depletion'></span><span id='topic+rSquared.depletion'></span>

<h3>Description</h3>

<p>Computes the Leslie or DeLury estimates of population size and catchability coefficient from paired catch and effort data. The Ricker modification may also be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depletion(
  catch,
  effort,
  method = c("Leslie", "DeLury", "Delury"),
  Ricker.mod = FALSE
)

## S3 method for class 'depletion'
summary(object, parm = c("all", "both", "No", "q", "lm"), verbose = FALSE, ...)

## S3 method for class 'depletion'
coef(object, parm = c("all", "both", "No", "q", "lm"), ...)

## S3 method for class 'depletion'
confint(
  object,
  parm = c("all", "both", "No", "q", "lm"),
  level = conf.level,
  conf.level = 0.95,
  ...
)

## S3 method for class 'depletion'
anova(object, ...)

## S3 method for class 'depletion'
rSquared(object, digits = getOption("digits"), percent = FALSE, ...)

## S3 method for class 'depletion'
plot(
  x,
  xlab = NULL,
  ylab = NULL,
  pch = 19,
  col.pt = "black",
  col.mdl = "gray70",
  lwd = 1,
  lty = 1,
  pos.est = "topright",
  cex.est = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depletion_+3A_catch">catch</code></td>
<td>
<p>A numeric vector of catches of fish at each time.</p>
</td></tr>
<tr><td><code id="depletion_+3A_effort">effort</code></td>
<td>
<p>A numeric vector of efforts expended at each time.</p>
</td></tr>
<tr><td><code id="depletion_+3A_method">method</code></td>
<td>
<p>A single string that indicates which depletion method to use</p>
</td></tr>
<tr><td><code id="depletion_+3A_ricker.mod">Ricker.mod</code></td>
<td>
<p>A single logical that indicates whether to use the modification proposed by Ricker (=TRUE) or not (=FALSE, default).</p>
</td></tr>
<tr><td><code id="depletion_+3A_object">object</code></td>
<td>
<p>An object saved from the <code>removal</code> call (i.e., of class <code>depletion</code>).</p>
</td></tr>
<tr><td><code id="depletion_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="depletion_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates whether a reminder of the method used should be printed with the summary results.</p>
</td></tr>
<tr><td><code id="depletion_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="depletion_+3A_level">level</code></td>
<td>
<p>Same as <code>conf.level</code> but used for compatibility with generic <code>confint</code> function.</p>
</td></tr>
<tr><td><code id="depletion_+3A_conf.level">conf.level</code></td>
<td>
<p>A single number that represents the level of confidence to use for constructing confidence intervals.</p>
</td></tr>
<tr><td><code id="depletion_+3A_digits">digits</code></td>
<td>
<p>The number of digits to round the <code>rSquared</code> result to.</p>
</td></tr>
<tr><td><code id="depletion_+3A_percent">percent</code></td>
<td>
<p>A logical that indicates if the <code>rSquared</code> result should be returned as a percentage (<code>=TRUE</code>) or as a proportion (<code>=FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="depletion_+3A_x">x</code></td>
<td>
<p>An object saved from the <code>depletion</code> call (i.e., of class <code>depletion</code>).</p>
</td></tr>
<tr><td><code id="depletion_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x-axis.</p>
</td></tr>
<tr><td><code id="depletion_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y-axis.</p>
</td></tr>
<tr><td><code id="depletion_+3A_pch">pch</code></td>
<td>
<p>A numeric that indicates the type of plotting character.</p>
</td></tr>
<tr><td><code id="depletion_+3A_col.pt">col.pt</code></td>
<td>
<p>A string that indicates the color of the plotted points.</p>
</td></tr>
<tr><td><code id="depletion_+3A_col.mdl">col.mdl</code></td>
<td>
<p>A string that indicates the color of the fitted line.</p>
</td></tr>
<tr><td><code id="depletion_+3A_lwd">lwd</code></td>
<td>
<p>A numeric that indicates the line width of the fitted line.</p>
</td></tr>
<tr><td><code id="depletion_+3A_lty">lty</code></td>
<td>
<p>A numeric that indicates the type of line used for the fitted line.</p>
</td></tr>
<tr><td><code id="depletion_+3A_pos.est">pos.est</code></td>
<td>
<p>A single string to identify where to place the estimated population estimate and catchability on the plot. Can be set to one of <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code> or <code>"center"</code> for positioning the estimated mortality rates on the plot. Typically <code>"bottomleft"</code> (DEFAULT) and <code>"topright"</code> will be &ldquo;out-of-the-way&rdquo; placements. Set <code>pos.est</code> to <code>NULL</code> to remove the estimated population size and catchability coefficient from the plot.</p>
</td></tr>
<tr><td><code id="depletion_+3A_cex.est">cex.est</code></td>
<td>
<p>A single numeric that identifies the character expansion value for the estimated population estimate and catchability placed on the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the Leslie method, a linear regression model of catch-per-unit-effort on cumulative catch prior to the sample is fit. The catchability coefficient (q) is estimated from the negative of the slope and the initial population size (No) is estimated by dividing the intercept by the catchability coefficient. If <code>Ricker.mod=TRUE</code> then the cumulative catch is modified to be the cumulative catch prior to the sample plus half of the catch of the current sample.
</p>
<p>For the DeLury method, a linear regression model of log (catch-per-unit-effort) on cumulative effort is fit. The catchability coefficient (q) is estimated from the negative of the slope and the initial population size (No) is estimated by dividing the intercept as an exponent of e by the catchability coefficient. If <code>Ricker.mod=TRUE</code> then the cumulative effort is modified to be the cumulative effort prior to the sample plus half of the effort of the current sample.
</p>
<p>Standard errors for the catchability and population size estimates are computed from formulas on page 298 (for Leslie) and 303 (for DeLury) from Seber (2002). Confidence intervals are computed using standard large-sample normal distribution theory with the regression error df.
</p>


<h3>Value</h3>

<p>A list with the following items:
</p>

<ul>
<li><p> method A string that indicates whether the <code>"Leslie"</code> or <code>"DeLury"</code> model was used.
</p>
</li>
<li><p> catch The original vector of catches.
</p>
</li>
<li><p> effort The original vector of efforts.
</p>
</li>
<li><p> cpe A computed vector of catch-per-unit-effort for each time.
</p>
</li>
<li><p> KorE A computed vector of cumulative catch (K; Leslie method) or effort (E; DeLury method).
</p>
</li>
<li><p> lm The <code>lm</code> object from the fit of CPE on K (Leslie method) or log(CPE) on E (DeLury method).
</p>
</li>
<li><p> est A 2x2 matrix that contains the estimates and standard errors for No and q.
</p>
</li></ul>



<h3>testing</h3>

<p>The Leslie method without the Ricker modification and the DeLury method with the Ricker modification matches the results from <code><a href="fishmethods.html#topic+deplet">deplet</a></code> in <span class="pkg">fishmethods</span> for the <code><a href="fishmethods.html#topic+darter">darter</a></code> (from <span class="pkg">fishmethods</span>), <code><a href="FSAdata.html#topic+LobsterPEI">LobsterPEI</a></code> and <code><a href="FSAdata.html#topic+BlueCrab">BlueCrab</a></code> from <span class="pkg">FSAdata</span>, and <code><a href="#topic+SMBassLS">SMBassLS</a></code> for N0 to whole numbers, the SE for No to one decimal, q to seven decimals, and the SE of q to at least five decimals.
</p>
<p>The Leslie method matches the results of Seber (2002) for N0, q, and the CI for Q but not the CI for N (which was so far off that it might be that Seber's result is incorrect) for the lobster data and the q and CI for q but the NO or its CI (likely due to lots of rounding in Seber 2002) for the Blue Crab data.
</p>
<p>The Leslie and DeLury methods match the results of Ricker (1975) for No and Q but not for the CI of No (Ricker used a very different method to compute CIs).
</p>


<h3>IFAR Chapter</h3>

<p>10-Abundance from Depletion Data.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Ricker, W.E. 1975. Computation and interpretation of biological statistics of fish populations. Technical Report Bulletin 191, Bulletin of the Fisheries Research Board of Canada. [Was (is?) from http://www.dfo-mpo.gc.ca/Library/1485.pdf.]
</p>
<p>Seber, G.A.F. 2002. The Estimation of Animal Abundance. Edward Arnold, Second edition (reprinted).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+removal">removal</a></code> for related functionality and <code><a href="fishmethods.html#topic+deplet">deplet</a></code> in <span class="pkg">fishmethods</span> for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Leslie model examples
# no Ricker modification
l1 &lt;- depletion(SMBassLS$catch,SMBassLS$effort,method="Leslie")
summary(l1)
summary(l1,verbose=TRUE)
summary(l1,parm="No")
rSquared(l1)
rSquared(l1,digits=1,percent=TRUE)
cbind(Est=coef(l1),confint(l1))
cbind(Est=coef(l1,parm="No"),confint(l1,parm="No"))
cbind(Est=coef(l1,parm="q"),confint(l1,parm="q"))
summary(l1,parm="lm")
plot(l1)

# with Ricker modification
l2 &lt;- depletion(SMBassLS$catch,SMBassLS$effort,method="Leslie",Ricker.mod=TRUE)
summary(l2)
cbind(Est=coef(l2),confint(l1))
plot(l2)

## DeLury model examples
# no Ricker modification
d1 &lt;- depletion(SMBassLS$catch,SMBassLS$effort,method="DeLury")
summary(d1)
summary(d1,parm="q")
summary(d1,verbose=TRUE)
rSquared(d1)
cbind(Est=coef(d1),confint(d1))
summary(d1,parm="lm")
plot(d1)

# with Ricker modification
d2 &lt;- depletion(SMBassLS$catch,SMBassLS$effort,method="DeLury",Ricker.mod=TRUE)
summary(d2)
cbind(Est=coef(d2),confint(d2))
cbind(Est=coef(d2,parm="q"),confint(d2,parm="q"))
plot(d2)

</code></pre>

<hr>
<h2 id='dunnTest'>Dunn's Kruskal-Wallis Multiple Comparisons.</h2><span id='topic+dunnTest'></span><span id='topic+dunnTest.default'></span><span id='topic+dunnTest.formula'></span><span id='topic+print.dunnTest'></span>

<h3>Description</h3>

<p>Performs Dunn's (1964) test of multiple comparisons following a significant Kruskal-Wallis test, possibly with a correction to control the experimentwise error rate. This is largely a wrapper for the <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> function in <span class="pkg">dunn.test</span>. Please see and cite that package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dunnTest(x, ...)

## Default S3 method:
dunnTest(
  x,
  g,
  method = dunn.test::p.adjustment.methods[c(4, 2:3, 5:8, 1)],
  two.sided = TRUE,
  altp = two.sided,
  ...
)

## S3 method for class 'formula'
dunnTest(
  x,
  data = NULL,
  method = dunn.test::p.adjustment.methods[c(4, 2:3, 5:8, 1)],
  two.sided = TRUE,
  altp = two.sided,
  ...
)

## S3 method for class 'dunnTest'
print(x, dunn.test.results = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dunnTest_+3A_x">x</code></td>
<td>
<p>A numeric vector of data values or a formula of the form x~g.</p>
</td></tr>
<tr><td><code id="dunnTest_+3A_...">...</code></td>
<td>
<p>Not yet used.</p>
</td></tr>
<tr><td><code id="dunnTest_+3A_g">g</code></td>
<td>
<p>A factor vector or a (non-numeric) vector that can be coerced to a factor vector.</p>
</td></tr>
<tr><td><code id="dunnTest_+3A_method">method</code></td>
<td>
<p>A single string that identifies the method used to control the experimentwise error rate. See the list of methods in <code>p.adjustment.methods</code> (documented with <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code>) in <span class="pkg">dunn.test</span>.</p>
</td></tr>
<tr><td><code id="dunnTest_+3A_two.sided">two.sided</code></td>
<td>
<p>A single logical that indicates whether a two-sided p-value should be returned (<code>TRUE</code>; default) or not. See details.</p>
</td></tr>
<tr><td><code id="dunnTest_+3A_altp">altp</code></td>
<td>
<p>Same as <code>two.sided</code>. Allows similar code with the <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> function in <span class="pkg">dunn.test</span>. <code>two.sided</code> is maintained because it pre-dates <code>altp</code>.</p>
</td></tr>
<tr><td><code id="dunnTest_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains <code>x</code> and <code>g</code>.</p>
</td></tr>
<tr><td><code id="dunnTest_+3A_dunn.test.results">dunn.test.results</code></td>
<td>
<p>A single logical that indicates whether the results that would have been printed by <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> function in <span class="pkg">dunn.test</span> are shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs &ldquo;Dunn's&rdquo; test of multiple comparisons following a Kruskal-Wallis test. Unadjusted one- or two-sided p-values for each pairwise comparison among groups are computed following Dunn's description as implemented in the <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> function from <span class="pkg">dunn.test</span>. These p-values may be adjusted using methods in the <code>p.adjustment.methods</code> function in <span class="pkg">dunn.test</span>.
</p>
<p>This function is largely a wrapper for the <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> function in <span class="pkg">dunn.test</span>. Changes here are the possible use of formula notation, results not printed by the main function (but are printed in a more useful format (in my opinion) by the <code>print</code> function), the p-values are adjusted by default with the &ldquo;holm&rdquo; method, and two-sided p-values are returned by default. See <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> function in <span class="pkg">dunn.test</span> for more details underlying these computations.
</p>


<h3>Value</h3>

<p>A list with three items &ndash; <code>method</code> is the long name of the method used to control the experimentwise error rate, <code>dtres</code> is the strings that would have been printed by the <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> function in <span class="pkg">dunn.test</span>, and <code>res</code> is a data.frame with the following variables:
</p>

<ul>
<li><p> Comparison: Labels for each pairwise comparison.
</p>
</li>
<li><p> Z: Values for the Z test statistic for each comparison.
</p>
</li>
<li><p> P.unadj: Unadjusted p-values for each comparison.
</p>
</li>
<li><p> P.adj: Adjusted p-values for each comparison.
</p>
</li></ul>



<h3>Note</h3>

<p>The data.frame will be reduced to only those rows that are complete cases for <code>x</code> and <code>g</code>. In other words, rows with missing data for either <code>x</code> or <code>g</code> are removed from the analysis and a warning will be issued.
</p>
<p>There are a number of functions in other packages that do similar analyses.
</p>
<p>The results from <code>DunnTest</code> match the results (in a different format) from the <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> function from <span class="pkg">dunn.test</span>.
</p>
<p>The <code>pairw.kw</code> function from the <span class="pkg">asbio</span> package performs the Dunn test with the Bonferroni correction. The <code>pairw.kw</code> also provides a confidence interval for the difference in mean ranks between pairs of groups. The p-value results from <code>DunnTest</code> match the results from <code>pairw.kw</code>.
</p>
<p>The <code>posthoc.kruskal.nemenyi.test</code> function from the <span class="pkg">PMCMR</span> package uses the &ldquo;Nemenyi&rdquo; (1963) method of multiple comparisons.
</p>
<p>The <code>kruskalmc</code> function from the <span class="pkg">pgirmess</span> package uses the method described by Siegel and Castellan (1988).
</p>
<p>It is not clear which method <code>kruskal</code> from the <span class="pkg">agricolae</span> package uses. It does not seem to output p-values but it does allow for a wide variety of methods to control the experimentwise error rate.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>, but this is largely a wrapper (see details) for <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> in <span class="pkg">dunn.test</span> written by Alexis Dinno.
</p>


<h3>References</h3>

<p>Dunn, O.J. 1964. Multiple comparisons using rank sums. Technometrics 6:241-252.
</p>


<h3>See Also</h3>

<p>See <code>kruskal.test</code>, <code><a href="dunn.test.html#topic+dunn.test">dunn.test</a></code> in <span class="pkg">dunn.test</span>, <code>posthoc.kruskal.nemenyi.test</code> in <span class="pkg">PMCMR</span>, <code>kruskalmc</code> in <span class="pkg">pgirmess</span>, and <code>kruskal</code> in <span class="pkg">agricolae</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## pH in four ponds data from Zar (2010)
ponds &lt;- data.frame(pond=as.factor(rep(1:4,each=8)),
                    pH=c(7.68,7.69,7.70,7.70,7.72,7.73,7.73,7.76,
                         7.71,7.73,7.74,7.74,7.78,7.78,7.80,7.81,
                         7.74,7.75,7.77,7.78,7.80,7.81,7.84,NA,
                         7.71,7.71,7.74,7.79,7.81,7.85,7.87,7.91))
ponds2 &lt;- ponds[complete.cases(ponds),]

# non-formula usage (default "holm" method)
dunnTest(ponds2$pH,ponds2$pond)

# formula usage (default "holm" method)
dunnTest(pH~pond,data=ponds2)

# other methods
dunnTest(pH~pond,data=ponds2,method="bonferroni")
dunnTest(pH~pond,data=ponds2,method="bh")
dunnTest(pH~pond,data=ponds2,method="none")

# one-sided
dunnTest(pH~pond,data=ponds2,two.sided=FALSE)

# warning message if incomplete cases were removed
dunnTest(pH~pond,data=ponds)

# print dunn.test results
tmp &lt;- dunnTest(pH~pond,data=ponds2)
print(tmp,dunn.test.results=TRUE)

</code></pre>

<hr>
<h2 id='Ecoli'>Population growth of Escherichia coli.</h2><span id='topic+Ecoli'></span>

<h3>Description</h3>

<p>The number of <em>Escherichia coli</em> cells versus time.
</p>


<h3>Format</h3>

<p>A data frame with 8 observations on the following 2 variables:
</p>

<dl>
<dt>days</dt><dd><p>Elapsed duration of the experiment</p>
</dd>
<dt>cells</dt><dd><p>Number of cells in the population</p>
</dd> 
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Nonlinear Model
</p>
</li>
<li><p> Other
</p>
</li></ul>



<h3>Source</h3>

<p>McKendrick, A.G. and M. Kesava Pai. 1911. The Rate of Multiplication of Micro-Organisms: a Mathematical Study. Proceedings of the Royal Society of Edinburgh. 31:649-655. <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/Ecoli.csv">CSV file</a>
</p>

<hr>
<h2 id='expandCounts'>Repeat individual fish data (including lengths) from tallied counts.</h2><span id='topic+expandCounts'></span>

<h3>Description</h3>

<p>Repeat individual fish data, including lengths, from tallied counts and, optionally, add a random digit to length measurements to simulate actual length of fish in the bin. This is useful as a precursor to summaries that require information, e.g., lengths, of individual fish (e.g., length frequency histograms, means lengths).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandCounts(
  data,
  cform,
  lform = NULL,
  removeCount = TRUE,
  lprec = 0.1,
  new.name = "newlen",
  cwid = 0,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandCounts_+3A_data">data</code></td>
<td>
<p>A data.frame that contains variables in <code>cform</code> and <code>lform</code>.</p>
</td></tr>
<tr><td><code id="expandCounts_+3A_cform">cform</code></td>
<td>
<p>A formula of the form <code>~countvar</code> where <code>countvar</code> generically represents the variable in <code>data</code> that contains the counts of individuals. See details.</p>
</td></tr>
<tr><td><code id="expandCounts_+3A_lform">lform</code></td>
<td>
<p>An optional formula of the form <code>~lowerbin+upperbin</code> where <code>lowerbin</code> and <code>upperbin</code> generically represent the variables in <code>data</code> that identify the lower- and upper-values of the length bins. See details.</p>
</td></tr>
<tr><td><code id="expandCounts_+3A_removecount">removeCount</code></td>
<td>
<p>A single logical that indicates if the variable that contains the counts of individuals (as given in <code>cform</code>) should be removed form the returned data.frame. The default is <code>TRUE</code> such that the variable will be removed as the returned data.frame contains individuals and the counts of individuals in tallied bins is not relevant to an individual.</p>
</td></tr>
<tr><td><code id="expandCounts_+3A_lprec">lprec</code></td>
<td>
<p>A single numeric that controls the precision to which the random lengths are recorded. See details.</p>
</td></tr>
<tr><td><code id="expandCounts_+3A_new.name">new.name</code></td>
<td>
<p>A single string that contains a name for the new length variable if random lengths are to be created.</p>
</td></tr>
<tr><td><code id="expandCounts_+3A_cwid">cwid</code></td>
<td>
<p>A single positive numeric that will be added to the lower length bin value in instances where the count exceeds one but only a lower (and not an upper) length were recorded. See details.</p>
</td></tr>
<tr><td><code id="expandCounts_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether progress message should be printed or not.</p>
</td></tr>
<tr><td><code id="expandCounts_+3A_...">...</code></td>
<td>
<p>Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fisheries data may be recorded as tallied counts in the field. For example, field biologists may have simply recorded that there were 10 fish in one group, 15 in another, etc. More specifically, the biologist may have recorded that there were 10 male Bluegill from the first sampling event between 100 and 124 mm, 15 male Bluegill from the first sampling event between 125 and 149 mm, and so on. At times, it may be necessary to expand these counts such that the repeated information appears in individual rows in a new data.frame. In this specific example, the tallied counts would be repeated such that the male, Bluegill, first sampling event, 100-124 mm information would be repeated 10 times; the male, Bluegill, first sampling event, 125-149 mm information would be repeated 15 times, and so on. This function facilitates this type of expansion.
</p>
<p>Length data has often been collected in a &ldquo;binned-and-tallied&rdquo; format (e.g., 10 fish in the 100-124 mm group, 15 in the 125-149 mm group, etc.). This type of data collection does not facilitate easy or precise calculations of summary statistics of length (i.e., mean and standard deviations of length). Expanding the data as described above does not solve this problem because the length data are still essentially categorical (i.e., which group the fish belongs to rather than what it's actual length is). To facilitate computation of summary statistics, the data can be expanded as described above and then a length can be randomly selected from within the recorded length bin to serve as a &ldquo;measured&rdquo; length for that fish. This function performs this type of expansion by randomly selecting the length from a uniform distribution within the length bin (e.g., each value between 100 and 124 mm has the same probability of being selected).
</p>
<p>This function makes some assumptions for some coding situations. First, it assumes that all <code>lowerbin</code> values are actually lower than all <code>upperbin</code> values. The function will throw an error if this is not true. Second, it assumes that if a <code>lowerbin</code> but no <code>upperbin</code> value is given then the <code>lowerbin</code> value is the exact measurement for those fish. Third, it assumes that if an <code>upperbin</code> but no <code>lowerbin</code> value is given that this is a data entry error and that the <code>upperbin</code> value should be the <code>lowerbin</code> value. Fourth, it assumes that it is a data entry error if <code>varcount</code> is zero or <code>NA</code> and <code>lowerbin</code> or <code>upperbin</code> contains values (i.e., why would there be lengths if no fish were captured?).
</p>


<h3>Value</h3>

<p>A data.frame of the same structure as <code>data</code> except that the variable in <code>cform</code> may be deleted and the variable in <code>new.name</code> may be added. The returned data.frame will have more rows than <code>data</code> because of the potential addition of new individuals expanded from the counts in <code>cform</code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+expandLenFreq">expandLenFreq</a></code> for expanding length frequencies where individual fish measurements were made on individual fish in a subsample and the remaining fish were simply counted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># all need expansion
( d1 &lt;- data.frame(name=c("Johnson","Johnson","Jones","Frank","Frank","Max"),
                   lwr.bin=c(15,15.5,16,16,17,17),
                   upr.bin=c(15.5,16,16.5,16.5,17.5,17.5),
                   freq=c(6,4,2,3,1,1)) )
expandCounts(d1,~freq)
expandCounts(d1,~freq,~lwr.bin+upr.bin)

# some need expansion
( d2 &lt;- data.frame(name=c("Johnson","Johnson","Jones","Frank","Frank","Max"),
                   lwr.bin=c(15,15.5,16,16,17.1,17.3),
                   upr.bin=c(15.5,16,16.5,16.5,17.1,17.3),
                   freq=c(6,4,2,3,1,1)) )
expandCounts(d2,~freq)
expandCounts(d2,~freq,~lwr.bin+upr.bin)

# none need expansion
( d3 &lt;- data.frame(name=c("Johnson","Johnson","Jones","Frank","Frank","Max"),
                   lwr.bin=c(15,15.5,16,16,17.1,17.3),
                   upr.bin=c(15,15.5,16,16,17.1,17.3),
                   freq=c(6,4,2,3,1,1)) )
expandCounts(d3,~freq)
expandCounts(d3,~freq,~lwr.bin+upr.bin)

# some need expansion, but different bin widths
( d4 &lt;- data.frame(name=c("Johnson","Johnson","Jones","Frank","Frank","Max"),
                   lwr.bin=c(15,  15,  16,  16,  17.1,17.3),
                   upr.bin=c(15.5,15.9,16.5,16.9,17.1,17.3),
                   freq=c(6,4,2,3,1,1)) )
expandCounts(d4,~freq)
expandCounts(d4,~freq,~lwr.bin+upr.bin)

# some need expansion but include zeros and NAs for counts
( d2a &lt;- data.frame(name=c("Johnson","Johnson","Jones","Frank","Frank","Max","Max","Max","Max"),
                    lwr.bin=c(15,  15.5,16  ,16  ,17.1,17.3,NA,NA,NA),
                    upr.bin=c(15.5,16  ,16.5,16.5,17.1,17.3,NA,NA,NA),
                    freq=c(6,4,2,3,1,1,NA,0,NA)) )
expandCounts(d2a,~freq,~lwr.bin+upr.bin)
 
# some need expansion but include NAs for upper values
( d2b &lt;- data.frame(name=c("Johnson","Johnson","Jones","Frank","Frank","Max"),
                    lwr.bin=c(15,  15.5,16  ,16  ,17.1,17.3),
                    upr.bin=c(NA  ,NA  ,16.5,16.5,17.1,17.3),
                    freq=c(6,4,2,3,1,1)) )
expandCounts(d2b,~freq,~lwr.bin+upr.bin)
 
# some need expansion but include NAs for upper values
( d2c &lt;- data.frame(name=c("Johnson","Johnson","Jones","Frank","Frank","Max"),
                    lwr.bin=c(NA,NA,  16  ,16  ,17.1,17.3),
                    upr.bin=c(15,15.5,16.5,16.5,17.1,17.3),
                    freq=c(6,4,2,3,1,1)) )
expandCounts(d2c,~freq,~lwr.bin+upr.bin)

## Not run: 
##!!##!!## Change path to where example file is and then run to demo

## Read in datafile (note periods in names)
df &lt;- read.csv("c:/aaawork/consulting/R_WiDNR/Statewide/Surveysummaries2010.csv")
str(df) 
## narrow variables for simplicity
df1 &lt;- df[,c("County","Waterbody.Name","Survey.Year","Gear","Species",
             "Number.of.Fish","Length.or.Lower.Length.IN","Length.Upper.IN",
             "Weight.Pounds","Gender")]
## Sum the count to see how many fish there should be after expansion
sum(df1$Number.of.Fish)

## Simple expansion
df2 &lt;- expandCounts(df1,~Number.of.Fish)

## Same expansion but include random component to lengths (thus new variable)
##   also note default lprec=0.1
df3 &lt;- expandCounts(df1,~Number.of.Fish,~Length.or.Lower.Length.IN+Length.Upper.IN)


## End(Not run)

</code></pre>

<hr>
<h2 id='expandLenFreq'>Expands a length frequency based on a subsample.</h2><span id='topic+expandLenFreq'></span>

<h3>Description</h3>

<p>Creates a vector of lengths for the individuals not measured based on the lengths measured in a subsample of individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandLenFreq(
  x,
  w,
  additional,
  startcat = NULL,
  total = additional + length(x),
  decimals = decs$wdec,
  show.summary = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandLenFreq_+3A_x">x</code></td>
<td>
<p>A numeric vector of length measurements.</p>
</td></tr>
<tr><td><code id="expandLenFreq_+3A_w">w</code></td>
<td>
<p>A number that indicates the width of length classes to create.</p>
</td></tr>
<tr><td><code id="expandLenFreq_+3A_additional">additional</code></td>
<td>
<p>The number of individuals that were not measured in the sample (for which measurements should be determined).</p>
</td></tr>
<tr><td><code id="expandLenFreq_+3A_startcat">startcat</code></td>
<td>
<p>A number that indicates the beginning of the first length-class.</p>
</td></tr>
<tr><td><code id="expandLenFreq_+3A_total">total</code></td>
<td>
<p>The total number of individuals in the sample (including those that were measured in the subsample).</p>
</td></tr>
<tr><td><code id="expandLenFreq_+3A_decimals">decimals</code></td>
<td>
<p>A number that indicates the number of decimals used in the output vector of estimated lengths.</p>
</td></tr>
<tr><td><code id="expandLenFreq_+3A_show.summary">show.summary</code></td>
<td>
<p>A logical that indicates whether a summary of the process should be shown at the end.</p>
</td></tr>
<tr><td><code id="expandLenFreq_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+lencat">lencat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a vector of lengths for the individuals not measured based on the lengths measured in a subsample of individuals. Length categories are created first that begin with the value in <code>startcat</code> (or the minimum observed value by default) and continue by values of <code>w</code> until a category value greater than the largest observed length in <code>x</code>. Categories of different widths are not allowed.
</p>
<p>The resulting &ldquo;expanded&rdquo; lengths are created by allocating individuals to each length class based on the proportion of measured individuals in the subsample in that length class. Individuals within a length class are then assigned a specific length within that length class based on a uniform distribution. Because the expanded number of individuals in a length class is rounded down based on the measured number per length class, not all individuals will initially be assigned a length value. The remaining individuals are assigned to a length class randomly according to weights based on the proportion of individuals in the measured length classes. Finally, these individuals are randomly assigned a specific length within the respective length class from a uniform distribution, same as above.
</p>
<p>The resulting length assignments are rounded to the number of decimals shown in <code>decimal</code>. If <code>decimals</code> is not set by the user then it will default to the same number of decimals shown in the <code>w</code> value. Care is taken to make sure that the rounded result will not pass out of the given length category (i.e., will not be allowed to round up to the next length category). Generally speaking, one will want to use more decimals then is shown in <code>w</code>. For example, one may want to create length categories with a width of 1 inch (i.e., <code>w=1</code>) but have the results recorded as if measured to within 0.1 inch (i.e., <code>decimals=1</code>).
</p>


<h3>Value</h3>

<p>Returns a vector that consists of measurements for the non-measured individuals in the entire sample.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+expandCounts">expandCounts</a></code> for expanding more than just lengths or expanding lengths when there is a known number in each length bin. See <code><a href="#topic+lencat">lencat</a></code> for creating length bins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set the random seed for reproducibility
set.seed(15343437)

## First example
# random lengths measured to nearest 0.1 unit -- values in a vector
len1 &lt;- round(runif(50,0.1,9.9),1)
# assignment of integer lengths to 110 non-measured individuals
new.len1a &lt;- expandLenFreq(len1,w=1,total=160)
new.len1a
# assignment of lengths to 0.1 to 110 non-measured individuals
new.len1b &lt;- expandLenFreq(len1,w=1,total=160,decimals=1)
new.len1b

## Second example -- if values are in a data.frame
# random lengths measured to nearest 0.1 unit
len2 &lt;- data.frame(len=round(runif(50,10,117),1))
# assignment of lengths to 0.1 for 140 non-measured indivs
new.len2a &lt;- expandLenFreq(len2$len,w=10,total=190,decimals=1)
new.len2a

## Third example
# hypothetically measured lengths
len &lt;- c(6.7,6.9,7.3,7.4,7.5,8.2,8.7,8.9)
# find lengths for unmeasured fish assuming a total of 30
newlen1 &lt;- expandLenFreq(len,w=0.5,total=30,decimals=1)
newlen1
# set a starting length category
newlen2 &lt;- expandLenFreq(len,w=0.5,startcat=6.2,total=30,decimals=1)
newlen2

</code></pre>

<hr>
<h2 id='extraTests'>Likelihood ratio and extra sum-of-squares tests.</h2><span id='topic+extraTests'></span><span id='topic+lrt'></span><span id='topic+extraSS'></span><span id='topic+print.extraTest'></span>

<h3>Description</h3>

<p>Likelihood ratio and extra sum-of-squares tests with multiple <code>lm</code> or <code>nls</code> models nested within one common model. This function is most useful when the nested functions are all at the same level; otherwise use <code>anova()</code> or <code>lrtest()</code> which are more flexible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrt(sim, ..., com, sim.names = sim.name, sim.name = NULL, com.name = NULL)

extraSS(sim, ..., com, sim.names = sim.name, sim.name = NULL, com.name = NULL)

## S3 method for class 'extraTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extraTests_+3A_sim">sim</code></td>
<td>
<p>The results of one <code>lm</code> or <code>nls</code> model, for example, that is a nested subset of the model in <code>com=</code>.</p>
</td></tr>
<tr><td><code id="extraTests_+3A_...">...</code></td>
<td>
<p>More model results that are nested subsets of the model in <code>com=</code>.</p>
</td></tr>
<tr><td><code id="extraTests_+3A_com">com</code></td>
<td>
<p>The results of one <code>lm</code> or <code>nls</code> model, for example, that the models in <code>sim=</code> and <code>...</code> are a subset of.</p>
</td></tr>
<tr><td><code id="extraTests_+3A_sim.name">sim.name</code>, <code id="extraTests_+3A_sim.names">sim.names</code></td>
<td>
<p>A string vector of &ldquo;names&rdquo; for simple model in <code>sim=</code> and <code>...</code>. <code>sim.names</code> is preferred but <code>sim.name</code> is allowed to allow for a common typing mistake.</p>
</td></tr>
<tr><td><code id="extraTests_+3A_com.name">com.name</code></td>
<td>
<p>A single &ldquo;name&rdquo; string for the complex model in <code>com=</code>.</p>
</td></tr>
<tr><td><code id="extraTests_+3A_x">x</code></td>
<td>
<p>An object from <code>lrt()</code> or <code>extraSS()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="stats.html#topic+anova">anova</a></code> and <code><a href="lmtest.html#topic+lrtest">lrtest</a></code> (from <span class="pkg">lmtest</span>) provide simple methods for conducting extra sum-of-squares or likelihood ratio tests when one model is nested within another model or when there are several layers of simple models all sequentially nested within each other. However, to compare several models that are nested at the same level with one common more complex model, then <code>anova()</code> and <code>lrtest()</code> must be repeated for each comparison. This repetition can be eliminated with <code>lapply()</code> but then the output is voluminous. This function is designed to remove the repetitiveness and to provide output that is compact and easy to read.
</p>


<h3>Value</h3>

<p>The main function returns a matrix with as many rows as model comparisons and columns of the following types:
</p>

<ul>
<li> <p><code>DfO</code> The error degrees-of-freedom from the subset (more simple) model.
</p>
</li>
<li> <p><code>RSSO</code>, <code>logLikO</code> The residual sum-of-squares (from <code>extraSS</code>) or log-likelihood (from <code>lrt</code>) from the subset (more simple) model.
</p>
</li>
<li> <p><code>DfA</code> The error degrees-of-freedom from the <code>com=</code> model.
</p>
</li>
<li> <p><code>RSSA</code>, <code>logLikA</code> The residual sum-of-squares (from <code>extraSS</code>) or log-likelihood (from <code>lrt</code>) from the <code>com=</code> model.
</p>
</li>
<li> <p><code>Df</code> The difference in error degrees-of-freedom between the two models.
</p>
</li>
<li> <p><code>SS</code>, <code>logLik</code> The difference in residual sum-of-squares (from <code>extraSS</code>) or log-likelihood (from <code>lrt</code>) between the two models.
</p>
</li>
<li> <p><code>F</code>, <code>Chisq</code> The corresponding F- (from <code>extraSS</code>) or Chi-square (from <code>lrt</code>) test statistic.
</p>
</li>
<li> <p><code>Pr(&gt;F)</code>, <code>Pr(&gt;Chisq)</code> The corresponding p-value.
</p>
</li></ul>



<h3>Note</h3>

<p>This function is experimental at this point. It seems to work fine for <code>lm</code> and <code>nls</code> models. An error will be thrown by <code>extraSS</code> for other model classes, but <code>lrt</code> will not (but it has not been thoroughly tests for other models).
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example data
df &lt;- data.frame(x=c(1,2,3,4,5,6,7,8,9,10),
                 y=c(4,6,5,7,9,8,7,12,16,22),
                 z=as.factor(rep(c("A","B"),each=5)),
                 w=as.factor(rep(c("A","B"),times=5)))
df$x2 &lt;- df$x^2

## Linear (lm()) models
#  ... regression
fit.0 &lt;- lm(y~1,data=df)
fit.1 &lt;- lm(y~x,data=df)
fit.2 &lt;- lm(y~x2+x,data=df)
extraSS(fit.0,fit.1,com=fit.2)
lrt(fit.0,fit.1,com=fit.2)

# ... show labels for models
extraSS(fit.0,fit.1,com=fit.2,
    sim.names=c("Null Model","Linear"),com.name="Quadratic")
lrt(fit.0,fit.1,com=fit.2,
    sim.names=c("Null Model","Linear"),com.name="Quadratic")

#  ... dummy variable regression
fit.2b &lt;- lm(y~x*z,data=df)
extraSS(fit.0,fit.1,com=fit.2b)
lrt(fit.0,fit.1,com=fit.2b)

#  ... ANOVAs
fit.1 &lt;- lm(y~w,data=df)
fit.2 &lt;- lm(y~w*z,data=df)
extraSS(fit.0,fit.1,com=fit.2)
lrt(fit.0,fit.1,com=fit.2)


## Non-linear (nls()) models
fit.0 = nls(y~c,data=df,start=list(c=10))
fit.1 = nls(y~a*x+c,data=df,start=list(a=1,c=1))
fit.2 = nls(y~b*x2+a*x+c,data=df,start=list(a=-1,b=0.3,c=10))
extraSS(fit.0,fit.1,com=fit.2)
lrt(fit.0,fit.1,com=fit.2)

## General least-squares (gls()) models
## Not run: 
  require(nlme)
  fit.0 &lt;- gls(y~1,data=df,method="ML")
  fit.1 &lt;- gls(y~x,data=df,method="ML")
  fit.2 &lt;- gls(y~x2+x,data=df,method="ML")
  lrt(fit.0,fit.1, com=fit.2)
  ## will return an error ... does not work with gls() models
  # extraSS(fit.0,fit.1, com=fit.2)

## End(Not run)

</code></pre>

<hr>
<h2 id='fact2num'>Converts &quot;numeric&quot; factor levels to numeric values.</h2><span id='topic+fact2num'></span>

<h3>Description</h3>

<p>Converts &ldquo;numeric&rdquo; factor levels to numeric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fact2num(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fact2num_+3A_object">object</code></td>
<td>
<p>A vector with &ldquo;numeric&rdquo; factor levels to be converted to numeric values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>junk &lt;- factor(c(1,7,2,4,3,10))
str(junk)
junk2 &lt;- fact2num(junk)
str(junk2)

## ONLY RUN IN INTERACTIVE MODE
if (interactive()) {

bad &lt;- factor(c("A","B","C"))
# This will result in an error -- levels are not 'numeric'
bad2 &lt;- fact2num(bad)

}  ## END IF INTERACTIVE MODE

</code></pre>

<hr>
<h2 id='fishR'>Opens web pages associated with the fishR website.</h2><span id='topic+fishR'></span>

<h3>Description</h3>

<p>Opens web pages associated with the <a href="https://fishr-core-team.github.io/fishR/">fishR website</a> in a browser. The user can open the main page or choose a specific page to open.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fishR(
  where = c("home", "posts", "books", "IFAR", "AIFFD", "packages", "data"),
  open = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fishR_+3A_where">where</code></td>
<td>
<p>A string that indicates a particular page on the fishR website to open.</p>
</td></tr>
<tr><td><code id="fishR_+3A_open">open</code></td>
<td>
<p>A logical that indicates whether the webpage should be opened in the default browser. Defaults to <code>TRUE</code>; <code>FALSE</code> is used for unit testing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, but a webpage will be opened in the default browser.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Opens an external webpage ... only run interactively
fishR()            # home page
fishR("posts")     # blog posts (some examples) page
fishR("books")     # examples page
fishR("IFAR")      # Introduction to Fisheries Analysis with R page
fishR("AIFFD")     # Analysis &amp; Interpretation of Freshw. Fisher. Data page
fishR("packages")  # list of r-related fishereis packages
fishR("data")      # list of fisheries data sets

## End(Not run)

</code></pre>

<hr>
<h2 id='FSA'>Fisheries stock assessment methods and data.</h2><span id='topic+FSA'></span><span id='topic+FSA-package'></span>

<h3>Description</h3>

<p>Functions to support basic fisheries stock assessment methods.
</p>


<h3>Details</h3>

<p>Functions from this package can be used to perform a variety of basic fisheries stock assessment methods. Detailed descriptions for most functions are available in the Introductory Fisheries Analysis with R book (Ogle 2016) (see <code>fishR("IFAR")</code>). Vignettes for the boxed examples in the &ldquo;Analysis and Interpretation of Freshwater Fisheries Data&rdquo; book can be viewed with <code>fishR("AIFFD")</code>.
</p>
<p>Questions, comments, or suggestions should be given on the <a href="https://github.com/fishR-Core-Team/FSA/issues/">GitHub FSA Issues page</a>.
</p>
<p>Packages with related functionality by the same author are
</p>

<ul>
<li><p> The <a href="https://github.com/fishR-Core-Team/FSAdata/">FSAdata package</a> contains additional data sets.
</p>
</li>
<li><p> The <a href="https://github.com/droglenc/FSAsim/">FSAsim package</a> simulation routines for various fisheries methods.
</p>
</li>
<li><p> The <a href="https://github.com/droglenc/FSAWs/">FSAWs package</a> contains functions for developing and validating standard weight equations.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Derek H. Ogle <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a> (<a href="https://orcid.org/0000-0002-0370-9299">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jason C. Doll <a href="mailto:jason.doll@fmarion.edu">jason.doll@fmarion.edu</a>
</p>
</li>
<li><p> A. Powell Wheeler <a href="mailto:powell.wheeler@gmail.com">powell.wheeler@gmail.com</a>
</p>
</li>
<li><p> Alexis Dinno <a href="mailto:alexis.dinno@pdx.edu">alexis.dinno@pdx.edu</a> (Provided base functionality of dunnTest())
</p>
</li></ul>



<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://fishr-core-team.github.io/FSA/">https://fishr-core-team.github.io/FSA/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/fishR-Core-Team/FSA/issues">https://github.com/fishR-Core-Team/FSA/issues</a>
</p>
</li></ul>


<hr>
<h2 id='FSA-defunct'>DEFUNCT functions.</h2><span id='topic+FSA-defunct'></span><span id='topic+bootCase'></span><span id='topic+chooseColors'></span><span id='topic+compIntercepts'></span><span id='topic+compSlopes'></span><span id='topic+diags'></span><span id='topic+filterD'></span><span id='topic+fitPlot'></span><span id='topic+fsaNews'></span><span id='topic+hoCoef'></span><span id='topic+mapvalues'></span><span id='topic+plotBinResp'></span><span id='topic+residPlot'></span><span id='topic+Subset'></span>

<h3>Description</h3>

<p>These functions were once part of FSA but have now been removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootCase(...)

chooseColors(...)

compIntercepts(...)

compSlopes(...)

diags(...)

filterD(...)

fitPlot(...)

fsaNews(...)

hoCoef(...)

mapvalues(...)

plotBinResp(...)

residPlot(...)

Subset(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FSA-defunct_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass through.</p>
</td></tr>
</table>

<hr>
<h2 id='geomean'>Calculates the geometric mean or geometric standard deviation.</h2><span id='topic+geomean'></span><span id='topic+geosd'></span>

<h3>Description</h3>

<p>Calculates the geometric mean or standard deviation of a vector of numeric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomean(x, na.rm = FALSE, zneg.rm = FALSE)

geosd(x, na.rm = FALSE, zneg.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomean_+3A_x">x</code></td>
<td>
<p>Vector of numeric values.</p>
</td></tr>
<tr><td><code id="geomean_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical indicating whether to remove missing values or not.</p>
</td></tr>
<tr><td><code id="geomean_+3A_zneg.rm">zneg.rm</code></td>
<td>
<p>Logical indicating whether to ignore or remove zero or negative values found in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The geometric mean is computed by log transforming the raw data in <code>x</code>, computing the arithmetic mean of the transformed data, and back-transforming this mean to the geometric mean by exponentiating.
</p>
<p>The geometric standard deviation is computed by log transforming the raw data in <code>x</code>, computing the arithmetic standard deviation of the transformed data, and back-transforming this standard deviation to the geometric standard deviation by exponentiating.
</p>


<h3>Value</h3>

<p>A numeric value that is the geometric mean or geometric standard deviation of the numeric values in <code>x</code>.
</p>


<h3>Note</h3>

<p>This function is largely an implementation of the code suggested by Russell Senior on R-help in November, 1999.
</p>


<h3>See Also</h3>

<p>See <code><a href="psych.html#topic+geometric.mean">geometric.mean</a></code> in <span class="pkg">psych</span> and <code><a href="DescTools.html#topic+Gmean">Gmean</a></code> for geometric mean calculators. See <code>Gsd</code> (documented with <code><a href="DescTools.html#topic+Gmean">Gmean</a></code>) from <span class="pkg">DescTools</span> for geometric standard deviation calculators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate random lognormal data
d &lt;- rlnorm(500,meanlog=0,sdlog=1)
# d has a mean on log scale of 0; thus, gm should be exp(0)~=1
# d has a sd on log scale of 1; thus, gsd should be exp(1)~=2.7
geomean(d)
geosd(d)

## Not run: 
## Demonstrate handling of zeros and negative values
x &lt;- seq(-1,5)
# this will given an error
geomean(x)
# this will only give a warning, but might not be what you want
geomean(x,zneg.rm=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='growthModels'>Creates a function for a specific parameterization of the von Bertalanffy, Gompertz, Richards, and logistic growth functions.</h2><span id='topic+growthModels'></span><span id='topic+vbFuns'></span><span id='topic+GompertzFuns'></span><span id='topic+RichardsFuns'></span><span id='topic+logisticFuns'></span><span id='topic+growthFunShow'></span>

<h3>Description</h3>

<p>Creates a function for a specific parameterizations of the von Bertalanffy, Gompertz, Richards, and logistic growth functions. Use <code>growthFunShow()</code> to see the equations for each growth function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vbFuns(
  param = c("Typical", "typical", "Traditional", "traditional", "BevertonHolt",
    "Original", "original", "vonBertalanffy", "GQ", "GallucciQuinn", "Mooij", "Weisberg",
    "Ogle", "Schnute", "Francis", "Laslett", "Polacheck", "Somers", "Somers2", "Pauly",
    "Fabens", "Fabens2", "Wang", "Wang2", "Wang3", "Francis2", "Francis3"),
  simple = FALSE,
  msg = FALSE
)

GompertzFuns(
  param = c("Ricker1", "Ricker2", "Ricker3", "QuinnDeriso1", "QuinnDeriso2",
    "QuinnDeriso3", "QD1", "QD2", "QD3", "Original", "original", "Troynikov1",
    "Troynikov2"),
  simple = FALSE,
  msg = FALSE
)

RichardsFuns(param = 1, simple = FALSE, msg = FALSE)

logisticFuns(
  param = c("CJ1", "CJ2", "Karkach", "Haddon", "CampanaJones1", "CampanaJones2"),
  simple = FALSE,
  msg = FALSE
)

growthFunShow(
  type = c("vonBertalanffy", "Gompertz", "Richards", "Logistic", "Schnute",
    "SchnuteRichards"),
  param = NULL,
  case = param,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growthModels_+3A_param">param</code></td>
<td>
<p>A string (for von Bertalanffy, Gompertz, and logistic) or numeric (for Richards) that indicates the specific parameterization of the growth function. See details.</p>
</td></tr>
<tr><td><code id="growthModels_+3A_simple">simple</code></td>
<td>
<p>A logical that indicates whether the function will accept all parameter values in the first parameter argument (<code>=FALSE</code>; DEFAULT) or whether all individual parameters must be specified in separate arguments (<code>=TRUE</code>).</p>
</td></tr>
<tr><td><code id="growthModels_+3A_msg">msg</code></td>
<td>
<p>A logical that indicates whether a message about the growth function and parameter definitions should be output (<code>=TRUE</code>) or not (<code>=FALSE</code>; DEFAULT).</p>
</td></tr>
<tr><td><code id="growthModels_+3A_type">type</code></td>
<td>
<p>A string (in <code>growthFunShow</code>) that indicates the type of growth function to show.</p>
</td></tr>
<tr><td><code id="growthModels_+3A_case">case</code></td>
<td>
<p>A numeric that indicates the specific case of the Schnute function to use. See details.</p>
</td></tr>
<tr><td><code id="growthModels_+3A_plot">plot</code></td>
<td>
<p>A logical that indicates whether the growth function expression should be shown as an equation in a simple plot.</p>
</td></tr>
<tr><td><code id="growthModels_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The functions ending in <code>xxxFuns</code> return a function that can be used to predict fish size given a vector of ages and values for the growth function parameters and, in some parameterizations, values for constants. The result should be saved to an object that is then the function name. When the resulting function is used, the parameters are ordered as shown when the definitions of the parameters are printed after the function is called (if <code>msg=TRUE</code>). If <code>simple=FALSE</code> (DEFAULT), then the values for all parameters may be included as a vector in the first parameter argument (but in the same order). Similarly, the values for all constants may be included as a vector in the first constant argument (i.e., <code>t1</code>). If <code>simple=TRUE</code>, then all parameters and constants must be declared individually. The resulting function is somewhat easier to read when <code>simple=TRUE</code>, but is less general for some applications.
</p>
<p>An expression of the equation for each growth function may be created with <code>growthFunShow</code>. In this function <code>type=</code> is used to select the major function type (e.g., von Bertalanffy, Gompertz, Richards, Logistic, Schnute) and <code>param=</code> is used to select a specific parameterization of that growth function. If <code>plot=TRUE</code>, then a simple graphic will be created with the equation using <code><a href="grDevices.html#topic+plotmath">plotmath</a></code> for a pretty format.
</p>


<h3>IFAR Chapter</h3>

<p>12-Individual Growth.
</p>


<h3>Note</h3>

<p>Take note of the following for parameterizations (i.e., <code>param</code>) of each growth function:
</p>

<ul>
<li><p> von Bertalanffy
</p>

<ul>
<li><p> The &lsquo;Original&rsquo; and &lsquo;vonBertalanffy&rsquo; are synonymous as are &lsquo;Typical&rsquo;, &lsquo;Traditional&rsquo;, and &lsquo;BevertonHolt&rsquo;. Further note that the &lsquo;Ogle&rsquo; parameterization has the &lsquo;Original&rsquo;/&lsquo;vonBertalanffy&rsquo; and &lsquo;Typical&rsquo;/&lsquo;Traditional&rsquo;/&lsquo;BevertonHolt&rsquo; parameterizations as special cases.
</p>
</li></ul>

</li>
<li><p> Gompertz
</p>

<ul>
<li><p> The &lsquo;Ricker2&rsquo; and &lsquo;QuinnDeriso1&rsquo; are synonymous, as are &lsquo;Ricker3&rsquo; and &lsquo;QuinnDeriso2&rsquo;.
</p>
</li>
<li><p> The parameterizations and parameters for the Gompertz function are varied and confusing in the literature. I have attempted to use a uniform set of parameters in these functions, but that makes a direct comparison to the literature difficult. Common sources for Gompertz models are listed in the references below. I make some comments here to aid comparisons to the literature.
</p>
</li>
<li><p> Within FSA, L0 is the mean length at age 0, Linf is the mean asymptotic length, ti is the age at the inflection point, gi is the instantaneous growth rate at the inflection point, t* is a dimensionless parameter related to time/age, and a is a dimensionless parameter related to growth.
</p>
</li>
<li><p> In the Quinn and Deriso (1999) functions (the &lsquo;QuinnDerisoX&rsquo; functions), the a parameter here is equal to lambda/K there and the gi parameter here is equal to the K parameter there. Also note that their Y is L here.
</p>
</li>
<li><p> In the Ricker (1979)[p. 705] functions (the &lsquo;RickerX&rsquo; functions), the a parameter here is equal to k there and the gi parameter here is equal to the g parameter there. Also note that their w is L here. In the Ricker (1979) functions as presented in Campana and Jones (1992), the a parameter here is equal to k parameter there and the gi parameter here is equal to the G parameter there. Also note that their X is L here.
</p>
</li>
<li><p> The function in Ricker (1975)[p. 232] is the same as &lsquo;Ricker2&rsquo; where the a parameter here is qual to G there and the gi parameter here is equal to the g parameter there. Also note that their w is L here.
</p>
</li>
<li><p> The function in Quist <em>et al.</em> (2012)[p. 714] is the same as &lsquo;Ricker1&rsquo; where the gi parameter here is equal to the G parameter there and the ti parameter here is equal to the t0 parameter there.
</p>
</li>
<li><p> The function in Katsanevakis and Maravelias (2008) is the same as &lsquo;Ricker1&rsquo; where the gi parameter here is equal to k2 parameter there and the ti parameter here is equal to the t2 parameter there.
</p>
</li></ul>

</li>
<li><p> Richards
</p>

<ul>
<li><p> Within FSA, Linf is the mean asymptotic length, ti is the age at the inflection point, k controls the slope at the inflection point (maximum relative growth rate), b is dimensionless but related to the vertical position (i.e., size) of the inflection point, a is dimensionless but related to the horizontal position (i.e., age) of the inflection point, and L0 is the mean length at age-0.
</p>
</li>
<li><p> The parameterizations (1-6) correspond to functions/equations 1, 4, 5, 6, 7, and 8, respectively, in Tjorve and Tjorve (2010). Note that their A, S, k, d, and B are Linf, a, k, b, and L0, respectively, here (in FSA). THeir (Tjorve and Tjorve 2010) K does not appear here.
</p>
</li></ul>

</li>
<li><p> logistic
</p>

<ul>
<li><p> Within FSA, L0 is the mean length at age 0, Linf is the mean asymptotic length, ti is the age at the inflection point, and gninf is the instantaneous growth rate at negative infinity.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>, thanks to Gabor Grothendieck for a hint about using <code>get()</code>.
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Campana, S.E. and C.M. Jones. 1992. Analysis of otolith microstructure data. Pages 73-100 In D.K. Stevenson and S.E. Campana, editors. Otolith microstructure examination and analysis. Canadian Special Publication of Fisheries and Aquatic Sciences 117. [Was (is?) from http://www.dfo-mpo.gc.ca/Library/141734.pdf.]
</p>
<p>Fabens, A. 1965. Properties and fitting of the von Bertalanffy growth curve. Growth 29:265-289.
</p>
<p>Francis, R.I.C.C. 1988. Are growth parameters estimated from tagging and age-length data comparable?  Canadian Journal of Fisheries and Aquatic Sciences, 45:936-942.
</p>
<p>Gallucci, V.F. and T.J. Quinn II. 1979. Reparameterizing, fitting, and testing a simple growth model. Transactions of the American Fisheries Society, 108:14-25.
</p>
<p>Garcia-Berthou, E., G. Carmona-Catot, R. Merciai, and D.H. Ogle. A technical note on seasonal growth models. Reviews in Fish Biology and Fisheries 22:635-640. [Was (is?) from https://www.researchgate.net/publication/257658359_A_technical_note_on_seasonal_growth_models.]
</p>
<p>Gompertz, B. 1825. On the nature of the function expressive of the law of human mortality, and on a new method of determining the value of life contingencies. Philosophical Transactions of the Royal Society of London. 115:513-583.
</p>
<p>Haddon, M., C. Mundy, and D. Tarbath. 2008. Using an inverse-logistic model to describe growth increments of Blacklip Abalone (<em>Haliotis rubra</em>) in Tasmania. Fishery Bulletin 106:58-71. [Was (is?) from http://aquaticcommons.org/8857/1/haddon_Fish_Bull_2008.pdf.]
</p>
<p>Karkach, A. S. 2006. Trajectories and models of individual growth. Demographic Research 15:347-400. [Was (is?) from http://www.demographic-research.org/volumes/vol15/12/15-12.pdf.]
</p>
<p>Katsanevakis, S. and C.D. Maravelias. 2008. Modeling fish growth: multi-model inference as a better alternative to a priori using von Bertalanffy equation. Fish and Fisheries 9:178-187.
</p>
<p>Mooij, W.M., J.M. Van Rooij, and S. Wijnhoven. 1999. Analysis and comparison of fish growth from small samples of length-at-age data: Detection of sexual dimorphism in Eurasian Perch as an example. Transactions of the American Fisheries Society 128:483-490.
</p>
<p>Polacheck, T., J.P. Eveson, and G.M. Laslett. 2004. Increase in growth rates of southern Bluefin Tuna (<em>Thunnus maccoyii</em>) over four decades: 1960 to 2000. Canadian Journal of Fisheries and Aquatic Sciences, 61:307-322.
</p>
<p>Quinn, T. J. and R. B. Deriso. 1999. Quantitative Fish Dynamics. Oxford University Press, New York, New York. 542 pages.
</p>
<p>Quist, M.C., M.A. Pegg, and D.R. DeVries. 2012. Age and Growth. Chapter 15 in A.V. Zale, D.L Parrish, and T.M. Sutton, Editors  Fisheries Techniques, Third Edition. American Fisheries Society, Bethesda, MD.
</p>
<p>Richards, F. J. 1959. A flexible growth function for empirical use. Journal of Experimental Biology 10:290-300.
</p>
<p>Ricker, W.E. 1975. Computation and interpretation of biological statistics of fish populations. Technical Report Bulletin 191, Bulletin of the Fisheries Research Board of Canada. [Was (is?) from http://www.dfo-mpo.gc.ca/Library/1485.pdf.]
</p>
<p>Ricker, W.E. 1979. Growth rates and models. Pages 677-743 In W.S. Hoar, D.J. Randall, and J.R. Brett, editors. Fish Physiology, Vol. 8: Bioenergetics and Growth. Academic Press, NY, NY. [Was (is?) from https://books.google.com/books?id=CB1qu2VbKwQC&amp;pg=PA705&amp;lpg=PA705&amp;dq=Gompertz+fish&amp;source=bl&amp;ots=y34lhFP4IU&amp;sig=EM_DGEQMPGIn_DlgTcGIi_wbItE&amp;hl=en&amp;sa=X&amp;ei=QmM4VZK6EpDAgwTt24CABw&amp;ved=0CE8Q6AEwBw#v=onepage&amp;q=Gompertz%20fish&amp;f=false.]
</p>
<p>Schnute, J. 1981. A versatile growth model with statistically stable parameters. Canadian Journal of Fisheries and Aquatic Sciences, 38:1128-1140.
</p>
<p>Somers, I. F. 1988. On a seasonally oscillating growth function. Fishbyte 6(1):8-11. [Was (is?) from http://www.worldfishcenter.org/Naga/na_2914.pdf.]
</p>
<p>Tjorve, E. and K. M. C. Tjorve. 2010. A unified approach to the Richards-model family for use in growth analyses: Why we need only two model forms. Journal of Theoretical Biology 267:417-425. [Was (is?) from https://www.researchgate.net/profile/Even_Tjorve/publication/46218377_A_unified_approach_to_the_Richards-model_family_for_use_in_growth_analyses_why_we_need_only_two_model_forms/links/54ba83b80cf29e0cb04bd24e.pdf.]
</p>
<p>Troynikov, V. S., R. W. Day, and A. M. Leorke. Estimation of seasonal growth parameters using a stochastic Gompertz model for tagging data. Journal of Shellfish Research 17:833-838. [Was (is?) from https://www.researchgate.net/profile/Robert_Day2/publication/249340562_Estimation_of_seasonal_growth_parameters_using_a_stochastic_gompertz_model_for_tagging_data/links/54200fa30cf203f155c2a08a.pdf.]
</p>
<p>Vaughan, D. S. and T. E. Helser. 1990. Status of the Red Drum stock of the Atlantic coast: Stock assessment report for 1989. NOAA Technical Memorandum NMFS-SEFC-263, 117 p. [Was (is?) from http://docs.lib.noaa.gov/noaa_documents/NMFS/SEFSC/TM_NMFS_SEFSC/NMFS_SEFSC_TM_263.pdf.]
</p>
<p>Wang, Y.-G. 1998. An improved Fabens method for estimation of growth parameters in the von Bertalanffy model with individual asymptotes. Canadian Journal of Fisheries and Aquatic Sciences 55:397-400.
</p>
<p>Weisberg, S., G.R. Spangler, and L. S. Richmond. 2010. Mixed effects models for fish growth. Canadian Journal of Fisheries And Aquatic Sciences 67:269-277.
</p>
<p>Winsor, C.P. 1932. The Gompertz curve as a growth curve. Proceedings of the National Academy of Sciences. 18:1-8. [Was (is?) from http://www.ncbi.nlm.nih.gov/pmc/articles/PMC1076153/pdf/pnas01729-0009.pdf.]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+Schnute">Schnute</a></code> for an implementation of the Schnute (1981) model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################################################
## Simple Examples -- Von B
( vb1 &lt;- vbFuns() )
ages &lt;- 0:20
plot(vb1(ages,Linf=20,K=0.3,t0=-0.2)~ages,type="b",pch=19)
( vb2 &lt;- vbFuns("Francis") )
plot(vb2(ages,L1=10,L2=19,L3=20,t1=2,t3=18)~ages,type="b",pch=19)
( vb2c &lt;- vbFuns("Francis",simple=TRUE) )   # compare to vb2

## Simple Examples -- Gompertz
( gomp1 &lt;- GompertzFuns() )
plot(gomp1(ages,Linf=800,gi=0.5,ti=5)~ages,type="b",pch=19)
( gomp2 &lt;- GompertzFuns("Ricker2") )
plot(gomp2(ages,L0=2,a=6,gi=0.5)~ages,type="b",pch=19)
( gomp2c &lt;- GompertzFuns("Ricker2",simple=TRUE) )   # compare to gomp2
( gompT &lt;- GompertzFuns("Troynikov1"))

## Simple Examples -- Richards
( rich1 &lt;- RichardsFuns() )
plot(rich1(ages,Linf=800,k=0.5,a=1,b=6)~ages,type="b",pch=19)
( rich2 &lt;- RichardsFuns(2) )
plot(rich2(ages,Linf=800,k=0.5,ti=3,b=6)~ages,type="b",pch=19)
( rich3 &lt;- RichardsFuns(3) )
plot(rich3(ages,Linf=800,k=0.5,ti=3,b=0.15)~ages,type="b",pch=19)
( rich4 &lt;- RichardsFuns(4) )
plot(rich4(ages,Linf=800,k=0.5,ti=3,b=0.95)~ages,type="b",pch=19)
lines(rich4(ages,Linf=800,k=0.5,ti=3,b=1.5)~ages,type="b",pch=19,col="blue")
( rich5 &lt;- RichardsFuns(5) )
plot(rich5(ages,Linf=800,k=0.5,L0=50,b=1.5)~ages,type="b",pch=19)
( rich6 &lt;- RichardsFuns(6) )
plot(rich6(ages,Linf=800,k=0.5,ti=3,Lninf=50,b=1.5)~ages,type="b",pch=19)
( rich2c &lt;- RichardsFuns(2,simple=TRUE) ) # compare to rich2

## Simple Examples -- Logistic
( log1 &lt;- logisticFuns() )
plot(log1(ages,Linf=800,gninf=0.5,ti=5)~ages,type="b",pch=19)
( log2 &lt;- logisticFuns("CJ2") )
plot(log2(ages,Linf=800,gninf=0.5,a=10)~ages,type="b",pch=19)
( log2c &lt;- logisticFuns("CJ2",simple=TRUE) ) # compare to log2
( log3 &lt;- logisticFuns("Karkach") )
plot(log3(ages,L0=10,Linf=800,gninf=0.5)~ages,type="b",pch=19)
( log4 &lt;- logisticFuns("Haddon") )


###########################################################
## Examples of fitting
##   After the last example a plot is constructed with three
##   or four lines on top of each other illustrating that the
##   parameterizations all produce the same fitted values.
##   However, observe the correlations in the summary() results.

## Von B
plot(tl~age,data=SpotVA1,pch=19)

# Fitting the typical parameterization of the von B function
fit1 &lt;- nls(tl~vb1(age,Linf,K,t0),data=SpotVA1,
            start=vbStarts(tl~age,data=SpotVA1))
summary(fit1,correlation=TRUE)
curve(vb1(x,Linf=coef(fit1)),from=0,to=5,col="red",lwd=10,add=TRUE)

# Fitting the Francis parameterization of the von B function
fit2 &lt;- nls(tl~vb2c(age,L1,L2,L3,t1=0,t3=5),data=SpotVA1,
            start=vbStarts(tl~age,data=SpotVA1,type="Francis",ages2use=c(0,5)))
summary(fit2,correlation=TRUE)
curve(vb2c(x,L1=coef(fit2)[1],L2=coef(fit2)[2],L3=coef(fit2)[3],t1=0,t3=5),
      from=0,to=5,col="blue",lwd=5,add=TRUE)

# Fitting the Schnute parameterization of the von B function
vb3 &lt;- vbFuns("Schnute")
fit3 &lt;- nls(tl~vb3(age,L1,L3,K,t1=0,t3=4),data=SpotVA1,
            start=vbStarts(tl~age,data=SpotVA1,type="Schnute",ages2use=c(0,4)))
summary(fit3,correlation=TRUE)
curve(vb3(x,L1=coef(fit3),t1=c(0,4)),from=0,to=5,col="green",lwd=2,add=TRUE)

## Gompertz
# Make some fake data using the original parameterization
gompO &lt;- GompertzFuns("original")
# setup ages, sample sizes (general reduction in numbers with
# increasing age), and additive SD to model
t &lt;- 1:15
n &lt;- c(10,40,35,25,12,10,10,8,6,5,3,3,3,2,2)
sd &lt;- 15
# expand ages
ages &lt;- rep(t,n)
# get lengths from gompertz and a random error for individuals
lens &lt;- gompO(ages,Linf=450,a=1,gi=0.3)+rnorm(length(ages),0,sd)
# put together as a data.frame
df &lt;- data.frame(age=ages,len=round(lens,0))

plot(len~age,data=df,pch=19,col=rgb(0,0,0,1/5))
  
# Fit first Ricker parameterization
fit1 &lt;- nls(len~gomp1(age,Linf,gi,ti),data=df,start=list(Linf=500,gi=0.3,ti=3))
summary(fit1,correlation=TRUE)
curve(gomp1(x,Linf=coef(fit1)),from=0,to=15,col="red",lwd=10,add=TRUE)

# Fit third Ricker parameterization
fit2 &lt;- nls(len~gomp2(age,L0,a,gi),data=df,start=list(L0=30,a=3,gi=0.3))
summary(fit2,correlation=TRUE)
curve(gomp2(x,L0=coef(fit2)),from=0,to=15,col="blue",lwd=5,add=TRUE)

# Fit third Quinn and Deriso parameterization (using simple=TRUE model)
gomp3 &lt;- GompertzFuns("QD3",simple=TRUE)
fit3 &lt;- nls(len~gomp3(age,Linf,gi,t0),data=df,start=list(Linf=500,gi=0.3,t0=0))
summary(fit3,correlation=TRUE)
curve(gomp3(x,Linf=coef(fit3)[1],gi=coef(fit3)[2],t0=coef(fit3)[3]),
      from=0,to=15,col="green",lwd=2,add=TRUE)

## Richards

## Not run: 
# Fit first Richards parameterization ... DOES NOT CONVERGE
fit1 &lt;- nls(len~rich1(age,Linf,k,a,b),data=df,
            start=list(Linf=450,k=0.3,a=0.2,b=3))
summary(fit1,correlation=TRUE)
curve(rich1(x,Linf=coef(fit1)),from=0,to=15,col="red",lwd=10,add=TRUE)

# Fit second Richards parameterization ... DOES NOT CONVERGE
fit2 &lt;- nls(len~rich2(age,Linf,k,ti,b),data=df,
            start=list(Linf=450,k=0.25,ti=3,b=3))
summary(fit2,correlation=TRUE)
curve(rich2(x,Linf=coef(fit2)),from=0,to=15,col="blue",lwd=7,add=TRUE)

## End(Not run)

plot(len~age,data=df,pch=19,col=rgb(0,0,0,1/5))

# Fit third Richards parameterization
fit3 &lt;- nls(len~rich3(age,Linf,k,ti,b),data=df,
            start=list(Linf=450,k=0.25,ti=3,b=-0.1))
summary(fit3,correlation=TRUE)
curve(rich3(x,Linf=coef(fit3)),from=0,to=15,col="green",lwd=4,add=TRUE)

# Fit fourth Richards parameterization
fit4 &lt;- nls(len~rich4(age,Linf,k,ti,b),data=df,
            start=list(Linf=450,k=0.25,ti=3,b=0.7))
summary(fit4,correlation=TRUE)
curve(rich4(x,Linf=coef(fit4)),from=0,to=15,col="black",lwd=1,add=TRUE)

## Logistic
plot(len~age,data=df,pch=19,col=rgb(0,0,0,1/5))

# Fit first Campana-Jones parameterization
fit1 &lt;- nls(len~log1(age,Linf,gninf,ti),data=df,
            start=list(Linf=450,gninf=0.45,ti=4))
summary(fit1,correlation=TRUE)
curve(log1(x,Linf=coef(fit1)),from=0,to=15,col="red",lwd=10,add=TRUE)

# Fit second Campana-Jones parameterization
fit2 &lt;- nls(len~log2(age,Linf,gninf,a),data=df,
            start=list(Linf=450,gninf=0.45,a=7))
summary(fit2,correlation=TRUE)
curve(log2(x,Linf=coef(fit2)),from=0,to=15,col="blue",lwd=5,add=TRUE)

# Fit Karkach parameterization (using simple=TRUE model)
log3 &lt;- logisticFuns("Karkach",simple=TRUE)
fit3 &lt;- nls(len~log3(age,Linf,L0,gninf),data=df,
            start=list(Linf=450,L0=30,gninf=0.45))
summary(fit3,correlation=TRUE)
curve(log3(x,Linf=coef(fit3)[1],L0=coef(fit3)[2],gninf=coef(fit3)[3]),
      from=0,to=15,col="green",lwd=2,add=TRUE)


#############################################################################
## Create expressions of the models
#############################################################################
# Typical von Bertalanffy ... Show as a stand-alone plot
growthFunShow("vonBertalanffy","Typical",plot=TRUE)
# Get and save the expression
( tmp &lt;- growthFunShow("vonBertalanffy","Typical") )
# Use expression as title on a plot
lens &lt;- vb1(ages,Linf=20,K=0.3,t0=-0.2)
plot(lens~ages,type="b",pch=19,main=tmp)
# Put expression in the main plot
text(10,5,tmp)
# Put multiple expressions on a plot
op &lt;- par(mar=c(0.1,0.1,0.1,0.1))
plot(0,type="n",xlab="",ylab="",xlim=c(0,1),ylim=c(0,3),xaxt="n",yaxt="n")
text(0,2.5,"Original:",pos=4)
text(0.5,2.5,growthFunShow("vonBertalanffy","Original"))
text(0,1.5,"Typical:",pos=4)
text(0.5,1.5,growthFunShow("vonBertalanffy","Typical"))
text(0,0.5,"Francis:",pos=4)
text(0.5,0.5,growthFunShow("vonBertalanffy","Francis"))
par(op)
</code></pre>

<hr>
<h2 id='headtail'>Shows rows from the head and tail of a data frame or matrix.</h2><span id='topic+headtail'></span>

<h3>Description</h3>

<p>Shows rows from the head and tail of a data frame or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headtail(x, n = 3L, which = NULL, addrownums = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headtail_+3A_x">x</code></td>
<td>
<p>A data frame or matrix.</p>
</td></tr>
<tr><td><code id="headtail_+3A_n">n</code></td>
<td>
<p>A single numeric that indicates the number of rows to display from each of the head and tail of structure.</p>
</td></tr>
<tr><td><code id="headtail_+3A_which">which</code></td>
<td>
<p>A numeric or string vector that contains the column numbers or names to display. Defaults to showing all columns.</p>
</td></tr>
<tr><td><code id="headtail_+3A_addrownums">addrownums</code></td>
<td>
<p>If there are no row names for the MATRIX, then create them from the row numbers.</p>
</td></tr>
<tr><td><code id="headtail_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or data.frame with 2*n rows.
</p>


<h3>Note</h3>

<p>If <code>n</code> is larger than the number of rows in <code>x</code> then all of <code>x</code> is displayed.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>peek</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>headtail(iris)
headtail(iris,10)
headtail(iris,which=c("Sepal.Length","Sepal.Width","Species"))
headtail(iris,which=grep("Sepal",names(iris)))
headtail(iris,n=200)

## Make a matrix for demonstration purposes only
miris &lt;- as.matrix(iris[,1:4])
headtail(miris)
headtail(miris,10)
headtail(miris,addrownums=FALSE)
headtail(miris,10,which=2:4)

## Make a tbl_df type from tibble ... note how headtail()
## is not limited by the tbl_df restriction on number of
## rows to show (but head() is).
if (require(tibble)) {
  iris2 &lt;- as_tibble(iris)
  class(iris2)
  headtail(iris2,n=15)
  head(iris2,n=15)
}
</code></pre>

<hr>
<h2 id='hist.formula'>Creates separate histograms by levels.</h2><span id='topic+hist.formula'></span>

<h3>Description</h3>

<p>Creates separate histograms of a quantitative variable by levels of a factor variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
hist(
  formula,
  data = NULL,
  main = "",
  right = FALSE,
  pre.main = "",
  xlab = NULL,
  ylab = "Frequency",
  same.breaks = TRUE,
  breaks = "Sturges",
  w = NULL,
  same.ylim = TRUE,
  ymax = NULL,
  col = "gray90",
  nrow = round(sqrt(num)),
  ncol = ceiling(sqrt(num)),
  byrow = TRUE,
  iaxs = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.formula_+3A_formula">formula</code></td>
<td>
<p>A formula. See details.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_data">data</code></td>
<td>
<p>An optional data frame that contains the variables in the model.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_main">main</code></td>
<td>
<p>A character string used as the main title for when a SINGLE histogram is produced.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_right">right</code></td>
<td>
<p>A logical that indicates if the histogram bins are right-closed (left open) intervals (<code>=TRUE</code>) or not (<code>=FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_pre.main">pre.main</code></td>
<td>
<p>A character string to be used as a prefix for the main title when multiple histograms are produced. See details.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_xlab">xlab</code></td>
<td>
<p>A character label for the x-axis. Defaults to name of quantitative variable in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_ylab">ylab</code></td>
<td>
<p>A character label for the y-axis. Defaults to &ldquo;Frequency&rdquo;.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_same.breaks">same.breaks</code></td>
<td>
<p>A logical that indicates whether the same break values (i.e., bins) should be used on each histogram. Ignored if <code>breaks</code> or <code>w</code> is provided by the user. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_breaks">breaks</code></td>
<td>
<p>A single numeric that indicates the number of bins or breaks or a vector that contains the lower values of the breaks. Ignored if <code>w</code> is not <code>NULL</code>. See <code><a href="graphics.html#topic+hist">hist</a></code> for more details.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_w">w</code></td>
<td>
<p>A single numeric that indicates the width of the bins to use. The bins will start at &ldquo;rounded&rdquo; values depending on the value of <code>w</code>. See <code><a href="#topic+lencat">lencat</a></code> for more details.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_same.ylim">same.ylim</code></td>
<td>
<p>A logical that indicates whether the same limits for the y-axis should be used on each histogram. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_ymax">ymax</code></td>
<td>
<p>A single value that sets the maximum y-axis limit for each histogram or a vector of length equal to the number of groups that sets the maximum y-axis limit for each histogram separately. If <code>NULL</code> (default), then a value will be found.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_col">col</code></td>
<td>
<p>A string that indicates the color for the bars on the histogram. Defaults to a light shade of gray (i.e., <code>"gray90"</code>).</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_nrow">nrow</code></td>
<td>
<p>A single numeric that contains the number of rows to use on the graphic.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_ncol">ncol</code></td>
<td>
<p>A single numeric that contains the number of columns to use on the graphic.</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_byrow">byrow</code></td>
<td>
<p>A single logical that indicates if the histograms should fill rows first (<code>=TRUE</code> or columns first (<code>=FALSE</code>).</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_iaxs">iaxs</code></td>
<td>
<p>A single logical that indicates whether both axes should be plotted using <code>xaxs="i"</code> and <code>yaxs="i"</code> (the default) or <code>xaxs="r"</code> and <code>yaxs="r"</code> (what R typically does).</p>
</td></tr>
<tr><td><code id="hist.formula_+3A_...">...</code></td>
<td>
<p>Other arguments to pass through to the default <code>hist()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula must be of the form <code>~quantitative</code>, <code>quantitative~1</code>, <code>quantitative~factor</code>, or <code>quantitative~factor*factor2</code> where <code>quantitative</code> is the quantitative variable to construct the histograms for and <code>factor</code> or <code>factor2</code> are factor variables that contain the levels for which separate histograms should be constructed.
</p>
<p>If the formula is of the form <code>~quantitative</code> or <code>quantitative~1</code> then only a single histogram of the quantitative variable will be produced. This allows <code>hist.formula()</code> to be used similarly to <code>hist()</code> but with a <code>data=</code> argument.
</p>
<p>The function produces a single (but see below) graphic that consists of a grid on which the separate histograms are printed. The rows and columns of this grid are determined to construct a plot that is as square as possible. However, the rows and columns can be set by the user with the <code>nrow=</code> and <code>ncol=</code> arguments. If the product of the number of rows and number of columns set by the user is less than the total number of histograms to be constructed then multiple pages of histograms will be produced (each requiring the user to click on the graph to go to the next graph). The x-axis of each separate histogram will be labeled identically. The default x-axis label is the name of the quantitative variable. This can be changed by the user with the <code>xlab=</code> argument.
</p>
<p>The default for <code>right=</code> is not the same as that used in <code>hist()</code> from <span class="pkg">graphics</span>. Thus, right-open (left-closed) bins are the default.
</p>
<p>The <code>iaxs=</code> argument defaults to <code>TRUE</code> so that <code>xaxs="i"</code> and <code>yaxs="i"</code> are used for both axes, which eliminates the &ldquo;floating&rdquo; x-axis that R typically plots for histograms.
</p>


<h3>Value</h3>

<p>A graphic is produced and nothing is returned unless <code>formula</code> results in only one histogram. In that case, an object of class <code>"histogram"</code> is returned, which is described in <code><a href="graphics.html#topic+hist">hist</a></code>.
</p>


<h3>IFAR Chapter</h3>

<p>3-Plotting Fundamentals.
</p>


<h3>Note</h3>

<p>Students often need to look at the distribution of a quantitative variable separated for different levels of a categorical variable. One method for examining these distributions is with <code>boxplot(quantitative~factor)</code>. Other methods use functions in <span class="pkg">Lattice</span> and <span class="pkg">ggplots2</span> but these packages have some learning &lsquo;overhead&rsquo; for newbie students. The formula notation, however, is a common way in R to tell R to separate a quantitative variable by the levels of a factor. Thus, this function adds code for formulas to the generic <code>hist</code> function. This allows newbie students to use a common notation (i.e., formula) to easily create multiple histograms of a quantitative variable separated by the levels of a factor.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>, but this implementation is largely a modification of the code provided by Marc Schwartz on the R-help mailing list on 1Jun07.
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>See base <code><a href="graphics.html#topic+hist">hist</a></code> for related functionality and <code><a href="plotrix.html#topic+multhist">multhist</a></code> in <span class="pkg">plotrix</span> for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Using the defaults
hist(Sepal.Length~Species,data=iris)

## Add x-labels and use a pre-fix on the main labels
hist(Sepal.Length~Species,data=iris,xlab="Sepal Length (cm)",
     pre.main="Species==")

## Use different breaks and different y-axis limits for each graph
hist(Sepal.Length~Species,data=iris,xlab="Sepal Length (cm)",
     same.breaks=FALSE,same.ylim=FALSE)

## Single histogram without grouping using formula notation
hist(~Sepal.Length,data=iris,xlab="Sepal Length (cm)")

## Using the bin width argument
hist(~Sepal.Length,data=iris,xlab="Sepal Length (cm)",w=1)
hist(Sepal.Length~Species,data=iris,xlab="Sepal Length (cm)",w=0.25)

</code></pre>

<hr>
<h2 id='histFromSum'>Create a histogram from a frequency table.</h2><span id='topic+histFromSum'></span><span id='topic+histFromSum.default'></span><span id='topic+histFromSum.formula'></span><span id='topic+histFromSum.table'></span>

<h3>Description</h3>

<p>Creates a histogram from values in a frequency table. Primarily used with already summarized length frequency data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histFromSum(x, ...)

## Default S3 method:
histFromSum(x, y, ...)

## S3 method for class 'table'
histFromSum(x, ...)

## S3 method for class 'formula'
histFromSum(x, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histFromSum_+3A_x">x</code></td>
<td>
<p>A numeric vector of bin/category values, a formula of the form <code>freq~cat</code> where <code>freq</code> contains the count/frequency values and <code>cat</code> contains the bin/category values, an object of class <code>table</code> from <code>table()</code> or <code>xtabs()</code>.</p>
</td></tr>
<tr><td><code id="histFromSum_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="histFromSum_+3A_y">y</code></td>
<td>
<p>A numeric vector of count/frequency values.</p>
</td></tr>
<tr><td><code id="histFromSum_+3A_data">data</code></td>
<td>
<p>A data.frame that contains the <code>freq</code> and <code>cat</code> variables if a formula is given in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a histogram fro values in a frequency table. The frequency table may be constructed from <code><a href="stats.html#topic+xtabs">xtabs</a></code>, <code><a href="base.html#topic+table">table</a></code>, or be in the form of a matrix or a data.frame (as if read in from an external data file).
</p>


<h3>Value</h3>

<p>None, but a graphic is created.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="graphics.html#topic+hist">hist</a></code> and <code><a href="#topic+hist.formula">hist.formula</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Make some dummy data with a length category variable
set.seed(634434789)
df &lt;- data.frame(tl=round(rnorm(100,100,20)))
df$lcat10 &lt;- lencat(df$tl,w=10)

## Summarize as tables
( tbl1 &lt;- xtabs(~lcat10,data=df) )
( tbl2 &lt;- table(df$lcat10) )

## Turn the tables into a data.frame for testing (convert
## the categories variables to numeric with fact2num())
df2 &lt;- data.frame(tbl1)
df2$lcat10 &lt;- fact2num(df2$lcat10)

## Turn the table into a matrix for testing
( mat1 &lt;- cbind(lcat10=as.numeric(rownames(tbl1)),freq=tbl1) )

## Histogram of the raw data ... set breaks and x-axis label
brks &lt;- seq(20,160,10)
xlbl &lt;- "Total Length (mm)"
hist(~tl,data=df,breaks=brks,xlab=xlbl)

## Use this function with various inputs ... changed colors
## on each plot so that it was obvious that a new plot was made.
# table from xtabs()
histFromSum(tbl1,breaks=brks,xlab=xlbl,col="gray75")
# table from table()
histFromSum(tbl2,breaks=brks,xlab=xlbl,col="gray70")
# vectors from data.frame
histFromSum(df2$lcat10,df2$Freq,breaks=brks,xlab=xlbl,col="gray65")
# vectors from matrix
histFromSum(mat1[,"lcat10"],mat1[,"freq"],breaks=brks,xlab=xlbl,col="gray60")
# formula from a data.frame
histFromSum(Freq~lcat10,data=df2,breaks=brks,xlab=xlbl,col="gray55")

</code></pre>

<hr>
<h2 id='hyperCI'>Confidence interval for population size (N) in hypergeometric distribution.</h2><span id='topic+hyperCI'></span>

<h3>Description</h3>

<p>Computes a confidence interval for population size (N) in hypergeometric distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperCI(M, n, m, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperCI_+3A_m">M</code></td>
<td>
<p>Number of successes in the population.</p>
</td></tr>
<tr><td><code id="hyperCI_+3A_n">n</code></td>
<td>
<p>Number of observations in the sample.</p>
</td></tr>
<tr><td><code id="hyperCI_+3A_m">m</code></td>
<td>
<p>Number of observed successes in the sample.</p>
</td></tr>
<tr><td><code id="hyperCI_+3A_conf.level">conf.level</code></td>
<td>
<p>Level of confidence to use for constructing confidence intervals (default is <code>0.95</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an inefficient brute-force algorithm. The algorithm computes the <code>conf.level</code> range of possible values for <code>m</code>, as if it was unknown, for a large range of values of N. It then finds all possible values of N for which <code>m</code> was in the <code>conf.level</code> range. The smallest and largest values of N for which <code>m</code> was in the <code>conf.level</code> range are the CI endpoints.
</p>


<h3>Value</h3>

<p>A 1x2 matrix that contains the lower and upper confidence interval bounds.
</p>


<h3>Note</h3>

<p>This algorithm is experimental at this point.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>hyperCI(50,25,10)

</code></pre>

<hr>
<h2 id='is.odd'>Determine if a number is odd or even.</h2><span id='topic+is.odd'></span><span id='topic+is.even'></span>

<h3>Description</h3>

<p>Determine if a number is odd or even.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.odd(x)

is.even(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.odd_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as x.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Individual values
is.odd(1)
is.odd(2)
is.even(3)
is.even(4)

## Vector of values
d &lt;- 1:8
data.frame(d,odd=is.odd(d),even=is.even(d))
</code></pre>

<hr>
<h2 id='jolly'>Jolly-Seber analysis from multiple mark-recapture events from an open population.</h2><span id='topic+jolly'></span><span id='topic+mrOpen'></span><span id='topic+summary.mrOpen'></span><span id='topic+confint.mrOpen'></span>

<h3>Description</h3>

<p>This function takes the two parts of a Method B table and uses the Jolly-Seber method to estimate the population size at each possible sample period and the apparent survival rate and number of additional individuals added to the population between possible sample periods. This method assumes that the population is open.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jolly(...)

mrOpen(
  mb.top,
  mb.bot = NULL,
  type = c("Jolly", "Manly"),
  conf.level = 0.95,
  phi.full = TRUE
)

## S3 method for class 'mrOpen'
summary(object, parm = c("N", "phi", "B", "M"), verbose = FALSE, ...)

## S3 method for class 'mrOpen'
confint(
  object,
  parm = c("N", "phi", "B"),
  level = NULL,
  conf.level = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jolly_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="jolly_+3A_mb.top">mb.top</code></td>
<td>
<p>A matrix that contains the &ldquo;top&rdquo; of the Method B table (i.e., a contingency table of capture sample (columns) and last seen sample (rows)) or an object of class <code>CapHist</code> from <code><a href="#topic+capHistSum">capHistSum</a></code>. See details.</p>
</td></tr>
<tr><td><code id="jolly_+3A_mb.bot">mb.bot</code></td>
<td>
<p>A data frame that contains the &ldquo;bottom&rdquo; of the Method B table (i.e., the number of marked fish in the sample (<code>m</code>), the number of unmarked fish in the sample (<code>u</code>), the total number of fish in the sample (<code>n</code>), and the number of marked fish returned to the population following the sample (<code>R</code>)).</p>
</td></tr>
<tr><td><code id="jolly_+3A_type">type</code></td>
<td>
<p>A string that indicates whether the large sample (normal theory) method of Jolly (<code>type="Jolly"</code>) or the &ldquo;arbitrary&rdquo; method of Manly (<code>type="Manly"</code>) should be used to construct confidence intervals.</p>
</td></tr>
<tr><td><code id="jolly_+3A_conf.level">conf.level</code></td>
<td>
<p>A single numeric that indicates the level of confidence to use for constructing confidence intervals (default is 0.95). See details.</p>
</td></tr>
<tr><td><code id="jolly_+3A_phi.full">phi.full</code></td>
<td>
<p>A logical that indicates whether the standard error for phi should include only sampling variability (<code>phi.full=FALSE</code>) or sampling and individual variability (<code>phi.full=TRUE</code>,default).</p>
</td></tr>
<tr><td><code id="jolly_+3A_object">object</code></td>
<td>
<p>An object from <code>mrOpen</code> (i.e., of class <code>mrOpen</code>).</p>
</td></tr>
<tr><td><code id="jolly_+3A_parm">parm</code></td>
<td>
<p>A string that identifies the model parameters for which to return summaries or confidence intervals. By default, all parameters are returned.</p>
</td></tr>
<tr><td><code id="jolly_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates if the observables and other notes should be printed in <code>summary</code> and if the type of confidence interval used should be printed in <code>confint</code>. See details.</p>
</td></tr>
<tr><td><code id="jolly_+3A_level">level</code></td>
<td>
<p>Same as <code>conf.level</code> but used for compatibility with generic <code>confint</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>jolly</code> is just a convenience wrapper that produces the exact same results as <code>mrOpen</code>.
</p>
<p>If <code>mb.top</code> contains an object from the <code><a href="#topic+capHistSum">capHistSum</a></code> function then <code>mb.bot</code> can be left missing. In this case, the function will extract the needed data from the <code>methodB.top</code> and <code>methodB.bot</code> portions of the <code>CapHist</code> class object.
</p>
<p>If <code>mb.top</code> is a matrix then it must be square, must have non-negative and no NA values in the upper triangle, and all NA values on the lower triangle and diagonal. If <code>mb.bot</code> is a matrix then it must have four rows named <code>m</code>, <code>u</code>, <code>n</code>, and <code>R</code> (see <code><a href="#topic+capHistSum">capHistSum</a></code> for definitions), all values must be non-NA, and the first value of <code>m</code> must be 0. The last value of <code>R</code> can either be 0 or some positive number (it is ultimately ignored in all calculations).
</p>
<p>All parameter estimates are performed using equations 4.6-4.9 from Pollock <em>et al.</em> (1990) and from page 204 in Seber 2002. If <code>type="Jolly"</code> then all standard errors (square root of the variances) are from equations 4.11, 4.12, and 4.14 in Pollock <em>et al.</em> (1990) (these are different than those in Seber (2002) ... see Pollock <em>et al.</em>'s note on page 21). If <code>type="Jolly"</code> and <code>phi.full=TRUE</code> then the full variance for the phi parameter is given as in eqn 4.18 in Pollock <em>et al.</em> (1990), otherwise eqn 4.13 from Pollock <em>et al.</em> (1990) is used. When <code>type="Jolly"</code> the confidence interval are produced using normal theory (i.e., estimate +/- z*SE). If <code>type="Manly"</code> then the confidence intervals for N and phi (none will be produced for B) are constructed using the methods of Manly (1984) and as described in 2.24-2.33 of Krebs (1989). No standard errors are returned when <code>type="Manly"</code>.
</p>
<p>The <code>summary</code> function returns estimates of M, N, phi, B, and their associated standard errors and, if <code>verbose=TRUE</code> the intermediate calculations of &ldquo;observables&rdquo; from the data &ndash; n, m, R, r, and z.
</p>
<p>The level of confidence is not set in the <code>confint</code> function, in contrast to most <code>confint</code> functions. Rather the confidence level is set in the main <code>mrOpen</code> function.
</p>


<h3>Value</h3>

<p>A list with the following items:
</p>

<ul>
<li><p> df A data frame that contains observable summaries from the data and estimates of the number of extant marked fish  (M), population size for each possible sample period (N), apparent survival rate between each possible pair of sample periods (phi), and the number of additional individuals added to the population between each possible pair of sample periods (B). In addition to the estimates, values of the standard errors and the lower and upper confidence interval bounds for each parameter are provided (however, see the details above).
</p>
</li>
<li><p> type The provided type of confidence intervals that was used.
</p>
</li>
<li><p> phi.full The provided logical that indicates the type of standard error for phi that was used.
</p>
</li>
<li><p> conf.level The provided level of confidence that was used.
</p>
</li></ul>



<h3>Testing</h3>

<p>The formulas have been triple-checked against formulas in Pollock <em>et al.</em> (1990), Manly (1984), and Seber (2002).
</p>
<p>The results for the <code><a href="#topic+CutthroatAL">CutthroatAL</a></code> data file (as analyzed in the example) was compared to results from the JOLLY program available at http://www.mbr-pwrc.usgs.gov/software/jolly.html. The r and z values matched, all M and N estimates match at one decimal place, all phi are within 0.001, and all B are within 0.7. The SE match for M except for two estimates that are within 0.1, match for N except for one estimate that is within 0.1, are within 0.001 for phi, and are within 1.3 for B (except for for the first estimate which is dramatically off).
</p>
<p>The results of <code>mrOpen</code> related to Table 4.4 of Pollock <em>et al.</em> (1990) match (to one decimal place) except for three estimates that are within 0.1% for N, match (to two decimal places) for phi except for where Pollock set phi&gt;1 to phi=1, match for B except for Pollock set B&lt;0 to B=0. The SE match (to two decimal places) for N except for N15 (which is within 0.5, &lt;5%), match (to three decimal places) for phi except for phi15 (which is within 0.001, &lt;0.5%), match (to two decimal places) for B except for B17 and B20 which are within 0.2 (&lt;0.2%)
</p>
<p>All point estimates of M, N, phi, and B and the SE of phi match the results in Table 2.3 of Krebs (1989) (within minimal rounding error for a very small number of results). The SE of N results are not close to those of Krebs (1989) (who does not provide a formula for SE so the discrepancy cannot be explored). The SE of B results match those of Krebs (1989) for 5 of the 8 values and are within 5% for 2 of the other 3 values (the last estimate is off by 27%).
</p>
<p>For comparing to Jolly's data as presented in Tables 5.1 and 5.2 of Seber (2002), M was within 4 (less than 1.5%), N was within 3% (except N2 which was within 9%), phi was within 0.01 (less than 1.5
</p>


<h3>IFAR Chapter</h3>

<p>9-Abundance from Capture-Recapture Data and 11-Mortality.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Jolly, G.M. 1965. Explicit estimates from capture-recapture data with both death and immigration &ndash; stochastic model. Biometrika, 52:225-247.
</p>
<p>Krebs, C.J. 1989. Ecological Methodology. Harper &amp; Row Publishers, New York.
</p>
<p>Leslie, P.H. and D. Chitty. 1951. The estimation of population parameters from data obtained by means of the capture-recapture method. I. The maximum likelihood equations for estimating the death-rate. Biometrika, 38:269-292.
</p>
<p>Manly, B.F.J. 1984. Obtaining confidence limits on parameters of the Jolly-Seber model for capture-recapture data. Biometrics, 40:749-758.
</p>
<p>Pollock, K.H., J.D. Nichols, C. Brownie, and J.E. Hines. 1991. Statistical inference for capture-recapture experiments. Wildlife Monographs, 107:1-97.
</p>
<p>Seber, G.A.F. 1965. A note on the multiple recapture census. Biometrika 52:249-259.
</p>
<p>Seber, G.A.F. 2002. The Estimation of Animal Abundance. Edward Arnold, second edition (reprinted).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+capHistSum">capHistSum</a></code>, <code><a href="#topic+mrClosed">mrClosed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First example -- capture histories summarized with capHistSum()
ch1 &lt;- capHistSum(CutthroatAL,cols2use=-1)  # ignore first column of fish ID
ex1 &lt;- mrOpen(ch1)
summary(ex1)
summary(ex1,verbose=TRUE)
summary(ex1,parm="N")
summary(ex1,parm=c("N","phi"))
confint(ex1)
confint(ex1,parm="N")
confint(ex1,parm=c("N","phi"))
confint(ex1,verbose=TRUE)

## Second example - Jolly's data -- summarized data entered "by hand"
s1 &lt;- rep(NA,13)
s2 &lt;- c(10,rep(NA,12))
s3 &lt;- c(3,34,rep(NA,11))
s4 &lt;- c(5,18,33,rep(NA,10))
s5 &lt;- c(2,8,13,30,rep(NA,9))
s6 &lt;- c(2,4,8,20,43,rep(NA,8))
s7 &lt;- c(1,6,5,10,34,56,rep(NA,7))
s8 &lt;- c(0,4,0,3,14,19,46,rep(NA,6))
s9 &lt;- c(0,2,4,2,11,12,28,51,rep(NA,5))
s10 &lt;- c(0,0,1,2,3,5,17,22,34,rep(NA,4))
s11 &lt;- c(1,2,3,1,0,4,8,12,16,30,rep(NA,3))
s12 &lt;- c(0,1,3,1,1,2,7,4,11,16,26,NA,NA)
s13 &lt;- c(0,1,0,2,3,3,2,10,9,12,18,35,NA)
jolly.top &lt;- cbind(s1,s2,s3,s4,s5,s6,s7,s8,s9,s10,s11,s12,s13)

n &lt;- c(54,146,169,209,220,209,250,176,172,127,123,120,142)
R &lt;- c(54,143,164,202,214,207,243,175,169,126,120,120,0)
m &lt;- c(0,10,37,56,53,77,112,86,110,84,77,72,95)
u &lt;- n-m
jolly.bot &lt;- rbind(m,u,n,R)

ex2 &lt;- mrOpen(jolly.top,jolly.bot)
summary(ex2,verbose=TRUE)
confint(ex2,verbose=TRUE)

ex3 &lt;- mrOpen(jolly.top,jolly.bot,type="Manly")
summary(ex3,verbose=TRUE)
confint(ex3,verbose=TRUE)

## demonstrate use of jolly()
ex3a &lt;- jolly(jolly.top,jolly.bot)

</code></pre>

<hr>
<h2 id='kCounts'>Specific utilities for use in a knitr document.</h2><span id='topic+kCounts'></span><span id='topic+kPvalue'></span><span id='topic+purl2'></span><span id='topic+reproInfo'></span>

<h3>Description</h3>

<p>Specific utilities for pretty printing various items in a knitr document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kCounts(value, capitalize = FALSE)

kPvalue(value, digits = 4, include.p = TRUE, latex = TRUE)

purl2(
  file,
  out.dir = NULL,
  newname = NULL,
  topnotes = NULL,
  moreItems = NULL,
  blanks = c("extra", "all", "none"),
  delHeader = NULL,
  timestamp = TRUE,
  ...
)

reproInfo(
  out = c("r", "markdown", "latex"),
  rqrdPkgs = NULL,
  elapsed = NULL,
  width = 0.95 * getOption("width"),
  addTOC = TRUE,
  newpage = FALSE,
  links = NULL,
  closeGraphics = TRUE,
  ind = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kCounts_+3A_value">value</code></td>
<td>
<p>A single numeric count or p-value.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_capitalize">capitalize</code></td>
<td>
<p>A logical that indicates if the returned words should be capitalized or not (the default).</p>
</td></tr>
<tr><td><code id="kCounts_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places to round the values to.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_include.p">include.p</code></td>
<td>
<p>A logical that indicates whether the result should be a character string with &ldquo;p=&rdquo; appended to the numerical result.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_latex">latex</code></td>
<td>
<p>A logical that indicates whether the resultant p-value string should be contained within dollar signs to form a latex formula.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_file">file</code></td>
<td>
<p>A string that contains the root name of the .RNW file. This will also be the name of the resultant purled file with .R appended.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_out.dir">out.dir</code></td>
<td>
<p>A string that indicates the directory structure in which the purled file should be located. This should not have a forward slash at the end.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_newname">newname</code></td>
<td>
<p>A string for the output filename (without the extension) from <code>purl2</code>.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_topnotes">topnotes</code></td>
<td>
<p>A character vector of lines to be added to the top of the output file. Each value in the vector will be placed on a single line at the top of the output file.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_moreitems">moreItems</code></td>
<td>
<p>A string that contains additional words that when found in the purled file will result in the entire line with those words to be deleted.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_blanks">blanks</code></td>
<td>
<p>A string that indicates if blank lines should be removed. If <code>blanks="all"</code> then all blank lines will be removed. If <code>blanks="extra"</code> then only &ldquo;extra&rdquo; blanks lines will be removed (i.e., one blank line will be left where there was originally more than one blank line).</p>
</td></tr>
<tr><td><code id="kCounts_+3A_delheader">delHeader</code></td>
<td>
<p>A single character that denotes the top and bottom of a block of lines that should be deleted from the script created by <code>purl2</code>.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_timestamp">timestamp</code></td>
<td>
<p>A logical that indicates whether a timestamp comment should be appended to the bottom of the script created by <code>purl2</code>.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_...">...</code></td>
<td>
<p>Additional arguments for the original <code>purl</code>.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_out">out</code></td>
<td>
<p>A string that indicates the type of output from <code>reproInfo</code> &ndash; Markdown, LaTeX, or simple R code.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_rqrdpkgs">rqrdPkgs</code></td>
<td>
<p>A string vector that contains packages that are required for the vignette and for which all dependencies should be found.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_elapsed">elapsed</code></td>
<td>
<p>A numeric, usually from <code>proc.time</code>, that is the time required to run the vignette. If <code>NULL</code> then this output will not be used. See the note below.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_width">width</code></td>
<td>
<p>A numeric that indicates the width to use for wrapping the reproducibility information when <code>out="r"</code>.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_addtoc">addTOC</code></td>
<td>
<p>A logical that indicates whether or not a table of contents entry for the reproducibility section should be added to the LaTeX output. Used only if <span class="rlang"><b>R</b></span>out=&quot;latex&quot;</p>
</td></tr>
<tr><td><code id="kCounts_+3A_newpage">newpage</code></td>
<td>
<p>A logical that indicates whether or not the reproducibility information should begin on a new page. Used only if <span class="rlang"><b>R</b></span>out=&quot;latex&quot;</p>
</td></tr>
<tr><td><code id="kCounts_+3A_links">links</code></td>
<td>
<p>A named character vector that will add a links bullet to the reproducibility information. The names will be shown and the values are the links. Used only if <span class="rlang"><b>R</b></span>out=&quot;markdown.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_closegraphics">closeGraphics</code></td>
<td>
<p>A logical that indicates whether the graphics device should be closed or not.</p>
</td></tr>
<tr><td><code id="kCounts_+3A_ind">ind</code></td>
<td>
<p>An integer that indicates the CRAN mirror to use. Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>kCounts</code> is used to convert numeric numbers to &lsquo;word&rsquo; numbers in a sentence.
</p>
</li>
<li> <p><code>kPvalue</code> is used to print &lsquo;pretty&rsquo; p-values. 
</p>
</li>
<li> <p><code>purl2</code> is used to create a modified (see below) Stangled or purled script.
</p>
</li>
<li> <p><code>reproInfo</code> is used to print &lsquo;reproducibility information&rsquo; for the document.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>kCounts</code> returns a numeric value if the count is less than zero or greater than ten and returns a character string of the number &lsquo;name&rsquo;. See the examples.
</p>
</li>
<li> <p><code>kPvalue</code> returns a character string of the supplied p-value rounded to the requested number of digits or a character string that indicates what the p-value is less than the value with a &lsquo;5&rsquo; in the <code>digits</code>+1 place. See the examples. 
</p>
</li>
<li> <p><code>purl2</code> is a modification of <code>purl</code> from <span class="pkg">knitr</span> that creates a file with the same name as <code>file</code> but with lines removed that contain certain words (those found in <code>ItemsToRemove</code> and <code>moreItems</code>). 
</p>
</li>
<li> <p><code>reproInfo</code> returns Markdown, LaTeX, or R code that prints &ldquo;reproducibility information&rdquo; at the bottom of the knitted document.
</p>
</li></ul>



<h3>Note</h3>

<p>In <code>reproInfo</code>, <code>elapsed</code> can be used to print the time it took to process the document by sending the elapsed time for processing to this argument. The simplest way to get an approximate elapsed time is to put  <code>st &lt;- proc.time()</code> very early (first line?) in your knitr code, put <code>et &lt;- proc.time()-st</code> very late in your knitr code (i.e., just prior to <code>reproInfo</code>), and then used <code>elapsed=et["user.self"]+et["sys.self"]</code> in <code>reproInfo</code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+formatC">formatC</a></code> for functionality similar to <code>kPvalue</code>. See <code>purl</code> and <code><a href="knitr.html#topic+knit">knit</a></code> in <span class="pkg">knitr</span> for functionality similar to <code>purl2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kCounts(7)
kCounts(17)
kCounts(0)
kCounts(-6)
kCounts(3,capitalize=TRUE)

kPvalue(0.123456789)
kPvalue(0.000123456)
kPvalue(0.000012345)
kPvalue(0.000012345,include.p=FALSE)
kPvalue(0.000012345,include.p=FALSE,latex=FALSE)

</code></pre>

<hr>
<h2 id='ksTest'>Kolmogorov-Smirnov Tests.</h2><span id='topic+ksTest'></span><span id='topic+ksTest.default'></span><span id='topic+ksTest.formula'></span>

<h3>Description</h3>

<p>Performs a one- or two-sample Kolmogorov-Smirnov test. Includes the option to perform the two-sample test using the formula notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksTest(x, ...)

## Default S3 method:
ksTest(
  x,
  y,
  ...,
  alternative = c("two.sided", "less", "greater"),
  exact = NULL
)

## S3 method for class 'formula'
ksTest(
  x,
  data = NULL,
  ...,
  alternative = c("two.sided", "less", "greater"),
  exact = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ksTest_+3A_x">x</code></td>
<td>
<p>A numeric vector of data values or a formula (see details).</p>
</td></tr>
<tr><td><code id="ksTest_+3A_...">...</code></td>
<td>
<p>Parameters of the distribution specified (as a character string) by <code>y</code>.</p>
</td></tr>
<tr><td><code id="ksTest_+3A_y">y</code></td>
<td>
<p>A numeric vector of data values, a character string naming a cumulative distribution function, or an actual cumulative distribution function. See <code><a href="stats.html#topic+ks.test">ks.test</a></code>.</p>
</td></tr>
<tr><td><code id="ksTest_+3A_alternative">alternative</code></td>
<td>
<p>A string that indicates the alternative hypothesis. See <code><a href="stats.html#topic+ks.test">ks.test</a></code>.</p>
</td></tr>
<tr><td><code id="ksTest_+3A_exact">exact</code></td>
<td>
<p><code>NULL</code> or a logical that indicates whether an exact p-value should be computed. See <code><a href="stats.html#topic+ks.test">ks.test</a></code>. Not available if ties are present, nor for the one-sided two-sample case.</p>
</td></tr>
<tr><td><code id="ksTest_+3A_data">data</code></td>
<td>
<p>A data frame that contains the variables in the formula for <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is exactly <code><a href="stats.html#topic+ks.test">ks.test</a></code> except that a formula may be used for the two-sample situation. The default version is simply a pass through to <code><a href="stats.html#topic+ks.test">ks.test</a></code>. See <code><a href="stats.html#topic+ks.test">ks.test</a></code> for more details.
</p>


<h3>Value</h3>

<p>See <code><a href="stats.html#topic+ks.test">ks.test</a></code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ks.test">ks.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see ks.test for other examples
x &lt;- rnorm(50)
y &lt;- runif(30)
df &lt;- data.frame(dat=c(x,y),
                 grp=factor(rep(c("x","y"),c(50,30))),
                 stringsAsFactors=FALSE)

## one-sample (from ks.test) still works
ksTest(x+2, "pgamma", 3, 2)
ks.test(x+2, "pgamma", 3, 2)

## first two-sample example in ?ks.test
ksTest(x,y)
ks.test(x,y)

## same as above but using data.frame and formula
ksTest(dat~grp,data=df)

</code></pre>

<hr>
<h2 id='lagratio'>Ratio of lagged observations.</h2><span id='topic+lagratio'></span>

<h3>Description</h3>

<p>Computes the ratio of lagged observations in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagratio(
  x,
  lag = 1L,
  recursion = 1L,
  differences = recursion,
  direction = c("backward", "forward"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagratio_+3A_x">x</code></td>
<td>
<p>A numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="lagratio_+3A_lag">lag</code></td>
<td>
<p>An integer representing the lag &lsquo;distance&rsquo;.</p>
</td></tr>
<tr><td><code id="lagratio_+3A_recursion">recursion</code></td>
<td>
<p>An integer that indicates the level of recursion for the calculations. A <code>1</code> will simply compute the ratios. A <code>2</code>, for example, will compute the ratios, save the result, and then compute the ratios of the results using the same <code>lag</code>. See examples.</p>
</td></tr>
<tr><td><code id="lagratio_+3A_differences">differences</code></td>
<td>
<p>Same as <code>recursion</code>. Used for symmetry with <code><a href="base.html#topic+diff">diff</a></code>.</p>
</td></tr>
<tr><td><code id="lagratio_+3A_direction">direction</code></td>
<td>
<p>A string that indicates the direction of calculation. A <code>"backward"</code> indicates that &lsquo;latter&rsquo; values are divided by &lsquo;former&rsquo; values. A <code>"forward"</code> indicates that &lsquo;former&rsquo; values are divided by &lsquo;latter&rsquo; values. See examples.</p>
</td></tr>
<tr><td><code id="lagratio_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>diff()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function behaves similarly to <code>diff()</code> except that it returns a vector or matrix of ratios rather than differences.
</p>


<h3>Value</h3>

<p>A vector or matrix of lagged ratios.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>diff</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Backward lagged ratios
# no recursion
lagratio(1:10,1)
lagratio(1:10,2)
# with recursion
lagratio(1:10,1,2)
lagratio(1:10,2,2)

## Forward lagged ratios
# no recursion
lagratio(10:1,1,direction="forward")
lagratio(10:1,2,direction="forward")
# with recursion
lagratio(10:1,1,2,direction="forward")
lagratio(10:1,2,2,direction="forward")

</code></pre>

<hr>
<h2 id='lencat'>Constructs length class/category variable.</h2><span id='topic+lencat'></span><span id='topic+lencat.default'></span><span id='topic+lencat.formula'></span>

<h3>Description</h3>

<p>Constructs a vector that contains the length class or category to which an individual belongs. Optionally, that vector can be appended to the original data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lencat(x, ...)

## Default S3 method:
lencat(
  x,
  w = 1,
  startcat = NULL,
  breaks = NULL,
  right = FALSE,
  use.names = FALSE,
  as.fact = use.names,
  droplevels = drop.levels,
  drop.levels = FALSE,
  ...
)

## S3 method for class 'formula'
lencat(
  x,
  data,
  w = 1,
  startcat = NULL,
  breaks = NULL,
  right = FALSE,
  use.names = FALSE,
  as.fact = use.names,
  droplevels = drop.levels,
  drop.levels = FALSE,
  vname = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lencat_+3A_x">x</code></td>
<td>
<p>A numeric vector that contains the length measurements or a formula of the form <code>~x</code> where &ldquo;x&rdquo; generically represents a variable in <code>data</code> that contains length measurements. This formula can only contain one variable.</p>
</td></tr>
<tr><td><code id="lencat_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
<tr><td><code id="lencat_+3A_w">w</code></td>
<td>
<p>A single numeric that indicates the width of length categories to create. Ignored if <code>breaks</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lencat_+3A_startcat">startcat</code></td>
<td>
<p>A single numeric that indicates the beginning of the first length category. Only used with <code>w</code>. See details for how this is handled when <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lencat_+3A_breaks">breaks</code></td>
<td>
<p>A numeric vector of lower values for the break points of the length categories.</p>
</td></tr>
<tr><td><code id="lencat_+3A_right">right</code></td>
<td>
<p>A logical that indicates if the intervals should be closed on the right (and open on the left) or vice versa.</p>
</td></tr>
<tr><td><code id="lencat_+3A_use.names">use.names</code></td>
<td>
<p>A logical that indicates whether the names for the values in <code>breaks</code> should be used for the levels in the new variable. Will throw a warning and then use default levels if <code>TRUE</code> but <code>names(breaks)</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="lencat_+3A_as.fact">as.fact</code></td>
<td>
<p>A logical that indicates that the new variable should be returned as a factor (<code>=TRUE</code>) or not (<code>=FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="lencat_+3A_droplevels">droplevels</code>, <code id="lencat_+3A_drop.levels">drop.levels</code></td>
<td>
<p>A logical that indicates that the new variable should retain all levels indicated in <code>breaks</code> (<code>=FALSE</code>; default) or not. Ignored if <code>as.fact=FALSE</code>.</p>
</td></tr>
<tr><td><code id="lencat_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains the length measurements given in the variable in the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="lencat_+3A_vname">vname</code></td>
<td>
<p>A string that contains the name for the new length class variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>breaks</code> is non-NULL, then <code>w</code> and <code>startcat</code> will be ignored. The vector of values in <code>breaks</code> should begin with a value smaller than the minimum observed value and end with a value larger than the maximum observed value. If the lowest break value is larger than the minimum observed value, then an error will occur. If the largest break value is smaller than the maximum observed value, then an additional break value larger than the maximum observed value will be added to <code>breaks</code> (and a warning will be sent). The values in <code>breaks</code> do not have to be equally spaced.
</p>
<p>If <code>breaks=NULL</code> (the default), then the value in <code>w</code> is used to create equally spaced categories. If <code>startcat=NULL</code> (the default), then the length categories will begin with the first value less than the minimum observed value &ldquo;rounded&rdquo; by <code>w</code>. For example, if the minimum observed value is 67, then the first length category will be 65 if <code>w=5</code>, 60 if <code>w=10</code>, 50 if <code>w=25</code>, and 50 if <code>w=50</code>. The length categories will continue from this starting value by values of <code>w</code> until a value greater than the largest observed value in <code>x</code>. The length categories are left-inclusive and right-exclusive by default (i.e., <code>right=FALSE</code>).
</p>
<p>The start of the length categories may also be set with <code>startcat</code>. The number in the <code>startcat</code> argument should be less than the smallest value in <code>x</code>. Additionally, the number of decimals in <code>startcat</code> should not be more than the number of decimals in <code>w</code> (e.g., <code>startcat=0.4</code> and <code>w=1</code> will result in an error).
</p>
<p>One may want to convert apparent numeric values to factor values if some of the length categories are missing (e.g., if factor values are used, for example, then tables of the length category values will have values for all length categories; i.e., it will have zeros for the length categories that are missing). The numeric values can be converted to factors by including <code>as.fact</code>. See the &ldquo;real data&rdquo; example.
</p>
<p>The observed values in <code>x</code> should be rounded to the appropriate number of decimals to avoid misplacement of individuals into incorrect length categories due to issues with machine-precision (see discussion in <code>all.equal</code>.)
</p>


<h3>Value</h3>

<p>If the formula version of the function is used, then a data.frame is returned with the a new variable, named as in <code>vname</code> (defaults to <code>LCat</code>), appended to the original data.frame. If the default version of the function is used, then a single vector is returned. The returned values will be numeric unless <code>breaks</code> is named and <code>use.names=TRUE</code> or if <code>as.fact=TRUE</code>.
</p>


<h3>IFAR Chapter</h3>

<p>2-Data Manipulation.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random lengths measured to nearest 0.1 unit
df1 &lt;- data.frame(len=round(runif(50,0.1,9.9),1))

# Create length categories by 0.1 unit
df1$LCat1 &lt;- lencat(df1$len,w=0.1)
xtabs(~LCat1,data=df1)

# length categories by 0.2 units
df1$LCat2 &lt;- lencat(df1$len,w=0.2)
xtabs(~LCat2,data=df1)

# length categories by 0.2 units starting at 0.1
df1$LCat3 &lt;- lencat(df1$len,w=0.2,startcat=0.1)
xtabs(~LCat3,data=df1)

# length categories as set by breaks
df1$LCat4 &lt;- lencat(df1$len,breaks=c(0,2,4,7,10))
xtabs(~LCat4,data=df1)

## A Second example
# random lengths measured to nearest unit
df2 &lt;- data.frame(len=round(runif(50,10,117),0))    

# length categories by 5 units
df2$LCat1 &lt;- lencat(df2$len,w=5)
xtabs(~LCat1,data=df2)

# length categories by 5 units starting at 7
df2$LCat2 &lt;- lencat(df2$len,w=5,startcat=7)
xtabs(~LCat2,data=df2)

# length categories by 10 units
df2$LCat3 &lt;- lencat(df2$len,w=10)
xtabs(~LCat3,data=df2)

# length categories by 10 units starting at 5
df2$LCat4 &lt;- lencat(df2$len,w=10,startcat=5)
xtabs(~LCat4,data=df2)

# length categories as set by breaks
df2$LCat5 &lt;- lencat(df2$len,breaks=c(5,50,75,150))
xtabs(~LCat5,data=df2)

## A Third example
# random lengths measured to nearest 0.1 unit
df3 &lt;- data.frame(len=round(runif(50,10,117),1))

# length categories by 5 units
df3$LCat1 &lt;- lencat(df3$len,w=5)
xtabs(~LCat1,data=df3)

## A Fourth example
# random lengths measured to nearest 0.01 unit
df4 &lt;- data.frame(len=round(runif(50,0.1,9.9),2))

# length categories by 0.1 unit
df4$LCat1 &lt;- lencat(df4$len,w=0.1)
xtabs(~LCat1,data=df4)

# length categories by 0.1 unit, but without missing categories
df4$LCat2 &lt;- lencat(df4$len,w=0.1,as.fact=TRUE)
xtabs(~LCat2,data=df4)

# length categories by 2 unit
df4$LCat3 &lt;- lencat(df4$len,w=2)
xtabs(~LCat3,data=df4)

## A Fifth example -- with real data
# remove variables with "anu" and "radcap" just for simplicity
smb1 &lt;- smb2 &lt;- SMBassWB[,-c(8:20)]

# 10 mm length classes - in default LCat variable
smb1$LCat10 &lt;- lencat(smb1$lencap,w=10)
head(smb1)
xtabs(~LCat10,data=smb1)

# Same as previous but returned as factor so levels with no fish still seen
smb1$LCat10A &lt;- lencat(smb1$lencap,w=10,as.fact=TRUE)
head(smb1)
xtabs(~LCat10A,data=smb1)

# Same as previous but returned as a factor with unused levels dropped
smb1$LCat10B &lt;- lencat(smb1$lencap,w=10,as.fact=TRUE,droplevels=TRUE)
head(smb1)
xtabs(~LCat10B,data=smb1)

# 25 mm length classes - in custom variable name
smb1$LCat25 &lt;- lencat(smb1$lencap,w=25)
head(smb1)
xtabs(~LCat25,data=smb1)

# using values from psdVal for Smallmouth Bass
smb1$PSDCat1 &lt;- lencat(smb1$lencap,breaks=psdVal("Smallmouth Bass"))
head(smb1)
xtabs(~PSDCat1,data=smb1)

# add category names
smb1$PSDCat2 &lt;- lencat(smb1$lencap,breaks=psdVal("Smallmouth Bass"),use.names=TRUE)
head(smb1)
xtabs(~PSDCat2,data=smb1)

# same as above but drop the unused levels
smb1$PSDCat2A &lt;- lencat(smb1$lencap,breaks=psdVal("Smallmouth Bass"),
                        use.names=TRUE,droplevels=TRUE)
head(smb1)
xtabs(~PSDCat2A,data=smb1)
str(smb1)

# same as above but not returned as a factor (returned as a character)
smb1$PSDcat2B &lt;- lencat(smb1$lencap,breaks=psdVal("Smallmouth Bass"),
                        use.names=TRUE,as.fact=FALSE)
str(smb1)

## A Sixth example -- similar to fifth example but using the formula notation
# 10 mm length classes - in default LCat variable
smb2 &lt;- lencat(~lencap,data=smb2,w=10)
head(smb2)

# 25 mm length classes - in custom variable name
smb2 &lt;- lencat(~lencap,data=smb2,w=25,vname="LenCat25")
head(smb2)

# using values from psdVal for Smallmouth Bass
smb2 &lt;- lencat(~lencap,data=smb2,breaks=psdVal("Smallmouth Bass"),vname="LenPsd")
head(smb2)

# add category names
smb2 &lt;- lencat(~lencap,data=smb2,breaks=psdVal("Smallmouth Bass"),vname="LenPsd2",
               use.names=TRUE,droplevels=TRUE)
head(smb2)
str(smb2)

</code></pre>

<hr>
<h2 id='logbtcf'>Constructs the correction-factor used when back-transforming log-transformed values.</h2><span id='topic+logbtcf'></span>

<h3>Description</h3>

<p>Constructs the correction-factor used when back-transforming log-transformed values according to Sprugel (1983). Sprugel's main formula &ndash; exp((syx^2)/2) &ndash; is used when syx is estimated for natural log transformed data. A correction for any base is obtained by multiplying the syx term by log_e(base) to give exp(((log_e(base)*syx)^2)/2). This more general formula is implemented here (if, of course, the base is exp(1) then the general formula reduces to the original specific formula).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logbtcf(obj, base = exp(1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logbtcf_+3A_obj">obj</code></td>
<td>
<p>An object from <code>lm</code>.</p>
</td></tr>
<tr><td><code id="logbtcf_+3A_base">base</code></td>
<td>
<p>A single numeric that indicates the base of the logarithm used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value that is the correction factor according to Sprugel (1983).
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Sprugel, D.G. 1983. Correcting for bias in log-transformed allometric equations. Ecology 64:209-210.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy data
df &lt;- data.frame(y=rlnorm(10),x=rlnorm(10))
df$logey &lt;- log(df$y)
df$log10y &lt;- log10(df$y)
df$logex &lt;- log(df$x)
df$log10x &lt;- log10(df$x)

# model and predictions on loge scale
lme &lt;- lm(logey~logex,data=df)
( ploge &lt;- predict(lme,data.frame(logex=log(10))) )
( pe &lt;- exp(ploge) )
( cfe &lt;- logbtcf(lme) )
( cpe &lt;- cfe*pe )

# model and predictions on log10 scale
lm10 &lt;- lm(log10y~log10x,data=df)
plog10 &lt;- predict(lm10,data.frame(log10x=log10(10)))
p10 &lt;- 10^(plog10)
( cf10 &lt;- logbtcf(lm10,10) )
( cp10 &lt;- cf10*p10 )

# cfe and cf10, cpe and cp10 should be equal
all.equal(cfe,cf10)
all.equal(cpe,cp10)

</code></pre>

<hr>
<h2 id='lwCompPreds'>Constructs plots of predicted weights at given lengths among different groups.</h2><span id='topic+lwCompPreds'></span>

<h3>Description</h3>

<p>Constructs plots of predicted weights at given lengths among different groups. These plots allow the user to explore differences in predicted weights at a variety of lengths when the weight-length relationship is not the same across a variety of groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lwCompPreds(
  object,
  lens = NULL,
  qlens = c(0.05, 0.25, 0.5, 0.75, 0.95),
  qlens.dec = 1,
  base = exp(1),
  interval = c("confidence", "prediction", "both"),
  center.value = 0,
  lwd = 1,
  connect.preds = TRUE,
  show.preds = FALSE,
  col.connect = "gray70",
  ylim = NULL,
  main.pre = "Length==",
  cex.main = 0.8,
  xlab = "Groups",
  ylab = "Predicted Weight",
  yaxs = "r",
  rows = round(sqrt(num)),
  cols = ceiling(sqrt(num))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lwCompPreds_+3A_object">object</code></td>
<td>
<p>An <code>lm</code> object (i.e., returned from fitting a model with <code>lm</code>). This model should have log(weight) as the response and log(length) as the explanatory covariate and an explanatory factor variable that describes the different groups.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_lens">lens</code></td>
<td>
<p>A numeric vector that indicates the lengths at which the weights should be predicted.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_qlens">qlens</code></td>
<td>
<p>A numeric vector that indicates the quantiles of lengths at which weights should be predicted. This is ignored if <code>lens</code> is non-null.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_qlens.dec">qlens.dec</code></td>
<td>
<p>A single numeric that identifies the decimal place that the lengths derived from <code>qlens</code> should be rounded to (Default is 1).</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_base">base</code></td>
<td>
<p>A single positive numeric value that indicates the base of the logarithm used in the <code>lm</code> object in <code>object</code>. The default is <code>exp(1)</code>, or the value e.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_interval">interval</code></td>
<td>
<p>A single string that indicates whether to plot confidence (<code>="confidence"</code>), prediction (<code>="prediction"</code>), or both (<code>="both"</code>) intervals.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_center.value">center.value</code></td>
<td>
<p>A single numeric value that indicates the log length used if the log length data was centered when constructing <code>object</code>.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_lwd">lwd</code></td>
<td>
<p>A single numeric that indicates the line width to be used for the confidence and prediction interval lines (if not <code>interval="both"</code>) and the prediction connections line. If <code>interval="both"</code> then the width of the prediction interval will be one less than this value so that the CI and PI appear different.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_connect.preds">connect.preds</code></td>
<td>
<p>A logical that indicates whether the predicted values should be connected with a line across groups or not.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_show.preds">show.preds</code></td>
<td>
<p>A logical that indicates whether the predicted values should be plotted with a point for each group or not.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_col.connect">col.connect</code></td>
<td>
<p>A color to use for the line that connects the predicted values (if <code>connect.preds=TRUE</code>).</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length two that indicates the limits of the y-axis to be used for each plot. If null then limits will be chosen for each graph individually.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_main.pre">main.pre</code></td>
<td>
<p>A character string to be used as a prefix for the main title. See details.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_cex.main">cex.main</code></td>
<td>
<p>A numeric value for the character expansion of the main title. See details.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_xlab">xlab</code></td>
<td>
<p>A single string for labeling the x-axis.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_ylab">ylab</code></td>
<td>
<p>A single string for labeling the y-axis.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_yaxs">yaxs</code></td>
<td>
<p>A single string that indicates how the y-axis is formed. See <code>par</code> for more details.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_rows">rows</code></td>
<td>
<p>A single numeric that contains the number of rows to use on the graphic.</p>
</td></tr>
<tr><td><code id="lwCompPreds_+3A_cols">cols</code></td>
<td>
<p>A single numeric that contains the number of columns to use on the graphic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None. However, a plot is produced.
</p>


<h3>IFAR Chapter</h3>

<p>7-Weight-Length.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># add log length and weight data to ChinookArg data
ChinookArg$logtl &lt;- log(ChinookArg$tl)
ChinookArg$logwt &lt;- log(ChinookArg$w)
# fit model to assess equality of slopes
lm1 &lt;- lm(logwt~logtl*loc,data=ChinookArg)
anova(lm1)

# set graphing parameters so that the plots will look decent
op &lt;- par(mar=c(3.5,3.5,1,1),mgp=c(1.8,0.4,0),tcl=-0.2)
# show predicted weights (w/ CI) at the default quantile lengths
lwCompPreds(lm1,xlab="Location")
# show predicted weights (w/ CI) at the quartile lengths
lwCompPreds(lm1,xlab="Location",qlens=c(0.25,0.5,0.75))
# show predicted weights (w/ CI) at certain lengths
lwCompPreds(lm1,xlab="Location",lens=c(60,90,120,150))
# show predicted weights (w/ just PI) at certain lengths
lwCompPreds(lm1,xlab="Location",lens=c(60,90,120,150),interval="prediction")
lwCompPreds(lm1,xlab="Location",lens=c(60,90,120,150),connect.preds=FALSE,show.preds=TRUE)

# fit model with a different base (plot should be the same as the first example)
ChinookArg$logtl &lt;- log10(ChinookArg$tl)
ChinookArg$logwt &lt;- log10(ChinookArg$w)
lm1 &lt;- lm(logwt~logtl*loc,data=ChinookArg)
lwCompPreds(lm1,base=10,xlab="Location")
## return graphing parameters to original state
par(op)

</code></pre>

<hr>
<h2 id='Mirex'>Mirex concentration, weight, capture year, and species of Lake Ontario salmon.</h2><span id='topic+Mirex'></span>

<h3>Description</h3>

<p>Mirex concentration, weight, capture year, and species of Lake Ontario Coho and Chinook salmon.
</p>


<h3>Format</h3>

<p>A data frame with 122 observations on the following 4 variables.
</p>
 
<dl>
<dt>year</dt><dd><p>a numeric vector of capture years</p>
</dd>
<dt>weight</dt><dd><p>a numeric vector of salmon weights (kg)</p>
</dd>
<dt>mirex</dt><dd><p>a numeric vector of mirex concentration in the salmon tissue (mg/kg)</p>
</dd>
<dt>species</dt><dd><p>a factor with levels <code>chinook</code> and <code>coho</code></p>
</dd>
</dl>



<h3>Details</h3>

<p>The <code>year</code> variable should be converted to a factor as shown in the example.
</p>


<h3>Topic(s)</h3>


<ul>
<li><p> Linear models
</p>
</li>
<li><p> Other
</p>
</li></ul>



<h3>Source</h3>

<p>From (actual data) Makarewicz, J.C., E.Damaske, T.W. Lewis, and M. Merner. 2003. Trend analysis reveals a recent reduction in mirex concentrations in Coho (<em>Oncorhynchus kisutch</em>) and Chinook (<em>O. tshawytscha</em>) Salmon from Lake Ontario. Environmental Science and Technology, 37:1521-1527. <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/Mirex.csv">CSV file</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mirex$year &lt;- factor(Mirex$year)
lm1 &lt;- lm(mirex~weight*year*species,data=Mirex)
anova(lm1)

</code></pre>

<hr>
<h2 id='Mmethods'>Estimate natural mortality from a variety of empirical methods.</h2><span id='topic+Mmethods'></span><span id='topic+metaM'></span><span id='topic+print.metaM'></span>

<h3>Description</h3>

<p>Several methods can be used to estimated natural mortality (M) from other types of data, including parameters from the von Bertalanffy growth equation, maximum age, and temperature. These relationships have been developed from meta-analyses of a large number of populations. Several of these methods are implemented in this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mmethods(what = c("all", "tmax", "K", "Hoenig", "Pauly"))

metaM(
  method = Mmethods(),
  justM = TRUE,
  tmax = NULL,
  K = NULL,
  Linf = NULL,
  t0 = NULL,
  b = NULL,
  L = NULL,
  Temp = NULL,
  t50 = NULL,
  Winf = NULL
)

## S3 method for class 'metaM'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mmethods_+3A_what">what</code></td>
<td>
<p>A string that indicates what grouping of methods to return. Defaults to returning all methods.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_method">method</code></td>
<td>
<p>A string that indicates which method or equation to use. See details.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_justm">justM</code></td>
<td>
<p>A logical that indicates whether just the estimate of M (<code>TRUE</code>; Default) or a more descriptive list should be returned.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_tmax">tmax</code></td>
<td>
<p>The maximum age for the population of fish.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_k">K</code></td>
<td>
<p>The Brody growth coefficient from the fit of the von Bertalanffy growth function.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_linf">Linf</code></td>
<td>
<p>The asymptotic mean length (cm) from the fit of the von Bertalanffy growth function.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_t0">t0</code></td>
<td>
<p>The x-intercept from the fit of the von Bertalanffy growth function.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_b">b</code></td>
<td>
<p>The exponent from the weight-length relationship (slope from the logW-logL relationship).</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_l">L</code></td>
<td>
<p>The body length of the fish (cm).</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_temp">Temp</code></td>
<td>
<p>The temperature experienced by the fish (C).</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_t50">t50</code></td>
<td>
<p>The age (time) when half the fish in the population are mature.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_winf">Winf</code></td>
<td>
<p>The asymptotic mean weight (g) from the fit of the von Bertalanffy growth function.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_x">x</code></td>
<td>
<p>A <code>metaM</code> object returned from <code>metaM</code> when <code>justM=FALSE</code>.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_digits">digits</code></td>
<td>
<p>A numeric that controls the number of digits printed for the estimate of M.</p>
</td></tr>
<tr><td><code id="Mmethods_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods. Not implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of several methods is chosen with <code>method</code>. The available methods can be seen with <code>Mmethods()</code> and are listed below with a brief description of where the equation came from. The sources (listed below) should be consulted for more specific information.
</p>

<ul>
<li> <p><code>method="HoenigNLS"</code>:  The &ldquo;modified Hoenig equation derived with a non-linear model&rdquo; as described in Then <em>et al.</em> (2015) on the third line of Table 3. This method was the preferred method suggested by Then <em>et al.</em> (2015). Requires only <code>tmax</code>.
</p>
</li>
<li> <p><code>method="PaulyLNoT"</code>: The &ldquo;modified Pauly length equation&rdquo; as described on the sixth line of Table 3 in Then <em>et al.</em> (2015). Then <em>et al.</em> (2015) suggested that this is the preferred model if maximum age (tmax) information was not available. Requires <code>K</code> and <code>Linf</code>.
</p>
</li>
<li> <p><code>method="PaulyL"</code>: The &ldquo;Pauly (1980) equation using fish lengths&rdquo; from his equation 11. This is the most commonly used method in the literature. Note that Pauly used common logarithms as used here but the model is often presented in other sources with natural logarithms. Requires <code>K</code>, <code>Linf</code>, and <code>T</code>.
</p>
</li>
<li> <p><code>method="PaulyW"</code>: The &ldquo;Pauly (1980) equation for weights&rdquo; from his equation 10. Requires <code>K</code>, <code>Winf</code>, and <code>T</code>.
</p>
</li>
<li> <p><code>method="HoeingO"</code>, <code>method="HoeingOF"</code>, <code>method="HoeingOM"</code>, <code>method="HoeingOC"</code>: The original &ldquo;Hoenig (1983) composite&rdquo;, &ldquo;fish&rdquo;, &ldquo;mollusc&rdquo;, and &ldquo;cetacean&rdquo; (fit with OLS) equations from the second column on page 899 of Hoenig (1983). Requires only <code>tmax</code>.
</p>
</li>
<li> <p><code>method="HoeingO2"</code>, <code>method="HoeingO2F"</code>, <code>method="HoeingO2M"</code>, <code>method="HoeingO2C"</code>: The original &ldquo;Hoenig (1983) composite&rdquo;, &ldquo;fish&rdquo;, &ldquo;mollusc&rdquo;, and &ldquo;cetacean&rdquo; (fit with Geometric Mean Regression) equations from the second column on page 537 of Kenchington (2014). Requires only <code>tmax</code>.
</p>
</li>
<li> <p><code>method="HoenigLM"</code>: The &ldquo;modified Hoenig equation derived with a linear model&rdquo; as described in Then <em>et al.</em> (2015) on the second line of Table 3. Requires only <code>tmax</code>.
</p>
</li>
<li> <p><code>method="HewittHoenig"</code>: The &ldquo;Hewitt and Hoenig (2005) equation&rdquo; from their equation 8. Requires only <code>tmax</code>.
</p>
</li>
<li> <p><code>method="tmax1"</code>: The &ldquo;one-parameter tmax equation&rdquo; from the first line of Table 3 in Then <em>et al.</em> (2015). Requires only <code>tmax</code>.
</p>
</li>
<li> <p><code>method="K1"</code>:  The &ldquo;one-parameter K equation&rdquo; from the fourth line of Table 3 in Then <em>et al.</em> (2015). Requires only <code>K</code>.
</p>
</li>
<li> <p><code>method="K2"</code>: The &ldquo;two-parameter K equation&rdquo; from the fifth line of Table 3 in Then <em>et al.</em> (2015). Requires only <code>K</code>.
</p>
</li>
<li> <p><code>method="JensenK1"</code>: The &ldquo;Jensen (1996) one-parameter K equation&rdquo;. Requires only <code>K</code>.
</p>
</li>
<li> <p><code>method="JensenK2"</code>: The &ldquo;Jensen (2001) two-parameter K equation&rdquo; from their equation 8. Requires only <code>K</code>.
</p>
</li>
<li> <p><code>method="Gislason"</code>: The &ldquo;Gislason <em>et al.</em> (2010) equation&rdquo; from their equation 2. Requires <code>K</code>, <code>Linf</code>, and <code>L</code>.
</p>
</li>
<li> <p><code>method="AlversonCarney"</code>: The &ldquo;Alverson and Carney (1975) equation&rdquo; as given in equation 10 of Zhang and Megrey (2006). Requires <code>tmax</code> and <code>K</code>.
</p>
</li>
<li> <p><code>method="Charnov"</code>: The &ldquo;Charnov <em>et al.</em> (2013) equation&rdquo; as given in the second column of page 545 of Kenchington (2014). Requires <code>K</code>, <code>Linf</code>, and <code>L</code>.
</p>
</li>
<li> <p><code>method="ZhangMegreyD"</code>, <code>method="ZhangMegreyP"</code>: The &ldquo;Zhang and Megrey (2006) equation&rdquo; as given in their equation 8 but modified for demersal or pelagic fish. Thus, the user must choose the fish type with <code>group</code>. Requires <code>tmax</code>, <code>K</code>, <code>t0</code>, <code>t50</code>, and <code>b</code>.
</p>
</li>
<li> <p><code>method="RikhterEfanov1"</code>: The &ldquo;Rikhter and Efanov (1976) equation (#2)&rdquo; as given in the second column of page 541 of Kenchington (2014) and in Table 6.4 of Miranda and Bettoli (2007). Requires only <code>t50</code>.
</p>
</li>
<li> <p><code>method="RikhterEfanov2"</code>: The &ldquo;Rikhter and Efanov (1976) equation (#1)&rdquo; as given in the first column of page 541 of Kenchington (2014). Requires <code>t50</code>, <code>K</code>, <code>t0</code>, and <code>b</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>Mmethods</code> returns a character vector with a list of methods. If only one <code>method</code> is chosen then <code>metaM</code> returns a single numeric if <code>justM=TRUE</code> or, otherwise, a <code>metaM</code> object that is a list with the following items:
</p>

<ul>
<li> <p><code>method</code>: The name for the method within the function (as given in <code>method</code>).
</p>
</li>
<li> <p><code>name</code>: A more descriptive name for the method.
</p>
</li>
<li> <p><code>givens</code>: A vector of values required by the method to estimate M.
</p>
</li>
<li> <p><code>M</code>: The estimated natural mortality rate.
</p>
</li></ul>

<p>If multiple <code>method</code>s are chosen then a data.frame is returned with the method name abbreviation in the <code>method</code> variable and the associated estimated M in the <code>M</code> variable.
</p>


<h3>Testing</h3>

<p>Kenchington (2014) provided life history parameters for several stocks and used many models to estimate M. I checked the calculations for the <code>PaulyL</code>, <code>PaulyW</code>, <code>HoenigO</code> for <code>Hgroup="all"</code> and <code>Hgroup="fish"</code>, <code>HoenigO2</code> for <code>Hgroup="all"</code> and <code>Hgroup="fish"</code>, <code>"JensenK1"</code>, <code>"Gislason"</code>, <code>"AlversonCarney"</code>, <code>"Charnov"</code>, <code>"ZhangMegrey"</code>, <code>"RikhterEfanov1"</code>, and <code>"RikhterEfanov2"</code> methods for three stocks. All results perfectly matched Kenchington's results for Chesapeake Bay Anchovy and Rio Formosa Seahorse. For the Norwegian Fjord Lanternfish, all results perfectly matched Kenchington's results except for when <code>Hgroup="fish"</code> for both <code>HoenigO</code> and <code>HoenigO2</code>.
</p>
<p>Results for the Rio Formosa Seahorse data were also tested against results from <code><a href="fishmethods.html#topic+M.empirical">M.empirical</a></code> from <span class="pkg">fishmethods</span> for the <code>PaulyL</code>, <code>PaulyW</code>, <code>HoenigO</code> for <code>Hgroup="all"</code> and <code>Hgroup="fish"</code>, <code>"Gislason"</code>, and <code>"AlversonCarney"</code> methods (the only methods in common between the two packages). All results matched perfectly.
</p>


<h3>IFAR Chapter</h3>

<p>11-Mortality.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Alverson, D.L. and M.J. Carney. 1975. A graphic review of the growth and decay of population cohorts. Journal du Conseil International pour l'Exploration de la Mer. 36:133-143.
</p>
<p>Charnov, E.L., H. Gislason, and J.G. Pope. 2013. Evolutionary assembly rules for fish life histories. Fish and Fisheries. 14:213-224.
</p>
<p>Gislason, H., N. Daan, J.C. Rice, and J.G. Pope. 2010. Size, growth, temperature and the natural mortality of marine fish. Fish and Fisheries 11:149-158.
</p>
<p>Hewitt, D.A. and J.M. Hoenig. 2005. Comparison of two approaches for estimating natural mortality based on longevity. Fishery Bulletin. 103:433-437. [Was (is?) from http://fishbull.noaa.gov/1032/hewitt.pdf.]
</p>
<p>Hoenig, J.M. 1983. Empirical use of longevity data to estimate mortality rates. Fishery Bulletin. 82:898-903. [Was (is?) from http://www.afsc.noaa.gov/REFM/age/Docs/Hoenig_EmpiricalUseOfLongevityData.pdf.]
</p>
<p>Jensen, A.L. 1996. Beverton and Holt life history invariants result from optimal trade-off of reproduction and survival. Canadian Journal of Fisheries and Aquatic Sciences. 53:820-822. [Was (is?) from .]
</p>
<p>Jensen, A.L. 2001. Comparison of theoretical derivations, simple linear regressions, multiple linear regression and principal components for analysis of fish mortality, growth and environmental temperature data. Environometrics. 12:591-598. [Was (is?) from http://deepblue.lib.umich.edu/bitstream/handle/2027.42/35236/487_ftp.pdf.]
</p>
<p>Kenchington, T.J. 2014. Natural mortality estimators for information-limited fisheries. Fish and Fisheries. 14:533-562.
</p>
<p>Pauly, D. 1980. On the interrelationships between natural mortality, growth parameters, and mean environmental temperature in 175 fish stocks. Journal du Conseil International pour l'Exploration de la Mer. 39:175-192. [Was (is?) from http://innri.unuftp.is/pauly/On%20the%20interrelationships%20betwe.pdf.]
</p>
<p>Rikhter, V.A., and V.N. Efanov. 1976. On one of the approaches for estimating natural mortality in fish populations (in Russian). ICNAF Research Document 76/IV/8, 12pp. 
</p>
<p>Then, A.Y., J.M. Hoenig, N.G. Hall, and D.A. Hewitt. 2015. Evaluating the predictive performance of empirical estimators of natural mortality rate using information on over 200 fish species. ICES Journal of Marine Science. 72:82-92.
</p>
<p>Zhang, C-I and B.A. Megrey. 2006. A revised Alverson and Carney model for estimating the instantaneous rate of natural mortality. Transactions of the American Fisheries Society. 135-620-633. [Was (is?) from http://www.pmel.noaa.gov/foci/publications/2006/zhan0531.pdf.]
</p>


<h3>See Also</h3>

<p>See <code><a href="fishmethods.html#topic+M.empirical">M.empirical</a></code> in <span class="pkg">fishmethods</span> for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## List names for available methods
Mmethods()
Mmethods("tmax")

## Simple Examples
metaM("tmax",tmax=20)
metaM("tmax",tmax=20,justM=FALSE)
metaM("HoenigNLS",tmax=20)
metaM("HoenigNLS",tmax=20,justM=FALSE)
 
## Example Patagonian Sprat ... from Table 2 in Cerna et al. (2014)
## http://www.scielo.cl/pdf/lajar/v42n3/art15.pdf
Temp &lt;- 11
Linf &lt;- 17.71
K &lt;- 0.78
t0 &lt;- -0.46
tmax &lt;- t0+3/K
t50 &lt;- t0-(1/K)*log(1-13.5/Linf)
metaM("RikhterEfanov1",t50=t50)
metaM("PaulyL",K=K,Linf=Linf,Temp=Temp)
metaM("PaulyL",K=K,Linf=Linf,Temp=Temp,justM=FALSE)
metaM("HoenigNLS",tmax=tmax)
metaM("HoenigO",tmax=tmax)
metaM("HewittHoenig",tmax=tmax)
metaM("AlversonCarney",K=K,tmax=tmax)

## Example of multiple calculations
metaM(c("RikhterEfanov1","PaulyL","HoenigO","HewittHoenig","AlversonCarney"),
     K=K,Linf=Linf,Temp=Temp,tmax=tmax,t50=t50)

## Example of multiple methods using Mmethods
# select some methods
metaM(Mmethods()[-c(15,20,22:24,26)],K=K,Linf=Linf,Temp=Temp,tmax=tmax,t50=t50)
# select just the Hoenig methods
metaM(Mmethods("Hoenig"),K=K,Linf=Linf,Temp=Temp,tmax=tmax,t50=t50)
 
</code></pre>

<hr>
<h2 id='mrClosed'>Estimate initial population size for single or multiple census mark-recapture data.</h2><span id='topic+mrClosed'></span><span id='topic+summary.mrClosed1'></span><span id='topic+confint.mrClosed1'></span><span id='topic+summary.mrClosed2'></span><span id='topic+confint.mrClosed2'></span><span id='topic+plot.mrClosed2'></span>

<h3>Description</h3>

<p>Estimates of the initial population size, along with associated confidence intervals, are constructed from single or multiple census mark-recapture data using a variety of methods. For single census data, the initial population size (N) is estimated from the number of marked animals from a first sample (M), number of captured animals in a second sample (n), and the number of recaptured marked animals in the second sample (m) using either the &lsquo;naive&rsquo; Petersen method or Chapman, Ricker, or Bailey modifications of the Petersen method. Single census data can also be separated by group (e.g., size class) to estimate the initial population size by class and for the overall population size. For multiple census data, the initial population size is estimated from the number of captured animals (n), number of recaptured marked animals (m), the number of marked animals that are marked and returned to the population (R), or the number of extant marked animals prior to the sample (M) on each of several samples using either the Schnabel (1938) or Schumacher-Eschmeyer (1943) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrClosed(
  M = NULL,
  n = NULL,
  m = NULL,
  R = NULL,
  method = c("Petersen", "Chapman", "Ricker", "Bailey", "Schnabel",
    "SchumacherEschmeyer"),
  labels = NULL,
  chapman.mod = TRUE
)

## S3 method for class 'mrClosed1'
summary(
  object,
  digits = 0,
  incl.SE = FALSE,
  incl.all = TRUE,
  verbose = FALSE,
  ...
)

## S3 method for class 'mrClosed1'
confint(
  object,
  parm = NULL,
  level = conf.level,
  conf.level = 0.95,
  digits = 0,
  type = c("suggested", "binomial", "hypergeometric", "normal", "Poisson"),
  bin.type = c("wilson", "exact", "asymptotic"),
  poi.type = c("exact", "daly", "byar", "asymptotic"),
  incl.all = TRUE,
  verbose = FALSE,
  ...
)

## S3 method for class 'mrClosed2'
summary(object, digits = 0, verbose = FALSE, ...)

## S3 method for class 'mrClosed2'
confint(
  object,
  parm = NULL,
  level = conf.level,
  conf.level = 0.95,
  digits = 0,
  type = c("suggested", "normal", "Poisson"),
  poi.type = c("exact", "daly", "byar", "asymptotic"),
  verbose = FALSE,
  ...
)

## S3 method for class 'mrClosed2'
plot(
  x,
  pch = 19,
  col.pt = "black",
  xlab = "Marked in Population",
  ylab = "Prop. Recaptures in Sample",
  loess = FALSE,
  lty.loess = 2,
  lwd.loess = 1,
  col.loess = "gray20",
  trans.loess = 10,
  span = 0.9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrClosed_+3A_m">M</code></td>
<td>
<p>A numeric representing the number of marked fish from the first sample (single-census), an object from <code>capHistSum()</code> (single- or multiple-census), or numeric vector of marked fish prior to ith samples (multiple-census).</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_n">n</code></td>
<td>
<p>A numeric representing the number of captured fish in the second sample (single-census) or numeric vector of captured fish in ith sample (multiple-census).</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_m">m</code></td>
<td>
<p>A numeric representing the number of recaptured (marked) fish in the second sample (single-census) or numeric vector of recaptured (marked) fish in ith sample (multiple-census).</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_r">R</code></td>
<td>
<p>A numeric vector representing the number of marked fish returned to the population (multiple-census). Note that several references use the number of &ldquo;new&rdquo; marks returned to the population rather than the &ldquo;total&rdquo; number of marks returned to the population that is used here.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_method">method</code></td>
<td>
<p>A single string that identifies the type of calculation method to use in the main function.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_labels">labels</code></td>
<td>
<p>A character or character vector used to label the rows of the resulting output matrix when using a single census method separated by groups. Must be the same length as <code>M</code>, <code>n</code>, and <code>m</code>. Defaults to upper-case letters if no values are given.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_chapman.mod">chapman.mod</code></td>
<td>
<p>A logical that represents whether the Chapman modification should be used (<code>=TRUE</code>, default) or not (<code>=FALSE</code>) when performing the Schnabel multiple census method.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_object">object</code>, <code id="mrClosed_+3A_x">x</code></td>
<td>
<p>An <code>mrClosed1</code> or <code>mrClosed2</code> object.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_digits">digits</code></td>
<td>
<p>The number of decimal digits to round the population estimates to. If <code>incl.SE=TRUE</code> then SE will be rounded to one more decimal place then given in <code>digits</code>.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_incl.se">incl.SE</code></td>
<td>
<p>A logical that indicates whether the results should include the calculated SE value. See details.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_incl.all">incl.all</code></td>
<td>
<p>A logical that indicates whether an overall population estimate should be computed when using a single census method that has been separated into sub-groups. See details.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates whether a reminder of the inputted values and what type of method was used should be printed with the summary and confidence interval results.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_parm">parm</code></td>
<td>
<p>Not used here (included in <code>confint</code> generic).</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_level">level</code></td>
<td>
<p>Same as <code>conf.level</code> but used for compatibility with <code>confint</code> generic.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_conf.level">conf.level</code></td>
<td>
<p>A numeric representing the level of confidence to use for confidence intervals.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_type">type</code></td>
<td>
<p>A single string that identifies the distribution to use when constructing confidence intervals in <code>confint</code>. See details.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_bin.type">bin.type</code></td>
<td>
<p>A string that identifies the method used to construct binomial confidence intervals (default is <code>"wilson"</code>). This is only used if <code>type="binomial"</code> in <code>confint</code>. See details of <code><a href="#topic+binCI">binCI</a></code>.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_poi.type">poi.type</code></td>
<td>
<p>A string that identifies the method used to construct Poisson confidence intervals (default is <code>"exact"</code>). This is only used if <code>type="Poisson"</code> in <code>confint</code>. See details of <code><a href="#topic+poiCI">poiCI</a></code>.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_pch">pch</code></td>
<td>
<p>A numeric used to indicate the type of plotting character.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_col.pt">col.pt</code></td>
<td>
<p>a string used to indicate the color of the plotted points.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x-axis.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y-axis.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_loess">loess</code></td>
<td>
<p>A logical that indicates if a loess smoother line (and approximate 95% confidence band) is fit to and shown on plot.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_lty.loess">lty.loess</code></td>
<td>
<p>A single numeric used to indicate the type of line used for the loess line.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_lwd.loess">lwd.loess</code></td>
<td>
<p>A single numeric used to indicate the line width of the loess line.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_col.loess">col.loess</code></td>
<td>
<p>A single string used to indicate the color of the loess line.</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_trans.loess">trans.loess</code></td>
<td>
<p>A single numeric that indicates how transparent the loess band should be (larger numbers are more transparent).</p>
</td></tr>
<tr><td><code id="mrClosed_+3A_span">span</code></td>
<td>
<p>A single numeric that controls the degree of smoothing. Values closer to 1 are more smooth.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For single census data, the following methods can be used:
</p>

<ul>
<li><p><code>method="Petersen"</code>. The &lsquo;naive&rsquo; Petersen as computed using equation 2.1 from Krebs (1989).
</p>
</li>
<li><p><code>method="Chapman"</code>. The Chapman (1951) modification of the Petersen method as computed using equation 2.2 from Krebs (1989).
</p>
</li>
<li><p><code>method="Ricker"</code>. The Ricker (1975) modification of the Petersen as computed using equation 3.7 from Ricker (1975). This is basically the same <code>method="Chapman"</code> except that Ricker (1975) did NOT subtract a 1 from the answer in the final step. Thus, the estimate from <code>method="Chapman"</code> will always be one less than the estimate from <code>method="Ricker"</code>.
</p>
</li>
<li><p><code>method="Bailey"</code>. The Bailey (1951, 1952) modification of the Petersen as computed using equation 2.3 from Krebs (1989).
</p>
</li></ul>

<p>If <code>M</code> contains an object from <code><a href="#topic+capHistSum">capHistSum</a></code> and one of Petersen, Chapman, Ricker, or Bailey methods has been selected with <code>method=</code> then <code>n=</code> and <code>m=</code> can be left missing or will be ignored and the needed data will be extracted from the <code>sum</code> portion of the <code>CapHist</code> class object. If the data were not summarized with <code><a href="#topic+capHistSum">capHistSum</a></code> then all of <code>M=</code>, <code>n=</code>, and <code>m=</code> must be supplied by the user.
</p>
<p>The population estimate (as computed with the formulas noted in the table above) is extracted with <code>summary</code>. In addition, the standard error of the population estimate (SE) can be extracted by including <code>incl.SE=TRUE</code>. The SE is from equation 3.6 (p. 78) in Ricker (1975) for the Petersen method, from p. 60 (near bottom) of Seber (2002) for the Chapman method, from p. 61 (middle) of Seber (2002) (and as noted on p. 79 of Ricker (1975)) for the Bailey method, and from equation 3.8 (p. 78) in Ricker (1975) for the Ricker method.
</p>
<p>Confidence intervals for the initial population size from the single census methods can be constructed using four different distributions as chosen with <code>type=</code> in <code>confint</code>. If <code>type="suggested"</code> then the type of confidence interval suggested by the rules on p. 18 in Krebs (1989) are used. The general methods for constructing confidence intervals for N are described below
</p>

<ul>
<li><p><code>type="hypergeometric"</code>. Uses <code><a href="#topic+hyperCI">hyperCI</a></code>. This is experimental at this point.
</p>
</li>
<li><p><code>type="binomial"</code>. Use <code><a href="#topic+binCI">binCI</a></code> to construct a confidence interval for m/n (Petersen method) or (m+1)/(n+1) (Chapman, Bailey, Ricker methods), divides M or (M+1) by the CI endpoints, and subtract 1 (for the Chapman method).
</p>
</li>
<li><p><code>type="Poisson"</code>. Use <code><a href="#topic+poiCI">poiCI</a></code> to construct a confidence interval for m (Petersen method) or (m+1) (Chapman, Bailey, Ricker methods), substitute the CI endpoints into the appropriate equation for estimating N, and subtract 1 (for the Chapman method).
</p>
</li>
<li><p><code>type="normal"</code>. Used equation 2.4 (p.20) from Krebs (2002) for the Petersen method. For the other methods, used N+/- Z(0.975)*SE, where the SE was computed as noted above.
</p>
</li></ul>

<p>If <code>incl.all=TRUE</code> in <code>summary</code> and population estimates have been constructed for multiple sub-groups then an overall population estimate is included by summing the population estimates for the multiple sub-groups. If <code>incl.SE=TRUE</code>, then an overall SE is computed by taking the square root of the summed VARIANCES for the multiple sub-groups.
</p>
<p>For multiple census data, the following methods can be declared for use with the <code>method=</code> argument:
</p>

<ul>
<li><p><code>method="Schnabel"</code>. The Schnabel (1938) method as computed with equation 3.15 from Ricker (1975).
</p>
</li>
<li><p><code>method="SchumacherEschmeyer"</code>. The Schumacher and Eschmeyer (1943) method as computed with equation 3.12 from Ricker (1975) eqn 3.12.
</p>
</li></ul>

<p>If <code>M</code> contains an object from <code><a href="#topic+capHistSum">capHistSum</a></code> and the Schnabel or Schumacher-Eschmeyer methods has been chosen then <code>n</code>, <code>m</code> and <code>R</code> can be left missing or will be ignored. In this case, the needed data is extracted from the <code>sum</code> portion of the <code>CapHist</code> class object. Otherwise, the user must supply vectors of results in <code>n</code>, <code>m</code>, and <code>R</code> or <code>M</code>.
</p>
<p>The population estimate for each method is extracted with <code>summary</code>. Standard errors for the population estimate can NOT be computed for the Schnabel or Schumacher-Eschmeyer methods (a warning will be produced if <code>incl.SE=TRUE</code> is used).
</p>
<p>Confidence intervals for the initial population size using multiple census methods can be constructed using the normal or Poisson distributions for the Schnabel method or the normal distribution for the Schumacher-Eschmeyer method as chosen with <code>type=</code>. If <code>type="suggested"</code> then the type of confidence interval suggested by the rule on p. 32 of Krebs (1989) is used (for the Schnabel method). If <code>type="Poisson"</code> for the Schnabel method then a confidence interval for the sum of m is computed with <code><a href="#topic+poiCI">poiCI</a></code> and the end points are substituted into the Schnabel equation to produce a CI for the population size. If <code>type="normal"</code> for the Schnabel method then the standard error for the <em>inverse</em> of the population estimate is computed as the square root of equation 2.11 from Krebs (1989) or equation 3.16 from Ricker (1975). The standard error for the Schumacher-Eschmeyer method is for the <em>inverse</em> of the population estimate and is computed with equation 2.14 from Krebs (1989) [Note that the divisor in Krebs (1989) is different than the divisor in equation 3.12 in Ricker (1975), but is consistent with equation 4.17 in Seber (2002).]  The confidence interval for the <em>inverse</em> population estimate is constructed from the inverse population estimate plus/minus a t critical value times the standard error for the inverse population estimate. The t critical value uses the number of samples minus 1 for the Schnabel method and the number of samples minus 2 when for the Schumacher-Eschmeyer method according to p. 32 of Krebs (1989) (note that this is different than what Ricker (1975) does). Finally, the confidence interval for the population estimate is obtained by inverting the confidence interval for the inverse population estimate. Note that confidence intervals for the population size when <code>type="normal"</code> may contain negative values (for the upper value) when the population estimate is relatively large and the number of samples is small (say, three) because the intervals are originally constructed on the inverted population estimate and they use the t-distribution.
</p>
<p>The <code>plot</code> can be used to identify assumption violations in the Schnabel and Schumacher-Eschmeyer methods (an error will be returned if used with any of the other methods). If the assumptions ARE met then the plot of the proportion of marked fish in a sample versus the cumulative number of marked fish should look linear. A loess line (with approximate 95% confidence bands) can be added to aid interpretation with <code>loess=TRUE</code>. Note, however, that adding the loess line may return a number of warning or produce a non-informative if the number of samples is small (&lt;8).
</p>


<h3>Value</h3>

<p>A list with the following items
</p>

<ul>
<li><p> M The number of marked fish from the first sample that was provided.
</p>
</li>
<li><p> n The number of captured fish in the second sample that was provided.
</p>
</li>
<li><p> m The number of recaptured (marked) fish in the second sample that was provided.
</p>
</li>
<li><p> M1 The adjusted (depending on <code>type</code>) number of marked fish from the first sample.
</p>
</li>
<li><p> n1 The adjusted (depending on <code>type</code>) number of captured fish in the second sample.
</p>
</li>
<li><p> m1 The adjusted (depending on <code>type</code>) number of recaptured (marked) fish in the second sample.
</p>
</li>
<li><p> cf A correction factor for the population estimate that depends on <code>type</code>.
</p>
</li>
<li><p> method The type of method used (provided by the user).
</p>
</li>
<li><p> methodLbl A label for the type of method used.
</p>
</li>
<li><p> N The estimated initial population size.
</p>
</li>
<li><p> labels Labels for the rows of summary matrix.
</p>
</li></ul>



<h3>Testing</h3>

<p>The results from the single census methods have had the following checks. The population estimates for all methods match reputable sources. The SE for the Chapman and Bailey methods match the results from <code><a href="fishmethods.html#topic+mrN.single">mrN.single</a></code> in <span class="pkg">fishmethods</span>,  The CI for the Petersen, Chapman, and Bailey methods partially match (are within 1
</p>
<p>The results for the multiple census methods have had the following checks. The population estimates for both methods match reputable sources. The intermediate calculations for both methods match those in Krebs (1989). The confidence interval for the Schnabel method using the Poisson distribution does NOT match Krebs (1989). This appears to be a difference in the use <code><a href="#topic+poiCI">poiCI</a></code> here versus distributional tables in Krebs (i.e., the difference appears to be completely in the critical values from the Poisson distribution). The confidence interval for the Schnabel method using the normal or the Poisson distribution do NOT match Ricker (1975), but there is not enough information in Ricker to determine why (it is likely due to numerical differences on the inverse scale). The confidence interval for the Schumacher-Eschmeyer method do match Krebs (1989) but not Ricker (1975). The Ricker result may be due to different df as noted above.
</p>


<h3>IFAR Chapter</h3>

<p>9-Abundance from Capture-Recapture Data.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Krebs, C.J. 1989. Ecological Methodology. Addison-Welsey Educational Publishing.
</p>
<p>Ricker, W.E. 1975. Computation and interpretation of biological statistics of fish populations. Technical Report Bulletin 191, Bulletin of the Fisheries Research Board of Canada. [Was (is?) from http://www.dfo-mpo.gc.ca/Library/1485.pdf.]
</p>
<p>Seber, G.A.F. 2002. The Estimation of Animal Abundance and Related Parameters. Edward Arnold, second edition.
</p>
<p>Schnabel, Z.E. 1938. The estimation of the total fish population of a lake. American Mathematician Monthly, 45:348-352.
</p>
<p>Schumacher, F.X. and R.W. Eschmeyer. 1943. The estimation of fish populations in lakes and ponds. Journal of the Tennessee Academy of Sciences, 18:228-249.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+capHistSum">capHistSum</a></code> for generating input data from capture histories. See <code><a href="#topic+poiCI">poiCI</a></code>, <code><a href="#topic+binCI">binCI</a></code>, and <code><a href="#topic+hyperCI">hyperCI</a></code> for specifics on functions used in confidence interval construction. See <code><a href="#topic+mrOpen">mrOpen</a></code> for handling mark-recapture data in an open population. See <code><a href="FSAdata.html#topic+SunfishIN">SunfishIN</a></code> in <span class="pkg">FSAdata</span> for an example to test matching of results with Ricker (1975)'  See <code><a href="fishmethods.html#topic+mrN.single">mrN.single</a></code> and <code><a href="fishmethods.html#topic+schnabel">schnabel</a></code> in <span class="pkg">fishmethods</span> for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Single census with no sub-groups
## Petersen estimate -- the default
mr1 &lt;- mrClosed(346,184,49)
summary(mr1)
summary(mr1,verbose=TRUE)
summary(mr1,incl.SE=TRUE)
summary(mr1,incl.SE=TRUE,digits=1)
confint(mr1)
confint(mr1,verbose=TRUE)
confint(mr1,type="hypergeometric")

## Chapman modification of the Petersen estimate
mr2 &lt;- mrClosed(346,184,49,method="Chapman")
summary(mr2,incl.SE=TRUE)
summary(mr2,incl.SE=TRUE,verbose=TRUE)

### Single census, using capHistSum() results
## data in capture history format
str(BluegillJL)
ch1 &lt;- capHistSum(BluegillJL)
mr3 &lt;- mrClosed(ch1)
summary(mr3,verbose=TRUE)
confint(mr3,verbose=TRUE)

### Single census with sub-groups
marked &lt;- c(93,35,72,16,46,20)
captured &lt;- c(103,30,73,17,39,18)
recaps &lt;- c(20,23,52,15,35,16)
lbls &lt;- c("YOY","Juvenile","Stock","Quality","Preferred","Memorable")
mr4 &lt;- mrClosed(marked,captured,recaps,method="Ricker",labels=lbls)
summary(mr4)
summary(mr4,incl.SE=TRUE)
summary(mr4,incl.SE=TRUE,verbose=TRUE)
summary(mr4,incl.SE=TRUE,incl.all=FALSE,verbose=TRUE)
confint(mr4)
confint(mr4,verbose=TRUE)
confint(mr4,incl.all=FALSE,verbose=TRUE)

### Multiple Census
## Data in summarized form ... Schnabel method
mr5 &lt;- with(PikeNY,mrClosed(n=n,m=m,R=R,method="Schnabel"))
plot(mr5)
plot(mr5,loess=TRUE)
summary(mr5)
summary(mr5,verbose=TRUE)
confint(mr5)
confint(mr5,verbose=TRUE)

## Schumacher-Eschmeyer method
mr6 &lt;- with(PikeNY,mrClosed(n=n,m=m,R=R,method="Schumacher"))
summary(mr6)
confint(mr6)

### Capture history data summarized by capHistSum()
# ignore first column of ID numbers
ch2 &lt;- capHistSum(PikeNYPartial1,cols2ignore="id")

## Schnabel method
mr7 &lt;- mrClosed(ch2,method="Schnabel")
plot(mr7)
summary(mr7)
confint(mr7)

</code></pre>

<hr>
<h2 id='nlsBoot'>Associated S3 methods for nlsBoot from nlstools.</h2><span id='topic+nlsBoot'></span><span id='topic+confint.nlsBoot'></span><span id='topic+htest.nlsBoot'></span><span id='topic+predict.nlsBoot'></span><span id='topic+htest'></span>

<h3>Description</h3>

<p>Provides S3 methods to construct non-parametric bootstrap confidence intervals and hypothesis tests for parameter values and predicted values of the response variable for a <code><a href="nlstools.html#topic+nlsBoot">nlsBoot</a></code> object from the <span class="pkg">nlstools</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nlsBoot'
confint(
  object,
  parm = NULL,
  level = conf.level,
  conf.level = 0.95,
  plot = FALSE,
  err.col = "black",
  err.lwd = 2,
  rows = NULL,
  cols = NULL,
  ...
)

## S3 method for class 'nlsBoot'
predict(object, FUN, conf.level = 0.95, digits = NULL, ...)

htest(object, ...)

## S3 method for class 'nlsBoot'
htest(
  object,
  parm = NULL,
  bo = 0,
  alt = c("two.sided", "less", "greater"),
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlsBoot_+3A_object">object</code></td>
<td>
<p>An object saved from <code>nlsBoot()</code>.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_parm">parm</code></td>
<td>
<p>An integer that indicates which parameter to compute the confidence interval or hypothesis test for. The confidence interval Will be computed for all parameters if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_level">level</code></td>
<td>
<p>Same as <code>conf.level</code>. Used for compatibility with the main <code>confint</code>.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_conf.level">conf.level</code></td>
<td>
<p>A level of confidence as a proportion.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_plot">plot</code></td>
<td>
<p>A logical that indicates whether a plot should be constructed. If <code>confint</code>, then a histogram of the <code>parm</code> parameters from the bootstrap samples with error bars that illustrate the bootstrapped confidence intervals will be constructed. If codehtest, then a histogram of the <code>parm</code> parameters with a vertical lines illustrating the <code>bo</code>value will be constructed.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_err.col">err.col</code></td>
<td>
<p>A single numeric or character that identifies the color for the error bars on the plot.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_err.lwd">err.lwd</code></td>
<td>
<p>A single numeric that identifies the line width for the error bars on the plot.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_rows">rows</code></td>
<td>
<p>A numeric that contains the number of rows to use on the graphic.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_cols">cols</code></td>
<td>
<p>A numeric that contains the number of columns to use on the graphic.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_...">...</code></td>
<td>
<p>Additional arguments to functions.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_fun">FUN</code></td>
<td>
<p>The function to be applied for the prediction. See the examples.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_digits">digits</code></td>
<td>
<p>A single numeric that indicates the number of digits for the result.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_bo">bo</code></td>
<td>
<p>The null hypothesized parameter value.</p>
</td></tr>
<tr><td><code id="nlsBoot_+3A_alt">alt</code></td>
<td>
<p>A string that identifies the &ldquo;direction&rdquo; of the alternative hypothesis. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>confint</code> finds the two quantiles that have the proportion (1-<code>conf.level</code>)/2 of the bootstrapped parameter estimates below and above. This is an approximate 100<code>conf.level</code>% confidence interval.
</p>
<p>In <code>htest</code> the &ldquo;direction&rdquo; of the alternative hypothesis is identified by a string in the <code>alt=</code> argument. The strings may be <code>"less"</code> for a &ldquo;less than&rdquo; alternative, <code>"greater"</code> for a &ldquo;greater than&rdquo; alternative, or <code>"two.sided"</code> for a &ldquo;not equals&rdquo; alternative (the DEFAULT). In the one-tailed alternatives the p-value is the proportion of bootstrapped parameter estimates in <code>object$coefboot</code> that are extreme of the null hypothesized parameter value in <code>bo</code>. In the two-tailed alternative the p-value is twice the smallest of the proportion of bootstrapped parameter estimates above or below the null hypothesized parameter value in <code>bo</code>.
</p>
<p>In <code>predict</code>, a user-supplied function is applied to each row of the <code>coefBoot</code> object in a <code>nlsBoot</code> object and then finds the median and the two quantiles that have the proportion (1-<code>conf.level</code>)/2 of the bootstrapped predictions below and above. The median is returned as the predicted value and the quantiles are returned as an approximate 100<code>conf.level</code>% confidence interval for that prediction.
</p>


<h3>Value</h3>

<p><code>confint</code> returns a matrix with as many rows as columns (i.e., parameter estimates) in the <code>object$coefboot</code> data frame and two columns of the quantiles that correspond to the approximate confidence interval.
</p>
<p><code>htest</code> returns a matrix with two columns. The first column contains the hypothesized value sent to this function and the second column is the corresponding p-value.
</p>
<p><code>predict</code> returns a matrix with one row and three columns, with the first column holding the predicted value (i.e., the median prediction) and the last two columns holding the approximate confidence interval.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Boot">Boot</a></code> and related methods in <span class="pkg">car</span> and <code>summary.<a href="nlstools.html#topic+nlsBoot">nlsBoot</a></code> in <span class="pkg">nlstools</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fnx &lt;- function(days,B1,B2,B3) {
  if (length(B1) &gt; 1) {
    B2 &lt;- B1[2]
    B3 &lt;- B1[3]
    B1 &lt;- B1[1]
  }
  B1/(1+exp(B2+B3*days))
}
nl1 &lt;- nls(cells~fnx(days,B1,B2,B3),data=Ecoli,
           start=list(B1=6,B2=7.2,B3=-1.45))
if (require(nlstools)) {
  nl1.bootn &lt;-  nlstools::nlsBoot(nl1,niter=99) # too few to be useful
  confint(nl1.bootn,"B1")
  confint(nl1.bootn,c(2,3))
  confint(nl1.bootn,conf.level=0.90)
  confint(nl1.bootn,plot=TRUE)
  predict(nl1.bootn,fnx,days=3)
  predict(nl1.bootn,fnx,days=1:3)
  htest(nl1.bootn,1,bo=6,alt="less")
}

</code></pre>

<hr>
<h2 id='nlsTracePlot'>Adds model fits from nls iterations to active plot.</h2><span id='topic+nlsTracePlot'></span>

<h3>Description</h3>

<p>Adds model fits from iterations of the <code><a href="stats.html#topic+nls">nls</a></code> algorithm as returned when <code>trace=TRUE</code>. Useful for diagnosing model fitting problems or issues associated with starting values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlsTracePlot(
  object,
  fun,
  from = NULL,
  to = NULL,
  n = 199,
  lwd = 2,
  col = NULL,
  rev.col = FALSE,
  legend = "topright",
  cex.leg = 0.9,
  box.lty.leg = 0,
  add = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlsTracePlot_+3A_object">object</code></td>
<td>
<p>An object saved from <code><a href="stats.html#topic+nls">nls</a></code> or from <code><a href="utils.html#topic+capture.output">capture.output</a></code> using <code><a href="base.html#topic+try">try</a></code> with <code><a href="stats.html#topic+nls">nls</a></code>. See details.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_fun">fun</code></td>
<td>
<p>A function that represents the model being fit in <code><a href="stats.html#topic+nls">nls</a></code>. This must take the x-axis variable as the first argument and model parameters as a vector in the second argument. See details.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_from">from</code>, <code id="nlsTracePlot_+3A_to">to</code></td>
<td>
<p>The range over which the function will be plotted. Defaults to range of the x-axis of the active plot.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_n">n</code></td>
<td>
<p>The number of value at which to evaluate the function for plotting (i.e., the number of values from <code>from</code> to <code>to</code>). Larger values make smoother lines.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_lwd">lwd</code></td>
<td>
<p>A numeric used to indicate the line width of the fitted line.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_col">col</code></td>
<td>
<p>A single character string that is a palette from <code><a href="grDevices.html#topic+hcl.pals">hcl.pals</a></code> or a vector of character strings containing colors for the fitted lines at each trace.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_rev.col">rev.col</code></td>
<td>
<p>A logical that indicates that the order of colors for plotting the lines should be reversed.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_legend">legend</code></td>
<td>
<p>Controls use and placement of the legend. See details.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_cex.leg">cex.leg</code></td>
<td>
<p>A single numeric value that represents the character expansion value for the legend. Ignored if <code>legend=FALSE</code>.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_box.lty.leg">box.lty.leg</code></td>
<td>
<p>A single numeric values that indicates the type of line to use for the box around the legend. The default is to not plot a box.</p>
</td></tr>
<tr><td><code id="nlsTracePlot_+3A_add">add</code></td>
<td>
<p>A logical indicating whether the lines should be added to the existing plot (defaults to <code>=TRUE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Nonlinear models fit with the <code><a href="stats.html#topic+nls">nls</a></code> function start with starting values for model parameters and iteratively search for other model parameters that continuously reduce the residual sum-of-squares (RSS) until some pre-determined criterion suggest that the RSS cannot be (substantially) further reduced. With good starting values and well-behaved data, the minimum RSS may be found in a few (&lt;10) iterations. However, poor starting values or poorly behaved data may lead to a prolonged and possibly failed search. An understanding of the iterations in a prolonged or failed search may help identify the failure and lead to choices that may result in a successful search. The <code>trace=TRUE</code> argument of <code><a href="stats.html#topic+nls">nls</a></code> allows one to see the values at each iterative step. The function documented here plots the &ldquo;trace&rdquo; results at each iteration on a previously existing plot of the data. This creates a visual of the iterative process.
</p>
<p>The <code>object</code> argument may be an object saved from a successful run of <code><a href="stats.html#topic+nls">nls</a></code>. See the examples with <code>SpotVA1</code> and <code>CodNorwegion</code>.
</p>
<p>However, if <code><a href="stats.html#topic+nls">nls</a></code> fails to converge to a solution then no useful object is returned. In this case, <code>trace=TRUE</code> must be added to the failed <code><a href="stats.html#topic+nls">nls</a></code> call. The call is then wrapped in <code><a href="base.html#topic+try">try</a></code> to work-around the failed convergence error. This is also wrapped in <code><a href="utils.html#topic+capture.output">capture.output</a></code> to capture the &ldquo;trace&rdquo; results. This is then saved to an object that which can then be the <code>object</code> of the function documented here. This process is illustrated with the example using <code>BSkateGB</code>.
</p>
<p>The function in <code>fun</code> is used to make predictions given the model parameter values at each step of the iteration. This function must accept the explanatory/independent variable as its first argument and values for all model parameters in a vector as its second argument. These types of functions are returned by <code><a href="#topic+vbFuns">vbFuns</a></code>, <code><a href="#topic+GompertzFuns">GompertzFuns</a></code>, <code><a href="#topic+logisticFuns">logisticFuns</a></code>, and <code><a href="#topic+RichardsFuns">RichardsFuns</a></code> for common growth models and <code><a href="#topic+srFuns">srFuns</a></code> for common stock-recruitment models. See the examples.
</p>


<h3>Value</h3>

<p>A matrix with the residual sum-of-squares in the first column and parameter estimates in the remaining columns for each iteration (rows) of <code><a href="stats.html#topic+nls">nls</a></code> as provided when <code>trace=TRUE</code>.
</p>


<h3>Note</h3>

<p>The position of the &ldquo;legend&rdquo; can be controlled in three ways. First, if <code>legend=TRUE</code>, then the R console is suspended until the user places the legend on the plot by clicking on the point where the upper-left corner of the legend should appear. Second, <code>legend=</code> can be set to one of <code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>, <code>"topleft"</code>, <code>"top"</code>, <code>"topright"</code>, <code>"right"</code> and <code>"center"</code>. In this case, the legend will be placed inside the plot frame at the given location. Finally, <code>legend=</code> can be set to a vector of length two which identifies the plot coordinates for the upper-left corner of where the legend should be placed. A legend will not be drawn if <code>legend=FALSE</code> or <code>legend=NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Examples following a successful fit
vb1 &lt;- vbFuns()
fit1 &lt;- nls(tl~vb1(age,Linf,K,t0),data=SpotVA1,start=list(Linf=12,K=0.3,t0=0))
plot(tl~age,data=SpotVA1,pch=21,bg="gray40")
nlsTracePlot(fit1,vb1,legend="bottomright")

r1 &lt;- srFuns("Ricker")
fitSR1 &lt;- nls(log(recruits)~log(r1(stock,a,b)),data=CodNorwegian,start=list(a=3,b=0.03))
plot(recruits~stock,data=CodNorwegian,pch=21,bg="gray40",xlim=c(0,200))
nlsTracePlot(fitSR1,r1)

# no plot, but returns trace results as a matrix
( tmp &lt;- nlsTracePlot(fitSR1,r1,add=FALSE) )

## Not run: 
if (require(FSAdata)) {
  data(BSkateGB,package="FSAdata")
  wtr &lt;- droplevels(subset(BSkateGB,season=="winter"))
  bh1 &lt;- srFuns()
  trc &lt;- capture.output(try(
  fitSR1 &lt;- nls(recruits~bh1(spawners,a,b),wtr,
                start=srStarts(recruits~spawners,data=wtr),trace=TRUE)
  ))
  plot(recruits~spawners,data=wtr,pch=21,bg="gray40")
  nlsTracePlot(trc,bh1)
  # zoom in on y-axis
  plot(recruits~spawners,data=wtr,pch=21,bg="gray40",ylim=c(0.02,0.05))
  nlsTracePlot(trc,bh1,legend="top")
  # return just the trace results
  ( tmp &lt;- nlsTracePlot(trc,bh1,add=FALSE) )
}

## End(Not run)

</code></pre>

<hr>
<h2 id='peek'>Peek into (show a subset of) a data frame or matrix.</h2><span id='topic+peek'></span>

<h3>Description</h3>

<p>Shows the first, last, and approximately evenly spaced rows from a data frame or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek(x, n = 20L, which = NULL, addrownums = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peek_+3A_x">x</code></td>
<td>
<p>A data frame or matrix.</p>
</td></tr>
<tr><td><code id="peek_+3A_n">n</code></td>
<td>
<p>A single numeric that indicates the number of rows to display.</p>
</td></tr>
<tr><td><code id="peek_+3A_which">which</code></td>
<td>
<p>A numeric or string vector that contains the column numbers or names to display. Defaults to showing all columns.</p>
</td></tr>
<tr><td><code id="peek_+3A_addrownums">addrownums</code></td>
<td>
<p>If there are no row names for the MATRIX, then create them from the row numbers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or data.frame with n rows.
</p>


<h3>Note</h3>

<p>If <code>n</code> is larger than the number of rows in <code>x</code> then all of <code>x</code> is displayed.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>
<p>A. Powell Wheeler, <a href="mailto:powell.wheeler@gmail.com">powell.wheeler@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>headtail</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>peek(iris)
peek(iris,n=6)
peek(iris,n=6,which=c("Sepal.Length","Sepal.Width","Species"))
peek(iris,n=6,which=grep("Sepal",names(iris)))
peek(iris,n=200)

## Make a matrix for demonstration purposes only
miris &lt;- as.matrix(iris[,1:4])
peek(miris)
peek(miris,n=6)
peek(miris,n=6,addrownums=FALSE)
peek(miris,n=6,which=2:4)

## Make a tbl_df type from dplyr ... note how peek() is not limited by
## the tbl_df restriction on number of rows to show (but head() is).
if (require(dplyr)) {
  iris2 &lt;- tbl_df(iris)
  class(iris2)
  peek(iris2,n=6)
  head(iris2,n=15)
}
</code></pre>

<hr>
<h2 id='perc'>Computes the percentage of values in a vector less than or greater than (and equal to) some value.</h2><span id='topic+perc'></span>

<h3>Description</h3>

<p>Computes the percentage of values in a vector less than or greater than (and equal to) a user-supplied value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perc(
  x,
  val,
  dir = c("geq", "gt", "leq", "lt"),
  na.rm = TRUE,
  digits = getOption("digits")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perc_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="perc_+3A_val">val</code></td>
<td>
<p>A single numeric value.</p>
</td></tr>
<tr><td><code id="perc_+3A_dir">dir</code></td>
<td>
<p>A string that indicates whether the percentage is for values in <code>x</code> that are &ldquo;greater than and equal&rdquo; <code>"geq"</code>, &ldquo;greater than&rdquo; <code>"gt"</code>, &ldquo;less than and equal&rdquo; <code>"leq"</code>, &ldquo;less than&rdquo; <code>"lt"</code> the value in <code>val</code>.</p>
</td></tr>
<tr><td><code id="perc_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical that indicates whether <code>NA</code> values should be removed (DEFAULT) from <code>x</code> or not.</p>
</td></tr>
<tr><td><code id="perc_+3A_digits">digits</code></td>
<td>
<p>A single numeric that indicates the number of decimals the percentage should be rounded to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is most useful when used with an apply-type of function.
</p>


<h3>Value</h3>

<p>A single numeric that is the percentage of values in <code>x</code> that meet the criterion in <code>dir</code> relative to <code>val</code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## vector of values
( tmp &lt;- c(1:8,NA,NA) )

## percentages excluding NA values
perc(tmp,5)
perc(tmp,5,"gt")
perc(tmp,5,"leq")
perc(tmp,5,"lt")

## percentages including NA values
perc(tmp,5,na.rm=FALSE)
perc(tmp,5,"gt",na.rm=FALSE)
perc(tmp,5,"leq",na.rm=FALSE)
perc(tmp,5,"lt",na.rm=FALSE)

</code></pre>

<hr>
<h2 id='PikeNY'>Summarized multiple mark-recapture data for all Northern Pike from Buckhorn Marsh, NY.</h2><span id='topic+PikeNY'></span>

<h3>Description</h3>

<p>Summary results of capture histories (number captured, number of recaptured fish, and number of unmarked fish that were marked) for all Buckhorn Marsh Northern Pike (<em>Esox lucius</em>).
</p>


<h3>Format</h3>

<p>A data frame with 21 observations on the following 4 variables:
</p>

<dl>
<dt>date</dt><dd><p>Capture date</p>
</dd>
<dt>n</dt><dd><p>Total fish captured in each sample</p>
</dd>
<dt>m</dt><dd><p>Marked fish captured in each sample</p>
</dd>
<dt>R</dt><dd><p>Marked fish returned to the population</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Population Size
</p>
</li>
<li><p> Abundance
</p>
</li>
<li><p> Mark-Recapture
</p>
</li>
<li><p> Capture-Recapture
</p>
</li>
<li><p> Schnabel
</p>
</li>
<li><p> Schumacher-Eschmeyer
</p>
</li></ul>



<h3>Source</h3>

<p>New York Power Authority. 2004. Use of Buckhorn Marsh and Grand Island tributaries by Northern Pike for spawning and as a nursery. Technical report, New York Power Authority, January 2004. Niagara Power Project (FERC No. 2216). <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/PikeNY.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+mrClosed">mrClosed</a></code> examples. Also see <code><a href="#topic+PikeNYPartial1">PikeNYPartial1</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(PikeNY)
head(PikeNY)

</code></pre>

<hr>
<h2 id='PikeNYPartial1'>Capture histories (4 samples), in capture history format, of a subset of Northern Pike from Buckhorn Marsh, NY.</h2><span id='topic+PikeNYPartial1'></span>

<h3>Description</h3>

<p>Each line consists of the capture history over four samples of Northern Pike (<em>Esox lucius</em>) in Buckhorn Marsh. This file contains the capture histories for only those pike captured from April 1-4.
</p>


<h3>Format</h3>

<p>A data frame with 57 observations on the following 4 variables.
</p>

<dl>
<dt>id</dt><dd><p>A unique identification numbers</p>
</dd>
<dt>first</dt><dd><p>Indicator variable for the first sample (1=captured)</p>
</dd> 
<dt>second</dt><dd><p>Indicator variable for the second sample (1=captured)</p>
</dd> 
<dt>third</dt><dd><p>Indicator variable for the third sample (1=captured)</p>
</dd> 
<dt>fourth</dt><dd><p>Indicator variable for the fourth sample (1=captured)</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Population Size 
</p>
</li>
<li><p> Abundance 
</p>
</li>
<li><p> Mark-Recapture
</p>
</li>
<li><p> Capture-Recapture
</p>
</li>
<li><p> Schnabel
</p>
</li>
<li><p> Schumacher-Eschmeyer
</p>
</li>
<li><p> Capture History
</p>
</li></ul>



<h3>Source</h3>

<p>Summary values taken from Table C-1 of New York Power Authority. 2004. Use of Buckhorn Marsh and Grand Island tributaries by Northern Pike for spawning and as a nursery. Technical report, New York Power Authority, January 2004. Niagara Power Project (FERC No. 2216). <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/PikeNYPartial1.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+capHistSum">capHistSum</a></code> and <code><a href="#topic+mrClosed">mrClosed</a></code> examples. Also see <code><a href="#topic+PikeNY">PikeNY</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(PikeNYPartial1)
head(PikeNYPartial1)

</code></pre>

<hr>
<h2 id='plotAB'>Construct traditional (Campana-like) age-bias plots.</h2><span id='topic+plotAB'></span>

<h3>Description</h3>

<p>Constructs a traditional (e.g., like that described in Campana <em>et al.</em> (1995)) age-bias plot to visualize potential differences in paired age estimates. Ages may be from, for example, two readers of the same structure, one reader at two times, two structures (e.g., scales, spines, otoliths), or one structure and known ages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAB(
  x,
  what = c("bias", "Campana", "numbers"),
  xlab = x$ref.lab,
  ylab = x$nref.lab,
  xlim = NULL,
  ylim = NULL,
  yaxt = graphics::par("yaxt"),
  xaxt = graphics::par("xaxt"),
  col.agree = "gray60",
  lwd.agree = lwd,
  lty.agree = 2,
  lwd = 1,
  sfrac = 0,
  pch.mean = 19,
  pch.mean.sig = 21,
  cex.mean = lwd,
  col.CI = "black",
  col.CIsig = "red",
  lwd.CI = lwd,
  sfrac.CI = sfrac,
  show.n = FALSE,
  nYpos = 1.03,
  cex.n = 0.75,
  cex.numbers = 0.75,
  col.numbers = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAB_+3A_x">x</code></td>
<td>
<p>An object of class <code>ageBias</code>, usually a result from <code>ageBias</code>.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_what">what</code></td>
<td>
<p>A string that indicates what type of plot to construct. See details.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_xlab">xlab</code>, <code id="plotAB_+3A_ylab">ylab</code></td>
<td>
<p>A string label for the x-axis (reference) or y-axis (non-reference) age estimates, respectively.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_xlim">xlim</code>, <code id="plotAB_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 that contains the limits of the x-axis (reference ages) or y-axis (non-reference ages), respectively.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_xaxt">xaxt</code>, <code id="plotAB_+3A_yaxt">yaxt</code></td>
<td>
<p>A string which specifies the x- and y-axis types. Specifying &ldquo;n&rdquo; suppresses plotting of the axis. See <code>?par</code>.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_col.agree">col.agree</code></td>
<td>
<p>A string or numeric for the color of the 1:1 or zero (if <code>difference=TRUE</code>) reference line.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_lwd.agree">lwd.agree</code></td>
<td>
<p>A numeric for the line width of the 1:1 or zero (if <code>difference=TRUE</code>) reference line.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_lty.agree">lty.agree</code></td>
<td>
<p>A numeric for the line type of the 1:1 or zero (if <code>difference=TRUE</code>) reference line.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_lwd">lwd</code></td>
<td>
<p>A numeric that controls the separate &lsquo;lwd&rsquo; argument (e.g., <code>lwd.CI</code> and <code>lwd.range</code>).</p>
</td></tr>
<tr><td><code id="plotAB_+3A_sfrac">sfrac</code></td>
<td>
<p>A numeric that controls the separate &lsquo;sfrac&rsquo; arguments (e.g., <code>sfrac.CI</code> and <code>sfrac.range</code>). See <code>sfrac</code> in <code><a href="plotrix.html#topic+plotCI">plotCI</a></code> of <span class="pkg">plotrix</span>.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_pch.mean">pch.mean</code></td>
<td>
<p>A numeric for the plotting character used for the mean values when the means are considered insignificant.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_pch.mean.sig">pch.mean.sig</code></td>
<td>
<p>A numeric for the plotting character for the mean values when the means are considered significant.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_cex.mean">cex.mean</code></td>
<td>
<p>A character expansion value for the size of the mean symbol in <code>pch.mean</code> and <code>pch.mean.sig</code>.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_col.ci">col.CI</code></td>
<td>
<p>A string or numeric for the color of confidence interval bars that are considered non-significant.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_col.cisig">col.CIsig</code></td>
<td>
<p>A string or numeric for the color of confidence interval bars that are considered significant.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_lwd.ci">lwd.CI</code></td>
<td>
<p>A numeric for the line width of the confidence interval bars.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_sfrac.ci">sfrac.CI</code></td>
<td>
<p>A numeric for the size of the ends of the confidence interval bars. See <code>sfrac</code> in <code><a href="plotrix.html#topic+plotCI">plotCI</a></code> of <span class="pkg">plotrix</span>.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_show.n">show.n</code></td>
<td>
<p>A logical for whether the sample sizes for each level of the x-axis variable is shown (<code>=TRUE</code>, default) or not (<code>=FALSE</code>).</p>
</td></tr>
<tr><td><code id="plotAB_+3A_nypos">nYpos</code></td>
<td>
<p>A numeric for the relative Y position of the sample size values when <code>show.n=TRUE</code>. For example, if <code>nYpos=1.03</code> then the sample size values will be centered at 3 percent above the top end of the y-axis.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_cex.n">cex.n</code></td>
<td>
<p>A character expansion value for the size of the sample size values.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_cex.numbers">cex.numbers</code></td>
<td>
<p>A character expansion value for the size of the numbers plotted when <code>what="numbers"</code> is used.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_col.numbers">col.numbers</code></td>
<td>
<p>A string for the color of the numbers plotted when <code>what="numbers"</code> is used.</p>
</td></tr>
<tr><td><code id="plotAB_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of plots for visualizing differences between sets of two age estimates may be created. The reference ages are plotted on the x-axis and the nonreference ages are on the y-axis. The 1:1 (45 degree) agreement line is shown for comparative purposes. The default plot (using <code>what="bias"</code>) was inspired by the age bias plot introduced by Campana <em>et al.</em> (1995). The default settings for this age bias plot show the mean and confidence interval for the nonreference ages at each of the reference ages. The level of confidence is controlled by <code>sig.level=</code> given in the original <code><a href="#topic+ageBias">ageBias</a></code> call (i.e., confidence level is 100*(1-<code>sig.level</code>)). Confidence intervals are only shown if the sample size is greater than the value in <code>min.n.CI=</code> (also from the original call to <code><a href="#topic+ageBias">ageBias</a></code>). Confidence intervals plotted in red with an open dot (by default; these can be changed with <code>col.CIsig</code> and <code>pch.mean.sig</code>, respectively) do not contain the reference age (see discussion of t-tests in <code><a href="#topic+ageBias">ageBias</a></code>). Sample sizes at each reference age are shown if <code>show.n=TRUE</code>. The position of the sample sizes is controlled with <code>nYpos=</code>, whereas their size is controlled with <code>cex.n</code>. Arguments may be used to nearly replicate the age bias plot as introduced by Campana <em>et al.</em> (1995) as shown in the examples.
</p>
<p>The frequency of observations at each unique (x,y) coordinate are shown by using <code>what="numbers"</code> in <code>plotAB</code>. The size of the numbers is controlled with <code>cex.numbers</code>.
</p>


<h3>Value</h3>

<p>Nothing, but see details for a description of the plot that is produced.
</p>


<h3>IFAR Chapter</h3>

<p>4-Age Comparisons. <b>This is most of the original functionality that was in <code>plot</code> in the book. See examples.</b>
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Campana, S.E., M.C. Annand, and J.I. McMillan. 1995. Graphical and statistical methods for determining the consistency of age determinations. Transactions of the American Fisheries Society 124:131-138. [Was (is?) available from http://www.bio.gc.ca/otoliths/documents/Campana%20et%20al%201995%20TAFS.pdf.]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ageBias">ageBias</a></code> and its plot method for what I consider a better age-bias plot; <code><a href="#topic+agePrecision">agePrecision</a></code> for measures of precision between pairs of age estimates; and <code><a href="fishmethods.html#topic+compare2">compare2</a></code> in <span class="pkg">fishmethods</span> for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Must create ageBias object first
ab1 &lt;- ageBias(scaleC~otolithC,data=WhitefishLC,
               ref.lab="Otolith Age",nref.lab="Scale Age")
               
# Default plot
plotAB(ab1)

# Very close to Campana et al. (2001)
plotAB(ab1,pch.mean.sig=19,col.CIsig="black",sfrac=0.01,
       ylim=c(-1,23),xlim=c(-1,23))
# Show sample sizes (different position and size than default)
plotAB(ab1,show.n=TRUE,nYpos=0.02,cex.n=0.5)

# Traditional numbers plot
plotAB(ab1,what="numbers") 

</code></pre>

<hr>
<h2 id='poiCI'>Confidence interval for Poisson counts.</h2><span id='topic+poiCI'></span>

<h3>Description</h3>

<p>Computes a confidence interval for the Poisson counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poiCI(
  x,
  conf.level = 0.95,
  type = c("exact", "daly", "byar", "asymptotic"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poiCI_+3A_x">x</code></td>
<td>
<p>A single number or vector that represents the number of observed successes.</p>
</td></tr>
<tr><td><code id="poiCI_+3A_conf.level">conf.level</code></td>
<td>
<p>A number that indicates the level of confidence to use for constructing confidence intervals (default is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="poiCI_+3A_type">type</code></td>
<td>
<p>A string that identifies the type of method to use for the calculations. See details.</p>
</td></tr>
<tr><td><code id="poiCI_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates whether <code>x</code> should be included in the returned matrix (<code>=TRUE</code>) or not (<code>=FALSE</code>; DEFAULT).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes a CI for the Poisson counts using the <code>exact</code>, gamma distribution (<code>daly</code>&lsquo;), Byar&rsquo;s (<code>byar</code>), or normal approximation (<code>asymptotic</code>) methods.
</p>
<p>The <code>pois.daly</code> function gives essentially identical answers to the <code>pois.exact</code> function except when x=0. When x=0, for the upper confidence limit <code>pois.exact</code> returns 3.689 and <code>pois.daly</code> returns 2.996.
</p>


<h3>Value</h3>

<p>A #x2 matrix that contains the lower and upper confidence interval bounds as columns and, if <code>verbose=TRUE</code> <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>, though this is largely based on <code>pois.exact</code>, <code>pois.daly</code>, <code>pois.byar</code>, and <code>pois.approx</code> from the old epitools package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Demonstrates using all types at once
poiCI(12)

## Selecting types
poiCI(12,type="daly")
poiCI(12,type="byar")
poiCI(12,type="asymptotic")
poiCI(12,type="asymptotic",verbose=TRUE)
poiCI(12,type=c("exact","daly"))
poiCI(12,type=c("exact","daly"),verbose=TRUE)

## Demonstrates use with multiple inputs
poiCI(c(7,10),type="exact")
poiCI(c(7,10),type="exact",verbose=TRUE)

</code></pre>

<hr>
<h2 id='psdAdd'>Creates a vector of Gabelhouse lengths for each species in an entire data frame.</h2><span id='topic+psdAdd'></span><span id='topic+psdAdd.default'></span><span id='topic+psdAdd.formula'></span>

<h3>Description</h3>

<p>Creates a vector of the Gabelhouse lengths specific to a species for all individuals in an entire data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdAdd(len, ...)

## Default S3 method:
psdAdd(
  len,
  species,
  units = c("mm", "cm", "in"),
  use.names = TRUE,
  addSpec = NULL,
  addLens = NULL,
  verbose = TRUE,
  ...
)

## S3 method for class 'formula'
psdAdd(
  len,
  data = NULL,
  units = c("mm", "cm", "in"),
  use.names = TRUE,
  addSpec = NULL,
  addLens = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdAdd_+3A_len">len</code></td>
<td>
<p>A numeric vector that contains lengths measurements or a formula of the form <code>len~spec</code> where &ldquo;len&rdquo; generically represents the length variable and &ldquo;spec&rdquo; generically represents the species variable. Note that this formula can only contain two variables and must have the length variable on the left-hand-side and the species variable on the right-hand-side.</p>
</td></tr>
<tr><td><code id="psdAdd_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="psdAdd_+3A_species">species</code></td>
<td>
<p>A character or factor vector that contains the species names. Ignored if <code>len</code> is a formula.</p>
</td></tr>
<tr><td><code id="psdAdd_+3A_units">units</code></td>
<td>
<p>A string that indicates the type of units used for the lengths. Choices are <code>mm</code> for millimeters (DEFAULT), <code>cm</code> for centimeters, and <code>in</code> for inches.</p>
</td></tr>
<tr><td><code id="psdAdd_+3A_use.names">use.names</code></td>
<td>
<p>A logical that indicates whether the vector returned is numeric (<code>=FALSE</code>) or string (<code>=TRUE</code>; default) representations of the Gabelhouse lengths. See details.</p>
</td></tr>
<tr><td><code id="psdAdd_+3A_addspec">addSpec</code></td>
<td>
<p>A character vector of species names for which <code>addLens</code> will be provided.</p>
</td></tr>
<tr><td><code id="psdAdd_+3A_addlens">addLens</code></td>
<td>
<p>A numeric vector of lengths that should be used in addition to the Gabelhouse lengths for the species in <code>addSpec</code>. See examples.</p>
</td></tr>
<tr><td><code id="psdAdd_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates whether detailed messages about species without Gabelhouse lengths or with no recorded values should be printed or not.</p>
</td></tr>
<tr><td><code id="psdAdd_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains the length measurements and species names if <code>len</code> is a formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This computes a vector that contains the Gabelhouse lengths specific to each species for all individuals in an entire data frame. The vector can be appended to an existing data.frame to create a variable that contains the Gabelhouse lengths for each individual. The Gabelhouse length value will be <code>NA</code> for each individual for which Gabelhouse length definitions do not exist in <code><a href="#topic+PSDlit">PSDlit</a></code>. Species names in the data.frame must be the same as those used in <code><a href="#topic+PSDlit">PSDlit</a></code>. See the examples for one method for changing species names to something that this function will recognize.
</p>
<p>Individuals shorter than &ldquo;stock&rdquo; length will be listed as <code>substock</code> if <code>use.names=TRUE</code> or <code>0</code> if <code>use.names=FALSE</code>.
</p>
<p>Additional lengths to be used for a species may be included by giving a vector of species names in <code>addSpec</code> and a corresponding vector of additional lengths in <code>addLens</code>. Note, however, that <code>use.names</code> will be reset to <code>FALSE</code> if <code>addSpec</code> and <code>addLens</code> are specified, as there is no way to order the names for all species when additional lengths are used.
</p>


<h3>Value</h3>

<p>A numeric or factor vector that contains the Gabelhouse length categories.
</p>


<h3>IFAR Chapter</h3>

<p>6-Size Structure.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Guy, C.S., R.M. Neumann, and D.W. Willis. 2006. New terminology for proportional stock density (PSD) and relative stock density (RSD): proportional size structure (PSS). Fisheries 31:86-87. [Was (is?) from http://pubstorage.sdstate.edu/wfs/415-F.pdf.]
</p>
<p>Guy, C.S., R.M. Neumann, D.W. Willis, and R.O. Anderson. 2006. Proportional size distribution (PSD): A further refinement of population size structure index terminology. Fisheries 32:348. [Was (is?) from http://pubstorage.sdstate.edu/wfs/450-F.pdf.]
</p>
<p>Willis, D.W., B.R. Murphy, and C.S. Guy. 1993. Stock density indices: development, use, and limitations. Reviews in Fisheries Science 1:203-222. [Was (is?) from http://web1.cnre.vt.edu/murphybr/web/Readings/Willis%20et%20al.pdf.]
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psdVal">psdVal</a></code>, <code><a href="#topic+psdCalc">psdCalc</a></code>, <code><a href="#topic+psdPlot">psdPlot</a></code>, <code><a href="#topic+PSDlit">PSDlit</a></code>, and <code><a href="#topic+wrAdd">wrAdd</a></code> for related functions. See <code><a href="plyr.html#topic+mapvalues">mapvalues</a></code> for help in changing species names to match those in <code><a href="#topic+PSDlit">PSDlit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create random data for three species
# only for repeatability
set.seed(345234534)
dbg &lt;- data.frame(species=factor(rep(c("Bluegill"),30)),
                  tl=round(rnorm(30,130,50),0))
dbg$wt &lt;- round(4.23e-06*dbg$tl^3.316+rnorm(30,0,10),1)
dlb &lt;- data.frame(species=factor(rep(c("Largemouth Bass"),30)),
                  tl=round(rnorm(30,350,60),0))
dlb$wt &lt;- round(2.96e-06*dlb$tl^3.273+rnorm(30,0,60),1)
dbt &lt;- data.frame(species=factor(rep(c("Bluefin Tuna"),30)),
                  tl=round(rnorm(30,1900,300),0))
dbt$wt &lt;- round(4.5e-05*dbt$tl^2.8+rnorm(30,0,6000),1)
df &lt;- rbind(dbg,dlb,dbt)
str(df)

## Examples (non-dplyr)
# Add variable using category names -- formula notation
df$PSD &lt;- psdAdd(tl~species,data=df)
head(df)
# Add variable using category names -- non-formula notation
df$PSD1 &lt;- psdAdd(df$tl,df$species)
head(df)
# Add variable using length values as names
df$PSD2 &lt;- psdAdd(tl~species,data=df,use.names=FALSE)
head(df)
# Add additional length and name for Bluegill
df$PSD3 &lt;- psdAdd(tl~species,data=df,addSpec="Bluegill",addLens=175)
head(df)
# Add add'l lengths and names for Bluegill and Largemouth Bass from a data.frame
addls &lt;- data.frame(species=c("Bluegill","Largemouth Bass","Largemouth Bass"),
                    lens=c(175,254,356))
df$psd4 &lt;- psdAdd(tl~species,data=df,addSpec=addls$species,addLens=addls$lens)
head(df)

## All of the above but using dplyr
if (require(dplyr)) {
  df &lt;- df %&gt;%
    mutate(PSD1A=psdAdd(tl,species)) %&gt;%
    mutate(PSD2A=psdAdd(tl,species,use.names=FALSE)) %&gt;%
    mutate(psd3a=psdAdd(tl,species,addSpec="Bluegill",addLens=175)) %&gt;%
    mutate(psd4a=psdAdd(tl,species,addSpec=addls$species,addLens=addls$lens))
}
df

</code></pre>

<hr>
<h2 id='psdCalc'>Convenience function for calculating PSD-X and PSD X-Y values.</h2><span id='topic+psdCalc'></span>

<h3>Description</h3>

<p>Convenience function for calculating (traditional) PSD-X and (incremental) PSD X-Y values for all Gabelhouse lengths and increments thereof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdCalc(
  formula,
  data,
  species,
  units = c("mm", "cm", "in"),
  method = c("multinomial", "binomial"),
  conf.level = 0.95,
  addLens = NULL,
  addNames = NULL,
  justAdds = FALSE,
  what = c("all", "traditional", "incremental", "none"),
  drop0Est = TRUE,
  showIntermediate = FALSE,
  digits = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdCalc_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>~length</code> where &ldquo;length&rdquo; generically represents a variable in <code>data</code> that contains the observed lengths. Note that this formula may only contain one variable and it must be numeric.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains the observed lengths given in the variable in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_species">species</code></td>
<td>
<p>A string that contains the species name for which Gabelhouse lengths exist. See <code><a href="#topic+psdVal">psdVal</a></code> for details. See details for how to use this function for species for which Gabelhouse lengths are not defined.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_units">units</code></td>
<td>
<p>A string that indicates the type of units used for the lengths. Choices are <code>mm</code> for millimeters (DEFAULT), <code>cm</code> for centimeters, and <code>in</code> for inches.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_method">method</code></td>
<td>
<p>A character that identifies the confidence interval method to use. See details in <code><a href="#topic+psdCI">psdCI</a></code>.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_conf.level">conf.level</code></td>
<td>
<p>A number that indicates the level of confidence to use for constructing confidence intervals (default is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_addlens">addLens</code></td>
<td>
<p>A numeric vector that contains minimum lengths for additional categories. See <code><a href="#topic+psdVal">psdVal</a></code> for details.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_addnames">addNames</code></td>
<td>
<p>A string vector that contains names for the additional lengths added with <code>addLens</code>. See <code><a href="#topic+psdVal">psdVal</a></code> for details.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_justadds">justAdds</code></td>
<td>
<p>A logical that indicates whether just the values related to the length sin <code>addLens</code> should be returned.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_what">what</code></td>
<td>
<p>A string that indicates the type of PSD values that will be printed. See details.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_drop0est">drop0Est</code></td>
<td>
<p>A logical that indicates whether the PSD values that are zero should be dropped from the output.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_showintermediate">showIntermediate</code></td>
<td>
<p>A logical that indicates whether the number of fish in the category and the number of stock fish (i.e., &ldquo;intermediate&rdquo; values) should be included in the returned matrix. Default is to not include these values.</p>
</td></tr>
<tr><td><code id="psdCalc_+3A_digits">digits</code></td>
<td>
<p>A numeric that indicates the number of decimals to round the result to. Default is zero digits following the recommendation of Neumann and Allen (2007).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the (traditional) PSD-X and (incremental) PSD X-Y values, with associated confidence intervals, for each Gabelhouse length. All PSD-X and PSD X-Y values are printed if <code>what="all"</code> (DEFAULT), only PSD-X values are printed if <code>what="traditional"</code>, only PSD X-Y values are printed if <code>what="incremental"</code>, and nothing is printed (but the matrix is still returned) if <code>what="none"</code>.
</p>
<p>Confidence intervals can be computed with either the multinomial (Default) or binomial distribution as set in <code>method</code>See details in <code><a href="#topic+psdCI">psdCI</a></code> for more information.
This function may be used for species for which Gabelhouse length categories are not defined. In this case do not include a name in <code>species</code>, but define at least two lengths in <code>addLens</code> where the first category MUST be called &ldquo;stock&rdquo;.
</p>


<h3>Value</h3>

<p>A matrix with columns that contain the computed PSD-X or PSD X-Y values and associated confidence intervals. If <code>showIntermediate=TRUE</code> then the number of fish in the category and the number of stock fish will also be shown.
</p>


<h3>Testing</h3>

<p>Point estimate calculations match those constructed &quot;by hand.&quot;
</p>


<h3>IFAR Chapter</h3>

<p>6-Size Structure.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Guy, C.S., R.M. Neumann, and D.W. Willis. 2006. New terminology for proportional stock density (PSD) and relative stock density (RSD): proportional size structure (PSS). Fisheries 31:86-87. [Was (is?) from http://pubstorage.sdstate.edu/wfs/415-F.pdf.]
</p>
<p>Guy, C.S., R.M. Neumann, D.W. Willis, and R.O. Anderson2006Proportional size distribution (PSD): A further refinement of population size structure index terminology. Fisheries. 32:348. [Was (is?) from http://pubstorage.sdstate.edu/wfs/450-F.pdf.]
</p>
<p>Neumann, R.M. and Allen, M.S. 2007. Size structure. In Guy, C.S. and Brown, M.L., editors, Analysis and Interpretation of Freshwater Fisheries Data, Chapter 9, pages 375-421. American Fisheries Society, Bethesda, MD.
</p>
<p>Willis, D.W., B.R. Murphy, and C.S. Guy. 1993. Stock density indices: development, use, and limitations. Reviews in Fisheries Science 1:203-222. [Was (is?) from http://web1.cnre.vt.edu/murphybr/web/Readings/Willis%20et%20al.pdf.]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+psdVal">psdVal</a></code>, <code><a href="#topic+psdPlot">psdPlot</a></code>, <code><a href="#topic+psdAdd">psdAdd</a></code>, <code><a href="#topic+PSDlit">PSDlit</a></code>, <code><a href="#topic+tictactoe">tictactoe</a></code>, <code><a href="#topic+lencat">lencat</a></code>, and <code><a href="#topic+rcumsum">rcumsum</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Random length data
# suppose this is yellow perch to the nearest mm
yepdf &lt;- data.frame(yepmm=round(c(rnorm(100,mean=125,sd=15),
                                  rnorm(50,mean=200,sd=25),
                                  rnorm(20,mean=300,sd=40)),0),
                    species=rep("Yellow Perch",170))
psdCalc(~yepmm,data=yepdf,species="Yellow perch",digits=1)
psdCalc(~yepmm,data=yepdf,species="Yellow perch",digits=1,drop0Est=TRUE)

## add a length
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=150)

## add lengths with names
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=150,addNames="minLen")
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=c("minLen"=150))
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=c(150,275),addNames=c("minSlot","maxSlot"))
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=c("minLen"=150,"maxslot"=275))

## add lengths with names, return just those values that use those lengths
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=c("minLen"=150),justAdds=TRUE)
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=c("minLen"=150),justAdds=TRUE,
        what="traditional")
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=c(150,275),
        addNames=c("minSlot","maxSlot"),justAdds=TRUE)
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=c(150,275),
        addNames=c("minSlot","maxSlot"),justAdds=TRUE,what="traditional")

## different output types
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=150,what="traditional")
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=150,what="incremental")
psdCalc(~yepmm,data=yepdf,species="Yellow perch",addLens=150,what="none")

## Show intermediate values
psdCalc(~yepmm,data=yepdf,species="Yellow perch",showInterm=TRUE)
psdCalc(~yepmm,data=yepdf,species="Yellow perch",what="traditional",showInterm=TRUE)
psdCalc(~yepmm,data=yepdf,species="Yellow perch",what="incremental",showInterm=TRUE)

## Control the digits
psdCalc(~yepmm,data=yepdf,species="Yellow perch",digits=1)

## Working with a species not in PSDlit ... same data, but don't give species
psdCalc(~yepmm,data=yepdf,addLens=c("stock"=130,"quality"=200,"preferred"=250,
                                    "memorable"=300,"trophy"=380))
psdCalc(~yepmm,data=yepdf,addLens=c("stock"=130,"quality"=200,
                                    "preferred"=250,"name1"=220))
                                    
</code></pre>

<hr>
<h2 id='psdCI'>Compute confidence intervals for PSD-X and PSD X-Y values.</h2><span id='topic+psdCI'></span>

<h3>Description</h3>

<p>Compute confidence intervals for (traditional) PSD-X and (incremental) PSD X-Y values as requested by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdCI(
  indvec,
  ptbl,
  n,
  method = c("binomial", "multinomial"),
  bin.type = c("wilson", "exact", "asymptotic"),
  conf.level = 0.95,
  label = NULL,
  digits = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdCI_+3A_indvec">indvec</code></td>
<td>
<p>A numeric vector of 0s and 1s that identify the linear combination of proportions from <code>ptbl</code> that the user is interested in. See details.</p>
</td></tr>
<tr><td><code id="psdCI_+3A_ptbl">ptbl</code></td>
<td>
<p>A numeric vector or array that contains the proportion or percentage of all individuals in each length category. See details.</p>
</td></tr>
<tr><td><code id="psdCI_+3A_n">n</code></td>
<td>
<p>A single numeric of the number of fish used to construct <code>ptbl</code>.</p>
</td></tr>
<tr><td><code id="psdCI_+3A_method">method</code></td>
<td>
<p>A string that identifies the confidence interval method to use. See details.</p>
</td></tr>
<tr><td><code id="psdCI_+3A_bin.type">bin.type</code></td>
<td>
<p>A string that identifies the type of method to use for calculation of the confidence intervals when <span class="rlang"><b>R</b></span>method=&quot;binomial&quot;. See details of <code><a href="#topic+binCI">binCI</a></code>.</p>
</td></tr>
<tr><td><code id="psdCI_+3A_conf.level">conf.level</code></td>
<td>
<p>A number that indicates the level of confidence to use for constructing confidence intervals (default is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="psdCI_+3A_label">label</code></td>
<td>
<p>A single string that can be used to label the row of the output matrix.</p>
</td></tr>
<tr><td><code id="psdCI_+3A_digits">digits</code></td>
<td>
<p>A numeric that indicates the number of decimals to round the result to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes confidence intervals for (traditional) PSD-X and (incremental) PSD X-Y values. Two methods can be used as chosen with <code>method=</code>. If <code>method="binomial"</code> then the binomial distribution (via <code>binCI()</code>) is used. If <code>method="multinomial"</code> then the multinomial method described by Brenden <em>et al.</em> (2008) is used. This function is defined to compute one confidence interval so <code>method="binomial"</code> is the default. See examples and <code><a href="#topic+psdCalc">psdCalc</a></code> for computing several simultaneous confidence intervals.
</p>
<p>A table of proportions within each length category is given in <code>ptbl</code>. If <code>ptbl</code> has any values greater than 1 then it is assumed that a table of percentages was supplied and the entire table will be divided by 100 to continue. The proportions must sum to 1 (with some allowance for rounding).
</p>
<p>A vector of length equal to the length of <code>ptbl</code> is given in <code>indvec</code> which contains zeros and ones to identify the linear combination of values in <code>ptbl</code> to use to construct the confidence intervals. For example, if <code>ptbl</code> has four proportions then <code>indvec=c(1,0,0,0)</code> would be used to construct a confidence interval for the population proportion in the first category. Alternatively, <code>indvec=c(0,0,1,1)</code> would be used to construct a confidence interval for the population proportion in the last two categories. This vector must not contain all zeros or all ones.
</p>


<h3>Value</h3>

<p>A matrix with columns that contain the computed PSD-X or PSD X-Y value and the associated confidence interval. The confidence interval values were set to zero or 100 if the computed value was negative or greater than 100, respectively.
</p>


<h3>Testing</h3>

<p>The multinomial results match the results given in Brenden <em>et al.</em> (2008).
</p>


<h3>IFAR Chapter</h3>

<p>6-Size Structure.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Brenden, T.O., T. Wagner, and B.R. Murphy. 2008. Novel tools for analyzing proportional size distribution index data. North American Journal of Fisheries Management 28:1233-1242. [Was (is?) from http://qfc.fw.msu.edu/Publications/Publication%20List/2008/Novel%20Tools%20for%20Analyzing%20Proportional%20Size%20Distribution_Brenden.pdf.]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+psdVal">psdVal</a></code>, <code><a href="#topic+psdPlot">psdPlot</a></code>, <code><a href="#topic+psdAdd">psdAdd</a></code>, <code><a href="#topic+PSDlit">PSDlit</a></code>, <code><a href="#topic+tictactoe">tictactoe</a></code>, <code><a href="#topic+lencat">lencat</a></code>, and <code><a href="#topic+rcumsum">rcumsum</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## similar to Brenden et al. (2008)
n &lt;- 997
ipsd &lt;- c(130,491,253,123)/n

## single binomial
psdCI(c(0,0,1,1),ipsd,n=n)
psdCI(c(1,0,0,0),ipsd,n=n,label="PSD S-Q")

## single multinomial
psdCI(c(0,0,1,1),ipsd,n=n,method="multinomial")
psdCI(c(1,0,0,0),ipsd,n=n,method="multinomial",label="PSD S-Q")

## multiple multinomials (but see psdCalc())
lbls &lt;- c("PSD S-Q","PSD Q-P","PSD P-M","PSD M-T","PSD","PSD-P")
imat &lt;- matrix(c(1,0,0,0,
                 0,1,0,0,
                 0,0,1,0,
                 0,0,0,1,
                 0,1,1,1,
                 0,0,1,1),nrow=6,byrow=TRUE)
rownames(imat) &lt;- lbls
imat

mcis &lt;- t(apply(imat,MARGIN=1,FUN=psdCI,ptbl=ipsd,n=n,method="multinomial"))
colnames(mcis) &lt;- c("Estimate","95% LCI","95% UCI")
mcis

## Multiple "Bonferroni-corrected" (for six comparisons) binomial method
bcis &lt;- t(apply(imat,MARGIN=1,FUN=psdCI,ptbl=ipsd,n=n,conf.level=1-0.05/6))
colnames(bcis) &lt;- c("Estimate","95% LCI","95% UCI")
bcis

</code></pre>

<hr>
<h2 id='PSDlit'>Gabelhouse five-cell length categories for various species.</h2><span id='topic+PSDlit'></span>

<h3>Description</h3>

<p>Cutoffs for the Gabelhouse five-cell length categories for a variety of species.
</p>


<h3>Format</h3>

<p>A data frame of 58 observations on the following 11 variables:
</p>

<dl>
<dt>species</dt><dd><p>Species name.</p>
</dd>
<dt>stock.in</dt><dd><p>Stock length in inches.</p>
</dd>
<dt>quality.in</dt><dd><p>Quality length in inches.</p>
</dd>
<dt>preferred.in</dt><dd><p>Preferred length in inches.</p>
</dd>
<dt>memorable.in</dt><dd><p>Memorable length in inches.</p>
</dd>
<dt>trophy.in</dt><dd><p>Trophy length in inches.</p>
</dd>
<dt>stock.cm</dt><dd><p>Stock length in cm.</p>
</dd>
<dt>quality.cm</dt><dd><p>Quality length in cm.</p>
</dd>
<dt>preferred.cm</dt><dd><p>Preferred length in cm.</p>
</dd>
<dt>memorable.cm</dt><dd><p>Memorable length in cm.</p>
</dd>
<dt>trophy.cm</dt><dd><p>Trophy length in cm.</p>
</dd>
<dt>source</dt><dd><p>Literature source for the length entries.</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Size structure
</p>
</li>
<li><p> Proportional size structure
</p>
</li>
<li><p> Relative stock density
</p>
</li>
<li><p> Proportional stock density
</p>
</li></ul>



<h3>IFAR Chapter</h3>

<p>6-Size Structure.
</p>


<h3>Source</h3>

<p>Original summary table from Dr. Michael Hansen, University of Wisconsin-Stevens Point. Additional species have been added by the package author from the literature.
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+psdVal">psdVal</a></code>, <code><a href="#topic+psdCalc">psdCalc</a></code>, <code><a href="#topic+psdPlot">psdPlot</a></code>, <code><a href="#topic+psdAdd">psdAdd</a></code>, and <code><a href="#topic+tictactoe">tictactoe</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(PSDlit)
head(PSDlit)

</code></pre>

<hr>
<h2 id='psdPlot'>Length-frequency histogram with Gabelhouse lengths highlighted.</h2><span id='topic+psdPlot'></span>

<h3>Description</h3>

<p>Constructs a length-frequency histogram with Gabelhouse lengths highlighted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdPlot(
  formula,
  data,
  species = "List",
  units = c("mm", "cm", "in"),
  startcat = 0,
  w = 1,
  justPSDQ = FALSE,
  main = "",
  xlab = "Length",
  ylab = "Number",
  xlim = NULL,
  ylim = c(0, max(h$counts) * 1.05),
  substock.col = "white",
  stock.col = "gray90",
  psd.col = "black",
  psd.lty = 2,
  psd.lwd = 1,
  show.abbrevs = TRUE,
  psd.add = TRUE,
  psd.pos = "topleft",
  psd.cex = 0.75,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdPlot_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>~length</code> where &ldquo;length&rdquo; generically represents a variable in <code>data</code> that contains length measurements. Note that this formula can only contain one variable.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains the length measurements given in the variable in the <code>formula</code>.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_species">species</code></td>
<td>
<p>A string that contains the species name for which Gabelhouse length categories exist. See <code><a href="#topic+psdVal">psdVal</a></code> for details.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_units">units</code></td>
<td>
<p>A string that indicates the type of units used for the length measurements. Choices are <code>mm</code> for millimeters (DEFAULT), <code>cm</code> for centimeters, and <code>in</code> for inches.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_startcat">startcat</code></td>
<td>
<p>A number that indicates the beginning of the first length-class.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_w">w</code></td>
<td>
<p>A number that indicates the width of length classes to create.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_justpsdq">justPSDQ</code></td>
<td>
<p>A logical that indicates whether just stock and quality (for PSD-Q calculations) categories should be used. If <code>FALSE</code> (default) then the five Gabelhouse categories will be used.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_main">main</code></td>
<td>
<p>A string that serves as the main label for the histogram.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_xlab">xlab</code></td>
<td>
<p>A string that serves as the label for the x-axis.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_ylab">ylab</code></td>
<td>
<p>A string that serves as the label for the y-axis.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length two that indicates the minimum and maximum values (i.e., fish lengths) for the x-axis.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length two that indicates the minimum and maximum values for the y-axis.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_substock.col">substock.col</code></td>
<td>
<p>A string that indicates the color to use for the bars representing under-stock size fish.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_stock.col">stock.col</code></td>
<td>
<p>A string that indicates the color to use for the bars representing stock size fish.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_psd.col">psd.col</code></td>
<td>
<p>A string that indicates the color to use for the vertical lines at the Gabelhouse length category values.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_psd.lty">psd.lty</code></td>
<td>
<p>A numeric that indicates the line type to use for the vertical lines at the Gabelhouse length category values.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_psd.lwd">psd.lwd</code></td>
<td>
<p>A numeric that indicates the line width to use for the vertical lines at the Gabelhouse length category values.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_show.abbrevs">show.abbrevs</code></td>
<td>
<p>A logical that indicates if the abbreviations for the Gabelhouse length categories should be added to the top of the plot.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_psd.add">psd.add</code></td>
<td>
<p>A logical that indicates if the calculated PSD values should be added to the plot (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_psd.pos">psd.pos</code></td>
<td>
<p>A string that indicates the position for where the PSD values will be shown. See details in <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_psd.cex">psd.cex</code></td>
<td>
<p>A numeric value that indicates the character expansion for the PSD values text.</p>
</td></tr>
<tr><td><code id="psdPlot_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the low-level plotting functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs a length-frequency histogram with the stock-sized fish highlighted, the Gabelhouse lengths marked by vertical lines, and the (traditional) PSD-X values superimposed.
</p>
<p>The length of fish plotted on the x-axis can be controlled with <code>xlim</code>, however, the minimum value in <code>xlim</code> must be less than the stock length for that species.
</p>


<h3>Value</h3>

<p>None. However, a graphic is produced.
</p>


<h3>IFAR Chapter</h3>

<p>6-Size Structure.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Guy, C.S., R.M. Neumann, and D.W. Willis. 2006. New terminology for proportional stock density (PSD) and relative stock density (RSD): proportional size structure (PSS). Fisheries 31:86-87. [Was (is?) from http://pubstorage.sdstate.edu/wfs/415-F.pdf.]
</p>
<p>Guy, C.S., R.M. Neumann, D.W. Willis, and R.O. Anderson. 2006. Proportional size distribution (PSD): A further refinement of population size structure index terminology. Fisheries 32:348. [Was (is?) from http://pubstorage.sdstate.edu/wfs/450-F.pdf.]
</p>
<p>Willis, D.W., B.R. Murphy, and C.S. Guy. 1993. Stock density indices: development, use, and limitations. Reviews in Fisheries Science 1:203-222. [Was (is?) from http://web1.cnre.vt.edu/murphybr/web/Readings/Willis%20et%20al.pdf.]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+psdVal">psdVal</a></code>, <code><a href="#topic+psdCalc">psdCalc</a></code>, <code><a href="#topic+psdAdd">psdAdd</a></code>, <code><a href="#topic+PSDlit">PSDlit</a></code>, <code><a href="#topic+lencat">lencat</a></code>, <code><a href="#topic+tictactoe">tictactoe</a></code>, <code><a href="#topic+lencat">lencat</a></code>, and <code><a href="#topic+rcumsum">rcumsum</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Random length data
# suppose this is yellow perch to the nearest mm
df &lt;- data.frame(spec=rep("Yellow Perch",170),
                 mm=c(rnorm(100,mean=125,sd=15),rnorm(50,mean=200,sd=25),
                      rnorm(20,mean=300,sd=40)))

## Example graphics
op &lt;- par(mar=c(3,3,2,1),mgp=c(1.7,0.5,0))
# Using 10-mm increments
psdPlot(~mm,data=df,species="Yellow perch",w=10)
psdPlot(~mm,data=df,species="Yellow perch",w=10,substock.col="gray90",
        stock.col="gray30")
# ... but without the PSD values
psdPlot(~mm,data=df,species="Yellow perch",w=10,psd.add=FALSE)
par(op)

</code></pre>

<hr>
<h2 id='psdVal'>Finds Gabelhouse lengths (for PSD calculations) for a species.</h2><span id='topic+psdVal'></span>

<h3>Description</h3>

<p>Returns a vector with the five Gabelhouse lengths for a chosen species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psdVal(
  species = "List",
  units = c("mm", "cm", "in"),
  incl.zero = TRUE,
  addLens = NULL,
  addNames = NULL,
  showJustSource = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psdVal_+3A_species">species</code></td>
<td>
<p>A string that contains the species name for which to find Gabelhouse lengths. See details.</p>
</td></tr>
<tr><td><code id="psdVal_+3A_units">units</code></td>
<td>
<p>A string that indicates the units for the returned lengths. Choices are <code>mm</code> for millimeters (DEFAULT), <code>cm</code> for centimeters, and <code>in</code> for inches.</p>
</td></tr>
<tr><td><code id="psdVal_+3A_incl.zero">incl.zero</code></td>
<td>
<p>A logical that indicates if a zero is included in the first position of the returned vector (DEFAULT) or not. This position will be named &ldquo;substock&rdquo;. See details.</p>
</td></tr>
<tr><td><code id="psdVal_+3A_addlens">addLens</code></td>
<td>
<p>A numeric vector that contains minimum length definitions for additional categories. See details.</p>
</td></tr>
<tr><td><code id="psdVal_+3A_addnames">addNames</code></td>
<td>
<p>A string vector that contains names for the additional length categories added with <code>addLens</code>. See details.</p>
</td></tr>
<tr><td><code id="psdVal_+3A_showjustsource">showJustSource</code></td>
<td>
<p>A logical that indicates whether just the literature source information should be returned (<code>TRUE</code>) or not. If <code>TRUE</code> this will NOT return any of the Gabelhouse length information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the Gabelhouse lengths from <code>data(PSDlit)</code> for the species given in <code>species</code>. The species name must be spelled exactly (within capitalization differences) as it appears in <code>data(PSDlit)</code>. Type <code>psdVal()</code> to see the list of species and how they are spelled.
</p>
<p>A zero is included in the first position of the returned vector if <code>incl.zero=TRUE</code>. This is useful when computing PSD values with a data.frame that contains fish smaller than the stock length.
</p>
<p>Additional lengths may be added to the returned vector with <code>addLens</code>. Names for these lengths can be included in <code>addNames</code>. If <code>addNames</code> is non-NULL, then it must be of the same length as <code>addLens</code>. If <code>addLens</code> is non-NULL but <code>addNames</code> is NULL, then the default names will be the same as the lengths in <code>addLens</code>. The <code>addLens</code> argument is useful for calculating PSD values that are different from the Gabelhouse lengths.
</p>


<h3>Value</h3>

<p>A vector of minimum values for length categories for the chosen species.
</p>


<h3>IFAR Chapter</h3>

<p>6-Size Structure.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Guy, C.S., R.M. Neumann, and D.W. Willis. 2006. New terminology for proportional stock density (PSD) and relative stock density (RSD): proportional size structure (PSS). Fisheries 31:86-87. [Was (is?) from http://pubstorage.sdstate.edu/wfs/415-F.pdf.]
</p>
<p>Guy, C.S., R.M. Neumann, D.W. Willis, and R.O. Anderson. 2006. Proportional size distribution (PSD): A further refinement of population size structure index terminology. Fisheries 32:348. [Was (is?) from http://pubstorage.sdstate.edu/wfs/450-F.pdf.]
</p>
<p>Willis, D.W., B.R. Murphy, and C.S. Guy. 1993. Stock density indices: development, use, and limitations. Reviews in Fisheries Science 1:203-222. [Was (is?) from http://web1.cnre.vt.edu/murphybr/web/Readings/Willis%20et%20al.pdf.]
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+psdCalc">psdCalc</a></code>, <code><a href="#topic+psdPlot">psdPlot</a></code>, <code><a href="#topic+psdAdd">psdAdd</a></code>, <code><a href="#topic+PSDlit">PSDlit</a></code>, <code><a href="#topic+tictactoe">tictactoe</a></code>, <code><a href="#topic+lencat">lencat</a></code>, and <code><a href="#topic+rcumsum">rcumsum</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># List all of the species
psdVal()
# Demonstrate typical usages
psdVal("Yellow perch")
psdVal("Walleye",units="cm")
psdVal("Bluegill",units="in")
psdVal("Bluegill",units="in",incl.zero=FALSE)
psdVal("Bluegill")
# Demonstrate that it will work with mis-capitalization
psdVal("bluegill")
psdVal("Yellow Perch")
# Demonstrate adding in user-defined categories
psdVal("Bluegill",units="in",addLens=7)
psdVal("Bluegill",units="in",addLens=7,addNames="MinLen")
psdVal("Bluegill",units="in",addLens=c(7,9),addNames=c("MinSlot","MaxSlot"))
psdVal("Bluegill",units="in",addLens=c("MinLen"=7))
psdVal("Bluegill",units="in",addLens=c("MinSlot"=7,"MaxSlot"=9))
psdVal("Bluegill",showJustSource=TRUE)

</code></pre>

<hr>
<h2 id='rcumsum'>Computes the prior to or reverse cumulative sum of a vector.</h2><span id='topic+rcumsum'></span><span id='topic+pcumsum'></span>

<h3>Description</h3>

<p>Computes the prior-to (i.e., the cumulative sum prior to but not including the current value) or the reverse (i.e., the number that large or larger) cumulative sum of a vector. Also works for 1-dimensional tables, matrices, and data.frames, though it is best used with vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcumsum(x)

pcumsum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcumsum_+3A_x">x</code></td>
<td>
<p>a numeric object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector that contains the prior-to or reverse cumulative sums.
</p>


<h3>Note</h3>

<p>An <code>NA</code> in the vector causes all returned values at and after the first <code>NA</code> for <code>pcumsum</code> and at and before the last <code>NA</code> for <code>rcumsum</code> to be <code>NA</code>. See the examples.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cumsum">cumsum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple example
cbind(vals=1:10,
      cum=cumsum(1:10),
      pcum=pcumsum(1:10),
      rcum=rcumsum(1:10))

## Example with NA
vals &lt;- c(1,2,NA,3)
cbind(vals,
      cum=cumsum(vals),
      pcum=pcumsum(vals),
      rcum=rcumsum(vals))

## Example with NA
vals &lt;- c(1,2,NA,3,NA,4)
cbind(vals,
      cum=cumsum(vals),
      pcum=pcumsum(vals),
      rcum=rcumsum(vals))
      
## Example with a matrix
mat &lt;- matrix(c(1,2,3,4,5),nrow=1)
cumsum(mat)
pcumsum(mat)
rcumsum(mat)

## Example with a table (must be 1-d)
df &lt;- sample(1:10,100,replace=TRUE)
tbl &lt;- table(df)
cumsum(tbl)
pcumsum(tbl)
rcumsum(tbl)

## Example with a data.frame (must be 1-d)
df &lt;- sample(1:10,100,replace=TRUE)
tbl &lt;- as.data.frame(table(df))[,-1]
cumsum(tbl)
pcumsum(tbl)
rcumsum(tbl)
</code></pre>

<hr>
<h2 id='removal'>Population estimates for k-, 3-, or 2-pass removal data.</h2><span id='topic+removal'></span><span id='topic+summary.removal'></span><span id='topic+confint.removal'></span>

<h3>Description</h3>

<p>Computes estimates, with confidence intervals, of the population size and probability of capture from the number of fish removed in k-, 3-, or 2-passes in a closed population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removal(
  catch,
  method = c("CarleStrub", "Zippin", "Seber3", "Seber2", "RobsonRegier2", "Moran",
    "Schnute", "Burnham"),
  alpha = 1,
  beta = 1,
  CS.se = c("Zippin", "alternative"),
  conf.level = 0.95,
  just.ests = FALSE,
  Tmult = 3,
  CIMicroFish = FALSE
)

## S3 method for class 'removal'
summary(
  object,
  parm = c("No", "p", "p1"),
  digits = getOption("digits"),
  verbose = FALSE,
  ...
)

## S3 method for class 'removal'
confint(
  object,
  parm = c("No", "p"),
  level = conf.level,
  conf.level = NULL,
  digits = getOption("digits"),
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removal_+3A_catch">catch</code></td>
<td>
<p>A numerical vector of catch at each pass.</p>
</td></tr>
<tr><td><code id="removal_+3A_method">method</code></td>
<td>
<p>A single string that identifies the removal method to use. See details.</p>
</td></tr>
<tr><td><code id="removal_+3A_alpha">alpha</code></td>
<td>
<p>A single numeric value for the alpha parameter in the CarleStrub method (default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="removal_+3A_beta">beta</code></td>
<td>
<p>A single numeric value for the beta parameter in the CarleStrub method (default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="removal_+3A_cs.se">CS.se</code></td>
<td>
<p>A single string that identifies whether the SE in the CarleStrub method should be computed according to Seber or Zippin.</p>
</td></tr>
<tr><td><code id="removal_+3A_conf.level">conf.level</code></td>
<td>
<p>A single number representing the level of confidence to use for constructing confidence intervals. This is sent in the main <code>removal</code> function rather than <code>confint</code>.</p>
</td></tr>
<tr><td><code id="removal_+3A_just.ests">just.ests</code></td>
<td>
<p>A logical that indicates whether just the estimates (<code>=TRUE</code>) or the return list (<code>=FALSE</code>; default; see below) is returned.</p>
</td></tr>
<tr><td><code id="removal_+3A_tmult">Tmult</code></td>
<td>
<p>A single numeric that will be multiplied by the total catch in all samples to set the upper value for the range of population sizes when minimizing the log-likelihood and creating confidence intervals for the Moran and Schnute methods. Large values are much slower to compute, but values that are too low may result in missing the best estimate. A warning is issued if too low of a value is suspected.</p>
</td></tr>
<tr><td><code id="removal_+3A_cimicrofish">CIMicroFish</code></td>
<td>
<p>A logical that indicates whether the t value used to calculate confidence intervals when <code>method="Burnham"</code> should be rounded to two or three decimals and whether the confidence intervals for No should be rounded to whole numbers as done in MicroFish 3.0. The default (<code>=FALSE</code>) is to NOT round the t values or No confidence interval. This option is provided only so that results will exactly match MicroFish results (see testing).</p>
</td></tr>
<tr><td><code id="removal_+3A_object">object</code></td>
<td>
<p>An object saved from <code>removal()</code>.</p>
</td></tr>
<tr><td><code id="removal_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given confidence intervals, either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="removal_+3A_digits">digits</code></td>
<td>
<p>A single numeric that controls the number of decimals in the output from <code>summary</code> and <code>confint</code>.</p>
</td></tr>
<tr><td><code id="removal_+3A_verbose">verbose</code></td>
<td>
<p>A logical that indicates whether descriptive labels should be printed from <code>summary</code> and if certain warnings are shown with <code>confint</code>.</p>
</td></tr>
<tr><td><code id="removal_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="removal_+3A_level">level</code></td>
<td>
<p>Not used, but here for compatibility with generic <code>confint</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main function computes the estimates and associated standard errors, if possible, for the initial population size, No, and probability of capture, p, for eight methods chosen with <code>method=</code>. The possible methods are:
</p>

<ul>
<li> <p><code>method="CarleStrub"</code>: The general weighted k-pass estimator proposed by Carle and Strub (1978). This function iteratively solves for No in equation 7 of Carle and Strub (1978).
</p>
</li>
<li> <p><code>method="Zippin"</code>: The general k-pass estimator generally attributed to Zippin. This function iteratively solves for No in bias corrected version of equation 3 (page 622) of Carle and Strub (1978). These results are not yet trustworthy (see Testing section below).
</p>
</li>
<li> <p><code>method="Seber3"</code>: The special case for k=3 estimator shown in equation 7.24 of Seber(2002).
</p>
</li>
<li> <p><code>method="Seber2"</code>: The special case for k=2 estimator shown on page 312 of Seber(2002).
</p>
</li>
<li> <p><code>method="RobsonRegier2"</code>: The special case for k=2 estimator shown by Robson and Regier (1968).
</p>
</li>
<li> <p><code>method="Moran"</code>: The likelihood method of Moran (1951) as implemented by Schnute (1983).
</p>
</li>
<li> <p><code>method="Schnute"</code>: The likelihood method of Schnute (1983) for the model that has a different probability of capture for the first sample but a constant probability of capture for all ensuing samples.
</p>
</li>
<li> <p><code>method="Burnham"</code>: The general k-pass estimator likelihood method created by Ken Burnham and presented by Van Deventer and Platts (1983). This method is used in the Microfish software (Van Deventer 1989).
</p>
</li></ul>

<p>Confidence intervals for the first five methods are computed using standard large-sample normal distribution theory. Note that the confidence intervals for the 2- and 3-pass special cases are only approximately correct if the estimated population size is greater than 200. If the estimated population size is between 50 and 200 then a 95% CI behaves more like a 90% CI.
</p>
<p>Confidence intervals for the next two methods use likelihood ratio theory as described in Schnute (1983) and are only produced for the No parameter. Standard errors are not produced with the Moran or Schnute methods.
</p>
<p>Confidence intervals for the last method are computed as per Ken Burnham's instructions for the Burnham Method (Jack Van Deventer, personal communication). Specifically, they are calculated with the t-statistic and No-1 degrees of freedom. Please note that the MicroFish software rounds the t-statistic before it calculates the confidence intervals about No and p. If you need the confidence interals produced by FSA::removal to duplicate MicroFish, please use CIMicroFish=TRUE.
</p>


<h3>Value</h3>

<p>A vector that contains the estimates and standard errors for No and p if <code>just.ests=TRUE</code> or (default) a list with at least the following items:
</p>

<ul>
<li><p> catch The original vector of observed catches.
</p>
</li>
<li><p> method The method used (provided by the user).
</p>
</li>
<li><p> lbl A descriptive label for the method used.
</p>
</li>
<li><p> est A matrix that contains the estimates and standard errors for No and p.
</p>
</li></ul>

<p>In addition, if the Moran or Schnute methods are used the list will also contain
</p>

<ul>
<li><p> min.nlogLH The minimum value of the negative log-likelihood function.
</p>
</li>
<li><p> Tmult The Tmult value sent by the user.
</p>
</li></ul>



<h3>testing</h3>

<p>The Carle-Strub method matches the examples in Carle and Strub (1978) for No, p, and the variance of No. The Carle-Strub estimates of No and p match the examples in Cowx (1983) but the SE of No does not. The Carle-Strub estimates of No match the results (for estimates that they did not reject) from Jones and Stockwell (1995) to within 1 individual in most instances and within 1% for all other instances (e.g., off by 3 individuals when the estimate was 930 individuals).
</p>
<p>The Seber3 results for No match the results in Cowx (1983).
</p>
<p>The Seber2 results for No, p, and the SE of No match the results in example 7.4 of Seber (2002) and in Cowx (1983).
</p>
<p>The RobsonRegier2 results for No and the SE of NO match the results in Cowx (1983)
</p>
<p>The Zippin method results do not match the examples in Seber (2002) or Cowx (1983) because <code>removal</code> uses the bias-corrected version from Carle and Strub (1978) and does not use the tables in Zippin (1958). The Zippin method is not yet trustworthy.
</p>
<p>The Moran and Schnute methods match the examples in Schnute (1983) perfectly for all point estimates and within 0.1 units for all confidence intervals.
</p>
<p>The Burnham method was tested against the free (gratis) Demo Version of MicroFish 3.0. Powell Wheeler used R to simulate 100, three-pass removal samples with capture probabilities between 0 and 1 and population sizes &lt;= 1000. The Burnham method implemented here exactly matched MicroFish in all 100 trials for No and p. In addition, the CIs for No exactly matched all 100 trials when CIMicroFish=TRUE. Powell was not able to check the CIs for p because the MicroFish 'Quick Population Estimate' does not report them.
</p>


<h3>IFAR Chapter</h3>

<p>10-Abundance from Depletion Data.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>
<p>A. Powell Wheeler, <a href="mailto:powell.wheeler@gmail.com">powell.wheeler@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Carle, F.L. and M.R. Strub. 1978. A new method for estimating population size from removal data. Biometrics, 34:621-630.
</p>
<p>Cowx, I.G. 1983. Review of the methods for estimating fish population size from survey removal data. Fisheries Management, 14:67-82.
</p>
<p>Moran, P.A.P. 1951. A mathematical theory of animal trapping. Biometrika 38:307-311.
</p>
<p>Robson, D.S., and H.A. Regier. 1968. Estimation of population number and mortality rates. pp. 124-158 in Ricker, W.E. (editor) Methods for Assessment of Fish Production in Fresh Waters. IBP Handbook NO. 3 Blackwell Scientific Publications, Oxford.
</p>
<p>Schnute, J. 1983. A new approach to estimating populations by the removal method. Canadian Journal of Fisheries and Aquatic Sciences, 40:2153-2169.
</p>
<p>Seber, G.A.F. 2002. The Estimation of Animal Abundance. Edward Arnold, second edition (Reprint).
</p>
<p>van Dishoeck, P. 2009. Effects of catchability variation on performance of depletion estimators: Application to an adaptive management experiment. Masters Thesis, Simon Fraser University. [Was (is?) from http://rem-main.rem.sfu.ca/theses/vanDishoeckPier_2009_MRM483.pdf.]
</p>
<p>Van Deventer, J.S. 1989. Microcomputer Software System for Generating Population Statistics from Electrofishing Data&ndash;User's Guide for MicroFish 3.0. USDA Forest Service, General Technical Report INT-254. 29 p. [Was (is?) from https://relicensing.pcwa.net/documents/Library/PCWA-L
</p>
<p>Van Deventer, J.S., and W.S. Platts. 1983. Sampling and estimating fish populations from streams. Transactions of the 48th North American Wildlife and Natural Resource Conference. pp. 349-354.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+depletion">depletion</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First example -- 3 passes
ct3 &lt;- c(77,50,37)

# Carle Strub (default) method
p1 &lt;- removal(ct3)
summary(p1)
summary(p1,verbose=TRUE)
summary(p1,parm="No")
summary(p1,parm="p")
confint(p1)
confint(p1,parm="No")
confint(p1,parm="p")

# Moran method
p2 &lt;- removal(ct3,method="Moran")
summary(p2,verbose=TRUE)
confint(p2,verbose=TRUE)
#'
# Schnute method
p3 &lt;- removal(ct3,method="Schnute")
summary(p3,verbose=TRUE)
confint(p3,verbose=TRUE)

# Burnham method
p4 &lt;- removal(ct3,method="Burnham")
summary(p4)
summary(p4,verbose=TRUE)
summary(p4,parm="No")
summary(p4,parm="p")
confint(p4)
confint(p4,parm="No")
confint(p4,parm="p")
## Second example -- 2 passes
ct2 &lt;- c(77,37)

# Seber method
p4 &lt;- removal(ct2,method="Seber2")
summary(p4,verbose=TRUE)
confint(p4)


### Test if catchability differs between first sample and the other samples
# chi-square test statistic from  negative log-likelihoods
#   from Moran and Schnute fits (from above)
chi2.val &lt;- 2*(p2$min.nlogLH-p3$min.nlogLH)
# p-value ... no significant difference
pchisq(chi2.val,df=1,lower.tail=FALSE)

# Another LRT example ... sample 1 from Schnute (1983)
ct4 &lt;- c(45,11,18,8)
p2a &lt;- removal(ct4,method="Moran")
p3a &lt;- removal(ct4,method="Schnute")
chi2.val &lt;- 2*(p2a$min.nlogLH-p3a$min.nlogLH)  # 4.74 in Schnute(1983)
pchisq(chi2.val,df=1,lower.tail=FALSE)         # significant difference (catchability differs)
summary(p3a)


### Using lapply() to use removal() on many different groups
###   with the removals in a single variable ("long format")
## create a dummy data frame
lake &lt;- factor(rep(c("Ash Tree","Bark","Clay"),each=5))
year &lt;- factor(rep(c("2010","2011","2010","2011","2010","2011"),times=c(2,3,3,2,2,3)))
pass &lt;- factor(c(1,2,1,2,3,1,2,3,1,2,1,2,1,2,3))
catch &lt;- c(57,34,65,34,12,54,26,9,54,27,67,34,68,35,12)
d &lt;- data.frame(lake,year,pass,catch)

## create a variable that indicates each different group
d$group &lt;- with(d,interaction(lake,year))
d
## split the catch by the different groups (creates a list of catch vectors)
ds &lt;- split(d$catch,d$group)
## apply removal() to each catch vector (i.e., different group)
res &lt;- lapply(ds,removal,just.ests=TRUE)
res &lt;- data.frame(t(data.frame(res,check.names=FALSE)))
## get rownames from above and split into separate columns
nms &lt;- t(data.frame(strsplit(rownames(res),"\\.")))
attr(nms,"dimnames") &lt;- NULL
fnl &lt;- data.frame(nms,res)
## put names together with values
rownames(fnl) &lt;- NULL
colnames(fnl)[1:2] &lt;- c("Lake","Year")
fnl


### Using apply() to use removal() on many different groups
###   with the removals in several variables ("wide format")
## create a dummy data frame (just reshaped from above as
## an example; -5 to ignore the group variable from above)
d1 &lt;- reshape(d[,-5],timevar="pass",idvar=c("lake","year"),direction="wide")
## apply restore() to each row of only the catch data
res1 &lt;- apply(d1[,3:5],MARGIN=1,FUN=removal,method="CarleStrub",just.ests=TRUE)
res1 &lt;- data.frame(t(data.frame(res1,check.names=FALSE)))
## add the grouping information to the results
fnl1 &lt;- data.frame(d1[,1:2],res1)
## put names together with values
rownames(fnl1) &lt;- NULL
fnl1

</code></pre>

<hr>
<h2 id='repeatedRows2Keep'>Find non-repeated consecutive rows in a data.frame.</h2><span id='topic+repeatedRows2Keep'></span>

<h3>Description</h3>

<p>Finds the rows in a data.frame that are not repeats of the row immediately above or below it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeatedRows2Keep(
  df,
  cols2use = NULL,
  cols2ignore = NULL,
  keep = c("first", "last")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeatedRows2Keep_+3A_df">df</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="repeatedRows2Keep_+3A_cols2use">cols2use</code></td>
<td>
<p>A string or numeric vector that indicates columns in <code>df</code> to use. Negative numeric values will not use those columns. Cannot use both <code>cols2use</code> and <code>col2ignore</code>.</p>
</td></tr>
<tr><td><code id="repeatedRows2Keep_+3A_cols2ignore">cols2ignore</code></td>
<td>
<p>A string or numeric vector that indicates columns in <code>df</code> to ignore. Cannot use both <code>cols2use</code> and <code>col2ignore</code>.</p>
</td></tr>
<tr><td><code id="repeatedRows2Keep_+3A_keep">keep</code></td>
<td>
<p>A string that indicates whether the <code>first</code> (DEFAULT) or <code>last</code> row of consecutive repeated rows should be kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single logical that indicates which rows of <code>df</code> to keep such that no consecutive rows (for the columns used) will be repeated.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test1 &lt;- data.frame(ID=1:10,
                    KEEP=c("First","Last","Both","Both","Both",
                           "Both","First","Neither","Last","Both"),
                    V1=c("a","a","a","B","b","B","A","A","A","a"),
                    V2=c("a","a","A","B","B","b","A","A","A","a"))
keepFirst &lt;- repeatedRows2Keep(test1,cols2ignore=1:2)
keepLast &lt;- repeatedRows2Keep(test1,cols2use=3:4,keep="last")
data.frame(test1,keepFirst,keepLast)

droplevels(subset(test1,keepFirst))  # should be all "First" or "Both" (7 items)
droplevels(subset(test1,keepLast))   # should be all "Last" or "Both" (7 items)

</code></pre>

<hr>
<h2 id='rSquared'>Extract the coefficient of determination from a linear model object.</h2><span id='topic+rSquared'></span><span id='topic+rSquared.default'></span><span id='topic+rSquared.lm'></span>

<h3>Description</h3>

<p>Extracts the coefficient of determination (i.e., &ldquo;r-squared&rdquo;) from a linear model (i.e., <code>lm</code>) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rSquared(object, ...)

## Default S3 method:
rSquared(object, ...)

## S3 method for class 'lm'
rSquared(object, digits = getOption("digits"), percent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rSquared_+3A_object">object</code></td>
<td>
<p>An object saved from <code>lm</code>.</p>
</td></tr>
<tr><td><code id="rSquared_+3A_...">...</code></td>
<td>
<p>Additional arguments for methods.</p>
</td></tr>
<tr><td><code id="rSquared_+3A_digits">digits</code></td>
<td>
<p>A single number that is the number of digits to round the returned result to.</p>
</td></tr>
<tr><td><code id="rSquared_+3A_percent">percent</code></td>
<td>
<p>A logical that indicates if the result should be returned as a percentage (<code>=TRUE</code>) or as a proportion (<code>=FALSE</code>; default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a convenience function to extract the <code>r.squared</code> part from <code>summary(lm)</code>.
</p>


<h3>Value</h3>

<p>A numeric, as either a proportion or percentage, that is the coefficient of determination for a linear model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm1 &lt;- lm(mirex~weight, data=Mirex)
rSquared(lm1)
rSquared(lm1,digits=3)
rSquared(lm1,digits=1,percent=TRUE)

## rSquared only works with lm objects
## Not run: 
nls1 &lt;- nls(mirex~a*weight^b,data=Mirex,start=list(a=1,b=1))
rSquared(nls1)

## End(Not run)

</code></pre>

<hr>
<h2 id='Schnute'>The four-parameter growth function from Schnute (1981).</h2><span id='topic+Schnute'></span>

<h3>Description</h3>

<p>The four-parameter growth function from Schnute (1981).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Schnute(
  t,
  case = 1,
  t1 = NULL,
  t3 = NULL,
  L1 = NULL,
  L3 = NULL,
  a = NULL,
  b = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Schnute_+3A_t">t</code></td>
<td>
<p>A numeric vector of ages over which to model growth.</p>
</td></tr>
<tr><td><code id="Schnute_+3A_case">case</code></td>
<td>
<p>A string that indicates the case of the Schnute growth function to use.</p>
</td></tr>
<tr><td><code id="Schnute_+3A_t1">t1</code></td>
<td>
<p>The (young) age that corresponds to <code>L1</code>. Set to minimum value in <code>t</code> by default.</p>
</td></tr>
<tr><td><code id="Schnute_+3A_t3">t3</code></td>
<td>
<p>The (old) age that corresponds to <code>L3</code>. Set to maximum value in <code>t</code> by default.</p>
</td></tr>
<tr><td><code id="Schnute_+3A_l1">L1</code></td>
<td>
<p>The mean size/length at <code>t1</code>.</p>
</td></tr>
<tr><td><code id="Schnute_+3A_l3">L3</code></td>
<td>
<p>The mean size/length at <code>t3</code>.</p>
</td></tr>
<tr><td><code id="Schnute_+3A_a">a</code></td>
<td>
<p>A dimensionless parameter that is related to the time/age at the inflection point.</p>
</td></tr>
<tr><td><code id="Schnute_+3A_b">b</code></td>
<td>
<p>A dimensionless parameter that is related to size/length at the inflection point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Schnute</code> returns a predicted size given the case of the function and the provided parameter values.
</p>


<h3>IFAR Chapter</h3>

<p>None specifically, but 12-Individual Growth is related.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Schnute, J. 1981. A versatile growth model with statistical stable parameters. Canadian Journal of Fisheries and Aquatic Sciences 38:1128-1140.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+vbFuns">vbFuns</a></code>, <code><a href="#topic+GompertzFuns">GompertzFuns</a></code>, <code><a href="#topic+RichardsFuns">RichardsFuns</a></code>, <code><a href="#topic+logisticFuns">logisticFuns</a></code>, and <code><a href="#topic+SchnuteRichards">SchnuteRichards</a></code> for similar functionality for other models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the formulae
growthFunShow("Schnute",1,plot=TRUE)
growthFunShow("Schnute",2,plot=TRUE)
growthFunShow("Schnute",3,plot=TRUE)
growthFunShow("Schnute",4,plot=TRUE)

## Simple examples
ages &lt;- 1:15
s1 &lt;- Schnute(ages,case=1,t1=1,t3=15,L1=30,L3=400,a=0.3,b=1)
s2 &lt;- Schnute(ages,case=2,t1=1,t3=15,L1=30,L3=400,a=0.3,b=1)
s3 &lt;- Schnute(ages,case=3,t1=1,t3=15,L1=30,L3=400,a=0.3,b=1)
s4 &lt;- Schnute(ages,case=4,t1=1,t3=15,L1=30,L3=400,a=0.3,b=1)

plot(s1~ages,type="l",lwd=2)
lines(s2~ages,lwd=2,col="red")
lines(s3~ages,lwd=2,col="blue")
lines(s4~ages,lwd=2,col="green")

</code></pre>

<hr>
<h2 id='SchnuteRichards'>The five-parameter growth function from Schnute and Richards (1990).</h2><span id='topic+SchnuteRichards'></span>

<h3>Description</h3>

<p>The five-parameter growth function from Schnute and Richards (1990). Note that this function is slightly modified (a &lsquo;+&rsquo; was changed to a &lsquo;-&rsquo; so that the &lsquo;a&rsquo; parameter will be positive) from the original in Schnute and Richards (1990)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SchnuteRichards(t, Linf = NULL, k = NULL, a = NULL, b = NULL, c = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SchnuteRichards_+3A_t">t</code></td>
<td>
<p>A numeric vector of ages over which to model growth.</p>
</td></tr>
<tr><td><code id="SchnuteRichards_+3A_linf">Linf</code></td>
<td>
<p>Mean asymptotic length.</p>
</td></tr>
<tr><td><code id="SchnuteRichards_+3A_k">k</code></td>
<td>
<p>The &quot;growth coefficient&quot; with units of (year^(-c)).</p>
</td></tr>
<tr><td><code id="SchnuteRichards_+3A_a">a</code></td>
<td>
<p>A dimensionless parameter</p>
</td></tr>
<tr><td><code id="SchnuteRichards_+3A_b">b</code></td>
<td>
<p>A dimensionless parameter.</p>
</td></tr>
<tr><td><code id="SchnuteRichards_+3A_c">c</code></td>
<td>
<p>A dimensionless parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>SchnuteRichards</code> returns a predicted size given the provided parameter values.
</p>


<h3>IFAR Chapter</h3>

<p>None specifically, but 12-Individual Growth is related.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Schnute, J.T. and L.J. Richards. 1990. A unified approach to the analysis of fish growth, maturity, and survivorship data. Canadian Journal of Fisheries and Aquatic Sciences. 47:24-40.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+vbFuns">vbFuns</a></code>, <code><a href="#topic+GompertzFuns">GompertzFuns</a></code>, <code><a href="#topic+RichardsFuns">RichardsFuns</a></code>, <code><a href="#topic+logisticFuns">logisticFuns</a></code>, and <code><a href="#topic+Schnute">Schnute</a></code> for similar functionality for other models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the formulae
growthFunShow("SchnuteRichards",plot=TRUE)

## Simple examples
ages &lt;- 1:15
s1 &lt;- SchnuteRichards(ages,Linf=100,k=0.03,a=0.01,b=0.005,c=2)
plot(s1~ages,type="l",lwd=2)

</code></pre>

<hr>
<h2 id='se'>Computes standard error of the mean.</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>Computes the standard error of the mean (i.e., standard deviation divided by the square root of the sample size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="se_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical that indicates whether missing values should be removed before computing the standard error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric that is the standard error of the mean of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code>se</code> in <span class="pkg">sciplot</span> for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:20
sd(x)/sqrt(length(x))
se(x)

# all return NA if missing values are not removed
x2 &lt;- c(x,NA)
sd(x2)/sqrt(length(x2))

# Better if missing values are removed
se(x2,na.rm=FALSE)
sd(x2,na.rm=TRUE)/sqrt(length(x2[complete.cases(x2)]))
se(x2)

</code></pre>

<hr>
<h2 id='SMBassLS'>Catch-effort data for Little Silver Lake (Ont) Smallmouth Bass.</h2><span id='topic+SMBassLS'></span>

<h3>Description</h3>

<p>Catch-effort data for Smallmouth Bass (<em>Micropterus dolomieu</em>) in Little Silver Lake, Ont.
</p>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 3 variables:
</p>

<dl>
<dt>day</dt><dd><p>Day of the catch</p>
</dd>
<dt>catch</dt><dd><p>Number of smallmouth bass caught</p>
</dd>
<dt>effort</dt><dd><p>Number of traps set per day</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Population size 
</p>
</li>
<li><p> Abundance
</p>
</li>
<li><p> Depletion methods 
</p>
</li>
<li><p> Leslie method
</p>
</li>
<li><p> DeLury method 
</p>
</li>
<li><p> Catchability
</p>
</li></ul>



<h3>Source</h3>

<p>From Omand, D.N. 1951. A study of populations of fish based on catch-effort statistics. Journal of Wildlife Management, 15:88-98. <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/SMBassLS.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+depletion">depletion</a></code> examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(SMBassLS)
head(SMBassLS)

</code></pre>

<hr>
<h2 id='SMBassWB'>Growth increment data for West Bearskin Lake, MN, Smallmouth Bass.</h2><span id='topic+SMBassWB'></span>

<h3>Description</h3>

<p>Growth data from Smallmouth Bass (<em>Micropterus dolomieu</em>) captured in West Bearskin Lake, MN. Five samples were collected over three years (1988-1990) with two gears (fall &ndash; trapnets, spring &ndash; electrofishing).
</p>


<h3>Format</h3>

<p>A data frame of 445 observations on the following 20 variables:
</p>

<dl>
<dt>species</dt><dd><p>Species of the fish (<code>SMB</code> for each fish in this file)</p>
</dd>
<dt>lake</dt><dd><p>Lake fish was captured in (<code>WB</code> for each fish in this file)</p>
</dd>
<dt>gear</dt><dd><p>Gear used to capture the fish (<code>T</code>=Trapnet and <code>E</code>=Electrofishing)</p>
</dd>
<dt>yearcap</dt><dd><p>Year fish was captured (<code>1988</code>, <code>1989</code>, or <code>1990</code>)</p>
</dd>
<dt>fish</dt><dd><p>A unique identifier for each fish</p>
</dd>
<dt>agecap</dt><dd><p>Assigned age-at-capture for the fish (from scales)</p>
</dd>
<dt>lencap</dt><dd><p>Total length-at-capture for the fish (mm)</p>
</dd>
<dt>anu1</dt><dd><p>Magnified scale radius (mm) to the 1st annulus</p>
</dd>
<dt>anu2</dt><dd><p>Magnified scale radius (mm) to the 2nd annulus</p>
</dd>
<dt>anu3</dt><dd><p>Magnified scale radius (mm) to the 3rd annulus</p>
</dd>
<dt>anu4</dt><dd><p>Magnified scale radius (mm) to the 4th annulus</p>
</dd>
<dt>anu5</dt><dd><p>Magnified scale radius (mm) to the 5th annulus</p>
</dd>
<dt>anu6</dt><dd><p>Magnified scale radius (mm) to the 6th annulus</p>
</dd>
<dt>anu7</dt><dd><p>Magnified scale radius (mm) to the 7th annulus</p>
</dd>
<dt>anu8</dt><dd><p>Magnified scale radius (mm) to the 8th annulus</p>
</dd>
<dt>anu9</dt><dd><p>Magnified scale radius (mm) to the 9th annulus</p>
</dd>
<dt>anu10</dt><dd><p>Magnified scale radius (mm) to the 10th annulus</p>
</dd>
<dt>anu11</dt><dd><p>Magnified scale radius (mm) to the 11th annulus</p>
</dd>
<dt>anu12</dt><dd><p>Magnified scale radius (mm) to the 12th annulus</p>
</dd>
<dt>radcap</dt><dd><p>Total scale radius at time of capture</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Growth increment analysis
</p>
</li>
<li><p> Weisberg linear growth model
</p>
</li>
<li><p> Back-Calculation
</p>
</li></ul>



<h3>Note</h3>

<p>Data are in one-fish-per-line format.
</p>


<h3>Source</h3>

<p>Data from the linear growth modeling software distributed in support of Weisberg, S. 1993. Using hard-part increment data to estimate age and environmental effects. Canadian Journal of Fisheries and Aquatic Sciences 50:1229-1237. <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/SMBassWB.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+capHistSum">capHistSum</a></code> and <code><a href="#topic+mrClosed">mrClosed</a></code> examples. Also see <code>wblake</code> from <span class="pkg">alr4</span> for the same dataset with only the <code>agecap</code>, <code>lencap</code>, and <code>radcap</code> variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(SMBassWB)
head(SMBassWB)

</code></pre>

<hr>
<h2 id='SpotVA1'>Age and length of spot.</h2><span id='topic+SpotVA1'></span>

<h3>Description</h3>

<p>Ages (from otoliths) and lengths of Virginia Spot (<em>Leiostomus xanthurus</em>).
</p>


<h3>Format</h3>

<p>A data frame of 403 observations on the following 2 variables:
</p>

<dl>
<dt>tl</dt><dd><p>Measured total lengths (in inches)</p>
</dd>
<dt>age</dt><dd><p>Ages assigned from examination of otoliths</p>
</dd>
</dl>



<h3>Details</h3>

<p>Final length measurements were simulated by adding a uniform error to the value at the beginning of the length category.
</p>


<h3>Topic(s)</h3>


<ul>
<li><p> Growth
</p>
</li>
<li><p> von Bertalanffy
</p>
</li></ul>



<h3>Source</h3>

<p>Extracted from Table 1 in Chapter 8 (Spot) of the VMRC Final Report on Finfish Ageing, 2002 by the Center for Quantitative Fisheries Ecology at Old Dominion University. <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/SpotVA1.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+vbFuns">vbFuns</a></code>, <code><a href="#topic+vbStarts">vbStarts</a></code>, and <code><a href="#topic+nlsTracePlot">nlsTracePlot</a></code> examples. Also see <code><a href="FSAdata.html#topic+SpotVA2">SpotVA2</a></code> in <span class="pkg">FSAdata</span> for related data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(SpotVA1)
head(SpotVA1)
plot(tl~age,data=SpotVA1)

</code></pre>

<hr>
<h2 id='srFuns'>Creates a function for a specific parameterization of a common stock-recruitment function .</h2><span id='topic+srFuns'></span><span id='topic+srFunShow'></span>

<h3>Description</h3>

<p>Creates a function for a specific parameterization of a &ldquo;Beverton-Holt&rdquo;, &ldquo;Ricker&rdquo;,  &ldquo;Shepherd&rdquo;, or &ldquo;Saila-Lorda&rdquo; stock-recruitment function. Use <code>srFunShow()</code> to see the equations of each function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srFuns(
  type = c("BevertonHolt", "Ricker", "Shepherd", "SailaLorda", "independence"),
  param = 1,
  simple = FALSE,
  msg = FALSE
)

srFunShow(
  type = c("BevertonHolt", "Ricker", "Shepherd", "SailaLorda"),
  param = 1,
  plot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srFuns_+3A_type">type</code></td>
<td>
<p>A string that indicates the type of stock-recruitment function.</p>
</td></tr>
<tr><td><code id="srFuns_+3A_param">param</code></td>
<td>
<p>A single numeric that indicates the parameterization of the stock-recruitment function.</p>
</td></tr>
<tr><td><code id="srFuns_+3A_simple">simple</code></td>
<td>
<p>A logical that indicates whether the user should be allowed to send all parameter values in the first parameter argument (<code>=FALSE</code>; default) or whether all individual parameters must be specified (<code>=TRUE</code>).</p>
</td></tr>
<tr><td><code id="srFuns_+3A_msg">msg</code></td>
<td>
<p>A logical that indicates whether a message about the function and parameter definitions should be output (<code>=TRUE</code>) or not (<code>=FALSE</code>; default).</p>
</td></tr>
<tr><td><code id="srFuns_+3A_plot">plot</code></td>
<td>
<p>A logical that indicates whether the growth function expression should be shown as an equation in a simple plot.</p>
</td></tr>
<tr><td><code id="srFuns_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>srFuns</code> returns a function that can be used to predict recruitment given a vector of stock sizes and values for the function parameters. The result should be saved to an object that can then be used as a function name. When the resulting function is used, the parameters are ordered as shown when the definitions of the parameters are printed after the function is called (assuming that <code>msg=TRUE</code>). The values for both/all parameters can be included as a vector of length two/three in the first parameter argument. If <code>simple=FALSE</code> then the values for all parameters can be included as a vector in the first parameter argument. If <code>simple=TRUE</code> then all parameters must be declared individually in each function. The resulting function is somewhat easier to read when <code>simple=TRUE</code>.
</p>
<p><code>srFunShow</code> returns an expression that can be use with <code><a href="grDevices.html#topic+plotmath">plotmath</a></code> to show the function equation in a pretty format. See examples.
</p>


<h3>IFAR Chapter</h3>

<p>13-Recruitment.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>, thanks to Gabor Grothendieck for a hint about using <code>get()</code>.
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Beverton, R.J.H. and S.J. Holt. 1957. On the dynamics of exploited fish populations, Fisheries Investigations (Series 2), volume 19. United Kingdom Ministry of Agriculture and Fisheries, 533 pp.
</p>
<p>Iles, T.C. 1994. A review of stock-recruitment relationships with reference to flatfish populations. Netherlands Journal of Sea Research 32:399-420.
</p>
<p>Quinn II, T.J. and R.B. Deriso. 1999. Quantitative Fish Dynamics. Oxford University Press.
</p>
<p>Ricker, W.E. 1954. Stock and recruitment. Journal of the Fisheries Research Board of Canada 11:559-623.
</p>
<p>Ricker, W.E. 1975. Computation and interpretation of biological statistics of fish populations. Technical Report Bulletin 191, Bulletin of the Fisheries Research Board of Canada. [Was (is?) from http://www.dfo-mpo.gc.ca/Library/1485.pdf.]
</p>
<p>Shepherd, J. 1982. A versatile new stock-recruitment relationship for fisheries and construction of sustainable yield curves. Journal du Conseil International pour l'Exploration de la Mar 40:67-75.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+srStarts">srStarts</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the formulae
## Simple Examples
# show what a message looks like with the function definition
srFuns("Ricker",msg=TRUE)

# create some dummy stock data
stock &lt;- seq(0.01,1000,length.out=199)

# Beverton-Holt #1 parameterization
( bh1 &lt;- srFuns() )
plot(bh1(stock,a=0.5,b=0.01)~stock,type="l",lwd=2,ylab="Recruits",xlab="Spawners",ylim=c(0,50))

# Ricker #1 parameterization
( r1 &lt;- srFuns("Ricker") )
lines(r1(stock,a=0.5,b=0.005)~stock,lwd=2,col="red")

# Shephered parameterization
( s1 &lt;- srFuns("Shepherd") )
lines(s1(stock,a=0.5,b=0.005,c=2.5)~stock,lwd=2,col="blue")

# Saila-Lorda parameterization
( sl1 &lt;- srFuns("SailaLorda") )
lines(sl1(stock,a=0.5,b=0.005,c=1.05)~stock,lwd=2,col="salmon")

## Examples of fitting stock-recruitment functions
# Fitting the Beverton-Holt #1 parameterization with multiplicative errors
bh1s &lt;- srStarts(recruits~stock,data=CodNorwegian)
fit1 &lt;- nls(log(recruits)~log(bh1(stock,a,b)),data=CodNorwegian,start=bh1s)
summary(fit1,correlation=TRUE)
plot(recruits~stock,data=CodNorwegian,pch=19,xlim=c(0,200))
curve(bh1(x,a=coef(fit1)[1],b=coef(fit1)[2]),from=0,to=200,col="red",lwd=3,add=TRUE)

# Fitting the Ricker #3 parameterization with multiplicative errors
r3 &lt;- srFuns("Ricker",param=3)
r3s &lt;- srStarts(recruits~stock,data=CodNorwegian,type="Ricker",param=3)
fit2 &lt;- nls(log(recruits)~log(r3(stock,a,Rp)),data=CodNorwegian,start=r3s)
summary(fit2,correlation=TRUE)
curve(r3(x,a=coef(fit2)[1],Rp=coef(fit2)[2]),from=0,to=200,col="blue",lwd=3,add=TRUE)

#############################################################################
## Create expressions of the functions
#############################################################################
# Simple example
srFunShow()
srFunShow(plot=TRUE)
srFunShow("BevertonHolt",1,plot=TRUE)

# Get and save the expression
( tmp &lt;- srFunShow("BevertonHolt",1) )
# Use expression as title on a plot
plot(bh1(stock,a=0.5,b=0.01)~stock,type="l",ylim=c(0,50),
     ylab="Recruits",xlab="Spawners",main=tmp)
# Put expression in the main plot
text(800,10,tmp)
# Put multiple expressions on a plot
op &lt;- par(mar=c(0.1,0.1,0.1,0.1))
plot(0,type="n",xlab="",ylab="",xlim=c(0,1),ylim=c(0,3),xaxt="n",yaxt="n")
text(0,2.5,"Beverton-Holt #1:",pos=4)
text(0.5,2.5,srFunShow("BevertonHolt",1))
text(0,1.5,"Ricker #2:",pos=4)
text(0.5,1.5,srFunShow("Ricker",2))
text(0,0.5,"Shepherd:",pos=4)
text(0.5,0.5,srFunShow("Shepherd"))
par(op)
</code></pre>

<hr>
<h2 id='srStarts'>Finds reasonable starting values for parameters in specific parameterizations of common stock-recruitment models.</h2><span id='topic+srStarts'></span>

<h3>Description</h3>

<p>Finds reasonable starting values for parameters in specific parameterizations of the &ldquo;Beverton-Holt&rdquo;, &ldquo;Ricker&rdquo;,  &ldquo;Shepherd&rdquo;, or &ldquo;Saila-Lorda&rdquo; stock-recruitment models. Use <code>srFunShow()</code> to see the equations of each model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srStarts(
  formula,
  data = NULL,
  type = c("BevertonHolt", "Ricker", "Shepherd", "SailaLorda", "independence"),
  param = 1,
  fixed = NULL,
  plot = FALSE,
  col.mdl = "gray70",
  lwd.mdl = 3,
  lty.mdl = 1,
  cex.main = 0.9,
  col.main = "red",
  dynamicPlot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srStarts_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>Recruits~Stock</code>.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_data">data</code></td>
<td>
<p>A data frame in which <code>Recruits</code> and <code>Stock</code> are found.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_type">type</code></td>
<td>
<p>A string that indicates the type of the stock-recruitment model. Must be one of <code>"BevertonHolt"</code>, <code>"Ricker"</code>, <code>"Shepherd"</code>, or <code>"SailaLorda"</code>.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_param">param</code></td>
<td>
<p>A numeric that indicates the parameterization of the stock-recruitment model type. This is ignored if <code>type="Shepherd"</code> or <code>type="SailaLorda"</code></p>
</td></tr>
<tr><td><code id="srStarts_+3A_fixed">fixed</code></td>
<td>
<p>A named list that contains user-defined rather than automatically generated (i.e., fixed) starting values for one or more parameters. See details.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_plot">plot</code></td>
<td>
<p>A logical that indicates whether or not a plot of the data with the model fit at the starting values superimposed is created.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_col.mdl">col.mdl</code></td>
<td>
<p>A color for the model when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_lwd.mdl">lwd.mdl</code></td>
<td>
<p>A line width for the model when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_lty.mdl">lty.mdl</code></td>
<td>
<p>A line type for the model when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_cex.main">cex.main</code></td>
<td>
<p>A character expansion value for the main title when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_col.main">col.main</code></td>
<td>
<p>A color for the main title when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_dynamicplot">dynamicPlot</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
<tr><td><code id="srStarts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to find reasonable starting values for a variety of parameterizations of the &ldquo;Beverton-Holt&rdquo;, &ldquo;Ricker&rdquo;,  &ldquo;Shepherd&rdquo;, or &ldquo;Saila-Lorda&rdquo; stock-recruitment models. There is no guarantee that these starting values are the &lsquo;best&rsquo; starting values. One should use them with caution and should perform sensitivity analyses to determine the impact of different starting values on the final model results.
</p>
<p>Starting values for the first parameterization of the Beverton-Holt model were derived by linearizing the function (inverting both sides and simplifying), fitting a linear model to the observed data, and extracting parameter values from the corresponding linear model parameters. Starting values for the other parameterizations of the Beverton-Holt model were derived from known relationships between the parameters of each parameterization and the first parameterization. If the computed starting value for the <code>Rp</code> parameter was larger than the largest observed recruitment value, then the starting value for <code>Rp</code> was set to the largest observed recruitment value.
</p>
<p>Starting values for the Shepherd function were the same as those for the first parameterization of the Beverton-Holt function with the addition that <code>c=1</code>.
</p>
<p>Starting values for the Ricker parameterizations followed the same general procedure as described for the Beverton-Holt parameterizations. If the computed starting value for <code>atilde</code> was less than zero then the starting value was set to 0.00001.
</p>
<p>Starting values for the Saila-Lorda function were the same as those for the first parameterization of the Ricker function with the addition that <code>c=1</code>.
</p>


<h3>Value</h3>

<p>A list that contains reasonable starting values. Note that the parameters will be listed in the same order and with the same names as listed in <code><a href="#topic+srFuns">srFuns</a></code>.
</p>


<h3>IFAR Chapter</h3>

<p>13-Recruitment.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Beverton, R.J.H. and S.J. Holt. 1957. On the dynamics of exploited fish populations, Fisheries Investigations (Series 2), volume 19. United Kingdom Ministry of Agriculture and Fisheries, 533 pp.
</p>
<p>Iles, T.C. 1994. A review of stock-recruitment relationships with reference to flatfish populations. Netherlands Journal of Sea Research 32:399-420.
</p>
<p>Quinn II, T.J. and R.B. Deriso. 1999. Quantitative Fish Dynamics. Oxford University Press.
</p>
<p>Ricker, W.E. 1954. Stock and recruitment. Journal of the Fisheries Research Board of Canada 11:559-623.
</p>
<p>Ricker, W.E. 1975. Computation and interpretation of biological statistics of fish populations. Technical Report Bulletin 191, Bulletin of the Fisheries Research Board of Canada. [Was (is?) from http://www.dfo-mpo.gc.ca/Library/1485.pdf.]
</p>
<p>Shepherd, J. 1982. A versatile new stock-recruitment relationship for fisheries and construction of sustainable yield curves. Journal du Conseil International pour l'Exploration de la Mar 40:67-75.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+srFunShow">srFunShow</a></code> and <code><a href="#topic+srFuns">srFuns</a></code> for related functionality. See <code><a href="#topic+nlsTracePlot">nlsTracePlot</a></code> for help troubleshooting nonlinear models that don't converge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple Examples
srStarts(recruits~stock,data=CodNorwegian)
srStarts(recruits~stock,data=CodNorwegian,param=2)
srStarts(recruits~stock,data=CodNorwegian,param=3)
srStarts(recruits~stock,data=CodNorwegian,param=4)
srStarts(recruits~stock,data=CodNorwegian,type="Ricker")
srStarts(recruits~stock,data=CodNorwegian,type="Ricker",param=2)
srStarts(recruits~stock,data=CodNorwegian,type="Ricker",param=3)
srStarts(recruits~stock,data=CodNorwegian,type="Shepherd")
srStarts(recruits~stock,data=CodNorwegian,type="SailaLorda")
srStarts(recruits~stock,data=CodNorwegian,type="independence")

## Simple Examples with a Plot
srStarts(recruits~stock,data=CodNorwegian,type="Ricker",plot=TRUE)
srStarts(recruits~stock,data=CodNorwegian,type="BevertonHolt",plot=TRUE)
srStarts(recruits~stock,data=CodNorwegian,type="Shepherd",plot=TRUE)
srStarts(recruits~stock,data=CodNorwegian,type="SailaLorda",plot=TRUE)
srStarts(recruits~stock,data=CodNorwegian,type="independence",plot=TRUE)

## See examples in srFuns() for use of srStarts() when fitting stock-recruit models

</code></pre>

<hr>
<h2 id='Summarize'>Summary statistics for a numeric variable.</h2><span id='topic+Summarize'></span><span id='topic+Summarize.default'></span><span id='topic+Summarize.formula'></span>

<h3>Description</h3>

<p>Summary statistics for a single numeric variable, possibly separated by the levels of a factor variable or variables. This function is very similar to <code><a href="base.html#topic+summary">summary</a></code> for a numeric variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Summarize(object, ...)

## Default S3 method:
Summarize(
  object,
  digits = getOption("digits"),
  na.rm = TRUE,
  exclude = NULL,
  nvalid = c("different", "always", "never"),
  percZero = c("different", "always", "never"),
  ...
)

## S3 method for class 'formula'
Summarize(
  object,
  data = NULL,
  digits = getOption("digits"),
  na.rm = TRUE,
  exclude = NULL,
  nvalid = c("different", "always", "never"),
  percZero = c("different", "always", "never"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summarize_+3A_object">object</code></td>
<td>
<p>A vector of numeric data.</p>
</td></tr>
<tr><td><code id="Summarize_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
<tr><td><code id="Summarize_+3A_digits">digits</code></td>
<td>
<p>A single numeric that indicates the number of decimals to round the numeric summaries.</p>
</td></tr>
<tr><td><code id="Summarize_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical that indicates whether numeric missing values (<code>NA</code>) should be removed (<code>=TRUE</code>, default) or not.</p>
</td></tr>
<tr><td><code id="Summarize_+3A_exclude">exclude</code></td>
<td>
<p>A string that contains the level that should be excluded from a factor variable.</p>
</td></tr>
<tr><td><code id="Summarize_+3A_nvalid">nvalid</code></td>
<td>
<p>A string that indicates how the &ldquo;validn&rdquo; result will be handled. If <code>"always"</code> then &ldquo;validn&rdquo; will always be shown and if <code>"never"</code> then &ldquo;validn&rdquo; will never be shown. However, if <code>"different"</code> (DEFAULT), then &ldquo;validn&rdquo; will only be shown if it differs from &ldquo;n&rdquo; (or if at least one group differs from &ldquo;n&rdquo; when summarized by multiple groups).</p>
</td></tr>
<tr><td><code id="Summarize_+3A_perczero">percZero</code></td>
<td>
<p>A string that indicates how the &ldquo;percZero&rdquo; result will be handled. If <code>"always"</code> then &ldquo;percZero&rdquo; will always be shown and if <code>"never"</code> then &ldquo;percZero&rdquo; will never be shown. However, if <code>"different"</code> (DEFAULT), then &ldquo;percZero&rdquo; will only be shown if it is greater than zero (or if at least one group is greater than zero when summarized by multiple groups).</p>
</td></tr>
<tr><td><code id="Summarize_+3A_data">data</code></td>
<td>
<p>A data.frame that contains the variables in <code>formula</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily used with formulas of the following types (where <code>quant</code> and <code>factor</code> generically represent quantitative/numeric and factor variables, respectively):
</p>

<table>
<tr>
 <td style="text-align: left;">
  Formula </td><td style="text-align: left;"> Description of Summary </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>~quant</code> </td><td style="text-align: left;"> Numerical summaries (see below) of <code>quant</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quant~factor</code> </td><td style="text-align: left;"> Summaries of <code>quant</code> separated by levels in <code>factor</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>quant~factor1*factor2</code> </td><td style="text-align: left;"> Summaries of <code>quant</code> separated by the combined levels in <code>factor1</code> and <code>factor2</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Numerical summaries include all results from <code><a href="base.html#topic+summary">summary</a></code> (min, Q1, mean, median, Q3, and max) and the sample size, valid sample size (sample size minus number of <code>NA</code>s), and standard deviation (i.e., <code>sd</code>). <code>NA</code> values are removed from the calculations with <code>na.rm=TRUE</code> (the DEFAULT). The number of digits in the returned results are controlled with <code>digits=</code>.
</p>


<h3>Value</h3>

<p>A named vector or data frame (when a quantitative variable is separated by one or two factor variables) of summary statistics for numeric data.
</p>


<h3>Note</h3>

<p>Students often need to examine basic statistics of a quantitative variable separated for different levels of a categorical variable. These results may be obtained with <code><a href="base.html#topic+tapply">tapply</a></code>, <code><a href="base.html#topic+by">by</a></code>, or <code><a href="stats.html#topic+aggregate">aggregate</a></code> (or with functions in other packages), but the use of these functions is not obvious to newbie students or return results in a format that is not obvious to newbie students. Thus, the formula method to <code>Summarize</code> allows newbie students to use a common notation (i.e., formula) to easily compute summary statistics for a quantitative variable separated by the levels of a factor.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+summary">summary</a></code> for related one dimensional functionality. See <code><a href="base.html#topic+tapply">tapply</a></code>, <code>summaryBy</code> in <span class="pkg">doBy</span>, <code><a href="psych.html#topic+describe">describe</a></code> in <span class="pkg">psych</span>, <code>describe</code> in <span class="pkg">prettyR</span>, and <code>basicStats</code> in <span class="pkg">fBasics</span> for similar &ldquo;by&rdquo; functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a data.frame of "data"
n &lt;- 102
d &lt;- data.frame(y=c(0,0,NA,NA,NA,runif(n-5)),
                w=sample(7:9,n,replace=TRUE),
                v=sample(0:2,n,replace=TRUE),
                g1=factor(sample(c("A","B","C",NA),n,replace=TRUE)),
                g2=factor(sample(c("male","female","UNKNOWN"),n,replace=TRUE)),
                g3=sample(c("a","b","c","d"),n,replace=TRUE),
                stringsAsFactors=FALSE)

# typical output of summary() for a numeric variable
summary(d$y)   

# this function           
Summarize(d$y,digits=3)
Summarize(~y,data=d,digits=3)
Summarize(y~1,data=d,digits=3)

# note that nvalid is not shown if there are no NAs and
#   percZero is not shown if there are no zeros
Summarize(~w,data=d,digits=3)
Summarize(~v,data=d,digits=3)

# note that the nvalid and percZero results can be forced to be shown
Summarize(~w,data=d,digits=3,nvalid="always",percZero="always")

## Numeric vector by levels of a factor variable
Summarize(y~g1,data=d,digits=3)
Summarize(y~g2,data=d,digits=3)
Summarize(y~g2,data=d,digits=3,exclude="UNKNOWN")

## Numeric vector by levels of two factor variables
Summarize(y~g1+g2,data=d,digits=3)
Summarize(y~g1+g2,data=d,digits=3,exclude="UNKNOWN")

## What happens if RHS of formula is not a factor
Summarize(y~w,data=d,digits=3)

## Summarizing multiple variables in a data.frame (must reduce to numerics)
lapply(as.list(d[,1:3]),Summarize,digits=4)

</code></pre>

<hr>
<h2 id='sumTable'>Creates a one- or two-way table of summary statistics.</h2><span id='topic+sumTable'></span><span id='topic+sumTable.formula'></span>

<h3>Description</h3>

<p>Creates a one- or two-way table of summary statistics for a quantitative variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumTable(formula, ...)

## S3 method for class 'formula'
sumTable(formula, data = NULL, FUN = mean, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumTable_+3A_formula">formula</code></td>
<td>
<p>A formula with a quantitative variable on the left-hand-side and one or two factor variables on the right-hand-side. See details.</p>
</td></tr>
<tr><td><code id="sumTable_+3A_...">...</code></td>
<td>
<p>Other arguments to pass through to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="sumTable_+3A_data">data</code></td>
<td>
<p>An optional data frame that contains the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="sumTable_+3A_fun">FUN</code></td>
<td>
<p>A scalar function that identifies the summary statistics. Applied to the quantitative variable for all data subsets identified by the combination of the factor(s). Defaults to <code>mean</code>.</p>
</td></tr>
<tr><td><code id="sumTable_+3A_digits">digits</code></td>
<td>
<p>A single numeric that indicates the number of digits to be used for the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula must be of the form <code>quantitative~factor</code> or <code>quantitative~factor*factor2</code> where <code>quantitative</code> is the quantitative variable to construct the summaries for and <code>factor</code> and <code>factor2</code> are factor variables that contain the levels for which separate summaries should be constructed. If the variables on the right-hand-side are not factors, then they will be coerced to be factors and a warning will be issued.
</p>
<p>This function is largely a wrapper to <code>tapply()</code>, but only works for one quantitative variable on the left-hand-side and one or two factor variables on the right-hand-side. Consider using <code><a href="base.html#topic+tapply">tapply</a></code> for situations with more factors on the right-hand-side.
</p>


<h3>Value</h3>

<p>A one-way array of values if only one factor variable is supplied on the right-hand-side of <code>formula</code>. A two-way matrix of values if two factor variables are supplied on the right-hand-side of <code>formula</code>. These are the same classes of objects returned by <code><a href="base.html#topic+tapply">tapply</a></code>.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+tapply">tapply</a></code> for a more general implementation. See <code><a href="#topic+Summarize">Summarize</a></code> for a similar computation when only one factor variable is given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The same examples as in the old aggregate.table in gdata package
## but data in data.frame to illustrate formula notation
d &lt;- data.frame(g1=sample(letters[1:5], 1000, replace=TRUE),
                g2=sample(LETTERS[1:3], 1000, replace=TRUE),
                dat=rnorm(1000))

sumTable(dat~g1*g2,data=d,FUN=length)       # get sample size
sumTable(dat~g1*g2,data=d,FUN=validn)       # get sample size (better way)
sumTable(dat~g1*g2,data=d,FUN=mean)         # get mean
sumTable(dat~g1*g2,data=d,FUN=sd)           # get sd
sumTable(dat~g1*g2,data=d,FUN=sd,digits=1)  # show digits= argument

## Also demonstrate use in the 1-way example -- but see Summarize()
sumTable(dat~g1,data=d,FUN=validn)
sumTable(dat~g1,data=d,FUN=mean)

## Example with a missing value (compare to above)
d$dat[1] &lt;- NA
sumTable(dat~g1,data=d,FUN=validn)  # note use of validn
sumTable(dat~g1,data=d,FUN=mean,na.rm=TRUE)

</code></pre>

<hr>
<h2 id='tictactoe'>Construct a base tic-tac-toe plot for presenting predator-prey PSD values.</h2><span id='topic+tictactoe'></span>

<h3>Description</h3>

<p>Construct a base tic-tac-toe plot for presenting predator-prey PSD values. Predator-prey PSD values are added with <code><a href="plotrix.html#topic+plotCI">plotCI</a></code> from <span class="pkg">plotrix</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tictactoe(
  predobj = c(30, 70),
  preyobj = c(30, 70),
  predlab = "Predator PSD",
  preylab = "Prey PSD",
  obj.col = "black",
  obj.trans = 0.2,
  bnd.col = "black",
  bnd.lwd = 1,
  bnd.lty = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tictactoe_+3A_predobj">predobj</code></td>
<td>
<p>A vector of length 2 that contains the target objective range for the predator.</p>
</td></tr>
<tr><td><code id="tictactoe_+3A_preyobj">preyobj</code></td>
<td>
<p>A vector of length 2 that contains the target objective range for the prey.</p>
</td></tr>
<tr><td><code id="tictactoe_+3A_predlab">predlab</code></td>
<td>
<p>A string representing a label for the x-axis.</p>
</td></tr>
<tr><td><code id="tictactoe_+3A_preylab">preylab</code></td>
<td>
<p>A string representing a label for the y-axis.</p>
</td></tr>
<tr><td><code id="tictactoe_+3A_obj.col">obj.col</code></td>
<td>
<p>A string designating a color to which the target objective regions should be shaded.</p>
</td></tr>
<tr><td><code id="tictactoe_+3A_obj.trans">obj.trans</code></td>
<td>
<p>A numeric (decimal) that indicates the level of transparency for marking the target objective regions.</p>
</td></tr>
<tr><td><code id="tictactoe_+3A_bnd.col">bnd.col</code></td>
<td>
<p>A string that indicates a color for the boundaries of the target objective regions.</p>
</td></tr>
<tr><td><code id="tictactoe_+3A_bnd.lwd">bnd.lwd</code></td>
<td>
<p>A numeric that indicates the line width for the boundaries of the target objective regions.</p>
</td></tr>
<tr><td><code id="tictactoe_+3A_bnd.lty">bnd.lty</code></td>
<td>
<p>A numeric that indicates the line type for the boundaries of the target objective regions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply creates a base tic-tac-toe plot. Observed values, with confidence intervals, are added to this plot with <code><a href="plotrix.html#topic+plotCI">plotCI</a></code> from <span class="pkg">plotrix</span>; see examples.
</p>


<h3>Value</h3>

<p>None. However, a graphic is produced.
</p>


<h3>IFAR Chapter</h3>

<p>6-Size Structure.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+psdVal">psdVal</a></code> and <code><a href="#topic+psdCalc">psdCalc</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create hypothetical data for plotting one point .. similar to what might come from psdCalc()
prey &lt;- c(45.4,30.2,56.8)
pred &lt;- c(24.5,10.2,36.7)
names(prey) &lt;- names(pred) &lt;- c("Estimate","95% LCI","95% UCI")
prey
pred

tictactoe()
if (require(plotrix)) {
  plotCI(prey[1],pred[1],li=prey[2],ui=prey[3],err="x",pch=16,add=TRUE)
  plotCI(prey[1],pred[1],li=pred[2],ui=pred[3],err="y",pch=16,add=TRUE) 
}

## Create hypothetical data for plotting three points ... similar to what might come from psdCalc()
prey &lt;- rbind(c(45.4,30.2,56.8),
              c(68.2,56.7,79.4),
              c(17.1, 9.5,26.3))
pred &lt;- rbind(c(24.5,10.2,36.7),
              c(14.2, 7.1,21.3),
              c(16.3, 8.2,24.4))
colnames(prey) &lt;- colnames(pred) &lt;- c("Estimate","95% LCI","95% UCI")
prey
pred

tictactoe()
if (require(plotrix)) {
  plotCI(prey[,1],pred[,1],li=prey[,2],ui=prey[,3],err="x",pch=16,add=TRUE)
  plotCI(prey[,1],pred[,1],li=pred[,2],ui=pred[,3],err="y",pch=16,add=TRUE)
}
lines(prey[,1],pred[,1])
text(prey[,1],pred[,1],labels=c(2010,2011,2012),adj=c(-0.5,-0.5))

</code></pre>

<hr>
<h2 id='validn'>Finds the number of valid (non-NA) values in a vector.</h2><span id='topic+validn'></span>

<h3>Description</h3>

<p>Finds the number of valid (non-NA) values in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validn(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validn_+3A_object">object</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value that is the number of non-<code>NA</code> values in a vector.
</p>


<h3>IFAR Chapter</h3>

<p>2-Basic Data Manipulations.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="plotrix.html#topic+valid.n">valid.n</a></code> in <span class="pkg">plotrix</span> and <code>nobs</code> in <span class="pkg">gdata</span> for similar functionality. See <code><a href="Matrix.html#topic+is.na">is.na</a></code> for finding the missing values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>junk1 &lt;- c(1,7,2,4,3,10,NA)
junk2 &lt;- c("Derek","Hugh","Ogle","Santa","Claus","Nick",NA,NA)
junk3 &lt;- factor(junk2)
junk4 &lt;- c(TRUE,TRUE,FALSE,FALSE,FALSE,TRUE,NA,NA)
junk5 &lt;- data.frame(junk1)
junk6 &lt;- data.frame(junk3)

validn(junk1)
validn(junk2)
validn(junk3)
validn(junk4)
validn(junk5)
validn(junk6)
 
</code></pre>

<hr>
<h2 id='vbStarts'>Find reasonable starting values for a von Bertalanffy growth function.</h2><span id='topic+vbStarts'></span>

<h3>Description</h3>

<p>Finds reasonable starting values for the parameters in a specific parameterization of the von Bertalanffy growth function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vbStarts(
  formula,
  data = NULL,
  param = c("Typical", "typical", "Traditional", "traditional", "BevertonHolt",
    "Original", "original", "vonBertalanffy", "GQ", "GallucciQuinn", "Mooij", "Weisberg",
    "Ogle", "Schnute", "Francis", "Somers", "Somers2", "Pauly"),
  type = param,
  fixed = NULL,
  meth0 = c("yngAge", "poly"),
  methLinf = c("Walford", "oldAge", "longFish"),
  num4Linf = 1,
  ages2use = NULL,
  methEV = c("means", "poly"),
  valOgle = NULL,
  plot = FALSE,
  col.mdl = "gray70",
  lwd.mdl = 3,
  lty.mdl = 1,
  cex.main = 0.9,
  col.main = "red",
  dynamicPlot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vbStarts_+3A_formula">formula</code></td>
<td>
<p>A formula of the form <code>len~age</code>.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_data">data</code></td>
<td>
<p>A data frame that contains the variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_type">type</code>, <code id="vbStarts_+3A_param">param</code></td>
<td>
<p>A string that indicates the parameterization of the von Bertalanffy model.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_fixed">fixed</code></td>
<td>
<p>A named list that contains user-defined rather than automatically generated (i.e., fixed) starting values for one or more parameters. See details.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_meth0">meth0</code></td>
<td>
<p>A string that indicates how the t0 and L0 parameters should be derived. See details.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_methlinf">methLinf</code></td>
<td>
<p>A string that indicates how Linf should be derived. See details.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_num4linf">num4Linf</code></td>
<td>
<p>A single numeric that indicates how many of the longest fish (if <code>methLinf="longFish"</code>) or how any of the oldest ages (if <code>methLinf="oldAge"</code>) should be averaged to estimate a starting value for Linf.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_ages2use">ages2use</code></td>
<td>
<p>A numerical vector of the two ages to be used in the Schnute or Francis parameterizations. See details.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_methev">methEV</code></td>
<td>
<p>A string that indicates how the lengths of the two ages in the Schnute parameterization or the three ages in the Francis parameterization should be derived. See details.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_valogle">valOgle</code></td>
<td>
<p>A single named numeric that is the set Lr or tr value for use in <code>type="Ogle"</code>. See details.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_plot">plot</code></td>
<td>
<p>A logical that indicates whether a plot of the data with the superimposed model fit at the starting values should be created.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_col.mdl">col.mdl</code></td>
<td>
<p>A color for the model when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_lwd.mdl">lwd.mdl</code></td>
<td>
<p>A line width for the model when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_lty.mdl">lty.mdl</code></td>
<td>
<p>A line type for the model when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_cex.main">cex.main</code></td>
<td>
<p>A character expansion value for the main title when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_col.main">col.main</code></td>
<td>
<p>A color for the main title when <code>plot=TRUE</code>.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_dynamicplot">dynamicPlot</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
<tr><td><code id="vbStarts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to find reasonable starting values for a variety of parameterizations of the von Bertalanffy growth function. There is no guarantee that these starting values are the &lsquo;best&rsquo; starting values. One should use them with caution and should perform sensitivity analyses to determine the impact of different starting values on the final model results.
</p>
<p>If <code>methLinf="Walford"</code>, then the Linf and K parameters are estimated via the concept of the Ford-Walford plot. If <code>methLinf="oldAge"</code> then Linf is estimated as the mean length of the <code>num4Linf</code> longest observed lengths.
</p>
<p>The product of the starting values for Linf and K is used as a starting value for omega in the GallucciQuinn and Mooij parameterizations. The result of log(2) divided by the starting value for K is used as the starting value for t50 in the Weisberg parameterization.
</p>
<p>If <code>meth0="yngAge"</code>, then a starting value for t0 or L0 is found by algebraically solving the typical or original parameterization, respectively, for t0 or L0 using the mean length of the first age with more than one data point as a &ldquo;known&rdquo; quantity. If <code>meth0="poly"</code> then a second-degree polynomial model is fit to the mean length-at-age data. The t0 starting value is set equal to the root of the polynomial that is closest to zero. The L0 starting value is set equal to the mean length at age-0 predicted from the polynomial function.
</p>
<p>Starting values for the L1 and L3 parameters in the Schnute parameterization and the L1, L2, and L3 parameters in the Francis parameterization may be found in two ways. If <code>methEV="poly"</code>, then the starting values are the predicted length-at-age from a second-degree polynomial fit to the mean lengths-at-age data. If <code>methEV="means"</code> then the observed sample means at the corresponding ages are used. In the case where one of the supplied ages is fractional, then the value returned will be linearly interpolated between the mean lengths of the two closest ages. The ages to be used for L1 and L3 in the Schnute and Francis parameterizations are supplied as a numeric vector of length 2 in <code>ages2use=</code>. If <code>ages2use=NULL</code> then the minimum and maximum observed ages will be used. In the Francis method, L2 will correspond to the age half-way between the two ages in <code>ages2use=</code>. A warning will be given if L2&lt;L1 for the Schnute method or if L2&lt;L1 or L3&lt;L2 for the Francis method.
</p>
<p>Starting values for the Somers and Pauly parameterizations are the same as the traditional parameterization for Linf, K, and t0. However, for the Pauly parameterization the starting value for Kpr is the starting value for K divided by 1 minus the starting value of NGT. The starting values of C, ts, WP, and NGT are set at constants that are unlikely to work for all species. Thus, the user should use the <code>fixed</code> argument to fix starting values for these parameters that are more likely to result in a reliable fit.
</p>


<h3>Value</h3>

<p>A list that contains reasonable starting values. Note that the parameters will be listed in the same order and with the same names as listed in <code><a href="#topic+vbFuns">vbFuns</a></code>.
</p>


<h3>IFAR Chapter</h3>

<p>12-Individual Growth.
</p>


<h3>Note</h3>

<p>The &lsquo;original&rsquo; and &lsquo;vonBertalanffy&rsquo; and the &lsquo;typical&rsquo; and &lsquo;BevertonHolt&rsquo; parameterizations are synonymous.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>See references in <code><a href="#topic+vbFuns">vbFuns</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+growthFunShow">growthFunShow</a></code> to display the equations for the parameterizations used in <span class="pkg">FSA</span> and <code><a href="#topic+vbFuns">vbFuns</a></code> for functions that represent the von Bertalanffy parameterizations. See <code><a href="#topic+nlsTracePlot">nlsTracePlot</a></code> for help troubleshooting nonlinear models that don't converge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple examples of each parameterization
vbStarts(tl~age,data=SpotVA1)
vbStarts(tl~age,data=SpotVA1,type="Original")
vbStarts(tl~age,data=SpotVA1,type="GQ")
vbStarts(tl~age,data=SpotVA1,type="Mooij")
vbStarts(tl~age,data=SpotVA1,type="Weisberg")
vbStarts(tl~age,data=SpotVA1,type="Francis",ages2use=c(0,5))
vbStarts(tl~age,data=SpotVA1,type="Schnute",ages2use=c(0,5))
vbStarts(tl~age,data=SpotVA1,type="Somers")
vbStarts(tl~age,data=SpotVA1,type="Somers2")
vbStarts(tl~age,data=SpotVA1,type="Pauly")
vbStarts(tl~age,data=SpotVA1,type="Ogle",valOgle=c(tr=0))
vbStarts(tl~age,data=SpotVA1,type="Ogle",valOgle=c(Lr=8))

## Using a different method to find Linf
vbStarts(tl~age,data=SpotVA1,methLinf="oldAge")
vbStarts(tl~age,data=SpotVA1,methLinf="oldAge",num4Linf=2)
vbStarts(tl~age,data=SpotVA1,methLinf="longFish")
vbStarts(tl~age,data=SpotVA1,methLinf="longFish",num4Linf=10)
vbStarts(tl~age,data=SpotVA1,type="Original",methLinf="oldAge")
vbStarts(tl~age,data=SpotVA1,type="Original",methLinf="oldAge",num4Linf=2)
vbStarts(tl~age,data=SpotVA1,type="Original",methLinf="longFish")
vbStarts(tl~age,data=SpotVA1,type="Original",methLinf="longFish",num4Linf=10)
vbStarts(tl~age,data=SpotVA1,type="Ogle",valOgle=c(tr=0),methLinf="oldAge",num4Linf=2)
vbStarts(tl~age,data=SpotVA1,type="Ogle",valOgle=c(Lr=8),methLinf="longFish",num4Linf=10)

## Using a different method to find t0 and L0
vbStarts(tl~age,data=SpotVA1,meth0="yngAge")
vbStarts(tl~age,data=SpotVA1,type="original",meth0="yngAge")

## Using a different method to find the L1, L2, and L3
vbStarts(tl~age,data=SpotVA1,type="Francis",ages2use=c(0,5),methEV="means")
vbStarts(tl~age,data=SpotVA1,type="Schnute",ages2use=c(0,5),methEV="means")

## Examples with a Plot
vbStarts(tl~age,data=SpotVA1,plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="original",plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="GQ",plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Mooij",plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Weisberg",plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Francis",ages2use=c(0,5),plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Schnute",ages2use=c(0,5),plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Somers",plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Somers2",plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Pauly",plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Ogle",valOgle=c(tr=0),plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Ogle",valOgle=c(Lr=8),plot=TRUE)

## Examples where some parameters are fixed by the user
vbStarts(tl~age,data=SpotVA1,fixed=list(Linf=15))
vbStarts(tl~age,data=SpotVA1,fixed=list(Linf=15,K=0.3))
vbStarts(tl~age,data=SpotVA1,fixed=list(Linf=15,K=0.3,t0=-1))
vbStarts(tl~age,data=SpotVA1,fixed=list(Linf=15,K=0.3,t0=-1),plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Pauly",fixed=list(t0=-1.5),plot=TRUE)
vbStarts(tl~age,data=SpotVA1,type="Ogle",valOgle=c(tr=2),fixed=list(Lr=10),plot=TRUE)

## See examples in vbFuns() for use of vbStarts() when fitting Von B models

</code></pre>

<hr>
<h2 id='WhitefishLC'>Assigned ages from two readers on three structures for Lake Whitefish from Lake Champlain.</h2><span id='topic+WhitefishLC'></span>

<h3>Description</h3>

<p>Assigned ages from two readers on three structures for Lake Whitefish (<em>Coregonus clupeaformis</em>) from Lake Champlain in 2009.
</p>


<h3>Format</h3>

<p>A data frame with 151 observations on the following 11 variables:
</p>

<dl>
<dt>fishID</dt><dd><p>A unique fish identification number</p>
</dd>
<dt>tl</dt><dd><p>Total length (in mm)</p>
</dd>
<dt>scale1</dt><dd><p>Assessed age from scales by first reader</p>
</dd>
<dt>scale2</dt><dd><p>Assessed age from scales by second reader</p>
</dd>
<dt>scaleC</dt><dd><p>Consensus age from scales by both reader</p>
</dd>
<dt>finray1</dt><dd><p>Assessed age from fin rays by first reader</p>
</dd>
<dt>finray2</dt><dd><p>Assessed age from fin rays by second reader</p>
</dd>
<dt>finrayC</dt><dd><p>Consensus age from fin rays by both reader</p>
</dd>
<dt>otolith1</dt><dd><p>Assessed age from otoliths by first reader</p>
</dd>
<dt>otolith2</dt><dd><p>Assessed age from otoliths by second reader</p>
</dd>
<dt>otolithC</dt><dd><p>Consensus age from otoliths by both reader</p>
</dd>
</dl>



<h3>Topic(s)</h3>


<ul>
<li><p> Age 
</p>
</li>
<li><p> Ageing Error
</p>
</li>
<li><p> Precision 
</p>
</li>
<li><p> Bias 
</p>
</li>
<li><p> Age Comparisons
</p>
</li></ul>



<h3>Source</h3>

<p>Data from Herbst, S.J. and J.E. Marsden. 2011. Comparison of precision and bias of scale, fin ray, and otolith age estimates for lake whitefish (<em>Coregonus clupeaformis</em>) in Lake Champlain. Journal of Great Lakes Research. 37:386-389. Contributed by Seth Herbst. <b>Do not use for other than educational purposes without permission from the author.</b> <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/WhitefishLC.csv">CSV file</a>
</p>


<h3>See Also</h3>

<p>Used in <code><a href="#topic+ageBias">ageBias</a></code> and <code><a href="#topic+agePrecision">agePrecision</a></code> examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(WhitefishLC)
head(WhitefishLC)

</code></pre>

<hr>
<h2 id='WR79'>Ages and lengths for a hypothetical sample from Westerheim and Ricker (1979).</h2><span id='topic+WR79'></span>

<h3>Description</h3>

<p>Ages and lengths for a hypothetical sample in Westerheim and Ricker (1979).
</p>


<h3>Format</h3>

<p>A data frame of 2369 observations on the following 3 variables:
</p>

<dl>
<dt>ID</dt><dd><p>Unique fish identifiers</p>
</dd>
<dt>len</dt><dd><p>Length of an individual fish</p>
</dd>
<dt>age</dt><dd><p>Age of an individual fish</p>
</dd>
</dl>



<h3>Details</h3>

<p>Age-length data in 5-cm increments taken exactly from Table 2A of the source which was a sample from a hypothetical population in which year-class strength varied in the ratio 2:1 and the rate of increase in length decreased with age. Actual lengths in each 5-cm interval were simulated with a uniform distribution. The aged fish in this file were randomly selected and an assessed age was assigned according to the information in Table 2A.
</p>


<h3>Topic(s)</h3>


<ul>
<li><p> Age-Length Key
</p>
</li></ul>



<h3>Source</h3>

<p>Simulated from Table 2A in Westerheim, S.J. and W.E. Ricker. 1979. Bias in using age-length key to estimate age-frequency distributions. Journal of the Fisheries Research Board of Canada. 35:184-189. <a href="https://raw.githubusercontent.com/fishR-Core-Team/FSA/master/data-raw/WR79.csv">CSV file</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(WR79)
head(WR79)

## Extract the aged sample
WR79.aged &lt;- subset(WR79,!is.na(age))
str(WR79.aged)

## Extract the length sample
WR79.length &lt;- subset(WR79,is.na(age))
str(WR79.length)

</code></pre>

<hr>
<h2 id='wrAdd'>Computes a vector of relative weights specific to a species in an entire data frame.</h2><span id='topic+wrAdd'></span><span id='topic+wrAdd.default'></span><span id='topic+wrAdd.formula'></span>

<h3>Description</h3>

<p>This computes a vector that contains the relative weight specific to each species for all individuals in an entire data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrAdd(wt, ...)

## Default S3 method:
wrAdd(wt, len, spec, units = c("metric", "English"), ...)

## S3 method for class 'formula'
wrAdd(wt, data, units = c("metric", "English"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrAdd_+3A_wt">wt</code></td>
<td>
<p>A numeric vector that contains weight measurements or a formula of the form <code>wt~len+spec</code> where &ldquo;wt&rdquo; generically represents the weight variable, &ldquo;len&rdquo; generically represents the length variable, and &ldquo;spec&rdquo; generically represents the species variable. Note that this formula can only contain three variables and they must be in the order of weight first, length second, species third.</p>
</td></tr>
<tr><td><code id="wrAdd_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="wrAdd_+3A_len">len</code></td>
<td>
<p>A numeric vector that contains length measurements. Not used if <code>wt</code> is a formula.</p>
</td></tr>
<tr><td><code id="wrAdd_+3A_spec">spec</code></td>
<td>
<p>A character or factor vector that contains the species names. Not used if <code>wt</code> is a formula.</p>
</td></tr>
<tr><td><code id="wrAdd_+3A_units">units</code></td>
<td>
<p>A string that indicates whether the weight and length data in <code>formula</code> are in (<code>"metric"</code> (DEFAULT; mm and g) or <code>"English"</code> (in and lbs) units.</p>
</td></tr>
<tr><td><code id="wrAdd_+3A_data">data</code></td>
<td>
<p>A data.frame that minimally contains variables of the the observed lengths, observed weights, and the species names given in the <code>formula=</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This computes a vector that contains the relative weight specific to each species for all individuals in an entire data frame. The vector can be appended to an existing data.frame to create a variable that contains the relative weights for each individual. The relative weight value will be <code>NA</code> for each individual for which a standard weight equation does not exist in <code><a href="#topic+WSlit">WSlit</a></code>, a standard weight equation for the units given in <code>units=</code> does not exist in <code><a href="#topic+WSlit">WSlit</a></code>, a standard weight equation for the 75th percentile does not exist in <code><a href="#topic+WSlit">WSlit</a></code>, or if the individual is shorter or longer than the lengths for which the standard weight equation should be applied. Either the linear or quadratic equation has been listed as preferred for each species, so only that equation will be used. The use of the 75th percentile is by far the most common and, because this function is designed for use on entire data frames, it will be the only percentile allowed. Thus, to use equations for other percentiles, one will have to use &ldquo;manual&rdquo; methods. See <code><a href="#topic+WSlit">WSlit</a></code> and <code><a href="#topic+wsVal">wsVal</a></code> for more details about types of equations, percentiles, finding which species have published standard weight equations, etc. See the examples for one method for changing species names to something that this function will recognize.
</p>


<h3>Value</h3>

<p>Returns A numeric vector that contains the computed relative weights, in the same order as in <code>data=</code>.
</p>


<h3>IFAR Chapter</h3>

<p>8-Condition.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+wsVal">wsVal</a></code>, <code><a href="#topic+WSlit">WSlit</a></code>, and <code><a href="#topic+psdAdd">psdAdd</a></code> for related functionality. See <code><a href="plyr.html#topic+mapvalues">mapvalues</a></code> for help in changing species names to match those in <code><a href="#topic+WSlit">WSlit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create random data for three species
# just to control the randomization
set.seed(345234534)
dbt &lt;- data.frame(species=factor(rep(c("Bluefin Tuna"),30)),
                  tl=round(rnorm(30,1900,300),0))
dbt$wt &lt;- round(4.5e-05*dbt$tl^2.8+rnorm(30,0,6000),1)
dbg &lt;- data.frame(species=factor(rep(c("Bluegill"),30)),
                  tl=round(rnorm(30,130,50),0))
dbg$wt &lt;- round(4.23e-06*dbg$tl^3.316+rnorm(30,0,10),1)
dlb &lt;- data.frame(species=factor(rep(c("Largemouth Bass"),30)),
                  tl=round(rnorm(30,350,60),0))
dlb$wt &lt;- round(2.96e-06*dlb$tl^3.273+rnorm(30,0,60),1)
df &lt;- rbind(dbt,dbg,dlb)
str(df)

df$Wr1 &lt;- wrAdd(wt~tl+species,data=df)
## same but with non-formula interface
df$Wr2 &lt;- wrAdd(df$wt,df$tl,df$species)

## Same as above but using dplyr
if (require(dplyr)) {
  df &lt;- mutate(df,Wr3a=wrAdd(wt,tl,species))
}

df
 
## Example with only one species in the data.frame
bg &lt;- droplevels(subset(df,species=="Bluegill"))
bg$Wr4 &lt;- wrAdd(wt~tl+species,data=bg)

</code></pre>

<hr>
<h2 id='WSlit'>All known standard weight equations.</h2><span id='topic+WSlit'></span>

<h3>Description</h3>

<p>Parameters for all known standard weight equations.
</p>


<h3>Format</h3>

<p>A data frame with observations on the following 13 variables:
</p>

<dl>
<dt>species</dt><dd><p>Species name. Use <code>wsVal()</code> to see the list of available species.</p>
</dd>
<dt>units</dt><dd><p>Units of measurements. <code>Metric</code> uses lengths in mm and weight in grams. <code>English</code> uses lengths in inches and weight in pounds.</p>
</dd>
<dt>type</dt><dd><p>Type of equation (<code>linear</code> or <code>quadratic</code>).</p>
</dd>
<dt>ref</dt><dd><p>Reference quartile (<code>75</code>, <code>50</code>, or <code>25</code>).</p>
</dd>
<dt>measure</dt><dd><p>The type of length measurement used &ndash; total length (<code>TL</code>) or fork length (<code>FL</code>).</p>
</dd>
<dt>method</dt><dd><p>The type of method used to derive the equation (Regression Line Percentile (<code>RLP</code>; see Murphy <em>et al.</em> (1990) and Murphy <em>et al.</em> (1991)), Empirical Percentile (<code>EmP</code>; see Gerow <em>et al.</em> (2005)), or <code>Other</code>).</p>
</dd>
<dt>min.len</dt><dd><p>Minimum total length (mm or in, depending on <code>units</code>) for which the equation should be applied.</p>
</dd>
<dt>max.len</dt><dd><p>Maximum total length (mm or in, depending on <code>units</code>) for which the equation should be applied.</p>
</dd>
<dt>int</dt><dd><p>The intercept for the model.</p>
</dd>
<dt>slope</dt><dd><p>The slope for the linear equation or the linear coefficient for the quadratic equation.</p>
</dd>
<dt>quad</dt><dd><p>The quadratic coefficient in the quadratic equation.</p>
</dd>
<dt>source</dt><dd><p>Source of the equation. These match the sources given in Neumann <em>et al.</em> (2012).</p>
</dd>
<dt>comment</dt><dd><p>Comments about use of equation.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The minimum TL for the English units were derived by rounding the converted minimum TL for the metric units to what seemed like common units (inches, half inches, or quarter inches).
</p>


<h3>Topic(s)</h3>


<ul>
<li><p> Relative weight
</p>
</li>
<li><p> Standard weight
</p>
</li>
<li><p> Condition
</p>
</li></ul>



<h3>IFAR Chapter</h3>

<p>8-Condition.
</p>


<h3>Source</h3>

<p>Most of these equations can be found in Neumann <em>et al.</em> (2012). Species not in Neumann <em>et al.</em> (2012) are noted as such in the <code>comments</code> variable.
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>
<p>Gerow, K.G., R.C. Anderson-Sprecher, and W.A. Hubert. 2005. A new method to compute standard weight equations that reduces length-related bias. North American Journal of Fisheries Management 25:12881300.
</p>
<p>Murphy, B.R., M.L. Brown, and T.A. Springer. 1990. Evaluation of the relative weight (Wr) index, with new applications to walleye. North American Journal of Fisheries Management 10:8597.
</p>
<p>Murphy, B. R., D. W. Willis, and T. A. Springer. 1991. The relative weight index in fisheries management: Status and needs. Fisheries (Bethesda) 16(2):3038.
</p>
<p>Neumann, R.M., C.S. Guy, and D.W. Willis. 2012. Length, Weight, and Associated Indices. Chapter 14 in Zale, A.V., D.L. Parrish, and T.M. Sutton, editors. Fisheries Techniques. American Fisheries Society, Bethesda, MD.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+wsVal">wsVal</a></code> and <code><a href="#topic+wrAdd">wrAdd</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(WSlit)
head(WSlit)

</code></pre>

<hr>
<h2 id='wsVal'>Finds standard weight equation coefficients for a particular species.</h2><span id='topic+wsVal'></span>

<h3>Description</h3>

<p>Returns a vector that contains all known or a subset of information about the standard weight equation for a given species, type of measurement units, and reference percentile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wsVal(
  species = "List",
  units = c("metric", "English"),
  ref = 75,
  simplify = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wsVal_+3A_species">species</code></td>
<td>
<p>A string that contains the species name for which to find coefficients. See details.</p>
</td></tr>
<tr><td><code id="wsVal_+3A_units">units</code></td>
<td>
<p>A string that indicates whether the coefficients for the standard weight equation to be returned are in (<code>"metric"</code> (DEFAULT; mm and g) or <code>"English"</code> (in and lbs) units.</p>
</td></tr>
<tr><td><code id="wsVal_+3A_ref">ref</code></td>
<td>
<p>A numeric that indicates which percentile the equation should be returned for. Note that the vast majority of equations only exist for the <code>75</code>th percentile (DEFAULT).</p>
</td></tr>
<tr><td><code id="wsVal_+3A_simplify">simplify</code></td>
<td>
<p>A logical that indicates whether the &lsquo;units&rsquo;, &lsquo;ref&rsquo;, &lsquo;measure&rsquo;, &lsquo;method&rsquo;, &lsquo;comments&rsquo;, and &lsquo;source&rsquo; fields should be included (<code>=FALSE</code>) or not (<code>=TRUE</code>; DEFAULT). See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extract all known information from <code><a href="#topic+WSlit">WSlit</a></code> about the following standard weight equation,
</p>
<p style="text-align: center;"><code class="reqn">log_{10}(Ws) = log_{10}(a) + blog_{10}(L) + blog_{10}(L)^{2}</code>
</p>

<p>See <code><a href="#topic+WSlit">WSlit</a></code> for more information about the meaning of each value returned.
</p>
<p>Note from above that the coefficients are returned for the TRANSFORMED model. Thus, to obtain the standard weight (Ws), the returned coefficients are used to compute the common log of Ws which must then bed raised to the power of 10 to compute the Ws.
</p>


<h3>Value</h3>

<p>A one row data frame from <code><a href="#topic+WSlit">WSlit</a></code> that contains all known information about the standard weight equation for a given species, type of measurement units, and reference percentile if <code>simplify=FALSE</code>. If <code>simplify=TRUE</code> then only the species; minimum and maximum length for which the standard equation should be applied; and intercept, slope, and quadratic  coefficients for the standard weight equation. Note that the maximum length and the quadratic coefficient will not be returned if they do not exist in <code><a href="#topic+WSlit">WSlit</a></code>.
</p>
<p>If no arguments are given to this function, a species name is mis-spelled, or if a standard weight equation does not exist (in <code><a href="#topic+WSlit">WSlit</a></code>) for a particular species, then a warning will be issued and a list of species names will be printed.
</p>


<h3>IFAR Chapter</h3>

<p>8-Condition.
</p>


<h3>Author(s)</h3>

<p>Derek H. Ogle, <a href="mailto:DerekOgle51@gmail.com">DerekOgle51@gmail.com</a>
</p>


<h3>References</h3>

<p>Ogle, D.H. 2016. <a href="https://fishr-core-team.github.io/fishR/pages/books.html#introductory-fisheries-analyses-with-r">Introductory Fisheries Analyses with R</a>. Chapman &amp; Hall/CRC, Boca Raton, FL.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+wrAdd">wrAdd</a></code> and <code><a href="#topic+WSlit">WSlit</a></code> for related functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wsVal()
wsVal("Bluegill")
wsVal("Bluegill",units="metric")
wsVal("Bluegill",units="English")
wsVal("Bluegill",units="English",simplify=TRUE)
wsVal("Ruffe",units="metric",simplify=TRUE)
wsVal("Ruffe",units="metric",ref=50,simplify=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
