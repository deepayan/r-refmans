<!DOCTYPE html><html><head><title>Help for package BayesianTools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BayesianTools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdaptpCR'><p>Adapts pCR values</p></a></li>
<li><a href='#AM'><p>The Adaptive Metropolis Algorithm</p></a></li>
<li><a href='#applySettingsDefault'><p>Provides the default settings for the different samplers in runMCMC</p></a></li>
<li><a href='#BayesianTools'><p>BayesianTools</p></a></li>
<li><a href='#betaFun'><p>Helper function for calculating beta</p></a></li>
<li><a href='#bridgesample'><p>Calculates the marginal likelihood of a chain via bridge sampling</p></a></li>
<li><a href='#calibrationTest'><p>Simulation-based calibration tests</p></a></li>
<li><a href='#checkBayesianSetup'><p>Checks if an object is of class 'BayesianSetup'</p></a></li>
<li><a href='#combineChains'><p>Function to combine chains</p></a></li>
<li><a href='#convertCoda'><p>Convert coda::mcmc objects to BayesianTools::mcmcSampler</p></a></li>
<li><a href='#correctThin'><p>Checks if thin is consistent with nTotalSamples samples and if not corrects it.</p></a></li>
<li><a href='#correlationPlot'><p>Flexible function to create correlation density plots</p></a></li>
<li><a href='#createBayesianSetup'><p>Creates a standardized collection of prior, likelihood and posterior functions, including error checks etc.</p></a></li>
<li><a href='#createBetaPrior'><p>Convenience function to create a beta prior</p></a></li>
<li><a href='#createLikelihood'><p>Creates a standardized likelihood class#'</p></a></li>
<li><a href='#createMcmcSamplerList'><p>Convenience function to create an object of class mcmcSamplerList from a list of mcmc samplers</p></a></li>
<li><a href='#createMixWithDefaults'><p>Allows to mix a given parameter vector with a default parameter vector</p></a></li>
<li><a href='#createPosterior'><p>Creates a standardized posterior class</p></a></li>
<li><a href='#createPrior'><p>Creates a standardized prior class</p></a></li>
<li><a href='#createPriorDensity'><p>Fits a density function to a multivariate sample</p></a></li>
<li><a href='#createProposalGenerator'><p>Factory that creates a proposal generator</p></a></li>
<li><a href='#createSmcSamplerList'><p>Convenience function to create an object of class SMCSamplerList from a list of mcmc samplers</p></a></li>
<li><a href='#createTruncatedNormalPrior'><p>Convenience function to create a truncated normal prior</p></a></li>
<li><a href='#createUniformPrior'><p>Convenience function to create a simple uniform prior distribution</p></a></li>
<li><a href='#DE'><p>Differential-Evolution MCMC</p></a></li>
<li><a href='#DEzs'><p>Differential-Evolution MCMC zs</p></a></li>
<li><a href='#DIC'><p>Deviance information criterion</p></a></li>
<li><a href='#DR'><p>The Delayed Rejection Algorithm</p></a></li>
<li><a href='#DRAM'><p>The Delayed Rejection Adaptive Metropolis Algorithm</p></a></li>
<li><a href='#DREAM'><p>DREAM</p></a></li>
<li><a href='#DREAMzs'><p>DREAMzs</p></a></li>
<li><a href='#factorMatrice'><p>factorMatrice</p></a></li>
<li><a href='#gelmanDiagnostics'><p>Gelman Diagnostics</p></a></li>
<li><a href='#generateCRvalues'><p>Generates matrix of CR values based on pCR</p></a></li>
<li><a href='#generateParallelExecuter'><p>Factory to generate a parallel executor of an existing function</p></a></li>
<li><a href='#generateTestDensityMultiNormal'><p>Multivariate normal likelihood</p></a></li>
<li><a href='#getBlock'><p>Determine the parameters in the block update</p></a></li>
<li><a href='#getBlockSettings'><p>getblockSettings</p></a></li>
<li><a href='#getCredibleIntervals'><p>Calculate confidence region from an MCMC or similar sample</p></a></li>
<li><a href='#getDharmaResiduals'><p>Creates a DHARMa object</p></a></li>
<li><a href='#getPanels'><p>getPanels</p></a></li>
<li><a href='#getPossibleSamplerTypes'><p>Returns possible sampler types</p></a></li>
<li><a href='#getPredictiveDistribution'><p>Calculates predictive distribution based on the parameters</p></a></li>
<li><a href='#getPredictiveIntervals'><p>Calculates Bayesian credible (confidence) and predictive intervals based on parameter sample</p></a></li>
<li><a href='#getRmvnorm'><p>Produce multivariate normal proposal</p></a></li>
<li><a href='#getSample'><p>Extracts the sample from a bayesianOutput</p></a></li>
<li><a href='#getSetup'><p>Function to get the setup from a bayesianOutput</p></a></li>
<li><a href='#getVolume'><p>Calculate posterior volume</p></a></li>
<li><a href='#Gfun'><p>Helper function for blow and hop moves</p></a></li>
<li><a href='#GOF'><p>Standard GOF metrics</p>
Startvalues for sampling with nrChains &gt; 1 : if you want to provide different start values for the different chains, provide a list</a></li>
<li><a href='#likelihoodAR1'><p>AR1 type likelihood function</p></a></li>
<li><a href='#likelihoodIidNormal'><p>Normal / Gaussian Likelihood function</p></a></li>
<li><a href='#logSumExp'><p>Funktion to compute log(sum(exp(x))</p></a></li>
<li><a href='#M'><p>The Metropolis Algorithm</p></a></li>
<li><a href='#makeObjectClassCodaMCMC'><p>Helper function to change an object to a coda mcmc class,</p></a></li>
<li><a href='#MAP'><p>calculates the Maxiumum APosteriori value (MAP)</p></a></li>
<li><a href='#marginalLikelihood'><p>Calcluated the marginal likelihood from a set of MCMC samples</p></a></li>
<li><a href='#marginalPlot'><p>Plot MCMC marginals</p></a></li>
<li><a href='#marginalPlotDensity'><p>Plot marginals as densities</p></a></li>
<li><a href='#marginalPlotViolin'><p>Plot marginals as violin plot</p></a></li>
<li><a href='#mcmcMultipleChains'><p>Run multiple chains</p></a></li>
<li><a href='#mergeChains'><p>Merge Chains</p></a></li>
<li><a href='#Metropolis'><p>Creates a Metropolis-type MCMC with options for covariance adaptatin, delayed rejection, Metropolis-within-Gibbs, and tempering</p></a></li>
<li><a href='#metropolisRatio'><p>Function to calculate the metropolis ratio</p></a></li>
<li><a href='#plotDiagnostic'><p>Diagnostic Plot</p></a></li>
<li><a href='#plotSensitivity'><p>Performs a one-factor-at-a-time sensitivity analysis for the posterior of a given bayesianSetup within the prior range.</p></a></li>
<li><a href='#plotTimeSeries'><p>Plots a time series, with the option to include confidence and prediction band</p></a></li>
<li><a href='#plotTimeSeriesResiduals'><p>Plots residuals of a time series</p></a></li>
<li><a href='#plotTimeSeriesResults'><p>Creates a time series plot typical for an MCMC / SMC fit</p></a></li>
<li><a href='#propFun'><p>Helper function to create proposal</p></a></li>
<li><a href='#rescale'><p>Rescale</p></a></li>
<li><a href='#runMCMC'><p>Main wrapper function to start MCMCs, particle MCMCs and SMCs</p></a></li>
<li><a href='#sampleEquallySpaced'><p>Gets n equally spaced samples (rows) from a matrix or vector</p></a></li>
<li><a href='#sampleMetropolis'><p>gets samples while adopting the MCMC proposal generator</p></a></li>
<li><a href='#scaleMatrix'><p>Function to scale matrices</p></a></li>
<li><a href='#setupStartProposal'><p>Help function to find starvalues and proposalGenerator settings</p></a></li>
<li><a href='#smcSampler'><p>SMC sampler</p></a></li>
<li><a href='#stopParallel'><p>Function to close cluster in BayesianSetup</p></a></li>
<li><a href='#sumSquare'><p>Helper function for sum of x*x</p></a></li>
<li><a href='#testDensityBanana'><p>Banana-shaped density function</p></a></li>
<li><a href='#testDensityGelmanMeng'><p>GelmanMeng test function</p></a></li>
<li><a href='#testDensityInfinity'><p>Test function infinity ragged</p></a></li>
<li><a href='#testDensityMultiNormal'><p>3d Mutivariate Normal likelihood</p></a></li>
<li><a href='#testDensityNormal'><p>Normal likelihood</p></a></li>
<li><a href='#testLinearModel'><p>Fake model, returns a ax + b linear response to 2-param vector</p></a></li>
<li><a href='#thinMatrix'><p>Function to thin matrices</p></a></li>
<li><a href='#tracePlot'><p>Trace plot for MCMC class</p></a></li>
<li><a href='#Twalk'><p>T-walk MCMC</p></a></li>
<li><a href='#TwalkMove'><p>Wrapper for step function</p></a></li>
<li><a href='#Twalksteps'><p>Main function that is executing and evaluating the moves</p></a></li>
<li><a href='#updateGroups'><p>Determine the groups of correlated parameters</p></a></li>
<li><a href='#updateProposalGenerator'><p>To update settings of an existing proposal genenerator</p></a></li>
<li><a href='#VSEM'><p>Very simple ecosystem model</p></a></li>
<li><a href='#vsemC'><p>C version of the VSEM model</p></a></li>
<li><a href='#VSEMcreateLikelihood'><p>Create an example dataset, and from that a likelihood or posterior for the VSEM model</p></a></li>
<li><a href='#VSEMcreatePAR'><p>Create a random radiation (PAR) time series</p></a></li>
<li><a href='#VSEMgetDefaults'><p>returns the default values for the VSEM</p></a></li>
<li><a href='#WAIC'><p>calculates the WAIC</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>General-Purpose MCMC and SMC Samplers and Tools for Bayesian
Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-30</td>
</tr>
<tr>
<td>Description:</td>
<td>General-purpose MCMC and SMC samplers, as well as plot and
    diagnostic functions for Bayesian statistics, with a particular focus on
    calibrating complex system models. Implemented samplers include various
    Metropolis MCMC variants (including adaptive and/or delayed rejection MH), the
    T-walk, two differential evolution MCMCs, two DREAM MCMCs, and a sequential
    Monte Carlo (SMC) particle filter.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, emulator, mvtnorm, tmvtnorm, IDPmisc, Rcpp (&ge; 0.12.12),
ellipse, numDeriv, msm, MASS, Matrix, stats, utils, graphics,
DHARMa, gap, bridgesampling</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DEoptim, lhs, sensitivity, knitr, rmarkdown, roxygen2,
testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/florianhartig/BayesianTools">https://github.com/florianhartig/BayesianTools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/florianhartig/BayesianTools/issues">https://github.com/florianhartig/BayesianTools/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-30 09:56:37 UTC; florian</td>
</tr>
<tr>
<td>Author:</td>
<td>Florian Hartig <a href="https://orcid.org/0000-0002-6255-9059"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Francesco Minunno [aut],
  Stefan Paul [aut],
  David Cameron [ctb],
  Tankred Ott [ctb],
  Maximilian Pichler [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Hartig &lt;florian.hartig@biologie.uni-regensburg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-30 19:40:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdaptpCR'>Adapts pCR values</h2><span id='topic+AdaptpCR'></span>

<h3>Description</h3>

<p>Adapts pCR values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdaptpCR(CR, delta, lCR, settings, Npop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdaptpCR_+3A_cr">CR</code></td>
<td>
<p>Vector of crossover probabilities. Needs to be of length nCR.</p>
</td></tr>
<tr><td><code id="AdaptpCR_+3A_delta">delta</code></td>
<td>
<p>vector with differences</p>
</td></tr>
<tr><td><code id="AdaptpCR_+3A_lcr">lCR</code></td>
<td>
<p>values to weight delta</p>
</td></tr>
<tr><td><code id="AdaptpCR_+3A_settings">settings</code></td>
<td>
<p>settings list</p>
</td></tr>
<tr><td><code id="AdaptpCR_+3A_npop">Npop</code></td>
<td>
<p>number of chains.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with CR values
</p>

<hr>
<h2 id='AM'>The Adaptive Metropolis Algorithm</h2><span id='topic+AM'></span>

<h3>Description</h3>

<p>The Adaptive Metropolis Algorithm (Haario et al. 2001)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AM(
  startValue = NULL,
  iterations = 10000,
  nBI = 0,
  parmin = NULL,
  parmax = NULL,
  FUN,
  f = 1,
  eps = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AM_+3A_startvalue">startValue</code></td>
<td>
<p>vector with the start values for the algorithm. Can be NULL if FUN is of class BayesianSetup. In this case startValues are sampled from the prior.</p>
</td></tr>
<tr><td><code id="AM_+3A_iterations">iterations</code></td>
<td>
<p>iterations to run</p>
</td></tr>
<tr><td><code id="AM_+3A_nbi">nBI</code></td>
<td>
<p>number of burnin</p>
</td></tr>
<tr><td><code id="AM_+3A_parmin">parmin</code></td>
<td>
<p>minimum values for the parameter vector or NULL if FUN is of class BayesianSetup</p>
</td></tr>
<tr><td><code id="AM_+3A_parmax">parmax</code></td>
<td>
<p>maximum values for the parameter vector or NULL if FUN is of class BayesianSetup</p>
</td></tr>
<tr><td><code id="AM_+3A_fun">FUN</code></td>
<td>
<p>function to be sampled from or object of class bayesianSetup</p>
</td></tr>
<tr><td><code id="AM_+3A_f">f</code></td>
<td>
<p>scaling factor</p>
</td></tr>
<tr><td><code id="AM_+3A_eps">eps</code></td>
<td>
<p>small number to avoid singularity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francesco Minunno
</p>


<h3>References</h3>

<p>Haario, Heikki, Eero Saksman, and Johanna Tamminen. &quot;An adaptive Metropolis algorithm.&quot; Bernoulli (2001): 223-242.
</p>

<hr>
<h2 id='applySettingsDefault'>Provides the default settings for the different samplers in runMCMC</h2><span id='topic+applySettingsDefault'></span>

<h3>Description</h3>

<p>Provides the default settings for the different samplers in runMCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applySettingsDefault(settings = NULL, sampler = "DEzs", check = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applySettingsDefault_+3A_settings">settings</code></td>
<td>
<p>optional list with parameters that will be used instead of the defaults</p>
</td></tr>
<tr><td><code id="applySettingsDefault_+3A_sampler">sampler</code></td>
<td>
<p>one of the samplers in <code><a href="#topic+runMCMC">runMCMC</a></code></p>
</td></tr>
<tr><td><code id="applySettingsDefault_+3A_check">check</code></td>
<td>
<p>logical determines whether parameters should be checked for consistency</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+runMCMC">runMCMC</a></code>
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='BayesianTools'>BayesianTools</h2><span id='topic+BayesianTools'></span>

<h3>Description</h3>

<p>A package with general-purpose MCMC and SMC samplers,  as well as plots and diagnostic functions for Bayesian statistics
</p>


<h3>Details</h3>

<p>A package with  general-purpose MCMC and SMC samplers, as well as plots and diagnostic functions for Bayesian statistics, particularly for process-based models.
</p>
<p>The package contains 2 central functions, <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code>, which creates a standardized Bayesian setup with likelihood and priors, and <code><a href="#topic+runMCMC">runMCMC</a></code>, which allows to run various MCMC and SMC samplers.
</p>
<p>The package can of course also be used for general (non-Bayesian) target functions.
</p>
<p>To use the package, a first step is to use <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code> to create a BayesianSetup, which usually contains prior and likelihood densities, or in general a target function.
</p>
<p>Those can be sampled with <code><a href="#topic+runMCMC">runMCMC</a></code>, which can call a number of general purpose Metropolis sampler, including the <code><a href="#topic+Metropolis">Metropolis</a></code> that allows to specify various popular Metropolis variants such as adaptive and/or delayed rejection Metropolis; two variants of differential evolution MCMC <code><a href="#topic+DE">DE</a></code>, <code><a href="#topic+DEzs">DEzs</a></code>, two variants of DREAM  <code><a href="#topic+DREAM">DREAM</a></code> and <code><a href="#topic+DREAMzs">DREAMzs</a></code>, the <code><a href="#topic+Twalk">Twalk</a></code> MCMC, and a Sequential Monte Carlo sampler <code><a href="#topic+smcSampler">smcSampler</a></code>.
</p>
<p>The output of runMCMC is of class mcmcSampler / smcSampler if one run is performed, or mcmcSamplerList / smcSamplerList if several sampler are run. Various functions are available for plotting, model comparison (DIC, marginal likelihood), or to use the output as a new prior.
</p>
<p>For details on how to use the packgage, run vignette(&quot;BayesianTools&quot;, package=&quot;BayesianTools&quot;).
</p>
<p>To get the suggested citation, run citation(&quot;BayesianTools&quot;)
</p>
<p>To report bugs or ask for help, post a <a href="https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example">reproducible example</a> via the BayesianTools <a href="https://github.com/florianhartig/BayesianTools/issues">issue tracker</a> on GitHub.
</p>
<p>Acknowledgements: The creation and maintenance of this package profited from funding and collaboration through Cost Action FP 1304 PROFOUND, DFG	DO 786/12-1 CONECT, EU FP7 ERA-NET Sumforest REFORCE and Bayklif Project BLIZ.
</p>

<hr>
<h2 id='betaFun'>Helper function for calculating beta</h2><span id='topic+betaFun'></span>

<h3>Description</h3>

<p>Helper function for calculating beta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaFun(at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaFun_+3A_at">at</code></td>
<td>
<p>&quot;traverse&quot; move proposal parameter.</p>
</td></tr>
</table>

<hr>
<h2 id='bridgesample'>Calculates the marginal likelihood of a chain via bridge sampling</h2><span id='topic+bridgesample'></span>

<h3>Description</h3>

<p>Calculates the marginal likelihood of a chain via bridge sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bridgesample(chain, nParams, lower = NULL, upper = NULL, posterior, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bridgesample_+3A_chain">chain</code></td>
<td>
<p>a single mcmc chain with samples as rows and parameters and posterior density as columns.</p>
</td></tr>
<tr><td><code id="bridgesample_+3A_nparams">nParams</code></td>
<td>
<p>number of parameters</p>
</td></tr>
<tr><td><code id="bridgesample_+3A_lower">lower</code></td>
<td>
<p>optional - lower bounds of the prior</p>
</td></tr>
<tr><td><code id="bridgesample_+3A_upper">upper</code></td>
<td>
<p>optional - upper bounds of the prior</p>
</td></tr>
<tr><td><code id="bridgesample_+3A_posterior">posterior</code></td>
<td>
<p>posterior density function</p>
</td></tr>
<tr><td><code id="bridgesample_+3A_...">...</code></td>
<td>
<p>arguments passed to bridge_sampler</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses &quot;bridge_sampler&quot; from the package &quot;bridgesampling&quot;.
</p>


<h3>Author(s)</h3>

<p>Tankred Ott
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginalLikelihood">marginalLikelihood</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>means &lt;- c(0, 1, 2)
sds &lt;- c(1, 0.6, 3)

# log-likelihood
ll &lt;- function (x) {
  return(sum(dnorm(x, mean = means, sd = sds, log = TRUE)))
}

# lower and upper bounds for prior
lb &lt;- rep(-10, 3)
ub &lt;- rep(10, 3)

# create setup and run MCMC
setup &lt;- createBayesianSetup(likelihood = ll,
                             lower = lb,
                             upper = ub)

out &lt;- runMCMC(bayesianSetup = setup,
               settings = list(iterations = 1000),
               sampler = "DEzs")

# sample from MCMC output with "burn-in" of 25%
sample &lt;- getSample(out$chain, start = 250, numSamples = 500)

# use bridge sampling to get marginal likelihood
bs_result &lt;- bridgesample(chain = sample,
                          nParams = out$setup$numPars,
                          lower = lb,
                          upper = ub,
                          posterior = out$setup$posterior$density)
bs_result
</code></pre>

<hr>
<h2 id='calibrationTest'>Simulation-based calibration tests</h2><span id='topic+calibrationTest'></span>

<h3>Description</h3>

<p>This function performs simulation-based calibration tests based on the idea that posteriors averaged over the prior should yield the prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibrationTest(posteriorList, priorDraws, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibrationTest_+3A_posteriorlist">posteriorList</code></td>
<td>
<p>a list with posterior samples. List items must be of a class that is supported by <code><a href="#topic+getSample">getSample</a></code>. This includes BayesianTools objects, but also matrix and data.frame</p>
</td></tr>
<tr><td><code id="calibrationTest_+3A_priordraws">priorDraws</code></td>
<td>
<p>a matrix with parameter values, drawn from the prior, that were used to simulate the data underlying the posteriorList. If colnames are provided, these will be used in the plots</p>
</td></tr>
<tr><td><code id="calibrationTest_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+getSample">getSample</a></code>. Consider in particular the thinning option.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to evaluate the results of a simulation-based calibration of an MCMC analysis.
</p>
<p>Briefly, the idea is to repeatedly
</p>

<ol>
<li><p> sample parameters from the prior,
</p>
</li>
<li><p> simulate new data based on these parameters,
</p>
</li>
<li><p> calculate the posterior for these data
</p>
</li></ol>

<p>If the sampler and the likelihood are implemented correctly, the average over all the posterior distribution should then again yield the prior (e.g. Cook et al., 2006).
</p>
<p>To test if this is the case, we implement the methods suggested by Talts et al., which is to calculate the rank statistics between the parameter draws and the posterior draws, which we then formally evaluate with a qq unif plot, and a ks.test
</p>
<p>I speculate that a ks.test between the two distribution would likely give an identical result, but this is not noted in Talts et al.
</p>
<p>Cook, S. R., Gelman, A. and Rubin, D. B. (2006). Validation of Software for Bayesian Models Using Posterior Quantiles. J. Comput. Graph. Stat. 15 675-692.
</p>
<p>Talts, Sean, Michael Betancourt, Daniel Simpson, Aki Vehtari, and Andrew Gelman. &quot;Validating Bayesian Inference Algorithms with Simulation-Based Calibration.&quot; arXiv preprint arXiv:1804.06788 (2018).
</p>


<h3>Note</h3>

<p>This function was implemented for the tests in Maliet, Odile, Florian Hartig, and Hélène Morlon. &quot;A model with many small shifts for estimating species-specific diversification rates.&quot; Nature ecology &amp; evolution 3.7 (2019): 1086-1092. The code linked with this paper provides a further example of its use.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='checkBayesianSetup'>Checks if an object is of class 'BayesianSetup'</h2><span id='topic+checkBayesianSetup'></span>

<h3>Description</h3>

<p>Function used to assure that an object is of class 'BayesianSetup'. If you pass a function, it is coverted to an object of class 'BayesianSetup' (using <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code>) before it is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkBayesianSetup(bayesianSetup, parallel = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkBayesianSetup_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>either object of class bayesianSetup or a log posterior function</p>
</td></tr>
<tr><td><code id="checkBayesianSetup_+3A_parallel">parallel</code></td>
<td>
<p>if bayesianSetup is a function, this will set the parallelization option for the class BayesianSetup that is created internally. If bayesianSetup is already a BayesianSetup, then this will check if parallel = T is requested but not supported by the BayesianSetup. This option is for internal use in the samplers</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The recommended option to use this function in the samplers is to have parallel with default NULL in the samplers, so that checkBayesianSetup with a function will create a bayesianSetup without parallelization, while it will do nothing with an existing BayesianSetup. If the user sets parallelization, it will set the approriate parallelization for a function, and check in case of an existing BayesianSetup. The checkBayesianSetup call in the samplers should then be followed by a check for parallel = NULL in sampler, in which case paralell can be set from the BayesianSetup
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code>
</p>

<hr>
<h2 id='combineChains'>Function to combine chains</h2><span id='topic+combineChains'></span>

<h3>Description</h3>

<p>Function to combine chains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combineChains(x, merge = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineChains_+3A_x">x</code></td>
<td>
<p>a list of MCMC chains</p>
</td></tr>
<tr><td><code id="combineChains_+3A_merge">merge</code></td>
<td>
<p>logical determines whether chains should be merged</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined chains
</p>


<h3>Note</h3>

<p>to combine several chains to a single McmcSamplerList, see <code><a href="#topic+createMcmcSamplerList">createMcmcSamplerList</a></code>
</p>

<hr>
<h2 id='convertCoda'>Convert coda::mcmc objects to BayesianTools::mcmcSampler</h2><span id='topic+convertCoda'></span>

<h3>Description</h3>

<p>Function is used to make the plot and diagnostic functions
available for coda::mcmc objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertCoda(sampler, names = NULL, info = NULL, likelihood = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertCoda_+3A_sampler">sampler</code></td>
<td>
<p>An object of class mcmc or mcmc.list</p>
</td></tr>
<tr><td><code id="convertCoda_+3A_names">names</code></td>
<td>
<p>vector giving the parameter names (optional)</p>
</td></tr>
<tr><td><code id="convertCoda_+3A_info">info</code></td>
<td>
<p>matrix (or list with matrices for mcmc.list objects) with three coloumns containing log posterior, log likelihood and log prior of the sampler for each time step (optional; but see Details)</p>
</td></tr>
<tr><td><code id="convertCoda_+3A_likelihood">likelihood</code></td>
<td>
<p>likelihood function used in the sampling (see Details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter 'likelihood' is optional for most functions but can be needed e.g for
using the <code><a href="#topic+DIC">DIC</a></code> function.
</p>
<p>Also the parameter info is optional for most uses. However for some functions (e.g. <code><a href="#topic+MAP">MAP</a></code>)
the matrix or single coloumns (e.g. log posterior) are necessary for the diagnostics.
</p>

<hr>
<h2 id='correctThin'>Checks if thin is consistent with nTotalSamples samples and if not corrects it.</h2><span id='topic+correctThin'></span>

<h3>Description</h3>

<p>Checks if thin is consistent with nTotalSamples samples and if not corrects it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctThin(nTotalSamples, thin, autoThinFraction = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctThin_+3A_ntotalsamples">nTotalSamples</code></td>
<td>
<p>total number of rows/samples</p>
</td></tr>
<tr><td><code id="correctThin_+3A_thin">thin</code></td>
<td>
<p>thinning</p>
</td></tr>
<tr><td><code id="correctThin_+3A_autothinfraction">autoThinFraction</code></td>
<td>
<p>fraction of the data that will be sampled when thin is set to &quot;auto&quot;. E.g. 0.5 means thin will be nTotalSamples * 0.5. The resulting thin value is rounded down to the next integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks if the thin argument is consistent with the data consisting of nTotalSamples samples/rows and corrects thin if not.
</p>


<h3>Author(s)</h3>

<p>Tankred Ott
</p>

<hr>
<h2 id='correlationPlot'>Flexible function to create correlation density plots</h2><span id='topic+correlationPlot'></span>

<h3>Description</h3>

<p>Flexible function to create correlation density plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlationPlot(
  mat,
  density = "smooth",
  thin = "auto",
  method = "pearson",
  whichParameters = NULL,
  scaleCorText = T,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlationPlot_+3A_mat">mat</code></td>
<td>
<p>object of class &quot;bayesianOutput&quot; or a matrix or data frame of variables</p>
</td></tr>
<tr><td><code id="correlationPlot_+3A_density">density</code></td>
<td>
<p>type of plot to do. Either &quot;smooth&quot; (default), &quot;corellipseCor&quot;, or &quot;ellipse&quot;</p>
</td></tr>
<tr><td><code id="correlationPlot_+3A_thin">thin</code></td>
<td>
<p>thinning of the matrix to make things faster. Default is to thin to 5000</p>
</td></tr>
<tr><td><code id="correlationPlot_+3A_method">method</code></td>
<td>
<p>method for calculating correlations. Possible choices are &quot;pearson&quot; (default), &quot;kendall&quot; and &quot;spearman&quot;</p>
</td></tr>
<tr><td><code id="correlationPlot_+3A_whichparameters">whichParameters</code></td>
<td>
<p>indices of parameters that should be plotted</p>
</td></tr>
<tr><td><code id="correlationPlot_+3A_scalecortext">scaleCorText</code></td>
<td>
<p>should the text to display correlation be scaled to the strength of the correlation</p>
</td></tr>
<tr><td><code id="correlationPlot_+3A_...">...</code></td>
<td>
<p>additional parameters to pass on to the <code><a href="#topic+getSample">getSample</a></code>, for example parametersOnly =F, or start = 1000</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>References</h3>

<p>The code for the correlation density plot originates from Hartig, F.; Dislich, C.; Wiegand, T. &amp; Huth, A. (2014) Technical Note: Approximate Bayesian parameterization of a process-based tropical forest model. Biogeosciences, 11, 1261-1272.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginalPlot">marginalPlot</a></code> <br />
<code><a href="#topic+plotTimeSeries">plotTimeSeries</a></code> <br />
<code><a href="#topic+tracePlot">tracePlot</a></code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a test likelihood function. 
ll &lt;- generateTestDensityMultiNormal(sigma = "no correlation")

## Create a BayesianSetup object from the likelihood 
## is the recommended way of using the runMCMC() function.
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, lower = rep(-10, 3), upper = rep(10, 3))

## Finally we can run the sampler and have a look
settings = list(iterations = 1000)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)

## Correlation density plots:
correlationPlot(out)

## additional parameters can be passed to getSample (see ?getSample for further information)
## e.g. to select which parameters to show or thinning (faster plot)
correlationPlot(out, scaleCorText = FALSE, thin = 100, start = 200, whichParameters = c(1,2))

## text to display correlation will be not scaled to the strength of the correlation
correlationPlot(out, scaleCorText = FALSE) 

## We can also switch the method for calculating correllations
correlationPlot(out, scaleCorText = FALSE, method = "spearman")


</code></pre>

<hr>
<h2 id='createBayesianSetup'>Creates a standardized collection of prior, likelihood and posterior functions, including error checks etc.</h2><span id='topic+createBayesianSetup'></span>

<h3>Description</h3>

<p>Creates a standardized collection of prior, likelihood and posterior functions, including error checks etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBayesianSetup(
  likelihood,
  prior = NULL,
  priorSampler = NULL,
  parallel = FALSE,
  lower = NULL,
  upper = NULL,
  best = NULL,
  names = NULL,
  parallelOptions = list(variables = "all", packages = "all", dlls = NULL),
  catchDuplicates = FALSE,
  plotLower = NULL,
  plotUpper = NULL,
  plotBest = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBayesianSetup_+3A_likelihood">likelihood</code></td>
<td>
<p>log likelihood density function</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_prior">prior</code></td>
<td>
<p>either a prior class (see <code><a href="#topic+createPrior">createPrior</a></code>) or a log prior density function</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_priorsampler">priorSampler</code></td>
<td>
<p>if a prior density (and not a prior class) is provided to prior, the optional prior sampling function can be provided here</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_parallel">parallel</code></td>
<td>
<p>parallelization option. Default is F. Other options include T, or &quot;external&quot;. See details.</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_lower">lower</code></td>
<td>
<p>vector with lower prior limits</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_upper">upper</code></td>
<td>
<p>vector with upper prior limits</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_best">best</code></td>
<td>
<p>vector with best prior values</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_names">names</code></td>
<td>
<p>optional vector with parameter names</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_paralleloptions">parallelOptions</code></td>
<td>
<p>list containing three lists. First &quot;packages&quot; determines the R packages necessary to run the likelihood function. Second &quot;variables&quot; the objects in the global environment needed to run the likelihood function and third &quot;dlls&quot; the DLLs needed to run the likelihood function (see Details and Examples).</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_catchduplicates">catchDuplicates</code></td>
<td>
<p>Logical, determines whether unique parameter combinations should only be evaluated once. Only used when the likelihood accepts a matrix with parameter as columns.</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_plotlower">plotLower</code></td>
<td>
<p>vector with lower limits for plotting</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_plotupper">plotUpper</code></td>
<td>
<p>vector with upper limits for plotting</p>
</td></tr>
<tr><td><code id="createBayesianSetup_+3A_plotbest">plotBest</code></td>
<td>
<p>vector with best values for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If prior is of class prior (e.g. create with <code><a href="#topic+createPrior">createPrior</a></code>), priorSampler, lower, upper and best will be ignored.<br /> If prior is a function (log prior density), priorSampler (custom sampler), or lower/upper (uniform sampler) is required.<br /> If prior is NULL, and lower and upper are passed, a uniform prior (see <code><a href="#topic+createUniformPrior">createUniformPrior</a></code>) will be created with boundaries lower and upper.
</p>
<p>For parallelization, Bayesiantools requies that the likelihood can evaluate several parameter vectors (supplied as a matrix) in parallel.
</p>

<ul>
<li><p> parallel = T means that an automatic parallelization of the likelihood via a standard R socket cluster is attempted, using the function <code><a href="#topic+generateParallelExecuter">generateParallelExecuter</a></code>. By default, of the N cores detected on the computer, N-1 cores are requested. Alternatively, you can provide a integer number to parallel, specifying the cores reserved for the cluster. When the cluster is cluster is created, a copy of your workspace, including DLLs and objects are exported to the cluster workers. Because this can be very inefficient, you can explicitly specify the packages, objects and DLLs that are to be exported via parallelOptions. Using parallel = T requires that the function to be parallelized is well encapsulate, i.e. can run on a shared memory / shared hard disk machine in parallel without interfering with each other.
</p>
</li></ul>

<p>If automatic parallelization cannot be done (e.g. because dlls are not thread-safe or write to shared disk), and only in this case, you should specify parallel = &quot;external&quot;. In this case, it is assumed that the likelihood is programmed such that it accepts a matrix with parameters as columns and the different model runs as rows. It is then up to the user if and how to parallelize this function. This option gives most flexibility to the user, in particular for complicated parallel architecture or shared memory problems.
</p>
<p>For more details on parallelization, make sure to read both vignettes, in particular the section on the likelihood in the main vignette, and the section on parallelization in the vignette on interfacing models.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig, Tankred Ott
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkBayesianSetup">checkBayesianSetup</a></code> <br />
<code><a href="#topic+createLikelihood">createLikelihood</a></code> <br />
<code><a href="#topic+createPrior">createPrior</a></code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ll &lt;- function(x) sum(dnorm(x, log = TRUE))

test &lt;- createBayesianSetup(ll, prior = NULL, priorSampler = NULL, lower = -10, upper = 10)
str(test)
test$prior$density(0)

test$likelihood$density(c(1,1))
test$likelihood$density(1)
test$posterior$density(1)
test$posterior$density(1, returnAll = TRUE)

test$likelihood$density(matrix(rep(1,4), nrow = 2))
#test$posterior$density(matrix(rep(1,4), nrow = 2), returnAll = TRUE)
test$likelihood$density(matrix(rep(1,4), nrow = 4))

## Not run: 

## Example of how to use parallelization using the VSEM model
# Note that the parallelization produces overhead and is not always
# speeding things up. In this example, due to the small
# computational cost of the VSEM the parallelization is
# most likely to reduce the speed of the sampler.

# Creating reference data
PAR &lt;- VSEMcreatePAR(1:1000)
refPars   &lt;- VSEMgetDefaults()
refPars[12,] &lt;- c(0.2, 0.001, 1)
rownames(refPars)[12] &lt;- "error-sd"

referenceData &lt;- VSEM(refPars$best[1:11], PAR) 
obs = apply(referenceData, 2, function(x) x + rnorm(length(x), 
                                                    sd = abs(x) * refPars$best[12]))

# Selecting parameters
parSel = c(1:6, 12)


## Builidng the likelihood function
likelihood &lt;- function(par, sum = TRUE){
  x = refPars$best
  x[parSel] = par
  predicted &lt;- VSEM(x[1:11], PAR)
  diff = c(predicted[,1:3] - obs[,1:3])
  llValues = dnorm(diff, sd = max(abs(c(predicted[,1:3])),0.0001) * x[12], log = TRUE) 
  if (sum == False) return(llValues)
  else return(sum(llValues))
}

# Prior
prior &lt;- createUniformPrior(lower = refPars$lower[parSel], upper = refPars$upper[parSel])

## Definition of the packages and objects that are exported to the cluster.
# These are the objects that are used in the likelihood function.
opts &lt;- list(packages = list("BayesianTools"), variables = list("refPars", "obs", "PAR" ), 
             dlls = NULL)

# Create Bayesian Setup
BSVSEM &lt;- createBayesianSetup(likelihood, prior, best = refPars$best[parSel], 
                              names = rownames(refPars)[parSel], parallel = 2,
                              parallelOptions = opts)

## The bayesianSetup can now be used in the runMCMC function.
# Note that not all samplers can make use of parallel
# computing.

# Remove the Bayesian Setup and close the cluster
stopParallel(BSVSEM)
rm(BSVSEM)


## End(Not run)
</code></pre>

<hr>
<h2 id='createBetaPrior'>Convenience function to create a beta prior</h2><span id='topic+createBetaPrior'></span>

<h3>Description</h3>

<p>Convenience function to create a beta prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBetaPrior(a, b, lower = 0, upper = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBetaPrior_+3A_a">a</code></td>
<td>
<p>shape1 of the beta distribution</p>
</td></tr>
<tr><td><code id="createBetaPrior_+3A_b">b</code></td>
<td>
<p>shape2 of the beta distribution</p>
</td></tr>
<tr><td><code id="createBetaPrior_+3A_lower">lower</code></td>
<td>
<p>lower values for the parameters</p>
</td></tr>
<tr><td><code id="createBetaPrior_+3A_upper">upper</code></td>
<td>
<p>upper values for the parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This creates a beta prior, assuming that lower / upper values for parameters are are fixed. The beta is the calculated relative to this lower / upper space.
</p>


<h3>Note</h3>

<p>for details see <code><a href="#topic+createPrior">createPrior</a></code>
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createPriorDensity">createPriorDensity</a></code> <br />
<code><a href="#topic+createPrior">createPrior</a></code> <br />
<code><a href="#topic+createTruncatedNormalPrior">createTruncatedNormalPrior</a></code> <br />
<code><a href="#topic+createUniformPrior">createUniformPrior</a></code> <br />
<code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the BT package includes a number of convenience functions to specify
# prior distributions, including createUniformPrior, createTruncatedNormalPrior
# etc. If you want to specify a prior that corresponds to one of these
# distributions, you should use these functions, e.g.:

prior &lt;- createUniformPrior(lower = c(0,0), upper = c(0.4,5))

prior$density(c(2, 3)) # outside of limits -&gt; -Inf
prior$density(c(0.2, 2)) # within limits, -0.6931472

# All default priors include a sampling function, i.e. you can create
# samples from the prior via
prior$sampler()
# [1] 0.2291413 4.5410389

# if you want to specify a prior that does not have a default function, 
# you should use the createPrior function, which expects a density and 
# optionally a sampler function:

density = function(par){
  d1 = dunif(par[1], -2,6, log =TRUE)
  d2 = dnorm(par[2], mean= 2, sd = 3, log =TRUE)
  return(d1 + d2)
}

sampler = function(n=1){
  d1 = runif(n, -2,6)
  d2 = rnorm(n, mean= 2, sd = 3)
  return(cbind(d1,d2))
}

prior &lt;- createPrior(density = density, sampler = sampler, 
                     lower = c(-10,-20), upper = c(10,20), best = NULL)

# note that the createPrior supports additional truncation


# To use a prior in an MCMC, include it in a BayesianSetup 

set.seed(123)
ll &lt;- function(x) sum(dnorm(x, log = TRUE)) # multivariate normal ll
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, prior = prior)

settings = list(iterations = 100)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, settings = settings)

# use createPriorDensity to create a new (estimated) prior from MCMC output

newPrior = createPriorDensity(out, method = "multivariate",
                              eps = 1e-10, lower = c(-10,-20), 
                              upper = c(10,20), best = NULL, scaling = 0.5)

</code></pre>

<hr>
<h2 id='createLikelihood'>Creates a standardized likelihood class#'</h2><span id='topic+createLikelihood'></span>

<h3>Description</h3>

<p>Creates a standardized likelihood class#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLikelihood(
  likelihood,
  names = NULL,
  parallel = F,
  catchDuplicates = T,
  sampler = NULL,
  parallelOptions = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createLikelihood_+3A_likelihood">likelihood</code></td>
<td>
<p>Log likelihood density</p>
</td></tr>
<tr><td><code id="createLikelihood_+3A_names">names</code></td>
<td>
<p>Parameter names (optional)</p>
</td></tr>
<tr><td><code id="createLikelihood_+3A_parallel">parallel</code></td>
<td>
<p>parallelization , either i) no parallelization &ndash;&gt; F, ii) native R parallelization &ndash;&gt; T / &quot;auto&quot; will select n-1 of your available cores, or provide a number for how many cores to use, or iii) external parallelization &ndash;&gt; &quot;external&quot;. External means that the likelihood is already able to execute parallel runs in form of a matrix with</p>
</td></tr>
<tr><td><code id="createLikelihood_+3A_catchduplicates">catchDuplicates</code></td>
<td>
<p>Logical, determines whether unique parameter combinations should only be evaluated once. Only used when the likelihood accepts a matrix with parameter as columns.</p>
</td></tr>
<tr><td><code id="createLikelihood_+3A_sampler">sampler</code></td>
<td>
<p>sampler</p>
</td></tr>
<tr><td><code id="createLikelihood_+3A_paralleloptions">parallelOptions</code></td>
<td>
<p>list containing two lists. First &quot;packages&quot; determines the R packages necessary to run the likelihood function. Second &quot;objects&quot; the objects in the global envirnment needed to run the likelihood function (for details see <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likelihoodIidNormal">likelihoodIidNormal</a></code> <br />
<code><a href="#topic+likelihoodAR1">likelihoodAR1</a></code> <br />
</p>

<hr>
<h2 id='createMcmcSamplerList'>Convenience function to create an object of class mcmcSamplerList from a list of mcmc samplers</h2><span id='topic+createMcmcSamplerList'></span>

<h3>Description</h3>

<p>Convenience function to create an object of class mcmcSamplerList from a list of mcmc samplers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMcmcSamplerList(mcmcList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createMcmcSamplerList_+3A_mcmclist">mcmcList</code></td>
<td>
<p>a list with each object being an mcmcSampler</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class &quot;mcmcSamplerList&quot;
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='createMixWithDefaults'>Allows to mix a given parameter vector with a default parameter vector</h2><span id='topic+createMixWithDefaults'></span>

<h3>Description</h3>

<p>This function is deprecated and will be removed by v0.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMixWithDefaults(pars, defaults, locations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createMixWithDefaults_+3A_pars">pars</code></td>
<td>
<p>vector with new parameter values</p>
</td></tr>
<tr><td><code id="createMixWithDefaults_+3A_defaults">defaults</code></td>
<td>
<p>vector with defaukt parameter values</p>
</td></tr>
<tr><td><code id="createMixWithDefaults_+3A_locations">locations</code></td>
<td>
<p>indices of the new parameter values</p>
</td></tr>
</table>

<hr>
<h2 id='createPosterior'>Creates a standardized posterior class</h2><span id='topic+createPosterior'></span>

<h3>Description</h3>

<p>Creates a standardized posterior class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createPosterior(prior, likelihood)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createPosterior_+3A_prior">prior</code></td>
<td>
<p>prior class</p>
</td></tr>
<tr><td><code id="createPosterior_+3A_likelihood">likelihood</code></td>
<td>
<p>Log likelihood density</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function is internally used in <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code> to create a standarized posterior class.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='createPrior'>Creates a standardized prior class</h2><span id='topic+createPrior'></span>

<h3>Description</h3>

<p>Creates a standardized prior class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createPrior(
  density = NULL,
  sampler = NULL,
  lower = NULL,
  upper = NULL,
  best = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createPrior_+3A_density">density</code></td>
<td>
<p>Prior density</p>
</td></tr>
<tr><td><code id="createPrior_+3A_sampler">sampler</code></td>
<td>
<p>Sampling function for density (optional)</p>
</td></tr>
<tr><td><code id="createPrior_+3A_lower">lower</code></td>
<td>
<p>vector with lower bounds of parameters</p>
</td></tr>
<tr><td><code id="createPrior_+3A_upper">upper</code></td>
<td>
<p>vector with upper bounds of parameter</p>
</td></tr>
<tr><td><code id="createPrior_+3A_best">best</code></td>
<td>
<p>vector with &quot;best&quot; parameter values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the general prior generator. It is highly recommended to not only implement the density, but also the sampler function. If this is not done, the user will have to provide explicit starting values for many of the MCMC samplers. Note the existing, more specialized prior function. If your prior can be created by those, they are preferred. Note also that priors can be created from an existing MCMC output from BT, or another MCMC sample, via <code><a href="#topic+createPriorDensity">createPriorDensity</a></code>.
</p>


<h3>Note</h3>

<p>min and max truncate, but not re-normalize the prior density (so, if a pdf that integrated to one is truncated, the integral will in general be smaller than one). For MCMC sampling, this doesn't make a difference, but if absolute values of the prior density are a concern, one should provide a truncated density function for the prior.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createPriorDensity">createPriorDensity</a></code> <br />
<code><a href="#topic+createBetaPrior">createBetaPrior</a></code> <br />
<code><a href="#topic+createUniformPrior">createUniformPrior</a></code> <br />
<code><a href="#topic+createTruncatedNormalPrior">createTruncatedNormalPrior</a></code><br />
<code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the BT package includes a number of convenience functions to specify
# prior distributions, including createUniformPrior, createTruncatedNormalPrior
# etc. If you want to specify a prior that corresponds to one of these
# distributions, you should use these functions, e.g.:

prior &lt;- createUniformPrior(lower = c(0,0), upper = c(0.4,5))

prior$density(c(2, 3)) # outside of limits -&gt; -Inf
prior$density(c(0.2, 2)) # within limits, -0.6931472

# All default priors include a sampling function, i.e. you can create
# samples from the prior via
prior$sampler()
# [1] 0.2291413 4.5410389

# if you want to specify a prior that does not have a default function, 
# you should use the createPrior function, which expects a density and 
# optionally a sampler function:

density = function(par){
  d1 = dunif(par[1], -2,6, log =TRUE)
  d2 = dnorm(par[2], mean= 2, sd = 3, log =TRUE)
  return(d1 + d2)
}

sampler = function(n=1){
  d1 = runif(n, -2,6)
  d2 = rnorm(n, mean= 2, sd = 3)
  return(cbind(d1,d2))
}

prior &lt;- createPrior(density = density, sampler = sampler, 
                     lower = c(-10,-20), upper = c(10,20), best = NULL)

# note that the createPrior supports additional truncation


# To use a prior in an MCMC, include it in a BayesianSetup 

set.seed(123)
ll &lt;- function(x) sum(dnorm(x, log = TRUE)) # multivariate normal ll
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, prior = prior)

settings = list(iterations = 100)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, settings = settings)

# use createPriorDensity to create a new (estimated) prior from MCMC output

newPrior = createPriorDensity(out, method = "multivariate",
                              eps = 1e-10, lower = c(-10,-20), 
                              upper = c(10,20), best = NULL, scaling = 0.5)

</code></pre>

<hr>
<h2 id='createPriorDensity'>Fits a density function to a multivariate sample</h2><span id='topic+createPriorDensity'></span>

<h3>Description</h3>

<p>Fits a density function to a multivariate sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createPriorDensity(
  sampler,
  method = "multivariate",
  eps = 1e-10,
  lower = NULL,
  upper = NULL,
  best = NULL,
  scaling = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createPriorDensity_+3A_sampler">sampler</code></td>
<td>
<p>an object of class BayesianOutput or a matrix</p>
</td></tr>
<tr><td><code id="createPriorDensity_+3A_method">method</code></td>
<td>
<p>method to generate prior - default and currently only option is multivariate</p>
</td></tr>
<tr><td><code id="createPriorDensity_+3A_eps">eps</code></td>
<td>
<p>numerical precision to avoid singularity</p>
</td></tr>
<tr><td><code id="createPriorDensity_+3A_lower">lower</code></td>
<td>
<p>vector with lower bounds of parameter for the new prior, independent of the input sample</p>
</td></tr>
<tr><td><code id="createPriorDensity_+3A_upper">upper</code></td>
<td>
<p>vector with upper bounds of parameter for the new prior, independent of the input sample</p>
</td></tr>
<tr><td><code id="createPriorDensity_+3A_best">best</code></td>
<td>
<p>vector with &quot;best&quot; values of parameter for the new prior, independent of the input sample</p>
</td></tr>
<tr><td><code id="createPriorDensity_+3A_scaling">scaling</code></td>
<td>
<p>optional scaling factor for the covariance. If scaling &gt; 1 will create a prior wider than the posterior, &lt; 1 a prior more narrow than the posterior. Scaling is linear to the posterior width, i.e. scaling = 2 will create a prior that with 2x the sd of the original posterior.</p>
</td></tr>
<tr><td><code id="createPriorDensity_+3A_...">...</code></td>
<td>
<p>parameters to pass on to the getSample function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a density estimator to a multivariate (typically a posterior) sample. The main purpose is to summarize a posterior sample as a pdf, in order to include it as a prior in a new analysis, for example when new data becomes available, or to calculate a fractional Bayes factor (see <code><a href="#topic+marginalLikelihood">marginalLikelihood</a></code>).
</p>
<p>The limitation of this function is that we currently only implement a multivariate normal density estimator, so you will have a loss of information if your posterior is not approximately multivariate normal, which is likely the case if you have weak data. Extending the function to include more flexible density estimators (e.g. gaussian processes) is on our todo list, but it's quite tricky to get this stable, so I'm not sure when we will have this working. In general, creating reliable empirical density estimates in high-dimensional parameter spaces is extremely tricky, regardless of the software you are using.
</p>
<p>For that reason, it is usually recommended to not update the posterior with this option, but rather:
</p>

<ol>
<li><p> If the full dataset is available, to make a single, or infrequent updates, recompute the entire model with the full / updated data
</p>
</li>
<li><p> For frequent updates, consider using SMC instead of MCMC sampling. SMC sampling doesn't require an analytical summary of the posterior.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createPrior">createPrior</a></code> <br />
<code><a href="#topic+createBetaPrior">createBetaPrior</a></code> <br />
<code><a href="#topic+createTruncatedNormalPrior">createTruncatedNormalPrior</a></code> <br />
<code><a href="#topic+createUniformPrior">createUniformPrior</a></code> <br />
<code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the BT package includes a number of convenience functions to specify
# prior distributions, including createUniformPrior, createTruncatedNormalPrior
# etc. If you want to specify a prior that corresponds to one of these
# distributions, you should use these functions, e.g.:

prior &lt;- createUniformPrior(lower = c(0,0), upper = c(0.4,5))

prior$density(c(2, 3)) # outside of limits -&gt; -Inf
prior$density(c(0.2, 2)) # within limits, -0.6931472

# All default priors include a sampling function, i.e. you can create
# samples from the prior via
prior$sampler()
# [1] 0.2291413 4.5410389

# if you want to specify a prior that does not have a default function, 
# you should use the createPrior function, which expects a density and 
# optionally a sampler function:

density = function(par){
  d1 = dunif(par[1], -2,6, log =TRUE)
  d2 = dnorm(par[2], mean= 2, sd = 3, log =TRUE)
  return(d1 + d2)
}

sampler = function(n=1){
  d1 = runif(n, -2,6)
  d2 = rnorm(n, mean= 2, sd = 3)
  return(cbind(d1,d2))
}

prior &lt;- createPrior(density = density, sampler = sampler, 
                     lower = c(-10,-20), upper = c(10,20), best = NULL)

# note that the createPrior supports additional truncation


# To use a prior in an MCMC, include it in a BayesianSetup 

set.seed(123)
ll &lt;- function(x) sum(dnorm(x, log = TRUE)) # multivariate normal ll
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, prior = prior)

settings = list(iterations = 100)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, settings = settings)

# use createPriorDensity to create a new (estimated) prior from MCMC output

newPrior = createPriorDensity(out, method = "multivariate",
                              eps = 1e-10, lower = c(-10,-20), 
                              upper = c(10,20), best = NULL, scaling = 0.5)

</code></pre>

<hr>
<h2 id='createProposalGenerator'>Factory that creates a proposal generator</h2><span id='topic+createProposalGenerator'></span>

<h3>Description</h3>

<p>Factory that creates a proposal generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createProposalGenerator(
  covariance,
  gibbsProbabilities = NULL,
  gibbsWeights = NULL,
  otherDistribution = NULL,
  otherDistributionLocation = NULL,
  otherDistributionScaled = F,
  message = F,
  method = "chol",
  scalingFactor = 2.38
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createProposalGenerator_+3A_covariance">covariance</code></td>
<td>
<p>covariance matrix. Can also be vector of the sqrt of diagonal elements &ndash;&gt; standard deviation</p>
</td></tr>
<tr><td><code id="createProposalGenerator_+3A_gibbsprobabilities">gibbsProbabilities</code></td>
<td>
<p>optional probabilities for the number of parameters to vary in a Metropolis within gibbs style - for 4 parameters, c(1,1,0.5,0) means that at most 3 parameters will be varied, and it is double as likely to vary one or two than varying 3</p>
</td></tr>
<tr><td><code id="createProposalGenerator_+3A_gibbsweights">gibbsWeights</code></td>
<td>
<p>optional probabilities for parameters to be varied in a Metropolis within gibbs style - default ist equal weight for all parameters - for 4 parameters, c(1,1,1,100) would mean that if 2 parameters would be selected, parameter 4 would be 100 times more likely to be picked than the others. If 4 is selected, the remaining parameters have equal probability.</p>
</td></tr>
<tr><td><code id="createProposalGenerator_+3A_otherdistribution">otherDistribution</code></td>
<td>
<p>optional additinal distribution to be mixed with the default multivariate normal. The distribution needs to accept a parameter vector (to allow for the option of making the distribution dependend on the parameter values), but it is still assumed that the change from the current values is returned, not the new absolute values.</p>
</td></tr>
<tr><td><code id="createProposalGenerator_+3A_otherdistributionlocation">otherDistributionLocation</code></td>
<td>
<p>a vector with 0 and 1, denoting which parameters are modified by the otherDistribution</p>
</td></tr>
<tr><td><code id="createProposalGenerator_+3A_otherdistributionscaled">otherDistributionScaled</code></td>
<td>
<p>should the other distribution be scaled if gibbs updates are calculated?</p>
</td></tr>
<tr><td><code id="createProposalGenerator_+3A_message">message</code></td>
<td>
<p>print out parameter settings</p>
</td></tr>
<tr><td><code id="createProposalGenerator_+3A_method">method</code></td>
<td>
<p>method for covariance decomposition</p>
</td></tr>
<tr><td><code id="createProposalGenerator_+3A_scalingfactor">scalingFactor</code></td>
<td>
<p>scaling factor for the proposals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+updateProposalGenerator">updateProposalGenerator</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testMatrix = matrix(rep(c(0,0,0,0), 1000), ncol = 4)
testVector = c(0,0,0,0)


##Standard multivariate normal proposal generator

testGenerator &lt;- createProposalGenerator(covariance = c(1,1,1,1), message = TRUE)

methods(class = "proposalGenerator")
print(testGenerator)

x = testGenerator$returnProposal(testVector)
x

x &lt;- testGenerator$returnProposalMatrix(testMatrix)
boxplot(x)

##Changing the covariance
testGenerator$covariance = diag(rep(100,4))
testGenerator &lt;- testGenerator$updateProposalGenerator(testGenerator, message = TRUE)

testGenerator$returnProposal(testVector)
x &lt;- testGenerator$returnProposalMatrix(testMatrix)
boxplot(x)


##-Changing the gibbs probabilities / probability to modify 1-n parameters

testGenerator$gibbsProbabilities = c(1,1,0,0)
testGenerator &lt;- testGenerator$updateProposalGenerator(testGenerator)

testGenerator$returnProposal(testVector)
x &lt;- testGenerator$returnProposalMatrix(testMatrix)
boxplot(x)


##-Changing the gibbs weights / probability to pick each parameter

testGenerator$gibbsWeights = c(0.3,0.3,0.3,100)
testGenerator &lt;- testGenerator$updateProposalGenerator(testGenerator)

testGenerator$returnProposal(testVector)
x &lt;- testGenerator$returnProposalMatrix(testMatrix)
boxplot(x)


##-Adding another function

otherFunction &lt;- function(x) sample.int(10,1)

testGenerator &lt;- createProposalGenerator(
  covariance = c(1,1,1), 
  otherDistribution = otherFunction, 
  otherDistributionLocation = c(0,0,0,1),
  otherDistributionScaled = TRUE
)

testGenerator$returnProposal(testVector)
x &lt;- testGenerator$returnProposalMatrix(testMatrix)
boxplot(x)
table(x[,4])
</code></pre>

<hr>
<h2 id='createSmcSamplerList'>Convenience function to create an object of class SMCSamplerList from a list of mcmc samplers</h2><span id='topic+createSmcSamplerList'></span>

<h3>Description</h3>

<p>Convenience function to create an object of class SMCSamplerList from a list of mcmc samplers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSmcSamplerList(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSmcSamplerList_+3A_...">...</code></td>
<td>
<p>a list of MCMC samplers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class smcSamplerList with each object being an smcSampler
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='createTruncatedNormalPrior'>Convenience function to create a truncated normal prior</h2><span id='topic+createTruncatedNormalPrior'></span>

<h3>Description</h3>

<p>Convenience function to create a truncated normal prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTruncatedNormalPrior(mean, sd, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTruncatedNormalPrior_+3A_mean">mean</code></td>
<td>
<p>best estimate for each parameter</p>
</td></tr>
<tr><td><code id="createTruncatedNormalPrior_+3A_sd">sd</code></td>
<td>
<p>sdandard deviation</p>
</td></tr>
<tr><td><code id="createTruncatedNormalPrior_+3A_lower">lower</code></td>
<td>
<p>vector of lower prior range for all parameters</p>
</td></tr>
<tr><td><code id="createTruncatedNormalPrior_+3A_upper">upper</code></td>
<td>
<p>vector of upper prior range for all parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>for details see <code><a href="#topic+createPrior">createPrior</a></code>
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createPriorDensity">createPriorDensity</a></code> <br />
<code><a href="#topic+createPrior">createPrior</a></code> <br />
<code><a href="#topic+createBetaPrior">createBetaPrior</a></code> <br />
<code><a href="#topic+createUniformPrior">createUniformPrior</a></code> <br />
<code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the BT package includes a number of convenience functions to specify
# prior distributions, including createUniformPrior, createTruncatedNormalPrior
# etc. If you want to specify a prior that corresponds to one of these
# distributions, you should use these functions, e.g.:

prior &lt;- createUniformPrior(lower = c(0,0), upper = c(0.4,5))

prior$density(c(2, 3)) # outside of limits -&gt; -Inf
prior$density(c(0.2, 2)) # within limits, -0.6931472

# All default priors include a sampling function, i.e. you can create
# samples from the prior via
prior$sampler()
# [1] 0.2291413 4.5410389

# if you want to specify a prior that does not have a default function, 
# you should use the createPrior function, which expects a density and 
# optionally a sampler function:

density = function(par){
  d1 = dunif(par[1], -2,6, log =TRUE)
  d2 = dnorm(par[2], mean= 2, sd = 3, log =TRUE)
  return(d1 + d2)
}

sampler = function(n=1){
  d1 = runif(n, -2,6)
  d2 = rnorm(n, mean= 2, sd = 3)
  return(cbind(d1,d2))
}

prior &lt;- createPrior(density = density, sampler = sampler, 
                     lower = c(-10,-20), upper = c(10,20), best = NULL)

# note that the createPrior supports additional truncation


# To use a prior in an MCMC, include it in a BayesianSetup 

set.seed(123)
ll &lt;- function(x) sum(dnorm(x, log = TRUE)) # multivariate normal ll
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, prior = prior)

settings = list(iterations = 100)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, settings = settings)

# use createPriorDensity to create a new (estimated) prior from MCMC output

newPrior = createPriorDensity(out, method = "multivariate",
                              eps = 1e-10, lower = c(-10,-20), 
                              upper = c(10,20), best = NULL, scaling = 0.5)

</code></pre>

<hr>
<h2 id='createUniformPrior'>Convenience function to create a simple uniform prior distribution</h2><span id='topic+createUniformPrior'></span>

<h3>Description</h3>

<p>Convenience function to create a simple uniform prior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createUniformPrior(lower, upper, best = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createUniformPrior_+3A_lower">lower</code></td>
<td>
<p>vector of lower prior range for all parameters</p>
</td></tr>
<tr><td><code id="createUniformPrior_+3A_upper">upper</code></td>
<td>
<p>vector of upper prior range for all parameters</p>
</td></tr>
<tr><td><code id="createUniformPrior_+3A_best">best</code></td>
<td>
<p>vector with &quot;best&quot; values for all parameters</p>
</td></tr>
</table>


<h3>Note</h3>

<p>for details see <code><a href="#topic+createPrior">createPrior</a></code>
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createPriorDensity">createPriorDensity</a></code>, <code><a href="#topic+createPrior">createPrior</a></code>, <code><a href="#topic+createBetaPrior">createBetaPrior</a></code>, <code><a href="#topic+createTruncatedNormalPrior">createTruncatedNormalPrior</a></code>, <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the BT package includes a number of convenience functions to specify
# prior distributions, including createUniformPrior, createTruncatedNormalPrior
# etc. If you want to specify a prior that corresponds to one of these
# distributions, you should use these functions, e.g.:

prior &lt;- createUniformPrior(lower = c(0,0), upper = c(0.4,5))

prior$density(c(2, 3)) # outside of limits -&gt; -Inf
prior$density(c(0.2, 2)) # within limits, -0.6931472

# All default priors include a sampling function, i.e. you can create
# samples from the prior via
prior$sampler()
# [1] 0.2291413 4.5410389

# if you want to specify a prior that does not have a default function, 
# you should use the createPrior function, which expects a density and 
# optionally a sampler function:

density = function(par){
  d1 = dunif(par[1], -2,6, log =TRUE)
  d2 = dnorm(par[2], mean= 2, sd = 3, log =TRUE)
  return(d1 + d2)
}

sampler = function(n=1){
  d1 = runif(n, -2,6)
  d2 = rnorm(n, mean= 2, sd = 3)
  return(cbind(d1,d2))
}

prior &lt;- createPrior(density = density, sampler = sampler, 
                     lower = c(-10,-20), upper = c(10,20), best = NULL)

# note that the createPrior supports additional truncation


# To use a prior in an MCMC, include it in a BayesianSetup 

set.seed(123)
ll &lt;- function(x) sum(dnorm(x, log = TRUE)) # multivariate normal ll
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, prior = prior)

settings = list(iterations = 100)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, settings = settings)

# use createPriorDensity to create a new (estimated) prior from MCMC output

newPrior = createPriorDensity(out, method = "multivariate",
                              eps = 1e-10, lower = c(-10,-20), 
                              upper = c(10,20), best = NULL, scaling = 0.5)

</code></pre>

<hr>
<h2 id='DE'>Differential-Evolution MCMC</h2><span id='topic+DE'></span>

<h3>Description</h3>

<p>Differential-Evolution MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DE(
  bayesianSetup,
  settings = list(startValue = NULL, iterations = 10000, f = -2.38, burnin = 0, thin = 1,
    eps = 0, consoleUpdates = 100, blockUpdate = list("none", k = NULL, h = NULL, pSel =
    NULL, pGroup = NULL, groupStart = 1000, groupIntervall = 1000), currentChain = 1,
    message = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DE_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>a BayesianSetup with the posterior density function to be sampled from</p>
</td></tr>
<tr><td><code id="DE_+3A_settings">settings</code></td>
<td>
<p>list with parameter settings</p>
</td></tr>
<tr><td><code id="DE_+3A_startvalue">startValue</code></td>
<td>
<p>(optional) eiter a matrix with start population, a number to define the number of chains that are run or a function that samples a starting population.</p>
</td></tr>
<tr><td><code id="DE_+3A_iterations">iterations</code></td>
<td>
<p>number of function evaluations.</p>
</td></tr>
<tr><td><code id="DE_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations treated as burn-in. These iterations are not recorded in the chain.</p>
</td></tr>
<tr><td><code id="DE_+3A_thin">thin</code></td>
<td>
<p>thinning parameter. Determines the interval in which values are recorded.</p>
</td></tr>
<tr><td><code id="DE_+3A_f">f</code></td>
<td>
<p>scaling factor gamma</p>
</td></tr>
<tr><td><code id="DE_+3A_eps">eps</code></td>
<td>
<p>small number to avoid singularity</p>
</td></tr>
<tr><td><code id="DE_+3A_blockupdate">blockUpdate</code></td>
<td>
<p>list determining whether parameters should be updated in blocks. For possible settings see Details.</p>
</td></tr>
<tr><td><code id="DE_+3A_message">message</code></td>
<td>
<p>logical determines whether the sampler's progress should be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For blockUpdate the first element in the list determines the type of blocking.
Possible choices are
</p>

<ul>
<li><p>&quot;none&quot; (default), no blocking of parameters
</p>
</li>
<li><p>&quot;correlation&quot;  blocking based on correlation of parameters. Using h or k (see below)
</p>
</li>
<li><p>&quot;random&quot;  random blocking. Using k (see below)
</p>
</li>
<li><p>&quot;user&quot;  user defined groups. Using groups (see below)
</p>
</li></ul>

<p>Further seven parameters can be specified. &quot;k&quot; determnined the number of groups, &quot;h&quot; the strength
of the correlation used to group parameter and &quot;groups&quot; is used for user defined groups.
&quot;groups&quot; is a vector containing the group number for each parameter. E.g. for three parameters
with the first two in one group, &quot;groups&quot; would be c(1,1,2).
Further pSel and pGroup can be used to influence the choice of groups. In the sampling process
a number of groups is randomly drawn and updated. pSel is a vector containing relative probabilities
for an update of the respective number of groups. E.g. for always updating only one group pSel = 1.
For updating one or two groups with the same probability pSel = c(1,1). By default all numbers
have the same probability.
The same principle is used in pGroup. Here the user can influence the probability of each group
to be updated. By default all groups have the same probability.
Finally &quot;groupStart&quot; defines the starting point of the groupUpdate and &quot;groupIntervall&quot; the intervall
in which the groups are evaluated.
</p>


<h3>Author(s)</h3>

<p>Francesco Minunno and Stefan Paul
</p>


<h3>References</h3>

<p>Braak, Cajo JF Ter. &quot;A Markov Chain Monte Carlo version of the genetic algorithm Differential Evolution: easy Bayesian computing for real parameter spaces.&quot; Statistics and Computing 16.3 (2006): 239-249.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DEzs">DEzs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesianTools)

ll &lt;- generateTestDensityMultiNormal(sigma = "no correlation")
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, 
                                     lower = rep(-10, 3), 
                                     upper = rep(10, 3))

settings = list(iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# DE family samplers are population MCMCs that run a number of internal chains
# in parallel. Here examples how to change the internal chains
# note that internal chains can be executedi n parallel
settings = list(startValue = 4, iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# Modify the start values of the internal chains (note that this is a matrix
# of dim nChain * nPar)
settings = list(startValue = matrix(rnorm(12), nrow = 4, ncol = 3), 
                iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# In the DE sampler family with Z matrix, the previous chains are written in 
# a common matrix, from which proposals are generated. Per default this matrix
# is started with samples from the prior, but we can change this. Often useful
# to improve sampler convergence, 
# see  https://github.com/florianhartig/BayesianTools/issues/79
settings = list(startValue = matrix(rnorm(12), nrow = 4, ncol = 3),
                Z = matrix(rnorm(300), nrow = 100, ncol = 3),
                iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)


</code></pre>

<hr>
<h2 id='DEzs'>Differential-Evolution MCMC zs</h2><span id='topic+DEzs'></span>

<h3>Description</h3>

<p>Differential-Evolution MCMC zs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEzs(
  bayesianSetup,
  settings = list(iterations = 10000, Z = NULL, startValue = NULL, pSnooker = 0.1, burnin
    = 0, thin = 1, f = 2.38, eps = 0, parallel = NULL, pGamma1 = 0.1, eps.mult = 0.2,
    eps.add = 0, consoleUpdates = 100, zUpdateFrequency = 1, currentChain = 1,
    blockUpdate = list("none", k = NULL, h = NULL, pSel = NULL, pGroup = NULL, groupStart
    = 1000, groupIntervall = 1000), message = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEzs_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>a BayesianSetup with the posterior density function to be sampled from</p>
</td></tr>
<tr><td><code id="DEzs_+3A_settings">settings</code></td>
<td>
<p>list with parameter settings</p>
</td></tr>
<tr><td><code id="DEzs_+3A_startvalue">startValue</code></td>
<td>
<p>(optional) eiter a matrix with start population, a number to define the number of chains that are run or a function that samples a starting population.</p>
</td></tr>
<tr><td><code id="DEzs_+3A_z">Z</code></td>
<td>
<p>starting Z population</p>
</td></tr>
<tr><td><code id="DEzs_+3A_iterations">iterations</code></td>
<td>
<p>iterations to run</p>
</td></tr>
<tr><td><code id="DEzs_+3A_psnooker">pSnooker</code></td>
<td>
<p>probability of Snooker update</p>
</td></tr>
<tr><td><code id="DEzs_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations treated as burn-in. These iterations are not recorded in the chain.</p>
</td></tr>
<tr><td><code id="DEzs_+3A_thin">thin</code></td>
<td>
<p>thinning parameter. Determines the interval in which values are recorded.</p>
</td></tr>
<tr><td><code id="DEzs_+3A_eps">eps</code></td>
<td>
<p>small number to avoid singularity</p>
</td></tr>
<tr><td><code id="DEzs_+3A_f">f</code></td>
<td>
<p>scaling factor for gamma</p>
</td></tr>
<tr><td><code id="DEzs_+3A_parallel">parallel</code></td>
<td>
<p>logical, determines weather parallel computing should be attempted (see details)</p>
</td></tr>
<tr><td><code id="DEzs_+3A_pgamma1">pGamma1</code></td>
<td>
<p>probability determining the frequency with which the scaling is set to 1 (allows jumps between modes)</p>
</td></tr>
<tr><td><code id="DEzs_+3A_eps.mult">eps.mult</code></td>
<td>
<p>random term (multiplicative error)</p>
</td></tr>
<tr><td><code id="DEzs_+3A_eps.add">eps.add</code></td>
<td>
<p>random term</p>
</td></tr>
<tr><td><code id="DEzs_+3A_blockupdate">blockUpdate</code></td>
<td>
<p>list determining whether parameters should be updated in blocks. For possible settings see Details.</p>
</td></tr>
<tr><td><code id="DEzs_+3A_message">message</code></td>
<td>
<p>logical determines whether the sampler's progress should be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For parallel computing, the likelihood density in the bayesianSetup needs to be parallelized, i.e. needs to be able to operate on a matrix of proposals
</p>
<p>For blockUpdate the first element in the list determines the type of blocking.
Possible choices are
</p>

<ul>
<li><p>&quot;none&quot; (default), no blocking of parameters
</p>
</li>
<li><p>&quot;correlation&quot;  blocking based on correlation of parameters. Using h or k (see below)
</p>
</li>
<li><p>&quot;random&quot;  random blocking. Using k (see below)
</p>
</li>
<li><p>&quot;user&quot;  user defined groups. Using groups (see below)
</p>
</li></ul>

<p>Further seven parameters can be specified. &quot;k&quot; determnined the number of groups, &quot;h&quot; the strength
of the correlation used to group parameter and &quot;groups&quot; is used for user defined groups.
&quot;groups&quot; is a vector containing the group number for each parameter. E.g. for three parameters
with the first two in one group, &quot;groups&quot; would be c(1,1,2).
Further pSel and pGroup can be used to influence the choice of groups. In the sampling process
a number of groups is randomly drawn and updated. pSel is a vector containing relative probabilities
for an update of the respective number of groups. E.g. for always updating only one group pSel = 1.
For updating one or two groups with the same probability pSel = c(1,1). By default all numbers
have the same probability.
The same principle is used in pGroup. Here the user can influence the probability of each group
to be updated. By default all groups have the same probability.
Finally &quot;groupStart&quot; defines the starting point of the groupUpdate and &quot;groupIntervall&quot; the intervall
in which the groups are evaluated.
</p>


<h3>Author(s)</h3>

<p>Francesco Minunno and Stefan Paul
</p>


<h3>References</h3>

<p>ter  Braak C. J. F., and Vrugt J. A. (2008). Differential Evolution Markov Chain with snooker updater and fewer chains. Statistics and Computing http://dx.doi.org/10.1007/s11222-008-9104-9
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DE">DE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesianTools)

ll &lt;- generateTestDensityMultiNormal(sigma = "no correlation")
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, 
                                     lower = rep(-10, 3), 
                                     upper = rep(10, 3))

settings = list(iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# DE family samplers are population MCMCs that run a number of internal chains
# in parallel. Here examples how to change the internal chains
# note that internal chains can be executedi n parallel
settings = list(startValue = 4, iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# Modify the start values of the internal chains (note that this is a matrix
# of dim nChain * nPar)
settings = list(startValue = matrix(rnorm(12), nrow = 4, ncol = 3), 
                iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# In the DE sampler family with Z matrix, the previous chains are written in 
# a common matrix, from which proposals are generated. Per default this matrix
# is started with samples from the prior, but we can change this. Often useful
# to improve sampler convergence, 
# see  https://github.com/florianhartig/BayesianTools/issues/79
settings = list(startValue = matrix(rnorm(12), nrow = 4, ncol = 3),
                Z = matrix(rnorm(300), nrow = 100, ncol = 3),
                iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)


</code></pre>

<hr>
<h2 id='DIC'>Deviance information criterion</h2><span id='topic+DIC'></span>

<h3>Description</h3>

<p>Deviance information criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(sampler, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_sampler">sampler</code></td>
<td>
<p>An object of class bayesianOutput (mcmcSampler, smcSampler, or mcmcList)</p>
</td></tr>
<tr><td><code id="DIC_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+getSample">getSample</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output:
list with the following elements: <br />
DIC   : Deviance Information Criterion <br />
IC    : Bayesian Predictive Information Criterion <br />
pD    : Effective number of parameters (pD = Dbar - Dhat) <br />
pV    : Effective number of parameters (pV = var(D)/2) <br />
Dbar  : Expected value of the deviance over the posterior <br />
Dhat  : Deviance at the mean posterior estimate <br />
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>References</h3>

<p>Spiegelhalter, D. J.; Best, N. G.; Carlin, B. P. &amp; van der Linde, A. (2002) Bayesian measures of model complexity and fit. J. Roy. Stat. Soc. B, 64, 583-639.<br /><br />
Gelman, A.; Hwang, J. &amp; Vehtari, A. (2014) Understanding predictive information criteria for Bayesian models. Statistics and Computing, Springer US, 24, 997-1016-.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WAIC">WAIC</a></code>, <code><a href="#topic+MAP">MAP</a></code>, <code><a href="#topic+marginalLikelihood">marginalLikelihood</a></code>
</p>

<hr>
<h2 id='DR'>The Delayed Rejection Algorithm</h2><span id='topic+DR'></span>

<h3>Description</h3>

<p>The Delayed Rejection Algorithm (Tierney and Mira, 1999)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DR(
  startValue = NULL,
  iterations = 10000,
  nBI = 0,
  parmin = NULL,
  parmax = NULL,
  f1 = 1,
  f2 = 0.5,
  FUN
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DR_+3A_startvalue">startValue</code></td>
<td>
<p>vector with the start values for the algorithm. Can be NULL if FUN is of class BayesianSetup. In this case startValues are sampled from the prior.</p>
</td></tr>
<tr><td><code id="DR_+3A_iterations">iterations</code></td>
<td>
<p>iterations to run</p>
</td></tr>
<tr><td><code id="DR_+3A_nbi">nBI</code></td>
<td>
<p>number of burnin</p>
</td></tr>
<tr><td><code id="DR_+3A_parmin">parmin</code></td>
<td>
<p>minimum values for the parameter vector or NULL if FUN is of class BayesianSetup</p>
</td></tr>
<tr><td><code id="DR_+3A_parmax">parmax</code></td>
<td>
<p>maximum values for the parameter vector or NULL if FUN is of class BayesianSetup</p>
</td></tr>
<tr><td><code id="DR_+3A_f1">f1</code></td>
<td>
<p>scaling factor for first proposal</p>
</td></tr>
<tr><td><code id="DR_+3A_f2">f2</code></td>
<td>
<p>scaling factor for second proposal</p>
</td></tr>
<tr><td><code id="DR_+3A_fun">FUN</code></td>
<td>
<p>function to be sampled from or object of class bayesianSetup</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francesco Minunno
</p>


<h3>References</h3>

<p>Tierney, Luke, and Antonietta Mira. &quot;Some adaptive Monte Carlo methods for Bayesian inference.&quot; Statistics in medicine 18.1718 (1999): 2507-2515.
</p>

<hr>
<h2 id='DRAM'>The Delayed Rejection Adaptive Metropolis Algorithm</h2><span id='topic+DRAM'></span>

<h3>Description</h3>

<p>The Delayed Rejection Adaptive Metropolis Algorithm (Haario et al. 2001)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DRAM(
  startValue = NULL,
  iterations = 10000,
  nBI = 0,
  parmin = NULL,
  parmax = NULL,
  FUN,
  f = 1,
  eps = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DRAM_+3A_startvalue">startValue</code></td>
<td>
<p>vector with the start values for the algorithm. Can be NULL if FUN is of class BayesianSetup. In this case startValues are sampled from the prior.</p>
</td></tr>
<tr><td><code id="DRAM_+3A_iterations">iterations</code></td>
<td>
<p>iterations to run</p>
</td></tr>
<tr><td><code id="DRAM_+3A_nbi">nBI</code></td>
<td>
<p>number of burnin</p>
</td></tr>
<tr><td><code id="DRAM_+3A_parmin">parmin</code></td>
<td>
<p>minimum values for the parameter vector or NULL if FUN is of class BayesianSetup</p>
</td></tr>
<tr><td><code id="DRAM_+3A_parmax">parmax</code></td>
<td>
<p>maximum values for the parameter vector or NULL if FUN is of class BayesianSetup</p>
</td></tr>
<tr><td><code id="DRAM_+3A_fun">FUN</code></td>
<td>
<p>function to be sampled from</p>
</td></tr>
<tr><td><code id="DRAM_+3A_f">f</code></td>
<td>
<p>scaling factor</p>
</td></tr>
<tr><td><code id="DRAM_+3A_eps">eps</code></td>
<td>
<p>small number to avoid singularity or object of class bayesianSetup</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francesco Minunno
</p>


<h3>References</h3>

<p>Haario, Heikki, Eero Saksman, and Johanna Tamminen. &quot;An adaptive Metropolis algorithm.&quot; Bernoulli (2001): 223-242.
</p>

<hr>
<h2 id='DREAM'>DREAM</h2><span id='topic+DREAM'></span>

<h3>Description</h3>

<p>DREAM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DREAM(
  bayesianSetup,
  settings = list(iterations = 10000, nCR = 3, gamma = NULL, eps = 0, e = 0.05, pCRupdate
    = TRUE, updateInterval = 10, burnin = 0, thin = 1, adaptation = 0.2, parallel = NULL,
    DEpairs = 2, consoleUpdates = 10, startValue = NULL, currentChain = 1, message =
    TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DREAM_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>Object of class 'bayesianSetup' or 'bayesianOuput'.</p>
</td></tr>
<tr><td><code id="DREAM_+3A_settings">settings</code></td>
<td>
<p>list with parameter values</p>
</td></tr>
<tr><td><code id="DREAM_+3A_iterations">iterations</code></td>
<td>
<p>Number of model evaluations</p>
</td></tr>
<tr><td><code id="DREAM_+3A_ncr">nCR</code></td>
<td>
<p>parameter determining the number of cross-over proposals. If nCR = 1 all parameters are updated jointly.</p>
</td></tr>
<tr><td><code id="DREAM_+3A_updateinterval">updateInterval</code></td>
<td>
<p>determining the intervall for the pCR update</p>
</td></tr>
<tr><td><code id="DREAM_+3A_gamma">gamma</code></td>
<td>
<p>Kurtosis parameter Bayesian Inference Scheme</p>
</td></tr>
<tr><td><code id="DREAM_+3A_eps">eps</code></td>
<td>
<p>Ergodicity term</p>
</td></tr>
<tr><td><code id="DREAM_+3A_e">e</code></td>
<td>
<p>Ergodicity term</p>
</td></tr>
<tr><td><code id="DREAM_+3A_pcrupdate">pCRupdate</code></td>
<td>
<p>If T, crossover probabilities will be updated</p>
</td></tr>
<tr><td><code id="DREAM_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations treated as burn-in. These iterations are not recorded in the chain.</p>
</td></tr>
<tr><td><code id="DREAM_+3A_thin">thin</code></td>
<td>
<p>thin thinning parameter. Determines the interval in which values are recorded.</p>
</td></tr>
<tr><td><code id="DREAM_+3A_adaptation">adaptation</code></td>
<td>
<p>Number or percentage of samples that are used for the adaptation in DREAM (see Details).</p>
</td></tr>
<tr><td><code id="DREAM_+3A_depairs">DEpairs</code></td>
<td>
<p>Number of pairs used to generate proposal</p>
</td></tr>
<tr><td><code id="DREAM_+3A_startvalue">startValue</code></td>
<td>
<p>eiter a matrix containing the start values (see details), an integer to define the number of chains that are run, a function to sample the start values or NUll, in which case the values are sampled from the prior.</p>
</td></tr>
<tr><td><code id="DREAM_+3A_consoleupdates">consoleUpdates</code></td>
<td>
<p>Intervall in which the sampling progress is printed to the console</p>
</td></tr>
<tr><td><code id="DREAM_+3A_message">message</code></td>
<td>
<p>logical determines whether the sampler's progress should be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Insted of a bayesianSetup, the function can take the output of a previous run to restart the sampler
from the last iteration. Due to the sampler's internal structure you can only use the output
of DREAM.
If you provide a matrix with start values the number of rows determines the number of chains that are run.
The number of coloumns must be equivalent to the number of parameters in your bayesianSetup. <br /><br />
There are several small differences in the algorithm presented here compared to the original paper by Vrugt et al. (2009). Mainly
the algorithm implemented here does not have an automatic stopping criterion. Hence, it will
always run the number of iterations specified by the user. Also, convergence is not
monitored and left to the user. This can easily be done with coda::gelman.diag(chain).
Further the proposed delayed rejectio step in Vrugt et al. (2009) is not implemented here.<br /><br />
</p>
<p>During the adaptation phase DREAM is running two mechanisms to enhance the sampler's efficiency.
First the disribution of crossover values is tuned to favor large jumps in the parameter space.
The crossover probabilities determine how many parameters are updated simultaneously.
Second outlier chains are replanced as they can largely deteriorate the sampler's performance.
However, these steps destroy the detailed balance of the chain. Consequently these parts of the chain
should be discarded when summarizing posterior moments. This can be done automatically during the
sampling process (i.e. burnin &gt; adaptation) or subsequently by the user. We chose to distinguish between
the burnin and adaptation phase to allow the user more flexibility in the sampler's settings.
</p>


<h3>Value</h3>

<p>mcmc.object containing the following elements: chains, X, pCR
</p>


<h3>Author(s)</h3>

<p>Stefan Paul
</p>


<h3>References</h3>

<p>Vrugt, Jasper A., et al. &quot;Accelerating Markov chain Monte Carlo simulation by differential evolution with self-adaptive randomized subspace sampling.&quot; International Journal of Nonlinear Sciences and Numerical Simulation 10.3 (2009): 273-290.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DREAMzs">DREAMzs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesianTools)

ll &lt;- generateTestDensityMultiNormal(sigma = "no correlation")
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, 
                                     lower = rep(-10, 3), 
                                     upper = rep(10, 3))

settings = list(iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# DE family samplers are population MCMCs that run a number of internal chains
# in parallel. Here examples how to change the internal chains
# note that internal chains can be executedi n parallel
settings = list(startValue = 4, iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# Modify the start values of the internal chains (note that this is a matrix
# of dim nChain * nPar)
settings = list(startValue = matrix(rnorm(12), nrow = 4, ncol = 3), 
                iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# In the DE sampler family with Z matrix, the previous chains are written in 
# a common matrix, from which proposals are generated. Per default this matrix
# is started with samples from the prior, but we can change this. Often useful
# to improve sampler convergence, 
# see  https://github.com/florianhartig/BayesianTools/issues/79
settings = list(startValue = matrix(rnorm(12), nrow = 4, ncol = 3),
                Z = matrix(rnorm(300), nrow = 100, ncol = 3),
                iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)


</code></pre>

<hr>
<h2 id='DREAMzs'>DREAMzs</h2><span id='topic+DREAMzs'></span>

<h3>Description</h3>

<p>DREAMzs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DREAMzs(
  bayesianSetup,
  settings = list(iterations = 10000, nCR = 3, gamma = NULL, eps = 0, e = 0.05, pCRupdate
    = FALSE, updateInterval = 10, burnin = 0, thin = 1, adaptation = 0.2, parallel =
    NULL, Z = NULL, ZupdateFrequency = 10, pSnooker = 0.1, DEpairs = 2, consoleUpdates =
    10, startValue = NULL, currentChain = 1, message = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DREAMzs_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>Object of class 'bayesianSetup' or 'bayesianOuput'.</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_settings">settings</code></td>
<td>
<p>list with parameter values</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_iterations">iterations</code></td>
<td>
<p>Number of model evaluations</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_ncr">nCR</code></td>
<td>
<p>parameter determining the number of cross-over proposals.  If nCR = 1 all parameters are updated jointly.</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_updateinterval">updateInterval</code></td>
<td>
<p>determining the intervall for the pCR (crossover probabilities) update</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_gamma">gamma</code></td>
<td>
<p>Kurtosis parameter Bayesian Inference Scheme.</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_eps">eps</code></td>
<td>
<p>Ergodicity term</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_e">e</code></td>
<td>
<p>Ergodicity term</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_pcrupdate">pCRupdate</code></td>
<td>
<p>Update of crossover probabilities</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations treated as burn-in. These iterations are not recorded in the chain.</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_thin">thin</code></td>
<td>
<p>thin thinning parameter. Determines the interval in which values are recorded.</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_adaptation">adaptation</code></td>
<td>
<p>Number or percentage of samples that are used for the adaptation in DREAM (see Details)</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_depairs">DEpairs</code></td>
<td>
<p>Number of pairs used to generate proposal</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_zupdatefrequency">ZupdateFrequency</code></td>
<td>
<p>frequency to update Z matrix</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_psnooker">pSnooker</code></td>
<td>
<p>probability of snooker update</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_z">Z</code></td>
<td>
<p>starting matrix for Z</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_startvalue">startValue</code></td>
<td>
<p>eiter a matrix containing the start values (see details), an integer to define the number of chains that are run, a function to sample the start values or NUll, in which case the values are sampled from the prior.</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_consoleupdates">consoleUpdates</code></td>
<td>
<p>Intervall in which the sampling progress is printed to the console</p>
</td></tr>
<tr><td><code id="DREAMzs_+3A_message">message</code></td>
<td>
<p>logical determines whether the sampler's progress should be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Insted of a bayesianSetup, the function can take the output of a previous run to restart the sampler
from the last iteration. Due to the sampler's internal structure you can only use the output
of DREAMzs.
If you provide a matrix with start values the number of rows detemines the number of chains that are run.
The number of coloumns must be equivalent to the number of parameters in your bayesianSetup. <br /><br />
There are several small differences in the algorithm presented here compared to the original paper by Vrugt et al. (2009). Mainly
the algorithm implemented here does not have an automatic stopping criterion. Hence, it will
always run the number of iterations specified by the user. Also, convergence is not
monitored and left to the user. This can easily be done with coda::gelman.diag(chain).
Further the proposed delayed rejectio step in Vrugt et al. (2009) is not implemented here.<br /><br />
During the adaptation phase DREAM is running two mechanisms to enhance the sampler's efficiency.
First the disribution of crossover values is tuned to favor large jumps in the parameter space.
The crossover probabilities determine how many parameters are updated simultaneously.
Second outlier chains are replanced as they can largely deteriorate the sampler's performance.
However, these steps destroy the detailed balance of the chain. Consequently these parts of the chain
should be discarded when summarizing posterior moments. This can be done automatically during the
sampling process (i.e. burnin &gt; adaptation) or subsequently by the user. We chose to distinguish between
the burnin and adaptation phase to allow the user more flexibility in the sampler's settings.
</p>


<h3>Value</h3>

<p>mcmc.object containing the following elements: chains, X, pCR, Z
</p>


<h3>Author(s)</h3>

<p>Stefan Paul
</p>


<h3>References</h3>

<p>Vrugt, Jasper A., et al. &quot;Accelerating Markov chain Monte Carlo simulation by differential evolution with self-adaptive randomized subspace sampling.&quot; International Journal of Nonlinear Sciences and Numerical Simulation 10.3 (2009): 273-290.
</p>
<p>ter  Braak C. J. F., and Vrugt J. A. (2008). Differential Evolution Markov Chain with snooker updater and fewer chains. Statistics and Computing http://dx.doi.org/10.1007/s11222-008-9104-9
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DREAM">DREAM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(BayesianTools)

ll &lt;- generateTestDensityMultiNormal(sigma = "no correlation")
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, 
                                     lower = rep(-10, 3), 
                                     upper = rep(10, 3))

settings = list(iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# DE family samplers are population MCMCs that run a number of internal chains
# in parallel. Here examples how to change the internal chains
# note that internal chains can be executedi n parallel
settings = list(startValue = 4, iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# Modify the start values of the internal chains (note that this is a matrix
# of dim nChain * nPar)
settings = list(startValue = matrix(rnorm(12), nrow = 4, ncol = 3), 
                iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)

# In the DE sampler family with Z matrix, the previous chains are written in 
# a common matrix, from which proposals are generated. Per default this matrix
# is started with samples from the prior, but we can change this. Often useful
# to improve sampler convergence, 
# see  https://github.com/florianhartig/BayesianTools/issues/79
settings = list(startValue = matrix(rnorm(12), nrow = 4, ncol = 3),
                Z = matrix(rnorm(300), nrow = 100, ncol = 3),
                iterations = 200)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)
summary(out)


</code></pre>

<hr>
<h2 id='factorMatrice'>factorMatrice</h2><span id='topic+factorMatrice'></span>

<h3>Description</h3>

<p>factorMatrice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorMatrice(sigma, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorMatrice_+3A_sigma">sigma</code></td>
<td>
<p>sigma</p>
</td></tr>
<tr><td><code id="factorMatrice_+3A_method">method</code></td>
<td>
<p>either &quot;eigen&quot;, &quot;svd&quot; or &quot;chol&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='gelmanDiagnostics'>Gelman Diagnostics</h2><span id='topic+gelmanDiagnostics'></span>

<h3>Description</h3>

<p>Runs Gelman Diagnotics for an object of class BayesianOutput
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gelmanDiagnostics(sampler, thin = "auto", plot = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gelmanDiagnostics_+3A_sampler">sampler</code></td>
<td>
<p>an object of class mcmcSampler or mcmcSamplerList</p>
</td></tr>
<tr><td><code id="gelmanDiagnostics_+3A_thin">thin</code></td>
<td>
<p>parameter determining the thinning intervall. Either an integer or &quot;auto&quot; (default) for automatic thinning.</p>
</td></tr>
<tr><td><code id="gelmanDiagnostics_+3A_plot">plot</code></td>
<td>
<p>should a Gelman plot be generated</p>
</td></tr>
<tr><td><code id="gelmanDiagnostics_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+getSample">getSample</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls <a href="coda.html#topic+gelman.diag">coda::gelman.diag</a> to calculate Gelman-Rubin diagnostics <a href="coda.html#topic+gelman.plot">coda::gelman.plot</a> to produce the plots.
</p>
<p>The idea of these diagnostics is to compare withing and between chain variance of several independent MCMC runs (Gelman &amp; Rubin, 1992). The ratio of the 2 is called the potential scale reduction factor (psfr, also called Rhat). If psfr = 1, this suggest that the independent MCMC runs are essentially identical, and which in turn suggests that they have converged. In practice, values &lt; 1.05, or sometimes &lt; 1.1 for all parameters are considered acceptable.
</p>
<p>To obtain reliable Gelman-Rubin diagnostics, the independent MCMCs should be started at different points of the parameter space, ideally overdispersed.
</p>
<p>The diagnostics also calculate a multivariate version of the psrf (mpsrf, Brooks &amp; Gelman 1998). In practice, values &lt; 1.1 or &lt; 1.2 are often considered acceptable. While useful as an overview, mpsrf &lt; 1.1 does not necessarily mean that all individual psrf &lt; 1.05, and thus I would in doubt recommend looking at the individual psrf and decide on a case-by-case basis if a lack of convergence for a particular parameter is a concern.
</p>
<p>Also, note that convergence is a continuum, and different aspects of a posterior estimation converge with different speed. The rules about 1.05 were obtained by looking at the error of the posterior median / mean. If the goal for the inference is a posterior quantity that is more unstable than the mean, for example tail probabilities or the DIC, one should try to obtain large posterior samples with smaller psrf values.
</p>
<p><strong>Note on the use of Gelman diagnostics for population MCMCs, in particular the DE sampler family</strong>: the Gelman diagnostics were originally designed for being applied to the outcome of several independent MCMC runs. Technically and practically, it can also be applied to a single population MCMC run that has several internal chains, such as DE, DEzs, DREAM, DREAMzs or T-Walk. As argued in ter Braak et al. (2008), the internal chains should be independent after burn-in. While this is likely correct, it also means that they are not completely independent before, and we observed this behavior in the use of the algorithms (i.e. that internal DEzs chains are more similar to each other than the chains of independent DEzs algorithms), see for example <a href="https://github.com/florianhartig/BayesianTools/issues/226">BT issue 226</a>. A concern is that this non-independence could lead to a failure to detect that the sampler hasn't converged yet, due to a wrong burn-in. We would therefore recommend to run several DEzs and check convergence with those, instead of running only one.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>References</h3>

<p>Gelman, A and Rubin, DB (1992) Inference from iterative simulation using multiple sequences, Statistical Science, 7, 457-511.
</p>
<p>Brooks, SP. and Gelman, A. (1998) General methods for monitoring convergence of iterative simulations. Journal of Computational and Graphical Statistics, 7, 434-455.
</p>
<p>ter Braak, Cajo JF, and Jasper A. Vrugt. &quot;Differential evolution Markov chain with snooker updater and fewer chains.&quot; Statistics and Computing 18.4 (2008): 435-446.
</p>

<hr>
<h2 id='generateCRvalues'>Generates matrix of CR values based on pCR</h2><span id='topic+generateCRvalues'></span>

<h3>Description</h3>

<p>Generates matrix of CR values based on pCR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCRvalues(pCR, settings, Npop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateCRvalues_+3A_pcr">pCR</code></td>
<td>
<p>Vector of crossover probabilities. Needs to be of length nCR.</p>
</td></tr>
<tr><td><code id="generateCRvalues_+3A_settings">settings</code></td>
<td>
<p>settings list</p>
</td></tr>
<tr><td><code id="generateCRvalues_+3A_npop">Npop</code></td>
<td>
<p>number of chains</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with CR values
</p>

<hr>
<h2 id='generateParallelExecuter'>Factory to generate a parallel executor of an existing function</h2><span id='topic+generateParallelExecuter'></span>

<h3>Description</h3>

<p>Factory to generate a parallel executor of an existing function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateParallelExecuter(
  fun,
  parallel = F,
  parallelOptions = list(variables = "all", packages = "all", dlls = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateParallelExecuter_+3A_fun">fun</code></td>
<td>
<p>function to be changed to parallel execution</p>
</td></tr>
<tr><td><code id="generateParallelExecuter_+3A_parallel">parallel</code></td>
<td>
<p>should a parallel R cluster be used or not. If set to T, cores will be detected automatically and n-1 of the available n cores of the machine will be used. Alternatively, you can set the number of cores used by hand</p>
</td></tr>
<tr><td><code id="generateParallelExecuter_+3A_paralleloptions">parallelOptions</code></td>
<td>
<p>list containing three lists. First &quot;packages&quot; determines the R packages necessary to run the likelihood function. Second &quot;variables&quot; the objects in the global environment needed to run the likelihood function and third &quot;dlls&quot; the DLLs needed to run the likelihood function (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For parallelization, option T means that an automatic parallelization via R is attempted, or &quot;external&quot;, in which case it is assumed that the likelihood is already parallelized. In this case it needs to accept a matrix with parameters as columns.
Further you can specify the packages, objects and DLLs that are exported to the cluster.
By default a copy of your workspace is exported. However, depending on your workspace this can be very inefficient.
</p>
<p>Alternatively you can specify the environments and packages in the likelihood function (e.g. BayesianTools::VSEM() instead of VSEM()).
</p>


<h3>Note</h3>

<p>Can also be used to make functions compatible with library sensitivity
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
testDensityMultiNormal &lt;- generateTestDensityMultiNormal()


parDen &lt;- generateParallelExecuter(testDensityMultiNormal)$parallelFun
x = matrix(runif(9,0,1), nrow = 3)
parDen(x)

</code></pre>

<hr>
<h2 id='generateTestDensityMultiNormal'>Multivariate normal likelihood</h2><span id='topic+generateTestDensityMultiNormal'></span>

<h3>Description</h3>

<p>Generates a 3 dimensional multivariate normal likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateTestDensityMultiNormal(
  mean = c(0, 0, 0),
  sigma = "strongcorrelation",
  sample = F,
  n = 1,
  throwErrors = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateTestDensityMultiNormal_+3A_mean">mean</code></td>
<td>
<p>vector with the three mean values of the distribution</p>
</td></tr>
<tr><td><code id="generateTestDensityMultiNormal_+3A_sigma">sigma</code></td>
<td>
<p>either a correlation matrix, or &quot;strongcorrelation&quot;, or &quot;no correlation&quot;</p>
</td></tr>
<tr><td><code id="generateTestDensityMultiNormal_+3A_sample">sample</code></td>
<td>
<p>should the function create samples</p>
</td></tr>
<tr><td><code id="generateTestDensityMultiNormal_+3A_n">n</code></td>
<td>
<p>number of samples to create</p>
</td></tr>
<tr><td><code id="generateTestDensityMultiNormal_+3A_throwerrors">throwErrors</code></td>
<td>
<p>parameter for test purpose. Between 0 and 1 for proportion of errors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>3-d multivariate normal density function with mean 2,4,0 and either strong correlation (default), or no correlation.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testDensityBanana">testDensityBanana</a></code> <br />
<code><a href="#topic+testLinearModel">testLinearModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sampling from the test function
x = generateTestDensityMultiNormal(sample  = TRUE, n = 1000)(1000)
correlationPlot(x)
marginalPlot(x)

# generating the the density
density = generateTestDensityMultiNormal(sample  = FALSE)
density(x[1,])
</code></pre>

<hr>
<h2 id='getBlock'>Determine the parameters in the block update</h2><span id='topic+getBlock'></span>

<h3>Description</h3>

<p>Determine the parameters in the block update
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBlock(blockSettings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBlock_+3A_blocksettings">blockSettings</code></td>
<td>
<p>settings for block update</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector containing the parameter to be updated
</p>

<hr>
<h2 id='getBlockSettings'>getblockSettings</h2><span id='topic+getBlockSettings'></span>

<h3>Description</h3>

<p>Transforms the original settings in settings used in the model runs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBlockSettings(blockUpdate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBlockSettings_+3A_blockupdate">blockUpdate</code></td>
<td>
<p>input settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with block settings
</p>

<hr>
<h2 id='getCredibleIntervals'>Calculate confidence region from an MCMC or similar sample</h2><span id='topic+getCredibleIntervals'></span>

<h3>Description</h3>

<p>Calculate confidence region from an MCMC or similar sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCredibleIntervals(sampleMatrix, quantiles = c(0.025, 0.975))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCredibleIntervals_+3A_samplematrix">sampleMatrix</code></td>
<td>
<p>matrix of outcomes. Could be parameters or predictions</p>
</td></tr>
<tr><td><code id="getCredibleIntervals_+3A_quantiles">quantiles</code></td>
<td>
<p>quantiles to be calculated</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPredictiveDistribution">getPredictiveDistribution</a></code> <br />
<code><a href="#topic+getPredictiveIntervals">getPredictiveIntervals</a></code> <br />
</p>

<hr>
<h2 id='getDharmaResiduals'>Creates a DHARMa object</h2><span id='topic+getDharmaResiduals'></span>

<h3>Description</h3>

<p>Creates a DHARMa object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDharmaResiduals(model, parMatrix, numSamples, observed, error, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getDharmaResiduals_+3A_model">model</code></td>
<td>
<p>function that calculates model predictions for a given parameter vector</p>
</td></tr>
<tr><td><code id="getDharmaResiduals_+3A_parmatrix">parMatrix</code></td>
<td>
<p>a parameter matrix from which the simulations will be generated</p>
</td></tr>
<tr><td><code id="getDharmaResiduals_+3A_numsamples">numSamples</code></td>
<td>
<p>the number of samples</p>
</td></tr>
<tr><td><code id="getDharmaResiduals_+3A_observed">observed</code></td>
<td>
<p>a vector of observed values</p>
</td></tr>
<tr><td><code id="getDharmaResiduals_+3A_error">error</code></td>
<td>
<p>function with signature f(mean, par) that generates error expectations from mean model predictions. Par is a vector from the matrix with the parameter samples (full length). f needs to know which of these parameters are parameters of the error function</p>
</td></tr>
<tr><td><code id="getDharmaResiduals_+3A_plot">plot</code></td>
<td>
<p>logical, determining whether the simulated residuals should be plotted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tankred Ott
</p>

<hr>
<h2 id='getPanels'>getPanels</h2><span id='topic+getPanels'></span>

<h3>Description</h3>

<p>Calculates the argument x for par(mfrow = x) for a desired number of panels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPanels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPanels_+3A_x">x</code></td>
<td>
<p>the desired number of panels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='getPossibleSamplerTypes'>Returns possible sampler types</h2><span id='topic+getPossibleSamplerTypes'></span>

<h3>Description</h3>

<p>Returns possible sampler types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPossibleSamplerTypes()
</code></pre>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='getPredictiveDistribution'>Calculates predictive distribution based on the parameters</h2><span id='topic+getPredictiveDistribution'></span>

<h3>Description</h3>

<p>Calculates predictive distribution based on the parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPredictiveDistribution(parMatrix, model, numSamples = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPredictiveDistribution_+3A_parmatrix">parMatrix</code></td>
<td>
<p>matrix of parameter values</p>
</td></tr>
<tr><td><code id="getPredictiveDistribution_+3A_model">model</code></td>
<td>
<p>model / function to calculate predictions. Outcome should be a vector</p>
</td></tr>
<tr><td><code id="getPredictiveDistribution_+3A_numsamples">numSamples</code></td>
<td>
<p>number of samples to be drawn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If numSamples is greater than the number of rows in parMatrix, or NULL, or FALSE, or less than 1 all samples in parMatrix will be used.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPredictiveIntervals">getPredictiveIntervals</a></code> <br />
<code><a href="#topic+getCredibleIntervals">getCredibleIntervals</a></code> <br />
</p>

<hr>
<h2 id='getPredictiveIntervals'>Calculates Bayesian credible (confidence) and predictive intervals based on parameter sample</h2><span id='topic+getPredictiveIntervals'></span>

<h3>Description</h3>

<p>Calculates Bayesian credible (confidence) and predictive intervals based on parameter sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPredictiveIntervals(
  parMatrix,
  model,
  numSamples = 1000,
  quantiles = c(0.025, 0.975),
  error = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPredictiveIntervals_+3A_parmatrix">parMatrix</code></td>
<td>
<p>matrix of parameter values</p>
</td></tr>
<tr><td><code id="getPredictiveIntervals_+3A_model">model</code></td>
<td>
<p>model / function to calculate predictions. Outcome should be a vector</p>
</td></tr>
<tr><td><code id="getPredictiveIntervals_+3A_numsamples">numSamples</code></td>
<td>
<p>number of samples to be drawn</p>
</td></tr>
<tr><td><code id="getPredictiveIntervals_+3A_quantiles">quantiles</code></td>
<td>
<p>quantiles to calculate</p>
</td></tr>
<tr><td><code id="getPredictiveIntervals_+3A_error">error</code></td>
<td>
<p>function with signature f(mean, par) that generates error expectations from mean model predictions. Par is a vector from the matrix with the parameter samples (full length). f needs to know which of these parameters are parameters of the error function. If supplied, will calculate also predictive intervals additional to credible intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If numSamples is greater than the number of rows in parMatrix, or NULL, or FALSE, or less than 1 all samples in parMatrix will be used.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPredictiveDistribution">getPredictiveDistribution</a></code> <br />
<code><a href="#topic+getCredibleIntervals">getCredibleIntervals</a></code> <br />
</p>

<hr>
<h2 id='getRmvnorm'>Produce multivariate normal proposal</h2><span id='topic+getRmvnorm'></span>

<h3>Description</h3>

<p>Produce multivariate normal proposal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRmvnorm(n = 1, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRmvnorm_+3A_n">n</code></td>
<td>
<p>n</p>
</td></tr>
<tr><td><code id="getRmvnorm_+3A_r">R</code></td>
<td>
<p>R</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X
</p>

<hr>
<h2 id='getSample'>Extracts the sample from a bayesianOutput</h2><span id='topic+getSample'></span><span id='topic+getSample.matrix'></span><span id='topic+getSample.double'></span><span id='topic+getSample.integer'></span><span id='topic+getSample.data.frame'></span><span id='topic+getSample.list'></span><span id='topic+getSample.mcmc'></span><span id='topic+getSample.mcmc.list'></span><span id='topic+getSample.MCMC'></span><span id='topic+getSample.MCMC_refClass'></span>

<h3>Description</h3>

<p>Extracts the sample from a bayesianOutput
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = 1,
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = FALSE,
  ...
)

## S3 method for class 'matrix'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)

## S3 method for class 'double'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)

## S3 method for class 'integer'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)

## S3 method for class 'data.frame'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)

## S3 method for class 'list'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)

## S3 method for class 'mcmc'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)

## S3 method for class 'mcmc.list'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)

## S3 method for class 'MCMC'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)

## S3 method for class 'MCMC_refClass'
getSample(
  sampler,
  parametersOnly = T,
  coda = F,
  start = 1,
  end = NULL,
  thin = "auto",
  numSamples = NULL,
  whichParameters = NULL,
  reportDiagnostics = F,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSample_+3A_sampler">sampler</code></td>
<td>
<p>an object of class mcmcSampler, mcmcSamplerList, smcSampler, smcSamplerList, mcmc, mcmc.list, double, numeric</p>
</td></tr>
<tr><td><code id="getSample_+3A_parametersonly">parametersOnly</code></td>
<td>
<p>for a BT output, if F, likelihood, posterior and prior values are also provided in the output</p>
</td></tr>
<tr><td><code id="getSample_+3A_coda">coda</code></td>
<td>
<p>works only for mcmc classes - provides output as a coda object. Note: if mcmcSamplerList contains mcmc samplers such as DE that have several chains, the internal chains will be collapsed. This may not be the desired behavior for all applications.</p>
</td></tr>
<tr><td><code id="getSample_+3A_start">start</code></td>
<td>
<p>for mcmc samplers start value in the chain. For SMC samplers, start particle</p>
</td></tr>
<tr><td><code id="getSample_+3A_end">end</code></td>
<td>
<p>for mcmc samplers end value in the chain. For SMC samplers, end particle</p>
</td></tr>
<tr><td><code id="getSample_+3A_thin">thin</code></td>
<td>
<p>thinning parameter. Either an integer determining the thinning intervall (default is 1) or &quot;auto&quot; for automatic thinning.</p>
</td></tr>
<tr><td><code id="getSample_+3A_numsamples">numSamples</code></td>
<td>
<p>sample size (only used if thin = 1). If you want to use numSamples set thin to 1.</p>
</td></tr>
<tr><td><code id="getSample_+3A_whichparameters">whichParameters</code></td>
<td>
<p>possibility to select parameters by index</p>
</td></tr>
<tr><td><code id="getSample_+3A_reportdiagnostics">reportDiagnostics</code></td>
<td>
<p>logical, determines whether settings should be included in the output</p>
</td></tr>
<tr><td><code id="getSample_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If thin is greater than the total number of samples in the sampler object the first and the last element (of each chain if a sampler with multiples chains is used) are sampled. If numSamples is greater than the total number of samples all samples are selected. In both cases a warning is displayed.
</p>
<p>If thin and numSamples is passed, the function will use the thin argument if it is valid and greater than 1, else numSamples will be used.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>
<p>Tankred Ott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ll = function(x) sum(dnorm(x, log = TRUE))

setup = createBayesianSetup(ll, lower = c(-10,-10), upper = c(10,10))

settings = list(nrChains = 2, iterations = 1000)
out &lt;- runMCMC(bayesianSetup = setup, sampler = "DEzs", settings = settings)

# population MCMCs divide the interations by the number of internal chains,
# so the end of the 3 chains is 1000/3 = 334
sample &lt;- getSample(out, start = 100, end = 334, thin = 10) 

# sampling with number of samples instead of thinning and
# returning a coda object
sample &lt;- getSample(out, start = 100, numSamples = 60, coda = TRUE)
plot(sample)


# MCMC with a single chain:
settings_2 &lt;- list(nrChains = 1, iterations = 1000)
out_2 &lt;- runMCMC(setup, sampler = "Metropolis", settings = settings_2)
sample_2 &lt;- getSample(out_2, numSamples = 100)

</code></pre>

<hr>
<h2 id='getSetup'>Function to get the setup from a bayesianOutput</h2><span id='topic+getSetup'></span>

<h3>Description</h3>

<p>Function to get the setup from a bayesianOutput
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSetup(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSetup_+3A_x">x</code></td>
<td>
<p>bayesianOutput</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bayesianSetup
</p>


<h3>Author(s)</h3>

<p>Tankred Ott
</p>

<hr>
<h2 id='getVolume'>Calculate posterior volume</h2><span id='topic+getVolume'></span>

<h3>Description</h3>

<p>Calculate posterior volume
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVolume(sampler, prior = F, method = "MVN", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVolume_+3A_sampler">sampler</code></td>
<td>
<p>an object of superclass bayesianOutput or any other class that has the getSample function implemented (e.g. Matrix)</p>
</td></tr>
<tr><td><code id="getVolume_+3A_prior">prior</code></td>
<td>
<p>schould also prior volume be calculated</p>
</td></tr>
<tr><td><code id="getVolume_+3A_method">method</code></td>
<td>
<p>method for volume estimation. Currently, the only option is &quot;MVN&quot;</p>
</td></tr>
<tr><td><code id="getVolume_+3A_...">...</code></td>
<td>
<p>additional parameters to pass on to the <code><a href="#topic+getSample">getSample</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea of this function is to provide an estimate of the &quot;posterior volume&quot;, i.e. how &quot;broad&quot; the posterior is. One potential application is to the overall reduction of parametric uncertainty between different data types, or between prior and posterior.
</p>
<p>Implemented methods for volume estimation:
</p>
<p>Option &quot;MVN&quot; - in this option, the volume is calculated as the determinant of the covariance matrix of the prior / posterior sample.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bayesianSetup = createBayesianSetup(
  likelihood = generateTestDensityMultiNormal(sigma = "no correlation"), 
  lower = rep(-10, 3), upper = rep(10, 3))

out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", 
               settings = list(iterations = 2000, message = FALSE))

getVolume(out, prior = TRUE)

bayesianSetup = createBayesianSetup(
  likelihood = generateTestDensityMultiNormal(sigma = "strongcorrelation"), 
  lower = rep(-10, 3), upper = rep(10, 3))

out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", 
               settings = list(iterations = 2000, message = FALSE))

getVolume(out, prior = TRUE)

</code></pre>

<hr>
<h2 id='Gfun'>Helper function for blow and hop moves</h2><span id='topic+Gfun'></span>

<h3>Description</h3>

<p>Helper function for blow and hop moves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gfun(case, npSel, pSel, h, x, x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gfun_+3A_case">case</code></td>
<td>
<p>Type of Twalk move. Either &quot;hop&quot; or &quot;blow&quot;</p>
</td></tr>
<tr><td><code id="Gfun_+3A_npsel">npSel</code></td>
<td>
<p>number of parameters that are changed.</p>
</td></tr>
<tr><td><code id="Gfun_+3A_psel">pSel</code></td>
<td>
<p>vector containing information about which parameters are changed.</p>
</td></tr>
<tr><td><code id="Gfun_+3A_h">h</code></td>
<td>
<p>Parameter for &quot;blow&quot; and hop moves</p>
</td></tr>
<tr><td><code id="Gfun_+3A_x">x</code></td>
<td>
<p>parameter vector of chain 1</p>
</td></tr>
<tr><td><code id="Gfun_+3A_x2">x2</code></td>
<td>
<p>parameter vector of chain 2</p>
</td></tr>
</table>


<h3>References</h3>

<p>Christen, J. Andres, and Colin Fox. &quot;A general purpose sampling algorithm for continuous distributions (the t-walk).&quot; Bayesian Analysis 5.2 (2010): 263-281.
</p>

<hr>
<h2 id='GOF'>Standard GOF metrics
Startvalues for sampling with nrChains &gt; 1 : if you want to provide different start values for the different chains, provide a list</h2><span id='topic+GOF'></span>

<h3>Description</h3>

<p>Standard GOF metrics
Startvalues for sampling with nrChains &gt; 1 : if you want to provide different start values for the different chains, provide a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOF(observed, predicted, plot = F, centered = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GOF_+3A_observed">observed</code></td>
<td>
<p>observed values</p>
</td></tr>
<tr><td><code id="GOF_+3A_predicted">predicted</code></td>
<td>
<p>predicted values</p>
</td></tr>
<tr><td><code id="GOF_+3A_plot">plot</code></td>
<td>
<p>should a plot be created</p>
</td></tr>
<tr><td><code id="GOF_+3A_centered">centered</code></td>
<td>
<p>if T, variables are centered to the mean of the observations, i.e. the intercept is for the mean value of the observation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function considers observed ~ predicted and calculates
</p>

<ol>
<li><p> rmse = root mean squared error
</p>
</li>
<li><p> mae = mean absolute errorr
</p>
</li>
<li><p> a linear regression with slope, intercept and coefficient of determination R2
</p>
</li></ol>

<p>For the linear regression, centered = T means that variables will be centered around the mean value of the observation. This setting avoids a correlation between slope and intercept (that the intercept is != 0 as soon as the slope is !=0)
</p>


<h3>Value</h3>

<p>A list with the following entries: rmse = root mean squared error, mae = mean absolute error, slope = slope of regression, offset = intercept of regression, R2 = R2 of regression
</p>


<h3>Note</h3>

<p>In principle, it is possible to plot observed ~ predicted and predicted ~ observed. However, if we assume that the error is mainly on the y axis (observations), i.e. that observations scatter around the true (ideal) value, we should plot observed ~ predicted. See Pineiro et al. (2008). How to evaluate models: observed vs. predicted or predicted vs. observed?. Ecological Modelling, 216(3-4), 316-322.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = runif(500,-1,1)
y = 0.2 + 0.9  *x + rnorm(500, sd = 0.5)

summary(lm(y ~ x))

GOF(x,y)

GOF(x,y, plot = TRUE)
</code></pre>

<hr>
<h2 id='likelihoodAR1'>AR1 type likelihood function</h2><span id='topic+likelihoodAR1'></span>

<h3>Description</h3>

<p>AR1 type likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihoodAR1(predicted, observed, sd, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihoodAR1_+3A_predicted">predicted</code></td>
<td>
<p>vector of predicted values</p>
</td></tr>
<tr><td><code id="likelihoodAR1_+3A_observed">observed</code></td>
<td>
<p>vector of observed values</p>
</td></tr>
<tr><td><code id="likelihoodAR1_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the iid normal likelihood</p>
</td></tr>
<tr><td><code id="likelihoodAR1_+3A_a">a</code></td>
<td>
<p>temporal correlation in the AR1 model</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The AR1 model considers the process: <br /> y(t) = a y(t-1) + E <br /> e = i.i.d. N(0,sd) <br /> |a| &lt; 1 <br /> At the moment, no NAs are allowed in the time series.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='likelihoodIidNormal'>Normal / Gaussian Likelihood function</h2><span id='topic+likelihoodIidNormal'></span>

<h3>Description</h3>

<p>Normal / Gaussian Likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihoodIidNormal(predicted, observed, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihoodIidNormal_+3A_predicted">predicted</code></td>
<td>
<p>vector of predicted values</p>
</td></tr>
<tr><td><code id="likelihoodIidNormal_+3A_observed">observed</code></td>
<td>
<p>vector of observed values</p>
</td></tr>
<tr><td><code id="likelihoodIidNormal_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the i.i.d. normal likelihood</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='logSumExp'>Funktion to compute log(sum(exp(x))</h2><span id='topic+logSumExp'></span>

<h3>Description</h3>

<p>Funktion to compute log(sum(exp(x))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logSumExp(x, mean = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logSumExp_+3A_x">x</code></td>
<td>
<p>values at log scale</p>
</td></tr>
<tr><td><code id="logSumExp_+3A_mean">mean</code></td>
<td>
<p>logical, determines whether the mean should be used instead of the sum</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes log(sum(exp(x)), using the offset trick to avoid numeric overflow, see, e.g. http://jblevins.org/notes/log-sum-exp. The mean option allows calculating logMeanExp
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='M'>The Metropolis Algorithm</h2><span id='topic+M'></span>

<h3>Description</h3>

<p>The Metropolis Algorithm (Metropolis et al. 1953)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M(
  startValue = NULL,
  iterations = 10000,
  nBI = 0,
  parmin = NULL,
  parmax = NULL,
  f = 1,
  FUN,
  consoleUpdates = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M_+3A_startvalue">startValue</code></td>
<td>
<p>vector with the start values for the algorithm. Can be NULL if FUN is of class BayesianSetup. In this case startValues are sampled from the prior.</p>
</td></tr>
<tr><td><code id="M_+3A_iterations">iterations</code></td>
<td>
<p>iterations to run</p>
</td></tr>
<tr><td><code id="M_+3A_nbi">nBI</code></td>
<td>
<p>number of burnin</p>
</td></tr>
<tr><td><code id="M_+3A_parmin">parmin</code></td>
<td>
<p>minimum values for the parameter vector or NULL if FUN is of class BayesianSetup</p>
</td></tr>
<tr><td><code id="M_+3A_parmax">parmax</code></td>
<td>
<p>maximum values for the parameter vector or NULL if FUN is of class BayesianSetup</p>
</td></tr>
<tr><td><code id="M_+3A_f">f</code></td>
<td>
<p>scaling factor</p>
</td></tr>
<tr><td><code id="M_+3A_fun">FUN</code></td>
<td>
<p>function to be sampled from or object of class bayesianSetup</p>
</td></tr>
<tr><td><code id="M_+3A_consoleupdates">consoleUpdates</code></td>
<td>
<p>interger, determines the frequency with which sampler progress is printed to the console</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francesco Minunno
</p>


<h3>References</h3>

<p>Metropolis, Nicholas, et al. &quot;Equation of state calculations by fast computing machines.&quot; The journal of chemical physics 21.6 (1953): 1087-1092.
</p>

<hr>
<h2 id='makeObjectClassCodaMCMC'>Helper function to change an object to a coda mcmc class,</h2><span id='topic+makeObjectClassCodaMCMC'></span>

<h3>Description</h3>

<p>Helper function to change an object to a coda mcmc class,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeObjectClassCodaMCMC(chain, start = 1, end = numeric(0), thin = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeObjectClassCodaMCMC_+3A_chain">chain</code></td>
<td>
<p>mcmc Chain</p>
</td></tr>
<tr><td><code id="makeObjectClassCodaMCMC_+3A_start">start</code></td>
<td>
<p>for mcmc samplers start value in the chain. For SMC samplers, start particle</p>
</td></tr>
<tr><td><code id="makeObjectClassCodaMCMC_+3A_end">end</code></td>
<td>
<p>for mcmc samplers end value in the chain. For SMC samplers, end particle</p>
</td></tr>
<tr><td><code id="makeObjectClassCodaMCMC_+3A_thin">thin</code></td>
<td>
<p>thinning parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Very similar to coda::mcmc but with less overhead
</p>


<h3>Value</h3>

<p>object of class coda::mcmc
</p>

<hr>
<h2 id='MAP'>calculates the Maxiumum APosteriori value (MAP)</h2><span id='topic+MAP'></span>

<h3>Description</h3>

<p>calculates the Maxiumum APosteriori value (MAP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAP(bayesianOutput, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAP_+3A_bayesianoutput">bayesianOutput</code></td>
<td>
<p>an object of class BayesianOutput (mcmcSampler, smcSampler, or mcmcList)</p>
</td></tr>
<tr><td><code id="MAP_+3A_...">...</code></td>
<td>
<p>optional values to be passed on the the getSample function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, this function simply returns the parameter combination with the highest posterior in the chain. A more refined option would be to take the MCMC sample and do additional calculations, e.g. use an optimizer, a kerne delnsity estimator, or some other tool to search / interpolate around the best value in the chain
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WAIC">WAIC</a></code>, <code><a href="#topic+DIC">DIC</a></code>, <code><a href="#topic+marginalLikelihood">marginalLikelihood</a></code>
</p>

<hr>
<h2 id='marginalLikelihood'>Calcluated the marginal likelihood from a set of MCMC samples</h2><span id='topic+marginalLikelihood'></span>

<h3>Description</h3>

<p>Calcluated the marginal likelihood from a set of MCMC samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalLikelihood(sampler, numSamples = 1000, method = "Chib", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalLikelihood_+3A_sampler">sampler</code></td>
<td>
<p>an MCMC or SMC sampler or list, or for method &quot;Prior&quot; also a BayesianSetup</p>
</td></tr>
<tr><td><code id="marginalLikelihood_+3A_numsamples">numSamples</code></td>
<td>
<p>number of samples to use. How this works, and if it requires recalculating the likelihood, depends on the method</p>
</td></tr>
<tr><td><code id="marginalLikelihood_+3A_method">method</code></td>
<td>
<p>method to choose. Currently available are &quot;Chib&quot; (default), the harmonic mean &quot;HM&quot;, sampling from the prior &quot;Prior&quot;, and bridge sampling &quot;Bridge&quot;. See details</p>
</td></tr>
<tr><td><code id="marginalLikelihood_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="#topic+getSample">getSample</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal likelihood is the average likelihood across the prior space. It is used, for example, for Bayesian model selection and model averaging.
</p>
<p>It is defined as </p>
<p style="text-align: center;"><code class="reqn">ML = \int L(\Theta) p(\Theta) d\Theta</code>
</p>

<p>Given that MLs are calculated for each model, you can get posterior weights (for model selection and/or model averaging) on the model by
</p>
<p style="text-align: center;"><code class="reqn">P(M_i|D) = ML_i * p(M_i) / (\sum_i ML_i * p(M_i) )</code>
</p>

<p>In BT, we return the log ML, so you will have to exp all values for this formula.
</p>
<p>It is well-known that the ML is VERY dependent on the prior, and in particular the choice of the width of uninformative priors may have major impacts on the relative weights of the models. It has therefore been suggested to not use the ML for model averaging / selection on uninformative priors. If you have no informative priors, and option is to split the data into two parts, use one part to generate informative priors for the model, and the second part for the model selection. See help for an example.
</p>
<p>The marginalLikelihood function currently implements four ways to calculate the marginal likelihood. Be aware that marginal likelihood calculations are notoriously prone to numerical stability issues. Especially in high-dimensional parameter spaces, there is no guarantee that any of the implemented algorithms will converge reasonably fast. The recommended (and default) method is the method &quot;Chib&quot; (Chib and Jeliazkov, 2001), which is based on MCMC samples, with a limited number of additional calculations. Despite being the current recommendation, note there are some numeric issues with this algorithm that may limit reliability for larger dimensions.
</p>
<p>The harmonic mean approximation, is implemented only for comparison. Note that the method is numerically unrealiable and usually should not be used.
</p>
<p>The third method is simply sampling from the prior. While in principle unbiased, it will only converge for a large number of samples, and is therefore numerically inefficient.
</p>
<p>The Bridge method uses bridge sampling as implemented in the R package &quot;bridgesampling&quot;. It is potentially more exact than the Chib method, but might require more computation time. However, this may be very dependent on the sampler.
</p>


<h3>Value</h3>

<p>A list with log of the marginal likelihood, as well as other diagnostics depending on the chose method
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>References</h3>

<p>Chib, Siddhartha, and Ivan Jeliazkov. &quot;Marginal likelihood from the Metropolis-Hastings output.&quot; Journal of the American Statistical Association 96.453 (2001): 270-281.
</p>
<p>Dormann et al. 2018. Model averaging in ecology: a review of Bayesian, information-theoretic, and tactical approaches for predictive inference. Ecological Monographs
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WAIC">WAIC</a></code>, <code><a href="#topic+DIC">DIC</a></code>, <code><a href="#topic+MAP">MAP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################
# Comparison of ML for two regression models

# Creating test data with quadratic relationship
sampleSize = 30
x &lt;- (-(sampleSize-1)/2):((sampleSize-1)/2)
y &lt;-  1 * x + 1*x^2 + rnorm(n=sampleSize,mean=0,sd=10)
# plot(x,y, main="Test Data")

# likelihoods for linear and quadratic model 
likelihood1 &lt;- function(param){
  pred = param[1] + param[2]*x + param[3] * x^2
  singlelikelihoods = dnorm(y, mean = pred, sd = 1/(param[4]^2), log = TRUE)
  return(sum(singlelikelihoods))  
}
likelihood2 &lt;- function(param){
  pred = param[1] + param[2]*x 
  singlelikelihoods = dnorm(y, mean = pred, sd = 1/(param[3]^2), log = TRUE)
  return(sum(singlelikelihoods))  
}

setUp1 &lt;- createBayesianSetup(likelihood1, 
                              lower = c(-5,-5,-5,0.01), 
                              upper = c(5,5,5,30))
setUp2 &lt;- createBayesianSetup(likelihood2, 
                              lower = c(-5,-5,0.01), 
                              upper = c(5,5,30))

out1 &lt;- runMCMC(bayesianSetup = setUp1)
M1 = marginalLikelihood(out1, start = 1000)

out2 &lt;- runMCMC(bayesianSetup = setUp2)
M2 = marginalLikelihood(out2, start = 1000)


### Calculating Bayes factor

exp(M1$ln.ML - M2$ln.ML)

# BF &gt; 1 means the evidence is in favor of M1. See Kass, R. E. &amp; Raftery, A. E. 
# (1995) Bayes Factors. J. Am. Stat. Assoc., Amer Statist Assn, 90, 773-795.

### Calculating Posterior weights

exp(M1$ln.ML) / ( exp(M1$ln.ML) + exp(M2$ln.ML))

# If models have different model priors, multiply with the prior probabilities of each model. 


## Not run:  
#############################################################
# Fractional Bayes factor

# Motivation: ML is very dependent on the prior, which is a problem if you 
# have uninformative priors. you can see this via rerunning the upper  
# example with changed priors - suddenly, support for M1 is gone


setUp1 &lt;- createBayesianSetup(likelihood1, 
                              lower = c(-500,-500,-500,0.01), 
                              upper = c(500,500,500,3000))
setUp2 &lt;- createBayesianSetup(likelihood2, 
                              lower = c(-500,-500,0.01), 
                              upper = c(500,500,3000))

out1 &lt;- runMCMC(bayesianSetup = setUp1)
M1 = marginalLikelihood(out1, start = 1000)

out2 &lt;- runMCMC(bayesianSetup = setUp2)
M2 = marginalLikelihood(out2, start = 1000)


### Calculating Bayes factor

exp(M1$ln.ML - M2$ln.ML)

# it has therefore been suggested that ML should not be calculated on uninformative priors. But
# what to do if there are no informative priors?
# one option is to calculate the fractional BF, which means that one splites the data in half,
# uses the first half to fit the model, and then use the posterior as a new (now informative)
# prior for the ML - let's do this for the previous case


# likelihoods with half the data 
likelihood1 &lt;- function(param){
  pred = param[1] + param[2]*x + param[3] * x^2
  singlelikelihoods = dnorm(y, mean = pred, sd = 1/(param[4]^2), log = TRUE)
  return(sum(singlelikelihoods[seq(1, 30, 2)]))  
}
likelihood2 &lt;- function(param){
  pred = param[1] + param[2]*x 
  singlelikelihoods = dnorm(y, mean = pred, sd = 1/(param[3]^2), log = TRUE)
  return(sum(singlelikelihoods[seq(1, 30, 2)]))  
}

setUp1 &lt;- createBayesianSetup(likelihood1, 
                              lower = c(-500,-500,-500,0.01), 
                              upper = c(500,500,500,3000))
setUp2 &lt;- createBayesianSetup(likelihood2, 
                              lower = c(-500,-500,0.01), 
                              upper = c(500,500,3000))

out1 &lt;- runMCMC(bayesianSetup = setUp1)
out2 &lt;- runMCMC(bayesianSetup = setUp2)

newPrior1 = createPriorDensity(out1, start = 200, 
                               lower = c(-500,-500,-500,0.01), 
                               upper = c(500,500,500,3000))
newPrior2 = createPriorDensity(out2, start = 200, 
                               lower = c(-500,-500,0.01), 
                               upper = c(500,500,3000))

# now rerun this with likelihoods for the other half of the data and new prior

likelihood1 &lt;- function(param){
  pred = param[1] + param[2]*x + param[3] * x^2
  singlelikelihoods = dnorm(y, mean = pred, sd = 1/(param[4]^2), log = TRUE)
  return(sum(singlelikelihoods[seq(2, 30, 2)]))  
}
likelihood2 &lt;- function(param){
  pred = param[1] + param[2]*x 
  singlelikelihoods = dnorm(y, mean = pred, sd = 1/(param[3]^2), log = TRUE)
  return(sum(singlelikelihoods[seq(2, 30, 2)]))  
}

setUp1 &lt;- createBayesianSetup(likelihood1, prior = newPrior1)
setUp2 &lt;- createBayesianSetup(likelihood2, prior = newPrior2)

out1 &lt;- runMCMC(bayesianSetup = setUp1)
M1 = marginalLikelihood(out1, start = 1000)

out2 &lt;- runMCMC(bayesianSetup = setUp2)
M2 = marginalLikelihood(out2, start = 1000)

### Calculating the fractional Bayes factor

exp(M1$ln.ML - M2$ln.ML)


## End(Not run)

############################################################
### Performance comparison ### 


# Low dimensional case with narrow priors - all methods have low error

# we use a truncated normal for the likelihood to make sure that the density 
# integrates to 1 - makes it easier to calcuate the theoretical ML
likelihood &lt;- function(x) sum(msm::dtnorm(x, log = TRUE, lower = -1, upper = 1))
prior = createUniformPrior(lower = rep(-1,2), upper = rep(1,2))
bayesianSetup &lt;- createBayesianSetup(likelihood = likelihood, prior = prior)
out = runMCMC(bayesianSetup = bayesianSetup, settings = list(iterations = 5000))

# plot(out)

# theoretical value
theory = log(1/(2^2))

marginalLikelihood(out)$ln.ML - theory
marginalLikelihood(out, method = "Prior", numSamples =  500)$ln.ML - theory
marginalLikelihood(out, method = "HM", numSamples =  500)$ln.ML - theory
marginalLikelihood(out, method = "Bridge", numSamples =  500)$ln.ML - theory


# higher dimensions - wide prior - HM and Prior don't work

likelihood &lt;- function(x) sum(msm::dtnorm(x, log = TRUE, lower = -10, upper = 10))
prior = createUniformPrior(lower = rep(-10,3), upper = rep(10,3))
bayesianSetup &lt;- createBayesianSetup(likelihood = likelihood, prior = prior)
out = runMCMC(bayesianSetup = bayesianSetup, settings = list(iterations = 5000))

# plot(out)

# theoretical value
theory = log(1/(20^3))

marginalLikelihood(out)$ln.ML - theory
marginalLikelihood(out, method = "Prior", numSamples =  500)$ln.ML - theory
marginalLikelihood(out, method = "HM", numSamples =  500)$ln.ML - theory
marginalLikelihood(out, method = "Bridge", numSamples =  500)$ln.ML - theory



</code></pre>

<hr>
<h2 id='marginalPlot'>Plot MCMC marginals</h2><span id='topic+marginalPlot'></span>

<h3>Description</h3>

<p>Plot MCMC marginals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalPlot(
  x,
  prior = NULL,
  xrange = NULL,
  type = "d",
  singlePanel = FALSE,
  settings = NULL,
  nPriorDraws = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalPlot_+3A_x">x</code></td>
<td>
<p>bayesianOutput, or matrix or data.frame containing with samples as rows and parameters as columns</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_prior">prior</code></td>
<td>
<p>if x is a bayesianOutput, T/F will determine if the prior is drawn (default = T). If x is matrix oder data.frame, a prior can be drawn if a matrix of prior draws with values as rows and parameters as columns can be provided here.</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_xrange">xrange</code></td>
<td>
<p>vector or matrix of plotting ranges for the x axis. If matrix, the rows must be parameters and the columns min and max values.</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_type">type</code></td>
<td>
<p>character determining the plot type. Either 'd' for density plot, or 'v' for violin plot</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_singlepanel">singlePanel</code></td>
<td>
<p>logical, determining whether the parameter should be plotted in a single panel or each in its own panel</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_settings">settings</code></td>
<td>
<p>optional list of additional settings for <code><a href="#topic+marginalPlotDensity">marginalPlotDensity</a></code>, and <code><a href="#topic+marginalPlotViolin">marginalPlotViolin</a></code>, respectively</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_npriordraws">nPriorDraws</code></td>
<td>
<p>number of draws from the prior, if x is bayesianOutput</p>
</td></tr>
<tr><td><code id="marginalPlot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+getSample">getSample</a></code>. If you have a high number of draws from the posterior it is advised to set numSamples (to e.g. 5000) for performance reasons.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tankred Ott, Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a test likelihood function. 
ll &lt;- generateTestDensityMultiNormal(sigma = "no correlation")

## Create a BayesianSetup
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, lower = rep(-10, 3), upper = rep(10, 3))

## Finally we can run the sampler and have a look
settings = list(iterations = 1000, adapt = FALSE)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)

marginalPlot(out, prior = TRUE)

## We can plot the marginals in several ways:
## violin plots
marginalPlot(out, type = 'v', singlePanel = TRUE) 
marginalPlot(out, type = 'v', singlePanel = FALSE)
marginalPlot(out, type = 'v', singlePanel = TRUE, prior = TRUE)

## density plot
marginalPlot(out, type = 'd', singlePanel = TRUE) 
marginalPlot(out, type = 'd', singlePanel = FALSE)
marginalPlot(out, type = 'd', singlePanel = TRUE, prior = TRUE)

## if you have a very wide prior you can use the xrange option to plot only
## a certain parameter range
marginalPlot(out, type = 'v', singlePanel = TRUE, xrange = matrix(rep(c(-5, 5), 3), ncol = 3))

##Further options
# We can pass arguments to getSample (check ?getSample) and to the density and violin plots
marginalPlot(out, type = 'v', singlePanel = TRUE, 
             settings = list(col = c('#FC006299','#00BBAA88')), prior = TRUE)
marginalPlot(out, type = 'v', singlePanel = TRUE, numSamples = 500)
</code></pre>

<hr>
<h2 id='marginalPlotDensity'>Plot marginals as densities</h2><span id='topic+marginalPlotDensity'></span>

<h3>Description</h3>

<p>Plot marginals as densities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalPlotDensity(
  posteriorMat,
  priorMat = NULL,
  xrange = NULL,
  col = c("#FC006299", "#00BBAA30"),
  singlePanel = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalPlotDensity_+3A_posteriormat">posteriorMat</code></td>
<td>
<p>matrix with samples as rows and parameters as columns</p>
</td></tr>
<tr><td><code id="marginalPlotDensity_+3A_priormat">priorMat</code></td>
<td>
<p>matrix (optional) with samples as rows and parameters as columns</p>
</td></tr>
<tr><td><code id="marginalPlotDensity_+3A_xrange">xrange</code></td>
<td>
<p>vector or matrix (optional), determining the plotting range, with parameters as columns and min, max as rows</p>
</td></tr>
<tr><td><code id="marginalPlotDensity_+3A_col">col</code></td>
<td>
<p>vector of colors for posterior and</p>
</td></tr>
<tr><td><code id="marginalPlotDensity_+3A_singlepanel">singlePanel</code></td>
<td>
<p>logical, determining whether the parameter should be plotted in a single panel or each in its own panel</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tankred Ott
</p>

<hr>
<h2 id='marginalPlotViolin'>Plot marginals as violin plot</h2><span id='topic+marginalPlotViolin'></span>

<h3>Description</h3>

<p>Plot marginals as violin plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginalPlotViolin(
  posteriorMat,
  priorMat = NULL,
  xrange = NULL,
  col = c("#FC006299", "#00BBAA88"),
  singlePanel = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginalPlotViolin_+3A_posteriormat">posteriorMat</code></td>
<td>
<p>matrix with samples as rows and parameters as columns</p>
</td></tr>
<tr><td><code id="marginalPlotViolin_+3A_priormat">priorMat</code></td>
<td>
<p>matrix (optional) with samples as rows and parameters as columns</p>
</td></tr>
<tr><td><code id="marginalPlotViolin_+3A_xrange">xrange</code></td>
<td>
<p>vector or matrix (optional), determining the plotting range, with parameters as columns and min, max as rows</p>
</td></tr>
<tr><td><code id="marginalPlotViolin_+3A_col">col</code></td>
<td>
<p>vector of colors for posterior and</p>
</td></tr>
<tr><td><code id="marginalPlotViolin_+3A_singlepanel">singlePanel</code></td>
<td>
<p>logical, determining whether the parameter should be plotted in a single panel or each in its own panel</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tankred Ott
</p>

<hr>
<h2 id='mcmcMultipleChains'>Run multiple chains</h2><span id='topic+mcmcMultipleChains'></span>

<h3>Description</h3>

<p>Run multiple chains
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcMultipleChains(bayesianSetup, settings, sampler)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcMultipleChains_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>Object of class &quot;BayesianSetup&quot;</p>
</td></tr>
<tr><td><code id="mcmcMultipleChains_+3A_settings">settings</code></td>
<td>
<p>list with settings for sampler</p>
</td></tr>
<tr><td><code id="mcmcMultipleChains_+3A_sampler">sampler</code></td>
<td>
<p>character, either &quot;Metropolis&quot; or &quot;DE&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the single runs ($sampler) and the chains in a coda::mcmc.list ($mcmc.list)
</p>

<hr>
<h2 id='mergeChains'>Merge Chains</h2><span id='topic+mergeChains'></span>

<h3>Description</h3>

<p>Merge a list of outputs from MCMC / SMC samplers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeChains(l, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeChains_+3A_l">l</code></td>
<td>
<p>a list with objects that can be accessed with <code><a href="#topic+getSample">getSample</a></code></p>
</td></tr>
<tr><td><code id="mergeChains_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to <code><a href="#topic+getSample">getSample</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function merges a list of outputs from MCMC / SMC samplers into a single matrix. Requirement is that the list contains classes for which the <code><a href="#topic+getSample">getSample</a></code> function works
</p>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='Metropolis'>Creates a Metropolis-type MCMC with options for covariance adaptatin, delayed rejection, Metropolis-within-Gibbs, and tempering</h2><span id='topic+Metropolis'></span>

<h3>Description</h3>

<p>Creates a Metropolis-type MCMC with options for covariance adaptatin, delayed rejection, Metropolis-within-Gibbs, and tempering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Metropolis(
  bayesianSetup,
  settings = list(startValue = NULL, optimize = T, proposalGenerator = NULL,
    consoleUpdates = 100, burnin = 0, thin = 1, parallel = NULL, adapt = T,
    adaptationInterval = 500, adaptationNotBefore = 3000, DRlevels = 1, proposalScaling =
    NULL, adaptationDepth = NULL, temperingFunction = NULL, gibbsProbabilities = NULL,
    message = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Metropolis_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>either an object of class bayesianSetup created by <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code> (recommended), or a log target function</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_settings">settings</code></td>
<td>
<p>a list of settings - possible options follow below</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_startvalue">startValue</code></td>
<td>
<p>startValue for the MCMC and optimization (if optimize = T). If not provided, the sampler will attempt to obtain the startValue from the bayesianSetup</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_optimize">optimize</code></td>
<td>
<p>logical, determines whether an optimization for start values and proposal function should be run before starting the sampling</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_proposalgenerator">proposalGenerator</code></td>
<td>
<p>optional proposalgenerator object (see <code><a href="#topic+createProposalGenerator">createProposalGenerator</a></code>)</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_proposalscaling">proposalScaling</code></td>
<td>
<p>additional scaling parameter for the proposals that controls the different scales of the proposals after delayed rejection (typical, after a rejection, one would want to try a smaller scale). Needs to be as long as DRlevels. Defaults to 0.5^(- 0:(mcmcSampler$settings$DRlevels -1)</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations treated as burn-in. These iterations are not recorded in the chain.</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_thin">thin</code></td>
<td>
<p>thinning parameter. Determines the interval in which values are recorded.</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_consoleupdates">consoleUpdates</code></td>
<td>
<p>integer, determines the frequency with which sampler progress is printed to the console</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_adapt">adapt</code></td>
<td>
<p>logical, determines wheter an adaptive algorithm should be implemented. Default is TRUE.</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_adaptationinterval">adaptationInterval</code></td>
<td>
<p>integer, determines the interval  of the adaption if adapt = TRUE.</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_adaptationnotbefore">adaptationNotBefore</code></td>
<td>
<p>integer, determines the start value for the adaption if adapt = TRUE.</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_drlevels">DRlevels</code></td>
<td>
<p>integer, determines the number of levels for a delayed rejection sampler. Default is 1, which means no delayed rejection is used.</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_temperingfunction">temperingFunction</code></td>
<td>
<p>function to implement simulated tempering in the algorithm. The function describes how the acceptance rate will be influenced in the course of the iterations.</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_gibbsprobabilities">gibbsProbabilities</code></td>
<td>
<p>vector that defines the relative probabilities of the number of parameters to be changes simultaniously.</p>
</td></tr>
<tr><td><code id="Metropolis_+3A_message">message</code></td>
<td>
<p>logical determines whether the sampler's progress should be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'Metropolis' function is the main function for all Metropolis based samplers in this package. To call the derivatives from the basic Metropolis-Hastings MCMC, you can either use the corresponding function (e.g. <code><a href="#topic+AM">AM</a></code> for an adaptive Metropolis sampler) or use the parameters to adapt the basic Metropolis-Hastings. The advantage of the latter case is that you can easily combine different properties (e.g. adapive sampling and delayed rejection sampling) without changing the function.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>References</h3>

<p>Haario, H., E. Saksman, and J. Tamminen (2001). An adaptive metropolis algorithm. Bernoulli , 223-242.
</p>
<p>Haario, Heikki, et al. &quot;DRAM: efficient adaptive MCMC.&quot; Statistics and Computing 16.4 (2006): 339-354.
</p>
<p>Hastings, W. K. (1970). Monte carlo sampling methods using markov chains and their applications. Biometrika 57 (1), 97-109.
</p>
<p>Green, Peter J., and Antonietta Mira. &quot;Delayed rejection in reversible jump Metropolis-Hastings.&quot; Biometrika (2001): 1035-1053.
</p>
<p>Metropolis, N., A. W. Rosenbluth, M. N. Rosenbluth, A. H. Teller, and E. Teller (1953). Equation of state calculations by fast computing machines. The journal of chemical physics 21 (6), 1087 - 1092.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Running the metropolis via the runMCMC with a proposal covariance generated from the prior 
# (can be useful for complicated priors)

ll = function(x) sum(dnorm(x, log = TRUE))
setup = createBayesianSetup(ll, lower = c(-10,-10), upper = c(10,10))

samples = setup$prior$sampler(1000)

generator = createProposalGenerator(diag(1, setup$numPars))
generator = updateProposalGenerator(generator, samples, manualScaleAdjustment = 1, message = TRUE)

settings =  list(proposalGenerator = generator, optimize = FALSE, iterations = 500)  

out = runMCMC(bayesianSetup = setup, sampler = "Metropolis", settings = settings)
</code></pre>

<hr>
<h2 id='metropolisRatio'>Function to calculate the metropolis ratio</h2><span id='topic+metropolisRatio'></span>

<h3>Description</h3>

<p>Function to calculate the metropolis ratio
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metropolisRatio(LP2, LP1, tempering = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metropolisRatio_+3A_lp2">LP2</code></td>
<td>
<p>log posterior old position</p>
</td></tr>
<tr><td><code id="metropolisRatio_+3A_lp1">LP1</code></td>
<td>
<p>log posterior of proposal</p>
</td></tr>
<tr><td><code id="metropolisRatio_+3A_tempering">tempering</code></td>
<td>
<p>value for tempering</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='plotDiagnostic'>Diagnostic Plot</h2><span id='topic+plotDiagnostic'></span>

<h3>Description</h3>

<p>This function plots the DIC, WAIC, mPSRF, PSRF(with upper C.I.) and traces of the parameters in dependence of iterations. DIC, WAIC are plotted separately for the chains and the trace plots also for the internal chains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDiagnostic(
  out,
  start = 50,
  numSamples = 100,
  window = 0.2,
  plotWAIC = F,
  plotPSRF = T,
  plotDIC = T,
  plotTrace = T,
  graphicParameters = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDiagnostic_+3A_out">out</code></td>
<td>
<p>object of class &quot;bayesianOutput&quot;</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_start">start</code></td>
<td>
<p>start value for calculating DIC, WAIC, mPSRF and PSRF, default = 50</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_numsamples">numSamples</code></td>
<td>
<p>for calculating WAIC, default = 10 because of high computational costs</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_window">window</code></td>
<td>
<p>plot range to show, vector of percents or only one value as start value for the window</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_plotwaic">plotWAIC</code></td>
<td>
<p>whether to calculate WAIC or not, default = T</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_plotpsrf">plotPSRF</code></td>
<td>
<p>calculate and plot mPSRF/PSRF or not, default = T</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_plotdic">plotDIC</code></td>
<td>
<p>calculate and plot DICor not, default = T</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_plottrace">plotTrace</code></td>
<td>
<p>show trace plots or not, default = T</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_graphicparameters">graphicParameters</code></td>
<td>
<p>graphic parameters as list for plot function</p>
</td></tr>
<tr><td><code id="plotDiagnostic_+3A_...">...</code></td>
<td>
<p>parameters to give to getSample</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maximilian Pichler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
  # Create bayesian setup with  
  bayesianSetup &lt;- createBayesianSetup(likelihood = testDensityNormal, 
                                       prior = createUniformPrior(lower = -10,
                                                                  upper = 10))
  # running MCMC
  out = runMCMC(bayesianSetup = bayesianSetup)
  
  # diagnostic plots
  plotDiagnostic(out)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotSensitivity'>Performs a one-factor-at-a-time sensitivity analysis for the posterior of a given bayesianSetup within the prior range.</h2><span id='topic+plotSensitivity'></span>

<h3>Description</h3>

<p>Performs a one-factor-at-a-time sensitivity analysis for the posterior of a given bayesianSetup within the prior range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSensitivity(bayesianSetup, selection = NULL, equalScale = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSensitivity_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>An object of class BayesianSetup</p>
</td></tr>
<tr><td><code id="plotSensitivity_+3A_selection">selection</code></td>
<td>
<p>indices of selected parameters</p>
</td></tr>
<tr><td><code id="plotSensitivity_+3A_equalscale">equalScale</code></td>
<td>
<p>if T, y axis of all plots will have the same scale</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function can also be used for sensitivity analysis of an arbitrary output - just create a BayesianSetup with this output.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ll &lt;- testDensityBanana
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, lower = rep(-10, 2), upper = rep(10, 2))

plotSensitivity(bayesianSetup)
</code></pre>

<hr>
<h2 id='plotTimeSeries'>Plots a time series, with the option to include confidence and prediction band</h2><span id='topic+plotTimeSeries'></span>

<h3>Description</h3>

<p>Plots a time series, with the option to include confidence and prediction band
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTimeSeries(
  observed = NULL,
  predicted = NULL,
  x = NULL,
  confidenceBand = NULL,
  predictionBand = NULL,
  xlab = "Time",
  ylab = "Observed / predicted values",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTimeSeries_+3A_observed">observed</code></td>
<td>
<p>observed values</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_predicted">predicted</code></td>
<td>
<p>predicted values</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_x">x</code></td>
<td>
<p>optional values for x axis (time)</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_confidenceband">confidenceBand</code></td>
<td>
<p>matrix with confidenceBand</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_predictionband">predictionBand</code></td>
<td>
<p>matrix with predictionBand</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_xlab">xlab</code></td>
<td>
<p>a title for the x axis</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_ylab">ylab</code></td>
<td>
<p>a title for the y axis</p>
</td></tr>
<tr><td><code id="plotTimeSeries_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values for confidence and prediction bands can be generated with <code><a href="#topic+getPredictiveIntervals">getPredictiveIntervals</a></code>. For a more elaborate version of this plot, see <code><a href="#topic+plotTimeSeriesResults">plotTimeSeriesResults</a></code>
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+marginalPlot">marginalPlot</a></code>, <code><a href="#topic+tracePlot">tracePlot</a></code>, <code><a href="#topic+correlationPlot">correlationPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create time series
ts &lt;- VSEMcreatePAR(1:100)

# create fake "predictions"
pred &lt;- ts + rnorm(length(ts), mean = 0, sd = 2)

# plot time series
par(mfrow=c(1,2))

plotTimeSeries(observed = ts, main="Observed")
plotTimeSeries(observed = ts, predicted = pred, main = "Observed and predicted")

par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='plotTimeSeriesResiduals'>Plots residuals of a time series</h2><span id='topic+plotTimeSeriesResiduals'></span>

<h3>Description</h3>

<p>Plots residuals of a time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTimeSeriesResiduals(residuals, x = NULL, main = "residuals")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTimeSeriesResiduals_+3A_residuals">residuals</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="plotTimeSeriesResiduals_+3A_x">x</code></td>
<td>
<p>optional values for x axis (time)</p>
</td></tr>
<tr><td><code id="plotTimeSeriesResiduals_+3A_main">main</code></td>
<td>
<p>title of the plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='plotTimeSeriesResults'>Creates a time series plot typical for an MCMC / SMC fit</h2><span id='topic+plotTimeSeriesResults'></span>

<h3>Description</h3>

<p>Creates a time series plot typical for an MCMC / SMC fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTimeSeriesResults(
  sampler,
  model,
  observed,
  error = NULL,
  plotResiduals = TRUE,
  start = 1,
  prior = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTimeSeriesResults_+3A_sampler">sampler</code></td>
<td>
<p>Either a) a matrix b) an MCMC object (list or not), or c) an SMC object</p>
</td></tr>
<tr><td><code id="plotTimeSeriesResults_+3A_model">model</code></td>
<td>
<p>function that calculates model predictions for a given parameter vector</p>
</td></tr>
<tr><td><code id="plotTimeSeriesResults_+3A_observed">observed</code></td>
<td>
<p>observed values as vector</p>
</td></tr>
<tr><td><code id="plotTimeSeriesResults_+3A_error">error</code></td>
<td>
<p>function with signature f(mean, par) that generates observations with error (error = stochasticity according to what is assumed in the likelihood) from mean model predictions. Par is a vector from the matrix with the parameter samples (full length). f needs to know which of these parameters are parameters of the error function. See example in <code><a href="#topic+VSEM">VSEM</a></code></p>
</td></tr>
<tr><td><code id="plotTimeSeriesResults_+3A_plotresiduals">plotResiduals</code></td>
<td>
<p>logical determining whether residuals should be plotted</p>
</td></tr>
<tr><td><code id="plotTimeSeriesResults_+3A_start">start</code></td>
<td>
<p>numeric start value for the plot (see <code><a href="#topic+getSample">getSample</a></code>)</p>
</td></tr>
<tr><td><code id="plotTimeSeriesResults_+3A_prior">prior</code></td>
<td>
<p>if a prior sampler is implemented, setting this parameter to TRUE will draw model parameters from the prior instead of the posterior distribution</p>
</td></tr>
<tr><td><code id="plotTimeSeriesResults_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getPredictiveIntervals">getPredictiveIntervals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create time series
ts &lt;- VSEMcreatePAR(1:100)

# create fake "predictions"
pred &lt;- ts + rnorm(length(ts), mean = 0, sd = 2)

# plot time series
par(mfrow=c(1,2))

plotTimeSeries(observed = ts, main="Observed")
plotTimeSeries(observed = ts, predicted = pred, main = "Observed and predicted")

par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='propFun'>Helper function to create proposal</h2><span id='topic+propFun'></span>

<h3>Description</h3>

<p>Helper function to create proposal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propFun(case, Npar, pn1, x, x2, beta = NULL, aw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propFun_+3A_case">case</code></td>
<td>
<p>Type of Twalk move. Either &quot;walk&quot;, &quot;traverse&quot;, &quot;hop&quot; or &quot;blow&quot;</p>
</td></tr>
<tr><td><code id="propFun_+3A_npar">Npar</code></td>
<td>
<p>number of parameters</p>
</td></tr>
<tr><td><code id="propFun_+3A_pn1">pn1</code></td>
<td>
<p>Probability determining the number of parameters that are changed.</p>
</td></tr>
<tr><td><code id="propFun_+3A_x">x</code></td>
<td>
<p>parameter vector of chain 1</p>
</td></tr>
<tr><td><code id="propFun_+3A_x2">x2</code></td>
<td>
<p>parameter vector of chain 2</p>
</td></tr>
<tr><td><code id="propFun_+3A_beta">beta</code></td>
<td>
<p>parameter for &quot;traverse&quot; move proposals.</p>
</td></tr>
<tr><td><code id="propFun_+3A_aw">aw</code></td>
<td>
<p>&quot;walk&quot; move proposal parameter.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Christen, J. Andres, and Colin Fox. &quot;A general purpose sampling algorithm for continuous distributions (the t-walk).&quot; Bayesian Analysis 5.2 (2010): 263-281.
</p>

<hr>
<h2 id='rescale'>Rescale</h2><span id='topic+rescale'></span>

<h3>Description</h3>

<p>Rescales values in the interval &quot;from&quot; (lower, upper) to the new interval &quot;to&quot; (lower, upper).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(x, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>
<p>vector of values tp be scaled</p>
</td></tr>
<tr><td><code id="rescale_+3A_from">from</code></td>
<td>
<p>vector of length 2, original interval (lower, upper)</p>
</td></tr>
<tr><td><code id="rescale_+3A_to">to</code></td>
<td>
<p>vector of length 2, target interval (lower, upper)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tankred Ott
</p>

<hr>
<h2 id='runMCMC'>Main wrapper function to start MCMCs, particle MCMCs and SMCs</h2><span id='topic+runMCMC'></span>

<h3>Description</h3>

<p>Main wrapper function to start MCMCs, particle MCMCs and SMCs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runMCMC(bayesianSetup, sampler = "DEzs", settings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runMCMC_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>either a BayesianSetup (see <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code>), a function, or a BayesianOutput created by runMCMC. The latter allows to continue a previous MCMC run. See details for how to restart a sampler.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_sampler">sampler</code></td>
<td>
<p>sampling algorithm to be run. Default is DEzs. Options are &quot;Metropolis&quot;, &quot;AM&quot;, &quot;DR&quot;, &quot;DRAM&quot;, &quot;DE&quot;, &quot;DEzs&quot;, &quot;DREAM&quot;, &quot;DREAMzs&quot;, &quot;SMC&quot;. For details see the help of the individual functions.</p>
</td></tr>
<tr><td><code id="runMCMC_+3A_settings">settings</code></td>
<td>
<p>list with settings for each sampler. If a setting is not provided, defaults (see <code><a href="#topic+applySettingsDefault">applySettingsDefault</a></code>) will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The runMCMC function can be started with either one of
</p>

<ol>
<li><p> an object of class BayesianSetup with prior and likelihood function (created with <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code>). check if appropriate parallelization options are used - many samplers can make use of parallelization if this option is activated when the class is created.
</p>
</li>
<li><p> a log posterior or other target function,
</p>
</li>
<li><p> an object of class BayesianOutput created by runMCMC. The latter allows to continue a previous MCMC run.
</p>
</li></ol>

<p>Settings for the sampler are provides as a list. You can see the default values by running <code><a href="#topic+applySettingsDefault">applySettingsDefault</a></code> with the respective sampler name. The following settings can be used for all MCMCs:
</p>

<ul>
<li><p> startValue (no default) start values for the MCMC. Note that DE family samplers require a matrix of start values. If startvalues are not provided, they are sampled from the prior.
</p>
</li>
<li><p> iterations (10000) the MCMC iterations
</p>
</li>
<li><p> burnin (0) burnin
</p>
</li>
<li><p> thin (1) thinning while sampling
</p>
</li>
<li><p> consoleUpdates (100) update frequency for console updates
</p>
</li>
<li><p> parallel (NULL) whether parallelization is to be used
</p>
</li>
<li><p> message (TRUE) if progress messages are to be printed
</p>
</li>
<li><p> nrChains (1) the number of independent MCMC chains to be run. Note that this is not controlling the internal number of chains in population MCMCs such as DE, so if you run nrChains = 3 with a DEzs startValue that is a 4xparameter matrix (= 4 internal chains), you will run independent DEzs runs with 4 internal chains each.
</p>
</li></ul>

<p>The MCMC samplers will have a number of additional settings, which are described in the Vignette (run vignette(&quot;BayesianTools&quot;, package=&quot;BayesianTools&quot;) and in the help of the samplers. See <code><a href="#topic+Metropolis">Metropolis</a></code> for Metropolis based samplers, <code><a href="#topic+DE">DE</a></code> and <code><a href="#topic+DEzs">DEzs</a></code> for standard differential evolution samplers, <code><a href="#topic+DREAM">DREAM</a></code> and <code><a href="#topic+DREAMzs">DREAMzs</a></code> for DREAM sampler, <code><a href="#topic+Twalk">Twalk</a></code> for the Twalk sampler, and <code><a href="#topic+smcSampler">smcSampler</a></code> for rejection and Sequential Monte Carlo sampling. Note that the samplers &quot;AM&quot;, &quot;DR&quot;, and &quot;DRAM&quot; are special cases of the &quot;Metropolis&quot; sampler and are shortcuts for predefined settings (&quot;AM&quot;: adapt=TRUE; &quot;DR&quot;: DRlevels=2; &quot;DRAM&quot;: adapt=True, DRlevels=2).
</p>
<p>Note that even if you specify parallel = T, this will only turn on internal parallelization of the samplers. The independent samplers controlled by nrChains are not evaluated in parallel, so if time is an issue it will be better to run the MCMCs individually and then combine them via <code><a href="#topic+createMcmcSamplerList">createMcmcSamplerList</a></code> into one joint object.
</p>
<p>Note that DE and DREAM variants as well as SMC and T-walk require a population to start, which should be provided as a matrix. Default (NULL) sets the population size for DE to 3 x dimensions of parameters, for DREAM to 2 x dimensions of parameters and for DEzs and DREAMzs to three, sampled from the prior. Note also that the zs variants of DE and DREAM require two populations, the current population and the z matrix (a kind of memory) - if you want to set both, provide a list with startvalue$X and startvalue$Z.
</p>
<p>setting startValue for sampling with nrChains &gt; 1 : if you want to provide different start values for the different chains, provide them as a list
</p>


<h3>Value</h3>

<p>The function returns an object of class mcmcSampler (if one chain is run) or mcmcSamplerList. Both have the superclass bayesianOutput. It is possible to extract the samples as a coda object or matrix with <code><a href="#topic+getSample">getSample</a></code>.
It is also possible to summarize the posterior as a new prior via <code><a href="#topic+createPriorDensity">createPriorDensity</a></code>.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a test likelihood function. 
ll &lt;- generateTestDensityMultiNormal(sigma = "no correlation")

## Create a BayesianSetup object from the likelihood 
## is the recommended way of using the runMCMC() function.
bayesianSetup &lt;- createBayesianSetup(likelihood = ll, lower = rep(-10, 3), upper = rep(10, 3))

## Finally we can run the sampler and have a look
settings = list(iterations = 1000, adapt = FALSE)
out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "Metropolis", settings = settings)

## out is of class bayesianOutput. There are various standard functions 
# implemented for this output

plot(out)
correlationPlot(out)
marginalPlot(out)
summary(out)

## additionally, you can return the sample as a coda object, and make use of the coda functions
# for plotting and analysis

codaObject = getSample(out, start = 500, coda = TRUE)
</code></pre>

<hr>
<h2 id='sampleEquallySpaced'>Gets n equally spaced samples (rows) from a matrix or vector</h2><span id='topic+sampleEquallySpaced'></span>

<h3>Description</h3>

<p>Gets n equally spaced samples (rows) from a matrix or vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleEquallySpaced(x, numSamples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleEquallySpaced_+3A_x">x</code></td>
<td>
<p>matrix or vector</p>
</td></tr>
<tr><td><code id="sampleEquallySpaced_+3A_numsamples">numSamples</code></td>
<td>
<p>number of samples (rows) to be drawn</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gets n equally spaced samples (rows) from a matrix and returns a new matrix (or vector) containing those samples
</p>


<h3>Author(s)</h3>

<p>Tankred Ott
</p>

<hr>
<h2 id='sampleMetropolis'>gets samples while adopting the MCMC proposal generator</h2><span id='topic+sampleMetropolis'></span>

<h3>Description</h3>

<p>Function to sample with cobinations of the basic Metropolis-Hastings MCMC algorithm (Metropolis et al., 1953), a variation of the adaptive Metropolis MCMC (Haario et al., 2001), the delayed rejection algorithm (Tierney &amp; Mira, 1999), and the delayed rejection adaptive Metropolis algorithm (DRAM, Haario et al), and the Metropolis within Gibbs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleMetropolis(mcmcSampler, iterations)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleMetropolis_+3A_mcmcsampler">mcmcSampler</code></td>
<td>
<p>an mcmcSampler</p>
</td></tr>
<tr><td><code id="sampleMetropolis_+3A_iterations">iterations</code></td>
<td>
<p>iterations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='scaleMatrix'>Function to scale matrices</h2><span id='topic+scaleMatrix'></span>

<h3>Description</h3>

<p>Function to scale matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleMatrix(mat, min, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleMatrix_+3A_mat">mat</code></td>
<td>
<p>matrix to scale</p>
</td></tr>
<tr><td><code id="scaleMatrix_+3A_min">min</code></td>
<td>
<p>minimum value</p>
</td></tr>
<tr><td><code id="scaleMatrix_+3A_max">max</code></td>
<td>
<p>maximum value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sclaed matrix
</p>

<hr>
<h2 id='setupStartProposal'>Help function to find starvalues and proposalGenerator settings</h2><span id='topic+setupStartProposal'></span>

<h3>Description</h3>

<p>Help function to find starvalues and proposalGenerator settings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setupStartProposal(proposalGenerator = NULL, bayesianSetup, settings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setupStartProposal_+3A_proposalgenerator">proposalGenerator</code></td>
<td>
<p>proposal generator</p>
</td></tr>
<tr><td><code id="setupStartProposal_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>either an object of class bayesianSetup created by <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code> (recommended), or a log target function</p>
</td></tr>
<tr><td><code id="setupStartProposal_+3A_settings">settings</code></td>
<td>
<p>list with settings</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='smcSampler'>SMC sampler</h2><span id='topic+smcSampler'></span>

<h3>Description</h3>

<p>Sequential Monte Carlo Sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smcSampler(
  bayesianSetup,
  initialParticles = 1000,
  iterations = 10,
  resampling = T,
  resamplingSteps = 2,
  proposal = NULL,
  adaptive = T,
  proposalScale = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smcSampler_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>either an object of class bayesianSetup created by <code><a href="#topic+createBayesianSetup">createBayesianSetup</a></code> (recommended), or a log target function</p>
</td></tr>
<tr><td><code id="smcSampler_+3A_initialparticles">initialParticles</code></td>
<td>
<p>initial particles - either a draw from the prior, provided as a matrix with the single parameters as columns and each row being one particle (parameter vector), or a numeric value with the number of desired particles. In this case, the sampling option must be provided in the prior of the BayesianSetup.</p>
</td></tr>
<tr><td><code id="smcSampler_+3A_iterations">iterations</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="smcSampler_+3A_resampling">resampling</code></td>
<td>
<p>if new particles should be created at each iteration</p>
</td></tr>
<tr><td><code id="smcSampler_+3A_resamplingsteps">resamplingSteps</code></td>
<td>
<p>how many resampling (MCMC) steps between the iterations</p>
</td></tr>
<tr><td><code id="smcSampler_+3A_proposal">proposal</code></td>
<td>
<p>optional proposal class</p>
</td></tr>
<tr><td><code id="smcSampler_+3A_adaptive">adaptive</code></td>
<td>
<p>should the covariance of the proposal be adapted during sampling</p>
</td></tr>
<tr><td><code id="smcSampler_+3A_proposalscale">proposalScale</code></td>
<td>
<p>scaling factor for the proposal generation. Can be adapted if there is too much / too little rejection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampler can be used for rejection sampling as well as for sequential Monte Carlo. For the former case set the iterations to one.
</p>


<h3>Note</h3>

<p>The SMC currently assumes that the initial particle is sampled from the prior. If a better initial estimate of the posterior distribution is available, this the sampler should be modified to include this. Currently, however, this is not included in the code, so the appropriate adjustments have to be done by hand.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example for the use of SMC 
# First we need a bayesianSetup - SMC makes most sense if we can  for demonstration,
# we'll write a function that puts out the number of model calls

MultiNomialNoCor &lt;- generateTestDensityMultiNormal(sigma = "no correlation")

parallelLL &lt;- function(parMatrix){
  print(paste("Calling likelihood with", nrow(parMatrix), "parameter combinations"))
  out = apply(parMatrix, 1, MultiNomialNoCor)
  return(out)
}

bayesianSetup &lt;- createBayesianSetup(likelihood = parallelLL, lower = rep(-10, 3),
                                     upper = rep(10, 3), parallel = "external")

# Defining settings for the sampler
# First we use the sampler for rejection sampling
settings &lt;- list(initialParticles = 1000, iterations = 1, resampling = FALSE)  
   
# Running the sampler
out1 &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "SMC", settings = settings)
#plot(out1)


# Now for sequential Monte Carlo
settings &lt;- list(initialParticles = 100, iterations = 5, resamplingSteps = 1)
out2 &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "SMC", settings = settings)
#plot(out2)

## Not run: 

## Example for starting a new SMC run with results from a previous SMC run

# Generate example data (time series)
# x1 and x2 are predictory, yObs is the response
t &lt;- seq(1, 365)
x1 &lt;- (sin( 1 / 160 * 2 * pi * t) + pi) * 5
x2 &lt;- cos( 1 / 182.5 * 1.25 * pi * t) * 12

# the model
mod &lt;- function(par, t1 = 1, tn = 365) {
  par[1] * x1[t1:tn] + par[2] * x2[t1:tn]
}

# the true parameters
par1 &lt;- 1.65
par2 &lt;- 0.75
yObs &lt;- mod(c(par1, par2)) + rnorm(length(x1), 0, 2)

# split the time series in half
plot(yObs ~ t)
abline(v = 182, col = "red", lty = 2)

# First half of the data
ll_1 &lt;- function(x, sum = TRUE) {
  out &lt;- dnorm(mod(x, 1, 182) - yObs[1:182], 0, 2, log = TRUE)
  if (sum == TRUE) sum(out) else out
}

# Fit the first half of the time series
# (e.g. fit the model to the data soon as you collect the data)
setup_1 &lt;- createBayesianSetup(ll_1, lower = c(-10, -10), upper = c(10, 10))
settings_1 &lt;- list(initialParticles = 1000)
out_1 &lt;- runMCMC(setup_1, "SMC", settings_1)
summary(out_1)


# Second half of the data
ll_2 &lt;- function(x, sum = TRUE) {
  out &lt;- dnorm(mod(x, 183, 365) - yObs[183:365], 0, 2, log = TRUE)
  if (sum == TRUE) sum(out) else out
}

# Fit the second half of the time series
# (e.g. fit the model to the data soon as you collect the data)
setup_2 &lt;- createBayesianSetup(ll_2, lower = c(-10, -10), upper = c(10, 10))

# This is the important step, we use the final particles from the
# previous SMC run to initialize the new SMC run
settings_2 &lt;- list(initialParticles = out_1$particles)
out_2 &lt;- runMCMC(setup_2, "SMC", settings_2)
summary(out_2)

par_pred &lt;- apply(out_2$particles, 2, median)
pred &lt;- mod(par_pred)
plotTimeSeries(yObs, pred)


## End(Not run)






</code></pre>

<hr>
<h2 id='stopParallel'>Function to close cluster in BayesianSetup</h2><span id='topic+stopParallel'></span>

<h3>Description</h3>

<p>Function closes
the parallel executer (if available)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopParallel(bayesianSetup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopParallel_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>object of class BayesianSetup</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefan Paul
</p>

<hr>
<h2 id='sumSquare'>Helper function for sum of x*x</h2><span id='topic+sumSquare'></span>

<h3>Description</h3>

<p>Helper function for sum of x*x
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumSquare(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumSquare_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
</table>

<hr>
<h2 id='testDensityBanana'>Banana-shaped density function</h2><span id='topic+testDensityBanana'></span>

<h3>Description</h3>

<p>Banana-shaped density function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDensityBanana(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDensityBanana_+3A_p">p</code></td>
<td>
<p>2-dim parameter vector</p>
</td></tr>
</table>


<h3>Note</h3>

<p>inspired from package FMEmcmc, seems to go back to Laine M (2008). Adaptive MCMC Methods with Applications in Environmental and Models. Finnish Meteorological Institute Contributions 69. ISBN 978-951-697-662-7.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateTestDensityMultiNormal">generateTestDensityMultiNormal</a></code> <br />
<code><a href="#topic+testLinearModel">testLinearModel</a></code>
</p>

<hr>
<h2 id='testDensityGelmanMeng'>GelmanMeng test function</h2><span id='topic+testDensityGelmanMeng'></span>

<h3>Description</h3>

<p>GelmanMeng test function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDensityGelmanMeng(x, A = 1, B = 0, C1 = 3, C2 = 3, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDensityGelmanMeng_+3A_x">x</code></td>
<td>
<p>parameter vector</p>
</td></tr>
<tr><td><code id="testDensityGelmanMeng_+3A_a">A</code></td>
<td>
<p>function parameter</p>
</td></tr>
<tr><td><code id="testDensityGelmanMeng_+3A_b">B</code></td>
<td>
<p>function parameter</p>
</td></tr>
<tr><td><code id="testDensityGelmanMeng_+3A_c1">C1</code></td>
<td>
<p>function parameter</p>
</td></tr>
<tr><td><code id="testDensityGelmanMeng_+3A_c2">C2</code></td>
<td>
<p>function parameter</p>
</td></tr>
<tr><td><code id="testDensityGelmanMeng_+3A_log">log</code></td>
<td>
<p>log
</p>
<p>A non-elliptical, bivariate density function proposed by Gelman and Meng (1991).</p>
</td></tr>
</table>

<hr>
<h2 id='testDensityInfinity'>Test function infinity ragged</h2><span id='topic+testDensityInfinity'></span>

<h3>Description</h3>

<p>Test function infinity ragged
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDensityInfinity(x, error = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDensityInfinity_+3A_x">x</code></td>
<td>
<p>2-dim parameter vector</p>
</td></tr>
<tr><td><code id="testDensityInfinity_+3A_error">error</code></td>
<td>
<p>should error or infinity be returned</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateTestDensityMultiNormal">generateTestDensityMultiNormal</a></code> <br />
<code><a href="#topic+testDensityBanana">testDensityBanana</a></code>
</p>

<hr>
<h2 id='testDensityMultiNormal'>3d Mutivariate Normal likelihood</h2><span id='topic+testDensityMultiNormal'></span>

<h3>Description</h3>

<p>3d Mutivariate Normal likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDensityMultiNormal(x, sigma = "strongcorrelation")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDensityMultiNormal_+3A_x">x</code></td>
<td>
<p>a parameter vector of arbitrary length</p>
</td></tr>
<tr><td><code id="testDensityMultiNormal_+3A_sigma">sigma</code></td>
<td>
<p>either a correlation matrix, or &quot;strongcorrelation&quot;, or &quot;no correlation&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='testDensityNormal'>Normal likelihood</h2><span id='topic+testDensityNormal'></span>

<h3>Description</h3>

<p>Normal likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testDensityNormal(x, sum = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testDensityNormal_+3A_x">x</code></td>
<td>
<p>a parameter vector of arbitrary length</p>
</td></tr>
<tr><td><code id="testDensityNormal_+3A_sum">sum</code></td>
<td>
<p>if likelihood should be summed or not</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='testLinearModel'>Fake model, returns a ax + b linear response to 2-param vector</h2><span id='topic+testLinearModel'></span>

<h3>Description</h3>

<p>Fake model, returns a ax + b linear response to 2-param vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testLinearModel(x, env = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testLinearModel_+3A_x">x</code></td>
<td>
<p>2-dim parameter vector</p>
</td></tr>
<tr><td><code id="testLinearModel_+3A_env">env</code></td>
<td>
<p>optional, environmental covariate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateTestDensityMultiNormal">generateTestDensityMultiNormal</a></code> <br />
<code><a href="#topic+testDensityBanana">testDensityBanana</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = c(1,2)
y = testLinearModel(x)
plot(y)
</code></pre>

<hr>
<h2 id='thinMatrix'>Function to thin matrices</h2><span id='topic+thinMatrix'></span>

<h3>Description</h3>

<p>Function to thin matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinMatrix(mat, thin = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinMatrix_+3A_mat">mat</code></td>
<td>
<p>matrix to thin</p>
</td></tr>
<tr><td><code id="thinMatrix_+3A_thin">thin</code></td>
<td>
<p>thinning parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>thinned matrix
</p>

<hr>
<h2 id='tracePlot'>Trace plot for MCMC class</h2><span id='topic+tracePlot'></span>

<h3>Description</h3>

<p>Trace plot for MCMC class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracePlot(sampler, thin = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracePlot_+3A_sampler">sampler</code></td>
<td>
<p>an object of class MCMC sampler</p>
</td></tr>
<tr><td><code id="tracePlot_+3A_thin">thin</code></td>
<td>
<p>determines the thinning intervall of the chain</p>
</td></tr>
<tr><td><code id="tracePlot_+3A_...">...</code></td>
<td>
<p>additional parameters to pass on to the <code><a href="#topic+getSample">getSample</a></code>, for example parametersOnly =F, or start = 1000</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+marginalPlot">marginalPlot</a></code> <br />
<code><a href="#topic+plotTimeSeries">plotTimeSeries</a></code> <br />
<code><a href="#topic+correlationPlot">correlationPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set up and run the MCMC
ll &lt;- function(x) sum(dnorm(x, log = TRUE))
setup &lt;- createBayesianSetup(likelihood = ll, lower = c(-10, -10), upper = c(10,10))
settings &lt;- list(iterations = 2000)
out &lt;- runMCMC(bayesianSetup = setup, settings = settings, sampler = "Metropolis")

# plot the trace
tracePlot(sampler = out, thin = 10)
tracePlot(sampler = out, thin = 50)

# additional parameters can be passed on to getSample (see help)
tracePlot(sampler = out, thin = 10, start = 500)
# select parameter by index
tracePlot(sampler = out, thin = 10, start = 500, whichParameters = 2)
</code></pre>

<hr>
<h2 id='Twalk'>T-walk MCMC</h2><span id='topic+Twalk'></span>

<h3>Description</h3>

<p>T-walk MCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Twalk(
  bayesianSetup,
  settings = list(iterations = 10000, at = 6, aw = 1.5, pn1 = NULL, Ptrav = 0.4918, Pwalk
    = 0.4918, Pblow = 0.0082, burnin = 0, thin = 1, startValue = NULL, consoleUpdates =
    100, message = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Twalk_+3A_bayesiansetup">bayesianSetup</code></td>
<td>
<p>Object of class 'bayesianSetup' or 'bayesianOuput'.</p>
</td></tr>
<tr><td><code id="Twalk_+3A_settings">settings</code></td>
<td>
<p>list with parameter values.</p>
</td></tr>
<tr><td><code id="Twalk_+3A_iterations">iterations</code></td>
<td>
<p>Number of model evaluations</p>
</td></tr>
<tr><td><code id="Twalk_+3A_at">at</code></td>
<td>
<p>&quot;traverse&quot; move proposal parameter. Default to 6</p>
</td></tr>
<tr><td><code id="Twalk_+3A_aw">aw</code></td>
<td>
<p>&quot;walk&quot; move proposal parameter. Default to 1.5</p>
</td></tr>
<tr><td><code id="Twalk_+3A_pn1">pn1</code></td>
<td>
<p>Probability determining the number of parameters that are changed</p>
</td></tr>
<tr><td><code id="Twalk_+3A_ptrav">Ptrav</code></td>
<td>
<p>Move probability of &quot;traverse&quot; moves, default to 0.4918</p>
</td></tr>
<tr><td><code id="Twalk_+3A_pwalk">Pwalk</code></td>
<td>
<p>Move probability of &quot;walk&quot; moves, default to 0.4918</p>
</td></tr>
<tr><td><code id="Twalk_+3A_pblow">Pblow</code></td>
<td>
<p>Move probability of &quot;traverse&quot; moves, default to 0.0082</p>
</td></tr>
<tr><td><code id="Twalk_+3A_burnin">burnin</code></td>
<td>
<p>number of iterations treated as burn-in. These iterations are not recorded in the chain.</p>
</td></tr>
<tr><td><code id="Twalk_+3A_thin">thin</code></td>
<td>
<p>thinning parameter. Determines the interval in which values are recorded.</p>
</td></tr>
<tr><td><code id="Twalk_+3A_startvalue">startValue</code></td>
<td>
<p>Matrix with start values</p>
</td></tr>
<tr><td><code id="Twalk_+3A_consoleupdates">consoleUpdates</code></td>
<td>
<p>Intervall in which the sampling progress is printed to the console</p>
</td></tr>
<tr><td><code id="Twalk_+3A_message">message</code></td>
<td>
<p>logical determines whether the sampler's progress should be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability of &quot;hop&quot; moves is 1 minus the sum of all other probabilities.
</p>


<h3>Value</h3>

<p>Object of class bayesianOutput.
</p>


<h3>Author(s)</h3>

<p>Stefan Paul
</p>


<h3>References</h3>

<p>Christen, J. Andres, and Colin Fox. &quot;A general purpose sampling algorithm for continuous distributions (the t-walk).&quot; Bayesian Analysis 5.2 (2010): 263-281.
</p>

<hr>
<h2 id='TwalkMove'>Wrapper for step function</h2><span id='topic+TwalkMove'></span>

<h3>Description</h3>

<p>Wrapper for step function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwalkMove(
  Npar,
  FUN,
  x,
  Eval,
  x2,
  Eval2,
  at = 6,
  aw = 1.5,
  pn1 = min(Npar, 4)/Npar,
  Ptrav = 0.4918,
  Pwalk = 0.4918,
  Pblow = 0.0082,
  Phop = 0.0082
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwalkMove_+3A_npar">Npar</code></td>
<td>
<p>Number of parameters</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_fun">FUN</code></td>
<td>
<p>Log posterior density</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_x">x</code></td>
<td>
<p>parameter vector of chain 1</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_eval">Eval</code></td>
<td>
<p>last evaluation of x</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_x2">x2</code></td>
<td>
<p>parameter vector of chain 2</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_eval2">Eval2</code></td>
<td>
<p>last evaluation of x</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_at">at</code></td>
<td>
<p>&quot;traverse&quot; move proposal parameter.</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_aw">aw</code></td>
<td>
<p>&quot;walk&quot; move proposal parameter.</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_pn1">pn1</code></td>
<td>
<p>Probability determining the number of parameters that are changed.</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_ptrav">Ptrav</code></td>
<td>
<p>Move probability of &quot;traverse&quot; moves, default to 0.4918</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_pwalk">Pwalk</code></td>
<td>
<p>Move probability of &quot;walk&quot; moves, default to 0.4918</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_pblow">Pblow</code></td>
<td>
<p>Move probability of &quot;blow&quot; moves, default to 0.0082</p>
</td></tr>
<tr><td><code id="TwalkMove_+3A_phop">Phop</code></td>
<td>
<p>Move probability of &quot;hop&quot; moves</p>
</td></tr>
</table>


<h3>References</h3>

<p>Christen, J. Andres, and Colin Fox. &quot;A general purpose sampling algorithm for continuous distributions (the t-walk).&quot; Bayesian Analysis 5.2 (2010): 263-281.
</p>

<hr>
<h2 id='Twalksteps'>Main function that is executing and evaluating the moves</h2><span id='topic+Twalksteps'></span>

<h3>Description</h3>

<p>Main function that is executing and evaluating the moves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Twalksteps(case, Npar, FUN, x, Eval, x2, Eval2, at, aw, pn1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Twalksteps_+3A_case">case</code></td>
<td>
<p>Type of Twalk move. Either &quot;walk&quot;, &quot;traverse&quot;, &quot;hop&quot; or &quot;blow&quot;</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_npar">Npar</code></td>
<td>
<p>number of parameters</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_fun">FUN</code></td>
<td>
<p>Log posterior density</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_x">x</code></td>
<td>
<p>parameter vector of chain 1</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_eval">Eval</code></td>
<td>
<p>last evaluation of x</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_x2">x2</code></td>
<td>
<p>parameter vector of chain 2</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_eval2">Eval2</code></td>
<td>
<p>last evaluation of x</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_at">at</code></td>
<td>
<p>&quot;traverse&quot; move proposal parameter.</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_aw">aw</code></td>
<td>
<p>&quot;walk&quot; move proposal parameter.</p>
</td></tr>
<tr><td><code id="Twalksteps_+3A_pn1">pn1</code></td>
<td>
<p>Probability determining the number of parameters that are changed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Christen, J. Andres, and Colin Fox. &quot;A general purpose sampling algorithm for continuous distributions (the t-walk).&quot; Bayesian Analysis 5.2 (2010): 263-281.
</p>

<hr>
<h2 id='updateGroups'>Determine the groups of correlated parameters</h2><span id='topic+updateGroups'></span>

<h3>Description</h3>

<p>Determine the groups of correlated parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateGroups(chain, blockSettings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateGroups_+3A_chain">chain</code></td>
<td>
<p>MCMC chain including only the parameters (not logP,ll, logP)</p>
</td></tr>
<tr><td><code id="updateGroups_+3A_blocksettings">blockSettings</code></td>
<td>
<p>list with settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>groups
</p>


<h3>Author(s)</h3>

<p>Stefan Paul
</p>

<hr>
<h2 id='updateProposalGenerator'>To update settings of an existing proposal genenerator</h2><span id='topic+updateProposalGenerator'></span>

<h3>Description</h3>

<p>To update settings of an existing proposal genenerator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateProposalGenerator(
  proposal,
  chain = NULL,
  message = F,
  eps = 1e-10,
  manualScaleAdjustment = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateProposalGenerator_+3A_proposal">proposal</code></td>
<td>
<p>an object of class proposalGenerator</p>
</td></tr>
<tr><td><code id="updateProposalGenerator_+3A_chain">chain</code></td>
<td>
<p>a chain to create the covariance matrix from (optional)</p>
</td></tr>
<tr><td><code id="updateProposalGenerator_+3A_message">message</code></td>
<td>
<p>whether to print an updating message</p>
</td></tr>
<tr><td><code id="updateProposalGenerator_+3A_eps">eps</code></td>
<td>
<p>numeric tolerance for covariance</p>
</td></tr>
<tr><td><code id="updateProposalGenerator_+3A_manualscaleadjustment">manualScaleAdjustment</code></td>
<td>
<p>optional adjustment for the covariance scale (multiplicative)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The this function can be applied in 2 ways 1) update the covariance given an MCMC chain, and 2) update the proposal generator after parameters have been changed
</p>

<hr>
<h2 id='VSEM'>Very simple ecosystem model</h2><span id='topic+VSEM'></span>

<h3>Description</h3>

<p>A very simple ecosystem model, based on three carbon pools and a basic LUE model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSEM(
  pars = c(KEXT = 0.5, LAR = 1.5, LUE = 0.002, GAMMA = 0.4, tauV = 1440, tauS = 27370,
    tauR = 1440, Av = 0.5, Cv = 3, Cs = 15, Cr = 3),
  PAR,
  C = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VSEM_+3A_pars">pars</code></td>
<td>
<p>a parameter vector with parameters and initial states</p>
</td></tr>
<tr><td><code id="VSEM_+3A_par">PAR</code></td>
<td>
<p>Forcing, photosynthetically active radiation (PAR) MJ /m2 /day</p>
</td></tr>
<tr><td><code id="VSEM_+3A_c">C</code></td>
<td>
<p>switch to choose whether to use the C or R version of the model. C is much faster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This Very Simple Ecosystem Model (VSEM) is a 'toy' model designed to be very simple but yet bear some resemblance to deterministic processed based ecosystem models (PBMs) that are commonly used in forest modelling.
</p>
<p>The model determines the accumulation of carbon in the plant and soil from the growth of the plant via photosynthesis and senescence to the soil which respires carbon back to the atmosphere.
</p>
<p>The model calculates Gross Primary Productivity (GPP) using a very simple light-use efficiency (LUE) formulation multiplied by light interception. Light interception is calculated via Beer's law with a constant light extinction coefficient operating on Leaf Area Index (LAI).
</p>
<p>A parameter (GAMMA) determines the fraction of GPP that is autotrophic respiration. The Net Primary Productivity (NPP) is then allocated to above and below-ground vegetation via a fixed allocation fraction. Carbon is lost from the plant pools to a single soil pool via fixed turnover rates. Heterotropic respiration in the soil is determined via a soil turnover rate.
</p>
<p>The model equations are
</p>
<p>&ndash; Photosynthesis
</p>
<p style="text-align: center;"><code class="reqn">LAI = LAR*Cv</code>
</p>

<p style="text-align: center;"><code class="reqn">GPP = PAR * LUE * (1 - \exp^{(-KEXT * LAI)})</code>
</p>

<p style="text-align: center;"><code class="reqn">NPP = (1-GAMMA) * GPP</code>
</p>

<p>&ndash; State equations
</p>
<p style="text-align: center;"><code class="reqn">dCv/dt  = Av * NPP - Cv/tauV</code>
</p>

<p style="text-align: center;"><code class="reqn">dCr/dt  = (1.0-Av) * NPP - Cr/tauR</code>
</p>

<p style="text-align: center;"><code class="reqn">dCs/dt  = Cr/tauR + Cv/tauV - Cs/tauS</code>
</p>

<p>The model time-step is daily.
</p>
<p>&ndash; VSEM inputs:
</p>
<p>PAR    Photosynthetically active radiation (PAR) MJ /m2 /day
</p>
<p>&ndash; VSEM parameters:
</p>
<p>KEXT   Light extinction coefficient m2 ground area / m2 leaf area
</p>
<p>LAR    Leaf area ratio m2 leaf area / kg aboveground vegetation
</p>
<p>LUE    Light-Use Efficiency (kg C MJ-1 PAR)
</p>
<p>GAMMA  Autotrophic respiration as a fraction of GPP
</p>
<p>tauV   Longevity of aboveground vegetation days
</p>
<p>tauR   Longevity of belowground vegetation days
</p>
<p>tauS   Residence time of soil organic matter d
</p>
<p>&ndash; VSEM states:
</p>
<p>Cv     Above-ground vegetation pool kg C / m2
</p>
<p>Cr     Below-ground vegetation pool kg C / m2
</p>
<p>Cs     Carbon in organic matter kg C / m2
</p>
<p>&ndash; VSEM fluxes:
</p>
<p>G     Gross Primary Productivity kg C /m2 /day
</p>
<p>NPP   Net Primary Productivity kg C /m2 /day
</p>
<p>NEE   Net Ecosystem Exchange kg C /m2 /day
</p>


<h3>Value</h3>

<p>a matrix with colums NEE, CV, CR and CS units and explanations see details
</p>


<h3>Author(s)</h3>

<p>David Cameron, R and C implementation by Florian Hartig
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VSEMgetDefaults">VSEMgetDefaults</a></code>, <code><a href="#topic+VSEMcreatePAR">VSEMcreatePAR</a></code>, , <code><a href="#topic+VSEMcreateLikelihood">VSEMcreateLikelihood</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  
## This example shows how to run and calibrate the VSEM model 

library(BayesianTools)

# Create input data for the model
PAR &lt;- VSEMcreatePAR(1:1000)
plot(PAR, main = "PAR (driving the model)", xlab = "Day")

# load reference parameter definition (upper, lower prior)
refPars &lt;- VSEMgetDefaults()
# this adds one additional parameter for the likelihood standard deviation (see below)
refPars[12,] &lt;- c(2, 0.1, 4) 
rownames(refPars)[12] &lt;- "error-sd"
head(refPars)

# create some simulated test data 
# generally recommended to start with simulated data before moving to real data
referenceData &lt;- VSEM(refPars$best[1:11], PAR) # model predictions with reference parameters  
referenceData[,1] = 1000 * referenceData[,1] 
# this adds the error - needs to conform to the error definition in the likelihood
obs &lt;- referenceData + rnorm(length(referenceData), sd = refPars$best[12])
oldpar &lt;- par(mfrow = c(2,2))
for (i in 1:4) plotTimeSeries(observed = obs[,i], 
                              predicted = referenceData[,i], main = colnames(referenceData)[i])

# Best to program in a way that we can choose easily which parameters to calibrate
parSel = c(1:6, 12)

# here is the likelihood 
likelihood &lt;- function(par, sum = TRUE){
  # set parameters that are not calibrated on default values 
  x = refPars$best
  x[parSel] = par
  predicted &lt;- VSEM(x[1:11], PAR) # replace here VSEM with your model 
  predicted[,1] = 1000 * predicted[,1] # this is just rescaling
  diff &lt;- c(predicted[,1:4] - obs[,1:4]) # difference betweeno observed and predicted
  # univariate normal likelihood. Note that there is a parameter involved here that is fit
  llValues &lt;- dnorm(diff, sd = x[12], log = TRUE)  
  if (sum == FALSE) return(llValues)
  else return(sum(llValues))
}

# optional, you can also directly provide lower, upper in the createBayesianSetup, see help
prior &lt;- createUniformPrior(lower = refPars$lower[parSel], 
                            upper = refPars$upper[parSel], best = refPars$best[parSel])

bayesianSetup &lt;- createBayesianSetup(likelihood, prior, names = rownames(refPars)[parSel])

# settings for the sampler, iterations should be increased for real applicatoin
settings &lt;- list(iterations = 2000, nrChains = 2)

out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)

## Not run: 

plot(out)
summary(out)
marginalPlot(out)
gelmanDiagnostics(out) # should be below 1.05 for all parameters to demonstrate convergence 

# Posterior predictive simulations

# Create a prediction function
createPredictions &lt;- function(par){
  # set the parameters that are not calibrated on default values 
  x = refPars$best
  x[parSel] = par
  predicted &lt;- VSEM(x[1:11], PAR) # replace here VSEM with your model 
  return(predicted[,1] * 1000)
}

# Create an error function
createError &lt;- function(mean, par){
  return(rnorm(length(mean), mean = mean, sd = par[7]))
}

# plot prior predictive distribution and prior predictive simulations
plotTimeSeriesResults(sampler = out, model = createPredictions, observed = obs[,1],
                      error = createError, prior = TRUE, main = "Prior predictive")

# plot posterior predictive distribution and posterior predictive simulations
plotTimeSeriesResults(sampler = out, model = createPredictions, observed = obs[,1],
                      error = createError, main = "Posterior predictive")


########################################################
# Demonstrating the updating of the prior from old posterior
# Note that it is usually more exact to rerun the MCMC 
# with all (old and new) data, instead of updating the prior
# because likely some information is lost when approximating the
# Posterior by a multivariate normal 

settings &lt;- list(iterations = 5000, nrChains = 2)

out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)

plot(out)
correlationPlot(out, start = 1000)

newPrior = createPriorDensity(out, method = "multivariate",
                              eps = 1e-10,
                              lower = refPars$lower[parSel],
                              upper = refPars$upper[parSel], start= 1000)

bayesianSetup &lt;- createBayesianSetup(likelihood = likelihood,
                                     prior = newPrior,
                                     names = rownames(refPars)[parSel] )

# check boundaries are correct set
bayesianSetup$prior$sampler() &lt; refPars$lower[parSel]
bayesianSetup$prior$sampler() &gt; refPars$upper[parSel]

# check prior looks similar to posterior
x = bayesianSetup$prior$sampler(2000)
correlationPlot(x, thin = F)

out &lt;- runMCMC(bayesianSetup = bayesianSetup, sampler = "DEzs", settings = settings)

plot(out)
correlationPlot(out)

plotTimeSeriesResults(sampler = out,
                      model = createPredictions,
                      observed = obs[,1],
                      error = createError,
                      prior = F, main = "Posterior predictive")

plotTimeSeriesResults(sampler = out,
                      model = createPredictions,
                      observed = obs[,1],
                      error = createError,
                      prior = T, main = "Prior predictive")





## End(Not run)

par(oldpar)
</code></pre>

<hr>
<h2 id='vsemC'>C version of the VSEM model</h2><span id='topic+vsemC'></span>

<h3>Description</h3>

<p>C version of the VSEM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsemC(par, PAR)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsemC_+3A_par">par</code></td>
<td>
<p>parameter vector</p>
</td></tr>
<tr><td><code id="vsemC_+3A_par">PAR</code></td>
<td>
<p>Photosynthetically active radiation (PAR) MJ /m2 /day</p>
</td></tr>
</table>

<hr>
<h2 id='VSEMcreateLikelihood'>Create an example dataset, and from that a likelihood or posterior for the VSEM model</h2><span id='topic+VSEMcreateLikelihood'></span>

<h3>Description</h3>

<p>Create an example dataset, and from that a likelihood or posterior for the VSEM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSEMcreateLikelihood(likelihoodOnly = F, plot = F, selection = c(1:6, 12))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VSEMcreateLikelihood_+3A_likelihoodonly">likelihoodOnly</code></td>
<td>
<p>switch to devide whether to create only a likelihood, or a full bayesianSetup with uniform priors.</p>
</td></tr>
<tr><td><code id="VSEMcreateLikelihood_+3A_plot">plot</code></td>
<td>
<p>switch to decide whether data should be plotted</p>
</td></tr>
<tr><td><code id="VSEMcreateLikelihood_+3A_selection">selection</code></td>
<td>
<p>vector containing the indices of the selected parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to be able to conveniently create a likelihood for the VSEM model for demonstration purposes. The function creates example data &ndash;&gt; likelihood &ndash;&gt; BayesianSetup, where the latter is the
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>

<hr>
<h2 id='VSEMcreatePAR'>Create a random radiation (PAR) time series</h2><span id='topic+VSEMcreatePAR'></span>

<h3>Description</h3>

<p>Create a random radiation (PAR) time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSEMcreatePAR(days = 1:(3 * 365))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VSEMcreatePAR_+3A_days">days</code></td>
<td>
<p>days to calculate the PAR for</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Cameron, R implementation by Florian Hartig
</p>

<hr>
<h2 id='VSEMgetDefaults'>returns the default values for the VSEM</h2><span id='topic+VSEMgetDefaults'></span>

<h3>Description</h3>

<p>returns the default values for the VSEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VSEMgetDefaults()
</code></pre>


<h3>Value</h3>

<p>a data.frame
</p>

<hr>
<h2 id='WAIC'>calculates the WAIC</h2><span id='topic+WAIC'></span>

<h3>Description</h3>

<p>calculates the WAIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WAIC(bayesianOutput, numSamples = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WAIC_+3A_bayesianoutput">bayesianOutput</code></td>
<td>
<p>an object of class BayesianOutput. Must implement a log-likelihood density function that can return point-wise log-likelihood values (&quot;sum&quot; argument).</p>
</td></tr>
<tr><td><code id="WAIC_+3A_numsamples">numSamples</code></td>
<td>
<p>the number of samples to calculate the WAIC</p>
</td></tr>
<tr><td><code id="WAIC_+3A_...">...</code></td>
<td>
<p>optional values to be passed on the the getSample function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The WAIC is constructed as
</p>
<p style="text-align: center;"><code class="reqn">WAIC = -2 * (lppd - p_{WAIC})</code>
</p>

<p>The lppd (log pointwise predictive density), defined in Gelman et al., 2013, eq. 4 as
</p>
<p style="text-align: center;"><code class="reqn">lppd = \sum_{i=1}^n \log \left(\frac{1}{S} \sum_{s=1}^S p(y_i | \theta^s)\right)</code>
</p>

<p>The value of <code class="reqn">p_WAIC</code> can be calculated in two ways, the method used is determined by the
<code>method</code> argument.
</p>
<p>Method 1 is defined as,
</p>
<p style="text-align: center;"><code class="reqn">p_{WAIC1} = 2 \sum_{i=1}^{n} (\log (\frac{1}{S} \sum_{s=1}^{S} p(y_i \ \theta^s)) - \frac{1}{S} \sum_{s = 1}^{S} \log p(y_i | \theta^s))</code>
</p>

<p>Method 2 is defined as,
</p>
<p style="text-align: center;"><code class="reqn">p_{WAIC2} = 2 \sum_{i=1}^{n} V_{s=1}^{S} (\log p(y_i | \theta^s))</code>
</p>

<p>where  <code class="reqn">V_{s=1}^{S}</code> is the sample variance.
</p>


<h3>Note</h3>

<p>The function requires that the likelihood passed on to BayesianSetup contains the option sum = T/F, with defaul F. If set to true, the likelihood for each data point must be returned.
</p>


<h3>Author(s)</h3>

<p>Florian Hartig
</p>


<h3>References</h3>

<p>Gelman, Andrew and Jessica Hwang and Aki Vehtari (2013), &quot;Understanding Predictive Information Criteria for Bayesian Models,&quot; <a href="http://www.stat.columbia.edu/~gelman/research/unpublished/waic_understand_final.pdf">http://www.stat.columbia.edu/~gelman/research/unpublished/waic_understand_final.pdf</a>.
</p>
<p>Watanabe, S. (2010). &quot;Asymptotic Equivalence of Bayes Cross Validation and Widely Applicable Information Criterion in Singular Learning Theory&quot;, Journal of Machine Learning Research, <a href="https://www.jmlr.org/papers/v11/watanabe10a.html">https://www.jmlr.org/papers/v11/watanabe10a.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DIC">DIC</a></code>, <code><a href="#topic+MAP">MAP</a></code>, <code><a href="#topic+marginalLikelihood">marginalLikelihood</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bayesianSetup &lt;- createBayesianSetup(likelihood = testDensityNormal, 
                                     prior = createUniformPrior(lower = rep(-10,2),
                                                                upper = rep(10,2)))

# likelihood density needs to have option sum = FALSE

testDensityNormal(c(1,1,1), sum = FALSE)
bayesianSetup$likelihood$density(c(1,1,1), sum = FALSE)
bayesianSetup$likelihood$density(matrix(rep(1,9), ncol = 3), sum = FALSE)

# running MCMC

out = runMCMC(bayesianSetup = bayesianSetup)

WAIC(out)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
