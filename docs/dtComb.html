<!DOCTYPE html><html lang="en-US"><head><title>Help for package dtComb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dtComb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dtComb'><p>dtComb: A Comprehensive R Library for Combining Diagnostic Tests</p></a></li>
<li><a href='#allMethods'><p>Includes machine learning models used for the mlComb function</p></a></li>
<li><a href='#availableMethods'><p>Available classification/regression methods in <code>dtComb</code></p></a></li>
<li><a href='#exampleData2'><p>A data set containing the carriers of a rare genetic disorder for 120 samples.</p></a></li>
<li><a href='#exampleData3'><p>A simulation data containing 250 diseased and 250 healthy individuals.</p></a></li>
<li><a href='#helper_minimax'><p>Helper function for minimax method.</p></a></li>
<li><a href='#helper_minmax'><p>Helper function for minmax method.</p></a></li>
<li><a href='#helper_PCL'><p>Helper function for PCL method.</p></a></li>
<li><a href='#helper_PT'><p>Helper function for PT method.</p></a></li>
<li><a href='#helper_TS'><p>Helper function for TS method.</p></a></li>
<li><a href='#kappa.accuracy'><p>Calculate Cohen's kappa and accuracy.</p></a></li>
<li><a href='#laparoscopy'><p>Examples data for the dtComb package</p></a></li>
<li><a href='#linComb'><p>Combine two diagnostic tests with several linear combination methods.</p></a></li>
<li><a href='#mathComb'><p>Combine two diagnostic tests with several mathematical operators and</p>
distance measures.</a></li>
<li><a href='#mlComb'><p>Combine two diagnostic tests with Machine Learning Algorithms.</p></a></li>
<li><a href='#nonlinComb'><p>Combine two diagnostic tests with several non-linear combination methods.</p></a></li>
<li><a href='#plotComb'><p>Plot the combination scores using the training model</p></a></li>
<li><a href='#predict.dtComb'><p>Predict combination scores and labels for new data sets using the</p>
training model</a></li>
<li><a href='#print_train'><p>Print the summary of linComb, nonlinComb, mlComb and mathComb</p>
functions.</a></li>
<li><a href='#rocsum'><p>Generate ROC curves and related  statistics for the given markers and</p>
Combination score.</a></li>
<li><a href='#std.test'><p>Standardization according to the training model parameters.</p></a></li>
<li><a href='#std.train'><p>Standardization according to the chosen method.</p></a></li>
<li><a href='#transform_math'><p>Mathematical transformations for biomarkers.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Statistical Combination of Diagnostic Tests</td>
</tr>
<tr>
<td>Description:</td>
<td>A system for combining two diagnostic tests using various approaches
              that include statistical and machine-learning-based methodologies. 
              These approaches are divided into four groups: linear combination 
              methods, non-linear combination methods, mathematical operators, 
              and machine learning algorithms. See 
              the <a href="https://biotools.erciyes.edu.tr/dtComb/">https://biotools.erciyes.edu.tr/dtComb/</a> website 
              for more information, documentation, and examples.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gokmenzararsiz/dtComb">https://github.com/gokmenzararsiz/dtComb</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>pROC (&ge; 1.18.0), caret, epiR, gam, ggplot2, ggpubr, glmnet,
OptimalCutpoints</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-19 08:24:59 UTC; serrailaydayerlitas</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Author:</td>
<td>Serra Ilayda Yerlitas [aut, ctb],
  Serra Bersan Gengec [aut, ctb],
  Necla Kochan [aut, ctb],
  Gozde Erturk Zararsiz [aut, ctb],
  Selcuk Korkmaz [aut, ctb],
  Gokmen Zararsiz [aut, ctb, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gokmen Zararsiz &lt;gokmen.zararsiz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-20 01:00:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='dtComb'>dtComb: A Comprehensive R Library for Combining Diagnostic Tests</h2><span id='topic+dtComb-package'></span><span id='topic+dtComb'></span>

<h3>Description</h3>

<p>The dtComb package calculates combination scores of two biomarkers given
under four main categories: linear combinations with the linComb function,
non-linear combinations with the nonlinComb function,
mathematical operators with the mathComb function, and machine learning
algorithms with the mlComb function.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gokmen Zararsiz <a href="mailto:gokmen.zararsiz@gmail.com">gokmen.zararsiz@gmail.com</a> [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Serra Ilayda Yerlitas <a href="mailto:ilaydayerlitas340@gmail.com">ilaydayerlitas340@gmail.com</a> [contributor]
</p>
</li>
<li><p> Serra Bersan Gengec <a href="mailto:serrabersan@gmail.com">serrabersan@gmail.com</a> [contributor]
</p>
</li>
<li><p> Necla Kochan <a href="mailto:necla.kayaalp@gmail.com">necla.kayaalp@gmail.com</a> [contributor]
</p>
</li>
<li><p> Gozde Erturk Zararsiz <a href="mailto:gozdeerturk9@gmail.com">gozdeerturk9@gmail.com</a> [contributor]
</p>
</li>
<li><p> Selcuk Korkmaz <a href="mailto:selcukorkmaz@gmail.com">selcukorkmaz@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/gokmenzararsiz/dtComb">https://github.com/gokmenzararsiz/dtComb</a>
</p>
</li></ul>


<hr>
<h2 id='allMethods'>Includes machine learning models used for the mlComb function</h2><span id='topic+allMethods'></span>

<h3>Description</h3>

<p>Includes machine learning models used for the mlComb function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(allMethods)
</code></pre>


<h3>Format</h3>

<p>A data frame with 113 rows and 2 variables:
</p>

<dl>
<dt>Method</dt><dd><p>Valid name for the function</p>
</dd>
<dt>Model</dt><dd><p>Model name</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(allMethods)
allMethods

</code></pre>

<hr>
<h2 id='availableMethods'>Available classification/regression methods in <code>dtComb</code></h2><span id='topic+availableMethods'></span>

<h3>Description</h3>

<p>This function returns a data.frame of available classification
methods in <code>dtComb</code>. These methods are imported from the caret package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>availableMethods()
</code></pre>


<h3>Value</h3>

<p><code>No return value</code> contains the method names and explanations of the
machine-learning models available for the dtComb package.
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
availableMethods()

</code></pre>

<hr>
<h2 id='exampleData2'>A data set containing the carriers of a rare genetic disorder for 120 samples.</h2><span id='topic+exampleData2'></span>

<h3>Description</h3>

<p>A data set containing the carriers of a rare genetic disorder for 120 samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exampleData2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 120 rows and 5 variables:
</p>

<dl>
<dt>Group</dt><dd><p>Indicator if the person was carriers, values carriers and
normals</p>
</dd>
<dt>m1</dt><dd><p>Biomarker 1, 1. measurement blood sample</p>
</dd>
<dt>m2</dt><dd><p>Biomarker 2, 2. measurement blood sample</p>
</dd>
<dt>m3</dt><dd><p>Biomarker 3, 3. measurement blood sample</p>
</dd>
<dt>m4</dt><dd><p>Biomarker 4, 4. measurement blood sample</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData2)
exampleData2$Group &lt;- factor(exampleData2$Group)
gcol &lt;- c("#E69F00", "#56B4E9")
plot(exampleData2$m1, exampleData2$m2,
  col = gcol[as.numeric(exampleData2$Group)]
)

</code></pre>

<hr>
<h2 id='exampleData3'>A simulation data containing 250 diseased and 250 healthy individuals.</h2><span id='topic+exampleData3'></span>

<h3>Description</h3>

<p>A simulation data containing 250 diseased and 250 healthy individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(exampleData3)
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 rows and 3 variables:
</p>

<dl>
<dt>status</dt><dd><p>Indicator of one's condition, values healthy and diseased</p>
</dd>
<dt>marker1</dt><dd><p>1. biomarker</p>
</dd>
<dt>marker2</dt><dd><p>2. biomarker</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(exampleData3)
exampleData3$status &lt;- factor(exampleData3$status)
gcol &lt;- c("#E69F00", "#56B4E9")
plot(exampleData3$marker1, exampleData3$marker2,
  col = gcol[as.numeric(exampleData3$status)]
)

</code></pre>

<hr>
<h2 id='helper_minimax'>Helper function for minimax method.</h2><span id='topic+helper_minimax'></span>

<h3>Description</h3>

<p>The <code>helper_minimax</code> function calculates the combination
coefficient and optimized value of given biomarkers for the minimax method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_minimax(t, neg.set, pos.set, markers, status)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="helper_minimax_+3A_t">t</code></td>
<td>
<p>a <code>numeric</code> parameter that will be estimated in minimax
method for the combination score</p>
</td></tr>
<tr><td><code id="helper_minimax_+3A_neg.set">neg.set</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the observation with
negative status</p>
</td></tr>
<tr><td><code id="helper_minimax_+3A_pos.set">pos.set</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the observation with
positive status</p>
</td></tr>
<tr><td><code id="helper_minimax_+3A_markers">markers</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the biomarkers</p>
</td></tr>
<tr><td><code id="helper_minimax_+3A_status">status</code></td>
<td>
<p>a <code>factor</code> data frame that includes the actual disease
status of the patients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> Optimized value calculated with combination scores
using t
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call data
data(laparoscopy)

# define the function parameters
markers &lt;- cbind(laparoscopy$ddimer, laparoscopy$log_leukocyte)
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))

neg.set &lt;- markers[status == levels(status)[1], ]
pos.set &lt;- markers[status == levels(status)[2], ]

t &lt;- 0.5

stat &lt;- helper_minimax(t,
  neg.set = neg.set, pos.set = pos.set,
  markers = markers, status
)

</code></pre>

<hr>
<h2 id='helper_minmax'>Helper function for minmax method.</h2><span id='topic+helper_minmax'></span>

<h3>Description</h3>

<p>The <code>helper_minmax</code> function estimates optimized value of
given biomarkers for the minmax method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_minmax(lambda, neg.set, pos.set)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="helper_minmax_+3A_lambda">lambda</code></td>
<td>
<p>a <code>numeric</code> parameter that will be estimated in minmax
method for the combination score</p>
</td></tr>
<tr><td><code id="helper_minmax_+3A_neg.set">neg.set</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the observations
with negative status</p>
</td></tr>
<tr><td><code id="helper_minmax_+3A_pos.set">pos.set</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the observations
with positive status</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> value for the estimated optimized value
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call data
data(laparoscopy)

# define the function parameters
markers &lt;- cbind(laparoscopy$ddimer, laparoscopy$log_leukocyte)
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))

neg.set &lt;- markers[status == levels(status)[1], ]
pos.set &lt;- markers[status == levels(status)[2], ]

lambda &lt;- 0.5

stat &lt;- helper_minmax(lambda, neg.set = neg.set, pos.set = pos.set)

</code></pre>

<hr>
<h2 id='helper_PCL'>Helper function for PCL method.</h2><span id='topic+helper_PCL'></span>

<h3>Description</h3>

<p>The <code>helper_PCL</code> function estimates the optimized value of
given biomarkers for the PCL method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_PCL(lambda, neg.set, pos.set)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="helper_PCL_+3A_lambda">lambda</code></td>
<td>
<p>a <code>numeric</code> parameter that will be estimated in minmax
method for the combination score</p>
</td></tr>
<tr><td><code id="helper_PCL_+3A_neg.set">neg.set</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the observation with
negative status</p>
</td></tr>
<tr><td><code id="helper_PCL_+3A_pos.set">pos.set</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the observation with
positive status</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> value for the estimated optimized value
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call data
data(laparoscopy)

# define the function parameters
markers &lt;- cbind(laparoscopy$ddimer, laparoscopy$log_leukocyte)
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))

neg.set &lt;- markers[status == levels(status)[1], ]
pos.set &lt;- markers[status == levels(status)[2], ]

lambda &lt;- 0.5

stat &lt;- helper_PCL(lambda, neg.set = neg.set, pos.set = pos.set)

</code></pre>

<hr>
<h2 id='helper_PT'>Helper function for PT method.</h2><span id='topic+helper_PT'></span>

<h3>Description</h3>

<p>The <code>helper_PT</code> function estimates the optimized value of
given biomarkers for the PT method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_PT(lambda, neg.set, pos.set)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="helper_PT_+3A_lambda">lambda</code></td>
<td>
<p>a <code>numeric</code> parameter that will be estimated in minmax
method for the combination score</p>
</td></tr>
<tr><td><code id="helper_PT_+3A_neg.set">neg.set</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the observation with
negative status</p>
</td></tr>
<tr><td><code id="helper_PT_+3A_pos.set">pos.set</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the observation with
positive status</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> value for the estimated optimized value
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call data
data(laparoscopy)

# define the function parameters
markers &lt;- cbind(laparoscopy$ddimer, laparoscopy$log_leukocyte)
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))

neg.set &lt;- markers[status == levels(status)[1], ]
pos.set &lt;- markers[status == levels(status)[2], ]

lambda &lt;- 0.5

stat &lt;- helper_PT(lambda, neg.set = neg.set, pos.set = pos.set)

</code></pre>

<hr>
<h2 id='helper_TS'>Helper function for TS method.</h2><span id='topic+helper_TS'></span>

<h3>Description</h3>

<p>The <code>helper_TS</code> function calculates the combination
coefficient and optimized value of given biomarkers for the TS method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper_TS(theta, markers, status)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="helper_TS_+3A_theta">theta</code></td>
<td>
<p>a <code>numeric</code> parameter that will be estimated in TS
method for the combination score</p>
</td></tr>
<tr><td><code id="helper_TS_+3A_markers">markers</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the biomarkers</p>
</td></tr>
<tr><td><code id="helper_TS_+3A_status">status</code></td>
<td>
<p>a <code>factor</code> data frame that includes the actual disease
status of the patients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> Optimized value calculated with combination scores
using theta
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call data
data(laparoscopy)

# define the function parameters
markers &lt;- cbind(laparoscopy$ddimer, laparoscopy$log_leukocyte)
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))

t &lt;- 0.5

stat &lt;- helper_TS(theta = t, markers = markers, status = status)

</code></pre>

<hr>
<h2 id='kappa.accuracy'>Calculate Cohen's kappa and accuracy.</h2><span id='topic+kappa.accuracy'></span>

<h3>Description</h3>

<p>The <code>kappa.accuracy</code> calculates Cohen's kappa and accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'accuracy'
kappa(DiagStatCombined)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kappa.accuracy_+3A_diagstatcombined">DiagStatCombined</code></td>
<td>
<p>a <code>numeric</code> table of confusion matrix of the
calculated combination score.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of Cohen's kappa and accuracy values
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>

<hr>
<h2 id='laparoscopy'>Examples data for the dtComb package</h2><span id='topic+laparoscopy'></span>

<h3>Description</h3>

<p>A data set containing the results of diagnostic laparoscopy procedures for 225
patients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(laparoscopy)
</code></pre>


<h3>Format</h3>

<p>A data frame with 225 rows and 3 variables:
</p>

<dl>
<dt>group</dt><dd><p>Indicator if the procedure was needed, values needed and
not_needed</p>
</dd>
<dt>ddimer</dt><dd><p>Biomarker 1, D-Dimer protein level in blood, ng/mL</p>
</dd>
<dt>log_leukocyte</dt><dd><p>Biomarker 2, Logarithm of Leukocyte count in blood,
per mcL</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(laparoscopy)
laparoscopy$group &lt;- factor(laparoscopy$group)
gcol &lt;- c("#E69F00", "#56B4E9")
plot(laparoscopy$ddimer, laparoscopy$log_leukocyte,
  col = gcol[as.numeric(laparoscopy$group)]
)

</code></pre>

<hr>
<h2 id='linComb'>Combine two diagnostic tests with several linear combination methods.</h2><span id='topic+linComb'></span>

<h3>Description</h3>

<p>The <code>linComb</code> function calculates the combination
scores of two diagnostic tests selected among several linear combination
methods and standardization options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linComb(
  markers = NULL,
  status = NULL,
  event = NULL,
  method = c("scoring", "SL", "logistic", "minmax", "PT", "PCL", "minimax", "TS"),
  resample = c("none", "cv", "repeatedcv", "boot"),
  nfolds = 5,
  nrepeats = 3,
  niters = 10,
  standardize = c("none", "range", "zScore", "tScore", "mean", "deviance"),
  ndigits = 0,
  show.plot = TRUE,
  direction = c("auto", "&lt;", "&gt;"),
  conf.level = 0.95,
  cutoff.method = c("CB", "MCT", "MinValueSp", "MinValueSe", "ValueSp", "ValueSe",
    "MinValueSpSe", "MaxSp", "MaxSe", "MaxSpSe", "MaxProdSpSe", "ROC01", "SpEqualSe",
    "Youden", "MaxEfficiency", "Minimax", "MaxDOR", "MaxKappa", "MinValueNPV",
    "MinValuePPV", "ValueNPV", "ValuePPV", "MinValueNPVPPV", "PROC01", "NPVEqualPPV",
    "MaxNPVPPV", "MaxSumNPVPPV", "MaxProdNPVPPV", "ValueDLR.Negative",
    "ValueDLR.Positive", "MinPvalue", "ObservedPrev", "MeanPrev", "PrevalenceMatching"),
  show.result = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linComb_+3A_markers">markers</code></td>
<td>
<p>a <code>numeric</code> a numeric data frame that includes two diagnostic tests
results</p>
</td></tr>
<tr><td><code id="linComb_+3A_status">status</code></td>
<td>
<p>a <code>factor</code> vector that includes the actual disease
status of the patients</p>
</td></tr>
<tr><td><code id="linComb_+3A_event">event</code></td>
<td>
<p>a <code>character</code> string that indicates the event in the status
to be considered as positive event</p>
</td></tr>
<tr><td><code id="linComb_+3A_method">method</code></td>
<td>
<p>a <code>character</code> string specifying the method used for
combining the markers. <br />
<strong>Notations:</strong>
Before getting into these methods,
let us first introduce some notations that will be used
throughout this vignette. Let
<code class="reqn">D_i,  i = 1, 2, \ldots, n_1</code>
be the marker values of <code class="reqn"> i\text{th}</code> individual in diseased group, where
<code class="reqn">D_i = (D_{i1}, D_{i2})</code> and
<code class="reqn">H_j, j=1,2, \ldots, n_2</code>
be the marker values of <code class="reqn"> j\text{th}</code> individual in healthy group, where
<code class="reqn">H_j = H_{j1}, H_{j2}</code>.
Let
<code class="reqn">x_i1 = c(D_{i1}, H_{j1})</code> be the values of the first marker, and
<code class="reqn">x_i2 = c(D_{i2}, H_{j2})</code> be values of the second marker for the <code class="reqn"> i\text{th}</code>
individual <code class="reqn"> i= 1,2, \ldots, n</code>. Let
<code class="reqn">D_{i,min} = min(D_{i1}, D_{i2}), D_{i,max} = max(D_{i1}, D_{i2}) ,
 H_{j,min} = min(H_{j1}, H_{j2}), H_{j,max} = max(H_{j1}, H_{j2}) </code> and
<code class="reqn">c_i</code> be  be the resulting combination score for the <code class="reqn"> i\text{th}</code> individual.
</p>
<p>The available methods are:
</p>

<ul>
<li> <p><b>Logistic Regression</b> <code>(logistic)</code>: Combination score obtained
by fitting a logistic regression modelis as follows:
</p>
<p style="text-align: center;"><code class="reqn"> c_i = \left(\frac{e^ {\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2}}}{1 + e^{\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2}}}\right)</code>
</p>

<p>A combination score obtained by fitting a logistic regression model typically refers
to the predicted probability or score assigned to each observation
in a dataset based on the logistic regression model’s
fitted values
</p>
</li>
<li> <p><b>Scoring based on Logistic Regression</b> <code>(scoring)</code>: Combination score is obtained using the
slope values of the relevant logistic regression model, slope values are rounded to the number of
digits taken from the user.
</p>
<p style="text-align: center;"><code class="reqn">c_i = \beta_1 x_{i1} + \beta_2 x_{i2}</code>
</p>

</li>
<li> <p><b>Pepe &amp; Thompson’s method</b> <code>(PT)</code>: The Pepe and Thompson combination score,
developed using their optimal linear combination technique, aims to maximize
the Mann-Whitney statistic in the same way that the Min-max method does. Unlike
the Min-max method, the Pepe and Thomson method takes into account all marker
values instead of just the lowest and maximum values.
</p>
<p style="text-align: center;"><code class="reqn">  maximize\; U(\alpha) = \left(\frac{1}{n_1,n_2}\right) {\sum_{i=1}^{n_1} {\sum_{j=1}^{n_2}}I(D_{i1} + \alpha D_{i2} &gt;= H_{j1} + \alpha H_{j2})}</code>
</p>

<p><br />
</p>
<p style="text-align: center;"><code class="reqn">c_i = x_{i1} + \alpha x_{i2}</code>
</p>

</li>
<li> <p><b>Pepe, Cai &amp; Langton’s method</b> <code>(PCL)</code>: Pepe, Cai and Langton combination score
obtained by using AUC as the parameter of a logistic regression model.
</p>
<p style="text-align: center;"><code class="reqn">maximize\; U(\alpha) = \left(\frac{1}{n_1,n_2}\right) {\sum_{i=1}^{n_1} {\sum_{j=1}^{n_2}}I(D_{i1} + \alpha D_{i2} &gt;}</code>
</p>

<p style="text-align: center;"><code class="reqn">H_{j1} + \alpha H_{j2}) + \left(\frac{1}{2} \right) I(D_{i1} + \alpha D_{i2} = H_{j1} + \alpha H_{j2})</code>
</p>

</li>
<li> <p><b>Min-Max method</b> <code>(minmax)</code>: This method linearly combines the minimum
and maximum values of the markers by finding a parameter,<code class="reqn">\alpha</code>  , that
maximizes the Mann-Whitney statistic, an empirical estimate of the ROC area.
</p>
<p style="text-align: center;"><code class="reqn"> maximize\;U( \alpha ) = \left(\frac{1}{n_1,n_2}\right) {\sum_{i=1}^{n_1} {\sum_{j=1}^{n_2}}I(D_{i,max} + \alpha D_{i,min} &gt; H_{j,max} + \alpha H_{j,min})}</code>
</p>

<p><br />
</p>
<p style="text-align: center;"><code class="reqn">c_i = x_{i,max} + \alpha x_{i,min}</code>
</p>

<p>where <code class="reqn">x_{i,max} = max(x_{i1},x_{i2})</code> and <code class="reqn"> x_{i,min} = min(x_{i1}, x_{i2})</code>
</p>
</li>
<li> <p><b>Su &amp; Liu’s method</b> <code>(SL)</code>: The Su and Liu combination score is computed through
Fisher’s discriminant coefficients, which assumes that the underlying
data follow a multivariate normal distribution, and the covariance matrices across
different classes are assumed to be proportional.Assuming that
<code class="reqn">D\sim N(\mu_D,\textstyle \sum_D)</code>
and
<code class="reqn">H\sim N(\mu_H,\textstyle \sum_H)</code> represent
the multivariate normal distributions for the diseased and non-diseased groups,
respectively. The Fisher’s coefficients are as follows:
</p>
<p style="text-align: center;"><code class="reqn">(\alpha , \beta) = (\textstyle \sum_{D}+\sum_{H})^{\;-1}\mu</code>
</p>

<p><code class="reqn"> \text{where} \mu_=\mu_D - \mu_H. \text{The combination score in this case is:}</code>
</p>
<p style="text-align: center;"><code class="reqn"> c_i = \alpha x_{i1} + \beta x_{i2}</code>
</p>

</li>
<li> <p><b>Minimax approach</b> <code>(minimax)</code>: Combination score obtained with the Minimax procedure;
<code class="reqn">t</code> parameter is chosen as the value that gives the maximum AUC from the
combination score. Suppose that D follows a multivariate normal distribution
<code class="reqn">D\sim N(\mu_D,\textstyle \sum_D)</code>, representing diseased group and H follows
a multivariate normal distribution <code class="reqn">H\sim N(\mu_H,\textstyle \sum_H)</code> , representing the non-diseased group.
Then Fisher’s coefficients are as follows:
</p>
<p style="text-align: center;"><code class="reqn"> (\alpha , \beta) = {[t { \textstyle \sum_{D}} + (1 - t)  \textstyle \sum_{H}] ^ {-1}}{(\mu_D - \mu_H)}</code>
</p>

<p style="text-align: center;"><code class="reqn">    c_i = b_1 x_1 + b_2 x_2</code>
</p>

</li>
<li> <p><b>Todor &amp; Saplacan’s method</b> <code>(TS)</code>:Combination score obtained by using
the trigonometric functions of the <code class="reqn">\Theta</code> value that optimizes the corresponding AUC.
</p>
<p style="text-align: center;"><code class="reqn"> c_i = sin(\theta) x_{i1} + cos(\theta) x_{i2}</code>
</p>

</li></ul>
</td></tr>
<tr><td><code id="linComb_+3A_resample">resample</code></td>
<td>
<p>a <code>character</code> string indicating the name of the
resampling options. Bootstrapping Cross-validation and repeated cross-validation
are given as the options for resampling, along with the number
of folds and number of repeats.
</p>

<ul>
<li> <p><code>boot</code>: Bootstrapping is performed similarly; the dataset
is divided into folds with replacement and models are trained and tested
in these folds to determine the best parameters for the given method and
dataset.
</p>
</li>
<li> <p><code>cv</code>: Cross-validation resampling, the dataset is divided into the
number of folds given without replacement; in each iteration, one fold is
selected as the test set, and the model is built using the remaining folds
and tested on the test set. The corresponding AUC values and the parameters
used for the combination are kept in a list. The best-performed model is
selected, and the combination score is returned for the whole dataset.
</p>
</li>
<li> <p><code>repeatedcv</code>: Repeated cross-validation the process is repeated,
and the best-performed models selected at each step are stored in another
list; the best performed among these models is selected to be applied to
the entire dataset.
</p>
</li></ul>
</td></tr>
<tr><td><code id="linComb_+3A_nfolds">nfolds</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of folds for
cross validation based resampling methods  (5, default)</p>
</td></tr>
<tr><td><code id="linComb_+3A_nrepeats">nrepeats</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of repeats
for &quot;repeatedcv&quot; option of resampling methods (3, default)</p>
</td></tr>
<tr><td><code id="linComb_+3A_niters">niters</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of
bootstrapped resampling iterations (10, default)</p>
</td></tr>
<tr><td><code id="linComb_+3A_standardize">standardize</code></td>
<td>
<p>a <code>character</code> string indicating the name of the
standardization method. The default option is no standardization applied.
Available options are:
</p>

<ul>
<li> <p><b>Z-score</b> <code>(zScore)</code>: This method scales the data to have a mean
of 0 and a standard deviation of 1. It subtracts the mean and divides by the standard
deviation for each feature. Mathematically,
</p>
<p style="text-align: center;"><code class="reqn"> Z-score = \frac{x - (\overline x)}{sd(x)}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker, <code class="reqn">\overline{x}</code> is the mean of the marker and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li>
<li> <p><b>T-score</b> <code>(tScore)</code>: T-score is commonly used
in data analysis to transform raw scores into a standardized form.
The standard formula for converting a raw score <code class="reqn">x</code> into a T-score is:
</p>
<p style="text-align: center;"><code class="reqn">T-score = \Biggl(\frac{x - (\overline x)}{sd(x)}\times 10 \Biggl) +50</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker, <code class="reqn">\overline{x}</code> is the mean of the marker
and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li>
<li> <p><b>Range (a.k.a. min-max scaling)</b> <code>(range)</code>: This method transforms data to
a specific range, between 0 and 1. The formula for this method is:
</p>
<p style="text-align: center;"><code class="reqn">Range = \frac{x - min(x)}{max(x) - min(x)}</code>
</p>

</li>
<li> <p><b>Mean</b> <code>(mean)</code>: This method, which helps
to understand the relative size of a single observation concerning
the mean of dataset, calculates the ratio of each data point to the mean value
of the dataset.
</p>
<p style="text-align: center;"><code class="reqn">Mean =  \frac{x}{\overline{x}}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker and <code class="reqn">\overline{x}</code> is the mean of the marker.
</p>
</li>
<li> <p><b>Deviance</b> <code>(deviance)</code>: This method, which allows for
comparison of individual data points in relation to the overall spread of
the data, calculates the ratio of each data point to the standard deviation
of the dataset.
</p>
<p style="text-align: center;"><code class="reqn">Deviance = \frac{x}{sd(x)}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li></ul>
</td></tr>
<tr><td><code id="linComb_+3A_ndigits">ndigits</code></td>
<td>
<p>a <code>integer</code> value to indicate the number of decimal
places to be used for rounding in Scoring method (0, default)</p>
</td></tr>
<tr><td><code id="linComb_+3A_show.plot">show.plot</code></td>
<td>
<p>a <code>logical</code>. If TRUE, a ROC curve is
plotted. Default is TRUE</p>
</td></tr>
<tr><td><code id="linComb_+3A_direction">direction</code></td>
<td>
<p>a <code>character</code> string determines in which direction the
comparison will be made.  &quot;&gt;&quot;: if the predictor values for the control group
are higher than the values of the case group (controls &gt; cases).
&quot;&lt;&quot;: if the predictor values for the control group are lower or equal than
the values of the case group (controls &lt; cases).</p>
</td></tr>
<tr><td><code id="linComb_+3A_conf.level">conf.level</code></td>
<td>
<p>a <code>numeric</code> values determines the confidence interval
for the roc curve(0.95, default).</p>
</td></tr>
<tr><td><code id="linComb_+3A_cutoff.method">cutoff.method</code></td>
<td>
<p>a <code>character</code> string determines the cutoff method
for the roc curve.</p>
</td></tr>
<tr><td><code id="linComb_+3A_show.result">show.result</code></td>
<td>
<p>a <code>logical</code> string indicating whether the results
should be printed to the console.</p>
</td></tr>
<tr><td><code id="linComb_+3A_...">...</code></td>
<td>
<p>further arguments. Currently has no effect on the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>numeric</code> linear combination scores calculated
according to the given method and standardization option.
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call data
data(laparoscopy)

# define the function parameters
markers &lt;- laparoscopy[, -1]
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))
event &lt;- "needed"

score1 &lt;- linComb(
  markers = markers, status = status, event = event,
  method = "logistic", resample = "none", show.plot = TRUE,
  standardize = "none", direction = "&lt;", cutoff.method = "Youden"
)

# call data
data(exampleData2)

# define the function parameters
markers &lt;- exampleData2[, -c(1:3, 6:7)]
status &lt;- factor(exampleData2$Group, levels = c("normals", "carriers"))
event &lt;- "carriers"

score2 &lt;- linComb(
  markers = markers, status = status, event = event,
  method = "PT", resample = "none", standardize = "none", direction = "&lt;",
  cutoff.method = "Youden", show.result = "TRUE"
)

score3 &lt;- linComb(
  markers = markers, status = status, event = event,
  method = "minmax", resample = "none", direction = "&lt;",
  cutoff.method = "Youden"
)

</code></pre>

<hr>
<h2 id='mathComb'>Combine two diagnostic tests with several mathematical operators and
distance measures.</h2><span id='topic+mathComb'></span>

<h3>Description</h3>

<p>The <code>mathComb</code> function returns the combination results of
two diagnostic tests with different mathematical operators, distance
measures, standardization, and transform options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mathComb(
  markers = NULL,
  status = NULL,
  event = NULL,
  method = c("add", "multiply", "divide", "subtract", "distance", "baseinexp",
    "expinbase"),
  distance = c("euclidean", "manhattan", "chebyshev", "kulczynski_d", "lorentzian",
    "avg", "taneja", "kumar-johnson"),
  standardize = c("none", "range", "zScore", "tScore", "mean", "deviance"),
  transform = c("none", "log", "exp", "sin", "cos"),
  show.plot = TRUE,
  direction = c("auto", "&lt;", "&gt;"),
  conf.level = 0.95,
  cutoff.method = c("CB", "MCT", "MinValueSp", "MinValueSe", "ValueSp", "ValueSe",
    "MinValueSpSe", "MaxSp", "MaxSe", "MaxSpSe", "MaxProdSpSe", "ROC01", "SpEqualSe",
    "Youden", "MaxEfficiency", "Minimax", "MaxDOR", "MaxKappa", "MinValueNPV",
    "MinValuePPV", "ValueNPV", "ValuePPV", "MinValueNPVPPV", "PROC01", "NPVEqualPPV",
    "MaxNPVPPV", "MaxSumNPVPPV", "MaxProdNPVPPV", "ValueDLR.Negative",
    "ValueDLR.Positive", "MinPvalue", "ObservedPrev", "MeanPrev", "PrevalenceMatching"),
  show.result = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mathComb_+3A_markers">markers</code></td>
<td>
<p>a <code>numeric</code> data frame that includes two diagnostic tests
results</p>
</td></tr>
<tr><td><code id="mathComb_+3A_status">status</code></td>
<td>
<p>a <code>factor</code> vector that includes the actual disease
status of the patients</p>
</td></tr>
<tr><td><code id="mathComb_+3A_event">event</code></td>
<td>
<p>a <code>character</code> string that indicates the event in the status
to be considered as positive event</p>
</td></tr>
<tr><td><code id="mathComb_+3A_method">method</code></td>
<td>
<p>a <code>character</code> string specifying the method used for
combining the markers. The available methods are:
</p>

<ul>
<li> <p><code>add</code>: Combination score obtained by adding markers
</p>
</li>
<li> <p><code>multiply</code>: Combination score obtained by multiplying markers
</p>
</li>
<li> <p><code>divide</code>: Combination score obtained by dividing markers
</p>
</li>
<li> <p><code>subtract</code>: Combination score obtained by subtracting markers
</p>
</li>
<li> <p><code>distance</code>: Combination score obtained with the help of
distance measures.
</p>
</li>
<li> <p><code>baseinexp</code>: Combination score obtained by marker1 power marker2.
</p>
</li>
<li> <p><code>expinbase</code>: Combination score obtained by marker2 power marker1.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mathComb_+3A_distance">distance</code></td>
<td>
<p>a <code>character</code> string specifying the method used for
combining the markers. The available methods are:
</p>

<ul>
<li> <p><b>Euclidean</b> (<code>euclidean</code>):
<code class="reqn">c_i = {\sqrt{(x_{i1}-0)^2+(x_{i2}-0)^2}}</code>
</p>
</li>
<li> <p><b>Manhattan</b>(<code>manhattan</code>):
<code class="reqn">c_i = |x_{i1}-0|+|x_{i2}-0|</code>
</p>
</li>
<li> <p><b>Chebyshev</b> (<code>chebyshev</code>):
<code class="reqn">c_i = max{|x_{i1}-0|,|x_{i2}-0|}</code>
</p>
</li>
<li> <p><b>Kulczynski</b> (<code>kulczynski_d</code>):
<code class="reqn">c_i = \frac{|x_{i1}-0|+|x_{i2}-0|}{min(x_{i1},x_{i2})}</code>
</p>
</li>
<li> <p><b>Lorentzian</b> (<code>lorentzian</code>):
<code class="reqn">c_i = (ln(1+|x_{i1}-0|))+ (ln(1+|x_{i2}-0|))</code>
</p>
</li>
<li> <p><b>Taneja</b> (<code>taneja</code>):
<code class="reqn">c_i = z_1\times\Biggl(log\frac{z_1}{\sqrt{(x_{i1}\times \epsilon )}}\Biggl)+z_2\times\Biggl(log\frac{z_2}{\sqrt{(x_{i2}\times\epsilon)}}\Biggl)</code>
</p>
</li>
<li> <p><b>Kumar-Johnson</b> (<code>kumar-johnson</code>):
<code class="reqn">c_i = {\frac{(x_{i1}-0)^2}{2(x_{i1}\times\epsilon)}}+{\frac{(x_{i2}-0)^2}{2(x_{i2}\times\epsilon)}}, \epsilon = 0.00001</code>
</p>
</li>
<li> <p><b>Avg</b> (<code>avg</code>):
</p>
<p style="text-align: center;"><code class="reqn">(L_1, L_n) = \frac{|x_{i1}-0|+|x_{i2}-0| + max{(x_{i1}-0),(x_{i2}-0)}}{2}</code>
</p>

</li></ul>
</td></tr>
<tr><td><code id="mathComb_+3A_standardize">standardize</code></td>
<td>
<p>a <code>character</code> string indicating the name of the
standardization method. The default option is no standardization applied.
Available options are:
</p>

<ul>
<li> <p><b>Z-score</b> <code>(zScore)</code>: This method scales the data to have a mean
of 0 and a standard deviation of 1. It subtracts the mean and divides by the standard
deviation for each feature. Mathematically,
</p>
<p style="text-align: center;"><code class="reqn"> Z-score = \frac{x - (\overline x)}{sd(x)}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker, <code class="reqn">\overline{x}</code> is the mean of the marker and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li>
<li> <p><b>T-score</b> <code>(tScore)</code>: T-score is commonly used
in data analysis to transform raw scores into a standardized form.
The standard formula for converting a raw score <code class="reqn">x</code> into a T-score is:
</p>
<p style="text-align: center;"><code class="reqn">T-score = \Biggl(\frac{x - (\overline x)}{sd(x)}\times 10 \Biggl) +50</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker, <code class="reqn">\overline{x}</code> is the mean of the marker
and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li>
<li> <p><b>Range (a.k.a. min-max scaling)</b> <code>(range)</code>: This method transforms data to
a specific range, between 0 and 1. The formula for this method is:
</p>
<p style="text-align: center;"><code class="reqn">Range = \frac{x - min(x)}{max(x) - min(x)}</code>
</p>

</li>
<li> <p><b>Mean</b> <code>(mean)</code>: This method, which helps
to understand the relative size of a single observation concerning
the mean of dataset, calculates the ratio of each data point to the mean value
of the dataset.
</p>
<p style="text-align: center;"><code class="reqn">Mean =  \frac{x}{\overline{x}}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker and <code class="reqn">\overline{x}</code> is the mean of the marker.
</p>
</li>
<li> <p><b>Deviance</b> <code>(deviance)</code>: This method, which allows for
comparison of individual data points in relation to the overall spread of
the data, calculates the ratio of each data point to the standard deviation
of the dataset.
</p>
<p style="text-align: center;"><code class="reqn">Deviance = \frac{x}{sd(x)}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mathComb_+3A_transform">transform</code></td>
<td>
<p>a <code>character</code> string indicating the name of the
standardization method. The default option is no standardization applied.
Available options are:
</p>

<ul>
<li> <p><code>log</code>: Applies logarithm transform to markers before calculating
combination score
</p>
</li>
<li> <p><code>exp</code>: Applies exponential transform to markers before
calculating combination score
</p>
</li>
<li> <p><code>sin</code>: Applies sinus trigonometric transform to markers before
calculatin combination score
</p>
</li>
<li> <p><code>cos</code>: Applies cosinus trigonometric transform to markers before
calculating combination score
</p>
</li></ul>
</td></tr>
<tr><td><code id="mathComb_+3A_show.plot">show.plot</code></td>
<td>
<p>a <code>logical</code>. If TRUE, a ROC curve is
plotted. Default is TRUE</p>
</td></tr>
<tr><td><code id="mathComb_+3A_direction">direction</code></td>
<td>
<p>a <code>character</code> string determines in which direction the
comparison will be made.  &quot;&gt;&quot;: if the predictor values for the control group
are higher than the values of the case group (controls &gt; cases).
&quot;&lt;&quot;: if the predictor values for the control group are lower or equal than
the values of the case group (controls &lt; cases).</p>
</td></tr>
<tr><td><code id="mathComb_+3A_conf.level">conf.level</code></td>
<td>
<p>a <code>numeric</code> values determines the confidence interval
for the roc curve(0.95, default).</p>
</td></tr>
<tr><td><code id="mathComb_+3A_cutoff.method">cutoff.method</code></td>
<td>
<p>a <code>character</code> string determines the cutoff method
for the roc curve.</p>
</td></tr>
<tr><td><code id="mathComb_+3A_show.result">show.result</code></td>
<td>
<p>a <code>logical</code> string indicating whether the results
should be printed to the console.</p>
</td></tr>
<tr><td><code id="mathComb_+3A_...">...</code></td>
<td>
<p>further arguments. Currently has no effect on the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>numeric</code> mathematical combination scores calculated
according to the given method and standardization option
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(laparoscopy)
markers &lt;- laparoscopy[, -1]
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))
event &lt;- "needed"
direction &lt;- "&lt;"
cutoff.method &lt;- "Youden"

score1 &lt;- mathComb(
  markers = markers, status = status, event = event,
  method = "distance", distance = "avg", direction = direction, show.plot = FALSE,
  standardize = "none", cutoff.method = cutoff.method
)

score2 &lt;- mathComb(
  markers = markers, status = status, event = event,
  method = "baseinexp", transform = "exp", direction = direction,
  cutoff.method = cutoff.method
)

score3 &lt;- mathComb(
  markers = markers, status = status, event = event,
  method = "subtract", direction = "auto", cutoff.method = "MinValueSp", transform = "sin"
)

</code></pre>

<hr>
<h2 id='mlComb'>Combine two diagnostic tests with Machine Learning Algorithms.</h2><span id='topic+mlComb'></span>

<h3>Description</h3>

<p>The <code>mlComb</code> function calculates the combination
scores of two diagnostic tests selected among several Machine Learning
Algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlComb(
  markers = NULL,
  status = NULL,
  event = NULL,
  method = NULL,
  resample = NULL,
  niters = 5,
  nfolds = 5,
  nrepeats = 3,
  preProcess = NULL,
  show.plot = TRUE,
  B = 25,
  direction = c("auto", "&lt;", "&gt;"),
  conf.level = 0.95,
  cutoff.method = c("CB", "MCT", "MinValueSp", "MinValueSe", "ValueSp", "ValueSe",
    "MinValueSpSe", "MaxSp", "MaxSe", "MaxSpSe", "MaxProdSpSe", "ROC01", "SpEqualSe",
    "Youden", "MaxEfficiency", "Minimax", "MaxDOR", "MaxKappa", "MinValueNPV",
    "MinValuePPV", "ValueNPV", "ValuePPV", "MinValueNPVPPV", "PROC01", "NPVEqualPPV",
    "MaxNPVPPV", "MaxSumNPVPPV", "MaxProdNPVPPV", "ValueDLR.Negative",
    "ValueDLR.Positive", "MinPvalue", "ObservedPrev", "MeanPrev", "PrevalenceMatching"),
  show.result = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mlComb_+3A_markers">markers</code></td>
<td>
<p>a <code>numeric</code> data frame that includes two diagnostic tests
results</p>
</td></tr>
<tr><td><code id="mlComb_+3A_status">status</code></td>
<td>
<p>a <code>factor</code> vector that includes the actual disease
status of the patients</p>
</td></tr>
<tr><td><code id="mlComb_+3A_event">event</code></td>
<td>
<p>a <code>character</code> string that indicates the event in the status
to be considered as positive event</p>
</td></tr>
<tr><td><code id="mlComb_+3A_method">method</code></td>
<td>
<p>a <code>character</code> string specifying the method used for
combining the markers. For the available methods see availableMethods()
</p>
<p><b>IMPORTANT</b>: See https://topepo.github.io/caret/available-models.html
for further information about the methods used in this function.</p>
</td></tr>
<tr><td><code id="mlComb_+3A_resample">resample</code></td>
<td>
<p>a <code>character</code> string that indicates the resampling
method used while training the model. The available methods are &quot;boot&quot;,
&quot;boot632&quot;, &quot;optimism_boot&quot;, &quot;boot_all&quot;, &quot;cv&quot;, &quot;repeatedcv&quot;, &quot;LOOCV&quot;, &quot;LGOCV&quot;,
&quot;none&quot;, &quot;oob&quot;, &quot;adaptive_cv&quot;, &quot;adaptive_boot&quot; and &quot;adaptive_LGOCV&quot;. for
details of these resampling methods see ?caret::trainControl</p>
</td></tr>
<tr><td><code id="mlComb_+3A_niters">niters</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of
bootstrapped resampling iterations (10, default)</p>
</td></tr>
<tr><td><code id="mlComb_+3A_nfolds">nfolds</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of folds for
cross validation based resampling methods  (5, default)</p>
</td></tr>
<tr><td><code id="mlComb_+3A_nrepeats">nrepeats</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of repeats
for &quot;repeatedcv&quot; option of resampling methods (3, default)</p>
</td></tr>
<tr><td><code id="mlComb_+3A_preprocess">preProcess</code></td>
<td>
<p>a <code>character</code> string that indicates the pre-processing
options to be applied in the data before training the model. Available
pre-processing methods are: &quot;BoxCox&quot;, &quot;YeoJohnson&quot;, &quot;expoTrans&quot;, &quot;center&quot;,
&quot;scale&quot;, &quot;range&quot;, &quot;knnImpute&quot;, &quot;bagImpute&quot;, &quot;medianImpute&quot;, &quot;pca&quot;, &quot;ica&quot;,
&quot;spatialSign&quot;, &quot;corr&quot;, &quot;zv&quot;, &quot;nzv&quot;, and &quot;conditionalX&quot;. For detailed
information about the methods see ?caret::preProcess</p>
</td></tr>
<tr><td><code id="mlComb_+3A_show.plot">show.plot</code></td>
<td>
<p>a <code>logical</code>. If TRUE, a ROC curve is
plotted. Default is TRUE</p>
</td></tr>
<tr><td><code id="mlComb_+3A_b">B</code></td>
<td>
<p>a <code>numeric</code> value that is the number of bootstrap samples for
bagging classifiers, &quot;bagFDA&quot;, &quot;bagFDAGCV&quot;, &quot;bagEarth&quot; and &quot;bagEarthGCV&quot;.
(25, default)</p>
</td></tr>
<tr><td><code id="mlComb_+3A_direction">direction</code></td>
<td>
<p>a <code>character</code> string determines in which direction the
comparison will be made.  &quot;&gt;&quot;: if the predictor values for the control group
are higher than the values of the case group (controls &gt; cases).
&quot;&lt;&quot;: if the predictor values for the control group are lower or equal than
the values of the case group (controls &lt; cases).</p>
</td></tr>
<tr><td><code id="mlComb_+3A_conf.level">conf.level</code></td>
<td>
<p>a <code>numeric</code> value to  determine the confidence interval
for the ROC curve(0.95, default).</p>
</td></tr>
<tr><td><code id="mlComb_+3A_cutoff.method">cutoff.method</code></td>
<td>
<p>a <code>character</code> string determines the cutoff method
for the ROC curve.</p>
</td></tr>
<tr><td><code id="mlComb_+3A_show.result">show.result</code></td>
<td>
<p>a <code>logical</code> string indicating whether the results
should be printed to the console.</p>
</td></tr>
<tr><td><code id="mlComb_+3A_...">...</code></td>
<td>
<p>optional arguments passed to selected classifiers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of AUC values, diagnostic statistics,
coordinates of the ROC curve for the combination score obtained using
Machine Learning Algorithms as well as the given biomarkers individually, a
comparison table for the AUC values of individual biomarkers and combination
score obtained and the fitted model.
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call data
data(laparoscopy)

# define the function parameters
markers &lt;- laparoscopy[, -1]
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))
event &lt;- "needed"

model &lt;- mlComb(
  markers = markers, status = status, event = event,
  method = "knn", resample = "repeatedcv", nfolds = 10, nrepeats = 5,
  preProcess = c("center", "scale"), direction = "&lt;", cutoff.method = "Youden"
)

</code></pre>

<hr>
<h2 id='nonlinComb'>Combine two diagnostic tests with several non-linear combination methods.</h2><span id='topic+nonlinComb'></span>

<h3>Description</h3>

<p>The <code>nonlinComb</code> function calculates the combination
scores of two diagnostic tests selected among several non-linear combination
methods and standardization options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonlinComb(
  markers = NULL,
  status = NULL,
  event = NULL,
  method = c("polyreg", "ridgereg", "lassoreg", "elasticreg", "splines", "sgam", "nsgam"),
  degree1 = 3,
  degree2 = 3,
  df1 = 4,
  df2 = 4,
  resample = c("none", "cv", "repeatedcv", "boot"),
  nfolds = 5,
  nrepeats = 3,
  niters = 10,
  standardize = c("none", "range", "zScore", "tScore", "mean", "deviance"),
  include.interact = FALSE,
  alpha = 0.5,
  show.plot = TRUE,
  direction = c("auto", "&lt;", "&gt;"),
  conf.level = 0.95,
  cutoff.method = c("CB", "MCT", "MinValueSp", "MinValueSe", "ValueSp", "ValueSe",
    "MinValueSpSe", "MaxSp", "MaxSe", "MaxSpSe", "MaxProdSpSe", "ROC01", "SpEqualSe",
    "Youden", "MaxEfficiency", "Minimax", "MaxDOR", "MaxKappa", "MinValueNPV",
    "MinValuePPV", "ValueNPV", "ValuePPV", "MinValueNPVPPV", "PROC01", "NPVEqualPPV",
    "MaxNPVPPV", "MaxSumNPVPPV", "MaxProdNPVPPV", "ValueDLR.Negative",
    "ValueDLR.Positive", "MinPvalue", "ObservedPrev", "MeanPrev", "PrevalenceMatching"),
  show.result = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nonlinComb_+3A_markers">markers</code></td>
<td>
<p>a <code>numeric</code> data frame that includes two diagnostic tests
results</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_status">status</code></td>
<td>
<p>a <code>factor</code> vector that includes the actual disease
status of the patients</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_event">event</code></td>
<td>
<p>a <code>character</code> string that indicates the event in the status
to be considered as positive event</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_method">method</code></td>
<td>
<p>a <code>character</code> string specifying the method used for
combining the markers. The available methods are:
</p>

<ul>
<li> <p><b>Logistic Regression with Polynomial Feature Space</b> <code>(polyreg)</code>:  The method
builds a logistic regression model with the polynomial feature space and returns the probability
of a positive event for each observation.
</p>
</li>
<li> <p><b>Ridge Regression with Polynomial Feature Space</b> <code>(ridgereg)</code>: Ridge regression is a
shrinkage method used to estimate the coefficients of highly correlated variables and in this case
the polynomial feature space created from two markers. For the implementation of the method,
glmnet() library is used with two functions: cv.glmnet() to run a cross
validation model to determine the tuning parameter <code class="reqn">\lambda</code> and glmnet() to fit the
model with the selected tuning parameter. For Ridge regression,
the glmnet() package is integrated into the dtComb package to facilitate the implementation
of this method.
</p>
</li>
<li> <p><b>Lasso Regression with Polynomial Feature Space</b> <code>(lassoreg)</code>: Lasso regression,
like Ridge regression, is a type of shrinkage method. However, a notable difference is that
Lasso tends to set some feature coefficients to zero, making it useful for feature elimination.
It also employs cross-validation for parameter selection and model fitting using the glmnet library.
</p>
</li>
<li> <p><b>Elastic Net Regression with Polynomial Feature Space</b> <code>(elasticreg)</code>: Elastic Net
regression is a hybrid model that merges the penalties from Ridge and Lasso regression, aiming
to leverage the strengths of both approaches. This model involves two parameters: <code class="reqn">\lambda</code>,
similar to Ridge and Lasso, and <code class="reqn">\alpha</code>, a user-defined mixing parameter ranging between 0 (representing Ridge)
and 1 (representing Lasso). The <code class="reqn">\alpha</code> parameter determines the balance or weights between the loss functions
of Ridge and Lasso regressions.
</p>
</li>
<li> <p><b>Splines</b> <code>(splines)</code>: Another non-linear approach to combine markers
involves employing regression models within a polynomial feature space. This approach
applies multiple regression models to the dataset using a function derived from
piecewise polynomials. This implementation uses splines with user-defined degrees
of freedom and degrees for the fitted polynomials. The splines library
is employed to construct piecewise logistic regression models using base splines.
</p>
</li>
<li> <p><b>Generalized Additive Models with Smoothing Splines and Generalized Additive Models
with Natural Cubic Splines</b> <code>(sgam &amp; nsgam)</code>: In addition to the basic spline structure,
Generalized Additive Models are applied with natural cubic splines and smoothing splines
using the gam library in R.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nonlinComb_+3A_degree1">degree1</code></td>
<td>
<p>a <code>numeric</code> value for polynomial based methods indicates
the degree of the feature space created for marker 1, for spline based
methods the degree of the fitted polynomial between each node for marker 1.
(3, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_degree2">degree2</code></td>
<td>
<p>a <code>numeric</code> value for polynomial based methods indicates
the degree of the feature space created for marker 2, for spline based
methods the degree of the fitted polynomial between each node for marker 2
(3, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_df1">df1</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of knots as the
degrees of freedom in spline based methods for marker 1 (4, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_df2">df2</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of knots as the
degrees of freedom in spline based methods for marker 2 (4, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_resample">resample</code></td>
<td>
<p>a <code>character</code> string indicating the name of the
resampling options. Bootstrapping Cross-validation and repeated cross-validation
are given as the options for resampling, along with the number
of folds and number of repeats.
</p>

<ul>
<li> <p><code>boot</code>: Bootstrapping is performed similarly; the dataset
is divided into folds with replacement and models are trained and tested
in these folds to determine the best parameters for the given method and
dataset.
</p>
</li>
<li> <p><code>cv</code>: Cross-validation resampling, the dataset is divided into the
number of folds given without replacement; in each iteration, one fold is
selected as the test set, and the model is built using the remaining folds
and tested on the test set. The corresponding AUC values and the parameters
used for the combination are kept in a list. The best-performed model is
selected, and the combination score is returned for the whole dataset.
</p>
</li>
<li> <p><code>repeatedcv</code>: Repeated cross-validation the process is repeated,
and the best-performed models selected at each step are stored in another
list; the best performed among these models is selected to be applied to
the entire dataset.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nonlinComb_+3A_nfolds">nfolds</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of folds for
cross validation based resampling methods  (5, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_nrepeats">nrepeats</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of repeats
for &quot;repeatedcv&quot; option of resampling methods (3, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_niters">niters</code></td>
<td>
<p>a <code>numeric</code> value that indicates the number of
bootstrapped resampling iterations (10, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_standardize">standardize</code></td>
<td>
<p>a <code>character</code> string indicating the name of the
standardization method. The default option is no standardization applied.
Available options are:
</p>

<ul>
<li> <p><b>Z-score</b> <code>(zScore)</code>: This method scales the data to have a mean
of 0 and a standard deviation of 1. It subtracts the mean and divides by the standard
deviation for each feature. Mathematically,
</p>
<p style="text-align: center;"><code class="reqn"> Z-score = \frac{x - (\overline x)}{sd(x)}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker, <code class="reqn">\overline{x}</code> is the mean of the marker and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li>
<li> <p><b>T-score</b> <code>(tScore)</code>: T-score is commonly used
in data analysis to transform raw scores into a standardized form.
The standard formula for converting a raw score <code class="reqn">x</code> into a T-score is:
</p>
<p style="text-align: center;"><code class="reqn">T-score = \Biggl(\frac{x - (\overline x)}{sd(x)}\times 10 \Biggl) +50</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker, <code class="reqn">\overline{x}</code> is the mean of the marker
and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li>
<li> <p><b>Range (a.k.a. min-max scaling)</b> <code>(range)</code>: This method transforms data to
a specific range, between 0 and 1. The formula for this method is:
</p>
<p style="text-align: center;"><code class="reqn">Range = \frac{x - min(x)}{max(x) - min(x)}</code>
</p>

</li>
<li> <p><b>Mean</b> <code>(mean)</code>: This method, which helps
to understand the relative size of a single observation concerning
the mean of dataset, calculates the ratio of each data point to the mean value
of the dataset.
</p>
<p style="text-align: center;"><code class="reqn">Mean =  \frac{x}{\overline{x}}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker and <code class="reqn">\overline{x}</code> is the mean of the marker.
</p>
</li>
<li> <p><b>Deviance</b> <code>(deviance)</code>: This method, which allows for
comparison of individual data points in relation to the overall spread of
the data, calculates the ratio of each data point to the standard deviation
of the dataset.
</p>
<p style="text-align: center;"><code class="reqn">Deviance = \frac{x}{sd(x)}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nonlinComb_+3A_include.interact">include.interact</code></td>
<td>
<p>a <code>logical</code> indicator that specifies whether to
include the interaction between the markers to the feature space created for
polynomial based methods (FALSE, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_alpha">alpha</code></td>
<td>
<p>a <code>numeric</code> value as the mixing parameter in Elastic Net
Regression method (0.5, default)</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_show.plot">show.plot</code></td>
<td>
<p>a <code>logical</code>. If TRUE, a ROC curve is
plotted. Default is TRUE</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_direction">direction</code></td>
<td>
<p>a <code>character</code> string determines in which direction the
comparison will be made.  &quot;&gt;&quot;: if the predictor values for the control group
are higher than the values of the case group (controls &gt; cases).
&quot;&lt;&quot;: if the predictor values for the control group are lower or equal than
the values of the case group (controls &lt; cases).</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_conf.level">conf.level</code></td>
<td>
<p>a <code>numeric</code> values determines the confidence interval
for the ROC curve(0.95, default).</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_cutoff.method">cutoff.method</code></td>
<td>
<p>a <code>character</code> string determines the cutoff method
for the ROC curve.</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_show.result">show.result</code></td>
<td>
<p>a <code>logical</code> string indicating whether the results
should be printed to the console.</p>
</td></tr>
<tr><td><code id="nonlinComb_+3A_...">...</code></td>
<td>
<p>further arguments. Currently has no effect on the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>numeric</code> nonlinear combination scores calculated
according to the given method and standardization option
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("laparoscopy")
data &lt;- laparoscopy

markers &lt;- data[, -1]
status &lt;- factor(data$group, levels = c("not_needed", "needed"))
event &lt;- "needed"
cutoff.method &lt;- "Youden"

score1 &lt;- nonlinComb(
  markers = markers, status = status, event = event,
  method = "lassoreg", include.interact = FALSE, resample = "boot", niters = 5,
  degree1 = 4, degree2 = 4, cutoff.method = cutoff.method,
  direction = "&lt;"
)

score2 &lt;- nonlinComb(
  markers = markers, status = status, event = event,
  method = "splines", resample = "none", cutoff.method = cutoff.method,
  standardize = "tScore", direction = "&lt;"
)

score3 &lt;- nonlinComb(
  markers = markers, status = status, event = event,
  method = "lassoreg", resample = "repeatedcv", include.interact = TRUE,
  cutoff.method = "ROC01", standardize = "zScore", direction = "auto"
)

</code></pre>

<hr>
<h2 id='plotComb'>Plot the combination scores using the training model</h2><span id='topic+plotComb'></span>

<h3>Description</h3>

<p>The <code>plotComb</code> a function that generates plots from the
training model. The function takes argument model. The outputs of the
function are three different plots generated from the combination scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotComb(model, status)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotComb_+3A_model">model</code></td>
<td>
<p>a <code>list</code> object where the parameters from the training
model are saved.</p>
</td></tr>
<tr><td><code id="plotComb_+3A_status">status</code></td>
<td>
<p>a <code>factor</code> vector that includes the actual disease
status of the patients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> plots
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# call data
data(laparoscopy)

# define the function parameters
markers &lt;- laparoscopy[, -1]
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))
event &lt;- "needed"

score1 &lt;- linComb(
  markers = markers, status = status, event = event,
  method = "scoring", resample = "none",
  standardize = "none", direction = "&lt;", cutoff.method = "Youden"
)

plotComb(score1, status)

score2 &lt;- nonlinComb(
  markers = markers, status = status, event = event,
  method = "nsgam", resample = "cv", include.interact = FALSE, direction = "&lt;",
  standardize = "zScore", cutoff.method = "Youden"
)

plot.score2 &lt;- plotComb(score2, status)

score3 &lt;- mathComb(
  markers = markers, status = status, event = event,
  method = "distance", distance = "euclidean", direction = "auto",
  standardize = "tScore", cutoff.method = "Youden"
)

plot.score3 &lt;- plotComb(score3, status)

</code></pre>

<hr>
<h2 id='predict.dtComb'>Predict combination scores and labels for new data sets using the
training model</h2><span id='topic+predict.dtComb'></span>

<h3>Description</h3>

<p>The <code>predict.dtComb</code> is a function that generates predictions
for a new dataset of biomarkers using the parameters from the fitted model.
The function takes arguments newdata and model. The function's output is the
combination scores and labels of object type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dtComb'
predict(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.dtComb_+3A_object">object</code></td>
<td>
<p>a <code>list</code> object where the parameters from the training
model are saved.</p>
</td></tr>
<tr><td><code id="predict.dtComb_+3A_newdata">newdata</code></td>
<td>
<p>a <code>numeric</code> new data set that includes biomarkers that
have not been introduced to the model before.</p>
</td></tr>
<tr><td><code id="predict.dtComb_+3A_...">...</code></td>
<td>
<p>further arguments. Currently has no effect on the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> predicted combination scores (or probabilities)
and labels
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# call data
data(laparoscopy)

# define the function parameters
markers &lt;- laparoscopy[, -1]
status &lt;- factor(laparoscopy$group, levels = c("not_needed", "needed"))
event &lt;- "needed"

score1 &lt;- linComb(
  markers = markers, status = status, event = event,
  method = "logistic", resample = "none",
  standardize = "none", direction = "&lt;", cutoff.method = "Youden"
)

comb.score1 &lt;- predict(score1, markers)

score2 &lt;- nonlinComb(
  markers = markers, status = status, event = "needed", include.interact = TRUE,
  method = "polyreg", resample = "repeatedcv", nfolds = 5,
  nrepeats = 10, cutoff.method = "Youden", direction = "auto"
)

comb.score2 &lt;- predict(score2, markers)

score3 &lt;- mathComb(
  markers = markers, status = status, event = event,
  method = "distance", distance = "euclidean", direction = "auto",
  standardize = "tScore", cutoff.method = "Youden"
)

comb.score3 &lt;- predict(score3, markers)

</code></pre>

<hr>
<h2 id='print_train'>Print the summary of linComb, nonlinComb, mlComb and mathComb
functions.</h2><span id='topic+print_train'></span>

<h3>Description</h3>

<p>The <code>print_train</code> function prints the summary statistics of
the fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_train(print_model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_train_+3A_print_model">print_model</code></td>
<td>
<p>a <code>list</code> of parameters taken from the fitted model
that includes the combination method, resampling method, pre-processing
method, selected optimum parameters and the results of fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>No return value</code> writes a summary of the results to the console.
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>

<hr>
<h2 id='rocsum'>Generate ROC curves and related  statistics for the given markers and
Combination score.</h2><span id='topic+rocsum'></span>

<h3>Description</h3>

<p>The <code>rocsum</code> function returns the ROC curves with
coordinates, Area Under the Curves of markers and combination score, Area Under
the Curve comparison of markers and combination score, Confusion matrices for both
markers and combination score with the cutoff values derived from the ROC Curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rocsum(
  markers = NULL,
  comb.score = NULL,
  status = NULL,
  event = NULL,
  direction = c("auto", "&lt;", "&gt;"),
  conf.level = 0.95,
  cutoff.method = c("CB", "MCT", "MinValueSp", "MinValueSe", "ValueSp", "ValueSe",
    "MinValueSpSe", "MaxSp", "MaxSe", "MaxSpSe", "MaxProdSpSe", "ROC01", "SpEqualSe",
    "Youden", "MaxEfficiency", "Minimax", "MaxDOR", "MaxKappa", "MinValueNPV",
    "MinValuePPV", "ValueNPV", "ValuePPV", "MinValueNPVPPV", "PROC01", "NPVEqualPPV",
    "MaxNPVPPV", "MaxSumNPVPPV", "MaxProdNPVPPV", "ValueDLR.Negative",
    "ValueDLR.Positive", "MinPvalue", "ObservedPrev", "MeanPrev", "PrevalenceMatching"),
  show.plot = show.plot
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rocsum_+3A_markers">markers</code></td>
<td>
<p>a <code>numeric</code> data frame that includes two diagnostic tests
results</p>
</td></tr>
<tr><td><code id="rocsum_+3A_comb.score">comb.score</code></td>
<td>
<p>a matrix of <code>numeric</code> combination scores calculated
according to the given method</p>
</td></tr>
<tr><td><code id="rocsum_+3A_status">status</code></td>
<td>
<p>a <code>factor</code> vector that includes the actual disease
status of the patients</p>
</td></tr>
<tr><td><code id="rocsum_+3A_event">event</code></td>
<td>
<p>a <code>character</code> string that indicates the event in the status
to be considered as positive event</p>
</td></tr>
<tr><td><code id="rocsum_+3A_direction">direction</code></td>
<td>
<p>a <code>character</code> string determines in which direction the
comparison will be made.  “&gt;”: if the predictor values for the control group
are higher than the values of the case group (controls &gt; cases).
“&lt;”: if the predictor values for the control group are lower or equal than
the values of the case group (controls &lt; cases).</p>
</td></tr>
<tr><td><code id="rocsum_+3A_conf.level">conf.level</code></td>
<td>
<p>a <code>numeric</code> values determines the confidens interval
for the ROC curve(0.95, default).</p>
</td></tr>
<tr><td><code id="rocsum_+3A_cutoff.method">cutoff.method</code></td>
<td>
<p>a <code>character</code> string determines the cutoff method
for the ROC curve.</p>
</td></tr>
<tr><td><code id="rocsum_+3A_show.plot">show.plot</code></td>
<td>
<p>a <code>logical</code>. If TRUE, a ROC curve is plotted.
Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>numeric</code> ROC Curves, AUC statistics and Confusion
matrices.
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>

<hr>
<h2 id='std.test'>Standardization according to the training model parameters.</h2><span id='topic+std.test'></span>

<h3>Description</h3>

<p>The <code>std.test</code> Standardization parameters will be taken
from the fitted training model and applied to the new data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std.test(newdata, model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="std.test_+3A_newdata">newdata</code></td>
<td>
<p>a <code>numeric</code> data frame of biomarkers</p>
</td></tr>
<tr><td><code id="std.test_+3A_model">model</code></td>
<td>
<p>a <code>list</code> of parameters from the output of linComb,
nonlinComb, mlComb or mathComb functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> dataframe of standardized biomarkers
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>

<hr>
<h2 id='std.train'>Standardization according to the chosen method.</h2><span id='topic+std.train'></span>

<h3>Description</h3>

<p>The <code>std.train</code> Standardization (range, zScore etc.) can be
estimated from the training data and applied to any dataset with the same
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std.train(data, standardize = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="std.train_+3A_data">data</code></td>
<td>
<p>a <code>numeric</code> data frame of biomarkers</p>
</td></tr>
<tr><td><code id="std.train_+3A_standardize">standardize</code></td>
<td>
<p>a <code>character</code> string indicating the name of the
standardization method. The default option is no standardization applied.
Available options are:
</p>

<ul>
<li> <p><b>Z-score</b> <code>(zScore)</code>: This method scales the data to have a mean
of 0 and a standard deviation of 1. It subtracts the mean and divides by the standard
deviation for each feature. Mathematically,
</p>
<p style="text-align: center;"><code class="reqn"> Z-score = \frac{x - (\overline x)}{sd(x)}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker, <code class="reqn">\overline{x}</code> is the mean of the marker and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li>
<li> <p><b>T-score</b> <code>(tScore)</code>: T-score is commonly used
in data analysis to transform raw scores into a standardized form.
The standard formula for converting a raw score <code class="reqn">x</code> into a T-score is:
</p>
<p style="text-align: center;"><code class="reqn">T-score = \Biggl(\frac{x - (\overline x)}{sd(x)}\times 10 \Biggl) +50</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker, <code class="reqn">\overline{x}</code> is the mean of the marker
and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li>
<li> <p><b>Range (a.k.a. min-max scaling)</b> <code>(range)</code>: This method transforms data to
a specific range, between 0 and 1. The formula for this method is:
</p>
<p style="text-align: center;"><code class="reqn">Range = \frac{x - min(x)}{max(x) - min(x)}</code>
</p>

</li>
<li> <p><b>Mean</b> <code>(mean)</code>: This method, which helps
to understand the relative size of a single observation concerning
the mean of dataset, calculates the ratio of each data point to the mean value
of the dataset.
</p>
<p style="text-align: center;"><code class="reqn">Mean =  \frac{x}{\overline{x}}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker and <code class="reqn">\overline{x}</code> is the mean of the marker.
</p>
</li>
<li> <p><b>Deviance</b> <code>(deviance)</code>: This method, which allows for
comparison of individual data points in relation to the overall spread of
the data, calculates the ratio of each data point to the standard deviation
of the dataset.
</p>
<p style="text-align: center;"><code class="reqn">Deviance = \frac{x}{sd(x)}</code>
</p>

<p>where <code class="reqn">x</code> is the value of a marker and <code class="reqn">sd(x)</code> is the standard deviation of the marker.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> data.frame of standardized biomarkers
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># call data
data(laparoscopy)

# define the function parameters
markers &lt;- laparoscopy[, -1]
markers2 &lt;- std.train(markers, "deviance")

</code></pre>

<hr>
<h2 id='transform_math'>Mathematical transformations for biomarkers.</h2><span id='topic+transform_math'></span>

<h3>Description</h3>

<p>The <code>transform_math</code> function applies a user preference
transformation from <code>log</code> <code>exp</code> <code>sin</code> <code>cos</code> transformations
for biomarkers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_math(markers, transform)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_math_+3A_markers">markers</code></td>
<td>
<p>a <code>numeric</code> data frame that contains the biomarkers</p>
</td></tr>
<tr><td><code id="transform_math_+3A_transform">transform</code></td>
<td>
<p>a <code>numeric</code> string specifying the method used for transform
the markers. The available methods are: <code>log</code> <code>exp</code> <code>sin</code> <code>cos</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> dataframe of standardized biomarkers
</p>


<h3>Author(s)</h3>

<p>Serra Ilayda Yerlitas, Serra Bersan Gengec, Necla Kochan,
Gozde Erturk Zararsiz, Selcuk Korkmaz, Gokmen Zararsiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(laparoscopy)
markes &lt;- laparoscopy[, -1]
transform_math(markes, transform = "log")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
