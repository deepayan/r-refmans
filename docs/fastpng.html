<!DOCTYPE html><html lang="en-AU"><head><title>Help for package fastpng</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastpng}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#get_png_info'><p>Get information about a PNG file</p></a></li>
<li><a href='#raw_spec'><p>Create a specification for how raw bytes should be interpreted when passed</p>
to <code>write_png()</code></a></li>
<li><a href='#read_png'><p>Read a PNG</p></a></li>
<li><a href='#spng_decode_flags'><p>Flags for decoding</p></a></li>
<li><a href='#test_image'><p>Test images in various R formats</p></a></li>
<li><a href='#write_png'><p>Write PNG</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read and Write PNG Files with Configurable Decoder/Encoder
Options</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mike Cheng &lt;mikefc@coolbutuseless.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Read and write PNG images with arrays, rasters, native
    rasters, numeric arrays, integer arrays, raw vectors and indexed
    values.  This PNG encoder exposes configurable internal options
    enabling the user to select a speed-size tradeoff.  For example,
    disabling compression can speed up writing PNG by a factor of 50.
    Multiple image formats are supported including raster, native rasters,
    and integer and numeric arrays at color depths of 1, 2, 3 or 4. 16-bit
    images are also supported. This implementation uses the 'libspng' 'C'
    library which is available from
    <a href="https://github.com/randy408/libspng/">https://github.com/randy408/libspng/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/coolbutuseless/fastpng">https://github.com/coolbutuseless/fastpng</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/coolbutuseless/fastpng/issues">https://github.com/coolbutuseless/fastpng/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>colorfast</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorfast (&ge; 1.0.1)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, png, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Copyright:</td>
<td>The included 'libspng' code is Copyright (c) 2018-2023,
Randy &lt;randy408@protonmail.com&gt;. Sections within the 'libspng'
code are derived from 'libpng' and copyright attributed to
those authors. See 'COPYRIGHTS' for license information and
full attribution of all copyrighted sections of code.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-AU</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-14 00:58:30 UTC; mike</td>
</tr>
<tr>
<td>Author:</td>
<td>Mike Cheng [aut, cre, cph],
  Randy408 [aut, cph] (Author of bundled libspng),
  The PNG Reference Library Authors [aut, cph],
  Cosmin Truta [cph] (SSE2 optimised filter functions, NEON optimised
    filter functions, NEON optimised palette expansion functions),
  Glenn Randers-Pehrson [cph] (SSE2 optimised filter functions),
  Andreas Dilger [cph],
  Guy Eric Schalnat [cph],
  Mike Klein [ctb] (SSE2 optimised filter functions),
  Matt Sarett [ctb] (SSE2 optimised filter functions),
  James Yu [ctb] (NEON optimised filter functions),
  Mars Rullgard [ctb] (NEON optimised filter functions),
  Arm Holdings [cph] (NEON optimised palette expansion functions),
  Richard Townsend [ctb] (NEON optimised palette expansion functions)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-14 03:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='get_png_info'>Get information about a PNG file</h2><span id='topic+get_png_info'></span>

<h3>Description</h3>

<p>Get information about a PNG file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_png_info(src)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_png_info_+3A_src">src</code></td>
<td>
<p>PNG filename or raw vector containing PNG data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name list of information about the PNG image:
</p>

<dl>
<dt>width,height</dt><dd><p>Dimensions of PNG</p>
</dd>
<dt>bit_depth</dt><dd><p>Bit depth. 8 or 16 bits</p>
</dd>
<dt>color_type,color_desc</dt><dd><p>color type and its description</p>
</dd>
<dt>compression_method</dt><dd><p>Compression setting</p>
</dd>
<dt>filter_method,filter_desc</dt><dd><p>Filter method and description</p>
</dd>
<dt>interlace_method,interlace_desc</dt><dd><p>Interlace method and description</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Create a small grayscale PNG image and fetch its PNG info
mat &lt;- matrix(c(0L, 255L), 3, 4)
png_data &lt;- write_png(mat)
get_png_info(png_data)

</code></pre>

<hr>
<h2 id='raw_spec'>Create a specification for how raw bytes should be interpreted when passed
to <code>write_png()</code></h2><span id='topic+raw_spec'></span>

<h3>Description</h3>

<p>Create a specification for how raw bytes should be interpreted when passed
to <code>write_png()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raw_spec(width, height, depth, bits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raw_spec_+3A_width">width</code>, <code id="raw_spec_+3A_height">height</code></td>
<td>
<p>image dimensions</p>
</td></tr>
<tr><td><code id="raw_spec_+3A_depth">depth</code></td>
<td>
<p>number of colour channels. Integer value in range [1, 4]</p>
</td></tr>
<tr><td><code id="raw_spec_+3A_bits">bits</code></td>
<td>
<p>number of bits for each colour channel. Either 8 or 16.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list to pass to the <code>write_png(..., raw_spec = )</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw_spec(100, 20, 3, 8)
</code></pre>

<hr>
<h2 id='read_png'>Read a PNG</h2><span id='topic+read_png'></span>

<h3>Description</h3>

<p>Read a PNG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_png(
  src,
  type = c("array", "raster", "nativeraster", "indexed", "raw"),
  rgba = FALSE,
  flags = 1L,
  avoid_transpose = FALSE,
  array_type = c("dbl", "int")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_png_+3A_src">src</code></td>
<td>
<p>PNG image provided as either a file path, or a raw vector 
containing encoded PNG data</p>
</td></tr>
<tr><td><code id="read_png_+3A_type">type</code></td>
<td>
<p>type of R object in which to store image data. Valid types are
'array', 'raster', &quot;nativeraster&quot;, 'indexed' and 'raw'.  Note that indexed
image objects can only be loaded from indexed PNGs.</p>
</td></tr>
<tr><td><code id="read_png_+3A_rgba">rgba</code></td>
<td>
<p>Should the result be forced into RGBA?  Default: FALSE
means to use the most appropriate format of the given R image type 
to store the data.  If <code>TRUE</code>, then the image will be forced
into RGBA color mode.</p>
</td></tr>
<tr><td><code id="read_png_+3A_flags">flags</code></td>
<td>
<p>Flags to apply when reading PNG. Default: 1 (always decode transparency from tRNS chunks). 
See <code>?spng_decode_flags</code> for other options.  Must be an integer.</p>
</td></tr>
<tr><td><code id="read_png_+3A_avoid_transpose">avoid_transpose</code></td>
<td>
<p>Default: FALSE. If <code>TRUE</code>, then transposing the image
from row-major (in the PNG), into column-major (in R) will be avoided
if possible.  This option only applies when reading grayscale or
indexed images.  Since the transposition is avoided, the decode 
step can be faster, but the image will not be in the correct orientation.</p>
</td></tr>
<tr><td><code id="read_png_+3A_array_type">array_type</code></td>
<td>
<p>'dbl' or 'int'. Default: dbl.  When reading PNG into an array,
should the data be stored as a double (i.e. real) in the range [0, 1] 
or an integer in the range [0,255] (for 8 bit images) or 
[0,65535] (for 16 bit images).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R image object of the specified type
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a small greyscale matrix, and write it to a PNG file
ras &lt;- matrix(c('#880000', '#000088'), 3, 4) 
ras &lt;- grDevices::as.raster(ras)
pngfile &lt;- tempfile()
write_png(ras, file = pngfile)
ras2 &lt;- read_png(pngfile, type = 'raster')
plot(ras2, interpolate = FALSE)
</code></pre>

<hr>
<h2 id='spng_decode_flags'>Flags for decoding</h2><span id='topic+spng_decode_flags'></span>

<h3>Description</h3>


<dl>
<dt>SPNG_DECODE_TRNS</dt><dd><p>Apply transparency</p>
</dd>
<dt>SPNG_DECODE_GAMMA</dt><dd><p>Apply gamma correction</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>spng_decode_flags
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='test_image'>Test images in various R formats</h2><span id='topic+test_image'></span>

<h3>Description</h3>

<p>A nested named list of test images (300 x 200 pixels).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_image
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 9.
</p>


<h3>Details</h3>

<p>Possible image color spaces within each image type
</p>

<dl>
<dt>$gray</dt><dd><p>Gray pixels representing intensity only</p>
</dd>
<dt>$gray_alpha</dt><dd><p>Gray pixels with an alpha channel</p>
</dd>
<dt>$rgb</dt><dd><p>RGB color image</p>
</dd>
<dt>$rgba</dt><dd><p>RGB color image with alpha channel</p>
</dd>
</dl>

<p>A description of the image data within each image type
</p>

<dl>
<dt>test_image$array</dt><dd> 
<p>Arrays of numeric values in the range [0, 1]
</p>

<dl>
<dt>$gray</dt><dd><p>A 2D matrix</p>
</dd>
<dt>$gray_alpha</dt><dd><p>A 3D array with 2 planes i.e. <code>dim(x)[3] == 2</code></p>
</dd>
<dt>$rgb</dt><dd><p>A 3D array with 3 planes i.e. <code>dim(x)[3] == 2</code></p>
</dd>
<dt>$rgba</dt><dd><p>A 3D array with 4 planes i.e. <code>dim(x)[3] == 2</code></p>
</dd>
</dl>

</dd>
<dt>test_image$array_16bit</dt><dd> 
<p>Same as <code>test_image$array</code> data except values contain 16 bits of 
signficant color information.
</p>
</dd>
<dt>test_image$array_int</dt><dd> 
<p>Arrays of integer values in the range [0, 255]
</p>

<dl>
<dt>$gray</dt><dd><p>A 2D matrix</p>
</dd>
<dt>$gray_alpha</dt><dd><p>A 3D array with 2 planes i.e. <code>dim(x)[3] == 2</code></p>
</dd>
<dt>$rgb</dt><dd><p>A 3D array with 3 planes i.e. <code>dim(x)[3] == 2</code></p>
</dd>
<dt>$rgba</dt><dd><p>A 3D array with 4 planes i.e. <code>dim(x)[3] == 2</code></p>
</dd>
</dl>

</dd>
<dt>test_image$array_int_16bit</dt><dd> 
<p>Same as <code>test_image$array_int</code> data except values are in the 
range [0, 65535]
</p>
</dd>
<dt>test_image$raster</dt><dd> 

<dl>
<dt>$rgb</dt><dd><p>Raster image of color values given as hex codes <code>#RRGGBB</code></p>
</dd>
<dt>$rgba</dt><dd><p>Raster image of color values given as hex codes <code>#RRGGBBAA</code></p>
</dd>
<dt>$named</dt><dd><p>Raster image of color values given as R color names e.g. 'red', 'blue'</p>
</dd>
</dl>

</dd>
<dt>test_image$nativeraster</dt><dd> 
<p>Integer matrix of integer values. Each 32-bit numeric value holds a
packed RGBA pixel
</p>

<dl>
<dt>$rgba</dt><dd></dd>
</dl>

</dd>
<dt>test_image$indexed</dt><dd> 

<dl>
<dt>$integer_index</dt><dd><p>An integer matrix. Each value is an index into a
separately specified color-lookup table</p>
</dd>
<dt>$numeric_index</dt><dd><p>A numeric matrix. Each value is an index into a
separately specified color-lookup table</p>
</dd>
<dt>$palette</dt><dd><p>An example color palette to use with indexed images. 256 colors.</p>
</dd>
</dl>

</dd>
<dt>test_image$raw</dt><dd>
<p>Sequences of raw bytes with attributes specifying 'width', 'height', 'depth' 
(i.e. number of colors) and 'bits' (number of bits for each color)
</p>

<dl>
<dt>$gray</dt><dd><p>Sequence of gray pixels i.e. GGGG</p>
</dd>
<dt>$gray_alpha</dt><dd><p>Sequence of GA pixels i.e. GAGAGA...</p>
</dd>
<dt>$rgb</dt><dd><p>Sequence of RGB pixels i.e. RGBRGBRGB...</p>
</dd>
<dt>$rgba</dt><dd><p>Sequence of RGB pixels i.e. RGBARGBARGBA...</p>
</dd>
</dl>

</dd>
<dt>test_image$raw_16_bit</dt><dd> 
<p>The same as <code>test_image$raw</code> except each color takes 2 raw bytes.
</p>
</dd>
</dl>


<hr>
<h2 id='write_png'>Write PNG</h2><span id='topic+write_png'></span>

<h3>Description</h3>

<p>Write PNG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_png(
  image,
  file = NULL,
  palette = NULL,
  use_filter = TRUE,
  compression_level = -1L,
  avoid_transpose = FALSE,
  bits = 8,
  trns = NULL,
  raw_spec = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_png_+3A_image">image</code></td>
<td>
<p>image.  Supported image types:
</p>

<dl>
<dt>Numeric arrays</dt><dd><p>Numeric arrays with values in the range [0, 1], with
1, 2, 3 or 4 colour planes to represent gray, gray+alpha, rgb
and rgba pixels, respectively</p>
</dd>
<dt>Rasters</dt><dd><p>Rasters with a mixture of named colours (e.g. 'red'),
and hex colours of the form #RGB, #RGBA, #RRGGBB and #RRGGBBAA</p>
</dd>
<dt>Integer arrays</dt><dd><p>Integer arrays with values in [0,255] treated as
8-bit image data.  Integer arrays with values in [0, 65535] treated as
16-bit image data</p>
</dd>
<dt>Native rasters</dt><dd><p>Integer matrices containing colurs in native format
i.e. 8-bit RGBA values packed into a single integer</p>
</dd>
<dt>Integer matrix + an indexed palette of colors</dt><dd><p>Can be saved as 
an indexed PNG</p>
</dd>
<dt>Raw vectors</dt><dd><p>Vectors of raw bytes must be accompanied by a 
<code>raw_spec</code> which details how the bytes are to be interpreted
e.g. colour depth, width and height</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="write_png_+3A_file">file</code></td>
<td>
<p>If NULL (the default) then return PNG data as raw vector, otherwise write
to the given file path.</p>
</td></tr>
<tr><td><code id="write_png_+3A_palette">palette</code></td>
<td>
<p>character vector of up to 256 colors. If specified, and the
image is a 2D matrix of integer or numeric values, then an indexed 
PNG is written where the matrix values indicate the colour palette
value to use. The values in the matrix must range from 0 (for the 
first colour)</p>
</td></tr>
<tr><td><code id="write_png_+3A_use_filter">use_filter</code></td>
<td>
<p>Use PNG filtering to help reduce size? Default: TRUE.
If FALSE, then filtering will be disabled which can make 
image writing faster.</p>
</td></tr>
<tr><td><code id="write_png_+3A_compression_level">compression_level</code></td>
<td>
<p>compression level for PNG. Default: -1 means
to use the default compression level.  Other valid
values are in range [0, 9].  In general, lower compression levels
result in faster compression, but larger image sizes.  For fastest
image writing, set <code>compression_level</code>
to 0 to completely disable compression.</p>
</td></tr>
<tr><td><code id="write_png_+3A_avoid_transpose">avoid_transpose</code></td>
<td>
<p>Should transposition be avoided if possible so as to 
maximise the speed of writing the PNG?  Default: FALSE.  
PNG is a row-major image format, but R stores data in column-major
ordering.  When writing data to PNG, it is often necessary to transpose
the R data to match what PNG requires.  If this option is set 
to <code>TRUE</code> then the image is written without this transposition and 
should speed up PNG creation.  This option only has an effect
for 2D integer and numeric matrix formats.</p>
</td></tr>
<tr><td><code id="write_png_+3A_bits">bits</code></td>
<td>
<p>bit depth. default 8.  Valid values are 8 and 16.  This option
only has an effect when image to output is a numeric array.</p>
</td></tr>
<tr><td><code id="write_png_+3A_trns">trns</code></td>
<td>
<p>color to be treated as transparent
in RGB and Greyscale images - without specifying a full alpha channel.  
Only a single color can be specified and it will be treated as a 
fully transparent color in the image.  This setting is only used 
when writing RGB and Greyscale images.  For 8-bit RGB images, the value
may be a hex color value i.e. <code>"#RRGGBB"</code> or a vector of 3 numeric
values in the range [0, 255].  For 8-bit greyscale images,
must be a single integer value in the range [0, 255].
For 16-bit RGB images, the value
may be a vector of 3 numeric
values in the range [0, 65535].  For 16-bit greyscale images,
must be a single integer value in the range [0, 65535].
Default: NULL - means to not add a transparency color.</p>
</td></tr>
<tr><td><code id="write_png_+3A_raw_spec">raw_spec</code></td>
<td>
<p>named list of image specifications for encoding a raw vector
to PNG. Use <code>raw_spec()</code> to create such a list in the correct format.
This argument is only required if the <code>image</code> argument is a 
raw vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>file</code> argument provided, function writes to file and returns 
nothing, otherwise it returns a raw vector holding the PNG
encoded data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a small greyscale integer matrix, and write it to a PNG file
mat &lt;- matrix(c(0L, 255L), 3, 4)
pngfile &lt;- tempfile()
write_png(mat, file = pngfile)
im &lt;- read_png(pngfile, type = 'raster') 
plot(im, interpolate = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
