<!DOCTYPE html><html lang="en"><head><title>Help for package Rook</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rook}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Rook-package'>
<p>Rook: A web server interface and package for R</p></a></li>
<li><a href='#App-class'><p>Class <code>App</code></p></a></li>
<li><a href='#Brewery-class'><p>Class <code>Brewery</code></p></a></li>
<li><a href='#Builder-class'><p>Class <code>Builder</code></p></a></li>
<li><a href='#File-class'><p>Class <code>File</code></p></a></li>
<li><a href='#is_rookable'>
<p>Test for Rookable applications</p></a></li>
<li><a href='#Middleware-class'><p>Class <code>Middleware</code></p></a></li>
<li><a href='#Mime-class'><p>Class <code>Mime</code> and object <code>Mime</code></p></a></li>
<li><a href='#Multipart-class'><p>Class <code>Multipart</code> and object <code>Multipart</code></p></a></li>
<li><a href='#Redirect-class'><p>Class <code>Redirect</code></p></a></li>
<li><a href='#Request-class'><p>Class <code>Request</code></p></a></li>
<li><a href='#Response-class'><p>Class <code>Response</code></p></a></li>
<li><a href='#Rhttpd-class'><p>Class <code>Rhttpd</code></p></a></li>
<li><a href='#RhttpdApp-class'><p>Class <code>RhttpdApp</code></p></a></li>
<li><a href='#RhttpdErrorStream-class'><p>Class <code>RhttpdErrorStream</code></p></a></li>
<li><a href='#RhttpdInputStream-class'><p>Class <code>RhttpdInputStream</code></p></a></li>
<li><a href='#Server'><p>Rook Server Object</p></a></li>
<li><a href='#Static-class'><p>Class <code>Static</code></p></a></li>
<li><a href='#suspend_console'>
<p>Suspend the R console</p></a></li>
<li><a href='#URLMap-class'><p>Class <code>URLMap</code></p></a></li>
<li><a href='#Utils-class'><p>Class <code>Utils</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>HTTP Web Server for R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-05</td>
</tr>
<tr>
<td>Description:</td>
<td>An HTTP web server for R with a documented API to interface between R and the server. The documentation contains the Rook specification and details for building and running Rook applications. To get started, be sure and read the 'Rook' help file first.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.13.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, tools, methods, brew</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/evanbiederstedt/rook">https://github.com/evanbiederstedt/rook</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/evanbiederstedt/rook/issues">https://github.com/evanbiederstedt/rook/issues</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey Horner [aut], Evan Biederstedt [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Biederstedt &lt;evan.biederstedt@gmail.com&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-05 23:55:46 UTC; evanbiederstedt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-07 08:50:19 UTC</td>
</tr>
</table>
<hr>
<h2 id='Rook-package'>
Rook: A web server interface and package for R
</h2><span id='topic+Rook-package'></span><span id='topic+Rook'></span>

<h3>Description</h3>

<p>This help page defines the Rook specification. It borrows heavily
from Ruby's Rack project: <a href="https://github.com/rack/rack">https://github.com/rack/rack</a>.
</p>
<p>After reading this document, read the <code><a href="#topic+Rhttpd">Rhttpd</a></code> help file
as it will get you familiar with installing and running <code>Rook</code>
applications. Then explore the example applications located in:
</p>
<p><code>system.file('exampleApps',package='Rook')</code>.
</p>


<h3>Rook applications</h3>

<p>A Rook application is an R reference class object that implements a 'call'
method or an R closure that takes exactly one argument, an environment,
and returns a list with three named elements: <code>'status'</code>, <code>'headers'</code>,
and <code>'body'</code>.
</p>


<h3>Hello World</h3>

<p>Here is a basic Rook application as a closure that implements 'hello world':
</p>
<pre>
function(env){
    body = paste('&lt;h1&gt;Hello World! This is Rook',env$rook.version,'.&lt;/h1&gt;')
    list(
        status = 200L,
        headers = list(
            'Content-Type' = 'text/html'
        ),
        body = body
    )
}
</pre>
<p>And the equivalent reference class example:
</p>
<pre>
setRefClass(
  'HelloWorld',
  methods = list(
    call = function(env){
      list(
        status = 200L,
        headers = list(
         'Content-Type' = 'text/html'
        ),
        body = paste('&lt;h1&gt;Hello World! This is Rook',env$rook.version,'.&lt;/h1&gt;')
      )
    }
  )
)
</pre>


<h3>The Environment</h3>

<p>The environment argument is a true R environment object which the
application is free to modify. It is required to contain the following
variables:
</p>

<dl>
<dt>REQUEST_METHOD</dt><dd><p> The HTTP request method, such as &quot;GET&quot; or &quot;POST&quot;. This
cannot ever be an empty string, and so is always required. </p>
</dd>
<dt>SCRIPT_NAME</dt><dd><p> The initial portion of the request URL's &quot;path&quot; that
corresponds to the application object, so that the application knows
its virtual &quot;location&quot;. This may be an empty string, if the application
corresponds to the &quot;root&quot; of the server.</p>
</dd>
<dt>PATH_INFO</dt><dd><p> The remainder of the request URL's &quot;path&quot;, designating the
virtual &quot;location&quot; of the request's target within the application. This
may be an empty string, if the request URL targets the application root
and does not have a trailing slash. This value may be percent-encoded
when I originating from a URL.</p>
</dd>
<dt>QUERY_STRING</dt><dd><p> The portion of the request URL that follows the ?,
if any. May be empty, but is always required!</p>
</dd>
<dt>SERVER_NAME, SERVER_PORT</dt><dd><p> When combined with SCRIPT_NAME and PATH_INFO,
these variables can be used to complete the URL. Note however that
HTTP_HOST, if present, should be used in preference to SERVER_NAME for
reconstructing the request URL. SERVER_NAME and SERVER_PORT can never
be empty strings, and so are always required.</p>
</dd>
<dt>HTTP_ Variables</dt><dd><p> Variables corresponding to the client-supplied
HTTP request headers (i.e., variables whose names begin with HTTP_). The
presence or absence of these variables should correspond with the presence
or absence of the appropriate HTTP header in the request.</p>
</dd>
</dl>

<p>In addition, the environment must include the following Rook-specific variables:
</p>

<dl>
<dt>rook.version</dt><dd><p> This version of Rook.</p>
</dd>
<dt>rook.url_scheme</dt><dd><p>'http' or 'https', depending on the request URL.</p>
</dd>
<dt>rook.input</dt><dd><p>See &ldquo;The Input Stream&rdquo; section.</p>
</dd>
<dt>rook.errors</dt><dd><p>See &ldquo;The Error Stream&rdquo; section.</p>
</dd>
</dl>



<h3>The Input Stream</h3>

<p>The rook.input variable must contain an object created from a reference
class that implements <code>read_lines()</code>, <code>read()</code>, and <code>rewind()</code>:
</p>

<dl>
<dt><code>read_lines(l=-1L)</code>:</dt><dd><p>takes one argument, the number of lines to read. Includes partial ending line.</p>
</dd>
<dt><code>read(l=-1L)</code>:</dt><dd><p>takes one argument, the number of bytes to read. Returns a raw vector.</p>
</dd>
<dt><code>rewind()</code>:</dt><dd><p>Rewinds the input stream back to the beginning.</p>
</dd>
</dl>



<h3>The Error Stream</h3>

<p>The rook.error variable must contain an object created from a reference
class that implements <code>flush()</code> and <code>cat()</code>:
</p>

<dl>
<dt><code>flush()</code>:</dt><dd><p>called with no arguments and makes the error stream immediately appear.</p>
</dd>
<dt><code>cat(...,sep=" ",fill=FALSE,labels=NULL)</code>:</dt><dd><p>called with the same arguments as R's <code>"<a href="base.html#topic+cat">cat</a>"</code> without the <code>file</code> and append <code>argument</code>.</p>
</dd>
</dl>



<h3>The Response</h3>

<p>Rook applications return a list with three named elements: <code>'status'</code>, <code>'headers'</code>,
and <code>'body'</code>.
</p>


<h4><code>'status'</code></h4>

<p>An HTTP status value as integer and must be greater than or equal to 100. 
</p>



<h4><code>'headers'</code></h4>

<p>A named list that contains only character values corresponding to valid HTTP headers.
</p>



<h4><code>'body'</code></h4>

<p>Either a character or raw vector. If the character vector is named
with value <code>'file'</code> then value of the vector is interpreted as the
location of a file.
</p>


<h3>Author(s)</h3>

<p> Jeffrey Horner &lt;jeffrey.horner@gmail.com&gt; </p>

<hr>
<h2 id='App-class'>Class <code>App</code></h2><span id='topic+App-class'></span><span id='topic+App'></span>

<h3>Description</h3>

<p>Abstract class from which <code>Middleware</code> and <code>Builder</code> inherit. Provides the <code>app</code> field.
</p>
<p><code>App</code> can also be used to instantiate reference classed applications wrapped around a function. See <code><a href="#topic+Middleware">Middleware</a></code> for an example.
</p>


<h3>Fields</h3>


<dl>
<dt><code>app</code>:</dt><dd><p>A Rook application.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>new(app=NULL)</code>:</dt><dd><p> Creates a new <code>App</code> object. <code>app</code> is any <code>Rook</code> aware R object.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+is_rookable">is_rookable</a></code>, <code><a href="#topic+Builder">Builder</a></code>, and <code><a href="#topic+Middleware">Middleware</a></code>.
</p>

<hr>
<h2 id='Brewery-class'>Class <code>Brewery</code></h2><span id='topic+Brewery-class'></span><span id='topic+Brewery'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+Middleware">Middleware</a></code> class for mapping URLs to a directory of files that are subsequently passed to <code><a href="brew.html#topic+brew">brew</a></code>. When a file is brewed, the two variables <code>req</code> (an object of class <code><a href="#topic+Request">Request</a></code>) and <code>res</code> (an object of class <code><a href="#topic+Response">Response</a></code>) are available for use.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(url,root,...):</code></dt><dd>
<p><code>url</code> is a character string or <code><a href="base.html#topic+regexp">regexp</a></code> on which to match, <code>root</code> is the name of the directory where brew files reside. Named arguments can be passed in via <code>...</code> and will be available within the scope of each brewed file.
</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Rhttpd">Rhttpd</a></code>, <code><a href="#topic+Builder">Builder</a></code>, <code><a href="#topic+Redirect">Redirect</a></code>, and <code><a href="brew.html#topic+brew">brew</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# This application runs any file found in tempdir() through brew.
#
s &lt;- Rhttpd$new()
## Not run: 
s$start(quiet=TRUE)

## End(Not run)
cat("&lt;h1&gt;Random Number: &lt;%=rnorm(1)%&gt;&lt;/h1&gt;",
    file=file.path(tempdir(),"index.html"))
s$add(name="random",
    app=Builder$new(
        Brewery$new(url="/",root=tempdir()),
        Redirect$new("/index.html")
    )
)
## Not run: 
s$browse('random') # Opens a browser window to the app.

## End(Not run)
file.remove(file.path(tempdir(),"index.html"))
s$remove(all=TRUE)
rm(s)
</code></pre>

<hr>
<h2 id='Builder-class'>Class <code>Builder</code></h2><span id='topic+Builder-class'></span><span id='topic+Builder'></span>

<h3>Description</h3>

<p>A convenience object for combining various <code>Middleware</code> with a default application to create a more complex Rook application.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(...)</code>:</dt><dd><p> Arguments can be any <code>Middleware</code> object while the last argument in the list must be a valid <code>Rook</code> application. That is, it will handle the incoming request without deferring to another application. </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Rhttpd">Rhttpd</a></code>, <code><a href="#topic+Static">Static</a></code>, <code><a href="#topic+Brewery">Brewery</a></code>, and <code><a href="#topic+Redirect">Redirect</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The following is the Hmisc example. Explore the folder
# system.file('exampleApps/Hmisc',package='Rook') for more information.
s &lt;- Rhttpd$new()
## Not run: 
library(Hmisc)
dir.create(file.path(tempdir(),'plots'),showWarnings=FALSE)
s$add( name="Hmisc",
    app=Builder$new(
        Static$new(
            urls = c('/css','/images','/javascript'),
            root = system.file('exampleApps/Hmisc',package='Rook')
        ),
        Static$new(urls='/plots',root=tempdir()),
        Brewery$new(
            url='/brew',
            root= system.file('exampleApps/Hmisc',package='Rook'),
            imagepath=file.path(tempdir(),'plots'),
            imageurl='../plots/'
        ),
        Redirect$new('/brew/useR2007.rhtml')
    )
)
s$start(quiet=TRUE)
s$browse('Hmisc') # Opens a browser window to the application.
s$remove(all=TRUE)
s$stop()

## End(Not run)
</code></pre>

<hr>
<h2 id='File-class'>Class <code>File</code></h2><span id='topic+File-class'></span><span id='topic+File'></span>

<h3>Description</h3>

<p>A Rook application that serves static files from a root directory, according to the path info of the Rook request.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(root):</code></dt><dd>
<p><code>root</code> is the name of the directory from where to serve files.
</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+Rhttpd">Rhttpd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This example serves all your files in /etc (on UNIX and Mac only).
#
# Note that when you open the application, you will see the word
# 'Forbidden'. "File" doesn't serve directories, so you must amend the
# url in the location bar with the file you want to view. Try adding /passwd.

s &lt;- Rhttpd$new()
## Not run: 
s$start(quiet=TRUE)

## End(Not run)
s$add(name="etc",app=File$new('/etc'))
## Not run: 
s$browse('etc') # Opens a browser window to the app.

## End(Not run)
s$remove(all=TRUE)
rm(s)
</code></pre>

<hr>
<h2 id='is_rookable'>
Test for Rookable applications
</h2><span id='topic+is_rookable'></span>

<h3>Description</h3>

<p>A convenience function for testing whether or not objects are either a function or reference class as defined by the Rook specification for applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rookable(app)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_rookable_+3A_app">app</code></td>
<td>
<p> Any R object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical determining whether or not argument is Rookable. Not vectorized.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rook">Rook</a></code>.
</p>

<hr>
<h2 id='Middleware-class'>Class <code>Middleware</code></h2><span id='topic+Middleware-class'></span><span id='topic+Middleware'></span>

<h3>Description</h3>

<p>An abstract class for building Rook Middleware applications. <code>Middleware</code> applications either handle the incoming web request or hand off the request to the Rook app defined in the field of the same name.
</p>


<h3>Methods</h3>


<dl>
<dt><code>set_app(app)</code>:</dt><dd> <p><code>app</code> is a <code><a href="#topic+Rook">Rook</a></code> application that will handle the request if this Middleware app does not. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>The following classes implement Middleware: 
<code><a href="#topic+Brewery">Brewery</a></code> and <code><a href="#topic+Static">Static</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Middleware applications are typically instantiated in the argument list of
# Builder$new(), but here is stand-alone example.
# 
# Once your browser loads the app, you will see something like this in
# your location bar: http://127.0.0.1:28649/custom/middle. Add '/foo'
# onto the end of that and reload.

setRefClass(
    'FooBar',
    contains = 'Middleware',
    methods = list(
        initialize = function(...){
            # app to defer to.
            callSuper(app=App$new(function(env){
                res &lt;- Response$new()
                res$write("&lt;h1&gt;I'm the deferred app.&lt;/h1&gt;")
                res$finish()
            }))
        },
        call = function(env){
            req &lt;- Request$new(env)
            res &lt;- Response$new()
            if (length(grep('foo',req$path_info()))){
                res$write("&lt;h1&gt;I'm the middleware app.&lt;/h1&gt;")        
                return(res$finish())
            } else {
                app$call(env)
            }
        }
    )
)
s &lt;- Rhttpd$new()
## Not run: 
s$start(quiet=TRUE)

## End(Not run)
s$add(name="middle",app=getRefClass('FooBar')$new())
## Not run: 
s$browse('middle') # Opens a browser window to the app.

## End(Not run)
s$remove(all=TRUE)
rm(s)
</code></pre>

<hr>
<h2 id='Mime-class'>Class <code>Mime</code> and object <code>Mime</code></h2><span id='topic+Mime-class'></span><span id='topic+Mime'></span>

<h3>Description</h3>

<p>A convenience object for determining the MIME type of a file name.
</p>


<h3>Methods</h3>


<dl>
<dt><code>file_extname(fname=NULL)</code>:</dt><dd><p> Returns the file extensions for the given file.</p>
</dd>
<dt><code>mime_type(ext=NULL, fallback='application/octet-stream')</code>:</dt><dd><p> Returns the MIME type given the file extension. Be sure to include the dot character in <code>ext</code>. If no match is found, then the fallback MIME type is returned.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>Mime$file_extname('foo.png')
Mime$mime_type('.png')
</code></pre>

<hr>
<h2 id='Multipart-class'>Class <code>Multipart</code> and object <code>Multipart</code></h2><span id='topic+Multipart-class'></span><span id='topic+Multipart'></span>

<h3>Description</h3>

<p>A convenience object for parsing multipart/form-data POST payloads.
</p>


<h3>Methods</h3>


<dl>
<dt><code>parse(env)</code>:</dt><dd><p> Returns parsed POST payload as a named list. <code>env</code> is an environment created by <code>Rhttpd</code> and conforms to the <code><a href="#topic+Rook">Rook</a></code> specification.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Rhttpd">Rhttpd</a></code>, <code><a href="#topic+Request">Request</a></code>, and <code><a href="#topic+Response">Response</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- Rhttpd$new()
## Not run: 
s$start(quiet=TRUE)

## End(Not run)
s$add(name="multi",
    app=function(env){
        req &lt;- Request$new(env)
        res &lt;- Response$new()
        res$write('&lt;form enctype="multipart/form-data" method=POST&gt;')
        res$write('Upload a file: &lt;input type=file name=fileUpload&gt;')
        res$write('&lt;input type=submit&gt;&lt;/form&gt;&lt;br&gt;')
        post &lt;- Multipart$parse(env)
        if (length(post)){
            poststr &lt;- paste(capture.output(str(post),file=NULL),collapse='\n')
            res$write(c('&lt;pre&gt;',poststr,'&lt;/pre&gt;'))
        }
        res$finish()
    }
)
## Not run: 
s$browse('multi') # Opens a browser window to the app.

## End(Not run)
s$remove(all=TRUE)
rm(s)
</code></pre>

<hr>
<h2 id='Redirect-class'>Class <code>Redirect</code></h2><span id='topic+Redirect-class'></span><span id='topic+Redirect'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+Rook">Rook</a></code> application whose only role is to return an HTTP redirect header to the given url.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(url)</code>:</dt><dd><p> Returns a <code>Rook</code> object. <code>url</code> is a character string whose value is a full or relative url to which the browser is redirected.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <code><a href="#topic+Brewery">Brewery</a></code> for an example. 
</p>

<hr>
<h2 id='Request-class'>Class <code>Request</code></h2><span id='topic+Request-class'></span><span id='topic+Request'></span>

<h3>Description</h3>

<p>A convenience class for working with a <code><a href="#topic+Rook">Rook</a></code> environment. Be sure to see the example at the end of this help file.
</p>


<h3>Methods</h3>


<dl>
<dt><code>parseable_data()</code>:</dt><dd><p> Returns a boolean value determining if the POST payload is parseable. </p>
</dd>
<dt><code>url()</code>:</dt><dd><p> Returns url as a character string containing the scheme, host, port, and possibly the GET query string if supplied.</p>
</dd>
<dt><code>request_method()</code>:</dt><dd><p> Returns the HTTP method as a character string, e.g. 'GET', 'POST', etc. </p>
</dd>
<dt><code>GET()</code>:</dt><dd><p> Returns a named list containing the variables parsed from the query string. </p>
</dd>
<dt><code>post()</code>:</dt><dd><p> Returns TRUE if the current request method is 'POST', FALSE otherwise. </p>
</dd>
<dt><code>new(env)</code>:</dt><dd><p> Instantiates a new <code>Request</code> object for the given <code>Rook</code> environment.</p>
</dd>
<dt><code>media_type()</code>:</dt><dd><p> Returns the media type for the current request as a character string.</p>
</dd>
<dt><code>query_string()</code>:</dt><dd><p> Returns the unparsed query string. </p>
</dd>
<dt><code>fullpath()</code>:</dt><dd><p> Returns the same string as url() but without the scheme, host, and port. </p>
</dd>
<dt><code>referer()</code> or <code>referrer()</code>:</dt><dd><p> Returns the referring url.  </p>
</dd>
<dt><code>cookies()</code>:</dt><dd><p> Returns any cookies in the request as a named list. </p>
</dd>
<dt><code>content_charset()</code>:</dt><dd><p> Returns the content charset as a character string. </p>
</dd>
<dt><code>head()</code>:</dt><dd><p> Returns TRUE if the HTTP method is 'HEAD', FALSE otherwise.</p>
</dd>
<dt><code>accept_encoding()</code>:</dt><dd><p> Returns the accept encoding header as a character string.</p>
</dd>
<dt><code>content_length()</code>:</dt><dd><p> Returns content length header value as a string. </p>
</dd>
<dt><code>form_data()</code>:</dt><dd><p> Returns TRUE if there's form data, e.g. POST data with the request, FALSE otherwise.</p>
</dd>
<dt><code>xhr()</code>:</dt><dd><p> Returns the x-requested-with header value as a character string.</p>
</dd>
<dt><code>params()</code>:</dt><dd><p> Returns the combination of <code>POST()</code> and <code>GET()</code> in one named list.</p>
</dd>
<dt><code>media_type_params()</code>:</dt><dd><p> Returns any media type parameters from the content type as a named list. </p>
</dd>
<dt><code>user_agent()</code>:</dt><dd><p> Returns the user-agent header value as a character string. </p>
</dd>
<dt><code>put()</code>:</dt><dd><p> Returns TRUE if the current request is a 'PUT'. </p>
</dd>
<dt><code>get()</code>:</dt><dd><p> Returns TRUE if the current request is a 'GET'. </p>
</dd>
<dt><code>path()</code>:</dt><dd><p> Returns a character string like <code>fullpath()</code> but without the query string. </p>
</dd>
<dt><code>body()</code>:</dt><dd><p> Returns the 'rook.input' object from the environment. See <code><a href="#topic+RhttpdInputStream">RhttpdInputStream</a></code> for more information.</p>
</dd>
<dt><code>port()</code>:</dt><dd><p> Returns the server port as an integer.e</p>
</dd>
<dt><code>host_with_port()</code>:</dt><dd><p> Returns the host and port as a character string separated by ':'. </p>
</dd>
<dt><code>scheme()</code>:</dt><dd><p> Returns the scheme, e.g. 'http' or 'https', as a character string. </p>
</dd>
<dt><code>ip()</code>:</dt><dd><p> Returns the remote IP address as a character string. </p>
</dd>
<dt><code>options()</code>:</dt><dd><p> Returns TRUE if the current request is 'OPTIONS'. </p>
</dd>
<dt><code>to_url(url, ...)</code>:</dt><dd><p> Concatenates the script name with the <code>url</code> argument along with any named parameters passed via <code>...</code> .</p>
</dd>
<dt><code>host()</code>:</dt><dd><p> Returns the server host as a character string. </p>
</dd>
<dt><code>POST()</code>:</dt><dd><p> Returns a named list containing the variables parsed from the POST payload.</p>
</dd>
<dt><code>trace()</code>:</dt><dd><p> Returns TRUE if the current request is 'TRACE'. </p>
</dd>
<dt><code>script_name(s=NULL)</code>:</dt><dd><p> Returns the script name of the application, e.g. '/custom/multi'. Also, if <code>s</code> is not NULL, sets the script name to <code>s</code>. </p>
</dd>
<dt><code>content_type()</code>:</dt><dd><p> Returns the content-type header value as a character string. </p>
</dd>
<dt><code>delete()</code>:</dt><dd><p> Returns TRUE if the current request is 'DELETE'. </p>
</dd>
<dt><code>path_info(s=NULL)</code>:</dt><dd><p> Returns the portion of the url after the script name as a character string. If <code>s</code> is not NULL, sets the path info to <code>s</code>.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Rhttpd">Rhttpd</a></code> and <code><a href="#topic+Response">Response</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# The following example prints out the result of each method.
# 
ls_str &lt;- function(s) paste(capture.output(str(s),file=NULL),collapse='\n')
s &lt;- Rhttpd$new()
## Not run: 
s$start(quiet=TRUE)

## End(Not run)
s$add(name="request",
    app=function(env){
        req &lt;- Request$new(env)
        res &lt;- Response$new()
        res$set_cookie('imacookie','42')
        action &lt;- req$to_url('/foo',bar=1,baz='three')
        res$write('&lt;form enctype="multipart/form-data" method=POST action="')
        res$write(action)
        res$write('"&gt;')
        res$write('Upload a file: &lt;input type=file name=fileUpload&gt;')
        res$write('&lt;input type=submit&gt;&lt;/form&gt;&lt;br&gt;&lt;pre&gt;')
        res$write(c('parseable_data: ',req$parseable_data(),'\n'))
        res$write(c('url: ',req$url(),'\n'))
        res$write(c('request_method: ',req$request_method(),'\n'))
        res$write(c('GET: ',ls_str(req$GET()),'\n'))
        res$write(c('post: ',req$post(),'\n'))
        res$write(c('media_type: ',req$media_type(),'\n'))
        res$write(c('query_string: ',req$query_string(),'\n'))
        res$write(c('fullpath: ',req$fullpath(),'\n'))
        res$write(c('referer: ',req$referer(),'\n'))
        res$write(c('cookies: ',ls_str(req$cookies()),'\n'))
        res$write(c('content_charset: ',req$content_charset(),'\n'))
        res$write(c('head: ',req$head(),'\n'))
        res$write(c('accept_encoding: ',req$accept_encoding(),'\n'))
        res$write(c('content_length: ',req$content_length(),'\n'))
        res$write(c('form_data: ',req$form_data(),'\n'))
        res$write(c('xhr: ',req$xhr(),'\n'))
        res$write(c('params: ',ls_str(req$params()),'\n'))
        res$write(c('media_type_params:\n',ls_str(req$media_type_params()),'\n'))
        res$write(c('user_agent: ',req$user_agent(),'\n'))
        res$write(c('put: ',req$put(),'\n'))
        res$write(c('get: ',req$get(),'\n'))
        res$write(c('path: ',req$path(),'\n'))
        res$write(c('body: ',ls_str(req$body()),'\n'))
        res$write(c('port: ',req$port(),'\n'))
        res$write(c('host_with_port: ',req$host_with_port(),'\n'))
        res$write(c('scheme: ',req$scheme(),'\n'))
        res$write(c('ip: ',req$ip(),'\n'))
        res$write(c('options: ',req$options(),'\n'))
        res$write(c('to_url: ',req$to_url('foo',bar=1,baz='two'),'\n'))
        res$write(c('host: ',req$host(),'\n'))
        res$write(c('POST: ',ls_str(req$POST()),'\n'))
        res$write(c('trace: ',req$trace(),'\n'))
        res$write(c('script_name: ',req$script_name(),'\n'))
        res$write(c('content_type: ',req$content_type(),'\n'))
        res$write(c('delete: ',req$delete(),'\n'))
        res$write(c('path_info: ',req$path_info(),'\n'))
        res$write(c('\nRac env: ',ls_str(as.list(env)),'\n'))
        res$finish()
    }
)
## Not run: 
s$browse('request') # Opens a browser window to the app.

## End(Not run)
s$remove(all=TRUE)
rm(s)
</code></pre>

<hr>
<h2 id='Response-class'>Class <code>Response</code></h2><span id='topic+Response-class'></span><span id='topic+Response'></span>

<h3>Description</h3>

<p>A convenience class for creating <code><a href="#topic+Rook">Rook</a></code> responses.
</p>


<h3>Methods</h3>


<dl>
<dt><code>header(key, value)</code>:</dt><dd><p> Sets an HTTP header for the
response. Both <code>key</code> and <code>value</code> must be character strings. If <code>value</code> is missing, then the <code>header</code> value is returned.</p>
</dd>
<dt><code>redirect(target, status=302)</code>:</dt><dd><p> Sets up an HTTP redirect to the <code>target</code> url. </p>
</dd>
<dt><code>write(str)</code>:</dt><dd><p> Takes a character vector and appends it to the response body. </p>
</dd>
<dt><code>new(body='', status=200, headers=list())</code>:</dt><dd><p> Create a new Response object. <code>body</code> is a character vector, <code>status</code> is an HTTP status value. <code>headers</code> is a named list.</p>
</dd>
<dt><code>set_cookie(key, value)</code>:</dt><dd><p> Sets an HTTP cookie for the response. Both <code>key</code> and <code>value</code> must be character strings.</p>
</dd>
<dt><code>delete_cookie(key, value)</code>:</dt><dd><p> Sends appropriate HTTP header to delete the associated cookie on the client. <code>key</code> and <code>value</code> must be character strings.</p>
</dd>
<dt><code>finish()</code>:</dt><dd><p> Returns the response according to the Rook specification.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Rhttpd">Rhttpd</a></code> and <code><a href="#topic+Request">Request</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- Rhttpd$new()
## Not run: 
s$start(quiet=TRUE)

## End(Not run)
s$add(name="response",
    app=function(env){
        req &lt;- Request$new(env)
        res &lt;- Response$new()
        res$write('hello')
        res$finish()
    }
)
## Not run: 
s$browse('response') # Opens a browser window to the app.

## End(Not run)
s$remove(all=TRUE)
rm(s)
</code></pre>

<hr>
<h2 id='Rhttpd-class'>Class <code>Rhttpd</code></h2><span id='topic+Rhttpd-class'></span><span id='topic+Rhttpd'></span>

<h3>Description</h3>

<p><code>Rhttpd</code> is a convenience class for installing and running Rook
applications. It hides the details of starting and stopping the server
and adding and removing <code>Rook</code> applications from the server.
</p>
<p>Users starts by creating one <code>Rhttpd</code> object, then adding
applications to it, and then starting the server (see the section
&ldquo;Examples&rdquo; for a typical session). There are no restrictions on
creating more than one server object, but know that it only manages the
applications that are added to it and not others.
</p>
<p>Applications can be added and removed regardless of whether or
not the server is running.  Stopping the server does not remove
any applications. Adding an application with the same name as
one already installed simply overwrites the one installed. If
the server is started with no applications installed, it will
install the application named <code>RookTestApp</code> located in:
</p>
<p><code>system.file('exampleApps/RookTestApp.R',package='Rook')</code>.
</p>
<p>Also, see <code><a href="utils.html#topic+browseURL">browseURL</a></code> to learn how to get R to
automatically launch your favorite web browser.
</p>
<p>NOTE: This version of Rook can only listen on the loopback device.
</p>


<h3>Methods</h3>


<dl>
<dt><code>open(x)</code> or <code>browse(x)</code>:</dt><dd><p> Calls <code><a href="utils.html#topic+browseURL">browseURL</a></code> on the installed Rook application designated by <code>x</code>. <code>x</code> is either an integer or a character string. See the output of <code>print()</code>.</p>
</dd>
<dt><code>print()</code> or <code>show()</code>:</dt><dd><p> Lists the installed Rook applications.</p>
</dd>
<dt><code>remove(app,all=FALSE)</code>:</dt><dd><p> Removes the application known to the server. <code>app</code> can be an <code>RhttpdApp</code> object previously added, the name of the application as a character string, or an index as a numeric or integer value. See the output of <code>print()</code>.</p>
</dd>
<dt><code>full_url(i)</code>:</dt><dd><p> Returns the absolute url to the application for the given index.</p>
</dd>
<dt><code>start(listen='127.0.0.1', port=getOption('help.ports'), quiet=FALSE)</code>:</dt><dd><p> Starts the server on the loopback device and <code>port</code>. <code>listen</code> is always character string. Note that if there are no applications added to the object prior to starting, then the RookTestApp located in <code>system.file('exampleApps/RookTestApp.R',package='Rook')</code> is automatically added.</p>
</dd>
<dt><code>new()</code>:</dt><dd><p> Create a new <code>Rhttpd</code> object. </p>
</dd>
<dt><code>launch(...)</code>:</dt><dd><p> Combines the steps of starting the server, creating an <code>RhttpdApp</code> object, adding it to the server, and opening the app in the browser. <code>...</code> argument is passed to <code>RhttpdApp$new()</code>.</p>
</dd>
<dt><code>debug()</code>:</dt><dd><p> Returns the integer value provided by <code>getOption('Rhttpd_debug')</code> or 0 if the option is NULL. </p>
</dd>
<dt><code>stop()</code>:</dt><dd><p> Stops the server. </p>
</dd>
<dt><code>add(app=NULL,name=NULL)</code>:</dt><dd><p> Adds a new <code>Rook</code> application to the server. <code>app</code> can be an <code><a href="#topic+RhttpdApp">RhttpdApp</a></code> object or any <code>Rook</code> application. <code>name</code> is a character string and is ignored if <code>app</code> is an <code>RhttpdApp</code> object.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+RhttpdApp">RhttpdApp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create an Rhttpd object and start the internal web server. Note that
# if there are no applications added, then the default RookTest app in
# system.file('exampleApps/RookTestApp.R',package='Rook') is automatically
# added.

s &lt;- Rhttpd$new()
## Not run: 
s$start(quiet=TRUE)
s$browse(1)

## End(Not run)
s$print()

# Be sure to install the Hmisc package before installing and running
# this application. You will want to; it's a pretty good one.
# s$add(
#    app=system.file('exampleApps/Hmisc/config.R',package='Rook'),
#    name='hmisc')

s$add(
    app=system.file('exampleApps/helloworld.R',package='Rook'),
    name='hello'
)
s$add(
    app=system.file('exampleApps/helloworldref.R',package='Rook'),
    name='helloref'
)
s$add(
    app=system.file('exampleApps/summary.R',package='Rook'),
    name='summary'
)

s$print()

#  Stops the server but doesn't uninstall the app
## Not run: 
s$stop()

## End(Not run)
s$remove(all=TRUE)
rm(s)
</code></pre>

<hr>
<h2 id='RhttpdApp-class'>Class <code>RhttpdApp</code></h2><span id='topic+RhttpdApp-class'></span><span id='topic+RhttpdApp'></span>

<h3>Description</h3>

<p>Creates a Rook application ready to add to an <code><a href="#topic+Rhttpd">Rhttpd</a></code> server.
</p>


<h3>Details</h3>

<p>The internal web server allows dispatching to user-defined closures
located in tools:::.httpd.handlers.env. For instance, if a handler named
'foo' is placed there, then the url path to that handler is /custom/foo.
</p>
<p><code>RhttpdApp</code> along with <code><a href="#topic+Rhttpd">Rhttpd</a></code> hide these details by
allowing a user to create application objects specifying only their name
and the application. There is currently a limit of 63 characters
or less for application names.
</p>
<p>NOTE: When a file is given as the value of the <code>app</code> argument
to <code>new()</code>, it is monitored for timestamp changes. If a change
occurs in the modification time as returned by <code><a href="base.html#topic+file.info">file.info</a></code>,
then the file is sourced prior to handling subsequent requests.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(app, name)</code>:</dt><dd><p> Creates an object of class <code>RhttpdApp</code>. Argument <code>app</code> can be any <code><a href="#topic+Rook">Rook</a></code> aware object or it can be a location to a file whose source creates a Rook aware object. That object must be named either <code>'app'</code> or the value of <code>name</code>. <code>name</code> is a character vector.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Rhttpd">Rhttpd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s &lt;- Rhttpd$new()
s$add(RhttpdApp$new(
    name='summary',
    app=system.file('exampleApps/summary.R',package='Rook')
))
## Not run: 
s$start(quiet=TRUE)
s$browse(1)

## End(Not run)
s$remove(all=TRUE)

#  Stops the server but doesn't uninstall the app
## Not run: 
s$stop()

## End(Not run)
s$remove(all=TRUE)
rm(s)
</code></pre>

<hr>
<h2 id='RhttpdErrorStream-class'>Class <code>RhttpdErrorStream</code></h2><span id='topic+RhttpdErrorStream-class'></span><span id='topic+RhttpdErrorStream'></span>

<h3>Description</h3>

<p>An internal class used by <code><a href="#topic+Rhttpd">Rhttpd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("RhttpdErrorStream")
</code></pre>

<hr>
<h2 id='RhttpdInputStream-class'>Class <code>RhttpdInputStream</code></h2><span id='topic+RhttpdInputStream-class'></span><span id='topic+RhttpdInputStream'></span>

<h3>Description</h3>

<p>An internal class used by <code><a href="#topic+Rhttpd">Rhttpd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("RhttpdInputStream")
</code></pre>

<hr>
<h2 id='Server'>Rook Server Object</h2><span id='topic+Server'></span>

<h3>Description</h3>

<p><code>Server</code> is an object exported by Rook that has no value to the user. It is mainly used by web servers for their convenience. To see an example of how it may be used, see rApache.R in the inst/servers directory.
</p>

<hr>
<h2 id='Static-class'>Class <code>Static</code></h2><span id='topic+Static-class'></span><span id='topic+Static'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+Middleware">Middleware</a></code> class for serving static files from a root directory given a set of url paths.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(urls, root)</code>:</dt><dd><p> Creates a new object. <code>urls</code> is a character vector whose elements must start with a <code>'/'</code>. <code>root</code> is a length 1 character vector whose value must be a valid directory. </p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <code><a href="#topic+Builder">Builder</a></code> for an example.
</p>

<hr>
<h2 id='suspend_console'>
Suspend the R console 
</h2><span id='topic+suspend_console'></span>

<h3>Description</h3>

<p>Calls Sys.sleep in a never-ending while loop to mimic suspension of the R console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suspend_console()
</code></pre>


<h3>Value</h3>

<p>No value is ever returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rook">Rook</a></code>.
</p>

<hr>
<h2 id='URLMap-class'>Class <code>URLMap</code></h2><span id='topic+URLMap-class'></span><span id='topic+URLMap'></span>

<h3>Description</h3>

<p>A <code><a href="#topic+Rook">Rook</a></code> application that maps url paths to other <code>Rook</code> applications.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(...)</code>:</dt><dd><p> Creates a <code>Rook</code> application. All arguments must be <code>Rook</code> applications and named as in the example.</p>
</dd>
</dl>



<h3>See Also</h3>

 
<p><code><a href="#topic+Rhttpd">Rhttpd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- Rhttpd$new()
s$add(
    name="pingpong",
    app=Rook::URLMap$new(
        '/ping' = function(env){
            req &lt;- Rook::Request$new(env)
            res &lt;- Rook::Response$new()
            res$write(sprintf('&lt;h1&gt;&lt;a href="%s"&gt;Pong&lt;/a&gt;&lt;/h1&gt;',req$to_url("/pong")))
            res$finish()
        },
        '/pong' = function(env){
            req &lt;- Rook::Request$new(env)
            res &lt;- Rook::Response$new()
            res$write(sprintf('&lt;h1&gt;&lt;a href="%s"&gt;Ping&lt;/a&gt;&lt;/h1&gt;',req$to_url("/ping")))
            res$finish()
        },
        '/?' = function(env){
            req &lt;- Rook::Request$new(env)
            res &lt;- Rook::Response$new()
            res$redirect(req$to_url('/pong'))
            res$finish()
        }
    )
)
## Not run: 
s$start(quiet=TRUE)
s$browse('pingpong')

## End(Not run)
s$remove('pingpong')
## Not run: 
s$stop()

## End(Not run)
rm(s)
</code></pre>

<hr>
<h2 id='Utils-class'>Class <code>Utils</code></h2><span id='topic+Utils-class'></span><span id='topic+Utils'></span>

<h3>Description</h3>

<p>A convenience object for working with various aspects of web requests and responses.
</p>


<h3>Methods</h3>


<dl>
<dt><code>bytesize(string=NULL)</code>:</dt><dd><p> Returns size in bytes for <code>string</code>, a character vector. </p>
</dd>
<dt><code>unescape(s=NULL)</code>:</dt><dd><p> returns the url decoded value of the character vector <code>s</code>. Also replaces the <code>'+'</code> character with a space. </p>
</dd>
<dt><code>status_code(status=NULL)</code>:</dt><dd><p> returns integer value for the given HTTP <code>status</code>, which can either be numeric or or a character vector describing the status. Returns <code>as.integer(500)</code> if <code>status</code> is NULL.</p>
</dd>
<dt><code>escape_html(string=NULL)</code>:</dt><dd><p> replaces <code>"&amp;"</code>, <code>"&lt;"</code>, <code>"&gt;"</code>, <code>"'"</code>, and <code>'"'</code> with entity equivalents. </p>
</dd>
<dt><code>raw.match(needle=NULL, haystack=NULL, all=TRUE)</code>:</dt><dd><p> returns index position of <code>needle</code> in  <code>haystack</code>. All matched indexes are returned by default. <code>needle</code> is either a raw vector or character string. <code>haystack</code> is a raw vector.</p>
</dd>
<dt><code>parse_query(qs=NULL, d=DEFAULT_SEP)</code>:</dt><dd><p> Creates a named list from the the query string <code>qs</code>. <code>d</code> is the separator value and defaults to <code>'[&amp;;] *'</code>.</p>
</dd>
<dt><code>rfc2822(ts=NULL)</code>:</dt><dd><p> Formats <code>ts</code> in RFC2822 time. <code>ts</code> must be a <code><a href="base.html#topic+POSIXt">POSIXt</a></code> object.</p>
</dd>
<dt><code>escape(s=NULL)</code>:</dt><dd><p> Transforms any non-printable characters found in <code>s</code> to their percent-encoded equivalents.</p>
</dd>
<dt><code>build_query(params=NULL)</code>:</dt><dd><p> Creates a query string from the named list given in <code>params</code>. </p>
</dd>
<dt><code>timezero()</code>:</dt><dd><p> Returns a <code>POSIXct</code> object set to UNIX epoch. </p>
</dd>
<dt><code>set_cookie_header(header, key, value, expires, path, domain, secure, httpOnly)</code>:</dt><dd><p> Sets an HTTP cookie header in the environment <code>header</code>. All arguments except <code>expires</code> are length 1 character vectors, while <code>expires</code> must be a <code>POSIXct</code> object. </p>
</dd>
<dt><code>delete_cookie_header(header, key, value, expires, path, domain, secure, httpOnly)</code>:</dt><dd><p> Deletes the HTTP cookie header. </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+Multipart">Multipart</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Utils$bytesize('foo')
Utils$escape('foo bar')
Utils$unescape('foo+bar')
Utils$escape_html('foo &lt;bar&gt;')
Utils$escape('foo &lt;bar&gt;')
Utils$escape('foo\n&lt;bar&gt;')
Utils$status_code('OK')
Utils$status_code('Found')
Utils$status_code('Not Found')
x &lt;- Utils$parse_query('foo=1&amp;bar=baz')
x
Utils$rfc2822(Sys.time())
Utils$timezero()
Utils$build_query(x)
rm(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
