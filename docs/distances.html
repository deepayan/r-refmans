<!DOCTYPE html><html><head><title>Help for package distances</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distances}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#distance_columns'><p>Distance matrix columns</p></a></li>
<li><a href='#distance_matrix'><p>Distance matrix</p></a></li>
<li><a href='#distances'><p>Constructor for distance metric objects</p></a></li>
<li><a href='#distances-package'><p>distances: Tools for Distance Metrics</p></a></li>
<li><a href='#is.distances'><p>Check <code>distances</code> object</p></a></li>
<li><a href='#max_distance_search'><p>Max distance search</p></a></li>
<li><a href='#nearest_neighbor_search'><p>Nearest neighbor search</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Distance Metrics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.10</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for constructing, manipulating and using distance metrics.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LicenseNote:</td>
<td>The distances packages includes the ANN library
(distributed under the LGPLv2.1 license).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fsavje/distances">https://github.com/fsavje/distances</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fsavje/distances/issues">https://github.com/fsavje/distances/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 21:40:09 UTC; fredriksavje</td>
</tr>
<tr>
<td>Author:</td>
<td>Fredrik Savje [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fredrik Savje &lt;fredrik.savje@yale.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='distance_columns'>Distance matrix columns</h2><span id='topic+distance_columns'></span>

<h3>Description</h3>

<p><code>distance_columns</code> extracts columns from the distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_columns(distances, column_indices, row_indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_columns_+3A_distances">distances</code></td>
<td>
<p>A <code><a href="#topic+distances">distances</a></code> object.</p>
</td></tr>
<tr><td><code id="distance_columns_+3A_column_indices">column_indices</code></td>
<td>
<p>An integer vector with point indices indicating
which columns to be extracted.</p>
</td></tr>
<tr><td><code id="distance_columns_+3A_row_indices">row_indices</code></td>
<td>
<p>If <code>NULL</code>, complete rows will be extracted.
If integer vector with point indices, only the indicated
rows will be extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the complete distance matrix is desired, <code><a href="#topic+distance_matrix">distance_matrix</a></code> is
faster than <code>distance_columns</code>.
</p>


<h3>Value</h3>

<p>Returns a matrix with the requested columns.
</p>

<hr>
<h2 id='distance_matrix'>Distance matrix</h2><span id='topic+distance_matrix'></span>

<h3>Description</h3>

<p><code>distance_matrix</code> makes distance matrices (complete and partial) from
<code><a href="#topic+distances">distances</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_matrix(distances, indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_matrix_+3A_distances">distances</code></td>
<td>
<p>A <code><a href="#topic+distances">distances</a></code> object.</p>
</td></tr>
<tr><td><code id="distance_matrix_+3A_indices">indices</code></td>
<td>
<p>If <code>NULL</code>, the complete distance matrix is made.
If integer vector with point indices,
a partial matrix including only the indicated data points is made.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a distance matrix of class <code><a href="stats.html#topic+dist">dist</a></code>.
</p>

<hr>
<h2 id='distances'>Constructor for distance metric objects</h2><span id='topic+distances'></span>

<h3>Description</h3>

<p><code>distances</code> constructs a distance metric for a set of points. Currently,
it only creates Euclidean distances. It can, however, create distances in any
linear projection of Euclidean space. In other words, Mahalanobis
distances or normalized Euclidean distances are both possible. It is also possible
to give each dimension of the space different weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distances(
  data,
  id_variable = NULL,
  dist_variables = NULL,
  normalize = NULL,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distances_+3A_data">data</code></td>
<td>
<p>a matrix or data frame containing the data points between distances should be derived.</p>
</td></tr>
<tr><td><code id="distances_+3A_id_variable">id_variable</code></td>
<td>
<p>optional IDs of the data points.
If <code>id_variable</code> is a single string and <code>data</code> is a data frame, the
corresponding column in <code>data</code> will be taken as IDs. That column will be
excluded from <code>data</code> when constructing distances (unless it is listed in
<code>dist_variables</code>). If <code>id_variable</code> is <code>NULL</code>, the IDs are set
to <code>1:nrow(data)</code>. Otherwise, <code>id_variable</code> must be of length
<code>nrow(data)</code> and will be used directly as IDs.</p>
</td></tr>
<tr><td><code id="distances_+3A_dist_variables">dist_variables</code></td>
<td>
<p>optional names of the columns in <code>data</code> that should
be used when constructing distances. If <code>dist_variables</code> is <code>NULL</code>,
all columns will be used (net of eventual column specified by <code>id_variable</code>).
If <code>data</code> is a matrix, <code>dist_variables</code> must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="distances_+3A_normalize">normalize</code></td>
<td>
<p>optional normalization of the data prior to distance construction. If <code>normalize</code>
is <code>NULL</code> or <code>"none"</code>, no normalization will be done (effectively setting <code>normalize</code>
to the identity matrix). If <code>normalize</code> is <code>"mahalanobize"</code>, normalization will be
done with <code>var(data)</code> (i.e., resulting in Mahalanobis distances). If <code>normalize</code> is
<code>"studentize"</code>, normalization is done with the diagonal of <code>var(data)</code>. If <code>normalize</code>
is a matrix, it will be used in the normalization. If <code>normalize</code> is a vector, a diagonal matrix
with the supplied vector as its diagonal will be used. The matrix used for normalization must be
positive-semidefinite.</p>
</td></tr>
<tr><td><code id="distances_+3A_weights">weights</code></td>
<td>
<p>optional weighting of the data prior to distance construction. If <code>normalize</code> is <code>NULL</code>
no weighting will be done (effectively setting <code>weights</code> to the identity matrix). If <code>weights</code>
is a matrix, that will be used in the weighting. If <code>normalize</code> is a vector, a diagonal matrix
with the supplied vector as its diagonal will be used. The matrix used for weighting must be
positive-semidefinite.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">x</code> and <code class="reqn">y</code> be two data points in <code>data</code> described by two vectors. <code>distances</code>
uses the following metric to derive the distance between <code class="reqn">x</code> and <code class="reqn">y</code>:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{(x - y) N^{-0.5} W (N^{-0.5})' (x - y)}</code>
</p>

<p>where <code class="reqn">N^{-0.5}</code> is the Cholesky decomposition (lower triangular) of the inverse of the
matrix speficied by <code>normalize</code>, and <code class="reqn">W</code> is the matrix speficied by <code>weights</code>.
</p>
<p>When <code>normalize</code> is <code>var(data)</code> (i.e., using the <code>"mahalanobize"</code> option), the function gives
(weighted) Mahalanobis distances. When <code>normalize</code> is <code>diag(var(data))</code> (i.e., using
the <code>"studentize"</code> option), the function divides each column by its variance leading to (weighted) normalized
Euclidean distances. If <code>normalize</code> is the identity matrix (i.e., using the <code>"none"</code> or <code>NULL</code> option), the function
derives ordinary Euclidean distances.
</p>


<h3>Value</h3>

<p>Returns a <code>distances</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_data_points &lt;- data.frame(x = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10),
                             y = c(10, 9, 8, 7, 6, 6, 7, 8, 9, 10))

# Euclidean distances
my_distances1 &lt;- distances(my_data_points)

# Euclidean distances in only one dimension
my_distances2 &lt;- distances(my_data_points,
                           dist_variables = "x")

# Mahalanobis distances
my_distances3 &lt;- distances(my_data_points,
                           normalize = "mahalanobize")

# Custom normalization matrix
my_norm_mat &lt;- matrix(c(3, 1, 1, 3), nrow = 2)
my_distances4 &lt;- distances(my_data_points,
                           normalize = my_norm_mat)

# Give "x" twice the weight compared to "y"
my_distances5 &lt;- distances(my_data_points,
                           weights = c(2, 1))

# Use normalization and weighting
my_distances6 &lt;- distances(my_data_points,
                           normalize = "mahalanobize",
                           weights = c(2, 1))

# Custom ID labels
my_data_points_withID &lt;- data.frame(my_data_points,
                                    my_ids = letters[1:10])
my_distances7 &lt;- distances(my_data_points_withID,
                           id_variable = "my_ids")



# Compare to standard R functions

all.equal(as.matrix(my_distances1), as.matrix(dist(my_data_points)))
# &gt; TRUE

all.equal(as.matrix(my_distances2), as.matrix(dist(my_data_points[, "x"])))
# &gt; TRUE

tmp_distances &lt;- sqrt(mahalanobis(as.matrix(my_data_points),
                                  unlist(my_data_points[1, ]),
                                  var(my_data_points)))
names(tmp_distances) &lt;- 1:10
all.equal(as.matrix(my_distances3)[1, ], tmp_distances)
# &gt; TRUE

tmp_data_points &lt;- as.matrix(my_data_points)
tmp_data_points[, 1] &lt;- sqrt(2) * tmp_data_points[, 1]
all.equal(as.matrix(my_distances5), as.matrix(dist(tmp_data_points)))
# &gt; TRUE

tmp_data_points &lt;- as.matrix(my_data_points)
tmp_cov_mat &lt;- var(tmp_data_points)
tmp_data_points[, 1] &lt;- sqrt(2) * tmp_data_points[, 1]
tmp_distances &lt;- sqrt(mahalanobis(tmp_data_points,
                                  tmp_data_points[1, ],
                                  tmp_cov_mat))
names(tmp_distances) &lt;- 1:10
all.equal(as.matrix(my_distances6)[1, ], tmp_distances)
# &gt; TRUE

tmp_distances &lt;- as.matrix(dist(my_data_points))
colnames(tmp_distances) &lt;- rownames(tmp_distances) &lt;- letters[1:10]
all.equal(as.matrix(my_distances7), tmp_distances)
# &gt; TRUE

</code></pre>

<hr>
<h2 id='distances-package'>distances: Tools for Distance Metrics</h2><span id='topic+distances-package'></span>

<h3>Description</h3>

<p>The <code>distances</code> package provides tools for constructing, manipulating
and using distance metrics in R. It calculates distances only as needed
(unlike the standard <code><a href="stats.html#topic+dist">dist</a></code> function which derives the
complete distance matrix when called). This saves memory and can increase
speed. The package also includes functions for fast nearest and farthest
neighbor searching.
</p>


<h3>Details</h3>

<p>See the package's website for more information:
<a href="https://github.com/fsavje/distances">https://github.com/fsavje/distances</a>.
</p>
<p>Bug reports and suggestions are greatly appreciated. They
are best reported here:
<a href="https://github.com/fsavje/distances/issues/new">https://github.com/fsavje/distances/issues/new</a>.
</p>

<hr>
<h2 id='is.distances'>Check <code>distances</code> object</h2><span id='topic+is.distances'></span>

<h3>Description</h3>

<p><code>is.distances</code> checks whether the provided object
is a valid instance of the <code><a href="#topic+distances">distances</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.distances(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.distances_+3A_x">x</code></td>
<td>
<p>object to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> is a valid
<code>distances</code> object, otherwise <code>FALSE</code>.
</p>

<hr>
<h2 id='max_distance_search'>Max distance search</h2><span id='topic+max_distance_search'></span>

<h3>Description</h3>

<p><code>max_distance_search</code> searches for the data point furthest from a set of
query points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_distance_search(distances, query_indices = NULL, search_indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_distance_search_+3A_distances">distances</code></td>
<td>
<p>A <code><a href="#topic+distances">distances</a></code> object.</p>
</td></tr>
<tr><td><code id="max_distance_search_+3A_query_indices">query_indices</code></td>
<td>
<p>An integer vector with point indices to query. If <code>NULL</code>,
all data points in <code>distances</code> are queried.</p>
</td></tr>
<tr><td><code id="max_distance_search_+3A_search_indices">search_indices</code></td>
<td>
<p>An integer vector with point indices to search among. If <code>NULL</code>,
all data points in <code>distances</code> are searched over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector with point indices for the data point furthest from each query.
</p>

<hr>
<h2 id='nearest_neighbor_search'>Nearest neighbor search</h2><span id='topic+nearest_neighbor_search'></span>

<h3>Description</h3>

<p><code>nearest_neighbor_search</code> searches for the k nearest neighbors of a set of
query points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest_neighbor_search(
  distances,
  k,
  query_indices = NULL,
  search_indices = NULL,
  radius = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_neighbor_search_+3A_distances">distances</code></td>
<td>
<p>A <code><a href="#topic+distances">distances</a></code> object.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_search_+3A_k">k</code></td>
<td>
<p>The number of neighbors to search for.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_search_+3A_query_indices">query_indices</code></td>
<td>
<p>An integer vector with point indices to query. If <code>NULL</code>,
all data points in <code>distances</code> are queried.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_search_+3A_search_indices">search_indices</code></td>
<td>
<p>An integer vector with point indices to search among. If <code>NULL</code>,
all data points in <code>distances</code> are searched over.</p>
</td></tr>
<tr><td><code id="nearest_neighbor_search_+3A_radius">radius</code></td>
<td>
<p>Restrict the search to a fixed radius around each query. If fewer than <code>k</code>
search points exist within this radius, no neighbors are reported (indicated by <code>NA</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with point indices for the nearest neighbors. Columns in this matrix indicate
queries, and rows are ordered by distances from the query.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
