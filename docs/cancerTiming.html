<!DOCTYPE html><html><head><title>Help for package cancerTiming</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cancerTiming}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alleleFrequency'>
<p>Get allele frequencies for tumor data</p></a></li>
<li><a href='#bootstrapEventTiming'>
<p>Bootstrap the results of eventTiming</p></a></li>
<li><a href='#eventTiming'>
<p>Estimate the time of events in tumor data</p></a></li>
<li><a href='#eventTimingOverList'>
<p>eventTiming for multiple samples and regions</p></a></li>
<li><a href='#hg19chromosomes'><p>Definitions of the p,q, and centromeres of chromosomes</p></a></li>
<li><a href='#labelSeg'>
<p>Helper functions for plotting</p></a></li>
<li><a href='#makeEventHistory'>
<p>Create the event history matrix</p></a></li>
<li><a href='#mleAF'>
<p>Estimate the most likely allele frequency</p></a></li>
<li><a href='#multidensity'>
<p>plot multiple density functions on top of each other</p>
</a></li>
<li><a href='#mut2Seg'>
<p>Align mutations to segments</p></a></li>
<li><a href='#mutData'>
<p>Example Mutation Data</p></a></li>
<li><a href='#plotAlleleByPosition'>
<p>Plot allele frequencies by position</p></a></li>
<li><a href='#plotAlleleDensity'><p>Plot density/histogram of allele frequencies</p></a></li>
<li><a href='#plotCopies'><p> plot segmentation values against each other</p>
</a></li>
<li><a href='#plotPi0'>
<p>Confidence intervals for <code class="reqn">\pi_0</code></p></a></li>
<li><a href='#plotSegmentation'><p>plot segmentation(s) against positions</p>
</a></li>
<li><a href='#plotSeqCount'>
<p>Basic function for plotting the ratio of tumor to normal coverage</p></a></li>
<li><a href='#readSimulation'>
<p>Simulate reads based on an event matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimation of Temporal Ordering of Cancer Abnormalities</td>
</tr>
<tr>
<td>Version:</td>
<td>3.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-04-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Elizabeth Purdom</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elizabeth Purdom &lt;epurdom@stat.berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Timing copy number changes using estimates of mutational allele frequency from resequencing of tumor samples.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.11.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>GenomicRanges, IRanges, S4Vectors</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, grDevices, graphics, LearnBayes, gplots</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-04-01 22:22:57 UTC; epurdom</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-04-03 00:22:46</td>
</tr>
</table>
<hr>
<h2 id='alleleFrequency'>
Get allele frequencies for tumor data
</h2><span id='topic+allAF'></span><span id='topic+contAF'></span><span id='topic+decontAF'></span><span id='topic+errorAF'></span>

<h3>Description</h3>

<p>Calculate allele frequencies that would be possible for a variant found in a region with a given number of total copies of the tumor, adjusted for the given percentage of normal contamination. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allAF(totalCopy,normCont=0,totalCopyNormal=2,
	type=c("mutation","SNPHet","SNPHomo"))
contAF(trueAF, totalCopy, normCont = 0, totalCopyNormal = 2, 
	type = c("mutation", "SNPHet", "SNPHomo"))
decontAF(contAF, totalCopy, normCont = 0, totalCopyNormal = 2, 
	type = c("mutation", "SNPHet", "SNPHomo"))
errorAF(trueAF,seqError=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alleleFrequency_+3A_totalcopy">totalCopy</code></td>
<td>
<p> total number of copies of DNA of the tumor, integer 

</p>
</td></tr>
<tr><td><code id="alleleFrequency_+3A_normcont">normCont</code></td>
<td>
<p> proportion of normal contamination (see Details)

</p>
</td></tr>
<tr><td><code id="alleleFrequency_+3A_totalcopynormal">totalCopyNormal</code></td>
<td>
<p> total number of copies of DNA in the normal sample

</p>
</td></tr>
<tr><td><code id="alleleFrequency_+3A_type">type</code></td>
<td>
<p> type of allele frequency (see Details)

</p>
</td></tr>
<tr><td><code id="alleleFrequency_+3A_trueaf">trueAF</code></td>
<td>
<p> vector of true AF values in tumor

</p>
</td></tr>
<tr><td><code id="alleleFrequency_+3A_contaf">contAF</code></td>
<td>
<p> vector of observed (contaminated by normal) allele frequency values

</p>
</td></tr>
<tr><td><code id="alleleFrequency_+3A_seqerror">seqError</code></td>
<td>

<p>The probability of sequencing error per base
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>contAF takes as input a true allele frequency and then adjusted its based on the given normal contamination, to give the allele frequencies actually expected from the mixture of tumor and normal cells present. decontAF does the reverse, taking contaminated AF and calculating the true AF that is implied for the given normal contamination. 
</p>
<p>errorAF gives the adjusted allele frequencies to account for sequencing error.
</p>
<p>allAF returns all the possible allele frequencies for a variant, namely (0:totalCopy)/totalCopy. For type=&quot;mutation&quot;, only alleles from (1:totalCopy)/totalCopy are calculated, since the assumption is that mutated (relative to germline) regions by definition are not expected to be present at 0 copies in the tumor. For &lsquo;allAF&rsquo;, &lsquo;normCont&rsquo; can be a vector, in which case all the allele frequencies are calculated for all the values of &lsquo;normCont&rsquo;; for the remaining functions, it must be a single value.
</p>
<p>Only integer values of &lsquo;totalCopy&rsquo; are allowed. 
</p>
<p>&lsquo;type&rsquo; refers to the type of variant, relative to the normal. Namely, how many copies of the variant are in the normal. Therefore &lsquo;mutation&rsquo; implies 0 copies in the normal, &lsquo;SNPHet&rsquo; implies 1 copy in the normal, and &lsquo;SNPHomo&rsquo; implies variant is in every copy of the normal (which could be not equal to 2 if totalCopyNormal is not 2).
</p>
<p>For the functions seqError, contAF, and decontAF, &lsquo;totalCopy&rsquo;, &lsquo;normCont&rsquo;,&lsquo;totalCopyNormal&rsquo;, and &lsquo;seqError&rsquo; can be vectors of the same length as the input.
</p>


<h3>Value</h3>

<p>For &lsquo;allAF&rsquo;, a list of the same length of &lsquo;normCont&rsquo;. Each element of the list is a vector of the entire set of possible allele frequencies for the corresponding level of normal contamination. 
</p>
<p>For &lsquo;contAF&rsquo;, &lsquo;decontAF&rsquo;, and &lsquo;seqError&rsquo; a vector the same length as the inputted allele frequencies that were to be converted.





</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom
</p>


<h3>Examples</h3>

<pre><code class='language-R'>contAF(1/3,totalCopy=3,normCont=.1,type="mutation")
contAF(c(.5,.5,.5),totalCopy=c(2,4,6),normCont=.2)

#allele frequencies possible for a location that is same 
#as reference in the normal, for three different values of normal contamination
allAF(totalCopy=3,normCont=c(0,.1,.5),type="mutation") 
#same, but for those that are heterozygous in the normal
allAF(totalCopy=3,normCont=c(0,.1,.5),type="SNPHet") 
</code></pre>

<hr>
<h2 id='bootstrapEventTiming'>
Bootstrap the results of eventTiming
</h2><span id='topic+bootstrapEventTiming'></span>

<h3>Description</h3>

<p>Create bootstrap estimates of pi base on the results of a call to eventTiming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> bootstrapEventTiming(eventOrdering, B, type = c("parametric",
                 "nonparametric"), pi, x, m ,call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrapEventTiming_+3A_eventordering">eventOrdering</code></td>
<td>
<p>output from eventTiming</p>
</td></tr>
<tr><td><code id="bootstrapEventTiming_+3A_b">B</code></td>
<td>
<p> number of bootstrap samples to take
</p>
</td></tr>
<tr><td><code id="bootstrapEventTiming_+3A_type">type</code></td>
<td>
<p>type of bootstrap confidence interval to calculate, one of &ldquo;parametric&quot;, &ldquo;nonparametric&quot;
</p>
</td></tr>
<tr><td><code id="bootstrapEventTiming_+3A_pi">pi</code></td>
<td>

<p>the estimate of $pi$ from which to create bootstrap samples (if type=&quot;parametric&quot;. If not given, will use output from eventOrdering)
</p>
</td></tr>
<tr><td><code id="bootstrapEventTiming_+3A_x">x</code></td>
<td>
<p> vector. the number of reads/fragments containing the variant; not needed if output from eventOrdering given.
</p>
</td></tr>
<tr><td><code id="bootstrapEventTiming_+3A_m">m</code></td>
<td>
<p> vector. the number of reads/fragments covering the location with the variant (the coverage); not needed if output from eventOrdering given.
</p>
</td></tr>
<tr><td><code id="bootstrapEventTiming_+3A_call">call</code></td>
<td>
<p>information about the call given to original eventTiming command. Only needed if eventOrdering object not given (mainly used for internal calls within eventTiming function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of dimension (B,length(pi)) with the estimate of pi for each of the bootstrap samples
</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom</p>


<h3>Examples</h3>

<pre><code class='language-R'>##can do this within eventTiming function, but here is an example doing it separately...
data(mutData)
ACNLOH&lt;-matrix(c(1,3,1,0),ncol=2,nrow=2,byrow=TRUE)
onlyMuts&lt;-subset(mutData,is.na(rsID) &amp; position &lt;= 1.8E7)
onlyMuts$t_depth&lt;-onlyMuts$t_ref_count+onlyMuts$t_alt_count
x&lt;-eventTiming(x=onlyMuts$t_alt_count,m=onlyMuts$t_depth,
    history=ACNLOH,totalCopy=2,type="CNLOH",normCont=0.22,returnAssignments=TRUE)
piBoot&lt;-bootstrapEventTiming(x,B=100,type="parametric")
</code></pre>

<hr>
<h2 id='eventTiming'>
Estimate the time of events in tumor data
</h2><span id='topic+eventTiming'></span>

<h3>Description</h3>

<p>Estimate the proportion of time spent between different chromosomal abnormalities based on the allele frequencies of mutated locations. 

</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventTiming	(x, m, history, totalCopy, 
	method = c("fullMLE","partialMLE", "Bayes"), 
	type = c("gain", "CNLOH"), seqError = 0, bootstrapCI = NULL, 
	B = if (method =="Bayes") 10000 else 500, CILevel = 0.95, normCont = 0, 
	verbose = TRUE, returnAssignments = FALSE, coverageCutoff = 1,
	minMutations = 10, init = NULL, maxiter = 100, tol= 1e-04, 
	mutationId = 1:length(x),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventTiming_+3A_x">x</code></td>
<td>
<p> vector. the number of reads/fragments containing the variant

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_m">m</code></td>
<td>
<p> vector. the number of reads/fragments covering the location with the variant (the coverage)

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_history">history</code></td>
<td>
<p> a matrix, based on the history of the region (see Details)

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_totalcopy">totalCopy</code></td>
<td>
<p> integer. the total number of copies of the tumor DNA for this region 

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_method">method</code></td>
<td>
<p>what estimation method to use, one of &ldquo;fullMLE&quot;,&ldquo;partialMLE&quot;,&ldquo;Bayes&quot; </p>
</td></tr>
<tr><td><code id="eventTiming_+3A_type">type</code></td>
<td>
<p> type of region, either a gain or a CNLOH region

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_seqerror">seqError</code></td>
<td>
<p>Probability of sequencing error</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_bootstrapci">bootstrapCI</code></td>
<td>
<p> type of bootstrap confidence interval to calculate, one of &ldquo;parametric&quot;, &ldquo;nonparametric&quot;. If NULL, then the confidence interval is not calculated

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_b">B</code></td>
<td>
<p> number of bootstrap samples to take (or simulations from the posterior for Bayesian estimation)

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_cilevel">CILevel</code></td>
<td>

<p>At what level the confidence intervals should be calculated.
</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_normcont">normCont</code></td>
<td>
<p> the proportion of normal contamination, between 0 and 1.

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_verbose">verbose</code></td>
<td>
<p> logical. Whether to give additional warnings as the program is running. 

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_returnassignments">returnAssignments</code></td>
<td>
<p> logical. Whether to return the probabilistic assignments of mutations to allele frequencies generated by the EM algorithm. Also returns the x,m values for those that pass the filter.

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_coveragecutoff">coverageCutoff</code></td>
<td>
<p> minimum value for m[i]; any entries with m[i]&lt;coverageCutoff are ignored in estimation.

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_minmutations">minMutations</code></td>
<td>
<p> minimum number of mutations required. </p>
</td></tr>
<tr><td><code id="eventTiming_+3A_init">init</code></td>
<td>
<p> initial value of multinomial parameter q passed to estimateQ. 

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations in calculation q.

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_tol">tol</code></td>
<td>
<p>tolerance in the convergence of q

</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_mutationid">mutationId</code></td>
<td>
<p>identification values of the mutations (vector of the same length as x and m). Default is indexing values, 1:length(x). Used when returnAssignments=TRUE so that the assignments of the mutations to allele frequencies can be linked with the original mutations if there has been filtering in eventTiming, e.g. due to depth of coverage. 
</p>
</td></tr>
<tr><td><code id="eventTiming_+3A_...">...</code></td>
<td>
<p>Arguments passed to internal fitting function for Bayesian Method. For example, &lsquo;alpha&rsquo; gives the Dirichlet prior of the bayesian estimate (default=1), &lsquo;tdf&rsquo; gives the number of degrees of freedom for the t proposal density used in the bayesian estimate (default=4), &lsquo;bayesApproxMethod&rsquo; gives the method for calculating the approximate distribution (default is &ldquo;sir&quot;; &ldquo;inv&quot; is for K=1 when the problem is 1-dimensional and one can easily grid and get the approximate posterior density and cdf).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with values
</p>
<table>
<tr><td><code>pi</code></td>
<td>
<p>estimate of pi vector</p>
</td></tr>
<tr><td><code>piCI</code></td>
<td>
<p>bootstrap confidence interval, if requested</p>
</td></tr>
<tr><td><code>q</code></td>
<td>
<p>estimate of the multinomial parameter q</p>
</td></tr>
<tr><td><code>perLocationProb</code></td>
<td>
<p>output from estimateQ giving per location P(P[i]|X[i],q), if requested. Only locations used in the estimation are included.</p>
</td></tr>
<tr><td><code>optimDetails</code></td>
<td>
<p>optimization details from estimateQ</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>list of the parameters of the call to the function: history, totalCopy, type, exactAllele, normCont, coverageCutoff, minMutations. In addition, &lsquo;alleleSet&rsquo; is included in this list, which is the set of possible alleles for this history, after adjusting for normal contamination. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elizabeth Purdom
</p>


<h3>References</h3>

<p>Durinck S, et al. (2011). &ldquo;Temporal Dissection of Tumorigenesis in Primary Cancers.&quot; Cancer Discovery, 1(2): 137&ndash;143.
Greenman CD, et al. (2012). &ldquo;Estimation of rearrangement phylogeny for cancer genomes.&quot; Genome Research, 22(2): 346&ndash;361.
Purdom E, et al. (2013). &ldquo;Timing Chromosomal Abnormalities within Cancer Samples.&rdquo; Bioinformatics, 29(24): 3113&ndash;3120.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mutData)
ACNLOH&lt;-matrix(c(1,3,1,0),ncol=2,nrow=2,byrow=TRUE)
onlyMuts&lt;-subset(mutData,is.na(rsID) &amp; position &lt;= 1.8E7)
onlyMuts$t_depth&lt;-onlyMuts$t_ref_count+onlyMuts$t_alt_count
x&lt;-eventTiming(x=onlyMuts$t_alt_count,m=onlyMuts$t_depth,
    history=ACNLOH,totalCopy=2,type="CNLOH",normCont=0.22)
x$pi #estimate of time of stages
x$q #estimate of the multinomial (likelihood of each of the alleles)
x$call$alleleSet #possible set of alleles after 
                #adjusting for normal contamination
</code></pre>

<hr>
<h2 id='eventTimingOverList'>
eventTiming for multiple samples and regions
</h2><span id='topic+eventTimingOverList'></span><span id='topic+getPi0Summary'></span>

<h3>Description</h3>

<p>eventTimingOverList is a wrapper to eventTiming that allows for timing of common events over several regions of a sample and/or multiple samples. getPi0Summary gets summary information about <code class="reqn">\pi_0</code> (the first event) from the output of that function and returns a simple dataframe of the estimate of <code class="reqn">\pi_0</code> for every region and sample combination. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventTimingOverList(dfList, normCont, eventArgs)
getPi0Summary(eventList, CI = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventTimingOverList_+3A_dflist">dfList</code></td>
<td>
<p>a list of mutation data per sample. Each element of the list corresponds to a sample, and consists of a data frame of mutation information for all of the regions that are to be timed. The data frame must have a certain format, see description below.
</p>
</td></tr>
<tr><td><code id="eventTimingOverList_+3A_normcont">normCont</code></td>
<td>

<p>a vector of equal length as dfList giving the normal contamination of each sample
</p>
</td></tr>
<tr><td><code id="eventTimingOverList_+3A_eventargs">eventArgs</code></td>
<td>

<p>list of arguments passed to eventTiming via &lsquo;do.call&rsquo;. Should NOT contain the arguments &lsquo;x&rsquo;,&lsquo;m&rsquo;,&lsquo;history&rsquo;,&lsquo;totalCopy&rsquo;,&lsquo;type&rsquo;,&lsquo;mutationId&rsquo; or &lsquo;normCont&rsquo;

</p>
</td></tr>
<tr><td><code id="eventTimingOverList_+3A_eventlist">eventList</code></td>
<td>

<p>Output of eventTimingOverList (see below)
</p>
</td></tr>
<tr><td><code id="eventTimingOverList_+3A_ci">CI</code></td>
<td>
<p>logical, whether to grab CI from the output. 

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data frame of mutation data for each sample must have the following columns: &lsquo;segId&rsquo;, &lsquo;type&rsquo;, &lsquo;nMutAllele&rsquo;, &lsquo;nReads&rsquo;, &lsquo;mutationId&rsquo;. The rows of the data frame correspond to mutated locations within the sample. &lsquo;segId&rsquo; is an identifier of the segmented region that the mutation is in; eventTiming will be run using the mutation data for each &lsquo;segId&rsquo; in the sample. &lsquo;type&rsquo; identifies the type of segment, one of c(&quot;Other&quot;,&quot;CNLOH&quot;,&quot;SingleGain&quot;,&quot;Diploid&quot;,&quot;DoubleGain&quot;). &lsquo;nMutAllele&rsquo; gives for every row (mutated location) the number of reads with the mutation and corresponds to &lsquo;x&rsquo; imputed into eventTiming. &lsquo;nReads&rsquo; gives the total number of reads covering the location and corresponds to &lsquo;m&rsquo; imputed into eventTiming. &lsquo;mutationId&rsquo; is a unique identifier for the mutation. 
</p>
<p>For arguments passed to eventTiming, it is recommended to pass verbose=FALSE if you want to avoid many warnings about mutations that do not meet the necessary criteria of coverage, etc.

</p>


<h3>Value</h3>

<p>eventTimingOverList returns a list equal to the number of samples. Each element of that list (i.e. per sample) is itself a list of length three corresponding to the three types of regions that can be timed, &ldquo;CNLOH&quot;,&ldquo;SingleGain&quot;, and &ldquo;DoubleGain&quot;. Each of these gives the output of eventTiming per region of that type.





</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTiming">eventTiming</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(GenomicRanges)){
	#fix up mutation data to right format
	data(mutData)
	colnames(mutData)[1]&lt;-c("chr")
	colnames(mutData)[grep("t_alt_count",colnames(mutData))]&lt;-"nMutAllele"
	colnames(mutData)[grep("t_ref_count",colnames(mutData))]&lt;-"nRefAllele"
	mutData$nReads&lt;-mutData$nMutAllele+mutData$nRefAllele
	mutData$mutationId&lt;-1:nrow(mutData)
	
	#add segmentation annotation -- second region is bogus, only for illustration
	segs&lt;-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),
		normCont=0.22,segId=c("Seg1","Seg2"),type=c("CNLOH","SingleGain"))
	##Create Trivial segmentation annotation for example
	mutId&lt;-mut2Seg(mutData,segs)
	eventOut&lt;-eventTimingOverList(dfList=list(Sample1=mutId),normCont=0.22)
	getPi0Summary(eventOut)
}

</code></pre>

<hr>
<h2 id='hg19chromosomes'>Definitions of the p,q, and centromeres of chromosomes</h2><span id='topic+hg19chromosomes'></span>

<h3>Description</h3>

<p>Gives the coordinates of the p,q, and centromeres of human chromosomes, based on hg19 </p>


<h3>Usage</h3>

<pre><code class='language-R'>hg19chromosomes</code></pre>


<h3>Format</h3>

<p>A data.frame containing 72 rows and 5 columns.
</p>

<dl>
<dt><code>chr</code></dt><dd><p>chromosome</p>
</dd>
<dt><code>start</code></dt><dd><p>start position</p>
</dd>
<dt><code>end</code></dt><dd><p>end position</p>
</dd>
<dt><code>label</code></dt><dd><p>one of &ldquo;p&quot;,&ldquo;q&quot;, and &ldquo;centromere&quot;</p>
</dd>
<dt><code>width</code></dt><dd><p>width of region</p>
</dd>
</dl>



<h3>Source</h3>

<p>UCSC genome browser</p>

<hr>
<h2 id='labelSeg'>
Helper functions for plotting
</h2><span id='topic+labelSeg'></span><span id='topic+numChromosome'></span><span id='topic+divideGenome'></span>

<h3>Description</h3>

<p>Helper functions for plotting and working with chromosomes and segmentations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelSeg(chr, start, end, pctOv = 0.1)
numChromosome(chr)
divideGenome(size=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labelSeg_+3A_chr">chr</code></td>
<td>
<p>chromosome
</p>
</td></tr>
<tr><td><code id="labelSeg_+3A_start">start</code></td>
<td>

<p>start position of segment
</p>
</td></tr>
<tr><td><code id="labelSeg_+3A_end">end</code></td>
<td>

<p>end position of segment
</p>
</td></tr>
<tr><td><code id="labelSeg_+3A_pctov">pctOv</code></td>
<td>

<p>required amount of percent overlap needed in order to report
</p>
</td></tr>
<tr><td><code id="labelSeg_+3A_size">size</code></td>
<td>
<p>Size, in MB, of the desired equally spaced divisions of the genome</p>
</td></tr>
</table>


<h3>Details</h3>

<p>labelSeg creates labels &lsquo;p&rsquo;, &lsquo;q&rsquo;, and &lsquo;pq&rsquo; for segmentations based on the overlap of the segment with the p/q portions of the human chromosome (hg19). It uses the data stored in hg19chromosomes with the package (under the directory 'extdata', not as a dataset of the package). Uses the findOverlaps function of GenomicRanges.
</p>
<p>numChromosome takes character valued chromosome labels (&ldquo;1&rdquo;,&ldquo;2&rdquo;,...,&ldquo;X&rdquo;,&ldquo;Y&rdquo;) and converts them into values 1:23. This is useful for sorting chromosome values, for example. 
</p>
<p>divideGenome makes segments of the genome of size equal to 'size' times 1e6, i.e. size-MB length intervals, also based on the hg19chromosomes data described above.
</p>


<h3>Value</h3>

<p>vector of numerical values between 1:23
</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom</p>


<h3>See Also</h3>

<p><code><a href="#topic+hg19chromosomes">hg19chromosomes</a></code>,<code><a href="GenomicRanges.html#topic+findOverlaps-methods">findOverlaps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mutData)
segData&lt;-data.frame(chromosome="17",start=c(0,1.8e7+1),
    end=c(1.8e7,max(mutData$position)),totalCpy=c(2,NA),
    markRegion=c(FALSE,TRUE))
if(require(GenomicRanges) &amp; require(IRanges)) labelSeg(chr=segData$chromosome,
    start=segData$start,end=segData$end)
chr&lt;-c("1","4","10","23","X")
chr[order(chr)]
chr[order(numChromosome(chr))]
</code></pre>

<hr>
<h2 id='makeEventHistory'>
Create the event history matrix
</h2><span id='topic+makeEventHistory'></span>

<h3>Description</h3>

<p>Create the event history matrix needed for the event timing algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeEventHistory(type = c("gain", "LOH"), copies = NULL, 
	totalCopy = sum(copies), onlyIdentifiable = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeEventHistory_+3A_type">type</code></td>
<td>


</td></tr>
<tr><td><code id="makeEventHistory_+3A_copies">copies</code></td>
<td>

<p>a vector of length 2, giving the number of copies of the maternal and paternal chromosomes

</p>
</td></tr>
<tr><td><code id="makeEventHistory_+3A_totalcopy">totalCopy</code></td>
<td>

<p>an integer between 2 and 5. totalCopy must be the sum of the numbers given for the argument copies

</p>
</td></tr>
<tr><td><code id="makeEventHistory_+3A_onlyidentifiable">onlyIdentifiable</code></td>
<td>

<p>logical. Only return event matrices corresponding to event histories with identifiable <code class="reqn">\pi_0</code>?

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The A matrix relates allele frequencies to the event history. The vector <code class="reqn">A \pi</code> gives the probabilities of each allele frequency possible for the specified event.





</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom
</p>


<h3>References</h3>

<p>Purdom, E, et al. (submitted). &ldquo;Timing Chromosomal Abnormalities within Cancer Samples.&rdquo;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeEventHistory(type="gain",totalCopy=8)
makeEventHistory(type="gain",copies=c(1,4),totalCopy=5,onlyIdentifiable=FALSE)
</code></pre>

<hr>
<h2 id='mleAF'>
Estimate the most likely allele frequency 
</h2><span id='topic+mleAF'></span>

<h3>Description</h3>

<p>Estimate the number of copies a mutation is found in, based on which allele value maximizes the binomial likelihood after correcting for normal contamination and seqError.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mleAF(x, m, totalCopy, maxCopy=totalCopy, seqError = 0, normCont = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mleAF_+3A_x">x</code></td>
<td>
<p> vector. the number of reads/fragments containing the variant
</p>
</td></tr>
<tr><td><code id="mleAF_+3A_m">m</code></td>
<td>
<p> vector. the number of reads/fragments covering the location with the variant (the coverage)
</p>
</td></tr>
<tr><td><code id="mleAF_+3A_totalcopy">totalCopy</code></td>
<td>

<p>The total number of copies (maternal and paternal combined), can be vector with length equal to length(x)
</p>
</td></tr>
<tr><td><code id="mleAF_+3A_maxcopy">maxCopy</code></td>
<td>

<p>The maximum number of copies of either maternal or paternal alleles, can be vector with length equal to length(x)
</p>
</td></tr>
<tr><td><code id="mleAF_+3A_seqerror">seqError</code></td>
<td>

<p>The probability of sequencing error per base, can be vector with length equal to length(x)
</p>
</td></tr>
<tr><td><code id="mleAF_+3A_normcont">normCont</code></td>
<td>

<p>Percentage of normal contamination, can be vector with length equal to length(x)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>maxCopy and totalCopy are used to determine the possible allele frequencies in a pure tumor cell, given by 1:maxCopy/totalCopy. The default of maxCopy=totalCopy ensures that all theoretically possible alleles are considered given the lack of further information, but in general will not be correct. For example, if the region has allelic copy 2/3, then there are only three possible allele frequencies rather than five.
</p>


<h3>Value</h3>

<p>List with following values:
</p>
<table>
<tr><td><code>perLocationProb</code></td>
<td>
<p>matrix of dimension (number of locations) x (number of possible allele frequencies), with each row corresponding to a given location and each column giving the probability of observing the data for that location for each of the possible allele frequencies</p>
</td></tr>
<tr><td><code>assignments</code></td>
<td>
<p>data.frame of dimension (number of locations) x 3, with columns ncopies=estimate of number of copies mutation is found in, based on which maximizes the likelihood, totalCopy=totalCopy given by user, AF=estimate of true allele frequency given by ncopies/totalCopy </p>
</td></tr>
<tr><td><code>alleleSet</code></td>
<td>
<p>Only returned if the parameters totalCopy, maxCopy, seqError, and normCont are of length=1. A data.frame with rows equal to number of possible alleles and three columns, tumorAF=the allele frequency in the pure tumor, AF= the corresponding allele frequency after adjusting for normal contamination and sequencing error, frequency = number of locations with that allele frequency.</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Elizabeth Purdom</p>


<h3>References</h3>

<p>Greenman, C D et al. 2012. &ldquo;Estimation of rearrangement phylogeny for cancer genomes.&quot; Genome Research 22(2):346-361.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#example of CNLOH
	m&lt;-c(24,41,40,15)
	x&lt;-c(13,21,17,12)
	nc&lt;-c(0.27,0.39,0.49,0.22)
	mleAF(x=x,m=m,totalCopy=2,maxCopy=2,normCont=nc)
	mleAF(x=x,m=m,totalCopy=c(2,3,2,3),maxCopy=2,normCont=nc)
	#note the difference in output if instead all data is from 
	#same sample (shares normal Contamination estimate)
	mleAF(x=x,m=m,totalCopy=2,maxCopy=2,normCont=nc[1])
</code></pre>

<hr>
<h2 id='multidensity'>
plot multiple density functions on top of each other

</h2><span id='topic+multidensity'></span>

<h3>Description</h3>

<p>plots multiple density functions on top of each other, calculating the correct xlim, ylim, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multidensity(x, col = palette(), lwd = 1, lty = 1, xlim, ylab = "Density", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multidensity_+3A_x">x</code></td>
<td>
<p> list of values to create density from (can be a data.frame which where columns are elements of the list)

</p>
</td></tr>
<tr><td><code id="multidensity_+3A_col">col</code></td>
<td>
<p> colors for each density plot

</p>
</td></tr>
<tr><td><code id="multidensity_+3A_lwd">lwd</code></td>
<td>
<p>lwd for each density plot

</p>
</td></tr>
<tr><td><code id="multidensity_+3A_lty">lty</code></td>
<td>
<p>lty for each density plot

</p>
</td></tr>
<tr><td><code id="multidensity_+3A_xlim">xlim</code></td>
<td>
<p>user defined xlim

</p>
</td></tr>
<tr><td><code id="multidensity_+3A_ylab">ylab</code></td>
<td>
<p>user defined ylab

</p>
</td></tr>
<tr><td><code id="multidensity_+3A_...">...</code></td>
<td>
<p>plotting parameters passed to initial plot command.

</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elizabeth Purdom
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-lapply(c(1,2,3),function(x){rnorm(100,mean=x)})
multidensity(x)
</code></pre>

<hr>
<h2 id='mut2Seg'>
Align mutations to segments
</h2><span id='topic+mut2Seg'></span>

<h3>Description</h3>

<p>A function to match mutations into the segments that include them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mut2Seg(mutData, segData, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mut2Seg_+3A_mutdata">mutData</code></td>
<td>
<p>matrix or data.frame. Column names must include &lsquo;chr&rsquo; and &lsquo;position&rsquo;

</p>
</td></tr>
<tr><td><code id="mut2Seg_+3A_segdata">segData</code></td>
<td>
<p>matrix or data.frame. Column names must include &lsquo;chr&rsquo;,&lsquo;start&rsquo;,and &lsquo;end&rsquo; (in any order)
</p>
</td></tr>
<tr><td><code id="mut2Seg_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE gives information about the progress and possible problems (e.g. if different chromosome names in the two sets )
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds which segments in the segData file contain the mutations and returns a data.frame with the concatenation of the mutation information and the segments information. The function relies on findOverlaps in the GenomicRanges package in bioconductor. 
</p>


<h3>Value</h3>

<p>Data frame with concatenated values.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom
</p>


<h3>See Also</h3>

<p><code><a href="GenomicRanges.html#topic+findOverlaps-methods">findOverlaps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(GenomicRanges) &amp; require(IRanges)){
	data(mutData)
	colnames(mutData)[1]&lt;-c("chr")
	segs&lt;-data.frame(chr=c(17,17),start=c(1,1.8e7+100),end=c(1.8e7,81195210),
		normCont=0.22,segId=c("CNLOH","Other"))
	##Trivial segmentation annotation for example
	mutId&lt;-mut2Seg(mutData,segs)
	head(mutId)	
}

</code></pre>

<hr>
<h2 id='mutData'>
Example Mutation Data
</h2><span id='topic+mutData'></span>

<h3>Description</h3>

<p>Example mutation data</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mutData)</code></pre>


<h3>Format</h3>

<p>A data frame with 1007 observations on the following 10 variables.
</p>

<dl>
<dt><code>chromosome</code></dt><dd><p>chromosome</p>
</dd>
<dt><code>position</code></dt><dd><p>position</p>
</dd>
<dt><code>refbase</code></dt><dd><p>reference base at this location</p>
</dd>
<dt><code>mutbase</code></dt><dd><p>variant base at this location</p>
</dd>
<dt><code>rsID</code></dt><dd><p>dbSNP database number, NA if not in database.</p>
</dd>
<dt><code>t_ref_count</code></dt><dd><p>number of fragments in tumor with the reference base</p>
</dd>
<dt><code>t_alt_count</code></dt><dd><p>number of fragments in tumor with the variant base</p>
</dd>
<dt><code>allelefreq</code></dt><dd><p>observed allele frequency</p>
</dd>
<dt><code>n_ref_count</code></dt><dd><p>number of fragments in normal with the ref base</p>
</dd>
<dt><code>n_alt_count</code></dt><dd><p>number of fragments in normal with the variant base</p>
</dd>
</dl>



<h3>Details</h3>

<p>Mutation data from chr17. The CNLOH region is from positions 0 to 1.8E7. The normal contamination estimate in the paper was given as 0.22.
</p>


<h3>Source</h3>

<p>Durinck, S, et al. (2011). &ldquo;Temporal Dissection of Tumorigenesis in Primary Cancers.&quot; Cancer Discovery, 1(2), 137-143.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mutData)
head(mutData)
#only mutations in the CNLOH region
onlyMuts&lt;-subset(mutData,is.na(rsID) &amp; position &lt;= 1.8E7) 
</code></pre>

<hr>
<h2 id='plotAlleleByPosition'>
Plot allele frequencies by position
</h2><span id='topic+plotAlleleByPosition'></span>

<h3>Description</h3>

<p>Plot observed allele frequencies from sequencing data against their location on the chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAlleleByPosition(mutData, segmentData = NULL, 
	whChr = 1:22, chromosomeId = "chr", 
	sampleName = NULL, sample = FALSE, tumorAFId, positionId, type = "mutation", 
	startId = "start", endId = "end", segFactorId, tCNId, MarkId, segColors, 
	normCont = NULL,  addData = NULL, addColor="red",col="black",pch=1,lwd=2,
	xlim,ylab="Allele Frequency",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAlleleByPosition_+3A_mutdata">mutData</code></td>
<td>
<p> data.frame with mutation data set to be plotted

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_segmentdata">segmentData</code></td>
<td>
<p> (optional) segmentation data

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_whchr">whChr</code></td>
<td>
<p> which chromosome to plot

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_chromosomeid">chromosomeId</code></td>
<td>
<p> column name for chromosome (must be same in all data.frames)

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_samplename">sampleName</code></td>
<td>
<p>id printed on the plot to identify the sample

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_sample">sample</code></td>
<td>
<p>logical. If true, take only a random sample of 10,000 locations for the chromosome. Can speed up for plotting SNPs.

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_tumorafid">tumorAFId</code></td>
<td>
<p> column name for the allele frequency in mutData

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_positionid">positionId</code></td>
<td>
<p>column name for the allele location in mutData

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_type">type</code></td>
<td>
<p>type of allele frequency plotted (passed to &lsquo;allAF&rsquo; in order to create the lines for the expected AF)

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_startid">startId</code></td>
<td>
<p>column name for the start of the segmentation (in segData)

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_endid">endId</code></td>
<td>
<p>column name for the end of the segmentation (in segData)

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_segfactorid">segFactorId</code></td>
<td>
<p>column name for the factor for segmentations (in segData). 

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_tcnid">tCNId</code></td>
<td>
<p>column name that gives the total copy number for the segmentation (in segData); needed if give normCont to calculated expected AF

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_markid">MarkId</code></td>
<td>
<p>column name of a column with logical values that identifies segments that should be marked up with hash marks.

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_segcolors">segColors</code></td>
<td>
<p>vector of colors for the segmentations. Should be as long as the number of levels of segFactorId

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_normcont">normCont</code></td>
<td>
<p>percent normal contamination. If missing, then lines for the expected AF will not be calculated.

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_adddata">addData</code></td>
<td>
<p> data.frame with another set (example germline SNPs) to be plotted in red

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_addcolor">addColor</code></td>
<td>
<p> color for the additional data

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_lwd">lwd</code></td>
<td>
<p>line width of the lines for the expected AF

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_xlim">xlim</code></td>
<td>
<p>xlim boundaries. If missing, will be calculated. 

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_col">col</code></td>
<td>
<p>col for the mutData points

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_pch">pch</code></td>
<td>
<p>pch for the mutData points

</p>
</td></tr>
<tr><td><code id="plotAlleleByPosition_+3A_...">...</code></td>
<td>
<p>arguments passed to initial plotting command.

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisibly the vector of colors for the segmentations, useful for making legends (see the example)





</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mutData)
 #only mutations in the CNLOH region
onlyMuts&lt;-subset(mutData,is.na(rsID) &amp; position &lt;= 1.8E7)
	snps&lt;-subset(mutData,!is.na(rsID) )
segData&lt;-data.frame(chromosome="17",start=c(0,1.8e7+1),
	end=c(1.8e7,max(mutData$position)),
	totalCpy=c(2,NA),markRegion=c(FALSE,TRUE))
out&lt;-plotAlleleByPosition(onlyMuts,whChr=17, segmentData=segData,
	tCNId="totalCpy",normCont=0.22, addData=snps,pch=19,
	addColor="grey",MarkId="markRegion",
	segColors="pink",xaxt="n",xlab="Position", segFactorId="totalCpy",
	chromosomeId = "chromosome",tumorAFId="allelefreq", 
	positionId="position",type="mutation") 
axis(1,line=1,tick=FALSE)
legend("topright",legend=c(names(out),"unknown"),fill=c(out,NA),
	title="Total Copy Number")

</code></pre>

<hr>
<h2 id='plotAlleleDensity'>Plot density/histogram of allele frequencies
</h2><span id='topic+plotAlleleDensity'></span>

<h3>Description</h3>

<p>Plot of densities/histograms of allele frequencies, useful for evaluating normal contamination estimate, total Copy number estimates, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAlleleDensity(af, depth, groupingId, totalCopy, groupCol=palette(),
	normCont = 0, type="mutation", minDepth = 40, 
	lineCols = c("grey", "tan4"), minMut = 40, 
	histogram = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAlleleDensity_+3A_af">af</code></td>
<td>

<p>vector of allele frequencies
</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_depth">depth</code></td>
<td>

<p>coverage of the location
</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_groupingid">groupingId</code></td>
<td>

<p>grouping variable for allele frequencies (single density curve/histogram for each id)

</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_totalcopy">totalCopy</code></td>
<td>

<p>the total copy number for the allele frequencies plotted (must be the same)

</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_groupcol">groupCol</code></td>
<td>

<p>colors for the different groups (if histogram=FALSE)

</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_type">type</code></td>
<td>

<p>type of allele frequency (mutation, SNPHet, SNPHomo), passed to allAF
</p>
</td></tr>  
<tr><td><code id="plotAlleleDensity_+3A_normcont">normCont</code></td>
<td>

<p>percentage of normal contamination. Can be vector of different values. 

</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_mindepth">minDepth</code></td>
<td>

<p>min required depth in order to include it in the density/histogram

</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_linecols">lineCols</code></td>
<td>

<p>colors of the vertical lines (each color is for different normal contamination)

</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_minmut">minMut</code></td>
<td>

<p>minimum number of mutations per group in order to plot the group

</p>
</td></tr>
<tr><td><code id="plotAlleleDensity_+3A_histogram">histogram</code></td>
<td>
<p> logical. should the plot be superimposed density curves (FALSE), or a single histogram per group (TRUE)?

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly the data used (i.e. passed minimum cutoff criteria), separated by the groupingId given by the user
</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mutData)
#only mutations in the CNLOH region
onlyMuts&lt;-subset(mutData,is.na(rsID) &amp; position &lt;= 1.8E7) 
plotAlleleDensity(onlyMuts$allelefreq,onlyMuts$t_ref_count+onlyMuts$t_alt_count,
	totalCopy=2,normCont=c(0,0.22),minMut=0,minDepth=0,hist=TRUE)

gpId&lt;-factor(is.na(mutData$rsID),levels=c("TRUE","FALSE"),labels=c("Mutations","SNPs"))
plotAlleleDensity(mutData$allelefreq,mutData$t_ref_count+mutData$t_alt_count,
	groupCol=c("black","red"),totalCopy=2,groupingId=gpId,minMut=0,minDepth=30,hist=FALSE)
legend("topleft",levels(gpId),fill=c("red","black"))
</code></pre>

<hr>
<h2 id='plotCopies'> plot segmentation values against each other

</h2><span id='topic+plotCopies'></span>

<h3>Description</h3>

<p>Plot different values per segment against each other (e.g. minor and major allele estimates).

</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCopies	(x, y, nX, nY, xleg, yleg, onlyPositive = TRUE,
	                 equalAxis = TRUE, integerLegend = TRUE, xlim, ylim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCopies_+3A_x">x</code></td>
<td>

<p>The values plotted for x coordinates (e.g. segmentation value for minor allele)
</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_y">y</code></td>
<td>

<p>The values plotted for y coordinates (e.g. segmentation value for major allele)
</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_nx">nX</code></td>
<td>

<p>The grouping id for the x coordinate (e.g. assignment of number of copies)
</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_ny">nY</code></td>
<td>

<p>The grouping id for the y coordinate (e.g. assignment of number of copies)
</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_xleg">xleg</code></td>
<td>

<p>title for the legend of the x values</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_yleg">yleg</code></td>
<td>

<p>title for the legend of the y values</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_xlim">xlim</code></td>
<td>
<p>limits for the x axis</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y axis</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_onlypositive">onlyPositive</code></td>
<td>
<p>only plot values positive in x and y</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_equalaxis">equalAxis</code></td>
<td>
<p>xlim and ylim are forced to be the same</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_integerlegend">integerLegend</code></td>
<td>
<p>Only give integers</p>
</td></tr>
<tr><td><code id="plotCopies_+3A_...">...</code></td>
<td>
<p>passed to the scatter plot command

</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elizabeth Purdom</p>


<h3>Examples</h3>

<pre><code class='language-R'>cp1&lt;-c(0,0,0,1,1,1,1,2,2,2,3,3,3)
cp2&lt;-c(0,1,2,1,2,2,3,2,2,4,3,6,8)
seg1&lt;-jitter(c(0,0,0,1,1,1,1,2,2,2,3,3,3))
seg2&lt;-jitter(c(0,1,2,1,2,2,3,2,2,4,3,6,8))
plotCopies(x=seg1,y=seg2,nX=cp1,nY=cp2)
</code></pre>

<hr>
<h2 id='plotPi0'>
Confidence intervals for <code class="reqn">\pi_0</code>
</h2><span id='topic+plotPi0'></span>

<h3>Description</h3>

<p>A plotting function to plot the confidence intervals of the estimated <code class="reqn">\pi_0</code> values returned from eventTiming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPi0(est, ui, li, samples, labels = NULL, xlab = "Segment", 
	ylab = expression(pi[0]), 
	pchFac = rep(1, length(est)), whHighlight = NULL, 
	nMut = NULL, xorder = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPi0_+3A_est">est</code></td>
<td>
<p>vector of the estimates of <code class="reqn">\pi_0</code>
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_ui">ui</code></td>
<td>

<p>vector of the upper values for the confidence interval of the <code class="reqn">\pi_0</code>
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_li">li</code></td>
<td>

<p>vector of the lower values for the confidence interval of the <code class="reqn">\pi_0</code>
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_samples">samples</code></td>
<td>

<p>vector indicating which sample each <code class="reqn">\pi_0</code> corresponds to (will be converted to factor with factor command)
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_labels">labels</code></td>
<td>

<p>character vector of the labels of each estimate (optional)
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_xlab">xlab</code></td>
<td>

<p>label for the xaxis, defaults to &ldquo;Segment&rdquo;
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_ylab">ylab</code></td>
<td>

<p>label for the yaxis, defaults to &ldquo;<code class="reqn">\pi_0</code>&rdquo;
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_pchfac">pchFac</code></td>
<td>

<p>vector of pch values for the center of the confidence interval
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_whhighlight">whHighlight</code></td>
<td>

<p>a vector of indices of the estimates that should be &lsquo;highlighted&rsquo; by coloring their confidence intervals red (optional)
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_nmut">nMut</code></td>
<td>

<p>a vector of values of the number of mutations from each confidence interval to be printed at the top of the plot
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_xorder">xorder</code></td>
<td>

<p>a vector giving an ordering of the estimates for the confidence intervals; if NULL, an order within each sample is created automatically. 
</p>
</td></tr>
<tr><td><code id="plotPi0_+3A_...">...</code></td>
<td>

<p>arguments passed to plotCI function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The order of the estimates found internally by the program (or given by the user) are returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom
</p>


<h3>See Also</h3>

<p>plotCI, eventTiming
</p>

<hr>
<h2 id='plotSegmentation'>plot segmentation(s) against positions

</h2><span id='topic+plotSegmentation'></span>

<h3>Description</h3>

<p>Plot the values of a segmentation against chromosome position. 

</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSegmentation(segs, valId, col = palette(),lty=1, lwd = 2, xlim, ylim,
	xlab="Position", ylab = valId,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSegmentation_+3A_segs">segs</code></td>
<td>

<p>list of segmentation data.frames. Each data.frame must have &lsquo;start&rsquo; and &lsquo;end&rsquo; as the column names of the limits of the segmentations.
</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_valid">valId</code></td>
<td>

<p>name of the column with the segmentation value to be plotted (must be the same in all data.frames)

</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_col">col</code></td>
<td>

<p>colors for the segmentation (1 per element of the list of segmentations)

</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_lty">lty</code></td>
<td>
<p>lty for the lines</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_lwd">lwd</code></td>
<td>

<p>lwd for the lines

</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_xlim">xlim</code></td>
<td>
<p>x limits

</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_ylim">ylim</code></td>
<td>
<p>y limits

</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_xlab">xlab</code></td>
<td>
<p>The label for the x-axis</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_ylab">ylab</code></td>
<td>
<p>The label for the y-axis</p>
</td></tr>
<tr><td><code id="plotSegmentation_+3A_...">...</code></td>
<td>
<p> passed to initial plotting command</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns invisibly the col and lty after any processing done, useful for legends.
</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mutData)
segData&lt;-data.frame(chromosome="17",start=c(0,1.8e7+1),
	end=c(1.8e7,max(mutData$position)),val=c(2,3))
cp1&lt;-data.frame(chromosome="17",start=c(0,1.8e7+1),
	end=c(1.8e7,max(mutData$position)),val=c(1,1))
cp2&lt;-data.frame(chromosome="17",start=c(0,1.8e7+1),
	end=c(1.8e7,max(mutData$position)),val=c(.9,2))
out&lt;-plotSegmentation(list(total=segData,cp1=cp1,cp2=cp2),
	valId="val",lwd=2,ylab="Segmentation Value")
legend("topright",names(out),fill=out)
</code></pre>

<hr>
<h2 id='plotSeqCount'>
Basic function for plotting the ratio of tumor to normal coverage
</h2><span id='topic+plotSeqCount'></span>

<h3>Description</h3>

<p>Basic function for plotting the ratio of tumor to normal coverage, and calculating the average over segments. A simple tool for assessing copy number breaks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSeqCount(position, t_count, n_count, ylim=NULL, normFac=1, 
	segs, segColors = palette(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSeqCount_+3A_position">position</code></td>
<td>

<p>vector of position of the base
</p>
</td></tr>
<tr><td><code id="plotSeqCount_+3A_t_count">t_count</code></td>
<td>

<p>vector of number of reads overlapping position in tumor
</p>
</td></tr>
<tr><td><code id="plotSeqCount_+3A_n_count">n_count</code></td>
<td>

<p>vector of number of reads overlapping position in normal</p>
</td></tr>
<tr><td><code id="plotSeqCount_+3A_ylim">ylim</code></td>
<td>

<p>set the limits of y axis. If NULL, default values found.
</p>
</td></tr>
<tr><td><code id="plotSeqCount_+3A_normfac">normFac</code></td>
<td>

<p>a normalizing factor to correct for
</p>
</td></tr>
<tr><td><code id="plotSeqCount_+3A_segs">segs</code></td>
<td>

<p>factor as same length as position, identifying which segment a count is from
</p>
</td></tr>
<tr><td><code id="plotSeqCount_+3A_segcolors">segColors</code></td>
<td>


</td></tr>
<tr><td><code id="plotSeqCount_+3A_...">...</code></td>
<td>

<p>passed to plot
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elizabeth Purdom
</p>

<hr>
<h2 id='readSimulation'>
Simulate reads based on an event matrix
</h2><span id='topic+readSimulation'></span>

<h3>Description</h3>

<p>Simulate reads based on an event matrix

</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSimulation(B, alleleSet, q, totalCopy, mutRate = NULL, seqError = 0, 
	fixedN = FALSE, normCont = 0, aveReadCoverage = 30, countDistribution = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSimulation_+3A_b">B</code></td>
<td>

<p>the number of simulated data sets to make

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_alleleset">alleleSet</code></td>
<td>

<p>a vector of expected allele frequencies, without contamination or sequencing error accounted for

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_q">q</code></td>
<td>

<p>integer. the number of expected allele frequencies???

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_totalcopy">totalCopy</code></td>
<td>

<p>integer. The total number of copies in the final stage, i.e. at the end of the event

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_mutrate">mutRate</code></td>
<td>

<p>a number between 0 and 1. The mutation rate, defined as the number of mutations observed divided by number of nucleotides sequenced or examined

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_seqerror">seqError</code></td>
<td>

<p>a number between 0 and 1 representing the sequencing error. The default value is 0, i.e. no sequencing error.

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_fixedn">fixedN</code></td>
<td>

<p>logical. Should the number of mutations be fixed? By default set to FALSE. If set to TRUE, the expected number of mutations is used, i.e. mutRate*B

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_normcont">normCont</code></td>
<td>

<p>a number between 0 and 1 describing the amount of normal contamination present in the sample. The default value is 0, i.e. no normal contamination.

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_avereadcoverage">aveReadCoverage</code></td>
<td>

<p>average read coverage of an allele. The default value is 30 reads per allele.

</p>
</td></tr>
<tr><td><code id="readSimulation_+3A_countdistribution">countDistribution</code></td>
<td>

<p>optional. Provide an empirical distribution for read coverage. If given, the argument aveReadCoverage is ignored, and the mean of the empirical distribution is used. By default, set to NULL. 

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame with simulated read counts under the normal contamination, sequencing error, allele frequency distribution, and read count distributions provided.





</p>


<h3>Author(s)</h3>

<p>Elizabeth Purdom</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#simulate from CNLOH event with pi[0]=.1
	Amat&lt;-makeEventHistory(totalCopy=2,type="LOH")[[1]]
	piVal&lt;-c(.1,.9)
	qvec&lt;-prop.table(Amat%*%piVal)

	sims&lt;-readSimulation(10, alleleSet=allAF(totalCopy=2)[[1]], q=qvec, 
	totalCopy=2, mutRate = 100, seqError = 0.1, fixedN = TRUE, 
	normCont = 0.1, aveReadCoverage = 30)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
