<!DOCTYPE html><html lang="en"><head><title>Help for package poputils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poputils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#poputils-package'><p>Functions for working with demographic data</p></a></li>
<li><a href='#age_group_type'><p>Infer Age Label Type</p></a></li>
<li><a href='#age_labels'><p>Create Age Labels</p></a></li>
<li><a href='#age_lower'><p>Lower Limits, Midpoints, and Upper Limits of Age Groups</p></a></li>
<li><a href='#check_age'><p>Validity Checks for Age Labels</p></a></li>
<li><a href='#check_equal_length'><p>Check that Arguments have Same Length</p></a></li>
<li><a href='#check_n'><p>Check Whole Number</p></a></li>
<li><a href='#check_no_overlap_colnums'><p>Check that Colnum Vectors do not Overlap</p></a></li>
<li><a href='#combine_age'><p>Aggregate Age Group Labels</p></a></li>
<li><a href='#ex_to_lifetab_brass'><p>Derive Life Tables that Match Life Expectancies,</p>
using a Brass Logit Model</a></li>
<li><a href='#find_label_female'><p>Identify Sex or Gender Labels Referring to Females</p></a></li>
<li><a href='#find_label_male'><p>Identify Sex or Gender Labels Referring to Males</p></a></li>
<li><a href='#find_var_age'><p>Identify an Age Variable</p></a></li>
<li><a href='#find_var_sexgender'><p>Identify a Sex or Gender Variable</p></a></li>
<li><a href='#find_var_time'><p>Identify a Time Variable</p></a></li>
<li><a href='#groups_colnums'><p>Get a named vector of column indices</p>
for the grouping variables in a
grouped data frame</a></li>
<li><a href='#lifetab'><p>Calculate Life Tables or Life Expectancies</p></a></li>
<li><a href='#logit'><p>Logit and Inverse-Logit Functions</p></a></li>
<li><a href='#matrix_to_list_of_cols'><p>Turn a Matrix Into a List of Columns or Rows</p></a></li>
<li><a href='#nzmort'><p>Mortality Data for New Zealand</p></a></li>
<li><a href='#nzmort_rvec'><p>Mortality Data and Probabilistic Rates for New Zealand</p></a></li>
<li><a href='#q0_to_m0'><p>Convert q0 to m0</p></a></li>
<li><a href='#reformat_age'><p>Reformat Age Group Labels</p></a></li>
<li><a href='#reformat_sex'><p>Reformat a Binary Sex Variable</p></a></li>
<li><a href='#rr3'><p>Randomly Round A Vector of Integers to Base 3</p></a></li>
<li><a href='#set_age_open'><p>Specify Open Age Group</p></a></li>
<li><a href='#to_matrix'><p>Build a Matrix from Measure and ID Variables</p></a></li>
<li><a href='#trim_01'><p>Trim Values So They Are Between 0 and 1</p></a></li>
<li><a href='#west_lifetab'><p>Coale-Demeny West Model Life Tables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Demographic Analysis and Data Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform tasks commonly encountered when
    preparing and analysing demographic data.
    Some functions are intended for end users, and
    others for developers. Includes functions for
    working with life tables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, rlang, rvec, tibble, tidyselect, utils, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, covr, dplyr, ggplot2, knitr, rmarkdown, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bayesiandemography.github.io/poputils/">https://bayesiandemography.github.io/poputils/</a>,
<a href="https://github.com/bayesiandemography/poputils">https://github.com/bayesiandemography/poputils</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bayesiandemography/poputils/issues">https://github.com/bayesiandemography/poputils/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-14 01:44:12 UTC; johnbryant</td>
</tr>
<tr>
<td>Author:</td>
<td>John Bryant [aut, cre],
  Bayesian Demography Limited [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Bryant &lt;john@bayesiandemography.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-14 02:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='poputils-package'>Functions for working with demographic data</h2><span id='topic+poputils'></span><span id='topic+poputils-package'></span>

<h3>Description</h3>

<p>Functions for common tasks in demographic
analyses. Some functions are aimed
at end-users, and others at developers.
</p>


<h3>For end users</h3>

<p><strong>Data manipulation</strong>
</p>

<ul>
<li> <p><code><a href="#topic+logit">logit()</a></code>,<code><a href="#topic+invlogit">invlogit()</a></code> Logistic transformation
</p>
</li>
<li> <p><code><a href="#topic+trim_01">trim_01()</a></code> Trim values to interval (0, 1)
</p>
</li>
<li> <p><code><a href="#topic+rr3">rr3()</a></code> Randomly round to base 3
</p>
</li></ul>

<p><strong>Labels</strong>
</p>

<ul>
<li> <p><code><a href="#topic+age_labels">age_labels()</a></code> Create age labels.
</p>
</li>
<li> <p><code><a href="#topic+age_lower">age_lower()</a></code>, <code><a href="#topic+age_mid">age_mid()</a></code>, <code><a href="#topic+age_upper">age_upper()</a></code> Limits and midpoints of age groups
</p>
</li>
<li> <p><code><a href="#topic+combine_age">combine_age()</a></code> Merge age group labels
</p>
</li>
<li> <p><code><a href="#topic+reformat_age">reformat_age()</a></code> Reformat age group labels
</p>
</li>
<li> <p><code><a href="#topic+reformat_sex">reformat_sex()</a></code> Reformat sex labels
</p>
</li>
<li> <p><code><a href="#topic+set_age_open">set_age_open()</a></code> Specify oldest age group
</p>
</li></ul>

<p><strong>Life expectancy, life tables</strong>
</p>

<ul>
<li> <p><code>ex_to_lifetab_brass()</code> Brass logit model.
</p>
</li>
<li> <p><code><a href="#topic+lifeexp">lifeexp()</a></code> Life expectancy
</p>
</li>
<li> <p><code><a href="#topic+lifetab">lifetab()</a></code> Full life table
</p>
</li>
<li> <p><code><a href="#topic+q0_to_m0">q0_to_m0()</a></code> Infant mortality
</p>
</li></ul>



<h3>For developers</h3>

<p><strong>Checking arguments</strong>
</p>

<ul>
<li> <p><code><a href="#topic+check_n">check_n()</a></code> Check an integer scalar
</p>
</li></ul>

<p><strong>Data manipulation</strong>
</p>

<ul>
<li> <p><code><a href="#topic+check_no_overlap_colnums">check_no_overlap_colnums()</a></code> Checking for argument clash
</p>
</li>
<li> <p><code><a href="#topic+groups_colnums">groups_colnums()</a></code> Get column numbers for grouping variables
</p>
</li>
<li> <p><code><a href="#topic+matrix_to_list_of_cols">matrix_to_list_of_cols()</a></code>, <code><a href="#topic+matrix_to_list_of_rows">matrix_to_list_of_rows()</a></code> Split matrix
</p>
</li>
<li> <p><code><a href="#topic+to_matrix">to_matrix()</a></code> Convert data frame to matrix
</p>
</li></ul>

<p><strong>Labels</strong>
</p>

<ul>
<li> <p><code><a href="#topic+age_group_type">age_group_type()</a></code> Infer type of age group label
</p>
</li>
<li> <p><code><a href="#topic+check_age">check_age()</a></code> Validity checks for age group labels
</p>
</li>
<li> <p><code><a href="#topic+find_label_female">find_label_female()</a></code>, <code><a href="#topic+find_label_male">find_label_male()</a></code> Identify sex or gender labels
</p>
</li>
<li> <p><code><a href="#topic+find_var_age">find_var_age()</a></code>, <code><a href="#topic+find_var_sexgender">find_var_sexgender()</a></code>, <code><a href="#topic+find_var_time">find_var_time()</a></code> Identify age, sex/gender, time variables
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Bryant <a href="mailto:john@bayesiandemography.com">john@bayesiandemography.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Bayesian Demography Limited [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://bayesiandemography.github.io/poputils/">https://bayesiandemography.github.io/poputils/</a>
</p>
</li>
<li> <p><a href="https://github.com/bayesiandemography/poputils">https://github.com/bayesiandemography/poputils</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bayesiandemography/poputils/issues">https://github.com/bayesiandemography/poputils/issues</a>
</p>
</li></ul>


<hr>
<h2 id='age_group_type'>Infer Age Label Type</h2><span id='topic+age_group_type'></span>

<h3>Description</h3>

<p>Determine whether a set of age labels
refer to one-year, five-year, or
life-table age groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_group_type(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_group_type_+3A_x">x</code></td>
<td>
<p>A vector of age labels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The valid types of age labels are:
</p>

<ul>
<li> <p><code>"single"</code>. One-year age groups, eg
<code>"0"</code> or <code>"55"</code>, and possibly
an open age group, eg <code>"90+"</code>.
</p>
</li>
<li> <p><code>"five"</code>. Five-year age groups, eg
<code>"0-4"</code> or <code>"55-59"</code>, and possibly
an open age group, eg <code>"100+"</code>.
</p>
</li>
<li> <p><code>"lt"</code>. Life table age groups, eg
<code>"0"</code>, <code>"1-4"</code>, <code>"5-9"</code>,
<code>"55-59"</code>, or <code>"80+"</code>.
</p>
</li></ul>

<p>If <code>x</code> does not fit any of these
descriptions, <code style="white-space: pre;">&#8288;then age_group_type()&#8288;</code> throws
an error.
</p>
<p>If <code>x</code> could belong to
more than one type, then <code>age_group_type()</code>
prefers <code>"single"</code> to <code>"five"</code> and <code>"lt"</code>,
and prefers <code>"five"</code> to <code>"lt"</code>.
</p>


<h3>Value</h3>

<p><code>"single"</code>, <code>"five"</code>, or <code>"lt"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age_group_type(c("5-9", "0-4", "100+"))
age_group_type(c("2", "5", "1"))
age_group_type(c("0", "1-4"))

## could be any "single" or "lt"
age_group_type("0")

## could be "five" or "lt"
age_group_type("80-84")
</code></pre>

<hr>
<h2 id='age_labels'>Create Age Labels</h2><span id='topic+age_labels'></span>

<h3>Description</h3>

<p>Create labels for age groups. The labels depend
on the <code>type</code> argument:
</p>

<ul>
<li> <p><code>"single"</code>. One-year age groups, eg
<code>"0"</code> or <code>"55"</code>, and possibly
an open age group, eg <code>"90+"</code>.
</p>
</li>
<li> <p><code>"five"</code>. Five-year age groups, eg
<code>"0-4"</code> or <code>"55-59"</code>, and possibly
an open age group, eg <code>"100+"</code>.
</p>
</li>
<li> <p><code>"lt"</code>. Life table age groups, eg
<code>"0"</code>, <code>"1-4"</code>, <code>"5-9"</code>,
<code>"55-59"</code>, or <code>"80+"</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>age_labels(type, min = 0, max = 100, open = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_labels_+3A_type">type</code></td>
<td>
<p>Type of age group labels:
<code>"single"</code>, <code>"five"</code>, or <code>"lt"</code>.</p>
</td></tr>
<tr><td><code id="age_labels_+3A_min">min</code></td>
<td>
<p>Minimum age. Defaults to 0.</p>
</td></tr>
<tr><td><code id="age_labels_+3A_max">max</code></td>
<td>
<p>Maximum age for closed age groups.
Defaults to 100.</p>
</td></tr>
<tr><td><code id="age_labels_+3A_open">open</code></td>
<td>
<p>Whether the last age group is
&quot;open&quot;, ie has no upper limit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first age group starts at the age
specified by <code>min</code>. If <code>open</code> is <code>TRUE</code>,
then the final age group starts at the age
specified by <code>max</code>. Otherwise, the
final age group ends at the age specified
by <code>max</code>.
</p>
<p><code>open</code> defaults to <code>TRUE</code> when
<code>min</code> equals zero, and to <code>FALSE</code>
otherwise.
</p>


<h3>Value</h3>

<p>A character vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reformat_age">reformat_age()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>age_labels(type = "single", min = 15, max = 40)
age_labels(type = "five")
age_labels(type = "lt", max = 80)
</code></pre>

<hr>
<h2 id='age_lower'>Lower Limits, Midpoints, and Upper Limits of Age Groups</h2><span id='topic+age_lower'></span><span id='topic+age_mid'></span><span id='topic+age_upper'></span>

<h3>Description</h3>

<p>Given a vector <code>x</code> of age group labels, return
a numeric vector.
</p>

<ul>
<li> <p><code>age_lower()</code> returns the lower limits of each age group,
</p>
</li>
<li> <p><code>age_mid()</code> returns the midpoints, and
</p>
</li>
<li> <p><code>age_upper()</code> returns the upper limits.
</p>
</li></ul>

<p>Vector <code>x</code> must describe 1-year, 5-year or life-table
age groups: see <code><a href="#topic+age_labels">age_labels()</a></code> for examples. <code>x</code> can
format these age groups in any way understood by
<code><a href="#topic+reformat_age">reformat_age()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>age_lower(x)

age_mid(x)

age_upper(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="age_lower_+3A_x">x</code></td>
<td>
<p>A vector of age group labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can make age groups easier to work
with. Lower and upper limits can be used for
selecting on age. Replacing age group with midpoints
can improve graphs.
</p>


<h3>Value</h3>

<p>A numeric vector, the same length as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reformat_age">reformat_age()</a></code> <code><a href="#topic+age_labels">age_labels()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("15-19", "5-9", "50+")
age_lower(x)
age_mid(x)
age_upper(x)

## non-standard formats are OK
age_lower(c("infants", "100 and over"))

df &lt;- data.frame(age = c("1-4", "10-14", "5-9", "0"),
                 rate = c(0.023, 0.015, 0.007, 0.068))
df
subset(df, age_lower(age) &gt;= 5)
</code></pre>

<hr>
<h2 id='check_age'>Validity Checks for Age Labels</h2><span id='topic+check_age'></span>

<h3>Description</h3>

<p>Check that age labels can be parsed and,
optionally, whether the labels are
complete, unique, start at zero,
and end with an open age group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_age(x, complete = FALSE, unique = FALSE, zero = FALSE, open = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_age_+3A_x">x</code></td>
<td>
<p>A vector of age labels.</p>
</td></tr>
<tr><td><code id="check_age_+3A_complete">complete</code></td>
<td>
<p>If <code>TRUE</code>,
test whether <code>x</code> has gaps.</p>
</td></tr>
<tr><td><code id="check_age_+3A_unique">unique</code></td>
<td>
<p>If <code>TRUE</code>,
test whether <code>x</code> has duplicates.</p>
</td></tr>
<tr><td><code id="check_age_+3A_zero">zero</code></td>
<td>
<p>If <code>TRUE</code>,
test whether youngest age group in
<code>x</code> starts at 0.</p>
</td></tr>
<tr><td><code id="check_age_+3A_open">open</code></td>
<td>
<p>If <code>TRUE</code>,
test whether oldest age group in <code>x</code>
is open.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>check_age()</code> only tests whether
a set of labels can be parsed as single-year,
five-year, or life table age groups.
(See <code><a href="#topic+age_group_type">age_group_type()</a></code> for more on the three
types of age group.) However, it can
also apply the following tests:
</p>

<ul>
<li> <p><code>complete</code>. Whether <code>x</code> includes
all intermediate age groups, with no gaps.
For instance, the labels <code>c("10-14", "15-19", "5-9")</code>
are complete, while the labels<code>c("15-19", "5-9")</code>
are not (because they are missing <code>"10-14"</code>.)
</p>
</li>
<li> <p><code>unique</code>. Whether <code>x</code> has duplicated labels.
</p>
</li>
<li> <p><code>zero</code>. Whether the youngest age group in <code>x</code> starts
at age 0, ie whether it includes <code>"0"</code> or <code>"0-4"</code>.
</p>
</li>
<li> <p><code>open</code>. Whether the oldest age group in <code>x</code> has an &quot;open&quot;
age group, such as <code>"100+"</code> or <code>"65+"</code>, that has no
upper limit.
</p>
</li></ul>



<h3>Value</h3>

<p><code>TRUE</code>, invisibly, or raises an
error if a test fails.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+reformat_age">reformat_age()</a></code> to convert age labels to
the format used by <strong>poputils</strong>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>try(
  check_age(c("10-14", "0-4", "15+"),
            complete = TRUE)  
)

try(
  check_age(c("10-14", "5-9", "0-4", "5-9", "15+"),
            unique = TRUE)
)

try(
  check_age(c("10-14", "5-9", "15+"),
            zero = TRUE)
)

try(
  check_age(c("10-14", "0-4", "5-9"),
            open = TRUE)
)
</code></pre>

<hr>
<h2 id='check_equal_length'>Check that Arguments have Same Length</h2><span id='topic+check_equal_length'></span>

<h3>Description</h3>

<p>Check that <code>x</code> and <code>y</code> have the same length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_equal_length(x, y, nm_x, nm_y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_equal_length_+3A_x">x</code>, <code id="check_equal_length_+3A_y">y</code></td>
<td>
<p>Arguments to compare</p>
</td></tr>
<tr><td><code id="check_equal_length_+3A_nm_x">nm_x</code>, <code id="check_equal_length_+3A_nm_y">nm_y</code></td>
<td>
<p>Names to use in error message</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'TRUE', invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:3
y &lt;- 3:1
check_equal_length(x = x,
                   y = y,
                   nm_x = "x",
                   nm_y = "y")
</code></pre>

<hr>
<h2 id='check_n'>Check Whole Number</h2><span id='topic+check_n'></span>

<h3>Description</h3>

<p>Check that <code>n</code> is  finite, non-NA scalar that
is an integer or integerish (ie is equal to <code>round(n)</code>),
and optionally within a specified range
and divisible by a specified number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_n(n, nm_n, min, max, divisible_by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_n_+3A_n">n</code></td>
<td>
<p>A whole number</p>
</td></tr>
<tr><td><code id="check_n_+3A_nm_n">nm_n</code></td>
<td>
<p>Name for 'n' to be used in error messages</p>
</td></tr>
<tr><td><code id="check_n_+3A_min">min</code></td>
<td>
<p>Minimum value 'n' can take. Can be NULL.</p>
</td></tr>
<tr><td><code id="check_n_+3A_max">max</code></td>
<td>
<p>Maximum values 'n' can take. Can be NULL.</p>
</td></tr>
<tr><td><code id="check_n_+3A_divisible_by">divisible_by</code></td>
<td>
<p>'n' must be divisible by this. Can be NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If all tests pass, <code>check_n()</code> returns <code>TRUE</code> invisibly.
Otherwise it throws an error.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check_n(10, nm_n = "count", min = 0, max = NULL, divisible_by = 1)
check_n(10, nm_n = "count", min = NULL, max = NULL, divisible_by = NULL)
check_n(10, nm_n = "n", min = 5, max = 10, divisible_by = 2)
</code></pre>

<hr>
<h2 id='check_no_overlap_colnums'>Check that Colnum Vectors do not Overlap</h2><span id='topic+check_no_overlap_colnums'></span>

<h3>Description</h3>

<p>Given a named list of colnum vectors, like those
produced by <code><a href="tidyselect.html#topic+eval_select">tidyselect::eval_select()</a></code>,
throw an error if there is an overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_no_overlap_colnums(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_no_overlap_colnums_+3A_x">x</code></td>
<td>
<p>A named list of integer vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code>, invisibly
</p>


<h3>See Also</h3>

<p><code><a href="tidyselect.html#topic+eval_select">tidyselect::eval_select()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(arg1 = c(age = 1L),
          arg2 = c(gender = 4L, region = 5L))
check_no_overlap_colnums(x)
</code></pre>

<hr>
<h2 id='combine_age'>Aggregate Age Group Labels</h2><span id='topic+combine_age'></span>

<h3>Description</h3>

<p>Convert age group labels to a less detailed classification.
The three classifications recognized by <code>combine_age()</code>
are <code>"single"</code>, <code>"five"</code>, and <code>"lt"</code>, as defined on
<code><a href="#topic+age_labels">age_labels()</a></code>. The following conversions are permitted:
</p>

<ul>
<li> <p><code>"single"</code> &mdash;&gt; <code>"lt"</code>
</p>
</li>
<li> <p><code>"single"</code> &mdash;&gt; <code>"five"</code>
</p>
</li>
<li> <p><code>"lt"</code> &mdash;&gt; <code>"five"</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>combine_age(x, to = c("five", "lt"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_age_+3A_x">x</code></td>
<td>
<p>A vector of age labels</p>
</td></tr>
<tr><td><code id="combine_age_+3A_to">to</code></td>
<td>
<p>Type of age classification
to convert to: <code>"five"</code> or <code>"lt"</code>.
Defaults to <code>"five"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>x</code> is a factor, then <code>combine_age()</code>
returns a factor; otherwise it returns a
character vector.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+age_labels">age_labels()</a></code> to create age group labels
</p>
</li>
<li> <p><code><a href="#topic+reformat_age">reformat_age()</a></code> to convert existing age group labels
to a standard format
</p>
</li>
<li> <p><code><a href="#topic+set_age_open">set_age_open()</a></code> to set the lower limit
of the open age group
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("0", "5", "3", "12")
combine_age(x)
combine_age(x, to = "lt")
</code></pre>

<hr>
<h2 id='ex_to_lifetab_brass'>Derive Life Tables that Match Life Expectancies,
using a Brass Logit Model</h2><span id='topic+ex_to_lifetab_brass'></span>

<h3>Description</h3>

<p>Turn life expectancies at birth into full life tables,
using the Brass logit model. The method is simple
and is designed for simulations or for
settings with little or no data on age-specific
mortality rates. In settings where data
on age-specific mortality is available,
other methods might be more appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_to_lifetab_brass(
  target,
  standard,
  infant = c("constant", "linear", "CD", "AK"),
  child = c("constant", "linear", "CD"),
  closed = c("constant", "linear"),
  open = "constant",
  radix = 1e+05,
  suffix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ex_to_lifetab_brass_+3A_target">target</code></td>
<td>
<p>A data frame containing a variable called
<code>"ex"</code>, and possibly others. See Details.</p>
</td></tr>
<tr><td><code id="ex_to_lifetab_brass_+3A_standard">standard</code></td>
<td>
<p>A data frame containing variables
called <code>age</code> and <code>lx</code>, and possibly others.
See details.</p>
</td></tr>
<tr><td><code id="ex_to_lifetab_brass_+3A_infant">infant</code>, <code id="ex_to_lifetab_brass_+3A_child">child</code>, <code id="ex_to_lifetab_brass_+3A_closed">closed</code>, <code id="ex_to_lifetab_brass_+3A_open">open</code></td>
<td>
<p>Methods used to
calculate life expectancy. See <code><a href="#topic+lifetab">lifetab()</a></code> for details.</p>
</td></tr>
<tr><td><code id="ex_to_lifetab_brass_+3A_radix">radix</code></td>
<td>
<p>Initial population for the
<code>lx</code> column in the derived life table(s).
Default is <code>100000</code>.</p>
</td></tr>
<tr><td><code id="ex_to_lifetab_brass_+3A_suffix">suffix</code></td>
<td>
<p>Optional suffix added to life table columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing one or more life tables.
</p>


<h3>Method</h3>

<p>The method implemented by <code>ex_to_lifetab_brass()</code> is
based on the observation that, if populations A and B
are demographically similar, then, in many cases,
</p>
<p style="text-align: center;"><code class="reqn">\text{logit}(l_x^{\text{B}}) \approx \alpha + \beta \text{logit}(l_x^{\text{A}})</code>
</p>

<p>where <code class="reqn">l_x</code> is the &quot;survivorship probability&quot; quantity
from a life table. When populations are
similar, <code class="reqn">beta</code> is often close to 1.
</p>
<p>Given (i) target life expectancy,
(ii) a set of <code class="reqn">l_x^{\text{A}}</code>),
(referred to as a &quot;standard&quot;), and
(iii) a value for <code class="reqn">\beta</code>,
<code>ex_to_lifetab_brass()</code> finds
a value for <code class="reqn">\alpha</code> that yields a set of
<code class="reqn">l_x^{\text{B}}</code>) with the required life expectancy.
</p>


<h3><code>target</code> argument</h3>

<p><code>target</code> is a data frame specifying
life expectancies for each population being modelled,
and, possibly, inputs to the calculations, and
index variables. Values in <code>target</code> are not age-specific.
</p>

<ul>
<li><p> A variable called <code>"ex"</code>, with life expectancy at birth
must be included in <code>target</code>.
</p>
</li>
<li><p> A variable called <code>"beta"</code> with values
for <code>beta</code> can be included in <code>target</code>.
This variable can be an <a href="rvec.html#topic+rvec">rvec</a>.
If no <code>"beta"</code> variable is included in <code>target</code>,
then <code>ex_to_lifetab_brass()</code> assumes that
<code class="reqn">beta \equiv 1</code>.
</p>
</li>
<li><p> A variable called <code>"sex"</code>. If the <code>infant</code>
argument to <code>ex_to_lifetab_brass()</code> is is <code>"CD"</code> or <code>"AK"</code>,
or if the <code>child</code> argument is <code>"CD"</code>,
<code>target</code> must include a <code style="white-space: pre;">&#8288;"sex" variable, and the labels for this variable must be interpretable by function [format_sex()]. Otherwise, the &#8288;</code>&quot;sex&quot;' variable  is optional,
and there is no restriction on labels.
</p>
</li>
<li><p> Other variables used to distinguish between
life expectancies, such as time, region,
or model variant.
</p>
</li></ul>



<h3><code>standard</code> argument</h3>

<p><code>standard</code> is a data frame specifying
the <code class="reqn">l_x</code> to be used with each life expectancy
in <code>ex</code>, and, optionally, values the average age
person-years lived by people who die in each group,
<code class="reqn">_na_x</code>. Values in <code>standard</code> are age-specific.
</p>

<ul>
<li><p> A variable called <code>"age"</code>, with labels that
can be parsed by <code><a href="#topic+reformat_age">reformat_age()</a></code>.
</p>
</li>
<li><p> A variable called <code>"lx"</code>.
Internally each set of <code class="reqn">l_x</code> is are standardized
so that the value for age 0 equals 1.
Within each set, values must be non-increasing.
Cannot be an rvec.
</p>
</li>
<li><p> Additional variables used to match rows in <code>standard</code>
to rows in <code>target</code>.
</p>
</li></ul>

<p>Internally, <code>standard</code> is merged with
<code>target</code> using a left join from <code>target</code>,
on any variables that <code>target</code>
and <code>standard</code> have in common.
</p>


<h3>References</h3>

<p>Brass W, Coale AJ. 1968. “Methods of analysis and estimation,”
in Brass, W,  Coale AJ, Demeny P, Heisel DF, et al. (eds).
The Demography of Tropical Africa. Princeton NJ:
Princeton University Press, pp. 88–139.
</p>
<p>Moultrie TA, Timæus IM. 2013. Introduction to Model Life Tables.
In Moultrie T, Dorrington R, Hill A, Hill K, Timæus I, Zaba B.
(eds). Tools for Demographic Estimation.
Paris: International Union for the Scientific Study of Population.
<a href="https://demographicestimation.iussp.org/content/using-models-derive-life-tables-incomplete-data">online version</a>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+logit">logit()</a></code>, <code><a href="#topic+invlogit">invlogit()</a></code> Logit function
</p>
</li>
<li> <p><code><a href="#topic+lifeexp">lifeexp()</a></code> Calculate life expectancy from detailed inputs
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## create new life tables based on level-1
## 'West' model life tables, but with lower
## life expectancy

library(dplyr, warn.conflicts = FALSE)

target &lt;- data.frame(sex = c("Female", "Male"), 
                     ex = c(17.5, 15.6))

standard &lt;- west_lifetab |&gt;
    filter(level == 1) |&gt;
    select(sex, age, lx)
    
ex_to_lifetab_brass(target = target,
                    standard = standard,
                    infant = "CD",
                    child = "CD")
</code></pre>

<hr>
<h2 id='find_label_female'>Identify Sex or Gender Labels Referring to Females</h2><span id='topic+find_label_female'></span>

<h3>Description</h3>

<p>Given labels for sex or gender, try to infer
which (if any) refer to females.
If no elements look like a label for females,
or if two or more elements do,
then return <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_label_female(nms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_label_female_+3A_nms">nms</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of <code>nms</code> or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_label_male">find_label_male()</a></code>, <code><a href="#topic+find_var_sexgender">find_var_sexgender()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_label_female(c("Female", "Male")) ## one valid
find_label_female(c("0-4", "5-9"))     ## none valid
find_label_female(c("F", "Fem"))       ## two valid
</code></pre>

<hr>
<h2 id='find_label_male'>Identify Sex or Gender Labels Referring to Males</h2><span id='topic+find_label_male'></span>

<h3>Description</h3>

<p>Given labels for sex or gender, try to infer
which (if any) refer to males.
If no elements look like a label for males,
or if two or more elements do,
then return <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_label_male(nms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_label_male_+3A_nms">nms</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of <code>nms</code> or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_label_female">find_label_female()</a></code>, <code><a href="#topic+find_var_sexgender">find_var_sexgender()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_label_male(c("Female", "Male")) ## one valid
find_label_male(c("0-4", "5-9"))     ## none valid
find_label_male(c("male", "m"))      ## two valid
</code></pre>

<hr>
<h2 id='find_var_age'>Identify an Age Variable</h2><span id='topic+find_var_age'></span>

<h3>Description</h3>

<p>Find the element of <code>nms</code> that looks like an age variable.
If no elements look like an age variable, or if
two or more elements do,
then return <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_var_age(nms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_var_age_+3A_nms">nms</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of <code>nms</code>, or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_var_time">find_var_time()</a></code>, <code><a href="#topic+find_var_sexgender">find_var_sexgender()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_var_age(c("Sex", "Year", "AgeGroup", NA)) ## one valid
find_var_age(c("Sex", "Year"))                 ## none valid
find_var_age(c("age", "age.years"))            ## two valid
</code></pre>

<hr>
<h2 id='find_var_sexgender'>Identify a Sex or Gender Variable</h2><span id='topic+find_var_sexgender'></span>

<h3>Description</h3>

<p>Find the element of <code>nms</code> that looks like
a sex or gender variable.
If no elements look like a sex or gender variable,
or if two or more elements do,
then return <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_var_sexgender(nms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_var_sexgender_+3A_nms">nms</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of <code>nms</code>, or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_var_age">find_var_age()</a></code>, <code><a href="#topic+find_var_time">find_var_time()</a></code>, <code><a href="#topic+find_label_female">find_label_female()</a></code>,
<code><a href="#topic+find_label_male">find_label_male()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_var_sexgender(c("Sex", "Year", "AgeGroup", NA)) ## one valid
find_var_sexgender(c("Age", "Region"))               ## none valid
find_var_sexgender(c("sexgender", "sexes"))          ## two valid
</code></pre>

<hr>
<h2 id='find_var_time'>Identify a Time Variable</h2><span id='topic+find_var_time'></span>

<h3>Description</h3>

<p>Find the element of <code>nms</code> that looks like an time variable.
If no elements look like a time variable, or if
two or more elements do,
then return <code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_var_time(nms)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_var_time_+3A_nms">nms</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An element of <code>nms</code>, or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find_var_age">find_var_age()</a></code>, <code><a href="#topic+find_var_sexgender">find_var_sexgender()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>find_var_time(c("Sex", "Year", "AgeGroup", NA)) ## one valid
find_var_time(c("Sex", "Region"))               ## none valid
find_var_time(c("time", "year"))                ## two valid
</code></pre>

<hr>
<h2 id='groups_colnums'>Get a named vector of column indices
for the grouping variables in a
grouped data frame</h2><span id='topic+groups_colnums'></span>

<h3>Description</h3>

<p>Constructed a named vector of indices
equivalent to the vectors produced by
tidyselect::eval_select, but for the grouping
variables in an object of class
&quot;grouped_df&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groups_colnums(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groups_colnums_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> is not grouped, then <code>groups_colnums</code>
returns a zero-length vector.
</p>


<h3>Value</h3>

<p>A named integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- data.frame(x = 1:4,
                 g = c(1, 1, 2, 2))
groups_colnums(df)
df &lt;- group_by(df, g)
groups_colnums(df)
</code></pre>

<hr>
<h2 id='lifetab'>Calculate Life Tables or Life Expectancies</h2><span id='topic+lifetab'></span><span id='topic+lifeexp'></span>

<h3>Description</h3>

<p>Calculate life table quantities. Function
<code>lifetab()</code> returns an entire life table.
Function <code>lifeexp()</code> returns life expectancy at birth.
The inputs can be mortality rates (<code>mx</code>) or
probabilities of dying (<code>qx</code>), though not both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lifetab(
  data,
  mx = NULL,
  qx = NULL,
  age = age,
  sex = NULL,
  ax = NULL,
  by = NULL,
  infant = c("constant", "linear", "CD", "AK"),
  child = c("constant", "linear", "CD"),
  closed = c("constant", "linear"),
  open = "constant",
  radix = 1e+05,
  suffix = NULL
)

lifeexp(
  data,
  mx = NULL,
  qx = NULL,
  at = 0,
  age = age,
  sex = NULL,
  ax = NULL,
  by = NULL,
  infant = c("constant", "linear", "CD", "AK"),
  child = c("constant", "linear", "CD"),
  closed = c("constant", "linear"),
  open = "constant",
  suffix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lifetab_+3A_data">data</code></td>
<td>
<p>Data frame with mortality data.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_mx">mx</code></td>
<td>
<p>&lt;<code><a href="tidyselect.html#topic+language">tidyselect</a></code>&gt;
Mortality rates, expressed as deaths per
person-year lived. Possibly an <a href="rvec.html#topic+rvec">rvec</a>.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_qx">qx</code></td>
<td>
<p>&lt;<code><a href="tidyselect.html#topic+language">tidyselect</a></code>&gt;
Probability of dying within age interval.
An alternative to <code>mx</code>. Possibly an <a href="rvec.html#topic+rvec">rvec</a>.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_age">age</code></td>
<td>
<p>&lt;<code><a href="tidyselect.html#topic+language">tidyselect</a></code>&gt;
Age group labels. The labels must be
interpretable by functions
such as <code><a href="#topic+reformat_age">reformat_age()</a></code> and <code><a href="#topic+age_group_type">age_group_type()</a></code>.
The first age group must start at age 0, and the
last age group must be &quot;open&quot;, with no upper
limit.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_sex">sex</code></td>
<td>
<p>&lt;<code><a href="tidyselect.html#topic+language">tidyselect</a></code>&gt;
Biological sex, with labels that can be
interpreted by <code><a href="#topic+reformat_sex">reformat_sex()</a></code>. Needed only when
<code>infant</code> is <code>"CD"</code> or <code>"AK"</code>, or <code>child</code> is
<code>"CD"</code>.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_ax">ax</code></td>
<td>
<p>&lt;<code><a href="tidyselect.html#topic+language">tidyselect</a></code>&gt;
Average age at death within age group.
Optional. See Details.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_by">by</code></td>
<td>
<p>&lt;<code><a href="tidyselect.html#topic+language">tidyselect</a></code>&gt;
Separate life tables, or life expectancies,
calculated for each combination the <code>by</code> variables.
If a <code>sex</code> variable was specified, then that
variable is automatically included among the <code>by</code>
variables. If <code>data</code> is a
<a href="https://dplyr.tidyverse.org/reference/group_data.html">grouped</a>
data frame, then the grouping variables
take precedence over <code>by</code>.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_infant">infant</code></td>
<td>
<p>Method used to calculate
life table values in age group <code>"0"</code>.
Ignored if <code>age</code> does not include age group <code>"0"</code>.
Default is <code>"constant"</code>.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_child">child</code></td>
<td>
<p>Method used to calculate
life table values in age group <code>"1-4"</code>.
Ignored if <code>age</code> does not include age group <code>"0"</code>.
Default is <code>"constant"</code>.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_closed">closed</code></td>
<td>
<p>Method used to calculate
life table values in closed age intervals
other than <code>"0"</code> and <code>"1-4"</code> (ie intervals
such as &quot;10-14&quot; or &quot;12&quot;). Default is <code>"constant"</code>.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_open">open</code></td>
<td>
<p>Method used to calculate
life table values in the final, open age group
(eg <code>"80+"</code> or <code>"110+"</code>).
Currently the only option is '&quot;constant&quot;.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_radix">radix</code></td>
<td>
<p>Initial population for the
<code>lx</code> column. Default is <code>100000</code>.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_suffix">suffix</code></td>
<td>
<p>Optional suffix added to new
columns in result.</p>
</td></tr>
<tr><td><code id="lifetab_+3A_at">at</code></td>
<td>
<p>Age at which life expectancy is calculated
(<code style="white-space: pre;">&#8288;lifeexp() only). Default is &#8288;</code>0'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="tibble.html#topic+tibble">tibble</a>.
</p>


<h3>Definitions of life table quantities</h3>


<ul>
<li> <p><code>mx</code> Deaths per person-year lived.
</p>
</li>
<li> <p><code>qx</code> Probability of surviving from the start
of age group 'x' to the end.
</p>
</li>
<li> <p><code>lx</code> Number of people alive at
the start of age group <code>x</code>.
</p>
</li>
<li> <p><code>dx</code> Number of deaths in age group <code>x</code>
</p>
</li>
<li> <p><code>Lx</code> Expected number of person years lived in
age group <code>x</code>.
</p>
</li>
<li> <p><code>ex</code> Life expectancy, calculated at the start
of age group <code>x</code>.
</p>
</li></ul>

<p>Mortality rates <code>mx</code> are sometimes expressed
as deaths per 1000 person-years lived, or per 100,000
person-years lived. <code>lifetab()</code> and <code>lifeexp()</code>
assumed that they are expressed as deaths per
person-year lived.
</p>


<h3>Calculation methods</h3>

<p><code>lifetab()</code> and <code>lifeexp()</code> implement several
methods for calculating life table quantities
from mortality rates. Each method makes
different assumptions about
the way that mortality rates vary within
age intervals:
</p>

<ul>
<li> <p><code>"constant"</code> Mortality rates are constant
within each interval.
</p>
</li>
<li> <p><code>"linear"</code>. Life table quantity <code>lx</code>
is a straight line within each interval.
Equivalently, deaths are distributed uniformly
within each interval.
</p>
</li>
<li> <p><code>"CD"</code>. Used only with age groups &quot;0&quot;
and &quot;1-4&quot;. Mortality rates decline
over the  age interval,
with the slope depending on the absolute
level of infant mortality. The formulas were
developed by Coale and Demeny (1983),
and used in Preston et al (2001).
</p>
</li>
<li> <p><code>"AK"</code>. Used only with age group &quot;0&quot;.
Mortality rates decline over the age interval,
with the slope depending on the absolute
level of infant mortality. The formulas
were formulas developed by Andreev and Kingkade (2015),
and are used in the Human Mortality Database
<a href="https://www.mortality.org/File/GetDocument/Public/Docs/MethodsProtocolV6.pdf">methods protocol</a>.
</p>
</li></ul>

<p>For a detailed description of the methods,
see the vignette for <strong>poputils</strong>.
</p>


<h3>ax</h3>

<p><code>ax</code> is the average number of years
lived in an age interval by people who
die in that interval. Demographers sometimes
refer to it as the 'separation factor'. If a non-<code>NA</code>
value of <code>ax</code> is supplied for an age group,
then the results for that age group are based
on the formula
</p>
<p style="text-align: center;"><code class="reqn">m_x = d_x / (n_x l_x + a_x d_x)</code>
</p>
<p>,
</p>
<p>(where <code>n_x</code> is the width of the age interval),
over-riding any methods specified via the <code>infant</code>, <code>child</code>,
<code>closed</code> and <code>open</code> arguments.
</p>


<h3>Open age group when inputs are qx</h3>

<p>The probability of dying, <code>qx</code>, is always 1 in the
final (open) age group. <code>qx</code> therefore provides
no direct information on mortality conditions
within the final age group. <code>lifetab()</code> and
<code>lifeexp()</code> use conditions in the second-to-final
age group as a proxy for conditions in the final
age group. When <code>open</code> is <code>"constant"</code> (which
is currently the only option), and no value
for <code>ax</code> in the final age group is provided,
<code>lifetab()</code> and <code>lifeexp()</code> assume
that <code class="reqn">m_A = m_{A-1}</code>, and set
<code class="reqn">L_{A} = l_A / m_A</code>.
</p>
<p>In practice, mortality is likely to be higher
in the final age group than in the second-to-final
age group, so the default procedure is likely to
lead to inaccuracies. When the size of the final
age group is very small, these inaccuracies will
be inconsequential. But in other cases, it may
be necessary to supply an explicit value for
<code>ax</code> for the final age group, or to use <code>mx</code>
rather than <code>qx</code> as inputs.
</p>


<h3>Using rvecs to represent uncertainty</h3>

<p>An <a href="rvec.html#topic+rvec">rvec</a> is a 'random vector',
holding multiple draws from a distribution.
Using an rvec for the <code>mx</code> argument to
<code>lifetab()</code> or <code>lifeexp()</code> is a way of representing
uncertainty. This uncertainty is propagated
through to the life table values, which will
also be rvecs.
</p>


<h3>References</h3>


<ul>
<li><p> Preston SH, Heuveline P, and Guillot M. 2001.
<em>Demography: Measuring and Modeling Population Processes</em>
Oxford: Blackwell.
</p>
</li>
<li><p> Coale AJ, Demeny P,  and Vaughn B. 1983.
<em>Regional model life tables and stable populations</em>
New York: Academic Press.
</p>
</li>
<li><p> Andreev, E.M. and Kingkade, W.W., 2015.
Average age at death in infancy and infant mortality level:
Reconsidering the Coale-Demeny formulas at current
levels of low mortality. <em>Demographic Research</em>,
33, pp.363-390.
</p>
</li>
<li><p> Human Mortality Database <a href="https://www.mortality.org/File/GetDocument/Public/Docs/MethodsProtocolV6.pdf">Methods Protocol</a>.
</p>
</li>
<li> <p><a href="https://demographicestimation.iussp.org">Tools for Demographic Estimation</a>.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+ex_to_lifetab_brass">ex_to_lifetab_brass()</a></code> Calculate life table from minimal inputs
</p>
</li>
<li> <p><code><a href="#topic+q0_to_m0">q0_to_m0()</a></code> Convert between infant mortality measures
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

## life table for females based on 'level 1'
## mortality rates "West" model life table
west_lifetab |&gt;
    filter(sex == "Female",
           level == 1) |&gt;
    lifetab(mx = mx)

## change method for infant and children from
## default ("constant") to "CD"
west_lifetab |&gt;
    filter(sex == "Female",
           level == 1) |&gt;
    lifetab(mx = mx,
            sex = sex,
            infant = "CD",
            child = "CD")

## calculate life expectancies
## for all levels, using the 'by'
## argument to distinguish levels
west_lifetab |&gt;
    lifeexp(mx = mx,
            sex = sex,
            infant = "CD",
            child = "CD",
            by = level)

## obtain the same result using
## 'group_by'
west_lifetab |&gt;
  group_by(level) |&gt;
  lifeexp(mx = mx,
          sex = sex,
          infant = "CD",
          child = "CD")

## calculations based on 'qx'
west_lifetab |&gt;
  lifeexp(qx = qx,
          sex = sex,
          by = level)

## life expectancy at age 60
west_lifetab |&gt;
  filter(level == 10) |&gt;
  lifeexp(mx = mx,
          at = 60,
          sex = sex)
</code></pre>

<hr>
<h2 id='logit'>Logit and Inverse-Logit Functions</h2><span id='topic+logit'></span><span id='topic+invlogit'></span>

<h3>Description</h3>

<p>Transform values to and from the logit scale.
<code>logit()</code> calculates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)

invlogit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_p">p</code></td>
<td>
<p>Values in the interval <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>.
Can be an atomic vector, a matrix,
or an <a href="rvec.html#topic+rvec">rvec</a>.</p>
</td></tr>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>Values in the interval <code style="white-space: pre;">&#8288;(-Inf, Inf)&#8288;</code>.
Can be an atomic vector, a matrix,
or an <a href="rvec.html#topic+rvec">rvec</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">x = \log \left(\frac{p}{1 - p}\right)</code>
</p>

<p>and <code>invlogit()</code> calculates
</p>
<p style="text-align: center;"><code class="reqn">p = \frac{e^x}{1 + e^x}</code>
</p>

<p>To avoid overflow, <code>invlogit()</code>
uses <code class="reqn">p = \frac{1}{1 + e^{-x}}</code>
internally for <code class="reqn">x</code> where <code class="reqn">x &gt; 0</code>.
</p>
<p>In some of the demographic literature,
the logit function is defined as
</p>
<p style="text-align: center;"><code class="reqn">x = \frac{1}{2} \log \left(\frac{p}{1 - p}\right).</code>
</p>

<p><code>logit()</code> and <code>invlogit()</code> follow the conventions
in statistics and machine learning, and omit the
<code class="reqn">\frac{1}{2}</code>.
</p>


<h3>Value</h3>


<ul>
<li><p> A vector of doubles, if <code>p</code> or <code>x</code> is a vector.
</p>
</li>
<li><p> A matrix of doubles, if <code>p</code> or <code>x</code> is a matrix.
</p>
</li>
<li><p> An object of class <code>rvec_dbl</code>, if <code>p</code> or <code>x</code> is an rvec.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- c(0.5, 1, 0.2)
logit(p)
invlogit(logit(p))
</code></pre>

<hr>
<h2 id='matrix_to_list_of_cols'>Turn a Matrix Into a List of Columns or Rows</h2><span id='topic+matrix_to_list_of_cols'></span><span id='topic+matrix_to_list_of_rows'></span>

<h3>Description</h3>

<p>Given a matrix, create a list, each element of which contains
a column or row from the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_list_of_cols(m)

matrix_to_list_of_rows(m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix_to_list_of_cols_+3A_m">m</code></td>
<td>
<p>A matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>matrix_to_list_of_cols()</code> and 'matrix_to_list_of_rows() are
internal functions, for use by developers, and would not
normally be called directly by end users.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>matrix_to_list_of_cols()</code> A list of vectors,
each of which is a column from <code>x</code>.
</p>
</li>
<li> <p><code>matrix_to_list_of_rows()</code>, A list of vectors,
each of which is a row from <code>x</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1:12, nrow = 3)
matrix_to_list_of_cols(m)
matrix_to_list_of_rows(m)
</code></pre>

<hr>
<h2 id='nzmort'>Mortality Data for New Zealand</h2><span id='topic+nzmort'></span>

<h3>Description</h3>

<p>Counts of deaths and population, by age, sex, and calendar
year, plus mortality rates, for New Zealand, 2021-2022.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzmort
</code></pre>


<h3>Format</h3>

<p>A data frame with 84 rows and the
following variables:
</p>

<ul>
<li> <p><code>year</code>: Calendar year.
</p>
</li>
<li> <p><code>gender</code>: <code>"Female"</code>, and <code>"Male"</code>.
</p>
</li>
<li> <p><code>age</code>: Age, in life table age groups, with an open age
group of 95+.
</p>
</li>
<li> <p><code>deaths</code>: Counts of deaths, randomly rounded to base 3.
</p>
</li>
<li> <p><code>popn</code>: Estimates of average annual population.
</p>
</li>
<li> <p><code>mx</code>: Mortality rates (deaths / popn).
</p>
</li></ul>



<h3>Source</h3>

<p>Modified from data in tables
&quot;Deaths by age and sex (Annual-Dec)&quot; and
&quot;Estimated Resident Population by Age and Sex (1991+) (Annual-Dec)&quot;
from Stats NZ online database <em>Infoshare</em>,
downloaded on 24 September 2023.
</p>

<hr>
<h2 id='nzmort_rvec'>Mortality Data and Probabilistic Rates for New Zealand</h2><span id='topic+nzmort_rvec'></span>

<h3>Description</h3>

<p>A modified version of <code>link{nzmort}</code> where <code>mx</code>
columns is an <a href="rvec.html#topic+rvec">rvec</a>, rather than an ordinary
R vector. The rvec holds the random draws from the posterior
distribution obtained from by a Bayesian statistical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nzmort_rvec
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 84 rows and 4 columns.
</p>

<hr>
<h2 id='q0_to_m0'>Convert q0 to m0</h2><span id='topic+q0_to_m0'></span>

<h3>Description</h3>

<p>Convert the probability of dying during infancy
(q0) to the mortality rate for infancy (m0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>q0_to_m0(
  q0,
  sex = NULL,
  a0 = NULL,
  infant = c("constant", "linear", "CD", "AK")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="q0_to_m0_+3A_q0">q0</code></td>
<td>
<p>Probability of dying in first
year of life. A numeric vector or an <a href="rvec.html#topic+rvec">rvec</a>.</p>
</td></tr>
<tr><td><code id="q0_to_m0_+3A_sex">sex</code></td>
<td>
<p>Biological sex. A vector the same length
as <code>q0</code>, with labels that can be
interpreted by <code><a href="#topic+reformat_sex">reformat_sex()</a></code>. Needed only when
<code>infant</code> is <code>"CD"</code> or <code>"AK"</code>.</p>
</td></tr>
<tr><td><code id="q0_to_m0_+3A_a0">a0</code></td>
<td>
<p>Average age at death for infants who die.
Optional. See help for <code><a href="#topic+lifetab">lifetab()</a></code>.</p>
</td></tr>
<tr><td><code id="q0_to_m0_+3A_infant">infant</code></td>
<td>
<p>Calculation method.
See help for <code><a href="#topic+lifetab">lifetab()</a></code>.
Default is <code>"constant"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or <a href="rvec.html#topic+rvec">rvec</a>.
</p>


<h3>Warning</h3>

<p>The term &quot;infant mortality rate&quot; is ambiguous.
Demographers sometimes use it to refer to m0
(which is an actual rate) and sometimes use
it to refer to q0 (which is a probability.)
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+lifetab">lifetab()</a></code> Calculate a full life table.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
west_lifetab |&gt;
 filter(age == 0, level &lt;= 5) |&gt;
 select(level, sex, age, mx, qx) |&gt;
 mutate(m0 = q0_to_m0(q0 = qx, sex = sex, infant = "CD"))
</code></pre>

<hr>
<h2 id='reformat_age'>Reformat Age Group Labels</h2><span id='topic+reformat_age'></span>

<h3>Description</h3>

<p>Convert age group labels to one of three formats:
</p>

<ul>
<li><p> Single-year age groups, eg
<code>"0"</code>, <code>"1"</code>, ..., <code>"99"</code>, <code>"100+"</code>.
</p>
</li>
<li><p> Life table age groups, eg
<code>"0"</code>, <code style="white-space: pre;">&#8288;"1-4", &#8288;</code>&quot;5-9&quot;<code style="white-space: pre;">&#8288;, ..., &#8288;</code>&quot;95-99&quot;<code style="white-space: pre;">&#8288;, &#8288;</code>&quot;100+&quot;'.
</p>
</li>
<li><p> Five-year age groups, eg
<code>"0-4"</code>, <code>"5-9"</code>, ..., <code>"95-99"</code>, <code>"100+"</code>.
</p>
</li></ul>

<p>By default <code>reformat_age()</code> returns a factor
that includes all intermediate age groups.
See below for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reformat_age(x, factor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reformat_age_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="reformat_age_+3A_factor">factor</code></td>
<td>
<p>Whether the return value
should be a factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reformat_age()</code> applies the following algorithm:
</p>

<ol>
<li><p> Tidy and translate text,
eg convert <code>"20 to 24 years"</code> to
<code>"20-24"</code>, convert <code>"infant"</code> to
<code>"0"</code>, or convert <code>"100 or more"</code> to
<code>"100+"</code>.
</p>
</li>
<li><p> Check whether the resulting
labels could have been produced by
<code><a href="#topic+age_labels">age_labels()</a></code>. If not, throw an error.
</p>
</li>
<li><p> If <code>factor</code> is <code>TRUE</code>
(the default), then return a factor. The levels of
this factor include all intermediate age groups.
Otherwise return a character vector.
</p>
</li></ol>

<p>When <code>x</code> consists entirely of numbers, <code>reformat_age()</code>
also checks for two special cases:
</p>

<ul>
<li><p> If every element of <code>x</code> is a multiple of 5,
and if <code>max(x) &gt;= 50</code>, then <code>x</code> is assumed to
describe 5-year age groups
</p>
</li>
<li><p> If every element of <code>x</code> is 0, 1, or a multiple
of 5, with <code>max(x) &gt;= 50</code>, then <code>x</code> is assumed
to describe life table age groups.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>factor</code> is <code>TRUE</code>,
then <code>reformat_age()</code> returns a factor;
otherwise it returns a character vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+age_labels">age_labels()</a></code>, <code><a href="#topic+reformat_sex">reformat_sex()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reformat_age(c("80 to 84", "90 or more", "85 to 89"))

## factor contains intermediate level missing from 'x'
reformat_age(c("80 to 84", "90 or more"))

## non-factor
reformat_age(c("80 to 84", "90 or more"),
          factor = FALSE)

## single
reformat_age(c("80", "90plus"))

## life table
reformat_age(c("0",
            "30-34",
            "10--14",
            "1-4 years"))
</code></pre>

<hr>
<h2 id='reformat_sex'>Reformat a Binary Sex Variable</h2><span id='topic+reformat_sex'></span>

<h3>Description</h3>

<p>Reformat a binary sex variable so
that it consists entirely of
values <code>"Female"</code>, <code>"Male"</code>,
and possibly <code>NA</code> and any values
included in <code>except</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reformat_sex(x, except = NULL, factor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reformat_sex_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="reformat_sex_+3A_except">except</code></td>
<td>
<p>Values to exclude when reformatting.</p>
</td></tr>
<tr><td><code id="reformat_sex_+3A_factor">factor</code></td>
<td>
<p>Whether the return value
should be a factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When parsing labels, <code>reformat_sex()</code>
ignores case: <code>"FEMALE"</code> and <code>"fEmAlE"</code>
are equivalent.
</p>
<p>White space is removed from the beginning
and end of labels.
</p>
<p><code>reformat_sex()</code> does not try to interpreting
numeric codes (eg <code>1</code>, <code>2</code>).
</p>


<h3>Value</h3>

<p>If <code>factor</code> is <code>TRUE</code>,
then <code>reformat_age()</code> returns a factor;
otherwise it returns a character vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+age_labels">age_labels()</a></code>, <code><a href="#topic+reformat_age">reformat_age()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>reformat_sex(c("F", "female", NA, "MALES"))

## values supplied for 'except'
reformat_sex(c("Fem", "Other", "Male", "M"),
             except = c("Other", "Diverse"))

## return an ordinary character vector
reformat_sex(c("F", "female", NA, "MALES"),
             factor = FALSE)
</code></pre>

<hr>
<h2 id='rr3'>Randomly Round A Vector of Integers to Base 3</h2><span id='topic+rr3'></span>

<h3>Description</h3>

<p>Apply the 'Random Round to Base 3' (RR3)
algorithm to a vector of integers
(or doubles where <code>round(x) == x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rr3(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rr3_+3A_x">x</code></td>
<td>
<p>A vector of integers (in the
sense that <code>round(x) == x</code>.) Can be an
<a href="rvec.html#topic+rvec">rvec</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RR3 algorithm is used by statistical
agencies to confidentialize data. Under the
RR3 algorithm, an integer <code class="reqn">n</code>
is randomly rounded as follows:
</p>

<ul>
<li><p> If <code class="reqn">n</code> is divisible by 3, leave it unchanged
</p>
</li>
<li><p> If dividing <code class="reqn">n</code> by 3 leaves a remainder of 1, then
round down (subtract 1) with probability 2/3,
and round up (add 2) with probability 1/3.
</p>
</li>
<li><p> If dividing <code class="reqn">n</code> by 3 leaves a remainder of 1,
then round down (subtract 2)
with probability 1/3, and round up (add 1)
with probability 2/3.
</p>
</li></ul>

<p>RR3 has some nice properties:
</p>

<ul>
<li><p> The randomly-rounded version of <code class="reqn">n</code>
has expected value <code class="reqn">n</code>.
</p>
</li>
<li><p> If <code class="reqn">n</code> non-negative, then the randomly
rounded version of <code class="reqn">n</code> is non-negative.
</p>
</li>
<li><p> If <code class="reqn">n</code> is non-positive, then the randomly
rounded version of <code class="reqn">n</code> is non-positive.
</p>
</li></ul>



<h3>Value</h3>

<p>A randomly-rounded version of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 5, 2, 0, -1, 3, NA)
rr3(x)
</code></pre>

<hr>
<h2 id='set_age_open'>Specify Open Age Group</h2><span id='topic+set_age_open'></span>

<h3>Description</h3>

<p>Set the lower limit of the open age group.
Given a vector of age group labels,
recode all age groups with a lower limit
greater than or equal to <code style="white-space: pre;">&#8288;&lt;lower&gt;&#8288;</code> to <code style="white-space: pre;">&#8288;&lt;lower&gt;+&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_age_open(x, lower)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_age_open_+3A_x">x</code></td>
<td>
<p>A vector of age labels.</p>
</td></tr>
<tr><td><code id="set_age_open_+3A_lower">lower</code></td>
<td>
<p>An integer. The lower limit
for the open age group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>set_age_open()</code> requires that <code>x</code> and
the return value have a
a five-year, single-year, or life table format,
as described in <code><a href="#topic+age_labels">age_labels()</a></code>.
</p>


<h3>Value</h3>

<p>A modified version of <code>x</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code>set_age_open()</code> uses <code><a href="#topic+age_lower">age_lower()</a></code> to identify
lower limits
</p>
</li>
<li> <p><code><a href="#topic+age_labels">age_labels()</a></code> for creating age labels from scratch
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("100+", "80-84", "95-99", "20-24")
set_age_open(x, 90)
set_age_open(x, 25)
</code></pre>

<hr>
<h2 id='to_matrix'>Build a Matrix from Measure and ID Variables</h2><span id='topic+to_matrix'></span>

<h3>Description</h3>

<p>Build a matrix where the elements are values of
a measure variable, and the rows and columns
are formed by observed combinations of ID
variables. The ID variables picked
out by <code>rows</code> and <code>cols</code> must uniquely identify
cells. <code>to_matrix()</code>, unlike <code>stats::xtabs()</code>,
does not sum across multiple combinations of
ID variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_matrix(x, rows, cols, measure)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_matrix_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="to_matrix_+3A_rows">rows</code></td>
<td>
<p>The ID variable(s)
used to distinguish rows in the matrix.</p>
</td></tr>
<tr><td><code id="to_matrix_+3A_cols">cols</code></td>
<td>
<p>The ID variable(s)
used to distinguish columns in the matrix.</p>
</td></tr>
<tr><td><code id="to_matrix_+3A_measure">measure</code></td>
<td>
<p>The measure variable, eg
rates or counts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- expand.grid(age = c(0, 1, 2),
                 sex = c("F", "M"),
                 region = c("A", "B"),
                 year = 2000:2001)
x$count &lt;- 1:24

to_matrix(x,
          rows = c(age, sex),
          cols = c(region, year),
          measure = count)

to_matrix(x,
          rows = c(age, sex, region),
          cols = year,
          measure = count)

## cells not uniquely identified
try(
to_matrix(x,
          rows = age,
          cols = sex,
          measure = count)
)
</code></pre>

<hr>
<h2 id='trim_01'>Trim Values So They Are Between 0 and 1</h2><span id='topic+trim_01'></span>

<h3>Description</h3>

<p>Trim a vector so that all values are greater
than 0 and less than 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_01(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim_01_+3A_x">x</code></td>
<td>
<p>A numeric vector. Can be an
<a href="rvec.html#topic+rvec">rvec</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If
</p>

<ul>
<li> <p><code>min</code> is lowest element of <code>x</code>
that is higher than 0, and
</p>
</li>
<li> <p><code>max</code> is the highest element of <code>x</code> that is
lower than 1,
then <code>trim_01()</code>
</p>
</li>
<li><p> shifts all elements of <code>x</code> that are lower than <code>min</code>
upwards, so that they equal <code>min</code>, and
</p>
</li>
<li><p> shifts all elements of <code>x</code> that are higher than <code>max</code>
downwards, so that they equal <code>max</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A trimmed version of <code>x</code>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+logit">logit()</a></code>, <code><a href="#topic+invlogit">invlogit()</a></code> Logit transformation
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 0.98, -0.001, 0.5, 0.01)
trim_01(x)
</code></pre>

<hr>
<h2 id='west_lifetab'>Coale-Demeny West Model Life Tables</h2><span id='topic+west_lifetab'></span>

<h3>Description</h3>

<p>Life table quantities from the &quot;West&quot; family
of Coale-Demeny model life tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>west_lifetab
</code></pre>


<h3>Format</h3>

<p>A data frame with 1,050 rows and the
following variables:
</p>

<ul>
<li> <p><code>level</code>: Index for life table. Lower level implies
lower life expectancy.
</p>
</li>
<li> <p><code>sex</code>: <code>"Female"</code>, and <code>"Male"</code>.
</p>
</li>
<li> <p><code>age</code>: Age, in life table age groups, with an open age
group of 95+.
</p>
</li>
<li> <p><code>mx</code>: Mortality rate.
</p>
</li>
<li> <p><code>ax</code>: Average years lived in age interval by people
who die in that interval.
</p>
</li>
<li> <p><code>qx</code>: Probability some alive at start of age interval
dies during interval.
</p>
</li>
<li> <p><code>lx</code>: Number of people still alive at start of
age interval.
</p>
</li>
<li> <p><code>dx</code>: Number of people dying during age interval.
</p>
</li>
<li> <p><code>Lx</code>: Number of person-years lived during age interval.
</p>
</li>
<li> <p><code>ex</code>: Expectation of life at start of age interval.
</p>
</li></ul>



<h3>Source</h3>

<p>Coale A, Demeny P, and Vaughn B. 1983.
Regional model life tables and stable populations.
2nd ed. New York: Academic Press,
accessed via <code>demogR::cdmltw()</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
