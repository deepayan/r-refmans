<!DOCTYPE html><html lang="en"><head><title>Help for package IDSpatialStats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IDSpatialStats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DengueSimR01'><p>Simulated dataset of dengue transmission with basic reproductive number of 1</p></a></li>
<li><a href='#DengueSimR02'><p>Simulated dataset of dengue cases with basic reproductive number of 2</p></a></li>
<li><a href='#DengueSimRepresentative'><p>Simulated dataset of dengue cases with representative underlying population</p></a></li>
<li><a href='#est.transdist'><p>Estimate transmission distance</p></a></li>
<li><a href='#est.transdist.bootstrap.ci'><p>Bootstrap mean transmission distance values</p></a></li>
<li><a href='#est.transdist.temporal'><p>Change in mean transmission distance over time</p></a></li>
<li><a href='#est.transdist.temporal.bootstrap.ci'><p>Bootstrapped confidence intervals for the change in mean transmission distance over time</p></a></li>
<li><a href='#est.transdist.theta.weights'><p>Estimate transmission distance theta values by replication</p></a></li>
<li><a href='#est.wt.matrix'><p>Calculate the Infector-Infectee Wallinga-Teunis matrix</p></a></li>
<li><a href='#est.wt.matrix.weights'><p>Estimate matrix of basic Wallinga-Teunis weights</p></a></li>
<li><a href='#get.cross.K'><p>Cross type K function using homotypic and heterotypic case types</p></a></li>
<li><a href='#get.cross.PCF'><p>Cross type Pair Correlation Function using homotypic and heterotypic case types</p></a></li>
<li><a href='#get.pi'><p>Generalized version of <code>get.pi</code></p></a></li>
<li><a href='#get.pi.bootstrap'><p>Bootstrap <code>get.pi</code> values.</p></a></li>
<li><a href='#get.pi.ci'><p>Calculate bootstrapped confidence intervals for <code>get.pi</code> values.</p></a></li>
<li><a href='#get.pi.permute'><p>get the null distribution of the <code>get.pi</code> function</p></a></li>
<li><a href='#get.pi.typed'><p>Optimized version of <code>get.pi</code> for typed data.</p></a></li>
<li><a href='#get.pi.typed.bootstrap'><p>runs bootstrapping on <code>get.pi.typed</code></p></a></li>
<li><a href='#get.pi.typed.permute'><p>get the null distribution of the get.pi.typed function</p></a></li>
<li><a href='#get.tau'><p>generalized version of <code>get.tau</code></p></a></li>
<li><a href='#get.tau.bootstrap'><p>Bootstrap <code>get.tau</code> values.</p></a></li>
<li><a href='#get.tau.ci'><p>Bootstrap confidence interval for the <code>get.tau</code> values</p></a></li>
<li><a href='#get.tau.permute'><p>get the null distribution of the <code>get.tau</code> function</p></a></li>
<li><a href='#get.tau.typed'><p>Optimized version of <code>get.tau</code> for typed data</p></a></li>
<li><a href='#get.tau.typed.bootstrap'><p>runs bootstrapping for <code>get.tau.typed</code></p></a></li>
<li><a href='#get.tau.typed.permute'><p>get the null distribution for the <code>get.tau.typed</code> function</p></a></li>
<li><a href='#get.theta'><p>Generalized version of <code>get.theta</code></p></a></li>
<li><a href='#get.theta.bootstrap'><p>Bootstrap <code>get.theta</code> values.</p></a></li>
<li><a href='#get.theta.ci'><p>Calculate bootstrapped confidence intervals for <code>get.theta</code> values.</p></a></li>
<li><a href='#get.theta.permute'><p>get the null distribution of the <code>get.theta</code> function</p></a></li>
<li><a href='#get.theta.typed'><p>Optimized version of <code>get.theta</code> for typed data.</p></a></li>
<li><a href='#get.theta.typed.bootstrap'><p>runs bootstrapping on <code>get.theta.typed</code></p></a></li>
<li><a href='#get.theta.typed.permute'><p>get the null distribution of the get.theta.typed function</p></a></li>
<li><a href='#get.transdist.theta'><p>Get weights of transmission distance theta</p></a></li>
<li><a href='#sim.epidemic'><p>Simulation of an epidemic in space and time</p></a></li>
<li><a href='#sim.plot'><p>Plot output of simulated epidemic</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Global Clustering in Infectious Disease</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements various novel and standard clustering statistics and
  other analyses useful for understanding the spread of infectious disease.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, spatstat.explore, spatstat.geom</td>
</tr>
<tr>
<td>Depends:</td>
<td>doParallel, foreach, parallel, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-24 14:42:36 UTC; twillard</td>
</tr>
<tr>
<td>Author:</td>
<td>John Giles [aut, ctb],
  Henrik Salje [aut, ctb],
  Justin Lessler [aut, cre],
  Timothy Willard [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Justin Lessler &lt;jlessler@unc.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-28 20:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='DengueSimR01'>Simulated dataset of dengue transmission with basic reproductive number of 1</h2><span id='topic+DengueSimR01'></span>

<h3>Description</h3>

<p>Dataset simulated using an agent based model with a spatially heterogeneous population structure. Infectious agents
were introduced resulting in agent to agent transmission. The distance between successive cases in a transmission chain
were randomly drawn from a uniform distribution U(0,100). Each infectious agent resulted in a single transmission to
another agent after a delay of 15 days, reflecting the generation time of dengue. There are 11 transmission chains,
each with a different genotype. The genotypes are subdivided into four serotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DengueSimR01
</code></pre>


<h3>Format</h3>

<p>Matrix with five columns representing the X and Y coordinates of infected individuals, the time of infection,
the genotype of the infecting pathogen and the serotype of the infecting pathogen.
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>

<hr>
<h2 id='DengueSimR02'>Simulated dataset of dengue cases with basic reproductive number of 2</h2><span id='topic+DengueSimR02'></span>

<h3>Description</h3>

<p>Dataset simulated using an agent based model with a spatially heterogeneous population structure. Infectious agents
were introduced resulting in agent to agent transmission. The distance between successive cases in a transmission chain
were randomly drawn from a uniform distribution U(0,100). Each infectious agent resulted in transmissions to two other
agents after a delay of 15 days, reflecting the generation time of dengue. There are 11 transmission chains, each with
a different genotype. The genotypes are subdivided into four serotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DengueSimR02
</code></pre>


<h3>Format</h3>

<p>Matrix with five columns representing the X and Y coordinates of infected individuals, the time of infection,
the genotype of the infecting pathogen and the serotype of the infecting pathogen.
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>

<hr>
<h2 id='DengueSimRepresentative'>Simulated dataset of dengue cases with representative underlying population</h2><span id='topic+DengueSimRepresentative'></span>

<h3>Description</h3>

<p>Dataset simulated using an agent based model with a spatially heterogeneous population structure. Infectious agents were
introduced resulting in agent to agent transmission. The distance between successive cases in a transmission chain were
randomly drawn from a uniform distribution U(0,100). Each infectious agent resulted in transmissions to two other agents
after a delay of 15 days, reflecting the generation time of dengue. There are 11 transmission chains, each with a different
genotype. The genotypes are subdivided into four serotypes. 500 randomly selected individuals from the underlying population
also included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DengueSimRepresentative
</code></pre>


<h3>Format</h3>

<p>Matrix with five columns representing the X and Y coordinates of infected individuals, the time of infection, the genotype
of the infecting pathogen and the serotype of the infecting pathogen. Individuals representative from the underlying population
have '-999'for time, genotype and serotype.
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>

<hr>
<h2 id='est.transdist'>Estimate transmission distance</h2><span id='topic+est.transdist'></span>

<h3>Description</h3>

<p>this function estimates the mean transmission distance of an epidemic when given the locations and times of symptomatic cases and the mean and standard deviation of the generation time of the infecting pathogen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.transdist(
  epi.data,
  gen.t.mean,
  gen.t.sd,
  t1,
  max.sep,
  max.dist,
  n.transtree.reps = 100,
  theta.weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.transdist_+3A_epi.data">epi.data</code></td>
<td>
<p>a three-column matrix giving the coordinates (<code>x</code> and <code>y</code>) and time of infection (<code>t</code> for all cases in an epidemic (columns must be in <code>x</code>, <code>y</code>, <code>t</code> order)</p>
</td></tr>
<tr><td><code id="est.transdist_+3A_gen.t.mean">gen.t.mean</code></td>
<td>
<p>mean generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist_+3A_gen.t.sd">gen.t.sd</code></td>
<td>
<p>standard deviation of generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist_+3A_t1">t1</code></td>
<td>
<p>time step to begin estimation of transmission distance</p>
</td></tr>
<tr><td><code id="est.transdist_+3A_max.sep">max.sep</code></td>
<td>
<p>maximum number of time steps allowed between two cases (passed to the <code>get.transdist.theta</code> function)</p>
</td></tr>
<tr><td><code id="est.transdist_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum spatial distance between two cases considered in calculation</p>
</td></tr>
<tr><td><code id="est.transdist_+3A_n.transtree.reps">n.transtree.reps</code></td>
<td>
<p>number of time to simulate transmission trees when estimating the weights of theta (passed to the <code>est.transdist.theta.weights</code> function, default = 10). Warning: higher values of this parameter cause significant increases in computation time.</p>
</td></tr>
<tr><td><code id="est.transdist_+3A_theta.weights">theta.weights</code></td>
<td>
<p>use external matrix of theta weights. If NULL (default) the matrix of theta weights is automatically estimated by calling the <code>est.transdist.theta.weights</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the estimated mean distance of the transmission kernel (<code>mu.est</code>) and its standard deviation (<code>sigma.est</code>). Bounded estimates (<code>bound.mu.est</code> and <code>bound.sigma.est</code>) are also given for when the assumption of equal mean and standard deviation is violated.
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>References</h3>

<p>Salje H, Cummings DAT and Lessler J (2016). “Estimating infectious disease transmission distances using the overall distribution of cases.” Epidemics, 17, pp. 10–18. ISSN 1755-4365, doi: <a href="https://www.sciencedirect.com/science/article/pii/S1755436516300317">10.1016/j.epidem.2016.10.001</a>.
</p>


<h3>See Also</h3>

<p>Other est.wt: 
<code><a href="#topic+est.wt.matrix">est.wt.matrix</a>()</code>,
<code><a href="#topic+est.wt.matrix.weights">est.wt.matrix.weights</a>()</code>
</p>
<p>Other transdist: 
<code><a href="#topic+est.transdist.bootstrap.ci">est.transdist.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.temporal">est.transdist.temporal</a>()</code>,
<code><a href="#topic+est.transdist.temporal.bootstrap.ci">est.transdist.temporal.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.theta.weights">est.transdist.theta.weights</a>()</code>,
<code><a href="#topic+get.transdist.theta">get.transdist.theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(123)

# Exponentially distributed transmission kernel with mean and standard deviation = 100
dist.func &lt;- alist(n=1, a=1/100, rexp(n, a)) 

# Simulate epidemic
a &lt;- sim.epidemic(R=1.5,
                  gen.t.mean=7,
                  gen.t.sd=2,
                  min.cases=50,
                  tot.generations=12,
                  trans.kern.func=dist.func)

# Estimate mean and standara deviation of transmission kernel
b &lt;- est.transdist(epi.data=a,
                   gen.t.mean=7,
                   gen.t.sd=2,
                   t1=0,
                   max.sep=1e10,
                   max.dist=1e10,
                   n.transtree.reps=10)
b


</code></pre>

<hr>
<h2 id='est.transdist.bootstrap.ci'>Bootstrap mean transmission distance values</h2><span id='topic+est.transdist.bootstrap.ci'></span>

<h3>Description</h3>

<p>Runs <code>est.trandsdist</code> on multiple bootstraps of the data and calculates confidence intervals for the mean transmission distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.transdist.bootstrap.ci(
  epi.data,
  gen.t.mean,
  gen.t.sd,
  t1,
  max.sep,
  max.dist,
  n.transtree.reps = 100,
  mean.equals.sd = FALSE,
  theta.weights = NULL,
  boot.iter,
  ci.low = 0.025,
  ci.high = 0.975,
  parallel = FALSE,
  n.cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.transdist.bootstrap.ci_+3A_epi.data">epi.data</code></td>
<td>
<p>a three-column matrix giving the coordinates (<code>x</code> and <code>y</code>) and time of infection (<code>t</code> for all cases in an epidemic (columns must be in <code>x</code>, <code>y</code>, <code>t</code> order)</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_gen.t.mean">gen.t.mean</code></td>
<td>
<p>mean generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_gen.t.sd">gen.t.sd</code></td>
<td>
<p>standard deviation of generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_t1">t1</code></td>
<td>
<p>time step to begin estimation of transmission distance</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_max.sep">max.sep</code></td>
<td>
<p>maximum number of time steps allowed between two cases (passed to the <code>get.transdist.theta</code> function)</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum spatial distance between two cases considered in calculation</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_n.transtree.reps">n.transtree.reps</code></td>
<td>
<p>number of time to simulate transmission trees when estimating the weights of theta (passed to the <code>est.transdist.theta.weights</code> function, default = 10). Warning: higher values of this parameter cause significant increases in computation time.</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_mean.equals.sd">mean.equals.sd</code></td>
<td>
<p>logical term indicating if the mean and standard deviation of the transmission kernel are expected to be equal (default = FALSE)</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_theta.weights">theta.weights</code></td>
<td>
<p>use external matrix of theta weights. If NULL (default) the matrix of theta weights is automatically estimated by calling the <code>est.transdist.theta.weights</code> function</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrapped iterations to perform</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_ci.low">ci.low</code></td>
<td>
<p>low end of the confidence interval (default = 0.025)</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_ci.high">ci.high</code></td>
<td>
<p>high end of the confidence interval (default = 0.975)</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_parallel">parallel</code></td>
<td>
<p>run bootstraps in parallel (default = FALSE)</p>
</td></tr>
<tr><td><code id="est.transdist.bootstrap.ci_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use when <code>parallel</code> = TRUE (default = NULL, which uses half the available cores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object containing the point estimate for mean transmission distance and low and high bootstrapped confidence intervals
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>References</h3>

<p>Salje H, Cummings DAT and Lessler J (2016). “Estimating infectious disease transmission distances using the overall distribution of cases.” Epidemics, 17, pp. 10–18. ISSN 1755-4365, doi: <a href="https://www.sciencedirect.com/science/article/pii/S1755436516300317">10.1016/j.epidem.2016.10.001</a>.
</p>


<h3>See Also</h3>

<p>Other transdist: 
<code><a href="#topic+est.transdist">est.transdist</a>()</code>,
<code><a href="#topic+est.transdist.temporal">est.transdist.temporal</a>()</code>,
<code><a href="#topic+est.transdist.temporal.bootstrap.ci">est.transdist.temporal.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.theta.weights">est.transdist.theta.weights</a>()</code>,
<code><a href="#topic+get.transdist.theta">get.transdist.theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1)

# Exponentially distributed transmission kernel with mean and standard deviation = 100
dist.func &lt;- alist(n=1, a=1/100, rexp(n, a)) 

# Simulate epidemic
a &lt;- sim.epidemic(R=2.5,
                  gen.t.mean=7,
                  gen.t.sd=2,
                  min.cases=20,
                  tot.generations=5,
                  trans.kern.func=dist.func)

# Estimate mean transmission kernel and its bootstrapped confidence intervals
b &lt;- est.transdist.bootstrap.ci(epi.data=a,
                                gen.t.mean=7,
                                gen.t.sd=2,
                                t1=0,
                                max.sep=1e10,
                                max.dist=1e10,
                                n.transtree.reps=10,
                                mean.equals.sd=TRUE,
                                boot.iter=10,
                                ci.low=0.025,
                                ci.high=0.975,
                                n.cores=2)
b


</code></pre>

<hr>
<h2 id='est.transdist.temporal'>Change in mean transmission distance over time</h2><span id='topic+est.transdist.temporal'></span>

<h3>Description</h3>

<p>Estimates the change in mean transmission distance over the duration of the epidemic by running <code>est.trandsdist</code> on all cases
occuring up to each time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.transdist.temporal(
  epi.data,
  gen.t.mean,
  gen.t.sd,
  t1,
  max.sep,
  max.dist,
  n.transtree.reps = 10,
  mean.equals.sd = FALSE,
  theta.weights = NULL,
  parallel = FALSE,
  n.cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.transdist.temporal_+3A_epi.data">epi.data</code></td>
<td>
<p>a three-column matrix giving the coordinates (<code>x</code> and <code>y</code>) and time of infection (<code>t</code> for all cases in an epidemic (columns must be in <code>x</code>, <code>y</code>, <code>t</code> order)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_gen.t.mean">gen.t.mean</code></td>
<td>
<p>mean generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_gen.t.sd">gen.t.sd</code></td>
<td>
<p>standard deviation of generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_t1">t1</code></td>
<td>
<p>time step to begin estimation of transmission distance</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_max.sep">max.sep</code></td>
<td>
<p>maximum number of time steps allowed between two cases (passed to the <code>get.transdist.theta</code> function)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum spatial distance between two cases considered in calculation</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_n.transtree.reps">n.transtree.reps</code></td>
<td>
<p>number of time to simulate transmission trees when estimating the weights of theta (passed to the <code>est.transdist.theta.weights</code> function, default = 10). Higher values of this parameter cause significant increases in computation time.</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_mean.equals.sd">mean.equals.sd</code></td>
<td>
<p>logical term indicating if the mean and standard deviation of the transmission kernel are expected to be equal (default = FALSE)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_theta.weights">theta.weights</code></td>
<td>
<p>use external matrix of theta weights. If NULL (default) the matrix of theta weights is automatically estimated by calling the <code>est.transdist.theta.weights</code> function</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_parallel">parallel</code></td>
<td>
<p>run time steps in parallel (default = FALSE)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use when <code>parallel</code> = TRUE (default = NULL, which uses half the available cores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix containing the point estimate for mean transmission distance for each unique time step of the epidemic and the sample size $n$ used to make the estimate
NAs are returned for time steps which contain fewer than three cases
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>References</h3>

<p>Salje H, Cummings DAT and Lessler J (2016). “Estimating infectious disease transmission distances using the overall distribution of cases.” Epidemics, 17, pp. 10–18. ISSN 1755-4365, doi: <a href="https://www.sciencedirect.com/science/article/pii/S1755436516300317">10.1016/j.epidem.2016.10.001</a>.
</p>


<h3>See Also</h3>

<p>Other transdist: 
<code><a href="#topic+est.transdist">est.transdist</a>()</code>,
<code><a href="#topic+est.transdist.bootstrap.ci">est.transdist.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.temporal.bootstrap.ci">est.transdist.temporal.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.theta.weights">est.transdist.theta.weights</a>()</code>,
<code><a href="#topic+get.transdist.theta">get.transdist.theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     
set.seed(123)

# Exponentially distributed transmission kernel with mean and standard deviation = 100
dist.func &lt;- alist(n=1, a=1/100, rexp(n, a)) 

# Simulate epidemic
a &lt;- sim.epidemic(R=2,
                  gen.t.mean=7,
                  gen.t.sd=2,
                  tot.generations=7,
                  min.cases=30,
                  trans.kern.func=dist.func)

a &lt;- a[sample(1:nrow(a), 50),] # subsample a to 50 observations

# Estimate mean transmission kernel over time
b &lt;- est.transdist.temporal(epi.data=a,
                            gen.t.mean=7,
                            gen.t.sd=2,
                            t1=0,
                            max.sep=1e10,
                            max.dist=1e10,
                            n.transtree.reps=5,
                            mean.equals.sd=TRUE,
                            n.cores=2)
b

plot(b[,2], pch=19, col='grey', ylim=c(min(b[,2], na.rm=TRUE), max(b[,2], na.rm=TRUE)), 
     xlab='Time step', ylab='Estimated mean of transmission kernel')
abline(h=100, col='red', lty=2)
axis(3, b[,2])

low &lt;- loess(b[,2] ~ as.vector(1:length(b[,2])))
low &lt;- predict(low, newdata=data.frame(as.vector(1:length(b[,2]))))
lines(low, lwd=3, col='blue')


</code></pre>

<hr>
<h2 id='est.transdist.temporal.bootstrap.ci'>Bootstrapped confidence intervals for the change in mean transmission distance over time</h2><span id='topic+est.transdist.temporal.bootstrap.ci'></span>

<h3>Description</h3>

<p>Estimates bootstrapped confidence intervals for the mean transmission distance over the duration of the epidemic by running <code>est.trandsdist</code> on all cases
occuring up to each time point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.transdist.temporal.bootstrap.ci(
  epi.data,
  gen.t.mean,
  gen.t.sd,
  t1,
  max.sep,
  max.dist,
  n.transtree.reps = 100,
  mean.equals.sd = FALSE,
  theta.weights = NULL,
  boot.iter,
  ci.low = 0.025,
  ci.high = 0.975,
  parallel = FALSE,
  n.cores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_epi.data">epi.data</code></td>
<td>
<p>a three-column matrix giving the coordinates (<code>x</code> and <code>y</code>) and time of infection (<code>t</code> for all cases in an epidemic (columns must be in <code>x</code>, <code>y</code>, <code>t</code> order)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_gen.t.mean">gen.t.mean</code></td>
<td>
<p>mean generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_gen.t.sd">gen.t.sd</code></td>
<td>
<p>standard deviation of generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_t1">t1</code></td>
<td>
<p>time step to begin estimation of transmission distance</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_max.sep">max.sep</code></td>
<td>
<p>maximum number of time steps allowed between two cases (passed to the <code>get.transdist.theta</code> function)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_max.dist">max.dist</code></td>
<td>
<p>maximum spatial distance between two cases considered in calculation</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_n.transtree.reps">n.transtree.reps</code></td>
<td>
<p>number of time to simulate transmission trees when estimating the weights of theta (passed to the <code>est.transdist.theta.weights</code> function, default = 10). Warning: higher values of this parameter cause significant increases in computation time.</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_mean.equals.sd">mean.equals.sd</code></td>
<td>
<p>logical term indicating if the mean and standard deviation of the transmission kernel are expected to be equal (default = FALSE)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_theta.weights">theta.weights</code></td>
<td>
<p>use external matrix of theta weights. If NULL (default) the matrix of theta weights is automatically estimated by calling the <code>est.transdist.theta.weights</code> function</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrapped iterations to perform</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_ci.low">ci.low</code></td>
<td>
<p>low end of the confidence interval (default = 0.025)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_ci.high">ci.high</code></td>
<td>
<p>high end of the confidence interval (default = 0.975)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_parallel">parallel</code></td>
<td>
<p>run bootstraps in parallel (default = FALSE)</p>
</td></tr>
<tr><td><code id="est.transdist.temporal.bootstrap.ci_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use when <code>parallel</code> = TRUE (default = NULL, which uses half the available cores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a four-column numeric matrix containing the point estimate for mean transmission distance, low and high bootstrapped confidence intervals, and the sample size up to each time step
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>References</h3>

<p>Salje H, Cummings DAT and Lessler J (2016). “Estimating infectious disease transmission distances using the overall distribution of cases.” Epidemics, 17, pp. 10–18. ISSN 1755-4365, doi: <a href="https://www.sciencedirect.com/science/article/pii/S1755436516300317">10.1016/j.epidem.2016.10.001</a>.
</p>


<h3>See Also</h3>

<p>Other transdist: 
<code><a href="#topic+est.transdist">est.transdist</a>()</code>,
<code><a href="#topic+est.transdist.bootstrap.ci">est.transdist.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.temporal">est.transdist.temporal</a>()</code>,
<code><a href="#topic+est.transdist.theta.weights">est.transdist.theta.weights</a>()</code>,
<code><a href="#topic+get.transdist.theta">get.transdist.theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(123)

# Exponentially distributed transmission kernel with mean and standard deviation = 100
dist.func &lt;- alist(n=1, a=1/100, rexp(n, a)) 

# Simulate epidemic
a &lt;- sim.epidemic(R=2,
                  gen.t.mean=7,
                  gen.t.sd=2,
                  tot.generations=8,
                  min.cases=30,
                  trans.kern.func=dist.func)

a &lt;- a[sample(1:nrow(a), 70),] # subsample a to 70 observations

# Estimate change in mean transmission kernel over time with confidence intervals
b &lt;- est.transdist.temporal.bootstrap.ci(epi.data=a,
                                         gen.t.mean=7,
                                         gen.t.sd=2,
                                         t1=0,
                                         max.sep=1e10,
                                         max.dist=1e10,
                                         n.transtree.reps=10,
                                         mean.equals.sd=TRUE,
                                         boot.iter=10,
                                         ci.low=0.025,
                                         ci.high=0.975,
                                         n.cores=2)

plot(b[,2], pch=19, col='grey', ylim=c(min(b[,1:3], na.rm=TRUE), max(b[,2:4], na.rm=TRUE)), 
     xlab='Time step', ylab='Estimated mean of transmission kernel')
abline(h=100, col='red', lty=2)
axis(3, 1:nrow(b), b[,5])

low &lt;- loess(b[,2] ~ as.vector(1:nrow(b)), span=1)
low &lt;- predict(low, newdata=data.frame(as.vector(1:nrow(b))))
lines(low, lwd=3, col='blue')

for(i in 3:4) {
     low &lt;- loess(b[,i] ~ as.vector(1:nrow(b)), span=1)
     low &lt;- predict(low, newdata=data.frame(as.vector(1:nrow(b))))
     lines(low, lty=2, lwd=3, col='blue')
}


</code></pre>

<hr>
<h2 id='est.transdist.theta.weights'>Estimate transmission distance theta values by replication</h2><span id='topic+est.transdist.theta.weights'></span>

<h3>Description</h3>

<p>This function estimates the weight of each theta value by performing a user defined number of replications with the <code>get.transdist.theta</code> function. The weights
of each theta are calculated as the number of simulations in which a case at time <code>t1</code> and <code>t2</code> are separated by theta transmission events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.transdist.theta.weights(case.times, gen.t.mean, t.density, t1, n.rep = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.transdist.theta.weights_+3A_case.times">case.times</code></td>
<td>
<p>a vector giving the occurrence time for each case</p>
</td></tr>
<tr><td><code id="est.transdist.theta.weights_+3A_gen.t.mean">gen.t.mean</code></td>
<td>
<p>the mean generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist.theta.weights_+3A_t.density">t.density</code></td>
<td>
<p>a vector giving the generation time density of the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.transdist.theta.weights_+3A_t1">t1</code></td>
<td>
<p>time step to begin simulation</p>
</td></tr>
<tr><td><code id="est.transdist.theta.weights_+3A_n.rep">n.rep</code></td>
<td>
<p>number of replications in the simulation (default = 100)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a three-dimensional array containing the mean normalized theta weights estimated across all replications
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>References</h3>

<p>Salje H, Cummings DAT and Lessler J (2016). “Estimating infectious disease transmission distances using the overall distribution of cases.” Epidemics, 17, pp. 10–18. ISSN 1755-4365, doi: <a href="https://www.sciencedirect.com/science/article/pii/S1755436516300317">10.1016/j.epidem.2016.10.001</a>.
</p>


<h3>See Also</h3>

<p>Other transdist: 
<code><a href="#topic+est.transdist">est.transdist</a>()</code>,
<code><a href="#topic+est.transdist.bootstrap.ci">est.transdist.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.temporal">est.transdist.temporal</a>()</code>,
<code><a href="#topic+est.transdist.temporal.bootstrap.ci">est.transdist.temporal.bootstrap.ci</a>()</code>,
<code><a href="#topic+get.transdist.theta">get.transdist.theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1)

gen.t.mean &lt;- 7
gen.t.sd &lt;- 2
t1 &lt;- 0

# Normally distributed transmission kernel with mean and standard deviation = 100
dist.func &lt;- alist(n=1, a=1/100, rexp(n, a)) 

# Simulate epidemic
a &lt;- sim.epidemic(R=5,
                  gen.t.mean=gen.t.mean,
                  gen.t.sd=gen.t.sd,
                  min.cases=5,
                  tot.generations=3,
                  trans.kern.func=dist.func)

# Get case times
a &lt;- a[order(a[,3]),]
case.times &lt;- round(a[,3])
unique.times &lt;- unique(case.times)
ntimes &lt;- length(unique.times)


# Generation time distribution
max.t &lt;- round(max(unique.times) - t1) - 1
n.step &lt;- round(max.t/gen.t.mean)
gen &lt;- rep(0, max.t*2)
for (i in 1:n.step){gen &lt;- gen + dnorm(1:(max.t*2), gen.t.mean*i, gen.t.sd*i)}
gen[1] &lt;- 0 # No instantaneous infections
t.density &lt;- gen/sum(gen)

# Estimation of theta weights matrix
b &lt;- est.transdist.theta.weights(case.times=case.times,
                                 n.rep=3, 
                                 gen.t.mean=gen.t.mean, 
                                 t1=t1, 
                                 t.density=t.density)

</code></pre>

<hr>
<h2 id='est.wt.matrix'>Calculate the Infector-Infectee Wallinga-Teunis matrix</h2><span id='topic+est.wt.matrix'></span>

<h3>Description</h3>

<p>A function which takes the time of each case occurrence, the generation time distribution of the infecting pathogen,
and the matrix of basic Wallinga-Teunis weights and estimates the probability that an infectee occurring time step j (columns)
was infected by a case occurring at time i (rows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.wt.matrix(case.times, gen.t.dist, basic.wt.weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.wt.matrix_+3A_case.times">case.times</code></td>
<td>
<p>a vector giving the occurrence time for each case</p>
</td></tr>
<tr><td><code id="est.wt.matrix_+3A_gen.t.dist">gen.t.dist</code></td>
<td>
<p>a vector giving the generation time distribution for the infecting pathogen</p>
</td></tr>
<tr><td><code id="est.wt.matrix_+3A_basic.wt.weights">basic.wt.weights</code></td>
<td>
<p>a matrix giving the basic normalized Wallinga-Teunis weights for each time step (output from the <code>est.wt.matrix.weights</code> function).
If this argument is <code>NULL</code> (the default), the basic Wallinga-Teunis matrix will be calculated automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical matrix with the number of columns and rows equal to the number of cases in the epidemic
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>References</h3>

<p>Salje H, Cummings DAT and Lessler J (2016). “Estimating infectious disease transmission distances using the overall distribution of cases.” Epidemics, 17, pp. 10–18. ISSN 1755-4365, doi: <a href="https://www.sciencedirect.com/science/article/pii/S1755436516300317">10.1016/j.epidem.2016.10.001</a>.
</p>


<h3>See Also</h3>

<p>Other est.wt: 
<code><a href="#topic+est.transdist">est.transdist</a>()</code>,
<code><a href="#topic+est.wt.matrix.weights">est.wt.matrix.weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

case.times &lt;- c(1,2,2,3,3)
gen &lt;- c(0, 2/3, 1/3, 0, 0)
t.density &lt;- gen/sum(gen)

a &lt;- est.wt.matrix(case.times=case.times, gen.t.dist=t.density)


</code></pre>

<hr>
<h2 id='est.wt.matrix.weights'>Estimate matrix of basic Wallinga-Teunis weights</h2><span id='topic+est.wt.matrix.weights'></span>

<h3>Description</h3>

<p>A function called by <code>est.wt.matrix</code>, which calculates the basic weights in the Wallinga-Teunis matrix given
the time of each case occurrence and the generation time distribution of the pathogen. Code adapted from the <span class="pkg">R0</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est.wt.matrix.weights(case.times, gen.t.dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est.wt.matrix.weights_+3A_case.times">case.times</code></td>
<td>
<p>a vector giving the occurrence time for each case</p>
</td></tr>
<tr><td><code id="est.wt.matrix.weights_+3A_gen.t.dist">gen.t.dist</code></td>
<td>
<p>a vector giving the generation time distribution for the infecting pathogen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical matrix with the number of columns and rows equal to the number of time steps in the epidemic
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>References</h3>

<p>Boelle P and Obadia T (2015). R0: Estimation of R0 and Real-Time Reproduction Number from Epidemics. R package version 1.2-6, <a href="https://CRAN.R-project.org/package=R0">https://CRAN.R-project.org/package=R0</a>.
</p>
<p>Salje H, Cummings DAT and Lessler J (2016). “Estimating infectious disease transmission distances using the overall distribution of cases.” Epidemics, 17, pp. 10–18. ISSN 1755-4365, doi: <a href="https://www.sciencedirect.com/science/article/pii/S1755436516300317">10.1016/j.epidem.2016.10.001</a>.
</p>


<h3>See Also</h3>

<p>Other est.wt: 
<code><a href="#topic+est.transdist">est.transdist</a>()</code>,
<code><a href="#topic+est.wt.matrix">est.wt.matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

case.times &lt;- c(1,2,2,3,3)
gen &lt;- c(0, 2/3, 1/3, 0, 0)
t.density &lt;- gen/sum(gen)

a &lt;- est.wt.matrix.weights(case.times=case.times, gen.t.dist=t.density)


</code></pre>

<hr>
<h2 id='get.cross.K'>Cross type K function using homotypic and heterotypic case types</h2><span id='topic+get.cross.K'></span>

<h3>Description</h3>

<p>A wrapper function of the <a href="spatstat.explore.html#topic+Kcross">Kcross</a> function from the <span class="pkg">spatstat.explore</span> package (Baddeley et al. 2016) that takes epidemiological data used by <span class="pkg">IDSpatialStats</span> functions and calculates the cross type K-function based on user defined case type homology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.cross.K(epi.data, type, hom, het = NULL, r = NULL, correction = "none")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.cross.K_+3A_epi.data">epi.data</code></td>
<td>
<p>a three-column numerical matrix that contains coordinates (<code>x</code> and <code>y</code>) for each case and information on case type (e.g. genotype or serotype). First two columns must be <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="get.cross.K_+3A_type">type</code></td>
<td>
<p>an integer giving the column that contains information on case type. Must be an integer or a character</p>
</td></tr>
<tr><td><code id="get.cross.K_+3A_hom">hom</code></td>
<td>
<p>a scalar or vector giving the homotypic case type(s). Equivalent to the 'j' point type used in the cross K function. Must be an integer or character</p>
</td></tr>
<tr><td><code id="get.cross.K_+3A_het">het</code></td>
<td>
<p>a scalar or vector giving the heterotypic case type(s). Equivalent to the 'i' point type used in the cross K function. The default is <code>NULL</code>, which uses any case type not defined in the <code>hom</code> argument as heterotypic. Must be an integer or a character</p>
</td></tr>
<tr><td><code id="get.cross.K_+3A_r">r</code></td>
<td>
<p>a numeric vector giving the spatial distances</p>
</td></tr>
<tr><td><code id="get.cross.K_+3A_correction">correction</code></td>
<td>
<p>type of edge correction to be applied (default set to 'none'). See the <a href="spatstat.explore.html#topic+Kcross">Kcross</a> function in the <span class="pkg">spatstat.explore</span> package for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a minimum of three columns giving the radius (<code>r</code>), the theoretical value of the K function for a Poisson process (<code>theo</code>), and value of the K function evaluated at radius <code>r</code>. The column name gives the type of edge correction used
</p>


<h3>Author(s)</h3>

<p>John Giles
</p>


<h3>References</h3>

<p>Baddeley A, Rubak E, and Turner R. (2016). &quot;Spatial Point Patterns: Methodology and Applications with R&quot;. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DengueSimR01)

k &lt;- get.cross.K(epi.data=DengueSimR01, type=5, hom=2, het=NULL, r=NULL, correction='border')

plot(k[,2], type='l', col='red', lty=2, xlab='r', ylab='cross K function')
lines(k$border)
</code></pre>

<hr>
<h2 id='get.cross.PCF'>Cross type Pair Correlation Function using homotypic and heterotypic case types</h2><span id='topic+get.cross.PCF'></span>

<h3>Description</h3>

<p>A wrapper function of the <a href="spatstat.explore.html#topic+pcf">pcf</a> function from the <span class="pkg">spatstat.explore</span> package (Baddeley et al. 2016) that takes epidemiological data used by <span class="pkg">IDSpatialStats</span> functions and calculates the cross type Pair Correlation Function based on user defined case type homology
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.cross.PCF(epi.data, type, hom, het = NULL, r = NULL, correction = "none")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.cross.PCF_+3A_epi.data">epi.data</code></td>
<td>
<p>a three-column numerical matrix that contains coordinates (<code>x</code> and <code>y</code>) for each case and information on case type (e.g. genotype or serotype). First two columns must be <code>x</code> and <code>y</code></p>
</td></tr>
<tr><td><code id="get.cross.PCF_+3A_type">type</code></td>
<td>
<p>an integer giving the column that contains information on case type. Must be an integer or a character</p>
</td></tr>
<tr><td><code id="get.cross.PCF_+3A_hom">hom</code></td>
<td>
<p>a scalar or vector giving the homotypic case type(s). Equivalent to the 'j' point type used in the cross K function. Must be an integer or character</p>
</td></tr>
<tr><td><code id="get.cross.PCF_+3A_het">het</code></td>
<td>
<p>a scalar or vector giving the heterotypic case type(s). Equivalent to the 'i' point type used in the cross K function. The default is <code>NULL</code>, which uses any case type not defined in the <code>hom</code> argument as heterotypic. Must be an integer or a character</p>
</td></tr>
<tr><td><code id="get.cross.PCF_+3A_r">r</code></td>
<td>
<p>a numeric vector giving the spatial distances</p>
</td></tr>
<tr><td><code id="get.cross.PCF_+3A_correction">correction</code></td>
<td>
<p>type of edge correction to be applied (default set to 'none'). See the <a href="spatstat.explore.html#topic+pcf">pcf</a> function in the <span class="pkg">spatstat.explore</span> package for more details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with two columns giving the radius <code>r</code>, the theoretical value of the Pair Correlation Function for a Poisson process (<code>theo</code>), and value of the Pair Correlation Function <code>pcf</code>
</p>


<h3>Author(s)</h3>

<p>John Giles
</p>


<h3>References</h3>

<p>Baddeley A, Rubak E, and Turner R. (2016). &quot;Spatial Point Patterns: Methodology and Applications with R&quot;. CRC Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DengueSimR01)

g &lt;- get.cross.PCF(epi.data=DengueSimR01, type=5, hom=2, het=NULL, r=NULL, correction='none')

plot(g$pcf, type='l', xlab='r', ylab='cross PCF')
abline(h=1, col='red', lty=2)
</code></pre>

<hr>
<h2 id='get.pi'>Generalized version of <code>get.pi</code></h2><span id='topic+get.pi'></span>

<h3>Description</h3>

<p>Generalized version of the <code>get.pi</code> function that takes in an arbitrary function and
returns the probability that a point within a particular range of a point of interest shares the relationship
specified by the passed in function with that point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pi(posmat, fun, r = 1, r.low = rep(0, length(r)), data.frame = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.pi_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns x, y and any other named columns
columns needed by <code>fun</code></p>
</td></tr>
<tr><td><code id="get.pi_+3A_fun">fun</code></td>
<td>
<p>a function that takes in two rows of <code>posmat</code> and returns:
</p>

<ol>
<li><p> for pairs included in the numerator and denominator
</p>
</li>
<li><p> for pairs that should only be included in the denominator
</p>
</li>
<li><p> for pairs that should be ignored all together</p>
</li></ol>

<p>Note that names from <code>posmat</code> are not preserved in calls to <code>fun</code>, so the columns of the matrix should be
referenced numerically
so this is not available to the <code>fun</code></p>
</td></tr>
<tr><td><code id="get.pi_+3A_r">r</code></td>
<td>
<p>the series of spatial distances (or there maximums) we are
interested in</p>
</td></tr>
<tr><td><code id="get.pi_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range, 0 by default</p>
</td></tr>
<tr><td><code id="get.pi_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pi value for each distance range that we look at. Where:
</p>
<p style="text-align: center;"><code class="reqn"> \pi(d_1, d_2) = \frac{\sum \boldsymbol{1} (d_{ij} \in [d_1,d_2)) \boldsymbol{1} (f(i,j)=1) }{\sum \sum \boldsymbol{1} [d_{ij} \in (d_1,d_2)) \boldsymbol{1} (f(i,j) \in \{1,2\}) }</code>
</p>



<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.pi: 
<code><a href="#topic+get.pi.bootstrap">get.pi.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.ci">get.pi.ci</a>()</code>,
<code><a href="#topic+get.pi.permute">get.pi.permute</a>()</code>,
<code><a href="#topic+get.pi.typed">get.pi.typed</a>()</code>,
<code><a href="#topic+get.pi.typed.bootstrap">get.pi.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.typed.permute">get.pi.typed.permute</a>()</code>
</p>
<p>Other spatialtau: 
<code><a href="#topic+get.tau">get.tau</a>()</code>,
<code><a href="#topic+get.theta">get.theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)

sero.type.func&lt;-function(a,b,tlimit=20){
  if(a[5]==b[5]&amp;(abs(a[3]-b[3])&lt;=tlimit)){rc=1}
  else{rc=2}
  return(rc)
}

sero.pi&lt;-get.pi(DengueSimR02,sero.type.func,r=r.max,r.low=r.min)


</code></pre>

<hr>
<h2 id='get.pi.bootstrap'>Bootstrap <code>get.pi</code> values.</h2><span id='topic+get.pi.bootstrap'></span>

<h3>Description</h3>

<p>Runs <code>get.pi</code> on multiple bootstraps of the data. Is formulated
such that the relationships between
points and themselves will not be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pi.bootstrap(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter = 500,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.pi.bootstrap_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.pi.bootstrap_+3A_fun">fun</code></td>
<td>
<p>the function to decide relationships</p>
</td></tr>
<tr><td><code id="get.pi.bootstrap_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.pi.bootstrap_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range. 0 by default</p>
</td></tr>
<tr><td><code id="get.pi.bootstrap_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.pi.bootstrap_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pi values for all the distances we looked at
</p>


<h3>Note</h3>

<p>In each bootstrap iteration N observations are drawn from the existing data with replacement. To avoid errors in
inference resulting from the same observatin being compared with itself in the bootstrapped data set, original indices
are perserved, and pairs of points in the bootstrapped dataset with the same original index are ignored.
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.pi: 
<code><a href="#topic+get.pi">get.pi</a>()</code>,
<code><a href="#topic+get.pi.ci">get.pi.ci</a>()</code>,
<code><a href="#topic+get.pi.permute">get.pi.permute</a>()</code>,
<code><a href="#topic+get.pi.typed">get.pi.typed</a>()</code>,
<code><a href="#topic+get.pi.typed.bootstrap">get.pi.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.typed.permute">get.pi.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
    if(a[1]!=2) return(3)
    if (b[1]==2) return(1)
    return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2


pi&lt;-get.pi(x,fun,r=r.max,r.low=r.min)
pi.boot&lt;-get.pi.bootstrap(x,fun,r=r.max,r.low=r.min,boot.iter=100)

pi.ci&lt;-apply(pi.boot[,-(1:2)],1,quantile,probs=c(0.25,0.75))

plot(r.mid, pi$pi , type="l")
lines(r.mid, pi.ci[1,] , lty=2)
lines(r.mid, pi.ci[2,] , lty=2)


</code></pre>

<hr>
<h2 id='get.pi.ci'>Calculate bootstrapped confidence intervals for <code>get.pi</code> values.</h2><span id='topic+get.pi.ci'></span>

<h3>Description</h3>

<p>Wrapper to <code>get.pi.bootstrap</code> that takes care of calculating the
confidence intervals based on the bootstrapped values..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pi.ci(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter = 1000,
  ci.low = 0.025,
  ci.high = 0.975,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.pi.ci_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.pi.ci_+3A_fun">fun</code></td>
<td>
<p>the function to decide relationships</p>
</td></tr>
<tr><td><code id="get.pi.ci_+3A_r">r</code></td>
<td>
<p>the series of spatial distances wer are interested in</p>
</td></tr>
<tr><td><code id="get.pi.ci_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range. 0 by default</p>
</td></tr>
<tr><td><code id="get.pi.ci_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.pi.ci_+3A_ci.low">ci.low</code></td>
<td>
<p>the low end of the ci...0.025 by default</p>
</td></tr>
<tr><td><code id="get.pi.ci_+3A_ci.high">ci.high</code></td>
<td>
<p>the high end of the ci...0.975 by default</p>
</td></tr>
<tr><td><code id="get.pi.ci_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with a row for the high and low values and
a column per distance
</p>


<h3>Author(s)</h3>

<p>Justin Lessler
</p>


<h3>See Also</h3>

<p>Other get.pi: 
<code><a href="#topic+get.pi">get.pi</a>()</code>,
<code><a href="#topic+get.pi.bootstrap">get.pi.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.permute">get.pi.permute</a>()</code>,
<code><a href="#topic+get.pi.typed">get.pi.typed</a>()</code>,
<code><a href="#topic+get.pi.typed.bootstrap">get.pi.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.typed.permute">get.pi.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
    if(a[1]!=2) return(3)
    if (b[1]==2) return(1)
    return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2


pi&lt;-get.pi(x,fun,r=r.max,r.low=r.min)
pi.ci&lt;-get.pi.ci(x,fun,r=r.max,r.low=r.min,boot.iter=100)

plot(r.mid, pi$pi, type="l")
lines(r.mid, pi.ci[,2] , lty=2)
lines(r.mid, pi.ci[,3] , lty=2)


</code></pre>

<hr>
<h2 id='get.pi.permute'>get the null distribution of the <code>get.pi</code> function</h2><span id='topic+get.pi.permute'></span>

<h3>Description</h3>

<p>Does permutations to calculate the null distribution of get pi
if there were no spatial dependence. Randomly reassigns coordinates
to each observation permutations times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pi.permute(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  permutations,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.pi.permute_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.pi.permute_+3A_fun">fun</code></td>
<td>
<p>the function to evaluate</p>
</td></tr>
<tr><td><code id="get.pi.permute_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.pi.permute_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.pi.permute_+3A_permutations">permutations</code></td>
<td>
<p>the number of permute iterations</p>
</td></tr>
<tr><td><code id="get.pi.permute_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pi values for all the distances we looked at
</p>


<h3>See Also</h3>

<p>Other get.pi: 
<code><a href="#topic+get.pi">get.pi</a>()</code>,
<code><a href="#topic+get.pi.bootstrap">get.pi.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.ci">get.pi.ci</a>()</code>,
<code><a href="#topic+get.pi.typed">get.pi.typed</a>()</code>,
<code><a href="#topic+get.pi.typed.bootstrap">get.pi.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.typed.permute">get.pi.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
    if(a[1]!=2) return(3)
    if (b[1]==2) return(1)
    return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2

pi&lt;-get.pi(x,fun,r=r.max,r.low=r.min)
pi.null&lt;-get.pi.permute(x,fun,r=r.max,r.low=r.min,permutations=100)

null.ci&lt;-apply(pi.null[,-(1:2)],1,quantile,probs=c(0.25,0.75))

plot(r.mid, pi$pi, type="l")
lines(r.mid, null.ci[1,] , lty=2)
lines(r.mid, null.ci[2,] , lty=2)


</code></pre>

<hr>
<h2 id='get.pi.typed'>Optimized version of <code>get.pi</code> for typed data.</h2><span id='topic+get.pi.typed'></span>

<h3>Description</h3>

<p>Version of the <code>get.pi</code> function that is optimized for statically typed data. That is
data where we are interested in the probability of points within some distance of points of
typeA are of typeB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pi.typed(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.pi.typed_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.pi.typed_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.pi.typed_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.pi.typed_+3A_r">r</code></td>
<td>
<p>the series of spatial distances wer are interested in</p>
</td></tr>
<tr><td><code id="get.pi.typed_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.pi.typed_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pi values for all the distances we looked at
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.pi: 
<code><a href="#topic+get.pi">get.pi</a>()</code>,
<code><a href="#topic+get.pi.bootstrap">get.pi.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.ci">get.pi.ci</a>()</code>,
<code><a href="#topic+get.pi.permute">get.pi.permute</a>()</code>,
<code><a href="#topic+get.pi.typed.bootstrap">get.pi.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.typed.permute">get.pi.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)

#Lets see if there's a difference in spatial dependence by time case occurs
type&lt;-2-(DengueSimR02[,"time"]&lt;120)
tmp&lt;-cbind(DengueSimR02,type=type)

typed.pi&lt;-get.pi.typed(tmp,typeA=1,typeB=2,r=r.max,r.low=r.min)


</code></pre>

<hr>
<h2 id='get.pi.typed.bootstrap'>runs bootstrapping on <code>get.pi.typed</code></h2><span id='topic+get.pi.typed.bootstrap'></span>

<h3>Description</h3>

<p>Bootstraps typed pi values. Makes sure distances between a sample and
another draw of itself are left out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pi.typed.bootstrap(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.pi.typed.bootstrap_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.pi.typed.bootstrap_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.pi.typed.bootstrap_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.pi.typed.bootstrap_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.pi.typed.bootstrap_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.pi.typed.bootstrap_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.pi.typed.bootstrap_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pi values for all the distances we looked at
</p>


<h3>See Also</h3>

<p>Other get.pi: 
<code><a href="#topic+get.pi">get.pi</a>()</code>,
<code><a href="#topic+get.pi.bootstrap">get.pi.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.ci">get.pi.ci</a>()</code>,
<code><a href="#topic+get.pi.permute">get.pi.permute</a>()</code>,
<code><a href="#topic+get.pi.typed">get.pi.typed</a>()</code>,
<code><a href="#topic+get.pi.typed.permute">get.pi.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)

#Lets see if there's a difference in spatial dependence by time case occurs
type&lt;-2-(DengueSimR02[,"time"]&lt;120)
tmp&lt;-cbind(DengueSimR02,type=type)

typed.pi.bs&lt;-get.pi.typed.bootstrap(tmp,typeA=1,typeB=2,r=r.max,r.low=r.min,boot.iter=100)


</code></pre>

<hr>
<h2 id='get.pi.typed.permute'>get the null distribution of the get.pi.typed function</h2><span id='topic+get.pi.typed.permute'></span>

<h3>Description</h3>

<p>Does permutations to calculate the null distribution of get pi
if there were no spatial dependence. Randomly reassigns coordinates
to each observation permutations times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.pi.typed.permute(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  permutations,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.pi.typed.permute_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.pi.typed.permute_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.pi.typed.permute_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.pi.typed.permute_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.pi.typed.permute_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.pi.typed.permute_+3A_permutations">permutations</code></td>
<td>
<p>the number of permute iterations</p>
</td></tr>
<tr><td><code id="get.pi.typed.permute_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pi values for all the distances we looked at
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.pi: 
<code><a href="#topic+get.pi">get.pi</a>()</code>,
<code><a href="#topic+get.pi.bootstrap">get.pi.bootstrap</a>()</code>,
<code><a href="#topic+get.pi.ci">get.pi.ci</a>()</code>,
<code><a href="#topic+get.pi.permute">get.pi.permute</a>()</code>,
<code><a href="#topic+get.pi.typed">get.pi.typed</a>()</code>,
<code><a href="#topic+get.pi.typed.bootstrap">get.pi.typed.bootstrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)

#Lets see if there's a difference in spatial dependence by time case occurs
type&lt;-2-(DengueSimR02[,"time"]&lt;75)
tmp&lt;-cbind(DengueSimR02,type=type)

typed.pi&lt;-get.pi.typed(tmp,typeA=1,typeB=2,r=r.max,r.low=r.min)
typed.pi.type.null&lt;-get.pi.typed.permute(tmp,typeA=1,typeB=2,r=r.max,r.low=r.min,permutations=100)


</code></pre>

<hr>
<h2 id='get.tau'>generalized version of <code>get.tau</code></h2><span id='topic+get.tau'></span>

<h3>Description</h3>

<p>returns the relative probability (or odds) that points at some distance
from an index point share some relationship with that point versus
the probability (or odds) any point shares that relationship with that point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tau(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  comparison.type = "representative",
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tau_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns x, y and any other named columns
columns needed by fun</p>
</td></tr>
<tr><td><code id="get.tau_+3A_fun">fun</code></td>
<td>
<p>a function that takes in two rows of posmat and returns:
</p>

<ol>
<li><p> for pairs included in the numerator (and the denominator for independent data)
</p>
</li>
<li><p> for pairs that should only be included in the denominator
</p>
</li>
<li><p> for pairs that should be ignored all together</p>
</li></ol>

<p>Note that names from <code>posmat</code> are not preserved in calls to
<code>fun</code>, so the columns of the matrix should be referenced numerically
so this is not available to fun</p>
</td></tr>
<tr><td><code id="get.tau_+3A_r">r</code></td>
<td>
<p>the series of spatial distances (or there maximums) we are
interested in</p>
</td></tr>
<tr><td><code id="get.tau_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range, 0 by default</p>
</td></tr>
<tr><td><code id="get.tau_+3A_comparison.type">comparison.type</code></td>
<td>
<p>what type of points are included in the comparison set.
</p>

<ul>
<li><p> &quot;representative&quot; if comparison set is representative of the underlying population
</p>
</li>
<li><p> &quot;independent&quot; if comparison set is cases/events coming from an indepedent process
</p>
</li></ul>
</td></tr>
<tr><td><code id="get.tau_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tau value for each distance we look at. If <code>comparison.type</code> is &quot;representative&quot;, this is:
</p>
<p><code>tau = get.pi(posmat, fun, r, r.low)/get.pi(posmat,fun,infinity,0)</code>
</p>
<p>If <code>comparison.type</code> is &quot;independent&quot;, this is:
</p>
<p><code>tau = get.theta(posmat, fun, r, r.low)/get.theta(posmat,fun,infinity,0)</code>
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.tau: 
<code><a href="#topic+get.tau.bootstrap">get.tau.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.ci">get.tau.ci</a>()</code>,
<code><a href="#topic+get.tau.permute">get.tau.permute</a>()</code>,
<code><a href="#topic+get.tau.typed">get.tau.typed</a>()</code>,
<code><a href="#topic+get.tau.typed.bootstrap">get.tau.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.typed.permute">get.tau.typed.permute</a>()</code>
</p>
<p>Other spatialtau: 
<code><a href="#topic+get.pi">get.pi</a>()</code>,
<code><a href="#topic+get.theta">get.theta</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR01)
data(DengueSimR02)
data(DengueSimRepresentative)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)
r.mid&lt;-(r.max+r.min)/2

sero.type.func&lt;-function(a,b,tlimit=20){
     if(a[5]==b[5]&amp;(abs(a[3]-b[3])&lt;=tlimit)){rc=1}
     else{rc=2}
     return(rc)
}

geno.type.func&lt;-function(a,b,tlimit=20){
     if(a[4]==b[4]&amp;(abs(a[3]-b[3])&lt;=tlimit)){rc=1}
     else{rc=2}
     return(rc)
}

sero.type.rep.func&lt;-function(a,b,tlimit=20){
     if(a[5]==1&amp;b[5]==1&amp;(abs(a[3]-b[3])&lt;=tlimit)){rc=1}
     else{if(a[5]==1&amp;b[5]==-999){rc=2}else{rc=3}}
     return(rc)
}

sero.tau.R01 &lt;- get.tau(DengueSimR01, sero.type.func, r=r.max, r.low=r.min, 
                      comparison.type="independent")
geno.tau.R01 &lt;- get.tau(DengueSimR01, geno.type.func, r=r.max, r.low=r.min, 
                      comparison.type="independent")

sero.tau.R02 &lt;- get.tau(DengueSimR02, sero.type.func, r=r.max, r.low=r.min, 
                      comparison.type="independent")
geno.tau.R02 &lt;- get.tau(DengueSimR02, geno.type.func, r=r.max, r.low=r.min, 
                      comparison.type="independent")

sero.tau.representative &lt;- get.tau(DengueSimRepresentative, sero.type.rep.func, 
                                   r=r.max, r.low=r.min, comparison.type="representative")

## R0 of 1
plot(r.mid,sero.tau.R01$tau,ylim=c(0.3,max(geno.tau.R01$tau)),log="y",
     cex.axis=1.25,col=rgb(t(col2rgb("blue")/255),alpha=0.6),
     xlab="Distance (m)",ylab="Tau",cex.main=0.9,lwd=2,type="l",las=1,cex.axis=0.75)
abline(h=1,lty=2)

abline(v=100,lty=1,lwd=2)
lines(r.mid,geno.tau.R01$tau,pch=20,col=rgb(t(col2rgb("dark green")/255),alpha=0.6),lwd=1)
lines(r.mid,sero.tau.representative$tau,pch=20,col=rgb(t(col2rgb("dark blue")/255),alpha=0.6),lty=2)
legend("topright",
       legend=c("Genotype",
                "Serotype",
                "Serotype (representative population)",
                "Maximum transmission distance"),
       lwd=1,col=c("dark green","blue","blue","black"),
       lty=c(1,1,2,1),bty="n")

## R0 of 2
plot(r.mid,sero.tau.R02$tau,ylim=c(0.3,max(geno.tau.R02)),log="y",
     cex.axis=1.25,col=rgb(t(col2rgb("blue")/255),alpha=0.6),
     xlab="Distance (m)",ylab="Tau",cex.main=0.9,lwd=2,type="l",las=1,cex.axis=0.75)
abline(h=1,lty=2)
abline(v=100,lty=1,lwd=2)
lines(r.mid,geno.tau.R02$tau,pch=20,col=rgb(t(col2rgb("dark green")/255),alpha=0.6),lwd=1)
legend("topright",
       legend=c("Genotype",
                "Serotype",
                "Maximum transmission distance"),
       lwd=1,col=c("dark green","blue","black"),lty=1,bty="n")


</code></pre>

<hr>
<h2 id='get.tau.bootstrap'>Bootstrap <code>get.tau</code> values.</h2><span id='topic+get.tau.bootstrap'></span>

<h3>Description</h3>

<p>Runs <code>get.tau</code> on multiple bootstraps of the data. Is formulated
such that the relationship between points and themselves will not be
calculated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tau.bootstrap(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter,
  comparison.type = "representative",
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tau.bootstrap_+3A_posmat">posmat</code></td>
<td>
<p>a matrix appropriate for input to <code>get.tau</code></p>
</td></tr>
<tr><td><code id="get.tau.bootstrap_+3A_fun">fun</code></td>
<td>
<p>a function appropriate as input to <code>get.pi</code></p>
</td></tr>
<tr><td><code id="get.tau.bootstrap_+3A_r">r</code></td>
<td>
<p>the series of spatial distances wer are interested in</p>
</td></tr>
<tr><td><code id="get.tau.bootstrap_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.tau.bootstrap_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.tau.bootstrap_+3A_comparison.type">comparison.type</code></td>
<td>
<p>the comparison type to pass as input to <code>get.pi</code></p>
</td></tr>
<tr><td><code id="get.tau.bootstrap_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing all bootstrapped values of tau for each distance interval
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.tau: 
<code><a href="#topic+get.tau">get.tau</a>()</code>,
<code><a href="#topic+get.tau.ci">get.tau.ci</a>()</code>,
<code><a href="#topic+get.tau.permute">get.tau.permute</a>()</code>,
<code><a href="#topic+get.tau.typed">get.tau.typed</a>()</code>,
<code><a href="#topic+get.tau.typed.bootstrap">get.tau.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.typed.permute">get.tau.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
    if(a[1]!=2) return(3)
    if (b[1]==2) return(1)
    return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2

tau&lt;-get.tau(x,fun,r=r.max,r.low=r.min)
tau.boot&lt;-get.tau.bootstrap(x,fun,r=r.max,r.low=r.min,boot.iter=50)

tau.ci&lt;-apply(tau.boot[,-(1:2)],1,quantile,probs=c(0.25,0.75))

plot(r.mid, tau$tau ,ylim=c(min(tau.ci),max(tau.ci)), type="l", log="y")
lines(c(0,100),c(1,1), lty=3, col="grey")
lines(r.mid, tau.ci[1,] , lty=2)
lines(r.mid, tau.ci[2,] , lty=2)


</code></pre>

<hr>
<h2 id='get.tau.ci'>Bootstrap confidence interval for the <code>get.tau</code> values</h2><span id='topic+get.tau.ci'></span>

<h3>Description</h3>

<p>Wrapper to <code>get.tau.bootstrap</code> that takes care of calulating
the confidence intervals based on the bootstrapped values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tau.ci(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter = 1000,
  comparison.type = "representative",
  ci.low = 0.025,
  ci.high = 0.975,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tau.ci_+3A_posmat">posmat</code></td>
<td>
<p>a matrix appropriate for input to <code>get.tau</code></p>
</td></tr>
<tr><td><code id="get.tau.ci_+3A_fun">fun</code></td>
<td>
<p>a function appropriate as input to <code>get.pi</code></p>
</td></tr>
<tr><td><code id="get.tau.ci_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.tau.ci_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.tau.ci_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.tau.ci_+3A_comparison.type">comparison.type</code></td>
<td>
<p>the comparison type to pass to get.tau</p>
</td></tr>
<tr><td><code id="get.tau.ci_+3A_ci.low">ci.low</code></td>
<td>
<p>the low end of the ci...0.025 by default</p>
</td></tr>
<tr><td><code id="get.tau.ci_+3A_ci.high">ci.high</code></td>
<td>
<p>the high end of the ci...0.975 by default</p>
</td></tr>
<tr><td><code id="get.tau.ci_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the point estimate of tau and its low and high confidence interval at each distance
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.tau: 
<code><a href="#topic+get.tau">get.tau</a>()</code>,
<code><a href="#topic+get.tau.bootstrap">get.tau.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.permute">get.tau.permute</a>()</code>,
<code><a href="#topic+get.tau.typed">get.tau.typed</a>()</code>,
<code><a href="#topic+get.tau.typed.bootstrap">get.tau.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.typed.permute">get.tau.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
     if(a[1]!=2) return(3)
     if (b[1]==2) return(1)
     return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2

tau &lt;- get.tau.ci(x,fun,r=r.max,r.low=r.min,boot.iter=50)

plot(r.mid, tau$pt.est, ylim=c(1/max(tau[,3:5]), max(tau[,3:5])), type="l", log="y",
     xlab="Distance", ylab="Tau")
lines(r.mid, tau$ci.low , lty=2)
lines(r.mid, tau$ci.high, lty=2)
lines(c(0,100),c(1,1), lty=3, col="grey")


</code></pre>

<hr>
<h2 id='get.tau.permute'>get the null distribution of the <code>get.tau</code> function</h2><span id='topic+get.tau.permute'></span>

<h3>Description</h3>

<p>Does permutations to calculate the null distribution of get pi
if there were no spatial dependence. Randomly reassigns coordinates
to each observation permutations times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tau.permute(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  permutations,
  comparison.type = "representative",
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tau.permute_+3A_posmat">posmat</code></td>
<td>
<p>a matrix appropriate for input to <code>get.tau</code></p>
</td></tr>
<tr><td><code id="get.tau.permute_+3A_fun">fun</code></td>
<td>
<p>a function appropriate for input to <code>get.tau</code></p>
</td></tr>
<tr><td><code id="get.tau.permute_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.tau.permute_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.tau.permute_+3A_permutations">permutations</code></td>
<td>
<p>the number of permute iterations</p>
</td></tr>
<tr><td><code id="get.tau.permute_+3A_comparison.type">comparison.type</code></td>
<td>
<p>the comparison type to pass as input to <code>get.pi</code></p>
</td></tr>
<tr><td><code id="get.tau.permute_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tau values for all the distances we looked at
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.tau: 
<code><a href="#topic+get.tau">get.tau</a>()</code>,
<code><a href="#topic+get.tau.bootstrap">get.tau.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.ci">get.tau.ci</a>()</code>,
<code><a href="#topic+get.tau.typed">get.tau.typed</a>()</code>,
<code><a href="#topic+get.tau.typed.bootstrap">get.tau.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.typed.permute">get.tau.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
    if(a[1]!=2) return(3)
    if (b[1]==2) return(1)
    return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2

tau&lt;-get.tau(x,fun,r=r.max,r.low=r.min,comparison.type = "independent")
tau.null&lt;-get.tau.permute(x,fun,r=r.max,r.low=r.min,permutations=50,comparison.type = "independent")

null.ci&lt;-apply(tau.null[,-(1:2)],1,quantile,probs=c(0.25,0.75))

plot(r.mid, tau$tau, ylim=c(1/max(tau$tau),max(tau$tau)), type="l", log="y")
lines(c(0,100),c(1,1), lty=3, col="grey")
lines(r.mid, null.ci[1,] , lty=2)
lines(r.mid, null.ci[2,] , lty=2)


</code></pre>

<hr>
<h2 id='get.tau.typed'>Optimized version of <code>get.tau</code> for typed data</h2><span id='topic+get.tau.typed'></span>

<h3>Description</h3>

<p>Version of th e <code>get.tau</code> function that is optimized for
statically typed data. That is data where we want the relationship between
points of type A and points of type B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tau.typed(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  comparison.type = "representative",
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tau.typed_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.tau.typed_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.tau.typed_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.tau.typed_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.tau.typed_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.tau.typed_+3A_comparison.type">comparison.type</code></td>
<td>
<p>what type of points are included in the comparison set.
</p>

<ul>
<li><p> &quot;representative&quot; if comparison set is representative of the underlying population
</p>
</li>
<li><p> &quot;independent&quot; if comparison set is cases/events coming from an indepedent process
</p>
</li></ul>
</td></tr>
<tr><td><code id="get.tau.typed_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of tau values for all the distances
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.tau: 
<code><a href="#topic+get.tau">get.tau</a>()</code>,
<code><a href="#topic+get.tau.bootstrap">get.tau.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.ci">get.tau.ci</a>()</code>,
<code><a href="#topic+get.tau.permute">get.tau.permute</a>()</code>,
<code><a href="#topic+get.tau.typed.bootstrap">get.tau.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.typed.permute">get.tau.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)
r.mid&lt;-(r.max+r.min)/2

#Lets see if there's a difference in spatial dependence by time case occurs
type&lt;-2-(DengueSimR02[,"time"]&lt;120)
tmp&lt;-cbind(DengueSimR02,type=type)

typed.tau&lt;-get.tau.typed(tmp,typeA=1,typeB=2,r=r.max,r.low=r.min,comparison.type = "independent")

plot(r.mid,typed.tau$tau,log="y",cex.axis=1.25,
     xlab="Distance (m)",ylab="Tau",cex.main=0.9,lwd=2,type="l")
abline(h=1,lty=2)


</code></pre>

<hr>
<h2 id='get.tau.typed.bootstrap'>runs bootstrapping for <code>get.tau.typed</code></h2><span id='topic+get.tau.typed.bootstrap'></span>

<h3>Description</h3>

<p>runs bootstrapping for <code>get.tau.typed</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tau.typed.bootstrap(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter,
  comparison.type = "representative",
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tau.typed.bootstrap_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.tau.typed.bootstrap_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.tau.typed.bootstrap_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.tau.typed.bootstrap_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.tau.typed.bootstrap_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.tau.typed.bootstrap_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.tau.typed.bootstrap_+3A_comparison.type">comparison.type</code></td>
<td>
<p>what type of points are included in the comparison set.
</p>

<ul>
<li><p> &quot;representative&quot; if comparison set is representative of the underlying population
</p>
</li>
<li><p> &quot;independent&quot; if comparison set is cases/events coming from an independent process
</p>
</li></ul>
</td></tr>
<tr><td><code id="get.tau.typed.bootstrap_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tau values for all the distances we looked at
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.tau: 
<code><a href="#topic+get.tau">get.tau</a>()</code>,
<code><a href="#topic+get.tau.bootstrap">get.tau.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.ci">get.tau.ci</a>()</code>,
<code><a href="#topic+get.tau.permute">get.tau.permute</a>()</code>,
<code><a href="#topic+get.tau.typed">get.tau.typed</a>()</code>,
<code><a href="#topic+get.tau.typed.permute">get.tau.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimulationR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)
r.mid&lt;-(r.max+r.min)/2

# Lets see if there's a difference in spatial dependence between those that occurred 
# late versus early in the outbreak

type &lt;- 2 - (DengueSimR02[,"time"] &lt; 120)
tmp &lt;- cbind(DengueSimR02, type=type)

typed.tau &lt;- get.tau.typed(tmp, typeA=1, typeB=2, r=r.max, r.low=r.min, 
                           comparison.type = "independent")

typed.tau.type.bs &lt;- get.tau.typed.bootstrap(tmp, typeA=1, typeB=2, r=r.max, r.low=r.min, 
                                             boot.iter=100, comparison.type = "independent")

ci &lt;- apply(typed.tau.type.bs[,-(1:2)], 1, quantile, probs=c(0.025,0.975))

plot(r.mid, typed.tau$tau, log="y",
     ylim=c(0.1,4), cex.axis=1.25,
     xlab="Distance (m)", ylab="Tau",
     cex.main=0.9, lwd=2, type="n")
abline(h=1,lty=1)
lines(r.mid,typed.tau$tau,pch=20,col=1,lwd=3)
lines(r.mid, ci[1,] , lty=2)
lines(r.mid, ci[2,] , lty=2)


</code></pre>

<hr>
<h2 id='get.tau.typed.permute'>get the null distribution for the <code>get.tau.typed</code> function</h2><span id='topic+get.tau.typed.permute'></span>

<h3>Description</h3>

<p>get the null distribution for the <code>get.tau.typed</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.tau.typed.permute(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  permutations,
  comparison.type = "representative",
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.tau.typed.permute_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.tau.typed.permute_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.tau.typed.permute_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.tau.typed.permute_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.tau.typed.permute_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.tau.typed.permute_+3A_permutations">permutations</code></td>
<td>
<p>the number of permute iterations</p>
</td></tr>
<tr><td><code id="get.tau.typed.permute_+3A_comparison.type">comparison.type</code></td>
<td>
<p>what type of points are included in the comparison set.
</p>

<ul>
<li><p> &quot;representative&quot; if comparison set is representative of the underlying population
</p>
</li>
<li><p> &quot;independent&quot; if comparison set is cases/events coming from an indepedent process
</p>
</li></ul>
</td></tr>
<tr><td><code id="get.tau.typed.permute_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with permutation tau values for each distance specified
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.tau: 
<code><a href="#topic+get.tau">get.tau</a>()</code>,
<code><a href="#topic+get.tau.bootstrap">get.tau.bootstrap</a>()</code>,
<code><a href="#topic+get.tau.ci">get.tau.ci</a>()</code>,
<code><a href="#topic+get.tau.permute">get.tau.permute</a>()</code>,
<code><a href="#topic+get.tau.typed">get.tau.typed</a>()</code>,
<code><a href="#topic+get.tau.typed.bootstrap">get.tau.typed.bootstrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimulationR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)
r.mid&lt;-(r.max+r.min)/2

#Lets see if there's a difference in spatial dependence by time case occurs
type &lt;- 2 - (DengueSimR02[,"time"] &lt; 120)
tmp &lt;- cbind(DengueSimR02, type=type)

typed.tau &lt;- get.tau.typed(tmp, typeA=1, typeB=2, r=r.max, r.low=r.min, 
                           comparison.type = "independent")

typed.tau.type.null&lt;-get.tau.typed.permute(tmp, typeA=1, typeB=2, r=r.max, r.low=r.min, 
                                           permutations=100, comparison.type = "independent")

null.ci &lt;- apply(typed.tau.type.null[,-(1:2)], 1, quantile, probs=c(0.025,0.975))

plot(r.mid, typed.tau$tau, ylim=c(0.3,4), log="y", cex.axis=1.25, 
     xlab="Distance (m)", ylab="Tau", cex.main=0.9, lwd=2, type="n")
abline(h=1,lty=1)
lines(r.mid,typed.tau$tau,pch=20,col=1,lwd=3)
lines(r.mid, null.ci[1,] , lty=2)
lines(r.mid, null.ci[2,] , lty=2)


</code></pre>

<hr>
<h2 id='get.theta'>Generalized version of <code>get.theta</code></h2><span id='topic+get.theta'></span>

<h3>Description</h3>

<p>Generalized version of the <code>get.theta</code> function that takes in an arbitrary function and
returns the odds that a point within a particular range of a point of interest shares the relationship
specified by the passed in function with that point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.theta(posmat, fun, r = 1, r.low = rep(0, length(r)), data.frame = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.theta_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns x, y and any other named columns
columns needed by fun</p>
</td></tr>
<tr><td><code id="get.theta_+3A_fun">fun</code></td>
<td>
<p>a function that takes in two rows of posmat and returns:
</p>

<ol>
<li><p>  for pairs that are (potentially) related
</p>
</li>
<li><p> for pairs that are unrelated
</p>
</li>
<li><p> for pairs that should be ignored all together</p>
</li></ol>

<p>Note that names from <code>posmat</code> are not preserved in calls to <code>fun</code>, so the columns of the matrix should be
referenced numerically
so this is not available to the fun</p>
</td></tr>
<tr><td><code id="get.theta_+3A_r">r</code></td>
<td>
<p>the series of spatial distances (or there maximums) we are
interested in</p>
</td></tr>
<tr><td><code id="get.theta_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range, 0 by default</p>
</td></tr>
<tr><td><code id="get.theta_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta value for each distance range that we look at. Where:
</p>
<p style="text-align: center;"><code class="reqn"> \theta(d_1,d_2) = \frac{\sum \boldsymbol{1} d_{ij} \in [d_1,d_2)) \boldsymbol{1} (f(i,j)=1) }{\sum \sum \boldsymbol{1} d_{ij} \in [d_1,d_2)) \boldsymbol{1} (f(i,j)=2) }</code>
</p>



<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.theta: 
<code><a href="#topic+get.theta.bootstrap">get.theta.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.ci">get.theta.ci</a>()</code>,
<code><a href="#topic+get.theta.permute">get.theta.permute</a>()</code>,
<code><a href="#topic+get.theta.typed">get.theta.typed</a>()</code>,
<code><a href="#topic+get.theta.typed.bootstrap">get.theta.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.typed.permute">get.theta.typed.permute</a>()</code>
</p>
<p>Other spatialtau: 
<code><a href="#topic+get.pi">get.pi</a>()</code>,
<code><a href="#topic+get.tau">get.tau</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)

sero.type.func&lt;-function(a,b,tlimit=20){
  if(a[5]==b[5]&amp;(abs(a[3]-b[3])&lt;=tlimit)){rc=1}
  else{rc=2}
  return(rc)
}

sero.theta&lt;-get.theta(DengueSimR02,sero.type.func,r=r.max,r.low=r.min)


</code></pre>

<hr>
<h2 id='get.theta.bootstrap'>Bootstrap <code>get.theta</code> values.</h2><span id='topic+get.theta.bootstrap'></span>

<h3>Description</h3>

<p>Runs <code>get.theta</code> on multiple bootstraps of the data. Is formulated
such that the relationships between
points and themselves will not be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.theta.bootstrap(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter = 500,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.theta.bootstrap_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.theta.bootstrap_+3A_fun">fun</code></td>
<td>
<p>the function to decide relationships</p>
</td></tr>
<tr><td><code id="get.theta.bootstrap_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.theta.bootstrap_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range. 0 by default</p>
</td></tr>
<tr><td><code id="get.theta.bootstrap_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.theta.bootstrap_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta values for all the distances we looked at
</p>


<h3>Note</h3>

<p>In each bootstrap iteration N observations are drawn from the existing data with replacement. To avoid errors in
inference resulting from the same observatin being compared with itself in the bootstrapped data set, original indices
are perserved, and pairs of points in the bootstrapped dataset with the same original index are ignored.
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.theta: 
<code><a href="#topic+get.theta">get.theta</a>()</code>,
<code><a href="#topic+get.theta.ci">get.theta.ci</a>()</code>,
<code><a href="#topic+get.theta.permute">get.theta.permute</a>()</code>,
<code><a href="#topic+get.theta.typed">get.theta.typed</a>()</code>,
<code><a href="#topic+get.theta.typed.bootstrap">get.theta.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.typed.permute">get.theta.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
    if(a[1]!=2) return(3)
    if (b[1]==2) return(1)
    return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2


theta&lt;-get.theta(x,fun,r=r.max,r.low=r.min)
theta.boot&lt;-get.theta.bootstrap(x,fun,r=r.max,r.low=r.min,boot.iter=100)

theta.ci&lt;-apply(theta.boot[,-(1:2)],1,quantile,probs=c(0.25,0.75))

plot(r.mid, theta$theta , type="l")
lines(r.mid, theta.ci[1,] , lty=2)
lines(r.mid, theta.ci[2,] , lty=2)


</code></pre>

<hr>
<h2 id='get.theta.ci'>Calculate bootstrapped confidence intervals for <code>get.theta</code> values.</h2><span id='topic+get.theta.ci'></span>

<h3>Description</h3>

<p>Wrapper to <code>get.theta.bootstrap</code> that takes care of calculating the
confience intervals based on the bootstrapped values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.theta.ci(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter = 1000,
  ci.low = 0.025,
  ci.high = 0.975,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.theta.ci_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.theta.ci_+3A_fun">fun</code></td>
<td>
<p>the function to decide relationships</p>
</td></tr>
<tr><td><code id="get.theta.ci_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.theta.ci_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range. 0 by default</p>
</td></tr>
<tr><td><code id="get.theta.ci_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.theta.ci_+3A_ci.low">ci.low</code></td>
<td>
<p>the low end of the ci...0.025 by default</p>
</td></tr>
<tr><td><code id="get.theta.ci_+3A_ci.high">ci.high</code></td>
<td>
<p>the high end of the ci...0.975 by default</p>
</td></tr>
<tr><td><code id="get.theta.ci_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with a row for the high and low values and
a column per distance
</p>


<h3>Author(s)</h3>

<p>Justin Lessler
</p>


<h3>See Also</h3>

<p>Other get.theta: 
<code><a href="#topic+get.theta">get.theta</a>()</code>,
<code><a href="#topic+get.theta.bootstrap">get.theta.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.permute">get.theta.permute</a>()</code>,
<code><a href="#topic+get.theta.typed">get.theta.typed</a>()</code>,
<code><a href="#topic+get.theta.typed.bootstrap">get.theta.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.typed.permute">get.theta.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
    if(a[1]!=2) return(3)
    if (b[1]==2) return(1)
    return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2

theta&lt;-get.theta(x,fun,r=r.max,r.low=r.min)
theta.ci&lt;-get.theta.ci(x,fun,r=r.max,r.low=r.min,boot.iter=100)

plot(r.mid, theta$theta, type="l")
lines(r.mid, theta.ci[,2] , lty=2)
lines(r.mid, theta.ci[,3] , lty=2)


</code></pre>

<hr>
<h2 id='get.theta.permute'>get the null distribution of the <code>get.theta</code> function</h2><span id='topic+get.theta.permute'></span>

<h3>Description</h3>

<p>Does permutations to calculate the null distribution of get theta
if there were no spatial dependence. Randomly reassigns coordinates
to each observation permutations times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.theta.permute(
  posmat,
  fun,
  r = 1,
  r.low = rep(0, length(r)),
  permutations,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.theta.permute_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.theta.permute_+3A_fun">fun</code></td>
<td>
<p>the function to evaluate</p>
</td></tr>
<tr><td><code id="get.theta.permute_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.theta.permute_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.theta.permute_+3A_permutations">permutations</code></td>
<td>
<p>the number of permute iterations</p>
</td></tr>
<tr><td><code id="get.theta.permute_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta values for all the distances we looked at
</p>


<h3>See Also</h3>

<p>Other get.theta: 
<code><a href="#topic+get.theta">get.theta</a>()</code>,
<code><a href="#topic+get.theta.bootstrap">get.theta.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.ci">get.theta.ci</a>()</code>,
<code><a href="#topic+get.theta.typed">get.theta.typed</a>()</code>,
<code><a href="#topic+get.theta.typed.bootstrap">get.theta.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.typed.permute">get.theta.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#compare normally distributed with uniform points
x&lt;-cbind(1,runif(100,-100,100), runif(100,-100,100))
x&lt;-rbind(x, cbind(2,rnorm(100,0,20), rnorm(100,0,20)))
colnames(x) &lt;- c("type","x","y")

fun&lt;-function(a,b) {
    if(a[1]!=2) return(3)
    if (b[1]==2) return(1)
    return(2)
}

r.max&lt;-seq(10,100,10)
r.min&lt;-seq(0,90,10)
r.mid &lt;- (r.max+r.min)/2

theta&lt;-get.theta(x,fun,r=r.max,r.low=r.min)
theta.null&lt;-get.theta.permute(x,fun,r=r.max,r.low=r.min,permutations=100)

null.ci&lt;-apply(theta.null[,-(1:2)],1,quantile,probs=c(0.25,0.75))

plot(r.mid, theta$theta , type="l")
lines(r.mid, null.ci[1,] , lty=2)
lines(r.mid, null.ci[2,] , lty=2)


</code></pre>

<hr>
<h2 id='get.theta.typed'>Optimized version of <code>get.theta</code> for typed data.</h2><span id='topic+get.theta.typed'></span>

<h3>Description</h3>

<p>Version of the <code>get.theta</code> function that is optimized for statically typed data. That is
data where we are interested in the odds that points within some distance of points of
typeA are of typeB.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.theta.typed(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.theta.typed_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.theta.typed_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.theta.typed_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.theta.typed_+3A_r">r</code></td>
<td>
<p>the series of spatial distances wer are interested in</p>
</td></tr>
<tr><td><code id="get.theta.typed_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.theta.typed_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta values for all the distances we looked at
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.theta: 
<code><a href="#topic+get.theta">get.theta</a>()</code>,
<code><a href="#topic+get.theta.bootstrap">get.theta.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.ci">get.theta.ci</a>()</code>,
<code><a href="#topic+get.theta.permute">get.theta.permute</a>()</code>,
<code><a href="#topic+get.theta.typed.bootstrap">get.theta.typed.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.typed.permute">get.theta.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR02)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)

#Lets see if there's a difference in spatial dependence by time case occurs
type&lt;-2-(DengueSimR02[,"time"]&lt;120)
tmp&lt;-cbind(DengueSimR02,type=type)

typed.theta.R01&lt;-get.theta.typed(tmp,typeA=2,typeB=2,r=r.max,r.low=r.min)


</code></pre>

<hr>
<h2 id='get.theta.typed.bootstrap'>runs bootstrapping on <code>get.theta.typed</code></h2><span id='topic+get.theta.typed.bootstrap'></span>

<h3>Description</h3>

<p>Bootstraps typed pi values. Makes sure distances between a sample and
another draw of itself are left out
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.theta.typed.bootstrap(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  boot.iter,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.theta.typed.bootstrap_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.theta.typed.bootstrap_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.theta.typed.bootstrap_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.theta.typed.bootstrap_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.theta.typed.bootstrap_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.theta.typed.bootstrap_+3A_boot.iter">boot.iter</code></td>
<td>
<p>the number of bootstrap iterations</p>
</td></tr>
<tr><td><code id="get.theta.typed.bootstrap_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta values for all the distances we looked at
</p>


<h3>See Also</h3>

<p>Other get.theta: 
<code><a href="#topic+get.theta">get.theta</a>()</code>,
<code><a href="#topic+get.theta.bootstrap">get.theta.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.ci">get.theta.ci</a>()</code>,
<code><a href="#topic+get.theta.permute">get.theta.permute</a>()</code>,
<code><a href="#topic+get.theta.typed">get.theta.typed</a>()</code>,
<code><a href="#topic+get.theta.typed.permute">get.theta.typed.permute</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR01)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)

#Lets see if there's a difference in spatial dependence by time case occurs
type&lt;-2-(DengueSimR01[,"time"]&lt;75)
tmp&lt;-cbind(DengueSimR01,type=type)

typed.theta.bs&lt;-get.theta.typed.bootstrap(tmp,typeA=1,typeB=2,r=r.max,r.low=r.min,boot.iter=100)


</code></pre>

<hr>
<h2 id='get.theta.typed.permute'>get the null distribution of the get.theta.typed function</h2><span id='topic+get.theta.typed.permute'></span>

<h3>Description</h3>

<p>Does permutations to calculate the null distribution of get theta
if there were no spatial dependence. Randomly reassigns coordinates
to each observation permutations times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.theta.typed.permute(
  posmat,
  typeA = -1,
  typeB = -1,
  r = 1,
  r.low = rep(0, length(r)),
  permutations,
  data.frame = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.theta.typed.permute_+3A_posmat">posmat</code></td>
<td>
<p>a matrix with columns type, x and y</p>
</td></tr>
<tr><td><code id="get.theta.typed.permute_+3A_typea">typeA</code></td>
<td>
<p>the &quot;from&quot; type that we are interested in, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.theta.typed.permute_+3A_typeb">typeB</code></td>
<td>
<p>the &quot;to&quot; type that we are interested i, -1 is wildcard</p>
</td></tr>
<tr><td><code id="get.theta.typed.permute_+3A_r">r</code></td>
<td>
<p>the series of spatial distances we are interested in</p>
</td></tr>
<tr><td><code id="get.theta.typed.permute_+3A_r.low">r.low</code></td>
<td>
<p>the low end of each range....0  by default</p>
</td></tr>
<tr><td><code id="get.theta.typed.permute_+3A_permutations">permutations</code></td>
<td>
<p>the number of permute iterations</p>
</td></tr>
<tr><td><code id="get.theta.typed.permute_+3A_data.frame">data.frame</code></td>
<td>
<p>logical indicating whether to return results as a data frame (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>theta values for all the distances we looked at
</p>


<h3>Author(s)</h3>

<p>Justin Lessler and Henrik Salje
</p>


<h3>See Also</h3>

<p>Other get.theta: 
<code><a href="#topic+get.theta">get.theta</a>()</code>,
<code><a href="#topic+get.theta.bootstrap">get.theta.bootstrap</a>()</code>,
<code><a href="#topic+get.theta.ci">get.theta.ci</a>()</code>,
<code><a href="#topic+get.theta.permute">get.theta.permute</a>()</code>,
<code><a href="#topic+get.theta.typed">get.theta.typed</a>()</code>,
<code><a href="#topic+get.theta.typed.bootstrap">get.theta.typed.bootstrap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(DengueSimR01)

r.max&lt;-seq(20,1000,20)
r.min&lt;-seq(0,980,20)

#Lets see if there's a difference in spatial dependence by time case occurs
type&lt;-2-(DengueSimR01[,"time"]&lt;75)
tmp&lt;-cbind(DengueSimR01,type=type)

typed.theta.R01&lt;-get.theta.typed(tmp,typeA=1,typeB=2,r=r.max,r.low=r.min)
typed.theta.type.null&lt;-get.theta.typed.permute(tmp, typeA=1, typeB=2, 
                                               r=r.max, r.low=r.min, permutations=100)


</code></pre>

<hr>
<h2 id='get.transdist.theta'>Get weights of transmission distance theta</h2><span id='topic+get.transdist.theta'></span>

<h3>Description</h3>

<p>This function estimates the weights of each theta (number of transmission events separating cases at two time points). A randomized transmission tree is drawn and the number of transmission events
separating cases at two time points is calculated based on probabilies found in the Wallinga-Teunis matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.transdist.theta(
  wal.teun.mat,
  cases,
  gen.t.mean,
  max.sep,
  ret.theta.mat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.transdist.theta_+3A_wal.teun.mat">wal.teun.mat</code></td>
<td>
<p>a Wallinga-Teunis matrix produced by the <code>est.wt.matrix</code> function</p>
</td></tr>
<tr><td><code id="get.transdist.theta_+3A_cases">cases</code></td>
<td>
<p>a vector of case times for each case</p>
</td></tr>
<tr><td><code id="get.transdist.theta_+3A_gen.t.mean">gen.t.mean</code></td>
<td>
<p>the mean generation time of the infecting pathogen</p>
</td></tr>
<tr><td><code id="get.transdist.theta_+3A_max.sep">max.sep</code></td>
<td>
<p>maximum number of transmission events allowed between two cases</p>
</td></tr>
<tr><td><code id="get.transdist.theta_+3A_ret.theta.mat">ret.theta.mat</code></td>
<td>
<p>logical value which returns the matrix of estimated theta values (default = FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a three-dimensional array containing normalized theta weights. Columns and rows represent unique case times. The third dimension is the number of transmission events between two cases.
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>References</h3>

<p>Salje H, Cummings DAT and Lessler J (2016). “Estimating infectious disease transmission distances using the overall distribution of cases.” Epidemics, 17, pp. 10–18. ISSN 1755-4365, doi: <a href="https://www.sciencedirect.com/science/article/pii/S1755436516300317">10.1016/j.epidem.2016.10.001</a>.
</p>


<h3>See Also</h3>

<p>Other transdist: 
<code><a href="#topic+est.transdist">est.transdist</a>()</code>,
<code><a href="#topic+est.transdist.bootstrap.ci">est.transdist.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.temporal">est.transdist.temporal</a>()</code>,
<code><a href="#topic+est.transdist.temporal.bootstrap.ci">est.transdist.temporal.bootstrap.ci</a>()</code>,
<code><a href="#topic+est.transdist.theta.weights">est.transdist.theta.weights</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

case.times &lt;- c(1,2,2,3,3)
gen &lt;- c(0, 2/3, 1/3, 0, 0)
t.density &lt;- gen/sum(gen)

gen.time &lt;- 2 # mean generation time

wt &lt;- est.wt.matrix(case.times=case.times, gen.t.dist=t.density)

ngen &lt;- round((max(case.times) - min(case.times)) / gen.time) + 1 # Number of generations

a &lt;- get.transdist.theta(wal.teun.mat=wt,
                         cases=case.times,
                         gen.t.mean=gen.time,
                         max.sep=ngen*2)


</code></pre>

<hr>
<h2 id='sim.epidemic'>Simulation of an epidemic in space and time</h2><span id='topic+sim.epidemic'></span>

<h3>Description</h3>

<p>A function which simulates the spatial spread of infections through time given the reproductive number (<code>R</code>),
a function describing the spatial transmission kernel (<code>trans.kern.func</code>), and the mean and standard deviation
of the generation time distribution (<code>gen.t.mean</code> and <code>gen.t.sd</code>) for the infecting pathogen. The function returns
the location (<code>x</code>, <code>y</code>) and time (<code>t</code>) for each case of infection in the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.epidemic(
  R,
  gen.t.mean,
  gen.t.sd,
  trans.kern.func,
  tot.generations = 10,
  min.cases = 0,
  max.try = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.epidemic_+3A_r">R</code></td>
<td>
<p>a scalar or a vector of length <code>tot.generations</code> providing the reproductive number for the epidemic.
If scalar, the R value is constant. If a vector, the R value varies according to each generation in the vector.</p>
</td></tr>
<tr><td><code id="sim.epidemic_+3A_gen.t.mean">gen.t.mean</code></td>
<td>
<p>mean of generation time</p>
</td></tr>
<tr><td><code id="sim.epidemic_+3A_gen.t.sd">gen.t.sd</code></td>
<td>
<p>standard deviation of the generation time (assumed to be normally distributed)</p>
</td></tr>
<tr><td><code id="sim.epidemic_+3A_trans.kern.func">trans.kern.func</code></td>
<td>
<p>a function for the transmission kernel that takes <code>n</code> as an arguement.
Function and associated parameters must be given in a list object.</p>
</td></tr>
<tr><td><code id="sim.epidemic_+3A_tot.generations">tot.generations</code></td>
<td>
<p>the total number of generations in the epidemic, where the index case (x,y,t = [0,0,0]) is considered generation zero (default = 10)</p>
</td></tr>
<tr><td><code id="sim.epidemic_+3A_min.cases">min.cases</code></td>
<td>
<p>the minimum number of cases in the epidemic (default = 0)</p>
</td></tr>
<tr><td><code id="sim.epidemic_+3A_max.try">max.try</code></td>
<td>
<p>maximum number of tries to acheive the minimum number of cases (default = 1000)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical matrix with three columns giving the coordinates <code>x</code> and <code>y</code>, and time <code>t</code> of simulated cases
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     
set.seed(1)

dist.func &lt;- alist(n=1, a=1/100, rexp(n, a)) # Exponential transmission kernel with mean = sd = 100

# Simulate epidemic with constant R value
a &lt;- sim.epidemic(R=1.5,
             gen.t.mean=7,
             gen.t.sd=2,
             tot.generations=15,
             min.cases=100,
             trans.kern.func=dist.func)

sim.plot(a)

# Simulate an epidemic with variable R value
r1 &lt;- 2
r2 &lt;- 0.25
tg &lt;- 25
R &lt;- seq(r1, r2, (r2 -r1)/(tg - 1))

b &lt;- sim.epidemic(R=R,
             gen.t.mean=7,
             gen.t.sd=2,
             tot.generations=tg,
             min.cases=100,
             trans.kern.func=dist.func)

sim.plot(b)


</code></pre>

<hr>
<h2 id='sim.plot'>Plot output of simulated epidemic</h2><span id='topic+sim.plot'></span>

<h3>Description</h3>

<p>A simple visualization function which plots the location of the index case and the spatial distribution of subsequent cases,
and the epidemic curve showing the case count over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.plot(sim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.plot_+3A_sim">sim</code></td>
<td>
<p>a three-column matrix object produced by the <code>sim.epidemic</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-panel plotted object
</p>


<h3>Author(s)</h3>

<p>John Giles, Justin Lessler, and Henrik Salje
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
