<!DOCTYPE html><html><head><title>Help for package postpack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {postpack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#array_format'><p>Convert a vector to the array structure used in model</p></a></li>
<li><a href='#cjs'><p>Example mcmc.list 1</p></a></li>
<li><a href='#cjs_no_rho'><p>Example mcmc.list 2</p></a></li>
<li><a href='#density_plot'><p>Create a density plot for a single desired node</p></a></li>
<li><a href='#diag_plots'><p>Create MCMC diagnostic plots for nodes of interest</p></a></li>
<li><a href='#drop_index'><p>Extract the base node name of a parameter</p></a></li>
<li><a href='#get_params'><p>Obtain the names of all nodes</p></a></li>
<li><a href='#id_mat'><p>Extract chain and iteration IDs for each sample</p></a></li>
<li><a href='#ins_regex_bracket'><p>Insert escapes on regex brackets</p></a></li>
<li><a href='#ins_regex_lock'><p>Insert the symbols to lock in a string for matching</p></a></li>
<li><a href='#list_out'><p>List vector elements in a nice format</p></a></li>
<li><a href='#match_params'><p>Find matching node names</p></a></li>
<li><a href='#mytitle'><p>Add a title between two figures</p></a></li>
<li><a href='#post_bind'><p>Combine two objects containing posterior samples</p></a></li>
<li><a href='#post_convert'><p>Convert MCMC samples to mcmc.list format</p></a></li>
<li><a href='#post_dim'><p>Obtain MCMC dimensions from an mcmc.list</p></a></li>
<li><a href='#post_remove'><p>Remove nodes from mcmc.list</p></a></li>
<li><a href='#post_subset'><p>Extract samples from specific nodes</p></a></li>
<li><a href='#post_summ'><p>Obtain posterior summaries and diagnostics of specific nodes</p></a></li>
<li><a href='#post_thin'><p>Perform post-MCMC thinning</p></a></li>
<li><a href='#postpack'><p>Utilities for Processing Posterior Samples Stored in mcmc.lists</p></a></li>
<li><a href='#rm_regex_bracket'><p>Remove escapes on regex brackets</p></a></li>
<li><a href='#rm_regex_lock'><p>Remove the symbols that lock in a string for matching</p></a></li>
<li><a href='#trace_plot'><p>Create a trace plot for a single desired node</p></a></li>
<li><a href='#vcov_decomp'><p>Decompose the posterior of a variance-covariance node</p></a></li>
<li><a href='#write_model'><p>Export BUGS/JAGS model from function to file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Utilities for Processing Posterior Samples Stored in
'mcmc.lists'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.4</td>
</tr>
<tr>
<td>Description:</td>
<td>The aim of 'postpack' is to provide the infrastructure for a standardized workflow for 'mcmc.list' objects.
    These objects can be used to store output from models fitted with Bayesian inference using
    'JAGS', 'WinBUGS', 'OpenBUGS', 'NIMBLE', 'Stan', or even custom MCMC algorithms. Although the 'coda' R package provides
    some methods for these objects, it is somewhat limited in easily performing post-processing tasks for
    specific nodes. Models are ever increasing in their complexity and the number of tracked nodes, and oftentimes
    a user may wish to summarize/diagnose sampling behavior for only a small subset of nodes at a time
    for a particular question or figure. Thus, many 'postpack' functions support performing tasks on a
    subset of nodes, where the subset is specified with regular expressions. The functions in 'postpack'
    streamline the extraction, summarization, and diagnostics of specific monitored nodes after model fitting.
    Further, because there is rarely only ever one model under consideration, 'postpack' scales efficiently 
    to perform the same tasks on output from multiple models simultaneously, facilitating rapid assessment 
    of model sensitivity to changes in assumptions.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr (&ge; 1.3.1), coda, mcmcse, abind</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bstaton1.github.io/postpack/">https://bstaton1.github.io/postpack/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bstaton1/postpack/issues">https://github.com/bstaton1/postpack/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, rstan, R2WinBUGS, R2jags, R2OpenBUGS,
nimble, rjags, jagsUI</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-21 00:14:57 UTC; bstaton</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Staton <a href="https://orcid.org/0000-0002-2342-3482"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Staton &lt;statonbe@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-21 00:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='array_format'>Convert a vector to the array structure used in model</h2><span id='topic+array_format'></span>

<h3>Description</h3>

<p>Use element names to place vector elements in
the appropriate location of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_format(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array_format_+3A_v">v</code></td>
<td>
<p>A vector with names indicating the index location of each element in a new array.
See the details (particularly the example) for more about what this means.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose you have an AxB matrix in your model, and you would like to
create an object that stores the posterior means in the same AxB matrix as found in
the model. For an AxB matrix, this is not too difficult to do &quot;by-hand&quot;.
However, if there are also dimensions C, D, and E, missing values, etc. it becomes more difficult.
</p>


<h3>Value</h3>

<p>An array with elements of <code>v</code> placed in the appropriate location based on their
index names.
</p>


<h3>Note</h3>

<p>Up to 10 dimensions are currently supported. Please submit an
<a href="https://github.com/bstaton1/postpack/issues">issue</a>
should you find that you need more dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# find an array node from your model
match_params(cjs, "SIG")

# extract the posterior mean of it
SIG_mean = post_summ(cjs, "SIG")["mean",]

# note that it has element names
SIG_mean

# create a matrix with elements in the proper place
array_format(SIG_mean)

</code></pre>

<hr>
<h2 id='cjs'>Example mcmc.list 1</h2><span id='topic+cjs'></span>

<h3>Description</h3>

<p>An example of samples from a joint posterior distribution from a Cormack-Jolly-Seber model.
<strong>The specific context does not matter, this object is provided to show examples of 'postpack' functionality</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs
</code></pre>


<h3>Format</h3>

<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.
</p>


<h3>Source</h3>

<p>Posterior samples generated from a model fitted to hypothetical data set.
See <code>vignette("example-mcmclists")</code> on the context, model, and monitored parameters.
</p>

<hr>
<h2 id='cjs_no_rho'>Example mcmc.list 2</h2><span id='topic+cjs_no_rho'></span>

<h3>Description</h3>

<p>An example of samples from a joint posterior distribution from a Cormack-Jolly-Seber model.
<strong>The specific context does not matter, this object is provided to show examples of 'postpack' functionality</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cjs_no_rho
</code></pre>


<h3>Format</h3>

<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.
</p>


<h3>Source</h3>

<p>This object stores samples from the same hypothetical example as for the <code><a href="#topic+cjs">cjs</a></code> example object,
with one small change to the model. The <code>rho</code> term that models correlation between slopes and intercepts
was forced to be zero, rather than estimating it. Consult <code>vignette("example-mcmclists")</code> for more details.
</p>

<hr>
<h2 id='density_plot'>Create a density plot for a single desired node</h2><span id='topic+density_plot'></span>

<h3>Description</h3>

<p>Used by <code><a href="#topic+diag_plots">diag_plots()</a></code>, not intended to be called separately
</p>


<h3>Usage</h3>

<pre><code class='language-R'>density_plot(post, param, show_diags = "if_poor_Rhat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_plot_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="density_plot_+3A_param">param</code></td>
<td>
<p>A regular expression that matches a single element in the model.
E.g., <code>"b0[1]"</code>, not <code>"b0"</code>. See <code><a href="#topic+match_params">match_params()</a></code>.</p>
</td></tr>
<tr><td><code id="density_plot_+3A_show_diags">show_diags</code></td>
<td>
<p>Control when to display numerical diagnostic summaries on plots. Must be one of
<code>"always"</code>, <code>"never"</code>, or <code>"if_poor_Rhat"</code>. <code>"if_poor_Rhat"</code> (the default)
will display the Rhat and effective MCMC samples if the Rhat statistic
is greater than 1.1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A figure showing the posterior density, separated by chain.
</p>


<h3>Note</h3>

<p>This is <strong>not</strong> a function users will generally use directly. Call <code><a href="#topic+diag_plots">diag_plots()</a></code> instead.
</p>

<hr>
<h2 id='diag_plots'>Create MCMC diagnostic plots for nodes of interest</h2><span id='topic+diag_plots'></span>

<h3>Description</h3>

<p>Allows quick visualization of posterior density and trace plots,
<strong>both</strong> separated by chain, for the desired nodes of interest. Includes the
ability to plot in the RStudio graphics device, an external device,
or a PDF file. Further, with the auto settings, the dimensions of the
plotting device scales to the job needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diag_plots(
  post,
  params,
  ext_device = FALSE,
  show_diags = "if_poor_Rhat",
  layout = "auto",
  dims = "auto",
  keep_percent = 1,
  save = FALSE,
  file = NULL,
  auto_escape = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag_plots_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_params">params</code></td>
<td>
<p>A vector of regular expressions specifying the nodes to match for plotting.
Accepts multi-element vectors to match more than one node at a time.
See <code><a href="#topic+match_params">match_params()</a></code> and <code>vignette("pattern-matching")</code> for more details.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_ext_device">ext_device</code></td>
<td>
<p>Display plots in an external device rather than the active device?
<code>FALSE</code> (the default) will plot in the active device (including RStudio window).
<code>TRUE</code> will create a new graphics device.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_show_diags">show_diags</code></td>
<td>
<p>Control when to display numerical diagnostic summaries on plots. Must be one of
<code>"always"</code>, <code>"never"</code>, or <code>"if_poor_Rhat"</code>. <code>"if_poor_Rhat"</code> (the default)
will display the Rhat and effective MCMC samples if the Rhat statistic
is greater than 1.1.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_layout">layout</code></td>
<td>
<p>Control how parameter diagnostics are organized into <code>"ROWSxCOLUMNS"</code>.
For example, <code>layout = "4x1"</code> has 4 rows and 1 column of parameter diagnostics.
Defaults to <code>"auto"</code>, which selects between the only accepted options of
<code>"1x1"</code>, <code>"2x1"</code>, <code>"4x1"</code>, <code>"4x2"</code>, and <code>"5x3"</code>.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_dims">dims</code></td>
<td>
<p>Control the dimensions of the graphics device using <code>"HEIGHTxWIDTH"</code> in inches.
For example, <code>"5x7"</code> would create a 5 inch tall and 7 inch wide plotting device.
Defaults to <code>"auto"</code>, which selects the dimensions that look nice when <code>layout = "auto"</code>
as well.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_keep_percent">keep_percent</code></td>
<td>
<p>Proportion (between 0 and 1) of samples to keep for trace plotting.
Passed to <code><a href="#topic+post_thin">post_thin()</a></code>.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_save">save</code></td>
<td>
<p>Save the diagnostic plots in a PDF file? If so,
specify <code>file = "example.pdf"</code> as well. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_file">file</code></td>
<td>
<p>File name of a PDF file to save the plots to.
Must include the <code>".pdf"</code> extension. Saved to working directory by default,
but can receive an absolute or relative file path as part of this argument.</p>
</td></tr>
<tr><td><code id="diag_plots_+3A_auto_escape">auto_escape</code></td>
<td>
<p>Automatically escape <code>"["</code> and <code>"]"</code> characters for pattern matching?
See <code><a href="#topic+match_params">match_params()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A multi-panel figure showing the posterior density and trace plots for requested nodes.
The device in which it is placed depends on the argument values.
</p>


<h3>Note</h3>

<p>If saving as a pdf, these files can get very large with many samples and render slowly.
The <code>keep_percent</code> argument is intended to help with this by thinning the chains at quasi-evenly spaced intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_params">match_params()</a></code>, <code><a href="#topic+density_plot">density_plot()</a></code>, <code><a href="#topic+trace_plot">trace_plot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  #load example mcmc.list
  data(cjs)

  # use current device
  diag_plots(cjs, "B0")

  # use a new device
  diag_plots(cjs, "B0", ext_device = TRUE)

  # always show diagnostic summaries
  diag_plots(cjs, "B0", show_diags = "always")

  # use a different layout (leaving it as "auto" is usually best)
  diag_plots(cjs, c("sig", "b"), layout = "5x3")

  # save diagnostics for all nodes to a pdf file
  diag_plots(cjs, "", save = TRUE, file = "diags.pdf")
}
</code></pre>

<hr>
<h2 id='drop_index'>Extract the base node name of a parameter</h2><span id='topic+drop_index'></span>

<h3>Description</h3>

<p>Removes square brackets, numbers, and commas that represent
the index of the node element in question. Returns just the node name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_index(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_index_+3A_params">params</code></td>
<td>
<p>Node names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the same length as <code>params</code>, with no indices included.
For example, <code>"a[1]"</code> becomes <code>"a"</code>.
</p>


<h3>Note</h3>

<p>This is <strong>not</strong> a function users will generally use directly.
</p>

<hr>
<h2 id='get_params'>Obtain the names of all nodes</h2><span id='topic+get_params'></span>

<h3>Description</h3>

<p>Returns the names of all quantities stored in
a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_params(post, type = "base_only")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_params_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="get_params_+3A_type">type</code></td>
<td>
<p>Format of returned matches; only two options are accepted:
</p>

<ul>
<li> <p><code>type = "base_only"</code> (the default) to return only the unique node names (without indices).
</p>
</li>
<li> <p><code>type = "base_index"</code> to return the node names with indices included.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with all node names stored in the <code>post</code> object, formatted as requested by <code>type</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # load example mcmc.list
data(cjs)

# get only node names, no indices (default)
get_params(cjs, type = "base_only")

# get indices too, where applicable
get_params(cjs, type = "base_index")
</code></pre>

<hr>
<h2 id='id_mat'>Extract chain and iteration IDs for each sample</h2><span id='topic+id_mat'></span>

<h3>Description</h3>

<p>Extract chain and iteration IDs for each sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_mat(post)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_mat_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with columns <code>"CHAIN"</code> and <code>"ITER"</code>.
</p>


<h3>Note</h3>

<p>This is <strong>not</strong> a function users will generally use directly.
</p>

<hr>
<h2 id='ins_regex_bracket'>Insert escapes on regex brackets</h2><span id='topic+ins_regex_bracket'></span>

<h3>Description</h3>

<p>Insert escapes on regex brackets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ins_regex_bracket(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ins_regex_bracket_+3A_params">params</code></td>
<td>
<p>Node names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Searches the contents of a string for the occurrence of a
square bracket or two, and inserts the necessary escapes for pattern matching
via regular expressions.
</p>


<h3>Value</h3>

<p>A character vector with all brackets escaped. For example,
<code>"a[1]"</code> becomes <code style="white-space: pre;">&#8288;"a\\[1\\]"&#8288;</code>
</p>


<h3>Note</h3>

<p>This is <strong>not</strong> a function users will generally use directly.
</p>

<hr>
<h2 id='ins_regex_lock'>Insert the symbols to lock in a string for matching</h2><span id='topic+ins_regex_lock'></span>

<h3>Description</h3>

<p>To ensure that a regular expression will match exactly,
it's necessary to specify so.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ins_regex_lock(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ins_regex_lock_+3A_params">params</code></td>
<td>
<p>Node names to paste a <code>^</code> and <code>$</code> (if not already present) to lock in the match.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with locking anchors inserted to force an exact match. For example,
<code style="white-space: pre;">&#8288;"a\\[1\\]"&#8288;</code> becomes <code style="white-space: pre;">&#8288;"^a\\[1\\]$"&#8288;</code>.
</p>


<h3>Note</h3>

<p>This is <strong>not</strong> a function users will generally use directly.
</p>

<hr>
<h2 id='list_out'>List vector elements in a nice format</h2><span id='topic+list_out'></span>

<h3>Description</h3>

<p>Converts a vector into a comma-separated list for use in sentences (error messages, warnings, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_out(x, final = NULL, per_line = 1e+06, wrap = NULL, indent = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_out_+3A_x">x</code></td>
<td>
<p>A vector, will be coerced to a character.</p>
</td></tr>
<tr><td><code id="list_out_+3A_final">final</code></td>
<td>
<p>Word that will separate the final element in the list from others.
See the examples.</p>
</td></tr>
<tr><td><code id="list_out_+3A_per_line">per_line</code></td>
<td>
<p>Number of elements printed per line. See the examples.</p>
</td></tr>
<tr><td><code id="list_out_+3A_wrap">wrap</code></td>
<td>
<p>Optional character to wrap around each element, e.g., quotation marks.</p>
</td></tr>
<tr><td><code id="list_out_+3A_indent">indent</code></td>
<td>
<p>Optional string to place in front of the first
element on each line. See the examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with length == 1; ready to be passed to
<code><a href="base.html#topic+stop">base::stop()</a></code>, <code><a href="base.html#topic+warning">base::warning()</a></code>, or <code><a href="base.html#topic+cat">base::cat()</a></code>, to provide a useful message.
</p>

<hr>
<h2 id='match_params'>Find matching node names</h2><span id='topic+match_params'></span>

<h3>Description</h3>

<p>Returns all the node names stored in a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
object that match a provided string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_params(post, params, type = "base_index", auto_escape = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_params_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="match_params_+3A_params">params</code></td>
<td>
<p>A vector of regular expressions specifying the nodes to match.
Accepts multi-element vectors to match more than one node at a time.
See examples and <code>vignette("pattern-matching")</code> for more details.</p>
</td></tr>
<tr><td><code id="match_params_+3A_type">type</code></td>
<td>
<p>Format of returned matches; only two options are accepted:
</p>

<ul>
<li> <p><code>type = "base_only"</code> to return only the unique node names (without indices).
</p>
</li>
<li> <p><code>type = "base_index"</code> (the default) to return the node names with indices included.
</p>
</li></ul>
</td></tr>
<tr><td><code id="match_params_+3A_auto_escape">auto_escape</code></td>
<td>
<p>Automatically escape <code>"["</code> and <code>"]"</code> characters for pattern matching?
<code>FALSE</code> will treat <code>"["</code> and <code>"]"</code> as special regular expression characters (unless explicitly escaped by user),
<code>TRUE</code> will treat these symbols as plain text to be matched.
It is generally recommended to keep this as <code>TRUE</code> (the default),
unless you are performing complex regex searches that require the
<code>"["</code> and <code>"]"</code> symbols to be special characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called as one of the first steps in many of the more downstream
functions in this package. It is thus fairly important to get used to
how the regular expressions work. This function can be used directly to hone in on the correct regular expression.
See the examples below.
</p>


<h3>Value</h3>

<p>A character vector with all node names in <code>post</code> that match <code>params</code>, formatted as requested by <code>type</code>..
If no matches are found, an error will be returned with
the base node names found in <code>post</code> to help the next try.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# these produce same output b/c of regex pattern matching
match_params(cjs, params = c("b0", "b1"))
match_params(cjs, params = c("b"))

# return only base names, not indices as well
match_params(cjs, params = "b", type = "base_only")

# force a match to start with B
match_params(cjs, "^B")

# force a match to end with 0
match_params(cjs, "0$")

# use a wild card to get b0[3] and b1[3]
match_params(cjs, "b.[3]")

# repeat a wild card
match_params(cjs, "s.+0")

# turn off auto escape to use [] in regex syntax rather than matching them as text
match_params(cjs, params = "[:digit:]$", auto_escape = FALSE)

# pass a dot to match all (same as get_params)
match_params(cjs, ".")
</code></pre>

<hr>
<h2 id='mytitle'>Add a title between two figures</h2><span id='topic+mytitle'></span>

<h3>Description</h3>

<p>Used by <code><a href="#topic+diag_plots">diag_plots()</a></code> to place a common
title over top of two figures: one density and one trace
for a given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mytitle(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mytitle_+3A_text">text</code></td>
<td>
<p>The text string to include as a centered title over two adjacent plots.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is <strong>not</strong> a function users will generally use directly.
</p>

<hr>
<h2 id='post_bind'>Combine two objects containing posterior samples</h2><span id='topic+post_bind'></span>

<h3>Description</h3>

<p>Intended for use when derived quantities are calculated from monitored posterior samples,
and you wish to combine them into the master <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>,
as though they were calculated and monitored during MCMC sampling.
It is not advised to combine samples from two MCMC runs, because covariance
of MCMC sampling would be lost.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_bind(post1, post2, dup_id = "_p2")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_bind_+3A_post1">post1</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> object.</p>
</td></tr>
<tr><td><code id="post_bind_+3A_post2">post2</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> object.</p>
</td></tr>
<tr><td><code id="post_bind_+3A_dup_id">dup_id</code></td>
<td>
<p>If any node names are duplicated in <code>post2</code>, what should be appended to the
end of these node names in the output? If this occurs a warning will be returned.
Defaults to <code>"_p2"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some important things to note:
</p>

<ul>
<li><p> If the object passed to <code>post1</code> is a <code><a href="base.html#topic+matrix">matrix</a></code>, <code>post2</code> must be a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, and vice versa.
</p>
</li>
<li><p> That is, two <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects are allowed, but not two <code><a href="base.html#topic+matrix">matrix</a></code> objects.
</p>
</li>
<li><p> For <code><a href="base.html#topic+matrix">matrix</a></code> objects, nodes should be stored as columns and samples should be stored as rows. Column names should be present.
</p>
</li>
<li><p> The objects passed to <code>post1</code> and <code>post2</code> must have the same number of chains, iterations, burnin, and thinning interval.
</p>
</li>
<li><p> If the node names are empty (e.g., missing column names in a <code><a href="base.html#topic+matrix">matrix</a></code>), the node names will be coerced to <code>"var1"</code>, <code>"var2"</code>, etc. and a warning will be returned.
</p>
</li></ul>



<h3>Value</h3>

<p>A single <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object containing samples of the nodes from both <code>post1</code> and <code>post2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# create two subsets from cjs: one as mcmc.list and one as matrix
# also works if both are mcmc.list objects
p1 = post_subset(cjs, "b0")
p2 = post_subset(cjs, "b1", matrix = TRUE)

# combine them into one mcmc.list
head(post_bind(p1, p2))
</code></pre>

<hr>
<h2 id='post_convert'>Convert MCMC samples to mcmc.list format</h2><span id='topic+post_convert'></span>

<h3>Description</h3>

<p>Wrapper around several ways of converting objects to <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> format,
automated based on the input object class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_convert(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_convert_+3A_obj">obj</code></td>
<td>
<p>An object storing posterior samples from an MCMC algorithm.
Accepted classes are <code><a href="base.html#topic+list">list</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code>, <code><a href="R2WinBUGS.html#topic+bugs">bugs</a></code>, <code><a href="R2jags.html#topic+jags">rjags</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepted classes are produced by several packages, including but probably not limited to:
</p>

<ul>
<li> <p><code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> objects are created by <code><a href="rstan.html#topic+stan">rstan::stan()</a></code>, which also provides <code><a href="rstan.html#topic+As.mcmc.list">rstan::As.mcmc.list()</a></code>. Rather than requiring users to have 'rstan' installed to use 'postpack', <code>post_convert()</code> will instruct users to use this function if supplied a <code><a href="rstan.html#topic+stanfit-class">stanfit</a></code> object.
</p>
</li>
<li> <p><code><a href="R2WinBUGS.html#topic+bugs">bugs</a></code> objects are created by <code><a href="R2WinBUGS.html#topic+bugs">R2WinBUGS::bugs()</a></code> and <code><a href="R2OpenBUGS.html#topic+bugs">R2OpenBUGS::bugs()</a></code>.
</p>
</li>
<li> <p><code><a href="R2jags.html#topic+jags">rjags</a></code> objects are created by <code><a href="R2jags.html#topic+jags">R2jags::jags()</a></code>.
</p>
</li>
<li> <p><code><a href="base.html#topic+list">list</a></code> objects are created by <code><a href="nimble.html#topic+runMCMC">nimble::runMCMC()</a></code>, 'MCMCpack' functions, or custom MCMC algorithms.
</p>
</li>
<li> <p><code><a href="base.html#topic+matrix">matrix</a></code> objects are created by <code><a href="#topic+post_subset">post_subset()</a></code> and is often the format of posterior quantities derived from monitored nodes.
</p>
</li>
<li> <p><code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects are created by <code><a href="rjags.html#topic+coda.samples">rjags::coda.samples()</a></code>, <code><a href="jagsUI.html#topic+jagsbasic">jagsUI::jags.basic()</a></code>, and <code><a href="jagsUI.html#topic+jags">jagsUI::jags()</a></code><code style="white-space: pre;">&#8288;$samples&#8288;</code>. If a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object is passed to <code>obj</code>, an error will be returned telling the user this function is not necessary.
</p>
</li></ul>

<p>If you find that a critical class conversion is missing, please submit an <a href="https://github.com/bstaton1/postpack/issues">issue</a> requesting its addition with a minimum working example of how it can be created.
</p>


<h3>Value</h3>

<p>The same information as passed in the <code>obj</code> argument, but formatted as <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> class.
</p>


<h3>Note</h3>


<ul>
<li><p> If samples are stored in a <code><a href="base.html#topic+list">list</a></code> object, the individual elements must be <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="coda.html#topic+mcmc">mcmc</a></code> class, storing the samples (rows) across parameters (columns, with names) for each chain (<code><a href="base.html#topic+list">list</a></code> elements). If <code><a href="base.html#topic+list">list</a></code> elements are in <code><a href="base.html#topic+matrix">matrix</a></code> format, they will be coerced to <code><a href="coda.html#topic+mcmc">mcmc</a></code> format, and thinning, start, and end intervals may be inaccurate.
</p>
</li>
<li><p> If samples are stored in a <code><a href="base.html#topic+matrix">matrix</a></code> object, rows should store samples and columns should store nodes. Multiple chains should be combined using <code><a href="base.html#topic+cbind">base::rbind()</a></code>. Two additional columns <strong>must</strong> be present: <code>"CHAIN"</code> and <code>"ITER"</code>, which denote the MCMC chain and iteration numbers, respectively.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="coda.html#topic+mcmc.list">coda::as.mcmc.list()</a></code>, <code><a href="coda.html#topic+mcmc">coda::as.mcmc()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## EXAMPLE 1
# load example mcmc.list
data(cjs)

# take a subset from cjs as a matrix, retain chain and iter ids
cjs_sub = post_subset(cjs, "^B", matrix = TRUE, chains = TRUE, iters = TRUE)

# convert back to mcmc.list
class(post_convert(cjs_sub))

## EXAMPLE 2: create mcmc.list from hypothetical MCMC samples; chains are list elements
# create hypothetical samples; can't use postpack on this - not an mcmc.list
samps = lapply(1:3, function(i) {
  m = matrix(rnorm(100), 20, 5)
  colnames(m) = paste0("param", 1:5)
  m
})

# convert
samps_new = post_convert(samps)

# can use postpack now
post_summ(samps_new, "param")

## EXAMPLE 3: create mcmc.list from hypothetical MCMC samples; chains rbind-ed matrices
# create samples
f = function() {
  m = matrix(rnorm(100), 20, 5)
  colnames(m) = paste0("param", 1:5)
  m
}
samps = rbind(f(), f(), f())

# assign chain and iter IDs to each sample
samps = cbind(CHAIN = rep(1:3, each = 20), ITER = rep(1:20, 3), samps)

# convert
samps_new = post_convert(samps)

# can use postpack now
post_summ(samps_new, "param")
</code></pre>

<hr>
<h2 id='post_dim'>Obtain MCMC dimensions from an mcmc.list</h2><span id='topic+post_dim'></span>

<h3>Description</h3>

<p>Quickly query the number of burn-in samples, post-burnin, thinning,
number of chains, etc. from a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_dim(post, types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_dim_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="post_dim_+3A_types">types</code></td>
<td>
<p>The dimension types to return. Must contain some of <code>"burn"</code>, <code>"post_burn"</code>,
<code>"thin"</code>, <code>"chains"</code>, <code>"nodes"</code>. Defaults to <code>NULL</code>, in which case all of these are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with named elements, which may contain:
</p>

<ul>
<li> <p><code>burn</code>: The burn-in period + adapting phase (per chain).
</p>
</li>
<li> <p><code>post_burn</code>: The post-burn-in period (per chain).
</p>
</li>
<li> <p><code>thin</code>: The thinning interval post-burn-in.
</p>
</li>
<li> <p><code>chains</code>: The number of chains.
</p>
</li>
<li> <p><code>saved</code>: The number of saved samples across all chains.
</p>
</li>
<li> <p><code>params</code>: The number of nodes with MCMC samples.
</p>
</li></ul>

<p>All of these will be returned if <code>types = NULL</code>, a subset can be returned by
specifying (for example) <code>types = c("burn", "thin")</code>.
</p>


<h3>Note</h3>

<p>If the <code>post</code> object was thinned after MCMC completed
using <code><a href="#topic+post_thin">post_thin()</a></code>, then the <code>"burn"</code> and <code>"thin"</code> dimensions will be improperly calculated.
<code><a href="#topic+post_thin">post_thin()</a></code> performs post-MCMC thinning of <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects,
and is solely for developing long-running post-processing code, so this is okay.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# get all relevant dimensions
post_dim(cjs)

# get only the number of chains
post_dim(cjs, "chains")

# get the thinning and burn-in intervals
post_dim(cjs, c("burn", "thin"))
</code></pre>

<hr>
<h2 id='post_remove'>Remove nodes from mcmc.list</h2><span id='topic+post_remove'></span>

<h3>Description</h3>

<p>Just like <code><a href="#topic+post_subset">post_subset()</a></code>, but keep all nodes <strong>except</strong> those that match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_remove(post, params, ask = TRUE, auto_escape = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_remove_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="post_remove_+3A_params">params</code></td>
<td>
<p>A vector of regular expressions specifying the nodes to match for removal.
Accepts multi-element vectors to match more than one node at a time.
See <code><a href="#topic+match_params">match_params()</a></code> and <code>vignette("pattern-matching")</code> for more details.</p>
</td></tr>
<tr><td><code id="post_remove_+3A_ask">ask</code></td>
<td>
<p>Prompt user for a response prior to removing nodes?</p>
</td></tr>
<tr><td><code id="post_remove_+3A_auto_escape">auto_escape</code></td>
<td>
<p>Automatically escape <code>"["</code> and <code>"]"</code> characters?
See <code><a href="#topic+match_params">match_params()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, identical in all ways to the original
except that nodes matched by the <code>params</code> argument are removed. If the user
responds &quot;no&quot; to the question when <code>ask = TRUE</code>, <code>post</code> is returned unaltered.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# get names of all nodes
get_params(cjs)

# remove the SIG nodes
new_cjs = suppressMessages(post_remove(cjs, "SIG", ask = FALSE))

# get names of new output
get_params(new_cjs)
</code></pre>

<hr>
<h2 id='post_subset'>Extract samples from specific nodes</h2><span id='topic+post_subset'></span>

<h3>Description</h3>

<p>Subsets a smaller portion from a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object
corresponding only to the node(s) requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_subset(
  post,
  params,
  matrix = FALSE,
  iters = FALSE,
  chains = FALSE,
  auto_escape = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_subset_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="post_subset_+3A_params">params</code></td>
<td>
<p>A vector of regular expressions specifying the nodes to match for subsetting.
Accepts multi-element vectors to match more than one node at a time.
See <code><a href="#topic+match_params">match_params()</a></code> and <code>vignette("pattern-matching")</code> for more details.</p>
</td></tr>
<tr><td><code id="post_subset_+3A_matrix">matrix</code></td>
<td>
<p>Return samples in <code><a href="base.html#topic+matrix">matrix</a></code> rather than <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> format?</p>
</td></tr>
<tr><td><code id="post_subset_+3A_iters">iters</code></td>
<td>
<p>Retain the iteration number of each sample if <code>matrix = TRUE</code>? Not used otherwise.</p>
</td></tr>
<tr><td><code id="post_subset_+3A_chains">chains</code></td>
<td>
<p>Retain the chain number of each sample if <code>matrix = TRUE</code>? Not used otherwise.</p>
</td></tr>
<tr><td><code id="post_subset_+3A_auto_escape">auto_escape</code></td>
<td>
<p>Automatically escape <code>"["</code> and <code>"]"</code> characters for pattern matching?
See <code><a href="#topic+match_params">match_params()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> object, depending on the
value of the <code>matrix</code> argument. Object contains all nodes that match the <code>params</code> argument;
an error will be returned if no matches are found.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_params">match_params()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# create mcmc.list with all nodes that contain "B0"
x1 = post_subset(cjs, "B0")

# create mcmc.list with all nodes that contain "b" or "B"
x2 = post_subset(cjs, c("b", "B"))

# perform the subset and return a matrix as output, while retaining the chain ID
x3 = post_subset(cjs, "B0", matrix = TRUE, chain = TRUE)
</code></pre>

<hr>
<h2 id='post_summ'>Obtain posterior summaries and diagnostics of specific nodes</h2><span id='topic+post_summ'></span>

<h3>Description</h3>

<p>Allows rapid calculation of summaries and diagnostics from <strong>specific nodes</strong>
stored in <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_summ(
  post,
  params,
  digits = NULL,
  probs = c(0.5, 0.025, 0.975),
  Rhat = FALSE,
  neff = FALSE,
  mcse = FALSE,
  by_chain = FALSE,
  auto_escape = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_summ_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="post_summ_+3A_params">params</code></td>
<td>
<p>A vector of regular expressions specifying the nodes to match for summarization.
Accepts multi-element vectors to match more than one node at a time.
See <code><a href="#topic+match_params">match_params()</a></code> and <code>vignette("pattern-matching")</code> for more details.</p>
</td></tr>
<tr><td><code id="post_summ_+3A_digits">digits</code></td>
<td>
<p>Control rounding of summaries.
Passed to <code><a href="base.html#topic+Round">base::round()</a></code> and defaults to <code>NULL</code>, which produces no rounding.</p>
</td></tr>
<tr><td><code id="post_summ_+3A_probs">probs</code></td>
<td>
<p>Posterior quantiles to calculate. Passed to <code><a href="stats.html#topic+quantile">stats::quantile()</a></code>.
Defaults to <code>probs = c(0.5, 0.025, 0.975)</code> (i.e., median and equal-tailed 95 percent credible interval).</p>
</td></tr>
<tr><td><code id="post_summ_+3A_rhat">Rhat</code></td>
<td>
<p>Calculate the Rhat convergence diagnostic using <code><a href="coda.html#topic+gelman.diag">coda::gelman.diag()</a></code>?
Fair warning: this can take a bit of time to run on many nodes/samples.</p>
</td></tr>
<tr><td><code id="post_summ_+3A_neff">neff</code></td>
<td>
<p>Calculate the number of effective MCMC samples using <code><a href="coda.html#topic+effectiveSize">coda::effectiveSize()</a></code>?
Fair warning: this can take a bit of time to run on many nodes/samples.</p>
</td></tr>
<tr><td><code id="post_summ_+3A_mcse">mcse</code></td>
<td>
<p>Calculate the Monte Carlo standard error for the posterior mean and reported quantiles
using the <code><a href="mcmcse.html#topic+mcse">mcmcse::mcse()</a></code> and <code><a href="mcmcse.html#topic+mcse.q">mcmcse::mcse.q()</a></code> functions
(batch means method with batch size automatically calculated)?
Fair warning: this can take a bit of time to run on many nodes/samples.</p>
</td></tr>
<tr><td><code id="post_summ_+3A_by_chain">by_chain</code></td>
<td>
<p>Calculate posterior summaries for each chain
rather than for the aggregate across chains? Defaults to <code>FALSE</code>.
The arguments <code>Rhat</code>, <code>neff</code>, and <code>mcse</code> are ignored if <code>by_chain = TRUE</code>
and a warning will be returned.</p>
</td></tr>
<tr><td><code id="post_summ_+3A_auto_escape">auto_escape</code></td>
<td>
<p>Automatically escape <code>"["</code> and <code>"]"</code> characters for pattern matching?
See <code><a href="#topic+match_params">match_params()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+matrix">matrix</a></code> object with summary statistics as rows and nodes as columns.
If <code>by_chain = TRUE</code>, an <code><a href="base.html#topic+array">array</a></code> with chain-specific summaries as the third dimension is returned instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match_params">match_params()</a></code>, <code><a href="coda.html#topic+gelman.diag">coda::gelman.diag()</a></code>, <code><a href="coda.html#topic+effectiveSize">coda::effectiveSize()</a></code>, <code><a href="mcmcse.html#topic+mcse">mcmcse::mcse()</a></code>, <code><a href="mcmcse.html#topic+mcse.q">mcmcse::mcse.q()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# calculate posterior summaries for the "p" nodes
# ("p[1]" doesn't exist in model)
post_summ(cjs, "p")

# do this by chain
post_summ(cjs, "p", by_chain = TRUE)

# calculate Rhat and Neff diagnostic summaries as well
# multiple node names too
post_summ(cjs, c("b0", "p"), Rhat = TRUE, neff = TRUE)

# calculate Monte Carlo SE for mean and quantiles, with rounding
post_summ(cjs, "p", mcse = TRUE, digits = 3)

# summarize different quantiles: median and central 80%
post_summ(cjs, "p", probs = c(0.5, 0.1, 0.9))
</code></pre>

<hr>
<h2 id='post_thin'>Perform post-MCMC thinning</h2><span id='topic+post_thin'></span>

<h3>Description</h3>

<p>Removes iterations from each chain of a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
object at quasi-evenly spaced intervals. Post-MCMC thinning is useful for
developing long-running post-processing code with a smaller but otherwise identical <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_thin(post, keep_percent, keep_iters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_thin_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="post_thin_+3A_keep_percent">keep_percent</code></td>
<td>
<p>Proportion (between 0 and 1) of samples to keep from each chain.
Setting <code>keep_percent = 0.2</code> will remove approximately 80 percent of the samples.</p>
</td></tr>
<tr><td><code id="post_thin_+3A_keep_iters">keep_iters</code></td>
<td>
<p>Number of samples to keep from each chain.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The samples will be removed at as evenly spaced intervals
as possible, however, this is not perfect. It is therefore recommended
to use the full posterior for final post-processing calculations, but this should be fine for
most development of long-running code.
</p>
<p>If both <code>keep_percent</code> and <code>keep_iters</code> are supplied, an error will be returned requesting that only
one be used.
</p>


<h3>Value</h3>

<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object, identical to <code>post</code>, but with fewer samples of each node.
</p>


<h3>Note</h3>

<p>Iteration numbers are reset after thinning the samples. So if running <code><a href="#topic+post_dim">post_dim()</a></code>
on output passed through <code>post_thin()</code>, you cannot trust the burn-in or thinning counts.
Again, this is not an issue for developing post-processing code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# take note of original dimensions
post_dim(cjs)

# keep ~20% of the samples
cjs_thin1 = post_thin(cjs, keep_percent = 0.2)

# note burn-in and thin intervals no longer correct!
# but desired outcome achieved - identical object but smaller
post_dim(cjs_thin1)

# keep 30 samples per chain
cjs_thin2 = post_thin(cjs, keep_iters = 30)
post_dim(cjs_thin2)
</code></pre>

<hr>
<h2 id='postpack'>Utilities for Processing Posterior Samples Stored in mcmc.lists</h2><span id='topic+postpack'></span>

<h3>Description</h3>

<p>The aim of 'postpack' is to provide the infrastructure for a standardized workflow for <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> objects.
These objects can be used to store output from models fitted with Bayesian inference using
JAGS, Win/OpenBUGS, NIMBLE, Stan, or even custom MCMC algorithms (see <code><a href="#topic+post_convert">post_convert()</a></code> for converting samples to
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> format). Although the 'coda' package provides some methods for these objects,
it is somewhat limited in easily performing post-processing tasks for <strong>particular nodes</strong>.
Models are ever increasing in their complexity and the number of tracked nodes, and oftentimes
a user may wish to summarize/diagnose sampling behavior for only a small subset of nodes at a time for a particular question or figure.
Thus, many 'postpack' functions support performing tasks on a subset of nodes, where the subset is specified with regular expressions.
The functions in this package streamline the extraction, summarization, and diagnostics of particular nodes monitored after model fitting.
Further, because there is rarely only ever one model under consideration, 'postpack' scales efficiently to perform the same tasks on output from multiple models
simultaneously, facilitating rapid assessment of model sensitivity to changes in assumptions.
</p>

<hr>
<h2 id='rm_regex_bracket'>Remove escapes on regex brackets</h2><span id='topic+rm_regex_bracket'></span>

<h3>Description</h3>

<p>Remove escapes on regex brackets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_regex_bracket(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_regex_bracket_+3A_params">params</code></td>
<td>
<p>Node names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Searches the contents of a string for the occurrence of a
square bracket or two (that has been escaped), and removes the escaping
that was necessary for matching via regular expressions.
</p>


<h3>Value</h3>

<p>A character vector with all brackets escaped. For example,
<code style="white-space: pre;">&#8288;"a\\[1\\]"&#8288;</code> becomes <code>"a[1]"</code>.
</p>


<h3>Note</h3>

<p>This is <strong>not</strong> a function users will generally use directly.
</p>

<hr>
<h2 id='rm_regex_lock'>Remove the symbols that lock in a string for matching</h2><span id='topic+rm_regex_lock'></span>

<h3>Description</h3>

<p>Undoes the work of <code><a href="#topic+ins_regex_lock">ins_regex_lock()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_regex_lock(params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_regex_lock_+3A_params">params</code></td>
<td>
<p>Node names to remove a <code>^</code> and <code>$</code> from (if present).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with locking anchors inserted to force an exact match. For example,
<code style="white-space: pre;">&#8288;"^a\\[1\\]$"&#8288;</code> becomes <code style="white-space: pre;">&#8288;"a\\[1\\]"&#8288;</code>.
</p>


<h3>Note</h3>

<p>This is <strong>not</strong> a function users will generally use directly.
</p>

<hr>
<h2 id='trace_plot'>Create a trace plot for a single desired node</h2><span id='topic+trace_plot'></span>

<h3>Description</h3>

<p>Create a trace plot for a single desired node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trace_plot(post, param, keep_percent = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trace_plot_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="trace_plot_+3A_param">param</code></td>
<td>
<p>A regular expression that matches a single element in the model.
E.g., <code>"b0[1]"</code>, not <code>"b0"</code>. See <code><a href="#topic+match_params">match_params()</a></code>.</p>
</td></tr>
<tr><td><code id="trace_plot_+3A_keep_percent">keep_percent</code></td>
<td>
<p>A numeric vector of length == 1 and on the range (0,1].
Percent of samples you'd like to keep for trace plotting and passed to <code><a href="#topic+post_thin">post_thin()</a></code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If saving as a pdf file, these files can get very large with many samples and render slowly.
The <code>keep_percent</code> argument is intended to help with this by thinning the chains at quasi-evenly spaced intervals.
This is <strong>not</strong> a function users will generally use directly. Call <code><a href="#topic+diag_plots">diag_plots()</a></code> instead.
</p>

<hr>
<h2 id='vcov_decomp'>Decompose the posterior of a variance-covariance node</h2><span id='topic+vcov_decomp'></span>

<h3>Description</h3>

<p>For each posterior sample, extract the standard deviation and correlation components
of a monitored node representing a variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcov_decomp(
  post,
  param,
  sigma_base_name = "sigma",
  rho_base_name = "rho",
  invert = FALSE,
  check = TRUE,
  auto_escape = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov_decomp_+3A_post">post</code></td>
<td>
<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.</p>
</td></tr>
<tr><td><code id="vcov_decomp_+3A_param">param</code></td>
<td>
<p>A vector of regular expressions specifying the nodes to match for plotting.
Must match only one base node name in <code>post</code>, and that node must store samples from a matrix within the model.
See <code><a href="#topic+match_params">match_params()</a></code> and <code>vignette("pattern-matching")</code> for more details.</p>
</td></tr>
<tr><td><code id="vcov_decomp_+3A_sigma_base_name">sigma_base_name</code></td>
<td>
<p>Base node name to assign to the standard deviation vector component?
Defaults to <code>"sigma"</code>, which becomes <code>"sigma[1]"</code>, <code>"sigma[2]"</code>, etc. in the output.</p>
</td></tr>
<tr><td><code id="vcov_decomp_+3A_rho_base_name">rho_base_name</code></td>
<td>
<p>Same as <code>sigma_base_name</code>, but for the correlation matrix component.</p>
</td></tr>
<tr><td><code id="vcov_decomp_+3A_invert">invert</code></td>
<td>
<p>Take the inverse of the matrix node matched by <code>param</code>
prior to performing the calculations? This would be necessary if the matrix node was expressed as
a precision matrix as used in the BUGS language. Triggers a call to <code><a href="base.html#topic+solve">base::solve()</a></code>.</p>
</td></tr>
<tr><td><code id="vcov_decomp_+3A_check">check</code></td>
<td>
<p>Perform checks sequentially that the matrix node is (a) square, (b) symmetrical, and (c) positive definite
before proceeding with the calculations? If set to <code>FALSE</code>, unexpected output may be returned or
other errors related to items a, b, and c may be triggered - this is not advised, though may be required
if wishing to set <code>invert = TRUE</code>.</p>
</td></tr>
<tr><td><code id="vcov_decomp_+3A_auto_escape">auto_escape</code></td>
<td>
<p>Automatically escape <code>"["</code> and <code>"]"</code> characters for pattern matching?
See <code><a href="#topic+match_params">match_params()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example mcmc.list
data(cjs)

# "SIG" is a covariance matrix node
SIG_decomp = vcov_decomp(cjs, "SIG")

# extract the posterior mean correlation matrix, and reformat
array_format(post_summ(SIG_decomp, "rho")["mean",])
</code></pre>

<hr>
<h2 id='write_model'>Export BUGS/JAGS model from function to file</h2><span id='topic+write_model'></span>

<h3>Description</h3>

<p>Performs the same basic function as <code><a href="R2OpenBUGS.html#topic+write.model">R2OpenBUGS::write.model()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_model(fun, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_model_+3A_fun">fun</code></td>
<td>
<p>A function object containing BUGS/JAGS model code</p>
</td></tr>
<tr><td><code id="write_model_+3A_file">file</code></td>
<td>
<p>A character vector of length == 1: the name of the file to write to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs the same basic function as <code><a href="R2OpenBUGS.html#topic+write.model">R2OpenBUGS::write.model()</a></code>,
but with slightly better output (scientific notation, spacing, etc.). The main reason it was created
for use in 'postpack' was to remove the need for using the 'R2OpenBUGS' package when not using OpenBUGS.
</p>


<h3>Value</h3>

<p>Nothing, but <code>file</code> is written to disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  # define some simple BUGS model as an R function
  # note the use of %_% to include a truncation
  mod = function() {
    # PRIORS
    mu ~ dnorm(0,0.001) %_% T(0,)
    sig ~ dunif(0,10)
    tau &lt;- 1/sig^2

    # LIKELIHOOD
    for (i in 1:n) {
      y[i] ~ dnorm(mu, tau)
    }
  }

  # write model to a text file to be called by BUGS/JAGS
  write_model(mod, "model.txt")
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
