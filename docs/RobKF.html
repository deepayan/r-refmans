<!DOCTYPE html><html><head><title>Help for package RobKF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RobKF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AORKF_huber'><p>A huberisation based additive outlier robust Kalman filter</p></a></li>
<li><a href='#AORKF_t'><p>A t-distribution based additive outlier robust Kalman filter</p></a></li>
<li><a href='#Generate_Data'><p>Simulate data from a Kalman model</p></a></li>
<li><a href='#IOAORKF'><p>An innovative and additive outlier robust Kalman filter</p></a></li>
<li><a href='#IORKF_huber'><p>A huberisation based innovative outlier robust Kalman filter</p></a></li>
<li><a href='#KF'><p>The classical Kalman filter</p></a></li>
<li><a href='#plot'><p>plot</p></a></li>
<li><a href='#print'><p>print</p></a></li>
<li><a href='#summary'><p>Summary</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Innovative and/or Additive Outlier Robust Kalman Filtering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-07-15</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a series of robust Kalman filtering approaches. It implements the additive outlier robust filters of Ruckdeschel et al. (2014) &lt;<a href="https://doi.org/10.48550/arXiv.1204.3358">doi:10.48550/arXiv.1204.3358</a>&gt; and Agamennoni et al. (2018) &lt;<a href="https://doi.org/10.1109%2FICRA.2011.5979605">doi:10.1109/ICRA.2011.5979605</a>&gt;, the innovative outlier robust filter of Ruckdeschel et al. (2014) &lt;<a href="https://doi.org/10.48550/arXiv.1204.3358">doi:10.48550/arXiv.1204.3358</a>&gt;, as well as the innovative and additive outlier robust filter of Fisch et al. (2020) &lt;<a href="https://doi.org/10.48550/arXiv.2007.03238">doi:10.48550/arXiv.2007.03238</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.2), Rdpack, ggplot2, reshape2, Matrix</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-15 08:18:49 UTC; grosedj1</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex TM Fisch [aut],
  Daniel Grose [aut, cre],
  Idris A Eckley [aut, ths],
  Paul Fearnhead [aut, ths],
  Lawrence Bardwell [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Grose &lt;dan.grose@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-15 09:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AORKF_huber'>A huberisation based additive outlier robust Kalman filter</h2><span id='topic+AORKF_huber'></span>

<h3>Description</h3>

<p>An additive outlier robust Kalman filter, based on the work by Ruckdeschel et al. (2014).
This function assumes that the additions are potentially polluted by a heavy tailed process.
The update equations are made robust to these via huberisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AORKF_huber(
  Y,
  mu_0,
  Sigma_0 = NULL,
  A,
  C,
  Sigma_Add,
  Sigma_Inn,
  h = 2,
  epsilon = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AORKF_huber_+3A_y">Y</code></td>
<td>
<p>A list of matrices containing the observations to be filtered.</p>
</td></tr>
<tr><td><code id="AORKF_huber_+3A_mu_0">mu_0</code></td>
<td>
<p>A matrix indicating the mean of the prior for the hidden states.</p>
</td></tr>
<tr><td><code id="AORKF_huber_+3A_sigma_0">Sigma_0</code></td>
<td>
<p>A matrix indicating the variance of the prior for the hidden states. It defaults to the limit of the variance of the Kalman filter.</p>
</td></tr>
<tr><td><code id="AORKF_huber_+3A_a">A</code></td>
<td>
<p>A matrix giving the updates for the hidden states.</p>
</td></tr>
<tr><td><code id="AORKF_huber_+3A_c">C</code></td>
<td>
<p>A matrix mapping the hidden states to the observed states.</p>
</td></tr>
<tr><td><code id="AORKF_huber_+3A_sigma_add">Sigma_Add</code></td>
<td>
<p>A positive definite matrix giving the additive noise covariance.</p>
</td></tr>
<tr><td><code id="AORKF_huber_+3A_sigma_inn">Sigma_Inn</code></td>
<td>
<p>A positive definite matrix giving the innovative noise covariance.</p>
</td></tr>
<tr><td><code id="AORKF_huber_+3A_h">h</code></td>
<td>
<p>A numeric giving the huber threshold. It defaults to 2.</p>
</td></tr>
<tr><td><code id="AORKF_huber_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive numeric giving the precision to which the limit of the covariance is to be computed. It defaults to 0.000001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rkf S3 class.
</p>


<h3>References</h3>

<p>Ruckdeschel P, Spangl B, Pupashenko D (2014).
&ldquo;Robust Kalman tracking and smoothing with propagating and non-propagating outliers.&rdquo;
<em>Statistical Papers</em>, <b>55</b>(1), 93&ndash;123.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RobKF)

set.seed(2019)

A = matrix(c(1), nrow = 1, ncol = 1)
C = matrix(c(1), nrow = 1, ncol = 1)

Sigma_Inn = diag(1,1)*0.01
Sigma_Add = diag(1,1)

mu_0 = matrix(0,nrow=1,ncol=1)

Y_list = Generate_Data(1000,A,C,Sigma_Add,Sigma_Inn,mu_0,anomaly_loc = c(100,400,700),
                       anomaly_type = c("Add","Add","Add"),anomaly_comp = c(1,1,1),
                       anomaly_strength = c(10,10,10))

Output = AORKF_huber(Y_list,mu_0,Sigma_0=NULL,A,C,Sigma_Add,Sigma_Inn)

plot(Output,conf_level = 0.9999)

</code></pre>

<hr>
<h2 id='AORKF_t'>A t-distribution based additive outlier robust Kalman filter</h2><span id='topic+AORKF_t'></span>

<h3>Description</h3>

<p>An additive outlier robust Kalman filter, based on the work by Agamennoni et al. (2018).
This function assumes that the additions are potentially polluted by a heavy tailed process, which is approximated by a t-distribution.
Variational inference is used to approximate the posterior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AORKF_t(
  Y,
  mu_0,
  Sigma_0 = NULL,
  A,
  C,
  Sigma_Add,
  Sigma_Inn,
  s = 2,
  epsilon = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AORKF_t_+3A_y">Y</code></td>
<td>
<p>A list of matrices containing the observations to be filtered.</p>
</td></tr>
<tr><td><code id="AORKF_t_+3A_mu_0">mu_0</code></td>
<td>
<p>A matrix indicating the mean of the prior for the hidden states.</p>
</td></tr>
<tr><td><code id="AORKF_t_+3A_sigma_0">Sigma_0</code></td>
<td>
<p>A matrix indicating the Variance of the prior for the hidden states. It defaults to the limit of the variance of the Kalman filter.</p>
</td></tr>
<tr><td><code id="AORKF_t_+3A_a">A</code></td>
<td>
<p>A matrix giving the updates for the hidden states.</p>
</td></tr>
<tr><td><code id="AORKF_t_+3A_c">C</code></td>
<td>
<p>A matrix mapping the hidden states to the observed states.</p>
</td></tr>
<tr><td><code id="AORKF_t_+3A_sigma_add">Sigma_Add</code></td>
<td>
<p>A positive definite matrix giving the additive noise covariance.</p>
</td></tr>
<tr><td><code id="AORKF_t_+3A_sigma_inn">Sigma_Inn</code></td>
<td>
<p>A positive definite matrix giving the innovative noise covariance.</p>
</td></tr>
<tr><td><code id="AORKF_t_+3A_s">s</code></td>
<td>
<p>A numeric giving the shape of the t-distribution to be considered. It defaults to 2.</p>
</td></tr>
<tr><td><code id="AORKF_t_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive numeric giving the precision to which the limit of the covariance, and the variational inferences is to be computed. It defaults to 0.000001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rkf S3 class.
</p>


<h3>References</h3>

<p>Agamennoni G, Nieto JI, Nebot EM (2011).
&ldquo;An outlier-robust Kalman filter.&rdquo;
In <em>2011 IEEE International Conference on Robotics and Automation</em>, 1551&ndash;1558.
IEEE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RobKF)

set.seed(2019)

A = matrix(c(1), nrow = 1, ncol = 1)
C = matrix(c(1), nrow = 1, ncol = 1)

Sigma_Inn = diag(1,1)*0.01
Sigma_Add = diag(1,1)

mu_0 = matrix(0,nrow=1,ncol=1)

Y_list = Generate_Data(1000,A,C,Sigma_Add,Sigma_Inn,mu_0,anomaly_loc = c(100,400,700),
                       anomaly_type = c("Add","Add","Add"),anomaly_comp = c(1,1,1),
                       anomaly_strength = c(10,10,10))

Output = AORKF_t(Y_list,mu_0,Sigma_0=NULL,A,C,Sigma_Add,Sigma_Inn)

plot(Output,conf_level = 0.9999)

</code></pre>

<hr>
<h2 id='Generate_Data'>Simulate data from a Kalman model</h2><span id='topic+Generate_Data'></span>

<h3>Description</h3>

<p>This function simulates data obeying a Kalman model whilst allowing the user to add innovative and additive anomalies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Generate_Data(
  n,
  A,
  C,
  Sigma_Add,
  Sigma_Inn,
  mu_0 = NULL,
  anomaly_loc = integer(0),
  anomaly_type = character(0),
  anomaly_comp = integer(0),
  anomaly_strength = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Generate_Data_+3A_n">n</code></td>
<td>
<p>A positive integer giving the number of observations desired</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_a">A</code></td>
<td>
<p>A matrix giving the updates for the hidden states.</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_c">C</code></td>
<td>
<p>A matrix mapping the hidden states to the observed states.</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_sigma_add">Sigma_Add</code></td>
<td>
<p>A positive definite diagonal matrix giving the additive noise covariance.</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_sigma_inn">Sigma_Inn</code></td>
<td>
<p>A positive definite diagonal matrix giving the innovative noise covariance.</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_mu_0">mu_0</code></td>
<td>
<p>A matrix indicating the mean of the prior for the hidden states. It defaults to a zero-vector.</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_anomaly_loc">anomaly_loc</code></td>
<td>
<p>A vector of integers giving the locations of anomalies.</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_anomaly_type">anomaly_type</code></td>
<td>
<p>A vector of strings, either &quot;Add&quot; or &quot;Inn&quot; indicating whether the anomaly is additive or innovative.</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_anomaly_comp">anomaly_comp</code></td>
<td>
<p>A vector of integers giving the component affected by the anomalies.</p>
</td></tr>
<tr><td><code id="Generate_Data_+3A_anomaly_strength">anomaly_strength</code></td>
<td>
<p>A vector of numerics giving the strength of the anomalies (in sigmas).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices, each corresponding to an observation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RobKF)
library(ggplot2)

set.seed(2018)

A = diag(2)*0.99
A[1,2] = -0.05
C = matrix(c(10,0.1),nrow=1)
mu = matrix(c(0,0),nrow=2)
Sigma_Inn = diag(c(1,0.01)*0.00001,nrow=2)
Sigma_Add = diag(c(1)*0.1,nrow=1)

Y_list = Generate_Data(100,A,C,Sigma_Add,Sigma_Inn, mu_0 = mu,  anomaly_loc = c(10,30,50), 
                      anomaly_type = c("Inn","Add","Inn"), 
                      anomaly_comp = c(1,1,2),  anomaly_strength = c(400,-10,3000))
                      
qplot(1:100,unlist(Y_list),xlab="time",ylab="observation")+theme_minimal()


</code></pre>

<hr>
<h2 id='IOAORKF'>An innovative and additive outlier robust Kalman filter</h2><span id='topic+IOAORKF'></span>

<h3>Description</h3>

<p>An implementation of Computationally Efficient Bayesian Anomaly detection by Sequential Sampling (CE-BASS) by Fisch et al. (2020).
This function assumes that both the innovations and additions are potentially polluted by a heavy tailed process, which is approximated by a t-distribution.
To approximate the posterior, particles for the precision (inverse variance) are sampled using a robust approximation to the posterior. Conditionally on those samples, the classical Kalman updates are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IOAORKF(
  Y,
  mu_0,
  Sigma_0 = NULL,
  A,
  C,
  Sigma_Add,
  Sigma_Inn,
  Particles,
  Descendants = 1,
  s = 2,
  anom_add_prob = NULL,
  anom_inn_prob = NULL,
  epsilon = 1e-06,
  horizon_matrix = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IOAORKF_+3A_y">Y</code></td>
<td>
<p>A list of matrices containing the observations to be filtered.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_mu_0">mu_0</code></td>
<td>
<p>A matrix indicating the mean of the prior for the hidden states.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_sigma_0">Sigma_0</code></td>
<td>
<p>A matrix indicating the variance of the prior for the hidden states. It defaults to the limit of the variance of the Kalman filter.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_a">A</code></td>
<td>
<p>A matrix giving the updates for the hidden states.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_c">C</code></td>
<td>
<p>A matrix mapping the hidden states to the observed states.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_sigma_add">Sigma_Add</code></td>
<td>
<p>A positive definite diagonal matrix giving the additive noise covariance.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_sigma_inn">Sigma_Inn</code></td>
<td>
<p>A positive definite diagonal matrix giving the innovative noise covariance.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_particles">Particles</code></td>
<td>
<p>An integer giving the number of particles to be maintained at each step. More particles lead to more accuracy, but also require more memory and CPU time. The parameter should be at least p + q + 1, where p s the dimension of the observations and q the dimension of the hidden states.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_descendants">Descendants</code></td>
<td>
<p>An integer giving the number of descendants to be sampled for each of the possible anomalies. Increasing Descendants leads to higher accuracy but also higher memory and CPU requirements. The default value is 1.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_s">s</code></td>
<td>
<p>A numeric giving the shape of the t-distribution to be considered. It defaults to 2.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_anom_add_prob">anom_add_prob</code></td>
<td>
<p>A vector of probabilities with length equal to the dimension of the observations giving the probabilities of additive outliers in each of the components. It defaults to 1/10000.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_anom_inn_prob">anom_inn_prob</code></td>
<td>
<p>A vector of probabilities with length equal to the dimension of the hidden state giving the probabilities of innovative outliers in each of the components. It defaults to 1/10000.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive numeric giving the precision to which the limit of the covariance is to be computed. It defaults to 0.000001.</p>
</td></tr>
<tr><td><code id="IOAORKF_+3A_horizon_matrix">horizon_matrix</code></td>
<td>
<p>A matrix of 0s and 1s giving the horizon's at which innovative particles are to be resampled. It defaults to a k by q matrix, where k is the number of observations required for observability of the system and q is the dimension of the hidden states.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An ioaorkf S3 class.
</p>


<h3>References</h3>

<p>Fisch A, Eckley IA, Fearnhead P (2020).
&ldquo;Innovative And Additive Outlier Robust Kalman Filtering With A Robust Particle Filter.&rdquo;
<em>arXiv preprint arXiv:2007.03238</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RobKF)

set.seed(2018)

A = diag(2)*0.99
A[1,2] = -0.05
C = matrix(c(10,0.1),nrow=1)
mu = matrix(c(0,0),nrow=2)
Sigma_Inn = diag(c(1,0.01)*0.00001,nrow=2)
Sigma_Add = diag(c(1)*0.1,nrow=1)

Y_list = Generate_Data(100,A,C,Sigma_Add,Sigma_Inn, mu_0 = mu,  anomaly_loc = c(10,30,50), 
                      anomaly_type = c("Inn","Add","Inn"), 
                      anomaly_comp = c(1,1,2),  anomaly_strength = c(400,-10,3000))
                      
horizon_matrix = matrix(1,nrow = 3 ,ncol = 2)

Particle_List = IOAORKF(Y_list,mu,Sigma_0=NULL,A,C,Sigma_Add,Sigma_Inn,Particles=20,
                        horizon_matrix=horizon_matrix)

plot(Particle_List)
summary(Particle_List)


</code></pre>

<hr>
<h2 id='IORKF_huber'>A huberisation based innovative outlier robust Kalman filter</h2><span id='topic+IORKF_huber'></span>

<h3>Description</h3>

<p>An innovative outlier robust Kalman filter, based on the work by Ruckdeschel et al. (2014).
This function assumes that the innovations are potentially polluted by a heavy tailed process.
The update equations are made robust to these via huberisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IORKF_huber(
  Y,
  mu_0,
  Sigma_0 = NULL,
  A,
  C,
  Sigma_Add,
  Sigma_Inn,
  h = 2,
  epsilon = 1e-06
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IORKF_huber_+3A_y">Y</code></td>
<td>
<p>A list of matrices containing the observations to be filtered.</p>
</td></tr>
<tr><td><code id="IORKF_huber_+3A_mu_0">mu_0</code></td>
<td>
<p>A matrix indicating the mean of the prior for the hidden states.</p>
</td></tr>
<tr><td><code id="IORKF_huber_+3A_sigma_0">Sigma_0</code></td>
<td>
<p>A matrix indicating the variance of the prior for the hidden states. It defaults to the limit of the variance of the Kalman filter.</p>
</td></tr>
<tr><td><code id="IORKF_huber_+3A_a">A</code></td>
<td>
<p>A matrix giving the updates for the hidden states.</p>
</td></tr>
<tr><td><code id="IORKF_huber_+3A_c">C</code></td>
<td>
<p>A matrix mapping the hidden states to the observed states.</p>
</td></tr>
<tr><td><code id="IORKF_huber_+3A_sigma_add">Sigma_Add</code></td>
<td>
<p>A positive definite matrix giving the additive noise covariance.</p>
</td></tr>
<tr><td><code id="IORKF_huber_+3A_sigma_inn">Sigma_Inn</code></td>
<td>
<p>A positive definite matrix giving the innovative noise covariance.</p>
</td></tr>
<tr><td><code id="IORKF_huber_+3A_h">h</code></td>
<td>
<p>A numeric giving the huber threshold. It defaults to 2.</p>
</td></tr>
<tr><td><code id="IORKF_huber_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive numeric giving the precision to which the limit of the covariance is to be computed. It defaults to 0.000001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rkf S3 class.
</p>


<h3>References</h3>

<p>Ruckdeschel P, Spangl B, Pupashenko D (2014).
&ldquo;Robust Kalman tracking and smoothing with propagating and non-propagating outliers.&rdquo;
<em>Statistical Papers</em>, <b>55</b>(1), 93&ndash;123.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RobKF)

set.seed(2019)

A = matrix(c(1), nrow = 1, ncol = 1)
C = matrix(c(1), nrow = 1, ncol = 1)

Sigma_Inn = diag(1,1)*0.01
Sigma_Add = diag(1,1)

mu_0 = matrix(0,nrow=1,ncol=1)

Y_list = Generate_Data(1000,A,C,Sigma_Add,Sigma_Inn,mu_0,anomaly_loc = c(100,400,700),
                       anomaly_type = c("Inn","Inn","Inn"),anomaly_comp = c(1,1,1),
                       anomaly_strength = c(50,80,-100))

Output = IORKF_huber(Y_list,mu_0,Sigma_0=NULL,A,C,Sigma_Add,Sigma_Inn,h=2)

plot(Output,conf_level = 0.9999)

</code></pre>

<hr>
<h2 id='KF'>The classical Kalman filter</h2><span id='topic+KF'></span>

<h3>Description</h3>

<p>The classical Kalman filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KF(Y, mu_0, Sigma_0 = NULL, A, C, Sigma_Add, Sigma_Inn, epsilon = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KF_+3A_y">Y</code></td>
<td>
<p>A list of matrices containing the observations to be filtered.</p>
</td></tr>
<tr><td><code id="KF_+3A_mu_0">mu_0</code></td>
<td>
<p>A matrix indicating the mean of the prior for the hidden states.</p>
</td></tr>
<tr><td><code id="KF_+3A_sigma_0">Sigma_0</code></td>
<td>
<p>A matrix indicating the variance of the prior for the hidden states. It defaults to the limit of the variance of the Kalman filter.</p>
</td></tr>
<tr><td><code id="KF_+3A_a">A</code></td>
<td>
<p>A matrix giving the updates for the hidden states.</p>
</td></tr>
<tr><td><code id="KF_+3A_c">C</code></td>
<td>
<p>A matrix mapping the hidden states to the observed states.</p>
</td></tr>
<tr><td><code id="KF_+3A_sigma_add">Sigma_Add</code></td>
<td>
<p>A positive definite matrix giving the additive noise covariance.</p>
</td></tr>
<tr><td><code id="KF_+3A_sigma_inn">Sigma_Inn</code></td>
<td>
<p>A positive definite matrix giving the innovative noise covariance.</p>
</td></tr>
<tr><td><code id="KF_+3A_epsilon">epsilon</code></td>
<td>
<p>A positive numeric giving the precision to which the limit of the covariance is to be computed. It defaults to 0.000001.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rkf S3 class.
</p>


<h3>References</h3>

<p>Kalman RE (1960).
&ldquo;A New Approach to Linear Filtering and Prediction Problems.&rdquo;
<em>Transactions of the ASME&ndash;Journal of Basic Engineering</em>, <b>82</b>(Series D), 35&ndash;45.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RobKF)

set.seed(2019)

A = matrix(c(1), nrow = 1, ncol = 1)
C = matrix(c(1), nrow = 1, ncol = 1)

Sigma_Inn = diag(1,1)*0.01
Sigma_Add = diag(1,1)

mu_0 = matrix(0,nrow=1,ncol=1)

Y_list = Generate_Data(1000,A,C,Sigma_Add,Sigma_Inn,mu_0)

Output = KF(Y_list,mu_0,Sigma_0=NULL,A,C,Sigma_Add,Sigma_Inn)

plot(Output)

</code></pre>

<hr>
<h2 id='plot'>plot</h2><span id='topic+plot'></span><span id='topic+plot.ioaorkf'></span><span id='topic+plot.rkf'></span>

<h3>Description</h3>

<p>A function to plot the output produced by <code><a href="#topic+AORKF_t">AORKF_t</a></code>, <code><a href="#topic+AORKF_huber">AORKF_huber</a></code>, <code><a href="#topic+IORKF_huber">IORKF_huber</a></code> or <code><a href="#topic+IOAORKF">IOAORKF</a></code>.
One can specify a time during the run for which the output should be displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ioaorkf'
plot(x, time = NULL, horizon = NULL, subset = NULL, ...)

## S3 method for class 'rkf'
plot(x, time = NULL, subset = NULL, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>An instance of an <code>ioaorkf</code> or <code>rkf</code> S3 class.</p>
</td></tr>
<tr><td><code id="plot_+3A_time">time</code></td>
<td>
<p>A positive integer giving the time at which the output is to be displayed. It defaults to the number of observations.</p>
</td></tr>
<tr><td><code id="plot_+3A_horizon">horizon</code></td>
<td>
<p>A positive integer giving the smoothing horizon that is to be used. It must be at least equal to the number of rows of the horizonmatrix used to obtain the ioaorkf object.</p>
</td></tr>
<tr><td><code id="plot_+3A_subset">subset</code></td>
<td>
<p>A list of integers indicating the components of observations which are to be plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="plot_+3A_conf_level">conf_level</code></td>
<td>
<p>A probability between 0 and 1 giving the confidence level at which the series are to be tested against anomalies. It defaults to 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>

<hr>
<h2 id='print'>print</h2><span id='topic+print'></span><span id='topic+print.ioaorkf'></span><span id='topic+print.rkf'></span>

<h3>Description</h3>

<p>A function to print the output produced by <code><a href="#topic+AORKF_t">AORKF_t</a></code>, <code><a href="#topic+AORKF_huber">AORKF_huber</a></code>, <code><a href="#topic+IORKF_huber">IORKF_huber</a></code> or <code><a href="#topic+IOAORKF">IOAORKF</a></code>.
One can specify a time during the run for which the output should be displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ioaorkf'
print(x, time = NULL, horizon = NULL, ...)

## S3 method for class 'rkf'
print(x, time = NULL, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>An instance of an <code>ioaorkf</code> or <code>rkf</code> S3 class.</p>
</td></tr>
<tr><td><code id="print_+3A_time">time</code></td>
<td>
<p>A positive integer giving the time at which the output is to be displayed. It defaults to the number of observations.</p>
</td></tr>
<tr><td><code id="print_+3A_horizon">horizon</code></td>
<td>
<p>A positive integer giving the smoothing horizon that is to be used. It must be at least equal to the number of rows of the horizonmatrix used to obtain the ioaorkf object.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="print_+3A_conf_level">conf_level</code></td>
<td>
<p>A probability between 0 and 1 giving the confidence level at which the series are to be tested against anomalies. It defaults to 0.95.</p>
</td></tr>
</table>

<hr>
<h2 id='summary'>Summary</h2><span id='topic+summary'></span><span id='topic+summary.ioaorkf'></span><span id='topic+summary.rkf'></span>

<h3>Description</h3>

<p>A function to summarise the output produced by <code><a href="#topic+AORKF_t">AORKF_t</a></code>, <code><a href="#topic+AORKF_huber">AORKF_huber</a></code>, <code><a href="#topic+IORKF_huber">IORKF_huber</a></code>, or <code><a href="#topic+IOAORKF">IOAORKF</a></code>.
One can specify a time during the run for which the output should be displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ioaorkf'
summary(object, time = NULL, horizon = NULL, ...)

## S3 method for class 'rkf'
summary(object, time = NULL, conf_level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>An instance of an <code>ioaorkf</code> or <code>rkf</code> S3 class.</p>
</td></tr>
<tr><td><code id="summary_+3A_time">time</code></td>
<td>
<p>A positive integer giving the time at which the output is to be displayed. It defaults to the number of observations.</p>
</td></tr>
<tr><td><code id="summary_+3A_horizon">horizon</code></td>
<td>
<p>A positive integer giving the smoothing horizon that is to be used. It must be at least equal to the number of rows of the horizonmatrix used to obtain the ioaorkf object.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="summary_+3A_conf_level">conf_level</code></td>
<td>
<p>A probability between 0 and 1 giving the confidence level at which the series are to be tested against anomalies. It defaults to 0.95.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
