<!DOCTYPE html><html lang="en"><head><title>Help for package geepack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geepack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compCoef'><p>Compare Regression Coefficiente between Nested Models</p></a></li>
<li><a href='#dietox'><p>Growth curves of pigs in a 3x3 factorial experiment</p></a></li>
<li><a href='#fixed2Zcor'><p>Construct zcor vector</p></a></li>
<li><a href='#geeglm'><p>Fit Generalized Estimating Equations (GEE)</p></a></li>
<li><a href='#geepack-internal'><p>Internal functions for the geepack package</p></a></li>
<li><a href='#geese'><p>Function to fit a Generalized Estimating Equation Model</p></a></li>
<li><a href='#geese.control'><p>Auxiliary for Controlling GEE Fitting</p></a></li>
<li><a href='#genZcor'><p>genZcor</p></a></li>
<li><a href='#koch'><p>Ordinal Data from Koch</p></a></li>
<li><a href='#muscatine'><p>Data on Obesity from the Muscatine Coronary Risk Factor Study.</p></a></li>
<li><a href='#ohio'><p>Ohio Children Wheeze Status</p></a></li>
<li><a href='#ordgee'><p>GEE for Clustered Ordinal Responses</p></a></li>
<li><a href='#QIC.geeglm'><p>Quasi Information Criterion</p></a></li>
<li><a href='#relRisk'><p>Fit a Relative Risk Model for Binary data with Log Link</p></a></li>
<li><a href='#respdis'><p>Clustered Ordinal Respiratory Disorder</p></a></li>
<li><a href='#respiratory'><p>Data from a clinical trial comparing two treatments for a respiratory</p>
illness</a></li>
<li><a href='#seizure'><p>Epiliptic Seizures</p></a></li>
<li><a href='#sitka89'><p>Growth of Sitka Spruce Trees</p></a></li>
<li><a href='#spruce'><p>Log-size of 79 Sitka spruce trees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.3.12</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Estimating Equation Package</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Søren Højsgaard &lt;sorenh@math.aau.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generalized estimating equations solver for parameters in
    mean, scale, and correlation structures, through mean link,
    scale link, and correlation link. Can also handle clustered
    categorical responses. See e.g. Halekoh and Højsgaard, (2005,
    &lt;<a href="https://doi.org/10.18637%2Fjss.v015.i02">doi:10.18637/jss.v015.i02</a>&gt;), for details. </td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, broom, magrittr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-23 07:43:13 UTC; sorenh</td>
</tr>
<tr>
<td>Author:</td>
<td>Søren Højsgaard [aut, cre, cph],
  Ulrich Halekoh [aut, cph],
  Jun Yan [aut, cph],
  Claus Thorn Ekstrøm [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-23 09:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='compCoef'>Compare Regression Coefficiente between Nested Models</h2><span id='topic+compCoef'></span>

<h3>Description</h3>

<p>Comparing regression coefficients between models when one model is nested
within another for clustered data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compCoef(fit0, fit1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compCoef_+3A_fit0">fit0</code></td>
<td>
<p>a fitted object of class <code>geese</code></p>
</td></tr>
<tr><td><code id="compCoef_+3A_fit1">fit1</code></td>
<td>
<p>another fitted object of class <code>geese</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two components: </p>
<table role = "presentation">
<tr><td><code>delta</code></td>
<td>
<p>estimated difference
in the coefficients of common covariates from <code>fit0</code> and
<code>fit1</code></p>
</td></tr> <tr><td><code>variance</code></td>
<td>
<p>estimated variance matrix of
delta</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jun Yan <a href="mailto:jyan.stat@gmail.com">jyan.stat@gmail.com</a>
</p>


<h3>References</h3>

<p>Allison, P. D. (1995). The impact of random predictors
on comparisons of coefficients between models: Comment on
Clogg, Petkova, and Haritou.  <em>American Journal of
Sociology</em>, <b>100</b>(5), 1294&ndash;1305.
</p>
<p>Clogg, C. C., Petkova, E., and Haritou, A. (1995). Statistical methods for
comparing regression coefficients between models.  <em>American Journal of
Sociology</em>, <b>100</b>(5), 1261&ndash;1293.
</p>
<p>Yan, J., Aseltine, R., and Harel, O. (2011). Comparing Regression
Coefficients Between Nested Linear Models for Clustered Data with
Generalized Estimating Equations. <em>Journal of Educational and
Behaviorial Statistics</em>, Forthcoming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate clustered data
gendat &lt;- function(ncl, clsz) {
## ncl: number of clusters
## clsz: cluster size (all equal)
  id &lt;- rep(1:ncl, each = clsz)
  visit &lt;- rep(1:clsz, ncl)
  n &lt;- ncl * clsz
  x1 &lt;- rbinom(n, 1, 0.5) ## within cluster varying binary covariate
  x2 &lt;- runif(n, 0, 1)   ## within cluster varying continuous covariate
  ## the true correlation coefficient rho for an ar(1)
  ## correlation structure is 2/3
  rho &lt;- 2/3
  rhomat &lt;- rho ^ outer(1:4, 1:4, function(x, y) abs(x - y))
  chol.u &lt;- chol(rhomat)
  noise &lt;- as.vector(sapply(1:ncl, function(x) chol.u %*% rnorm(clsz)))
  y &lt;- 1 + 3 * x1 - 2 * x2 + noise
  dat &lt;- data.frame(y, id, visit, x1, x2)
  dat
}

simdat &lt;- gendat(100, 4)
fit0 &lt;- geese(y ~ x1, id = id, data = simdat, corstr = "un")
fit1 &lt;- geese(y ~ x1 + x2, id = id, data = simdat, corstr = "un")
compCoef(fit0, fit1)

</code></pre>

<hr>
<h2 id='dietox'>Growth curves of pigs in a 3x3 factorial experiment</h2><span id='topic+dietox'></span>

<h3>Description</h3>

<p>The <code>dietox</code> data frame has 861 rows and 7 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dietox
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Weight</dt><dd><p>Weight in Kg</p>
</dd>
<dt>Feed</dt><dd><p>Cumulated feed intake in Kg</p>
</dd>
<dt>Time</dt><dd><p>Time (in weeks) in the experiment</p>
</dd>
<dt>Pig</dt><dd><p>Factor; id of each pig</p>
</dd>
<dt>Evit</dt><dd><p>Factor; vitamin E dose; see 'details'.</p>
</dd>
<dt>Cu</dt><dd><p>Factor, copper dose; see 'details'</p>
</dd>
<dt>Start</dt><dd><p>Start weight in experiment, i.e. weight at week 1.</p>
</dd>
<dt>Litter</dt><dd><p>Factor, id of litter of each pig</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data contains weight of slaughter pigs measured weekly for 12
weeks. Data also contains the startweight (i.e. the weight at week
1). The treatments are 3 different levels of Evit = vitamin E (dose: 0,
100, 200 mg dl-alpha-tocopheryl acetat /kg feed) in combination with 3
different levels of Cu=copper (dose: 0, 35, 175 mg/kg feed) in the feed.
The cumulated feed intake is also recorded. The pigs are littermates.
</p>


<h3>Source</h3>

<p>Lauridsen, C., Højsgaard, S.,Sørensen, M.T. C. (1999) Influence of
Dietary Rapeseed Oli, Vitamin E, and Copper on Performance and
Antioxidant and Oxidative Status of Pigs. J. Anim. Sci.77:906-916
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dietox)
head(dietox)
## Not run: 
if (require(ggplot2)){
  qplot(Time, Weight, data=dietox, col=Pig) + geom_line() +
        theme(legend.position = "none") + facet_grid(Evit~Cu)
} else {
  coplot(Weight ~ Time | Evit * Cu, data=dietox)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='fixed2Zcor'>Construct zcor vector</h2><span id='topic+fixed2Zcor'></span>

<h3>Description</h3>

<p>Construct zcor vector (of fixed correlations) from a fixed
working correlation matrix, a specification of clusters and a
specifcation of waves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixed2Zcor(cor.fixed, id, waves)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixed2Zcor_+3A_cor.fixed">cor.fixed</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="fixed2Zcor_+3A_id">id</code></td>
<td>
<p>Clusters</p>
</td></tr>
<tr><td><code id="fixed2Zcor_+3A_waves">waves</code></td>
<td>
<p>Vector giving the ordering of observations within clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector which can be passed as the zcor argument to geeglm.
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genZcor">genZcor</a></code>, <code><a href="#topic+geeglm">geeglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
timeorder &lt;- rep(1:5, 6)
tvar      &lt;- timeorder + rnorm(length(timeorder))
idvar &lt;- rep(1:6, each=5)
uuu   &lt;- rep(rnorm(6), each=5)
yvar  &lt;- 1 + 2*tvar + uuu + rnorm(length(tvar))
simdat &lt;- data.frame(idvar, timeorder, tvar, yvar)
head(simdat,12)

simdatPerm &lt;- simdat[sample(nrow(simdat)),]
simdatPerm &lt;- simdatPerm[order(simdatPerm$idvar),]
head(simdatPerm)

cor.fixed &lt;- matrix(c(1    , 0.5  , 0.25,  0.125, 0.125,
                      0.5  , 1    , 0.25,  0.125, 0.125,
                      0.25 , 0.25 , 1   ,  0.5  , 0.125,
                      0.125, 0.125, 0.5  , 1    , 0.125,
                      0.125, 0.125, 0.125, 0.125, 1     ), nrow=5, ncol=5)
cor.fixed

zcor &lt;- fixed2Zcor(cor.fixed, id=simdatPerm$idvar, waves=simdatPerm$timeorder)
zcor

mod4 &lt;- geeglm(yvar~tvar, id=idvar, data=simdatPerm, corstr="fixed", zcor=zcor)
mod4

</code></pre>

<hr>
<h2 id='geeglm'>Fit Generalized Estimating Equations (GEE)</h2><span id='topic+geeglm'></span>

<h3>Description</h3>

<p>The geeglm function fits generalized estimating equations using
the 'geese.fit' function of the 'geepack' package for doing the actual
computations. geeglm has a syntax similar to glm and returns an object
similar to a glm object.  An important feature of geeglm, is that an
anova method exists for these models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geeglm(
  formula,
  family = gaussian,
  data = parent.frame(),
  weights,
  subset,
  na.action,
  start = NULL,
  etastart,
  mustart,
  offset,
  control = geese.control(...),
  method = "glm.fit",
  contrasts = NULL,
  id,
  waves = NULL,
  zcor = NULL,
  corstr = "independence",
  scale.fix = FALSE,
  scale.value = 1,
  std.err = "san.se",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geeglm_+3A_formula">formula</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_family">family</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_data">data</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_weights">weights</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_subset">subset</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_na.action">na.action</code></td>
<td>
<p>No action is taken. Indeed geeglm only works on complete
data.</p>
</td></tr>
<tr><td><code id="geeglm_+3A_start">start</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_etastart">etastart</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_mustart">mustart</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_offset">offset</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_control">control</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_method">method</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_contrasts">contrasts</code></td>
<td>
<p>See corresponding documentation to <code>glm</code></p>
</td></tr>
<tr><td><code id="geeglm_+3A_id">id</code></td>
<td>
<p>a vector which identifies the clusters.  The length of
&lsquo;id&rsquo; should be the same as the number of observations.  Data
are assumed to be sorted so that observations on each cluster
appear as contiguous rows in data. If data is not sorted this
way, the function will not identify the clusters correctly. If
data is not sorted this way, a warning will be issued. Please
consult the package vignette for details.</p>
</td></tr>
<tr><td><code id="geeglm_+3A_waves">waves</code></td>
<td>
<p>Wariable specifying the ordering of repeated
mesurements on the same unit.  Also used in connection with
missing values. Please consult the package vignette for details.</p>
</td></tr>
<tr><td><code id="geeglm_+3A_zcor">zcor</code></td>
<td>
<p>Used for entering a user defined working correlation
structure.</p>
</td></tr>
<tr><td><code id="geeglm_+3A_corstr">corstr</code></td>
<td>
<p>a character string specifying the correlation
structure. The following are permitted: '&quot;independence&quot;',
'&quot;exchangeable&quot;', '&quot;ar1&quot;', '&quot;unstructured&quot;' and '&quot;userdefined&quot;'</p>
</td></tr>
<tr><td><code id="geeglm_+3A_scale.fix">scale.fix</code></td>
<td>
<p>a logical variable; if true, the scale parameter
is fixed at the value of 'scale.value'.</p>
</td></tr>
<tr><td><code id="geeglm_+3A_scale.value">scale.value</code></td>
<td>
<p>numeric variable giving the value to which the
scale parameter should be fixed; used only if 'scale.fix =
TRUE'.</p>
</td></tr>
<tr><td><code id="geeglm_+3A_std.err">std.err</code></td>
<td>
<p>Type of standard error to be calculated. Defualt
'san.se' is the usual robust estimate.  Other options are
'jack': if approximate jackknife variance estimate should be
computed.  'j1s': if 1-step jackknife variance estimate should
be computed.  'fij': logical indicating if fully iterated
jackknife variance estimate should be computed.</p>
</td></tr>
<tr><td><code id="geeglm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case of corstr=&quot;fixed&quot; one must provide the zcor vector if
the clusters have unequal sizes. Clusters with size one must not be
represented in zcor.
</p>


<h3>Value</h3>

<p>An object of type 'geeglm'
</p>


<h3>Warning </h3>

<p>Use &quot;unstructured&quot; correlation structure only with great
care. (It may cause R to crash).
</p>


<h3>Note</h3>

<p>See the documentation for the 'geese' function for additional
information. geeglm only works for complete data. Thus if there are NA's
in data you can specify data=na.omit(mydata).
</p>


<h3>Author(s)</h3>

<p>Søren Højsgaard, <a href="mailto:sorenh@math.aau.dk">sorenh@math.aau.dk</a>
</p>


<h3>References</h3>

<p>Halekoh, U.; Højsgaard, S. and Yan, J (2006)
The R Package geepack for Generalized Estimating Equations.
Journal of Statistical Software, 15, 2, 1-11&quot;
</p>
<p>Liang, K.Y. and Zeger, S.L. (1986) Longitudinal data analysis using
generalized linear models. Biometrika, <em>73</em> 13-22.
</p>
<p>Prentice, R.L. and Zhao, L.P. (1991). Estimating equations for
parameters in means and covariances of multivariate discrete and
continuous responses.  Biometrics, <em>47</em> 825-839.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geese">geese</a></code>, <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+anova.geeglm">anova.geeglm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dietox)
dietox$Cu     &lt;- as.factor(dietox$Cu)
mf &lt;- formula(Weight ~ Cu * (Time + I(Time^2) + I(Time^3)))
gee1 &lt;- geeglm(mf, data=dietox, id=Pig, family=poisson("identity"), corstr="ar1")
gee1
coef(gee1)
vcov(gee1)
summary(gee1)
coef(summary(gee1))

mf2 &lt;- formula(Weight ~ Cu * Time + I(Time^2) + I(Time^3))
gee2 &lt;- geeglm(mf2, data=dietox, id=Pig, family=poisson("identity"), corstr="ar1")
anova(gee2)

# Notice the difference here: Clusters of observations must
# appear as chunks in data. 

set.seed(1)
chick1 &lt;- ChickWeight
chick2 &lt;- chick1[sample(nrow(chick1)),]
chick3 &lt;- chick2[order(chick2$Chick),]

fit1 &lt;- geeglm(weight~Time, id=Chick, data=chick1)
fit2 &lt;- geeglm(weight~Time, id=Chick, data=chick2)
fit3 &lt;- geeglm(weight~Time, id=Chick, data=chick3)

vcov(fit1)
vcov(fit2)
vcov(fit3)



</code></pre>

<hr>
<h2 id='geepack-internal'>Internal functions for the geepack package</h2><span id='topic+internal'></span><span id='topic+tidy'></span><span id='topic++25+3E+25'></span><span id='topic+crossutri'></span><span id='topic+genZodds'></span><span id='topic+anova.geeglm'></span><span id='topic+anovageePrim2'></span><span id='topic+anova.geeglmlist'></span><span id='topic+plot.geeglm'></span><span id='topic+print.geeglm'></span><span id='topic+eprint'></span><span id='topic+print.summary.geeglm'></span><span id='topic+residuals.geeglm'></span><span id='topic+summary.geeglm'></span><span id='topic+vcov.geeglm'></span>

<h3>Description</h3>

<p>Internal functions called by other functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossutri(wave)
genZodds(clusz, waves, corstrv, ncat)
</code></pre>


<h3>Details</h3>

<p>These are not to be called directly by the user.
</p>

<hr>
<h2 id='geese'>Function to fit a Generalized Estimating Equation Model</h2><span id='topic+geese'></span><span id='topic+geese.fit'></span><span id='topic+print.geese'></span><span id='topic+summary.geese'></span><span id='topic+print.summary.geese'></span>

<h3>Description</h3>

<p>Produces an object of class &lsquo;geese&rsquo; which is a Generalized Estimating
Equation fit of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geese(
  formula = formula(data),
  sformula = ~1,
  id,
  waves = NULL,
  data = parent.frame(),
  subset = NULL,
  na.action = na.omit,
  contrasts = NULL,
  weights = NULL,
  zcor = NULL,
  corp = NULL,
  control = geese.control(...),
  b = NULL,
  alpha = NULL,
  gm = NULL,
  family = gaussian(),
  mean.link = NULL,
  variance = NULL,
  cor.link = "identity",
  sca.link = "identity",
  link.same = TRUE,
  scale.fix = FALSE,
  scale.value = 1,
  corstr = "independence",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geese_+3A_formula">formula</code></td>
<td>
<p>a formula expression as for <code>glm</code>, of the form
<code>response ~ predictors</code>. See the documentation of lm and
formula for details. As for glm, this specifies the linear
predictor for modeling the mean. A term of the form
<code>offset(expression)</code> is allowed.</p>
</td></tr>
<tr><td><code id="geese_+3A_sformula">sformula</code></td>
<td>
<p>a formula expression of the form <code> ~
    predictor</code>, the response being ignored. This specifies the
linear predictor for modeling the dispersion. A term of the
form <code>offset(expression)</code> is allowed.</p>
</td></tr>
<tr><td><code id="geese_+3A_id">id</code></td>
<td>
<p>a vector which identifies the clusters.  The length of
&lsquo;id&rsquo; should be the same as the number of observations.  Data
are assumed to be sorted so that observations on a cluster are
contiguous rows for all entities in the formula.</p>
</td></tr>
<tr><td><code id="geese_+3A_waves">waves</code></td>
<td>
<p>an integer vector which identifies components in
clusters. The length of <code>waves</code> should be the same as the
number of observation.  components with the same <code>waves</code>
value will have the same link functions.</p>
</td></tr>
<tr><td><code id="geese_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to interpret the
variables occurring in the <code>formula</code>, along with the
<code>id</code> and <code>n</code> variables.</p>
</td></tr>
<tr><td><code id="geese_+3A_subset">subset</code></td>
<td>
<p>expression saying which subset of the rows of the
data should be used in the fit.  This can be a logical vector
(which is replicated to have length equal to the number of
observations), or a numeric vector indicating which observation
numbers are to be included, or a character vector of the row
names to be included.  All observations are included by
default.</p>
</td></tr>
<tr><td><code id="geese_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data.  For <code>gee</code>
only <code>na.omit</code> should be used here.</p>
</td></tr>
<tr><td><code id="geese_+3A_contrasts">contrasts</code></td>
<td>
<p>a list giving contrasts for some or all of the
factors appearing in the model formula.  The elements of the
list should have the same name as the variable and should be
either a contrast matrix (specifically, any full-rank matrix
with as many rows as there are levels in the factor), or else a
function to compute such a matrix given the number of levels.</p>
</td></tr>
<tr><td><code id="geese_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the
fitting process. The length of <code>weights</code> should be the
same as the number of observations. This weights is not (yet)
the weight as in sas proc genmod, and hence is not recommended
to use.</p>
</td></tr>
<tr><td><code id="geese_+3A_zcor">zcor</code></td>
<td>
<p>a design matrix for correlation parameters.</p>
</td></tr>
<tr><td><code id="geese_+3A_corp">corp</code></td>
<td>
<p>known parameters such as coordinates used for
correlation coefficients.</p>
</td></tr>
<tr><td><code id="geese_+3A_control">control</code></td>
<td>
<p>a list of iteration and algorithmic constants. See
<code><a href="#topic+geese.control">geese.control</a></code> for their names and default
values. These can also be set as arguments to <code>geese</code>
itself.</p>
</td></tr>
<tr><td><code id="geese_+3A_b">b</code></td>
<td>
<p>an initial estimate for the mean parameters.</p>
</td></tr>
<tr><td><code id="geese_+3A_alpha">alpha</code></td>
<td>
<p>an initial estimate for the correlation parameters.</p>
</td></tr>
<tr><td><code id="geese_+3A_gm">gm</code></td>
<td>
<p>an initial estimate for the scale parameters.</p>
</td></tr>
<tr><td><code id="geese_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link
function to be used in the model, as for <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="geese_+3A_mean.link">mean.link</code></td>
<td>
<p>a character string specifying the link function
for the means. The following are allowed: <code>"identity"</code>,
<code>"logit"</code>, <code>"probit"</code>, <code>"cloglog"</code>,
<code>"log"</code>, and <code>"inverse"</code>.  The default value is
determined from family.</p>
</td></tr>
<tr><td><code id="geese_+3A_variance">variance</code></td>
<td>
<p>a character string specifying the variance function
in terms of the mean. The following are allowed:
<code>"gaussian"</code>, <code>"binomial"</code>, <code>"poisson"</code>, and
<code>"gamma"</code>. The default value is determined from family.</p>
</td></tr>
<tr><td><code id="geese_+3A_cor.link">cor.link</code></td>
<td>
<p>a character string specifying the link function for
the correlation coefficients. The following are allowed:
<code>"identity"</code>, and <code>"fisherz"</code>.</p>
</td></tr>
<tr><td><code id="geese_+3A_sca.link">sca.link</code></td>
<td>
<p>a character string specifying the link function for
the scales. The following are allowed: <code>"identity"</code>, and
<code>"log"</code>.</p>
</td></tr>
<tr><td><code id="geese_+3A_link.same">link.same</code></td>
<td>
<p>a logical indicating if all the components in a
cluster should use the same link.</p>
</td></tr>
<tr><td><code id="geese_+3A_scale.fix">scale.fix</code></td>
<td>
<p>a logical variable; if true, the scale parameter
is fixed at the value of <code>scale.value</code>.</p>
</td></tr>
<tr><td><code id="geese_+3A_scale.value">scale.value</code></td>
<td>
<p>numeric variable giving the value to which the
scale parameter should be fixed; used only if <code>scale.fix
    == TRUE</code>.</p>
</td></tr>
<tr><td><code id="geese_+3A_corstr">corstr</code></td>
<td>
<p>a character string specifying the correlation
structure.  The following are permitted: <code>"independence"</code>,
<code>"exchangeable"</code>, <code>"ar1"</code>, <code>"unstructured"</code>,
<code>"userdefined"</code>, and <code>"fixed"</code></p>
</td></tr>
<tr><td><code id="geese_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when the correlation structure is <code>fixed</code>, the specification of
<code>Zcor</code> should be a vector of length <code>sum(clusz * (clusz - 1)) /
2.</code>
</p>


<h3>Value</h3>

<p>An object of class <code>"geese"</code> representing the fit.
</p>


<h3>Author(s)</h3>

<p>Jun Yan <a href="mailto:jyan.stat@gmail.com">jyan.stat@gmail.com</a>
</p>


<h3>References</h3>

<p>Yan, J. and J.P. Fine (2004) Estimating Equations for
Association Structures.  <em>Statistics in Medicine</em>,
<b>23</b>, 859&ndash;880.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+ordgee">ordgee</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(seizure)
## Diggle, Liang, and Zeger (1994) pp166-168, compare Table 8.10
seiz.l &lt;- reshape(seizure,
                  varying=list(c("base","y1", "y2", "y3", "y4")),
                  v.names="y", times=0:4, direction="long")
seiz.l &lt;- seiz.l[order(seiz.l$id, seiz.l$time),]
seiz.l$t &lt;- ifelse(seiz.l$time == 0, 8, 2)
seiz.l$x &lt;- ifelse(seiz.l$time == 0, 0, 1)
m1 &lt;- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
            data=seiz.l, corstr="exch", family=poisson)
summary(m1)
m2 &lt;- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
            data = seiz.l, subset = id!=49,
            corstr = "exch", family=poisson)
summary(m2)
## Using fixed correlation matrix
cor.fixed &lt;- matrix(c(1, 0.5, 0.25, 0.125, 0.125,
                      0.5, 1, 0.25, 0.125, 0.125,
                      0.25, 0.25, 1, 0.5, 0.125,
                      0.125, 0.125, 0.5, 1, 0.125,
                      0.125, 0.125, 0.125, 0.125, 1), 5, 5)
cor.fixed
zcor &lt;- rep(cor.fixed[lower.tri(cor.fixed)], 59)
m3 &lt;- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
            data = seiz.l, family = poisson,
            corstr = "fixed", zcor = zcor)
summary(m3)

data(ohio)
fit &lt;- geese(resp ~ age + smoke + age:smoke, id=id, data=ohio,
             family=binomial, corstr="exch", scale.fix=TRUE)
summary(fit)
fit.ar1 &lt;- geese(resp ~ age + smoke + age:smoke, id=id, data=ohio,
                 family=binomial, corstr="ar1", scale.fix=TRUE)
summary(fit.ar1)

###### simulated data
## a function to generate a dataset
gendat &lt;- function() {
  id &lt;- gl(50, 4, 200)
  visit &lt;- rep(1:4, 50)
  x1 &lt;- rbinom(200, 1, 0.6) ## within cluster varying binary covariate
  x2 &lt;- runif(200, 0, 1)   ## within cluster varying continuous covariate
  phi &lt;- 1 + 2 * x1         ## true scale model
  ## the true correlation coefficient rho for an ar(1)
  ## correlation structure is 0.667.
  rhomat &lt;- 0.667 ^ outer(1:4, 1:4, function(x, y) abs(x - y))
  chol.u &lt;- chol(rhomat)
  noise &lt;- as.vector(sapply(1:50, function(x) chol.u %*% rnorm(4)))
  e &lt;- sqrt(phi) * noise
  y &lt;- 1 + 3 * x1 - 2 * x2 + e
  dat &lt;- data.frame(y, id, visit, x1, x2)
  dat
}

dat &lt;- gendat()
fit &lt;- geese(y ~ x1 + x2, id = id, data = dat, sformula = ~ x1,
             corstr = "ar1", jack = TRUE, j1s = TRUE, fij = TRUE)
summary(fit)


#### create user-defined design matrix of unstrctured correlation.
#### in this case, zcor has 4*3/2 = 6 columns, and 50 * 6 = 300 rows
zcor &lt;- genZcor(clusz = rep(4, 50), waves = dat$visit, "unstr")
zfit &lt;- geese(y ~ x1 + x2, id = id, data = dat, sformula = ~ x1,
              corstr = "userdefined", zcor = zcor,
              jack = TRUE, j1s = TRUE, fij = TRUE)
summary(zfit)

#### Now, suppose that we want the correlation of 1-2, 2-3, and 3-4
#### to be the same. Then zcor should have 4 columns.
z2 &lt;- matrix(NA, 300, 4)
z2[,1] &lt;- zcor[,1] + zcor[,4] + zcor[,6]
z2[,2:4] &lt;- zcor[, c(2, 3, 5)]
summary(geese(y ~ x1 + x2, id = id, data = dat, sformula = ~ x1,
              corstr = "userdefined", zcor = z2,
              jack = TRUE, j1s = TRUE, fij = TRUE))

#### Next, we introduce non-constant cluster sizes by
#### randomly selecting 60 percent of the data
good &lt;- sort(sample(1:nrow(dat), .6 * nrow(dat))) 
mdat &lt;- dat[good,]

summary(geese(y ~ x1 + x2, id = id, data = mdat, waves = visit,
              sformula = ~ x1, corstr="ar1",
              jack = TRUE, j1s = TRUE, fij = TRUE))


</code></pre>

<hr>
<h2 id='geese.control'>Auxiliary for Controlling GEE Fitting</h2><span id='topic+geese.control'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for <code style="white-space: pre;">&#8288;gee' fitting. Only used when calling &#8288;</code>geese' or &lsquo;geese.fit&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geese.control(
  epsilon = 1e-04,
  maxit = 25,
  trace = FALSE,
  scale.fix = FALSE,
  jack = FALSE,
  j1s = FALSE,
  fij = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geese.control_+3A_epsilon">epsilon</code></td>
<td>
<p>positive convergence tolerance epsilon; the
iterations converge when the absolute value of the difference
in parameter estimate is below <code>epsilon</code>.</p>
</td></tr>
<tr><td><code id="geese.control_+3A_maxit">maxit</code></td>
<td>
<p>integer giving the maximal number of Fisher Scoring
iteration.</p>
</td></tr>
<tr><td><code id="geese.control_+3A_trace">trace</code></td>
<td>
<p>logical indicating if output should be produced for
each iteration.</p>
</td></tr>
<tr><td><code id="geese.control_+3A_scale.fix">scale.fix</code></td>
<td>
<p>logical indicating if the scale should be fixed.</p>
</td></tr>
<tr><td><code id="geese.control_+3A_jack">jack</code></td>
<td>
<p>logical indicating if approximate jackknife variance
estimate should be computed.</p>
</td></tr>
<tr><td><code id="geese.control_+3A_j1s">j1s</code></td>
<td>
<p>logical indicating if 1-step jackknife variance estimate
should be computed.</p>
</td></tr>
<tr><td><code id="geese.control_+3A_fij">fij</code></td>
<td>
<p>logical indicating if fully iterated jackknife variance
estimate should be computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code style="white-space: pre;">&#8288;trace' is true, output for each iteration is printed to the screen by the c++ code. Hence, &#8288;</code>options(digits = *)' does not control the precision.
</p>


<h3>Value</h3>

<p>A list with the arguments as components.
</p>


<h3>Author(s)</h3>

<p>Jun Yan <a href="mailto:jyan.stat@gmail.com">jyan.stat@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code style="white-space: pre;">&#8288;geese.fit', the fitting procedure used by &#8288;</code>geese'.
</p>

<hr>
<h2 id='genZcor'>genZcor</h2><span id='topic+genZcor'></span><span id='topic+humbelbee'></span>

<h3>Description</h3>

<p>constructs the design matrix for the correlation structures: independence,
echangeable, ar1 and unstructured The user will need this function only as a
basis to construct a user defined correlation structure: use genZcor to get
the design matrix Z for the unstructured correlation and define the specific
correlation structure by linear combinations of the columns of Z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genZcor(clusz, waves, corstrv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genZcor_+3A_clusz">clusz</code></td>
<td>
<p>integer vector giving the number of observations in
each cluster.</p>
</td></tr>
<tr><td><code id="genZcor_+3A_waves">waves</code></td>
<td>
<p>integer vector, obervations in the same cluster with
values of wave i and j have the correlation
<code class="reqn">latex</code>.</p>
</td></tr>
<tr><td><code id="genZcor_+3A_corstrv">corstrv</code></td>
<td>
<p>correlation structures:
1=independence, 2=exchangeable, 3=ar1, 4=unstructured.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The design matrix for the correlation structure.
</p>


<h3>Author(s)</h3>

<p>Jun Yan <a href="mailto:jyan.stat@gmail.com">jyan.stat@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixed2Zcor">fixed2Zcor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example to construct a Toeplitz correlation structure
#    sigma_ij=sigma_|i-j|

# data set with 5 clusters and maximally 4 observations (visits) per cluster
gendat &lt;- function() {
       id &lt;- gl(5, 4, 20)
       visit &lt;- rep(1:4, 5)
       y &lt;- rnorm(id)
       dat &lt;- data.frame(y, id, visit)[c(-2,-9),]
}

set.seed(88)
dat &lt;- gendat()

# generating the design matrix for the unstructured correlation
zcor &lt;- genZcor(clusz = table(dat$id), waves = dat$visit, corstrv=4)

# defining the Toeplitz structure 
zcor.toep     &lt;- matrix(NA, nrow(zcor), 3)
zcor.toep[,1] &lt;- apply(zcor[,c(1, 4, 6)], 1, sum)
zcor.toep[,2] &lt;- apply(zcor[,c(2, 5)], 1, sum)
zcor.toep[,3] &lt;- zcor[,3]

zfit1 &lt;- geese(y ~ 1,id = id, data = dat,
                   corstr = "userdefined", zcor = zcor.toep)


zfit2 &lt;- geeglm(y ~ 1,id = id, data = dat,
                   corstr = "userdefined", zcor = zcor.toep)

</code></pre>

<hr>
<h2 id='koch'>Ordinal Data from Koch</h2><span id='topic+koch'></span>

<h3>Description</h3>

<p>The <code>koch</code> data frame has 288 rows and 4 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>koch
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>trt</dt><dd><p>a numeric vector</p>
</dd>
<dt>day</dt><dd><p>a numeric vector</p>
</dd>
<dt>y</dt><dd><p>an ordered factor with levels: <code>1</code> &lt; <code>2</code> &lt; <code>3</code></p>
</dd>
<dt>id</dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(koch)
fit &lt;- ordgee(ordered(y) ~ trt + as.factor(day), id=id, data=koch, corstr="exch")
summary(fit)

</code></pre>

<hr>
<h2 id='muscatine'>Data on Obesity from the Muscatine Coronary Risk Factor Study.</h2><span id='topic+muscatine'></span>

<h3>Description</h3>

<p>The data are from the Muscatine Coronary Risk Factor (MCRF) study,
a longitudinal survey of school-age children in Muscatine, Iowa.
The MCRF study had the goal of examining the development and
persistence of risk factors for coronary disease in children.  In
the MCRF study, weight and height measurements of five cohorts of
children, initially aged 5-7, 7-9, 9-11, 11-13, and 13-15 years,
were obtained biennially from 1977 to 1981. Data were collected on
4856 boys and girls. On the basis of a comparison of their weight
to age-gender specific norms, children were classified as obese or
not obese.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>muscatine
</code></pre>


<h3>Format</h3>

<p>A dataframe with 14568 rows and 7 variables:
</p>

<dl>
<dt>id</dt><dd><p>identifier of child.</p>
</dd>
<dt>gender</dt><dd><p>gender of child</p>
</dd>
<dt>base_age</dt><dd><p>baseline age</p>
</dd>
<dt>age</dt><dd><p>current age</p>
</dd>
<dt>occasion</dt><dd><p>identifier of occasion of recording</p>
</dd>
<dt>obese</dt><dd><p>'yes' or 'no'</p>
</dd>
<dt>numobese</dt><dd><p>obese in numerical form: 1 corresponds to 'yes'
and 0 corresponds to 'no'.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://content.sph.harvard.edu/fitzmaur/ala2e/muscatine.txt">https://content.sph.harvard.edu/fitzmaur/ala2e/muscatine.txt</a>
</p>
<p>Woolson, R.F. and Clarke, W.R. (1984). Analysis of categorical
incompletel longitudinal data. Journal of the Royal Statistical Society,
Series A, 147, 87-99.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>muscatine$cage &lt;- muscatine$age - 12                                         
muscatine$cage2 &lt;- muscatine$cage^2                                          
                                                                        
f1 &lt;- numobese ~ gender                                                 
f2 &lt;- numobese ~ gender + cage + cage2 +                                
    gender:cage + gender:cage2                                          
                                                                        
gee1 &lt;- geeglm(formula = f1, id = id,                                   
               waves = occasion, data = muscatine, family = binomial(),      
               corstr = "independence")                                 
                                                                        
gee2 &lt;- geeglm(formula = f2, id = id,                                   
               waves = occasion, data = muscatine, family = binomial(),      
               corstr = "independence")                                 
                                                                        
tidy(gee1)                                                              
tidy(gee2)                                                              
QIC(gee1)
QIC(gee2)


</code></pre>

<hr>
<h2 id='ohio'>Ohio Children Wheeze Status</h2><span id='topic+ohio'></span>

<h3>Description</h3>

<p>The <code>ohio</code> data frame has 2148 rows and 4 columns. The dataset is a
subset of the six-city study, a longitudinal study of the health effects of
air pollution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ohio
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>resp</dt><dd><p>an indicator of wheeze status (1=yes, 0=no)</p>
</dd>
<dt>id</dt><dd><p>a numeric vector for subject id</p>
</dd>
<dt>age</dt><dd><p>a numeric vector of age, 0 is 9 years old</p>
</dd>
<dt>smoke</dt><dd><p>an indicator of maternal smoking at the first
year of the study</p>
</dd>
</dl>



<h3>References</h3>

<p>Fitzmaurice, G.M. and Laird, N.M. (1993) A likelihood-based
method for analyzing longitudinal binary responses, <em>Biometrika</em>
<b>80</b>: 141&ndash;151.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ohio)

fit.ex &lt;- geeglm(resp ~ age + smoke + age:smoke, id=id, data=ohio,
   family=binomial, corstr="exch", scale.fix=TRUE)
QIC(fit.ex)

fit.ar &lt;- geeglm(resp ~ age + smoke + age:smoke, id=id, data=ohio,
   family=binomial, corstr="ar1", scale.fix=TRUE)
QIC(fit.ex)
</code></pre>

<hr>
<h2 id='ordgee'>GEE for Clustered Ordinal Responses</h2><span id='topic+ordgee'></span>

<h3>Description</h3>

<p>Produces an object of class &lsquo;geese&rsquo; which is a
Generalized Estimating Equation fit of the clustered ordinal
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordgee(
  formula = formula(data),
  ooffset = NULL,
  id,
  waves = NULL,
  data = parent.frame,
  subset = NULL,
  na.action = na.omit,
  contrasts = NULL,
  weights = NULL,
  z = NULL,
  mean.link = "logit",
  corstr = "independence",
  control = geese.control(...),
  b = NA,
  alpha = NA,
  scale.fix = TRUE,
  scale.val = 1,
  int.const = TRUE,
  rev = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordgee_+3A_formula">formula</code></td>
<td>
<p>a formula expression as for <code>glm</code>, of the form
<code>response ~ predictors</code>. See the documentation of lm and
formula for details. As for glm, this specifies the linear
predictor for modelling the mean. A term of the form
<code>offset(expression)</code> is allowed.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_ooffset">ooffset</code></td>
<td>
<p>vector of offset for the odds ratio model.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_id">id</code></td>
<td>
<p>a vector which identifies the clusters.  The length of
&lsquo;id&rsquo; should be the same as the number of observations.  Data
are assumed to be sorted so that observations on a cluster are
contiguous rows for all entities in the formula.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_waves">waves</code></td>
<td>
<p>an integer vector which identifies components in
clusters. The length of <code>waves</code> should be the same as the
number of observation.  components with the same <code>waves</code>
value will have the same link functions.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to interpret the
variables occurring in the <code>formula</code>, along with the
<code>id</code> and <code>n</code> variables.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_subset">subset</code></td>
<td>
<p>expression saying which subset of the rows of the
data should be used in the fit.  This can be a logical vector
(which is replicated to have length equal to the number of
observations), or a numeric vector indicating which observation
numbers are to be included, or a character vector of the row
names to be included.  All observations are included by
default.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data.  For <code>gee</code>
only <code>na.omit</code> should be used here.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_contrasts">contrasts</code></td>
<td>
<p>a list giving contrasts for some or all of the
factors appearing in the model formula.  The elements of the
list should have the same name as the variable and should be
either a contrast matrix (specifically, any full-rank matrix
with as many rows as there are levels in the factor), or else a
function to compute such a matrix given the number of levels.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the
fitting process. The length of <code>weights</code> should be the
same as the number of observations.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_z">z</code></td>
<td>
<p>a design matrix for the odds ratio model. The number of
rows of z is </p>
<p style="text-align: center;"><code class="reqn">c^2 \sum n_i(n_i - 1)/2,</code>
</p>
<p> where <code class="reqn">n_i</code> is
the cluster size, and <code class="reqn">c</code> is the number of categories minus
1.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_mean.link">mean.link</code></td>
<td>
<p>a character string specifying the link function
for the means. The following are allowed: <code>"logit"</code>,
<code>"probit"</code>, and <code>"cloglog"</code>.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_corstr">corstr</code></td>
<td>
<p>a character string specifying the log odds. The
following are allowed: <code>"independence"</code>,
<code>"exchangeable"</code>, <code>"unstructured"</code>, and
<code>"userdefined"</code>.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_control">control</code></td>
<td>
<p>a list of iteration and algorithmic constants. See
<code><a href="#topic+geese.control">geese.control</a></code> for their names and default
values. These can also be set as arguments to <code>geese</code>
itself.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_b">b</code></td>
<td>
<p>an initial estimate for the mean parameters.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_alpha">alpha</code></td>
<td>
<p>an initial estimate for the odds ratio parameters.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_scale.fix">scale.fix</code></td>
<td>
<p>a logical variable indicating if scale is fixed;
it is set at TRUE currently (it can not be FALSE yet!).</p>
</td></tr>
<tr><td><code id="ordgee_+3A_scale.val">scale.val</code></td>
<td>
<p>this argument is ignored currently.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_int.const">int.const</code></td>
<td>
<p>a logical variable; if true, the intercepts are
constant, and if false, the intercepts are different for
different components in the response.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_rev">rev</code></td>
<td>
<p>a logical variable. For example, for a three level
ordered response Y = 2, the accumulated indicator is coded as
(1, 0, 0) if true and (0, 1, 1) if false.</p>
</td></tr>
<tr><td><code id="ordgee_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"geese"</code> representing the fit.
</p>


<h3>Author(s)</h3>

<p>Jun Yan <a href="mailto:jyan.stat@gmail.com">jyan.stat@gmail.com</a>
</p>


<h3>References</h3>

<p>Heagerty, P.J. and Zeger, S.L. (1996) Marginal
regression models for clustered ordinal measurements.
<em>JASA</em>, <b>91</b> 1024&ndash;1036.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+geese">geese</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(respdis)
resp.l &lt;- reshape(respdis, varying =list(c("y1", "y2", "y3", "y4")),
                  v.names = "resp", direction = "long")
resp.l &lt;- resp.l[order(resp.l$id, resp.l$time),]
fit &lt;- ordgee(ordered(resp) ~ trt, id=id, data=resp.l, int.const=FALSE)
summary(fit)

data(ohio)
ohio$resp &lt;- ordered(as.factor(ohio$resp))
fit &lt;- ordgee(resp ~ age + smoke + age:smoke, id = id, data=ohio)
summary(fit)

</code></pre>

<hr>
<h2 id='QIC.geeglm'>Quasi Information Criterion</h2><span id='topic+QIC.geeglm'></span><span id='topic+QIC'></span><span id='topic+QIC.geekin'></span><span id='topic+QIC.ordgee'></span>

<h3>Description</h3>

<p>Function for calculating the quasi-likelihood under the independence model
information criterion (QIC), quasi-likelihood, correlation information
criterion (CIC), and corrected QIC for one or several fitted geeglm model
object from the geepack package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geeglm'
QIC(object, ..., tol = .Machine$double.eps, env = parent.frame())

## S3 method for class 'ordgee'
QIC(object, ..., tol = .Machine$double.eps, env = parent.frame())

## S3 method for class 'geekin'
QIC(object, ..., tol = .Machine$double.eps, env = parent.frame())

QIC(object, ..., tol = .Machine$double.eps, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QIC.geeglm_+3A_object">object</code></td>
<td>
<p>a fitted GEE model from the geepack
package. Currently only works on geeglm objects.</p>
</td></tr>
<tr><td><code id="QIC.geeglm_+3A_...">...</code></td>
<td>
<p>optionally more fitted geeglm model objects.</p>
</td></tr>
<tr><td><code id="QIC.geeglm_+3A_tol">tol</code></td>
<td>
<p>the tolerance used for matrix inversion.</p>
</td></tr>
<tr><td><code id="QIC.geeglm_+3A_env">env</code></td>
<td>
<p>environment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>QIC is used to select a correlation structure. The QICu is used to compare
models that have the same working correlation matrix and the same
quasi-likelihood form but different mean specifications. CIC has been
suggested as a more robust alternative to QIC when the model for the mean
may not fit the data very well and when models with different correlation
structures are compared.
</p>
<p>Models with smaller values of QIC, CIC, QICu, or QICC are preferred.
</p>
<p>If the MASS package is loaded then the <code><a href="MASS.html#topic+ginv">ginv</a></code> function is used
for matrix inversion. Otherwise the standard <code><a href="base.html#topic+solve">solve</a></code> function is
used.
</p>


<h3>Value</h3>

<p>A vector or matrix with the QIC, QICu, quasi likelihood,
CIC, the number of mean effect parameters, and the corrected
QIC for each GEE object
</p>


<h3>Author(s)</h3>

<p>Claus Ekstrom <a href="mailto:claus@rprimer.dk">claus@rprimer.dk</a>, Brian McLoone <a href="mailto:bmcloone@pdx.edu">bmcloone@pdx.edu</a> and Steven Orzack <a href="mailto:orzack@freshpond.org">orzack@freshpond.org</a>
</p>


<h3>References</h3>

<p>Pan, W. (2001). <em>Akaike's information criterion in
generalized estimating equations</em>. Biometrics, 57, 120-125.<br />
Hardin, J.W.  and Hilbe, J.M. (2012). <em>Generalized
Estimating Equations, 2nd Edition</em>, Chapman and Hall/CRC: New
York. <br />
</p>
<div class="sourceCode"><pre>Hin, L.-Y. and Wang, Y-G.
(2009). \emph{Working-correlation-structure identification in
generalized estimating equations}, Statistics in Medicine 28:
generalized estimating equations}, Statistics in Medicine 28:
642-658. \cr Thall, P.F.  and Vail, S.C. (1990). \emph{Some
Covariance Models for Longitudinal Count Data with
Overdispersion}.  Biometrics, 46, 657-671.
</pre></div>


<h3>See Also</h3>

<p><code>geeglm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(geepack)
data(ohio)
fit &lt;- geeglm(resp ~ age + smoke + age:smoke, id=id, data=ohio,
             family=binomial, corstr="exch", scale.fix=TRUE)
fit2 &lt;- geeglm(resp ~ age + smoke + age:smoke, id=id, data=ohio,
             family=binomial, corstr="ar1", scale.fix=TRUE)            
QIC(fit, fit2)

</code></pre>

<hr>
<h2 id='relRisk'>Fit a Relative Risk Model for Binary data with Log Link</h2><span id='topic+relRisk'></span>

<h3>Description</h3>

<p>Fit a Relative Risk Model for Binary data with Log
Link using the COPY method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relRisk(
  formula,
  id,
  waves = NULL,
  data = parent.frame(),
  subset = NULL,
  contrasts = NULL,
  na.action = na.omit,
  corstr = "indep",
  ncopy = 1000,
  control = geese.control(),
  b = NULL,
  alpha = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relRisk_+3A_formula">formula</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_id">id</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_waves">waves</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_data">data</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_subset">subset</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_contrasts">contrasts</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_na.action">na.action</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_corstr">corstr</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_ncopy">ncopy</code></td>
<td>
<p>the number of copies of the original data in
constructing weight.</p>
</td></tr>
<tr><td><code id="relRisk_+3A_control">control</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
<tr><td><code id="relRisk_+3A_b">b</code></td>
<td>
<p>initial values for regression coefficients as in
<code>geese</code> but more difficult to obtain due to the log link.</p>
</td></tr>
<tr><td><code id="relRisk_+3A_alpha">alpha</code></td>
<td>
<p>same as in <code>geese</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"geese"</code> representing the fit.
</p>


<h3>Author(s)</h3>

<p>Jun Yan <a href="mailto:jyan.stat@gmail.com">jyan.stat@gmail.com</a>
</p>


<h3>References</h3>

<p>Lumley, T., Kornmal, R. and Ma, S. (2006). Relative
risk regression in medical research: models, contrasts,
estimators, and algorithms. UW Biostatistics Working Paper
Series 293, University of Washington.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## this example was used in Yu and Yan (2010, techreport)
data(respiratory)
respiratory$treat &lt;- relevel(respiratory$treat, ref = "P")
respiratory$sex &lt;- relevel(respiratory$sex, ref = "M")
respiratory$center &lt;- as.factor(respiratory$center)
## 1 will be the reference level

fit &lt;- relRisk(outcome ~ treat + center + sex + age + baseline + visit,
               id = id, corstr = "ar1", data = respiratory, ncopy=10000)
summary(fit)
## fit &lt;- relRisk(outcome ~ treat + center + sex + age + baseline + visit,
##               id = id, corstr = "ex", data = respiratory)
## summary(fit)
## fit &lt;- relRisk(outcome ~ treat + center + sex + age + baseline + visit,
##                id = id, corstr = "indep", data = respiratory)
## summary(fit)

</code></pre>

<hr>
<h2 id='respdis'>Clustered Ordinal Respiratory Disorder</h2><span id='topic+respdis'></span>

<h3>Description</h3>

<p>The <code>respdis</code> data frame has 111 rows and 3 columns. The study described
in Miller et. al. (1993) is a randomized clinical trial of a new treatment of
respiratory disorder. The study was conducted in 111 patients who were
randomly assigned to one of two treatments (active, placebo). At each of four
visits during the follow-up period, the response status of each patients was
classified on an ordinal scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>respdis
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>y1, y2, y3, y4</dt><dd><p>ordered factor measured at 4 visits for the response with
levels, <code>1</code> &lt; <code>2</code> &lt; <code>3</code>, 1 = poor, 2 = good, and 3 =
excellent</p>
</dd>
<dt>trt</dt><dd><p>a factor for treatment with levels, 1 = active, 0 =
placebo.</p>
</dd>
</dl>



<h3>References</h3>

<p>Miller, M.E., David, C.S., and Landis, R.J. (1993) The analysis
of longitudinal polytomous data: Generalized estimating equation and
connections with weighted least squares, <em>Biometrics</em> <b>49</b>:
1033-1048.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(respdis)
resp.l &lt;- reshape(respdis, varying = list(c("y1", "y2", "y3", "y4")),
                  v.names = "resp", direction = "long")
resp.l &lt;- resp.l[order(resp.l$id, resp.l$time),]
fit &lt;- ordgee(ordered(resp) ~ trt, id = id, data = resp.l, int.const = FALSE)
summary(fit)

z &lt;- model.matrix( ~ trt - 1, data = respdis)
ind &lt;- rep(1:111, 4*3/2 * 2^2)
zmat &lt;- z[ind,,drop=FALSE]
fit &lt;- ordgee(ordered(resp) ~ trt, id = id, data = resp.l, int.const = FALSE,
              z = zmat, corstr = "exchangeable")
summary(fit)

</code></pre>

<hr>
<h2 id='respiratory'>Data from a clinical trial comparing two treatments for a respiratory
illness</h2><span id='topic+respiratory'></span><span id='topic+respiratoryWide'></span>

<h3>Description</h3>

<p>The data are from a clinical trial of patients with respiratory illness,
where 111 patients from two different clinics were randomized to receive
either placebo or an active treatment. Patients were examined at baseline
and at four visits during treatment. The respiratory
status (categorized as 1 = good, 0 = poor) was determined at each
visit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>respiratory
</code></pre>


<h3>Format</h3>

<p>A data frame with 444 observations on the following 8 variables.
</p>

<dl>
<dt>center</dt><dd><p>a numeric vector</p>
</dd>
<dt>id</dt><dd><p>a numeric vector</p>
</dd>
<dt>treat</dt><dd><p>treatment or placebo</p>
</dd>
<dt>sex</dt><dd><p>M or F</p>
</dd>
<dt>age</dt><dd><p>in years at baseline</p>
</dd>
<dt>baseline</dt><dd><p>resporatory status at baseline</p>
</dd>
<dt>visit</dt><dd><p>id of each of four visits</p>
</dd>
<dt>outcome</dt><dd><p>respiratory status at each visit</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(respiratory)
data(respiratory, package="geepack")
respiratory$center &lt;- factor(respiratory$center)
head(respiratory)

m1 &lt;- glm(outcome ~ center + treat + age + baseline, data=respiratory,                
          family=binomial())                                                          
gee.ind &lt;- geeglm(outcome ~ center + treat + age + baseline, data=respiratory, id=id, 
          family=binomial(), corstr="independence")                                   
gee.exc &lt;- geeglm(outcome ~ center + treat + age + baseline, data=respiratory, id=id, 
             family=binomial(), corstr="exchangeable")                                
gee.uns &lt;- geeglm(outcome ~ center + treat + age + baseline, data=respiratory, id=id, 
             family=binomial(), corstr="unstructured")                                
gee.ar1 &lt;- geeglm(outcome ~ center + treat + age + baseline, data=respiratory, id=id, 
             family=binomial(), corstr="ar1")                                         

mlist &lt;- list(gee.ind, gee.exc, gee.uns, gee.ar1)
do.call(rbind, lapply(mlist, QIC))
lapply(mlist, tidy)

</code></pre>

<hr>
<h2 id='seizure'>Epiliptic Seizures</h2><span id='topic+seizure'></span>

<h3>Description</h3>

<p>The <code>seizure</code> data frame has 59 rows and 7 columns. The dataset has the
number of epiliptic seizures in each of four two-week intervals, and in a
baseline eight-week inverval, for treatment and control groups with a total
of 59 individuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seizure
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>y1</dt><dd><p>the number of epiliptic seizures in the 1st 2-week interval</p>
</dd>
<dt>y2</dt><dd><p>the number of epiliptic seizures in the 2nd 2-week interval</p>
</dd>
<dt>y3</dt><dd><p>the number of epiliptic seizures in the 3rd 2-week interval</p>
</dd>
<dt>y4</dt><dd><p>the number of epiliptic seizures in the 4th 2-week interval</p>
</dd>
<dt>trt</dt><dd><p>an indicator of treatment</p>
</dd> <dt>base</dt><dd><p>the number of epilitic
seizures in a baseline 8-week interval</p>
</dd> <dt>age</dt><dd><p>a numeric vector of
subject age</p>
</dd> </dl>



<h3>Source</h3>

<p>Thall, P.F. and Vail S.C. (1990) Some covariance models for
longitudinal count data with overdispersion. <em>Biometrics</em> <b>46</b>:
657&ndash;671.
</p>


<h3>References</h3>

<p>Diggle, P.J., Liang, K.Y., and Zeger, S.L. (1994) Analysis of
Longitudinal Data. Clarendon Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(seizure)
## Diggle, Liang, and Zeger (1994) pp166-168, compare Table 8.10
seiz.l &lt;- reshape(seizure,
                  varying=list(c("base","y1", "y2", "y3", "y4")),
                  v.names="y", times=0:4, direction="long")
seiz.l &lt;- seiz.l[order(seiz.l$id, seiz.l$time),]
seiz.l$t &lt;- ifelse(seiz.l$time == 0, 8, 2)
seiz.l$x &lt;- ifelse(seiz.l$time == 0, 0, 1)
m1 &lt;- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
            data=seiz.l, corstr="exch", family=poisson)
summary(m1)
m2 &lt;- geese(y ~ offset(log(t)) + x + trt + x:trt, id = id,
            data = seiz.l, subset = id!=49,
            corstr = "exch", family=poisson)
summary(m2)

## Thall and Vail (1990)
seiz.l &lt;- reshape(seizure, varying=list(c("y1","y2","y3","y4")),
                  v.names="y", direction="long")
seiz.l &lt;- seiz.l[order(seiz.l$id, seiz.l$time),]
seiz.l$lbase &lt;- log(seiz.l$base / 4)
seiz.l$lage &lt;- log(seiz.l$age)
seiz.l$v4 &lt;- ifelse(seiz.l$time == 4, 1, 0)
m3 &lt;- geese(y ~ lbase + trt + lbase:trt + lage + v4, 
            sformula = ~ as.factor(time) - 1, id = id,
            data = seiz.l, corstr = "exchangeable", family=poisson)
## compare to Model 13 in Table 4, noticeable difference
summary(m3)

## set up a design matrix for the correlation
z &lt;- model.matrix(~ age, data = seizure)  # data is not seiz.l
## just to illustrate the scale link and correlation link
m4 &lt;- geese(y ~ lbase + trt + lbase:trt + lage + v4,
            sformula = ~ as.factor(time)-1, id = id,
            data = seiz.l, corstr = "ar1", family = poisson,
            zcor = z, cor.link = "fisherz", sca.link = "log")
summary(m4)

</code></pre>

<hr>
<h2 id='sitka89'>Growth of Sitka Spruce Trees</h2><span id='topic+sitka89'></span>

<h3>Description</h3>

<p>Impact of ozone on the growth of sitka spruce trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sitka89
</code></pre>


<h3>Format</h3>

<p>A dataframe
</p>

<dl>
<dt>size:</dt><dd><p>size of the tree measured in <code class="reqn">log(height*diamter^2)</code></p>
</dd>
<dt>time:</dt><dd><p>days after the 1st january, 1988</p>
</dd>
<dt>tree:</dt><dd><p>id number of a tree</p>
</dd>
<dt>treat:</dt><dd><p>ozone: grown under ozone environment, control: ozone free</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
data(sitka89)

</code></pre>

<hr>
<h2 id='spruce'>Log-size of 79 Sitka spruce trees</h2><span id='topic+spruce'></span>

<h3>Description</h3>

<p>The <code>spruce</code> data frame has 1027 rows and 6 columns. The data consists
of measurements on 79 sitka spruce trees over two growing seasons. The trees
were grown in four controlled environment chambers, of which the first two,
containing 27 trees each, were treated with introduced ozone at 70 ppb whilst
the remaining two, containing 12 and 13 trees, were controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spruce
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>chamber</dt><dd><p>a numeric vector of chamber numbers</p>
</dd>
<dt>ozone</dt><dd><p>a factor with levels <code>enriched</code> and <code>normal</code></p>
</dd>
<dt>id</dt><dd><p>a numeric vector of tree id</p>
</dd>
<dt>time</dt><dd><p>a numeric vector of the time when the
measurements were taken, measured in days since Jan. 1, 1988</p>
</dd>
<dt>wave</dt><dd><p>a numeric vector of the measurement number</p>
</dd> <dt>logsize</dt><dd><p>a
numeric vector of the log-size</p>
</dd>
</dl>



<h3>Source</h3>

<p>Diggle, P.J., Liang, K.Y., and Zeger, S.L. (1994) Analysis of
Longitudinal Data, Clarendon Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(spruce)
spruce$contr &lt;- ifelse(spruce$ozone=="enriched", 0, 1)
sitka88 &lt;- spruce[spruce$wave &lt;= 5,]
sitka89 &lt;- spruce[spruce$wave &gt; 5,]
fit.88 &lt;- geese(logsize ~ as.factor(wave) + contr +
                          I(time/100*contr) - 1,
                id=id, data=sitka88, corstr="ar1")
summary(fit.88)

fit.89 &lt;- geese(logsize ~ as.factor(wave) + contr - 1,
                id=id, data=sitka89, corstr="ar1")
summary(fit.89)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
