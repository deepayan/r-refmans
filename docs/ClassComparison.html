<!DOCTYPE html><html><head><title>Help for package ClassComparison</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ClassComparison}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bum-class'><p>Class &quot;Bum&quot;</p></a></li>
<li><a href='#BumSummary-class'><p>Class &quot;BumSummary&quot;</p></a></li>
<li><a href='#Dudoit-class'><p>Class &quot;Dudoit&quot;</p></a></li>
<li><a href='#dwil'><p>Wilcoxon Density Function</p></a></li>
<li><a href='#MultiLinearModel-class'><p>Class &quot;MultiLinearModel&quot;</p></a></li>
<li><a href='#MultiTtest-class'><p>Class &quot;MultiTtest&quot;</p></a></li>
<li><a href='#MultiWilcoxonTest-class'><p>Class &quot;MultiWilcoxonTest&quot;</p></a></li>
<li><a href='#rankSum'><p>Wilcoxon Rank-Sum Statistic</p></a></li>
<li><a href='#Sam-class'><p>Class &quot;Sam&quot;</p></a></li>
<li><a href='#SamSummary-class'><p>Class &quot;SamSummary&quot;</p></a></li>
<li><a href='#significant'><p>Generic Methods for Significance</p></a></li>
<li><a href='#SingleGroup-class'><p>Class &quot;SingleGroup&quot;</p></a></li>
<li><a href='#SmoothTtest-class'><p>Class &quot;SmoothTtest&quot;</p></a></li>
<li><a href='#TNoM-class'><p>Classes &quot;TNoM&quot; and &quot;fullTNoM&quot;</p></a></li>
<li><a href='#TNoMSummary-class'><p>Class &quot;TNoMSummary&quot;</p></a></li>
<li><a href='#TwoGroupStats-class'><p>Class &quot;TwoGroupStats&quot;</p></a></li>
<li><a href='#variantT'><p>Classes for Variant T-tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>3.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-05-01</td>
</tr>
<tr>
<td>Title:</td>
<td>Classes and Methods for "Class Comparison" Problems on
Microarrays</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin R. Coombes</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines the classes used for "class comparison" problems
  in the OOMPA project (<a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a>). Class
  comparison includes tests for differential expression; see Simon's
  book for details on typical problem types.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), oompaBase (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, stats, splines, Biobase</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (== 2.0)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Microarray, DifferentialExpression, MultipleComparisons</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-05-06 12:39:50 UTC; Kevin Coombes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-05-06 16:40:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bum-class'>Class &quot;Bum&quot;</h2><span id='topic+Bum'></span><span id='topic+Bum-class'></span><span id='topic+countSignificant+2CBum-method'></span><span id='topic+cutoffSignificant+2CBum-method'></span><span id='topic+hist+2CBum-method'></span><span id='topic+image+2CBum-method'></span><span id='topic+selectSignificant+2CBum-method'></span><span id='topic+summary+2CBum-method'></span><span id='topic+likelihoodBum'></span>

<h3>Description</h3>

<p>The <code>Bum</code> class is used to fit a beta-uniform mixture model to a
set of p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Bum(pvals, ...)
## S4 method for signature 'Bum'
summary(object, tau=0.01, ...)
## S4 method for signature 'Bum'
hist(x, res=100, xlab='P Values', main='', ...)
## S4 method for signature 'Bum'
image(x, ...)
## S4 method for signature 'Bum'
cutoffSignificant(object, alpha, by='FDR', ...)
## S4 method for signature 'Bum'
selectSignificant(object, alpha, by='FDR', ...)
## S4 method for signature 'Bum'
countSignificant(object, alpha, by='FDR', ...)
likelihoodBum(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bum-class_+3A_pvals">pvals</code></td>
<td>
<p>numeric vector containing values between <code>0</code> and <code>1</code></p>
</td></tr>
<tr><td><code id="Bum-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Bum</code></p>
</td></tr>
<tr><td><code id="Bum-class_+3A_tau">tau</code></td>
<td>
<p>numeric scalar between <code>0</code> and <code>1</code>, representing a
cutoff on the p-values</p>
</td></tr>
<tr><td><code id="Bum-class_+3A_x">x</code></td>
<td>
<p>object of class <code>Bum</code></p>
</td></tr>
<tr><td><code id="Bum-class_+3A_res">res</code></td>
<td>
<p>positive integer scalar specifying the resolution at which to
plot the fitted distribution curve</p>
</td></tr>
<tr><td><code id="Bum-class_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying the label for the x axis</p>
</td></tr>
<tr><td><code id="Bum-class_+3A_main">main</code></td>
<td>
<p>character string specifying the graph title</p>
</td></tr>
<tr><td><code id="Bum-class_+3A_alpha">alpha</code></td>
<td>
<p>Either the false discovery rate (if <code>by = 'FDR'</code>) or
the posterior probability (if <code>by = 'EmpiricalBayes'</code>)</p>
</td></tr>
<tr><td><code id="Bum-class_+3A_by">by</code></td>
<td>
<p>character string denoting the method to use for determining
cutoffs. Valid values are:
</p>

<ul>
<li><p> FDR
</p>
</li>
<li><p> FalseDiscovery
</p>
</li>
<li><p> EmpiricalBayes
</p>
</li></ul>
</td></tr>
<tr><td><code id="Bum-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The BUM method was introduced by Stan Pounds and Steve Morris,
although it was simultaneously discovered by several other
researchers. It is generally applicable to any analysis of microarray
or proteomics data that performs a separate statistical hypothesis
test for each gene or protein, where each test produces a p-value that
would be valid if the analyst were only performing one statistical
test. When performing thousands of statistical tests, however, those
p-values no longer have the same interpretation as Type I error
rates. The idea behind BUM is that, under the null hypothesis that
none of the genes or proteins is interesting, the expected
distribution of the set of p-values is uniform. By contrast, if some
of the genes are interesting, then we should see an overabundance of
small p-values (or a spike in the histogram near zero). We can model
the alternative hypothesis with a beta distribution, and view the set
of all p-values as a mixture distribution.
</p>
<p>Fitting the BUM model is straightforward, using a nonlinear optimizer
to compute the maximum likelihood parameters. After the model has
been fit, one can easily determine cutoffs on the p-values that
correspond to desired false discovery rates. Alternatively, the
original Pounds and Morris paper shows that their results can be
reinterpreted to recover the empirical Bayes method introduced by
Efron and Tibshirani. Thus, one can also determine cutoffs by
specifying a desired posterior probability of significance.
</p>


<h3>Value</h3>

<p>Graphical functions (<code>hist</code> and <code>image</code>) invisibly return the
object on which they were invoked.
</p>
<p>The <code>cutoffSignificant</code> method returns a real number between zero
and one. P-values below this cutoff are considered statistically
significant at either the specified false discovery rate or at the
specified posterior probability.
</p>
<p>The <code>selectSignificant</code> method returns a vector of logical values
whose length is equal to the length of the vector of p-values that was
used to construct the <code>Bum</code> object.  True values in the return
vector mark the statistically significant p-values.
</p>
<p>The <code>countSignificant</code> method returns an integer, the number of
statistically significant p-values.
</p>
<p>The <code>summary</code> method returns an object of class
<code><a href="#topic+BumSummary">BumSummary</a></code>.
</p>


<h3>Creating Objects</h3>

<p>Although objects can be created directly using <code>new</code>, the most
common usage will be to pass a vector of p-values to the
<code>Bum</code> function. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>pvals</code>:</dt><dd><p>numeric vector of p-values used to construct the
object.</p>
</dd>
<dt><code>ahat</code>:</dt><dd><p>Model parameter</p>
</dd>
<dt><code>lhat</code>:</dt><dd><p>Model parameter</p>
</dd>
<dt><code>pihat</code>:</dt><dd><p>Model parameter</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary(object, tau=0.01, ...)</dt><dd><p>For each value of the p-value
cutoff <code>tau</code>, computes estimates of the fraction of true
positives (TP), false negatives (FN), false positives (FP), and
true negatives (TN).</p>
</dd>
<dt>hist(x, res=100, xlab='P Values', main=&rdquo;, ...)</dt><dd><p>Plots a
histogram of the object, and overlays (1) a straight line to indicate
the contribution of the uniform component and (2) the fitted
beta-uniform distribution from the observed values. Colors in the
plot are controlled by
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$EXPECTED</a></code> and 
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$OBSERVED</a></code>.
</p>
</dd>
<dt>image(x, ...)</dt><dd><p>Produces four plots in a 2x2 layout: (1) the
histogram produced by <code>hist</code>; (2) a plot of cutoffs against
the desired false discovery rate; (3) a plot of cutoffs against
the posterior probability of coming from the beta component; and
(4) an <abbr><span class="acronym">ROC</span></abbr> curve.</p>
</dd>
<dt>cutoffSignificant(object, alpha, by='FDR', ...)</dt><dd><p>Computes the
cutoff needed for significance, which in this case means arising
from the beta component rather than the uniform component of the
mixture. Significance is specified either by the false discovery
rate (when <code>by = 'FDR'</code> or <code>by = 'FalseDiscovery'</code>) or
by the posterior probability (when <code>by = 'EmpiricalBayes'</code>)</p>
</dd>
<dt>selectSignificant(object, alpha, by='FDR', ...)</dt><dd><p>Uses
<code>cutoffSignificant</code> to determine a logical vector that
indicates which of the p-values are significant.</p>
</dd>
<dt>countSignificant(object, alpha, by='FDR', ...)</dt><dd><p>Uses
<code>selectSignificant</code> to count the number of significant
p-values.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Pounds S, Morris SW.<br />
<em>Estimating the occurrence of false positives and false negatives in
microarray studies by approximating and partitioning the empirical
distribution of p-values.</em><br />
Bioinformatics. 2003 Jul 1;19(10):1236-42. 
</p>
<p>Benjamini Y, Hochberg Y.<br />
<em>Controlling the false discovery rate: a practical and powerful approach
to multiple testing.</em><br />
J Roy Statist Soc B, 1995; 57: 289-300.
</p>
<p>Efron B, Tibshirani R.<br />
<em>Empirical bayes methods and false discovery rates for microarrays.</em><br />
Genet Epidemiol 2002, 23: 70-86.
</p>


<h3>See Also</h3>

<p>Two classes that produce lists of p-values that can (and often
should) be analyzed using BUM are <code><a href="#topic+MultiTtest">MultiTtest</a></code> and
<code><a href="#topic+MultiLinearModel">MultiLinearModel</a></code>. Also see <code><a href="#topic+BumSummary">BumSummary</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Bum")
fake.data &lt;- c(runif(700), rbeta(300, 0.3, 1))
a &lt;- Bum(fake.data)
hist(a, res=200)

alpha &lt;- (1:25)/100
plot(alpha, cutoffSignificant(a, alpha, by='FDR'),
     xlab='Desired False Discovery Rate', type='l',
     main='FDR Control', ylab='Significant P Value')

GAMMA &lt;- 5*(10:19)/100
plot(GAMMA, cutoffSignificant(a, GAMMA, by='EmpiricalBayes'),
     ylab='Significant P Value', type='l',
     main='Empirical Bayes', xlab='Posterior Probability')

b &lt;- summary(a, (0:100)/100)
be &lt;- b@estimates
sens &lt;- be$TP/(be$TP+be$FN)
spec &lt;- be$TN/(be$TN+be$FP)
plot(1-spec, sens, type='l', xlim=c(0,1), ylim=c(0,1), main='ROC Curve')
points(1-spec, sens)
abline(0,1)

image(a)

countSignificant(a, 0.05, by='FDR')
countSignificant(a, 0.99, by='Emp')
</code></pre>

<hr>
<h2 id='BumSummary-class'>Class &quot;BumSummary&quot;</h2><span id='topic+BumSummary'></span><span id='topic+BumSummary-class'></span><span id='topic+show+2CBumSummary-method'></span>

<h3>Description</h3>

<p>An implementation class. Users are not expected to create these objects
directly; they are produced as return objects from the summary method for
<code>Bum</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>bum</code>:</dt><dd><p>object of class <code>Bum</code> </p>
</dd>
<dt><code>estimates</code>:</dt><dd><p>data.frame</p>
</dd>
<dt><code>Fhat</code>:</dt><dd><p>numeric</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "BumSummary")</code>: Print the
object, which contains a summary of the underlying <code>Bum</code>
object. The summary contains a data frame with estimates of the
fraction of true positives (TP), false positives (FP), true negatives
(TN) and false negatives (FN) at the set of p-value cutoffs
specified in the call to the summary method.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bum">Bum</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("BumSummary")
</code></pre>

<hr>
<h2 id='Dudoit-class'>Class &quot;Dudoit&quot;</h2><span id='topic+Dudoit'></span><span id='topic+Dudoit-class'></span><span id='topic+plot+2CDudoit+2Cmissing-method'></span><span id='topic+cutoffSignificant+2CDudoit-method'></span><span id='topic+selectSignificant+2CDudoit-method'></span><span id='topic+countSignificant+2CDudoit-method'></span>

<h3>Description</h3>

<p>An implementation of the method of Dudoit and colleagues to apply the
Westfall-Young adjustment to p-values to control the family-wise error
rate when analyzing microarray data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dudoit(data, classes, nPerm=1000, verbose=TRUE)
## S4 method for signature 'Dudoit,missing'
plot(x, y, xlab='T-Statistic', ylab='P-Value', ...)
## S4 method for signature 'Dudoit'
cutoffSignificant(object, alpha, ...)
## S4 method for signature 'Dudoit'
selectSignificant(object, alpha, ...)
## S4 method for signature 'Dudoit'
countSignificant(object, alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dudoit-class_+3A_data">data</code></td>
<td>
<p>either a data frame or matrix with numeric values, or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_classes">classes</code></td>
<td>
<p>If <code>data</code> is a data frame or matrix, then classes
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>classes</code> can be a character string that
names one of the factor columns in the associated
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> subobject.</p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_nperm">nPerm</code></td>
<td>
<p>integer scalar specifying the number of permutations to perform</p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_verbose">verbose</code></td>
<td>
<p>logical scalar. If <code>TRUE</code>, prints additional output</p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_object">object</code></td>
<td>
<p>object of class <code>Dudoit</code></p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_alpha">alpha</code></td>
<td>
<p>numeric scalar specifying the target family-wise error rate</p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_x">x</code></td>
<td>
<p>object of class <code>Dudoit</code></p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_y">y</code></td>
<td>
<p>Nothing, since it is supposed to be missing. Changes to the Rd
processor require documenting the missing entry.</p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying label for the x axis</p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_ylab">ylab</code></td>
<td>
<p>character string specifying label for the y axis</p>
</td></tr>
<tr><td><code id="Dudoit-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In 2002, Dudoit and colleagues introduced a method to adjust the
p-values when performing gene-by-gene tests for differential
expression. The adjustment was based on the method of Westfall and
Young, with the goal of controlling the family-wise error rate.
</p>


<h3>Value</h3>

<p>The standard method for <code>plot</code> returns what you would expect.
</p>
<p>The <code>cutoffSignificant</code> method returns a real number (its input
value <code>alpha</code>).  The <code>selectSignificant</code> method returns a
vector of logical values identifying the significant test results, and
<code>countSignificant</code> returns an integer counting the number of
significant test results.
</p>


<h3>Objects from the Class</h3>

<p>As usual, objects can be created by <code>new</code>, but better methods are
available in the form of the <code>Dudoit</code> function. The basic
inputs to this function are the same as those used for row-by-row
statistical tests throughout the ClassComparison package; a detailed
description can be found in the <code><a href="#topic+MultiTtest">MultiTtest</a></code> class.
</p>
<p>The additional input determines the number, <code>nPerm</code>, of
permutations to perform. The accuracy of the p-value adjustment
depends on this value. Since the implementation is in R (and does not
call out to something compiled like C or FORTRAN), however, the
computations are slow. The default value of 1000 can take a long
time with modern microarrays that contain 40,000 spots.
</p>


<h3>Slots</h3>


<dl>
<dt><code>adjusted.p</code>:</dt><dd><p>numeric vector of adjusted p-values.</p>
</dd>
<dt><code>t.statistics</code>:</dt><dd><p>Object of class <code>numeric</code>
containing the computed t-statistics. </p>
</dd>
<dt><code>p.values</code>:</dt><dd><p>Object of class <code>numeric</code> containing
the computed p-values.</p>
</dd>
<dt><code>groups</code>:</dt><dd><p>Object of class <code>character</code> containing
the names of the classes being compared.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>call</code> containing the
function call that created the object.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>MultiTtest</code>, directly. In particular, objects of this class
inherit methods for <code>summary</code>, <code>hist</code>, and <code>plot</code> from
the base class.
</p>


<h3>Methods</h3>


<dl>
<dt>cutoffSignificant(object, alpha, ...)</dt><dd><p>Determine cutoffs on
the adjusted p-values at the desired significance level.  In other
words, this function simply returns <code>alpha</code>.</p>
</dd>
<dt>selectSignificant(object, alpha, ...)</dt><dd><p>Compute a logical
vector for selecting significant test results.</p>
</dd>
<dt>countSignificant(object, alpha, ...)</dt><dd><p>Count the number of
significant test results.</p>
</dd>
<dt>plot</dt><dd><p><code>signature(x=Dudoit, y=missing)</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Dudoit S, Yang YH, Callow MJ, Speed TP.<br />
<em>Statistical Methods for Identifying Differentially Expressed Genes in
Replicated cDNA Microarray Experiments.</em><br />
Statistica Sinica (2002), 12(1): 111-139.
</p>
<p>Westfall PH, Young SS.<br />
<em>Resampling-based multiple testing: examples and methods for p-value
adjustment.</em><br />
Wiley series in probability and mathematics statistics.
John Wiley and Sons, 1993.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bum">Bum</a></code>,
<code><a href="#topic+MultiTtest">MultiTtest</a></code>,
<code><a href="#topic+SmoothTtest">SmoothTtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Dudoit")
ng &lt;- 10000
ns &lt;- 15
nd &lt;- 200
fake.class &lt;- factor(rep(c('A', 'B'), each=ns))
fake.data &lt;- matrix(rnorm(ng*ns*2), nrow=ng, ncol=2*ns)
fake.data[1:nd, 1:ns] &lt;- fake.data[1:nd, 1:ns] + 2
fake.data[(nd+1):(2*nd), 1:ns] &lt;- fake.data[(nd+1):(2*nd), 1:ns] - 2

# the permutation test is slow. it really needs many more
# than 10 permutations, but this is just an example...
dud &lt;- Dudoit(fake.data, fake.class, nPerm=10)
summary(dud)
plot(dud)
countSignificant(dud, 0.05)
</code></pre>

<hr>
<h2 id='dwil'>Wilcoxon Density Function</h2><span id='topic+dwil'></span>

<h3>Description</h3>

<p>Computes the density function for the Wilcoxon rank-sum distribution
without centering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dwil(q, m, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dwil_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
<tr><td><code id="dwil_+3A_m">m</code></td>
<td>
<p>number of observations in the first sample</p>
</td></tr>
<tr><td><code id="dwil_+3A_n">n</code></td>
<td>
<p>number of observations in the second sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the density function for the Wilcoxon rank-sum distribution, using
exact values when both groups have fewer than 50 items and switching
to a normal approximation otherwise. It was originally written for
S-Plus, which still perversely insists that <code>m</code> and <code>n</code> must
be less than 50. The function was retained when the OOMPA library was
ported to R, since S-Plus keeps the actual rank-sum but R centers the
distribution at zero. This function encapsulated the difference, allowing
everything else to continue to work as it had worked previously.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>q</code> containing (approximate or
exact) values of the density function.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dwil(51:60, 9, 3)
dwil(51:60, 9, 51)
</code></pre>

<hr>
<h2 id='MultiLinearModel-class'>Class &quot;MultiLinearModel&quot;</h2><span id='topic+MultiLinearModel'></span><span id='topic+multiTukey'></span><span id='topic+MultiLinearModel-class'></span><span id='topic+anova+2CMultiLinearModel-method'></span><span id='topic+hist+2CMultiLinearModel-method'></span><span id='topic+plot+2CMultiLinearModel+2Cmissing-method'></span><span id='topic+plot+2CMultiLinearModel+2CANY-method'></span><span id='topic+summary+2CMultiLinearModel-method'></span>

<h3>Description</h3>

<p>Class to fit multiple (row-by-row) linear (fixed-effects) models on
microarray or proteomics data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiLinearModel(form, clindata, arraydata)
## S4 method for signature 'MultiLinearModel'
summary(object, ...)
## S4 method for signature 'MultiLinearModel'
hist(x, xlab='F Statistics', main=NULL, ...)
## S4 method for signature 'MultiLinearModel,missing'
plot(x, y, ylab='F Statistics', ...)
## S4 method for signature 'MultiLinearModel,ANY'
plot(x, y, xlab='F Statistics',
 ylab=deparse(substitute(y)), ...)
## S4 method for signature 'MultiLinearModel'
anova(object, ob2, ...)
multiTukey(object, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiLinearModel-class_+3A_form">form</code></td>
<td>
<p><code>formula</code> object specifying the linear model</p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_clindata">clindata</code></td>
<td>
<p>either a data frame of &quot;clinical&quot; or other
covariates, or an <code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code>.</p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_arraydata">arraydata</code></td>
<td>
<p>matrix or data frame of values to be explained by the model.
If <code>clindata</code> is an <code>ExpressionSet</code>, then <code>arraydata</code> can be
omitted, since it is assumed to be part of the <code>ExpressionSet</code>.</p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_object">object</code></td>
<td>
<p>object of class <code>MultiLinearModel</code></p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_ob2">ob2</code></td>
<td>
<p>object of class <code>MultiLinearModel</code></p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_x">x</code></td>
<td>
<p>object of class <code>MultiLinearModel</code></p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_y">y</code></td>
<td>
<p>optional numeric vector</p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying label for the x-axis</p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_ylab">ylab</code></td>
<td>
<p>character string specifying label for the y-axis</p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_main">main</code></td>
<td>
<p>character string specifying graph title</p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting functions</p>
</td></tr>
<tr><td><code id="MultiLinearModel-class_+3A_alpha">alpha</code></td>
<td>
<p>numeric scalar between <code>0</code> and <code>1</code> specifying
the significance level for the Tukey test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>anova</code> method returns a data frame.  The rows in the data
frame corresponds to the rows in the <code>arraydata</code> object that was
used to construct the <code>MultiLinearModel</code> objects.  The first
column contains the F-statistics and the second column contains the
p-values.
</p>
<p>The <code>multiTukey</code> function returns a vector whose length equals
the number of rows in the <code>arraydata</code> object used to construct
the <code>MultiLinearModel</code>. Assuming that the overall F-test was
significant, differences in group means (in each data row) larger than
this value are significant by Tukey's test for honestly significant
difference. (Of course, that statement is incorrect, since we haven't
fully corrected for multiple testing. Our standard practice is to take
the p-values from the row-by-row F-tests and evaluate them using the
beta-uniform mixture model (see <code><a href="#topic+Bum">Bum</a></code>). For the rows that
correspond to models whose p-values are smaller than the <code>Bum</code>
cutoff, we simply use the Tukey HSD values without further
modification.)
</p>


<h3>Creating Objects</h3>

<p>Objects should be created by calling the <code>MultiLinearModel</code>
function. The first argument is a <code><a href="stats.html#topic+formula">formula</a></code> specifying
the linear model, in the same manner that it would be passed to
<code><a href="stats.html#topic+lm">lm</a></code>. We will fit the linear model separately for each
row in the <code>arraydata</code> matrix. Rows of <code>arraydata</code> are
attached to the <code>clindata</code> data frame and are always referred to
as &quot;Y&quot; in the formulas. In particular, this implies that
<code>clindata</code> can not include a column already called &quot;Y&quot;. Further,
the implementation only works if &quot;Y&quot; is the response variable in the model.
</p>


<h3>Multiple linear models with &quot;ExpressionSet&quot; objects</h3>

<p>The BioConductor packages uses an <code>ExpressionSet</code> to combine microarray
data and clinical covariates (known in their context as
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> objects) into a single structure.
You can call <code>MultiLinearModel</code> using an <code>ExpressionSet</code> object
for the <code>clindata</code> argument. In this case, the function extracts
the <code>phenoData</code> slot of the <code>ExpressionSet</code> to use for the
clinical covariates, and extracts the <code>exprs</code> slot of the
<code>ExpressionSet</code> object to use for the array data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code>:</dt><dd><p>A <code>call</code> object describing how the object
was constructed. </p>
</dd>
<dt><code>model</code>:</dt><dd><p>The <code>formula</code> object specifying the linear
model. </p>
</dd>
<dt><code>F.statistics</code>:</dt><dd><p>A numeric vector of F-statistics
comparing the linear model to the null model. </p>
</dd>
<dt><code>p.values</code>:</dt><dd><p>A numeric vector containing the p-values
associated to the F-statistics.</p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>A <code>matrix</code> of the coefficients in
the linear models. </p>
</dd>
<dt><code>predictions</code>:</dt><dd><p>A <code>matrix</code> of the (Y-hat) values
predicted by the models. </p>
</dd>
<dt><code>sse</code>:</dt><dd><p>A numeric vector of the sum of squared error
terms from fitting the models. </p>
</dd>
<dt><code>ssr</code>:</dt><dd><p>A numeric vector of the sum of squared
regression terms from the model. </p>
</dd>
<dt><code>df</code>:</dt><dd><p>A numeric vector (of length two) containing the
degrees of freedom for the F-tests.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
<dt>hist(x, xlab='F Statistics', main=NULL, ...)</dt><dd><p>Create a
histogram of the F-statistics.</p>
</dd>
<dt>plot(x, ylab='F Statistics', ...)</dt><dd><p>Plot the F-statistics as a
function of the row index.</p>
</dd>
<dt>plot(x, y, xlab='F Statistics', ylab=deparse(substitute(y)),
...)</dt><dd><p>Plot the F-statistics against the numeric vector <code>y</code>.</p>
</dd>
<dt>anova(object, ob2, ...)</dt><dd><p>Perform row-by-row F-tests comparing
two different linear models.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The <code>MultiLinearModel</code> constructor computes row-by-row F-tests
comparing each linear model to the null model Y ~ 1.  In many
instances, one wishes to use an F-test to compare two different linear
models. For instance, many standard applications of analysis of
variance (ANOVA) can be described using such a comparison between two
different linear models. The <code>anova</code> method for the
<code>MultiLinearModel</code> class performs row-by-row F-tests comparing
two competing linear models.
</p>
<p>The implementation of <code>MultiLinearModel</code> does not take the naive
approach of using either <code><a href="base.html#topic+apply">apply</a></code> or a
<code><a href="base.html#topic+for">for</a></code>-loop to attach rows one at a time and fit separate
linear models. All the models are actually fit simultaneously by a
series of matrix operations, which greatly reduces the amount of time
needed to compute the models. The constraint on the column names in
<code>clindata</code> still holds, since one row is attached to allow
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code> to determine the contrasts matrix.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+anova">anova</a></code>,
<code><a href="stats.html#topic+lm">lm</a></code>,
<code><a href="#topic+Bum">Bum</a></code>,
<code><a href="#topic+MultiTtest">MultiTtest</a></code>,
<code><a href="#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MultiLinearModel")
ng &lt;- 10000
ns &lt;- 50
dat &lt;- matrix(rnorm(ng*ns), ncol=ns)
cla &lt;- factor(rep(c('A', 'B'), 25))
cla2 &lt;- factor(rep(c('X', 'Y', 'Z'), times=c(15, 20, 15)))
covars &lt;- data.frame(Grade=cla, Stage=cla2)
res &lt;- MultiLinearModel(Y ~ Grade + Stage, covars, dat)
summary(res)
hist(res, breaks=101)
plot(res)
plot(res, res@p.values)

graded &lt;- MultiLinearModel(Y ~ Grade, covars, dat)
summary(graded)

hist(graded@p.values, breaks=101)
hist(res@p.values, breaks=101)

oop &lt;- anova(res, graded)
hist(oop$p.values, breaks=101)
</code></pre>

<hr>
<h2 id='MultiTtest-class'>Class &quot;MultiTtest&quot;</h2><span id='topic+MultiTtest'></span><span id='topic+MultiTtest-class'></span><span id='topic+hist+2CMultiTtest-method'></span><span id='topic+plot+2CMultiTtest+2Cmissing-method'></span><span id='topic+plot+2CMultiTtest+2CANY-method'></span><span id='topic+summary+2CMultiTtest-method'></span><span id='topic+as.data.frame+2CMultiTtest-method'></span>

<h3>Description</h3>

<p>Class to perform row-by-row t-tests on microarray or proteomics data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiTtest(data, classes, na.rm=TRUE)
## S4 method for signature 'MultiTtest'
summary(object, ...)
## S4 method for signature 'MultiTtest'
as.data.frame(x, row.names=NULL, optional=FALSE, ...)
## S4 method for signature 'MultiTtest'
hist(x, xlab='T Statistics', main=NULL, ...)
## S4 method for signature 'MultiTtest,missing'
plot(x, y, ylab='T Statistics', ...)
## S4 method for signature 'MultiTtest,ANY'
plot(x, y, xlab='T Statistics', ylab=deparse(substitute(y)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiTtest-class_+3A_data">data</code></td>
<td>
<p>either a data frame or matrix with numeric values, or an
<code><a href="Biobase.html#topic+ExpressionSet-class">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data</p>
</td></tr> 
<tr><td><code id="MultiTtest-class_+3A_classes">classes</code></td>
<td>
<p>If <code>data</code> is a data frame or matrix, then classes
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>classes</code> can be a character string that
names one of the factor columns in the associated
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> subobject.</p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_na.rm">na.rm</code></td>
<td>
<p>logical scalar. If <code>TRUE</code>, compute t-statistics after
omitting <code>NA</code> values from individual rows of the data matrix</p>
</td></tr> 
<tr><td><code id="MultiTtest-class_+3A_object">object</code></td>
<td>
<p>object of class <code>MultiTtest</code></p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_x">x</code></td>
<td>
<p>object of class <code>MultiTtest</code></p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_y">y</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying the label for the x axis</p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_ylab">ylab</code></td>
<td>
<p>character string specifying the label for the y axis</p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_main">main</code></td>
<td>
<p>character string specifying the plot title</p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_row.names">row.names</code></td>
<td>
<p>see the base version</p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_optional">optional</code></td>
<td>
<p>see the base version</p>
</td></tr>
<tr><td><code id="MultiTtest-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The graphical routines invisibly return the object against which
they were invoked.
</p>


<h3>Creating objects</h3>

<p>Although objects can be created using <code>new</code>, the preferred method is
to use the <code>MultiTtest</code> generator. In the simplest case, you
simply pass in a data matrix and a logical vector assigning classes to
the columns, and the constructor performs row-by-row two-sample
t-tests and computes the associated (single test) p-values. To adjust
for multiple testing, you can pass the p-values on to the
<code><a href="#topic+Bum">Bum</a></code> class.
</p>
<p>If you use a factor instead of a logical vector, then the t-test
compares the first level of the factor to everything else. To handle
the case of multiple classes, see the <code><a href="#topic+MultiLinearModel">MultiLinearModel</a></code>
class.
</p>
<p>As with other class comparison functions that are part of the OOMPA,
we can also perform statistical tests on
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> objects from
the BioConductor libraries. In this case, we pass in an
<code>ExpressionSet</code> object along with the name of a factor to use for
splitting the data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>t.statistics</code>:</dt><dd><p>Object of class <code>numeric</code>
containing the computed t-statistics. </p>
</dd>
<dt><code>p.values</code>:</dt><dd><p>Object of class <code>numeric</code> containing
the computed p-values. </p>
</dd>
<dt><code>df</code>:</dt><dd><p>Numeric vector of the degrees of freedom per
gene. Introduced to allow for missing data.</p>
</dd>
<dt><code>groups</code>:</dt><dd><p>Object of class <code>character</code> containing
the names of the classes being compared. </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>call</code> containing the
function call that created the object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
<dt>hist(x, xlab='T Statistics', main=NULL, ...)</dt><dd><p>Produce a
histogram of the t-statistics.</p>
</dd>
<dt>plot(x)</dt><dd><p>Produces a scatter plot of the t-statistics against
their index.</p>
</dd>
<dt>plot(x,y)</dt><dd><p>Produces a scatter plot of the t-statistics in the
object <code>x</code> against the numeric vector <code>y</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code>matrixT</code>,
<code><a href="#topic+Bum">Bum</a></code>,
<code><a href="#topic+Dudoit">Dudoit</a></code>,
<code><a href="#topic+MultiLinearModel">MultiLinearModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MultiTtest")
ng &lt;- 10000
ns &lt;- 50
dat &lt;- matrix(rnorm(ng*ns), ncol=ns)
cla &lt;- factor(rep(c('A', 'B'), each=25))
res &lt;- MultiTtest(dat, cla)
summary(res)
hist(res, breaks=101)
plot(res)
plot(res, res@p.values)
hist(res@p.values, breaks=101)

dat[1,1] &lt;- NA
mm &lt;- matrixMean(dat, na.rm=TRUE)
vv &lt;- matrixVar(dat, mm, na.rm=TRUE)
tt &lt;- matrixT(dat, cla, na.rm=TRUE)
mtt &lt;- MultiTtest(dat,cla)
</code></pre>

<hr>
<h2 id='MultiWilcoxonTest-class'>Class &quot;MultiWilcoxonTest&quot;</h2><span id='topic+MultiWilcoxonTest'></span><span id='topic+MultiWilcoxonTest-class'></span><span id='topic+countSignificant+2CMultiWilcoxonTest-method'></span><span id='topic+cutoffSignificant+2CMultiWilcoxonTest-method'></span><span id='topic+hist+2CMultiWilcoxonTest-method'></span><span id='topic+plot+2CMultiWilcoxonTest+2Cmissing-method'></span><span id='topic+selectSignificant+2CMultiWilcoxonTest-method'></span><span id='topic+summary+2CMultiWilcoxonTest-method'></span>

<h3>Description</h3>

<p>The <code>MultiWilcoxonTest</code> class is used to perform row-by-row Wilcoxon
rank-sum tests on a data matrix. Significance cutoffs are determined by the
empirical Bayes method of Efron and Tibshirani.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiWilcoxonTest(data, classes, histsize=NULL)
## S4 method for signature 'MultiWilcoxonTest'
summary(object, prior=1, significance=0.9, ...)
## S4 method for signature 'MultiWilcoxonTest'
hist(x, xlab='Rank Sum',
 ylab='Prob(Different | Y)', main='', ...)
## S4 method for signature 'MultiWilcoxonTest,missing'
plot(x, prior=1, significance=0.9,
 ylim=c(-0.5, 1), xlab='Rank Sum', ylab='Prob(Different | Y)', ...)
## S4 method for signature 'MultiWilcoxonTest'
cutoffSignificant(object, prior, significance, ...)
## S4 method for signature 'MultiWilcoxonTest'
selectSignificant(object, prior, significance, ...)
## S4 method for signature 'MultiWilcoxonTest'
countSignificant(object, prior, significance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiWilcoxonTest-class_+3A_data">data</code></td>
<td>
<p>either a data frame or matrix with numeric values, or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_classes">classes</code></td>
<td>
<p> If <code>data</code> is a data frame or matrix, then classes
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>classes</code> can be a character string that
names one of the factor columns in the associated
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> subobject.</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_histsize">histsize</code></td>
<td>
<p>An integer; the number of bins used for the histogram
summarizing the Wilcoxon statistics. When <code>NULL</code>, each discrete
rank-sum value gets its own bin.</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_object">object</code></td>
<td>
<p>an object of the <code>MultiWilcoxonTest</code> class.</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_x">x</code></td>
<td>
<p>an object of the <code>MultiWilcoxonTest</code> class.</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying label for the x axis</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_ylab">ylab</code></td>
<td>
<p>character string specifying label for the y axis</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_ylim">ylim</code></td>
<td>
<p>Plotting limits on the y-axis</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_main">main</code></td>
<td>
<p>character string specifying graph title</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_prior">prior</code></td>
<td>
<p>Prior probability that an arbitrary gene is not differentially
expressed, or that an arbitrary row does not yield a significant
Wilcoxon rank-sum statistic. </p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_significance">significance</code></td>
<td>
<p>Desired level of posterior probability</p>
</td></tr>
<tr><td><code id="MultiWilcoxonTest-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper by Efron and Tibshirani.
</p>


<h3>Value</h3>

<p>The standard methods <code>summary</code>, <code>hist</code>, and <code>plot</code>
return what you would expect.
</p>
<p>The <code>cutoffSignificant</code> method returns a list of two
integers. Rank-sum values smaller than the first value or larger than
the second value are statistically significant in the sense that their
posterior probability exceeds the specified <code>significance</code> level
given the assumptions about the <code>prior</code> probability of not being
significant.
</p>
<p>The <code>selectSignificant</code> method returns a vector of logical values
identifying the significant test results, and <code>countSignificant</code>
returns an integer counting the number of significant test results.
</p>


<h3>Creating Objects</h3>

<p>As usual, objects can be created by <code>new</code>, but better methods are
available in the form of the <code>MultiWilcoxonTest</code> function. The
inputs to this function are the same as those used for row-by-row
statistical tests throughout the ClassComparison package; a detailed
description can be found in the <code><a href="#topic+MultiTtest">MultiTtest</a></code> class.
</p>
<p>The constructor computes row-by-row Wilcoxon rank-sum statistics on
the input <code>data</code>, comparing the two groups defined by the
<code>classes</code> argument. It also estimates the observed and
theoretical (expected) density functions for the collection of
rank-sum statistics.
</p>
<p>The additional input argument, <code>histsize</code> is usually best left to
its default value. In certain pathological cases, we have found it
necessary to use fewer bins; one suspects that the underlying model
does not adequately capture the complexity of those situations.
</p>


<h3>Slots</h3>


<dl>
<dt><code>rank.sum.statistics</code>:</dt><dd><p>numeric vector containing the
computed rank-sum statistics.</p>
</dd>
<dt><code>xvals</code>:</dt><dd><p>numeric vector, best thought of as the vector
of possible rank-sum statistics given the sizes of the two groups.</p>
</dd>
<dt><code>theoretical.pdf</code>:</dt><dd><p>numeric vector containing the
theoretical density function evaluated at the points of
<code>xvals</code>.</p>
</dd>
<dt><code>pdf</code>:</dt><dd><p>numeric vector containing the empirical density
function computed at the points of <code>xvals</code>.</p>
</dd>
<dt><code>unravel</code>:</dt><dd><p>numeric vector containing a smoothed
estimate (by Poisson regression using B-splines) of the empirical
density function evaluated at <code>xvals</code>.</p>
</dd>
<dt><code>groups</code>:</dt><dd><p>A vector containing the names of the groups
defined by <code>classes</code>.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>object of class <code>call</code> representing the
function call that created the object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary(object, prior=1, significance=0.9, ...)</dt><dd>
<p>Write out a summary of the object. For a given value of the
<code>prior</code> probability of not being differentially expressed and
a given significance cutoff on the posterior probability, reports
the cutoffs and number of items in both tails of the distribution.</p>
</dd>
<dt>hist(x, xlab='Rank Sum', ylab='Prob(Different|Y)', main=&rdquo;, ...)</dt><dd>
<p>Plot a histogram of the rank-sum statistics, with overlaid curves
representing the expected and observed distributions.  Colors of
the curves are controlled by
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$EXPECTED</a></code> and 
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$OBSERVED</a></code>.
</p>
</dd>
<dt>plot(x, prior=1, significance=0.9, ylim=c(-0.5, 1), xlab='Rank
Sum', ylab='Prob(Different | Y)', ...)</dt><dd>
<p>Plots the posterior probability of being differentially expressed
for given values of the <code>prior</code>.  Horizontal lines are added
at each specified <code>significance</code> level for the posterior
probability.
</p>
</dd> 
<dt>cutoffSignificant(object, prior, significance, ...)</dt><dd><p>Determine
cutoffs on the rank-sum statistic at the desired significance level.</p>
</dd>
<dt>selectSignificant(object, prior, significance, ...)</dt><dd><p>Compute a
logical vector for selecting significant test results.</p>
</dd>
<dt>countSignificant(object, prior, significance, ...)</dt><dd><p>Count the
number of significant test results.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Efron B, Tibshirani R.<br />
<em>Empirical bayes methods and false discovery rates for microarrays.</em><br />
Genet Epidemiol 2002, 23: 70-86.
</p>
<p>Pounds S, Morris SW.<br />
<em>Estimating the occurrence of false positives and false negatives in
microarray studies by approximating and partitioning the empirical
distribution of p-values.</em><br />
Bioinformatics. 2003 Jul 1;19(10):1236-42. 
</p>


<h3>See Also</h3>

<p>Implementation is handled in part by the functions <code><a href="#topic+dwil">dwil</a></code>
and <code><a href="#topic+rankSum">rankSum</a></code>. The empirical Bayes results for
alternative tests (such as <code><a href="#topic+MultiTtest">MultiTtest</a></code>) can be obtained
using the beta-uniform mixture model in the <code><a href="#topic+Bum">Bum</a></code> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MultiWilcoxonTest")
ng &lt;- 10000
ns &lt;- 15
nd &lt;- 200
fake.class &lt;- factor(rep(c('A', 'B'), each=ns))
fake.data &lt;- matrix(rnorm(ng*ns*2), nrow=ng, ncol=2*ns)
fake.data[1:nd, 1:ns] &lt;- fake.data[1:nd, 1:ns] + 2
fake.data[(nd+1):(2*nd), 1:ns] &lt;- fake.data[(nd+1):(2*nd), 1:ns] - 2

a &lt;- MultiWilcoxonTest(fake.data, fake.class)
hist(a)
plot(a)
plot(a, prior=0.85)
abline(h=0)

cutoffSignificant(a, prior=0.85, signif=0.95)
countSignificant(a, prior=0.85, signif=0.95)
</code></pre>

<hr>
<h2 id='rankSum'>Wilcoxon Rank-Sum Statistic</h2><span id='topic+rankSum'></span>

<h3>Description</h3>

<p>Compute the Wilcoxon rank-sum statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankSum(data, selector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankSum_+3A_data">data</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="rankSum_+3A_selector">selector</code></td>
<td>
<p>logical vector the same length as <code>data</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an efficient function to compute the value of the Wilcoxon
rank-sum statistic without the extra overhead of the full
<code>wilcox.test</code> function. It is used internally by the
<code><a href="#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code> class to perform row-by-row Wilcoxon
tests.
</p>


<h3>Value</h3>

<p>Returns an integer, the rank-sum of the subset of the
<code>data</code> for which the <code>selector</code> is true. 
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dwil">dwil</a></code>,
<code><a href="#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- rnorm(100)
cc &lt;- rep(c(TRUE, FALSE), each=50)
rankSum(dd, cc)
</code></pre>

<hr>
<h2 id='Sam-class'>Class &quot;Sam&quot;</h2><span id='topic+Sam'></span><span id='topic+Sam-class'></span><span id='topic+countSignificant+2CSam-method'></span><span id='topic+plot+2CSam+2Cmissing-method'></span><span id='topic+selectSignificant+2CSam-method'></span><span id='topic+summary+2CSam-method'></span>

<h3>Description</h3>

<p>Implements the &quot;Significance Analysis of Microarrays&quot; approach to
detecting differentially expressed genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sam(data, classes, nPerm=100, verbose=TRUE)
## S4 method for signature 'Sam,missing'
plot(x, y, tracks=NULL, xlab='Expected T Statistics (Empirical)',
 ylab='Observed T Statistics', ...)
## S4 method for signature 'Sam'
summary(object, cutoff=1, ...)
## S4 method for signature 'Sam'
selectSignificant(object, cutoff=1, ...)
## S4 method for signature 'Sam'
countSignificant(object, cutoff=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sam-class_+3A_data">data</code></td>
<td>
<p> Either a data frame or matrix with numeric values or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_classes">classes</code></td>
<td>
<p> If <code>data</code> is a data frame or matrix, then classes
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>classes</code> can be a character string that
names one of the factor columns in the associated
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> subobject.</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_nperm">nPerm</code></td>
<td>
<p>An integer; the number of permutations</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_x">x</code></td>
<td>
<p>A <code>Sam</code> object</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_y">y</code></td>
<td>
<p>Nothing, since it is supposed to be missing. Changes to the Rd
processor require documenting the missing entry.</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_tracks">tracks</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_xlab">xlab</code></td>
<td>
<p>Label for the x axis</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_ylab">ylab</code></td>
<td>
<p>Label for the y axis</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_object">object</code></td>
<td>
<p>A <code>Sam</code> object</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_cutoff">cutoff</code></td>
<td>
<p>A numeric value</p>
</td></tr>
<tr><td><code id="Sam-class_+3A_...">...</code></td>
<td>
<p>The usual extra arguments to generic functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SAM approach to analyzing microarray data was developed by Tusher
and colleagues; their implementation is widely available.  This is an
independent implementation based on the description in their original
paper, customized to use the same interface (and thus work with
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> objects) used
by the rest of the ClassComparison package. The fundamental idea
behind SAM is that the observed distribution of row-by-row two-sample
t-tests should be compared not to the theoretical null distribution
but to a null distribution estimated by a permutation test. The
<code>Sam</code> constructor performs the permutation test.
</p>


<h3>Value</h3>

<p><code>summary</code> returns an object of class <code><a href="#topic+SamSummary">SamSummary</a></code>.
</p>
<p><code>selectSignificant</code> returns a vector of logical values.
</p>
<p><code>countSignificant</code> returns an integer.
</p>


<h3>Creating Objects</h3>

<p>As usual, objects can be created by <code>new</code>, but better methods are
available in the form of the <code>Sam</code> function. The inputs to this
function are the same as those used for row-by-row statistical tests
throughout the ClassComparison package; a detailed description can be
found in the <code>MultiTtest</code> class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>t.statistics</code>:</dt><dd><p>numeric vector containing the observed
t-statistics.</p>
</dd> 
<dt><code>observed</code>:</dt><dd><p>numeric vector containing the sorted
observed t-statistics.</p>
</dd>
<dt><code>expected</code>:</dt><dd><p>numeric vector of the expected
distribution of t-statistics based on a permutation test.</p>
</dd>
<dt><code>sim.data</code>:</dt><dd><p>numeric matrix containing all the t-statistics
from all the permutations.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>object of class <code>call</code> specifying the function
call that was used to create this object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary(object, cutoff=1, ...)</dt><dd><p>Compute a summary of the object. </p>
</dd>
<dt>plot(x, tracks=NULL, xlab='Expected T Statistics (Empirical)',
ylab='Observed t Statistics', ...)</dt><dd><p>Plot the observed and expected
t-statistics. The <code>tracks</code> argument causes parallel lines to be
drawn on either side of the quantile-quantile central line, at the
specified offsets. Colors in the plot are controlled by the current
values of <code><a href="oompaBase.html#topic+oompaColor">oompaColor$CENTRAL.LINE</a></code> and
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$CONFIDENCE.CURVE</a></code> </p>
</dd>
<dt>selectSignificant(object, cutoff=1, ...)</dt><dd><p>Compute a vector
that selects significant values</p>
</dd>
<dt>countSignificant(object, cutoff=1, ...)</dt><dd><p>Count the number of
significant values</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Tusher VG, Tibshirani R, Chu G.<br />
<em>Significance analysis of microarrays applied to the ionizing radiation
response.</em><br />
Proc Natl Acad Sci U S A (2001) 98, 5116-5121.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bum">Bum</a></code>,
<code><a href="#topic+MultiTtest">MultiTtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Sam")
ng &lt;- 10000
ns &lt;- 50
nd &lt;- 100
dat &lt;- matrix(rnorm(ng*ns), ncol=ns)
dat[1:nd, 1:(ns/2)] &lt;- dat[1:nd, 1:(ns/2)] + 2
dat[(nd+1):(2*nd), 1:(ns/2)] &lt;- dat[(nd+1):(2*nd), 1:(ns/2)] - 2
cla &lt;- factor(rep(c('A', 'B'), each=25))

res &lt;- Sam(dat, cla)
plot(res)

plot(res, tracks=1:3)

summary(res)
summary(res, cutoff=2)

a &lt;- summary(res)
plot(a@significant.calls)
plot(a@significant.calls[1:300])

countSignificant(res, 1)
</code></pre>

<hr>
<h2 id='SamSummary-class'>Class &quot;SamSummary&quot;</h2><span id='topic+SamSummary'></span><span id='topic+SamSummary-class'></span><span id='topic+show+2CSamSummary-method'></span>

<h3>Description</h3>

<p>An implementation class. Users are not expected to create these objects
directly; they are produced as return objects from the summary method
for <code>Sam</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>fdr</code>:</dt><dd><p>numeric scalar between <code>0</code> and <code>1</code> specifying
the expected false discovery rate</p>
</dd>
<dt><code>hi</code>:</dt><dd><p>Upper threshold for significance</p>
</dd>
<dt><code>lo</code>:</dt><dd><p>Lower threshold for significance</p>
</dd>
<dt><code>cutoff</code>:</dt><dd><p>numeric scalar specified in the call to the
<code>Sam</code> <code>summary</code> method.</p>
</dd>
<dt><code>significant.calls</code>:</dt><dd><p>vector of logical values</p>
</dd>
<dt><code>average.false.count</code>:</dt><dd><p>The average number of false
positives in the permuted data at this cutoff level.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = SamSummary)</code>:  Print the
object, which contains a summary of the underlying <code>Sam</code>
object.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sam">Sam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SamSummary")
</code></pre>

<hr>
<h2 id='significant'>Generic Methods for Significance</h2><span id='topic+cutoffSignificant'></span><span id='topic+cutoffSignificant-method'></span><span id='topic+cutoffSignificant+2CANY-method'></span><span id='topic+selectSignificant'></span><span id='topic+selectSignificant-method'></span><span id='topic+selectSignificant+2CANY-method'></span><span id='topic+countSignificant'></span><span id='topic+countSignificant-method'></span><span id='topic+countSignificant+2CANY-method'></span>

<h3>Description</h3>

<p>In the world of multiple testing that is inhabited by most microarray
or protein profiling experiments, analysts frequently perform separate
statistical tests for each gene or protein in the experiment.
Determining cutoffs that achieve statistical significance (in a
meaningful way) is an inherent part of the procedure. It is then
common to select the significant items for further processing or for
preparing reports, or at least to count the number of significant
items. These generic functions provide a standard set of tools for
selecting and counting the significant items, which can be used with
various statistical tests and various ways to account for multiple
testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ANY'
cutoffSignificant(object, ...)
## S4 method for signature 'ANY'
selectSignificant(object, ...)
## S4 method for signature 'ANY'
countSignificant(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="significant_+3A_object">object</code></td>
<td>
<p>an object that performs multiple statistical tests on
microarray or proteomics data</p>
</td></tr>
<tr><td><code id="significant_+3A_...">...</code></td>
<td>
<p>additional arguments affecting these generic methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cutoffSignificant</code> returns appropriate cutoff values that achieve
specified significance criteria.
</p>
<p><code>selectSignificant</code> returns a logical vector, with <code>TRUE</code> values
indicating items that satisfy the cutoff making them statistically
significant.
</p>
<p><code>countSignificant</code> returns an integer, representing the number of
significant items.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>

<hr>
<h2 id='SingleGroup-class'>Class &quot;SingleGroup&quot;</h2><span id='topic+SingleGroup'></span><span id='topic+SingleGroup-class'></span><span id='topic+as.data.frame+2CSingleGroup-method'></span><span id='topic+plot+2CSingleGroup+2Cmissing-method'></span><span id='topic+print+2CSingleGroup-method'></span><span id='topic+show+2CSingleGroup-method'></span><span id='topic+summary+2CSingleGroup-method'></span>

<h3>Description</h3>

<p>Preliminary analysis of one group of samples for use in
the <code><a href="#topic+SmoothTtest">SmoothTtest</a></code> class. A key feature is the standard
quality control plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingleGroup(avg, sd, span=0.5, name='')
## S4 method for signature 'SingleGroup'
as.data.frame(x, row.names=NULL, optional=FALSE)
## S4 method for signature 'SingleGroup'
summary(object, ...)
## S4 method for signature 'SingleGroup'
print(x, ...)
## S4 method for signature 'SingleGroup'
show(object)
## S4 method for signature 'SingleGroup,missing'
plot(x, multiple=3, ccl=0, main=x@name,
 xlab='Mean', ylab='Std Dev', xlim=0, ylim=0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingleGroup-class_+3A_avg">avg</code></td>
<td>
<p>numeric vector of mean values</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_sd">sd</code></td>
<td>
<p>numeric vector of standard deviations</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_span">span</code></td>
<td>
<p>parameter is passed onto <code><a href="stats.html#topic+loess">loess</a></code></p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_name">name</code></td>
<td>
<p>character string specifying the name of this object</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_object">object</code></td>
<td>
<p>object of class <code>SingleGroup</code></p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_x">x</code></td>
<td>
<p>object of class <code>SingleGroup</code></p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_multiple">multiple</code></td>
<td>
<p>numeric scalar specifying the multiple of the smoothed
standard deviation to call significant</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_ccl">ccl</code></td>
<td>
<p>list containing objects of the
<code><a href="oompaBase.html#topic+ColorCoding">ColorCoding</a></code> class. If left at its default
value of zero, colors are chosen automatically.</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_main">main</code></td>
<td>
<p>character string specifying plot title</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying label for the x axis</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_ylab">ylab</code></td>
<td>
<p>character string specifying label for the y axis</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_xlim">xlim</code></td>
<td>
<p>Plotting limits for the x axis. If left at the default
value of zero, then the limits are automatically generated</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_ylim">ylim</code></td>
<td>
<p>Plotting limits for the y axis. If left at the default
value of zero, then the limits are automatically generated</p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_row.names">row.names</code></td>
<td>
<p>See the base version of <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code></p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_optional">optional</code></td>
<td>
<p>See the base version of <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code></p>
</td></tr>
<tr><td><code id="SingleGroup-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In 2001 and 2002, Baggerly and Coombes developed the smooth t-test for
finding differentially expressed genes in microarray data. Along with
many others, they began by log-transforming the data as a reasonable
step in the direction of variance stabilization. They observed,
however, that the gene-by-gene standard deviations still seemed to
vary in a systematic way as a function of the mean log intensity. By
borrowing strength across genes and using <code><a href="stats.html#topic+loess">loess</a></code> to fit
the observed standard deviations as a function of the mean, one
presumably got a better estimate of the true standard deviation.
</p>


<h3>Creating Objects</h3>

<p>Objects can be created by calls to the <code>SingleGroup</code> constructor.
Users rarely have need to create these objects directly; they are
usually created as a consequence of the construction of an object of
the <code><a href="#topic+SmoothTtest">SmoothTtest</a></code> class.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>character string specifying the name of this object</p>
</dd>
<dt><code>avg</code>:</dt><dd><p>numeric vector of mean values</p>
</dd>
<dt><code>sd</code>:</dt><dd><p>numeric vector of standard deviations</p>
</dd>
<dt><code>span</code>:</dt><dd><p>parameter used in the <code><a href="stats.html#topic+loess">loess</a></code> function
to fit <code>sd</code> as a function of <code>avg</code>.</p>
</dd>
<dt><code>fit</code>:</dt><dd><p>list containing components <code>x</code> and
<code>y</code> resulting from the <code>loess</code> fit</p>
</dd>
<dt><code>score</code>:</dt><dd><p>numeric vector specifying the ratio of the pointwise
standard deviations to their smooth (loess) estimates</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.data.frame(x, row.names=NULL, optional=FALSE)</dt><dd><p>Combine the
slots containing numeric vectors into a data frame, suitable for
printing or exporting.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
<dt>print(x, ...)</dt><dd><p>Print the entire object. You never want to do
this.</p>
</dd>
<dt>show(object)</dt><dd><p>Print the entire object. You never want to do
this.</p>
</dd>
<dt>plot(x, multiple=3, ccl=0, main=x@name, xlab='Mean', ylab='Std
Dev', xlim=0, ylim=0, ...)</dt><dd><p>Produce a scatter plot of the standard
deviations (<code>x@sd</code>) as a function of the means (<code>x@avg</code>).
The appropriate multiple of the <code>loess</code> fit is overlaid, and
points that exceed this multiple are flagged in a different
color. Colors in the plot are controlled by the current values of
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$CENTRAL.LINE</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$CONFIDENCE.CURVE</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$BORING</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$BAD.REPLICATE</a></code>, and
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$WORST.REPLICATE</a></code>.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Baggerly KA, Coombes KR, Hess KR, Stivers DN, Abruzzo LV, Zhang W.<br />
<em>Identifying differentially expressed genes in cDNA microarray
experiments.</em><br />
J Comp Biol. 8:639-659, 2001.
</p>
<p>Coombes KR, Highsmith WE, Krogmann TA, Baggerly KA, Stivers DN, Abruzzo LV.<br />
<em>Identifying and quantifying sources of variation in microarray data
using high-density cDNA membrane arrays.</em><br />
J Comp Biol. 9:655-669, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SmoothTtest">SmoothTtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SingleGroup")
m &lt;- rnorm(1000, 8, 2.5)
v &lt;- rnorm(1000, 0.7)
plot(m, v)

x &lt;- SingleGroup(m, v, name='bogus')

summary(x)

plot(x)
plot(x, multiple=2)
</code></pre>

<hr>
<h2 id='SmoothTtest-class'>Class &quot;SmoothTtest&quot;</h2><span id='topic+SmoothTtest'></span><span id='topic+SmoothTtest-class'></span><span id='topic+as.data.frame+2CSmoothTtest-method'></span><span id='topic+plot+2CSmoothTtest+2Cmissing-method'></span><span id='topic+summary+2CSmoothTtest-method'></span>

<h3>Description</h3>

<p>Implements the smooth t-test for differential expression as developed
by Baggerly and Coombes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SmoothTtest(stats, aname='Group One', bname='Group Two',
 name=paste(aname, 'vs.', bname))
## S4 method for signature 'SmoothTtest'
as.data.frame(x, row.names=NULL, optional=FALSE)
## S4 method for signature 'SmoothTtest'
summary(object, ...)
## S4 method for signature 'SmoothTtest,missing'
plot(x, folddiff=3, goodflag=2, badch=4, ccl=0,
 name=x@name, pch='.', xlab='log intensity', ylab='log ratio', ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SmoothTtest-class_+3A_stats">stats</code></td>
<td>
<p>object of class <code><a href="#topic+TwoGroupStats">TwoGroupStats</a></code></p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_aname">aname</code></td>
<td>
<p>character string specifying the name of the first group</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_bname">bname</code></td>
<td>
<p>character string specifying the name of the second group</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_name">name</code></td>
<td>
<p>character string specifying the name of this object</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_object">object</code></td>
<td>
<p>object of class <code>SmoothTtest</code></p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_x">x</code></td>
<td>
<p>object of class <code>SmoothTtest</code></p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_row.names">row.names</code></td>
<td>
<p>See the base version of <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code></p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_optional">optional</code></td>
<td>
<p>See the base version of <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code></p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_folddiff">folddiff</code></td>
<td>
<p>numeric scalar specifying the level of fold difference
considered large enough to be indicated in the plots</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_goodflag">goodflag</code></td>
<td>
<p>numeric scalar specifying the level (in standard deviation
units) of the smooth t-statistic considered large enough to be indicated
in the plot</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_badch">badch</code></td>
<td>
<p>numeric scalar specifying the level of variability in single
groups considered large enough to be worrisome. See the <code>multiple</code>
argument to the <code>plot</code> method in the <code><a href="#topic+SingleGroup">SingleGroup</a></code> class.</p>
</td></tr> 
<tr><td><code id="SmoothTtest-class_+3A_ccl">ccl</code></td>
<td>
<p>list containing objects of class
<code><a href="oompaBase.html#topic+ColorCoding">ColorCoding</a></code>. If left at its default
value of zero, colors are chosen automatically.</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_pch">pch</code></td>
<td>
<p>default plotting character</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_xlab">xlab</code></td>
<td>
<p>character string specifying label for the x axis</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_ylab">ylab</code></td>
<td>
<p>character string specifying label for the y axis</p>
</td></tr>
<tr><td><code id="SmoothTtest-class_+3A_...">...</code></td>
<td>
<p>extra arguments for generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In 2001 and 2002, Baggerly and Coombes developed the smooth t-test for
finding differentially expressed genes in microarray data. Along with
many others, they began by log-transforming the data as a reasonable
step in the direction of variance stabilization. They observed,
however, that the gene-by-gene standard deviations still seemed to
vary in a systematic way as a function of the mean log intensity. By
borrowing strength across genes and using <code><a href="stats.html#topic+loess">loess</a></code> to fit
the observed standard deviations as a function of the mean, one
presumably got a better estimate of the true standard deviation.
</p>
<p>These smooth estimates are computed for each of two groups of samples
being compared. They are then combined (gene-by-gene using the usual
univariate formulas) to compute pooled &quot;smooth&quot; estimates of the standard
deviation. These smooth estimates are then used in gene-by-gene
t-tests.
</p>
<p>The interesting question then arises of how to compute and interpret
p-values associated to these individual tests. The liberal
argument asserts that, because smoothing uses data from hundreds
of measurements to estimate the standard deviation, it can effectively
be treated as &quot;known&quot; in the t-tests, which should thus be compared
against the normal distribution. A conservative argument claims
that the null distribution should still be the t-distribution with the
degrees of freedom determined in the usual way by the number of
samples. The truth probably lies somewhere in between, and is
probably best approximated by some kind of permutation test. In this
implementation, we take the coward's way out and don't provide any of
those alternatives. You have to extract the t-statistics (from the
<code>smooth.t.statistics</code> slot of the object) and compute your own
p-values in your favorite way. If you base the computations on a
theoretical model rather than a permutation test, then the
<code><a href="#topic+Bum">Bum</a></code> class provides a convenient way to account for
multiple testing.
</p>


<h3>Creating Objects</h3>

<p>In practice, users will first use a data frame and a classification
vector (or an <code>ExpressionSet</code>) to construct an object of the
<code><a href="#topic+TwoGroupStats">TwoGroupStats</a></code> object. This object can then be handed
directly to the <code>SmoothTtest</code> function to perform the smooth
t-test.
</p>


<h3>Slots</h3>


<dl>
<dt><code>one</code>:</dt><dd><p>object of class <code>SingleGroup</code> representing a
loess smooth of standard deviation as a function of the mean in the
first group of samples</p>
</dd>
<dt><code>two</code>:</dt><dd><p>object of class <code>SingleGroup</code> representing a
loess smooth of standard deviation as a function of the mean in the
second group of samples</p>
</dd>
<dt><code>smooth.t.statistics</code>:</dt><dd><p>numeric vector containing the
smooth t-statistics</p>
</dd>
<dt><code>fit</code>:</dt><dd><p>data.frame with two columns, <code>x</code> and <code>y</code>,
containing the smooth estimates of the pooled standard deviation</p>
</dd>
<dt><code>dif</code>:</dt><dd><p>numeric vector of the differences in mean
values between the two groups</p>
</dd>
<dt><code>avg</code>:</dt><dd><p>numeric vector of the overall mean value</p>
</dd>
<dt><code>aname</code>:</dt><dd><p>character string specifying the name of the first
group</p>
</dd>
<dt><code>bname</code>:</dt><dd><p>character string specifying the name of the second
group</p>
</dd>
<dt><code>name</code>:</dt><dd><p>character string specifying the name of this object</p>
</dd>
<dt><code>stats</code>:</dt><dd><p>object of class <code>TwoGroupStats</code> that was used
to create this object</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.data.frame(x, row.names=NULL, optional=FALSE)</dt><dd><p>Convert the
object into a data frame suitable for printing or exporting.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
<dt>plot(x, folddiff=3, goodflag=2, badch=4, ccl=0, name=x@name,
pch='.', xlab='log intensity', ylab='log ratio', ...)</dt><dd><p>Create a
set of six plots.  The first two plots are the QC plots from the
<code><a href="#topic+SingleGroup">SingleGroup</a></code> objects representing the two groups of
samples. The third plot is a scatter plot comparing the means in
the two groups. The fourth plot is Bland-Altman plot of the
overall mean against the difference in means (also known colloquially
as an M-vs-A plot). The fifth plot is a histogram of the smooth
t-statistics. The final plot is a scatter plot of the smooth
t-statistics as a function of the mean intensity.
Colors in the plots are controlled by the current values of
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$BORING</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$SIGNIFICANT</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$BAD.REPLICATE</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$WORST.REPLICATE</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$FOLD.DIFFERENCE</a></code>,
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$CENTRAL.LINE</a></code>, and
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$CONFIDENCE.CURVE</a></code>.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Baggerly KA, Coombes KR, Hess KR, Stivers DN, Abruzzo LV, Zhang W.<br />
<em>Identifying differentially expressed genes in cDNA microarray
experiments.</em><br />
J Comp Biol. 8:639-659, 2001.
</p>
<p>Coombes KR, Highsmith WE, Krogmann TA, Baggerly KA, Stivers DN, Abruzzo LV.<br />
<em>Identifying and quantifying sources of variation in microarray data
using high-density cDNA membrane arrays.</em><br />
J Comp Biol. 9:655-669, 2002.
</p>
<p>Altman DG, Bland JM.<br />
<em>Measurement in Medicine: the Analysis of Method Comparison Studies.</em><br />
The Statistician, 1983; 32: 307-317. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bum">Bum</a></code>,
<code><a href="#topic+MultiTtest">MultiTtest</a></code>,
<code><a href="#topic+SingleGroup">SingleGroup</a></code>,
<code><a href="#topic+TwoGroupStats">TwoGroupStats</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("SmoothTtest")
bogus &lt;- matrix(rnorm(30*1000, 8, 3), ncol=30, nrow=1000)
splitter &lt;- rep(FALSE, 30)
splitter[16:30] &lt;- TRUE
x &lt;- TwoGroupStats(bogus, splitter)
y &lt;- SmoothTtest(x)

opar &lt;- par(mfrow=c(2, 3), pch='.')
plot(y, badch=2, goodflag=1)
par(opar)
</code></pre>

<hr>
<h2 id='TNoM-class'>Classes &quot;TNoM&quot; and &quot;fullTNoM&quot;</h2><span id='topic+TNoM'></span><span id='topic+TNoM-class'></span><span id='topic+countSignificant+2CTNoM-method'></span><span id='topic+selectSignificant+2CTNoM-method'></span><span id='topic+summary+2CTNoM-method'></span><span id='topic+update+2CTNoM-method'></span><span id='topic+fullTNoM-class'></span><span id='topic+hist+2CfullTNoM-method'></span><span id='topic+plot+2CfullTNoM+2Cmissing-method'></span>

<h3>Description</h3>

<p>Implements the &quot;Total Number of Misclassifications&quot; method for finding
differentially expressed genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TNoM(data, classes, verbose=TRUE)
## S4 method for signature 'TNoM'
summary(object, ...)
## S4 method for signature 'TNoM'
update(object, nPerm, verbose=FALSE, ...)
## S4 method for signature 'TNoM'
selectSignificant(object, cutoff, ...)
## S4 method for signature 'TNoM'
countSignificant(object, cutoff, ...)
## S4 method for signature 'fullTNoM,missing'
plot(x, y, ...)
## S4 method for signature 'fullTNoM'
hist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TNoM-class_+3A_data">data</code></td>
<td>
<p> Either a data frame or matrix with numeric values or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr> 
<tr><td><code id="TNoM-class_+3A_classes">classes</code></td>
<td>
<p> If <code>data</code> is a data frame or matrix, then classes
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>classes</code> can be a character string that
names one of the factor columns in the associated
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> subobject.</p>
</td></tr>
<tr><td><code id="TNoM-class_+3A_verbose">verbose</code></td>
<td>
<p>logical scalar. If <code>TRUE</code>, print out intermediate results</p>
</td></tr>
<tr><td><code id="TNoM-class_+3A_object">object</code></td>
<td>
<p>object of class <code>TNoM</code></p>
</td></tr>
<tr><td><code id="TNoM-class_+3A_nperm">nPerm</code></td>
<td>
<p>integer scalar specifying the number of permutations to perform</p>
</td></tr>
<tr><td><code id="TNoM-class_+3A_cutoff">cutoff</code></td>
<td>
<p>integer scalar</p>
</td></tr>
<tr><td><code id="TNoM-class_+3A_x">x</code></td>
<td>
<p>object of class <code>fullTNoM</code></p>
</td></tr>
<tr><td><code id="TNoM-class_+3A_y">y</code></td>
<td>
<p>Nothing, since it is supposed to be missing. Changes to the Rd
processor require documenting the missing entry.</p>
</td></tr>
<tr><td><code id="TNoM-class_+3A_...">...</code></td>
<td>
<p>extra arguments to generic or plotting routines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The TNoM method was developed by Yakhini and Ben-Dor and first
applied in the melanoma microarray study by Bittner and colleagues
(see references). The goal of the method is to detect genes that are
differentially expressed between two groups of samples. The idea is
that each gene serves as a potential classifier to distinguish the two
groups. One starts by determining an optimal cutoff on the expression
of each gene and counting the number of misclassifications that gene
makes. Next, we bin genes based on the total number of
misclassifications. This distribution can be compared with the expected
value (by simulating normal data sets of the same size).
Alternatively, one can estimate the null distribution directly by
scrambling the sample labels to perform a permutation test.
</p>
<p>The <code>TNoM</code> constructor computes the optimal cutoffs and the
misclassification rates. The <code>update</code> method performs the
simulations and permutation tests, producing an object of the
<code>fullTNoM</code> class.
</p>


<h3>Value</h3>

<p><code>summary</code> returns a <code><a href="#topic+TNoMSummary">TNoMSummary</a></code> object.
</p>
<p><code>update</code> returns a <code>fullTNoM</code> object.
</p>
<p><code>selectSignificant</code> returns a vector of logical values.
</p>
<p><code>countSignificant</code> returns an integer.
</p>


<h3>Creating Objects</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>TNoM</code> generator. The inputs to this function are the same as those
used for row-by-row statistical tests throughout the <span class="pkg">ClassComparison</span>
package; a detailed description can be found in the <code>MultiTtest</code> class.
</p>


<h3>Slots</h3>

<p>Objects of the <code>TNoM</code> class have the following slots:
</p>

<dl>
<dt><code>data</code>:</dt><dd><p>The data matrix used to construct the object</p>
</dd>
<dt><code>tnomData</code>:</dt><dd><p>numeric vector, whose length is the number
of rows in <code>data</code>, recording the minimum number of
misclassification  achieved using this data row.</p>
</dd> 
<dt><code>nCol</code>:</dt><dd><p>The number of columns in <code>data</code></p>
</dd>
<dt><code>nRow</code>:</dt><dd><p>The number of rows in <code>data</code></p>
</dd>
<dt><code>classifier</code>:</dt><dd><p>The classification vector used to create
the object.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The function <code>call</code> that created the object </p>
</dd>
</dl>

<p>Objects of the <code>fullTNoM</code> class have the following slots:  
</p>

<dl>
<dt><code>dex</code>:</dt><dd><p>Numeric vector of the different possible numbers
of misclassifications</p>
</dd>
<dt><code>fakir</code>:</dt><dd><p>Numeric vector of expected values based on simulations</p>
</dd>
<dt><code>obs</code>:</dt><dd><p>Numeric vector of observed values</p>
</dd>
<dt><code>scr</code>:</dt><dd><p>Numeric vector of values based on a permutation test</p>
</dd>
<dt><code>name</code>:</dt><dd><p>A character string with a name for the object</p>
</dd>
</dl>



<h3>Methods</h3>

<p>Objects of the <code>TNoM</code> class have the following methods:
</p>

<dl>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object,
including the number of genes achieving each possible number of
misclassifications.</p>
</dd>
<dt>countSignificant(object, cutoff, ...)</dt><dd><p>Count the number of
significant genes at the given <code>cutoff</code>.</p>
</dd>
<dt>selectSignificant(object, cutoff, ...)</dt><dd><p>Get a vector for
selecting the number of significant genes at the given
<code>cutoff</code>.</p>
</dd>
<dt>update(object, nPerm, verbose=FALSE, ...)</dt><dd><p>Perform
simulation and permutation tests on the <code>TNoM</code> object.</p>
</dd>
</dl>

<p>Objects of the <code>fullTNoM</code> class have the following methods:
</p>

<dl>
<dt>plot(x, ...)</dt><dd><p>Plot a summary of the TNoM object. This consists
of three curves: the observed cumulative number of genes at each
misclassification level, along with the corresponding numbers
expected based on simulations or permutation tests.
The colors of the curves are controlled by the values of
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$OBSERVED</a></code>, 
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$EXPECTED</a></code>, and
<code><a href="oompaBase.html#topic+oompaColor">oompaColor$PERMTEST</a></code> </p>
</dd>
<dt>hist(x, ...)</dt><dd><p>Plot a not terribly useful nor informative
histogram of the results.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Bittner M, Meltzer P, Chen Y, Jiang Y, Seftor E, Hendrix M, Radmacher M,
Simon R, Yakhini Z, Ben-Dor A, Sampas N, Dougherty E, Wang E, Marincola
F, Gooden C, Lueders J, Glatfelter A, Pollock P, Carpten J, Gillanders
E, Leja D, Dietrich K, Beaudry C, Berens M, Alberts D, Sondak V.<br />
<em>Molecular classification of cutaneous malignant melanoma by gene
expression profiling.</em><br />
Nature. 2000 Aug 3;406(6795):536-40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bum">Bum</a></code>,
<code><a href="#topic+MultiTtest">MultiTtest</a></code>,
<code><a href="#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TNoM")
showClass("fullTNoM")
n.genes &lt;- 200
n.samples &lt;- 10

bogus &lt;- matrix(rnorm(n.samples*n.genes, 0, 3), ncol=n.samples)
splitter &lt;- rep(FALSE, n.samples)
splitter[sample(1:n.samples, trunc(n.samples/2))] &lt;- TRUE

tn &lt;- TNoM(bogus, splitter)
summary(tn)

tnf &lt;- update(tn)
plot(tnf)
hist(tnf)
</code></pre>

<hr>
<h2 id='TNoMSummary-class'>Class &quot;TNoMSummary&quot;</h2><span id='topic+TNoMSummary'></span><span id='topic+TNoMSummary-class'></span><span id='topic+show+2CTNoMSummary-method'></span>

<h3>Description</h3>

<p>An implementation class. Users are not expected to create these objects
directly; they are produced as return objects from the summary method for
<code>TNoM</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>TNoM</code>:</dt><dd><p>object of class <code>TNoM</code> ~~ </p>
</dd>
<dt><code>counts</code>:</dt><dd><p>object of class <code>numeric</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = TNoMSummary)</code>:  Print the
object, which contains a summary of the underlying <code>TNoM</code>
object. In particular, the summary reports the number of genes
achieving each possible number of misclassifications.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TNoM">TNoM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TNoMSummary")
</code></pre>

<hr>
<h2 id='TwoGroupStats-class'>Class &quot;TwoGroupStats&quot;</h2><span id='topic+TwoGroupStats'></span><span id='topic+TwoGroupStats-class'></span><span id='topic+as.data.frame+2CTwoGroupStats-method'></span><span id='topic+plot+2CTwoGroupStats+2Cmissing-method'></span><span id='topic+print+2CTwoGroupStats-method'></span><span id='topic+show+2CTwoGroupStats-method'></span><span id='topic+summary+2CTwoGroupStats-method'></span>

<h3>Description</h3>

<p>Compute row-by-row means and variances for a data matrix
whose columns belong to two different groups of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TwoGroupStats(data, classes, name=comparison, name1=A, name2=B)
## S4 method for signature 'TwoGroupStats'
as.data.frame(x, row.names=NULL, optional=FALSE)
## S4 method for signature 'TwoGroupStats'
summary(object, ...)
## S4 method for signature 'TwoGroupStats'
print(x, ...)
## S4 method for signature 'TwoGroupStats'
show(object)
## S4 method for signature 'TwoGroupStats,missing'
plot(x, main=x@name, useLog=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoGroupStats-class_+3A_data">data</code></td>
<td>
<p> Either a data frame or matrix with numeric values or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_classes">classes</code></td>
<td>
<p> If <code>data</code> is a data frame or matrix, then classes
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>classes</code> can be a character string that
names one of the factor columns in the associated
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> subobject.</p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_name">name</code></td>
<td>
<p> A character string; the name of this object </p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_name1">name1</code></td>
<td>
<p> A character string; the name of the first group </p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_name2">name2</code></td>
<td>
<p> A character string; the name of the second group </p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_x">x</code></td>
<td>
<p>A <code>TwoGroupStats</code> object</p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_row.names">row.names</code></td>
<td>
<p>See the base version of <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code></p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_optional">optional</code></td>
<td>
<p>See the base version of <code><a href="base.html#topic+as.data.frame.default">as.data.frame.default</a></code></p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_object">object</code></td>
<td>
<p>A <code>TwoGroupStats</code> object</p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_main">main</code></td>
<td>
<p>Plot title</p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_uselog">useLog</code></td>
<td>
<p>a logical flag; should the values be log-transformed
before plotting?</p>
</td></tr>
<tr><td><code id="TwoGroupStats-class_+3A_...">...</code></td>
<td>
<p>The usual extra arguments to generic functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class was one of the earliest developments in our suite of tools
to analyze microarrays. Its main purpose is to segregate out the
preliminary computation of summary statistics on a row-by-row basis,
along with a set of plots that could be generated automatically and
used for quality control.
</p>


<h3>Creating Objects</h3>

<p>Although objects of the class can be created by a direct call to
<a href="methods.html#topic+new">new</a>, the preferred method is to use the
<code>TwoGroupStats</code> generator. The inputs to this
function are the same as those used for row-by-row statistical tests
throughout the ClassComparison package; a detailed description can be
found in the <code>MultiTtest</code> class.
</p>
<p>One should note that this class serves as the front end to the
<code><a href="#topic+SmoothTtest">SmoothTtest</a></code> class, providing it with an interface that
accepts <code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code>
objects compatible with the other statistical tests in the
ClassComparison package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mean1</code>:</dt><dd><p>numeric vector of means in the first group</p>
</dd>
<dt><code>mean2</code>:</dt><dd><p>numeric vector of means in the second group</p>
</dd>
<dt><code>overallMean</code>:</dt><dd><p>numeric vector of overall row means</p>
</dd>
<dt><code>var1</code>:</dt><dd><p>numeric vector of variances in the first group</p>
</dd>
<dt><code>var2</code>:</dt><dd><p>numeric vector of variances in the second group</p>
</dd>
<dt><code>overallVar</code>:</dt><dd><p>numeric vector of variances assuming
the two groups have the same mean</p>
</dd>
<dt><code>pooledVar</code>:</dt><dd><p>numeric vector of row-by-row pooled variances,
assuming the two groups have the same variance but different means</p>
</dd>
<dt><code>n1</code>:</dt><dd><p>numeric scalar specifying number of items in the
first group</p>
</dd>
<dt><code>n2</code>:</dt><dd><p>numeric scalar specifying number of items in the
second group</p>
</dd>
<dt><code>name1</code>:</dt><dd><p>character string specifying name of the first group</p>
</dd>
<dt><code>name2</code>:</dt><dd><p>character string specifying name of the second group</p>
</dd>
<dt><code>name</code>:</dt><dd><p>character string specifying name of the object</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>as.data.frame(x, row.names=NULL, optional=FALSE)</dt><dd><p>Collect the
numeric vectors from the object into a single dat fame, suitable
for printing or exporting.</p>
</dd>
<dt>summary(object, ...)</dt><dd><p>Write out a summary of the object.</p>
</dd>
<dt>print(x, ...)</dt><dd><p>Print the object. (Actually, it only prints a
summary, since the whole object is almost always more than you
really want to see. If you insist on printing everything, use
<code>as.data.frame</code>.)</p>
</dd>
<dt>show(object)</dt><dd><p>Print the object (same as print method).)</p>
</dd>
<dt>plot(x, main=x@name, useLog=FALSE, ...)</dt><dd><p>This function
actually produces six different plots of the data, so it is
usually wrapped by a graphical layout command like
<code>par(mfrow=c(2,3))</code>. The first two plots show the relation
between the mean and standard deviation for the two groups
separately; the third plot does the same for the overall mean and
variance.  The fourth plot is a Bland-Altman plot of the difference
between the means against the overall mean. (In the microarray
world, this is usually called an M-vs-A plot.)  A loess fit is
overlaid on the scatter plot, and points outside confidence bounds
based on the fit are printed in a different color to flag them as
highly variable. The fifth plot shows a loess fit (with confidence
bounds) of the difference as a function of the row index (which
often is related to the geometric position of spots on a
microarray). Thus, this plot gives a possible indication of regions
of an array where unusual things happen. The final plot compares
the overall variances to the pooled variances.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>Altman DG, Bland JM.<br />
<em>Measurement in Medicine: the Analysis of Method Comparison Studies.</em><br />
The Statistician, 1983; 32: 307-317. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MultiTtest">MultiTtest</a></code>,
<code><a href="#topic+SmoothTtest">SmoothTtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("TwoGroupStats")
bogus &lt;- matrix(rnorm(30*1000, 8, 3), ncol=30, nrow=1000)
splitter &lt;- rep(FALSE, 30)
splitter[16:30] &lt;- TRUE

x &lt;- TwoGroupStats(bogus, splitter)
summary(x)

opar&lt;-par(mfrow=c(2,3), pch='.')
plot(x)
par(opar)
</code></pre>

<hr>
<h2 id='variantT'>Classes for Variant T-tests</h2><span id='topic+MultiTtestPaired'></span><span id='topic+MultiTtestUnequal'></span><span id='topic+MultiTtestPaired-class'></span><span id='topic+MultiTtestUnequal-class'></span><span id='topic+summary+2CMultiTtestPaired-method'></span><span id='topic+summary+2CMultiTtestUnequal-method'></span>

<h3>Description</h3>

<p>Classes to perform row-by-row paired or unequal variance t-tests on
microarray or proteomics data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiTtestPaired(data, classes, pairing)
MultiTtestUnequal(data, classes)
## S4 method for signature 'MultiTtestPaired'
summary(object, ...)
## S4 method for signature 'MultiTtestUnequal'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variantT_+3A_data">data</code></td>
<td>
<p> Either a data frame or matrix with numeric values or an
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> as defined
in the BioConductor tools for analyzing microarray data.</p>
</td></tr> 
<tr><td><code id="variantT_+3A_classes">classes</code></td>
<td>
<p> If <code>data</code> is a data frame or matrix, then classes
must be either a logical vector or a factor. If <code>data</code> is an
<code>ExpressionSet</code>, then <code>classes</code> can be a character string that
names one of the factor columns in the associated
<code><a href="Biobase.html#topic+phenoData">phenoData</a></code> subobject.</p>
</td></tr>
<tr><td><code id="variantT_+3A_pairing">pairing</code></td>
<td>
<p>A numerical vector indicating which samples are
paired.</p>
</td></tr>
<tr><td><code id="variantT_+3A_object">object</code></td>
<td>
<p>A <code>MultiTtest</code> object</p>
</td></tr>
<tr><td><code id="variantT_+3A_...">...</code></td>
<td>
<p>Unused; optional extra parameters for <code>summary</code>.</p>
</td></tr>
</table>


<h3>Creating objects</h3>

<p>Although objects can be created using <code>new</code>, the better method is
to use the <code>MultiTtestPaired</code> or <code>MultiTtestUnequal</code>
functions. In the simplest case, you simply pass in a data matrix
and a logical vector assigning classes to the columns (and, in the
case of a paired t-test, a numeric vector describing the pairing), and
the constructor performs row-by-row two-sample t-tests and computes
the associated (single test) p-values.  To adjust for multiple
testing, you can pass the p-values on to the <code><a href="#topic+Bum">Bum</a></code> class.
</p>
<p>If you use a factor instead of a logical vector, then the t-test
compares the first level of the factor to everything else.  To handle
the case of multiple classes, see the <code><a href="#topic+MultiLinearModel">MultiLinearModel</a></code>
class.
</p>
<p>As with other class comparison functions that are part of the OOMPA,
we can also perform statistical tests on
<code><a href="Biobase.html#topic+class.ExpressionSet">ExpressionSet</a></code> objects from
the BioConductor libraries. In this case, we pass in an
<code>ExpressionSet</code> object along with the name of a factor to use for
splitting the data.
</p>


<h3>Extends</h3>

<p>Both classes extend class <code><a href="#topic+MultiTtest">MultiTtest</a></code>, directly. See that
class for descriptions of the inherited methods and slots.
</p>


<h3>Slots</h3>


<dl>
<dt><code>df</code>:</dt><dd><p>The <code>MultiTtestUnequal</code> class adds a slot to
record e gene-by-gene degrees of freedom, which can change along
with the variances.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>summary</dt><dd><p><code>signature(object = MultiTtestPaired)</code>:
Write out a summary of the object. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = MultiTtestUnequal)</code>:
Write out a summary of the object. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>
</p>


<h3>References</h3>

<p>OOMPA</p>


<h3>See Also</h3>

<p><code><a href="#topic+Bum">Bum</a></code>,
<code><a href="#topic+MultiTtest">MultiTtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MultiTtestPaired")
showClass("MultiTtestUnequal")
ng &lt;- 10000
ns &lt;- 50
dat &lt;- matrix(rnorm(ng*ns), ncol=ns)
cla &lt;- factor(rep(c('A', 'B'), each=25))
res &lt;- MultiTtestUnequal(dat, cla)
summary(res)
hist(res, breaks=101)
plot(res, res@p.values)

pairing &lt;- rep(1:25, 2)
res &lt;- MultiTtestPaired(dat, cla, pairing)
summary(res)
plot(res)
hist(res@p.values, breaks=101)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
