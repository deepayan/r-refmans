<!DOCTYPE html><html><head><title>Help for package Rlinsolve</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rlinsolve}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aux.fisch'><p>Generate a 2-dimensional discrete Poisson matrix</p></a></li>
<li><a href='#lsolve.bicg'><p>Biconjugate Gradient method</p></a></li>
<li><a href='#lsolve.bicgstab'><p>Biconjugate Gradient Stabilized Method</p></a></li>
<li><a href='#lsolve.cg'><p>Conjugate Gradient method</p></a></li>
<li><a href='#lsolve.cgs'><p>Conjugate Gradient Squared method</p></a></li>
<li><a href='#lsolve.cheby'><p>Chebyshev Method</p></a></li>
<li><a href='#lsolve.gmres'><p>Generalized Minimal Residual method</p></a></li>
<li><a href='#lsolve.gs'><p>Gauss-Seidel method</p></a></li>
<li><a href='#lsolve.jacobi'><p>Jacobi method</p></a></li>
<li><a href='#lsolve.qmr'><p>Quasi Minimal Residual Method</p></a></li>
<li><a href='#lsolve.sor'><p>Successive Over-Relaxation method</p></a></li>
<li><a href='#lsolve.ssor'><p>Symmetric Successive Over-Relaxation method</p></a></li>
<li><a href='#Rlinsolve'><p>A Collection of Iterative Solvers for (Sparse) Linear System of Equations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Iterative Solvers for (Sparse) Linear System of Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Solving a system of linear equations is one of the most fundamental
    computational problems for many fields of mathematical studies, such as
    regression problems from statistics or numerical partial differential equations.
    We provide basic stationary iterative solvers such as Jacobi, Gauss-Seidel,
    Successive Over-Relaxation and SSOR methods. Nonstationary, also known as
	Krylov subspace methods are also provided. Sparse matrix computation is also supported
    in that solving large and sparse linear systems can be manageable using 'Matrix' package
    along with 'RcppArmadillo'. For a more detailed description, see a book by Saad (2003)
    &lt;<a href="https://doi.org/10.1137%2F1.9780898718003">doi:10.1137/1.9780898718003</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.4), Matrix, Rdpack, stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-21 05:04:26 UTC; kisung</td>
</tr>
<tr>
<td>Author:</td>
<td>Kisung You <a href="https://orcid.org/0000-0002-8584-459X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kisung You &lt;kisungyou@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-21 15:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='aux.fisch'>Generate a 2-dimensional discrete Poisson matrix</h2><span id='topic+aux.fisch'></span>

<h3>Description</h3>

<p>Poisson equation is one of most well-known elliptic partial differential equations. In order to
give a concrete example, a discrete Poisson matrix is generated, assuming we have <code>N</code> number of
grid points for each dimension under square domain. <em>fisch</em> is a German word for Poisson.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aux.fisch(N, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aux.fisch_+3A_n">N</code></td>
<td>
<p>the number of grid points for each direction.</p>
</td></tr>
<tr><td><code id="aux.fisch_+3A_sparse">sparse</code></td>
<td>
<p>a logical; <code>TRUE</code> for returning sparse matrix, <code>FALSE</code> otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code class="reqn">(N^2 \times N^2)</code> matrix having block banded structure.
</p>


<h3>References</h3>

<p>Golub, G. H. and Van Loan, C. F. (1996) <em>Matrix Computations, 3rd Ed.</em>, pages 177–180.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate dense and sparse Poisson matrix of size 25 by 25.
A = aux.fisch(5, sparse=FALSE)
B = aux.fisch(5, sparse=TRUE)
(all(A==B)) # TRUE if two matrices are equal.


</code></pre>

<hr>
<h2 id='lsolve.bicg'>Biconjugate Gradient method</h2><span id='topic+lsolve.bicg'></span>

<h3>Description</h3>

<p>Biconjugate Gradient(BiCG) method is a modification of Conjugate Gradient for nonsymmetric systems using
evaluations with respect to <code class="reqn">A^T</code> as well as <code class="reqn">A</code> in matrix-vector multiplications.
For an overdetermined system where <code>nrow(A)&gt;ncol(A)</code>,
it is automatically transformed to the normal equation. Underdetermined system -
<code>nrow(A)&lt;ncol(A)</code> - is not supported. Preconditioning matrix <code class="reqn">M</code>, in theory, should be symmetric and positive definite
with fast computability for inverse, though it is not limited until the solver level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.bicg(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 10000,
  preconditioner = diag(ncol(A)),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.bicg_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.bicg_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.bicg_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.bicg_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.bicg_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.bicg_+3A_preconditioner">preconditioner</code></td>
<td>
<p>an <code class="reqn">(n\times n)</code> preconditioning matrix; default is an identity matrix.</p>
</td></tr>
<tr><td><code id="lsolve.bicg_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Fletcher R (1976).
&ldquo;Conjugate gradient methods for indefinite systems.&rdquo;
In Watson GA (ed.), <em>Numerical Analysis</em>, volume 506, 73&ndash;89.
Springer Berlin Heidelberg, Berlin, Heidelberg.
ISBN 978-3-540-07610-0 978-3-540-38129-7.
</p>
<p>Voevodin VV (1983).
&ldquo;The question of non-self-adjoint extension of the conjugate gradients method is closed.&rdquo;
<em>USSR Computational Mathematics and Mathematical Physics</em>, <b>23</b>(2), 143&ndash;144.
ISSN 00415553.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.cg(A,b)
out2 = lsolve.bicg(A,b)
matout = cbind(matrix(x),out1$x, out2$x);
colnames(matout) = c("true x","CG result", "BiCG result")
print(matout)

</code></pre>

<hr>
<h2 id='lsolve.bicgstab'>Biconjugate Gradient Stabilized Method</h2><span id='topic+lsolve.bicgstab'></span>

<h3>Description</h3>

<p>Biconjugate Gradient Stabilized(BiCGSTAB) method is a stabilized version of Biconjugate Gradient method for nonsymmetric systems using
evaluations with respect to <code class="reqn">A^T</code> as well as <code class="reqn">A</code> in matrix-vector multiplications.
For an overdetermined system where <code>nrow(A)&gt;ncol(A)</code>,
it is automatically transformed to the normal equation. Underdetermined system -
<code>nrow(A)&lt;ncol(A)</code> - is not supported. Preconditioning matrix <code class="reqn">M</code>, in theory, should be symmetric and positive definite
with fast computability for inverse, though it is not limited until the solver level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.bicgstab(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 1000,
  preconditioner = diag(ncol(A)),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.bicgstab_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.bicgstab_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.bicgstab_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.bicgstab_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.bicgstab_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.bicgstab_+3A_preconditioner">preconditioner</code></td>
<td>
<p>an <code class="reqn">(n\times n)</code> preconditioning matrix; default is an identity matrix.</p>
</td></tr>
<tr><td><code id="lsolve.bicgstab_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>van der Vorst HA (1992).
&ldquo;Bi-CGSTAB: A Fast and Smoothly Converging Variant of Bi-CG for the Solution of Nonsymmetric Linear Systems.&rdquo;
<em>SIAM Journal on Scientific and Statistical Computing</em>, <b>13</b>(2), 631&ndash;644.
ISSN 0196-5204, 2168-3417.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.cg(A,b)
out2 = lsolve.bicg(A,b)
out3 = lsolve.bicgstab(A,b)
matout = cbind(matrix(x),out1$x, out2$x, out3$x);
colnames(matout) = c("true x","CG result", "BiCG result", "BiCGSTAB result")
print(matout)


</code></pre>

<hr>
<h2 id='lsolve.cg'>Conjugate Gradient method</h2><span id='topic+lsolve.cg'></span>

<h3>Description</h3>

<p>Conjugate Gradient(CG) method is an iterative algorithm for solving a system of linear equations where the system
is symmetric and positive definite.
For a square matrix <code class="reqn">A</code>, it is required to be symmetric and positive definite.
For an overdetermined system where <code>nrow(A)&gt;ncol(A)</code>,
it is automatically transformed to the normal equation. Underdetermined system -
<code>nrow(A)&lt;ncol(A)</code> - is not supported. Preconditioning matrix <code class="reqn">M</code>, in theory, should be symmetric and positive definite
with fast computability for inverse, though it is not limited until the solver level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.cg(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 10000,
  preconditioner = diag(ncol(A)),
  adjsym = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.cg_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.cg_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.cg_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.cg_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.cg_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.cg_+3A_preconditioner">preconditioner</code></td>
<td>
<p>an <code class="reqn">(n\times n)</code> preconditioning matrix; default is an identity matrix.</p>
</td></tr>
<tr><td><code id="lsolve.cg_+3A_adjsym">adjsym</code></td>
<td>
<p>a logical; <code>TRUE</code> to symmetrize the system by transforming the system into normal equation, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="lsolve.cg_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hestenes MR, Stiefel E (1952).
&ldquo;Methods of conjugate gradients for solving linear systems.&rdquo;
<em>Journal of Research of the National Bureau of Standards</em>, <b>49</b>(6), 409.
ISSN 0091-0635.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.sor(A,b,w=0.5)
out2 = lsolve.cg(A,b)
matout = cbind(matrix(x),out1$x, out2$x);
colnames(matout) = c("true x","SSOR result", "CG result")
print(matout)

</code></pre>

<hr>
<h2 id='lsolve.cgs'>Conjugate Gradient Squared method</h2><span id='topic+lsolve.cgs'></span>

<h3>Description</h3>

<p>Conjugate Gradient Squared(CGS) method is an extension of Conjugate Gradient method where the system
is symmetric and positive definite. It aims at achieving faster convergence using an idea of
contraction operator twice. For a square matrix <code class="reqn">A</code>,it is required to be symmetric and positive definite.
For an overdetermined system where <code>nrow(A)&gt;ncol(A)</code>,
it is automatically transformed to the normal equation. Underdetermined system -
<code>nrow(A)&lt;ncol(A)</code> - is not supported. Preconditioning matrix <code class="reqn">M</code>, in theory, should be symmetric and positive definite
with fast computability for inverse, though it is not limited until the solver level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.cgs(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 10000,
  preconditioner = diag(ncol(A)),
  adjsym = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.cgs_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.cgs_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.cgs_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.cgs_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.cgs_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.cgs_+3A_preconditioner">preconditioner</code></td>
<td>
<p>an <code class="reqn">(n\times n)</code> preconditioning matrix; default is an identity matrix.</p>
</td></tr>
<tr><td><code id="lsolve.cgs_+3A_adjsym">adjsym</code></td>
<td>
<p>a logical; <code>TRUE</code> to symmetrize the system by transforming the system into normal equation, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="lsolve.cgs_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Sonneveld P (1989).
&ldquo;CGS, A Fast Lanczos-Type Solver for Nonsymmetric Linear systems.&rdquo;
<em>SIAM Journal on Scientific and Statistical Computing</em>, <b>10</b>(1), 36&ndash;52.
ISSN 0196-5204, 2168-3417.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.cg(A,b)
out2 = lsolve.cgs(A,b)
matout = cbind(matrix(x),out1$x, out2$x);
colnames(matout) = c("true x","CG result", "CGS result")
print(matout)

</code></pre>

<hr>
<h2 id='lsolve.cheby'>Chebyshev Method</h2><span id='topic+lsolve.cheby'></span>

<h3>Description</h3>

<p>Chebyshev method - also known as Chebyshev iteration - avoids computation of inner product,
enabling distributed-memory computation to be more efficient at the cost of requiring
a priori knowledge on the range of spectrum for matrix <code>A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.cheby(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 10000,
  preconditioner = diag(ncol(A)),
  adjsym = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.cheby_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.cheby_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.cheby_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.cheby_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.cheby_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.cheby_+3A_preconditioner">preconditioner</code></td>
<td>
<p>an <code class="reqn">(n\times n)</code> preconditioning matrix; default is an identity matrix.</p>
</td></tr>
<tr><td><code id="lsolve.cheby_+3A_adjsym">adjsym</code></td>
<td>
<p>a logical; <code>TRUE</code> to symmetrize the system by transforming the system into normal equation, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="lsolve.cheby_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gutknecht MH, Röllin S (2002).
&ldquo;The Chebyshev iteration revisited.&rdquo;
<em>Parallel Computing</em>, <b>28</b>(2), 263&ndash;283.
ISSN 01678191.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.sor(A,b,w=0.5)
out2 = lsolve.cheby(A,b)
matout = cbind(x, out1$x, out2$x);
colnames(matout) = c("original x","SOR result", "Chebyshev result")
print(matout)

</code></pre>

<hr>
<h2 id='lsolve.gmres'>Generalized Minimal Residual method</h2><span id='topic+lsolve.gmres'></span>

<h3>Description</h3>

<p>GMRES is a generic iterative solver for a nonsymmetric system of linear equations. As its name suggests, it approximates
the solution using Krylov vectors with minimal residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.gmres(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 1000,
  preconditioner = diag(ncol(A)),
  restart = (ncol(A) - 1),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.gmres_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.gmres_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.gmres_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.gmres_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.gmres_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.gmres_+3A_preconditioner">preconditioner</code></td>
<td>
<p>an <code class="reqn">(n\times n)</code> preconditioning matrix; default is an identity matrix.</p>
</td></tr>
<tr><td><code id="lsolve.gmres_+3A_restart">restart</code></td>
<td>
<p>the number of iterations before restart.</p>
</td></tr>
<tr><td><code id="lsolve.gmres_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Saad Y, Schultz MH (1986).
&ldquo;GMRES: A Generalized Minimal Residual Algorithm for Solving Nonsymmetric Linear Systems.&rdquo;
<em>SIAM Journal on Scientific and Statistical Computing</em>, <b>7</b>(3), 856&ndash;869.
ISSN 0196-5204, 2168-3417.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.cg(A,b)
out3_1 = lsolve.gmres(A,b,restart=2)
out3_2 = lsolve.gmres(A,b,restart=3)
out3_3 = lsolve.gmres(A,b,restart=4)
matout = cbind(matrix(x),out1$x, out3_1$x, out3_2$x, out3_3$x);
colnames(matout) = c("true x","CG", "GMRES(2)", "GMRES(3)", "GMRES(4)")
print(matout)


</code></pre>

<hr>
<h2 id='lsolve.gs'>Gauss-Seidel method</h2><span id='topic+lsolve.gs'></span>

<h3>Description</h3>

<p>Gauss-Seidel(GS) method is an iterative algorithm for solving a system of linear equations,
with a decomposition <code class="reqn">A = D+L+U</code> where <code class="reqn">D</code> is a diagonal matrix and
<code class="reqn">L</code> and U are strictly lower/upper triangular matrix respectively.
For a square matrix <code class="reqn">A</code>, it is required to be diagonally dominant or symmetric and positive definite.
For an overdetermined system where <code>nrow(A)&gt;ncol(A)</code>,
it is automatically transformed to the normal equation. Underdetermined system -
<code>nrow(A)&lt;ncol(A)</code> - is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.gs(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 1000,
  adjsym = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.gs_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.gs_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.gs_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.gs_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.gs_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.gs_+3A_adjsym">adjsym</code></td>
<td>
<p>a logical; <code>TRUE</code> to symmetrize the system by transforming the system into normal equation, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="lsolve.gs_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Demmel JW (1997).
<em>Applied Numerical Linear Algebra</em>.
Society for Industrial and Applied Mathematics.
ISBN 978-0-89871-389-3 978-1-61197-144-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out = lsolve.gs(A,b)
matout = cbind(matrix(x),out$x); colnames(matout) = c("true x","est from GS")
print(matout)

</code></pre>

<hr>
<h2 id='lsolve.jacobi'>Jacobi method</h2><span id='topic+lsolve.jacobi'></span>

<h3>Description</h3>

<p>Jacobi method is an iterative algorithm for solving a system of linear equations,
with a decomposition <code class="reqn">A = D+R</code> where <code class="reqn">D</code> is a diagonal matrix.
For a square matrix <code class="reqn">A</code>, it is required to be diagonally dominant. For an overdetermined system where <code>nrow(A)&gt;ncol(A)</code>,
it is automatically transformed to the normal equation. Underdetermined system -
<code>nrow(A)&lt;ncol(A)</code> - is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.jacobi(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 1000,
  weight = 2/3,
  adjsym = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.jacobi_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.jacobi_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.jacobi_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.jacobi_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.jacobi_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.jacobi_+3A_weight">weight</code></td>
<td>
<p>a real number in <code class="reqn">(0,1]</code>; 1 for native Jacobi.</p>
</td></tr>
<tr><td><code id="lsolve.jacobi_+3A_adjsym">adjsym</code></td>
<td>
<p>a logical; <code>TRUE</code> to symmetrize the system by transforming the system into normal equation, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="lsolve.jacobi_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Demmel JW (1997).
<em>Applied Numerical Linear Algebra</em>.
Society for Industrial and Applied Mathematics.
ISBN 978-0-89871-389-3 978-1-61197-144-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.jacobi(A,b,weight=1,verbose=FALSE)   # unweighted
out2 = lsolve.jacobi(A,b,verbose=FALSE)            # weight of 0.66
out3 = lsolve.jacobi(A,b,weight=0.5,verbose=FALSE) # weight of 0.50
print("* lsolve.jacobi : overdetermined case example")
print(paste("*   error for unweighted    Jacobi case : ",norm(out1$x-x)))
print(paste("*   error for 0.66 weighted Jacobi case : ",norm(out2$x-x)))
print(paste("*   error for 0.50 weighted Jacobi case : ",norm(out3$x-x)))

</code></pre>

<hr>
<h2 id='lsolve.qmr'>Quasi Minimal Residual Method</h2><span id='topic+lsolve.qmr'></span>

<h3>Description</h3>

<p>Quasia-Minimal Resudial(QMR) method is another remedy of the BiCG which shows
rather irregular convergence behavior. It adapts to solve the reduced tridiagonal system
in a least squares sense and its convergence is known to be quite smoother than BiCG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.qmr(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 1000,
  preconditioner = diag(ncol(A)),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.qmr_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.qmr_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.qmr_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.qmr_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.qmr_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.qmr_+3A_preconditioner">preconditioner</code></td>
<td>
<p>an <code class="reqn">(n\times n)</code> preconditioning matrix; default is an identity matrix.</p>
</td></tr>
<tr><td><code id="lsolve.qmr_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Freund RW, Nachtigal NM (1991).
&ldquo;QMR: a quasi-minimal residual method for non-Hermitian linear systems.&rdquo;
<em>Numerische Mathematik</em>, <b>60</b>(1), 315&ndash;339.
ISSN 0029-599X, 0945-3245.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.cg(A,b)
out2 = lsolve.bicg(A,b)
out3 = lsolve.qmr(A,b)
matout = cbind(matrix(x),out1$x, out2$x, out3$x);
colnames(matout) = c("true x","CG result", "BiCG result", "QMR result")
print(matout)

## End(Not run)

</code></pre>

<hr>
<h2 id='lsolve.sor'>Successive Over-Relaxation method</h2><span id='topic+lsolve.sor'></span>

<h3>Description</h3>

<p>Successive Over-Relaxation(SOR) method is a variant of Gauss-Seidel method for solving a system of linear equations,
with a decomposition <code class="reqn">A = D+L+U</code> where <code class="reqn">D</code> is a diagonal matrix and
<code class="reqn">L</code> and U are strictly lower/upper triangular matrix respectively.
For a square matrix <code class="reqn">A</code>, it is required to be diagonally dominant or symmetric and positive definite like GS method.
For an overdetermined system where <code>nrow(A)&gt;ncol(A)</code>,
it is automatically transformed to the normal equation. Underdetermined system -
<code>nrow(A)&lt;ncol(A)</code> - is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.sor(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 1000,
  w = 1,
  adjsym = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.sor_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.sor_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.sor_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.sor_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.sor_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.sor_+3A_w">w</code></td>
<td>
<p>a weight value in <code class="reqn">(0,2).</code>; <code>w=1</code> leads to Gauss-Seidel method.</p>
</td></tr>
<tr><td><code id="lsolve.sor_+3A_adjsym">adjsym</code></td>
<td>
<p>a logical; <code>TRUE</code> to symmetrize the system by transforming the system into normal equation, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="lsolve.sor_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Demmel JW (1997).
<em>Applied Numerical Linear Algebra</em>.
Society for Industrial and Applied Mathematics.
ISBN 978-0-89871-389-3 978-1-61197-144-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.sor(A,b)
out2 = lsolve.sor(A,b,w=0.5)
out3 = lsolve.sor(A,b,w=1.5)
matout = cbind(matrix(x),out1$x, out2$x, out3$x);
colnames(matout) = c("true x","SOR 1 = GS", "SOR w=0.5", "SOR w=1.5")
print(matout)

</code></pre>

<hr>
<h2 id='lsolve.ssor'>Symmetric Successive Over-Relaxation method</h2><span id='topic+lsolve.ssor'></span>

<h3>Description</h3>

<p>Symmetric Successive Over-Relaxation(SSOR) method is a variant of Gauss-Seidel method for solving a system of linear equations,
with a decomposition <code class="reqn">A = D+L+U</code> where <code class="reqn">D</code> is a diagonal matrix and
<code class="reqn">L</code> and U are strictly lower/upper triangular matrix respectively.
For a square matrix <code class="reqn">A</code>, it is required to be diagonally dominant or symmetric and positive definite like GS method.
For an overdetermined system where <code>nrow(A)&gt;ncol(A)</code>,
it is automatically transformed to the normal equation. Underdetermined system -
<code>nrow(A)&lt;ncol(A)</code> - is not supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lsolve.ssor(
  A,
  B,
  xinit = NA,
  reltol = 1e-05,
  maxiter = 1000,
  w = 1,
  adjsym = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lsolve.ssor_+3A_a">A</code></td>
<td>
<p>an <code class="reqn">(m\times n)</code> dense or sparse matrix. See also <code><a href="Matrix.html#topic+sparseMatrix">sparseMatrix</a></code>.</p>
</td></tr>
<tr><td><code id="lsolve.ssor_+3A_b">B</code></td>
<td>
<p>a vector of length <code class="reqn">m</code> or an <code class="reqn">(m\times k)</code> matrix (dense or sparse) for solving <code class="reqn">k</code> systems simultaneously.</p>
</td></tr>
<tr><td><code id="lsolve.ssor_+3A_xinit">xinit</code></td>
<td>
<p>a length-<code class="reqn">n</code> vector for initial starting point. <code>NA</code> to start from a random initial point near 0.</p>
</td></tr>
<tr><td><code id="lsolve.ssor_+3A_reltol">reltol</code></td>
<td>
<p>tolerance level for stopping iterations.</p>
</td></tr>
<tr><td><code id="lsolve.ssor_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="lsolve.ssor_+3A_w">w</code></td>
<td>
<p>a weight value in <code class="reqn">(0,2).</code>; <code>w=1</code> leads to Gauss-Seidel method.</p>
</td></tr>
<tr><td><code id="lsolve.ssor_+3A_adjsym">adjsym</code></td>
<td>
<p>a logical; <code>TRUE</code> to symmetrize the system by transforming the system into normal equation, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="lsolve.ssor_+3A_verbose">verbose</code></td>
<td>
<p>a logical; <code>TRUE</code> to show progress of computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing </p>

<dl>
<dt>x</dt><dd><p>solution; a vector of length <code class="reqn">n</code> or a matrix of size <code class="reqn">(n\times k)</code>.</p>
</dd>
<dt>iter</dt><dd><p>the number of iterations required.</p>
</dd>
<dt>errors</dt><dd><p>a vector of errors for stopping criterion.</p>
</dd>
</dl>



<h3>References</h3>

<p>Demmel JW (1997).
<em>Applied Numerical Linear Algebra</em>.
Society for Industrial and Applied Mathematics.
ISBN 978-0-89871-389-3 978-1-61197-144-6.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Overdetermined System
set.seed(100)
A = matrix(rnorm(10*5),nrow=10)
x = rnorm(5)
b = A%*%x

out1 = lsolve.ssor(A,b)
out2 = lsolve.ssor(A,b,w=0.5)
out3 = lsolve.ssor(A,b,w=1.5)
matout = cbind(matrix(x),out1$x, out2$x, out3$x);
colnames(matout) = c("true x","SSOR w=1", "SSOR w=0.5", "SSOR w=1.5")
print(matout)

</code></pre>

<hr>
<h2 id='Rlinsolve'>A Collection of Iterative Solvers for (Sparse) Linear System of Equations</h2><span id='topic+Rlinsolve'></span>

<h3>Description</h3>

<p>Solving a system of linear equations is one of the most fundamental
computational problems for many fields of mathematical studies, such as
regression from statistics or numerical partial differential equations.
We provide a list of both stationary and nonstationary solvers. Sparse
matrix class from <span class="pkg">Matrix</span> is also supported for large sparse system.
</p>


<h3>Non-square matrix</h3>

<p>For a matrix <code class="reqn">A</code> of size <code>(m-by-n)</code>, we say the system is
<strong>overdetermined</strong> if <code>m&gt;n</code>, <strong>underdetermined</strong> if <code>m&lt;n</code>, or
<strong>squared</strong> if <code>m=n</code>. In the current version, underdetermined system is
not supported; it will later appear with sparse constraints. For an overdetermined system,
it automatically transforms the problem into <em>normal equation</em>, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">Ax=b \rightarrow A^T Ax = A^T b</code>
</p>

<p>even though if suffers from worse condition number while having desirable property
of a system to be symmetric and positive definite.
</p>


<h3>Sparsity</h3>

<p><span class="pkg">RcppArmadillo</span> is extensively used in the package. In order for
bullet-proof transition between dense and sparse matrix, only 3 of
12 RcppArmadillo-supported sparse matrix formats have access to
our algorithms; <code>"dgCMatrix"</code>,<code>"dtCMatrix"</code> and <code>"dsCMatrix"</code>.
Please see <a href="https://CRAN.R-project.org/package=RcppArmadillo/vignettes/RcppArmadillo-sparseMatrix.pdf">the vignette</a>
on sparse matrix support from RcppArmadillo. If either of two inputs <code>A</code> or <code>b</code> is
sparse, all matrices involved are automatically transformed into sparse matrices.
</p>


<h3>Composition of the Package</h3>

<p>Following is a list of stationary methods,
</p>

<dl>
<dt><code><a href="#topic+lsolve.jacobi">lsolve.jacobi</a></code></dt><dd><p>Jacobi method</p>
</dd>
<dt><code><a href="#topic+lsolve.gs">lsolve.gs</a></code></dt><dd><p>Gauss-Seidel method</p>
</dd>
<dt><code><a href="#topic+lsolve.sor">lsolve.sor</a></code></dt><dd><p>Successive Over-Relaxation method</p>
</dd>
<dt><code><a href="#topic+lsolve.ssor">lsolve.ssor</a></code></dt><dd><p>Symmetric Successive Over-Relaxation method</p>
</dd>
</dl>
<p> as well as nonstationary (or, Krylov subspace) methods,
</p>

<dl>
<dt><code><a href="#topic+lsolve.bicg">lsolve.bicg</a></code></dt><dd><p>Bi-Conjugate Gradient method</p>
</dd>
<dt><code><a href="#topic+lsolve.bicgstab">lsolve.bicgstab</a></code></dt><dd><p>Bi-Conjugate Gradient Stabilized method</p>
</dd>
<dt><code><a href="#topic+lsolve.cg">lsolve.cg</a></code></dt><dd><p>Conjugate Gradient method</p>
</dd>
<dt><code><a href="#topic+lsolve.cgs">lsolve.cgs</a></code></dt><dd><p>Conjugate Gradient Squared method</p>
</dd>
<dt><code><a href="#topic+lsolve.cheby">lsolve.cheby</a></code></dt><dd><p>Chebyshev method</p>
</dd>
<dt><code><a href="#topic+lsolve.gmres">lsolve.gmres</a></code></dt><dd><p>Generalized Minimal Residual method</p>
</dd>
<dt><code><a href="#topic+lsolve.qmr">lsolve.qmr</a></code></dt><dd><p>Quasi-Minimal Residual method</p>
</dd>
</dl>

<p>Also, <code><a href="#topic+aux.fisch">aux.fisch</a></code> is provided to generate a sparse system of
discrete Poisson matrix from finite difference approximation scheme of Poisson equation
on 2-dimensional square domain.
</p>


<h3>References</h3>

<p>Demmel, J.W. (1997) <em>Applied Numerical Linear Algebra, 1st ed.</em>, SIAM.
</p>
<p>Barrett, R., Berry, M., Chan, T.F., Demmel, J., Donato, J., Dongarra, J.,
Eijkhout, V., Pozo, R., Romine, C., and van der Vorst, H. (1994) <em>Templates for the Solution
of Linear Systems: Building Blocks for Iterative Methods, 2nd ed.</em> Philadelphia, SIAM.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
