<!DOCTYPE html><html><head><title>Help for package UPMASK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {UPMASK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyse_randomKde2d'><p>Perform analysis of random 2d distributions</p></a></li>
<li><a href='#analyse_randomKde2d_AutoCalibrated'><p>Perform analysis of random 2d distributions (auto calibrated)</p></a></li>
<li><a href='#analyse_randomKde2d_smart'><p>Perform analysis of random 2d distributions</p></a></li>
<li><a href='#create_randomKde2d'><p>Compute the density based distance quantity using a 2D Kernel Density Estimation</p></a></li>
<li><a href='#create_smartTable'><p>Create a look up table</p></a></li>
<li><a href='#getStarsAtHighestDensityRegion'><p>Perform cut in the membership list based on the 2D space distribution</p></a></li>
<li><a href='#innerLoop'><p>UPMASK inner loop</p></a></li>
<li><a href='#kde2dForSubset'><p>Compute the density based distance quantity using a 2D Kernel Density Estimation</p></a></li>
<li><a href='#meanThreeSigRej'><p>Perform cuts in the data</p></a></li>
<li><a href='#outerLoop'><p>UPMASK outer loop</p></a></li>
<li><a href='#performCuts'><p>Perform cuts in the data</p></a></li>
<li><a href='#takeErrorsIntoAccount'><p>Take Errors Into Account for UPMASK analysis</p></a></li>
<li><a href='#UPMASK-package'>
<p>Unsupervised Photometric Membership Assignment in Stellar Clusters</p></a></li>
<li><a href='#UPMASKdata'><p>Run UPMASK in a data frame</p></a></li>
<li><a href='#UPMASKfile'><p>Run UPMASK in a file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unsupervised Photometric Membership Assignment in Stellar
Clusters</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-01-28</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alberto Krone-Martins &lt;algol@sim.ul.pt&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of the UPMASK method for performing membership
    assignment in stellar clusters in R. It is prepared to use photometry and
    spatial positions, but it can take into account other types of data. The
    method is able to take into account arbitrary error models, and it is
    unsupervised, data-driven, physical-model-free and relies on as few
    assumptions as possible. The approach followed for membership assessment is
    based on an iterative process, dimensionality reduction, a clustering
    algorithm and a kernel density estimation.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, MASS, RSQLite, DBI, dimRed, loe</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-01 17:18:39 UTC; brain</td>
</tr>
<tr>
<td>Author:</td>
<td>Alberto Krone-Martins [aut, cre],
  Andre Moitinho [aut],
  Eduardo Bezerra [ctb],
  Leonardo Lima [ctb],
  Tristan Cantat-Gaudin [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-01 17:43:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyse_randomKde2d'>Perform analysis of random 2d distributions</h2><span id='topic+analyse_randomKde2d'></span>

<h3>Description</h3>

<p><code>analyse_randomKde2d</code> will compute statistics from uniformly randomly
created 2D fields based on Kernel Density Estimations (calling the code <code><a href="#topic+create_randomKde2d">create_randomKde2d</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_randomKde2d(nfields=100, nstars, maxX, maxY, nKde=50, 
showStats=FALSE, returnStats=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyse_randomKde2d_+3A_nfields">nfields</code></td>
<td>
<p>an integer with the number of individual field realisations</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_+3A_nstars">nstars</code></td>
<td>
<p>an integer with the number of stars to consider</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_+3A_maxx">maxX</code></td>
<td>
<p>the length of the field in X</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_+3A_maxy">maxY</code></td>
<td>
<p>the length of the field in Y</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_+3A_nkde">nKde</code></td>
<td>
<p>the number of samplings of the kernel in each direction</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_+3A_showstats">showStats</code></td>
<td>
<p>a boolean indicating if the user wants to see statistics</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_+3A_returnstats">returnStats</code></td>
<td>
<p>a boolean indicating if the user wants statistics to be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the <code>mean</code> and <code>sd</code> fields containing the results 
of the random field analysis.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Runs the analysis on random fields
toyRes &lt;- analyse_randomKde2d(100, 200, 100, 100, showStats=TRUE)

# Clean the environment
rm(toyRes)
 
</code></pre>

<hr>
<h2 id='analyse_randomKde2d_AutoCalibrated'>Perform analysis of random 2d distributions (auto calibrated)</h2><span id='topic+analyse_randomKde2d_AutoCalibrated'></span>

<h3>Description</h3>

<p>The experimental code <code>analyse_randomKde2d_AutoCalibrated</code> 
computes statistics from uniformly randomly created 2D fields based on kernel density 
estimations (using <code><a href="#topic+create_randomKde2d">create_randomKde2d</a></code>). It runs for as many 
interations as necessary for the statistical measuremnt stabilize (but it will abort
after <code>maxIter</code> iterations is reached).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_randomKde2d_AutoCalibrated(nstars, maxX, maxY, nKde=50, maxIter=40, 
                                          showStats=FALSE, returnStats=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyse_randomKde2d_AutoCalibrated_+3A_nstars">nstars</code></td>
<td>
<p>an integer with the number of stars to consider</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_AutoCalibrated_+3A_maxx">maxX</code></td>
<td>
<p>the length of the field in X</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_AutoCalibrated_+3A_maxy">maxY</code></td>
<td>
<p>the length of the field in Y</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_AutoCalibrated_+3A_nkde">nKde</code></td>
<td>
<p>the number of samplings of the kernel in each direction</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_AutoCalibrated_+3A_maxiter">maxIter</code></td>
<td>
<p>an integer with the maximum number of iterations</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_AutoCalibrated_+3A_showstats">showStats</code></td>
<td>
<p>a boolean indicating if the user wants to see statistics</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_AutoCalibrated_+3A_returnstats">returnStats</code></td>
<td>
<p>a boolean indicating if the user wants statistics to be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the <code>mean</code> and <code>sd</code> fields containing the results 
of the random field analysis.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Runs the analysis on random fields
toyRes &lt;- analyse_randomKde2d_AutoCalibrated(100, 100, 100, 100, showStats=TRUE)

# Clean the environment
rm(toyRes)
 
</code></pre>

<hr>
<h2 id='analyse_randomKde2d_smart'>Perform analysis of random 2d distributions</h2><span id='topic+analyse_randomKde2d_smart'></span>

<h3>Description</h3>

<p><code>analyse_randomKde2d_smart</code> will compute statistics from uniformly 
randomly created 2D fields based on Kernel Density Estimations (calling the code 
<code><a href="#topic+analyse_randomKde2d">analyse_randomKde2d</a></code>). However, if a random field using the same number of stars
was already computed in this run of UPMASK, it will avoid computing it again and will
return the value that is stored in a SQLite database table. If the random field was 
not yet analysed, it will run the analysis, store the result in the database table, and 
return the value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyse_randomKde2d_smart(nfields=100, nstars, maxX, maxY, nKde=50, 
showStats=FALSE, returnStats=TRUE, smartTableDB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyse_randomKde2d_smart_+3A_nfields">nfields</code></td>
<td>
<p>an integer with the number of individual field realisations</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_smart_+3A_nstars">nstars</code></td>
<td>
<p>an integer with the number of stars to consider</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_smart_+3A_maxx">maxX</code></td>
<td>
<p>the length of the field in X</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_smart_+3A_maxy">maxY</code></td>
<td>
<p>the length of the field in Y</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_smart_+3A_nkde">nKde</code></td>
<td>
<p>the number of samplings of the kernel in each direction</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_smart_+3A_showstats">showStats</code></td>
<td>
<p>a boolean indicating if the user wants to see statistics</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_smart_+3A_returnstats">returnStats</code></td>
<td>
<p>a boolean indicating if the user wants statistics to be returned</p>
</td></tr>
<tr><td><code id="analyse_randomKde2d_smart_+3A_smarttabledb">smartTableDB</code></td>
<td>
<p>a database connection to the smart look-up table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the <code>mean</code> and <code>sd</code> fields containing the results 
of the random field analysis.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create the smart look-up table
library(RSQLite)
stcon &lt;- create_smartTable()

# Runs the analysis on random fields
system.time(
toyRes1 &lt;- analyse_randomKde2d_smart(300, 200, 100, 100, smartTableDB=stcon)) # slow
system.time(
toyRes2 &lt;- analyse_randomKde2d_smart(300, 200, 100, 100, smartTableDB=stcon)) # quick

# Clean the environment
rm(list=c("toyRes1", "toyRes2"))
dbDisconnect(stcon)
 
</code></pre>

<hr>
<h2 id='create_randomKde2d'>Compute the density based distance quantity using a 2D Kernel Density Estimation</h2><span id='topic+create_randomKde2d'></span>

<h3>Description</h3>

<p><code>create_randomKde2d</code> will compute the 2D Kernel Density Estimation for 
a random sampling of the requested number of points and will return the quantiy 
<code>(max(d)-mean(d))/sd(d)</code>, if the option <code>returnDistance</code> is set to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_randomKde2d(nstars, maxX, maxY, nKde=50, printPlots=FALSE, 
showStats=FALSE, returnDistance=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_randomKde2d_+3A_nstars">nstars</code></td>
<td>
<p>an integer with the number of stars to consider</p>
</td></tr>
<tr><td><code id="create_randomKde2d_+3A_maxx">maxX</code></td>
<td>
<p>the length of the field in X</p>
</td></tr>
<tr><td><code id="create_randomKde2d_+3A_maxy">maxY</code></td>
<td>
<p>the length of the field in Y</p>
</td></tr>
<tr><td><code id="create_randomKde2d_+3A_nkde">nKde</code></td>
<td>
<p>the number of samplings of the kernel in each direction</p>
</td></tr>
<tr><td><code id="create_randomKde2d_+3A_printplots">printPlots</code></td>
<td>
<p>a boolean indicating if the user wants to see plots</p>
</td></tr>
<tr><td><code id="create_randomKde2d_+3A_showstats">showStats</code></td>
<td>
<p>a boolean indicating if the user wants to see statistics</p>
</td></tr>
<tr><td><code id="create_randomKde2d_+3A_returndistance">returnDistance</code></td>
<td>
<p>a boolean indicating if the user wants statistics to be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double representing the density based distance quantity.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>References</h3>

<p><a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins, A. &amp; Moitinho, A., A&amp;A, v.561, p.A57, 2014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute the density based distance quantity with random fields
distVar &lt;- create_randomKde2d(100, 10, 10, showStats=FALSE, 
                              printPlots=FALSE, returnDistance=TRUE)

# Clean the environment
rm(distVar)
 
</code></pre>

<hr>
<h2 id='create_smartTable'>Create a look up table</h2><span id='topic+create_smartTable'></span>

<h3>Description</h3>

<p><code>create_smartTable</code> will create a look up table for random 
field analysis inside an SQLite database. The table is automatically filled each time 
<code>UPMASK</code> calls the function <code><a href="#topic+analyse_randomKde2d_smart">analyse_randomKde2d_smart</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_smartTable()
</code></pre>


<h3>Value</h3>

<p>A data base connection to the SQLite database containing the smartTable.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create the table
library(RSQLite)
stcon &lt;- create_smartTable() 

# Clean the environment
dbDisconnect(stcon)

</code></pre>

<hr>
<h2 id='getStarsAtHighestDensityRegion'>Perform cut in the membership list based on the 2D space distribution</h2><span id='topic+getStarsAtHighestDensityRegion'></span>

<h3>Description</h3>

<p><code>getStarsAtHighestDensityRegion</code> will compute the 2D Kernel Density 
Estimation for the requested subset of data and will return only the stars in the most
dense region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getStarsAtHighestDensityRegion(ocdata_out, threshold=2, posIdx=c(1,2), 
plotAnalysis=FALSE, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getStarsAtHighestDensityRegion_+3A_ocdata_out">ocdata_out</code></td>
<td>
<p>a data frame to use</p>
</td></tr>
<tr><td><code id="getStarsAtHighestDensityRegion_+3A_threshold">threshold</code></td>
<td>
<p>a double with the thresholding level</p>
</td></tr>
<tr><td><code id="getStarsAtHighestDensityRegion_+3A_posidx">posIdx</code></td>
<td>
<p>an array of integers indicating the columns of the data frame containing the spatial positions</p>
</td></tr>
<tr><td><code id="getStarsAtHighestDensityRegion_+3A_plotanalysis">plotAnalysis</code></td>
<td>
<p>a boolean indicating if the anaylsis should be plotted</p>
</td></tr>
<tr><td><code id="getStarsAtHighestDensityRegion_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the code should be verbose</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the objects which were selected from <code>ocdata_out</code>
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple data set
toyDataDF &lt;- data.frame(x=runif(50, 0, 10), y=runif(50, 0, 10), resMclust.class=rep(1, 50))
toyDataDF &lt;- rbind(toyDataDF, data.frame(x=rnorm(50, 2, 3), 
                   y=rnorm(50, 4, 3), resMclust.class=rep(1, 50)))

# Perform the XY density based cut
toyRes &lt;- getStarsAtHighestDensityRegion(toyDataDF)

# Clean the environment
rm(list=c("toyDataDF", "toyRes"))
 
</code></pre>

<hr>
<h2 id='innerLoop'>UPMASK inner loop</h2><span id='topic+innerLoop'></span>

<h3>Description</h3>

<p><code>innerLoop</code> executes the UPMASK method's inner loop and returns 
the stars which were considered as cluster member stars.
</p>
<p>The <code>innerLoop</code> perform the PCA, runs the clustering algorithm and check for 
overdensities in the spatial distribution for the clustered stars in the PC space using
a 2d kernel density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>innerLoop(ocdata_full, ocdata, classAlgol="kmeans", autoThresholdLevel=3, 
autoThreshold=TRUE, iiter=0, plotIter=FALSE, verbosity=1, starsPerClust_kmeans=50, 
nstarts_kmeans=50, runId=0, autoCalibrated=FALSE, stopIfEmpty=FALSE, 
positionDataIndexes=c(1,2), smartTableDB, nDimsToKeep=4, dimRed="PCA", scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="innerLoop_+3A_ocdata_full">ocdata_full</code></td>
<td>
<p>a data frame with the data to perform the analysis</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_ocdata">ocdata</code></td>
<td>
<p>a data frame with the data to consider in the PCA step</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_classalgol">classAlgol</code></td>
<td>
<p>a string indicating the type of clustering algorithm to consider. Only k-means is implemented at this moment (defaults to kmeans)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_autothresholdlevel">autoThresholdLevel</code></td>
<td>
<p>an integer indicating the level for thresholding of the spatial distribution</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_autothreshold">autoThreshold</code></td>
<td>
<p>a boolean indicating if autoThresolding should be adopted (defaults to TRUE)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_iiter">iiter</code></td>
<td>
<p>and integer indicating the number of the iteration (passed by the <code>outerLoop</code>)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_plotiter">plotIter</code></td>
<td>
<p>a boolean indicating if the user wants to see iteration plots (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_verbosity">verbosity</code></td>
<td>
<p>a flag indicating the verbosity level: it can be 0 (no screen output at all), 1 (minimum), &gt;=2 (all)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_starsperclust_kmeans">starsPerClust_kmeans</code></td>
<td>
<p>an integer with the average number of stars per k-means cluster</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_nstarts_kmeans">nstarts_kmeans</code></td>
<td>
<p>an integer the amount of random re-initializations of the k-means clustering method (usually it is not necessary to modify this)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_runid">runId</code></td>
<td>
<p>an integer greater than zero indicating the run Id (passed by the <code>outerLoop</code>)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_autocalibrated">autoCalibrated</code></td>
<td>
<p>a boolean indicating if the number of random field realizations for the clustering check in the position space should be autocalibrated (experimental code, defaults to FALSE).</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_stopifempty">stopIfEmpty</code></td>
<td>
<p>a boolean indicating if the code should completely stop if no spatial clustering is detected (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_positiondataindexes">positionDataIndexes</code></td>
<td>
<p>an array of integers indicating the columns of the data frame containing the spatial position measurements</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_smarttabledb">smartTableDB</code></td>
<td>
<p>a database connection to the smart look-up table</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_ndimstokeep">nDimsToKeep</code></td>
<td>
<p>an integer with the number of dimensions to consider (defaults to 4)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_dimred">dimRed</code></td>
<td>
<p>a string with the dimensionality reduction method to use (defaults to PCA. The only other options are LaplacianEigenmaps or None)</p>
</td></tr>
<tr><td><code id="innerLoop_+3A_scale">scale</code></td>
<td>
<p>a boolean indicating if the data should be scaled and centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with objects considered as members at this iteration.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>References</h3>

<p><a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins, A. &amp; Moitinho, A., A&amp;A, v.561, p.A57, 2014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Perform a one run of the innerLoop using a simulated open cluster with 
# spatial and photometric data 
# Load the data into a data frame
fileName &lt;- "oc_12_500_1000_1.0_p019_0880_1_25km_120nR_withcolors.dat"
inputFileName &lt;- system.file("extdata", fileName, package="UPMASK")
ocData &lt;- read.table(inputFileName, header=TRUE)
ocData &lt;- data.frame(ocData, id=(1:length(ocData[,1]))) # create an id

# Prepare the data to run the inner loop
posIdx &lt;- c(1,2)
photIdx &lt;- c(3,5,7,9,11,19,21,23,25,27)

# Create the look up table
library(RSQLite)
stcon &lt;- create_smartTable()

# Run the inner loop 
innerLoopRes &lt;- innerLoop(ocData, ocData[,photIdx], autoThresholdLevel=1, verbosity=2,
                          starsPerClust_kmeans=25, positionDataIndexes=posIdx, 
                          smartTableDB=stcon)

# Clean the environment
rm(list=c("inputFileName", "ocData", "posIdx", "photIdx", "innerLoopRes", 
   "fileName"))
dbDisconnect(stcon)

## End(Not run) 
 
</code></pre>

<hr>
<h2 id='kde2dForSubset'>Compute the density based distance quantity using a 2D Kernel Density Estimation</h2><span id='topic+kde2dForSubset'></span>

<h3>Description</h3>

<p><code>kde2dForSubset</code> will compute the 2D Kernel Density Estimation for 
the requested subset of data and will return the quantiy <code>(max(d)-mean(d))/sd(d)</code>
if the option <code>returnDistance</code> is set to TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kde2dForSubset(df, setw=1, n=50, showStats=TRUE, printPlots=TRUE, 
returnDistance=FALSE, positionDataIndexes=c(1,2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kde2dForSubset_+3A_df">df</code></td>
<td>
<p>a data frame to use</p>
</td></tr>
<tr><td><code id="kde2dForSubset_+3A_setw">setw</code></td>
<td>
<p>an integer with the class of the stars to perform the analysis</p>
</td></tr>
<tr><td><code id="kde2dForSubset_+3A_n">n</code></td>
<td>
<p>the number of points in the regular grid of the density estimation</p>
</td></tr>
<tr><td><code id="kde2dForSubset_+3A_showstats">showStats</code></td>
<td>
<p>a boolean indicating if the user wants to see output statistics</p>
</td></tr>
<tr><td><code id="kde2dForSubset_+3A_printplots">printPlots</code></td>
<td>
<p>a boolean indicating if the user wants to see plots</p>
</td></tr>
<tr><td><code id="kde2dForSubset_+3A_returndistance">returnDistance</code></td>
<td>
<p>a boolean indicating if the distance between the max and the mean in units of standard deviations should be returned</p>
</td></tr>
<tr><td><code id="kde2dForSubset_+3A_positiondataindexes">positionDataIndexes</code></td>
<td>
<p>an array of integers indicating the columns of the file containing the spatial position measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A double representing the density based distance quantity.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>References</h3>

<p><a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins, A. &amp; Moitinho, A., A&amp;A, v.561, p.A57, 2014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple data set with the values and errors
toyDataDF &lt;- data.frame(x=runif(50, 0, 10), y=runif(50, 0, 10), resMclust.class=rep(1, 50))

# Run the KDE 2D analysis for the required subset
disV &lt;- kde2dForSubset(toyDataDF, showStats=FALSE, printPlots=FALSE, returnDistance=TRUE)

# Clean the environment
rm(list=c("toyDataDF", "disV"))
 
</code></pre>

<hr>
<h2 id='meanThreeSigRej'>Perform cuts in the data</h2><span id='topic+meanThreeSigRej'></span>

<h3>Description</h3>

<p><code>meanThreeSigRej</code> will perform an interative rejection using the mean
and three sigma of the data. The function will compute the mean and standard 
deviation of the input vector, reject all entries lying farther than three-sigma, and 
iterate until the mean varies (fractionaly) by less than the tolerance value. The 
function will return a data frame with the mean, standard deviation value and the 
number of iterations until the convergence was reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanThreeSigRej(vec, maxI, tolerance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanThreeSigRej_+3A_vec">vec</code></td>
<td>
<p>a vector with the data to consider</p>
</td></tr>
<tr><td><code id="meanThreeSigRej_+3A_maxi">maxI</code></td>
<td>
<p>an integer with the maximum amount of iterations allowed</p>
</td></tr>
<tr><td><code id="meanThreeSigRej_+3A_tolerance">tolerance</code></td>
<td>
<p>a double with the tolerance value (as <code>(old-new)/old</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the fields <code>mean</code>, <code>sd</code> (the standard deviation) and <code>convergenceAtIter</code> (the iteration where the convergence was reached).
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple data set with the values and errors
toyData &lt;- c(rnorm(30, mean=0, sd=5), 10000, 1000)

# Call the function to perform cuts
toyDataItStat &lt;- meanThreeSigRej(toyData)

cat(paste("True mean             = 0\n"))
cat(paste("Before rejection mean =",round(mean(toyData),2),"\n"))
cat(paste("After rejetion mean   =",round(toyDataItStat$mean,2),"\n"))

# Clean the environment
rm(list=c("toyData", "toyDataItStat"))
 
</code></pre>

<hr>
<h2 id='outerLoop'>UPMASK outer loop</h2><span id='topic+outerLoop'></span>

<h3>Description</h3>

<p><code>outerLoop</code> executes the UPMASK method's outer loop on a data frame, 
and returns another data frame as output, with the id of the object and it's 
classification as a stellar cluster member or not.
</p>
<p>The <code>outerLoop</code> perform cuts in the data if necessary (by calling 
<code><a href="#topic+performCuts">performCuts</a></code>), take errors in the data table into account if the user request (by
calling <code><a href="#topic+innerLoop">innerLoop</a></code>), runs the inner loop (by calling <code><a href="#topic+innerLoop">innerLoop</a></code>) until 
convergence of the membership list or util the maximum number of iterations is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outerLoop(ocdata_full, positionDataIndexes=c(1,2),
photometricDataIndexes=c(3,5,7,9,11,19,21,23,25,27),
photometricErrorDataIndexes=c(4,6,8,10,12,20,22,24,26,28), threshold=1, maxIter=25, 
plotIter=FALSE, verbose=FALSE, starsPerClust_kmeans=50, nstarts_kmeans=50, 
finalXYCut=FALSE, autoCalibrated=FALSE, considerErrors=FALSE, run=0, 
smartTableDB, nDimsToKeep=4, dimRed="PCA", scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outerLoop_+3A_ocdata_full">ocdata_full</code></td>
<td>
<p>a data frame with the data to perform the analysis</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_positiondataindexes">positionDataIndexes</code></td>
<td>
<p>an array of integers indicating the columns of the data frame containing the spatial position measurements</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_photometricdataindexes">photometricDataIndexes</code></td>
<td>
<p>an array of integers with the column numbers containing photometric measurements (or any other measurement to go into the PCA step)</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_photometricerrordataindexes">photometricErrorDataIndexes</code></td>
<td>
<p>an array of integers with the column numbers containing the errors of the photometric measurements</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_threshold">threshold</code></td>
<td>
<p>a double indicating the thresholding level for the random field analysis</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_maxiter">maxIter</code></td>
<td>
<p>an integer the maximum amount of iterations of the outer loop before giving up convergence (usually it is not necessary to modify this)</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_plotiter">plotIter</code></td>
<td>
<p>a boolean indicating if the user wants to see iteration plots</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the output to screen should be verbose</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_starsperclust_kmeans">starsPerClust_kmeans</code></td>
<td>
<p>an integer with the average number of stars per k-means cluster</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_nstarts_kmeans">nstarts_kmeans</code></td>
<td>
<p>an integer the amount of random re-initializations of the k-means clustering method (usually it is not necessary to modify this)</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_finalxycut">finalXYCut</code></td>
<td>
<p>a boolean indicating if a final cut in the XY space should be performed (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_autocalibrated">autoCalibrated</code></td>
<td>
<p>a boolean indicating if the number of random field realizations for the clustering check in the position space should be autocalibrated (experimental code, defaults to FALSE).</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_considererrors">considerErrors</code></td>
<td>
<p>a boolean indicating if the errors should be taken into account</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_run">run</code></td>
<td>
<p>an integer greater than zero indicating the run number</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_smarttabledb">smartTableDB</code></td>
<td>
<p>a database connection to the smart look-up table</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_ndimstokeep">nDimsToKeep</code></td>
<td>
<p>an integer with the number of dimensions to consider (defaults to 4)</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_dimred">dimRed</code></td>
<td>
<p>a string with the dimensionality reduction method to use (defaults to PCA. The only other options are LaplacianEigenmaps or None)</p>
</td></tr>
<tr><td><code id="outerLoop_+3A_scale">scale</code></td>
<td>
<p>a boolean indicating if the data should be scaled and centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the id and class (member / not member) of each object at this run.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>References</h3>

<p><a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins, A. &amp; Moitinho, A., A&amp;A, v.561, p.A57, 2014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Perform a one run of the outerLoop using a simulated open cluster with 
# spatial and photometric data 
# Load the data into a data frame
fileName &lt;- "oc_12_500_1000_1.0_p019_0880_1_25km_120nR_withcolors.dat"
inputFileName &lt;- system.file("extdata", fileName, package="UPMASK")
ocData &lt;- read.table(inputFileName, header=TRUE)

# Create the look up table
library(RSQLite)
stcon &lt;- create_smartTable()

# Run the outer loop 
posIdx &lt;- c(1,2)
photIdx &lt;- c(3,5,7,9,11,19,21,23,25,27)
photErrIdx &lt;- c(4,6,8,10,12,20,22,24,26,28)
outerLoopRes &lt;- outerLoop(ocData, posIdx, photIdx, PhotErrIdx,
                          starsPerClust_kmeans=25, verbose=TRUE, smartTableDB=stcon)

# Clean the environment
rm(list=c("inputFileName", "ocData", "posIdx", "photIdx", "photErrIdx", 
          "outerLoopRes", "fileName"))
dbDisconnect(stcon)

## End(Not run) 
 
</code></pre>

<hr>
<h2 id='performCuts'>Perform cuts in the data</h2><span id='topic+performCuts'></span>

<h3>Description</h3>

<p><code>performCuts</code> will perform cuts in the data. This function is provided
as a place holder, and it is empty, but it is called by <code>UPMASK</code>, so if the user 
needs to perform cuts in the data for the UPMASK analysis, this function should be 
tailored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performCuts(originalData)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performCuts_+3A_originaldata">originalData</code></td>
<td>
<p>a data frame to use as the baseline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple data set with the values and errors
toyDataDF &lt;- data.frame(x=runif(10, 0, 10), dx=rep(0.2, 10), y=runif(10, 0, 10), 
                        dy=rep(0.1, 10))

# Call the function to perform cuts
newToyDataDF &lt;- performCuts(toyDataDF)

# Clean the environment
rm(list=c("toyDataDF", "newToyDataDF"))
 
</code></pre>

<hr>
<h2 id='takeErrorsIntoAccount'>Take Errors Into Account for UPMASK analysis</h2><span id='topic+takeErrorsIntoAccount'></span>

<h3>Description</h3>

<p>Based on a data frame containing measurements and errors, the 
<code>takeErrorsIntoAccount</code> will produce another data frame where each measurement of 
the original data frame is replaced by another value taken from a random distribution. 
The implemented error model is gaussian, so each value of the output data frame will
be a random sampling from a gaussian distribution where the mean is the value in the 
original data frame (indicated by the <code>photometricDataIndexes</code> column argument) 
and the standard deviation is the value from its corresponding error (indicated by the 
<code>photometricErrorDataIndexes</code> column argument). The newly constructed dataframe
is returned by the function.
</p>
<p>The user can adapt this function so it can take any error model into account during the
UPMASK analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>takeErrorsIntoAccount(originalData, dataIndexes, errorIndexes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="takeErrorsIntoAccount_+3A_originaldata">originalData</code></td>
<td>
<p>a data frame to use as the baseline</p>
</td></tr>
<tr><td><code id="takeErrorsIntoAccount_+3A_dataindexes">dataIndexes</code></td>
<td>
<p>an array of integers indicating the columns corresponding to the measurements</p>
</td></tr>
<tr><td><code id="takeErrorsIntoAccount_+3A_errorindexes">errorIndexes</code></td>
<td>
<p>an array of integers indicating the columns corresponding to the errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the new values sampled from the error distributions.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>References</h3>

<p><a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins, A. &amp; Moitinho, A., A&amp;A, v.561, p.A57, 2014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a simple data set with the values and errors
toyDataDF &lt;- data.frame(x=runif(10, 0, 10), dx=rep(0.2, 10), y=runif(10, 0, 10), 
                        dy=rep(0.1, 10))

# Apply the error models to create another data frame
newToyDataDF &lt;- takeErrorsIntoAccount(toyDataDF, c(1,3), c(2,4))

# Plot the results
plot(toyDataDF$x, toyDataDF$y)
points(newToyDataDF$x, newToyDataDF$y, pch=19, cex=0.8, col="red")

# Clean the environment
rm(list=c("toyDataDF", "newToyDataDF"))
 
</code></pre>

<hr>
<h2 id='UPMASK-package'>
Unsupervised Photometric Membership Assignment in Stellar Clusters
</h2><span id='topic+UPMASK-package'></span><span id='topic+UPMASK'></span>

<h3>Description</h3>

<p>An implementation of the UPMASK method for performing membership
assignment in stellar clusters in R. It is prepared to use photometry and
spatial positions, but it can take into account other types of data. The
method is able to take into account arbitrary error models, and it is
unsupervised, data-driven, physical-model-free and relies on as few
assumptions as possible. The approach followed for membership assessment is
based on an iterative process, principal component analysis, a clustering
algorithm and a kernel density estimation.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> UPMASK</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2017-06-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><img src="../help/figures/UPMASK-SimOC-Ex-Manual.jpg" alt="UPMASKexample" />

</p>
<p>The two main functions in the <code>UPMASK</code> package are <code><a href="#topic+UPMASKfile">UPMASKfile</a></code> and 
<code><a href="#topic+UPMASKdata">UPMASKdata</a></code>. The later will run the <code>UPMASK</code> method on data inside a 
data frame, while the former will perform the analysis on a file (the later deals with 
loading a file inside a data frame, calling the <code><a href="#topic+UPMASKdata">UPMASKdata</a></code> function and 
writing the results to an output file).
</p>
<p>The package includes data from two simulated fields comprising simulated data from cluster and 
field stars &ndash; to be used for demonstration. The analysis of these files using UPMASK lead 
to results presented in the figures above 
(from <a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins&amp;Moitinho, 2014</a>),
which show the spatial positions of the objects in the original datasets (in the left), 
the same objects but color coded by membership probability after the <code>UPMASK</code> analysis 
(in the center) and the color-magnitude diagram of all the stars also color coded by 
membership probability (in the right).
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>
<p>Maintainer: Alberto Krone-Martins &lt;algol@sim.ul.pt&gt;
</p>


<h3>References</h3>

<p><a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins, A. &amp; Moitinho, A., Astronomy&amp;Astrophysics, v.561, p.A57, 2014</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+UPMASKfile">UPMASKfile</a></code>, 
<code><a href="#topic+UPMASKdata">UPMASKdata</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#
# Example of how to run UPMASK using data from a file
# Note: serious analysis require larger nRuns, and see UPMASKfile documentation 
# for the parametrization.
# Write a string with the filename of the input and output files
inputFileName &lt;- system.file("extdata", 
             "oc_12_500_1000_1.0_p019_0880_1_25km_120nR_withcolors.dat", package="UPMASK")
outputFileName &lt;- file.path(tempdir(), "RESULTS.dat")
# Run UPMASK
UPMASKfile(inputFileName, outputFileName, nRuns=5, starsPerClust_kmeans=25, 
          verbose=TRUE, fileWithHeader=TRUE)          
# Done, the results are written to the file outputFileName

#
# Example of how to run UPMASK using data from a data frame 
# Note: serious analysis require larger nRuns, and see UPMASKdata documentation 
# for the parametrization.
# Load the data into a data frame
inputFileName &lt;- system.file("extdata", 
             "oc_12_5000_4000_4.0_p019_0900_1_15km_120nR_withcolors.dat", package="UPMASK")
ocData &lt;- read.table(inputFileName, header=TRUE)
# Run UPMASK
upmaskRes &lt;- UPMASKdata(ocData, nRuns=5, starsPerClust_kmeans=25, verbose=TRUE)
# Done, the results are in the data frame upmaskRes

# Clean the environment
rm(list=c("inputFileName","outputFileName","ocData","upmaskRes"))

## End(Not run)
</code></pre>

<hr>
<h2 id='UPMASKdata'>Run UPMASK in a data frame</h2><span id='topic+UPMASKdata'></span>

<h3>Description</h3>

<p><code>UPMASKdata</code> executes the UPMASK method on a data frame, and returns 
another data frame as output, including the membership analysis result as additional 
columns. 
</p>
<p><code>UPMASKdata</code> is a method for performing membership assignment in stellar 
clusters. The distributed code is prepared to use photometry and spatial positions, 
but it can take into account other types of data as well. The method is able to take 
into account arbitrary error models (the used must rewrite the 
<code><a href="#topic+takeErrorsIntoAccount">takeErrorsIntoAccount</a></code> function), and it is unsupervised, data-driven, 
physical-model-free and relies on as few assumptions as possible. The approach followed
for membership assessment is based on an iterative process, dimensionality reduction, 
a clustering algorithm and a kernel density estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPMASKdata(dataTable, positionDataIndexes=c(1,2),
photometricDataIndexes=c(3,5,7,9,11,19,21,23,25,27),
photometricErrorDataIndexes=c(4,6,8,10,12,20,22,24,26,28), threshold=1, 
classAlgol="kmeans", maxIter=25, starsPerClust_kmeans=25, nstarts_kmeans=50, 
nRuns=8, runInParallel=FALSE, paralelization="multicore", independent=TRUE, 
verbose=FALSE, autoCalibrated=FALSE, considerErrors=FALSE, 
finalXYCut=FALSE, nDimsToKeep=4, dimRed="PCA", scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPMASKdata_+3A_datatable">dataTable</code></td>
<td>
<p>a data frame with the data to perform the analysis</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_positiondataindexes">positionDataIndexes</code></td>
<td>
<p>an array of integers indicating the columns of the data frame containing the spatial position measurements</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_photometricdataindexes">photometricDataIndexes</code></td>
<td>
<p>an array of integers with the column numbers containing photometric measurements (or any other measurement to go into the PCA step)</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_photometricerrordataindexes">photometricErrorDataIndexes</code></td>
<td>
<p>an array of integers with the column numbers containing the errors of the photometric measurements</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_threshold">threshold</code></td>
<td>
<p>a double indicating the thresholding level for the random field analysis</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_classalgol">classAlgol</code></td>
<td>
<p>a string indicating the type of clustering algorithm to consider. Only k-means is implemented at this moment (defaults to kmeans)</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_maxiter">maxIter</code></td>
<td>
<p>an integer the maximum amount of iterations of the outer loop before giving up convergence (usually it is not necessary to modify this)</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_starsperclust_kmeans">starsPerClust_kmeans</code></td>
<td>
<p>an integer with the average number of stars per k-means cluster</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_nstarts_kmeans">nstarts_kmeans</code></td>
<td>
<p>an integer the amount of random re-initializations of the k-means clustering method (usually it is not necessary to modify this)</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_nruns">nRuns</code></td>
<td>
<p>the total number of individual runs to execute the total number of outer loop runs to execute</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_runinparallel">runInParallel</code></td>
<td>
<p>a boolean indicating if the code should run in parallel</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_paralelization">paralelization</code></td>
<td>
<p>a string with the type of paralilization to use. the paralelization can be: &quot;multicore&quot; or &quot;MPIcluster&quot;. At this moment only &quot;multicore&quot; is implemented (defaults to multicore).</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_independent">independent</code></td>
<td>
<p>a boolean indicating if non-parallel runs should be completely independent</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the output to screen should be verbose</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_autocalibrated">autoCalibrated</code></td>
<td>
<p>a boolean indicating if the number of random field realizations for the clustering check in the position space should be autocalibrated (experimental code, defaults to FALSE).</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_considererrors">considerErrors</code></td>
<td>
<p>a boolean indicating if the errors should be taken into account</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_finalxycut">finalXYCut</code></td>
<td>
<p>a boolean indicating if a final cut in the XY space should be performed (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_ndimstokeep">nDimsToKeep</code></td>
<td>
<p>an integer with the number of dimensions to consider (defaults to 4)</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_dimred">dimRed</code></td>
<td>
<p>a string with the dimensionality reduction method to use (defaults to PCA. The only other options are LaplacianEigenmaps or None)</p>
</td></tr>
<tr><td><code id="UPMASKdata_+3A_scale">scale</code></td>
<td>
<p>a boolean indicating if the data should be scaled and centered</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the original data used to run the method and additional columns indicating the classification at each run, as well as a membership probability in the frequentist sense.
</p>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>References</h3>

<p><a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins, A. &amp; Moitinho, A., A&amp;A, v.561, p.A57, 2014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Analyse a simulated open cluster using spatial and photometric data 
# Load the data into a data frame
fileNameI &lt;- "oc_12_500_1000_1.0_p019_0880_1_25km_120nR_withcolors.dat"
inputFileName &lt;- system.file("extdata", fileNameI, package="UPMASK")
ocData &lt;- read.table(inputFileName, header=TRUE)

# Example of how to run UPMASK using data from a data frame
# (serious analysis require at least larger nRuns)
posIdx &lt;- c(1,2)
photIdx &lt;- c(3,5,7,9,11,19,21,23,25,27)
photErrIdx &lt;- c(4,6,8,10,12,20,22,24,26,28)

upmaskRes &lt;- UPMASKdata(ocData, posIdx, photIdx, PhotErrIdx, nRuns=2, 
                        starsPerClust_kmeans=25, verbose=TRUE)

# Create a simple raw plot to see the results
pCols &lt;- upmaskRes[,length(upmaskRes)]/max(upmaskRes[,length(upmaskRes)])
plot(upmaskRes[,1], upmaskRes[,2], col=rgb(0,0,0,pCols), cex=0.5, pch=19)

# Clean the environment
rm(list=c("inputFileName", "ocData", "posIdx", "photIdx", "photErrIdx", 
          "upmaskRes", "pCols"))

## End(Not run) 
 
</code></pre>

<hr>
<h2 id='UPMASKfile'>Run UPMASK in a file</h2><span id='topic+UPMASKfile'></span>

<h3>Description</h3>

<p><code>UPMASKfile</code> executes the UPMASK method using a file as an input
and writes another file as an output. This is a wrapper function that only reads a 
file into an R data frame, calls the <code>UPMASKdata</code> function using this data frame 
and the parameters passed by the user and writes the output into another file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPMASKfile(filenameWithPathInput, filenameWithPathOuput, 
positionDataIndexes=c(1,2), photometricDataIndexes=c(3,5,7,9,11,19,21,23,25,27),
photometricErrorDataIndexes=c(4,6,8,10,12,20,22,24,26,28), threshold=1, 
maxIter=20, starsPerClust_kmeans=50, nstarts_kmeans=50, nRuns=5, 
runInParallel=FALSE, paralelization="multicore", independent=TRUE, verbose=FALSE, 
autoCalibrated=FALSE, considerErrors=FALSE, finalXYCut=FALSE, 
fileWithHeader=FALSE, nDimsToKeep=4, dimRed="PCA", scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPMASKfile_+3A_filenamewithpathinput">filenameWithPathInput</code></td>
<td>
<p>a string indicating the file containing the data to run UPMASK on (with full path)</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_filenamewithpathouput">filenameWithPathOuput</code></td>
<td>
<p>a string indicating the file where the output shall be written (with full path)</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_positiondataindexes">positionDataIndexes</code></td>
<td>
<p>an array of integers indicating the columns of the file containing the spatial position measurements</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_photometricdataindexes">photometricDataIndexes</code></td>
<td>
<p>an array of integers with the column numbers containing photometric measurements (or any other measurement to go into the PCA step)</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_photometricerrordataindexes">photometricErrorDataIndexes</code></td>
<td>
<p>an array of integers with the column numbers containing the errors of the photometric measurements</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_threshold">threshold</code></td>
<td>
<p>a double indicating the thresholding level for the random field analysis</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_maxiter">maxIter</code></td>
<td>
<p>an integer the maximum amount of iterations of the outer loop before giving up convergence (usually it is not necessary to modify this)</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_starsperclust_kmeans">starsPerClust_kmeans</code></td>
<td>
<p>an integer with the average number of stars per k-means cluster</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_nstarts_kmeans">nstarts_kmeans</code></td>
<td>
<p>an integer the amount of random re-initializations of the k-means clustering method (usually it is not necessary to modify this)</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_nruns">nRuns</code></td>
<td>
<p>the total number of individual runs to execute the total number of outer loop runs to execute</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_runinparallel">runInParallel</code></td>
<td>
<p>a boolean indicating if the code should run in parallel</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_paralelization">paralelization</code></td>
<td>
<p>a string with the type of paralilization to use. the paralelization can be: &quot;multicore&quot; or &quot;MPIcluster&quot;. At this moment only &quot;multicore&quot; is implemented (defaults to multicore).</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_independent">independent</code></td>
<td>
<p>a boolean indicating if non-parallel runs should be completely independent</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the output to screen should be verbose</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_autocalibrated">autoCalibrated</code></td>
<td>
<p>a boolean indicating if the number of random field realizations for the clustering check in the position space should be autocalibrated (experimental code, defaults to FALSE).</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_considererrors">considerErrors</code></td>
<td>
<p>a boolean indicating if the errors should be taken into account</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_finalxycut">finalXYCut</code></td>
<td>
<p>a boolean indicating if a final cut in the XY space should be performed (defaults to FALSE)</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_filewithheader">fileWithHeader</code></td>
<td>
<p>a boolean indicating if the input file has a text header</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_ndimstokeep">nDimsToKeep</code></td>
<td>
<p>an integer with the number of dimensions to consider (defaults to 4)</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_dimred">dimRed</code></td>
<td>
<p>a string with the dimensionality reduction method to use (defaults to PCA. The only other options are LaplacianEigenmaps or None)</p>
</td></tr>
<tr><td><code id="UPMASKfile_+3A_scale">scale</code></td>
<td>
<p>a boolean indicating if the data should be scaled and centered</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alberto Krone-Martins, Andre Moitinho
</p>


<h3>References</h3>

<p><a href="http://dx.doi.org/10.1051/0004-6361/201321143">Krone-Martins, A. &amp; Moitinho, A., A&amp;A, v.561, p.A57, 2014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Analyse a simulated open cluster using spatial and photometric data 
# Create strings with filenames
fileNameI &lt;- "oc_12_500_1000_1.0_p019_0880_1_25km_120nR_withcolors.dat"
inputFileName &lt;- system.file("extdata", fileNameI, package="UPMASK")
outputFileName &lt;- file.path(tempdir(), "up-RESULTS.dat")

# Example of how to run UPMASK using data from a file
# (serious analysis require at least larger nRuns)
posIdx &lt;- c(1,2)
photIdx &lt;- c(3,5,7,9,11,19,21,23,25,27)
photErrIdx &lt;- c(4,6,8,10,12,20,22,24,26,28)
UPMASKfile(inputFileName, outputFileName, posIdx, photIdx, photErrIdx, nRuns=5, 
           starsPerClust_kmeans=25, verbose=TRUE, fileWithHeader=TRUE)

# Open the resulting file to inspect the results
tempResults &lt;- read.table(outputFileName, header=TRUE)

# Create a simple raw plot to see the results
pCols &lt;- tempResults[,length(tempResults)]/max(tempResults[,length(tempResults)])
plot(tempResults[,1], tempResults[,2], col=rgb(0,0,0,pCols), cex=0.5, pch=19)

# Clean the environment
rm(list=c("tempResults", "inputFileName", "outputFileName", "pCols", "fileNameI"))

## End(Not run) 
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
