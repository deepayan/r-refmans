<!DOCTYPE html><html lang="en"><head><title>Help for package frontiles</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {frontiles}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#frontiles-package'>
<p>alpha-quantile efficiency score and 2d/3d representation of frontier</p></a></li>
<li><a href='#alphafrontier.2d'><p>Representation of alpha-quantile efficiency frontier for 1 output and 1 input</p></a></li>
<li><a href='#alphafrontier.3d'>
<p>3d representation of alpha-quantile frontier in the case of 2 input and 1 output.</p></a></li>
<li><a href='#alphascore'><p>Calculates alpha-quantile efficiency score</p></a></li>
<li><a href='#burposte'><p>Burposte data</p></a></li>
<li><a href='#ordermfrontier.2d'><p>Representation of m-order efficiency frontier for 1 output and 1 input</p></a></li>
<li><a href='#ordermscore'><p>Calculates order-m efficiency score with asymptotic formula</p></a></li>
<li><a href='#ordermscore.boot'><p>Calculates order-m efficiency score with bootstrap algorithm</p></a></li>
<li><a href='#ROCscore'><p>The ROC curve to help choosing alpha and m parameters</p></a></li>
<li><a href='#spain'>
<p>Spain data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Partial Frontier Efficiency Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-31</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, rgl</td>
</tr>
<tr>
<td>Description:</td>
<td>It calculates the alpha-quantile proposed by Daouia and Simar (2007) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2006.07.002">doi:10.1016/j.jeconom.2006.07.002</a>&gt; and order-m efficiency score in multi-dimension proposed by Daouia and Gijbels (2011) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2010.12.002">doi:10.1016/j.jeconom.2010.12.002</a>&gt; and computes several summaries and representation of the associated frontiers in 2d and 3d.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>alphafrontier.2d.r alphafrontier.3d.r alphascore.r
ordermscore.r ordermscore.boot.r ordermfrontier.2d.r ROCscore.r</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 15:45:00 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Thibault Laurent [aut, cre, cph],
  Abdelaati Daouia [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thibault Laurent &lt;thibault.laurent@univ-tlse1.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-14 15:52:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='frontiles-package'>
alpha-quantile efficiency score and 2d/3d representation of frontier
</h2><span id='topic+frontiles-package'></span><span id='topic+frontiles'></span>

<h3>Description</h3>

<p>It calculates the alpha-quantile efficiency score and order-m score in multi-dimension and 
gives representation of alpha-quantile efficiency frontier. This
work was supported by the agence nationale de la recherche through the EPI project (ANR-08-BLAN-0106-01)
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> frontiles</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-01</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL Vesion 2 or later</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Abdelaati Daouia and Thibault Laurent
</p>
<p>Maintainer: &lt;thibault.laurent@univ-tlse1.fr&gt;
</p>


<h3>References</h3>

<p>Daouia, A. and L. Simar (2007), Nonparametric efficiency analysis: A multivariate conditional quantile approach, <em>Journal of Econometrics 140</em>, 375-400.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spain)
xobs=as.matrix(spain[,3:4])
yobs=as.matrix(spain[,1])
score.ref.1&lt;-alphascore(xobs,yobs)
</code></pre>

<hr>
<h2 id='alphafrontier.2d'>Representation of alpha-quantile efficiency frontier for 1 output and 1 input</h2><span id='topic+alphafrontier.2d'></span>

<h3>Description</h3>

<p>Representation of the alpha-quantile efficiency frontier (output, input or hyperbolic direction)
for a set of reference points (xobs, yobs) in 2D (1 output and 1 input).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphafrontier.2d(xobs, yobs, type="output", alpha=0.95, add=FALSE, 
confidence=FALSE, shade=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alphafrontier.2d_+3A_xobs">xobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times 1</code>, input of sample points</p>
</td></tr>
<tr><td><code id="alphafrontier.2d_+3A_yobs">yobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times 1</code>, output of sample points</p>
</td></tr>
<tr><td><code id="alphafrontier.2d_+3A_type">type</code></td>
<td>
<p>a direction to choose among &quot;output&quot;, &quot;input&quot; and &quot;hyper&quot;</p>
</td></tr>
<tr><td><code id="alphafrontier.2d_+3A_alpha">alpha</code></td>
<td>
<p>a scalar between 0 and 1</p>
</td></tr>
<tr><td><code id="alphafrontier.2d_+3A_add">add</code></td>
<td>
<p>a boolean with TRUE for keeping the active device</p>
</td></tr>    
<tr><td><code id="alphafrontier.2d_+3A_confidence">confidence</code></td>
<td>
<p>a boolean for representing a confidence interval</p>
</td></tr>    
<tr><td><code id="alphafrontier.2d_+3A_shade">shade</code></td>
<td>
<p>a boolean for shading the confidence interval</p>
</td></tr>   
<tr><td><code id="alphafrontier.2d_+3A_...">...</code></td>
<td>
<p>usual options for ploting the frontier, lty, col, etc.</p>
</td></tr>     
</table>


<h3>Details</h3>

<p>Actually, there is no confidence interval when type=&quot;hyper&quot;.
If type=&quot;input&quot; and confidence=TRUE, the y-axis is permuted with the x-axis</p>


<h3>Value</h3>

<p>No return value, used for plotting the alpha-quantile efficiency frontier for 1 output and 1 input</p>


<h3>Author(s)</h3>

<p> Abdelaati Daouia and Thibault Laurent </p>


<h3>References</h3>

<p>Daouia, A. and L. Simar (2007), Nonparametric efficiency analysis: A multivariate conditional quantile approach, <em>Journal of Econometrics 140</em>, 375-400.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordermfrontier.2d">ordermfrontier.2d</a></code>, <code><a href="#topic+alphascore">alphascore</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1st example
data(spain)
plot(y ~ x2, data = spain)
alphafrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "output",
  alpha = 0.95, col = 'red', lty = 2, add = TRUE)
alphafrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "input",
  alpha = 0.95, col = 'royalblue', lty = 3, add = TRUE)
alphafrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "hyper",
  alpha = 0.95, col = 'green', lty = 4, add = TRUE)
legend("topleft", title = "alpha-quantile frontier; alpha=0.95",
  legend = c("output direction", "input direction", "hyper direction"), 
  lty = 2:4, col = c("red", "royalblue", "green"))

# 2nd example
plot(y ~ x2, data = spain)
alphafrontier.2d(as.matrix(spain$x2), as.matrix(spain$y),
  type = "output", alpha = 1, add = TRUE)
alphafrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "output",
  alpha = 0.95, col = 'blue', lty = 2, add = TRUE)
ordermfrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "output",
  m = 30, col = 'green', lty = 3, add = TRUE)
legend("topleft", title = "output direction", legend = c("FDH", "alpha=0.95", "m=30"),
  lty = 1:3, col = c("black", "royalblue", "green"))

# 3rd example
alphafrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "output",
  confidence = TRUE, shade = TRUE, alpha = 0.98)
title("Alpha-quantile frontier with alpha=0.98 and its confidence interval")
</code></pre>

<hr>
<h2 id='alphafrontier.3d'>
3d representation of alpha-quantile frontier in the case of 2 input and 1 output. 
</h2><span id='topic+alphafrontier.3d'></span>

<h3>Description</h3>

<p>3d representation of alpha-quantile frontier for a set of reference points (xobs,yobs)
in the case of two input and one output. No representation yet 
for hyperbolic direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphafrontier.3d(xobs, yobs, type="output",alpha=0.95, digits=4, 
box.leg=TRUE, palette=heat_hcl, rgl=FALSE, n.class=NULL,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alphafrontier.3d_+3A_xobs">xobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times 2</code>, input of reference points</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_yobs">yobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times 1</code>, output of reference points</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_type">type</code></td>
<td>
<p>a character, &quot;output&quot; or &quot;input&quot; direction</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_alpha">alpha</code></td>
<td>
<p>a scalar</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_digits">digits</code></td>
<td>
<p>a precision parameter to compute the alpha-frontier</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_box.leg">box.leg</code></td>
<td>
<p>representation of a legend-box on the plot with the values of frontier</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_palette">palette</code></td>
<td>
<p>function to use for colors in case where option <code>col</code> has not been called. See package colorspace for more informations.</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_rgl">rgl</code></td>
<td>
<p>a boolean, for output direction, representation of the graphic in 3d if TRUE</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_n.class">n.class</code></td>
<td>
<p>a numeric, for output direction, the number of class</p>
</td></tr>
<tr><td><code id="alphafrontier.3d_+3A_...">...</code></td>
<td>
<p>usual parameters of function <code>plot</code>. Use the parameter <code>asp</code> to modify the scale of window...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In &quot;input&quot; direction:
You choose a value of output in the legend box, the efficiency-frontier of the input is represented with the corresponding color on the 2d graphic. 
In &quot;output&quot; direction : 
For calculate the alpha-quantile efficiency output frontier everywhere, we have
constructed a grid of size <code class="reqn">n \times n</code> by drawing vertical and horizontal lines
which intersect each reference observations. Then, we have calculated for each cell <code class="reqn">C_k</code>
<code class="reqn">k=1,...,n^2</code> the prediction of the alpha-quantile output
efficiency frontier which correspond to the <code class="reqn">\alpha^{th}</code> elements of the suite
<code class="reqn">\{y_j\}_{j=1,...,n_k}</code> where reference observations j,
<code class="reqn">j=1,...,n_k</code> verify
</p>
<p style="text-align: center;"><code class="reqn">\ x^1_j\leq\inf_{(x^1,x^2) \in C_k}x^1</code>
</p>
<p> and
<code class="reqn">x^2\leq\inf_{(x_1,x_2) \in C_k}x^2</code>.   <br />
We propose to use an algorithm which filled up cells with colors depending on the values
taken by the alpha-quantile output efficiency frontier. The algorithm attach the row
and vary the column as the folling figure can show it.
</p>


<h3>Value</h3>

<p>no values
</p>


<h3>Note</h3>

<p>The algorithm used is certainly not optimized. For a data set of 61 observations, the function
necessits 15.17s on an Optiplex GX745 2 duo 2.13GHz under Windows Vista and probably bugs beyond a
certain number of observation</p>


<h3>Author(s)</h3>

<p> Abdelaati Daouia and Thibault Laurent </p>


<h3>See Also</h3>

<p><code><a href="#topic+alphascore">alphascore</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(spain)
xyn &lt;- cbind(spain[, 3:4],spain[, 1])
xtab &lt;- as.matrix(xyn[, c(1,2)])
ytab &lt;- matrix(xyn[, 3])

# representation in 2-d

op &lt;- par(no.readonly = TRUE) # the whole list of settable par's.
alphafrontier.3d(xtab, ytab, type = "output", alpha = 0.6, xlab = "input 1",
 ylab = "input 2", main = "blabla") 
points(xtab, pch = 16)
par(op)
</code></pre>

<hr>
<h2 id='alphascore'>Calculates alpha-quantile efficiency score</h2><span id='topic+alphascore'></span>

<h3>Description</h3>

<p>Calculates alpha-quantile efficiency score (output, input and hyperbolic direction)
for a set of evaluation points (xeval, yeval) depending on reference points (xobs, yobs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphascore(xobs, yobs, xeval=xobs, yeval=yobs, alpha=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alphascore_+3A_xobs">xobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times p</code>, input of sample points</p>
</td></tr>
<tr><td><code id="alphascore_+3A_yobs">yobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times q</code>, output of sample points</p>
</td></tr>
<tr><td><code id="alphascore_+3A_xeval">xeval</code></td>
<td>
<p>a matrix of size <code class="reqn">n_2 \times p</code>, input of assessment points</p>
</td></tr>
<tr><td><code id="alphascore_+3A_yeval">yeval</code></td>
<td>
<p>a matrix of size <code class="reqn">n_2 \times q</code>, output of assessment points</p>
</td></tr>
<tr><td><code id="alphascore_+3A_alpha">alpha</code></td>
<td>
<p>a scalar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A score between 0 and 1 means that DMU is inefficient. If DMU greater than 1, DMU is super-efficient.   
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> object with the  alpha-quantile efficiency score in:
</p>
<table role = "presentation">
<tr><td><code>output</code></td>
<td>
<p>output direction</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>input direction</p>
</td></tr>
<tr><td><code>hyper</code></td>
<td>
<p>hyperbolic direction</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Abdelaati Daouia and Thibault Laurent </p>


<h3>References</h3>

<p>Daouia, A. and L. Simar (2007), Nonparametric efficiency analysis: A multivariate conditional quantile approach, <em>Journal of Econometrics 140</em>, 375-400.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alphafrontier.2d">alphafrontier.2d</a></code>, <code><a href="#topic+ordermscore">ordermscore</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1st example
data(spain)
res.alqf &lt;- alphascore(xobs = as.matrix(spain[, c(2, 3, 4)]),
               yobs = as.matrix(spain[, 1]), alpha = 0.8)

# 2nd example
data(burposte)
bur.samp &lt;- burposte[which(burposte$xinput &lt; 50000), ]
ind.samp &lt;- sample(nrow(bur.samp), 500)
xeval &lt;- as.matrix(bur.samp[ind.samp[1:100], 2])
yeval &lt;- as.matrix(bur.samp[ind.samp[1:100], 3])
xobs &lt;- as.matrix(bur.samp[ind.samp[101:500], 2])
yobs &lt;- as.matrix(bur.samp[ind.samp[101:500], 3])

alphafrontier.2d(xobs, yobs, alpha = 0.95)
points(xeval, yeval, pch = 16, col = 'red')
text(xeval, yeval, as.character(1:100), adj = 2, cex = 0.8)
score.new.0.95 &lt;- alphascore(xobs, yobs, xeval, yeval, alpha = 0.95)
</code></pre>

<hr>
<h2 id='burposte'>Burposte data</h2><span id='topic+burposte'></span>

<h3>Description</h3>

<p>Burposte data</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(burposte)</code></pre>


<h3>Format</h3>

<p>A data frame with 9521 observations on the following 3 variables.
</p>

<dl>
<dt><code>ident</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>xinput</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>yprod</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Cazals C., Florens J.-P., Simar L. (2002), Nonparametric frontier estimation: a robust approach, <em>Journal of Econometrics 106</em>, 1-25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(burposte)
</code></pre>

<hr>
<h2 id='ordermfrontier.2d'>Representation of m-order efficiency frontier for 1 output and 1 input</h2><span id='topic+ordermfrontier.2d'></span>

<h3>Description</h3>

<p>Representation of the m-order efficiency score (output, input or hyperbolic direction)
for a set of reference points (xobs, yobs) in 2D (1 output and 1 input).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordermfrontier.2d(xobs, yobs, type = "output", m = 30, add = FALSE,
     confidence = FALSE, shade = FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordermfrontier.2d_+3A_xobs">xobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times 1</code>, input of sample points</p>
</td></tr>
<tr><td><code id="ordermfrontier.2d_+3A_yobs">yobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times 1</code>, output of sample points</p>
</td></tr>
<tr><td><code id="ordermfrontier.2d_+3A_type">type</code></td>
<td>
<p>a direction to choose among &quot;output&quot;, &quot;input&quot; and &quot;hyper&quot;</p>
</td></tr>
<tr><td><code id="ordermfrontier.2d_+3A_m">m</code></td>
<td>
<p>an integer</p>
</td></tr>
<tr><td><code id="ordermfrontier.2d_+3A_add">add</code></td>
<td>
<p>a boolean with TRUE for keeping the active device</p>
</td></tr>    
<tr><td><code id="ordermfrontier.2d_+3A_confidence">confidence</code></td>
<td>
<p>a boolean for representing a confidence interval</p>
</td></tr>    
<tr><td><code id="ordermfrontier.2d_+3A_shade">shade</code></td>
<td>
<p>a boolean for shading the confidence interval</p>
</td></tr>   
<tr><td><code id="ordermfrontier.2d_+3A_...">...</code></td>
<td>
<p>usual options for ploting the frontier, lty, col, etc.</p>
</td></tr>     
</table>


<h3>Details</h3>

<p>Actually, there is no confidence interval when type=&quot;hyper&quot;.
If type=&quot;input&quot; and confidence=TRUE, the y-axis is permuted with the x-axis</p>


<h3>Value</h3>

<p>No return value, used for plotting the m-order efficiency frontier for 1 output and 1 input</p>


<h3>Author(s)</h3>

<p> Abdelaati Daouia and Thibault Laurent </p>


<h3>References</h3>

<p>Daouia, A. and L. Simar (2007), Nonparametric efficiency analysis: A multivariate conditional quantile approach, <em>Journal of Econometrics 140</em>, 375-400.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1st example
data(spain)
plot(y ~ x2, data = spain)
ordermfrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "output",
  m = 30, col = 'red', lty = 2, add = TRUE)
ordermfrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "input", m = 30,
  col = 'royalblue', lty = 3, add = TRUE)
ordermfrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "hyper", m = 30,
  col = 'green', lty = 4, add = TRUE)
legend("topleft", legend = c("output direction", "input direction", "hyper direction"),
  lty = 2:4, col = c("red", "royalblue", "green"))

# 2nd example
ordermfrontier.2d(as.matrix(spain$x2), as.matrix(spain$y), type = "output",
  confidence = TRUE, shade = TRUE, m = 30)
</code></pre>

<hr>
<h2 id='ordermscore'>Calculates order-m efficiency score with asymptotic formula</h2><span id='topic+ordermscore'></span>

<h3>Description</h3>

<p>Calculates order-m efficiency score (output, input and hyperbolic direction)
for a set of assessment points (xeval, yeval) depending on sample points (xobs, yobs),
using the formulas of Daouia and Gijbels (2011). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordermscore(xobs, yobs, xeval=xobs, yeval=yobs, m=30)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordermscore_+3A_xobs">xobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times p</code>, input of sample points</p>
</td></tr>
<tr><td><code id="ordermscore_+3A_yobs">yobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times q</code>, output of sample points</p>
</td></tr>
<tr><td><code id="ordermscore_+3A_xeval">xeval</code></td>
<td>
<p>a matrix of size <code class="reqn">n_2 \times p</code>, input of assessment points</p>
</td></tr>
<tr><td><code id="ordermscore_+3A_yeval">yeval</code></td>
<td>
<p>a matrix of size <code class="reqn">n_2 \times q</code>, output of assessment points</p>
</td></tr>
<tr><td><code id="ordermscore_+3A_m">m</code></td>
<td>
<p>an integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A score between 0 and 1 means that DMU is inefficient. If DMU greater than 1, DMU is super-efficient.   
The asymptotic formula of the order-m score are given in Daouia and Gijbels (2011). 
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> object with the order-m efficiency score in:
</p>
<table role = "presentation">
<tr><td><code>output</code></td>
<td>
<p>output direction</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>input direction</p>
</td></tr>
<tr><td><code>hyper</code></td>
<td>
<p>hyperbolic direction</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Abdelaati Daouia and Thibault Laurent </p>


<h3>References</h3>

<p>Daouia and Gijbels (2011), Robustness and inference in nonparametric partial-frontier modeling, 
<em>Journal of Econometrics</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alphascore">alphascore</a></code>, <code><a href="#topic+ordermfrontier.2d">ordermfrontier.2d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1st example
data(spain)
score.orderm&lt;-ordermscore(xobs = as.matrix(spain[, c(2, 3, 4)]),
                          yobs = as.matrix(spain[, 1]))

# 2nd example
data(burposte)
ind.samp &lt;- sample(nrow(burposte), 500)
xobs &lt;- as.matrix(burposte[ind.samp[1:100], 2])
yobs &lt;- as.matrix(burposte[ind.samp[1:100], 3])
xeval &lt;- as.matrix(burposte[ind.samp[101:500],2])
yeval &lt;- as.matrix(burposte[ind.samp[101:500], 3])
score.orderm.2 &lt;- ordermscore(xobs, yobs, xeval, yeval)
</code></pre>

<hr>
<h2 id='ordermscore.boot'>Calculates order-m efficiency score with bootstrap algorithm</h2><span id='topic+ordermscore.boot'></span>

<h3>Description</h3>

<p>Calculates order-m efficiency score (output, input and hyperbolic direction)
for a set of assessment points (xeval, yeval) depending on sample points (xobs, yobs), 
using the initial algorithm of Cazals et al. (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordermscore.boot(xobs, yobs, xeval=xobs, yeval=yobs, m=30, B=200, m.move=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordermscore.boot_+3A_xobs">xobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times p</code>, input of sample points</p>
</td></tr>
<tr><td><code id="ordermscore.boot_+3A_yobs">yobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times q</code>, output of sample points</p>
</td></tr>
<tr><td><code id="ordermscore.boot_+3A_xeval">xeval</code></td>
<td>
<p>a matrix of size <code class="reqn">n_2 \times p</code>, input of assessment points</p>
</td></tr>
<tr><td><code id="ordermscore.boot_+3A_yeval">yeval</code></td>
<td>
<p>a matrix of size <code class="reqn">n_2 \times q</code>, output of assessment points</p>
</td></tr>
<tr><td><code id="ordermscore.boot_+3A_m">m</code></td>
<td>
<p>an integer, the number of selected firms</p>
</td></tr>
<tr><td><code id="ordermscore.boot_+3A_b">B</code></td>
<td>
<p>an integer, the number of replication</p>
</td></tr>
<tr><td><code id="ordermscore.boot_+3A_m.move">m.move</code></td>
<td>
<p>a boolean, to choose different values of m</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the algorithm initially proposed by Cazals et al. (2002).
If m.move=TRUE, different values of m are given as suggested by Daouia et al (2009).
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> object with the average mean order-m efficiency score and standard deviation associated:
</p>
<table role = "presentation">
<tr><td><code>output</code></td>
<td>
<p>output direction</p>
</td></tr>
<tr><td><code>output</code></td>
<td>
<p>output direction</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>input direction</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>input direction</p>
</td></tr>
<tr><td><code>hyper</code></td>
<td>
<p>hyperbolic direction</p>
</td></tr> 
<tr><td><code>hyper</code></td>
<td>
<p>hyperbolic direction</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p> Abdelaati Daouia and Thibault Laurent </p>


<h3>References</h3>

<p>Cazals et al. (2002), Nonparametric frontier estimation: a robust approach, 
<em>Journal of Econometrics</em>.
</p>
<p>Daouia et al. (2009), Regularization of Nonparametric Frontier Estimators, <em>TSE working paper</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ordermscore">ordermscore</a></code>,<code><a href="#topic+alphascore">alphascore</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># 1st example
data(spain)
score.orderm.b &lt;- ordermscore.boot(xobs = as.matrix(spain[, c(2, 3, 4)]),
                    yobs = as.matrix(spain[, 1]))

system.time(
  ordermscore.boot(xobs = as.matrix(spain[, c(2, 3, 4)]), 
                 yobs = as.matrix(spain[, 1]))
)
system.time(
  ordermscore(xobs = as.matrix(spain[, c(2, 3, 4)]),
              yobs = as.matrix(spain[, 1]))
)

# 2nd example

data(burposte)
ind.samp &lt;- sample(nrow(burposte), 500)
xobs &lt;- as.matrix(burposte[ind.samp[1:100], 2])
yobs &lt;- as.matrix(burposte[ind.samp[1:100], 3])
xeval &lt;- as.matrix(burposte[ind.samp[101:500], 2])
yeval &lt;- as.matrix(burposte[ind.samp[101:500], 3])
score.orderm.2.b &lt;- ordermscore.boot(xobs, yobs, xeval, yeval)
 
</code></pre>

<hr>
<h2 id='ROCscore'>The ROC curve to help choosing alpha and m parameters</h2><span id='topic+ROCscore'></span>

<h3>Description</h3>

<p>Computes the percentage of firms super-efficient according to the parameter alpha 
for alpha-quantile score and m for m-order score in a given direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ROCscore(xobs, yobs, type="output")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ROCscore_+3A_xobs">xobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times p</code>, input of sample points</p>
</td></tr>
<tr><td><code id="ROCscore_+3A_yobs">yobs</code></td>
<td>
<p>a matrix of size <code class="reqn">n_1 \times q</code>, output of sample points</p>
</td></tr>
<tr><td><code id="ROCscore_+3A_type">type</code></td>
<td>
<p>a direction to choose among &quot;output&quot;, &quot;input&quot; and &quot;hyper&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A firm is super-efficient if it score is greater than 1. By consulting this graph, we may choose the values of alpha and m which correspond to the desired degree of robustness, 
i.e. the percentage of high performers of the population we want to exclude in our more realistic benchmarking comparison (see p.78 of Daraio and Simar, 2010). 
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> object with:
</p>
<table role = "presentation">
<tr><td><code>alpha</code></td>
<td>
<p>different values of alpha</p>
</td></tr>
<tr><td><code>f(alpha)</code></td>
<td>
<p>the percentage of firms super-efficient</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>different values of m</p>
</td></tr> 
<tr><td><code>f(m)</code></td>
<td>
<p>the percentage of firms super-efficient</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Abdelaati Daouia and Thibault Laurent </p>


<h3>References</h3>

<p>Daraio and Simar (2007),<em>Advanced Robust and Nonparametric Methods in Efficiency Analysis</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1st example
data(spain)
res.roc &lt;- ROCscore(xobs = as.matrix(spain[,c(2,3,4)]),
                    yobs = as.matrix(spain[,1]),
                    type = "output")
</code></pre>

<hr>
<h2 id='spain'>
Spain data
</h2><span id='topic+spain'></span>

<h3>Description</h3>

<p>Spain data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(spain)</code></pre>


<h3>Format</h3>

<p>A data frame with 61 observations on the following 4 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a numeric vector of output</p>
</dd>
<dt><code>x1</code></dt><dd><p>a numeric vector of input</p>
</dd>
<dt><code>x2</code></dt><dd><p>a numeric vector of input</p>
</dd>
<dt><code>x3</code></dt><dd><p>a numeric vector of input</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(spain)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
