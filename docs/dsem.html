<!DOCTYPE html><html lang="en"><head><title>Help for package dsem</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dsem}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_fitted_DAG'><p>Convert output from package dsem to phylopath</p></a></li>
<li><a href='#as_sem'><p>Convert dsem to sem output</p></a></li>
<li><a href='#bering_sea'><p>Bering Sea marine ecosystem</p></a></li>
<li><a href='#cAIC'><p>Calculate conditional AIC</p></a></li>
<li><a href='#classify_variables'><p>Classify variables path</p></a></li>
<li><a href='#convert_equations'><p>Convert equations notation</p></a></li>
<li><a href='#dsem'><p>Fit dynamic structural equation model</p></a></li>
<li><a href='#dsem_control'><p>Detailed control for dsem structure</p></a></li>
<li><a href='#dsemRTMB'><p>Fit dynamic structural equation model</p></a></li>
<li><a href='#isle_royale'><p>Isle Royale wolf and moose</p></a></li>
<li><a href='#list_parameters'><p>List fixed and random effects</p></a></li>
<li><a href='#logLik.dsem'><p>Marginal log-likelihood</p></a></li>
<li><a href='#loo_residuals'><p>Calculate leave-one-out residuals</p></a></li>
<li><a href='#make_dfa'><p>Make text for dynamic factor analysis</p></a></li>
<li><a href='#make_dsem_ram'><p>Make a RAM (Reticular Action Model)</p></a></li>
<li><a href='#parse_path'><p>Parse path</p></a></li>
<li><a href='#plot.dsem'><p>Simulate dsem</p></a></li>
<li><a href='#predict.dsem'><p>predictions using dsem</p></a></li>
<li><a href='#print.dsem'><p>Print fitted dsem object</p></a></li>
<li><a href='#read_model'><p>Make a RAM (Reticular Action Model)</p></a></li>
<li><a href='#residuals.dsem'><p>Calculate residuals</p></a></li>
<li><a href='#sea_otter'><p>Sea otter trophic cascade</p></a></li>
<li><a href='#simulate.dsem'><p>Simulate dsem</p></a></li>
<li><a href='#stepwise_selection'><p>Simulate dsem</p></a></li>
<li><a href='#summary.dsem'><p>summarize dsem</p></a></li>
<li><a href='#test_dsep'><p>Test d-separation</p></a></li>
<li><a href='#TMBAIC'><p>Calculate marginal AIC for a fitted model</p></a></li>
<li><a href='#total_effect'><p>Calculate total effects</p></a></li>
<li><a href='#vcov.dsem'><p>Extract Variance-Covariance Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit Dynamic Structural Equation Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-10</td>
</tr>
<tr>
<td>Imports:</td>
<td>TMB, Matrix, sem, igraph, utils, RTMB (&ge; 1.7.0), ggraph,
ggplot2, grid, methods, stats, ggm</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, AER, phylopath, rmarkdown, reshape, gridExtra, dynlm,
MARSS, ggpubr, vars, testthat, DHARMa</td>
</tr>
<tr>
<td>Enhances:</td>
<td>rstan, tmbstan</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>Description:</td>
<td>Applies dynamic structural equation models to time-series data
	with generic and simplified specification for simultaneous and lagged
	effects. Methods are described in Thorson et al. (2024)
	"Dynamic structural equation models synthesize ecosystem dynamics 
	constrained by ecological mechanisms."  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://james-thorson-noaa.github.io/dsem/">https://james-thorson-noaa.github.io/dsem/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/James-Thorson-NOAA/dsem/issues">https://github.com/James-Thorson-NOAA/dsem/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-13 02:12:49 UTC; James.Thorson</td>
</tr>
<tr>
<td>Author:</td>
<td>James Thorson <a href="https://orcid.org/0000-0001-7415-1010"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Maurice Goodman <a href="https://orcid.org/0000-0002-6874-2313"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Wouter van der Bijl
    <a href="https://orcid.org/0000-0002-7366-1868"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (template for d-separation test)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Thorson &lt;James.Thorson@noaa.gov&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-13 03:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_fitted_DAG'>Convert output from package dsem to phylopath</h2><span id='topic+as_fitted_DAG'></span>

<h3>Description</h3>

<p>Convert dsem to phylopath output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_fitted_DAG(
  fit,
  lag = 0,
  what = c("Estimate", "Std_Error", "p_value"),
  direction = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_fitted_DAG_+3A_fit">fit</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="as_fitted_DAG_+3A_lag">lag</code></td>
<td>
<p>which lag to output</p>
</td></tr>
<tr><td><code id="as_fitted_DAG_+3A_what">what</code></td>
<td>
<p>whether to output estimates <code>what="Estimate"</code>, standard errors <code>what="Std_Error"</code>
or p-values <code>what="Std_Error"</code></p>
</td></tr>
<tr><td><code id="as_fitted_DAG_+3A_direction">direction</code></td>
<td>
<p>whether to include one-sided arrows <code>direction=1</code>, or both one- and two-sided arrows <code>direction=c(1,2)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Convert output to format supplied by <code><a href="phylopath.html#topic+est_DAG">est_DAG</a></code>
</p>

<hr>
<h2 id='as_sem'>Convert dsem to sem output</h2><span id='topic+as_sem'></span>

<h3>Description</h3>

<p>Convert output from package dsem to sem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_sem(object, lag = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_sem_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="as_sem_+3A_lag">lag</code></td>
<td>
<p>what lag to extract and visualize</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Convert output to format supplied by <code><a href="sem.html#topic+sem">sem</a></code>
</p>

<hr>
<h2 id='bering_sea'>Bering Sea marine ecosystem</h2><span id='topic+bering_sea'></span>

<h3>Description</h3>

<p>Data used to demonstrate and test ecosystem synthesis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bering_sea)
</code></pre>

<hr>
<h2 id='cAIC'>Calculate conditional AIC</h2><span id='topic+cAIC'></span>

<h3>Description</h3>

<p>Calculates the conditional Akaike Information criterion (cAIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cAIC(object, what = c("cAIC", "EDF"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cAIC_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="cAIC_+3A_what">what</code></td>
<td>
<p>Whether to return the cAIC or the effective degrees of freedom
(EDF) for each group of random effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cAIC is designed to optimize the expected out-of-sample predictive
performance for new data that share the same random effects as the
in-sample (fitted) data, e.g., spatial interpolation.  In this sense,
it should be a fast approximation to optimizing the model structure
based on k-fold crossvalidation.
By contrast, <code>AIC</code> calculates the
marginal Akaike Information Criterion, which is designed to optimize
expected predictive performance for new data that have new random effects,
e.g., extrapolation, or inference about generative parameters.
</p>
<p>cAIC also calculates as a byproduct the effective degrees of freedom,
i.e., the number of fixed effects that would have an equivalent impact on
model flexibility as a given random effect.
</p>
<p>Both cAIC and EDF are calculated using Eq. 6 of Zheng Cadigan Thorson 2024.
</p>
<p>Note that, for models that include profiled fixed effects, these profiles
are turned off.
</p>


<h3>Value</h3>

<p>Either the cAIC, or the effective degrees of freedom (EDF) by group
of random effects
</p>


<h3>References</h3>

<p>**Deriving the general approximation to cAIC used here**
</p>
<p>Zheng, N., Cadigan, N., &amp; Thorson, J. T. (2024).
A note on numerical evaluation of conditional Akaike information for
nonlinear mixed-effects models (arXiv:2411.14185). arXiv.
<a href="https://doi.org/10.48550/arXiv.2411.14185">doi:10.48550/arXiv.2411.14185</a>
</p>
<p>**The utility of EDF to diagnose hierarchical model behavior**
</p>
<p>Thorson, J. T. (2024). Measuring complexity for hierarchical
models using effective degrees of freedom. Ecology,
105(7), e4327 <a href="https://doi.org/10.1002/ecy.4327">doi:10.1002/ecy.4327</a>
</p>

<hr>
<h2 id='classify_variables'>Classify variables path</h2><span id='topic+classify_variables'></span>

<h3>Description</h3>

<p><code>classify_variables</code> is copied from <code>sem:::classifyVariables</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_variables(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classify_variables_+3A_model">model</code></td>
<td>
<p>SEM model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Copied from package 'sem' under licence GPL (&gt;= 2) with permission from John Fox
</p>


<h3>Value</h3>

<p>Tagged-list defining exogenous and endogenous variables
</p>

<hr>
<h2 id='convert_equations'>Convert equations notation</h2><span id='topic+convert_equations'></span>

<h3>Description</h3>

<p>Converts equations to arrow-and-lag notation expected by dsem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_equations(equations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_equations_+3A_equations">equations</code></td>
<td>
<p>Specification for time-series structural equation model structure
including lagged or simultaneous effects.  See Details section in
<code><a href="#topic+convert_equations">convert_equations</a></code> for more description</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function modifies code copied from package
'sem' under licence GPL (&gt;= 2) with permission from John Fox.
</p>
<p>For specifyEquations, each input line is either a regression equation or the
specification of a variance or covariance. Regression equations are of the form
y = par1*x1 + par2*x2 + ... + park*xk
where y and the xs are variables in the model (either observed or latent),
and the pars are parameters. If a parameter is given as a numeric value
(e.g., 1) then it is treated as fixed. Note that no error variable is
included in the equation; error variances are specified via either
the covs argument, via V(y) = par (see immediately below), or are
added automatically to the model when, as by default, endog.variances=TRUE.
A regression equation may be split over more than one input by breaking at a +,
so that + is either the last non-blank character on a line or the
first non-blank character on the subsequent line.
</p>
<p>Variances are specified in the form V(var) = par and
covariances in the form C(var1, var2) = par, where the vars are
variables (observed or unobserved) in the model. The symbols V and C
may be in either lower- or upper-case. If par is a numeric value (e.g., 1)
then it is treated as fixed. In conformity with the RAM model,
a variance or covariance for an endogenous variable in the
model is an error variance or covariance.
</p>
<p>To set a start value for a free parameter, enclose the numeric
start value in parentheses after the parameter name, as parameter(value).
</p>

<hr>
<h2 id='dsem'>Fit dynamic structural equation model</h2><span id='topic+dsem'></span>

<h3>Description</h3>

<p>Fits a dynamic structural equation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsem(
  sem,
  tsdata,
  family = rep("fixed", ncol(tsdata)),
  estimate_delta0 = FALSE,
  prior_negloglike = NULL,
  control = dsem_control(),
  covs = colnames(tsdata)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsem_+3A_sem">sem</code></td>
<td>
<p>Specification for time-series structural equation model structure
including lagged or simultaneous effects.  See Details section in
<code><a href="#topic+make_dsem_ram">make_dsem_ram</a></code> for more description</p>
</td></tr>
<tr><td><code id="dsem_+3A_tsdata">tsdata</code></td>
<td>
<p>time-series data, as outputted using <code><a href="stats.html#topic+ts">ts</a></code></p>
</td></tr>
<tr><td><code id="dsem_+3A_family">family</code></td>
<td>
<p>Character-vector listing the distribution used for each column of <code>tsdata</code>, where
each element must be <code>fixed</code> (for no measurement error), 
<code>normal</code> for normal measurement error using an identity link,
<code>gamma</code> for a gamma measurement error using a fixed CV and log-link, 
<code>bernoulli</code> for a Bernoulli measurement error using a logit-link, or
<code>poisson</code> for a Poisson measurement error using a log-link.
<code>family="fixed"</code> is default behavior and assumes that a given variable is measured exactly.
Other options correspond to different specifications of measurement error.</p>
</td></tr>
<tr><td><code id="dsem_+3A_estimate_delta0">estimate_delta0</code></td>
<td>
<p>Boolean indicating whether to estimate deviations from equilibrium in initial year
as fixed effects, or alternatively to assume that dynamics start at some stochastic draw away from
the stationary distribution</p>
</td></tr>
<tr><td><code id="dsem_+3A_prior_negloglike">prior_negloglike</code></td>
<td>
<p>A user-provided function that takes as input the vector of fixed effects out$obj$par
returns the negative log-prior probability. For example
<code>prior_negloglike = function(obj) -1 * dnorm( obj$par[1], mean=0, sd=0.1, log=TRUE)</code>
specifies a normal prior probability
for the for the first fixed effect with mean of zero and logsd of 0.1.
NOTE:  this implementation does not work well with <code>tmbstan</code> and
is highly experimental.  If using priors, considering using <code><a href="#topic+dsemRTMB">dsemRTMB</a></code>
instead.  The option in <code>dsem</code> is mainly intended to validate its
use in <code>dsemRTMB</code>.  Note that the user must load RTMB using
<code>library(RTMB)</code> prior to running the model.</p>
</td></tr>
<tr><td><code id="dsem_+3A_control">control</code></td>
<td>
<p>Output from <code><a href="#topic+dsem_control">dsem_control</a></code>, used to define user
settings, and see documentation for that function for details.</p>
</td></tr>
<tr><td><code id="dsem_+3A_covs">covs</code></td>
<td>
<p>optional: a character vector of one or more elements, with each element giving a string of variable 
names, separated by commas. Variances and covariances among all variables in each such string are 
added to the model. Warning: covs=&quot;x1, x2&quot; and covs=c(&quot;x1&quot;, &quot;x2&quot;) are not equivalent: 
covs=&quot;x1, x2&quot; specifies the variance of x1, the variance of x2, and their covariance, 
while covs=c(&quot;x1&quot;, &quot;x2&quot;) specifies the variance of x1 and the variance of x2 but not their covariance.
These same covariances can be added manually via argument 'sem', but using argument 'covs' might
save time for models with many variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A DSEM involves (at a minimum):
</p>

<dl>
<dt>Time series</dt><dd><p>a matrix <code class="reqn">\mathbf X</code> where column <code class="reqn">\mathbf x_c</code> for variable c is
a time-series;</p>
</dd>
<dt>Path diagram</dt><dd><p>a user-supplied specification for the path coefficients, which
define the precision (inverse covariance) <code class="reqn">\mathbf Q</code> for a matrix of state-variables
and see <code><a href="#topic+make_dsem_ram">make_dsem_ram</a></code> for more details on the math involved.</p>
</dd>
</dl>

<p>The model also estimates the time-series mean <code class="reqn"> \mathbf{\mu}_c </code> for each variable.
The mean and precision matrix therefore define a Gaussian Markov random field for <code class="reqn">\mathbf X</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{vec}(\mathbf X) \sim \mathrm{MVN}( \mathrm{vec}(\mathbf{I_T} \otimes \mathbf{\mu}), \mathbf{Q}^{-1}) </code>
</p>

<p>Users can the specify
a distribution for measurement errors (or assume that variables are measured without error) using
argument <code>family</code>.  This defines the link-function <code class="reqn">g_c(.)</code> and distribution <code class="reqn">f_c(.)</code>
for each time-series <code class="reqn">c</code>:
</p>
<p style="text-align: center;"><code class="reqn"> y_{t,c} \sim f_c( g_c^{-1}( x_{t,c} ), \theta_c )</code>
</p>

<p><code>dsem</code> then estimates all specified coefficients, time-series means <code class="reqn">\mu_c</code>, and distribution
measurement errors <code class="reqn">\theta_c</code> via maximizing a log-marginal likelihood, while
also estimating state-variables <code class="reqn">x_{t,c}</code>.
<code>summary.dsem</code> then assembles estimates and standard errors in an easy-to-read format.
Standard errors for fixed effects (path coefficients, exogenoux variance parameters, and measurement error parameters)
are estimated from the matrix of second derivatives of the log-marginal likelihod,
and standard errors for random effects (i.e., missing or state-space variables) are estimated
from a generalization of this method (see <code><a href="TMB.html#topic+sdreport">sdreport</a></code> for details).
</p>


<h3>Value</h3>

<p>An object (list) of class 'dsem'. Elements include:
</p>

<dl>
<dt>obj</dt><dd><p>TMB object from <code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</dd>
<dt>ram</dt><dd><p>RAM parsed by <code>make_dsem_ram</code></p>
</dd>
<dt>model</dt><dd><p>SEM structure parsed by <code>make_dsem_ram</code> as intermediate description of model linkages</p>
</dd>
<dt>tmb_inputs</dt><dd><p>The list of inputs passed to <code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</dd>
<dt>opt</dt><dd><p>The output from <code><a href="stats.html#topic+nlminb">nlminb</a></code></p>
</dd>
<dt>sdrep</dt><dd><p>The output from <code><a href="TMB.html#topic+sdreport">sdreport</a></code></p>
</dd>
<dt>interal</dt><dd><p>Objects useful for package function, i.e., all arguments
passed during the call</p>
</dd>
<dt>run_time</dt><dd><p>Total time to run model</p>
</dd>
</dl>



<h3>References</h3>

<p>**Introducing the package, its features, and comparison with other software
(to cite when using dsem):**
</p>
<p>Thorson, J. T., Andrews, A., Essington, T., Large, S. (2024).
Dynamic structural equation models synthesize
ecosystem dynamics constrained by ecological mechanisms.
Methods in Ecology and Evolution. <a href="https://doi.org/10.1111/2041-210X.14289">doi:10.1111/2041-210X.14289</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define model
sem = "
  # Link, lag, param_name
  cprofits -&gt; consumption, 0, a1
  cprofits -&gt; consumption, 1, a2
  pwage -&gt; consumption, 0, a3
  gwage -&gt; consumption, 0, a3
  cprofits -&gt; invest, 0, b1
  cprofits -&gt; invest, 1, b2
  capital -&gt; invest, 0, b3
  gnp -&gt; pwage, 0, c2
  gnp -&gt; pwage, 1, c3
  time -&gt; pwage, 0, c1
"

# Load data
data(KleinI, package="AER")
TS = ts(data.frame(KleinI, "time"=time(KleinI) - 1931))
tsdata = TS[,c("time","gnp","pwage","cprofits",'consumption',
               "gwage","invest","capital")]

# Fit model
fit = dsem( sem=sem,
            tsdata = tsdata,
            estimate_delta0 = TRUE,
            control = dsem_control(quiet=TRUE) )
summary( fit )
plot( fit )
plot( fit, edge_label="value" )

</code></pre>

<hr>
<h2 id='dsem_control'>Detailed control for dsem structure</h2><span id='topic+dsem_control'></span>

<h3>Description</h3>

<p>Define a list of control parameters.  Note that
the format of this input is likely to change more rapidly than that of
<code><a href="#topic+dsem">dsem</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsem_control(
  nlminb_loops = 1,
  newton_loops = 1,
  trace = 0,
  eval.max = 1000,
  iter.max = 1000,
  getsd = TRUE,
  quiet = FALSE,
  run_model = TRUE,
  gmrf_parameterization = c("separable", "projection"),
  constant_variance = c("conditional", "marginal", "diagonal"),
  use_REML = TRUE,
  profile = NULL,
  parameters = NULL,
  map = NULL,
  getJointPrecision = FALSE,
  extra_convergence_checks = TRUE,
  lower = -Inf,
  upper = Inf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsem_control_+3A_nlminb_loops">nlminb_loops</code></td>
<td>
<p>Integer number of times to call <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_newton_loops">newton_loops</code></td>
<td>
<p>Integer number of Newton steps to do after running
<code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_trace">trace</code></td>
<td>
<p>Parameter values are printed every 'trace' iteration
for the outer optimizer. Passed to
'control' in <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_eval.max">eval.max</code></td>
<td>
<p>Maximum number of evaluations of the objective function
allowed. Passed to 'control' in <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_iter.max">iter.max</code></td>
<td>
<p>Maximum number of iterations allowed. Passed to 'control' in
<code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_getsd">getsd</code></td>
<td>
<p>Boolean indicating whether to call <code><a href="TMB.html#topic+sdreport">sdreport</a></code></p>
</td></tr>
<tr><td><code id="dsem_control_+3A_quiet">quiet</code></td>
<td>
<p>Boolean indicating whether to run model printing messages to terminal or not;</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_run_model">run_model</code></td>
<td>
<p>Boolean indicating whether to estimate parameters (the default), or
instead to return the model inputs and compiled TMB object without running;</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_gmrf_parameterization">gmrf_parameterization</code></td>
<td>
<p>Parameterization to use for the Gaussian Markov 
random field, where the default 'separable' constructs a precision matrix
that must be full rank, and the alternative 'projection' constructs
a full-rank and IID precision for variables over time, and then projects
this using the inverse-cholesky of the precision, where this projection
can be rank-deficient.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_constant_variance">constant_variance</code></td>
<td>
<p>Whether to specify a constant conditional variance 
<code class="reqn"> \mathbf{\Gamma \Gamma}^t</code> using the default <code>constant_variance="conditional"</code>, 
which results in a changing marginal variance      
along the specified causal graph when lagged paths are present. Alternatively, the user can
specify a constant marginal variance using <code>constant_variance="diagonal"</code>
or <code>constant_variance="marginal"</code>,
such that <code class="reqn"> \mathbf{\Gamma}</code> and <code class="reqn">\mathbf{I-P}</code> are rescaled to achieve this constraint.  
All options
are equivalent when the model includes no lags (only simultaneous effects) and
no covariances (no two-headed arrows).  <code>"diagonal"</code> and <code>"marginal"</code>
are equivalent when the model includes no covariances. Given some exogenous covariance, 
<code>constant_variance = "diagonal"</code> preserves the conditional correlation and has
changing conditional variance, while <code>constant_variance = "marginal"</code> has changing
conditional correlation along the causal graph.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_use_reml">use_REML</code></td>
<td>
<p>Boolean indicating whether to treat non-variance fixed effects as random,
either to motigate bias in estimated variance parameters or improve efficiency for
parameter estimation given correlated fixed and random effects</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_profile">profile</code></td>
<td>
<p>Parameters to profile out of the likelihood (this subset will be appended to <code>random</code> with Laplace approximation disabled).</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_parameters">parameters</code></td>
<td>
<p>list of fixed and random effects, e.g., as constructed by <code>dsem</code> and then modified
by hand (only helpful for advanced users to change starting values or restart at intended values)</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_map">map</code></td>
<td>
<p>list of fixed and mirrored parameters, constructed by <code>dsem</code> by default but available
to override this default and then pass to <code><a href="TMB.html#topic+MakeADFun">MakeADFun</a></code></p>
</td></tr>
<tr><td><code id="dsem_control_+3A_getjointprecision">getJointPrecision</code></td>
<td>
<p>whether to get the joint precision matrix.  Passed
to <code><a href="TMB.html#topic+sdreport">sdreport</a></code>.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_extra_convergence_checks">extra_convergence_checks</code></td>
<td>
<p>Boolean indicating whether to run extra checks on model
convergence.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_lower">lower</code></td>
<td>
<p>vectors of lower bounds, replicated to be as long as start and passed to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.
If unspecified, all parameters are assumed to be unconstrained.</p>
</td></tr>
<tr><td><code id="dsem_control_+3A_upper">upper</code></td>
<td>
<p>vectors of upper bounds, replicated to be as long as start and passed to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.
If unspecified, all parameters are assumed to be unconstrained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 object of class &quot;dsem_control&quot; that specifies detailed model settings,
allowing user specification while also specifying default values
</p>

<hr>
<h2 id='dsemRTMB'>Fit dynamic structural equation model</h2><span id='topic+dsemRTMB'></span>

<h3>Description</h3>

<p>Fits a dynamic structural equation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsemRTMB(
  sem,
  tsdata,
  family = rep("fixed", ncol(tsdata)),
  estimate_delta0 = FALSE,
  log_prior = function(p) 0,
  control = dsem_control(),
  covs = colnames(tsdata)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsemRTMB_+3A_sem">sem</code></td>
<td>
<p>Specification for time-series structural equation model structure
including lagged or simultaneous effects.  See Details section in
<code><a href="#topic+make_dsem_ram">make_dsem_ram</a></code> for more description</p>
</td></tr>
<tr><td><code id="dsemRTMB_+3A_tsdata">tsdata</code></td>
<td>
<p>time-series data, as outputted using <code><a href="stats.html#topic+ts">ts</a></code></p>
</td></tr>
<tr><td><code id="dsemRTMB_+3A_family">family</code></td>
<td>
<p>Character-vector listing the distribution used for each column of <code>tsdata</code>, where
each element must be <code>fixed</code> (for no measurement error), 
<code>normal</code> for normal measurement error using an identity link,
<code>gamma</code> for a gamma measurement error using a fixed CV and log-link, 
<code>bernoulli</code> for a Bernoulli measurement error using a logit-link, or
<code>poisson</code> for a Poisson measurement error using a log-link.
<code>family="fixed"</code> is default behavior and assumes that a given variable is measured exactly.
Other options correspond to different specifications of measurement error.</p>
</td></tr>
<tr><td><code id="dsemRTMB_+3A_estimate_delta0">estimate_delta0</code></td>
<td>
<p>Boolean indicating whether to estimate deviations from equilibrium in initial year
as fixed effects, or alternatively to assume that dynamics start at some stochastic draw away from
the stationary distribution</p>
</td></tr>
<tr><td><code id="dsemRTMB_+3A_log_prior">log_prior</code></td>
<td>
<p>A user-provided function that takes as input the list of
parameters <code>out$obj$env$parList()</code> where <code>out</code> is the output from
<code>dsemRTMB()</code>, and returns the log-prior probability.  For example
<code>log_prior = function(p) dnorm( p$beta_z[1], mean=0, sd=0.1, log=TRUE)</code>
specifies a normal prior probability for the first path coefficient
with mean of zero and sd of 0.1.  Note that the user must load RTMB using
<code>library(RTMB)</code> prior to running the model.</p>
</td></tr>
<tr><td><code id="dsemRTMB_+3A_control">control</code></td>
<td>
<p>Output from <code><a href="#topic+dsem_control">dsem_control</a></code>, used to define user
settings, and see documentation for that function for details.</p>
</td></tr>
<tr><td><code id="dsemRTMB_+3A_covs">covs</code></td>
<td>
<p>optional: a character vector of one or more elements, with each element giving a string of variable 
names, separated by commas. Variances and covariances among all variables in each such string are 
added to the model. Warning: covs=&quot;x1, x2&quot; and covs=c(&quot;x1&quot;, &quot;x2&quot;) are not equivalent: 
covs=&quot;x1, x2&quot; specifies the variance of x1, the variance of x2, and their covariance, 
while covs=c(&quot;x1&quot;, &quot;x2&quot;) specifies the variance of x1 and the variance of x2 but not their covariance.
These same covariances can be added manually via argument 'sem', but using argument 'covs' might
save time for models with many variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dsemRTMB</code> is interchangeable with <code><a href="#topic+dsem">dsem</a></code>, but uses RTMB
instead of TMB for estimation.  Both are provided for comparison and
real-world comparison.
</p>


<h3>Value</h3>

<p>An object (list) of class 'dsem', fitted using RTMB
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define model
sem = "
  # Link, lag, param_name
  cprofits -&gt; consumption, 0, a1
  cprofits -&gt; consumption, 1, a2
  pwage -&gt; consumption, 0, a3
  gwage -&gt; consumption, 0, a3
  cprofits -&gt; invest, 0, b1
  cprofits -&gt; invest, 1, b2
  capital -&gt; invest, 0, b3
  gnp -&gt; pwage, 0, c2
  gnp -&gt; pwage, 1, c3
  time -&gt; pwage, 0, c1
"

# Load data
data(KleinI, package="AER")
TS = ts(data.frame(KleinI, "time"=time(KleinI) - 1931))
tsdata = TS[,c("time","gnp","pwage","cprofits",'consumption',
               "gwage","invest","capital")]

# Fit model
fit = dsemRTMB( sem=sem,
            tsdata = tsdata,
            estimate_delta0 = TRUE,
            control = dsem_control(quiet=TRUE) )

</code></pre>

<hr>
<h2 id='isle_royale'>Isle Royale wolf and moose</h2><span id='topic+isle_royale'></span>

<h3>Description</h3>

<p>Data used to demonstrate and test cross-lagged (vector autoregressive) models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(isle_royale)
</code></pre>


<h3>Details</h3>

<p>Data extracted from file &quot;Data_wolves_moose_Isle_Royale_June2019.csv&quot; available at
<a href="https://www.isleroyalewolf.org">https://www.isleroyalewolf.org</a> and obtained 2023-06-23.
Reproduced with permission from John Vucetich, and generated by the
Wolves and Moose of Isle Royale project.
</p>


<h3>References</h3>

<p>Vucetich, JA and Peterson RO. 2012. The population biology of Isle Royale wolves and moose: an overview. <a href="https://www.isleroyalewolf.org">https://www.isleroyalewolf.org</a>
</p>

<hr>
<h2 id='list_parameters'>List fixed and random effects</h2><span id='topic+list_parameters'></span>

<h3>Description</h3>

<p><code>list_parameters</code> lists all fixed and random effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_parameters(Obj, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_parameters_+3A_obj">Obj</code></td>
<td>
<p>Compiled TMB object</p>
</td></tr>
<tr><td><code id="list_parameters_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, whether to print messages to terminal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tagged-list of fixed and random effects, returned invisibly and printed to screen
</p>

<hr>
<h2 id='logLik.dsem'>Marginal log-likelihood</h2><span id='topic+logLik.dsem'></span>

<h3>Description</h3>

<p>Extract the (marginal) log-likelihood of a dsem model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsem'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.dsem_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="logLik.dsem_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>logLik</code> with attributes
</p>
<table role = "presentation">
<tr><td><code>val</code></td>
<td>
<p>log-likelihood</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>number of parameters</p>
</td></tr>
</table>
<p>Returns an object of class logLik. This has attributes
&quot;df&quot; (degrees of freedom) giving the number of (estimated) fixed effects
in the model, abd &quot;val&quot; (value) giving the marginal log-likelihood.
This class then allows <code>AIC</code> to work as expected.
</p>

<hr>
<h2 id='loo_residuals'>Calculate leave-one-out residuals</h2><span id='topic+loo_residuals'></span>

<h3>Description</h3>

<p>Calculates quantile residuals using the predictive distribution from
a jacknife (i.e., leave-one-out predictive distribution)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loo_residuals(
  object,
  nsim = 100,
  what = c("quantiles", "samples", "loo"),
  track_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo_residuals_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="loo_residuals_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations to use if <code>family!="fixed"</code> for some variable,
such that simulation residuals are required.</p>
</td></tr>
<tr><td><code id="loo_residuals_+3A_what">what</code></td>
<td>
<p>whether to return quantile residuals, or samples from the leave-one-out predictive
distribution of data, or a table of leave-one-out predictions and standard errors for the
latent state</p>
</td></tr>
<tr><td><code id="loo_residuals_+3A_track_progress">track_progress</code></td>
<td>
<p>whether to track runtimes on terminal</p>
</td></tr>
<tr><td><code id="loo_residuals_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditional quantile residuals cannot be calculated when using <code>family = "fixed"</code>, because
state-variables are fixed at available measurements and hence the conditional distribution is a Dirac
delta function.  One alternative is to use leave-one-out residuals, where we calculate the predictive distribution
for each state value when dropping the associated observation, and then either use that as the
predictive distribution, or sample from that predictive distribution and then calculate
a standard quantile distribution for a given non-fixed family.  This appraoch is followed here.
It is currently only implemented when  all variables follow <code>family = "fixed"</code>, but
could be generalized to a mix of families upon request.
</p>


<h3>Value</h3>

<p>A matrix of residuals, with same order and dimensions as argument <code>tsdata</code>
that was passed to <code>dsem</code>.
</p>

<hr>
<h2 id='make_dfa'>Make text for dynamic factor analysis</h2><span id='topic+make_dfa'></span>

<h3>Description</h3>

<p>Make the text string for a dynamic factor analysis expressed using
arrow-and-lag notation for DSEM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dfa(variables, n_factors, factor_names = paste0("F", seq_len(n_factors)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dfa_+3A_variables">variables</code></td>
<td>
<p>Character string of variables (i.e., column names of <code>tsdata</code>).</p>
</td></tr>
<tr><td><code id="make_dfa_+3A_n_factors">n_factors</code></td>
<td>
<p>Number of factors.</p>
</td></tr>
<tr><td><code id="make_dfa_+3A_factor_names">factor_names</code></td>
<td>
<p>Optional character-vector of factor names,
which must match NA columns in <code>tsdata</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A text string to be passed to <code><a href="#topic+dsem">dsem</a></code>
</p>

<hr>
<h2 id='make_dsem_ram'>Make a RAM (Reticular Action Model)</h2><span id='topic+make_dsem_ram'></span>

<h3>Description</h3>

<p><code>make_dsem_ram</code> converts SEM arrow notation to <code>ram</code> describing SEM parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_dsem_ram(
  sem,
  times,
  variables,
  covs = variables,
  quiet = FALSE,
  remove_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_dsem_ram_+3A_sem">sem</code></td>
<td>
<p>Specification for time-series structural equation model structure
including lagged or simultaneous effects.  See Details section in
<code><a href="#topic+make_dsem_ram">make_dsem_ram</a></code> for more description</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_times">times</code></td>
<td>
<p>A character vector listing the set of times in order</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_variables">variables</code></td>
<td>
<p>A character vector listing the set of variables</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_covs">covs</code></td>
<td>
<p>A character vector listing variables for which to estimate a standard deviation</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_quiet">quiet</code></td>
<td>
<p>Boolean indicating whether to print messages to terminal</p>
</td></tr>
<tr><td><code id="make_dsem_ram_+3A_remove_na">remove_na</code></td>
<td>
<p>Boolean indicating whether to remove NA values from RAM (default) or not.
<code>remove_NA=FALSE</code> might be useful for exploration and diagnostics for
advanced users</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>RAM specification using arrow-and-lag notation</strong>
</p>
<p>Each line of the RAM specification for <code><a href="#topic+make_dsem_ram">make_dsem_ram</a></code> consists of four (unquoted) entries,
separated by commas:
</p>

<dl>
<dt>1. Arrow specification:</dt><dd><p>This is a simple formula, of the form
<code>A -&gt; B</code> or, equivalently, <code>B &lt;- A</code> for a regression
coefficient (i.e., a single-headed or directional arrow);
<code>A &lt;-&gt; A</code> for a variance or <code>A &lt;-&gt; B</code> for a covariance
(i.e., a double-headed or bidirectional arrow). Here, <code>A</code> and
<code>B</code> are variable names in the model. If a name does not correspond
to an observed variable, then it is assumed to be a latent variable.
Spaces can appear freely in an arrow specification, and
there can be any number of hyphens in the arrows, including zero: Thus,
e.g., <code>A-&gt;B</code>, <code>A --&gt; B</code>, and <code>A&gt;B</code> are all legitimate
and equivalent.</p>
</dd>
<dt>2. Lag (using positive values):</dt><dd><p>An integer specifying whether the linkage
is simultaneous (<code>lag=0</code>) or lagged (e.g., <code>X -&gt; Y, 1, XtoY</code>
indicates that X in time T affects Y in time T+1), where
only one-headed arrows can be lagged. Using positive values to indicate lags
then matches the notational convention used in package <span class="pkg">dynlm</span>.</p>
</dd>
<dt>3. Parameter name:</dt><dd><p>The name of the regression coefficient, variance,
or covariance specified by the arrow. Assigning the same name to two or
more arrows results in an equality constraint. Specifying the parameter name
as <code>NA</code> produces a fixed parameter.</p>
</dd>
<dt>4. Value:</dt><dd><p>start value for a free parameter or value of a fixed parameter.
If given as <code>NA</code> (or simply omitted), the model is provide a default
starting value.</p>
</dd>
</dl>

<p>Lines may end in a comment following #. The function extends code copied from package
'sem' under licence GPL (&gt;= 2) with permission from John Fox.
</p>
<p><strong>Simultaneous autoregressive process for simultaneous and lagged effects</strong>
</p>
<p>This text then specifies linkages in a multivariate time-series model for variables <code class="reqn">\mathbf X</code>
with dimensions <code class="reqn">T \times C</code> for <code class="reqn">T</code> times and <code class="reqn">C</code> variables.
<code>make_dsem_ram</code> then parses this text to build a path matrix <code class="reqn">\mathbf{P}</code> with
dimensions <code class="reqn">TC \times TC</code>, where element <code class="reqn">\rho_{k_2,k_1}</code>
represents the impact of <code class="reqn">x_{t_1,c_1}</code> on <code class="reqn">x_{t_2,c_2}</code>, where <code class="reqn">k_1=T c_1+t_1</code>
and <code class="reqn">k_2=T c_2+t_2</code>.  This path matrix defines a simultaneous equation
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{vec}(\mathbf X) = \mathbf P \mathrm{vec}(\mathbf X) + \mathrm{vec}(\mathbf \Delta)</code>
</p>

<p>where <code class="reqn">\mathbf \Delta</code> is a matrix of exogenous errors with covariance <code class="reqn">\mathbf{V = \Gamma \Gamma}^t</code>,
where <code class="reqn">\mathbf \Gamma</code> is the Cholesky of exogenous covariance.  This
simultaneous autoregressive (SAR) process then results in <code class="reqn">\mathbf X</code> having covariance:
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{Cov}(\mathbf X) = \mathbf{(I - P)}^{-1} \mathbf{\Gamma \Gamma}^t \mathbf{((I - P)}^{-1})^t </code>
</p>

<p>Usefully, computing the inverse-covariance (precision) matrix <code class="reqn">\mathbf{Q = V}^{-1}</code> does not require inverting <code class="reqn">\mathbf{(I - P)}</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{Q} = (\mathbf{\Gamma}^{-1} \mathbf{(I - P)})^t \mathbf{\Gamma}^{-1} \mathbf{(I - P)} </code>
</p>

<p><strong>Example: univariate first-order autoregressive model</strong>
</p>
<p>This simultaneous autoregressive (SAR) process across variables and times
allows the user to specify both simutanous effects (effects among variables within
year <code class="reqn">T</code>) and lagged effects (effects among variables among years <code class="reqn">T</code>).
As one example, consider a univariate and first-order autoregressive process where <code class="reqn">T=4</code>.
with independent errors.  This is specified by passing <code> sem = "X -&gt; X, 1, rho \n X &lt;-&gt; X, 0, sigma" </code> to <code>make_dsem_ram</code>.
This is then parsed to a RAM:
</p>

<table>
<tr>
 <td style="text-align: right;">
  <strong>heads</strong> </td><td style="text-align: right;"> <strong>to</strong> </td><td style="text-align: right;"> <strong>from</strong> </td><td style="text-align: right;"> <strong>paarameter</strong> </td><td style="text-align: right;"> <strong>start</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
  1 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> &lt;NA&gt;</td>
</tr>
<tr>
 <td style="text-align: right;">
  1 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> &lt;NA&gt;</td>
</tr>
<tr>
 <td style="text-align: right;">
  1 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;">  1 </td><td style="text-align: right;"> &lt;NA&gt;</td>
</tr>
<tr>
 <td style="text-align: right;">
  2 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> &lt;NA&gt;</td>
</tr>
<tr>
 <td style="text-align: right;">
  2 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;">  2 </td><td style="text-align: right;"> &lt;NA&gt;</td>
</tr>
<tr>
 <td style="text-align: right;">
  2 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 3 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> &lt;NA&gt;</td>
</tr>
<tr>
 <td style="text-align: right;">
  2 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> &lt;NA&gt;
</td>
</tr>

</table>

<p>Rows of this RAM where <code>heads=1</code> are then interpreted to construct the path matrix <code class="reqn">\mathbf P</code>, where column &quot;from&quot;
in the RAM indicates column number in the matrix, column &quot;to&quot; in the RAM indicates row number in the matrix:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf P = \begin{bmatrix}
    0 &amp; 0 &amp; 0 &amp; 0 \\
    \rho &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \rho &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \rho &amp; 0\\
    \end{bmatrix} </code>
</p>

<p>While rows where <code>heads=2</code> are interpreted to construct the Cholesky of exogenous covariance <code class="reqn">\mathbf \Gamma</code>
and column &quot;parameter&quot; in the RAM associates each nonzero element of those
two matrices with an element of a vector of estimated parameters:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf \Gamma = \begin{bmatrix}
    \sigma &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; \sigma &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; \sigma &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; \sigma\\
    \end{bmatrix} </code>
</p>

<p>with two estimated parameters <code class="reqn">\mathbf \beta = (\rho, \sigma) </code>. This then results in covariance:
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{Cov}(\mathbf X) = \sigma^2 \begin{bmatrix}
    1      &amp; \rho^1              &amp; \rho^2                        &amp; \rho^3                  \\
    \rho^1 &amp; 1 + \rho^2          &amp; \rho^1 (1 + \rho^2)           &amp; \rho^2 (1 + \rho^2)     \\
    \rho^2 &amp; \rho^1 (1 + \rho^2) &amp; 1 + \rho^2 + \rho^4           &amp; \rho^1 (1 + \rho^2 + \rho^4)                 \\
    \rho^3 &amp; \rho^2 (1 + \rho^2) &amp; \rho^1 (1 + \rho^2 + \rho^4)  &amp; 1 + \rho^2 + \rho^4 + \rho^6 \\
    \end{bmatrix} </code>
</p>

<p>Which converges on the stationary covariance for an AR1 process for times <code class="reqn">t&gt;&gt;1</code>:
</p>
<p style="text-align: center;"><code class="reqn"> \mathrm{Cov}(\mathbf X) = \frac{\sigma^2}{1+\rho^2} \begin{bmatrix}
    1 &amp; \rho^1 &amp; \rho^2 &amp; \rho^3 \\
    \rho^1 &amp; 1 &amp; \rho^1 &amp; \rho^2 \\
    \rho^2 &amp; \rho^1 &amp; 1 &amp; \rho^1 \\
    \rho^3 &amp; \rho^2 &amp; \rho^1 &amp; 1\\
    \end{bmatrix} </code>
</p>

<p>except having a lower pointwise variance for the initial times, which arises as a &quot;boundary effect&quot;.
</p>
<p>Similarly, the arrow-and-lag notation can be used to specify a SAR representing
a conventional structural equation model (SEM), cross-lagged (a.k.a. vector autoregressive)
models (VAR), dynamic factor analysis (DFA), or many other time-series models.
</p>


<h3>Value</h3>

<p>A reticular action module (RAM) describing dependencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Univariate AR1
sem = "
  X -&gt; X, 1, rho
  X &lt;-&gt; X, 0, sigma
"
make_dsem_ram( sem=sem, variables="X", times=1:4 )

# Univariate AR2
sem = "
  X -&gt; X, 1, rho1
  X -&gt; X, 2, rho2
  X &lt;-&gt; X, 0, sigma
"
make_dsem_ram( sem=sem, variables="X", times=1:4 )

# Bivariate VAR
sem = "
  X -&gt; X, 1, XtoX
  X -&gt; Y, 1, XtoY
  Y -&gt; X, 1, YtoX
  Y -&gt; Y, 1, YtoY
  X &lt;-&gt; X, 0, sdX
  Y &lt;-&gt; Y, 0, sdY
"
make_dsem_ram( sem=sem, variables=c("X","Y"), times=1:4 )

# Dynamic factor analysis with one factor and two manifest variables
# (specifies a random-walk for the factor, and miniscule residual SD)
sem = "
  factor -&gt; X, 0, loadings1
  factor -&gt; Y, 0, loadings2
  factor -&gt; factor, 1, NA, 1
  X &lt;-&gt; X, 0, NA, 0.01       # Fix at negligible value
  Y &lt;-&gt; Y, 0, NA, 0.01       # Fix at negligible value
"
make_dsem_ram( sem=sem, variables=c("X","Y","factor"), times=1:4 )

# ARIMA(1,1,0)
sem = "
  factor -&gt; factor, 1, rho1 # AR1 component
  X -&gt; X, 1, NA, 1          # Integrated component
  factor -&gt; X, 0, NA, 1
  X &lt;-&gt; X, 0, NA, 0.01      # Fix at negligible value
"
make_dsem_ram( sem=sem, variables=c("X","factor"), times=1:4 )

# ARIMA(0,0,1)
sem = "
  factor -&gt; X, 0, NA, 1
  factor -&gt; X, 1, rho1     # MA1 component
  X &lt;-&gt; X, 0, NA, 0.01     # Fix at negligible value
"
make_dsem_ram( sem=sem, variables=c("X","factor"), times=1:4 )

</code></pre>

<hr>
<h2 id='parse_path'>Parse path</h2><span id='topic+parse_path'></span>

<h3>Description</h3>

<p><code>parse_path</code> is copied from <code>sem::parse.path</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_path(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_path_+3A_path">path</code></td>
<td>
<p>text to parse</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Copied from package 'sem' under licence GPL (&gt;= 2) with permission from John Fox
</p>


<h3>Value</h3>

<p>Tagged-list defining variables and direction for a specified path coefficient
</p>

<hr>
<h2 id='plot.dsem'>Simulate dsem</h2><span id='topic+plot.dsem'></span>

<h3>Description</h3>

<p>Plot from a fitted <code>dsem</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsem'
plot(
  x,
  y,
  edge_label = c("name", "value", "value_and_stars"),
  digits = 2,
  style = c("igraph", "ggraph"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dsem_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="plot.dsem_+3A_y">y</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="plot.dsem_+3A_edge_label">edge_label</code></td>
<td>
<p>Whether to plot parameter names, estimated values,
or estimated values along with stars indicating significance at
0.05, 0.01, or 0.001 levels (based on two-sided Wald tests)</p>
</td></tr>
<tr><td><code id="plot.dsem_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places to be used</p>
</td></tr>
<tr><td><code id="plot.dsem_+3A_style">style</code></td>
<td>
<p>Whether to make a graph using <code>igraph</code> or <code>ggraph</code></p>
</td></tr>
<tr><td><code id="plot.dsem_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function coerces output from a graph and then plots the graph.
</p>


<h3>Value</h3>

<p>Invisibly returns the output from <code><a href="igraph.html#topic+graph_from_data_frame">graph_from_data_frame</a></code>
which was passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code> for plotting.
</p>

<hr>
<h2 id='predict.dsem'>predictions using dsem</h2><span id='topic+predict.dsem'></span>

<h3>Description</h3>

<p>Predict variables given new (counterfactual) values of data, or for future or past times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsem'
predict(object, newdata = NULL, type = c("link", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.dsem_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="predict.dsem_+3A_newdata">newdata</code></td>
<td>
<p>optionally, a data frame in which to look for variables with which to predict.
If omitted, the fitted data are used to create predictions. If desiring predictions after the fitted data,
the user must append rows with NAs for those future times.  Similarly, if desiring predictions given counterfactual
values for time-series data, then those individual observations can be edited while keeping other observations at their
original fitted values.</p>
</td></tr>
<tr><td><code id="predict.dsem_+3A_type">type</code></td>
<td>
<p>the type of prediction required. The default is on the scale of the linear predictors;
the alternative &quot;response&quot; is on the scale of the response variable.
Thus for a Poisson-distributed variable the default predictions are of log-intensity and type = &quot;response&quot; gives the predicted intensity.</p>
</td></tr>
<tr><td><code id="predict.dsem_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of predicted values with dimensions and order corresponding to
argument <code>newdata</code> is provided, or <code>tsdata</code> if not.
Predictions are provided on either link or response scale, and
are generated by re-optimizing random effects condition on MLE
for fixed effects, given those new data.
</p>

<hr>
<h2 id='print.dsem'>Print fitted dsem object</h2><span id='topic+print.dsem'></span>

<h3>Description</h3>

<p>Prints output from fitted dsem model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsem'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.dsem_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="print.dsem_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to provide clean terminal output when calling fitted
object in terminal.
</p>

<hr>
<h2 id='read_model'>Make a RAM (Reticular Action Model)</h2><span id='topic+read_model'></span>

<h3>Description</h3>

<p><code>read_model</code> converts SEM arrow notation to <code>model</code> describing SEM parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_model(sem, times, variables, covs = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_model_+3A_sem">sem</code></td>
<td>
<p>Specification for time-series structural equation model structure
including lagged or simultaneous effects.  See Details section in
<code><a href="#topic+make_dsem_ram">make_dsem_ram</a></code> for more description</p>
</td></tr>
<tr><td><code id="read_model_+3A_times">times</code></td>
<td>
<p>A character vector listing the set of times in order</p>
</td></tr>
<tr><td><code id="read_model_+3A_variables">variables</code></td>
<td>
<p>A character vector listing the set of variables</p>
</td></tr>
<tr><td><code id="read_model_+3A_covs">covs</code></td>
<td>
<p>A character vector listing variables for which to estimate a standard deviation</p>
</td></tr>
<tr><td><code id="read_model_+3A_quiet">quiet</code></td>
<td>
<p>Boolean indicating whether to print messages to terminal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+make_dsem_ram">make_dsem_ram</a></code> for details
</p>

<hr>
<h2 id='residuals.dsem'>Calculate residuals</h2><span id='topic+residuals.dsem'></span>

<h3>Description</h3>

<p>Calculate deviance or response residuals for dsem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsem'
residuals(object, type = c("deviance", "response"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.dsem_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="residuals.dsem_+3A_type">type</code></td>
<td>
<p>which type of residuals to compute (only option is <code>"deviance"</code> or <code>"response"</code> for now)</p>
</td></tr>
<tr><td><code id="residuals.dsem_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of residuals, with same order and dimensions as argument <code>tsdata</code>
that was passed to <code>dsem</code>.
</p>

<hr>
<h2 id='sea_otter'>Sea otter trophic cascade</h2><span id='topic+sea_otter'></span>

<h3>Description</h3>

<p>Data used to demonstrate and test trophic cascades options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sea_otter)
</code></pre>

<hr>
<h2 id='simulate.dsem'>Simulate dsem</h2><span id='topic+simulate.dsem'></span>

<h3>Description</h3>

<p>Simulate from a fitted <code>dsem</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsem'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  variance = c("none", "random", "both"),
  resimulate_gmrf = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.dsem_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="simulate.dsem_+3A_nsim">nsim</code></td>
<td>
<p>number of simulated data sets</p>
</td></tr>
<tr><td><code id="simulate.dsem_+3A_seed">seed</code></td>
<td>
<p>random seed</p>
</td></tr>
<tr><td><code id="simulate.dsem_+3A_variance">variance</code></td>
<td>
<p>whether to ignore uncertainty in fixed and
random effects, include estimation uncertainty in random effects,
or include estimation uncertainty in both fixed and random effects</p>
</td></tr>
<tr><td><code id="simulate.dsem_+3A_resimulate_gmrf">resimulate_gmrf</code></td>
<td>
<p>whether to resimulate the GMRF based on estimated or
simulated random effects (determined by argument <code>variance</code>)</p>
</td></tr>
<tr><td><code id="simulate.dsem_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function conducts a parametric bootstrap, i.e., simulates new data
conditional upon estimated values for fixed and random effects.  The user
can optionally simulate new random effects conditional upon their estimated
covariance, or simulate new fixed and random effects conditional upon their imprecision.
</p>
<p>Note that <code>simulate</code> will have no effect on states <code>x_tj</code> for which there
is a measurement and when those measurements are fitted using <code>family="fixed"</code>, unless
<code>resimulate_gmrf=TRUE</code>.  In this latter case, the GMRF is resimulated given
estimated path coefficients
</p>


<h3>Value</h3>

<p>Simulated data, either from <code>obj$simulate</code> where <code>obj</code> is the compiled
TMB object, first simulating a new GMRF and then calling <code>obj$simulate</code>.
</p>

<hr>
<h2 id='stepwise_selection'>Simulate dsem</h2><span id='topic+stepwise_selection'></span>

<h3>Description</h3>

<p>Plot from a fitted <code>dsem</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise_selection(model_options, model_shared, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepwise_selection_+3A_model_options">model_options</code></td>
<td>
<p>character-vector containing sem elements
that could be included or dropped depending upon their
parsimony</p>
</td></tr>
<tr><td><code id="stepwise_selection_+3A_model_shared">model_shared</code></td>
<td>
<p>character-vector containing sem elements
that must be included regardless of parsimony</p>
</td></tr>
<tr><td><code id="stepwise_selection_+3A_quiet">quiet</code></td>
<td>
<p>whether to avoid displaying progress to terminal</p>
</td></tr>
<tr><td><code id="stepwise_selection_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+dsem">dsem</a></code>,
other than <code>sem</code> e.g., <code>tsdata</code>, <code>family</code>
etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function conducts stepwise (i.e., forwards and backwards) model
selection using marginal AIC, while forcing some model elements to be
included and selecting among others.
</p>


<h3>Value</h3>

<p>An object (list) that includes:
</p>

<dl>
<dt>model</dt><dd><p>the string with the selected SEM model</p>
</dd>
<dt>record</dt><dd><p>a list showing the AIC and whether each <code>model_options</code> is included or not</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Simulate x -&gt; y -&gt; z
set.seed(101)
x = rnorm(100)
y = 0.5*x + rnorm(100)
z = 1*y + rnorm(100)
tsdata = ts(data.frame(x=x, y=y, z=z))

# define candidates
model_options = c(
  "y -&gt; z, 0, y_to_z",
  "x -&gt; z, 0, x_to_z"
)
# define paths that are required
model_shared = "
  x -&gt; y, 0, x_to_y
"

# Do selection
step = stepwise_selection(
  model_options = model_options,
  model_shared = model_shared,
  tsdata = tsdata,
  quiet = TRUE
)

# Check selected model
cat(step$model)

</code></pre>

<hr>
<h2 id='summary.dsem'>summarize dsem</h2><span id='topic+summary.dsem'></span>

<h3>Description</h3>

<p>summarize parameters from a fitted dynamic structural equation model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsem'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dsem_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="summary.dsem_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A DSEM is specified using &quot;arrow and lag&quot; notation, which specifies the set of
path coefficients and exogenous variance parameters to be estimated. Function <code>dsem</code>
then estimates the maximum likelihood value for those coefficients and parameters
by maximizing the log-marginal likelihood.  Standard errors for parameters are calculated
from the matrix of second derivatives of this log-marginal likelihood (the &quot;Hessian matrix&quot;).
</p>
<p>However, many users will want to associate individual parameters and standard errors
with the path coefficients that were specified using the &quot;arrow and lag&quot; notation.
This task is complicated in
models where some path coefficients or variance parameters are specified to share a single value a priori,
or were assigned a name of NA and hence assumed to have a fixed value a priori (such that
these coefficients or parameters have an assigned value but no standard error).
The <code>summary</code> function therefore compiles the MLE for coefficients (including duplicating
values for any path coefficients that assigned the same value) and standard error
estimates, and outputs those in a table that associates them with the user-supplied path and parameter names.
It also outputs the z-score and a p-value arising from a two-sided Wald test (i.e.
comparing the estimate divided by standard error against a standard normal distribution).
</p>


<h3>Value</h3>

<p>Returns a data.frame summarizing estimated path coefficients, containing columns:
</p>

<dl>
<dt>path</dt><dd><p>The parsed path coefficient</p>
</dd>
<dt>lag</dt><dd><p>The lag, where e.g. 1 means the predictor in time t effects the response in time t+1</p>
</dd>
<dt>name</dt><dd><p>Parameter name</p>
</dd>
<dt>start</dt><dd><p>Start value if supplied, and NA otherwise</p>
</dd>
<dt>parameter</dt><dd><p>Parameter number</p>
</dd>
<dt>first</dt><dd><p>Variable in path treated as predictor</p>
</dd>
<dt>second</dt><dd><p>Variable in path treated as response</p>
</dd>
<dt>direction</dt><dd><p>Whether the path is one-headed or two-headed</p>
</dd>
<dt>Estimate</dt><dd><p>Maximum likelihood estimate</p>
</dd>
<dt>Std_Error</dt><dd><p>Estimated standard error from the Hessian matrix</p>
</dd>
<dt>z_value</dt><dd><p>Estimate divided by Std_Error</p>
</dd>
<dt>p_value</dt><dd><p>P-value associated with z_value using a two-sided Wald test</p>
</dd>
</dl>


<hr>
<h2 id='test_dsep'>Test d-separation</h2><span id='topic+test_dsep'></span>

<h3>Description</h3>

<p>Calculate the p-value for a test of d-separation <strong>(Experimental)</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_dsep(
  object,
  n_time = NULL,
  n_burnin = NULL,
  what = c("pvalue", "CIC", "all"),
  test = c("wald", "lr")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_dsep_+3A_object">object</code></td>
<td>
<p>object from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="test_dsep_+3A_n_time">n_time</code></td>
<td>
<p>how many times to include when defining the set of conditional
independence relationships. If missing, this value is taken from
the maximum lag that's included in the model plus one.</p>
</td></tr>
<tr><td><code id="test_dsep_+3A_n_burnin">n_burnin</code></td>
<td>
<p>how many times to include prior to <code>seq_len(n_time)</code> when
identifying the conditioning set that must be included when defining
conditional independence relationships.</p>
</td></tr>
<tr><td><code id="test_dsep_+3A_what">what</code></td>
<td>
<p>whether to just get the p-value, an information criterion
based on the conditional independence test, or a named list with these two
and other intermediate calculations (used for diagnosing test behavior)</p>
</td></tr>
<tr><td><code id="test_dsep_+3A_test">test</code></td>
<td>
<p>whether to test each conditional-independence relationship
using a (univariate) wald test or a (multivariate) likelihood ratio test.
The likelihood-ratio test might be more accurate given estimation covariance
and also faster (does not require standard errors), but also is not
used by phylopath and therefore less supported by previous d-dsep
testing applications.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A user-specified SEM implies a set of conditional independence relationships
among variables, which can be fitted individually, extracting the
slope and associated p-value, and then combining these p-values to define
a model-wide (omnibus) p-value for the hypothesis that a given data set arises
from the specified model.  This test is modified from package:phylopath.  However
it is unclear exactly how to define the set of conditional-independence assumptions
in a model with temporal autocorrelation, and the test was not developed for
uses when data are missing.  At the time of writing, the function is hightly
experimental.
</p>
<p>Note that the method is not currently designed to deal with two-headed arrows
among variables (i.e., exogenous covariance).
</p>


<h3>Value</h3>

<p>A p-value representing the weight of evidence that the data arises
from the specified model, where a low p-value indicates
significant evidence for rejecting this hypothesis.
</p>


<h3>References</h3>

<p>Shipley, B. (2000). A new inferential test
for path models based on directed acyclic graphs. Structural
Equation Modeling, 7(2), 206-218. <a href="https://doi.org/10.1207/S15328007SEM0702_4">doi:10.1207/S15328007SEM0702_4</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
set.seed(101)
a = rnorm( 100 )
b = 0.5*a + rnorm(100)
c = 1*a + rnorm(100)
d = 1*b - 0.5*c + rnorm(100)
tsdata = ts(data.frame(a=a, b=b, c=c, d=d))

# fit wrong model
wrong = dsem(
  tsdata = tsdata,
  sem = "
    a -&gt; d, 0, a_to_d
    b -&gt; d, 0, b_to_d
    c -&gt; d, 0, c_to_d
  "
)
test_dsep( wrong )

# fit right model
right = dsem(
  tsdata = tsdata,
  sem = "
    a -&gt; b, 0, a_to_b
    a -&gt; c, 0, a_to_c
    b -&gt; d, 0, b_to_d
    c -&gt; d, 0, c_to_d
  "
)
test_dsep( right )
</code></pre>

<hr>
<h2 id='TMBAIC'>Calculate marginal AIC for a fitted model</h2><span id='topic+TMBAIC'></span>

<h3>Description</h3>

<p><code>TMBAIC</code> calculates AIC for a given model fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TMBAIC(opt, k = 2, n = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TMBAIC_+3A_opt">opt</code></td>
<td>
<p>the output from <code>nlminb</code> or <code>optim</code></p>
</td></tr>
<tr><td><code id="TMBAIC_+3A_k">k</code></td>
<td>
<p>the penalty on additional fixed effects (default=2, for AIC)</p>
</td></tr>
<tr><td><code id="TMBAIC_+3A_n">n</code></td>
<td>
<p>the sample size, for use in AICc calculation (default=Inf, for which AICc=AIC)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AIC, where a parsimonious model has a AIC relative to other candidate models
</p>

<hr>
<h2 id='total_effect'>Calculate total effects</h2><span id='topic+total_effect'></span>

<h3>Description</h3>

<p>Calculate a data frame of total effects, representing the 
estimated effect of every variable on every other variable and any time-lag
from 0 (simultaneous effects) to a user-specified maximum lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_effect(object, n_lags = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="total_effect_+3A_object">object</code></td>
<td>
<p>Output from <code><a href="#topic+dsem">dsem</a></code></p>
</td></tr>
<tr><td><code id="total_effect_+3A_n_lags">n_lags</code></td>
<td>
<p>Number of lags over which to calculate total effects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Total effects are taken from the Leontief matrix <code class="reqn">\mathbf{(I-P)^{-1}}</code>,
where <code class="reqn">\mathbf{P}</code> is the path matrix across variables and times.
</p>


<h3>Value</h3>

<p>A data frame listing the time-lag (lag), variable that is undergoing some 
exogenous change (from), and the variable being impacted (to), along with the 
total effect (total_effect) including direct and indirect pathways, and the
partial &quot;direct&quot; effect (direct_effect)
</p>

<hr>
<h2 id='vcov.dsem'>Extract Variance-Covariance Matrix</h2><span id='topic+vcov.dsem'></span>

<h3>Description</h3>

<p>extract the covariance of fixed effects, or both fixed and random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsem'
vcov(object, which = c("fixed", "random", "both"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov.dsem_+3A_object">object</code></td>
<td>
<p>output from <code>dsem</code></p>
</td></tr>
<tr><td><code id="vcov.dsem_+3A_which">which</code></td>
<td>
<p>whether to extract the covariance among fixed effects, random effects, or both</p>
</td></tr>
<tr><td><code id="vcov.dsem_+3A_...">...</code></td>
<td>
<p>ignored, for method compatibility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix containing the estimated covariances among the parameter estimates in the model.
The dimensions dependend upon the argument <code>which</code>, to determine whether fixed, random effects,
or both are outputted.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
