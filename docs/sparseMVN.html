<!DOCTYPE html><html><head><title>Help for package sparseMVN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sparseMVN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sparseMVN-package'><p>Multivariate Normal Functions for Sparse Covariate and Precision Matrices</p></a></li>
<li><a href='#binary'><p>Binary choice example</p></a></li>
<li><a href='#dmvn.sparse'><p>Compute density  from multivariate normal distribution</p></a></li>
<li><a href='#rmvn.sparse'><p>Sample from multivariate normal distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Normal Functions for Sparse Covariance and
Precision Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Braun &lt;braunm@smu.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://braunm.github.io/sparseMVN/">https://braunm.github.io/sparseMVN/</a>,
<a href="https://github.com/braunm/sparseMVN/">https://github.com/braunm/sparseMVN/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/braunm/sparseMVN/issues/">https://github.com/braunm/sparseMVN/issues/</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Computes multivariate normal (MVN) densities, and
    samples from MVN distributions, when the covariance or
    precision matrix is sparse.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.mozilla.org/en-US/MPL/2.0/">MPL (&ge; 2.0)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.3), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr (&ge; 1.0), tidyr (&ge; 1.1), ggplot2 (&ge; 3.3), forcats (&ge;
0.5), mvtnorm (&ge; 1.0.6) , knitr, bookdown, kableExtra,
testthat, scales, trustOptim (&ge; 0.8.5)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-20 02:54:47 UTC; braunm</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Braun <a href="https://orcid.org/0000-0003-4774-2119"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-25 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sparseMVN-package'>Multivariate Normal Functions for Sparse Covariate and Precision Matrices</h2><span id='topic+sparseMVN-package'></span><span id='topic+_PACKAGE'></span><span id='topic+sparseMVN'></span>

<h3>Description</h3>

<p>MVN functions for sparse covariance and precision matrices.
</p>


<h3>Details</h3>

<p>Computes multivariate normal (MVN) densities, and samples
from MVN distributions, when either the covariance or precision
matrix is stored as a sparse Matrix (a dsCMatrix object, as defined
in the Matrix package.  The user can provide the precision matrix
directly, rather than convert it to a covariance via matrix
inversion.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Braun <a href="mailto:braunm@smu.edu">braunm@smu.edu</a> (<a href="https://orcid.org/0000-0003-4774-2119">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://braunm.github.io/sparseMVN/">https://braunm.github.io/sparseMVN/</a>
</p>
</li>
<li> <p><a href="https://github.com/braunm/sparseMVN/">https://github.com/braunm/sparseMVN/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/braunm/sparseMVN/issues/">https://github.com/braunm/sparseMVN/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='binary'>Binary choice example</h2><span id='topic+binary'></span><span id='topic+binary.f'></span><span id='topic+binary.grad'></span><span id='topic+binary.hess'></span><span id='topic+binary.sim'></span>

<h3>Description</h3>

<p>Functions for binary choice example in the vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary.f(P, data, priors, order.row = FALSE)

binary.grad(P, data, priors, order.row = FALSE)

binary.hess(P, data, priors, order.row = FALSE)

binary.sim(N, k, T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_+3A_p">P</code></td>
<td>
<p>Numeric vector of length <code class="reqn">(N+1)k</code>.  First <code class="reqn">Nk</code>
elements are heterogeneous coefficients. The remaining k elements are population parameters.</p>
</td></tr>
<tr><td><code id="binary_+3A_data">data</code></td>
<td>
<p>Named list of data matrices Y and X, and choice count integer T</p>
</td></tr>
<tr><td><code id="binary_+3A_priors">priors</code></td>
<td>
<p>Named list of matrices inv.Omega and inv.A.</p>
</td></tr>
<tr><td><code id="binary_+3A_order.row">order.row</code></td>
<td>
<p>Determines order of heterogeneous coefficients in
parameter vector. If TRUE, heterogeneous coefficients are ordered by unit.  If FALSE, they are ordered by covariate.</p>
</td></tr>
<tr><td><code id="binary_+3A_n">N</code></td>
<td>
<p>Number of heterogeneous units</p>
</td></tr>
<tr><td><code id="binary_+3A_k">k</code></td>
<td>
<p>Number of heterogeneous parameters</p>
</td></tr>
<tr><td><code id="binary_+3A_t">T</code></td>
<td>
<p>Observations per household</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used by the heterogeneous binary
choice example in the vignette. There are N heterogeneous units, each making T binary choices.  The choice probabilities depend on k covariates.  binary.sim simulates a dataset suitable for running the example.
</p>


<h3>Value</h3>

<p>For binary.f, binary.df and binary.hess, the log posterior density, gradient and Hessian, respectively. The Hessian is a dgCMatrix object. binary.sim returns a list with simulated Y and X, and the input T.
</p>

<hr>
<h2 id='dmvn.sparse'>Compute density  from multivariate normal distribution</h2><span id='topic+dmvn.sparse'></span>

<h3>Description</h3>

<p>Compute density  from multivariate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmvn.sparse(x, mu, CH, prec = TRUE, log = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmvn.sparse_+3A_x">x</code></td>
<td>
<p>numeric matrix, where each row is an MVN sample.</p>
</td></tr>
<tr><td><code id="dmvn.sparse_+3A_mu">mu</code></td>
<td>
<p>mean (numeric vector)</p>
</td></tr>
<tr><td><code id="dmvn.sparse_+3A_ch">CH</code></td>
<td>
<p>An object of class dCHMsimpl or dCHMsuper that represents
the Cholesky factorization of either the precision (default) or covariance
matrix.  See details.</p>
</td></tr>
<tr><td><code id="dmvn.sparse_+3A_prec">prec</code></td>
<td>
<p>If TRUE, CH is the Cholesky decomposition of the precision
matrix.  If false, it is the decomposition for the covariance matrix.</p>
</td></tr>
<tr><td><code id="dmvn.sparse_+3A_log">log</code></td>
<td>
<p>If TRUE (default), returns the log density, else returns density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A density or log density for each row of x
</p>


<h3>Details</h3>

<p>This function use sparse matrix operations to compute the
log density of a multivariate normal distribution.  The user must compute
the Cholesky decomposition first, using the Cholesky function in the Matrix
package.  This function operates on a sparse symmetric matrix, and returns
an object of class dCHMsimpl or dCHMsuper (this depends on the algorithm
that was used for the decomposition).  This object contains information about
any fill-reducing permutations that were used to preserve sparsity.  The
rmvn.sparse and dmvn.sparse functions use this permutation information, even
if pivoting was turned off.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   require(Matrix)
   m &lt;- 20
   p &lt;- 2
   k &lt;- 4

## build sample sparse covariance matrix
   Q1 &lt;- tril(kronecker(Matrix(seq(0.1,p,length=p*p),p,p),diag(m)))
   Q2 &lt;- cbind(Q1,Matrix(0,m*p,k))
   Q3 &lt;- rbind(Q2,cbind(Matrix(rnorm(k*m*p),k,m*p),Diagonal(k)))
   V &lt;- tcrossprod(Q3)
   CH &lt;- Cholesky(V)

   x &lt;- rmvn.sparse(10,rep(0,p*m+k),CH, FALSE)
   y &lt;- dmvn.sparse(x[1,],rep(0,p*m+k), CH, FALSE)

</code></pre>

<hr>
<h2 id='rmvn.sparse'>Sample from multivariate normal distribution</h2><span id='topic+rmvn.sparse'></span>

<h3>Description</h3>

<p>Efficient sampling and density calculation from a multivariate
normal,
when the covariance or precision matrix is sparse. These functions are
designed for MVN samples of very large dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvn.sparse(n, mu, CH, prec = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvn.sparse_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="rmvn.sparse_+3A_mu">mu</code></td>
<td>
<p>mean (numeric vector)</p>
</td></tr>
<tr><td><code id="rmvn.sparse_+3A_ch">CH</code></td>
<td>
<p>An object of class dCHMsimpl or dCHMsuper that represents
the Cholesky factorization of either the precision (default) or covariance
matrix.  See details.</p>
</td></tr>
<tr><td><code id="rmvn.sparse_+3A_prec">prec</code></td>
<td>
<p>If TRUE, CH is the Cholesky decomposition of the precision
matrix.  If false, it is the decomposition for the covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of samples from an MVN distribution (one in each row)
</p>


<h3>Details</h3>

<p>This function uses sparse matrix operations to sample from a multivariate normal distribution.  The user must compute
the Cholesky decomposition first, using the Cholesky function in the Matrix
package.  This function operates on a sparse symmetric matrix, and returns
an object of class dCHMsimpl or dCHMsuper (this depends on the algorithm
that was used for the decomposition).  This object contains information about
any fill-reducing permutations that were used to preserve sparsity.  The
rmvn.sparse and dmvn.sparse functions use this permutation information, even
if pivoting was turned off.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   require(Matrix)
   m &lt;- 20
   p &lt;- 2
   k &lt;- 4

## build sample sparse covariance matrix
   Q1 &lt;- tril(kronecker(Matrix(seq(0.1,p,length=p*p),p,p),diag(m)))
   Q2 &lt;- cbind(Q1,Matrix(0,m*p,k))
   Q3 &lt;- rbind(Q2,cbind(Matrix(rnorm(k*m*p),k,m*p),Diagonal(k)))
   V &lt;- tcrossprod(Q3)
   CH &lt;- Cholesky(V)

   x &lt;- rmvn.sparse(10,rep(0,p*m+k),CH, FALSE)
   y &lt;- dmvn.sparse(x[1,],rep(0,p*m+k), CH, FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
