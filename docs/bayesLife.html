<!DOCTYPE html><html><head><title>Help for package bayesLife</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesLife}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesLife-package'>
<p>Bayesian Projection of the Life Expectancy</p></a></li>
<li><a href='#bayesLife-internal'>
<p>Internal Functions and datasets of bayesLife</p></a></li>
<li><a href='#bayesLife.mcmc'>
<p>MCMC Simulation Object</p></a></li>
<li><a href='#bayesLife.mcmc.meta'>
<p>MCMC Simulation Meta Object</p></a></li>
<li><a href='#compute.loess'>
<p>Computing Residuals and Fitting Local Polynomial Regression</p></a></li>
<li><a href='#convert.e0.trajectories'>
<p>Converting Trajectories of Life Expectancy into ACSII Files</p></a></li>
<li><a href='#e0.coda.list.mcmc'>
<p>Convertion to coda's Objects</p></a></li>
<li><a href='#e0.diagnose'>
<p>Convergence Diagnostics for Markov Chain Monte Carlo of Life Expectancy</p></a></li>
<li><a href='#e0.dl.coverage'>
<p>Goodness of Fit of the Double Logistic Function</p></a></li>
<li><a href='#e0.DLcurve.plot'>
<p>Plotting  Posterior Distribution of the Double Logistic Function of Life Expectancy</p></a></li>
<li><a href='#e0.gap.plot'>
<p>Posterior Distribution of Gaps in Female and Male Life Expectancy</p></a></li>
<li><a href='#e0.jmale.estimate'>
<p>Estimation of the Joint Female-Male Model</p></a></li>
<li><a href='#e0.jmale.predict'>
<p>Prediction of the Joint Female-Male Model</p></a></li>
<li><a href='#e0.joint.plot'>
<p>Joint Posterior Distribution of Female and Male Life Expectancy</p></a></li>
<li><a href='#e0.map'>
<p>World Map of the Life Expectancy</p></a></li>
<li><a href='#e0.median.set'>
<p>Editing the Projection Medians</p></a></li>
<li><a href='#e0.parameter.names'>
<p>Accessing Parameter Names</p></a></li>
<li><a href='#e0.pardensity.plot'>
<p>Plotting MCMC Parameter Density</p></a></li>
<li><a href='#e0.partraces.plot'>
<p>Plotting MCMC Parameter Traces</p></a></li>
<li><a href='#e0.predict'>
<p>Generating Posterior Trajectories of the Life Expectancy</p></a></li>
<li><a href='#e0.predict.extra'>
<p>Generating Posterior Trajectories of the Life Expectancy for Specific Countries or Regions</p></a></li>
<li><a href='#e0.predict.subnat'>
<p>Generating Posterior Trajectories of Subnational Life Expectancy at Birth</p></a></li>
<li><a href='#e0.raftery.diag'>
<p>Raftery Diagnostics for Parameters of the Life Expectancy</p></a></li>
<li><a href='#e0.trajectories.plot'>
<p>Posterior Distribution of Trajectories of Life Expectancy</p></a></li>
<li><a href='#e0options'>
<p>Global options</p></a></li>
<li><a href='#get.e0.convergence'>
<p>Accessing a Convergence Object</p></a></li>
<li><a href='#get.e0.mcmc'>
<p>Accessing MCMC Results</p></a></li>
<li><a href='#get.e0.parameter.traces'>
<p>Accessing MCMC Parameter Traces</p></a></li>
<li><a href='#get.e0.prediction'>
<p>Accessing a Prediction Object</p></a></li>
<li><a href='#get.e0.trajectories'>
<p>Accessing Trajectories of Life Expectancy</p></a></li>
<li><a href='#get.rege0.prediction'>
<p>Accessing Subnational Prediction Objects</p></a></li>
<li><a href='#get.thinned.e0.mcmc'>
<p>Creating and Accessing Thinned MCMCs</p></a></li>
<li><a href='#include'>
<p>Inclusion Codes</p></a></li>
<li><a href='#run.e0.mcmc'>
<p>Running Bayesian Hierarchical Model for Life Expectancy via Markov Chain Monte Carlo</p></a></li>
<li><a href='#run.e0.mcmc.extra'>
<p>Run MCMC for Extra Countries, Areas or Regions</p></a></li>
<li><a href='#summary.bayesLife.convergence'>
<p>Summary of a Life Expectancy Convergence Object</p></a></li>
<li><a href='#summary.bayesLife.mcmc.set'>
<p>Summary Statistics for Life Expectancy MCMCs</p></a></li>
<li><a href='#summary.bayesLife.prediction'>
<p>Summary of a Prediction of the Life Expectancy</p></a></li>
<li><a href='#write.e0.projection.summary'>
<p>Writing Projection Summary Files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Projection of Life Expectancy</td>
</tr>
<tr>
<td>Version:</td>
<td>5.2-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Hana Sevcikova, Adrian Raftery, Jennifer Chunn </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hana Sevcikova &lt;hanas@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Making probabilistic projections of life expectancy for all countries of the world, using a Bayesian hierarchical model &lt;<a href="https://doi.org/10.1007%2Fs13524-012-0193-x">doi:10.1007/s13524-012-0193-x</a>&gt;. Subnational projections are also supported.</td>
</tr>
<tr>
<td>Depends:</td>
<td>bayesTFR (&ge; 7.3-0), R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>wpp2019, hett, car, coda, data.table</td>
</tr>
<tr>
<td>Suggests:</td>
<td>wpp2017, wpp2015, wpp2012, wpp2010</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bayespop.csss.washington.edu">https://bayespop.csss.washington.edu</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-15 21:17:04 UTC; hana</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-16 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesLife-package'>
Bayesian Projection of the Life Expectancy</h2><span id='topic+bayesLife-package'></span><span id='topic+bayesLife'></span>

<h3>Description</h3>

<p>Collection of functions for making probabilistic projections of the life expectancy for all countries of the world, 
using a Bayesian hierarchical model and the United Nations demographic time series. Projections on a subnational level are also supported.
</p>


<h3>Details</h3>

<p>The projection follows a method developed by Chunn et al (2010, 2013).  It uses historical data provided by the United Nations to simulate a posterior distribution of the life expectancy for all countries in the world simultaneously. 
</p>
<p>The package is implemented in a similar way as the <span class="pkg">bayesTFR</span> package and thus, many functions have their equivalents in <span class="pkg">bayesTFR</span>. The main functions of the <span class="pkg">bayesLife</span> package are:
</p>

<ul>
<li> <p><a href="#topic+run.e0.mcmc">run.e0.mcmc</a>: Runs a Markov Chain Monte Carlo (MCMC) simulation for one or more chains, possibly in parallel.  It results in a posterior sample of the MCMC parameters.  Existing simulation runs can be resumed using <a href="#topic+continue.e0.mcmc">continue.e0.mcmc</a>.
</p>
</li>
<li> <p><a href="#topic+e0.predict">e0.predict</a>: Using the posterior parameter samples it derives posterior trajectories of the life expectancy for all countries.
</p>
</li>
<li> <p><a href="#topic+e0.jmale.predict">e0.jmale.predict</a>: Given existing outputs of <a href="#topic+e0.predict">e0.predict</a> for female life expectancy, this function estimates and predicts a joint male life expectancy as described in Raftery et al (2014).
</p>
</li>
<li> <p><a href="#topic+e0.predict.subnat">e0.predict.subnat</a>: Given existing projections on national level, it generates projections on a subnational level, for both, female and male (Sevcikova and Raftery 2021).
</p>
</li></ul>

<p>A number of functions analyzing results are included in the package:
</p>

<ul>
<li> <p><a href="#topic+e0.trajectories.plot">e0.trajectories.plot</a>: Shows the posterior trajectories for a given country, including their median and given probability intervals.
</p>
</li>
<li> <p><a href="#topic+e0.trajectories.table">e0.trajectories.table</a>: Shows the posterior trajectories for a given country in a tabular form.
</p>
</li>
<li> <p><a href="#topic+e0.map">e0.map</a> and <a href="#topic+e0.map.gvis">e0.map.gvis</a>: Show a world map of life expectancy for a given projection period.
</p>
</li>
<li> <p><a href="#topic+e0.DLcurve.plot">e0.DLcurve.plot</a>: Shows the posterior curves of the double logistic function used in the simulation, including their median and given probability intervals.
</p>
</li>
<li> <p><a href="#topic+e0.partraces.plot">e0.partraces.plot</a> and <a href="#topic+e0.partraces.cs.plot">e0.partraces.cs.plot</a>: Plot the MCMC traces of country-independent parameters and country-specific parameters, respectively.
</p>
</li>
<li> <p><a href="#topic+e0.pardensity.plot">e0.pardensity.plot</a> and <a href="#topic+e0.pardensity.cs.plot">e0.pardensity.cs.plot</a>: Plot the posterior density of the MCMCs for country-independent parameters and country-specific parameters, respectively.
</p>
</li>
<li> <p><a href="#topic+summary.bayesLife.mcmc.set">summary.bayesLife.mcmc.set</a>: Summary function for the MCMC results.
</p>
</li>
<li> <p><a href="#topic+summary.bayesLife.prediction">summary.bayesLife.prediction</a>: Summary function for the prediction results.
</p>
</li></ul>

<p>For MCMC diagnostics, function <a href="#topic+e0.coda.list.mcmc">e0.coda.list.mcmc</a> creates an object of type &ldquo;mcmc.list&rdquo; that can be used with the <span class="pkg">coda</span> package.  Furthermore, function <a href="#topic+e0.diagnose">e0.diagnose</a> analyzes the MCMCs using the Raftery diagnostics implemented in the <span class="pkg">coda</span> package and gives information about parameters that did not converge. Function <a href="#topic+e0.dl.coverage">e0.dl.coverage</a> computes a goodness of fit of the double logistic function.
</p>
<p>Existing simulation results can be accessed using the <a href="#topic+get.e0.mcmc">get.e0.mcmc</a> function.  An existing prediction can be accessed via <a href="#topic+get.e0.prediction">get.e0.prediction</a>. Existing predictions on a subnational level can be accessed via <a href="#topic+get.rege0.prediction">get.rege0.prediction</a>.
</p>
<p>For a table with countries included in the mcmc or prediction object, the function <a href="bayesTFR.html#topic+get.countries.table">get.countries.table</a> can be used in the same way as in <span class="pkg">bayesTFR</span>.
</p>
<p>Historical data are taken from one of the packages <span class="pkg">wpp2019</span> (default), <span class="pkg">wpp2017</span>, <span class="pkg">wpp2015</span>, <span class="pkg">wpp2012</span> or <span class="pkg">wpp2010</span>, depending on users settings. For more recent data, package <span class="pkg">wpp2022</span> can be installed from Github (@PPgp).
</p>


<h3>Note</h3>

<p>There is a directory <code>ex-data</code> shipped with the package which contains results from an example simulation, containing one chain with 60 iterations.  The Example section below shows how these results were created.  These data are used in Example sections throughout the manual.  The user can either reproduce the data in her/his local directory, or use the ones from the package.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery, Jennifer Chunn
</p>
<p>Maintainer: Hana Sevcikova &lt;hanas@uw.edu&gt;
</p>


<h3>References</h3>

<p>J. L. Chunn, A. E. Raftery, P. Gerland, H. Sevcikova (2013): Bayesian Probabilistic Projections of Life Expectancy for All Countries. Demography 50(3):777-801. &lt;doi:10.1007/s13524-012-0193-x&gt;
</p>
<p>A. E. Raftery,  N. Li, H. Sevcikova, P. Gerland, G. K. Heilig (2012). Bayesian probabilistic population projections for all countries. Proceedings of the National Academy of Sciences 109:13915-13921.
</p>
<p>A. E. Raftery,  N. Lalic, P. Gerland (2014). Joint Probabilistic Projection of Female and Male Life Expectancy. Demographic Research, 30:795-822.
</p>
<p>H. Sevcikova, A. E. Raftery (2021). Probabilistic Projection of Subnational Life Expectancy. Journal of Official Statistics, , Vol. 37, no. 3, 591-610.
</p>


<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+bayesTFR-package">bayesTFR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.e0.mcmc(sex = 'F', nr.chains = 1, iter = 60, seed = 1, 
        thin = 1, output.dir = sim.dir, verbose = TRUE)
pred &lt;- e0.predict(m, burnin = 30, verbose = TRUE)
summary(pred, country = "Canada")
unlink(sim.dir, recursive = TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='bayesLife-internal'>
Internal Functions and datasets of bayesLife
</h2><span id='topic+bdem.parameter.traces'></span><span id='topic+e0.DLisDecrement'></span><span id='topic+e0.get.dlcurves'></span><span id='topic+get.countries.index.bayesLife.mcmc.meta'></span><span id='topic+get.data.matrix.bayesLife.mcmc.meta'></span><span id='topic+get.data.imputed.bayesLife.prediction'></span><span id='topic+get.e0.shift'></span><span id='topic+get.friendly.variant.names.bayesLife.prediction'></span><span id='topic+get.new.e0.colnames'></span><span id='topic+get.nr.countries.bayesLife.mcmc.meta'></span><span id='topic+get.nrest.countries.bayesLife.mcmc.meta'></span><span id='topic+get.projection.summary.header.bayesLife.prediction'></span><span id='topic+get.traj.ascii.header.bayesLife.mcmc.meta'></span><span id='topic+get.UN.variant.names.bayesLife.prediction'></span><span id='topic+store.bayesLife.convergence'></span><span id='topic+store.bayesLife.prediction'></span><span id='topic+loess.sd'></span>

<h3>Description</h3>

<p>These functions and datasets are not to be used directly by the user.
</p>

<hr>
<h2 id='bayesLife.mcmc'>
MCMC Simulation Object
</h2><span id='topic+bayesLife.mcmc'></span>

<h3>Description</h3>

<p>MCMC simulation object <code>bayesLife.mcmc</code> containing information about one MCMC chain. A set of such objects belonging to the same simulation together with a <code><a href="#topic+bayesLife.mcmc.meta">bayesLife.mcmc.meta</a></code> object constitute a <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> object. 
</p>


<h3>Details</h3>

<p>An object <code>bayesLife.mcmc</code> points to a place on disk (element <code>output.dir</code>) where MCMC results from all iterations are stored. They can be retrieved to the memory using <code><a href="#topic+get.e0.mcmc">get.e0.mcmc</a>(...)</code>. 
</p>
<p>The object is in standard cases not to be manipulated by itself, but rather as part of a <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> object.
</p>


<h3>Value</h3>

<p>A <code>bayesLife.mcmc</code> object contains parameters of the Bayesian hierarchical model, more specifically, their initial values (all names with the suffix <code>.ini</code>) and values from the last iteration.  These are: <br />
<code>Triangle/Triangle.ini, lambda/lambda.ini</code> - world parameters, containing four values each. They correspond to model parameters <code class="reqn">\Delta_1, \dots, \Delta_4</code> and <code class="reqn">\lambda_1, \dots \lambda_4</code>, respectively.<br />
<code>k/k.ini, z/z.ini, omega/omega.ini, lambda.k/lambda.k.ini,</code><br /> <code>lambda.z/lambda.z.ini</code> -  world parameters, containing one value each. They correspond to model parameters <code class="reqn">k</code>, <code class="reqn">z</code>, <code class="reqn">\omega</code>, <code class="reqn">\lambda_k</code>, and <code class="reqn">\lambda_z</code>, respectively.<br />
<code>Triangle.c</code> - country-specific parameter <code class="reqn">\Delta^c_1, \dots, \Delta^c_4</code> with four values for each country, i.e. an <code class="reqn">4 \times C</code> matrix where <code class="reqn">C</code> is the number of countries.<br />
<code>k.c, z.c</code> - country-specific parameters <code class="reqn">k^c</code> and <code class="reqn">z^c</code> (1d arrays of length <code class="reqn">C</code>).<br />
Furthermore, the object contains components:
</p>
<table>
<tr><td><code>iter</code></td>
<td>
<p>Total number of iterations the simulation was started with.</p>
</td></tr>
<tr><td><code>finished.iter</code></td>
<td>
<p>Number of iterations that were finished.  Results from the last finished iteration are stored in the parameters above.</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>Length of the MCMC stored on disk. It differs from <code>finished.iter</code> only if <code>thin</code> is larger than one.</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>
<p>Thinning interval used when simulating the MCMCs.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Identifier of this chain.</p>
</td></tr>
<tr><td><code>output.dir</code></td>
<td>
<p>Subdirectory (relative to <code>output.dir</code> in the <code><a href="#topic+bayesLife.mcmc.meta">bayesLife.mcmc.meta</a></code> object) where results of this chain are stored.</p>
</td></tr>
<tr><td><code>traces</code></td>
<td>
<p>This is a placeholder for keeping whole parameter traces in the memory.  If the processing operates in a low memory mode, it will be 0.  It can be filled in using the function <code><a href="#topic+get.e0.mcmc">get.e0.mcmc</a>(..., low.memory=FALSE)</code>. In such a case, <code>traces</code> is a <code class="reqn">I \times J</code> array where <code class="reqn">I</code> is the MCMC <code>length</code> and <code class="reqn">J</code> is the number of parameters.</p>
</td></tr>
<tr><td><code>traces.burnin</code></td>
<td>
<p>Burnin used to retrieve the traces, i.e. how many stored iterations are missing from the beginning in the <code>traces</code> array comparing to the &lsquo;raw&rsquo; traces on the disk.</p>
</td></tr>
<tr><td><code>rng.state</code></td>
<td>
<p>State of the random number generator at the end of the last finished interation.</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.meta">bayesLife.mcmc.meta</a></code> used for simulation of this chain.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>, <code><a href="#topic+get.e0.mcmc">get.e0.mcmc</a></code>, <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>, <code><a href="#topic+bayesLife.mcmc.meta">bayesLife.mcmc.meta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
# loads traces from one chain
m &lt;- get.e0.mcmc(sim.dir, low.memory = FALSE, burnin = 40, chain.ids = 1)
# should have 20 rows, since 60 iterations in total minus 40 burnin
dim(e0.mcmc(m, 1)$traces)
summary(m)
</code></pre>

<hr>
<h2 id='bayesLife.mcmc.meta'>
MCMC Simulation Meta Object
</h2><span id='topic+bayesLife.mcmc.meta'></span>

<h3>Description</h3>

<p>Simulation meta object <code>bayesLife.mcmc.meta</code> used by all chains of the same MCMC simulation. 
It contains information that is common to all chains. It is a part of a <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> object.
</p>


<h3>Details</h3>

<p>The object is in standard cases not to be manipulated by itself, but rather as part of a <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> object.
</p>


<h3>Value</h3>

<p>A <code>bayesLife.mcmc.meta</code> object stores values of the various input arguments 
of the <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code> function. These are <code>sex</code>, <code>nr.chains</code>, 
<code>start.year</code>, <code>present.year</code>, <code>wpp.year</code>, <code>my.e0.file</code>, <code>compression.type</code>. <br />
Furthermore, it contains components:
</p>
<table>
<tr><td><code>e0.matrix.all</code></td>
<td>
<p>A <code class="reqn">q \times n</code> matrix with the United Nations life expectancy estimates. <code class="reqn">q</code> is number of years, <code class="reqn">n</code> is number of countries (see <code>nr.countries</code> below). The first <code class="reqn">n_e</code> columns correspond to countries included in the MCMC estimation (see <code>nr.countries.estimation</code> below), where <code class="reqn">n_e &lt;= n</code>. The order of the countries corresponds to the order of countries in the element <code>regions</code> and <code>regionsDT</code>, see below.</p>
</td></tr>
<tr><td><code>e0.matrix</code></td>
<td>
<p>Like <code>e0.matrix.all</code>, but it has <code>NA</code> values for years that were excluded from the estimation due to setting the <code>start.year</code> and <code>present.year</code> argument, and the &lsquo;last.observed&rsquo; column (see Details in <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>).</p>
</td></tr>
<tr><td><code>d.ct</code></td>
<td>
<p>A difference e0 matrix of size <code class="reqn">(q-1) \times n</code>. Each element <code class="reqn">x_{t,i}</code> is a difference 
<code class="reqn">y_{t+1,i}-y_{t,i}</code> where <code class="reqn">y</code> denotes elements of the <code>e0.matrix</code>. Outliers are set to <code>NA</code>.</p>
</td></tr>
<tr><td><code>loessSD</code></td>
<td>
<p>Matrix of the same dimension as <code>d.ct</code>. It contains values of the <code>loess_sd</code> dataset at the e0 levels of <code>e0.matrix</code>. See also <code><a href="#topic+compute.loess">compute.loess</a></code>.</p>
</td></tr>
<tr><td><code>nr.countries</code></td>
<td>
<p>Number of countries included in the e0 matrices.</p>
</td></tr>
<tr><td><code>nr.countries.estimation</code></td>
<td>
<p>Number of countries included in the MCMC estimation. It must be smaller or equal to <code>nr.countries</code>.</p>
</td></tr>
<tr><td><code>Tc.index</code></td>
<td>
<p>A list with one element per country. For each country, it contains the index within <code>e0.matrix</code> where the observed historical data are not <code>NA</code>, i.e. it points to the data used in the estimation.</p>
</td></tr>
<tr><td><code>regions</code></td>
<td>
<p>List of arrays of length <code>nr.countries</code>. These are: <br />
<code>name</code> - Region name for each country.<br />
<code>code</code> - Region code for each country. <br />
<code>area_name</code> - Area name for each country. <br />
<code>area_code</code> - Area code for each country. <br />
<code>country_name</code> - Array of country names. <br />
<code>country_code</code> - Array of country codes. <br />
Any country indices in the <code>bayesLife.mcmc.meta</code> object are derived from this component.</p>
</td></tr>
<tr><td><code>regionsDT</code></td>
<td>
<p>Like <code>regions</code> but for convenience it is a <code>data.table</code> object. A country in i-th row of this table has e0 data stored in the i-th column of <code>e0.matrix</code>.</p>
</td></tr>
<tr><td><code>output.dir</code></td>
<td>
<p>Directory for storing simulation output.</p>
</td></tr>
<tr><td><code>mcmc.options</code></td>
<td>
<p>List of various options used in the estimation. See <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>.</p>
</td></tr>
<tr><td><code>country.bounds</code></td>
<td>
<p>List of country-specific bounds of the various parameter priors, as constructed from the <code>country.overwrites</code> option (see <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>).</p>
</td></tr>
<tr><td><code>suppl.data</code></td>
<td>
<p>If supplemental data were used in the simulation (i.e. start year was set prior to 1950), this is a list containing information about the additional data. It has the following components of the same form as described above, but related only to the additional data: <code>e0.matrix</code>,  <code>regions</code>, <code>regionsDT</code>, <code>Tc.index</code>, <code>nr.countries</code>, <code>d.ct</code>, <code>loessSD</code>. In addition, it has the vectors<br />
<code>index.from.all.countries</code> - a vector of size <code>nr.countries</code> (all countries) where each element is an index to the supplemental data, i.e. a match from regions$country_code to suppl.data$regions$country_code.<br />
<code>index.to.all.countries</code> - a vector of size <code>suppl.data$nr.countries</code> (additional countries) where each element is an index to all data, i.e. a match from <code>suppl.data$regions$country_code</code> to <code>regions$country_code</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>, <code><a href="#topic+get.e0.mcmc">get.e0.mcmc</a></code>, <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
m &lt;- get.e0.mcmc(sim.dir)
summary(m, meta.only = TRUE)
names(m$meta)
</code></pre>

<hr>
<h2 id='compute.loess'>
Computing Residuals and Fitting Local Polynomial Regression
</h2><span id='topic+compute.loess'></span><span id='topic+compute.residuals'></span>

<h3>Description</h3>

<p>Functions for computing residuals from the observed life expectancy and MCMC estimation, and fitting a local polynomial regression. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.residuals(sim.dir, burnin = 1000)

compute.loess(sim.dir = NULL, burnin = 1000, residuals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.loess_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC estimation. In <code>compute.loess</code>, it is only used if <code>residuals</code> is not given.</p>
</td></tr>
<tr><td><code id="compute.loess_+3A_burnin">burnin</code></td>
<td>
<p>Number of (unthinned) iterations to be discarded. In <code>compute.loess</code>, it is only used if <code>residuals</code> is not given.</p>
</td></tr>
<tr><td><code id="compute.loess_+3A_residuals">residuals</code></td>
<td>
<p>Residuals can be computed outside of the <code>compute.loess</code> function and passed as the <code>residuals</code> argument. If not given, the <code>compute.loess</code> function calls <code>compute.residuals</code> internally, in which case <code>sim.dir</code> must be given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Bayesian hierarchical model for life expectancy uses a lowess curve as a multiplier of the variance. The dataset is stored in the package as the <code>loess_sd</code> dataset. These functions can be used to re-compute this <code>loess_sd</code> dataset. In such a case, the simulation should be run with the argument <code>constant.variance = TRUE</code> (in <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>).
</p>
<p>The residuals are computed for each country as the absolute differences between the observed life expectancy increases and the mean of the estimated double logistic function at the corresponding life expectancy level.
</p>


<h3>Value</h3>

<p><code>compute.residuals</code> returns a data frame with columns &lsquo;x&rsquo; (life expectancy levels) and &lsquo;y&rsquo; (absolute residuals). 
</p>
<p><code>compute.loess</code> also returns a data frame with columns &lsquo;x&rsquo; and &lsquo;y&rsquo;, where &lsquo;x&rsquo; is the same as before (with added a minimum and maximum) and &lsquo;y&rsquo; is the local polynomial fit with constant tails.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
resid &lt;- compute.residuals(sim.dir, burnin = 30)
lws &lt;- compute.loess(residuals = resid)

# plot residuals and loess
plot(resid$x, resid$y, ylim = c(0, 4))
lines(lws$x, lws$y, col = "red")
</code></pre>

<hr>
<h2 id='convert.e0.trajectories'>
Converting Trajectories of Life Expectancy into ACSII Files</h2><span id='topic+convert.e0.trajectories'></span>

<h3>Description</h3>

<p>Converts trajectories of the life expectancy stored in a binary format into two CSV files of a UN-specific format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert.e0.trajectories(dir = file.path(getwd(), "bayesLife.output"), 
    n = 1000, output.dir = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert.e0.trajectories_+3A_dir">dir</code></td>
<td>
<p>Directory containing the prediction object. It should correspond to the <code>output.dir</code> argument of the <code><a href="#topic+e0.predict">e0.predict</a></code> function.</p>
</td></tr>
<tr><td><code id="convert.e0.trajectories_+3A_n">n</code></td>
<td>
<p>Number of trajectories to be stored. It can be either a single number or the word &ldquo;all&rdquo; in which case all available trajectories are converted.</p>
</td></tr>
<tr><td><code id="convert.e0.trajectories_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory in which the resulting files will be stored. If <code>NULL</code> the same directory is used as for the prediction. Otherwise, if the directory contains joint predictions for both sexes, the ouptuts are stored into subdirectories &lsquo;<span class="file">F</span>&rsquo; and &lsquo;<span class="file">M</span>&rsquo;.</p>
</td></tr>
<tr><td><code id="convert.e0.trajectories_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates two files per sex. One is called &ldquo;ascii_trajectories.csv&rdquo;, it is a comma-separated table with the following columns: 
</p>
<ul>
<li><p>&ldquo;LocID&rdquo;: country code 
</p>
</li>
<li><p>&ldquo;Period&rdquo;: prediction interval, e.g. 2015-2020 
</p>
</li>
<li><p>&ldquo;Year&rdquo;: middle year of the prediction interval
</p>
</li>
<li><p>&ldquo;Trajectory&rdquo;: identifier of the trajectory
</p>
</li>
<li><p>&ldquo;e0&rdquo;: life expectancy
</p>
</li></ul>

<p>The second file is called &ldquo;ascii_trajectories_wide.csv&rdquo;, it is also a comma-separated table and it contains the same information as above but in a &lsquo;transposed&rsquo; format. I.e. the data for one country are ordered in columns, thus, there is one column per country. The country columns are ordered alphabetically. 
</p>
<p>If <code>n</code> is smaller than the total number of trajectories, the trajectories are selected using equal spacing.</p>


<h3>Note</h3>

<p>This function is automatically called from the <code><a href="#topic+e0.predict">e0.predict</a></code> function, therefore in standard cases it will not be needed to call it directly. However, it can be useful for example, if different number of trajectories are to be converted, without having to re-run the prediction.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+write.e0.projection.summary">write.e0.projection.summary</a></code>, <code><a href="#topic+e0.predict">e0.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
pred.dir &lt;- file.path(getwd(), "exampleLEpred")

# stores 10 trajectories out of 30 (60-30) into 
# exampleLEpred/predictions/ascii_trajectories.csv (for female)
# and exampleLEpred/predictions/joint_male/ascii_trajectories.csv (for male)
e0.predict(sim.dir = sim.dir, output.dir = pred.dir, 
            burnin = 30, save.as.ascii = 10, verbose = TRUE)
            
# stores all 30 trajectories into the current directory
convert.e0.trajectories(dir = pred.dir, n = "all", output.dir = ".", verbose = TRUE)

# Note: If the output.dir argument in e0.predict is omitted, 
# call convert.e0.trajectories with dir = sim.dir 

## End(Not run)
</code></pre>

<hr>
<h2 id='e0.coda.list.mcmc'>
Convertion to coda's Objects
</h2><span id='topic+e0.coda.list.mcmc'></span><span id='topic+coda.mcmc.bayesLife.mcmc'></span>

<h3>Description</h3>

<p>The functions convert MCMC traces (simulated using <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>) into objects that can be used with the <span class="pkg">coda</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.coda.list.mcmc(mcmc.list = NULL, country = NULL, chain.ids = NULL, 
    sim.dir = file.path(getwd(), "bayesLife.output"), 
    par.names = NULL, par.names.cs = NULL, low.memory = FALSE, ...)
    
## S3 method for class 'bayesLife.mcmc'
coda.mcmc(mcmc, country = NULL, par.names = NULL, par.names.cs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.coda.list.mcmc_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code> objects, or an object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> or <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>. If it is <code>NULL</code>, the MCMCs are loaded from <code>sim.dir</code>. Either <code>mcmc.list</code> or <code>sim.dir</code> must be given.</p>
</td></tr>
<tr><td><code id="e0.coda.list.mcmc_+3A_mcmc">mcmc</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="e0.coda.list.mcmc_+3A_country">country</code></td>
<td>
<p>Country name or code. It is used in connection with the <code>par.names.cs</code> argument (see below).</p>
</td></tr>
<tr><td><code id="e0.coda.list.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>
<p>Vector of chain identifiers. By default, all chains available in the <code>mcmc.list</code> object are included.
</p>
</td></tr>
<tr><td><code id="e0.coda.list.mcmc_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. Only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="e0.coda.list.mcmc_+3A_par.names">par.names</code></td>
<td>
<p>Names of country-independent parameters to be included.</p>
</td></tr>
<tr><td><code id="e0.coda.list.mcmc_+3A_par.names.cs">par.names.cs</code></td>
<td>
<p>Names of country-specific parameters to be included. The argument <code>country</code> is used to filter out traces that correspond to a specific country. If <code>country</code> is not given, for each parameter, traces for all countries are included.</p>
</td></tr>
<tr><td><code id="e0.coda.list.mcmc_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the function should run in a memory-efficient mode.</p>
</td></tr>
<tr><td><code id="e0.coda.list.mcmc_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <span class="pkg">coda</span>'s <code><a href="coda.html#topic+mcmc">mcmc</a></code> function, such as <code>burnin</code> and <code>thin</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>e0.coda.list.mcmc</code> returns an object of class &ldquo;mcmc.list&rdquo;. The function <code>coda.mcmc</code> returns an object of class &ldquo;mcmc&rdquo;, both defined in the <span class="pkg">coda</span> package.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.partraces.plot">e0.partraces.plot</a></code> for plotting the MCMC traces and <code><a href="#topic+summary.bayesLife.mcmc.set">summary.bayesLife.mcmc.set</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
coda.list &lt;- e0.coda.list.mcmc(sim.dir = sim.dir, country = "France", burnin = 30)
summary(coda.list)
</code></pre>

<hr>
<h2 id='e0.diagnose'>
Convergence Diagnostics for Markov Chain Monte Carlo of Life Expectancy
</h2><span id='topic+e0.diagnose'></span><span id='topic+bayesLife.convergence'></span>

<h3>Description</h3>

<p>Function <code>e0.diagnose</code> runs convergence diagnostics of existing MCMCs, using the <code>raftery.diag</code> function from the <span class="pkg">coda</span> package. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.diagnose(sim.dir, thin = 225, burnin = 10000, express = FALSE, 
    country.sampling.prop = NULL, keep.thin.mcmc = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.diagnose_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results.</p>
</td></tr>
<tr><td><code id="e0.diagnose_+3A_thin">thin</code></td>
<td>
<p>Thinning interval.</p>
</td></tr>
<tr><td><code id="e0.diagnose_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of the parameter traces.</p>
</td></tr>
<tr><td><code id="e0.diagnose_+3A_express">express</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the convergence diagnostics is run only on the country-independent parameters. If <code>FALSE</code>, the country-specific parameters are included in the diagnostics. The number of countries can be controlled by <code>country.sampling.prop</code>.</p>
</td></tr>
<tr><td><code id="e0.diagnose_+3A_country.sampling.prop">country.sampling.prop</code></td>
<td>
<p>Proportion of countries that are included in the diagnostics. If it is <code>NULL</code> and <code>express=FALSE</code>, all countries are included. Setting here a number between 0 and 1, one can limit the number of countries which are then randomly sampled. Note that for long MCMCs, this argument may significantly influence the run-time of this function.</p>
</td></tr>
<tr><td><code id="e0.diagnose_+3A_keep.thin.mcmc">keep.thin.mcmc</code></td>
<td>
<p>Logical. If <code>TRUE</code> the thinned traces used for computing the diagnostics are stored on disk (see <code><a href="#topic+create.thinned.e0.mcmc">create.thinned.e0.mcmc</a></code>).</p>
</td></tr>
<tr><td><code id="e0.diagnose_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function invokes the <code><a href="#topic+e0.raftery.diag">e0.raftery.diag</a></code> function separately for country-independent parameters and for country-specific parameters. It results in two possible states: red, i.e. it did not converge, and green, i.e. it converged.
The resulting object is stored in <br /> &lsquo;<span class="file">{sim.dir}/diagnostics/bayesLife.convergence_{thin}_{burnin}.rda</span>&rsquo; and can be accessed using the function <code><a href="#topic+get.e0.convergence">get.e0.convergence</a></code>.
</p>
<p>Function <code><a href="bayesTFR.html#topic+has.mcmc.converged">has.mcmc.converged</a></code> from the <span class="pkg">bayesTFR</span> package can be used to check if the existing diagnostics converged.
</p>


<h3>Value</h3>

<p><code>e0.diagnose</code> returns an object of class <code>bayesLife.convergence</code> with components:
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>Table containing all not-converged parameters. Its columns include &lsquo;Total iterations needed&rsquo; and &lsquo;Remaining iterations&rsquo;.</p>
</td></tr>
<tr><td><code>lresult.country.independent</code></td>
<td>
<p>Number of rows in <code>result</code> that correspond to country-independent paramters. These rows are groupped at the beginning of the table.</p>
</td></tr>
<tr><td><code>country.independent</code></td>
<td>
<p>Result of <code><a href="#topic+e0.raftery.diag">e0.raftery.diag</a></code> processed on country-independent parameters.</p>
</td></tr>
<tr><td><code>country.specific</code></td>
<td>
<p>Result of <code><a href="#topic+e0.raftery.diag">e0.raftery.diag</a></code> processed on country-specific parameters.</p>
</td></tr>
<tr><td><code>iter.needed</code></td>
<td>
<p>Number of additional iterations suggested in order to achieve convergence.</p>
</td></tr>
<tr><td><code>iter.total</code></td>
<td>
<p>Total number of iterations of the original unthinned set of chains.</p>
</td></tr>
<tr><td><code>use.nr.traj</code></td>
<td>
<p>Suggestion for number of trajectories in generating predictions.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>Burnin used.</p>
</td></tr>
<tr><td><code>thin</code></td>
<td>
<p>Thinning interval used.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>Vector of character strings containing the result status. Possible values: &lsquo;green&rsquo;, &lsquo;red&rsquo;.</p>
</td></tr>
<tr><td><code>mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> that corresponds to the original set of MCMCs on which the diagnostics was run.</p>
</td></tr>
<tr><td><code>thin.mcmc</code></td>
<td>
<p>If <code>keep.thin.mcmc</code> is <code>TRUE</code>, it is an object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> that corresponds to the thinned mcmc set on which the diagnostics was run, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code>express</code></td>
<td>
<p>Value of the input argument <code>express</code>.</p>
</td></tr>
<tr><td><code>nr.countries</code></td>
<td>
<p>Vector with elements <code>used</code> - number of countries used in this diagnostics, and <code>total</code> - number of countries that this <code>mcmc.set</code> object was estimated on.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.raftery.diag">e0.raftery.diag</a></code>, <code><a href="coda.html#topic+raftery.diag">raftery.diag</a></code>, <code><a href="#topic+summary.bayesLife.convergence">summary.bayesLife.convergence</a></code>, <code><a href="#topic+get.e0.convergence">get.e0.convergence</a></code>, <code><a href="#topic+create.thinned.e0.mcmc">create.thinned.e0.mcmc</a></code>
</p>

<hr>
<h2 id='e0.dl.coverage'>
Goodness of Fit of the Double Logistic Function
</h2><span id='topic+e0.dl.coverage'></span>

<h3>Description</h3>

<p>The function computes coverage, i.e. the ratio of observed data fitted within the given probability intervals of the predictive posterior distribution of the double logistic function, as well as the root mean square error of the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.dl.coverage(sim.dir, pi = c(80, 90, 95), burnin = 10000, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.dl.coverage_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. If a prediction and its corresponding thinned mcmcs are available in the simulation directory, those are taken for assessing the goodness of fit.</p>
</td></tr>
<tr><td><code id="e0.dl.coverage_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="e0.dl.coverage_+3A_burnin">burnin</code></td>
<td>
<p>Burnin. Only relevant if <code>sim.dir</code> does not contain thinned chains.</p>
</td></tr>
<tr><td><code id="e0.dl.coverage_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the same components as <code><a href="bayesTFR.html#topic+tfr.dl.coverage">tfr.dl.coverage</a></code>.
</p>


<h3>Note</h3>

<p>To see the fit visually per country, use <code><a href="#topic+e0.DLcurve.plot">e0.DLcurve.plot</a>(..., predictive.distr=TRUE,...)</code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.DLcurve.plot">e0.DLcurve.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
e0 &lt;- get.e0.mcmc(sim.dir)
# Note that this simulation is a toy example and thus has not converged.
gof &lt;- e0.dl.coverage(sim.dir)
gof$country.coverage
e0.DLcurve.plot(e0, country=608, predictive.distr=TRUE, pi=c(80, 90, 95))

## End(Not run)</code></pre>

<hr>
<h2 id='e0.DLcurve.plot'>
Plotting  Posterior Distribution of the Double Logistic Function of Life Expectancy
</h2><span id='topic+e0.DLcurve.plot'></span><span id='topic+e0.DLcurve.plot.all'></span><span id='topic+e0.world.dlcurves'></span><span id='topic+e0.country.dlcurves'></span><span id='topic+e0.parDL.plot'></span>

<h3>Description</h3>

<p>The functions plot the posterior distribution of the double logistic function used in the simulation, including their median and given probability intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.DLcurve.plot(mcmc.list, country, burnin = NULL, pi = 80, 
    e0.lim = NULL, nr.curves = 20, predictive.distr = FALSE, ylim = NULL, 
    xlab = "e(0)", ylab = "5-year gains", main = NULL, show.legend = TRUE, 
    col = c('black', 'red', "#00000020"), ...)
    
e0.DLcurve.plot.all(mcmc.list = NULL, sim.dir = NULL, 
    output.dir = file.path(getwd(), "DLcurves"),
    output.type = "png", burnin = NULL, verbose = FALSE, ...)
    
e0.parDL.plot(mcmc.set, country = NULL, burnin = NULL, lty = 2, 
    ann = TRUE, ...)
	
e0.world.dlcurves(x, mcmc.list, burnin = NULL, ...)

e0.country.dlcurves(x, mcmc.list, country, burnin = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.DLcurve.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code> objects, an object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> or of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>. In case of <code>e0.DLcurve.plot.all</code> if it si <code>NULL</code>, it is loaded from <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> or <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of parameter traces.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_e0.lim">e0.lim</code></td>
<td>
<p>It can be a tuple of the minimum and maximum life expectancy to be shown in the plot. If <code>NULL</code>, it takes the minimum of observed data and 40, and the maximum of observed data and 90.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_nr.curves">nr.curves</code></td>
<td>
<p>Number of curves to be plotted. If <code>NULL</code>, all curves are plotted.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_predictive.distr">predictive.distr</code></td>
<td>
<p>Logical. If <code>TRUE</code>, an error term is added to each trajectory.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_ylim">ylim</code>, <code id="e0.DLcurve.plot_+3A_xlab">xlab</code>, <code id="e0.DLcurve.plot_+3A_ylab">ylab</code>, <code id="e0.DLcurve.plot_+3A_main">main</code>, <code id="e0.DLcurve.plot_+3A_lty">lty</code></td>
<td>
<p>Graphical parameters passed to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical determining if the legend should be shown.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_col">col</code></td>
<td>
<p>Vector of colors in this order: 1. observed data points, 2. quantiles, 3. trajectories</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters. In addition, any arguments from <code>e0.DLcurve.plot</code> except <code>country</code> can be passed to <code>e0.DLcurve.plot.all</code>.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the simulation results. Only relevant, if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting graphs are stored.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_x">x</code></td>
<td>
<p>e0 values for which the double logistic should be computed.</p>
</td></tr>
<tr><td><code id="e0.DLcurve.plot_+3A_ann">ann</code></td>
<td>
<p>Logical if parameters should be annotated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>e0.DLcurve.plot</code> plots double logistic curves for the given country.  <code>e0.DLcurve.plot.all</code> creates such plots for all countries and stores them in <code>output.dir</code>. Parameters passed to the double logistic function are either thinned traces created by the <code><a href="#topic+e0.predict">e0.predict</a></code> function (if <code>mcmc.list</code> is an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>), or they are selected by equal spacing from the MCMC traces. In the former case, <code>burnin</code> is set automatically; in the latter case, <code>burnin</code> defaults to 0 since such object has already been &ldquo;burned&rdquo;. If <code>nr.curves</code> is smaller than 2000, the median and probability intervals are computed on a sample of 2000 equally spaced data points, otherwise on all plotted curves.
</p>
<p>Function <code>e0.parDL.plot</code> draws the means of the DL parameters as vertical and horizontal lines. The lines are added to the current graphical device and annotated if <code>ann</code> is <code>TRUE</code>. If country is <code>NULL</code>, the mean of world parameters are drawn.
</p>
<p>Function <code>e0.world.dlcurves</code> returns the DL curves of the hierarchical distribution. Function <code>e0.country.dlcurves</code> returns DL curves for a given country. If <code>mcmc.list</code> is a prediction object, <code>burnin</code> should not be given, as such object has already been &ldquo;burned&rdquo;.  
</p>


<h3>Value</h3>

<p><code>e0.world.dlcurves</code> and <code>e0.country.dlcurves</code> return a matrix of size <code class="reqn">N \times M</code> where <code class="reqn">N</code> is the number of trajectories and <code class="reqn">M</code> is the number of values of <code class="reqn">x</code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
mcmc.set &lt;- get.e0.mcmc(sim.dir = sim.dir)
e0.DLcurve.plot(mcmc.set, country = "Japan", burnin = 40)
e0.parDL.plot(mcmc.set, "Japan")

# add the median of the hierarchical DL curves
x &lt;- seq(40, 90, length = 100)
world &lt;- e0.world.dlcurves(x, mcmc.set, burnin = 40)
qw &lt;- apply(world, 2, median) 
lines(x, qw, col = 'blue')

## End(Not run)
</code></pre>

<hr>
<h2 id='e0.gap.plot'>
Posterior Distribution of Gaps in Female and Male Life Expectancy
</h2><span id='topic+e0.gap.plot'></span><span id='topic+e0.gap.plot.all'></span>

<h3>Description</h3>

<p>The functions plot the posterior distribution of the gaps between female and male life expectancy, modeled and predicted using a model described in Lalic (2011) and Raftery, Lalic &amp; Gerland (2014). This can be done for one country (<code>e0.gap.plot</code>) or for all countries (<code>e0.gap.plot.all</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.gap.plot(e0.pred, country, e0.pred2 = NULL, pi = c(80, 95), 
    nr.traj = 0, xlim = NULL, ylim = NULL, type = "b", 
    xlab = "Year", ylab = "Gap in life expectancy", main = NULL, 
    show.legend = TRUE, ...)
    
e0.gap.plot.all(e0.pred, output.dir = file.path(getwd(), "e0gaps"),
    output.type = "png", verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.gap.plot_+3A_e0.pred">e0.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> containing female projections. If <code>e0.pred2</code> is not given, then this object must contain the &lsquo;joint.male&rsquo; component, generated using the <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code> function.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_e0.pred2">e0.pred2</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> containing male projections. By default the male projections is taken from the joint female-male projections in <code>e0.pred</code>, see above.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be plotted.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_xlim">xlim</code>, <code id="e0.gap.plot_+3A_ylim">ylim</code>, <code id="e0.gap.plot_+3A_type">type</code>, <code id="e0.gap.plot_+3A_xlab">xlab</code>, <code id="e0.gap.plot_+3A_ylab">ylab</code>, <code id="e0.gap.plot_+3A_main">main</code></td>
<td>
<p>Graphical parameters passed to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical controlling whether the legend should be drawn.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting graphs are stored.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="e0.gap.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters. In addition, for <code>e0.gap.plot.all</code>, <code>...</code> 
contains any of the arguments of  <code>e0.gap.plot</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>References</h3>

<p>Lalic, N. (2011). Master's thesis at the Department of Statistics, University of Washington.
</p>
<p>A. E. Raftery,  N. Lalic, P. Gerland (2014). Joint Probabilistic Projection of Female and Male Life Expectancy. Demographic Research, 30:795-822.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.joint.plot">e0.joint.plot</a></code>, <code><a href="#topic+e0.jmale.estimate">e0.jmale.estimate</a></code>, <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>, <code><a href="#topic+get.e0.jmale.prediction">get.e0.jmale.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example for e0.jmale.predict
</code></pre>

<hr>
<h2 id='e0.jmale.estimate'>
Estimation of the Joint Female-Male Model
</h2><span id='topic+e0.jmale.estimate'></span>

<h3>Description</h3>

<p>The function estimates the joint female-male model of life expectancy, as described in Raftery et al. (2014, 2012) and Lalic (2011). It consist of two equations with t-distributed errors, see Details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.jmale.estimate(mcmc.set, countries.index = NULL, 
    estDof.eq1 = TRUE, start.eq1 = list(dof = 2), max.e0.eq1 = 83, 
    estDof.eq2 = TRUE, start.eq2 = list(dof = 2),
    constant.gap.eq2 = TRUE, include.suppl.gap = FALSE, 
    my.e0.file = NULL, my.locations.file = NULL, 
    verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.jmale.estimate_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> containing estimation results of female life expectancy.</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_countries.index">countries.index</code></td>
<td>
<p>Index of countries (within the mcmc.set object) to be included in the estimation. By default, all countries included in the estimation of <code>mcmc.set</code> are used.</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_estdof.eq1">estDof.eq1</code>, <code id="e0.jmale.estimate_+3A_estdof.eq2">estDof.eq2</code></td>
<td>
<p>Logical, controlling whether the degrees of freedom of the first and second  equation, respectively, should be estimated. If it is <code>FALSE</code> the degrees of freedom are set using the arguments <code>start.eq1</code> and <code>start.eq2</code>, respectively.</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_start.eq1">start.eq1</code>, <code id="e0.jmale.estimate_+3A_start.eq2">start.eq2</code></td>
<td>
<p>Argument <code>start</code> of the <code><a href="hett.html#topic+tlm">tlm</a></code> function of the <span class="pkg">hett</span> package, which is applied to the first and second equation of the model, respectively. It is a list of possibly four named components, (&quot;beta&quot;, &quot;lambda&quot;, &quot;dof&quot;, &quot;omega&quot;), for the location, scale, degrees of freedom parameters and random scale effects respectively. If <code>estDof.eq1</code> (<code>estDof.eq2</code>) is <code>FALSE</code>, the &quot;dof&quot; component must be given.
</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_max.e0.eq1">max.e0.eq1</code></td>
<td>
<p>Maximum female life expectancy of records included in the estimation of the first equation (parameter <code class="reqn">M</code> in Details below).</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_constant.gap.eq2">constant.gap.eq2</code></td>
<td>
<p>Logical. If <code>TRUE</code> the coefficient of the second equation (<code class="reqn">\gamma_1</code>) is set to one and the standard deviation is estimated under the assumption of normal distribution.</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_include.suppl.gap">include.suppl.gap</code></td>
<td>
<p>If <code>TRUE</code> data prior 1950 are used in the estimation of the gap model.</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_my.e0.file">my.e0.file</code></td>
<td>
<p>File name containing user-specified male time series for one or more countries. The function replaces the corresponding country data from the  WPP dataset by values in this file. Only columns are replaced that match column names of the WPP dataset.</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_my.locations.file">my.locations.file</code></td>
<td>
<p>File name containing user-specified locations if different from the default <code><a href="wpp2017.html#topic+UNlocations">UNlocations</a></code> dataset. It should be the same file as passed to <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code> for female life expectancy.</p>
</td></tr>
<tr><td><code id="e0.jmale.estimate_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off. If <code>TRUE</code> summary results from the <code><a href="hett.html#topic+tlm">tlm</a></code> function of both equations are shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The joint female-male life expectancy model is a model for estimating gaps <code class="reqn">G</code> between female and male life expectancy. It consists of two parts, see Equation (1) in Raftery et  al. (2012): <br />
1. If <code class="reqn">l_{c,t} \leq M</code>, then 
</p>
<p style="text-align: center;"><code class="reqn">
	G_{c,t} = \beta_0 + \beta_1 l_{c,1953} + \beta_2 G_{c,t-1} + \beta_3 l_{c,t} + \beta_4 (l_{c,t}-75)_+ + \epsilon_{c,t}
</code>
</p>

<p>where <code class="reqn">\epsilon_{c,t}</code> is iid <code class="reqn">t(\mu=0, \sigma_1^2, \nu_1)</code>.
</p>
<p>2. If <code class="reqn">l_{c,t} &gt; M</code>, then 
</p>
<p style="text-align: center;"><code class="reqn">
	G_{c,t} = \gamma_1 G_{c,t-1} + \epsilon_{c,t}
</code>
</p>

<p>where <code class="reqn">\epsilon_{c,t}</code> is iid <code class="reqn">t(\mu=0, \sigma_2^2, \nu_2)</code>.
</p>
<p>Here, <code class="reqn">t</code> is the time and <code class="reqn">c</code> is the country index. <code class="reqn">G_{c,t}</code> is the gap for country <code class="reqn">c</code> at time <code class="reqn">t</code> and <code class="reqn">l_{c,t}</code> is the female life expectancy for country <code class="reqn">c</code> at time <code class="reqn">t</code>. <code class="reqn">M</code> can be set in the <code>max.e0.eq1</code> argument.
</p>
<p>Using the <code><a href="hett.html#topic+tlm">tlm</a></code> function of the <span class="pkg">hett</span> package, the function  estimates the coefficients <code class="reqn">\beta_i</code> (<code class="reqn">i=1,\dots,4</code>) and <code class="reqn">\gamma_1</code>, as well as paramteres <code class="reqn">\sigma_j</code> (<code class="reqn">j=1,2</code>) and optionally the degrees of freedom <code class="reqn">\nu_j</code> (<code class="reqn">j=1,2</code>). If <code>constant.gap.eq2</code> is <code>TRUE</code>, <code class="reqn">\gamma_1</code> is set to 1 and <code class="reqn">\epsilon_{c,t}</code> is iid <code class="reqn">N(\mu=0, \sigma_2^2)</code>.
</p>
<p>The <code>mcmc.set</code> object should be a <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> object obtained from a simulation of a female life expectancy. Note that since only the observed data and no MCMC results are used in this estimation, the <code>mcmc.set</code> object can be obtained from a toy simulation such as in the example below. The function extracts observed data from this object and treats them as <code class="reqn">l_{c,t}</code>. For the male historical time series, the function takes the male WPP dataset (<code><a href="wpp2017.html#topic+e0M">e0M</a></code>) from the same <span class="pkg">wpp</span> package as the female data, and possibly partly replaces the male dataset by any user-specified data given in <code>my.e0.file</code>. 
</p>


<h3>Value</h3>

<p>List with the components, <code>eq1</code> and <code>eq2</code>, each containing estimation results from the first and second equation, respectively. These are:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated coefficients <code class="reqn">\beta_i</code>.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Parameter <code class="reqn">\sigma_j</code>.</p>
</td></tr>
<tr><td><code>dof</code></td>
<td>
<p>Degrees of freedom <code class="reqn">\nu_j</code>. If <code>estDof.eq1</code> (<code>estDof.eq2</code>) is <code>TRUE</code> this parameter is estimated, otherwise it is set to the value of <code>start.eq1$dof</code> (<code>start.eq2$dof</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>References</h3>

<p>A. E. Raftery,  N. Lalic, P. Gerland (2014). Joint Probabilistic Projection of Female and Male Life Expectancy. Demographic Research, 30:795-822.
</p>
<p>A. E. Raftery,  N. Li, H. Sevcikova , P. Gerland, G. K. Heilig (2012). Bayesian probabilistic population projections for all countries. Proceedings of the National Academy of Sciences 109:13915-13921.	
</p>
<p>Lalic, N. (2011). Master's thesis at the Department of Statistics, University of Washington. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
m &lt;- get.e0.mcmc(sim.dir)
fit &lt;- e0.jmale.estimate(m, verbose = TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='e0.jmale.predict'>
Prediction of the Joint Female-Male Model
</h2><span id='topic+e0.jmale.predict'></span>

<h3>Description</h3>

<p>Prediction of the joint female-male model of life expectancy, as described in Raftery et al. (2014, 2012) and Lalic (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.jmale.predict(e0.pred, estimates = NULL, gap.lim = c(0, 18), 
    max.e0.eq1.pred = 86, my.e0.file = NULL, my.locations.file = NULL,
    save.as.ascii = 1000, resample.outrange = TRUE, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.jmale.predict_+3A_e0.pred">e0.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> containing female projections of life expectancy.</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_estimates">estimates</code></td>
<td>
<p>List of the same structure as returned by <code><a href="#topic+e0.jmale.estimate">e0.jmale.estimate</a></code>, containing the model estimation results. If it is not given, the <code><a href="#topic+e0.jmale.estimate">e0.jmale.estimate</a></code> function is invoked.</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_gap.lim">gap.lim</code></td>
<td>
<p>Vector of length two giving the minimum and maximum bounds for the female-male life expectancy gaps. See argument <code>resample.outrange</code> for two ways of handling gaps that fall outside of this range.</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_max.e0.eq1.pred">max.e0.eq1.pred</code></td>
<td>
<p>Maximum female life expectancy for male projections handled by the first equation (parameter <code class="reqn">M</code> in Equation (1) in Raftery et al. (2012)).</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_my.e0.file">my.e0.file</code></td>
<td>
<p>File name containing user-specified male time series for one or more countries. The function replaces the corresponding country data from the WPP dataset by values in this file. Only columns are replaced that match column names of the WPP dataset.</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_my.locations.file">my.locations.file</code></td>
<td>
<p>File name containing user-specified locations if different from the default <code><a href="wpp2017.html#topic+UNlocations">UNlocations</a></code> dataset. It should be the same file as passed to <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code> for female life expectancy.</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_save.as.ascii">save.as.ascii</code></td>
<td>
<p>Either a number determining how many trajectories should be converted into an ASCII file, or &ldquo;all&rdquo; in which case all trajectories are converted. It should be set to 0, if no conversion is desired.</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_resample.outrange">resample.outrange</code></td>
<td>
<p>Logical indicating if values outside of the allowed gap range given by <code>gap.lim</code> should be resampled. If set to <code>FALSE</code>, such values are truncated instead.</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="e0.jmale.predict_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+e0.jmale.estimate">e0.jmale.estimate</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no <code>estimates</code> are given, the function invokes an estimation by calling <code><a href="#topic+e0.jmale.estimate">e0.jmale.estimate</a></code>. Using those estimates, the male life expectancy is projected forward in time (as a function of a female-male gap), using the female predictions from <code>e0.pred</code>. The initial male data point is extracted from the male WPP dataset (<code><a href="wpp2017.html#topic+e0M">e0M</a></code>) and possibly partly replaced by any user-specified data given in <code>my.e0.file</code>.
</p>
<p>The resulting trajectory files are stored in a subdirectory of the female prediction directory, called &lsquo;joint_male&rsquo;. Furthermore, an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> is created and added to <code>e0.pred</code> as a component called <code>joint.male</code>. 
</p>
<p>The predicted gaps can be viewed using the <code><a href="#topic+e0.gap.plot">e0.gap.plot</a></code> function.
</p>


<h3>Value</h3>

<p>Updated <code>e0.pred</code> object where a new component was added, called <code>joint.male</code>. It is also an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> and it contains results from this prediction.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>References</h3>

<p>A. E. Raftery,  N. Lalic, P. Gerland (2014). Joint Probabilistic Projection of Female and Male Life Expectancy. Demographic Research, 30:795-822.
</p>
<p>A. E. Raftery,  N. Li, H. Sevcikova , P. Gerland, G. K. Heilig (2012). Bayesian probabilistic population projections for all countries. Proceedings of the National Academy of Sciences 109:13915-13921.
</p>
<p>Lalic, N. (2011). Master's thesis at the Department of Statistics, University of Washington. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.jmale.estimate">e0.jmale.estimate</a></code>, <code><a href="#topic+get.e0.jmale.prediction">get.e0.jmale.prediction</a></code>, <code><a href="#topic+e0.predict">e0.predict</a></code>, <code><a href="#topic+e0.gap.plot">e0.gap.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.e0.mcmc(sex = 'F', nr.chains = 1, iter = 30, thin = 1, output.dir = sim.dir)
pred &lt;- e0.predict(m, burnin = 15, verbose = FALSE, save.as.ascii = 0, 
                    predict.jmale = FALSE)
both.pred &lt;- e0.jmale.predict(pred)
e0.trajectories.plot(both.pred, 'Guatemala') # Female
e0.trajectories.plot(get.e0.jmale.prediction(both.pred), 'Guatemala') # Male

# Marginal distribution of the sex-specific projections
e0.trajectories.plot(both.pred, 'GTM', both.sexes = TRUE,  pi = 80)

# Plotting the gaps
e0.gap.plot(both.pred, 'GTM')

# Joint distribution of the sex-specific projections
e0.joint.plot(both.pred, 'Guatemala', pi = 80, years = c(2013, 2043, 2093))

unlink(sim.dir, recursive = TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='e0.joint.plot'>
Joint Posterior Distribution of Female and Male Life Expectancy
</h2><span id='topic+e0.joint.plot'></span><span id='topic+e0.joint.plot.all'></span>

<h3>Description</h3>

<p>The functions plot the joint posterior distribution of female and male life expectancy, modeled and predicted using the joint model described in Lalic (2011) and Raftery, Lalic &amp; Gerland (2014). This can be done for one country (<code>e0.joint.plot</code>) or for all countries (<code>e0.joint.plot.all</code>).</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.joint.plot(e0.pred, country, pi = 95, years, nr.points = 500, 
    obs.pch = 17, obs.cex=1, xlim = NULL, 
    ylim = NULL, xlab = "Female life expectancy", ylab = "Male life expectancy", 
    main = NULL, col = NULL, show.legend = TRUE, add = FALSE, ...)
    
e0.joint.plot.all(e0.pred, output.dir = file.path(getwd(), "e0joint"),
    output.type = "png", verbose = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.joint.plot_+3A_e0.pred">e0.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> containing female projections.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_years">years</code></td>
<td>
<p>Array of future years for which to plot the distribution.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_nr.points">nr.points</code></td>
<td>
<p>Number of points shown in the plot for each year.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_obs.pch">obs.pch</code>, <code id="e0.joint.plot_+3A_obs.cex">obs.cex</code></td>
<td>
<p>Graphical parameters used for displaying observed data or data without variation.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_xlim">xlim</code>, <code id="e0.joint.plot_+3A_ylim">ylim</code>, <code id="e0.joint.plot_+3A_xlab">xlab</code>, <code id="e0.joint.plot_+3A_ylab">ylab</code>, <code id="e0.joint.plot_+3A_main">main</code></td>
<td>
<p>Graphical parameters passed to the <code><a href="base.html#topic+plot">plot</a></code> function.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_col">col</code></td>
<td>
<p>Array of colors, one for each year.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical controlling whether the legend should be drawn.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_add">add</code></td>
<td>
<p>Logical controlling whether the distribution should be plotted into a new graphic device (<code>FALSE</code>) or into an existing device (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting graphs are stored.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="e0.joint.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed to the <code><a href="graphics.html#topic+lines">lines</a></code> function drawing ellipses. In addition, for <code>e0.joint.plot.all</code>, <code>...</code> contains any of the arguments of  <code>e0.joint.plot</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>References</h3>

<p>Lalic, N. (2011). Master's thesis at the Department of Statistics, University of Washington.
</p>
<p>A. E. Raftery,  N. Lalic, P. Gerland (2014). Joint Probabilistic Projection of Female and Male Life Expectancy. Demographic Research, 30:795-822.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.gap.plot">e0.gap.plot</a></code>, <code><a href="#topic+e0.trajectories.plot">e0.trajectories.plot</a></code>, <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example for e0.jmale.predict
</code></pre>

<hr>
<h2 id='e0.map'>
World Map of the Life Expectancy 
</h2><span id='topic+e0.map'></span><span id='topic+e0.map.all'></span><span id='topic+get.e0.map.parameters'></span><span id='topic+e0.map.gvis'></span><span id='topic+e0.ggmap'></span>

<h3>Description</h3>

<p>Generates a world map of the life expectancy for given quantile and projection or estimation period, using different techniques: <code>e0.map</code> and <code>e0.map.all</code> use <span class="pkg">rworldmap</span>, <code>e0.ggmap</code> uses <span class="pkg">ggplot2</span>, and <code>e0.map.gvis</code> creates an interactive map via <span class="pkg">GoogleVis</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.map(pred, ...)
	
e0.ggmap(pred, ...)

e0.map.all(pred, output.dir, output.type = "png", 
    e0.range = NULL, nr.cats = 50, same.scale = TRUE, 
    quantile = 0.5, file.prefix = "e0wrldmap_", ...)
			
get.e0.map.parameters(pred, e0.range = NULL, 
    nr.cats = 50, same.scale = TRUE, quantile = 0.5, ...)
    
e0.map.gvis(pred, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.map_+3A_pred">pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="e0.map_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting maps are stored.</p>
</td></tr>
<tr><td><code id="e0.map_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="e0.map_+3A_e0.range">e0.range</code></td>
<td>
<p>Range of the life expectancy to be displayed. It is of the form <code>c(</code><var>e0.min</var>, <var>e0.max</var><code>)</code>.
By default, the whole range is considered. Note that countries with values outside of the given range will appear white.</p>
</td></tr>
<tr><td><code id="e0.map_+3A_nr.cats">nr.cats</code></td>
<td>
<p>Number of color categories.</p>
</td></tr>
<tr><td><code id="e0.map_+3A_same.scale">same.scale</code></td>
<td>
<p>Logical controlling if maps for all years of this prediction object should be on the same color scale.</p>
</td></tr>
<tr><td><code id="e0.map_+3A_quantile">quantile</code></td>
<td>
<p>Quantile for which the map should be generated. It must be equal to one of the values in <code>dimnames(pred$quantiles[[2]])</code>, i.e. 0, 0.025, 0.05, 0.1, 0.2, 0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.75, 0.8, 0.9, 0.95, 0.975, 1. Value 0.5 corresponds to the median.</p>
</td></tr>
<tr><td><code id="e0.map_+3A_file.prefix">file.prefix</code></td>
<td>
<p>Prefix for file names.</p>
</td></tr>
<tr><td><code id="e0.map_+3A_...">...</code></td>
<td>
<p>In <code>e0.map</code>, ... are all arguments that can be passed to <code><a href="bayesTFR.html#topic+tfr.map">tfr.map</a></code>, such as <code>quantile</code>, <code>year</code>, <code>projection.index</code>, <code>par.name</code>, <code>adjusted</code>, <code>device</code>, <code>main</code>, <code>device.args</code>, and <code>data.args</code>. In <code>e0.map.gvis</code>, ... are all arguments that can be passed to <code><a href="bayesTFR.html#topic+tfr.map.gvis">tfr.map.gvis</a></code>. In <code>e0.ggmap</code>, ... are arguments that can be passed to <code><a href="bayesTFR.html#topic+tfr.ggmap">tfr.ggmap</a></code>. In addition, functions that use the <span class="pkg">rworldmap</span> package accept
arguments passed to the <code>rworldmap::mapCountryData</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>e0.map</code> creates a single map for the given time period and quantile. <code>e0.map.all</code> generates a sequence of maps, namely one for each projection period. If the package <span class="pkg">fields</span> is installed, a color bar legend at the botom of the map is created.
</p>
<p>Function <code>get.e0.map.parameters</code> can be used in combination with <code>e0.map</code>. (Note that <code>get.e0.map.parameters</code> is called from inside of <code>e0.map.all</code>.) It sets breakpoints for the color scheme using quantiles of a fitted gamma distribution.
</p>
<p>Function <code>e0.ggmap</code> is similar to <code>e0.map</code>, but used the <span class="pkg">ggplot2</span> package in combination with the <code>geom_sf</code> function.
</p>
<p>Function <code>e0.map.gvis</code> creates an interactive map using the <span class="pkg">googleVis</span> package and opens it in an internet browser. It also generates a table of the mapped values that can be sorted by columns interactively in the browser. 
</p>
<p>By default, both <code>e0.map</code>, <code>e0.ggmap</code> and <code>e0.map.gvis</code> produce maps of life expectancy. Alternatively, the functions can be used to plot country-specific MCMC parameters into a world map. They are given by the argument <code>par.name</code>. One can pass any value from <code><a href="#topic+e0.parameter.names.cs.extended">e0.parameter.names.cs.extended</a>()</code>.
</p>


<h3>Value</h3>

<p><code>get.e0.map.parameters</code> returns a list with elements:
</p>
<table>
<tr><td><code>pred</code></td>
<td>
<p>The object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> used in the function.</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>Value of the argument <code>quantile</code>.</p>
</td></tr>
<tr><td><code>catMethod</code></td>
<td>
<p>If the argument <code>same.scale</code> is <code>TRUE</code>, this element contains breakpoints for categorization. It is generated from a fitted gamma distribution. Otherwise, it is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>numCats</code></td>
<td>
<p>Number of categories.</p>
</td></tr>
<tr><td><code>coulourPalette</code></td>
<td>
<p>Subset of the rainbow palette, starting from dark blue and ending at red.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Additional arguments passed to the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+tfr.map">tfr.map</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
pred &lt;- get.e0.prediction(sim.dir = sim.dir)

# Using ggplot2
e0.ggmap(pred, same.scale = TRUE)
e0.ggmap(pred, year = 2100, same.scale = TRUE)

# Using rworldmap
# Uses heat colors and seven categories by default
e0.map(pred)
# Uses more colors with more suitable categorization
params &lt;- get.e0.map.parameters(pred)
do.call('e0.map', params)
# Another projection year on the same scale
do.call('e0.map', c(list(year = 2043), params))

# Interactive map (requires Flash)
e0.map.gvis(pred, year = 2043)
## End(Not run)
</code></pre>

<hr>
<h2 id='e0.median.set'>
Editing the Projection Medians
</h2><span id='topic+e0.median.set'></span><span id='topic+e0.median.shift'></span><span id='topic+e0.median.reset'></span><span id='topic+e0.median.adjust.jmale'></span><span id='topic+e0.shift.prediction.to.wpp'></span>

<h3>Description</h3>

<p>These functions are to be used by expert analysts. They allow to change the projection medians either to specific values, including the WPP values, or shift the medians by a given constant or a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.median.set(sim.dir, country, values, years = NULL, joint.male = FALSE)

e0.median.shift(sim.dir, country, reset = FALSE, shift = 0, 
    from = NULL, to = NULL, joint.male = FALSE)
    
e0.median.adjust.jmale(sim.dir, countries, factors = c(1.2, 1.1))

e0.median.reset(sim.dir, countries = NULL, joint.male = FALSE)

e0.shift.prediction.to.wpp(sim.dir, joint.male = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.median.set_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory containing the prediction object.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_countries">countries</code></td>
<td>
<p>Vector of country names or codes. In the <code>e0.median.reset</code> function, if this argument is <code>NULL</code> (default), the reset is done for all countries.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_values">values</code></td>
<td>
<p>Array of the new median values.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_years">years</code></td>
<td>
<p>Numeric vector giving years which <code>values</code> correspond to. Ideally it should be of the same length as <code>values</code>. If it is <code>NULL</code>,
<code>values</code> are set starting from the first prediction period. If <code>values</code> correspond to consecutive years, only the first year might be given here. A year <code class="reqn">t</code> represents a prediction period <code class="reqn">[t_i, t_{i+1}]</code> if <code class="reqn">t_i &lt; t \leq t_{i+1}</code>.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_joint.male">joint.male</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function is applied to a male prediction that was generated using the joint female-male model implemented in the function <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_reset">reset</code></td>
<td>
<p>Logical. If <code>TRUE</code> medians in a range of <code>from</code> and <code>to</code> are reset to their original values.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_shift">shift</code></td>
<td>
<p>Constant by which the medians should be offset. It is not used if <code>reset</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_from">from</code></td>
<td>
<p>Year from which the offset/reset should start. By default, it starts at the first prediction period.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_to">to</code></td>
<td>
<p>Year until which the offset/reset should be done. By default, it is set to the last prediction period.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_factors">factors</code></td>
<td>
<p>It should be a vector where each element corresponds to one time period. The adjustment of male medians is done as <code>e0m(t) = e0f(t) - gap(t)*factor(t)</code>.</p>
</td></tr>
<tr><td><code id="e0.median.set_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying adjustment function. It can be <code>verbose</code> to show/hide the progress of the adjustment and <code>wpp.year</code> to adjust it to if it differs from the wpp year of the simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>e0.median.set</code> can be used to set the medians of the given country to specific values. Function <code>e0.median.shift</code> can be used to offset the medians by a specific constant, or to reset the medians to their original BHM values. Function <code>e0.median.adjust.jmale</code> adjusts male medians using factors that can expand or shrink the female-male gap. 
</p>
<p>Function<code>e0.shift.prediction.to.wpp</code> shifts the projected medians so that they correspond to the values found in the <code>e0Fproj</code> (<code>joint.male = FALSE</code>) or <code>e0Mproj</code> (<code>joint.male = TRUE</code>) datasets of the <span class="pkg">wpp</span> package that either corresponds to the package used for the simulation itself or is given by the <code>wpp.year</code> argument. If using <span class="pkg">wpp2022</span>, the dataset name is automatically adjusted depending if it is an annual or a 5-year simulation.
</p>
<p>Function <code>e0.median.reset</code> resets medians of the given countries to the original values. By default it deletes adjustments for all countries.
</p>
<p>In all cases, if a median is modified, the corresponding offset is stored in the prediction object (element <code>median.shift</code>). All functions write the updated prediction object back to disk. All functions in the package that use trajectories and trajectory statistics use the <code>median.shift</code> values to offset the results correspondingly, i.e. trajectories are shifted the same way as the medians.
</p>


<h3>Value</h3>

<p>All functions return an updated object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova</p>

<hr>
<h2 id='e0.parameter.names'>
Accessing Parameter Names
</h2><span id='topic+e0.parameter.names'></span><span id='topic+e0.parameter.names.cs'></span><span id='topic+e0.parameter.names.extended'></span><span id='topic+e0.parameter.names.cs.extended'></span>

<h3>Description</h3>

<p>Functions for accessing names of the MCMC parameters, either country-independent or country-specific.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.parameter.names(...)
e0.parameter.names.cs(...)
e0.parameter.names.extended(...)
e0.parameter.names.cs.extended(country.code = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.parameter.names_+3A_country.code">country.code</code></td>
<td>
<p>Country code. If it is given, the country-specific parameter names contain the suffix &lsquo;_c<code class="reqn">x</code>&rsquo; where <code class="reqn">x</code> is the <code>country.code</code>.</p>
</td></tr>
<tr><td><code id="e0.parameter.names_+3A_...">...</code></td>
<td>
<p>List of options containing elements <code>world.parameters</code> and <code>country.parameters</code>. If not given, they are obtained from the global environment, using <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>e0.parameter.names</code> returns names of the world parameters.<br />
<code>e0.parameter.names.cs</code> returns names of the country-specific parameters.<br />
<code>e0.parameter.names.extended</code> returns names of all world parameters in their extended format. I.e. parameters &lsquo;Triangle&rsquo; and &lsquo;lambda&rsquo; have the suffix &lsquo;_1&rsquo;, &lsquo;_2&rsquo;, &lsquo;_3&rsquo;, and &lsquo;_4&rsquo;. <br />
<code>e0.parameter.names.cs.extended</code> returns names of all country-specific parameters in their extended format. I.e. parameters &lsquo;Triangle.c&rsquo; and &lsquo;lambda.c&rsquo; are in their extended format with the suffix &lsquo;_1&rsquo;, &lsquo;_2&rsquo; and &lsquo;_3&rsquo;.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e0.parameter.names()
e0.parameter.names.extended()
e0.parameter.names.cs()
e0.parameter.names.cs.extended()
</code></pre>

<hr>
<h2 id='e0.pardensity.plot'>
Plotting MCMC Parameter Density
</h2><span id='topic+e0.pardensity.plot'></span><span id='topic+e0.pardensity.cs.plot'></span>

<h3>Description</h3>

<p>Functions for plotting density of the posterior distribution of the MCMC parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.pardensity.plot(mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesLife.output"), 
    chain.ids = NULL, par.names = NULL, 
    burnin = NULL, dev.ncol = 5, low.memory = TRUE, ...)
    
e0.pardensity.cs.plot(country, mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesLife.output"), 
    chain.ids = NULL, par.names = NULL, 
    burnin = NULL, dev.ncol = 3, low.memory = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.pardensity.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country.</p>
</td></tr>
<tr><td><code id="e0.pardensity.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code> objects, or an object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> or of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>. If it is <code>NULL</code>, the parameter values are loaded from <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="e0.pardensity.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. It is only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="e0.pardensity.plot_+3A_chain.ids">chain.ids</code></td>
<td>
<p>List of MCMC identifiers to be plotted. If it is <code>NULL</code>, all chains found in <code>mcmc.list</code> or <code>sim.dir</code> are plotted.</p>
</td></tr>
<tr><td><code id="e0.pardensity.plot_+3A_par.names">par.names</code></td>
<td>
<p>Names of parameters for which density should be plotted. By default all country-independent parameters are plotted if used within <code>e0.pardensity.plot</code>, or all country-specific parameters are plotted if used within <code>e0.pardensity.cs.plot</code>.</p>
</td></tr>
<tr><td><code id="e0.pardensity.plot_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of each chain.</p>
</td></tr>
<tr><td><code id="e0.pardensity.plot_+3A_dev.ncol">dev.ncol</code></td>
<td>
<p>Number of columns for the graphics device. If the number of parameters is smaller than <code>dev.ncol</code>, the number of columns is automatically decreased.</p>
</td></tr>
<tr><td><code id="e0.pardensity.plot_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the processing should run in a memory-efficient mode.</p>
</td></tr>
<tr><td><code id="e0.pardensity.plot_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>density</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions plot the density of the posterior distribution either for country-independent parameters (<code>e0.pardensity.plot</code>) or for country-specific parameters (<code>e0.pardensity.cs.plot</code>), one graph per parameter.  One can restrict it to specific chains by setting the <code>chain.ids</code> argument and to specific parameters by setting the <code>par.names</code> argument. 
</p>
<p>If <code>mcmc.list</code> is an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>, thinned traces are used instead of the full chains. In such a case, <code>burnin</code> and <code>chain.ids</code> cannot be modified - their value is set to the one used when the thinned traces were created, namely when running <code><a href="#topic+e0.predict">e0.predict</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.partraces.plot">e0.partraces.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
e0.pardensity.plot(sim.dir = sim.dir, burnin = 10)
e0.pardensity.cs.plot(country = "Ireland", sim.dir = sim.dir, burnin = 10)
</code></pre>

<hr>
<h2 id='e0.partraces.plot'>
Plotting MCMC Parameter Traces
</h2><span id='topic+e0.partraces.plot'></span><span id='topic+e0.partraces.cs.plot'></span>

<h3>Description</h3>

<p>Functions for plotting the MCMC parameter traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.partraces.plot(mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesLife.output"), 
    chain.ids = NULL, par.names = NULL, 
    nr.points = NULL, dev.ncol = 5, low.memory = TRUE, ...)
    
e0.partraces.cs.plot(country, mcmc.list = NULL, 
    sim.dir = file.path(getwd(), "bayesLife.output"), 
    chain.ids = NULL, par.names = NULL, 
    nr.points = NULL, dev.ncol = 3, low.memory = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.partraces.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="e0.partraces.plot_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code>bayesLife.mcmc</code> objects, or an object of class <code>bayesLife.mcmc.set</code> or of class <code>bayesLife.prediction</code>. If it is <code>NULL</code>, the traces are loaded from <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="e0.partraces.plot_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. It is only used if <code>mcmc.list</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="e0.partraces.plot_+3A_chain.ids">chain.ids</code></td>
<td>
<p>List of MCMC identifiers to be plotted. If it is <code>NULL</code>, all chains found in <code>mcmc.list</code> or <code>sim.dir</code> are plotted.</p>
</td></tr>
<tr><td><code id="e0.partraces.plot_+3A_par.names">par.names</code></td>
<td>
<p>Names of parameters for which traces should be plotted. By default all country-independent parameters are plotted if used within <code>e0.partraces.plot</code>, or country-specific parameters are plotted if used within <code>e0.partraces.cs.plot</code>.</p>
</td></tr>
<tr><td><code id="e0.partraces.plot_+3A_nr.points">nr.points</code></td>
<td>
<p>Number of points to be plotted. If <code>NULL</code>, all (stored) points are plotted, otherwise the traces are thinned evenly.</p>
</td></tr>
<tr><td><code id="e0.partraces.plot_+3A_dev.ncol">dev.ncol</code></td>
<td>
<p>Number of column for the graphics device. If the number of parameters is smaller than <code>dev.ncol</code>, the number of columns is automatically decreased.</p>
</td></tr>
<tr><td><code id="e0.partraces.plot_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the processing should run in a low-memory mode. If it is <code>FALSE</code>, traces of all available parameters are loaded into memory. Otherwise, parameters are loaded as they are needed and are not kept in the memory.</p>
</td></tr>
<tr><td><code id="e0.partraces.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical arguments. It can also contain the arguments <code>burnin</code> or <code>thin</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions plot MCMC traces either for country-independent parameters (<code>e0.partraces.plot</code>) or for country-specific parameters (<code>e0.partraces.cs.plot</code>), one graph per parameter.  One can restrict it to specific chains by setting the <code>chain.ids</code> argument, and to specific parameters by setting the <code>par.names</code> argument.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.coda.list.mcmc">e0.coda.list.mcmc</a></code> and <code><a href="#topic+get.e0.parameter.traces">get.e0.parameter.traces</a></code> for retrieving the raw values of traces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
e0.partraces.plot(sim.dir = sim.dir)
e0.partraces.cs.plot(country = "IRL", sim.dir = sim.dir)
</code></pre>

<hr>
<h2 id='e0.predict'>
Generating Posterior Trajectories of the Life Expectancy
</h2><span id='topic+e0.predict'></span><span id='topic+bayesLife.prediction'></span>

<h3>Description</h3>

<p>Using the posterior parameter samples simulated by <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code> the function  generates posterior trajectories for the life expectancy for all countries of the world.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.predict(mcmc.set = NULL, end.year = 2100, 
    sim.dir = file.path(getwd(), "bayesLife.output"), replace.output = FALSE, 
    predict.jmale = TRUE, nr.traj = NULL, thin = NULL, burnin = 10000, 
    use.diagnostics = FALSE, save.as.ascii = 0, start.year = NULL,  
    output.dir = NULL, low.memory = TRUE, ignore.last.observed = FALSE,
    seed = NULL, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.predict_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>. If it is <code>NULL</code>, the object is loaded from the directory given by <code>sim.dir</code>.
</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_end.year">end.year</code></td>
<td>
<p>End year of the prediction.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results. It should equal to the <code>output.dir</code> argument in <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_replace.output">replace.output</code></td>
<td>
<p>Logical. If <code>TRUE</code>, existing predictions in <code>output.dir</code> will be replaced by results of this run.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_predict.jmale">predict.jmale</code></td>
<td>
<p>Logical controlling if a joint female-male prediciton should be performed. This is done only if the underlying mcmcs in <code>sim.dir</code> correspond to a female simulation. In such a case the <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code> is invoked. Arguments to this function can be passed in ....</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be generated. If <code>NULL</code>, the argument <code>thin</code> is taken to determine the number of trajectories. If both are <code>NULL</code>, the number of trajectories corresponds to the minimum of the size of the parameter sample and 2000.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_thin">thin</code></td>
<td>
<p>Thinning interval used for determining the number of trajectories. Only relevant, if <code>nr.traj</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of the parameter traces.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_use.diagnostics">use.diagnostics</code></td>
<td>
<p>Logical determining if an existing convergence diagnostics should be used for choosing the values of <code>thin</code> and <code>burnin</code>. In such a case, arguments <code>nr.traj</code>, <code>thin</code> and <code>burnin</code> are ignored. The &lsquo;best&rsquo; values are chosen from results of running the <code><a href="#topic+e0.diagnose">e0.diagnose</a></code> function. Only diagnostics can be used that suggest a convergence of the underlying MCMCs. If there are more than one such objects, the one is chosen whose recommendation for the number of trajectories is larger and closest to 2000.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_save.as.ascii">save.as.ascii</code></td>
<td>
<p>Either a number determining how many trajectories should be converted into an ASCII file, or &ldquo;all&rdquo; in which case all trajectories are converted. It should be set to 0, if no conversion is desired (default).</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_start.year">start.year</code></td>
<td>
<p>This argument should be only used if the start year of the prediction is before or at the present year of the MCMC run (see Details below). By default the prediction starts in the next time period after the present year (passed to <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>).</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which the resulting prediction object and the trajectories are stored. If it is <code>NULL</code>, it is set to either <code>sim.dir</code>, or to <code>output.dir</code> of <code>mcmc.set$meta</code> if <code>mcmc.set</code> is given.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_low.memory">low.memory</code></td>
<td>
<p>Logical indicating if the prediction should run in a low-memory mode. If it is <code>FALSE</code>, the whole traces of all parameters, including the burnin, are loaded into memory. Otherwise, burnins are discarded and parameters are loaded as they are needed and are not kept in the memory.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_ignore.last.observed">ignore.last.observed</code></td>
<td>
<p>Logical. By default, the prediction (or imputation) for each country starts one time period after the last observed data point for that country defined by the &ldquo;last.observed&rdquo; column in the data. If this argument is set to <code>TRUE</code>, the prediction ignores that &ldquo;last.observed&rdquo; value and starts at the last data point found in the data. This allows to exclude some time periods from the estimation, but include them in the prediction.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set. It can be used to generate reproducible projections.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="e0.predict_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trajectories are generated using the double logistic function (Chunn et al. 2013). Parameter samples  simulated via <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code> are used from all chains, from which the given burnin was discarded. They are evenly thinned to match <code>nr.traj</code> or using the <code>thin</code> argument. Such thinned parameter traces, collapsed into one chain, if they do not already exist, are stored on disk into the sub-directory &lsquo;<span class="file">thinned_mcmc_<em>t</em>_<em>b</em></span>&rsquo; where <em>t</em> is the value  of <code>thin</code> and <em>b</em> the value of <code>burnin</code> (see <code><a href="#topic+create.thinned.e0.mcmc">create.thinned.e0.mcmc</a></code>). 
</p>
<p>The projection is run for all missing values before the present year, if any. Medians over the trajectories are used as  imputed values and the trajectories are discarded. The process then continues by projecting the future values where all generated trajectories are kept.
</p>
<p>A special case is when the argument <code>start.year</code> is given that is smaller or equal the present year. In such a case, imputed missing values before present year are treated as ordinary predictions (trajectories are kept). All historical data between start year and present year are used as projections.
</p>
<p>The resulting prediction object is saved into &lsquo;<span class="file">{output.dir}/predictions</span>&rsquo;. Trajectories for all countries are saved into the same directory in a binary format, one file per country. At the end of the projection, if <code>save.as.ascii</code> is larger than 0, the function converts the given number of trajectories into a CSV file of a UN-specific format. They are selected by equal spacing (see function <code><a href="#topic+convert.e0.trajectories">convert.e0.trajectories</a></code> for more details on the conversion). In addition, two summary files are created: one in a user-friendly format, the other using a UN-specific coding of the variants and time (see <code><a href="#topic+write.e0.projection.summary">write.e0.projection.summary</a></code> for more details).
</p>


<h3>Value</h3>

<p>Object of class <code>bayesLife.prediction</code> which is a list containing components:
</p>
<table>
<tr><td><code>quantiles</code></td>
<td>
<p>A <code class="reqn">n \times q \times p</code> array of quantile values computed on the trajectories. <code class="reqn">n</code> is the number of countries,
<code class="reqn">q</code> is the number of quantiles and <code class="reqn">p</code> is the number of projections. Which quantiles are to be computed is determined by the global option <code><a href="#topic+e0pred.options">e0pred.options</a>("quantiles")</code>.</p>
</td></tr>
<tr><td><code>traj.mean.sd</code></td>
<td>
<p>A <code class="reqn">n \times 2 \times p</code> array holding the mean of all trajectories in the first column and the standard deviation in the second column.
<code class="reqn">n</code> and <code class="reqn">p</code> are the number of countries and number of projections, respectively.</p>
</td></tr>
<tr><td><code>nr.traj</code></td>
<td>
<p>Number of trajectories.</p>
</td></tr>
<tr><td><code>e0.matrix.reconstructed</code></td>
<td>
<p>Matrix containing imputed e0 values on spots where the original e0 matrix has missing values, i.e. between the last observed data point and the present year. </p>
</td></tr>
<tr><td><code>output.directory</code></td>
<td>
<p>Directory where trajectories corresponding to this prediction are stored.</p>
</td></tr>
<tr><td><code>nr.projections</code></td>
<td>
<p>Number of projections.</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>Burnin used for this prediction.</p>
</td></tr>
<tr><td><code>end.year</code></td>
<td>
<p>The end year of this prediction.</p>
</td></tr>
<tr><td><code>start.year</code></td>
<td>
<p>The <code>start.year</code> input argument.</p>
</td></tr>
<tr><td><code>mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> used for this prediction, i.e. the burned, thinned, and collapsed MCMC chain.</p>
</td></tr>
<tr><td><code>joint.male</code></td>
<td>
<p>If <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code> was invoked, this is an object of class <code>bayesLife.prediction</code> containing male projections. In addition to the components above, it contains elements <code>fit</code> (estimation results from <code><a href="#topic+e0.jmale.estimate">e0.jmale.estimate</a></code>) and <code>meta.changes</code> (components of <code><a href="#topic+bayesLife.mcmc.meta">bayesLife.mcmc.meta</a></code> that differ from the female meta component).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, using code from Jennifer Chunn
</p>


<h3>References</h3>

<p>J. L. Chunn, A. E. Raftery, P. Gerland, H. Sevcikova (2013): Bayesian Probabilistic Projections of Life Expectancy for All Countries. Demography 50(3):777-801. &lt;doi:10.1007/s13524-012-0193-x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>, <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>, <code><a href="#topic+create.thinned.e0.mcmc">create.thinned.e0.mcmc</a></code>, <code><a href="#topic+convert.e0.trajectories">convert.e0.trajectories</a></code>, 
<code><a href="#topic+get.e0.prediction">get.e0.prediction</a></code>, <code><a href="#topic+summary.bayesLife.prediction">summary.bayesLife.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m &lt;- run.e0.mcmc(nr.chains = 1, iter = 50, thin = 1, verbose = TRUE)
pred &lt;- e0.predict(m, burnin = 25, verbose = TRUE)
summary(pred, country = "Portugal")

# names and codes of countries included
head(get.countries.table(pred, iso = TRUE))
## End(Not run)
</code></pre>

<hr>
<h2 id='e0.predict.extra'>
Generating Posterior Trajectories of the Life Expectancy for Specific Countries or Regions
</h2><span id='topic+e0.predict.extra'></span>

<h3>Description</h3>

<p>Using the posterior parameter samples the function generates posterior trajectories of the life expectancy for given countries or regions. It is intended to be used after running <code><a href="#topic+run.e0.mcmc.extra">run.e0.mcmc.extra</a></code>, but it can be also used for purposes of testing specific settings on one or a few countries. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.predict.extra(sim.dir = file.path(getwd(), 'bayesLife.output'), 
    prediction.dir = sim.dir, countries = NULL, 
    save.as.ascii = 1000, verbose = TRUE, ...)
	</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.predict.extra_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory with the MCMC simulation results.</p>
</td></tr>
<tr><td><code id="e0.predict.extra_+3A_prediction.dir">prediction.dir</code></td>
<td>
<p>Directory where the prediction object and the trajectories are stored.</p>
</td></tr>
<tr><td><code id="e0.predict.extra_+3A_countries">countries</code></td>
<td>
<p>Vector of country codes for which the prediction should be made. If it is <code>NULL</code>, the prediction is run for all countries that are included in the MCMC object but for which no prediction was generated.</p>
</td></tr>
<tr><td><code id="e0.predict.extra_+3A_save.as.ascii">save.as.ascii</code></td>
<td>
<p>Either a number determining how many trajectories should be converted into an ascii file, or &ldquo;all&rdquo; in which case all trajectories are converted. It should be set to 0, if no converions is desired. Note that the convertion is done on all countries.</p>
</td></tr>
<tr><td><code id="e0.predict.extra_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="e0.predict.extra_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to a joint female-male prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to use this function, a prediction object must exist, i.e. the function <code><a href="#topic+e0.predict">e0.predict</a></code> must have been processed prior to using this function.
</p>
<p>Trajectories for given countries or regions are generated and stored in binary format along with other countries (in <code>prediction.dir</code>). The existing prediction object is updated and stored in the same directory. If <code>save.as.ascii</code> is larger than zero, trajectories of ALL countries are converted to an ascii format.
</p>
<p>If the prediction object contains joint male projections, these are also created for the given countries.
</p>


<h3>Value</h3>

<p>Updated object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.predict">e0.predict</a></code>, <code><a href="#topic+run.e0.mcmc.extra">run.e0.mcmc.extra</a></code>
</p>

<hr>
<h2 id='e0.predict.subnat'>
Generating Posterior Trajectories of Subnational Life Expectancy at Birth
</h2><span id='topic+e0.predict.subnat'></span><span id='topic+e0.jmale.predict.subnat'></span><span id='topic+subnat.gap.estimates'></span>

<h3>Description</h3>

<p>Generates posterior trajectories of the life expectancy at birth (e0) for subregions of given countries, for female and male. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.predict.subnat(countries, my.e0.file, 
    sim.dir = file.path(getwd(), "bayesLife.output"), 
    method = c("ar1", "shift", "scale"),
    predict.jmale = FALSE, my.e0M.file = NULL,
    end.year = 2100, start.year = NULL, output.dir = NULL, 
    annual = NULL, nr.traj = NULL, seed = NULL, 
    ar.pars = NULL, save.as.ascii = 0, verbose = TRUE, 
    jmale.estimates = NULL, ...)
                
e0.jmale.predict.subnat(e0.pred, estimates = NULL, 	
    gap.lim = c(0,18), max.e0.eq1.pred = 86, my.e0.file = NULL, 
    save.as.ascii = 0, verbose = TRUE)
    
subnat.gap.estimates(annual = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.predict.subnat_+3A_countries">countries</code></td>
<td>
<p>Vector of numerical country codes or country names.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_my.e0.file">my.e0.file</code></td>
<td>
<p>Tab-separated ASCII file containing the subnational e0 data. In <code>e0.predict.subnat</code>, if female and male e0 are projected jointly (i.e. <code>predict.jmale</code> is <code>TRUE</code>), this file should contain the female e0. In <code>e0.jmale.predict.subnat</code>, this file should contain the male e0. See Details for more information on its format.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Simulation directory with the national projections generated using <code><a href="#topic+e0.predict">e0.predict</a></code>.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_method">method</code></td>
<td>
<p>Method to use for the projections, see the reference paper.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_predict.jmale">predict.jmale</code></td>
<td>
<p>Logical determining if male projections should be generated as well. If <code>TRUE</code>, the argument <code>my.e0M.file</code> must be given.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_my.e0m.file">my.e0M.file</code></td>
<td>
<p>Tab-separated ASCII file containing the subnational male e0 data.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_end.year">end.year</code></td>
<td>
<p>End year of the projections.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_start.year">start.year</code></td>
<td>
<p>Start year of the projections. By default, projections start at the same time point as the national projections.</p>
</td></tr> 
<tr><td><code id="e0.predict.subnat_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which the resulting prediction objects and the trajectories are stored. See below for details.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_annual">annual</code></td>
<td>
<p>Logical indicating if the subnational projection should be on an annual scale or a 5-year scale. By default, 
the scale is matched to the national simulation given by <code>sim.dir</code>. If given, the scale must match to the scale of the subnational data provided in <code>my.e0.file</code>. 
If the subnational and national scales are not the same, 
the national trajectories are either interpolated (if <code>annual = TRUE</code> and the national simulation is not annual) or averaged to 5-year values 
(if <code>annual = FALSE</code> and the national simulation is annual).</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be generated. If <code>NULL</code>, the number of trajectories in the national projections is used.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set. It can be used to generate reproducible projections.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_ar.pars">ar.pars</code></td>
<td>
<p>Named vector containing the parameter estimates for the AR(1) method (i.e. if <code>method = "ar1"</code>, default). If given, it must have elements called <code>rho</code>, <code>U</code>, <code>a</code> and <code>b</code>. See the reference paper for details on the estimation. By default for a 5-year simulation, <code>c(rho = 0.95, U = 82.5, a = 0.0482, b = -0.0154)</code> is used. 
For an annual simulation these default parameters are scaled to <code>c(rho = 0.9898, U = 82.5, a = 0.01, b = -0.0032)</code>, see details below.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_save.as.ascii">save.as.ascii</code></td>
<td>
<p>Either a number determining how many trajectories should be converted into an ASCII file, or &ldquo;all&rdquo; in which case all trajectories are converted. By default no conversion is performed.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_jmale.estimates">jmale.estimates</code>, <code id="e0.predict.subnat_+3A_estimates">estimates</code></td>
<td>
<p>List with estimates for the female-male gap model. The default values are retrieved using the function <code>subnat.gap.estimates()</code>.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>e0.jmale.predict.subnat</code>, which are <code>gap.lim</code> and <code>max.e0.eq1.pred</code>.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_e0.pred">e0.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>. It should be one element of the list returned by <code>e0.predict.subnat</code> corresponding to one country.</p>
</td></tr>
<tr><td><code id="e0.predict.subnat_+3A_gap.lim">gap.lim</code>, <code id="e0.predict.subnat_+3A_max.e0.eq1.pred">max.e0.eq1.pred</code></td>
<td>
<p>The same meaning as in <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>e0.predict.subnat</code> function implements the methodology described in Sevcikova and Raftery (2021). Given a set of national bayesLife projections, it applies one of the methods (AR(1), Shift or Scale) to each national trajectory and each subregion of given countries which yields subnational e0 projections. 
</p>
<p>The file on subnational data passed into <code>my.e0.file</code> and <code>my.e0M.file</code> has to have a column &ldquo;country_code&rdquo; with numerical values corresponding to countries given in the argument <code>countries</code>, and column &ldquo;reg_code&rdquo; giving the numerical identifier of each subregion. Column &ldquo;name&rdquo; should be used for subregion name, and column &ldquo;country_name&rdquo; for country name. An optional column &ldquo;include_code&rdquo; can be used to eliminate entries from processing. Entries with values of 1 or 2 will be included, all others will be ignored. Column &ldquo;last.observed&rdquo; can be used to define which time period contains the last observed data point (given as integer, e.g. year in the middle of the time period). Remaining columns define the time periods, e.g. &ldquo;2000-2005&rdquo;, &ldquo;2005-2010&rdquo; for a 5-year simulation, or &ldquo;2020&rdquo;, &ldquo;2021&rdquo; for an annual simulation. The package contains an example of such dataset, see Example below.
</p>
<p>The default AR(1) parameters for the &ldquo;ar1&rdquo; method were designed for a 5-year simulation, see Sevcikova &amp; Raftery (2021) for more detail. These are <code class="reqn">\rho = 0.95, U = 82.5, a = 0.0482, b = -0.0154</code>. If an annual AR(1) process is desired, we use the following conversion for the autoregressive parameter <code class="reqn">\rho</code> and the <code class="reqn">a</code> and <code class="reqn">b</code> parameters: 
<code class="reqn">\rho^* = \rho^{(1/5)}, a^* = a * \sqrt{((1 - \rho^{(2/5)})/(1 - \rho^2))}, b^* = b * \sqrt{((1 - \rho^{(2/5)})/(1 - \rho^2))}</code>. The <code class="reqn">U</code> parameter stays the same for both processes. Thus, the annual parameters are  <code>c(rho = 0.9898, U = 82.5, a = 0.01, b = -0.0032)</code>. Note that if the <code>ar.pars</code> argument is specified by the user, it is assumed that the parameters have been scaled appropriately and thus, no conversion takes place.
</p>
<p>Argument <code>output.dir</code> gives a location on disk where results of the function should be stored. If it is <code>NULL</code> (default),  results are stored in the same directory as the national projections. In both cases a subdirectory called &ldquo;subnat_<code>method</code>&rdquo; is created in which each country has its own subfolder with the country code in its name. Each such subfolder contains the same type of outputs as in the national case generated using <code><a href="#topic+e0.predict">e0.predict</a></code>, most importantly a directory &ldquo;predictions&rdquo; with trajectories for each region.
</p>
<p>If the argument <code>predict.jmale</code> is <code>TRUE</code>, the <code>e0.predict.subnat</code> invokes  the <code>e0.jmale.predict.subnat</code> function for each country. However, one can call the <code>e0.jmale.predict.subnat</code> function explicitly. It applies the female-male gap model to regions of one country. See <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code> for more detail on the model. The default  covariates of the model are not estimated on the fly. They were estimated externally using subnational data for about 30 countries and can be viewed using <code>subnat.gap.estimates()</code>, either for estimates derived from 5-year data (default) or annual data (<code>annual = TRUE</code>).
</p>


<h3>Value</h3>

<p>Function <code>e0.predict.subnat</code> returns a list of objects of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>. The name of each element includes its country code. Not all elements of the class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> are available. For example, no <code>mcmc.set</code> is attached to these objects. Thus, not all functions that work with <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> can be applied to these results.
</p>
<p>Function <code>e0.jmale.predict.subnat</code> returns an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> which updates the input <code>e0.pred</code> object by adding a new component called <code>joint.male</code>. This component is also an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> and it contains results of the male projections. 
</p>


<h3>Note</h3>

<p>Even though the resulting object contains subnational results, the names  of its elements are the same as in the national case. This allows to apply the same functions on both objects (subnational and national). However, it means that sometimes the meaning of the elements or function arguments does not match the subnational context. For example, various functions expect the argument <code>country</code>. When a subnational object is passed to such a function, <code>country</code> means a subregion. 
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>References</h3>

<p>H. Sevcikova, A. E. Raftery (2021). Probabilistic Projection of Subnational Life Expectancy. Journal of Official Statistics, Vol. 37, no. 3, 591-610.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.rege0.prediction">get.rege0.prediction</a></code>, <code><a href="#topic+e0.predict">e0.predict</a></code>, <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># View the example data
my.sube0.file &lt;- file.path(find.package("bayesLife"), 'extdata', 'subnational_e0_template.txt')
sube0 &lt;- read.delim(my.sube0.file, check.names = FALSE)
head(sube0)

# Directory with national projections (contains 30 trajectories for each country)
nat.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")

# Subnational projections for Australia and Canada, 
# including the joint female-male gap model
subnat.dir &lt;- tempfile()
preds &lt;- e0.predict.subnat(c(36, 124), my.e0.file = my.sube0.file,
    sim.dir = nat.dir, output.dir = subnat.dir, start.year = 2018)
    
names(preds)
get.countries.table(preds[["36"]])
summary(preds[["36"]], "Queensland")
e0.trajectories.plot(preds[["36"]], "Queensland")

# plot subnational and national e0 in one plot
nat.pred &lt;- get.e0.prediction(nat.dir)
e0.trajectories.plot(preds[["36"]], 4, pi = 80)
e0.trajectories.plot(nat.pred, "Australia", add = TRUE, 
      col = rep("darkgreen", 5), nr.traj = 0, show.legend = FALSE)
legend("top", c("regional e0", "national e0"), col = c("red", "darkgreen"), 
  lty = 1, bty = 'n')

# Add male projection to Canada, 
# using (wrongly) female data only for demonstration
predCan &lt;- e0.jmale.predict.subnat(preds[["124"]], my.e0.file = my.sube0.file)

# retrieve male prediction object
predCanMale &lt;- get.rege0.prediction(subnat.dir, 124, joint.male = TRUE)
# the same works using
predCanMale &lt;- get.e0.jmale.prediction(predCan)

# Retrieve female and male trajectories
trajsF.Alberta &lt;- get.e0.trajectories(predCan, "Alberta")
trajsM.Alberta &lt;- get.e0.trajectories(predCanMale, "Alberta")
# summary of differences
summary(t(trajsF.Alberta - trajsM.Alberta))

# cleanup
unlink(subnat.dir)

# See more examples in ?get.rege0.prediction
</code></pre>

<hr>
<h2 id='e0.raftery.diag'>
Raftery Diagnostics for Parameters of the Life Expectancy
</h2><span id='topic+e0.raftery.diag'></span>

<h3>Description</h3>

<p>The function computes the Raftery diagnostics for each parameter in the same way as <code><a href="bayesTFR.html#topic+tfr.raftery.diag">tfr.raftery.diag</a></code> of the <span class="pkg">bayesTFR</span> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.raftery.diag(mcmc = NULL, sim.dir = file.path(getwd(), "bayesLife.output"), 
    burnin = 0, country = NULL, par.names = NULL, par.names.cs = NULL,
    country.sampling.prop = 1, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.raftery.diag_+3A_mcmc">mcmc</code></td>
<td>

<p>A <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code> or <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> object.
</p>
</td></tr>
<tr><td><code id="e0.raftery.diag_+3A_sim.dir">sim.dir</code></td>
<td>

<p>Directory with the MCMC simulation results. Only used if <code>mcmc</code> is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="e0.raftery.diag_+3A_burnin">burnin</code></td>
<td>

<p>Burnin.
</p>
</td></tr>
<tr><td><code id="e0.raftery.diag_+3A_country">country</code></td>
<td>
<p>Name or code of a country. If it is given, only country-specific parameters parameters of that country are considered.</p>
</td></tr>
<tr><td><code id="e0.raftery.diag_+3A_par.names">par.names</code></td>
<td>

<p>Names of country-independent parameters for which the Raftery diagnostics should be computed. By default all parameters are used.
</p>
</td></tr>
<tr><td><code id="e0.raftery.diag_+3A_par.names.cs">par.names.cs</code></td>
<td>

<p>Names of country-specific parameters for which the Raftery diagnostics should be computed. By default all parameters are used.
</p>
</td></tr>
<tr><td><code id="e0.raftery.diag_+3A_country.sampling.prop">country.sampling.prop</code></td>
<td>
<p>Proportion of countries that are included in the diagnostics. It should be between 0 and 1. If it is smaller than 1, the countries are randomly sampled. It is only relevant if <code>par.names.cs</code> is not <code>NULL</code>. </p>
</td></tr>
<tr><td><code id="e0.raftery.diag_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="e0.raftery.diag_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="#topic+e0.coda.list.mcmc">e0.coda.list.mcmc</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="bayesTFR.html#topic+tfr.raftery.diag">tfr.raftery.diag</a></code> for details. This function is called from <code><a href="#topic+e0.diagnose">e0.diagnose</a></code>. 
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Adrian Raftery
</p>


<h3>See Also</h3>

<p><code><a href="bayesTFR.html#topic+tfr.raftery.diag">tfr.raftery.diag</a></code>, <code><a href="coda.html#topic+raftery.diag">raftery.diag</a></code>, <code><a href="#topic+e0.diagnose">e0.diagnose</a></code>
</p>

<hr>
<h2 id='e0.trajectories.plot'>
Posterior Distribution of Trajectories of Life Expectancy
</h2><span id='topic+e0.trajectories.plot'></span><span id='topic+e0.trajectories.plot.all'></span><span id='topic+e0.trajectories.table'></span>

<h3>Description</h3>

<p>The functions plot/tabulate the posterior distribution of trajectories of the life expectancy for a given country, or for all countries, including their median and given probability intervals. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e0.trajectories.plot(e0.pred, country, pi = c(80, 95), both.sexes = FALSE,
    nr.traj = NULL, adjusted.only = TRUE, typical.trajectory = FALSE, 
    xlim = NULL, ylim = NULL, type = "b", 
    xlab = "Year", ylab = "Life expectancy at birth", main = NULL, 
    lwd = c(2, 2, 2, 2, 1), col = c('black', 'green', 'red', 'red', '#00000020'),
    col2 = c('gray39', 'greenyellow', 'hotpink', 'hotpink', '#00000020'),
    pch = c(1, 2), show.legend = TRUE, add = FALSE, ...)
    
e0.trajectories.plot.all(e0.pred, 
    output.dir = file.path(getwd(), 'e0trajectories'),
    output.type = "png", verbose = FALSE, ...)
	
e0.trajectories.table(e0.pred, country, pi = c(80, 95), 
    both.sexes = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0.trajectories.plot_+3A_e0.pred">e0.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_pi">pi</code></td>
<td>
<p>Probability interval. It can be a single number or an array. If <code>both.sexes</code> is <code>TRUE</code> the default is 95.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_both.sexes">both.sexes</code></td>
<td>
<p>Logical or the character &ldquo;A&rdquo;. If <code>TRUE</code> the distribution of both sexes is plotted into one graphics (or tabulated), provided the <code>e0.pred</code> is a female prediction and contains a joint male prediction as a result of running the function <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>. For &ldquo;A&rdquo; it plots/tabulates the distribution of the average life expectancy over both sexes.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_nr.traj">nr.traj</code></td>
<td>
<p>Number of trajectories to be plotted. If <code>NULL</code>, all trajectories are plotted, otherwise they are thinned evenly. If <code>both.sexes</code> is <code>TRUE</code> the default is zero.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_adjusted.only">adjusted.only</code></td>
<td>
<p>Logical. By default, if the projection median is adjusted using e.g. <code><a href="#topic+e0.median.set">e0.median.set</a></code>, the function plots the adjusted median. If <code>adjusted.only=FALSE</code> the original (non-adjusted) median is plotted as well.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_typical.trajectory">typical.trajectory</code></td>
<td>
<p>Logical. If <code>TRUE</code> one trajectory is shown  for which the median absolute deviation from the median e0 projection is the median among all the trajectories.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_xlim">xlim</code>, <code id="e0.trajectories.plot_+3A_ylim">ylim</code>, <code id="e0.trajectories.plot_+3A_type">type</code>, <code id="e0.trajectories.plot_+3A_xlab">xlab</code>, <code id="e0.trajectories.plot_+3A_ylab">ylab</code>, <code id="e0.trajectories.plot_+3A_main">main</code></td>
<td>
<p>Graphical parameters passed to the <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_lwd">lwd</code>, <code id="e0.trajectories.plot_+3A_col">col</code>, <code id="e0.trajectories.plot_+3A_col2">col2</code></td>
<td>
<p>Vector of five elements giving the line width and color for: 1. observed data, 2. imputed missing data, 3. median, 4. quantiles, 5. trajectories. <code>col2</code> is only used if <code>both.sexes</code> is <code>TRUE</code>. In such a case, <code>col2</code> is used for female lines and <code>col</code> is used for male lines, which in this case defaults to 
<code>c('black', 'green', 'darkgreen', 'darkgreen', 'gray')</code>.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_pch">pch</code></td>
<td>
<p>Vector of two elements specifying plotting symbols for the observed and imputed data, respectively. It is not used if <code>type</code> is not one of &ldquo;b&rdquo;, &ldquo;p&rdquo; or &ldquo;o&rdquo;.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical controlling whether the legend should be drawn.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_add">add</code></td>
<td>
<p>Logical controlling whether the trajectories should be plotted into a new graphic device (<code>FALSE</code>) or into an existing device (<code>TRUE</code>). One can use this argument to plot trajectories from multiple countries into one graphics.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters. In addition, for <code>e0.trajectories.plot.all</code>, <code>...</code> 
contains any of the arguments of  <code>e0.trajectories.plot</code>, and for <code>e0.trajectories.table</code>, <code>...</code> contains 
the <code>pi</code> and <code>country</code> arguments.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory into which resulting graphs are stored.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_output.type">output.type</code></td>
<td>
<p>Type of the resulting files. It can be &ldquo;png&rdquo;, &ldquo;pdf&rdquo;, &ldquo;jpeg&rdquo;, &ldquo;bmp&rdquo;, &ldquo;tiff&rdquo;, or &ldquo;postscript&rdquo;.</p>
</td></tr>
<tr><td><code id="e0.trajectories.plot_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>e0.trajectories.plot</code> plots posterior distribution of trajectories of life expectancy for a given country. <code>e0.trajectories.table</code> gives the same output in a tabular format. <br />
<code>e0.trajectories.plot.all</code> creates a set of such graphs (one per country) that are stored in <code>output.dir</code>. 
</p>
<p>The median and given probability intervals are computed using all available trajectories. Thus, <code>nr.traj</code> does not influence those values - it is used only to control the number of trajectories plotted.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
pred &lt;- get.e0.prediction(sim.dir)
e0.trajectories.table(pred, country = "Japan", pi = c(80, 95))
e0.trajectories.plot(pred, country = "Japan", pi = c(80, 95))

# plot multiple countries into one plot
e0.trajectories.plot(pred, "JP", col = rep("green", 5), nr.traj = 0,
         pi = c(80), show.legend = FALSE, main = "")
e0.trajectories.plot(pred, "USA", col = rep("blue", 5),  
        add = TRUE, nr.traj = 0, pi = c(80), show.legend = FALSE)
legend("topleft", legend = c("Japan", "USA"), col = c("green", "blue"), 
        lty = 1, bty = "n")
</code></pre>

<hr>
<h2 id='e0options'>
Global options
</h2><span id='topic+e0options'></span><span id='topic+e0mcmc.options'></span><span id='topic+e0pred.options'></span><span id='topic+using.bayesLife'></span><span id='topic+e0mcmc.dlpriors.options'></span><span id='topic+get.DLpriors'></span><span id='topic+DLpriors'></span>

<h3>Description</h3>

<p>Setting, retrieving and updating global options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>using.bayesLife()
e0options()
e0mcmc.options(..., annual = FALSE)
e0pred.options(...)

e0mcmc.dlpriors.options(prior.choice = "B", annual = FALSE, 
    un.constraints = FALSE)
    
get.DLpriors(prior.choice = NULL, annual = FALSE)

data(DLpriors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e0options_+3A_...">...</code></td>
<td>
<p>Arguments in <code>tag = value</code> form, or names of options to retrieve.</p>
</td></tr>
<tr><td><code id="e0options_+3A_annual">annual</code></td>
<td>
<p>Logical indicating if the options are for an annual simulation (<code>TRUE</code>) or a 5-year simulation(<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="e0options_+3A_prior.choice">prior.choice</code></td>
<td>
<p>A character indicating for which combination of the upper bound on the <code class="reqn">z</code> parameter and the upper bound of <code>sumTriangle.lim</code> priors for <code>a</code>, <code>delta</code> and <code>tau</code> should be used. Choices are &ldquo;A&rdquo; (0.653, 83), &ldquo;B&rdquo; (0.653, 86; default), &ldquo;C&rdquo; (1.150, 83), &ldquo;D&rdquo; (1.150, 86). See Details for more information. Use <code>get.DLpriors()</code> to view the priors. If this argument is <code>NULL</code> no update/choice is taken.</p>
</td></tr>
<tr><td><code id="e0options_+3A_un.constraints">un.constraints</code></td>
<td>
<p>Logical indicating if constraints on the lower bounds of the <code>Triangle</code> parameter posed by the UN in WPP 2022 should be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>using.bayesLife</code> sets all global options to their default values. Function <code>e0options</code> is used to get all options as a named list. 
</p>
<p>The global options are divided into three main categories, namely options used for MCMC estimations in a 5-year simulation, in a 1-year simulation, and options used for predictions. To set or retrieve options of the first two categories, use <code>e0mcmc.options</code> and use the argument <code>annual</code> to distinguish between them (see section MCMC Options below), while the third category is controlled by <code>e0pred.options</code> (see section Prediction Options below). 
</p>
<p>Many options are in the form of a list and it is possible to overwrite only single elements of the list. However, if an option is a vector, all elements of the vector have to be defined when updating (see Example).
</p>
<p>The dataset <code>DLpriors</code> contains four sets of parameters <code>a</code>, <code>delta</code> and <code>tau</code> (see section MCMC Options below) estimated for different combinations of the upper limit on the <code>z</code> parameter (i.e. maximum 5-year increase of e0; column &ldquo;Uz&rdquo;) and the upper bound of the sum of <code class="reqn">\Delta_i</code> (column &ldquo;Sa&rdquo;; set in the <code>sumTriangle.lim</code> option which is interpreted as the value of e0 for which the transition is completed; see below for more detail). A <code>get.DLpriors()</code> call retrieves all available combinations. Function <code>e0mcmc.dlpriors.options</code> can be used to change the default option B (i.e. the upper limit on <code>z</code> being 0.653 and the transition being completed at e0 of 86). Use the column &ldquo;option&rdquo; from <code>DLpriors</code> to select the desired combination. In addition, setting the argument <code>un.constraints</code> to <code>TRUE</code> will set the lower limit on the <code class="reqn">\Delta_i</code> parameters (<code>Triangle</code>, <code>Triangle.c</code>) to the same values as the UN used for WPP 2022. Note that the <code>DLpriors</code> dataset corresponds to parameter values designed for a 5-year simulation. Use <code>get.DLprior(annual = TRUE)</code> to see the equivalents for an annual simulation where various values are divided by five.
</p>


<h3>Value</h3>

<p><code>e0options</code> returns a list of all global options.<br /><br />
<code>e0mcmc.options</code>, when called with no argument other than <code>annual</code>, it returns a list of options related to the MCMC estimation. The <code>annual</code> argument determines if the values correspond to an annual or 5-year simulation.<br /><br />
<code>e0pred.options</code>, when called with no argument, it returns a list of options related to the prediction. <br /><br />
For both, <code>e0mcmc.options</code> and <code>e0pred.options</code>, when a specific option is queried, it returns the value of that option. When an option is set, a list of the previous values of all MCMC/prediction options is returned invisibly. <br /><br />
<code>get.DLpriors</code> returns the content of the <code>DLpriors</code> dataset. <br /><br />
<code>e0mcmc.dlpriors.options</code> overwrites various values and like <code>e0mcmc.options</code>, it returns a list of the previous values of all MCMC options invisibly. 
</p>


<h3>MCMC Options</h3>


<dl>
<dt>a</dt><dd><p>vector of the <code class="reqn">a_1</code>, ... ,<code class="reqn">a_6</code> parameters, which are the prior means of the world-level parameters (<code class="reqn">\Delta_1</code>, ..., <code class="reqn">\Delta_4</code>, <code class="reqn">k</code>, <code class="reqn">z</code>).</p>
</dd>
<dt>delta</dt><dd><p>vector of the <code class="reqn">\delta_1</code>, ... ,<code class="reqn">\delta_6</code> parameters, 
which are the prior standard deviations of the world-level parameters (<code class="reqn">\Delta_1</code>, ..., <code class="reqn">\Delta_4</code>, <code class="reqn">k</code>, <code class="reqn">z</code>).</p>
</dd>
<dt>tau</dt><dd><p>vector of the <code class="reqn">\tau_1</code>, ... ,<code class="reqn">\tau_6</code> parameters, which is the square root rate of the prior Gamma distribution of the world-level parameters (<code class="reqn">\lambda_1</code>, ..., <code class="reqn">\lambda_4</code>, <code class="reqn">\lambda_k</code>, <code class="reqn">\lambda_z</code>).</p>
</dd>
<dt>Triangle</dt><dd><p>list with elements:
</p>

<dl>
<dt>ini</dt><dd><p>list with elements:
</p>

<dl>
<dt>T1, T2, T3, T4</dt><dd><p>initial values for <code class="reqn">\Delta_1</code>, ..., <code class="reqn">\Delta_4</code>. If not <code>NULL</code>, then each element should be of the same length as the number of MCMC chains. If it is <code>NULL</code>, the initial values are equally spaced between <code>ini.low</code> and <code>ini.up</code> for the respective parameter. By default in the estimation, if there is just one chain, the initial value is the middle point of the interval.</p>
</dd>
</dl>
</dd>
<dt>ini.low, ini.up</dt><dd><p>vectors of length four. They are the lower and upper bounds for initial values of <code class="reqn">\Delta_1</code>, ..., <code class="reqn">\Delta_4</code>. An <code class="reqn">i</code>-th item is only used if <code>ini$Ti</code> is <code>NULL</code>.</p>
</dd>
<dt>prior.low, prior.up</dt><dd><p>vectors of length four. They are the lower and upper bounds for the prior (truncated normal) distribution of <code class="reqn">\Delta_1</code>, ..., <code class="reqn">\Delta_4</code>.</p>
</dd>   
<dt>slice.width</dt><dd><p>vector of length four defining the slice width for MCMC slice sampling for the four parameters, <code class="reqn">\Delta_1</code>, ..., <code class="reqn">\Delta_4</code>.</p>
</dd>
</dl>
</dd>
<dt>k, z</dt><dd><p>lists with elements:
</p>

<dl>
<dt>ini</dt><dd><p>vector of initial values for <code class="reqn">k</code> (<code class="reqn">z</code>). Its length (if not <code>NULL</code>) should correspond to the number of MCMC chains. By default, the initial values are equally spaced between <code>ini.low</code> and <code>ini.up</code>. In case of one chain, the initial value is by default the middle point of the interval.</p>
</dd>
<dt>ini.low, ini.up</dt><dd><p>single value giving the lower and upper bounds for initial values of <code class="reqn">k</code> (<code class="reqn">z</code>). It is only used if <code>ini</code> is <code>NULL</code>. Regarding defaults for the <code class="reqn">z</code> parameter, see Note below.</p>
</dd>
<dt>prior.low, prior.up</dt><dd><p>single value giving the lower and upper bounds for the prior (truncated normal) distribution  of <code class="reqn">k</code> (<code class="reqn">z</code>). Regarding defaults for the <code class="reqn">z</code> parameter, see Note below.</p>
</dd>
<dt>slice.width</dt><dd><p>single value giving the slice width for MCMC slice sampling of the <code class="reqn">z</code> parameter (not available for <code class="reqn">k</code>).</p>
</dd>
</dl>
</dd>
<dt>lambda</dt><dd><p>list with elements:
</p>

<dl>
<dt>ini</dt><dd><p>list with elements:
</p>

<dl>
<dt>T1, T2, T3, T4</dt><dd><p>initial values for <code class="reqn">\lambda_1</code>, ..., <code class="reqn">\lambda_4</code>. Each element should be of the same length as the number of MCMC chains. If it is <code>NULL</code>, the initial values are equally spaced between <code>ini.low</code> and <code>ini.up</code> of the respective parameter. By default, if there is just one chain, the value is the middle point of the interval.</p>
</dd>
</dl>
</dd>
<dt>ini.low, ini.up</dt><dd><p>vectors of length four. They are the lower and upper bounds for initial values of <code class="reqn">\lambda_1</code>, ..., <code class="reqn">\lambda_4</code>. An <code class="reqn">i</code>-th item is only used if <code>ini$Ti</code> is <code>NULL</code>.</p>
</dd>
<dt>slice.width</dt><dd><p>vector of length four defining the slice width for MCMC slice sampling for the four parameters, <code class="reqn">\lambda_1</code>, ..., <code class="reqn">\lambda_4</code>.</p>
</dd>
</dl>
</dd>
<dt>lambda.k, lambda.z</dt><dd><p>lists with elements:
</p>
     
<dl>
<dt>ini</dt><dd><p>vector of initial values for <code class="reqn">\lambda_k</code> (<code class="reqn">\lambda_z</code>). Its length (if not <code>NULL</code>) should correspond to the number of MCMC chains. By default, the initial values are equally spaced between <code>ini.low</code> and <code>ini.up</code>. In case of one chain, the initial value is by default the middle point of the interval.</p>
</dd>
<dt>ini.low, ini.up</dt><dd><p>single value giving the lower and upper bounds for initial values of <code class="reqn">\lambda_k</code> (<code class="reqn">\lambda_z</code>). It is only used if <code>ini</code> is <code>NULL</code>.</p>
</dd> 
<dt>slice.width</dt><dd><p>single value giving the slice width for MCMC slice sampling of the <code class="reqn">\lambda_z</code> parameter (not available for <code class="reqn">\lambda_k</code>).</p>
</dd>
</dl>
</dd>
<dt>omega</dt><dd><p>list with elements:
</p>
 
<dl>
<dt>ini</dt><dd><p>vector of initial values for <code class="reqn">\omega</code>. Its length (if not <code>NULL</code>) should correspond to the number of MCMC chains. By default, the initial values are equally spaced between <code>ini.low</code> and <code>ini.up</code>. In case of one chain, the initial value is by default the middle point of the interval.</p>
</dd>
<dt>ini.low, ini.up</dt><dd><p>single value giving the lower and upper bounds for initial values of <code class="reqn">\omega</code>. It is only used if <code>ini</code> is <code>NULL</code>.</p>
</dd>
</dl>
</dd>
<dt>Triangle.c</dt><dd><p>list with elements:
</p>
  
<dl>
<dt>ini.norm</dt><dd><p>list with elements:
</p>

<dl>
<dt>mean, sd</dt><dd><p>vectors of size four. They correspond to the means and standard deviations, respectively, for the initial values of the country-specific parameters <code class="reqn">\Delta_1^c</code>, ..., <code class="reqn">\Delta_4^c</code> which are drawn from a truncated normal distribution with bounds defined by <code>prior.low</code> and <code>prior.up</code>.</p>
</dd>
</dl>
</dd>
<dt>prior.low, prior.up</dt><dd><p>vectors of length four. They are the lower and upper bounds for the prior (truncated normal) distribution of country-specific <code class="reqn">\Delta_1^c</code>, ..., <code class="reqn">\Delta_4^c</code>.</p>
</dd> 
<dt>slice.width</dt><dd><p>vector of length four defining the slice width for MCMC slice sampling of the country-specific <code class="reqn">\Delta_1^c</code>, ..., <code class="reqn">\Delta_4^c</code>.</p>
</dd>
</dl>
</dd>
<dt>k.c, z.c</dt><dd><p>list with elements:
</p>
  
<dl>
<dt>ini.norm</dt><dd><p>named vector of length two, called &ldquo;mean&rdquo; and &ldquo;sd&rdquo;. The elements correspond to the means and standard deviations, respectively, for the initial values of the country-specific parameters <code class="reqn">k^c</code> (<code class="reqn">z^c</code>) which are drawn from a normal distribution truncated between <code>prior.low</code> and <code>prior.up</code>.</p>
</dd>
<dt>prior.low, prior.up</dt><dd><p>single values giving the lower and upper bounds for the prior (truncated normal) distribution  of country-specific <code class="reqn">k^c</code> (<code class="reqn">z^c</code>). Regarding defaults for <code class="reqn">z^c</code>, see Note below.</p>
</dd>
<dt>slice.width</dt><dd><p>single value giving the slice width for MCMC slice sampling of the <code class="reqn">k^c</code> (<code class="reqn">z^c</code>) parameter.</p>
</dd>
</dl>
</dd>
<dt>nu</dt><dd><p>the shape parameter of the Gamma distributions of all <code class="reqn">\lambda</code> parameters is <code>nu/2</code>.</p>
</dd>
<dt>dl.p1, dl.p2</dt><dd><p>values of the parameters <code class="reqn">p_1</code> and <code class="reqn">p_2</code> of the double logistic function.</p>
</dd>
<dt>sumTriangle.lim</dt><dd><p>lower and upper limits for the sum of the <code class="reqn">\Delta_i</code> parameters. MCMC proposals that are outside of this limit are rejected. It is applied to both, the world parameters as well as the country specific parameters. The sum of <code class="reqn">\Delta_i</code> can be interpreted as the level of e0 at which the transition is completed and is followed by an e0 increase with a constant rate <code>z</code>.</p>
</dd>
<dt>world.parameters</dt><dd><p>named vector where names are the world parameters and values are the number of sub-parameters. For example, <code class="reqn">\Delta</code> has 4 sub-parameters, while <code class="reqn">k</code> and <code class="reqn">z</code> are both just one parameter.</p>
</dd>
<dt>country.parameters</dt><dd><p>named vector where names are the country-specific parameters and values are the number of sub-parameters.</p>
</dd>
<dt>outliers</dt><dd><p>ranges for determining outliers in the historical data. If <code>outliers=c(x, y)</code> then any increase in life expectancy smaller than <code>x</code> or larger than <code>y</code> is considered as an outlier and removed from the estimation.</p>
</dd>
<dt>buffer.size</dt><dd><p>buffer size (in number of [thinned] iterations) for keeping data in the memory. The smaller the <code>buffer.size</code> the more often will the process access the hard disk and thus, the slower the run. On the other hand, the smaller the <code>buffer.size</code> the less data will be lost in case of failure.</p>
</dd>
<dt>auto.conf</dt><dd><p>list containing a configuration for an &lsquo;automatic&rsquo; run. All items in this list must be integer values. The option is only used if the argument <code>iter</code> in <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code> is set to &lsquo;auto&rsquo; (see description of argument <code>iter</code> in <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>). The list contains the following elements:
</p>
  
<dl>
<dt>iter</dt><dd><p>gives the number of iterations in the first chunk of the MCMC simulation.</p>
</dd>
<dt>iter.incr</dt><dd><p>gives the number of iterations in the following chunks.</p>
</dd>
<dt>nr.chains</dt><dd><p>gives the number of chains in all chunks of the MCMC simulation.</p>
</dd>
<dt>thin, burnin</dt><dd><p>used in the convergence diagnostics following each chunk.</p>
</dd>
<dt>max.loops</dt><dd><p>controls the maximum number of chunks.</p>
</dd>
</dl>
</dd>
<dt>country.overwrites</dt><dd><p>This option allows to overwrite some of the prior parameters for specific countries. If it is not <code>NULL</code> it should be a data frame with an obligatory column &lsquo;country_code&rsquo;. Each row then corresponds to one country. Other columns can be &lsquo;k.c.prior.low&rsquo;, &lsquo;k.c.prior.up&rsquo;, &lsquo;z.c.prior.low&rsquo;, &lsquo;z.c.prior.up&rsquo;, &lsquo;Triangle_<code class="reqn">x</code>.c.prior.low&rsquo; and &lsquo;Triangle_<code class="reqn">x</code>.c.prior.up&rsquo; where <code class="reqn">x</code> can be an integer from 1 to 4.</p>
</dd>
</dl>


<h3>Note</h3>

<p>Parameter <code class="reqn">z</code> determines the asymptote in gains in life expectancy. The following text gives an explanation for the choice of  upper limits on <code class="reqn">z</code>-related parameters: 
</p>
<p>The pace of improvement and the asymptotic limit in future gains in female life expectancy vary for each projected trajectory, but ultimately is informed and constrained by the finding that the rate of increase of maximum female life expectancy over the past 150 year has been highly linear (2a, 2b) (i.e., about 2.4 years per decade), albeit at slightly lower pace once the leading countries started to exceed 75 years of female life expectancy at birth in the 1960s (3) (about 2.26 years of gains per decade). By assuming that the asymptotic average rate of increase in life expectancy is nonnegative, life expectancy is assumed to continually increase (on average), and no limit is imposed to life expectancy in the foreseeable future. The increase in maximum female life span among countries with highest life expectancy and reliable data on very old age provide further guidance on future rate of progress which has also been increasingly linear at least since the 1970s (4a-4c) (about 1.25 years per decade for countries like Sweden and Norway), and is used to inform the asymptotic average rate of increase in female life expectancy used in the 2012 WPP Revision. To set the posterior median to an annual gain of 0.125 year (or 5-year gain of 0.625 in this context) the upper bound value of 0.653 is used for the world prior (<code class="reqn">z</code>) and country-specific prior (<code class="reqn">z_c</code>) as default values in the estimation of the double-logistic parameters.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Patrick Gerland contributed to the documentation.
</p>


<h3>References</h3>

<p>(1) J. L. Chunn, A. E. Raftery, P. Gerland, H. Sevcikova (2013): Bayesian Probabilistic Projections of Life Expectancy for All Countries. Demography 50(3):777-801. &lt;doi:10.1007/s13524-012-0193-x&gt;
</p>
<p>(2a)  Oeppen J, and J.W. Vaupel (2002) Broken limits to life expectancy. Science 296:1029-1031. 
</p>
<p>(2b) Vaupel, J.W. and K.G.V. Kistowski. 2005. Broken Limits to Life Expectancy. Ageing Horizons (3):6-13.
</p>
<p>(3) Vallin, J., and F. Mesle (2009). The Segmented Trend Line of Highest Life Expectancies. Population and Development Review, 35(1), 159-187. doi:10.1111/j.1728-4457.2009.00264.x
</p>
<p>(4a) Wilmoth, J. R., L. J. Deegan, H. Lundstrom, and S. Horiuchi (2000). Increase of maximum life-span in Sweden, 1861-1999. Science, 289(5488), 2366-2368. 
</p>
<p>(4b) Wilmoth, J. R. and J-M. Robine. (2003). The world trend in maximum life span, in: J. R. Carey and S. Tuljapurkar (eds.), Life Span: Evolutionary, Ecological, and Demographic Perspectives, supplement to vol. 29, Population and Development Review, pp. 239-257. 
</p>
<p>(4c) Wilmoth, J. R. and N. Ouellette (2012). Maximum human lifespan: Will the records be unbroken?, Paper presented at the European Population Conference, Stockholm, Sweden, 13-16 June.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>, <code><a href="#topic+e0.predict">e0.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e0mcmc.options("z", "Triangle")
# Set new z$ini.up and Triangle$prior.up
# Modifying single elements of the z-list and Triangle-list.
# However, Triangle$prior.up is a vector and needs all four values.
e0mcmc.options(z = list(ini.up = 0.8), Triangle = list(prior.up = rep(120, 4)))
e0mcmc.options("z", "Triangle")

# revert to defaults
using.bayesLife()
e0mcmc.options("z", "Triangle")

# options for an annual simulation
e0mcmc.options("z", "sumTriangle.lim", annual = TRUE)

# modify using a different set from DLpriors
get.DLpriors(annual = TRUE) # view the DLpriors dataset
e0mcmc.dlpriors.options("C", annual = TRUE) # use C option
# upper bounds for z correspond to values from DLpriors divided by 5
e0mcmc.options("z", "sumTriangle.lim", annual = TRUE)
# set the UN's Triangle lower bound constraints 
e0mcmc.dlpriors.options(NULL, annual = TRUE, un.constraints = TRUE)
e0mcmc.options("Triangle", "Triangle.c", annual = TRUE) # prior.low is modified

</code></pre>

<hr>
<h2 id='get.e0.convergence'>
Accessing a Convergence Object
</h2><span id='topic+get.e0.convergence'></span><span id='topic+get.e0.convergence.all'></span>

<h3>Description</h3>

<p>The functions load objects of class <code><a href="#topic+bayesLife.convergence">bayesLife.convergence</a></code> from disk that were created using the function <code><a href="#topic+e0.diagnose">e0.diagnose</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.e0.convergence(sim.dir = file.path(getwd(), "bayesLife.output"), 
    thin = 225, burnin = 10000)
	
get.e0.convergence.all(sim.dir = file.path(getwd(), "bayesLife.output"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.e0.convergence_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Simulation directory used for computing the diagnostics.</p>
</td></tr>
<tr><td><code id="get.e0.convergence_+3A_thin">thin</code></td>
<td>
<p>Thinning interval used with this diagnostics.</p>
</td></tr>
<tr><td><code id="get.e0.convergence_+3A_burnin">burnin</code></td>
<td>
<p>Burnin used for computing the diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>get.e0.convergence</code> loads an object of class <code><a href="#topic+bayesLife.convergence">bayesLife.convergence</a></code> for the specific <code>thin</code> and <code>burnin</code>. Function <code>get.e0.convergence.all</code> loads all <code><a href="#topic+bayesLife.convergence">bayesLife.convergence</a></code> objects available in <code>sim.dir</code>. 
</p>


<h3>Value</h3>

<p><code>get.e0.convergence</code> returns an object of class <code><a href="#topic+bayesLife.convergence">bayesLife.convergence</a></code>; <br />
<code>get.e0.convergence.all</code> returns a list of objects of class <code><a href="#topic+bayesLife.convergence">bayesLife.convergence</a></code>.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.diagnose">e0.diagnose</a></code>, <code><a href="#topic+summary.bayesLife.convergence">summary.bayesLife.convergence</a></code>.
</p>

<hr>
<h2 id='get.e0.mcmc'>
Accessing MCMC Results
</h2><span id='topic+get.e0.mcmc'></span><span id='topic+has.e0.mcmc'></span><span id='topic+e0.mcmc'></span><span id='topic+e0.mcmc.list'></span>

<h3>Description</h3>

<p>The function <code>get.e0.mcmc</code> retrieves results of an MCMC simulation and creates an object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>. Function <code>has.e0.mcmc</code> checks the existence of such results. Function <code>e0.mcmc</code> extracts a single chain, and <code>e0.mcmc.list</code> extracts several or all chains from the simulation results. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.e0.mcmc(sim.dir = file.path(getwd(), "bayesLife.output"), 
    chain.ids = NULL, low.memory = TRUE, burnin = 0, verbose = FALSE)
    
has.e0.mcmc(sim.dir)

e0.mcmc(mcmc.set, chain.id = 1)

e0.mcmc.list(mcmc.set, chain.ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.e0.mcmc_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory where the simulation results are stored.</p>
</td></tr>
<tr><td><code id="get.e0.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>
<p>Chain identifiers in case only specific chains should be included in the resulting object. By default, all available chains are included.</p>
</td></tr>
<tr><td><code id="get.e0.mcmc_+3A_low.memory">low.memory</code></td>
<td>
<p>If <code>FALSE</code> full MCMC traces are loaded into memory.</p>
</td></tr>
<tr><td><code id="get.e0.mcmc_+3A_burnin">burnin</code></td>
<td>
<p>Burnin used for loading traces. Only relevant, if <code>low.memory=FALSE</code>.</p>
</td></tr>
<tr><td><code id="get.e0.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="get.e0.mcmc_+3A_chain.id">chain.id</code></td>
<td>
<p>Chain identifier.</p>
</td></tr>
<tr><td><code id="get.e0.mcmc_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get.e0.mcmc</code> returns an object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>. <code>has.e0.mcmc</code> returns a logical value.
<code>e0.mcmc</code> returns an object of class <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code>, and <code>e0.mcmc.list</code> returns a list of <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code> objects. 
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
m &lt;- get.e0.mcmc(sim.dir)
summary(m)

# summary of the world parameters for a single chain
# (the same as above since there is only one chain in this toy example)
summary(e0.mcmc.list(m)[[1]], par.names.cs = NULL)

# the same as
summary(e0.mcmc(m, chain.id = 1), par.names.cs = NULL)
</code></pre>

<hr>
<h2 id='get.e0.parameter.traces'>
Accessing MCMC Parameter Traces
</h2><span id='topic+get.e0.parameter.traces'></span><span id='topic+get.e0.parameter.traces.cs'></span>

<h3>Description</h3>

<p>Functions for accessing traces of the MCMC parameters, either country-independent or country-specific.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.e0.parameter.traces(mcmc.list, par.names = NULL, 
    burnin = 0, thinning.index = NULL, thin = NULL)
    
get.e0.parameter.traces.cs(mcmc.list, country.obj, 
    par.names = NULL, burnin = 0, thinning.index = NULL, thin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.e0.parameter.traces_+3A_mcmc.list">mcmc.list</code></td>
<td>
<p>List of <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code> objects.</p>
</td></tr>
<tr><td><code id="get.e0.parameter.traces_+3A_country.obj">country.obj</code></td>
<td>
<p>Country object list (see <code><a href="bayesTFR.html#topic+get.country.object">get.country.object</a></code>).</p>
</td></tr>
<tr><td><code id="get.e0.parameter.traces_+3A_par.names">par.names</code></td>
<td>
<p>Names of country-independent parameters (in case of <code>get.e0.parameter.traces</code>) or country-specific parameters (in case of <code>get.e0.parameter.traces.cs</code>) to be included. By default all parameters are included.</p>
</td></tr>
<tr><td><code id="get.e0.parameter.traces_+3A_burnin">burnin</code></td>
<td>
<p>Burn-in indicating how many iterations should be removed from the beginning of each chain.</p>
</td></tr>
<tr><td><code id="get.e0.parameter.traces_+3A_thinning.index">thinning.index</code></td>
<td>
<p>Index of the traces for thinning. If it is <code>NULL</code>, <code>thin</code> is used. <code>thinning.index</code> does not include <code>burnin</code> and should be flattened over all chains. For example, if there are two MCMC chains of length 1000, <code>burnin=200</code> and we want a sample of length 400, then the value should be <code>thinning.index=seq(1,1600, length=400)</code>.</p>
</td></tr>
<tr><td><code id="get.e0.parameter.traces_+3A_thin">thin</code></td>
<td>
<p>Alternative to <code>thinning.index</code>. The above example is equivalent to <code>thin=4</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Both functions return a matrix with columns being the parameters and rows being the MCMC values, attached to one another in case of multiple chains. <code>get.e0.parameter.traces</code> returns country-independent parameters, <code>get.e0.parameter.traces.cs</code> returns country-specific parameters.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.coda.list.mcmc">e0.coda.list.mcmc</a></code> for another way of retrieving parameter traces. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
m &lt;- get.e0.mcmc(sim.dir)
e0.values &lt;- get.e0.parameter.traces(m$mcmc.list, burnin = 10, par.names = "z")
hist(e0.values, main = colnames(e0.values))

e0.values.cs &lt;- get.e0.parameter.traces.cs(m$mcmc.list, 
                    get.country.object("Canada", meta = m$meta),
                    burnin = 10, par.names = "z.c")
hist(e0.values.cs, main = colnames(e0.values.cs))</code></pre>

<hr>
<h2 id='get.e0.prediction'>
Accessing a Prediction Object
</h2><span id='topic+get.e0.prediction'></span><span id='topic+get.e0.jmale.prediction'></span><span id='topic+has.e0.prediction'></span><span id='topic+has.e0.jmale.prediction'></span>

<h3>Description</h3>

<p>Function <code>get.e0.prediction</code> retrieves results of a prediction and creates an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>. Function <code>has.e0.prediction</code> checks an existence of such results. Analogously, functions <code>get.e0.jmale.prediction</code> and <code>has.e0.jmale.prediction</code> retrieve and check an existence of male predictions from a given female prediction object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.e0.prediction(mcmc = NULL, sim.dir = NULL, joint.male = FALSE, mcmc.dir = NULL)

has.e0.prediction(mcmc = NULL, sim.dir = NULL)

get.e0.jmale.prediction(e0.pred)

has.e0.jmale.prediction(e0.pred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.e0.prediction_+3A_mcmc">mcmc</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> used to make the prediction.  If it is <code>NULL</code>, the prediction is loaded from directory given by <code>sim.dir</code>.</p>
</td></tr>
<tr><td><code id="get.e0.prediction_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Directory where the prediction is stored.  It should correspond to the value of the <code>output.dir</code> argument used in the <code><a href="#topic+e0.predict">e0.predict</a></code> function.  Only relevant if <code>mcmc</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="get.e0.prediction_+3A_joint.male">joint.male</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function is applied to a male prediction that was generated using the joint female-male model implemented in the function <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>.</p>
</td></tr>
<tr><td><code id="get.e0.prediction_+3A_mcmc.dir">mcmc.dir</code></td>
<td>
<p>Optional argument to be used only in a special case when the mcmc object contained in the prediction object was estimated in different directory than in the one to which it points to (for example due to moving or renaming the original directory). The argument causes that the mcmc is redirected to the given directory.</p>
</td></tr>
<tr><td><code id="get.e0.prediction_+3A_e0.pred">e0.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mcmc</code> is not <code>NULL</code>, the search directory is set to <code>mcmc$meta$output.dir</code>. This approach assumes that the prediction was stored in the same directory as the MCMC simulation, i.e. the <code>output.dir</code> argument of the <code><a href="#topic+e0.predict">e0.predict</a></code> function was set to <code>NULL</code>. If it is not the case, the argument <code>mcmc.dir</code> should be used.
</p>
<p>Function <code>get.e0.jmale.prediction</code> extracts male projections from the <code>e0.pred</code> objects (which should be a female prediction object), if the male prediction was generated using the  <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code> function. <code>has.e0.jmale.prediction</code> checks if such male prediction was generated.
</p>


<h3>Value</h3>

<p>Functions <code>has.e0.prediction</code> and <code>has.e0.jmale.prediction</code> return a logical indicating if a prediction exists. 
</p>
<p>Functions <code>get.e0.prediction</code> and <code>get.e0.jmale.prediction</code> return an
object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>, <code><a href="#topic+e0.predict">e0.predict</a></code>, <code><a href="#topic+summary.bayesLife.prediction">summary.bayesLife.prediction</a></code>, <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
pred &lt;- get.e0.prediction(sim.dir = sim.dir)
# female prediction summary
summary(pred, country = "Canada")

## Not run: 
# male prediction summary
# (works only if a joint male prediction exists - not the case in this toy example)
summary(get.e0.jmale.prediction(pred), country = "Canada")
## End(Not run)
</code></pre>

<hr>
<h2 id='get.e0.trajectories'>
Accessing Trajectories of Life Expectancy
</h2><span id='topic+get.e0.trajectories'></span>

<h3>Description</h3>

<p>Function for accessing trajectories of the life expectancy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.e0.trajectories(e0.pred, country)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.e0.trajectories_+3A_e0.pred">e0.pred</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="get.e0.trajectories_+3A_country">country</code></td>
<td>
<p>Name or numerical code of a country. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function loads trajectories of life expectancy for the given country from disk
and returns it as a matrix.
</p>


<h3>Value</h3>

<p>Array of size the number of projection periods (including the present year) times the number of trajectories. The row names correspond to the mid-years of the prediction periods.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>, <code><a href="#topic+get.e0.prediction">get.e0.prediction</a></code>, <code><a href="#topic+e0.trajectories.table">e0.trajectories.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output") 
pred &lt;- get.e0.prediction(sim.dir=sim.dir)
get.e0.trajectories(pred, "Germany")
</code></pre>

<hr>
<h2 id='get.rege0.prediction'>
Accessing Subnational Prediction Objects
</h2><span id='topic+get.rege0.prediction'></span>

<h3>Description</h3>

<p>Retrieve subnational (regional) prediction results produced by <code><a href="#topic+e0.predict.subnat">e0.predict.subnat</a></code>, either for one country or for all available countries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.rege0.prediction(sim.dir, country = NULL, method = "ar1", joint.male = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.rege0.prediction_+3A_sim.dir">sim.dir</code></td>
<td>
<p>Simulation directory of the subnational predictions. It corresponds to the argument <code>output.dir</code> in <code><a href="#topic+e0.predict.subnat">e0.predict.subnat</a></code>.
</p>
</td></tr>
<tr><td><code id="get.rege0.prediction_+3A_country">country</code></td>
<td>
<p>Numerical country code. If it is not given, all available subnational predictions are retrieved.</p>
</td></tr>
<tr><td><code id="get.rege0.prediction_+3A_method">method</code></td>
<td>
<p>Method used for generating the projections. It corresponds to the <code>method</code> argument in <code><a href="#topic+e0.predict.subnat">e0.predict.subnat</a></code>.</p>
</td></tr>
<tr><td><code id="get.rege0.prediction_+3A_joint.male">joint.male</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function is applied to a male prediction that was generated using the joint female-male gap model implemented in the function <code><a href="#topic+e0.jmale.predict.subnat">e0.jmale.predict.subnat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Predictions for country <code class="reqn">x</code> are assumed to be stored in &ldquo;<code>sim.dir</code>/subnat_<code>method</code>/c<code class="reqn">x</code>&rdquo;.
</p>


<h3>Value</h3>

<p>If argument <code>country</code> is given, the function returns an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>. If it is <code>NULL</code>, it returns a list of such objects. Names of the list items are the country codes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.predict.subnat">e0.predict.subnat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subnational example data
my.sube0.file &lt;- file.path(find.package("bayesLife"), 'extdata', 'subnational_e0_template.txt')
sube0 &lt;- read.delim(my.sube0.file, check.names = FALSE)
countries &lt;- unique(sube0[, c("country_code", "country_name")])

# Directory with national projections (contains 30 trajectories for each country)
nat.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")

# Subnational projections for all three countries,
# including male projections where female 
# data is used only for demonstration purposes
# (my.e0M.file should contain male e0).
subnat.dir &lt;- tempfile()
e0.predict.subnat(countries$country_code, my.e0.file = my.sube0.file,
    sim.dir = nat.dir, output.dir = subnat.dir, start.year = 2013,
    predict.jmale = TRUE, my.e0M.file = my.sube0.file)
    
# Retrieve results for all countries
preds &lt;- get.rege0.prediction(subnat.dir)
names(preds)

# View tables of subregions for each country
for(i in 1:nrow(countries)) {
  cat("\n\n", countries$country_name[i], "\n")
  print(get.countries.table(preds[[as.character(countries$country_code[i])]]))
}
# Quantiles for individual subregions for female
e0.trajectories.table(preds[["36"]], "Victoria")

# Retrieve results for one country (Canada)
pred &lt;- get.rege0.prediction(subnat.dir, 124)
e0.trajectories.plot(pred, "Quebec", both.sexes = TRUE)

# Retrieve only male results
predM &lt;- get.rege0.prediction(subnat.dir, 124, joint.male = TRUE)
e0.trajectories.table(predM, "Quebec")

# cleanup
unlink(subnat.dir)

# See more examples in ?e0.predict.subnat
</code></pre>

<hr>
<h2 id='get.thinned.e0.mcmc'>
Creating and Accessing Thinned MCMCs
</h2><span id='topic+get.thinned.e0.mcmc'></span><span id='topic+create.thinned.e0.mcmc'></span>

<h3>Description</h3>

<p>The function <code>get.thinned.e0.mcmc</code> accesses 
a thinned and burned version of the given MCMC set. <code>create.thinned.e0.mcmc</code> creates such set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.thinned.e0.mcmc(mcmc.set, thin = 1, burnin = 0)

create.thinned.e0.mcmc(mcmc.set, thin = 1, burnin = 0, 
    output.dir = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.thinned.e0.mcmc_+3A_mcmc.set">mcmc.set</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>.</p>
</td></tr>
<tr><td><code id="get.thinned.e0.mcmc_+3A_thin">thin</code>, <code id="get.thinned.e0.mcmc_+3A_burnin">burnin</code></td>
<td>
<p>Thinning interval and burnin used for creating or identifying the thinned object.</p>
</td></tr>
<tr><td><code id="get.thinned.e0.mcmc_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory for storing the thinned object. By default it is stored into the same directory as <code>mcmc.set</code>.</p>
</td></tr>
<tr><td><code id="get.thinned.e0.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>create.thinned.e0.mcmc</code> is called from <code><a href="#topic+e0.predict">e0.predict</a></code> and thus, the resulting object contains exactly the same MCMCs used for generating projections. 
</p>
<p>The thinning is done as follows: The given <code>burnin</code> is removed from the beginning of each chain in the original MCMC set. Then each chain is thinned by <code>thin</code> using equal spacing and all chains are collapsed into one single chain per parameter. They are stored in <code>output.dir</code> under the name &lsquo;<span class="file">thinned_mcmc_<em>t</em>_<em>b</em></span>&rsquo; where <em>t</em> is the value  of <code>thin</code> and <em>b</em> the value of <code>burnin</code>.   
</p>


<h3>Value</h3>

<p>Both functions return an object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>. <code>get.thinned.e0.mcmc</code> returns <code>NULL</code> if such object does not exist.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>, <code><a href="#topic+e0.predict">e0.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sim.dir &lt;- tempfile()
m &lt;- run.e0.mcmc(nr.chains = 2, iter = 60, thin = 2, output.dir = sim.dir, verbose = TRUE)
pr &lt;- e0.predict(m, burnin = 40, predict.jmale = FALSE) # creates thinned MCMCs
mb &lt;- get.thinned.e0.mcmc(m, thin = 2, burnin = 40)
summary(mb, meta.only = TRUE) # length 20 = 2chains x (60-40)iters./2thin

# the same chain as 
summary(pr$mcmc.set, meta.only = TRUE)

unlink(sim.dir, recursive=TRUE)
## End(Not run)
</code></pre>

<hr>
<h2 id='include'>
Inclusion Codes
</h2><span id='topic+include'></span><span id='topic+include_2019'></span><span id='topic+include_2017'></span><span id='topic+include_2015'></span><span id='topic+include_2010'></span><span id='topic+include_2012'></span><span id='topic+include_2022'></span>

<h3>Description</h3>

<p>Datasets containing codes that determine which countries are to be included into a simulation or/and projections. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(include_2022)
data(include_2019)
data(include_2017)
data(include_2015)
data(include_2012)
data(include_2010)
</code></pre>


<h3>Format</h3>

<p>Data frames containing one record per country or region. It has the following variables:
</p>

<dl>
<dt>country</dt><dd><p>Name of country or region. Not used.</p>
</dd>
<dt>country_code</dt><dd><p>Numerical Location Code (3-digit codes following ISO 3166-1 numeric standard) - see <a href="https://en.wikipedia.org/wiki/ISO_3166-1_numeric">https://en.wikipedia.org/wiki/ISO_3166-1_numeric</a>.</p>
</dd>
<dt>include_code</dt><dd><p>Entries for which <code>include_code=2</code> are included in MCMC simulations (i.e. estimation of the model parameters). Entries for which <code>include_code</code> is 1 or 2 are included in the prediction.</p>
</dd></dl>



<h3>Details</h3>

<p>In a simulation, an <code>include_*</code> dataset is selected that corresponds to the given <code>wpp.year</code> passed to the function <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>. It is merged with an <code><a href="wpp2019.html#topic+e0">e0</a></code> dataset from the corresponding <span class="pkg">wpp</span> package using the <code>country_code</code> column. Thus, the country entries in this dataset should correspond to entries in the <code>e0F</code> (<code>e0M</code>) dataset.
</p>
<p>The package contains also a dataset called &lsquo;<span class="file">my_e0_template</span>&rsquo; (in &lsquo;<span class="file">extdata</span>&rsquo; directory) which is a template for user-specified e0 time series. It has the same structure as the <code><a href="wpp2019.html#topic+e0">e0</a></code> dataset, except that most of the columns are optional. The only required column is <code>country_code</code> (see description of the argument <code>my.e0.file</code> in <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>).
</p>


<h3>Note</h3>

<p>In all three datasets, countries affected by AIDS are not included in the estimation, i.e. the <code>include_code</code> is set to 3.  
</p>


<h3>Source</h3>

<p>Data provided by the United Nations Population Division.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(include_2019)
head(include_2019)
# select AIDS countries
subset(include_2019, include_code == 3)
</code></pre>

<hr>
<h2 id='run.e0.mcmc'>
Running Bayesian Hierarchical Model for Life Expectancy via Markov Chain Monte Carlo
</h2><span id='topic+run.e0.mcmc'></span><span id='topic+continue.e0.mcmc'></span><span id='topic+bayesLife.mcmc.set'></span>

<h3>Description</h3>

<p>Runs (or continues running) MCMCs for simulating the life expectancy for all countries of the world, using a Bayesian hierarchical model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.e0.mcmc(sex = c("Female", "Male"), nr.chains = 3, iter = 160000, 
    output.dir = file.path(getwd(), "bayesLife.output"), 
    thin = 10, replace.output = FALSE, annual = FALSE,
    start.year = 1873, present.year = 2020, wpp.year = 2019, 
    my.e0.file = NULL, my.locations.file = NULL, constant.variance = FALSE, 
    seed = NULL, parallel = FALSE, nr.nodes = nr.chains, compression.type = 'None',
    verbose = FALSE, verbose.iter = 100, mcmc.options = NULL, ...)
    
continue.e0.mcmc(iter, chain.ids = NULL, 
    output.dir = file.path(getwd(), "bayesLife.output"), 
    parallel = FALSE, nr.nodes = NULL, auto.conf = NULL, 
    verbose = FALSE, verbose.iter = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.e0.mcmc_+3A_sex">sex</code></td>
<td>
<p>Sex for which to run the simulation.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_nr.chains">nr.chains</code></td>
<td>
<p>Number of MCMC chains to run.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_iter">iter</code></td>
<td>
<p>Number of iterations to run in each chain. In addition to a single value, it can have the value &lsquo;auto&rsquo; for an automatic assessment of the convergence. In such a case, the function runs for the number of iterations given in the global option <code>auto.conf</code> list (see <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>), then checks if the MCMCs converged (using the <code>auto.conf</code> settings). If it did not converge, the procedure is repeated until convergence is reached or the number of repetition exceeded <code>auto.conf$max.loops</code>.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory which the simulation output should be written into.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_thin">thin</code></td>
<td>
<p>Thinning interval between consecutive observations to be stored on disk.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_replace.output">replace.output</code></td>
<td>
<p>If <code>TRUE</code>, existing outputs in <code>output.dir</code> will be replaced by results of this simulation.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_annual">annual</code></td>
<td>
<p>If <code>TRUE</code>, the model will be trained based on annual data. in such a case, argument <code>my.e0.file</code> must be used to provide the annual observed data.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_start.year">start.year</code></td>
<td>
<p>Start year for using historical data.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_present.year">present.year</code></td>
<td>
<p>End year for using historical data.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_wpp.year">wpp.year</code></td>
<td>
<p>Year for which WPP data is used. The functions loads a package called <span class="pkg">wpp</span><code class="reqn">x</code> where <code class="reqn">x</code> is the <code>wpp.year</code> and uses the <code><a href="wpp2019.html#topic+e0">e0</a>*</code> datasets.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_my.e0.file">my.e0.file</code></td>
<td>
<p>File name containing user-specified e0 time series for one or more countries. See Details below.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_my.locations.file">my.locations.file</code></td>
<td>
<p>File name containing user-specified locations. See Details below.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_constant.variance">constant.variance</code></td>
<td>
<p>Logical indicating if the model should be estimated using constant variance. It should only be used if the standard deviation lowess is to be analysed, see <code><a href="#topic+compute.loess">compute.loess</a></code>.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. If <code>NULL</code> no seed is set. It can be used to generate reproducible results.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_parallel">parallel</code></td>
<td>
<p>Logical determining if the simulation should run multiple chains in parallel. If it is <code>TRUE</code>, the package <span class="pkg">snowFT</span> is required.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_nr.nodes">nr.nodes</code></td>
<td>
<p>Relevant only if <code>parallel</code> is <code>TRUE</code>. It gives the number of nodes for running the simulation in parallel. By default it equals to the number of chains.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_compression.type">compression.type</code></td>
<td>
<p>One of &lsquo;None&rsquo;, &lsquo;gz&rsquo;, &lsquo;xz&rsquo;, &lsquo;bz&rsquo;, determining type of a compression of the MCMC files.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_verbose">verbose</code></td>
<td>
<p>Logical switching log messages on and off.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_verbose.iter">verbose.iter</code></td>
<td>
<p>Integer determining how often (in number of iterations) log messages are outputted during the estimation.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_mcmc.options">mcmc.options</code></td>
<td>
<p>List of options that overwrites global MCMC options as defined in <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>. Type <code>e0mcmc.options()</code> to view default values.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_auto.conf">auto.conf</code></td>
<td>
<p>In <code>continue.e0.mcmc</code>, one can overwrite the global <code>auto.conf</code> option, see <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code> for its definition. This argument is only used if the function argument <code>iter</code> is set to &lsquo;auto&rsquo;.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the function <code>snowFT::performParallel</code>, if <code>parallel</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc_+3A_chain.ids">chain.ids</code></td>
<td>
<p>Array of chain identifiers that should be resumed. If it is <code>NULL</code>, all existing chains in <code>output.dir</code> are resumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>run.e0.mcmc</code> uses a set of global options (for priors, initial values etc.), possibly modified by the <code>mcmc.options</code> argument. One can also modify these options using <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>. Call <code>e0mcmc.options()</code> for the full set of options. Function <code>continue.e0.mcmc</code> inherits its set of options from the corresponding <code>run.e0.mcmc</code> call.
</p>
<p>The function <code>run.e0.mcmc</code> creates an object of class <code><a href="#topic+bayesLife.mcmc.meta">bayesLife.mcmc.meta</a></code> and stores it in <code>output.dir</code>.  It launches <code>nr.chains</code> MCMCs, either sequentially or in parallel.  Parameter traces of each chain are stored as (possibly compressed) ASCII files in a subdirectory of <code>output.dir</code>, called <code>mc</code><em>x</em> where <em>x</em> is the identifier of that chain.  There is one file per parameter, named after the parameter with the suffix &ldquo;.txt&rdquo;, possibly followed by a compression suffix if <code>compression.type</code> is given.  Country-specific parameters have the suffix <code>_country</code><em>c</em> where <em>c</em> is the country code.  In addition to the trace files, each <code>mc</code><em>x</em> directory contains the object <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code> in binary format.  All chain-specific files  are written into disk after the first, last and each <code class="reqn">i</code>-th (thinned) iteration, where <code class="reqn">i</code> is given by the global option <code>buffer.size</code>.
</p>
<p>Using the function <code>continue.e0.mcmc</code> one can continue simulating an existing MCMCs by <code>iter</code> iterations for either all or selected chains. The global options used for generating the existing MCMCs will be used. Only the <code>auto.conf</code> option can be overwritten by passing the new value as an argument.
</p>
<p>The function loads observed data (further denoted as WPP dataset), depending on the specified sex,  from the <code><a href="wpp2019.html#topic+e0F">e0F</a></code> (<code><a href="wpp2019.html#topic+e0M">e0M</a></code>) and <code><a href="wpp2019.html#topic+e0F_supplemental">e0F_supplemental</a></code> (<code><a href="wpp2019.html#topic+e0M_supplemental">e0M_supplemental</a></code>) datasets in a <span class="pkg">wpp</span><code class="reqn">x</code> package where <code class="reqn">x</code> is the <code>wpp.year</code>. It is then merged with the  <code><a href="#topic+include">include</a></code> dataset that corresponds to the same <code>wpp.year</code>. The argument <code>my.e0.file</code> can be used to overwrite those default data. Such a file can include a subset of countries contained in the WPP dataset, as well as a set of new countries. In the former case,
the function replaces the corresponding country data from the WPP dataset with values in this file. Only columns are replaced that match column names of the WPP dataset, and in addition, columns &lsquo;last.observed&rsquo; and &lsquo;include_code&rsquo; are used, if present. Countries are merged with WPP using the column &lsquo;country_code&rsquo;. In addition, in order the countries to be included in the simulation, in both cases (whether they are included in the WPP dataset or not), they must be contained in the table of locations (<code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code>). In addition, their corresponding &lsquo;include_code&rsquo; must be set to 2. If the column &lsquo;include_code&rsquo; is present in <code>my.e0.file</code>, its value overwrites the default include code, unless is -1. 
</p>
<p>If <code>annual</code> is <code>TRUE</code> the default WPP dataset is not used and the <code>my.e0.file</code> argument must provide the dataset to be used for estimation. Its time-related columns should be single years.
</p>
<p>The default UN table of locations mentioned above can be overwritten/extended by using a file passed as the <code>my.locations.file</code> argument. Such a file must have the same structure as the <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> dataset. Entries in this file will overwrite corresponding entries in <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code> matched by the column &lsquo;country_code&rsquo;. If there is no such entry in the default dataset, it will be appended. This option of appending new locations is especially useful in cases when <code>my.e0.file</code> contains new countries/regions that are not included in <code><a href="wpp2019.html#topic+UNlocations">UNlocations</a></code>. In such a case, one must provide a <code>my.locations.file</code> with a definition of those countries/regions.
</p>
<p>For simulation of the hyperparameters of the Bayesian hierarchical model, all countries are used that are included in the WPP dataset, possibly complemented by the <code>my.e0.file</code>, that have <code>include_code</code> equal to 2. The hyperparameters are used to simulate country-specific parameters, which is done for all countries with <code>include_code</code> equal 1 or 2.  The following values of <code>include_code</code> in <code>my.e0.file</code> are recognized: -1 (do not overwrite the default include code), 0 (ignore), 1 (include in prediction but not estimation), 2 (include in both, estimation and prediction). Thus, the set of countries included in the estimation and prediction can be fully specified by the user.
</p>
<p>Optionally, <code>my.e0.file</code> can contain a column called <code>last.observed</code> containing the year of the last observation for each country. In such a case, the code would ignore any data after that time point. Furthermore, the function <code><a href="#topic+e0.predict">e0.predict</a></code> fills in the missing values using the median of the BHM procedure (stored in <code>e0.matrix.reconstructed</code> of the <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code> object). For <code>last.observed</code> values that are below a middle year of a time interval <code class="reqn">[t_i, t_{i+1}]</code> (computed as <code class="reqn">t_i+3</code>) the last valid data point is the time interval <code class="reqn">[t_{i-1}, t_i]</code>, whereas for values larger equal a middle year, the data point in <code class="reqn">[t_i, t_{i+1}]</code> is valid.
</p>
<p>The package contains a dataset called &lsquo;<span class="file">my_e0_template</span>&rsquo; (in &lsquo;<span class="file">extdata</span>&rsquo; directory) which is a template for user-specified <code>my.e0.file</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>bayesLife.mcmc.set</code> which is a list with two components:
</p>
<table>
<tr><td><code>meta</code></td>
<td>
<p>An object of class <code><a href="#topic+bayesLife.mcmc.meta">bayesLife.mcmc.meta</a></code>.</p>
</td></tr>
<tr><td><code>mcmc.list</code></td>
<td>
<p>A list of objects of class <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code>, one for each MCMC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova, Patrick Gerland contributed to the documentation.
</p>


<h3>References</h3>

<p>J. L. Chunn, A. E. Raftery, P. Gerland, H. Sevcikova (2013): Bayesian Probabilistic Projections of Life Expectancy for All Countries. Demography 50(3):777-801. &lt;doi:10.1007/s13524-012-0193-x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get.e0.mcmc">get.e0.mcmc</a></code>, <code><a href="#topic+summary.bayesLife.mcmc.set">summary.bayesLife.mcmc.set</a></code>, <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>, <code><a href="#topic+e0.predict">e0.predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m &lt;- run.e0.mcmc(nr.chains = 1, iter = 5, thin = 1, verbose = TRUE)
summary(m)
m &lt;- continue.e0.mcmc(iter = 5, verbose = TRUE)
summary(m)
## End(Not run)
</code></pre>

<hr>
<h2 id='run.e0.mcmc.extra'>
Run MCMC for Extra Countries, Areas or Regions
</h2><span id='topic+run.e0.mcmc.extra'></span>

<h3>Description</h3>

<p>Run MCMC for extra countries, areas or regions. It uses the posterior distribution of model hyperparameters from an existing simulation to generate country-specific parameters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.e0.mcmc.extra(sim.dir = file.path(getwd(), "bayesLife.output"), 
    countries = NULL, my.e0.file = NULL, 
    iter = NULL, thin = 1, burnin = 0, 
    parallel = FALSE, nr.nodes = NULL,  my.locations.file = NULL,
    country.overwrites = NULL, verbose = FALSE, verbose.iter = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run.e0.mcmc.extra_+3A_sim.dir">sim.dir</code></td>
<td>

<p>Directory with an existing simulation.
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_countries">countries</code></td>
<td>
<p>Vector of country codes. These include codes of areas and regions (see column <code>country_code</code> in <code><a href="wpp2017.html#topic+UNlocations">UNlocations</a></code>).
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_my.e0.file">my.e0.file</code></td>
<td>

<p>File name containing user-specified time series of life expectancy for countries for which the simulation should run (see Details below).
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_iter">iter</code></td>
<td>

<p>Number of iterations to be used for sampling from the posterior distribution of the hyperparameters. By default, the number of (possibly thinned) iterations used in the existing simulation is taken.
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_thin">thin</code></td>
<td>

<p>Thinning interval for sampling from the posterior distribution of the hyperparameters.
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_burnin">burnin</code></td>
<td>

<p>Number of iterations discarded before sampling from the posterior distribution of the hyperparameters.
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_parallel">parallel</code></td>
<td>

<p>Logical determining if the simulation should run multiple chains in parallel.
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_nr.nodes">nr.nodes</code></td>
<td>

<p>Relevant only if <code>parallel</code> is <code>TRUE</code>. It gives the number of nodes for running the simulation in parallel. By default it equals to the number of chains contained in the existing simulation.
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_my.locations.file">my.locations.file</code></td>
<td>
<p>File name containing user-specified locations. See Details below.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_country.overwrites">country.overwrites</code></td>
<td>
<p>This argument allows to overwrite some of the prior parameters for specific countries, stored in the global option of the same name, see <code><a href="#topic+e0mcmc.options">e0mcmc.options</a></code>. It is a data frame where each row corresponds to one country. Rows corresponding to countries that are not processed in this function are ignored.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_verbose">verbose</code></td>
<td>

<p>Logical switching log messages on and off.
</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_verbose.iter">verbose.iter</code></td>
<td>
<p>Integer determining how often (in number of iterations) log messages are outputted during the estimation.</p>
</td></tr>
<tr><td><code id="run.e0.mcmc.extra_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to the function <code>snowFT::performParallel</code>, if <code>parallel</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to make predictions for countries, areas or regions (further denoted as &lsquo;countries&rsquo;) that were not included in the MCMC estimation (invoked by <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>). It creates MCMC traces for country-specific parameters. The purpose of this function is to have country-specific parameters available in order to be able to generate projections for additional countries or their aggregations, without having to re-run the often time-expensive MCMC simulation.
</p>
<p>The set of countries to be considered by this function can be given either by their codes, using the argument <code>countries</code>, in which case the countries must be included in the UN WPP <code><a href="wpp2017.html#topic+e0">e0</a></code> dataset. Or, it can be given by a user-specific file, using the argument <code>my.e0.file</code>. The function considers a union of both arguments. The function will ignore all countries that were used in the existing MCMC simulation for estimating the hyperparameters. Countries that already own country-specific parameters (e.g. because they were included in <code>my.e0.file</code> passed to <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>) get their parameters recomputed. Note that all countries must be included in the <code><a href="wpp2017.html#topic+UNlocations">UNlocations</a></code> dataset, but unlike in <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>, their  <code>include_code</code> is ignored. As in the case of <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>, the default dataset of locations <code><a href="wpp2017.html#topic+UNlocations">UNlocations</a></code> can be overwritten using a file of the same structure as <code><a href="wpp2017.html#topic+UNlocations">UNlocations</a></code> passed via the <code>my.locations.file</code> argument. This file should be especially used, if e0 is simulated for new locations that are not included in <code><a href="wpp2017.html#topic+UNlocations">UNlocations</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>.
</p>


<h3>Note</h3>

<p>If there is an existing projection for the directory <code>sim.dir</code>, use <code><a href="#topic+e0.predict.extra">e0.predict.extra</a></code> to obtain projections for the extra countries used in this function.</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>, <code><a href="#topic+e0.predict.extra">e0.predict.extra</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m &lt;- run.e0.mcmc(nr.chains = 1, iter = 20, thin = 1, verbose = TRUE)
m &lt;- run.e0.mcmc.extra(countries = c(908,924), burnin = 10, verbose = TRUE)
summary(m, country = 924)
pred &lt;- e0.predict(burnin = 10, verbose = TRUE)
summary(pred, country = 908)
## End(Not run)
</code></pre>

<hr>
<h2 id='summary.bayesLife.convergence'>
Summary of a Life Expectancy Convergence Object
</h2><span id='topic+summary.bayesLife.convergence'></span>

<h3>Description</h3>

<p>Summary of an object of class <code><a href="#topic+bayesLife.convergence">bayesLife.convergence</a></code> created using the <code><a href="#topic+e0.diagnose">e0.diagnose</a></code> function. It gives an overview about parameters that did not converge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesLife.convergence'
summary(object, expand = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bayesLife.convergence_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.convergence">bayesLife.convergence</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.convergence_+3A_expand">expand</code></td>
<td>
<p>By default, the function does not show parameters for each country for which there was no convergence, if the status is &lsquo;red&rsquo;. This argument can switch that option on.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.convergence_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+e0.diagnose">e0.diagnose</a></code>
</p>

<hr>
<h2 id='summary.bayesLife.mcmc.set'>
Summary Statistics for Life Expectancy MCMCs
</h2><span id='topic+summary.bayesLife.mcmc.set'></span><span id='topic+print.summary.bayesLife.mcmc.set'></span><span id='topic+print.summary.bayesLife.mcmc.set.meta'></span><span id='topic+summary.bayesLife.mcmc'></span>

<h3>Description</h3>

<p>Summary of an object <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> or <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code>, computed via <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>.  It can be obtained either for all countries or for a specific country, and either for all parameters or for specific parameters.  The function uses the <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code> function of the <span class="pkg">coda</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesLife.mcmc.set'
summary(object, country = NULL, chain.id = NULL, 
    par.names = NULL, par.names.cs = NULL, meta.only = FALSE, 
    thin = 1, burnin = 0, ...)
	
## S3 method for class 'bayesLife.mcmc'
summary(object, country = NULL,
    par.names = NULL, par.names.cs = NULL, thin = 1, burnin = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code> or <code><a href="#topic+bayesLife.mcmc">bayesLife.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_country">country</code></td>
<td>
<p>Country name or code if a country-specific summary is desired. It can also be given as ISO-2 or ISO-3 characters.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_chain.id">chain.id</code></td>
<td>
<p>Identifiers of MCMC chains. By default, all chains are considered.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_par.names">par.names</code></td>
<td>
<p>Country independent parameters to be included in the summary. Run <code><a href="#topic+e0.parameter.names">e0.parameter.names</a>()</code> for defaults.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_par.names.cs">par.names.cs</code></td>
<td>
<p>Country-specific parameters to be included in the summary. Run <code><a href="#topic+e0.parameter.names.cs">e0.parameter.names.cs</a>()</code> for defaults.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_meta.only">meta.only</code></td>
<td>
<p>Logical. If it is <code>TRUE</code>, only meta information of the simulation is included.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_thin">thin</code></td>
<td>
<p>Thinning interval. Only used if larger than the <code>thin</code> argument used in <code><a href="#topic+run.e0.mcmc">run.e0.mcmc</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_burnin">burnin</code></td>
<td>
<p>Number of iterations to be discarded from the beginning of each chain before computing the summary.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.mcmc.set_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code> function of the <span class="pkg">coda</span> package.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesLife.mcmc.set">bayesLife.mcmc.set</a></code>, <code><a href="coda.html#topic+summary.mcmc">summary.mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
m &lt;- get.e0.mcmc(sim.dir)
summary(m, country="Czechia", burnin=20)

# names and codes of countries included
head(get.countries.table(m, iso = TRUE))
# using an ISO code
summary(m, country="MG", burnin=20)
</code></pre>

<hr>
<h2 id='summary.bayesLife.prediction'>
Summary of a Prediction of the Life Expectancy
</h2><span id='topic+summary.bayesLife.prediction'></span><span id='topic+print.summary.bayesLife.prediction'></span>

<h3>Description</h3>

<p>Country-specific summary of an object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>, created using the function <code><a href="#topic+e0.predict">e0.predict</a></code>. The summary contains the mean, standard deviation and several commonly used quantiles of the simulated trajectories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bayesLife.prediction'
summary(object, country = NULL, compact = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bayesLife.prediction_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.prediction_+3A_country">country</code></td>
<td>
<p>Country name or code.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.prediction_+3A_compact">compact</code></td>
<td>
<p>Logical switching between a smaller and larger number of displayed quantiles.</p>
</td></tr>
<tr><td><code id="summary.bayesLife.prediction_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesLife.prediction">bayesLife.prediction</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.dir &lt;- file.path(find.package("bayesLife"), "ex-data", "bayesLife.output")
pred &lt;- get.e0.prediction(sim.dir=sim.dir)                                                    
summary(pred, country="Iceland")

# names and codes of countries included
tail(get.countries.table(pred, iso = TRUE), 20)

# using an ISO code
summary(pred, country="CHE")
</code></pre>

<hr>
<h2 id='write.e0.projection.summary'>
Writing Projection Summary Files
</h2><span id='topic+write.e0.projection.summary'></span>

<h3>Description</h3>

<p>The function creates two files containing projection summaries, such as the median, the lower and upper bound of the 80 and 90% probability intervals, respectively, and the constant variant. One file is in a user-friendly format, whereas the other is in a UN-specific format with internal coding of the time and the variants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.e0.projection.summary(dir = file.path(getwd(), "bayesLife.output"), 
    output.dir = NULL, revision = NULL, adjusted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.e0.projection.summary_+3A_dir">dir</code></td>
<td>
<p>Directory containing the prediction object. It should correspond to the <code>output.dir</code> argument of the <code><a href="#topic+e0.predict">e0.predict</a></code> function.</p>
</td></tr>
<tr><td><code id="write.e0.projection.summary_+3A_output.dir">output.dir</code></td>
<td>
<p>Directory in which the resulting file will be stored. If <code>NULL</code> the same directory is used as for the prediction.</p>
</td></tr>
<tr><td><code id="write.e0.projection.summary_+3A_revision">revision</code></td>
<td>
<p>UN revision number. If <code>NULL</code> it is determined from the corresponding WPP year: WPP 2008 corresponds to revision 13, every subsequent WPP increases the revision number by one. Used as a constant in the second file only.</p>
</td></tr>
<tr><td><code id="write.e0.projection.summary_+3A_adjusted">adjusted</code></td>
<td>
<p>Logical. By default the function writes summary using the original BHM projections. If the projection medians are adjusted (using e.g. <code><a href="#topic+e0.median.set">e0.median.set</a></code>), setting this argument to <code>TRUE</code> causes writing the adjusted projections.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first file that the function creates is called &lsquo;<span class="file">projection_summary_user_friendly.csv</span>&rsquo;, it is a comma-separated table with the following columns: 
</p>
<ul>
<li><p>&ldquo;country_name&rdquo;: country name
</p>
</li>
<li><p>&ldquo;country_code&rdquo;: country code
</p>
</li>
<li><p>&ldquo;variant&rdquo;: name of the variant, such as &ldquo;median&rdquo;, &ldquo;lower 80&rdquo;, &ldquo;upper 80&rdquo;, &ldquo;lower 95&rdquo;, &ldquo;upper 95&rdquo;, &ldquo;constant&rdquo;
</p>
</li>
<li><p>period1: e.g. &ldquo;2010-2015&rdquo;: life expectancy for the first time period
</p>
</li>
<li><p>period2: e.g. &ldquo;2015-2020&rdquo;: life expectancy for the second time period
</p>
</li>
<li><p>... further columns with life expectancy projections
</p>
</li></ul>

<p>The second file, called &lsquo;<span class="file">projection_summary.csv</span>&rsquo;, also comma-separated table, contains the same information as above in a UN-specific format:
</p>
<ul>
<li><p>&ldquo;RevID&rdquo;: revision number, passed to the function as an argument;
</p>
</li>
<li><p>&ldquo;VarID&rdquo;: variant identifier, extracted from the <code><a href="bayesTFR.html#topic+UN_variants">UN_variants</a></code> dataset in the <span class="pkg">bayesTFR</span> package;
</p>
</li>
<li><p>&ldquo;LocID&rdquo;: country code;
</p>
</li>
<li><p>&ldquo;TimeID&rdquo;: time identifier, extracted from the <code><a href="bayesTFR.html#topic+UN_time">UN_time</a></code> dataset in the <span class="pkg">bayesTFR</span> package;
</p>
</li>
<li><p>&ldquo;e0&rdquo;: the life expectancy for this variant, location and time period.
</p>
</li></ul>

<p>If the simulation directory contains joint male predictions, summary files for those are created as well. In such a case, if <code>output.dir</code> is given, separate subdirectories for female and male are created.
</p>


<h3>Note</h3>

<p>This function is automatically called from the <code><a href="#topic+e0.predict">e0.predict</a></code> and <code><a href="#topic+e0.jmale.predict">e0.jmale.predict</a></code> functions, therefore in standard cases it will not be needed to call it directly.
</p>


<h3>Author(s)</h3>

<p>Hana Sevcikova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert.e0.trajectories">convert.e0.trajectories</a></code>, <code><a href="#topic+e0.predict">e0.predict</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
