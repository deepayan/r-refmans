<!DOCTYPE html><html lang="en"><head><title>Help for package MicSim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MicSim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MicSim-package'>
<p>MicSim: Continuous-time microsimulation for population projection</p></a></li>
<li><a href='#buildTransitionMatrix'>
<p>Determining transition pattern and transition functions</p></a></li>
<li><a href='#convertToLongFormat'>
<p>Reshaping microsimulation output into long format</p></a></li>
<li><a href='#convertToWideFormat'>
<p>Reshaping microsimulation output into wide format</p></a></li>
<li><a href='#getAgeInDays'>
<p>Get from a given date the age in days</p></a></li>
<li><a href='#getDay'>
<p>Get the day in a month (in a year) from days elapsed since 01-01-1970</p></a></li>
<li><a href='#getInDateFormat'>
<p>Get date in the format 'yyyyddmm' from days elapsed since 01-01-1970</p></a></li>
<li><a href='#getInDays'>
<p>Get from a date given in the numeric format yyyymmdd the number of days elapsed since 1970-01-01</p></a></li>
<li><a href='#getInDays_my'>
<p>Get the number of days that have pasted from 1970-01-01 until 'yyyymm11'.</p></a></li>
<li><a href='#getMonth'>
<p>Get the month in a year from days elapsed since 01-01-1970</p></a></li>
<li><a href='#getYear'>
<p>Get the calendar year from days elapsed since 01-01-1970</p></a></li>
<li><a href='#immigrPopMigrExp'>
<p>One possible population of migrants for the MicSim package.</p></a></li>
<li><a href='#initPopMigrExp'>
<p>One possible initial population for the MicSim package.</p></a></li>
<li><a href='#micSim'>
<p>Run microsimulation (sequentially)</p></a></li>
<li><a href='#micSimParallel'>
<p>Run microsimulation (parallel computing)</p></a></li>
<li><a href='#migrExpRates'>
<p>Transition rates for migration example of MicSim package.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Performing Continuous-Time Microsimulation</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-23</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sabine Zinn &lt;szinn@diw.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This toolkit allows performing continuous-time microsimulation for a wide range of life science (demography, social sciences, epidemiology) applications. Individual life-courses are specified by a continuous-time multi-state model as described in Zinn (2014) &lt;<a href="https://doi.org/10.34196%2FIJM.00105">doi:10.34196/IJM.00105</a>&gt;. </td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), snowfall, rlecuyer</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, glue</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-23 13:09:43 UTC; Freddie</td>
</tr>
<tr>
<td>Author:</td>
<td>Sabine Zinn [aut, cre],
  Claudio Bosco [ctb],
  Maurizio Teobaldell [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-23 17:02:50 UTC</td>
</tr>
</table>
<hr>
<h2 id='MicSim-package'>
MicSim: Continuous-time microsimulation for population projection
</h2><span id='topic+MicSim-package'></span><span id='topic+MicSim'></span>

<h3>Description</h3>

<p>In life sciences, the central device of microsimulations is the life-course of an individual, which is defined by the sequence of states that the individual visits over time, and the waiting times between these state transitions. Modelling and simulating the life courses of a representative share of population members allows mapping population dynamics on a very detailed scale.
</p>
<p>A standard approach to describe individual behavior is a continuous-time multi-state model. A multi-state model is a stochastic process that at any point in time occupies one out of a set of discrete states. These states summarize the demographically relevant categories an individual can belong to. Generally, the state space is determined by the problem to be studied, but commonly it will at least comprise the elementary demographic characteristics of sex and marital status. One element always present in the state space is &quot;dead&quot;, a risk to which each individual is always exposed to.
</p>
<p>In (demographic) microsimulations life-courses usually evolve along two time scales: individual age and calendar time. A possible third time scale is the time that an individual has already spent in his/her current state, e.g., the time that has elapsed since an individual's wedding. An event implies a change in the state of an individual. Age always runs parallel to the process time of a model. Therefore birthday, i.e., the completion of another year of life, is not an event in itself. 
</p>
<p>A common way to characterize an individual life-course is via a trajectory of a stochastic process from the family of Markovian processes, where the process time maps the time span over which we &quot;observe&quot; an individual life-course. The MicSim package uses time-inhomogeneuous Markov models to describe individual life-courses. That way, transition intensities can vary at each point in time, i.e. are not assumed to be constant for predefined time intervals (such as whole years).
</p>
<p>The transition intensities (also denoted as hazard rates or transition rates) of Markovian processes are their key quantities. Once they are known one can compute the distribution functions of sojourn times and thus simulate synthetic life-courses. That is, to run a microsimulation model, for all transitions and time scales considered transition rates have to be provided. A whole bunch of statistical estimation approaches exist to estimate transition rates from (e.g., register, survey, panel) data. Furthermore, also methods for approximating transition rates from probabilities are available, e.g. by assuming that they are constant in the interval covered by a probability, yielding the so called exponential model. More details on this are given in the description of the &lsquo;micsim&rsquo; function of this package, which is the actual workhorse of this toolkit. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> MicSim</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-23</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Sabine Zinn
</p>
<p>Maintainer: szinn@diw.de
</p>


<h3>References</h3>

<p>S. Zinn (2014). The MicSim Package of R: An Entry-Level Toolkit for Continuous-Time Microsimulation. In International Journal of Microsimulation 7(3), 3-32.
</p>
<p>Willekens, F., &amp; Putter, H. (2014). Software for multistate analysis. Demographic Research, 31, 381-420. 
</p>

<hr>
<h2 id='buildTransitionMatrix'>
Determining transition pattern and transition functions 
</h2><span id='topic+buildTransitionMatrix'></span>

<h3>Description</h3>

<p>The function <code>buildTransitionMatrix</code> supports the constructing of the &lsquo;transition matrix&rsquo;, which determines the transition pattern of the microsimulation model. The actual microsimulation is performed by <a href="#topic+micSim">micSim</a> (sequentially) or by <a href="#topic+micSimParallel">micSimParallel</a> (parallel computing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildTransitionMatrix(allTransitions, absTransitions, stateSpace)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildTransitionMatrix_+3A_alltransitions">allTransitions</code></td>
<td>

<p>A matrix comprising all possible transitions between values of state variables in the first column and in the second column the names of the functions defining the corresponding transition rates.
</p>
</td></tr>
<tr><td><code id="buildTransitionMatrix_+3A_abstransitions">absTransitions</code></td>
<td>

<p>A matrix comprising the names of the absorbing states which individuals are always exposed to (such as &quot;dead&quot;&quot; and emigrated labeled as &quot;rest&quot;) in the first column and in the second column the names of the functions defining the corresponding transition rates. 
</p>
</td></tr>
<tr><td><code id="buildTransitionMatrix_+3A_statespace">stateSpace</code></td>
<td>

<p>A matrix comprising all nonabsorbing states considered during simulation. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>buildTransitionMatrix</code> is an auxiliary function for building the transition matrix required to run the microsimulation using <a href="#topic+micSim">micSim</a> or <a href="#topic+micSimParallel">micSimParallel</a>. 
</p>
<p>In <code>stateSpace</code> all state variables considered during simulation including their values have to be defined. Values are always described using labels. For example, label &quot;M&quot; for being married. Each column of <code>stateSpace</code> refers to one state variable considered and each row refers to one state of the state space. Apart from &quot;m&quot; and &quot;f&quot; reserved for male and female (state variable: gender) and &quot;no&quot; and &quot;low&quot; reserved for no education and elementary school attended (state variable: educational attainment), labels can be set arbitrarily.
</p>
<p>Each element of the first column of <code>allTransitions</code> has to be of the form &quot;A-&gt;B&quot; with indicating &quot;A&quot; the starting value of a transition and &quot;B&quot; the arrival value. (&quot;-&gt;&quot; is the placeholder defined to mark a transition.) For example, &quot;0&quot; (childless) describes the starting value of the transition marking a first birth event and &quot;1&quot; (first child) its arrival value. All value labels used have to be identical to the value labels of the state variables specifying the simulation model.
</p>
<p>All absorbing states listed in the first column of <code>absTransitions</code> have to be given as strings such as &quot;dead&quot; for being dead or &quot;rest&quot; for emigrated. Since dying is a competing risk all individuals are always exposed to, &quot;dead&quot; is a mandatory part of <code>absTransitions</code>.
</p>
<p>All transitions can be defined to depend on several state variables. For example, a divorce rate depends on gender and on the fertility status. Therefore, the starting value and the arrival value of a transition have to be specified as a combination of the considered attributes, separated by a forward slash and in accordance with the ordering of the state variables in the state space. For example, &quot;f/A-&gt;f/B&quot; describes a female specific transition from &quot;A&quot; to &quot;B&quot; and &quot;f/M/1 -&gt; f/D/1&quot; might describe a mother's (indicated by &quot;1&quot;) transition from &quot;M&quot; (e.g., married) to &quot;D&quot; (e.g., divorced).
For absorbing states, a prefix indicates the attributes on which a transition is assumed to depend (also separated by forward slashs), e.g., &quot;f/dead&quot; and &quot;m/dead&quot; describe gender specific mortality transitions and &quot;f/M/dead&quot; and &quot;m/M/dead&quot; indicate gender specific mortality rates for married persons. 
</p>


<h3>Value</h3>

<p>The <code>transitionMatrix</code> that is mandatory to perform a microsimulation run by <a href="#topic+micSim">micSim</a> (sequentially) or by <a href="#topic+micSimParallel">micSimParallel</a> (parallel computing) is returned. The matrix has as many rows as the simulation model comprises nonabsorbing states and as many columns as the simulation model comprises absorbing and nonabsorbing states. The rows indicate starting states of transitions and the columns signify arrival states. At positions indicating impossible transitions, the matrix contains zeros. Otherwise the name of the function defining the respective transition rates is given.  
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#########################################################################################
# 1. Example: Transition rates are specified to depend on only one state variable
#########################################################################################

# Defintion of state space, i.e., nonabsorbing and absorbing states
sex &lt;- c("m","f")                     
fert &lt;- c("0","1","2","3+")           
marital &lt;- c("NM","M","D","W")        
edu &lt;- c("no","low","med","high")   
stateSpace &lt;- expand.grid(sex=sex,fert=fert,marital=marital,edu=edu)

# Possible transitions indicating fertility behavior are "0-&gt;1", "1-&gt;2", "2-&gt;3+", 
# and "3+-&gt;3+". Here, "-&gt;" is the defined placeholder defining a transition.
# `fert1Rates' marks the name of the function defining the transition rates to 
# parity one and `fert2Rates' marks the name of the function defining the transition 
# rates to higher parities. 
# Note: The functions `fert1Rates' and `fert1Rates' are transition rate functions 
# defined by the user. Their naming depends on the user's choice.
fertTrMatrix &lt;- cbind(c("0-&gt;1","1-&gt;2","2-&gt;3+","3+-&gt;3+"),                         
                c("fert1Rates", "fert2Rates", "fert2Rates","fert2Rates"))

# Possible transitions indicating changes in the marital status are "NM-&gt;M", "M-&gt;D", 
# "M-&gt;W", "D-&gt;M", and "W-&gt;M".
# `marriage1Rates' marks the name of the function defining the transition rates for first 
# marriage and `marriage2Rates' marks the name of the function defining the transition rates 
# for further marriages. `divorceRates' marks the name of the function defining divorce 
# rates and `widowhoodRates' marks the name of the function describing transition rates to 
# widowhood. 
# Note: The functions `marriage1Rates',`marriage2Rates', `divorceRates', and 
# `widowhoodRates' are transition rate functions defined by the user. 
# Their naming depends on the user's choice.
maritalTrMatrix &lt;- cbind(c("NM-&gt;M","M-&gt;D","M-&gt;W","D-&gt;M","W-&gt;M"),              
                   c("marriage1Rates","divorceRates","widowhoodRates","marriage2Rates",
                     "marriage2Rates"))
                   
# Possible transitions indicating changes in the educational attainment are "no-&gt;low", 
# "low-&gt;med", and "med-&gt;high". 
# `noToLowEduRates' marks the name of the function defining transition rates for accessing 
# primary education, `noToLowEduRates' marks the name of the function defining transition 
# rates for graduating with a lower secondary education, and `medToHighEduRates' marks the 
# name of the function defining transition rates for graduating with a higher secondary 
# education.
# Note: The functions `noToLowEduRates',`noToLowEduRates', and `medToHighEduRates' are 
# transition rate functions defined by the user. Their naming depends on the user's 
# choice.                  
eduTrMatrix &lt;- cbind(c("no-&gt;low","low-&gt;med","med-&gt;high"),
               c("noToLowEduRates","noToLowEduRates","medToHighEduRates")) 
               
# Combine all possible transitions and the related transition function into one matrix.          
allTransitions &lt;- rbind(fertTrMatrix, maritalTrMatrix, eduTrMatrix)

# Possible absorbing states are `dead' and `rest'. (The latter indicates leaving the 
# population because of emigration). The accordant transition rate functions are named 
# `mortRates' and `emigrRates'. (Again, naming is up to the user.)
absTransitions &lt;- rbind(c("dead","mortRates"),c("rest","emigrRates"))

# Construct `transition matrix'.
transitionMatrix &lt;- buildTransitionMatrix(allTransitions,absTransitions,stateSpace)

#########################################################################################
# 2. Example: Transition rates are gender specific
#########################################################################################
# Defintion of nonabsorbing and absorbing states
sex &lt;- c("m","f")                               
stateX &lt;- c("H","P")        
stateSpace &lt;- expand.grid(sex=sex,stateX=stateX)
absStates &lt;- c("dead")   

# Transitions indicating changes in `stateX'. 
# We assume distinct transition rates for females and males.
# Note: The functions `ratesHP_f',`ratesHP_m', `ratesPH_f', and 
# `ratesPH_m' are transition rate functions defined by the user. 
trMatrix_f &lt;- cbind(c("f/H-&gt;f/P","f/P-&gt;f/H"),c("ratesHP_f", "ratesPH_f"))
trMatrix_m &lt;- cbind(c("m/H-&gt;m/P","m/P-&gt;m/H"),c("ratesHP_m", "ratesPH_m"))
allTransitions &lt;- rbind(trMatrix_f,trMatrix_m)

# We assume gender specific mortality rates.
# Note: The naming and specification of the respective mortality rate functions 
# `mortRates_f' and `mortRates_m' depend on the user.
absTransitions &lt;- rbind(c("f/dead","mortRates_f"), c("m/dead","mortRates_m"))

transitionMatrix &lt;- buildTransitionMatrix(allTransitions=allTransitions,
                      absTransitions=absTransitions, stateSpace=stateSpace)



</code></pre>

<hr>
<h2 id='convertToLongFormat'>
Reshaping microsimulation output into long format
</h2><span id='topic+convertToLongFormat'></span>

<h3>Description</h3>

<p>The function reshapes the output given by <a href="#topic+micSim">micSim</a> or by <a href="#topic+micSimParallel">micSimParallel</a> into long format. In long format, the data comprises for each episode which an individual experiences one row. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToLongFormat(pop,migr=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertToLongFormat_+3A_pop">pop</code></td>
<td>

<p>The data frame <code>pop</code> contains the whole synthetic population considered during simulation including all events generated. For each individidual <code>pop</code> contains as many rows as the individual performed transitions during simulation.  
</p>
</td></tr>
<tr><td><code id="convertToLongFormat_+3A_migr">migr</code></td>
<td>

<p>A logical variable indicating whether the simulation model considers immigration. The default setting is &quot;no immigration considered&quot;: <code>migr=FALSE</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>convertToLongFormat</code> uses information from the definition of the microsimulation model. In particular, it uses <code>stateSpace</code>, <code>absTransitions</code>, <code>allTransitions</code>, <code>simHorizon</code>, and optionally <code>immigrPop</code>. (For a description of these objects see <a href="#topic+micSim">micSim</a>.) <code>stateSpace</code>, <code>absTransitions</code>, <code>allTransitions</code>,  <code>simHorizon</code>, and <code>immigrPop</code> are globally defined, i.e., they are already part of the workspace. Thus, they do not have to be given to <code>convertToLongFormat</code> as extra input parameters.  
</p>


<h3>Value</h3>

<p>A data frame comprising the microsimulation output in long format.
</p>
<p>- <code>ID</code> is the unique numerical person identifier of an individual.
</p>
<p>- <code>birthDate</code> is the birth date of an individual.
</p>
<p>- The variables <code>Tstart</code> and <code>Tstop</code> mark the start und the ending dates of episodes.   
</p>
<p>- <code>statusEntry</code> specifies whether the entry into an episode has been observed. Value &quot;1&quot; marks an observed entry and &quot;0&quot; marks a left truncated episode.
</p>
<p>- <code>statusExit</code> specifies whether a transition between two states or right censoring completed an episode. Value &quot;1&quot; indicates a transition and &quot;0&quot; a censoring event. 
</p>
<p>- <code>OD</code> names the transition which completed an episode. Here, right censoring is marked by &quot;cens&quot;.  
</p>
<p>- <code>ns</code> gives the number of episodes an individual has passed.
</p>
<p>- <code>Episode</code> enumerates the episodes an individual has passed.
</p>
<p>- The last columns of the data frame contain for each individual and episode the values of the state variables during that episode such as &lsquo;sex&rsquo;, &lsquo;education&rsquo;, etc. 
</p>
<p>- Birth and transition times are given as calendar dates in form of chron objects.
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run microsimulation before, e.g., the complex example described on the 
# help page of the function "micSim".
## Not run: 
pop &lt;- micSim(initPop, immigrPop, transitionMatrix, absStates, initStates, initStatesProb, 
        maxAge, simHorizon, fertTr)
popLong &lt;- convertToLongFormat(pop,migr=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='convertToWideFormat'>
Reshaping microsimulation output into wide format
</h2><span id='topic+convertToWideFormat'></span>

<h3>Description</h3>

<p>The function reshapes the output given by <a href="#topic+micSim">micSim</a> or by <a href="#topic+micSimParallel">micSimParallel</a> into wide format. In wide format, the data comprises for each episode which an individual experiences additional column entries. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToWideFormat(pop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertToWideFormat_+3A_pop">pop</code></td>
<td>

<p>The data frame <code>pop</code> contains the whole synthetic population considered during simulation including all events generated. For each individidual <code>pop</code> contains as many rows as the individual performed transitions during simulation.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame comprising the microsimulation output in wide format.
</p>
<p>- <code>ID</code> is the unique numerical person identifier of an individual.
</p>
<p>- <code>birthDate</code> is the birth date of an individual.
</p>
<p>- <code>initState</code> is the state in which an individual initially entered the virtual population of the simulation.  
</p>
<p>- <code>ns</code> gives the number of (completed) episodes an individual has passed.
</p>
<p>- The variables <code>From.i</code> and <code>To.i</code> mark the start und the arrival state of the transition corresponding to episode <code>i</code>. The variables <code>transitionTime.i</code> and <code>transitionAge.i</code> give the corresponding transition time and age. The enumerator <code>i</code> ranges from 1 to the maximal number of transitions which an individual experienced during simulation. Only completed episodes are counted.  
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run microsimulation before, e.g., the complex example described on the 
# help page of the function "micSim".
## Not run: 
pop &lt;- micSim(initPop, immigrPop, transitionMatrix, absStates, initStates,    
    initStatesProb, maxAge, simHorizon, fertTr)
popWide &lt;- convertToWideFormat(pop)

## End(Not run)

</code></pre>

<hr>
<h2 id='getAgeInDays'>
Get from a given date the age in days
</h2><span id='topic+getAgeInDays'></span>

<h3>Description</h3>

<p>Function computes for a given date the correct age in days.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAgeInDays(currDate, birthDate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getAgeInDays_+3A_currdate">currDate</code></td>
<td>

<p>Reference date given as string of the format &quot;yyyymmdd&quot;. 
</p>
</td></tr>
<tr><td><code id="getAgeInDays_+3A_birthdate">birthDate</code></td>
<td>

<p>Birth date given as string of the format &quot;yyyymmdd&quot;. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correct age at the specific date <code>currDate</code> in days 
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getAgeInDays("20200826", "19800605")
</code></pre>

<hr>
<h2 id='getDay'>
Get the day in a month (in a year) from days elapsed since 01-01-1970
</h2><span id='topic+getDay'></span>

<h3>Description</h3>

<p>Function computes from days elapsed since 01-01-1970 the day in a month (in a year).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDay(daysSince01011970)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDay_+3A_dayssince01011970">daysSince01011970</code></td>
<td>

<p>Days elapsed since 1970-01-01
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Day in a month (in a year) computed from days elapsed since 01-01-1970
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getDay(2561)
</code></pre>

<hr>
<h2 id='getInDateFormat'>
Get date in the format 'yyyyddmm' from days elapsed since 01-01-1970
</h2><span id='topic+getInDateFormat'></span>

<h3>Description</h3>

<p>Function generates from days elapsed since 01-01-1970 the date in the string format 'yyyyddmm'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInDateFormat(daysSince01011970)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getInDateFormat_+3A_dayssince01011970">daysSince01011970</code></td>
<td>

<p>Days elapsed since 1970-01-01
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Date in string format 'yyyyddmm' from days elapsed since 01-01-1970
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getInDateFormat(2561)
</code></pre>

<hr>
<h2 id='getInDays'>
Get from a date given in the numeric format yyyymmdd the number of days elapsed since 1970-01-01
</h2><span id='topic+getInDays'></span>

<h3>Description</h3>

<p>Function computes the days that have pasted since 1970-01-01 up to the currDate (in the numeric format yyyymmdd)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInDays(currDate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getInDays_+3A_currdate">currDate</code></td>
<td>

<p>Date given as string of the numeric format yyyymmdd. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of days elapsed since 1970-01-01.
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getInDays(20200826)
</code></pre>

<hr>
<h2 id='getInDays_my'>
Get the number of days that have pasted from 1970-01-01 until 'yyyymm11'.
</h2><span id='topic+getInDays_my'></span>

<h3>Description</h3>

<p>Function computes the number of days that have pasted from 1970-01-01 until 'yyyymm11'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInDays_my(year, month)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getInDays_my_+3A_year">year</code></td>
<td>

<p>Year for which days elapsed should be computed, i.e., the yyyy in 'yyyymm11' 
</p>
</td></tr>
<tr><td><code id="getInDays_my_+3A_month">month</code></td>
<td>

<p>Month for which days elapsed should be computed, i.e., the mm in 'yyyymm11' 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of days that have pasted from 1970-01-01 until 'yyyymm11' 
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getInDays_my(2020, 12)
</code></pre>

<hr>
<h2 id='getMonth'>
Get the month in a year from days elapsed since 01-01-1970
</h2><span id='topic+getMonth'></span>

<h3>Description</h3>

<p>Function computes from days elapsed since 01-01-1970 the related month a year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMonth(daysSince01011970)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMonth_+3A_dayssince01011970">daysSince01011970</code></td>
<td>

<p>Days elapsed since 1970-01-01
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Month in a year computed from days elapsed since 01-01-1970
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getMonth(2561)
</code></pre>

<hr>
<h2 id='getYear'>
Get the calendar year from days elapsed since 01-01-1970
</h2><span id='topic+getYear'></span>

<h3>Description</h3>

<p>Function computes from days elapsed since 01-01-1970 the related calendar year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getYear(daysSince01011970)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getYear_+3A_dayssince01011970">daysSince01011970</code></td>
<td>

<p>Days elapsed since 1970-01-01
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Calendar year from days elapsed since 01-01-1970
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getYear(2561)
</code></pre>

<hr>
<h2 id='immigrPopMigrExp'>
One possible population of migrants for the MicSim package.
</h2><span id='topic+immigrPopMigrExp'></span>

<h3>Description</h3>

<p>Population of migrants for the MicSim package with 3758 migrants and migration dates between 01-01-2014 and 30-12-2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("immigrPopMigrExp")</code></pre>


<h3>Format</h3>

<p>A data frame with information of birthdates, date of immigration and state at   immigration of 3758 migrants.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>Personal identifier</p>
</dd>
<dt><code>immigrDate</code></dt><dd><p>Immigration date</p>
</dd>
<dt><code>birthDate</code></dt><dd><p>Birth date of migrants</p>
</dd>
<dt><code>immigrInitState</code></dt><dd><p>State at immigration</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a example data set for the MicSim package. The population of migrants is already in the format that is required by the package. For more details on this see <a href="#topic+micSim">micSim</a>. The state space for the states and the related state domains are defined in the vignette of this package. The related application is also part of the vignette.
</p>


<h3>Source</h3>

<p>European Commission
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(immigrPopMigrExp)
</code></pre>

<hr>
<h2 id='initPopMigrExp'>
One possible initial population for the MicSim package.
</h2><span id='topic+initPopMigrExp'></span>

<h3>Description</h3>

<p>Initial population for the MicSim package with 72965 persons with birthdates from 08-03-1914 to 30-12-2013.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("initPopMigrExp")</code></pre>


<h3>Format</h3>

<p>A data frame with information of birthdates, date of immigration and state at   immigration of 3758 migrants.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>Personal identifier</p>
</dd>
<dt><code>birthDate</code></dt><dd><p>Birth date of entity</p>
</dd>
<dt><code>initState</code></dt><dd><p>Initial state</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a example data set for the MicSim package. The initial population is already in the format that is required by the package. For more details on this see <a href="#topic+micSim">micSim</a>.
The state space for the states and the related state domains are defined in the vignette of this package. The related application is also part of the vignette.
</p>


<h3>Source</h3>

<p>European Commission
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(initPopMigrExp)
</code></pre>

<hr>
<h2 id='micSim'>
Run microsimulation (sequentially)
</h2><span id='topic+micSim'></span>

<h3>Description</h3>

<p>Performs a continuous-time microsimulation run (sequentially, i.e., using only one CPU core).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>micSim(initPop, immigrPop=NULL, transitionMatrix, absStates=NULL, 
        fixInitStates = c(), varInitStates=c(), initStatesProb=c(), 
        maxAge=99, simHorizon, fertTr=c(), monthSchoolEnrol=c())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="micSim_+3A_initpop">initPop</code></td>
<td>

<p>Data frame comprising the starting population of the simulation.
</p>
</td></tr>
<tr><td><code id="micSim_+3A_immigrpop">immigrPop</code></td>
<td>

<p>Data frame comprising information about the immigrants entering the population across simulation time. 
</p>
</td></tr>
<tr><td><code id="micSim_+3A_transitionmatrix">transitionMatrix</code></td>
<td>

<p>A matrix indicating the transition pattern and the names of the functions determining the respective transition rates (with rates to be returned as vectors, i.e. for input age 0 to 10 eleven rate values have to be returned).
</p>
</td></tr>
<tr><td><code id="micSim_+3A_absstates">absStates</code></td>
<td>

<p>A vector indicating the absorbing states of the model.
</p>
</td></tr>
<tr><td><code id="micSim_+3A_fixinitstates">fixInitStates</code></td>
<td>

<p>(Vector of) Indices of substates determining the attributes/substates that a newborn will be taken over from the mother.
If empty or not defined, no attributes will be inherited.
</p>
</td></tr>
<tr><td><code id="micSim_+3A_varinitstates">varInitStates</code></td>
<td>

<p>(A vector comprising the) Substates / attributes that are assigned to a newborn randomly according to the probabilities <code>initStatesProb</code>, i.e. that are not inherited from the mother. 
</p>
</td></tr>
<tr><td><code id="micSim_+3A_initstatesprob">initStatesProb</code></td>
<td>

<p>A vector comprising the probabilities corresponding to <code>varInitStates</code>. 
If <code>fixInitStates</code> are given (i.e. attributes from the mother are inherited), these probabilities have to sum to one   conditioned on the inherited attributes, i.e. for  each (set of) inherited attribute(s) separately. Otherwise, the sum of <code>initStatesProb</code> has to be one.
</p>
</td></tr>
<tr><td><code id="micSim_+3A_maxage">maxAge</code></td>
<td>

<p>A scalar indicating the exact maximal age (i.e., sharp 100.00 years) which an individual can reach during simulation. <code>maxAge</code> has to be greater than zero. 
</p>
</td></tr>
<tr><td><code id="micSim_+3A_simhorizon">simHorizon</code></td>
<td>

<p>A vector comprising the starting and ending date of the simulation. Both dates have to be given as strings in the format &lsquo;yyyymmdd&rsquo;. The starting date has to precede the ending date.
</p>
</td></tr>
<tr><td><code id="micSim_+3A_ferttr">fertTr</code></td>
<td>

<p>A vector indicating all transitions triggering a child birth event during simulation, that is, the creation of a new individual. 
</p>
</td></tr>
<tr><td><code id="micSim_+3A_monthschoolenrol">monthSchoolEnrol</code></td>
<td>

<p>The month (as numeric value from 1 to 12) indicating the general enrollment month for elementary school, e.g., 9 for September. If transition to elementary school is not defined (see below under &lsquo;details&rsquo;) and no such month is given school enrollment to elementary school is not modelled / simulated. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All nonabsorbing states considered during simulation have to be defined as composite states. In more detail, they consist of labels indicating values of state variables. Within states, labels are separated by a forward slash &quot;/&quot;. Possible state variables are, for example, gender, number of children ever born, and educational attainment. Corresponding values are, for example, &quot;m&quot; and &quot;f&quot; (gender), &quot;0&quot;,&quot;1&quot;,&quot;2&quot;, and &quot;3+&quot; (number of children ever born), &quot;no&quot;, &quot;low&quot;, &quot;med&quot;, and &quot;high&quot; (educational attainment). Possible examples of states are &quot;m/0/low&quot; for a childless male with elementary education  or &quot;f/1/high&quot; for a female with one child and a higher secondary school degree. All state variables considered plus accordant value labels have to be provided by the user. The only exception is gender which is predefined by labels &quot;m&quot; and &quot;f&quot; indicating male and female individuals. The label values &quot;no&quot; and &quot;low&quot; are reserved for enrolment events to elementary school (see below).
</p>
<p>Nonabsorbing states have to be given as strings such as &quot;dead&quot; for being dead or &quot;rest&quot; for emigrated.
</p>
<p><code>micSim</code> is able to conduct enrollment events to elementary school such that they take place on the first day of the <code>monthSchoolEnrol</code>th month of a particular year. For this purpose, a state variable defining educational attainment has to be created first. Then, labels of possible values have to be defined such that &quot;no&quot; describes no education and &quot;low&quot; describes elementary education. Finally, the transition function determining the transition rate for the respective enrollment event has to be defined to return &quot;Inf&quot; for the age x at which children should be enrolled (e.g., at age seven) and zero otherwise. That way, an event &quot;school enrollment on <code>dateSchoolEnrol</code> of the year in which a child turns x years old&quot; is enforced. A related illustration is given below in the second example.
</p>
<p>If school enrollment is not of interest to the modeller, <code>monthSchoolEnrol</code> can let be unspecified. Then during simulation that feature is ignored. 
</p>
<p>The starting population <code>initPop</code> has to be given in the form of a data frame. Each row of the data frame corresponds to one individual. <code>initPop</code> has to comprise the following information: 
unique numerical person identifier (ID), birth date, and initial state (i.e., the state occupied by the individual when entering the synthetic population). Birth dates have to be given as strings in the format &lsquo;yyyymmdd&rsquo;, e.g. &lsquo;20220815&rsquo; for Aug 15th 2022. Be aware that at simulation starting date all individuals in the initial population have already to be born and younger than <code>maxAge</code>. Otherwise, <code>micSim</code> throws an error message pointing to this issue. 
</p>
<p>Information about immigrants has to be given in the form of a data frame (<code>immigrPop</code>). Each row of the data frame corresponds to one immigrant.
<code>immigrPop</code> contains the following data: unique numerical person identifier (ID), immigration date, birth date, and initial state (i.e., the state occupied by the immigrant when entering the simulated population). Immigration dates and birth dates have to provided as strings in the format &lsquo;yyyymmdd&rsquo;, e.g. &lsquo;20220815&rsquo; for Aug 15th 2022. Immigration dates have to be specified to occur after simulation starting date and before simulation stopping date. Immigrants must be born when they migrate. Otherwise, <code>micSim</code> throws error messages pointing to this issues.   
</p>
<p>For each transition that should be considered during simulation accordant transition rates have to be provided. Since MicSim's model is a continuous-time multi-state model these rates are transition intensities (as also used for defining time-inhomogeneuous Markov models) and not probabilities. Palloni (2000) illustrates very well the difference between both concepts. Zinn (2011) describes methods for estimating rates for MicSim's model. A crude way of transforming transition probabilities to rates is assuming that the rates <code class="reqn">lambda_{ij}</code> (for leaving state <code class="reqn">i</code> to enter state <code class="reqn">j</code>) are constant in the time interval (of length <code class="reqn">t</code>) captured by a corresponding probability <code class="reqn">p_{ij}</code>:
</p>
<p><code class="reqn">p_{ij} = 1 - exp(- lambda_{ij} * t)</code> which yields <code class="reqn">lambda_{ij} = - 1/t * ln(1-p_{ij})</code>.
</p>
<p>Be aware that this is only an approximation since this formula belongs to a time-homogeneuous Markov model and not to the more flexible time-inhomogeneuous Markov model (as used by MicSim). Thus, here for the time interval covered by <code class="reqn">p_{ij}</code> a time-homogeneuous Markov model is assumed. Many users may have annual transition probabilities at hand, i.e., <code class="reqn">t=1</code>. 
</p>
<p><code>micSim</code> requires these rates in form of functions which are handed over via the transition matrix <code>transitionMatrix</code> (described in the subsequent paragraph). The <code>MicSim</code> package allows rates to depend on three time scales: age, calendar time, and the time that has elapsed since the last change of a particular state variable (e.g., the time elapsed since wedding). 
In accordance therewith, <code>micSim</code> requires transition rates functions to feature three input parameters, namely <code>age</code>, <code>calTime</code>, and <code>duration</code>.
Via <code>age</code> the age of an individual is handed over, via <code>caltime</code> the calendar time, and via <code>duration</code> the time that has elapsed since the last change of the affected state variable. 
All three input parameters might vary, or only one or two of them.
Also none of the input parameters can be specified to vary, i.e., transition rates can be defined to be constant. 
Since <code>micSim</code> computes integrals of rates along simulation procedure, the rates functions must deliver vector of rates for vectors of inputs, i.e. for an input vector of ages (e.g. ages [0,1,2,3]) the rates functions have to given as many rate values as is the length of the age vector (in the example, four rate values). More details on this are given in the examples below or in the vignette to this package. 
If rates are assumed to be independent of a specific time scale, the corresponding input argument can simply be ignored within the body of the rates function (i.e., is not used to determine a specific rate value).
For illustration, see the examples in the example section. 
Beware that rates for age have to be delivered at maximal only until <code>maxAge</code>. If *more* rates are given, this does not cause an error but they are not used.  
Note that allowing transition rates to vary along the time elapsed since a last transition facilitates modelling gestation gaps after a delivery: For a period of nine or ten months transition rates for higher order parities are simply set to zero (e.g., see the complex example in the example section).  
</p>
<p>The transition matrix <code>transitionMatrix</code> has as many rows as the simulation model comprises nonabsorbing states and as many columns as the simulation model comprises absorbing and nonabsorbing states. The rows of <code>transitionMatrix</code> mark starting states of transitions and the columns mark arrival states. At positions of <code>transitionMatrix</code> indicating impossible transitions, the matrix contains zeros. Otherwise the name of the function determining the respective transition rates has to be given. The function <a href="#topic+buildTransitionMatrix">buildTransitionMatrix</a> supports the construction of <code>transitionMatrix</code>.
</p>
<p>If, during simulation, an individual reaches <code>maxAge</code>, he/she stays in his/her current state until simulation ending date is reached, that is, the respective individual is no longer at risk of experiencing any events and his/her ongoing episode will be censored at simlation ending date.  
</p>
<p>Each element of <code>fertTr</code> has to be of the form &quot;A-&gt;B&quot;, that is, &quot;A&quot; indicates the starting attribute of the transition and &quot;B&quot; the arrival attribute. (&quot;-&gt;&quot; is the placeholder defined to mark a transition.) For example, &quot;0&quot; (childless) gives the starting point of the transition marking a first birth event and &quot;1&quot; (first child) its arrival point. All fertility attributes given in <code>fertTr</code> have to be part of the state variable specifiying fertility in the state space. That is, if there is none, <code>fertTr</code> is empty: <code>fertTr=c()</code>.
</p>


<h3>Value</h3>

<p>The data frame <code>pop</code> contains the whole synthetic population considered during simulation including all events generated. In more detail, <code>pop</code> contains as many rows as there are transitions performed by the individuals. Also, &quot;entering the population&quot; is considered as an event. In general, individuals can enter the simulation via three channels: by being part of the starting population, by immigration, and by being born during simulation. If fertility events are part of the model's specification (i.e., <code>fertTr</code> is not empty), <code>pop</code> contains an additional column indicating the ID of the mother for individuals born during simulation. For all other individuals, the ID of the mother is unknown (i.e., set to &lsquo;NA&rsquo;).
</p>
<p>The function <a href="#topic+convertToLongFormat">convertToLongFormat</a> reshapes the microsimulation output into long format, while the function <a href="#topic+convertToWideFormat">convertToWideFormat</a> gives the microsimulation in wide format. 
</p>


<h3>Note</h3>

<p>For large-scale models and simulation, I recommend parallel computing using <a href="#topic+micSimParallel">micSimParallel</a>. This speeds up execution times considerably.
However, before running an extensive simulation on multiple cores, the package user should definitely check whether the input for the simulation fits. 
This can best be achieved by first running a short and less extensive simulation with only one core (e.g., running only a one percent sample of the initial population).</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>References</h3>

<p>Palloni, A. (2001). Increment-Decrement Life Tables. In: Preston, S., Heuveline, P., &amp; Guillot, M. (eds). Demography: measuring and modeling population processes. Malden, MA: Blackwell Publishers.
</p>
<p>Zinn, S. (2011). Preparation of required input data. In: Zinn, S. A Continuous-Time Microsimulation and First Steps Towards a Multi-Level Approach in Demography, Disseration, Chapter 3, <a href="https://rosdok.uni-rostock.de/file/rosdok_derivate_0000004766/Dissertation_Zinn_2011.pdf">https://rosdok.uni-rostock.de/file/rosdok_derivate_0000004766/Dissertation_Zinn_2011.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######################################################################################
# 1. Simple example only dealing with mortality events
######################################################################################

# Clean workspace 
rm(list=ls())

# Defining simulation horizon
startDate &lt;- 20000101 # yyyymmdd
endDate   &lt;- 21001231 # yyyymmdd
simHorizon &lt;- c(startDate=startDate, endDate=endDate)

# Seed for random number generator
set.seed(234)

# Definition of maximal age
maxAge &lt;- 120

# Defintion of nonabsorbing and absorbing states
sex &lt;- c("m","f")
stateSpace &lt;- sex
attr(stateSpace,"name") &lt;- "sex"
absStates &lt;- "dead"

# Definition of an initial population 
birthDates &lt;- c("19301231","19990403","19561015","19911111","19650101")
initStates &lt;- c("f","m","f","m","m")
initPop &lt;- data.frame(ID=1:5,birthDate=birthDates,initState=initStates)

# Definition of mortality rates (Gompertz model)
mortRates &lt;- function(age, calTime, duration){
  a &lt;- 0.00003
  b &lt;- ifelse(calTime&lt;=2020, 0.1, 0.097)
  rate &lt;- a*exp(b*age)
  return(rate)
}

# Transition pattern and assignment of functions specifying transition rates
absTransitions &lt;- c("dead","mortRates")
transitionMatrix &lt;- buildTransitionMatrix(allTransitions=NULL,
  absTransitions=absTransitions, stateSpace=stateSpace)

# Execute microsimulation (sequentially, i.e., using only one CPU)
pop &lt;- micSim(initPop=initPop, transitionMatrix=transitionMatrix, absStates=absStates, 
  maxAge=maxAge, simHorizon=simHorizon)
  
######################################################################################
# 2. More complex, but only illustrative example dealing with mortality, changes in 
# fertily, and with the inheritance of attributes of the mother
######################################################################################  

# Clean workspace 
rm(list=ls())

# Defining simulation horizon
startDate &lt;- 20140101 # yyyymmdd
endDate   &lt;- 20241231 # yyyymmdd
simHorizon &lt;- c(startDate=startDate, endDate=endDate)
  
# Seed for random number generator
set.seed(234)

# Definition of maximal age 
maxAge &lt;- 100  

# Defintion of nonabsorbing and absorbing states
sex &lt;- c("m","f")                     
nat &lt;- c("DE","AT","IT") # nationality
fert &lt;- c("0","1")           
stateSpace &lt;- expand.grid(sex=sex,nat=nat,fert=fert)
absStates &lt;- "dead" 

# Definition of an initial population (for illustration purposes, create a random population)
N = 100   
birthDates &lt;- runif(N, min=getInDays(19500101), max=getInDays(20131231)) 
getRandInitState &lt;- function(birthDate){
  age &lt;- trunc((getInDays(simHorizon[1]) - birthDate)/365.25) 
  s1 &lt;- sample(sex,1)
  s2 &lt;- sample(nat,1)
  s3 &lt;- ifelse(age&lt;=18, fert[1], sample(fert,1))
  initState &lt;- paste(c(s1,s2,s3),collapse="/")
  return(initState)
}
initPop &lt;- data.frame(ID=1:N, birthDate=birthDates, initState=sapply(birthDates, getRandInitState))
initPop$birthDate &lt;- getInDateFormat(initPop$birthDate)

# Definition of initial states for newborns
# To have possibility to define distinct sex ratios for distinct nationalities, 
# inherit related substate from the mother 
fixInitStates &lt;- 2 # give indices for attribute/substate that will be taken over 
                   # from the mother, here: nat 
varInitStates &lt;- rbind(c("m","DE","0"), c("f","DE","0"),
                       c("m","AT","0"), c("f","AT","0"), 
                       c("m","IT","0"), c("f","IT","0")) 
initStatesProb &lt;- c(0.515,0.485, 
                    0.515,0.485,
                    0.515,0.485)
# Mind: depending on the inherited attribute nat="DE", nat="AT", or nat="IT"
# initials probabilites must sum to one                       

# Definition of (possible) transition rates  
# Fertility rates (Hadwiger mixture model)
fertRates &lt;- function(age, calTime, duration){ 
  b &lt;- ifelse(calTime&lt;=2020, 3.5, 3.0)
  c &lt;- ifelse(calTime&lt;=2020, 28, 29)
  rate &lt;-  (b/c)*(c/age)^(3/2)*exp(-b^2*(c/age+age/c-2))
  rate[age&lt;=15 | age&gt;=45] &lt;- 0
  return(rate)
}
# Mortality rates (Gompertz model)
mortRates &lt;- function(age, calTime, duration){
  a &lt;- .00003
  b &lt;- ifelse(calTime&lt;=2020, 0.1, 0.097)
  rate &lt;- a*exp(b*age)
  return(rate)
}

fertTrMatrix &lt;- cbind(c("f/DE/0-&gt;f/DE/1", "f/AT/0-&gt;f/AT/1", "f/IT/0-&gt;f/IT/1"),
                      c(rep("fertRates",3))) 
allTransitions &lt;- fertTrMatrix

absTransitions &lt;- cbind(c("f/DE/dead", "f/AT/dead", "f/IT/dead", 
                          "m/DE/dead", "m/AT/dead", "m/IT/dead"),
                       c(rep("mortRates",6)))                          

transitionMatrix &lt;- buildTransitionMatrix(allTransitions=allTransitions,
                                          absTransitions=absTransitions, 
                                          stateSpace=stateSpace)

# Define transitions triggering a birth event
fertTr &lt;- fertTrMatrix[,1]

# Execute microsimulation 
pop &lt;- micSim(initPop=initPop,
               transitionMatrix=transitionMatrix, absStates=absStates,
               varInitStates=varInitStates, initStatesProb=initStatesProb,
               fixInitStates=fixInitStates,
               maxAge=maxAge, simHorizon=simHorizon,fertTr=fertTr)  
  
######################################################################################
# 3. Complex example dealing with mortality, changes in the fertily and the marital 
# status, in the educational attainment, as well as dealing with migration
######################################################################################

# Clean workspace 
rm(list=ls())

# Defining simulation horizon
startDate &lt;- 20140101 # yyyymmdd
endDate   &lt;- 20241231 # yyyymmdd
simHorizon &lt;- c(startDate=startDate, endDate=endDate)

# Seed for random number generator
set.seed(234)

# Definition of maximal age 
maxAge &lt;- 100  

# Defintion of nonabsorbing and absorbing states
sex &lt;- c("m","f")                     
fert &lt;- c("0","1+")           
marital &lt;- c("NM","M","D","W")        
edu &lt;- c("no","low","med","high")   
stateSpace &lt;- expand.grid(sex=sex,fert=fert,marital=marital,edu=edu)
absStates &lt;- c("dead","rest")   

# General month of enrollment to elementary school
monthSchoolEnrol &lt;- 9

# Definition of an initial population (for illustration purposes, create a random population)
N = 100                                                       
birthDates &lt;- runif(N, min=getInDays(19500101), max=getInDays(20131231)) 
getRandInitState &lt;- function(birthDate){
  age &lt;- trunc((getInDays(simHorizon[1]) - birthDate)/365.25) 
  s1 &lt;- sample(sex,1)
  s2 &lt;- ifelse(age&lt;=18, fert[1], sample(fert,1))
  s3 &lt;- ifelse(age&lt;=18, marital[1], ifelse(age&lt;=22, sample(marital[1:3],1), 
                                           sample(marital,1)))
  s4 &lt;- ifelse(age&lt;=7, edu[1], ifelse(age&lt;=18, edu[2], ifelse(age&lt;=23, sample(edu[2:3],1), 
                                                              sample(edu[-1],1))))
  initState &lt;- paste(c(s1,s2,s3,s4),collapse="/")
  return(initState)
}
initPop &lt;- data.frame(ID=1:N, birthDate=birthDates, initState=sapply(birthDates, getRandInitState))
initPop$birthDate &lt;- getInDateFormat(initPop$birthDate)
range(initPop$birthDate)

# Definition of immigrants entering the population (for illustration purposes, create immigrants 
# randomly)
M = 20                                                           
immigrDates &lt;- runif(M, min=getInDays(20140101), max=getInDays(20241231)) 
immigrAges &lt;- runif(M, min=15*365.25, max=70*365.25)
immigrBirthDates &lt;- immigrDates - immigrAges
IDmig &lt;- max(as.numeric(initPop[,"ID"]))+(1:M)
immigrPop &lt;- data.frame(ID = IDmig, immigrDate = immigrDates, birthDate=immigrBirthDates, 
                        immigrInitState=sapply(immigrBirthDates, getRandInitState))  
immigrPop$birthDate &lt;- getInDateFormat(immigrPop$birthDate)
immigrPop$immigrDate &lt;- getInDateFormat(immigrPop$immigrDate)

# Definition of initial states for newborns 
varInitStates &lt;- rbind(c("m","0","NM","no"),c("f","0","NM","no")) 
# Definition of related occurrence probabilities
initStatesProb &lt;- c(0.515,0.485)                              

# Definition of (possible) transition rates  
# (1) Fertility rates (Hadwiger mixture model)
fert1Rates &lt;- function(age, calTime, duration){  # parity 1
  b &lt;- ifelse(calTime&lt;=2020, 3.9, 3.3)
  c &lt;- ifelse(calTime&lt;=2020, 28, 29)
  rate &lt;-  (b/c)*(c/age)^(3/2)*exp(-b^2*(c/age+age/c-2))
  rate[age&lt;=15 | age&gt;=45] &lt;- 0
  return(rate)
}
fert2Rates &lt;- function(age, calTime, duration){  # partiy 2+
  b &lt;- ifelse(calTime&lt;=2020, 3.2, 2.8)
  c &lt;- ifelse(calTime&lt;=2020, 32, 33)
  rate &lt;-  (b/c)*(c/age)^(3/2)*exp(-b^2*(c/age+age/c-2))
  rate[age&lt;=15 | age&gt;=45 | duration&lt;0.75] &lt;- 0
  return(rate)
}
# (2) Rates for first marriage (normal density)
marriage1Rates &lt;- function(age, calTime, duration){  
  m &lt;- ifelse(calTime&lt;=2020, 25, 30)
  s &lt;- ifelse(calTime&lt;=2020, 3, 3)
  rate &lt;- dnorm(age, mean=m, sd=s)
  rate[age&lt;=16] &lt;- 0
  return(rate)
}
# (3) Remariage rates (log-logistic model)
marriage2Rates &lt;- function(age, calTime, duration){  
  b &lt;- ifelse(calTime&lt;=2020, 0.07, 0.10)
  p &lt;- ifelse(calTime&lt;=2020, 2.7,2.7)
  lambda &lt;- ifelse(calTime&lt;=1950, 0.04, 0.03)
  rate &lt;- b*p*(lambda*age)^(p-1)/(1+(lambda*age)^p)
  rate[age&lt;=18] &lt;- 0
  return(rate)
}
# (4) Divorce rates (normal density)
divorceRates &lt;- function(age, calTime, duration){
  m &lt;- 40
  s &lt;- ifelse(calTime&lt;=2020, 7, 6)
  rate &lt;- dnorm(age,mean=m,sd=s)
  rate[age&lt;=18] &lt;- 0
  return(rate)
}
# (5) Widowhood rates (gamma cdf)
widowhoodRates &lt;- function(age, calTime, duration){
  rate &lt;- ifelse(age&lt;=30, 0, pgamma(age-30, shape=6, rate=0.06))
  return(rate)
}
# (6) Rates to change educational attainment
# Set rate to `Inf' to make transition for age 7 deterministic.
noToLowEduRates &lt;- function(age, calTime, duration){
  rate &lt;- ifelse(age==7,Inf,0) 
  return(rate)
}
lowToMedEduRates &lt;- function(age, calTime, duration){
  rate &lt;- dnorm(age,mean=16,sd=1)
  rate[age&lt;=15 | age&gt;=25] &lt;- 0
  return(rate)
}
medToHighEduRates &lt;- function(age, calTime, duration){
  rate &lt;- dnorm(age,mean=20,sd=3)
  rate[age&lt;=18 | age&gt;=35] &lt;- 0
  return(rate)
}
# (7) Mortality rates (Gompertz model)
mortRates &lt;- function(age, calTime, duration){
  a &lt;- .00003
  b &lt;- ifelse(calTime&lt;=2020, 0.1, 0.097)
  rate &lt;- a*exp(b*age)
  return(rate)
}
# (8) Emigration rates 
emigrRates &lt;- function(age, calTime, duration){
  rate &lt;- ifelse(age&lt;=18,0,0.0025)
  return(rate)
}

# Transition pattern and assignment of functions specifying transition rates
fertTrMatrix &lt;- cbind(c("0-&gt;1+","1+-&gt;1+"),                         
  c("fert1Rates", "fert2Rates"))
maritalTrMatrix &lt;- cbind(c("NM-&gt;M","M-&gt;D","M-&gt;W","D-&gt;M","W-&gt;M"),              
  c("marriage1Rates","divorceRates","widowhoodRates",
 "marriage2Rates","marriage2Rates"))
eduTrMatrix &lt;- cbind(c("no-&gt;low","low-&gt;med","med-&gt;high"),
  c("noToLowEduRates","lowToMedEduRates","medToHighEduRates")) 
allTransitions &lt;- rbind(fertTrMatrix, maritalTrMatrix, eduTrMatrix)
absTransitions &lt;- rbind(c("dead","mortRates"),c("rest","emigrRates"))
transitionMatrix &lt;- buildTransitionMatrix(allTransitions=allTransitions,
  absTransitions=absTransitions, stateSpace=stateSpace)

# Define transitions triggering a birth event
fertTr &lt;- fertTrMatrix[,1]

# Execute microsimulation 
pop &lt;- micSim(initPop=initPop, immigrPop=immigrPop, 
              transitionMatrix=transitionMatrix, 
              absStates=absStates, 
              varInitStates=varInitStates, 
              initStatesProb=initStatesProb, 
              maxAge=maxAge, 
              simHorizon=simHorizon, 
              fertTr=fertTr, 
              monthSchoolEnrol=monthSchoolEnrol)  
  

</code></pre>

<hr>
<h2 id='micSimParallel'>
Run microsimulation (parallel computing)
</h2><span id='topic+micSimParallel'></span>

<h3>Description</h3>

<p>The function <code>micSimParallel</code> is a parallelized version of the function <a href="#topic+micSim">micSim</a>. That is, it runs a continuous-time microsimulation simulation distributed, i.e., using more than one CPU core.</p>


<h3>Usage</h3>

<pre><code class='language-R'>micSimParallel(initPop, immigrPop = NULL, initPopList = c(), immigrPopList = c(), 
  transitionMatrix, absStates = NULL, varInitStates = c(), initStatesProb = c(), 
  fixInitStates = c(), maxAge = 99, simHorizon, fertTr = c(), 
  monthSchoolEnrol=c(), cores=1, seeds=1254)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="micSimParallel_+3A_initpop">initPop</code></td>
<td>
<p>Either an initial population has to be given as a whole or splitted to be run at the distinct cores, see arguments <code>initPopList</code>. If it is given as a whole it is automatically splitted by MicSim such that the population parts run on the distinct cores are approx. equally sized.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_immigrpop">immigrPop</code></td>
<td>
<p>Optionally, a population of migrants entering the virtual population along simulation time can be given, see arguments <code>immigrPopList</code>. This migrants population can either be given as a whole or splitted to be run at the distinct cores. If it is given as a whole it is automatically splitted by MicSim such that the population parts run on the distinct cores are approx. equally sized.   
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_transitionmatrix">transitionMatrix</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_absstates">absStates</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_varinitstates">varInitStates</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_initstatesprob">initStatesProb</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_initpoplist">initPopList</code></td>
<td>

<p>Optional: A list containing the initial population split for the distinct cores. 
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_immigrpoplist">immigrPopList</code></td>
<td>

<p>Optional: A list containing the immigration population split for the distinct cores. 
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_fixinitstates">fixInitStates</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_maxage">maxAge</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_simhorizon">simHorizon</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_ferttr">fertTr</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_monthschoolenrol">monthSchoolEnrol</code></td>
<td>
<p>See <a href="#topic+micSim">micSim</a>.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_cores">cores</code></td>
<td>

<p>Number of CPUs to be used.
</p>
</td></tr>
<tr><td><code id="micSimParallel_+3A_seeds">seeds</code></td>
<td>

<p>Seeds for pseudo number generators used for parallel computing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>cores</code> must not exceed the number of cores of the computer (cluster) used. 
</p>
<p>In <code>seeds</code> as many seeds should be given as cores are used. If less are given, the latter are repeated to complete the set of seeds. 
</p>


<h3>Value</h3>

<p>The data frame <code>pop</code> contains the whole synthetic population considered during simulation including all events generated. For more details, see <a href="#topic+micSim">micSim</a>.
</p>


<h3>Author(s)</h3>

<p>Sabine Zinn
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Clean workspace 
rm(list=ls())

# Defining simulation horizon
startDate &lt;- 20140101 # yyyymmdd
endDate   &lt;- 20241231 # yyyymmdd
simHorizon &lt;- c(startDate=startDate, endDate=endDate)

# Seed for random number generator
set.seed(234)

# Definition of maximal age 
maxAge &lt;- 100  

# Defintion of nonabsorbing and absorbing states
sex &lt;- c("m","f")                     
fert &lt;- c("0","1+")           
marital &lt;- c("NM","M","D","W")        
edu &lt;- c("no","low","med","high")   
stateSpace &lt;- expand.grid(sex=sex,fert=fert,marital=marital,edu=edu)
absStates &lt;- c("dead","rest")   

# General month of enrollment to elementary school
monthSchoolEnrol &lt;- 9

# Definition of an initial population (for illustration purposes, create a random population)
N = 10000                                                       
birthDates &lt;- runif(N, min=getInDays(19500101), max=getInDays(20131231)) 
getRandInitState &lt;- function(birthDate){
  age &lt;- trunc((getInDays(simHorizon[1]) - birthDate)/365.25) 
  s1 &lt;- sample(sex,1)
  s2 &lt;- ifelse(age&lt;=18, fert[1], sample(fert,1))
  s3 &lt;- ifelse(age&lt;=18, marital[1], ifelse(age&lt;=22, sample(marital[1:3],1), 
                                           sample(marital,1)))
  s4 &lt;- ifelse(age&lt;=7, edu[1], ifelse(age&lt;=18, edu[2], ifelse(age&lt;=23, sample(edu[2:3],1), 
                                                              sample(edu[-1],1))))
  initState &lt;- paste(c(s1,s2,s3,s4),collapse="/")
  return(initState)
}
initPop &lt;- data.frame(ID=1:N, birthDate=birthDates, initState=sapply(birthDates, getRandInitState))
initPop$birthDate &lt;- getInDateFormat(initPop$birthDate)
range(initPop$birthDate)

# Definition of immigrants entering the population (for illustration purposes, create immigrants 
# randomly)
M = 2000                                                           
immigrDates &lt;- runif(M, min=getInDays(20140101), max=getInDays(20241231)) 
immigrAges &lt;- runif(M, min=15*365.25, max=70*365.25)
immigrBirthDates &lt;- immigrDates - immigrAges
IDmig &lt;- max(as.numeric(initPop[,"ID"]))+(1:M)
immigrPop &lt;- data.frame(ID = IDmig, immigrDate = immigrDates, birthDate=immigrBirthDates, 
                        immigrInitState=sapply(immigrBirthDates, getRandInitState))  
immigrPop$birthDate &lt;- getInDateFormat(immigrPop$birthDate)
immigrPop$immigrDate &lt;- getInDateFormat(immigrPop$immigrDate)

# Definition of initial states for newborns 
varInitStates &lt;- rbind(c("m","0","NM","no"),c("f","0","NM","no")) 
# Definition of related occurrence probabilities
initStatesProb &lt;- c(0.515,0.485)                              

# Definition of (possible) transition rates  
# (1) Fertility rates (Hadwiger mixture model)
fert1Rates &lt;- function(age, calTime, duration){  # parity 1
  b &lt;- ifelse(calTime&lt;=2020, 3.9, 3.3)
  c &lt;- ifelse(calTime&lt;=2020, 28, 29)
  rate &lt;-  (b/c)*(c/age)^(3/2)*exp(-b^2*(c/age+age/c-2))
  rate[age&lt;=15 | age&gt;=45] &lt;- 0
  return(rate)
}
fert2Rates &lt;- function(age, calTime, duration){  # partiy 2+
  b &lt;- ifelse(calTime&lt;=2020, 3.2, 2.8)
  c &lt;- ifelse(calTime&lt;=2020, 32, 33)
  rate &lt;-  (b/c)*(c/age)^(3/2)*exp(-b^2*(c/age+age/c-2))
  rate[age&lt;=15 | age&gt;=45 | duration&lt;0.75] &lt;- 0
  return(rate)
}
# (2) Rates for first marriage (normal density)
marriage1Rates &lt;- function(age, calTime, duration){  
  m &lt;- ifelse(calTime&lt;=2020, 25, 30)
  s &lt;- ifelse(calTime&lt;=2020, 3, 3)
  rate &lt;- dnorm(age, mean=m, sd=s)
  rate[age&lt;=16] &lt;- 0
  return(rate)
}
# (3) Remariage rates (log-logistic model)
marriage2Rates &lt;- function(age, calTime, duration){  
  b &lt;- ifelse(calTime&lt;=2020, 0.07, 0.10)
  p &lt;- ifelse(calTime&lt;=2020, 2.7,2.7)
  lambda &lt;- ifelse(calTime&lt;=1950, 0.04, 0.03)
  rate &lt;- b*p*(lambda*age)^(p-1)/(1+(lambda*age)^p)
  rate[age&lt;=18] &lt;- 0
  return(rate)
}
# (4) Divorce rates (normal density)
divorceRates &lt;- function(age, calTime, duration){
  m &lt;- 40
  s &lt;- ifelse(calTime&lt;=2020, 7, 6)
  rate &lt;- dnorm(age,mean=m,sd=s)
  rate[age&lt;=18] &lt;- 0
  return(rate)
}
# (5) Widowhood rates (gamma cdf)
widowhoodRates &lt;- function(age, calTime, duration){
  rate &lt;- ifelse(age&lt;=30, 0, pgamma(age-30, shape=6, rate=0.06))
  return(rate)
}
# (6) Rates to change educational attainment
# Set rate to `Inf' to make transition for age 7 deterministic.
noToLowEduRates &lt;- function(age, calTime, duration){
  rate &lt;- ifelse(age==7,Inf,0) 
  return(rate)
}
lowToMedEduRates &lt;- function(age, calTime, duration){
  rate &lt;- dnorm(age,mean=16,sd=1)
  rate[age&lt;=15 | age&gt;=25] &lt;- 0
  return(rate)
}
medToHighEduRates &lt;- function(age, calTime, duration){
  rate &lt;- dnorm(age,mean=20,sd=3)
  rate[age&lt;=18 | age&gt;=35] &lt;- 0
  return(rate)
}
# (7) Mortality rates (Gompertz model)
mortRates &lt;- function(age, calTime, duration){
  a &lt;- .00003
  b &lt;- ifelse(calTime&lt;=2020, 0.1, 0.097)
  rate &lt;- a*exp(b*age)
  return(rate)
}
# (8) Emigration rates 
emigrRates &lt;- function(age, calTime, duration){
  rate &lt;- ifelse(age&lt;=18,0,0.0025)
  return(rate)
}

# Transition pattern and assignment of functions specifying transition rates
fertTrMatrix &lt;- cbind(c("0-&gt;1+","1+-&gt;1+"),                         
  c("fert1Rates", "fert2Rates"))
maritalTrMatrix &lt;- cbind(c("NM-&gt;M","M-&gt;D","M-&gt;W","D-&gt;M","W-&gt;M"),              
  c("marriage1Rates","divorceRates","widowhoodRates",
 "marriage2Rates","marriage2Rates"))
eduTrMatrix &lt;- cbind(c("no-&gt;low","low-&gt;med","med-&gt;high"),
  c("noToLowEduRates","lowToMedEduRates","medToHighEduRates")) 
allTransitions &lt;- rbind(fertTrMatrix, maritalTrMatrix, eduTrMatrix)
absTransitions &lt;- rbind(c("dead","mortRates"),c("rest","emigrRates"))
transitionMatrix &lt;- buildTransitionMatrix(allTransitions=allTransitions,
  absTransitions=absTransitions, stateSpace=stateSpace)

# Define transitions triggering a birth event
fertTr &lt;- fertTrMatrix[,1]

# Run microsimulation on cluster with three cores (settings depend on cluster used)
## Not run: 
cores &lt;- 3
seeds &lt;- c(1233,1245,265)
initPopList &lt;- list(initPop[1:5000,], initPop[5001:8000,],initPop[8001:nrow(initPop),])
immigrPopList &lt;- list(immigrPop[1:1000,], immigrPop[1001:1500,],immigrPop[1501:nrow(immigrPop),])

pop &lt;- micSimParallel(initPopList=initPopList, immigrPopList=immigrPopList, 
  transitionMatrix=transitionMatrix, absStates=absStates, varInitStates=varInitStates, 
  initStatesProb=initStatesProb, maxAge=maxAge, simHorizon=simHorizon, 
  fertTr=fertTr, monthSchoolEnrol=monthSchoolEnrol, 
  cores=cores, seeds=seeds)

## End(Not run)

</code></pre>

<hr>
<h2 id='migrExpRates'>
Transition rates for migration example of MicSim package.
</h2><span id='topic+migrExpRates'></span>

<h3>Description</h3>

<p>Transition rates for fertility (up to parity 4), migration between Spain / Netherlands / Sweden, mortality rates and emigration rates (leaving the Spain, the Netherlands, Sweden to some other country than these three). Rates have been estimated by the Unit &ldquo;Migration, Demography and Governance Unit&rdquo; of the European Commission.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("migrExpRates")</code></pre>


<h3>Format</h3>

<p>A data frame with transition rates for 30 states and ages from 0 to 99.
</p>

<dl>
<dt><code>mort_f_ES</code></dt><dd><p>mortality rates for females in Spain</p>
</dd>
<dt><code>mort_f_NL</code></dt><dd><p>mortality rates for females in the Netherlands</p>
</dd>
<dt><code>mort_f_SE</code></dt><dd><p>mortality rates for females in Sweden</p>
</dd>
<dt><code>mort_m_ES</code></dt><dd><p>mortality rates for males in Spain</p>
</dd>
<dt><code>mort_m_NL</code></dt><dd><p>mortality rates for males in the Netherlands</p>
</dd>
<dt><code>mort_m_SE</code></dt><dd><p>mortality rates for males in Sweden</p>
</dd>
<dt><code>fert_ES_0_1</code></dt><dd><p>fertility rates for partity 1 for Spain</p>
</dd>
<dt><code>fert_ES_1_2</code></dt><dd><p>fertility rates for partity 2 for Spain</p>
</dd>
<dt><code>fert_ES_2_3</code></dt><dd><p>fertility rates for partity 3 for Spain</p>
</dd>
<dt><code>fert_ES_3_4</code></dt><dd><p>fertility rates for partity 4 for Spain</p>
</dd>    
<dt><code>fert_NL_0_1</code></dt><dd><p>fertility rates for partity 1 for the Netherlands</p>
</dd>
<dt><code>fert_NL_1_2</code></dt><dd><p>fertility rates for partity 2 for the Netherlands</p>
</dd>
<dt><code>fert_NL_2_3</code></dt><dd><p>fertility rates for partity 3 for the Netherlands</p>
</dd>
<dt><code>fert_NL_3_4</code></dt><dd><p>fertility rates for partity 4 for the Netherlands</p>
</dd>   
<dt><code>fert_SE_0_1</code></dt><dd><p>fertility rates for partity 1 for Sweden</p>
</dd>
<dt><code>fert_SE_1_2</code></dt><dd><p>fertility rates for partity 2 for Sweden</p>
</dd>
<dt><code>fert_SE_2_3</code></dt><dd><p>fertility rates for partity 3 for Sweden</p>
</dd>
<dt><code>fert_SE_3_4</code></dt><dd><p>fertility rates for partity 4 for Sweden</p>
</dd>  
<dt><code>rate_ES_NL</code></dt><dd><p>migration rates for Spain to the Netherlands</p>
</dd>
<dt><code>rate_ES_SE</code></dt><dd><p>migration rates for Spain to the Sweden</p>
</dd>
<dt><code>rate_NL_ES</code></dt><dd><p>migration rates for the Netherlands to Spain</p>
</dd>
<dt><code>rate_NL_SE</code></dt><dd><p>migration rates for the Netherlands to Sweden</p>
</dd>  
<dt><code>rate_SE_ES</code></dt><dd><p>migration rates for Sweden to Spain</p>
</dd>  
<dt><code>rate_SE_NL</code></dt><dd><p>migration rates for Sweden to the Netherlands</p>
</dd>      
<dt><code>emig_f_ES</code></dt><dd><p>emigration rates for females in Spain</p>
</dd>
<dt><code>emig_f_NL</code></dt><dd><p>emigration rates for females in the Netherlands</p>
</dd>
<dt><code>emig_f_SE</code></dt><dd><p>emigration rates for females in Sweden</p>
</dd>
<dt><code>emig_m_ES</code></dt><dd><p>emigration rates for females in Spain</p>
</dd>  
<dt><code>emig_m_NL</code></dt><dd><p>emigration rates for females in the Netherlands</p>
</dd> 
<dt><code>emig_m_SE</code></dt><dd><p>emigration rates for females in Sweden</p>
</dd>   
</dl>



<h3>Source</h3>

<p>European Commission
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(migrExpRates)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
