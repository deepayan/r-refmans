<!DOCTYPE html><html><head><title>Help for package stfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARE'><p>Absolute relative error</p></a></li>
<li><a href='#epan'><p>Epanicnicov kernel function</p></a></li>
<li><a href='#getMask'><p>Get image mask</p></a></li>
<li><a href='#getMissingLayers'><p>Get missing layer index</p></a></li>
<li><a href='#landsat106'><p>Landsat data example</p></a></li>
<li><a href='#landsatVis'><p>Data visualization for landsat data</p></a></li>
<li><a href='#lc_cov_1d'><p>Local constant covariance estimation</p></a></li>
<li><a href='#lc_cov_1d_est'><p>Local constant covariance estimation</p></a></li>
<li><a href='#llreg'><p>Local linear regression</p></a></li>
<li><a href='#lpreg'><p>Local Polynomial Regression</p></a></li>
<li><a href='#meanEst'><p>STFIT Mean Estimation</p></a></li>
<li><a href='#NMSE'><p>Normalized Mean Square Estimation</p></a></li>
<li><a href='#opts_stfit'><p>Options for stfit</p></a></li>
<li><a href='#outlier'><p>Image Outlier Detection</p></a></li>
<li><a href='#pctMissing'><p>Missing value percentages</p></a></li>
<li><a href='#rmOutlier'><p>Remove outlier</p></a></li>
<li><a href='#RMSE'><p>Root Mean Square Estimation</p></a></li>
<li><a href='#seffEst'><p>STFIT Spatial Effect Estimation</p></a></li>
<li><a href='#smooth_spline'><p>Smoothing spline regression</p></a></li>
<li><a href='#spreg'><p>spline regression</p></a></li>
<li><a href='#stfit_landsat'><p>STFIT for Landsat data</p></a></li>
<li><a href='#stfit-package'><p>stfit: Spatial-Temporal Functional Imputation Tool</p></a></li>
<li><a href='#teffEst'><p>STFIT Temporal Effect Estimation</p></a></li>
<li><a href='#weightMatrix'><p>Weight matrix calculation</p></a></li>
<li><a href='#weightVector'><p>Weight vector calculation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatio-Temporal Functional Imputation Tool</td>
</tr>
<tr>
<td>Version:</td>
<td>0.99.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-17</td>
</tr>
<tr>
<td>Description:</td>
<td>A general spatiotemporal satellite image imputation method based on sparse functional data analytic techniques. The imputation method applies and extends the Functional Principal Analysis by Conditional Estimation (PACE). The underlying idea for the proposed procedure is to impute a missing pixel by borrowing information from temporally and spatially contiguous pixels based on the best linear unbiased prediction.  </td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mingsnu/stfit/issues">https://github.com/mingsnu/stfit/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, Matrix, doParallel, foreach, abind, fda, raster,
rasterVis, RColorBrewer</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, dplyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-17 23:25:55 UTC; Weicheng</td>
</tr>
<tr>
<td>Author:</td>
<td>Weicheng Zhu [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Weicheng Zhu &lt;mingsnu@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-18 12:20:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARE'>Absolute relative error</h2><span id='topic+ARE'></span>

<h3>Description</h3>

<p>Absolute relative error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARE(y, ypred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARE_+3A_y">y</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="ARE_+3A_ypred">ypred</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric number. A measure of difference between y and ypred.
</p>

<hr>
<h2 id='epan'>Epanicnicov kernel function</h2><span id='topic+epan'></span>

<h3>Description</h3>

<p>Epanicnicov kernel function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epan_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='getMask'>Get image mask</h2><span id='topic+getMask'></span>

<h3>Description</h3>

<p>Get image mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMask(object, tol = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMask_+3A_object">object</code></td>
<td>
<p>A numeric matrix. Each row is an row stacked image.</p>
</td></tr>
<tr><td><code id="getMask_+3A_tol">tol</code></td>
<td>
<p>If the percentage of missing values for a pixel over time is greater than this
value, this pixel is treated as a mask value.</p>
</td></tr>
</table>

<hr>
<h2 id='getMissingLayers'>Get missing layer index</h2><span id='topic+getMissingLayers'></span>

<h3>Description</h3>

<p>Get missing layer index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMissingLayers(rst.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMissingLayers_+3A_rst.list">rst.list</code></td>
<td>
<p>a RasterStack or RasterBrick object or a list of them</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index of the missing layers
</p>

<hr>
<h2 id='landsat106'>Landsat data example</h2><span id='topic+landsat106'></span><span id='topic+landsat2'></span>

<h3>Description</h3>

<p>A dataset containing observation values of a 31x31 pixcels 
landsat image observed between year 1982 and 2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landsat106

landsat2
</code></pre>


<h3>Format</h3>

<p>A data frame with 990 rows and 963 columns:
</p>

<ul>
<li><p> year year
</p>
</li>
<li><p> doy day of the year
</p>
</li>
<li><p> pixeli pixel value for the i-th pixel of the image
</p>
</li></ul>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 990 rows and 963 columns.
</p>

<hr>
<h2 id='landsatVis'>Data visualization for landsat data</h2><span id='topic+landsatVis'></span>

<h3>Description</h3>

<p>Data visualization for landsat data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landsatVis(
  mat,
  img.nrow = 31,
  byrow = FALSE,
  colthm = rasterTheme(panel.background = list(col = "black"), region = brewer.pal(9,
    "YlOrRd")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="landsatVis_+3A_mat">mat</code></td>
<td>
<p>A matrix, each row corresponds to a vectorized image pixel values.</p>
</td></tr>
<tr><td><code id="landsatVis_+3A_img.nrow">img.nrow</code></td>
<td>
<p>number of rows of the image</p>
</td></tr>
<tr><td><code id="landsatVis_+3A_byrow">byrow</code></td>
<td>
<p>logical value indicating whether the pixcel values are stored 
by row or by column. Default to FALSE</p>
</td></tr>
<tr><td><code id="landsatVis_+3A_colthm">colthm</code></td>
<td>
<p>Color theme for the plot, passing to the <code>par.settings</code> 
parameter of the <code>levelplot</code> function in the <code>rasterVis</code> package</p>
</td></tr>
<tr><td><code id="landsatVis_+3A_...">...</code></td>
<td>
<p>All other options passed to  <code>levelplot</code> function in the 
<code>rasterVis</code> package</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>landsatVis(landsat106[landsat106$year == 2015, -c(1:2)], 
names.attr = as.character(landsat106$doy[landsat106$year == 2015]))
</code></pre>

<hr>
<h2 id='lc_cov_1d'>Local constant covariance estimation</h2><span id='topic+lc_cov_1d'></span>

<h3>Description</h3>

<p>Local constant covariance estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lc_cov_1d(ids, time, resid, W, t1, t2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lc_cov_1d_+3A_ids">ids</code></td>
<td>
<p>a vector indicating subject/group ids</p>
</td></tr>
<tr><td><code id="lc_cov_1d_+3A_time">time</code></td>
<td>
<p>integer vector of observed time points, the minimum time unit is 1</p>
</td></tr>
<tr><td><code id="lc_cov_1d_+3A_resid">resid</code></td>
<td>
<p>vector of residual values used for covariance calculation</p>
</td></tr>
<tr><td><code id="lc_cov_1d_+3A_w">W</code></td>
<td>
<p>weight vector, it contains both kernel and bandwidth information in general 
local polynomial estimation setting up</p>
</td></tr>
<tr><td><code id="lc_cov_1d_+3A_t1">t1</code></td>
<td>
<p>time point 1</p>
</td></tr>
<tr><td><code id="lc_cov_1d_+3A_t2">t2</code></td>
<td>
<p>time point 2</p>
</td></tr>
</table>

<hr>
<h2 id='lc_cov_1d_est'>Local constant covariance estimation</h2><span id='topic+lc_cov_1d_est'></span>

<h3>Description</h3>

<p>Local constant covariance estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lc_cov_1d_est(ids, time, resid, W, tt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lc_cov_1d_est_+3A_ids">ids</code></td>
<td>
<p>a vector indicating subject/group ids</p>
</td></tr>
<tr><td><code id="lc_cov_1d_est_+3A_time">time</code></td>
<td>
<p>integer vector of observed time points, the minimum time unit is 1</p>
</td></tr>
<tr><td><code id="lc_cov_1d_est_+3A_resid">resid</code></td>
<td>
<p>vector of residual values used for covariance calculation</p>
</td></tr>
<tr><td><code id="lc_cov_1d_est_+3A_w">W</code></td>
<td>
<p>weight vector, it contains both kernel and bandwidth information in general 
local polynomial estimation setting up</p>
</td></tr>
<tr><td><code id="lc_cov_1d_est_+3A_tt">tt</code></td>
<td>
<p>time vector</p>
</td></tr>
</table>

<hr>
<h2 id='llreg'>Local linear regression</h2><span id='topic+llreg'></span>

<h3>Description</h3>

<p>Local linear regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llreg(x, y, x.eval = x, minimum.num.obs = 4, h = 60, Kern = epan)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llreg_+3A_x">x</code></td>
<td>
<p>independent variable</p>
</td></tr>
<tr><td><code id="llreg_+3A_y">y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="llreg_+3A_x.eval">x.eval</code></td>
<td>
<p>dnew data to predict on</p>
</td></tr>
<tr><td><code id="llreg_+3A_minimum.num.obs">minimum.num.obs</code></td>
<td>
<p>minimum number of observations needed to run the regression</p>
</td></tr>
<tr><td><code id="llreg_+3A_h">h</code></td>
<td>
<p>bandwidth</p>
</td></tr>
<tr><td><code id="llreg_+3A_kern">Kern</code></td>
<td>
<p>Kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predicted values at 'x.eval'
</p>

<hr>
<h2 id='lpreg'>Local Polynomial Regression</h2><span id='topic+lpreg'></span>

<h3>Description</h3>

<p>Local Polynomial Regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpreg(x, y, x.eval, minimum.num.obs = 4, span = 0.3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpreg_+3A_x">x</code></td>
<td>
<p>independent variable</p>
</td></tr>
<tr><td><code id="lpreg_+3A_y">y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="lpreg_+3A_x.eval">x.eval</code></td>
<td>
<p>vector to predict on</p>
</td></tr>
<tr><td><code id="lpreg_+3A_minimum.num.obs">minimum.num.obs</code></td>
<td>
<p>minimum number of observations needed to run the regression</p>
</td></tr>
<tr><td><code id="lpreg_+3A_span">span</code></td>
<td>
<p>see 'loess' function</p>
</td></tr>
<tr><td><code id="lpreg_+3A_...">...</code></td>
<td>
<p>other parameters passed to 'loess' function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predicted values at 'x.eval'
</p>

<hr>
<h2 id='meanEst'>STFIT Mean Estimation</h2><span id='topic+meanEst'></span>

<h3>Description</h3>

<p>The function is used for pixel-wise mean estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanEst(
  doy,
  mat,
  doyeval = seq(min(doy), max(doy)),
  msk = rep(FALSE, ncol(mat)),
  outlier.tol = 0.5,
  minimum.num.obs = 4,
  cluster = NULL,
  redo = TRUE,
  clipRange = c(-Inf, Inf),
  clipMethod = c("truncate", "nnr"),
  img.nrow = NULL,
  img.ncol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanEst_+3A_doy">doy</code></td>
<td>
<p>vector of day of year (DOY) index</p>
</td></tr>
<tr><td><code id="meanEst_+3A_mat">mat</code></td>
<td>
<p>data matrix. Each row contains a row stacked image pixel values.</p>
</td></tr>
<tr><td><code id="meanEst_+3A_doyeval">doyeval</code></td>
<td>
<p>a vector of DOY on which to get the mean imputation</p>
</td></tr>
<tr><td><code id="meanEst_+3A_msk">msk</code></td>
<td>
<p>an optional logistic vector. TRUE represent the corresponding pixel is always missing.</p>
</td></tr>
<tr><td><code id="meanEst_+3A_outlier.tol">outlier.tol</code></td>
<td>
<p>the tolerance value in defining an image as outlier. The percent of 
outlier pixels in an image exceed this value is regarded as outlier image which will not
be used in temporal mean estimation.</p>
</td></tr>
<tr><td><code id="meanEst_+3A_minimum.num.obs">minimum.num.obs</code></td>
<td>
<p>minimum number of observations needed for mean estimation. Too few observations
may lead to big estimation error.</p>
</td></tr>
<tr><td><code id="meanEst_+3A_cluster">cluster</code></td>
<td>
<p>an optional vector defining clusters of pixels. If NULL, mean estimation
is conducted on each pixel, otherwise all pixels from the same cluster are combined for
mean estimation.</p>
</td></tr>
<tr><td><code id="meanEst_+3A_redo">redo</code></td>
<td>
<p>whether to recalculate the mean estimation if there is an outlier (only redo once).</p>
</td></tr>
<tr><td><code id="meanEst_+3A_cliprange">clipRange</code></td>
<td>
<p>vector of length 2, specifying the minimum and maximum values of the prediction value</p>
</td></tr>
<tr><td><code id="meanEst_+3A_clipmethod">clipMethod</code></td>
<td>
<p>&quot;nnr&quot; or &quot;truncate&quot;. &quot;nnr&quot; uses average of nearest neighbor pixels to impute;
&quot;truncate use the clipRange value to truncate.</p>
</td></tr>
<tr><td><code id="meanEst_+3A_img.nrow">img.nrow</code></td>
<td>
<p>number of rows for an image, only used when 'clipMethod' is &quot;nnr&quot;</p>
</td></tr>
<tr><td><code id="meanEst_+3A_img.ncol">img.ncol</code></td>
<td>
<p>number of columns for an image, only used when 'clipMethod' is &quot;nnr&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are several predefined methods for mean estimation: <code>smooth_spline</code>, 
<code>llreg</code>, <code>lpreg</code> and <code>spreg</code>. User can use <code>opt$get()</code> to check
the current registered method and use <code>opt$set()</code> function to set the method.
For exmaple, one can run <code>opt$set(smooth_spline)</code> first and then run the 
<code>meanEst</code> function to use smoothing spline regression for mean eatimation.
User can also customize the methods for mean estimation. For example, mean estimation
through fourier basis expansion:
</p>
<pre>
.X = fda::eval.basis(1:365, fda::create.fourier.basis(rangeval=c(0,365), nbasis=11))
customfun &lt;- function(x, y, x.eval=1:365, minimum.num.obs = 10){
  nonna.idx = !is.na(y)
  if(sum(nonna.idx) &lt; minimum.num.obs)
    return(rep(NA, 365))
  ## lmfit = lm.fit(.X[unlist(lapply(x, function(x) which(x == x.eval))),], y[nonna.idx])
  lmfit = lm.fit(.X[x[nonna.idx],], y[nonna.idx])
  return(.X[x.eval,] 
}
stfit::opts_stfit$set(temporal_mean_est = customfun)
</pre>


<h3>Value</h3>

<p>a list containing the following entries:
</p>

<ul>
<li><p> doyeval: same as input <code>doyeval</code>
</p>
</li>
<li><p> meanmat: estimated mean matrix, with number of rows equals length of <code>doyeval</code>
and number of columns equal <code>ncol(mat)</code>
</p>
</li>
<li><p> idx: a list of image indexes 
</p>

<ul>
<li><p> idx.allmissing: completely missing image indexes,
</p>
</li>
<li><p> idx.partialmissing: partially observed image indexes,
</p>
</li>
<li><p> idx.fullyobserved: fully observed image indexes,
</p>
</li>
<li><p> idx.outlier: outlier image indexes.
</p>
</li></ul>

</li>
<li><p> outlier: a list of image outliers information
</p>

<ul>
<li><p> outidx: index of the outlier image
</p>
</li>
<li><p> outpct: percentage of outlier pixels corresponding to <code>outidx</code>,
</p>
</li>
<li><p> outlst: a list of the same length as <code>outidx</code>, with each list the missing pixel index.
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='NMSE'>Normalized Mean Square Estimation</h2><span id='topic+NMSE'></span>

<h3>Description</h3>

<p>Normalized Mean Square Estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMSE(y, ypred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMSE_+3A_y">y</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="NMSE_+3A_ypred">ypred</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric number. A measure of difference between y and ypred.
</p>

<hr>
<h2 id='opts_stfit'>Options for stfit</h2><span id='topic+opts_stfit'></span>

<h3>Description</h3>

<p>Options for stfit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_stfit
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>

<hr>
<h2 id='outlier'>Image Outlier Detection</h2><span id='topic+outlier'></span>

<h3>Description</h3>

<p>Image Outlier Detection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outlier_+3A_mat">mat</code></td>
<td>
<p>data matrix. Each row is a row stacked image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the following entries:
</p>

<ul>
<li><p> outidx: index of the outlier image
</p>
</li>
<li><p> outpct: percentage of outlier pixels corresponding to <code>outidx</code>,
</p>
</li>
<li><p> outlst: a list of the same length as <code>outidx</code>, with each list the missing pixel index.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dfB = landsat106[landsat106$year &gt;= 2000,]
matB = as.matrix(dfB[,-c(1:2)])
outlier(matB)
</code></pre>

<hr>
<h2 id='pctMissing'>Missing value percentages</h2><span id='topic+pctMissing'></span>

<h3>Description</h3>

<p>Missing value percentages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pctMissing(x, mc.cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pctMissing_+3A_x">x</code></td>
<td>
<p>A <code>RasterStack</code> object</p>
</td></tr>
<tr><td><code id="pctMissing_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Numer of cores to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of percent of missing values for each layer
</p>

<hr>
<h2 id='rmOutlier'>Remove outlier</h2><span id='topic+rmOutlier'></span>

<h3>Description</h3>

<p>An outlier is defined as points outside the whiskers of the boxplot
over the time domain (DOY).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmOutlier(rst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmOutlier_+3A_rst">rst</code></td>
<td>
<p>a *Raster object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a *Raster object
</p>

<hr>
<h2 id='RMSE'>Root Mean Square Estimation</h2><span id='topic+RMSE'></span>

<h3>Description</h3>

<p>Root Mean Square Estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSE(y, ypred)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RMSE_+3A_y">y</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="RMSE_+3A_ypred">ypred</code></td>
<td>
<p>vecotr</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric number. A measure of difference between y and ypred.
</p>

<hr>
<h2 id='seffEst'>STFIT Spatial Effect Estimation</h2><span id='topic+seffEst'></span>

<h3>Description</h3>

<p>STFIT Spatial Effect Estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seffEst(
  rmat,
  img.nrow,
  img.ncol,
  h.cov = 2,
  h.sigma2 = 2,
  weight.cov = NULL,
  weight.sigma2 = NULL,
  nnr,
  method = c("lc", "emp"),
  partial.only = TRUE,
  pve = 0.99,
  msk = NULL,
  msk.tol = 0.95,
  var.est = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seffEst_+3A_rmat">rmat</code></td>
<td>
<p>residual matrix</p>
</td></tr>
<tr><td><code id="seffEst_+3A_img.nrow">img.nrow</code></td>
<td>
<p>image row dimension</p>
</td></tr>
<tr><td><code id="seffEst_+3A_img.ncol">img.ncol</code></td>
<td>
<p>image column dimension</p>
</td></tr>
<tr><td><code id="seffEst_+3A_h.cov">h.cov</code></td>
<td>
<p>bandwidth for spatial covariance estimation; ignored if <code>weight.cov</code> is supplied</p>
</td></tr>
<tr><td><code id="seffEst_+3A_h.sigma2">h.sigma2</code></td>
<td>
<p>bandwidth for sigma2 estimation</p>
</td></tr>
<tr><td><code id="seffEst_+3A_weight.cov">weight.cov</code></td>
<td>
<p>weight matrix for spatial covariance estimation</p>
</td></tr>
<tr><td><code id="seffEst_+3A_weight.sigma2">weight.sigma2</code></td>
<td>
<p>weight vector for spatial variance estimation</p>
</td></tr>
<tr><td><code id="seffEst_+3A_nnr">nnr</code></td>
<td>
<p>maximum number of nearest neighbor pixels to use for spatial covariance estimation</p>
</td></tr>
<tr><td><code id="seffEst_+3A_method">method</code></td>
<td>
<p>&quot;lc&quot; for local constant covariance estimation and &quot;emp&quot; for empirical covariance estimation</p>
</td></tr>
<tr><td><code id="seffEst_+3A_partial.only">partial.only</code></td>
<td>
<p>calculate the spatical effect for partially observed images only, default is TRUE</p>
</td></tr>
<tr><td><code id="seffEst_+3A_pve">pve</code></td>
<td>
<p>percent of variance explained of the selected eigen values. Default is 0.99.</p>
</td></tr>
<tr><td><code id="seffEst_+3A_msk">msk</code></td>
<td>
<p>an optional logistic vector. TRUE represent the corresponding pixel is always missing.</p>
</td></tr>
<tr><td><code id="seffEst_+3A_msk.tol">msk.tol</code></td>
<td>
<p>if 'msk' is not given, the program will determine the mask using <code>getMask</code>
function. If the percentage of missing values for a pixel over time is greater than this</p>
</td></tr>
<tr><td><code id="seffEst_+3A_var.est">var.est</code></td>
<td>
<p>Whether to estimate the variance of the temporal effect. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 3 with entries:
</p>

<ul>
<li><p> seff_mat: estimated spatial effect matrix of the same shape as <code>rmat</code>.
</p>
</li>
<li><p> seff_var_mat: estimated spatial effect variance matrix of the same shape as <code>rmat</code>.
</p>
</li>
<li><p> idx: a list of two entries:
</p>

<ul>
<li><p> idx.allmissing: index of the completely missing images.
</p>
</li>
<li><p> idx.imputed: index of the partially observed images, where spatial effects 
are estimated.
</p>
</li></ul>

</li></ul>


<hr>
<h2 id='smooth_spline'>Smoothing spline regression</h2><span id='topic+smooth_spline'></span>

<h3>Description</h3>

<p>Smoothing spline regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_spline(x, y, x.eval = x, minimum.num.obs = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_spline_+3A_x">x</code></td>
<td>
<p>independent variable</p>
</td></tr>
<tr><td><code id="smooth_spline_+3A_y">y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="smooth_spline_+3A_x.eval">x.eval</code></td>
<td>
<p>vector to predict on</p>
</td></tr>
<tr><td><code id="smooth_spline_+3A_minimum.num.obs">minimum.num.obs</code></td>
<td>
<p>minimum number of observations needed to run the regression</p>
</td></tr>
<tr><td><code id="smooth_spline_+3A_...">...</code></td>
<td>
<p>other parameters to be passed to <code>smooth.spline</code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predicted values at 'x.eval'
</p>

<hr>
<h2 id='spreg'>spline regression</h2><span id='topic+spreg'></span>

<h3>Description</h3>

<p>spline regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spreg(
  x,
  y,
  x.eval,
  minimum.num.obs = 4,
  basis = c("fourier", "bspline"),
  rangeval = c(min(x.eval) - 1, max(x.eval)),
  nbasis = 11,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spreg_+3A_x">x</code></td>
<td>
<p>independent variable</p>
</td></tr>
<tr><td><code id="spreg_+3A_y">y</code></td>
<td>
<p>response variable</p>
</td></tr>
<tr><td><code id="spreg_+3A_x.eval">x.eval</code></td>
<td>
<p>vector to predict on</p>
</td></tr>
<tr><td><code id="spreg_+3A_minimum.num.obs">minimum.num.obs</code></td>
<td>
<p>minimum number of observations needed to run the regression</p>
</td></tr>
<tr><td><code id="spreg_+3A_basis">basis</code></td>
<td>
<p>what basis to use, &quot;fourier&quot; and &quot;bspline&quot; are available</p>
</td></tr>
<tr><td><code id="spreg_+3A_rangeval">rangeval</code></td>
<td>
<p>see <code>fda::create.basis</code></p>
</td></tr>
<tr><td><code id="spreg_+3A_nbasis">nbasis</code></td>
<td>
<p>see <code>fda::create.basis</code></p>
</td></tr>
<tr><td><code id="spreg_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>fad::create.basis</code> functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>predicted values at 'x.eval'
</p>

<hr>
<h2 id='stfit_landsat'>STFIT for Landsat data</h2><span id='topic+stfit_landsat'></span>

<h3>Description</h3>

<p>This function is used for Landsat data imputation, which includes five steps: 
mean estimation, outlier detection, temporal effect estimation, spatial effect
estimation and imputation. In real application, one can use this as a template
to create a five steps imputation procedure depending on the real data structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stfit_landsat(
  year,
  doy,
  mat,
  img.nrow,
  img.ncol,
  doyeval = 1:365,
  h.tcov = 100,
  h.tsigma2 = 300,
  h.scov = 2,
  h.ssigma2 = 2,
  nnr = 10,
  outlier.action = c("keep", "remove"),
  outlier.tol = 0.2,
  intermediate.save = TRUE,
  intermediate.dir = "./intermediate_output/",
  use.intermediate.result = TRUE,
  teff = TRUE,
  seff = TRUE,
  doy.break = NULL,
  cycle = FALSE,
  t.grid = NULL,
  t.grid.num = 50,
  clipRange = c(0, 1800),
  clipMethod = "nnr",
  var.est = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stfit_landsat_+3A_year">year</code></td>
<td>
<p>vecotr of year</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_doy">doy</code></td>
<td>
<p>vecotr of DOY (day of the year)</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_mat">mat</code></td>
<td>
<p>a numeric matrix. Each row contains a row stacked image pixel values.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_img.nrow">img.nrow</code></td>
<td>
<p>number of rows of the image</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_img.ncol">img.ncol</code></td>
<td>
<p>number of columns of the image</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_doyeval">doyeval</code></td>
<td>
<p>a vector of DOY on which to get the mean and temporal imputation</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_h.tcov">h.tcov</code></td>
<td>
<p>bandwidth for temporal covariance estimation</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_h.tsigma2">h.tsigma2</code></td>
<td>
<p>bandwith for temporal variance estimation</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_h.scov">h.scov</code></td>
<td>
<p>bandwidth for spatial covariance estimation</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_h.ssigma2">h.ssigma2</code></td>
<td>
<p>bandwidth for spatial variance estimation</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_nnr">nnr</code></td>
<td>
<p>maximum number of nearest neighbor pixels to use for spatial covariance estimation</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_outlier.action">outlier.action</code></td>
<td>
<p>&quot;keep&quot; to keep outliers; &quot;remove&quot; to replace outliers with imputed values</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_outlier.tol">outlier.tol</code></td>
<td>
<p>The threshold to use to define outlier image. Default is 0.2, i.e. images
with more than 20% outlier pixels are treated as outlier image.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_intermediate.save">intermediate.save</code></td>
<td>
<p>TRUE or FASLE; whether to save the intermediate results including
mean, temporal effect and spacial effect imputation resutls. The intermediate results can be
useful to avoid duplicating the computation for some imputation steps.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_intermediate.dir">intermediate.dir</code></td>
<td>
<p>directory where to save the intermediate results</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_use.intermediate.result">use.intermediate.result</code></td>
<td>
<p>whether to use the intermediate results in the 'intermediate.dir' folder. 
Default is TRUE.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_teff">teff</code></td>
<td>
<p>TRUE or FALSE, wheter to calculate the temporal effect. Default is TRUE.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_seff">seff</code></td>
<td>
<p>TRUE or FALSE, wheter to calculate the spatial effect. Default is TRUE.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_doy.break">doy.break</code></td>
<td>
<p>a vector of break points for <code>doy</code> where the spatial effect are 
estimated seperately on each interval. Default is NULL, i.e. the spatial effect is assumed
to be the same over <code>doy</code>.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_cycle">cycle</code></td>
<td>
<p>TRUE or FALSE. When <code>doy.break</code> is specified, whether to combine the first
<code>doy.break</code> interval and the last <code>doy.break</code> together for spatial effect estimation.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_t.grid">t.grid</code></td>
<td>
<p>a vector of grid points on which to calculate the temporal covariance function</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_t.grid.num">t.grid.num</code></td>
<td>
<p>number of grid points to use for temporal covariance estimation. 
Ignored if <code>t.grid</code> is given.</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_cliprange">clipRange</code></td>
<td>
<p>passed to <code>meanEst</code> function</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_clipmethod">clipMethod</code></td>
<td>
<p>passed to <code>meanEst</code> function</p>
</td></tr>
<tr><td><code id="stfit_landsat_+3A_var.est">var.est</code></td>
<td>
<p>Whether to estimate the variance of the temporal and spatial effects. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 4 with entries:
</p>

<ul>
<li><p> imat: imputed matrix of <code>mat</code>
</p>
</li>
<li><p> smat: standard error matrix of the same size as <code>mat</code>
</p>
</li>
<li><p> idx: a list of image indexes 
</p>

<ul>
<li><p> idx.allmissing: completely missing image indexes,
</p>
</li>
<li><p> idx.partialmissing: partially observed image indexes,
</p>
</li>
<li><p> idx.fullyobserved: fully observed image indexes,
</p>
</li>
<li><p> idx.outlier: outlier image indexes.
</p>
</li></ul>

</li>
<li><p> outlier: a list of image outliers information
</p>

<ul>
<li><p> outidx: image index with outlier pixels,
</p>
</li>
<li><p> outpct: percentage of outlier pixels corresponding to <code>outidx</code>,
</p>
</li>
<li><p> outlst: a list of the same length as <code>outidx</code>, with each list the missing 
pixel index.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(doParallel)
library(raster)
library(rasterVis)
library(RColorBrewer)
dfB = landsat106[landsat106$year &gt;= 2000,]
matB = as.matrix(dfB[,-c(1:2)])
year = dfB$year
doy = dfB$doy
if(require(doParallel))
  registerDoParallel(1)
res &lt;- stfit_landsat(year, doy, matB, 31, 31, nnr=30,
use.intermediate.result = FALSE, intermediate.save = FALSE, var.est = TRUE)
## visualize the imputed results
idx = c(res$idx$idx.allmissing[150], res$idx$idx.partialmissing[c(30, 60, 90)])
rst_list = list()
for(i in 1:length(idx)){
  rst_list[(i-1)*3+1] = raster(matrix(matB[idx[i],], 31))
  rst_list[(i-1)*3+2] = raster(matrix(res$imat[idx[i],], 31))
  rst_list[(i-1)*3+3] = raster(matrix(res$sdmat[idx[i],], 31))
}
s = stack(rst_list)
levelplot(s, index.cond=list(c(seq(1, 12, 3), seq(2, 12, 3), seq(3, 12, 3))),
          par.setting = rasterTheme(panel.background=list(col="black"),
                                    region = brewer.pal(9, 'YlOrRd')),
          names.attr = c(rbind(paste0("Original ", idx), 
                               paste0("Imputed ", idx),
                               paste0("Std. Error ", idx))),
          layout = c(4,3))


</code></pre>

<hr>
<h2 id='stfit-package'>stfit: Spatial-Temporal Functional Imputation Tool</h2><span id='topic+stfit-package'></span>

<h3>Description</h3>

<p>The stfit package provides functions to impute missing values for a 
sequence of observed images for the same location using functional
data analysis technique
</p>

<hr>
<h2 id='teffEst'>STFIT Temporal Effect Estimation</h2><span id='topic+teffEst'></span>

<h3>Description</h3>

<p>STFIT Temporal Effect Estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teffEst(
  ids,
  doy,
  rmat,
  doyeval = seq(min(doy), max(doy)),
  h.cov = 100,
  h.sigma2 = 300,
  weight.cov = NULL,
  weight.sigma2 = NULL,
  pve = 0.99,
  t.grid = NULL,
  t.grid.num = 50,
  var.est = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="teffEst_+3A_ids">ids</code></td>
<td>
<p>ids for 'group', for data with repeated measurement over years, year is ids; 
for pixels belong to certain clusters, cluster is ids.</p>
</td></tr>
<tr><td><code id="teffEst_+3A_doy">doy</code></td>
<td>
<p>vecotr of DOY (day of the year)</p>
</td></tr>
<tr><td><code id="teffEst_+3A_rmat">rmat</code></td>
<td>
<p>residual matrix with rows corresponding to <code>doy</code> and columns corresponding to pixel index</p>
</td></tr>
<tr><td><code id="teffEst_+3A_doyeval">doyeval</code></td>
<td>
<p>a vector of DOY on which to get the temporal imputation</p>
</td></tr>
<tr><td><code id="teffEst_+3A_h.cov">h.cov</code></td>
<td>
<p>bandwidth for temporal covariance estimation; ignored if <code>weight.cov</code> is supplied</p>
</td></tr>
<tr><td><code id="teffEst_+3A_h.sigma2">h.sigma2</code></td>
<td>
<p>bandwidth for temporal variance estimation</p>
</td></tr>
<tr><td><code id="teffEst_+3A_weight.cov">weight.cov</code></td>
<td>
<p>weight vector for temporal covariance estimation</p>
</td></tr>
<tr><td><code id="teffEst_+3A_weight.sigma2">weight.sigma2</code></td>
<td>
<p>weight vector for temporal variance estimation</p>
</td></tr>
<tr><td><code id="teffEst_+3A_pve">pve</code></td>
<td>
<p>percentage of variance explained; used for number of eigen values selection. Default is 0.99.</p>
</td></tr>
<tr><td><code id="teffEst_+3A_t.grid">t.grid</code></td>
<td>
<p>a vector of grid points on which to calculate the temporal covariance function</p>
</td></tr>
<tr><td><code id="teffEst_+3A_t.grid.num">t.grid.num</code></td>
<td>
<p>number of grid points to use for temporal covariance estimation. Ignored if <code>t.grid</code> is given.</p>
</td></tr>
<tr><td><code id="teffEst_+3A_var.est">var.est</code></td>
<td>
<p>Whether to estimate the variance of the temporal effect. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of length 2 with entries:
</p>

<ul>
<li><p> teff_array: 3-d array with first dimention 'ids', second dimention 'doy' and third
dimention pixel index.
</p>
</li>
<li><p> teff_var_array: same structure as <code>teff_array</code> if <code>var.est</code> is TRUE,
otherwise NULL.
</p>
</li></ul>


<hr>
<h2 id='weightMatrix'>Weight matrix calculation</h2><span id='topic+weightMatrix'></span>

<h3>Description</h3>

<p>Weight matrix calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightMatrix(h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightMatrix_+3A_h">h</code></td>
<td>
<p>'bandwith'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a weighting matrix
</p>

<hr>
<h2 id='weightVector'>Weight vector calculation</h2><span id='topic+weightVector'></span>

<h3>Description</h3>

<p>Weight vector calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightVector(h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightVector_+3A_h">h</code></td>
<td>
<p>bandwidth, should be positive numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
