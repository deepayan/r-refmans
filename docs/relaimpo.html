<!DOCTYPE html><html lang="en"><head><title>Help for package relaimpo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {relaimpo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#relaimpo-package'><p> Package to calculate relative importance metrics for linear models</p></a></li>
<li><a href='#booteval.relimp'><p> Functions to Bootstrap Relative Importance Metrics</p></a></li>
<li><a href='#calc.relimp'><p> Function to calculate relative importance metrics for linear models</p></a></li>
<li><a href='#classesmethods.relaimpo'><p> Classes and Methods in Package relaimpo</p></a></li>
<li><a href='#mianalyze.relimp'><p>Function to do relative importance calculations based on multiply imputed datasets</p></a></li>
<li><a href='#relimplm-class'><p>Class relimplm</p></a></li>
<li><a href='#relimplmboot-class'><p>Class relimplmboot</p></a></li>
<li><a href='#relimplmbooteval-class'><p>Class relimplmbooteval</p></a></li>
<li><a href='#relimplmbootMI-class'><p>Class relimplmbootMI</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Relative Importance of Regressors in Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-04</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides several metrics for assessing relative importance in linear models. These can be printed, plotted and bootstrapped. The recommended metric is lmg, which provides a decomposition of the model explained variance into non-negative contributions. There is a version of this package available that additionally provides a new and also recommended metric called pmvd. If you are a non-US user, you can download this extended version from Ulrike Groempings web site.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.2.1), MASS, boot, survey, mitools, graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, corpcor</td>
</tr>
<tr>
<td>Suggests:</td>
<td>care</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrike Groemping &lt;ulrike.groemping@bht-berlin.de&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://prof.bht-berlin.de/groemping/relaimpo/">https://prof.bht-berlin.de/groemping/relaimpo/</a>,
<a href="https://prof.bht-berlin.de/groemping/">https://prof.bht-berlin.de/groemping/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrike Groemping [aut, cre],
  Matthias Lehrkamp [ctb]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-04 09:11:39 UTC; groemping</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-04 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='relaimpo-package'> Package to calculate relative importance metrics for linear models  </h2><span id='topic+relaimpo-package'></span><span id='topic+relaimpo'></span>

<h3>Description</h3>

<p><span class="pkg">relaimpo</span> calculates several relative importance metrics for the linear model. 
The recommended metrics are <code>lmg</code> (<code class="reqn">R^2</code> partitioned by averaging over orders, like in Lindemann, Merenda and Gold (1980, p.119ff)) 
and <code>pmvd</code> (a newly proposed metric by Feldman (2005), non-US version only). 
For completeness, several other metrics are also on offer. Other packages with related topics: <code>hier.part</code>, <code>relimp</code>.
</p>


<h3>Details</h3>

<p><span class="pkg">relaimpo</span> calculates the metrics and also offers the possibility of bootstrapping them and of displaying results in print and graphically. 
</p>
<p>It is possible to designate a subset of variables as adjustment variables that always stay in the model so that relative importance is only 
assessed among the remaining variables.
</p>
<p>Models can have up to 2-way interactions that are treated hierarchically - i.e. an interaction is only allowed in a model that also contains all its main effects.
In case of interactions, only metric <code>lmg</code> can be used. 
</p>
<p>Observations with missing values are by default excluded from the analysis for most functions. 
The function <code><a href="#topic+mianalyze.relimp">mianalyze.relimp</a></code> allows to draw conclusions from a set of multiply imputed data sets. 
This function is currently more restrictive than the rest of the package in terms of data types and models 
that can be used (when summarizing the multiply imputed samples without calculating confidence intervals, 
all possibilities available elsewhere are also applicable in <code><a href="#topic+mianalyze.relimp">mianalyze.relimp</a></code>).
</p>
<p><span class="pkg">relaimpo</span> does accomodate complex survey designs by making use of the facilities in package <span class="pkg">survey</span>. 
Currently, interactions and calculated variables cannot be combined with using a complex survey design in bootstrapping functions. 
</p>


<h3>Acknowlegment </h3>

<p> This package uses as an internal function the function <code>nchoosek</code> from <span class="pkg">vsn</span>, authored by Wolfgang Huber, available under LGPL. 
Furthermore, it uses a modified version of the function carscore from <span class="pkg">care</span> by Verena Zuber and Korbinian Strimmer.</p>


<h3>Warning </h3>

<p><code>lmg</code> and <code>pmvd</code> are computer-intensive. Although they are calculated based on the 
covariance matrix, which saves substantial computing time in comparison to carrying out actual regressions, 
these methods still take quite long for problems with many regressors. Obviously, 
this is particularly relevant in combination with bootstrapping.
</p>


<h3>Note</h3>

<p> There are two versions of this package. The version on CRAN is globally licensed under GPL version 2 (or later). 
There is an extended version with the interesting additional metric <code>pmvd</code> that is licensed according to GPL version 2
under the geographical restriction &quot;outside of the US&quot; because of potential issues with US patent 6,640,204. This version can be obtained 
from Ulrike Groempings website (cf. references section). Whenever you load the package, a display tells you, which version you are loading. </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

 
<p>Chevan, A. and Sutherland, M. (1991) Hierarchical Partitioning. <em>The American Statistician</em> <b>45</b>, 90&ndash;96.
</p>
<p>Darlington, R.B. (1968) Multiple regression in psychological research and practice. <em>Psychological Bulletin</em>  <b>69</b>, 161&ndash;182.
</p>
<p>Feldman, B. (2005) Relative Importance and Value. Manuscript (Version 1.1, March 19 2005), downloadable at <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2255827">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2255827</a>
</p>
<p>Genizi, A. (1993) Decomposition of R2 in multiple regression with correlated regressors. <em>Statistica Sinica</em> <b>3</b>, 407&ndash;420. 
Downloadable at <a href="https://www3.stat.sinica.edu.tw/statistica/password.asp?vol=3&amp;num=2&amp;art=10">https://www3.stat.sinica.edu.tw/statistica/password.asp?vol=3&amp;num=2&amp;art=10</a>
</p>
<p>Groemping, U. (2006) Relative Importance for Linear Regression in R: The Package relaimpo 
<em>Journal of Statistical Software</em> <b>17</b>, Issue 1. 
Downloadable at <a href="https://www.jstatsoft.org/v17/i01">https://www.jstatsoft.org/v17/i01</a>
</p>
<p>Lindeman, R.H., Merenda, P.F. and Gold, R.Z. (1980) <em>Introduction to Bivariate and Multivariate Analysis</em>, Glenview IL: Scott, Foresman.
</p>
<p>Zuber, V. and Strimmer, K. (2010) <em>Variable importance and model selection by decorrelation</em>. Preprint, downloadable at <a href="https://arxiv.org/abs/1007.5516">https://arxiv.org/abs/1007.5516</a>
</p>
<p>Go to <a href="https://prof.bht-berlin.de/groemping/relaimpo/">https://prof.bht-berlin.de/groemping/relaimpo/</a> for further information and references.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+calc.relimp">calc.relimp</a></code>, <code><a href="#topic+booteval.relimp">booteval.relimp</a></code>, <code><a href="#topic+mianalyze.relimp">mianalyze.relimp</a></code>,
<code><a href="#topic+classesmethods.relaimpo">classesmethods.relaimpo</a></code>, package <span class="pkg">hier.part</span>, package <span class="pkg">survey</span></p>

<hr>
<h2 id='booteval.relimp'> Functions to Bootstrap Relative Importance Metrics </h2><span id='topic+boot.relimp'></span><span id='topic+boot.relimp.default'></span><span id='topic+boot.relimp.formula'></span><span id='topic+boot.relimp.lm'></span><span id='topic+booteval.relimp'></span>

<h3>Description</h3>

<p>These functions provide bootstrap confidence intervals for relative importances. 
<code>boot.relimp</code> uses the R package boot to do the actual bootstrapping of requested metrics 
(which may take quite a while), 
while <code>booteval.relimp</code> evaluates the results and provides confidence intervals.
Output from <code>booteval.relimp</code> is printed with a tailored print method, and a plot method
produces bar plots with confidence indication of the relative importance metrics. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## generic function
boot.relimp(object, ...)

## default S3 method
## Default S3 method:
boot.relimp(object, x = NULL, ..., b = 1000, type = "lmg", 
    rank = TRUE, diff = TRUE, rela = FALSE, always = NULL, 
    groups = NULL, groupnames = NULL, fixed=FALSE, 
    weights = NULL, design = NULL)

## S3 method for formula objects
## S3 method for class 'formula'
boot.relimp(formula, data, weights, na.action, ..., subset = NULL)

## S3 method for objects of class lm
## S3 method for class 'lm'
boot.relimp(object, type = "lmg", groups = NULL, groupnames=NULL, always = NULL, 
    ..., b=1000)

## function for evaluating bootstrap results
booteval.relimp(bootrun, bty = "perc", level = 0.95, 
    sort = FALSE, norank = FALSE, nodiff = FALSE, 
    typesel = c("lmg", "pmvd", "last", "first", "betasq", "pratt", "genizi", "car"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="booteval.relimp_+3A_object">object</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_formula">formula</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.
But note the additional restriction that - in connection with the <code>design=</code>-option - 
it is currently not possible to use factors, interactions or calculated quantities in a formula.
</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_x">x</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_b">b</code></td>
<td>
<p> is the number of bootstrap runs requested on boot.relimp (default: <code>b=1000</code>). 
Make sure to set this to a lower number, if you are simply testing code. </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_type">type</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_rank">rank</code></td>
<td>
<p> is a logical requesting bootstrapping of ranks (<code>rank=TRUE</code>, default) for each metric from type </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_diff">diff</code></td>
<td>
<p> is a logical requesting bootstrapping of pairwise differences in relative importance (<code>diff=TRUE</code>, 
default) for each metric in type </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_rela">rela</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_always">always</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_groups">groups</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_groupnames">groupnames</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_weights">weights</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code> for specification of weights. 
See also the Details section of this help page for usage of different types of weights. </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_design">design</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>. But note that there are 
currently some restrictions regarding usability of other possibilities, when using a <code>design</code> 
in <code>boot.relimp</code>: formulae can only be simpler than usual, and factors, interactions or 
calculated variables in formulae are not permitted.
</p>
<p>For a description of the bootstrap method's treatment of designs, see the details section.
In the current version, using a design in bootstrapping must be considered EXPERIMENTAL.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_fixed">fixed</code></td>
<td>
<p> is a logical requesting bootstrapping for a fixed design matrix (if TRUE). 
The default is bootstrapping for randomly drawn samples (fixed = FALSE). </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_data">data</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_subset">subset</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_na.action">na.action</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_...">...</code></td>
<td>
<p> usable for further arguments, particularly all arguments of the default method can be given to all other methods </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_bootrun">bootrun</code></td>
<td>
<p> is an object of class <code>relimplmboot</code> created by function <code>boot.relimp</code>. 
It hands over all relevant information on the bootstrap runs to function <code>booteval.relimp</code>. </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_bty">bty</code></td>
<td>
<p> is the type of bootstrap interval requested (a character string), 
as handed over to the function <code>boot.ci</code> from package <code>boot</code>. 
Possible choices are <code>bca</code>, <code>perc</code>, <code>basic</code> and <code>norm</code>. 
<code>student</code> is not supported.  </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_level">level</code></td>
<td>
<p> is a single confidence level or a numeric vector of confidence levels. </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_sort">sort</code></td>
<td>
<p> is a logical requesting output sorted by size of relative contribution (<code>sort=TRUE</code>) or by variable position in list (<code>sort=FALSE</code>, default). </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_norank">norank</code></td>
<td>
<p> is a logical that suppresses of rank letters (<code>norank=TRUE</code>) even if ranks have been bootstrapped. </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_nodiff">nodiff</code></td>
<td>
<p> is a logical that suppresses output of confidence intervals for differences (<code>nodiff=TRUE</code>), even if differences have been bootstrapped. </p>
</td></tr>
<tr><td><code id="booteval.relimp_+3A_typesel">typesel</code></td>
<td>
<p> provides the metrics that are to be reported. Default: all available ones 
(intersection of those available in object <code>bootrun</code> and those requested in <code>typesel</code>). 
<code>typesel</code> accepts the same values as <code>type</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculations of metrics are based on the function <code>calc.relimp</code>. 
Bootstrapping is done with the R package <code>boot</code>, 
resampling the full observation vectors by default (combinations of response, weights and regressors, cf. Fox (2002)). 
If <code>fixed=TRUE</code> is specified, bootstrapping is based on residuals rather than full observations, 
keeping the X-variables fixed.
</p>
<p>If the <code>weights</code> option is used, weights are resampled together with the full observations, 
and weighted contributions are calculated for each resample (no re-normalization is done within the resamples.)
</p>
<p>Please note that usage of weights in linear models can have very different reasons. 
One motivation is a different variability of different observations, where weights are the inverse variances. 
This is the way <code>weights</code> are treated in function <code>lm</code> and also in <code>calc.relimp</code> and in <code>boot.relimp</code>, 
if a vector of weights is given with the <code>weights</code> option. Specifically, weights do not affect the 
resampling probability in bootstrapping, i.e. each observation has the same probability to be included in resamples.
</p>
<p>If the weights in a data frame represent the multiplicity of each observation (i.e. there are several units with 
identical combination of values in the data, and the weights represent the number of units with exactly this value 
pattern for each row of the data frame), they can also be directly used as weights in <code>calc.relimp</code> for 
calculating the metrics. However, such frequency weights cannot be appropriately accomodated in <code>boot.relimp</code>; 
instead, the data frame with frequencies has to be expanded to include one row for each unit before using the 
resampling routine (e.g. using function <code>untable</code> from package <span class="pkg">reshape</span> or function <code>expand.table</code> 
from package <span class="pkg">epitools</span>.
</p>
<p>In survey situations, weights are used to generate a more representative picture of the population: 
an observation's weight is typically the number of units of the population that this single observed unit represents. 
In this situation, there is no reason to consider observations with higher weights as less variable than observations 
with lower weights; thus, while estimates can again be obtained treating the weights in the same way as mentioned before,
their usage in estimation of standard errors and in bootstrapping is different. 
In order to appropriately accomodate survey weights for these purposes, it is not sufficient to only provide the 
weights vector; instead, it is necessary to provide a design generated with package <span class="pkg">survey</span> or an object of 
class <code>svyglm</code> (produced by function <code>svyglm</code>) that includes the appropriate design information.
</p>
<p>Clusters are a way to take care of dependency structures like in longitudinal data. 
Thus, while relaimpo does not (currently) cover linear mixed models (e.g. produced by function <code>lme</code>), it is possible to 
accomodate clustered data by applying function <code>svyglm</code> with linear link function and gaussian distribution 
to a design that contains clusters. The bootstrapping approach subsequently takes care of the dependence by considering 
clusters as sampling units. Users who want to use this approach can mimic the second example below.
</p>
<p>If the <code>design</code> option is used (experimental), resampling is done within package <span class="pkg">survey</span>, 
and the resampled contributions are also calculated within package survey. The results from these calculations 
are plugged into an object from package <span class="pkg">boot</span>, and confidence interval calculation is subsequently handled in 
<span class="pkg">boot</span>. The approach is considered experimental: so far no simulation studies have been conducted for 
complex survey designs, and because of limited experience (in spite of thorough testing) it is not unlikely that 
bugs will be found by users who are routinely using complex survey designs.
</p>
<p>The output provides results for all selected relative importance metrics. 
The output object can be printed and plotted (description of syntax: <code><a href="#topic+classesmethods.relaimpo">classesmethods.relaimpo</a></code>).   
</p>
<p>Printed output: In addition to the standard output of <code>calc.relimp</code> 
(one row for each regressor, one column for each bootstrapped metric), 
there is a table of confidence intervals for each selected metric 
(one row per combination of regressor and metric). 
This table is enhanced by information on rank confidence intervals, 
if ranks have been bootstrapped (<code>rank=TRUE</code>) and <code>norank=FALSE</code>. 
In addition, if differences have been bootstrapped (<code>diff=TRUE</code>) and <code>nodiff=FALSE</code>, 
there is a table of estimated pairwise differences with confidence intervals.
</p>
<p>Graphical output: Application of the plot method to the object created by <code>booteval.relimp</code> 
yields barplot representations for all bootstrapped metrics (all in one graphics window). Confidence level (<code>lev=</code>) 
and number of characters in variable names to be used (<code>names.abbrev=</code>) can be modified. 
Confidence bounds are indicated on the graphs by added vertical lines. 
<code>par()</code> options can be used for modifying output (exceptions: <code>mfrow</code>, <code>oma</code> and 
<code>mar</code> are overridden by the plot method).
</p>


<h3>Value</h3>

<p>The value of <code>boot.relimp</code> is of class <code>relimplmboot</code>. It is designed to be useful as input for <code>booteval.relimp</code> and is not further described here. 
<code>booteval.relimp</code> returns an object of class <code>relimplmbooteval</code>, the items of which can be accessed by 
the <code>$</code> or the <code>@</code> extractors. 
</p>
<p>In addition to the items described for function <code><a href="#topic+calc.relimp">calc.relimp</a></code>, which are also available here, 
the following items may be of interest for further calculations:
</p>
<table role = "presentation">
<tr><td><code>metric.lower</code></td>
<td>
<p>matrix of lower confidence bounds for &ldquo;metric&rdquo;: one row for each confidence level, 
one column for each element of &ldquo;metric&rdquo;. &ldquo;metric&rdquo; can be any of <code>lmg</code>, <code>lmg.rank</code>, 
<code>lmg.diff</code>, ... 
(replace <code>lmg</code> with other available relative importance metrics, cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>)</p>
</td></tr>
<tr><td><code>metric.upper</code></td>
<td>
<p>matrix of upper confidence bounds for &ldquo;metric&rdquo;: one row for each confidence level, 
one column for each element of &ldquo;metric&rdquo;</p>
</td></tr>
<tr><td><code>metric.boot</code></td>
<td>
<p>matrix of bootstrap results for &ldquo;metric&rdquo;: one row for each bootstrap run, 
one column for each element of &ldquo;metric&rdquo;. 
Here, &ldquo;metric&rdquo; can be chosen as any of the above-mentioned and also as <code class="reqn">R^2</code></p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>number of bootstrap runs underlying the evaluations</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>confidence levels</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The bootstrap confidence intervals should be used for exploratory purposes only. 
They can be somewhat liberal: Limited simulations for percentile intervals have shown that non-coverage probabilities 
can be up to twice the nominal probabilities. More investigations are needed.
</p>
<p>Be aware that the method itself needs some computing time in case of many regressors. 
Hence, bootstrapping should be used with awareness of computing time issues.
</p>
<p><code>relaimpo</code> is a package for univariate linear models. 
Using <code>relaimpo</code> on objects that inherit from class <code>lm</code> but are not univariate linear model objects 
may produce nonsensical results without warning. Objects of class <code>mlm</code> or <code>glm</code> with link functions other than identity 
or family other than gaussian lead to an error message. 
</p>


<h3>Note</h3>

<p> There are two versions of this package. The version on CRAN is globally licensed under GPL version 2 (or later). 
There is an extended version with the interesting additional metric <code>pmvd</code> that is licensed according to GPL version 2
under the geographical restriction &quot;outside of the US&quot; because of potential issues with US patent 6,640,204. This version can be obtained 
from Ulrike Groempings website (cf. references section). Whenever you load the package, a display tells you, which version you are loading. </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

<p>Chevan, A. and Sutherland, M. (1991) Hierarchical Partitioning. <em>The American Statistician</em> <b>45</b>, 90&ndash;96.
</p>
<p>Darlington, R.B. (1968) Multiple regression in psychological research and practice. <em>Psychological Bulletin</em>  <b>69</b>, 161&ndash;182.
</p>
<p>Feldman, B. (2005) Relative Importance and Value. Manuscript (Version 1.1, March 19 2005), downloadable at <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2255827">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2255827</a>
</p>
<p>Fox, J. (2002) Bootstrapping regression models. <em>An R and S-PLUS Companion to Applied Regression: A web appendix to the book</em>.  
<a href="https://socialsciences.mcmaster.ca/jfox/Books/Companion-2E/appendix/Appendix-Bootstrapping.pdf">https://socialsciences.mcmaster.ca/jfox/Books/Companion-2E/appendix/Appendix-Bootstrapping.pdf</a>.
</p>
<p>Genizi, A. (1993) Decomposition of R2 in multiple regression with correlated regressors. <em>Statistica Sinica</em> <b>3</b>, 407&ndash;420. 
Downloadable at <a href="https://www3.stat.sinica.edu.tw/statistica/password.asp?vol=3&amp;num=2&amp;art=10">https://www3.stat.sinica.edu.tw/statistica/password.asp?vol=3&amp;num=2&amp;art=10</a>
</p>
<p>Groemping, U. (2006) Relative Importance for Linear Regression in R: The Package relaimpo 
<em>Journal of Statistical Software</em> <b>17</b>, Issue 1. 
Downloadable at <a href="https://www.jstatsoft.org/v17/i01">https://www.jstatsoft.org/v17/i01</a>
</p>
<p>Lindeman, R.H., Merenda, P.F. and Gold, R.Z. (1980) <em>Introduction to Bivariate and Multivariate Analysis</em>, Glenview IL: Scott, Foresman.
</p>
<p>Zuber, V. and Strimmer, K. (2010) <em>Variable importance and model selection by decorrelation</em>. Preprint, downloadable at <a href="https://arxiv.org/abs/1007.5516">https://arxiv.org/abs/1007.5516</a>
</p>
<p>Go to <a href="https://prof.bht-berlin.de/groemping/relaimpo/">https://prof.bht-berlin.de/groemping/relaimpo/</a> for further information and references.
</p>


<h3>See Also</h3>

 <p><span class="pkg"><a href="#topic+relaimpo">relaimpo</a></span>, <code><a href="#topic+calc.relimp">calc.relimp</a></code>, <code><a href="#topic+mianalyze.relimp">mianalyze.relimp</a></code>, 
<code><a href="#topic+classesmethods.relaimpo">classesmethods.relaimpo</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################################################################
### Example: relative importance of various socioeconomic indicators 
###          for Fertility in Switzerland
### Fertility is first column of data set swiss
#####################################################################
data(swiss)
   # bootstrapping
       bootswiss &lt;- boot.relimp(swiss, b = 100,  
                type = c("lmg", "last", "first", "pratt"),
                rank = TRUE, diff = TRUE, rela = TRUE)
       # for demonstration purposes only 100 bootstrap replications

       #alternatively, use formula interface
       bootsub &lt;- boot.relimp(Fertility~Education+Catholic+Infant.Mortality, swiss, 
              subset=Catholic&gt;40, b = 100, type = c("lmg", "last", "first", "pratt"),
              rank = TRUE, diff = TRUE)
       # for demonstration purposes only 100 bootstrap replications

   #default output (percentily intervals, as of Version 2 of the package)
    booteval.relimp(bootswiss)
    plot(booteval.relimp(bootswiss))

    #sorted printout, chosen confidence levels, chosen interval method
    #store as object
        result &lt;- booteval.relimp(bootsub, bty="bca", 
              sort = TRUE, level=c(0.8,0.9))
         #because of only 100 bootstrap replications, 
         #default bca intervals produce warnings
    #output driven by print method
        result
    #result plotting with default settings 
    #(largest confidence level, names abbreviated to length 4)
        plot(result)
    #result plotting with modified settings (chosen confidence level, 
    #names abbreviated to chosen length)
        plot(result, level=0.8,names.abbrev=5)
    #result plotting with longer names shown vertically
        par(las=2)
        plot(result, level=0.9,names.abbrev=6)
    #plot does react to options set with par()
    #exceptions: mfrow, mar and oma are set within the plot routine itself

#####################################################################
### Example: bootstrapping clustered data                            
###          data taken from example.lmm of package lmm
### y is change in pulse (heart beats per minute) 
###    15 min (occ 1 to 3) and 90 min (occ 4 to 6) after 
###    treatment with Placebo (occ 1 or 4) low (occ 2 or 5) 
###    or high (occ 3 or 6) dose of marihuana
### each of 9 subjects is observed under most or all 
### of the 6 possible conditions
#####################################################################
## create example data from package lmm
y &lt;- c(16,20,16,20,-6,-4,
    12,24,12,-6,4,-8,
    8,8,26,-4,4,8,
    20,8,20,-4,
    8,4,-8,22,-8,
    10,20,28,-20,-4,-4,
    4,28,24,12,8,18,
    -8,20,24,-3,8,-24,
    20,24,8,12)
occ &lt;- c(1,2,3,4,5,6,
      1,2,3,4,5,6,
      1,2,3,4,5,6,
      1,2,5,6,
      1,2,3,5,6,
      1,2,3,4,5,6,
      1,2,3,4,5,6,
      1,2,3,4,5,6,
      2,3,4,5)
subj &lt;- c(1,1,1,1,1,1,
       2,2,2,2,2,2,
       3,3,3,3,3,3,
       4,4,4,4,
       5,5,5,5,5,
       6,6,6,6,6,6,
       7,7,7,7,7,7,
       8,8,8,8,8,8,
       9,9,9,9)
### manual creation of dummies
### reference category placebo after 90min (occ=4)
dumm1 &lt;- as.numeric(occ==1)
dumm2 &lt;- as.numeric(occ==2)
dumm3 &lt;- as.numeric(occ==3)
dumm5 &lt;- as.numeric(occ==5)
dumm6 &lt;- as.numeric(occ==6)

## create data frame
dat &lt;- data.frame(y,dumm1,dumm2,dumm3,dumm5,dumm6,subj)

### create design with clusters
des &lt;- svydesign(id=~subj,data=dat)

### apply bootstrapping
### using the design with subjects as clusters implies that 
###     clusters are generally kept in or excluded as a whole
### of course, b=100 is too small, only chosen for speed of package creation 
bt &lt;- boot.relimp(y~dumm1+dumm2+dumm3+dumm5+dumm6,data=dat,
   design=des,b=100,type=c("lmg","first","last","betasq","pratt"))

### calculate and display results
booteval.relimp(bt,lev=0.9,nodiff=TRUE)

</code></pre>

<hr>
<h2 id='calc.relimp'> Function to calculate relative importance metrics for linear models </h2><span id='topic+calc.relimp'></span><span id='topic+calc.relimp.default'></span><span id='topic+calc.relimp.formula'></span><span id='topic+calc.relimp.lm'></span>

<h3>Description</h3>

<p>calc.relimp calculates several relative importance metrics for the linear model. 
The recommended metrics are <code>lmg</code> (<code class="reqn">R^2</code> partitioned by averaging over orders, like in Lindemann, Merenda and Gold (1980, p.119ff)) 
and <code>pmvd</code> (a newly proposed metric by Feldman (2005) that is provided in the non-US version of the package only). 
For completeness and comparison purposes, several other metrics are also on offer (cf. e.g. Darlington (1968)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## generic function
calc.relimp(object, ...)

## default S3 method
## Default S3 method:
calc.relimp(object, x = NULL, ..., 
       type = "lmg", diff = FALSE, rank = TRUE, rela = FALSE, always = NULL, 
       groups = NULL, groupnames = NULL, weights=NULL, design=NULL)

## S3 method for formula object
## S3 method for class 'formula'
calc.relimp(formula, data, weights, na.action, ..., subset=NULL)

## S3 method for objects of class lm
## S3 method for class 'lm'
calc.relimp(object, type = "lmg", groups = NULL, groupnames=NULL, always = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc.relimp_+3A_object">object</code></td>
<td>
<p> The class of this object determines which of the methods is used:
There are special methods for output objects from function <code><a href="stats.html#topic+lm">lm</a></code> 
(or linear model objects inheriting from class lm 
generated by other functions like <code><a href="stats.html#topic+glm">glm</a></code> and <code>svyglm</code>)
and for formula objects.
For all other types of object, the default method is used.
</p>
<p>Thus, object can be
</p>
<p>a formula (e.g. <code>y~x1+x2+x3+x2:x3</code>) (cf. below for details)
</p>
<p>OR
</p>
<p>the output of a linear model call (inheriting from class <code>lm</code>, but not <code>mlm</code>); 
output objects from <code>lm</code>, <code>glm</code>, <code>svyglm</code> or <code>aov</code> work 
(if linear with identity link in case of glm's);
there may be further functions that output objects inheriting from <code>lm</code> 
which may or may not work reasonably with <code>calc.relimp</code>; 
for <code>calc.relimp</code> to be appropriate, the underlying model must at least be linear!
</p>
<p>The restrictions on usage of interactions listed under item formula below also 
apply to linear model objects. 
</p>
<p>OR 
</p>
<p>the covariance matrix of a response y and regressors x, 
(e.g. obtained by cov(cbind(y,x)), if y is a column vector of response values 
and x a corresponding matrix of regressors) 
</p>
<p>OR 
</p>
<p>a (raw) data matrix or data frame with the response variable in the first column
</p>
<p>OR
</p>
<p>a response vector or one-column matrix, 
if <code>x</code> contains the corresponding matrix or data frame of regressors.</p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_formula">formula</code></td>
<td>
<p> The first object, if a formula is to be given; 
one response only. 
</p>
<p>Interaction terms are currently limited to second-order.
</p>
<p>Note: If several interaction terms are given, calculations may be very 
resource intensive, if these are all connected (e.g. with A:B, B:C, C:D, all A,B,C,D are connected, 
while with A:B, C:D, D:E there are separate groups A,B and C,D,E). 
</p>
<p>Interaction terms occurring in always do not increase resource usage 
(but are only permitted if the respective main effects also occur in always).
</p>
<p>Interactions and groups currently cannot be used simultaneously. 
</p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_x">x</code></td>
<td>
<p> a (raw) data matrix or data frame containing the regressors, 
if <code>object</code> is a response vector or one-column matrix
</p>
<p>OR 
</p>
<p>NULL, if <code>object</code> is anything else </p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_type">type</code></td>
<td>
<p> can be a character string, character vector or list of character strings.
It is the collection of metrics that are to be calculated. 
Available metrics: <code>lmg</code>, <code>pmvd</code> (non-US version only), <code>last</code>, <code>first</code>, 
<code>betasq</code>, <code>pratt</code>, <code>genizi</code> and <code>car</code>. For brief sketches of their meaning cf. details section. </p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_diff">diff</code></td>
<td>
<p> logical; if TRUE, pairwise differences between the relative contributions are calculated; default FALSE </p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_rank">rank</code></td>
<td>
<p> logical; if TRUE, ranks of regressors in terms of relative contributions are calculated; default TRUE </p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_rela">rela</code></td>
<td>
<p> is a logical requesting relative importances summing to 100% (<code>rela=TRUE</code>). 
If rela is FALSE (default), some of the metrics sum to <code class="reqn">R^2</code> (<code>lmg</code>, <code>pmvd</code>, <code>pratt</code>), 
others do not have a meaningful sum (<code>last</code>, <code>first</code>, <code>betasq</code>).</p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_always">always</code></td>
<td>
<p> is a vector of column numbers or names of variables to be always in the 
model (adjusted for). Valid numbers are 2 to (number of regressors + 1) (1 is reserved for the response), 
valid character strings are all column names of <code>object</code> or <code>x</code> respectively 
that refer to regressor variables. Numbers and names cannot be mixed. 
</p>
<p>Relative importance is only assessed for the variables not selected in <code>always</code>. 
</p>
<p>This option currently does not work for metrics <code>genizi</code> and <code>car</code>.</p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_groups">groups</code></td>
<td>
<p> is a list of vectors of column numbers or names of variables to be combined into groups. 
If only one group is needed, a vector can be given. The numbers and character strings needed are of the same form 
as for <code>always</code>. 
</p>
<p>Relative importance is only allocated between groups of regressors, no subdivision within groups is calculated. 
Regressors that do not occur in any group are included as singletons.
A regressor must not occur in <code>always</code> and in <code>groups</code>. Also, groups cannot be used with a linear model or a formula 
in case of higher order effects (interactions). Finally, <code>groups</code> only works with the four metrics 
<code>lmg</code>, <code>pmvd</code>, <code>last</code> and <code>first</code>.</p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_groupnames">groupnames</code></td>
<td>
<p> is a vector of names for the variable groups to be used for annotation of output.</p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_weights">weights</code></td>
<td>
<p> is a vector of case weights for the observations in the data frame (or matrix).
You can EITHER specify <code>weights</code> OR a <code>design</code>.
Note that weights must not be specified for linear model objects (since these should contain their weights as 
part of the model).</p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_design">design</code></td>
<td>
<p> is a design object of class <code>survey.design</code> (cf. package <span class="pkg">survey</span>).
You can EITHER specify a <code>design</code> OR <code>weights</code>. For <code>calc.relimp</code>, the design is used 
for calculating weights only.
Note that it is discouraged (though possible) to specify a design for a conventional linear model object 
(since a survey-specific linear model should be used for survey data, cf. function <code>svyglm</code>). 
</p>
<p>Also note that care is needed when using <code>subset</code> together with <code>design</code>: 
the <code>subset</code>-Option only treats the <code>data</code> handed directly to <code>calc.relimp</code>,
the <code>design</code> has to be equivalently treated beforehand. </p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_data">data</code></td>
<td>
<p> if first object is of class formula: 
an optional matrix or data frame that the variables in formula and subset come from; 
if it is omitted, all names must be meaningful in the environment from which calc.relimp is called</p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_subset">subset</code></td>
<td>
<p> if first object is of class formula: 
an optional expression indicating the subset of the observations of <code>data</code> that should be used in the fit. 
This can be a logical vector, or a numeric vector indicating which observation numbers are to be included, 
or a  character  vector of the row names to be included.  All (non-missing) observations are included by
default. </p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_na.action">na.action</code></td>
<td>
<p> if first object is of class formula: 
an optional function that indicates what should happen when the data contain 'NA's. 
The default is first, any na.action attribute of data, second the setting given in the call to calc.relimp,
third the na.action setting of options. Possible choices are &quot;na.fail&quot;,  
(print an error message and terminate if there are any incomplete observations), 
&quot;na.omit&quot; or &quot;na.exclude&quot; (equivalent for package <code>relaimpo</code>, 
both analyse complete cases only and print a warning, this is also what is done the default method ). </p>
</td></tr>
<tr><td><code id="calc.relimp_+3A_...">...</code></td>
<td>
<p> usable for further arguments, 
particularly most arguments of default method can be given to all other methods 
(exception: weights and design cannot be given to lm-method) </p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>lmg</dt><dd><p> is the <code class="reqn">R^2</code> contribution averaged over orderings among regressors, cf. e.g. Lindeman, Merenda and Gold 1980, 
p.119ff or Chevan and Sutherland (1991).</p>
</dd> 
<dt>pmvd</dt><dd><p> is the proportional marginal variance decomposition as proposed by Feldman (2005) (non-US version only).
It can be interpreted as a weighted average over orderings among regressors, with data-dependent weights. </p>
</dd> 
<dt>last</dt><dd><p> is each variables contribution when included last, also sometimes called usefulness.</p>
</dd> 
<dt>first</dt><dd><p> is each variables contribution when included first, which is just the squared covariance between y and the variable.</p>
</dd>
<dt>betasq</dt><dd><p> is the squared standardized coefficient.</p>
</dd> 
<dt>pratt</dt><dd><p> is the product of the standardized coefficient and the correlation.</p>
</dd>
<dt>genizi</dt><dd><p> is the <code class="reqn">R^2</code> decomposition according to Genizi 1993</p>
</dd>
<dt>car</dt><dd><p> is the <code class="reqn">R^2</code> decomposition according to Zuber and Strimmer 2010, also available from package <span class="pkg">care</span> 
(squares of scores produced by function <code><a href="care.html#topic+carscore">carscore</a></code>
</p>
</dd>
</dl>
<p>Each metric is calculated using the internal function &ldquo;metric&rdquo;<code>calc</code>, e.g. <code>lmgcalc</code>.
</p>
<p>Five of the metrics in <code>calc.relimp</code> (<code>lmg</code>, <code>pmvd</code>, <code>pratt</code>, <code>genizi</code> and <code>car</code>), 
decompose the model <code class="reqn">R^2</code>. 
<code>calc.relimp</code> (<code>lmg</code>, <code>pmvd</code>, <code>pratt</code>, <code>genizi</code> and <code>car</code>) sum to the <code class="reqn">R^2</code> that is to be decomposed, 
if <code>rela = FALSE</code> and to 100pct if <code>rela = TRUE</code>.
</p>
<p>The other metrics also (artificially) sum to 100pct if <code>rela = TRUE</code>. 
If <code>rela = FALSE</code>, they are given relative to var(y) (or the conditional variance of y after adjusting out the variables 
requested in <code>always</code>) but do not sum to <code class="reqn">R^2</code>.
</p>
<p>If <code>always</code> requests some variables to be always in the model, these are conditioned upon 
(i.e. included into the model first). Only the remaining <code class="reqn">R^2</code> that is not explained by 
these variables is decomposed among the other regressors. This currently does not work for metrics <code>genizi</code> and <code>car</code>.
</p>
<p>Four of the metrics, <code>lmg</code>, <code>pmvd</code>, <code>first</code> and <code>last</code>, 
are related to the order in which the variables are included into the model. 
For these it is possible to consider the variables in groups that are always entered into the model together. 
</p>
<p>Note that <span class="pkg">relaimpo</span> can only provide metric <code>lmg</code> for models with interactions (2-way interactions only). 
It averages only over those orders, for which the interactions enter the model after both their main effects.
</p>
<p>Note that there are different types of weights, weights indicating the variability of the response 
(observations with a more variable responses receive a lower weight than those with a less variable response,
like in the Aitken estimator), frequency weights indicating the number of observations with exactly the observed 
data pattern of the current observation, or weights indicating the number of population units represented by the 
current observation (inverse sampling probability, weights typically used in survey situations). All three types of 
weight alike can be handed to function <code>calc.relimp</code> using the <code>weights=</code> option. Note, however, that they 
have to be treated differently for bootstrapping (cf. <code><a href="#topic+boot.relimp">boot.relimp</a></code>).
</p>
<p>Data from complex surveys can be treated by providing a survey design with <code>design=</code>-option. 
For <code>calc.relimp</code>, it is also sufficient to provide the weights derived from the design using the 
<code>weights=</code>-option. 
</p>
<p><code>calc.relimp</code> cannot handle data with missing values directly. It applies complete-case analysis, 
i.e. drops all units with any missing values by default. While this can be appropriate, if there are only few 
missing values, data with more severe missingness issues need special treatment. Package <span class="pkg">relaimpo</span> 
offers the function <code>mianalyze.relimp</code> that handles multiply-imputed datasets (that can be created 
by several other <span class="rlang"><b>R</b></span>-packages). Currently, possibilities in this function are limited due to the fact that 
it uses complex survey designs and bootstrapping which do not (yet) go together well with factors, interactions 
and calculated quantities in formulae.
</p>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>var.y</code></td>
<td>
<p>the variance of the response</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>the coefficient of determination, <code class="reqn">R^2</code></p>
</td></tr>
<tr><td><code>R2.decomp</code></td>
<td>
<p>the part of the coefficient of determination that is decomposed among the 
variables under investigation </p>
</td></tr>
<tr><td><code>lmg</code></td>
<td>
<p>vector of relative contributions obtained from the <code>lmg</code> method, if <code>lmg</code> has been requested in <code>type</code></p>
</td></tr>
<tr><td><code>lmg.diff</code></td>
<td>
<p>vector of pairwise differences between relative contributions obtained from the <code>lmg</code> method, 
if <code>lmg</code> has been requested in <code>type</code> and <code>diff=TRUE</code></p>
</td></tr>
<tr><td><code>lmg.rank</code></td>
<td>
<p>rank of the regressors relative contributions obtained from the <code>lmg</code> method, 
if <code>lmg</code> has been requested in <code>type</code> and <code>rank=TRUE</code></p>
</td></tr>
<tr><td><code>metric</code>, <code>metric.diff</code>, <code>metric.rank</code></td>
<td>
<p>analogous to <code>lmg</code> for other metrics</p>
</td></tr>
<tr><td><code>ave.coeffs</code></td>
<td>
<p>average coefficients for variables not not requested by always only 
for models of different sizes;
</p>
<p>note that coefficients refer to modeling residuals after adjusting out variables 
listed in always (both from response and other explanatory variables)</p>
</td></tr>
<tr><td><code>namen</code></td>
<td>
<p>names of variables, starting with response</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>character vector of metrics available</p>
</td></tr>
<tr><td><code>rela</code></td>
<td>
<p>Have metrics been normalized to sum 100% ?</p>
</td></tr>
<tr><td><code>always</code></td>
<td>
<p>column numbers of variables always in the model; 
in case of factors, the column numbers given here are not identical to those in 
the call to <code>calc.relimp</code>, but refer to the columns of the model matrix</p>
</td></tr>
<tr><td><code>alwaysnam</code></td>
<td>
<p>names of variables always in the model</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>contains the call that generated the object</p>
</td></tr>
</table>


<h3>Warning </h3>

<p><code>lmg</code> and <code>pmvd</code> are computer-intensive. Although they are calculated based on the 
covariance matrix, which saves substantial computing time in comparison to carrying out actual regressions, 
these methods still take quite long for problems with many regressors.
</p>
<p><code>relaimpo</code> is a package for univariate linear models. 
Using <code>relaimpo</code> on objects that inherit from class <code>lm</code> but are not univariate linear model objects 
may produce nonsensical results without warning. Objects of class <code>mlm</code> or <code>glm</code> with link functions other than identity 
or family other than gaussian lead to an error message. 
</p>


<h3>Note</h3>

<p> There are two versions of this package. The version on CRAN is globally licensed under GPL version 2 (or later). 
There is an extended version with the interesting additional metric <code>pmvd</code> that is licensed according to GPL version 2
under the geographical restriction &quot;outside of the US&quot; because of potential issues with US patent 6,640,204. 
This version can be obtained from Ulrike Groempings website (cf. references section). 
Whenever you load the package, a display tells you, which version you are loading. </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

 
<p>Chevan, A. and Sutherland, M. (1991) Hierarchical Partitioning. <em>The American Statistician</em> <b>45</b>, 90&ndash;96.
</p>
<p>Darlington, R.B. (1968) Multiple regression in psychological research and practice. <em>Psychological Bulletin</em> <b>69</b>, 161&ndash;182.
</p>
<p>Feldman, B. (2005) Relative Importance and Value. Manuscript (Version 1.1, March 19 2005), downloadable at <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2255827">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2255827</a>
</p>
<p>Genizi, A. (1993) Decomposition of R2 in multiple regression with correlated regressors. <em>Statistica Sinica</em> <b>3</b>, 407&ndash;420. 
Downloadable at <a href="https://www3.stat.sinica.edu.tw/statistica/password.asp?vol=3&amp;num=2&amp;art=10">https://www3.stat.sinica.edu.tw/statistica/password.asp?vol=3&amp;num=2&amp;art=10</a>
</p>
<p>Groemping, U. (2006) Relative Importance for Linear Regression in R: The Package relaimpo 
<em>Journal of Statistical Software</em> <b>17</b>, Issue 1. 
Downloadable at <a href="https://www.jstatsoft.org/v17/i01">https://www.jstatsoft.org/v17/i01</a>
</p>
<p>Lindeman, R.H., Merenda, P.F. and Gold, R.Z. (1980) <em>Introduction to Bivariate and Multivariate Analysis</em>, Glenview IL: Scott, Foresman.
</p>
<p>Zuber, V. and Strimmer, K. (2010) <em>Variable importance and model selection by decorrelation</em>. Preprint, downloadable at <a href="https://arxiv.org/abs/1007.5516">https://arxiv.org/abs/1007.5516</a>
</p>
<p>Go to <a href="https://prof.bht-berlin.de/groemping/relaimpo/">https://prof.bht-berlin.de/groemping/relaimpo/</a> for further information and references.
</p>


<h3>See Also</h3>

 <p><span class="pkg"><a href="#topic+relaimpo">relaimpo</a></span>, <code><a href="#topic+booteval.relimp">booteval.relimp</a></code>, <code><a href="#topic+mianalyze.relimp">mianalyze.relimp</a></code>, 
<code><a href="#topic+classesmethods.relaimpo">classesmethods.relaimpo</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################################################################
### Example: relative importance of various socioeconomic indicators 
###          for Fertility in Switzerland
### Fertility is first column of data set swiss
#####################################################################
data(swiss)
    calc.relimp(swiss, 
       type = c("lmg", "last", "first", "betasq", "pratt", "genizi", "car") )
    # calculation of all available relative importance metrics 
        # non-US version offers the additional metric "pmvd", 
        # i.e. call would be 
        # calc.relimp(cov(swiss), 
        # type = c("lmg", "pmvd", "last", "first", "betasq, "pratt"), 
        # rela = TRUE )
    ## same analysis with formula or lm method and a few modified options
    crf &lt;- calc.relimp(Fertility~Agriculture+Examination+Education+Catholic+Infant.Mortality,swiss, 
        subset = Catholic&gt;40,
        type = c("lmg", "last", "first", "betasq", "pratt"), rela = TRUE )
    crf
    linmod &lt;- lm(Fertility~Agriculture+Examination+Education+Catholic+Infant.Mortality,swiss)
    crlm &lt;- calc.relimp(linmod, 
        type = c("lmg", "last", "first", "betasq", "pratt", "genizi", "car"), rela = TRUE )
    plot(crlm)
    # bar plot of the relative importance metrics

    #of statistical interest in this context: correlation matrix
       cor(swiss)

    #demonstration of conditioning on one regressor using always
    calc.relimp(swiss, 
       type = c("lmg", "last", "first", "betasq", "pratt"), rela = FALSE,
       always = "Education" )

    # using calc.relimp with grouping of two regressors
    # and weights (not reasonable here, purely for demo purposes)
    calc.relimp(swiss, 
       type = c("lmg", "last", "first"), rela = FALSE,
       groups = c("Education","Examination"), weights = abs(-23:23) )

    # using calc.relimp with grouping of two regressors
    # and a design object (not reasonable here, purely for demo purposes)
    des &lt;- svydesign(~1, data=swiss, weights=~abs(-23:23))
    calc.relimp(swiss, 
       type = c("lmg", "last", "first"), rela = FALSE,
       groups = c("Education","Examination"), groupnames ="EduExam", design = des)

    # calc.relimp with factors (betasq and pratt not possible)
      # (calc.relimp would not be necessary here, 
      # because the experiment is balanced)
    calc.relimp(1/time~poison+treat,data=poisons, rela = FALSE,
         type = c("lmg", "last", "first"))
    # including also the interaction (lmg possible only)
    calc.relimp(1/time~poison*treat,data=poisons, rela = FALSE)
</code></pre>

<hr>
<h2 id='classesmethods.relaimpo'> Classes and Methods in Package relaimpo </h2><span id='topic+classesmethods.relaimpo'></span><span id='topic+relimplm'></span><span id='topic+relimplmtest'></span><span id='topic+relimplmboot'></span><span id='topic+relimplmbooteval'></span><span id='topic+relimplmbootMI'></span><span id='topic+plot.relimplm'></span><span id='topic+print.relimplm'></span><span id='topic++24.relimplm'></span><span id='topic+plot.relimplmbooteval'></span><span id='topic+print.relimplmbooteval'></span><span id='topic++24.relimplmbooteval'></span><span id='topic+plot.relimplmbootMI'></span><span id='topic+print.relimplmbootMI'></span><span id='topic++24.relimplmbootMI'></span><span id='topic+summary.relimplmbootMI'></span>

<h3>Description</h3>

<p>Output objects from package <span class="pkg">relaimpo</span> have classes <code>relimplm</code> (output from calc.relimp), <code>relimplmboot</code> 
(output from boot.relimp), <code>relimplmbooteval</code> (output from booteval.relimp) or <code>relimplmbootMI</code>. 
For classes <code>relimplm</code>, <code>relimplmbooteval</code> and <code>relimplmbootMI</code>, there are methods for plotting and printing, 
usage of which is described below. For class <code>relimplmbootMI</code>, there is in addition a summary-method,
which produces a less detailed output than the show / print - method.
For classes <code>relimplm</code>, <code>relimplmbooteval</code> and <code>relimplmbootMI</code>, 
there is in addition a method for extracting slots of the class with <code>$</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relimplm'
print(x,...,show.coeffs = ifelse(any(c("lmg", "pmvd") %in% x@type) 
    &amp; is.null(x@always), TRUE, FALSE))

## S3 method for class 'relimplm'
plot(x,...,names.abbrev=4, ylim=NULL, main=NULL, cex.title=1.5)

## S3 method for class 'relimplmbooteval'
print(x,...)                                    

## S3 method for class 'relimplmbootMI'
print(x,...)                                    

## S3 method for class 'relimplmbooteval'
plot(x, ..., lev=max(x@level), names.abbrev=4, ylim=NULL, 
    main=NULL, cex.title=1.5)   

## S3 method for class 'relimplmbootMI'
plot(x, ..., lev=max(x@level), names.abbrev=4, ylim=NULL, 
    main=NULL, cex.title=1.5)   

## S3 method for class 'relimplmbootMI'
summary(object, ..., lev = max(object@level))                                    

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classesmethods.relaimpo_+3A_x">x</code></td>
<td>
 <p><code>x</code> is an output object from package <span class="pkg">relaimpo</span> of the required class </p>
</td></tr>
<tr><td><code id="classesmethods.relaimpo_+3A_show.coeffs">show.coeffs</code></td>
<td>
 <p><code>show.coeffs</code>, if set to <code>FALSE</code>, suppresses printing of averaged coefficients, 
which are otherwise printed, if <code>lmg</code> and/or <code>pmvd</code> are among the metrics in <code>x</code> and 
<code>always</code> is <code>NULL</code>. 
See details for a discussion of the averaged coefficients, if <code>always</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="classesmethods.relaimpo_+3A_object">object</code></td>
<td>
 <p><code>object</code> is an object of class <code>relimplmbootMI</code> 
(output from function <code>mianalyze.relimp</code>) </p>
</td></tr>
<tr><td><code id="classesmethods.relaimpo_+3A_...">...</code></td>
<td>
<p> further arguments to functions </p>
</td></tr>
<tr><td><code id="classesmethods.relaimpo_+3A_names.abbrev">names.abbrev</code></td>
<td>
 <p><code>names.abbrev</code> is an integer that provides the number of characters to which the bar labels 
are shortened (default: 4). </p>
</td></tr>
<tr><td><code id="classesmethods.relaimpo_+3A_ylim">ylim</code></td>
<td>
<p>The plot routines try to use appropriate scaling. If adjustments are needed, <code>ylim</code> can be used 
like usually on plot. </p>
</td></tr>
<tr><td><code id="classesmethods.relaimpo_+3A_main">main</code></td>
<td>
<p>The plot routine uses a default title based on the reponses name. 
If adjustments are desired, <code>main</code> can be used for specifying a different title.
Note that only the first title is affected 
(in case of plot.relimpbooteval, there is also a sub title that cannot be changed). </p>
</td></tr>
<tr><td><code id="classesmethods.relaimpo_+3A_cex.title">cex.title</code></td>
<td>
 <p><code>cex.title</code> specifies the text size for the overall title. 
Thus, the <code>par</code> option <code>cex.main</code> can be used for specifying the size of individual plot titles.</p>
</td></tr>
<tr><td><code id="classesmethods.relaimpo_+3A_lev">lev</code></td>
<td>
 <p><code>lev</code> is a numeric that provides the confidence level to be plotted 
or displayed respectivly (default: maximum available confidence level; 0.5&lt;lev&lt;1  ). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This documentation part describes S3 methods. In addition there are S4 methods for <code>show</code> which
coincide with the S3 methods for <code>print</code> and an S4 method for coercing objects of <code>relimplm</code> to lists
(of their numeric elements).
</p>
<p>Print (and show) methods produce annotated output for <code>calc.relimp</code>, <code>booteval.relimp</code>, and 
<code>mianalyze.relimp</code> (or the objects produced by these functions). Since version 2.1, <code>calc.relimp</code> 
provides averaged coefficients for different sub model sizes (slot <code>ave.coeffs</code> of class <code>relimplm</code>), 
if metrics based on averaging over orderings (<code>lmg</code> and/or <code>pmvd</code>) are calculated. 
These are per default printed if the slot <code>always</code> of <code>x</code> is <code>NULL</code>. 
If some variables were forced into all models (non-NULL <code>always</code>), the averaged coefficients 
refer to the adjusted model after taking residuls from regressions on the <code>always</code>-columns 
of the X-matrix for both response and the other columns of the X-matrix. The reason is that these could be 
easily and cheaply implemented into the existing code and do correspond to sub models relevant 
for <code>lmg</code> and <code>pmvd</code>. Users who are interested in these coefficients, can set option <code>show.coeffs=TRUE</code> 
in spite of non-NULL <code>always</code>. 
</p>
<p>The plot methods produce barplots of relative contributions, 
either of the metrics alone for output objects of class <code>relimplm</code> from function <code>calc.relimp</code>, 
or of the metrics with lines indicating confidence intervals for output objects of class <code>relimplmbooteval</code> 
from function <code>booteval.relimp</code> or <code>relimplmbootMI</code> from function <code>booteval.relimp</code>.   
</p>
<p>Most <code>par()</code> options can be set and should work on plot. 
Exceptions: mfrow, oma and mar are set by the plot function, 
depending on the number of metrics to plot and the amount of annotating text required. 
</p>
<p>The summary-method for class <code>relimplmbootMI</code> allows to quickly display brief output and to change 
the confidence level versus the level used in the original run (with interval bounds stored in the 
&ldquo;metric&rdquo;.lower and &ldquo;metric&rdquo;.upper slots and displayed by print and show methods).
</p>
<p>Because of a defined S3-extraction method, 
slots of classes <code>relimplm</code>, <code>relimplmbooteval</code> and <code>relimplmbootMI</code> can be extracted not only 
with the <code>@</code> extractor but also with <code>$</code>. 
Hence, output elements from functions <code>calc.relimp</code>, <code>booteval.relimp</code>, and <code>mianalyze.relimp</code>
can be extracted as though the output objects were lists.
</p>
<p>Note that there also is an an internally-used class relimplmtest that permits the internal function 
calc.relimp_default.intern to output further detail needed for usage from within other funtions. 
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

<p> Go to <a href="https://prof.bht-berlin.de/groemping/">https://prof.bht-berlin.de/groemping/</a> for further information and references.</p>


<h3>See Also</h3>

 <p><span class="pkg"><a href="#topic+relaimpo">relaimpo</a></span>, <code><a href="#topic+calc.relimp">calc.relimp</a></code>, <code><a href="#topic+booteval.relimp">booteval.relimp</a></code>, 
<code><a href="#topic+mianalyze.relimp">mianalyze.relimp</a></code>, 
<code><a href="#topic+relimplm-class">relimplm-class</a></code>, <code><a href="#topic+relimplmboot-class">relimplmboot-class</a></code>, 
<code><a href="#topic+relimplmbooteval-class">relimplmbooteval-class</a></code>, <code><a href="#topic+relimplmbootMI-class">relimplmbootMI-class</a></code>    </p>

<hr>
<h2 id='mianalyze.relimp'>Function to do relative importance calculations based on multiply imputed datasets</h2><span id='topic+mianalyze.relimp'></span>

<h3>Description</h3>

<p>The function mianalyze.relimp takes a list of imputed data frames (or matrices), 
calculates relative importance metrics for each of these and combines these metrics into 
overall estimates with estimated variances according to the method by Rubin (1987). 
The output object can be summarized, printed and plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mianalyze.relimp(implist, level = 0.95, sort = FALSE, ..., b = 50, type = "lmg", 
    diff = TRUE, no.CI = FALSE, rela = FALSE, always = NULL, groups = NULL, 
    groupnames = NULL, deslist = NULL, bootlist.out = FALSE, formula = NULL, 
    weights = NULL, strata=NULL, ids=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mianalyze.relimp_+3A_implist">implist</code></td>
<td>
<p>list of data frames or matrices containing multiply-imputed datasets, 
or object of class <code>imputationList</code>
</p>
<p>If no formula is given, the first column of each data frame/matrix is assumed to 
be the response variable, the other columns are regressors.
</p>
<p>If a list of designs is also given, the <code>variables</code> component of each design must 
consist of the necessary columns from the respective entry in implist; 
if no formula is given, the <code>variables</code> component of each design must coincide 
(except for the order of columns) with the respective entry in implist.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_level">level</code></td>
<td>
<p>is a single confidence level (between 0.5 and 1)</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_sort">sort</code></td>
<td>
<p> is a logical requesting output sorted by size of relative contribution 
(<code>sort=TRUE</code>) or by variable position in list (<code>sort=FALSE</code>, default). </p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_...">...</code></td>
<td>
<p>Further arguments, currently none available</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_b">b</code></td>
<td>
<p> is the number of bootstrap runs requested on boot.relimp (default: <code>b=50</code>). 
Make sure to set this to a higher number, if you want to subsequently use the <code>bootlist</code> slot
for calculating further confidence intervals with function <code>booteval.relimp</code>. </p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_type">type</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_diff">diff</code></td>
<td>
<p> is a logical requesting bootstrapping of pairwise differences in relative importance (<code>diff=TRUE</code>, 
default) for each metric in type </p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_no.ci">no.CI</code></td>
<td>
<p> if set to TRUE, suppresses calculation of confidence intervals and only averages estimated metrics
from all imputed data sets in implist. Currently, <code>no.CI = TRUE</code> is the only setting for which 
<code>mianalyze.relimp</code> works when using models with factors, groups or interactions.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_rela">rela</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_always">always</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_groups">groups</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_groupnames">groupnames</code></td>
<td>
<p> cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_deslist">deslist</code></td>
<td>
<p> is a list of design object of class <code>survey.design</code> (cf. package <code>survey</code>).
You can EITHER specify a <code>deslist</code> OR <code>weights</code> and/or <code>strata</code> and/or <code>ids</code>. 
Note that the design list must contain the same data objects (in the &ldquo;variables&rdquo; element) 
that are listed in <code>implist</code>, so that a lot of storage space is needed in case of large datasets.
</p>
<p>If deslist is not given, the function creates a list of designs using <code>weights</code>, 
<code>strata</code>, and <code>ids</code> information. Whenever the required designs are simple enough to be covered by
specifying <code>weights</code>, <code>strata</code>, and <code>ids</code>, this is by far preferrable in terms of 
storage.  </p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_bootlist.out">bootlist.out</code></td>
<td>
<p> If TRUE, the individual bootstrap results for each multiply imputed data set 
are stored in the bootlist slot of the output object (may be storage-intensive).
</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_formula">formula</code></td>
<td>
<p> cf. <code><a href="#topic+boot.relimp">boot.relimp</a></code>; 
NOTE: If no.CI = FALSE, i.e. confidence intervals are not suppressed, 
<code>formula</code> has to follow the same restrictions as mentioned under item <code>design</code> for 
<code><a href="#topic+boot.relimp">boot.relimp</a></code> (no calculated variables, no interaction terms, no factors),
since confidence interval calculations in <code>mianalyze.relimp</code> are design-based,
even if no <code>deslist-</code>option is given.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_weights">weights</code></td>
<td>
<p> is a vector of case weights for the observations in the data frame (or matrix).
You can EITHER specify <code>weights</code> OR a <code>deslist</code>. 
If <code>weights</code> is NULL, equal weights are assumed, unless otherwise specified in <code>deslist</code>.
For the different types of weights and their appropriate treatment for obtaining confidence intervals,
cf. the &ldquo;Details&rdquo; section of <code><a href="#topic+boot.relimp">boot.relimp</a></code>.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_strata">strata</code></td>
<td>
<p> is a strata request that will be handed to function <code>svydesign</code> for defining the 
strata in a survey design (to be given to mianalyze without the <code>~</code>).
You can EITHER specify <code>strata</code> OR a <code>deslist</code>. 
If <code>strata</code> is NULL, one stratum is assumed, unless otherwise specified in <code>deslist</code>.</p>
</td></tr>
<tr><td><code id="mianalyze.relimp_+3A_ids">ids</code></td>
<td>
<p> is an id-request that will be handed to function <code>svydesign</code> for defining the clusters 
in a survey design (to be given to mianalyze without the <code>~</code>).
You can EITHER specify <code>ids</code> OR a <code>deslist</code>. 
If <code>ids</code> is NULL, it is assumed that there are no clusters, 
unless otherwise specified in <code>deslist</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple imputation is a contemporary method for handling data with a substantial missing value problem. 
It produces a number of completed data sets (e.g. 10) the inference from which is subsequently combined. 
The most frequently used way of combination is the one by Rubin: estimates from the 
different completed data sets are averaged, and the variance is estimated by combining the average over the 
estimated variances (within imputation variance) with an appropriately-scaled variance between estimates,
and confidence intervals are obtained by using a t-distribution with appropriately 
chosen degrees of freedom.
</p>
<p>The variance-covariance matrix of the vector of estimates for each individual completed data set is obtained 
from function withReplicates in package <span class="pkg">survey</span> based on <span class="pkg">survey</span>'s bootstrap replication weights. 
On request (<code>bootlist.out=TRUE</code>), the underlying bootstrap resamples are also stored in the 
<code>bootlist</code>-slot of the output object. In this case, list elements of the <code>bootlist</code>-slot 
are objects of class <code>relimplmboot</code> and can be processed by function <code>booteval.relimp</code>. 
This can help in getting an impression whether the overall aggregated confidence intervals are heavily distorted 
towards symmetry. If such sanity-checking is intended, the default value for <code>b</code> should be substantially 
increased.
</p>
<p>Function <code>mianalyze.relimp</code> needs a list of multiply-imputed data sets or an object of class 
<code>imputationList</code> for input. 
Multiply imputed data sets can - within R - be obtained from various packages. Hints for creating lists 
of the form needed for <code>mianalyze.relimp</code> are given below for users of functions <code>aregImpute</code>, 
<code>mice</code>, and <code>amelia</code>. Users of packages <span class="pkg">norm</span>, <span class="pkg">cat</span>, <span class="pkg">mix</span>, or <span class="pkg">pan</span> 
(who have managed to operate these extremely uncomfortable packages) can of course also produce lists of 
imputed data sets (only less comfortably). 
</p>
<p>For an object <code>imp</code> of class <code>mids</code> obtained from function <code>mice</code> in package <span class="pkg">mice</span>, 
the code 
</p>
<p><code>lapply(as.list(1:imp$m),function(obj) complete(imp,action=obj))</code> 
</p>
<p>produces a list of multiply-imputed data sets as needed for function <code>mianalyze.relimp</code>.
For an object <code>f</code> of class <code>aregImpute</code> produced by function <code>aregImpute</code> in package <span class="pkg">Hmisc</span>,
</p>
<p><code>lapply(as.list(1:f$m),function(obj) impute(imp,imputation=obj))</code> 
</p>
<p>produces the required list of multiply-imputed data sets.
For an object <code>output</code> produced by function <code>amelia</code> in package <span class="pkg">Amelia</span>, the code 
</p>
<p><code>output[1:output$amelia.args$m]</code> 
</p>
<p>produces the list of multiply-imputed data sets as needed for function <code>mianalyze.relimp</code>.
</p>
<p>For multiple imputation, practice is in many cases ahead of theory; this is no different with function 
<code>mianalyze.relimp</code>. Users should note that the validity of confidence intervals has only been proven for 
likelihood-based analyses. Since the metrics calculated in <span class="pkg">relaimpo</span> are not strictly likelihood-based, 
the confidence intervals from function <code>mianalyze.relimp</code> must be considered approximate and experimental.
</p>


<h3>Value</h3>

<p>The value returned by function <code>mianalyze.relimp</code> is an object of class <code>relimplmbootMI</code> 
(if <code>no.CI = FALSE</code>, default) or an object of class <code>relimplm</code> (if no.CI=TRUE). 
It can be printed, plotted and summarized using special methods. 
For extracting its items, the <code>@</code> or <code>$</code> extractors can be used. 
</p>
<p>In addition to the items described for function <code><a href="#topic+calc.relimp">calc.relimp</a></code>, which are also available here, 
the following items from class <code>relimplmbootMI</code> may be of interest for further calculations:
</p>
<table role = "presentation">
<tr><td><code>metric.lower</code></td>
<td>
<p>matrix of lower confidence bounds for &ldquo;metric&rdquo;: one row for each confidence level, 
one column for each element of &ldquo;metric&rdquo;. &ldquo;metric&rdquo; can be any of <code>lmg</code>, <code>lmg.rank</code>, 
<code>lmg.diff</code>, ... 
(replace <code>lmg</code> with other available relative importance metrics, cf. <code><a href="#topic+calc.relimp">calc.relimp</a></code>)</p>
</td></tr>
<tr><td><code>metric.upper</code></td>
<td>
<p>matrix of upper confidence bounds for &ldquo;metric&rdquo;: one row for each confidence level, 
one column for each element of &ldquo;metric&rdquo;</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>number of bootstrap runs underlying the evaluations</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code>MIresult</code></td>
<td>
<p>object of class <code>MIresult</code> that can be processed by the function summary.MIresult 
from package survey</p>
</td></tr>
<tr><td><code>bootlist</code></td>
<td>
<p>only available if bootlist.out=TRUE has been chosen; 
list of objects of class boot.relimp; each list element can be input to function 
<code><a href="#topic+booteval.relimp">booteval.relimp</a></code> </p>
</td></tr>
</table>


<h3>Warning </h3>

<p>The confidence intervals produced here should be used for exploratory purposes only. 
They can be somewhat liberal and are likely to be too symmetric particularly for small data sets.
The confidence intervals produced by function <code>mianalyze.relimp</code> need further research into their behaviour 
and are currently considered experimental.
</p>
<p>Be aware that the methods themselves (<code>lmg</code> and even more <code>pmvd</code>) need some computing time in case of 
many regressors. Hence, bootstrapping of multiple data sets should be used with awareness of computing time issues.
</p>


<h3>Note</h3>

<p> There are two versions of this package. The version on CRAN is globally licensed under GPL version 2 (or later). 
There is an extended version with the interesting additional metric <code>pmvd</code> that is licensed according to GPL version 2
under the geographical restriction &quot;outside of the US&quot; because of potential issues with US patent 6,640,204. This version can be obtained 
from Ulrike Groempings website (cf. references section). Whenever you load the package, a display tells you, which version you are loading. </p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>References</h3>

<p>Chevan, A. and Sutherland, M. (1991) Hierarchical Partitioning. <em>The American Statistician</em> <b>45</b>, 90&ndash;96.
</p>
<p>Darlington, R.B. (1968) Multiple regression in psychological research and practice. <em>Psychological Bulletin</em>  <b>69</b>, 161&ndash;182.
</p>
<p>Feldman, B. (2005) Relative Importance and Value. Manuscript (Version 1.1, March 19 2005), downloadable at <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2255827">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=2255827</a>
</p>
<p>Genizi, A. (1993) Decomposition of R2 in multiple regression with correlated regressors. <em>Statistica Sinica</em> <b>3</b>, 407&ndash;420. 
Downloadable at <a href="https://www3.stat.sinica.edu.tw/statistica/password.asp?vol=3&amp;num=2&amp;art=10">https://www3.stat.sinica.edu.tw/statistica/password.asp?vol=3&amp;num=2&amp;art=10</a>
</p>
<p>Groemping, U. (2006) Relative Importance for Linear Regression in R: The Package relaimpo 
<em>Journal of Statistical Software</em> <b>17</b>, Issue 1. 
Downloadable at <a href="https://www.jstatsoft.org/v17/i01">https://www.jstatsoft.org/v17/i01</a>
</p>
<p>Lindeman, R.H., Merenda, P.F. and Gold, R.Z. (1980) <em>Introduction to Bivariate and Multivariate Analysis</em>, Glenview IL: Scott, Foresman.
</p>
<p>Little, R.J.A. and Rubin, D.B. (2002) <em>Statistical Analysis with Missing Data</em>, Wiley, New York.
</p>
<p>Zuber, V. and Strimmer, K. (2010) <em>Variable importance and model selection by decorrelation</em>. Preprint, downloadable at <a href="https://arxiv.org/abs/1007.5516">https://arxiv.org/abs/1007.5516</a>
</p>
<p>Go to <a href="https://prof.bht-berlin.de/groemping/">https://prof.bht-berlin.de/groemping/</a> for further information and references.
</p>


<h3>See Also</h3>

 <p><span class="pkg"><a href="#topic+relaimpo">relaimpo</a></span>, <code><a href="#topic+calc.relimp">calc.relimp</a></code>, <code><a href="#topic+booteval.relimp">booteval.relimp</a></code>, 
<code><a href="#topic+classesmethods.relaimpo">classesmethods.relaimpo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## smi contains a list of 5 imputed datasets (class imputationList) from package mitools
  ## (first element of smi is list of data frames)
  ## it is not a well-suited example for relative importance but easily available for demonstrating 
  ##         multiple imputation-related functionality
  
  data(smi)
  
  ## obtain averaged estimates only, without confidence intervals
  ## works with factors and interactions
  mianalyze.relimp(smi[[1]], formula = cistot ~ drkfre+sex+wave, no.CI = TRUE)
  ## for obtaining all individual estimates, use lapply:
  smi.cr.list &lt;- lapply(smi[[1]], function(obj) calc.relimp(cistot ~ drkfre+sex+wave, data=obj))
  ## display result for first individual imputed data set
  smi.cr.list[[1]]
  
  ## obtain confidence intervals, 
  ## currently only usable for models without calculated variables, factors, groups, interactions
  
  ## call without using weights, strata, clusters or a design list
  mianalyze.relimp(smi[[1]], formula = cistot ~ mdrkfre+sex+wave)  
  ## call using the id column (identical in all smi data sets) for cluster structure
  ident &lt;- smi[[1]][[1]]$id
  mitest &lt;- mianalyze.relimp(smi[[1]], formula = cistot ~ mdrkfre+sex+wave, ids=ident)  
  mitest
      ## postprocess: look at intervals with different confidence level
      summary(mitest,lev=0.8)
  ## call with design list
  deslist &lt;- lapply(smi[[1]], function(obj) svydesign(~id,strata=~sex,weights=~cistot,data=obj))
  mitest &lt;- mianalyze.relimp(smi[[1]], formula = cistot ~ mdrkfre+sex+wave, deslist=deslist, 
       level=c(0.8))
  mitest  
</code></pre>

<hr>
<h2 id='relimplm-class'>Class relimplm </h2><span id='topic+relimplm-class'></span><span id='topic+coerce+2Crelimplm+2Clist-method'></span><span id='topic+show+2Crelimplm-method'></span>

<h3>Description</h3>

<p>  This is the class of output objects from the function <code>calc.relimp</code> 
in package <span class="pkg">relaimpo</span>. Its elements are described in the documentation of <code><a href="#topic+calc.relimp">calc.relimp</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects should only be created by calls to the function <code>calc.relimp</code>.  
</p>


<h3>Slots</h3>


<dl>
<dt><code>var.y</code>:</dt><dd><p>Object of class <code>"numeric"</code> </p>
</dd>
<dt><code>R2</code>:</dt><dd><p>Object of class <code>"numeric"</code> </p>
</dd>
<dt><code>R2.decomp</code>:</dt><dd><p>Object of class <code>"numeric"</code> </p>
</dd>
<dt><code>lmg</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pmvd</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>first</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>last</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>betasq</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pratt</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>genizi</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>car</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>lmg.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pmvd.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>first.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>last.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>betasq.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pratt.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>genizi.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>car.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>lmg.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pmvd.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>first.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>last.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>betasq.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pratt.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>genizi.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>car.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>namen</code>:</dt><dd><p>Object of class <code>"character"</code>: variable names, starting with name for response </p>
</dd>
<dt><code>nobs</code>:</dt><dd><p>Object of class <code>"numeric"</code>: number of valid observations used in analysis 
(available only if calculations are based on raw data) </p>
</dd>
<dt><code>ave.coeffs</code>:</dt><dd><p>Object of class <code>"matrix"</code>: average coefficients for models of different sizes </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code>: metrics that have been calculated </p>
</dd>
<dt><code>rela</code>:</dt><dd><p>Object of class <code>"logical"</code>: TRUE means that metrics have been normalized to sum 100pct </p>
</dd>
<dt><code>always</code>:</dt><dd><p>Object of class <code>"numintnull"</code>: variables always in the model (adjusted for),
in terms of columns in the model matrix (i.e. in case of factors in the model, there are more entries 
than in the call to function <code>calc.relimp</code>; first possible column is 2 (1 reserved for response)) </p>
</dd>
<dt><code>alwaysnam</code>:</dt><dd><p>Object of class <code>"charnull"</code>: variable names of variables always in model </p>
</dd>
<dt><code>groupdocu</code>:</dt><dd><p>Object of class <code>"list"</code>: information on group definitions </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"langnull"</code>: the call that created the object </p>
</dd>
</dl>



<h3>Methods</h3>

<p>This documentation section documents S4 methods only. 
There are also S3-methods for printing, plotting and extracting slots with <code>$</code>. 
For their usage, see <code><a href="#topic+classesmethods.relaimpo">classesmethods.relaimpo</a></code>.
</p>

<dl>
<dt>coerce</dt><dd><p>S4-method: If an object of this class is coerced to list by <code>as(object, "list")</code>, 
the slots are output to the list in the following order: <code>var.y</code>, <code>R2</code>, <code>lmg</code>, <code>lmg.rank</code>, <code>lmg.diff</code>, 
next three in non-US version only: <code>pmvd</code>, <code>pmvd.rank</code>, <code>pmvd.diff</code>, <code>last</code>,  
<code>last.rank</code>, <code>last.diff</code>, ..., <code>pratt</code>, <code>pratt.rank</code>, <code>pratt.diff</code>, <code>namen</code>, <code>type</code>, 
<code>rela</code>, <code>always</code>, <code>alwaysnam</code>
</p>
</dd>

<dt>show</dt><dd><p>S4-method: identical to <code>print</code></p>
</dd>


</dl>



<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>See Also</h3>

<p><code><a href="#topic+calc.relimp">calc.relimp</a></code>, <code><a href="#topic+print.relimplm">print.relimplm</a></code>, <code><a href="#topic+plot.relimplm">plot.relimplm</a></code>, <span class="pkg"><a href="#topic+relaimpo">relaimpo</a></span>
</p>

<hr>
<h2 id='relimplmboot-class'>Class relimplmboot </h2><span id='topic+relimplmboot-class'></span><span id='topic+show+2Crelimplmboot-method'></span>

<h3>Description</h3>

<p>  This is the class for output objects from function <code>boot.relimp</code>. It is needed as input to function <code>booteval.relimp</code>. </p>


<h3>Objects from the Class</h3>

<p>Objects should only be created by calls to the function <code>boot.relimp</code>. 
</p>


<h3>Slots</h3>


<dl>
<dt><code>boot</code>:</dt><dd><p>Object of class <code>"boot"</code>, output from bootstrapping </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code>, metrics that have been bootstrapped </p>
</dd>
<dt><code>nboot</code>:</dt><dd><p>Object of class <code>"numeric"</code>, number of bootstrap runs </p>
</dd>
<dt><code>rank</code>:</dt><dd><p>Object of class <code>"logical"</code>, have ranks been bootstrapped ? </p>
</dd>
<dt><code>diff</code>:</dt><dd><p>Object of class <code>"logical"</code>, have differences been bootstrapped ? </p>
</dd>
<dt><code>rela</code>:</dt><dd><p>Object of class <code>"logical"</code>, have the metrics been forced to add up to 100pct (TRUE) or not? </p>
</dd>
<dt><code>fixed</code>:</dt><dd><p>Object of class <code>"logical"</code>, has bootstrapping been done for fixed (TRUE) or random (FALSE) regressors? </p>
</dd>
<dt><code>namen</code>:</dt><dd><p>Object of class <code>"character"</code>: variable names of all variables (y and the regressors) </p>
</dd>
<dt><code>nobs</code>:</dt><dd><p>Object of class <code>"numeric"</code>: number of valid observations used in calculations </p>
</dd>
<dt><code>always</code>:</dt><dd><p>Object of class <code>"numintnull"</code>: variables always in the model </p>
</dd>
<dt><code>alwaysnam</code>:</dt><dd><p>Object of class <code>"charnull"</code>: variable names of variables always in model </p>
</dd>
<dt><code>groupdocu</code>:</dt><dd><p>Object of class <code>"list"</code>: information on group definitions </p>
</dd>
<dt><code>wt</code>:</dt><dd><p>Object of class <code>"numintnull"</code>: observation weights </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"numintmatnull"</code>: variance-covariance matrix of the estimate</p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"langnull"</code>: the call that created the object </p>
</dd>
</dl>



<h3>Methods</h3>

<p>This documentation section documents S4 methods only. 
There is an analogous S3-method for printing.
</p>

<dl>
<dt>show</dt><dd><p>S4 method: identical to <code>print</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin </p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.relimp">boot.relimp</a></code>, <code><a href="#topic+booteval.relimp">booteval.relimp</a></code>,
<code><a href="#topic+relimplmbooteval-class">relimplmbooteval-class</a></code>,<code><a href="#topic+relimplmbootMI-class">relimplmbootMI-class</a></code>
</p>

<hr>
<h2 id='relimplmbooteval-class'>Class relimplmbooteval </h2><span id='topic+relimplmbooteval-class'></span><span id='topic+show+2Crelimplmbooteval-method'></span>

<h3>Description</h3>

<p>  Output object from function <code><a href="#topic+booteval.relimp">booteval.relimp</a></code>, described there. </p>


<h3>Objects from the Class</h3>

<p>Objects should only be created by calls to function <code>booteval.relimp</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lmg.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>lmg.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>lmg.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>lmg.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>lmg.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>lmg.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>var.y.boot</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>R2.boot</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>R2.decomp.boot</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>lmg.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>lmg.rank.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.rank.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.rank.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.rank.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.rank.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.rank.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.rank.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.rank.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>lmg.diff.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pmvd.diff.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>last.diff.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>first.diff.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>betasq.diff.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>pratt.diff.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>genizi.diff.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>car.diff.boot</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>est</code>:</dt><dd><p>Object of class <code>"numintnull"</code> ~~ </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"numintmatnull"</code> ~~ </p>
</dd>
<dt><code>level</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>nboot</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>diffnam</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>rank</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>diff</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>rela</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>fixed</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>sort</code>:</dt><dd><p>Object of class <code>"logical"</code> ~~ </p>
</dd>
<dt><code>bty</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>mark</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>markdiff</code>:</dt><dd><p>Object of class <code>"matrix"</code> ~~ </p>
</dd>
<dt><code>var.y</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>R2</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>R2.decomp</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>lmg</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pmvd</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>first</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>last</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>betasq</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pratt</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>genizi</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>car</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>lmg.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pmvd.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>first.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>last.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>betasq.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pratt.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>genizi.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>car.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>lmg.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pmvd.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>first.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>last.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>betasq.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>pratt.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>genizi.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>car.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>namen</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
<dt><code>nobs</code>:</dt><dd><p>Object of class <code>"numeric"</code> ~~ </p>
</dd>
<dt><code>ave.coeffs</code>:</dt><dd><p>Object of class <code>"numintmatnull"</code> ~~ </p>
</dd>
<dt><code>always</code>:</dt><dd><p>Object of class <code>"numintnull"</code> ~~ </p>
</dd>
<dt><code>alwaysnam</code>:</dt><dd><p>Object of class <code>"charnull"</code> ~~ </p>
</dd>
<dt><code>groupdocu</code>:</dt><dd><p>Object of class <code>"list"</code> ~~ </p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"langnull"</code> ~~ </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+relimplm-class">relimplm</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>This documentation section documents S4 methods only. 
There are also S3-methods for printing, plotting and extracting slots with <code>$</code>. 
For their usage, see <code><a href="#topic+classesmethods.relaimpo">classesmethods.relaimpo</a></code>.
</p>

<dl>
<dt>show</dt><dd><p>S4 method: identical to <code>print</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin</p>


<h3>See Also</h3>

<p><code><a href="#topic+relimplm-class">relimplm-class</a></code>, <code><a href="#topic+relimplmboot-class">relimplmboot-class</a></code>, <code><a href="#topic+relimplmbootMI-class">relimplmbootMI-class</a></code>, 
<code><a href="#topic+booteval.relimp">booteval.relimp</a></code>, <code><a href="#topic+print.relimplmbooteval">print.relimplmbooteval</a></code>, 
<code><a href="#topic+plot.relimplmbooteval">plot.relimplmbooteval</a></code>
</p>

<hr>
<h2 id='relimplmbootMI-class'>Class relimplmbootMI </h2><span id='topic+relimplmbootMI-class'></span><span id='topic+show+2CrelimplmbootMI-method'></span>

<h3>Description</h3>

<p>  Output object from function <code><a href="#topic+mianalyze.relimp">mianalyze.relimp</a></code>, described there. </p>


<h3>Objects from the Class</h3>

<p>Objects should only be created by calls to function <code>mianalyze.relimp</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>lmg.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>lmg.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>lmg.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>lmg.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>lmg.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>lmg.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pmvd.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pmvd.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pmvd.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pmvd.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pmvd.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pmvd.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>last.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>last.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>last.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>last.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>last.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>last.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>first.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>first.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>first.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>first.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>first.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>first.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>betasq.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>betasq.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>betasq.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>betasq.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>betasq.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>betasq.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pratt.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pratt.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pratt.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pratt.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pratt.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>pratt.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>genizi.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>genizi.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>genizi.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>genizi.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>genizi.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>genizi.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>car.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>car.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>car.rank.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>car.rank.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>car.diff.lower</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>car.diff.upper</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>MIresult</code>:</dt><dd><p>Object of class <code>"MIresult"</code>  </p>
</dd>
<dt><code>est</code>:</dt><dd><p>Object of class <code>"numintnull"</code>  </p>
</dd>
<dt><code>vcov</code>:</dt><dd><p>Object of class <code>"nummatnull"</code>  </p>
</dd>
<dt><code>bootlist</code>:</dt><dd><p>Object of class <code>"listnull"</code>, 
list of objects of class relimplmboot or null </p>
</dd>
<dt><code>level</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>nboot</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>diffnam</code>:</dt><dd><p>Object of class <code>"character"</code>  </p>
</dd>
<dt><code>rank</code>:</dt><dd><p>Object of class <code>"logical"</code>  </p>
</dd>
<dt><code>diff</code>:</dt><dd><p>Object of class <code>"logical"</code>  </p>
</dd>
<dt><code>rela</code>:</dt><dd><p>Object of class <code>"logical"</code>  </p>
</dd>
<dt><code>fixed</code>:</dt><dd><p>Object of class <code>"logical"</code>  </p>
</dd>
<dt><code>type</code>:</dt><dd><p>Object of class <code>"character"</code>  </p>
</dd>
<dt><code>sort</code>:</dt><dd><p>Object of class <code>"logical"</code>  </p>
</dd>
<dt><code>bty</code>:</dt><dd><p>Object of class <code>"character"</code>  </p>
</dd>
<dt><code>mark</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>markdiff</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>var.y</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>R2</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>R2.decomp</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>lmg</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pmvd</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>first</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>last</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>betasq</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pratt</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>genizi</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>car</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>lmg.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pmvd.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>first.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>last.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>betasq.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pratt.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>genizi.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>car.rank</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>lmg.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pmvd.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>first.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>last.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>betasq.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pratt.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>genizi.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>car.diff</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>namen</code>:</dt><dd><p>Object of class <code>"character"</code>  </p>
</dd>
<dt><code>nobs</code>:</dt><dd><p>Object of class <code>"numeric"</code>: number of valid observations used in analysis  </p>
</dd>
<dt><code>always</code>:</dt><dd><p>Object of class <code>"numintnull"</code>: variables always in the model </p>
</dd>
<dt><code>alwaysnam</code>:</dt><dd><p>Object of class <code>"charnull"</code>: variable names of variables always in model </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"relimplm"</code>, directly.
</p>


<h3>Methods</h3>

<p>This documentation section documents S4 methods only. 
There are also S3-methods for printing, plotting, extracting slots with <code>$</code> and producing 
a brief summary. For their usage, see <code><a href="#topic+classesmethods.relaimpo">classesmethods.relaimpo</a></code>.
</p>

<dl>
<dt>show</dt><dd><p> S4-method: identical to <code>print</code></p>
</dd>
</dl>
<p>to the slot <code>MIresult</code> for a briefer output than the standard printout 
</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping, BHT Berlin</p>


<h3>See Also</h3>

<p><code><a href="#topic+relimplm-class">relimplm-class</a></code>, <code><a href="#topic+relimplmbooteval-class">relimplmbooteval-class</a></code>, 
<code><a href="#topic+booteval.relimp">booteval.relimp</a></code>, <code><a href="#topic+print.relimplmbootMI">print.relimplmbootMI</a></code>, 
<code><a href="#topic+plot.relimplmbootMI">plot.relimplmbootMI</a></code>, <code><a href="#topic+summary.relimplmbootMI">summary.relimplmbootMI</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
