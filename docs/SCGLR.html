<!DOCTYPE html><html><head><title>Help for package SCGLR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SCGLR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+24.MultivariateFormula'><p>$ operator for multivariate formula</p></a></li>
<li><a href='#barplot.SCGLR'><p>Barplot of percent of overall X variance captured by component</p></a></li>
<li><a href='#barplot.SCGLRTHM'><p>Barplot of percent of overall X variance captured by component</p></a></li>
<li><a href='#critConvergence'><p>Auxiliary function for controlling SCGLR fitting</p></a></li>
<li><a href='#customize'><p>Plot customization</p></a></li>
<li><a href='#genus'><p>Sample dataset of abundance of genera in tropical moist forest</p></a></li>
<li><a href='#infoCriterion'><p>Function that calculates cross-validation selection criteria</p></a></li>
<li><a href='#methodSR'><p>Regularization criterion types</p></a></li>
<li><a href='#multivariateFormula'><p>Formula construction</p></a></li>
<li><a href='#multivariateGlm.fit'><p>Multivariate generalized linear regression</p></a></li>
<li><a href='#multivariatePredictGlm'><p>Function that predicts the responses from the covariates for a new sample</p></a></li>
<li><a href='#pairs.SCGLR'><p>Pairwise scglr plot on components</p></a></li>
<li><a href='#plot.SCGLR'><p>SCGLR generic plot</p></a></li>
<li><a href='#plot.SCGLRTHM'><p>SCGLRTHM generic plot</p></a></li>
<li><a href='#print.MultivariateFormula'><p>print a multivariate formula</p></a></li>
<li><a href='#print.SCGLR'><p>Print SCGLR object</p></a></li>
<li><a href='#scglr'><p>Function that fits the scglr model</p></a></li>
<li><a href='#scglrCrossVal'><p>Function that fits and selects the number of component by cross-validation.</p></a></li>
<li><a href='#scglrTheme'><p>Function that fits the theme model</p></a></li>
<li><a href='#scglrThemeBackward'><p>Theme Backward selection</p></a></li>
<li><a href='#screeplot.SCGLR'><p>Screeplot of percent of overall X variance captured by component</p></a></li>
<li><a href='#screeplot.SCGLRTHM'><p>Screeplot of percent of overall X variance captured by component</p></a></li>
<li><a href='#summary.SCGLR'><p>Summarizing SCGLR fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Supervised Component Generalized Linear Regression</td>
</tr>
<tr>
<td>Description:</td>
<td>
    An extension of the Fisher Scoring Algorithm to combine PLS regression with GLM 
    estimation in the multivariate context. Covariates can also be grouped in themes.</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-09-24</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://scnext.github.io/SCGLR">https://scnext.github.io/SCGLR</a>, <a href="https://github.com/SCnext/SCGLR">https://github.com/SCnext/SCGLR</a>,
<a href="https://cran.r-project.org/package=SCGLR">https://cran.r-project.org/package=SCGLR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SCnext/SCGLR/issues">https://github.com/SCnext/SCGLR/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix,Formula,expm,graphics,ggplot2,grid,pROC,ade4</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel,gridExtra</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-09-28 08:56:02 UTC; gcornu</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillaume Cornu <a href="https://orcid.org/0000-0002-7523-5176"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Frederic Mortier [aut],
  Catherine Trottier [aut],
  Xavier Bry [aut],
  Sylvie Gourlet-Fleury
    <a href="https://orcid.org/0000-0002-1136-4307"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [dtc]
    (http://www.coforchange.eu/),
  Claude Garcia <a href="https://orcid.org/0000-0002-7351-0226"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [dtc] (http://www.cofortips.org/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillaume Cornu &lt;gcornu@cirad.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-09-28 09:30:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='+24.MultivariateFormula'>$ operator for multivariate formula</h2><span id='topic++24.MultivariateFormula'></span>

<h3>Description</h3>

<p>S3 helper function to retrieve attributes as if it was named values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MultivariateFormula'
f$a
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24.MultivariateFormula_+3A_f">f</code></td>
<td>
<p>formula</p>
</td></tr>
<tr><td><code id="+2B24.MultivariateFormula_+3A_a">a</code></td>
<td>
<p>attribute</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>frm &lt;- multivariateFormula(y~x+z)
print(frm$Y)
</code></pre>

<hr>
<h2 id='barplot.SCGLR'>Barplot of percent of overall X variance captured by component</h2><span id='topic+barplot.SCGLR'></span>

<h3>Description</h3>

<p>Barplot of percent of overall X variance captured by component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLR'
barplot(height, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplot.SCGLR_+3A_height">height</code></td>
<td>
<p>object of class 'SCGLR', usually a result of running <code><a href="#topic+scglr">scglr</a></code>.</p>
</td></tr>
<tr><td><code id="barplot.SCGLR_+3A_...">...</code></td>
<td>
<p>optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class ggplot.
</p>


<h3>See Also</h3>

<p>For barplot application see examples in <code><a href="#topic+plot.SCGLR">plot.SCGLR</a></code>.
</p>

<hr>
<h2 id='barplot.SCGLRTHM'>Barplot of percent of overall X variance captured by component</h2><span id='topic+barplot.SCGLRTHM'></span>

<h3>Description</h3>

<p>Barplot of percent of overall X variance captured by component by theme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLRTHM'
barplot(height, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplot.SCGLRTHM_+3A_height">height</code></td>
<td>
<p>object of class 'SCGLRTHM', usually a result of running <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
<tr><td><code id="barplot.SCGLRTHM_+3A_...">...</code></td>
<td>
<p>optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class ggplot.
</p>

<hr>
<h2 id='critConvergence'>Auxiliary function for controlling SCGLR fitting</h2><span id='topic+critConvergence'></span>

<h3>Description</h3>

<p>Auxiliary function for <code>scglr</code> fitting used to 
construct a convergence control argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critConvergence(tol = 1e-06, maxit = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="critConvergence_+3A_tol">tol</code></td>
<td>
<p>positive convergence threshold.</p>
</td></tr>
<tr><td><code id="critConvergence_+3A_maxit">maxit</code></td>
<td>
<p>integer, maximum number of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing elements named as the arguments.
</p>

<hr>
<h2 id='customize'>Plot customization</h2><span id='topic+customize'></span>

<h3>Description</h3>

<p>Parameters used to choose what to plot and how. These parameters are given to <code><a href="#topic+plot.SCGLR">plot.SCGLR</a></code> and <code><a href="#topic+pairs.SCGLR">pairs.SCGLR</a></code>.
</p>


<h3>Details</h3>

<p>Parameter name can be abbreviated (e.g. <code>pred.col</code> will be understood as predictors.color).<br />
Options can be set globally using <code>options("plot.SCGLR")</code>. It will then provide default values that can be further overriden by giving explicit parameter value.
</p>

<table>
<tr>
 <td style="text-align: left;">
   <b><em>parameter name</em></b>    </td><td style="text-align: left;"> <b><em>type (default value). Description.</em></b></td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>title</code>                    </td><td style="text-align: left;"> string (NULL). Main title of plot (override built-in).</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>labels.auto</code>              </td><td style="text-align: left;"> logical (TRUE). Should covariate or predictor labels be aligned with arrows.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>labels.offset</code>            </td><td style="text-align: left;"> numeric (0.01). Offset by which labels should be moved from tip of arrows.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>labels.size</code>              </td><td style="text-align: left;"> numeric (1). Relative size for labels. Use it to globally alter label size.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>expand</code>                   </td><td style="text-align: left;"> numeric (1). Expand factor for windows size. Use it for example to make room for clipped labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>threshold</code>                </td><td style="text-align: left;"> numeric. All covariates and/or predictors whose sum of square correlations with the two components of the plane lower than this threshold will be ignored.</td>
</tr>
<tr>
 <td style="text-align: left;">

   <b><code>observations</code></b>      </td><td style="text-align: left;"> logical (FALSE). Should we draw observations.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>observations.size</code>        </td><td style="text-align: left;"> numeric (1). Point size. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>observations.color</code>       </td><td style="text-align: left;"> character ("black"). Point color.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>observations.alpha</code>       </td><td style="text-align: left;"> numeric (1). Point transparency.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>observations.factor</code>      </td><td style="text-align: left;"> logical (FALSE). Paint observations according to factor (specify factor).</td>
</tr>
<tr>
 <td style="text-align: left;">

   <b><code>predictors</code></b>        </td><td style="text-align: left;"> logical or array of characters (FALSE). Should we draw predictors and optionally which one (TRUE means all).</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.color</code>         </td><td style="text-align: left;"> string ("red"). Base color used to draw predictors.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.alpha</code>         </td><td style="text-align: left;"> numeric (1). Overall transparency for predictors (0 is transparent, 1 is opaque). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.arrows</code>        </td><td style="text-align: left;"> logical (TRUE). Should we draw arrows for predictors.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.arrows.color</code>  </td><td style="text-align: left;"> string (predictors.color). Specific color for predictor arrows.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.arrows.alpha</code>  </td><td style="text-align: left;"> numeric (predictors.alpha). Transparency for predictor arrows.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.labels</code>        </td><td style="text-align: left;"> logical (TRUE). Should we draw labels for predictors.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.labels.color</code>  </td><td style="text-align: left;"> string (predictors.color). Specific color for predictor labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.labels.alpha</code>  </td><td style="text-align: left;"> numeric (predictors.alpha). Transparency for predictor labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.labels.size</code>   </td><td style="text-align: left;"> numeric (labels.size). Specific size for predictor labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>predictors.labels.auto</code>   </td><td style="text-align: left;"> logical (labels.auto). Should predictor labels be aligned with arrows.</td>
</tr>
<tr>
 <td style="text-align: left;">

   <b><code>covariates</code></b>        </td><td style="text-align: left;"> logical or array of characters (TRUE). Should we draw covariates and optionally which one (TRUE means all).</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.color</code>         </td><td style="text-align: left;"> string ("black"). Base color used to draw covariates. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.alpha</code>         </td><td style="text-align: left;"> numeric (1). Overall transparency for covariates (0 is transparent, 1 is opaque). </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.arrows</code>        </td><td style="text-align: left;"> logical (TRUE). Should we draw arrows for covariates.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.arrows.color</code>  </td><td style="text-align: left;"> string (covariates.color). Specific color for covariate arrows.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.arrows.alpha</code>  </td><td style="text-align: left;"> numeric (covariates.alpha). Transparency for covariate arrows.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.labels</code>        </td><td style="text-align: left;"> logical (TRUE). Should we draw labels for predictors.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.labels.color</code>  </td><td style="text-align: left;"> string (covariates.color). Specific color for predictor labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.labels.alpha</code>  </td><td style="text-align: left;"> numeric (covariates.alpha). Transparency for covariate labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.labels.size</code>   </td><td style="text-align: left;"> numeric (labels.size). Specific size for covariate labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>covariates.labels.auto</code>   </td><td style="text-align: left;"> logical (labels.auto). Should covariate labels be aligned with arrows. </td>
</tr>
<tr>
 <td style="text-align: left;">

   <b><code>factor</code></b>            </td><td style="text-align: left;"> logical or character (FALSE). Should we draw a factor chosen among additionnal variables (TRUE mean first one).</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>factor.points</code>            </td><td style="text-align: left;"> logical (TRUE). Should symbol be drawn for factors.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>factor.points.size</code>       </td><td style="text-align: left;"> numeric (4). Symbol size.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>factor.points.shape</code>      </td><td style="text-align: left;"> numeric (13). Point shape.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>factor.labels</code>            </td><td style="text-align: left;"> logical (TRUE). Should factor labels be drawn.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>factor.labels.color</code>      </td><td style="text-align: left;"> string ("black"). Color used to draw labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>factor.labels.size</code>       </td><td style="text-align: left;"> numeric (labels.size). Specific size for factor labels.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# setting parameters
plot(genus.scglr)
plot(genus.scglr, predictors=TRUE)
plot(genus.scglr, predictors=TRUE, pred.arrows=FALSE)

# setting global style
options(plot.SCGLR=list(predictors=TRUE, pred.arrows=FALSE))
plot(genus.scglr)

# setting custom style
myStyle &lt;- list(predictors=TRUE, pred.arrows=FALSE)
plot(genus.scglr, style=myStyle)

## End(Not run)
</code></pre>

<hr>
<h2 id='genus'>Sample dataset of abundance of genera in tropical moist forest</h2><span id='topic+genus'></span>

<h3>Description</h3>

<p>Genus gives the abundance of 27 common tree genera in the tropical moist forest 
of the Congo-Basin and 40 geo-referenced environmental variables on one thousand 8 by 8 km plots
(observations). Each plot's data was obtained by aggregating the data measured on a variable 
number of previously sampled 0.5 ha sub-plots. Geo-referenced environmental variables were 
used to describe the physical factors as well as vegetation characteristics. 
14 physical factors were used pertaining the description of topography, geology and rainfall 
of each plot. Vegetation is characterized through 16-days enhanced vegetation index (EVI) data.
</p>


<h3>Format</h3>


<table>
<tr>
 <td style="text-align: left;">
   <code>gen1 to gen27</code> </td><td style="text-align: left;"> abundance of the 27 common genera.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>altitude</code> </td><td style="text-align: left;"> above-sea level in meters.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>pluvio_yr</code> </td><td style="text-align: left;"> mean annual rainfall.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>forest</code> </td><td style="text-align: left;"> classified into seven classes.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>pluvio_1 to pluvio_12</code> </td><td style="text-align: left;"> monthly rainfalls.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>geology</code> </td><td style="text-align: left;"> 5-level geological substrate.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>evi_1 to evi_23</code> </td><td style="text-align: left;"> 16-days enhanced vegetation indexes.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lon and lat</code> </td><td style="text-align: left;"> position of the plot centers.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>surface</code> </td><td style="text-align: left;"> sampled area.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Note</h3>

<p>The use of this dataset for publication must make reference to the CoForChange project.
</p>


<h3>Author(s)</h3>

<p>CoForChange project
</p>


<h3>References</h3>

<p>S. Gourlet-Fleury et al. (2009&ndash;2014) CoForChange project: <a href="http://www.coforchange.eu/">http://www.coforchange.eu/</a>
</p>
<p>C. Garcia et al. (2013&ndash;2015) CoForTips project: <a href="http://www.cofortips.org/">http://www.cofortips.org/</a>
</p>

<hr>
<h2 id='infoCriterion'>Function that calculates cross-validation selection criteria</h2><span id='topic+infoCriterion'></span>

<h3>Description</h3>

<p>Function that calculates cross-validation selection criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infoCriterion(ynew, pred, family, type, size = NULL, npar = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infoCriterion_+3A_ynew">ynew</code></td>
<td>
<p>data matrix corresponding to the observations used as test sample.</p>
</td></tr>
<tr><td><code id="infoCriterion_+3A_pred">pred</code></td>
<td>
<p>predicted value of the linear predictor obtained from Xnew and the estimated parameters.</p>
</td></tr>
<tr><td><code id="infoCriterion_+3A_family">family</code></td>
<td>
<p>a vector of the same length as the number of responses containing characters
identifying the distribution families of the dependent variables.
&quot;bernoulli&quot;, &quot;binomial&quot;, &quot;poisson&quot; or &quot;gaussian&quot; are allowed.</p>
</td></tr>
<tr><td><code id="infoCriterion_+3A_type">type</code></td>
<td>
<p>information criterion used. Likelihood, aic, bic, aicc or
Mean Square Prediction Error (mspe) are defined. Area Under ROC Curve (auc) also defined for Bernoulli cases only.</p>
</td></tr>
<tr><td><code id="infoCriterion_+3A_size">size</code></td>
<td>
<p>describes the number of trials for the binomial dependent variables.
A (number of statistical units * number of binomial dependent variables) matrix is expected.</p>
</td></tr>
<tr><td><code id="infoCriterion_+3A_npar">npar</code></td>
<td>
<p>number of parameters used for penalisation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the criterion value for each dependent variable (row)
and each number of components (column).
</p>

<hr>
<h2 id='methodSR'>Regularization criterion types</h2><span id='topic+methodSR'></span>

<h3>Description</h3>

<p>Regularization criterion types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methodSR(phi = "vpi", l = 1, s = 1/2, maxiter = 1000,
  epsilon = 1e-06, bailout = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methodSR_+3A_phi">phi</code></td>
<td>
<p>character string describing structura relevance used in the regularization process.
Allowed values are &quot;vpi&quot; for Variable Powered Inertia and &quot;cv&quot; for Component Variance. Default to &quot;vpi&quot;.</p>
</td></tr>
<tr><td><code id="methodSR_+3A_l">l</code></td>
<td>
<p>is an integer argument (&gt;1) tuning the importance of variable bundle locality.</p>
</td></tr>
<tr><td><code id="methodSR_+3A_s">s</code></td>
<td>
<p>is a numeric argument (in [0,1]) tuning the strength of structural relevance with respect to goodness of fit.</p>
</td></tr>
<tr><td><code id="methodSR_+3A_maxiter">maxiter</code></td>
<td>
<p>integer for maximum number of iterations of <code>SR</code> function</p>
</td></tr>
<tr><td><code id="methodSR_+3A_epsilon">epsilon</code></td>
<td>
<p>positive convergence threshold</p>
</td></tr>
<tr><td><code id="methodSR_+3A_bailout">bailout</code></td>
<td>
<p>integer argument</p>
</td></tr>
</table>

<hr>
<h2 id='multivariateFormula'>Formula construction</h2><span id='topic+multivariateFormula'></span>

<h3>Description</h3>

<p>Helper function for building multivariate scglr formula.
</p>
<p>NOTE: Interactions involving factors are not allowed for now.
For interactions between two quantitative variables, use <code>I(x*y)</code> as usual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivariateFormula(Y, X = NULL, ..., A = NULL, additional = NULL,
  data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multivariateFormula_+3A_y">Y</code></td>
<td>
<p>a formula or a vector of character containing the names of the dependent variables.</p>
</td></tr>
<tr><td><code id="multivariateFormula_+3A_x">X</code></td>
<td>
<p>a vector of character containing the names of the covariates (X) involved in the components or a list of it.</p>
</td></tr>
<tr><td><code id="multivariateFormula_+3A_...">...</code></td>
<td>
<p>additional groups of covariates (theme)</p>
</td></tr>
<tr><td><code id="multivariateFormula_+3A_a">A</code></td>
<td>
<p>a vector of character containing the names of the additional covariates.</p>
</td></tr>
<tr><td><code id="multivariateFormula_+3A_additional">additional</code></td>
<td>
<p>logical (if A is not provided, should we consider last X to be additional covariates)</p>
</td></tr>
<tr><td><code id="multivariateFormula_+3A_data">data</code></td>
<td>
<p>a data frame against which formula's variable will be checked</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If Y is given as a formula, groups of covariates must be separated by <code>|</code> (pipes). To declare last
group as additional covariates, one can use <code>||</code> (double pipes) as last group separator or set
<code>additional</code> parameter as <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>MultivariateFormula, Formula, formula</code> with additional attributes: Y, X, A, X_vars, Y_vars,A_vars,XA_vars, YXA_vars, additional
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# build multivariate formula
ny &lt;- c("y1","y2")
nx1 &lt;- c("x11","x12")
nx2 &lt;- c("x21","x22")
nadd &lt;- c("add1","add2")
form &lt;- multivariateFormula(ny,nx1,nx2,nadd,additional=T)
form2 &lt;- multivariateFormula(ny,list(nx1,nx2,nadd),additional=T)
form3 &lt;- multivariateFormula(ny,list(nx1,nx2),A=nadd)
form4 &lt;- multivariateFormula(y1+y2~x11+x12|x21+x22||add1+add2)
# Print formulas
form
form2
form3

## End(Not run)
</code></pre>

<hr>
<h2 id='multivariateGlm.fit'>Multivariate generalized linear regression</h2><span id='topic+multivariateGlm.fit'></span>

<h3>Description</h3>

<p><code>multivariateGlm</code> is used to fit multivariate generalized linear models
specified by a symbolic formula together with the distributions of the responses.
This function performs a simple GLM fit for each dependent variable with the associated distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivariateGlm.fit(Y, comp, family, offset, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multivariateGlm.fit_+3A_y">Y</code></td>
<td>
<p>matrix of dependent variables.</p>
</td></tr>
<tr><td><code id="multivariateGlm.fit_+3A_comp">comp</code></td>
<td>
<p>matrix of covariates.</p>
</td></tr>
<tr><td><code id="multivariateGlm.fit_+3A_family">family</code></td>
<td>
<p>a vector of character giving the family distribution of each response.</p>
</td></tr>
<tr><td><code id="multivariateGlm.fit_+3A_offset">offset</code></td>
<td>
<p>used for the poisson dependent variables.
A vector or a matrix of size: number of observations * number of Poisson dependent variables is expected.</p>
</td></tr>
<tr><td><code id="multivariateGlm.fit_+3A_size">size</code></td>
<td>
<p>a matrix giving the number of trials for each Binomial dependent variable
ncol(size) must be equal to the number of Binomial variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list, each item of which is the glm object associated with each response.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SCGLR)

# load sample data
data(genus)

# get variable names from dataset
n &lt;- names(genus)
ny &lt;- n[grep("^gen",n)]    # Y &lt;- names that begins with "gen"
nx &lt;- n[-grep("^gen",n)]   # X &lt;- remaining names

# remove "geology" and "surface" from nx as surface
# is offset and we want to use geology as additional covariate
nx &lt;-nx[!nx%in%c("geology","surface")]

# build multivariate formula
# we also add "lat*lon" as computed covariate
form &lt;- multivariateFormula(ny,c(nx,"I(lat*lon)"),c("geology"))

# split genus dataset
sub &lt;- sample(1:nrow(genus),100,replace=FALSE)
sub_fit &lt;- (1:nrow(genus))[-sub]

# define family
fam &lt;- rep("poisson",length(ny))

# fit the model
genus.scglr &lt;- scglr(formula=form, data=genus, family=fam, K=4,
 offset=genus$surface, subset=sub_fit)

# xnew, the design matrix associated to sub-sample used for prediction
# note rhs parameter is introduced to take into account that the
# covariate part of the formula is composed of two differents sets
xnew &lt;- model.matrix(form, data=genus[sub,], rhs=1:2)[,-1]

# prediction based on the scglr approch
pred.scglr &lt;- multivariatePredictGlm(xnew,family=fam,
 beta=genus.scglr$beta, offset=genus$surface[sub])
cor.scglr &lt;-diag(cor(pred.scglr,genus[sub,ny]))
plot(cor.scglr, col="red",ylim=c(-1,1))

# prediction based on classical poisson glm
X &lt;- model.matrix(form, data=genus)[,-1]
Y &lt;- genus[,ny]
genus.glm &lt;- multivariateGlm.fit(Y[sub_fit,,drop=FALSE],X[sub_fit,,drop=FALSE],
             family=fam, offset=matrix(genus$surface[sub_fit],
             length(sub_fit),length(ny)),size=NULL)
coefs &lt;- sapply(genus.glm,coef)

# rhs parameter is introduced to take into account that the
# covariate part of the formula is composed of two differents sets
pred.glm &lt;- multivariatePredictGlm(xnew,family=fam,beta=coefs,
 offset=genus$surface[sub])
cor.glm &lt;- diag(cor(pred.glm,genus[sub,ny]))

points(cor.glm, col="blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='multivariatePredictGlm'>Function that predicts the responses from the covariates for a new sample</h2><span id='topic+multivariatePredictGlm'></span>

<h3>Description</h3>

<p>Function that predicts the responses from the covariates for a new sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multivariatePredictGlm(Xnew, family, beta, offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multivariatePredictGlm_+3A_xnew">Xnew</code></td>
<td>
<p>a data frame containing the values of the covariates for the new sample.</p>
</td></tr>
<tr><td><code id="multivariatePredictGlm_+3A_family">family</code></td>
<td>
<p>a vector of character specifying the distributions of the responses.</p>
</td></tr>
<tr><td><code id="multivariatePredictGlm_+3A_beta">beta</code></td>
<td>
<p>the matrix of coefficients estimated from the calibration sample.</p>
</td></tr>
<tr><td><code id="multivariatePredictGlm_+3A_offset">offset</code></td>
<td>
<p>used for the poisson dependent variables.
A vector or a matrix of size: number of observations * number of Poisson dependent variables is expected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of predicted values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SCGLR)

# load sample data
data(genus)

# get variable names from dataset
n &lt;- names(genus)
ny &lt;- n[grep("^gen",n)]    # Y &lt;- names that begins with "gen"
nx &lt;- n[-grep("^gen",n)]   # X &lt;- remaining names

# remove "geology" and "surface" from nx as surface is
# offset and we want to use geology as additional covariate
nx &lt;-nx[!nx%in%c("geology","surface")]

# build multivariate formula
# we also add "lat*lon" as computed covariate
form &lt;- multivariateFormula(ny,c(nx,"I(lat*lon)"),c("geology"))

# split genus dataset
sub &lt;- sample(1:nrow(genus),100,replace=FALSE)
sub_fit &lt;- (1:nrow(genus))[-sub]

# define family
fam &lt;- rep("poisson",length(ny))

# fit the model
genus.scglr &lt;- scglr(formula=form, data=genus, family=fam, K=4,
 offset=genus$surface, subset=sub_fit)

# xnew, the design matrix associated to sub-sample used for prediction
# rhs parameters is introduced to take into account that the covariate
# of the formula is composed of two differents sets
xnew &lt;- model.matrix(form, data=genus[sub,], rhs=1:2)[,-1]

# prediction based on the scglr approch
pred.scglr &lt;- multivariatePredictGlm(xnew,family=fam,
 beta=genus.scglr$beta,offset=genus$surface[sub])
cor.scglr &lt;-diag(cor(pred.scglr,genus[sub,ny]))
plot(cor.scglr, col="red",ylim=c(-1,1))

# prediction based on classical poisson glm
X &lt;- model.matrix(form, data=genus)[,-1]
Y &lt;- genus[,ny]
genus.glm &lt;- multivariateGlm.fit(Y[sub_fit,,drop=FALSE],X[sub_fit,,drop=FALSE],
                              family=fam, offset=matrix(genus$surface[sub_fit],
                              length(sub_fit),length(ny)),size=NULL)
coefs &lt;- sapply(genus.glm,coef)

# rhs parameters is introduced to take into account that the covariate
# part of the formula is composed of two differents sets
pred.glm &lt;- multivariatePredictGlm(xnew,family=fam,beta=coefs,
 offset=genus$surface[sub])
cor.glm &lt;- diag(cor(pred.glm,genus[sub,ny]))

points(cor.glm, col="blue")

## End(Not run)
</code></pre>

<hr>
<h2 id='pairs.SCGLR'>Pairwise scglr plot on components</h2><span id='topic+pairs.SCGLR'></span>

<h3>Description</h3>

<p>Pairwise scglr plot on components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLR'
pairs(x, ..., nrow = NULL, ncol = NULL,
  components = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.SCGLR_+3A_x">x</code></td>
<td>
<p>object of class 'SCGLR', usually a result of running <code><a href="#topic+scglr">scglr</a></code>.</p>
</td></tr>
<tr><td><code id="pairs.SCGLR_+3A_...">...</code></td>
<td>
<p>optionally, further arguments forwarded to <code><a href="#topic+plot.SCGLR">plot.SCGLR</a></code>.</p>
</td></tr>
<tr><td><code id="pairs.SCGLR_+3A_nrow">nrow</code></td>
<td>
<p>number of rows of the grid layout.</p>
</td></tr>
<tr><td><code id="pairs.SCGLR_+3A_ncol">ncol</code></td>
<td>
<p>number of columns of the grid layout.</p>
</td></tr>
<tr><td><code id="pairs.SCGLR_+3A_components">components</code></td>
<td>
<p>vector of integers selecting components to plot (default is all components).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>For pairs application see examples in <code><a href="#topic+plot.SCGLR">plot.SCGLR</a></code>
</p>

<hr>
<h2 id='plot.SCGLR'>SCGLR generic plot</h2><span id='topic+plot.SCGLR'></span>

<h3>Description</h3>

<p>SCGLR generic plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLR'
plot(x, ..., style = getOption("plot.SCGLR"),
  plane = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SCGLR_+3A_x">x</code></td>
<td>
<p>an object from SCGLR class.</p>
</td></tr>
<tr><td><code id="plot.SCGLR_+3A_...">...</code></td>
<td>
<p>optional arguments (see <a href="#topic+customize">customize</a>).</p>
</td></tr>
<tr><td><code id="plot.SCGLR_+3A_style">style</code></td>
<td>
<p>named list of values used to customize the plot (see <a href="#topic+customize">customize</a>)</p>
</td></tr>
<tr><td><code id="plot.SCGLR_+3A_plane">plane</code></td>
<td>
<p>a size-2 vector (or comma separated string) indicating which components are plotted (eg: c(1,2) or &quot;1,2&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SCGLR)

# load sample data
data(genus)

# get variable names from dataset
n &lt;- names(genus)
ny &lt;- n[grep("^gen",n)]    # Y &lt;- names that begins with "gen"
nx &lt;- n[-grep("^gen",n)]   # X &lt;- remaining names

# remove "geology" and "surface" from nx
# as surface is offset and we want to use geology as additional covariate
nx &lt;-nx[!nx%in%c("geology","surface")]

# build multivariate formula
# we also add "lat*lon" as computed covariate
form &lt;- multivariateFormula(ny,c(nx,"I(lat*lon)"),c("geology"))

# define family
fam &lt;- rep("poisson",length(ny))

genus.scglr &lt;- scglr(formula=form,data = genus,family=fam, K=4,
 offset=genus$surface)

summary(genus.scglr)

barplot(genus.scglr)

plot(genus.scglr)

plot(genus.scglr, predictors=TRUE, factor=TRUE)

pairs(genus.scglr)


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.SCGLRTHM'>SCGLRTHM generic plot</h2><span id='topic+plot.SCGLRTHM'></span>

<h3>Description</h3>

<p>SCGLR generic plot for themes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLRTHM'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SCGLRTHM_+3A_x">x</code></td>
<td>
<p>an object from SCGLRTHM class.</p>
</td></tr>
<tr><td><code id="plot.SCGLRTHM_+3A_...">...</code></td>
<td>
<p>see SCGLR plot method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>

<hr>
<h2 id='print.MultivariateFormula'>print a multivariate formula</h2><span id='topic+print.MultivariateFormula'></span>

<h3>Description</h3>

<p>S3 helper function to print a multivariate formula
NB use $ semantic to retrieve metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MultivariateFormula'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.MultivariateFormula_+3A_x">x</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="print.MultivariateFormula_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='print.SCGLR'>Print SCGLR object</h2><span id='topic+print.SCGLR'></span>

<h3>Description</h3>

<p>Prints inertia per component and residual and null deviance for each Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SCGLR_+3A_x">x</code></td>
<td>
<p>object of class 'SCGLR', usually a result of running <code><a href="#topic+scglr">scglr</a></code>.</p>
</td></tr>
<tr><td><code id="print.SCGLR_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='scglr'>Function that fits the scglr model</h2><span id='topic+scglr'></span>

<h3>Description</h3>

<p>Calculates the components to predict all the dependent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scglr(formula, data, family, K = 1, size = NULL, weights = NULL,
  offset = NULL, subset = NULL, na.action = na.omit, crit = list(),
  method = methodSR())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scglr_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>MultivariateFormula</code> (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="scglr_+3A_data">data</code></td>
<td>
<p>a data frame to be modeled.</p>
</td></tr>
<tr><td><code id="scglr_+3A_family">family</code></td>
<td>
<p>a vector of character of the same length as the number of dependent variables:
&quot;bernoulli&quot;, &quot;binomial&quot;, &quot;poisson&quot; or &quot;gaussian&quot; is allowed.</p>
</td></tr>
<tr><td><code id="scglr_+3A_k">K</code></td>
<td>
<p>number of components, default is one.</p>
</td></tr>
<tr><td><code id="scglr_+3A_size">size</code></td>
<td>
<p>describes the number of trials for the binomial dependent variables.
A (number of statistical units * number of binomial dependent variables) matrix is expected.</p>
</td></tr>
<tr><td><code id="scglr_+3A_weights">weights</code></td>
<td>
<p>weights on individuals (not available for now)</p>
</td></tr>
<tr><td><code id="scglr_+3A_offset">offset</code></td>
<td>
<p>used for the poisson dependent variables.
A vector or a matrix of size: number of observations * number of Poisson dependent variables is expected.</p>
</td></tr>
<tr><td><code id="scglr_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="scglr_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain NAs. The default is set to <code>na.omit</code>.</p>
</td></tr>
<tr><td><code id="scglr_+3A_crit">crit</code></td>
<td>
<p>a list of two elements : maxit and tol, describing respectively the maximum number of iterations and
the tolerance convergence criterion for the Fisher scoring algorithm. Default is set to 50 and 10e-6 respectively.</p>
</td></tr>
<tr><td><code id="scglr_+3A_method">method</code></td>
<td>
<p>structural relevance criterion. Object of class &quot;method.SCGLR&quot;
built by  <code><a href="#topic+methodSR">methodSR</a></code> for Structural Relevance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the SCGLR class.
</p>
<p>The function <code><a href="base.html#topic+summary">summary</a></code> (i.e., <code><a href="#topic+summary.SCGLR">summary.SCGLR</a></code>) can be used to obtain or print a summary of the results.
</p>
<p>The generic accessor functions <code><a href="stats.html#topic+coef">coef</a></code> can be used to extract various useful features of the value returned by <code>scglr</code>.
</p>
<p>An object of class &quot;<code>SCGLR</code>&quot; is a list containing following components:
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>matrix of size (number of regressors * number of components), contains the component-loadings,
i.e. the coefficients of the regressors in the linear combination giving each component.</p>
</td></tr>
<tr><td><code>comp</code></td>
<td>
<p>matrix of size (number of statistical units * number of components) having the components as column vectors.</p>
</td></tr>
<tr><td><code>compr</code></td>
<td>
<p>matrix of size (number of statistical units * number of components) having the standardized components as column vectors.</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>list of length number of dependant variables. Each element is a matrix of coefficients, standard errors, z-values and p-values.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>matrix of size (number of regressors + 1 (intercept) * number of dependent variables), contains the coefficients
of the regression on the original regressors X.</p>
</td></tr>
<tr><td><code>lin.pred</code></td>
<td>
<p>data.frame of size (number of statistical units * number of dependent variables), the fitted linear predictor.</p>
</td></tr>
<tr><td><code>xFactors</code></td>
<td>
<p>data.frame containing the nominal regressors.</p>
</td></tr>
<tr><td><code>xNumeric</code></td>
<td>
<p>data.frame containing the quantitative regressors.</p>
</td></tr>
<tr><td><code>inertia</code></td>
<td>
<p>matrix of size (number of components * 2), contains the percentage and cumulative percentage
of the overall regressors' variance, captured by each component.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>vector of length (number of dependent variables), gives the likelihood of the model of each <code class="reqn">y_k</code>'s GLM on the components.</p>
</td></tr>
<tr><td><code>deviance.null</code></td>
<td>
<p>vector of length (number of dependent variables), gives the deviance  of the null model of each <code class="reqn">y_k</code>'s GLM on the components.</p>
</td></tr>
<tr><td><code>deviance.residual</code></td>
<td>
<p>vector of length (number of dependent variables), gives the deviance  of the model of each <code class="reqn">y_k</code>'s GLM on the components.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bry X., Trottier C., Verron T. and Mortier F. (2013) Supervised Component Generalized Linear Regression using a PLS-extension of the Fisher scoring algorithm. <em>Journal of Multivariate Analysis</em>, 119, 47-60.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SCGLR)

# load sample data
data(genus)

# get variable names from dataset
n &lt;- names(genus)
ny &lt;- n[grep("^gen",n)]    # Y &lt;- names that begins with "gen"
nx &lt;- n[-grep("^gen",n)]   # X &lt;- remaining names

# remove "geology" and "surface" from nx
# as surface is offset and we want to use geology as additional covariate
nx &lt;-nx[!nx%in%c("geology","surface")]

# build multivariate formula
# we also add "lat*lon" as computed covariate
form &lt;- multivariateFormula(ny,c(nx,"I(lat*lon)"),A=c("geology"))

# define family
fam &lt;- rep("poisson",length(ny))

genus.scglr &lt;- scglr(formula=form,data = genus,family=fam, K=4,
 offset=genus$surface)

summary(genus.scglr)

## End(Not run)
</code></pre>

<hr>
<h2 id='scglrCrossVal'>Function that fits and selects the number of component by cross-validation.</h2><span id='topic+scglrCrossVal'></span>

<h3>Description</h3>

<p>Function that fits and selects the number of component by cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scglrCrossVal(formula, data, family, K = 1, nfolds = 5,
  type = "mspe", size = NULL, offset = NULL, subset = NULL,
  na.action = na.omit, crit = list(), method = methodSR(),
  mc.cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scglrCrossVal_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;Formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_data">data</code></td>
<td>
<p>the data frame to be modeled.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_family">family</code></td>
<td>
<p>a vector of character of length q specifying the distributions of the responses. Bernoulli, binomial, poisson and gaussian are allowed.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_k">K</code></td>
<td>
<p>number of components, default is one.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds, default is 5.
Although nfolds can be as large as the sample size (leave-one-out CV),
it is not recommended for large datasets.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_type">type</code></td>
<td>
<p>loss function to use for cross-validation.
Currently six options are available depending on whether the responses are of the same distribution family.
If the responses are all bernoulli distributed, then the prediction performance may be measured
through the area under the ROC curve: type = &quot;auc&quot;
In any other case one can choose among the following five options (&quot;likelihood&quot;,&quot;aic&quot;,&quot;aicc&quot;,&quot;bic&quot;,&quot;mspe&quot;).</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_size">size</code></td>
<td>
<p>specifies the number of trials of the binomial variables included in the model.  A (n*qb) matrix is expected
for qb binomial variables.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_offset">offset</code></td>
<td>
<p>used for the poisson dependent variables.
A vector or a matrix of size: number of observations * number of Poisson dependent variables is expected.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain NAs. The default is set to the <code>na.omit</code>.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_crit">crit</code></td>
<td>
<p>a list of two elements : maxit and tol, describing respectively the maximum number of iterations and
the tolerance convergence criterion for the Fisher scoring algorithm. Default is set to 50 and 10e-6 respectively.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_method">method</code></td>
<td>
<p>Regularization criterion type. Object of class &quot;method.SCGLR&quot;
built by <code><a href="#topic+methodSR">methodSR</a></code> for Structural Relevance.</p>
</td></tr>
<tr><td><code id="scglrCrossVal_+3A_mc.cores">mc.cores</code></td>
<td>
<p>max number of cores to use when using parallelization (Not available in windows yet and strongly discouraged if in interactive mode).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the criterion values for each response (rows) and each number of components (columns).
</p>


<h3>References</h3>

<p>Bry X., Trottier C., Verron T. and Mortier F. (2013) Supervised Component Generalized Linear Regression using a PLS-extension of the Fisher scoring algorithm. <em>Journal of Multivariate Analysis</em>, 119, 47-60.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SCGLR)

# load sample data
data(genus)

# get variable names from dataset
n &lt;- names(genus)
ny &lt;- n[grep("^gen",n)]    # Y &lt;- names that begins with "gen"
nx &lt;- n[-grep("^gen",n)]   # X &lt;- remaining names

# remove "geology" and "surface" from nx
# as surface is offset and we want to use geology as additional covariate
nx &lt;-nx[!nx%in%c("geology","surface")]

# build multivariate formula
# we also add "lat*lon" as computed covariate
form &lt;- multivariateFormula(ny,c(nx,"I(lat*lon)"),A=c("geology"))

# define family
fam &lt;- rep("poisson",length(ny))

# cross validation
genus.cv &lt;- scglrCrossVal(formula=form, data=genus, family=fam, K=12,
 offset=genus$surface)

# find best K
mean.crit &lt;- colMeans(log(cv))

#plot(mean.crit, type="l")

## End(Not run)
</code></pre>

<hr>
<h2 id='scglrTheme'>Function that fits the theme model</h2><span id='topic+scglrTheme'></span>

<h3>Description</h3>

<p>Calculates the components to predict all the dependent variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scglrTheme(formula, data, H, family, size = NULL, weights = NULL,
  offset = NULL, subset = NULL, na.action = na.omit, crit = list(),
  method = methodSR(), st = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scglrTheme_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="#topic+multivariateFormula">MultivariateFormula</a></code>&quot; (or one that can be coerced
to that class): a symbolic description of the model to be fitted. The details
of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_data">data</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_h">H</code></td>
<td>
<p>vector of R integer. Number of components to keep for each theme</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_family">family</code></td>
<td>
<p>a vector of character of the same length as the number of dependent variables:
&quot;bernoulli&quot;, &quot;binomial&quot;, &quot;poisson&quot; or &quot;gaussian&quot; is allowed.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_size">size</code></td>
<td>
<p>describes the number of trials for the binomial dependent variables.
A (number of statistical units * number of binomial dependent variables) matrix is expected.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_weights">weights</code></td>
<td>
<p>weights on individuals (not available for now)</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_offset">offset</code></td>
<td>
<p>used for the poisson dependent variables.
A vector or a matrix of size: number of observations * number of Poisson dependent variables is expected.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain NAs. The default is set to <code>na.omit</code>.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_crit">crit</code></td>
<td>
<p>a list of two elements : maxit and tol, describing respectively the maximum number of iterations and
the tolerance convergence criterion for the Fisher scoring algorithm. Default is set to 50 and 10e-6 respectively.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_method">method</code></td>
<td>
<p>structural relevance criterion. Object of class &quot;method.SCGLR&quot;
built by  <code><a href="#topic+methodSR">methodSR</a></code> for Structural Relevance.</p>
</td></tr>
<tr><td><code id="scglrTheme_+3A_st">st</code></td>
<td>
<p>logical (FALSE) theme build and fit order. TRUE means random, FALSE means sequential (T1, ..., Tr)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models for theme are specified symbolically. A model as the form <code>response ~ terms</code> where <code>response</code>
is the numeric response vector and terms is a series of R themes composed of
predictors. Themes are separated by  &quot;|&quot; (pipe) and are composed. ... Y1+Y2+...
~ X11+X12+...+X1_  | X21+X22+... | ...+X1_+...  | A1+A2+... See <code><a href="#topic+multivariateFormula">multivariateFormula</a></code>.
</p>


<h3>Value</h3>

<p>a list of SCGLRTHM class. Each element is a SCGLR object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SCGLR)

# load sample data
data(genus)

# get variable names from dataset
n &lt;- names(genus)
n &lt;-n[!n%in%c("geology","surface","lon","lat","forest","altitude")]
ny &lt;- n[grep("^gen",n)]    # Y &lt;- names that begins with "gen"
nx1 &lt;- n[grep("^evi",n)]   # X &lt;- remaining names
nx2 &lt;- n[-c(grep("^evi",n),grep("^gen",n))]


form &lt;- multivariateFormula(ny,nx1,nx2,A=c("geology"))
fam &lt;- rep("poisson",length(ny))
testthm &lt;-scglrTheme(form,data=genus,H=c(2,2),family=fam,offset = genus$surface)
plot(testthm)

## End(Not run)
</code></pre>

<hr>
<h2 id='scglrThemeBackward'>Theme Backward selection</h2><span id='topic+scglrThemeBackward'></span>

<h3>Description</h3>

<p>Perform component selection by cross-validation backward approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scglrThemeBackward(formula, data, H, family, size = NULL,
  weights = NULL, offset = NULL, na.action = na.omit,
  crit = list(), method = methodSR(), kfolds = 10, type = "mspe",
  st = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scglrThemeBackward_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;<code><a href="Formula.html#topic+Formula">Formula</a></code>&quot; (or one that can be coerced
to that class): a symbolic description of the model to be fitted. The details
of model specification are given under Details.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_data">data</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_h">H</code></td>
<td>
<p>vector of R integer. Number of components to keep for each theme</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_family">family</code></td>
<td>
<p>a vector of character of the same length as the number of dependent variables:
&quot;bernoulli&quot;, &quot;binomial&quot;, &quot;poisson&quot; or &quot;gaussian&quot; is allowed.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_size">size</code></td>
<td>
<p>describes the number of trials for the binomial dependent variables.
A (number of statistical units * number of binomial dependent variables) matrix is expected.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_weights">weights</code></td>
<td>
<p>weights on individuals (not available for now)</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_offset">offset</code></td>
<td>
<p>used for the poisson dependent variables.
A vector or a matrix of size: number of observations * number of Poisson dependent variables is expected.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data contain NAs. The default is set to <code>na.omit</code>.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_crit">crit</code></td>
<td>
<p>a list of two elements : maxit and tol, describing respectively the maximum number of iterations and
the tolerance convergence criterion for the Fisher scoring algorithm. Default is set to 50 and 10e-6 respectively.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_method">method</code></td>
<td>
<p>structural relevance criterion. Object of class &quot;method.SCGLR&quot;
built by  <code><a href="#topic+methodSR">methodSR</a></code> for Structural Relevance.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_kfolds">kfolds</code></td>
<td>
<p>number of folds - default is 10. Although nfolds can be as large as the sample size (leave-one-out CV),
it is not recommended for large datasets. Smallest value allowable is nfolds=2
Models for theme are specified symbolically. A model as the form <code>response ~ terms</code> where <code>response</code>
is the numeric response vector and terms is a series of R themes composed of
predictors. Themes are separated by  &quot;|&quot; (pipe) and are composed.... Y1+Y2+...
~ X11+X12+...+X1_  | X21+X22+... | ...+X1_+...  | A1+A2+... See <code><a href="#topic+multivariateFormula">multivariateFormula</a></code>.</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_type">type</code></td>
<td>
<p>loss function to use for cross-validation.
Currently six options are available depending on whether the responses are of the same distribution family.
If the responses are all bernoulli distributed, then the prediction performance may be measured
through the area under the ROC curve: type = &quot;auc&quot;
In any other case one can choose among the following five options (&quot;likelihood&quot;,&quot;aic&quot;,&quot;aicc&quot;,&quot;bic&quot;,&quot;mspe&quot;).</p>
</td></tr>
<tr><td><code id="scglrThemeBackward_+3A_st">st</code></td>
<td>
<p>logical (FALSE) theme build and fit order. TRUE means random, FALSE means sequential (T1, ..., Tr)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the path followed along the selection process, the associated mean square predictor error and the best configuration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SCGLR)

# load sample data
data(genus)

# get variable names from dataset
n &lt;- names(genus)
n &lt;-n[!n%in%c("geology","surface","lon","lat","forest","altitude")]
ny &lt;- n[grep("^gen",n)]    # Y &lt;- names that begins with "gen"
nx1 &lt;- n[grep("^evi",n)]   # X &lt;- remaining names
nx2 &lt;- n[-c(grep("^evi",n),grep("^gen",n))]


form &lt;- multivariateFormula(ny,nx1,nx2,A=c("geology"))
fam &lt;- rep("poisson",length(ny))
testcv &lt;- scglrThemeBackward(form,data=genus,H=c(2,2),family=fam,offset = genus$surface,kfolds=2)
Cross-validation pathway
testcv$H_path
Plot criterion
plot(testcv$cv_path)
Best combination
testcv$H_best

## End(Not run)
</code></pre>

<hr>
<h2 id='screeplot.SCGLR'>Screeplot of percent of overall X variance captured by component</h2><span id='topic+screeplot.SCGLR'></span>

<h3>Description</h3>

<p>Screeplot of percent of overall X variance captured by component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLR'
screeplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screeplot.SCGLR_+3A_x">x</code></td>
<td>
<p>object of class 'SCGLR', usually a result of running <code><a href="#topic+scglr">scglr</a></code>.</p>
</td></tr>
<tr><td><code id="screeplot.SCGLR_+3A_...">...</code></td>
<td>
<p>optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class ggplot.
</p>


<h3>See Also</h3>

<p>For screeplot application see examples in <code><a href="#topic+plot.SCGLR">plot.SCGLR</a></code>.
</p>

<hr>
<h2 id='screeplot.SCGLRTHM'>Screeplot of percent of overall X variance captured by component</h2><span id='topic+screeplot.SCGLRTHM'></span>

<h3>Description</h3>

<p>Screeplot of percent of overall X variance captured by component by theme
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLRTHM'
screeplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screeplot.SCGLRTHM_+3A_x">x</code></td>
<td>
<p>object of class 'SCGLRTHM', usually a result of running <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
<tr><td><code id="screeplot.SCGLRTHM_+3A_...">...</code></td>
<td>
<p>optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class ggplot.
</p>

<hr>
<h2 id='summary.SCGLR'>Summarizing SCGLR fits</h2><span id='topic+summary.SCGLR'></span><span id='topic+print.summary.SCGLR'></span>

<h3>Description</h3>

<p>Summary method for class &quot;SCGLR&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCGLR'
summary(object, ...)

## S3 method for class 'summary.SCGLR'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SCGLR_+3A_object">object</code></td>
<td>
<p>an object of class &quot;SCGLR&quot;, usually a result of a call to <code><a href="#topic+scglr">scglr</a></code>.</p>
</td></tr>
<tr><td><code id="summary.SCGLR_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="summary.SCGLR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;summary.SCGLR&quot;, usually a result of a call to summary.SCGLR.</p>
</td></tr>
<tr><td><code id="summary.SCGLR_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to use when printing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;summary.SCGLR&quot;.
</p>
<table>
<tr><td><code>inertia</code></td>
<td>
<p>inertia per component.</p>
</td></tr>
<tr><td><code>deviance.null</code></td>
<td>
<p>null deviance for each <code class="reqn">Y_k</code>.</p>
</td></tr>
<tr><td><code>deviance.residual</code></td>
<td>
<p>residual deviance for each <code class="reqn">Y_k</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>squared correlations with numerical covariates.</p>
</td></tr>
<tr><td><code>rho.pred</code></td>
<td>
<p>squared correlations with linear predictors.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>contains the coefficients of the regression on the components.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
