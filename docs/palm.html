<!DOCTYPE html><html><head><title>Help for package palm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {palm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#palm'><p>palm: A package to fit point process models via the Palm</p>
likelihood</a></li>
<li><a href='#boot.palm'><p>Bootstrapping for fitted models</p></a></li>
<li><a href='#coef.palm'><p>Extract parameter estimates.</p></a></li>
<li><a href='#confint.palm'><p>Extracts Neyman-Scott point process parameter confidence intervals.</p></a></li>
<li><a href='#example.1D'><p>1-dimensional example data</p></a></li>
<li><a href='#example.2D'><p>2-dimensional example data</p></a></li>
<li><a href='#example.twocamera'><p>Two-camera example data.</p></a></li>
<li><a href='#fit.ns'><p>Fitting a Neyman-Scott point process model</p></a></li>
<li><a href='#fit.twocamera'><p>Estimation of animal density from two-camera surveys.</p></a></li>
<li><a href='#fit.void'><p>Fitting a model to a void point process</p></a></li>
<li><a href='#plot.palm'><p>Plotting an estimated Palm intensity function.</p></a></li>
<li><a href='#porpoise.data'><p>Two-camera porpoise data.</p></a></li>
<li><a href='#sim.ns'><p>Simulating points from a Neyman-Scott point process</p></a></li>
<li><a href='#sim.twocamera'><p>Simulating data from two-camera aerial surveys.</p></a></li>
<li><a href='#sim.void'><p>Simulating points from a void point process.</p></a></li>
<li><a href='#summary.palm'><p>Summarising palm model fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Point Process Models via the Palm Likelihood</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Stevenson &lt;ben.stevenson@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Stevenson &lt;ben.stevenson@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), Rcpp (&ge; 0.11.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>gsl, methods, minqa, mvtnorm, R6</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to fit point process models using the Palm likelihood. First proposed by Tanaka, Ogata, and Stoyan (2008) &lt;<a href="https://doi.org/10.1002%2Fbimj.200610339">doi:10.1002/bimj.200610339</a>&gt;, maximisation of the Palm likelihood can provide computationally efficient parameter estimation for point process models in situations where the full likelihood is intractable. This package is chiefly focused on Neyman-Scott point processes, but can also fit the void processes proposed by Jones-Todd et al. (2019) &lt;<a href="https://doi.org/10.1002%2Fsim.8046">doi:10.1002/sim.8046</a>&gt;. The development of this package was motivated by the analysis of capture-recapture surveys on which individuals cannot be identified&mdash;the data from which can conceptually be seen as a clustered point process (Stevenson, Borchers, and Fewster, 2019 &lt;<a href="https://doi.org/10.1111%2Fbiom.12983">doi:10.1111/biom.12983</a>&gt;). As such, some of the functions in this package are specifically for the estimation of cetacean density from two-camera aerial surveys.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/b-steve/palm">https://github.com/b-steve/palm</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-22 04:00:03 UTC; ben</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-22 05:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='palm'>palm: A package to fit point process models via the Palm
likelihood</h2><span id='topic+palm'></span><span id='topic+palm-package'></span>

<h3>Description</h3>

<p>First proposed by Tanaka, Ogata, and Stoyan (2008), maximisation of
the Palm likelihood can provide computationally efficient parameter
estimation for point process models in situations where the full
likelihood is intractable. This package contains functions to fit a
variety of point process models, but is chiefly concerned with
Neyman-Scott point processes (NSPPs).
</p>


<h3>Details</h3>

<p>The development of this package was motivated by the analysis of
capture-recapture surveys on which individuals cannot be
identified&mdash;the data from which can conceptually be seen as a NSPP
(Fewster, Stevenson, and Borchers, 2016). As such, some of the
functions in this package are specifically for the estimation of
cetacean density from two-camera aerial surveys; see Stevenson,
Borchers, and Fewster (2019).
</p>
<p>This package can also fit void processes, which, along with NSPPs,
have been fitted to patterns of colon cancer and stroma cell
locations (Jones-Todd et al., 2019).
</p>
<p>The main functions of this package are summarised below.
</p>


<h3>Model fitting</h3>


<ul>
<li><p> The <a href="#topic+fit.ns">fit.ns</a> function fits NSPPs.
</p>
</li>
<li><p> The <a href="#topic+fit.twocamera">fit.twocamera</a> function estimates animal density
from two-camera aerial surveys. This model is a NSPP and can
be fitted using <a href="#topic+fit.ns">fit.ns</a>, but it is more straightforward
to use <a href="#topic+fit.twocamera">fit.twocamera</a>.
</p>
</li>
<li><p> The <a href="#topic+fit.void">fit.void</a> function fits void point processes.
</p>
</li></ul>



<h3>Variance estimation</h3>

<p>Variance estimation is achieved by parametric bootstrap. The
<a href="#topic+boot.palm">boot.palm</a> function carries out this procedure from an object
generated by one of the fitting functions, above. Confidence
intervals and standard errors can be calculated from an object
returned by <a href="#topic+boot.palm">boot.palm</a> using <a href="#topic+confint.palm">confint.palm</a> and
<a href="#topic+coef.palm">coef.palm</a>, respectively.
</p>


<h3>Data simulation</h3>


<ul>
<li><p> The <a href="#topic+sim.ns">sim.ns</a> function simulates data from NSPPs.
</p>
</li>
<li><p> The <a href="#topic+sim.twocamera">sim.twocamera</a> function simulates detection data
from two-camera aerial surveys.
</p>
</li>
<li><p> The <a href="#topic+sim.void">sim.void</a> function simulates data from void point
processes.
</p>
</li></ul>



<h3>References</h3>

<p>Fewster, R. M., Stevenson, B. C., and Borchers,
D. L. (2016) Trace-contrast methods for capture-recapture
without capture histories. <em>Statistical Science</em>,
<strong>31</strong>: 245&ndash;258.
</p>
<p>Jones-Todd, C. M., Caie, P., Illian, J. B., Stevenson,
B. C., Savage, A., Harrison, D. J., and Bown,
J. L. (2019). Identifying prognostic structural features in
tissue sections of colon cancer patients using point pattern
analysis. <em>Statistics in Medicine</em>, <strong>38</strong>:
1421&ndash;1441.
</p>
<p>Stevenson, B. C., Borchers, D. L., and Fewster,
R. M. (2019) Cluster capture-recapture to account for
identification uncertainty on aerial surveys of animal
populations. <em>Biometrics</em>, <strong>75</strong>: 326&ndash;336.
</p>
<p>Tanaka, U., Ogata, Y., and Stoyan, D. (2008) Parameter
estimation and model selection for Neyman-Scott point
processes. <em>Biometrical Journal</em>, <strong>50</strong>: 43&ndash;57.
</p>

<hr>
<h2 id='boot.palm'>Bootstrapping for fitted models</h2><span id='topic+boot.palm'></span>

<h3>Description</h3>

<p>Carries out a parametric bootstrap procedure for models fitted
using the <code>palm</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.palm(fit, N, prog = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.palm_+3A_fit">fit</code></td>
<td>
<p>A fitted object.</p>
</td></tr>
<tr><td><code id="boot.palm_+3A_n">N</code></td>
<td>
<p>The number of bootstrap resamples.</p>
</td></tr>
<tr><td><code id="boot.palm_+3A_prog">prog</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a progress bar is printed to
the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original model object containing additional information
from the bootstrap procedure. These are accessed by functions
such as <a href="#topic+summary.palm">summary.palm</a> and <a href="#topic+confint.palm">confint.palm</a>. The
bootstrap parameter estimates can be found in the <code>boots</code>
component of the returned object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model.
fit &lt;- fit.ns(example.2D, lims = rbind(c(0, 1), c(0, 1)), R = 0.5)
## Carry out bootstrap.
fit &lt;- boot.palm(fit, N = 100)
## Inspect standard errors and confidence intervals.
summary(fit)
confint(fit)
## Estimates are very imprecise---these data were only used as
## they can be fitted and bootstrapped quickly for example purposes.

</code></pre>

<hr>
<h2 id='coef.palm'>Extract parameter estimates.</h2><span id='topic+coef.palm'></span><span id='topic+coef.palm_twocamerachild'></span>

<h3>Description</h3>

<p>Extracts estimated parameters from an object returned by the
fitting functions in this package, such as <a href="#topic+fit.ns">fit.ns</a>,
<a href="#topic+fit.void">fit.void</a>, and <a href="#topic+fit.twocamera">fit.twocamera</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'palm'
coef(object, se = FALSE, ...)

## S3 method for class 'palm_twocamerachild'
coef(object, se = FALSE, report.2D = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.palm_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="coef.palm_+3A_se">se</code></td>
<td>
<p>Logical, if <code>TRUE</code> standard errors are presented
(if available) instead of parameter estimates.</p>
</td></tr>
<tr><td><code id="coef.palm_+3A_...">...</code></td>
<td>
<p>Other parameters (for S3 generic compatibility).</p>
</td></tr>
<tr><td><code id="coef.palm_+3A_report.2d">report.2D</code></td>
<td>
<p>Logical, for two-camera model fits only. If
<code>TRUE</code>, two-dimensional animal density is reported.</p>
</td></tr>
</table>

<hr>
<h2 id='confint.palm'>Extracts Neyman-Scott point process parameter confidence intervals.</h2><span id='topic+confint.palm'></span>

<h3>Description</h3>

<p>Extracts confidence intervals for estimated and derived parameters
from a model fitted using <a href="#topic+fit.ns">fit.ns</a>, <a href="#topic+fit.void">fit.void</a>, or
<a href="#topic+fit.twocamera">fit.twocamera</a>, then bootstrapped using <a href="#topic+boot.palm">boot.palm</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'palm'
confint(object, parm = NULL, level = 0.95, method = "percentile", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.palm_+3A_object">object</code></td>
<td>
<p>A fitted model returned by <a href="#topic+fit.ns">fit.ns</a>,
bootstrapped using boot.</p>
</td></tr>
<tr><td><code id="confint.palm_+3A_parm">parm</code></td>
<td>
<p>A vector of parameter names, specifying which
parameters are to be given confidence intervals. Defaults to
all parameters.</p>
</td></tr>
<tr><td><code id="confint.palm_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="confint.palm_+3A_method">method</code></td>
<td>
<p>A character string specifying the method used to
calculate confidence intervals. Choices are &quot;normal&quot;, for a
normal approximation, and &quot;percentile&quot;, for the percentile
method.</p>
</td></tr>
<tr><td><code id="confint.palm_+3A_...">...</code></td>
<td>
<p>Other parameters (for S3 generic compatibility).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bootstrap parameter estimates can be found in the <code>boots</code>
component of the model object, so alternative confidence interval
methods can be calculated by hand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fitting model.
fit &lt;- fit.ns(example.2D, lims = rbind(c(0, 1), c(0, 1)), R = 0.5)
## Carrying out bootstrap.
fit &lt;- boot.palm(fit, N = 100)
## Calculating 95% confidence intervals.
confint(fit)
## Estimates are very imprecise---these data were only used as
## they can be fitted and bootstrapped quickly for example purposes.

</code></pre>

<hr>
<h2 id='example.1D'>1-dimensional example data</h2><span id='topic+example.1D'></span>

<h3>Description</h3>

<p>Simulated data from a Neyman-Scott point process, with children
points generated in the interval [0, 1]. The number of children
spawned by each parent is from a Binomial(4, 0.5) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.1D
</code></pre>


<h3>Format</h3>

<p>A matrix.
</p>

<hr>
<h2 id='example.2D'>2-dimensional example data</h2><span id='topic+example.2D'></span>

<h3>Description</h3>

<p>Simulated data from a Neyman-Scott point process, with children
points generated on the unit square. The number of children spawned
by each parent is from a Binomial(2, 0.5) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.2D
</code></pre>


<h3>Format</h3>

<p>A matrix.
</p>

<hr>
<h2 id='example.twocamera'>Two-camera example data.</h2><span id='topic+example.twocamera'></span>

<h3>Description</h3>

<p>Simulated data from a two-camera aerial survey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.twocamera
</code></pre>


<h3>Format</h3>

<p>A list.
</p>

<hr>
<h2 id='fit.ns'>Fitting a Neyman-Scott point process model</h2><span id='topic+fit.ns'></span>

<h3>Description</h3>

<p>Estimates parameters for a Neyman-Scott point process by maximising
the Palm likelihood. This approach was first proposed by Tanaka et
al. (2008) for two-dimensional Thomas processes. Further
generalisations were made by Stevenson, Borchers, and Fewster
(2019) and Jones-Todd et al. (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.ns(
  points,
  lims,
  R,
  disp = "gaussian",
  child.dist = "pois",
  child.info = NULL,
  sibling.list = NULL,
  edge.correction = "pbc",
  start = NULL,
  bounds = NULL,
  use.bobyqa = FALSE,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.ns_+3A_points">points</code></td>
<td>
<p>A matrix or list of matrices containing locations of
observed points, where each row corresponds to a point and each
column corresponds to a dimension. If a list, then the patterns
are assumed to be independent and a single process is fitted to
all.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_lims">lims</code></td>
<td>
<p>A matrix or list of matrices with two columns,
corresponding to the upper and lower limits of each dimension,
respectively. If a list, then each matrix provides the limits
for the corresponding pattern in <code>points</code>.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_r">R</code></td>
<td>
<p>Truncation distance for the difference process.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_disp">disp</code></td>
<td>
<p>A character string indicating the distribution of
children around their parents. Use <code>"gaussian"</code> for
multivariate normal dispersion with standard deviation
<code>sigma</code>, or <code>"uniform"</code> for uniform dispersion within
distance <code>tau</code> of the parent.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_child.dist">child.dist</code></td>
<td>
<p>The distribution of the number of children
generated by a randomly selected parent. For a Poisson
distribution, use <code>"pois"</code>; for a binomial distribution,
use <code>"binomx"</code>, where <code>"x"</code> is replaced by the fixed
value of the number of independent trials (e.g.,
<code>"binom5"</code> for a Binomial(5, p) distribution, and
<code>"binom50"</code> for a Binomial(50, p) distribution); and
<code>"twocamera"</code> for a child distribution appropriate for a
two-camera aerial survey.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_child.info">child.info</code></td>
<td>
<p>A list of further information that is required
about the distribution for the number of children generated by
parents. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_sibling.list">sibling.list</code></td>
<td>
<p>An optional list that comprises (i) a component
named <code>sibling.mat</code>, containing a matrix such that the jth
entry in the ith row is <code>TRUE</code> if the ith and jth points
are known siblings, <code>FALSE</code> if they are known nonsiblings,
and <code>NA</code> if their sibling status is not known; (ii) alpha,
providing the probability that a sibling is successfully
identified as a sibling; and (iii) beta, providing the
probability that a nonsibling is successfully identified as a
nonsibling. For multi-pattern fitting, this object must be a
list of such lists, one for each pattern.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_edge.correction">edge.correction</code></td>
<td>
<p>The method used for the correction of edge
effects. Either <code>"pbc"</code> for periodic boundary conditions,
or <code>"buffer"</code> for a buffer-zone correction.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_start">start</code></td>
<td>
<p>A named vector of starting values for the model
parameters.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_bounds">bounds</code></td>
<td>
<p>A list with named components. Each component should
be a vector of length two, giving the upper and lower bounds
for the named parameter.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_use.bobyqa">use.bobyqa</code></td>
<td>
<p>Logical; if <code>TRUE</code> the <a href="minqa.html#topic+bobyqa">bobyqa</a> function
is used for optimisation. Otherwise the <a href="stats.html#topic+nlminb">nlminb</a> function
is used. Note that <a href="minqa.html#topic+bobyqa">bobyqa</a> seems to be less stable than
<a href="stats.html#topic+nlminb">nlminb</a>, but does not require calculation of the Palm
likelihood's partial derivatives.</p>
</td></tr>
<tr><td><code id="fit.ns_+3A_trace">trace</code></td>
<td>
<p>Logical; if <code>TRUE</code>, parameter values are printed
to the screen for each iteration of the optimisation procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>D</code> is the density of parent points, which is
always estimated. Possible additional parameters are
</p>

<ul>
<li> <p><code>lambda</code>, the expected number of children generated per
parent (when <code>child.dist = "pois"</code>).
</p>
</li>
<li> <p><code>p</code>, the proportion of the <code>x</code> possible children
that are generated (when <code>child.dist = "binomx"</code>).
</p>
</li>
<li> <p><code>kappa</code>, the average length of the surface phase of a
diving cetacean (when <code>child.dist = "twocamera"</code>; see
Stevenson, Borchers, and Fewster, 2019).
</p>
</li>
<li> <p><code>sigma</code>, the standard deviation of dispersion along
each dimension (when <code>disp</code> = &quot;gaussian&quot;).
</p>
</li>
<li> <p><code>tau</code>, the maximum distance a child can be from its
parent (when <code>disp</code> = &quot;uniform&quot;).
</p>
</li></ul>

<p>The <code>"child.info"</code> argument is required when <code>child.dist</code>
is set to <code>"twocamera"</code>. It must be a list that comprises (i) a
component named <code>w</code>, providing the halfwidth of the detection
zone; (ii) a component named <code>b</code>, providing the halfwidth of
the survey area; (iii) a component named <code>l</code>, providing the
time lag between cameras (in seconds); and (iv) a component named
<code>tau</code>, providing the mean dive-cycle duration. See Stevenson,
Borchers, and Fewster (2019) for details.
</p>


<h3>Value</h3>

<p>An R6 reference class object.
</p>


<h3>References</h3>

<p>Jones-Todd, C. M., Caie, P., Illian, J. B., Stevenson,
B. C., Savage, A., Harrison, D. J., and Bown, J. L. (in
press). Identifying prognostic structural features in tissue
sections of colon cancer patients using point pattern
analysis. <em>Statistics in Medicine</em>, <strong>38</strong>:
1421&ndash;1441.
</p>
<p>Stevenson, B. C., Borchers, D. L., and Fewster,
R. M. (2019) Cluster capture-recapture to account for
identification uncertainty on aerial surveys of animal
populations. <em>Biometrics</em>, <strong>75</strong>: 326&ndash;336.
</p>
<p>Tanaka, U., Ogata, Y., and Stoyan, D. (2008) Parameter
estimation and model selection for Neyman-Scott point
processes. <em>Biometrical Journal</em>, <strong>50</strong>: 43&ndash;57.
</p>


<h3>See Also</h3>

<p>Use <a href="#topic+coef.palm">coef.palm</a> to extract estimated parameters, and
<a href="#topic+plot.palm">plot.palm</a> to plot the estimated Palm intensity
function. Use <a href="#topic+boot.palm">boot.palm</a> to run a parametric bootstrap,
allowing calculation of standard errors and confidence
intervals.
</p>
<p>See <a href="#topic+sim.ns">sim.ns</a> to simulate from a Neyman-Scott point
process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fitting model to example data.
fit &lt;- fit.ns(example.2D, lims = rbind(c(0, 1), c(0, 1)), R = 0.5)
## Printing estimates.
coef(fit)
## Plotting the estimated Palm intensity.
plot(fit)
## Not run: 
## Simulating data and fitting additional models.
set.seed(1234)
## One-dimensional Thomas process.
data.thomas &lt;- sim.ns(c(D = 10, lambda = 5, sigma = 0.025), lims = rbind(c(0, 1)))
## Fitting a model to these data.
fit.thomas &lt;- fit.ns(data.thomas$points, lims = rbind(c(0, 1)), R = 0.5)
## Three-dimensional Matern process.
data.matern &lt;- sim.ns(c(D = 10, lambda = 10, tau = 0.1), disp = "uniform",
                      lims = rbind(c(0, 1), c(0, 2), c(0, 3)))
## Fitting a model to these data.
fit.matern &lt;- fit.ns(data.matern$points, lims = rbind(c(0, 1), c(0, 2), c(0, 3)),
                     R = 0.5, disp = "uniform")

## End(Not run)

</code></pre>

<hr>
<h2 id='fit.twocamera'>Estimation of animal density from two-camera surveys.</h2><span id='topic+fit.twocamera'></span>

<h3>Description</h3>

<p>Estimates animal density (amongst other parameters) from two-camera
aerial surveys. This conceptualises sighting locations as a
Neyman-Scott point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.twocamera(
  points,
  cameras = NULL,
  d,
  w,
  b,
  l,
  tau,
  R,
  edge.correction = "pbc",
  start = NULL,
  bounds = NULL,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.twocamera_+3A_points">points</code></td>
<td>
<p>A vector (or single-column matrix) containing the
distance along the transect that each detection was made.</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_cameras">cameras</code></td>
<td>
<p>An optional vector containing the camera ID (either
<code>1</code> or <code>2</code>) that made the corresponding detection in
<code>points</code>.</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_d">d</code></td>
<td>
<p>The length of the transect flown (in km).</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_w">w</code></td>
<td>
<p>The distance from the transect to which detection of
individuals on the surface is certain. This is equivalent to
the half-width of the detection zone.</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_b">b</code></td>
<td>
<p>The distance from the transect to the edge of the area of
interest. Conceptually, the distance between the transect and
the furthest distance a whale could be on the passing of the
first camera and plausibly move into the detection zone by the
passing of the second camera.</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_l">l</code></td>
<td>
<p>The lag between cameras (in seconds).</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_tau">tau</code></td>
<td>
<p>Mean dive-cycle duration (in seconds).</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_r">R</code></td>
<td>
<p>Truncation distance (see <a href="#topic+fit.ns">fit.ns</a>).</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_edge.correction">edge.correction</code></td>
<td>
<p>The method used for the correction of edge
effects. Either <code>"pbc"</code> for periodic boundary conditions,
or <code>"buffer"</code> for a buffer-zone correction.</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_start">start</code></td>
<td>
<p>A named vector of starting values for the model
parameters.</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_bounds">bounds</code></td>
<td>
<p>A list with named components. Each component should
be a vector of length two, giving the upper and lower bounds
for the named parameter.</p>
</td></tr>
<tr><td><code id="fit.twocamera_+3A_trace">trace</code></td>
<td>
<p>Logical; if <code>TRUE</code>, parameter values are printed
to the screen for each iteration of the optimisation procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is simply a wrapper for <code>fit.ns</code>, and
facilitates the fitting of the model proposed by Stevenson,
Borchers, and Fewster (2019). This function presents the
parameter <code>D.2D</code> (two-dimensional cetacean density in
cetaceans per square km) rather than <code>D</code> for enhanced
interpretability.
</p>
<p>For further details on the cluster capture-recapture estimation
approach, see Fewster, Stevenson and Borchers (2016).
</p>


<h3>Value</h3>

<p>An R6 reference class object.
</p>


<h3>References</h3>

<p>Fewster, R. M., Stevenson, B. C., and Borchers,
D. L. (2016) Trace-contrast methods for capture-recapture
without capture histories. <em>Statistical Science</em>,
<strong>31</strong>: 245&ndash;258.
</p>
<p>Stevenson, B. C., Borchers, D. L., and Fewster,
R. M. (2019) Cluster capture-recapture to account for
identification uncertainty on aerial surveys of animal
populations. <em>Biometrics</em>, <strong>75</strong>: 326&ndash;336.
</p>


<h3>See Also</h3>

<p>Use <a href="#topic+coef.palm">coef.palm</a> to extract estimated parameters, and
<a href="#topic+plot.palm">plot.palm</a> to plot the estimated Palm intensity
function. Use <a href="#topic+boot.palm">boot.palm</a> to run a parametric bootstrap,
allowing calculation of standard errors and confidence
intervals.
</p>
<p>See <a href="#topic+sim.twocamera">sim.twocamera</a> to simulate sightings from a
two-camera aerial survey.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Fitting model.
fit &lt;- fit.twocamera(points = example.twocamera$points, cameras = example.twocamera$cameras,
                     d = 500, w = 0.175, b = 0.5, l = 20, tau = 110, R = 1)
## Printing estimates.
coef(fit)
## Plotting the estimated Palm intensity.
plot(fit)

</code></pre>

<hr>
<h2 id='fit.void'>Fitting a model to a void point process</h2><span id='topic+fit.void'></span>

<h3>Description</h3>

<p>Estimates parameters for a void point process by maximising the
Palm likelihood. This approach was first proposed by Tanaka et
al. (2008) for two-dimensional Thomas processes. Generalisation to
d-dimensional void processes was made by Jones-Todd et al. (in
press).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.void(
  points,
  lims,
  R,
  edge.correction = "pbc",
  start = NULL,
  bounds = NULL,
  use.bobyqa = FALSE,
  trace = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.void_+3A_points">points</code></td>
<td>
<p>A matrix or list of matrices containing locations of
observed points, where each row corresponds to a point and each
column corresponds to a dimension. If a list, then the patterns
are assumed to be independent and a single process is fitted to
all.</p>
</td></tr>
<tr><td><code id="fit.void_+3A_lims">lims</code></td>
<td>
<p>A matrix or list of matrices with two columns,
corresponding to the upper and lower limits of each dimension,
respectively. If a list, then each matrix provides the limits
for the corresponding pattern in <code>points</code>.</p>
</td></tr>
<tr><td><code id="fit.void_+3A_r">R</code></td>
<td>
<p>Truncation distance for the difference process.</p>
</td></tr>
<tr><td><code id="fit.void_+3A_edge.correction">edge.correction</code></td>
<td>
<p>The method used for the correction of edge
effects. Either <code>"pbc"</code> for periodic boundary conditions,
or <code>"buffer"</code> for a buffer-zone correction.</p>
</td></tr>
<tr><td><code id="fit.void_+3A_start">start</code></td>
<td>
<p>A named vector of starting values for the model
parameters.</p>
</td></tr>
<tr><td><code id="fit.void_+3A_bounds">bounds</code></td>
<td>
<p>A list with named components. Each component should
be a vector of length two, giving the upper and lower bounds
for the named parameter.</p>
</td></tr>
<tr><td><code id="fit.void_+3A_use.bobyqa">use.bobyqa</code></td>
<td>
<p>Logical; if <code>TRUE</code> the <a href="minqa.html#topic+bobyqa">bobyqa</a> function
is used for optimisation. Otherwise the <a href="stats.html#topic+nlminb">nlminb</a> function
is used. Note that <a href="minqa.html#topic+bobyqa">bobyqa</a> seems to be less stable than
<a href="stats.html#topic+nlminb">nlminb</a>, but does not require calculation of the Palm
likelihood's partial derivatives.</p>
</td></tr>
<tr><td><code id="fit.void_+3A_trace">trace</code></td>
<td>
<p>Logical; if <code>TRUE</code>, parameter values are printed
to the screen for each iteration of the optimisation procedure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters to estimate are as follows: </p>
 <ul>
<li> <p><code>Dc</code>,
the baseline density of points prior to the deletion process.
</p>
</li>
<li> <p><code>Dp</code>, the density of unobserved parents that cause voids.
</p>
</li>
<li> <p><code>tau</code>, the radius of the deletion process centred at each parent.
</p>
</li></ul>



<h3>Value</h3>

<p>An R6 reference class object.
</p>


<h3>References</h3>

<p>Jones-Todd, C. M., Caie, P., Illian, J. B., Stevenson,
B. C., Savage, A., Harrison, D. J., and Bown, J. L. (in
press). Identifying prognostic structural features in tissue
sections of colon cancer patients using point pattern
analysis. <em>Statistics in Medicine</em>, <strong>38</strong>:
1421&ndash;1441.
</p>
<p>Tanaka, U., Ogata, Y., and Stoyan, D. (2008) Parameter
estimation and model selection for Neyman-Scott point
processes. <em>Biometrical Journal</em>, <strong>50</strong>: 43&ndash;57.
</p>


<h3>See Also</h3>

<p>Use <a href="#topic+coef.palm">coef.palm</a> to extract estimated parameters, and
<a href="#topic+plot.palm">plot.palm</a> to plot the estimated Palm intensity
function. Use <a href="#topic+boot.palm">boot.palm</a> to run a parametric bootstrap,
allowing calculation of standard errors and confidence
intervals.
</p>
<p>See <a href="#topic+sim.void">sim.void</a> to simulate from a void process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(1234)
## Simulating a two-dimensional void process.
void.data &lt;- sim.void(c(Dc = 1000, Dp = 10, tau = 0.05), rbind(c(0, 1), c(0, 1)))
## Fitting model.
fit &lt;- fit.void(void.data$points, rbind(c(0, 1), c(0, 1)), R = 0.5)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.palm'>Plotting an estimated Palm intensity function.</h2><span id='topic+plot.palm'></span>

<h3>Description</h3>

<p>Plots a fitted Palm intensity function from an object returned by
<a href="#topic+fit.ns">fit.ns</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'palm'
plot(x, xlim = NULL, ylim = NULL, show.empirical = TRUE, breaks = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.palm_+3A_x">x</code></td>
<td>
<p>A fitted model from <a href="#topic+fit.ns">fit.ns</a>.</p>
</td></tr>
<tr><td><code id="plot.palm_+3A_xlim">xlim</code></td>
<td>
<p>Numeric vector giving the x-coordinate range.</p>
</td></tr>
<tr><td><code id="plot.palm_+3A_ylim">ylim</code></td>
<td>
<p>Numeric vector giving the y-coordinate range.</p>
</td></tr>
<tr><td><code id="plot.palm_+3A_show.empirical">show.empirical</code></td>
<td>
<p>Logical, if <code>TRUE</code> the empirical Palm
intensity is also plotted.</p>
</td></tr>
<tr><td><code id="plot.palm_+3A_breaks">breaks</code></td>
<td>
<p>The number of breakpoints between cells for the
empirical Palm intensity.</p>
</td></tr>
<tr><td><code id="plot.palm_+3A_...">...</code></td>
<td>
<p>Other parameters (for S3 generic compatibility).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Fit model.
fit &lt;- fit.ns(example.2D, lims = rbind(c(0, 1), c(0, 1)), R = 0.5)
## Plot fitted Palm intensity.
plot(fit)

</code></pre>

<hr>
<h2 id='porpoise.data'>Two-camera porpoise data.</h2><span id='topic+porpoise.data'></span>

<h3>Description</h3>

<p>Synthetic data constructed from circle-back aerial survey data; see
Stevenson, Borchers, and Fewster (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>porpoise.data
</code></pre>


<h3>Format</h3>

<p>A list.
</p>


<h3>References</h3>

<p>Stevenson, B. C., Borchers, D. L., and Fewster,
R. M. (2019) Cluster capture-recapture to account for
identification uncertainty on aerial surveys of animal
populations. <em>Biometrics</em>, <strong>75</strong>: 326&ndash;336.
</p>

<hr>
<h2 id='sim.ns'>Simulating points from a Neyman-Scott point process</h2><span id='topic+sim.ns'></span>

<h3>Description</h3>

<p>Generates points from a Neyman-Scott point process using parameters
provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.ns(
  pars,
  lims,
  disp = "gaussian",
  child.dist = "pois",
  parents = NULL,
  child.info = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.ns_+3A_pars">pars</code></td>
<td>
<p>A named vector containing the values of the parameters
of the process that generates the points.</p>
</td></tr>
<tr><td><code id="sim.ns_+3A_lims">lims</code></td>
<td>
<p>A matrix or list of matrices with two columns,
corresponding to the upper and lower limits of each dimension,
respectively. If a list, then each matrix provides the limits
for the corresponding pattern in <code>points</code>.</p>
</td></tr>
<tr><td><code id="sim.ns_+3A_disp">disp</code></td>
<td>
<p>A character string indicating the distribution of
children around their parents. Use <code>"gaussian"</code> for
multivariate normal dispersion with standard deviation
<code>sigma</code>, or <code>"uniform"</code> for uniform dispersion within
distance <code>tau</code> of the parent.</p>
</td></tr>
<tr><td><code id="sim.ns_+3A_child.dist">child.dist</code></td>
<td>
<p>The distribution of the number of children
generated by a randomly selected parent. For a Poisson
distribution, use <code>"pois"</code>; for a binomial distribution,
use <code>"binomx"</code>, where <code>"x"</code> is replaced by the fixed
value of the number of independent trials (e.g.,
<code>"binom5"</code> for a Binomial(5, p) distribution, and
<code>"binom50"</code> for a Binomial(50, p) distribution); and
<code>"twocamera"</code> for a child distribution appropriate for a
two-camera aerial survey.</p>
</td></tr>
<tr><td><code id="sim.ns_+3A_parents">parents</code></td>
<td>
<p>An optional matrix containing locations of
parents. If this is provided, then the parameter <code>D</code> is
not required in <code>pars</code>. If this is not provided, then
parents are generated from a homogeneous Poisson point process
with intensity <code>D</code>.</p>
</td></tr>
<tr><td><code id="sim.ns_+3A_child.info">child.info</code></td>
<td>
<p>A list of further information that is required
about the distribution for the number of children generated by
parents. See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a list of possible parameter names, see <a href="#topic+fit.ns">fit.ns</a>.
</p>
<p>The <code>"child.info"</code> argument is required when <code>child.dist</code>
is set to <code>"twocamera"</code>. It must be a list that comprises (i) a
component named <code>w</code>, providing the halfwidth of the detection
zone; (ii) a component named <code>b</code>, providing the halfwidth of
the survey area; (iii) a component named <code>l</code>, providing the
time lag between cameras (in seconds); and (iv) a component named
<code>tau</code>, providing the mean dive-cycle duration. See Stevenson,
Borchers, and Fewster (2019) for details.
</p>


<h3>Value</h3>

<p>A list. The first component gives the Cartesian coordinates
of the generated points. The second component returns the
parent locations. A third component may provide sibling
information.
</p>


<h3>References</h3>

<p>Stevenson, B. C., Borchers, D. L., and Fewster,
R. M. (2019) Cluster capture-recapture to account for
identification uncertainty on aerial surveys of animal
populations. <em>Biometrics</em>, <strong>75</strong>: 326&ndash;336.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulating from a one-dimensional Thomas process.
data.thomas &lt;- sim.ns(c(D = 10, lambda = 5, sigma = 0.025), lims = rbind(c(0, 1)))
## Simulating from a three-dimensional Matern process.
data.matern &lt;- sim.ns(c(D = 10, lambda = 10, tau = 0.1), disp = "uniform",
                      lims = rbind(c(0, 1), c(0, 2), c(0, 3)))

</code></pre>

<hr>
<h2 id='sim.twocamera'>Simulating data from two-camera aerial surveys.</h2><span id='topic+sim.twocamera'></span>

<h3>Description</h3>

<p>Simulating data from two-camera aerial surveys.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.twocamera(pars, d, w, b, l, tau, parents = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.twocamera_+3A_pars">pars</code></td>
<td>
<p>A vector containing elements named <code>D.2D</code>,
<code>kappa</code>, and <code>sigma</code>, providing values of animal
density (animals per square km), average duration of surface
phase (s), and dispersion (km).</p>
</td></tr>
<tr><td><code id="sim.twocamera_+3A_d">d</code></td>
<td>
<p>The length of the transect flown (in km).</p>
</td></tr>
<tr><td><code id="sim.twocamera_+3A_w">w</code></td>
<td>
<p>The distance from the transect to which detection of
individuals on the surface is certain. This is equivalent to
the half-width of the detection zone.</p>
</td></tr>
<tr><td><code id="sim.twocamera_+3A_b">b</code></td>
<td>
<p>The distance from the transect to the edge of the area of
interest. Conceptually, the distance between the transect and
the furthest distance a whale could be on the passing of the
first camera and plausibly move into the detection zone by the
passing of the second camera.</p>
</td></tr>
<tr><td><code id="sim.twocamera_+3A_l">l</code></td>
<td>
<p>The lag between cameras (in seconds).</p>
</td></tr>
<tr><td><code id="sim.twocamera_+3A_tau">tau</code></td>
<td>
<p>Mean dive-cycle duration (in seconds).</p>
</td></tr>
<tr><td><code id="sim.twocamera_+3A_parents">parents</code></td>
<td>
<p>An optional vector containing the parent locations
for all animals within the area of interest, given in distance
along the transect (in km). If this is provided, then the
parameter <code>D.2D</code> is not required in <code>pars</code>. If this
is not provided, then parent locations are generated from a
homogeneous Poisson point process with intensity <code>D.2D</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The first component gives the distance along the
transect of detected individuals. The second gives the parent
locations. The third identifies which parent location generated
each detected individual. The fourth gives the distance from
the transect centre line of the detection location. The fifth
provides observed sibling information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twocamera.data &lt;- sim.twocamera(c(D.2D = 1.3, kappa = 27, sigma = 0.02), d = 500,
                                w = 0.175, b = 0.5, l = 20, tau = 110)

</code></pre>

<hr>
<h2 id='sim.void'>Simulating points from a void point process.</h2><span id='topic+sim.void'></span>

<h3>Description</h3>

<p>Generates points from a void point process using parameters provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.void(pars, lims, parents = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.void_+3A_pars">pars</code></td>
<td>
<p>A named vector containing the values of the parameters
of the process that generates the points.</p>
</td></tr>
<tr><td><code id="sim.void_+3A_lims">lims</code></td>
<td>
<p>A matrix or list of matrices with two columns,
corresponding to the upper and lower limits of each dimension,
respectively. If a list, then each matrix provides the limits
for the corresponding pattern in <code>points</code>.</p>
</td></tr>
<tr><td><code id="sim.void_+3A_parents">parents</code></td>
<td>
<p>An optional matrix containing locations of
parents. If this is provided, then the parameter <code>D</code> is
not required in <code>pars</code>. If this is not provided, then
parents are generated from a homogeneous Poisson point process
with intensity <code>Dp</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a list of possible parameter names, see <a href="#topic+fit.ns">fit.ns</a>.
</p>


<h3>Value</h3>

<p>A list. The first component gives the Cartesian coordinates
of the generated points. The second component returns the
parent locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two-dimensional void process.
void.data &lt;- sim.void(c(Dc = 1000, Dp = 10, tau = 0.05), rbind(c(0, 1), c(0, 1)))
## Plotting the data.
plot(void.data$points)
points(void.data$parents, pch = 16, col = "red")

</code></pre>

<hr>
<h2 id='summary.palm'>Summarising palm model fits</h2><span id='topic+summary.palm'></span>

<h3>Description</h3>

<p>Provides a useful summary of the model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'palm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.palm_+3A_object">object</code></td>
<td>
<p>A fitted model returned by <a href="#topic+fit.ns">fit.ns</a>.</p>
</td></tr>
<tr><td><code id="summary.palm_+3A_...">...</code></td>
<td>
<p>Other parameters (for S3 generic compatibility).</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
