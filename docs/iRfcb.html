<!DOCTYPE html><html lang="en"><head><title>Help for package iRfcb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iRfcb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#iRfcb-package'><p>iRfcb: Tools for Managing Imaging FlowCytobot (IFCB) Data</p></a></li>
<li><a href='#create_package_manifest'><p>Function to Create MANIFEST.txt</p></a></li>
<li><a href='#defunct'><p>Defunct functions</p></a></li>
<li><a href='#ifcb_adjust_classes'><p>Adjust Classifications in Manual Annotations</p></a></li>
<li><a href='#ifcb_annotate_batch'><p>Annotate IFCB Images with Specified Class</p></a></li>
<li><a href='#ifcb_convert_filenames'><p>Convert IFCB Filenames to Timestamps</p></a></li>
<li><a href='#ifcb_correct_annotation'><p>Correct Annotations in MATLAB Classlist Files</p></a></li>
<li><a href='#ifcb_count_mat_annotations'><p>Count IFCB Annotations from .mat Files</p></a></li>
<li><a href='#ifcb_create_class2use'><p>Create a class2use .mat File</p></a></li>
<li><a href='#ifcb_create_empty_manual_file'><p>Create an Empty Manual Classification MAT File</p></a></li>
<li><a href='#ifcb_create_manifest'><p>Create a MANIFEST.txt File</p></a></li>
<li><a href='#ifcb_download_test_data'><p>Download Test IFCB Data</p></a></li>
<li><a href='#ifcb_extract_annotated_images'><p>Extract Annotated Images from IFCB Data</p></a></li>
<li><a href='#ifcb_extract_biovolumes'><p>Extract Biovolumes from IFCB Data and Compute Carbon Content</p></a></li>
<li><a href='#ifcb_extract_classified_images'><p>Extract Taxa Images from MATLAB Classified Sample</p></a></li>
<li><a href='#ifcb_extract_pngs'><p>Extract Images from IFCB ROI File</p></a></li>
<li><a href='#ifcb_get_ecotaxa_example'><p>Get Ecotaxa Column Names</p></a></li>
<li><a href='#ifcb_get_ferrybox_data'><p>Retrieve Ferrybox Data for Specified Timestamps</p></a></li>
<li><a href='#ifcb_get_mat_names'><p>Get Variable Names from a MAT File</p></a></li>
<li><a href='#ifcb_get_mat_variable'><p>Get Classes from a MAT File</p></a></li>
<li><a href='#ifcb_get_runtime'><p>Read IFCB Header File and Extract Runtime Information</p></a></li>
<li><a href='#ifcb_get_shark_colnames'><p>Get Shark Column Names</p></a></li>
<li><a href='#ifcb_get_shark_example'><p>Get Shark Column Example</p></a></li>
<li><a href='#ifcb_get_trophic_type'><p>Get Trophic Type for a List of Plankton Taxa</p></a></li>
<li><a href='#ifcb_is_diatom'><p>Identify Diatoms in Taxa List</p></a></li>
<li><a href='#ifcb_is_in_basin'><p>Check if Points are in a Specific Sea Basin</p></a></li>
<li><a href='#ifcb_is_near_land'><p>Determine if Positions are Near Land</p></a></li>
<li><a href='#ifcb_match_taxa_names'><p>Retrieve WoRMS Records with Retry Mechanism</p></a></li>
<li><a href='#ifcb_merge_manual'><p>Merge IFCB Manual Classification Data</p></a></li>
<li><a href='#ifcb_psd'><p>Plot and Save IFCB PSD Data</p></a></li>
<li><a href='#ifcb_psd_plot'><p>Generate PSD Plot for a Given Sample</p></a></li>
<li><a href='#ifcb_py_install'><p>Install iRfcb Python Environment</p></a></li>
<li><a href='#ifcb_read_features'><p>Read Feature Files from a Specified Folder or File Paths</p></a></li>
<li><a href='#ifcb_read_hdr_data'><p>Reads HDR Data from IFCB HDR Files</p></a></li>
<li><a href='#ifcb_read_mat'><p>Read a MATLAB .mat File in R</p></a></li>
<li><a href='#ifcb_read_summary'><p>Read and Summarize Classified IFCB Data</p></a></li>
<li><a href='#ifcb_replace_mat_values'><p>Replace Values in MATLAB Classlist</p></a></li>
<li><a href='#ifcb_run_image_gallery'><p>Run IFCB Image Gallery</p></a></li>
<li><a href='#ifcb_summarize_biovolumes'><p>Summarize Biovolumes and Carbon Content from IFCB Data</p></a></li>
<li><a href='#ifcb_summarize_class_counts'><p>Count Cells from TreeBagger Classifier Output</p></a></li>
<li><a href='#ifcb_summarize_png_counts'><p>Summarize Image Counts by Class and Sample</p></a></li>
<li><a href='#ifcb_summarize_png_data'><p>Summarize Image Counts by Class and Sample</p></a></li>
<li><a href='#ifcb_summarize_png_metadata'><p>Summarize PNG Image Metadata</p></a></li>
<li><a href='#ifcb_volume_analyzed'><p>Estimate Volume Analyzed from IFCB Header File</p></a></li>
<li><a href='#ifcb_volume_analyzed_from_adc'><p>Estimate Volume Analyzed from IFCB ADC File</p></a></li>
<li><a href='#ifcb_which_basin'><p>Determine if Points are in a Specified Sea Basin</p></a></li>
<li><a href='#ifcb_zip_matlab'><p>Create a Zip Archive of Manual MATLAB Files</p></a></li>
<li><a href='#ifcb_zip_pngs'><p>Zip PNG Folders</p></a></li>
<li><a href='#read_hdr_file'><p>Function to Read Individual Files and Extract Relevant Lines</p></a></li>
<li><a href='#retrieve_worms_records'><p>Retrieve WoRMS Records with Retry Mechanism</p></a></li>
<li><a href='#split_large_zip'><p>Split Large Zip File into Smaller Parts</p></a></li>
<li><a href='#summarize_TBclass'><p>Summarize TreeBagger Classifier Results</p></a></li>
<li><a href='#vol2C_lgdiatom'><p>Convert Biovolume to Carbon for Large Diatoms</p></a></li>
<li><a href='#vol2C_nondiatom'><p>Convert Biovolume to Carbon for Non-Diatom Protists</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Managing Imaging FlowCytobot (IFCB) Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive suite of tools for managing, processing, and analyzing data from the IFCB. I R FlowCytobot ('iRfcb') supports quality control, geospatial analysis, and preparation of IFCB data for publication in databases like <a href="https://www.gbif.org">https://www.gbif.org</a>, <a href="https://www.obis.org">https://www.obis.org</a>, <a href="https://emodnet.ec.europa.eu/en">https://emodnet.ec.europa.eu/en</a>, <a href="https://shark.smhi.se/">https://shark.smhi.se/</a>, and <a href="https://www.ecotaxa.org">https://www.ecotaxa.org</a>. The package integrates with the MATLAB 'ifcb-analysis' tool, which is described in Sosik and Olson (2007) &lt;<a href="https://doi.org/10.4319%2Flom.2007.5.204">doi:10.4319/lom.2007.5.204</a>&gt;, and provides features for working with raw, manually classified, and machine learningâ€“classified image datasets. Key functionalities include image extraction, particle size distribution analysis, taxonomic data handling, and biomass concentration calculations, essential for plankton research.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>zip, lifecycle, shiny, stringr, dplyr, sf, reticulate (&ge;
1.41.0), tidyr, ggplot2, readr, worrms, png, R.matlab, curl,
lubridate</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Note:</td>
<td>This package includes code from https://github.com/kudelalab/PSD
by kudelalab licensed under the MIT License.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), fs, mockery,
shinytest2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://europeanifcbgroup.github.io/iRfcb/">https://europeanifcbgroup.github.io/iRfcb/</a>,
<a href="https://github.com/EuropeanIFCBGroup/iRfcb">https://github.com/EuropeanIFCBGroup/iRfcb</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 22:12:00 UTC; anderstorstensson</td>
</tr>
<tr>
<td>Author:</td>
<td>Anders Torstensson
    <a href="https://orcid.org/0000-0002-8283-656X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]
    (affiliation: Swedish Meteorological and Hydrological Institute),
  Kendra Hayashi <a href="https://orcid.org/0000-0003-1600-9504"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Jamie Enslein [ctb],
  Raphael Kudela <a href="https://orcid.org/0000-0002-8640-1205"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Alle Lie <a href="https://orcid.org/0009-0001-8709-4841"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Jayme Smith <a href="https://orcid.org/0000-0002-9669-4427"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  DTO-BioFlow [fnd] (funding: Horizon Europe,
    HORIZON-MISS-2022-OCEAN-01-07)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anders Torstensson &lt;anders.torstensson@smhi.se&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-15 17:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='iRfcb-package'>iRfcb: Tools for Managing Imaging FlowCytobot (IFCB) Data</h2><span id='topic+iRfcb'></span><span id='topic+iRfcb-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A comprehensive suite of tools for managing, processing, and analyzing data from the IFCB. I R FlowCytobot ('iRfcb') supports quality control, geospatial analysis, and preparation of IFCB data for publication in databases like <a href="https://www.gbif.org">https://www.gbif.org</a>, <a href="https://www.obis.org">https://www.obis.org</a>, <a href="https://emodnet.ec.europa.eu/en">https://emodnet.ec.europa.eu/en</a>, <a href="https://shark.smhi.se/">https://shark.smhi.se/</a>, and <a href="https://www.ecotaxa.org">https://www.ecotaxa.org</a>. The package integrates with the MATLAB 'ifcb-analysis' tool, which is described in Sosik and Olson (2007) <a href="https://doi.org/10.4319/lom.2007.5.204">doi:10.4319/lom.2007.5.204</a>, and provides features for working with raw, manually classified, and machine learningâ€“classified image datasets. Key functionalities include image extraction, particle size distribution analysis, taxonomic data handling, and biomass concentration calculations, essential for plankton research.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Anders Torstensson <a href="mailto:anders.torstensson@smhi.se">anders.torstensson@smhi.se</a> (<a href="https://orcid.org/0000-0002-8283-656X">ORCID</a>) (Swedish Meteorological and Hydrological Institute)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kendra Hayashi (<a href="https://orcid.org/0000-0003-1600-9504">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jamie Enslein [contributor]
</p>
</li>
<li><p> Raphael Kudela (<a href="https://orcid.org/0000-0002-8640-1205">ORCID</a>) [contributor]
</p>
</li>
<li><p> Alle Lie (<a href="https://orcid.org/0009-0001-8709-4841">ORCID</a>) [contributor]
</p>
</li>
<li><p> Jayme Smith (<a href="https://orcid.org/0000-0002-9669-4427">ORCID</a>) [contributor]
</p>
</li>
<li><p> DTO-BioFlow (Horizon Europe, HORIZON-MISS-2022-OCEAN-01-07) [funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://europeanifcbgroup.github.io/iRfcb/">https://europeanifcbgroup.github.io/iRfcb/</a>
</p>
</li>
<li> <p><a href="https://github.com/EuropeanIFCBGroup/iRfcb">https://github.com/EuropeanIFCBGroup/iRfcb</a>
</p>
</li></ul>


<hr>
<h2 id='create_package_manifest'>Function to Create MANIFEST.txt</h2><span id='topic+create_package_manifest'></span>

<h3>Description</h3>

<p>This function generates a MANIFEST.txt file that lists all files in the specified paths,
along with their sizes. It recursively includes files from directories and skips paths that
do not exist. The manifest excludes the manifest file itself if present in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_package_manifest(paths, manifest_path = "MANIFEST.txt", temp_dir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_package_manifest_+3A_paths">paths</code></td>
<td>
<p>A character vector of paths to files and/or directories to include in the manifest.</p>
</td></tr>
<tr><td><code id="create_package_manifest_+3A_manifest_path">manifest_path</code></td>
<td>
<p>A character string specifying the path to the manifest file. Default is &quot;MANIFEST.txt&quot;.</p>
</td></tr>
<tr><td><code id="create_package_manifest_+3A_temp_dir">temp_dir</code></td>
<td>
<p>A character string specifying the temporary directory to be removed from the file paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return any value. It creates a <code>MANIFEST.txt</code> file at the specified location,
which contains a list of all files (including their sizes) in the provided paths.
The file paths are relative to the specified <code>temp_dir</code>, and the manifest excludes the manifest file itself if present.
</p>

<hr>
<h2 id='defunct'>Defunct functions</h2><span id='topic+defunct'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#defunct"><img src="../help/figures/lifecycle-defunct.svg" alt='[Defunct]' /></a>
</p>
<p>These functions were deprecated for at least five release cycles before being
made defunct. If there's a known replacement, calling the function
will tell you about it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Deprecated in 0.3.* -------------------------------------
</code></pre>

<hr>
<h2 id='ifcb_adjust_classes'>Adjust Classifications in Manual Annotations</h2><span id='topic+ifcb_adjust_classes'></span>

<h3>Description</h3>

<p>This function adjusts the classifications in manual annotation files based on a class2use file.
It loads a specified class2use file and applies the adjustments to all relevant files in the
specified manual folder. Optionally, it can also perform compression on the output files.
This is the R equivalent function of <code>start_mc_adjust_classes_user_training</code> from the
<code style="white-space: pre;">&#8288;ifcb-analysis repository&#8288;</code> (Sosik and Olson 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_adjust_classes(class2use_file, manual_folder, do_compression = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_adjust_classes_+3A_class2use_file">class2use_file</code></td>
<td>
<p>A character string representing the full path to the class2use file
(should be a .mat file).</p>
</td></tr>
<tr><td><code id="ifcb_adjust_classes_+3A_manual_folder">manual_folder</code></td>
<td>
<p>A character string representing the path to the folder containing manual
annotation files. The function will look for files starting with 'D' in this folder.</p>
</td></tr>
<tr><td><code id="ifcb_adjust_classes_+3A_do_compression">do_compression</code></td>
<td>
<p>A logical value indicating whether to apply compression to the output files.
Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a python interpreter to be installed.
The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_py_install">ifcb_py_install</a></code> <code><a href="#topic+ifcb_create_class2use">ifcb_create_class2use</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ifcb_adjust_classes("C:/training/config/class2use", "C:/training/manual/2014/")

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_annotate_batch'>Annotate IFCB Images with Specified Class</h2><span id='topic+ifcb_annotate_batch'></span>

<h3>Description</h3>

<p>This function creates or updates manual <code>.mat</code> classlist files with a user specified class in batch,
based on input vector of IFCB image names.
These <code>.mat</code> can be used with the code in the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_annotate_batch(
  png_images,
  class,
  manual_folder,
  adc_folder,
  class2use_file,
  manual_output = NULL,
  manual_recursive = FALSE,
  unclassified_id = 1,
  do_compression = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_annotate_batch_+3A_png_images">png_images</code></td>
<td>
<p>A character vector containing the names of the PNG images to be annotated in the format DYYYYMMDDTHHMMSS_IFCBXXX_ZZZZZ.png, where XXX represent the IFCB number and ZZZZZ the roi number.</p>
</td></tr>
<tr><td><code id="ifcb_annotate_batch_+3A_class">class</code></td>
<td>
<p>A character string or integer specifying the class name or class2use index to annotate the images with. If a string is provided, it is matched against the available classes in <code>class2use_file</code>.</p>
</td></tr>
<tr><td><code id="ifcb_annotate_batch_+3A_manual_folder">manual_folder</code></td>
<td>
<p>A character string specifying the path to the folder containing the manual <code>.mat</code> classlist files.</p>
</td></tr>
<tr><td><code id="ifcb_annotate_batch_+3A_adc_folder">adc_folder</code></td>
<td>
<p>A character string specifying the path to the base folder containing the raw data, organized in subfolders by year (YYYY) and date (DYYYYMMDD). Each subfolder contains ADC files, which are used to determine the number of regions of interest (ROIs) for each sample when creating new manual <code>.mat</code> files.</p>
</td></tr>
<tr><td><code id="ifcb_annotate_batch_+3A_class2use_file">class2use_file</code></td>
<td>
<p>A character string specifying the path to the <code>.mat</code> file containing class names and corresponding indices.</p>
</td></tr>
<tr><td><code id="ifcb_annotate_batch_+3A_manual_output">manual_output</code></td>
<td>
<p>A character string specifying the path to the folder where updated or newly created <code>.mat</code> classlist files will be saved. If not provided, the <code>manual_folder</code> path will be used by default.</p>
</td></tr>
<tr><td><code id="ifcb_annotate_batch_+3A_manual_recursive">manual_recursive</code></td>
<td>
<p>A logical value indicating whether to search recursively within <code>manual_folder</code> for <code>.mat</code> files. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_annotate_batch_+3A_unclassified_id">unclassified_id</code></td>
<td>
<p>An integer specifying the class ID to use for unclassified regions of interest (ROIs) when creating new manual <code>.mat</code> files. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="ifcb_annotate_batch_+3A_do_compression">do_compression</code></td>
<td>
<p>A logical value indicating whether to compress the .mat file. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a python interpreter to be installed. The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
</p>
<p>If an image belongs to a sample that already has a corresponding manual <code>.mat</code> file,
the function updates the class IDs for the specified regions of interest (ROIs) in that file.
If no manual file exists for the sample, the function creates a new one based on the sample's ADC data,
assigning unclassified IDs to all ROIs initially, then applying the specified class to the relevant ROIs.
</p>
<p>The class parameter can be provided as either a string (class name) or an integer (class index).
If a string is provided, the function will attempt to match it to one of the available
classes in <code>class2use_file</code>. If no match is found, an error is thrown.
</p>
<p>The function assumes that the ADC files are organized in subfolders by year (YYYY) and date (DYYYYMMDD) within <code>adc_folder</code>.
</p>


<h3>Value</h3>

<p>The function does not return a value. It creates or updates <code>.mat</code> files in the <code>manual_folder</code> to
reflect the specified annotations.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_correct_annotation">ifcb_correct_annotation</a></code>, <code><a href="#topic+ifcb_create_empty_manual_file">ifcb_create_empty_manual_file</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize a python session if not already set up
ifcb_py_install()

# Annotate two png images with class "Nodularia_spumigena" and update or create manual files
ifcb_annotate_batch(
  png_images = c("D20230812T162908_IFCB134_01399.png",
                 "D20230714T102127_IFCB134_00069.png"),
  class = "Nodularia_spumigena",
  manual_folder = "path/to/manual",
  adc_folder = "path/to/adc",
  class2use_file = "path/to/class2use.mat"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_convert_filenames'>Convert IFCB Filenames to Timestamps</h2><span id='topic+ifcb_convert_filenames'></span>

<h3>Description</h3>

<p>This function converts IFCB filenames to a data frame with separate columns for
the sample name, full timestamp, year, month, day, time, and IFCB number.
ROI numbers are included if available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_convert_filenames(filenames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_convert_filenames_+3A_filenames">filenames</code></td>
<td>
<p>A character vector of IFCB filenames in the format &quot;DYYYYMMDDTHHMMSS_IFCBxxx&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with columns:
</p>

<ul>
<li> <p><code>sample</code>: The extracted sample name.
</p>
</li>
<li> <p><code>full_timestamp</code>: The full timestamp in &quot;YYYY-MM-DD HH:MM:SS&quot; format.
</p>
</li>
<li> <p><code>year</code>: The year as an integer.
</p>
</li>
<li> <p><code>month</code>: The month as an integer.
</p>
</li>
<li> <p><code>day</code>: The day as an integer.
</p>
</li>
<li> <p><code>time</code>: The extracted time in &quot;HH:MM:SS&quot; format.
</p>
</li>
<li> <p><code>ifcb_number</code>: The IFCB instrument number.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>filenames &lt;- c("D20230314T001205_IFCB134", "D20230615T123045_IFCB135")
timestamps &lt;- ifcb_convert_filenames(filenames)
print(timestamps)

</code></pre>

<hr>
<h2 id='ifcb_correct_annotation'>Correct Annotations in MATLAB Classlist Files</h2><span id='topic+ifcb_correct_annotation'></span>

<h3>Description</h3>

<p>This function corrects annotations in MATLAB classlist files located in a specified manual folder,
generated by the code in the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
It replaces the class ID of specified regions of interest (ROIs) in the classlist files based on
a correction file or a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_correct_annotation(
  manual_folder,
  out_folder,
  correction = NULL,
  correct_classid,
  do_compression = TRUE,
  correction_file = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_correct_annotation_+3A_manual_folder">manual_folder</code></td>
<td>
<p>A character string specifying the path to the folder containing the original MAT classlist files to be updated.</p>
</td></tr>
<tr><td><code id="ifcb_correct_annotation_+3A_out_folder">out_folder</code></td>
<td>
<p>A character string specifying the path to the folder where updated MAT classlist files will be saved.</p>
</td></tr>
<tr><td><code id="ifcb_correct_annotation_+3A_correction">correction</code></td>
<td>
<p>Either a character string specifying the path to the correction file, or a character vector containing image filenames to be corrected.
If a file is provided, it should have a column named <code>image_filename</code>. If a character vector is provided, it will be treated as a direct list of image filenames.</p>
</td></tr>
<tr><td><code id="ifcb_correct_annotation_+3A_correct_classid">correct_classid</code></td>
<td>
<p>An integer specifying the class ID to use for corrections.</p>
</td></tr>
<tr><td><code id="ifcb_correct_annotation_+3A_do_compression">do_compression</code></td>
<td>
<p>A logical value indicating whether to compress the .mat file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_correct_annotation_+3A_correction_file">correction_file</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Use <code>correction</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a python interpreter to be installed. The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
</p>
<p>The correction file is expected to contain at least one column: <code>image_filename</code>, which includes the filenames of the images (with or without additional trailing information).
The function processes each file, corrects the annotations, and saves the updated files in the output folder.
</p>
<p>If a character vector is provided as <code>correction</code>, it will be used directly as a list of filenames for correction.
</p>
<p>The <code>correction</code> is typically generated using a Shiny app that provides an interactive interface for browsing and managing
IFCB (Imaging FlowCytobot) image galleries. This Shiny app can be initialized using the function <code>ifcb_run_image_gallery()</code>.
</p>


<h3>Value</h3>

<p>This function does not return any value; it updates the classlist files in the specified output directory.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_py_install">ifcb_py_install</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize a python session if not already set up
ifcb_py_install()

# Correct class ID in .mat classlist files using a correction file
ifcb_correct_annotation("input/manual",
                        "output/manual",
                        "corrections.txt",
                        99)

# Correct class ID in .mat classlist files using a character vector of filenames
ifcb_correct_annotation("input/manual",
                        "output/manual",
                        c("D20230917T153755_IFCB134_01724.png",
                          "D20230917T110059_IFCB134_00380.png"),
                        99)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_count_mat_annotations'>Count IFCB Annotations from .mat Files</h2><span id='topic+ifcb_count_mat_annotations'></span>

<h3>Description</h3>

<p>This function processes .mat files, generated by the code in the <code>ifcb-analysis</code> repository (Sosik and Olson 2007),
to count and summarize the annotations for each class based on the class2use information provided in a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_count_mat_annotations(
  manual_files,
  class2use_file,
  skip_class = NULL,
  sum_level = "class",
  mat_recursive = FALSE,
  use_python = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_count_mat_annotations_+3A_manual_files">manual_files</code></td>
<td>
<p>A character string specifying the path to the .mat files or a folder containing .mat files.</p>
</td></tr>
<tr><td><code id="ifcb_count_mat_annotations_+3A_class2use_file">class2use_file</code></td>
<td>
<p>A character string specifying the path to the file containing the class2use variable.</p>
</td></tr>
<tr><td><code id="ifcb_count_mat_annotations_+3A_skip_class">skip_class</code></td>
<td>
<p>A numeric vector of class IDs or a character vector of class names to be excluded from the count. Default is NULL.</p>
</td></tr>
<tr><td><code id="ifcb_count_mat_annotations_+3A_sum_level">sum_level</code></td>
<td>
<p>A character string specifying the level of summarization. Options: &quot;sample&quot;, &quot;roi&quot; or &quot;class&quot; (default).</p>
</td></tr>
<tr><td><code id="ifcb_count_mat_annotations_+3A_mat_recursive">mat_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for MATLAB files recursively when <code>manual_files</code> is a folder. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_count_mat_annotations_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read the <code>.mat</code> file using a Python-based method. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_python = TRUE</code>, the function tries to read the <code>.mat</code> file using <code>ifcb_read_mat()</code>, which relies on <code>SciPy</code>.
This approach may be faster than the default approach using <code>R.matlab::readMat()</code>, especially for large <code>.mat</code> files.
To enable this functionality, ensure Python is properly configured with the required dependencies.
You can initialize the Python environment and install necessary packages using <code>ifcb_py_install()</code>.
</p>
<p>If <code>use_python = FALSE</code> or if <code>SciPy</code> is not available, the function falls back to using <code>R.matlab::readMat()</code>.
</p>


<h3>Value</h3>

<p>A data frame with the total count of images per class, roi or per sample.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Count annotations excluding specific class IDs
result &lt;- ifcb_count_mat_annotations("path/to/manual_folder",
                                     "path/to/class2use_file",
                                     skip_class = c(99, 100))
print(result)

# Count annotations excluding a specific class name
result &lt;- ifcb_count_mat_annotations("path/to/manual_folder",
                                     "path/to/class2use_file",
                                     skip_class = "unclassified")
print(result)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_create_class2use'>Create a class2use .mat File</h2><span id='topic+ifcb_create_class2use'></span>

<h3>Description</h3>

<p>This function creates a <code>.mat</code> file containing a character vector of class names.
A class2use file can be used for manual annotation using the code in the <code>ifcb-analysis</code>
repository (Sosik and Olson 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_create_class2use(classes, filename, do_compression = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_create_class2use_+3A_classes">classes</code></td>
<td>
<p>A character vector of class names to be saved in the <code>.mat</code> file.</p>
</td></tr>
<tr><td><code id="ifcb_create_class2use_+3A_filename">filename</code></td>
<td>
<p>A string specifying the output file path (with <code>.mat</code> extension).</p>
</td></tr>
<tr><td><code id="ifcb_create_class2use_+3A_do_compression">do_compression</code></td>
<td>
<p>A logical value indicating whether to compress the <code>.mat</code> file. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a python interpreter to be installed.
The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
</p>


<h3>Value</h3>

<p>No return value. This function is called for its side effect of creating a <code>.mat</code> file.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_py_install">ifcb_py_install</a></code> <code><a href="#topic+ifcb_adjust_classes">ifcb_adjust_classes</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example usage:
classes &lt;- c("unclassified", "Dinobryon_spp", "Helicostomella_spp")

ifcb_create_class2use(classes, "class2use_output.mat", do_compression = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_create_empty_manual_file'>Create an Empty Manual Classification MAT File</h2><span id='topic+ifcb_create_empty_manual_file'></span>

<h3>Description</h3>

<p>Generates a MAT file for IFCB data with an empty manual classification structure using a specified number of ROIs,
class names, and saves it to a specified output file. This function utilizes a Python script for creating the structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_create_empty_manual_file(
  roi_length,
  class2use,
  output_file,
  unclassified_id = 1,
  do_compression = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_create_empty_manual_file_+3A_roi_length">roi_length</code></td>
<td>
<p>Integer. The number of rows in the class list (number of ROIs).</p>
</td></tr>
<tr><td><code id="ifcb_create_empty_manual_file_+3A_class2use">class2use</code></td>
<td>
<p>Character vector. The names of the classes to include in the <code>class2use_manual</code> field of the MAT file.</p>
</td></tr>
<tr><td><code id="ifcb_create_empty_manual_file_+3A_output_file">output_file</code></td>
<td>
<p>Character. The path where the output MAT file will be saved.</p>
</td></tr>
<tr><td><code id="ifcb_create_empty_manual_file_+3A_unclassified_id">unclassified_id</code></td>
<td>
<p>Integer. The value to use in the second column of the class list. Default is 1.</p>
</td></tr>
<tr><td><code id="ifcb_create_empty_manual_file_+3A_do_compression">do_compression</code></td>
<td>
<p>A logical value indicating whether to compress the .mat file. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a python interpreter to be installed. The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
</p>


<h3>Value</h3>

<p>No return value. This function is called for its side effects.
The created MAT file is saved at the specified <code>output_file</code> location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize a python session if not already set up
ifcb_py_install()

# Create a MAT file with 100 ROIs, using a vector of class names, and save it to "output.mat"
ifcb_create_empty_manual_file(roi_length = 100,
                              class2use = c("unclassified", "Aphanizomenon_spp"),
                              output_file = "output.mat")

# Create a MAT file with a different unclassified_id
ifcb_create_empty_manual_file(roi_length = 100,
                              class2use = c("unclassified", "Aphanizomenon_spp"),
                              output_file = "output.mat",
                              unclassified_id = 999)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_create_manifest'>Create a MANIFEST.txt File</h2><span id='topic+ifcb_create_manifest'></span>

<h3>Description</h3>

<p>This function generates a MANIFEST.txt file listing all files in a specified folder and its subfolders,
along with their sizes in bytes. The function can optionally exclude an existing MANIFEST.txt file from
the generated list. A manifest may be useful when archiving images in data repositories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_create_manifest(
  folder_path,
  manifest_path = file.path(folder_path, "MANIFEST.txt"),
  exclude_manifest = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_create_manifest_+3A_folder_path">folder_path</code></td>
<td>
<p>A character string specifying the path to the folder whose files are to be listed.</p>
</td></tr>
<tr><td><code id="ifcb_create_manifest_+3A_manifest_path">manifest_path</code></td>
<td>
<p>A character string specifying the path and name of the MANIFEST.txt file to be created. Defaults to &quot;folder_path/MANIFEST.txt&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_create_manifest_+3A_exclude_manifest">exclude_manifest</code></td>
<td>
<p>A logical value indicating whether to exclude an existing MANIFEST.txt file from the list. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects. Creates a MANIFEST.txt file at the specified location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a MANIFEST.txt file for the current directory
ifcb_create_manifest(".")

# Create a MANIFEST.txt file for a specific directory, excluding an existing MANIFEST.txt file
ifcb_create_manifest("path/to/directory")

# Create a MANIFEST.txt file and save it to a specific path
ifcb_create_manifest("path/to/directory", manifest_path = "path/to/manifest/MANIFEST.txt")

# Create a MANIFEST.txt file without excluding an existing MANIFEST.txt file
ifcb_create_manifest("path/to/directory", exclude_manifest = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_download_test_data'>Download Test IFCB Data</h2><span id='topic+ifcb_download_test_data'></span>

<h3>Description</h3>

<p>This function downloads a zip archive containing MATLAB files from the <code>iRfcb</code>
dataset available in the SMHI IFCB Plankton Image Reference Library (Torstensson et al. 2024),
unzips them into the specified folder and extracts png images. These data can be used, for instance,
for testing iRfcb and for creating the tutorial vignette
using <code>vignette("tutorial", package = "iRfcb")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_download_test_data(
  dest_dir,
  figshare_article = "48158716",
  max_retries = 5,
  sleep_time = 10,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_download_test_data_+3A_dest_dir">dest_dir</code></td>
<td>
<p>The destination directory where the files will be unzipped.</p>
</td></tr>
<tr><td><code id="ifcb_download_test_data_+3A_figshare_article">figshare_article</code></td>
<td>
<p>The file article number at the SciLifeLab Figshare data repository.
By default, the iRfcb test dataset (48158716) from Torstensson et al. (2024) is used.</p>
</td></tr>
<tr><td><code id="ifcb_download_test_data_+3A_max_retries">max_retries</code></td>
<td>
<p>The maximum number of retry attempts in case of download failure. Default is 5.</p>
</td></tr>
<tr><td><code id="ifcb_download_test_data_+3A_sleep_time">sleep_time</code></td>
<td>
<p>The sleep time between download attempts, in seconds. Default is 10.</p>
</td></tr>
<tr><td><code id="ifcb_download_test_data_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function is called for its side effect of downloading, extracting, and organizing IFCB test data.
</p>


<h3>References</h3>

<p>Torstensson, Anders; Skjevik, Ann-Turi; Mohlin, Malin; Karlberg, Maria; Karlson, Bengt (2024). SMHI IFCB Plankton Image Reference Library. Version 3. SciLifeLab. Dataset.
<a href="https://doi.org/10.17044/scilifelab.25883455.v3">doi:10.17044/scilifelab.25883455.v3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Download and unzip IFCB test data into the "data" directory
ifcb_download_test_data("data")

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_extract_annotated_images'>Extract Annotated Images from IFCB Data</h2><span id='topic+ifcb_extract_annotated_images'></span>

<h3>Description</h3>

<p>This function extracts labeled images from IFCB (Imaging FlowCytobot) data,
annotated using the MATLAB code from the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
It reads manually classified data, maps class indices to class names, and extracts
the corresponding Region of Interest (ROI) images, saving them to the specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_extract_annotated_images(
  manual_folder,
  class2use_file,
  roi_folders,
  out_folder,
  skip_class = NA,
  verbose = TRUE,
  manual_recursive = FALSE,
  roi_recursive = TRUE,
  overwrite = FALSE,
  use_python = FALSE,
  roi_folder = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_extract_annotated_images_+3A_manual_folder">manual_folder</code></td>
<td>
<p>A character string specifying the path to the directory containing the manually classified .mat files.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_class2use_file">class2use_file</code></td>
<td>
<p>A character string specifying the path to the file containing class names.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_roi_folders">roi_folders</code></td>
<td>
<p>A character vector specifying one or more directories containing the ROI files.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_out_folder">out_folder</code></td>
<td>
<p>A character string specifying the output directory where the extracted images will be saved.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_skip_class">skip_class</code></td>
<td>
<p>A numeric vector of class IDs or a character vector of class names to be excluded from the count. Default is NULL.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_manual_recursive">manual_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for MATLAB files recursively within the <code>manual_folder</code>. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_roi_recursive">roi_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for data files recursively within the <code>roi_folder</code> (if provided). Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical value indicating whether to overwrite existing PNG files. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read the <code>.mat</code> file using a Python-based method. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_annotated_images_+3A_roi_folder">roi_folder</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Use <code>roi_folders</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_python = TRUE</code>, the function tries to read the <code>.mat</code> file using <code>ifcb_read_mat()</code>, which relies on <code>SciPy</code>.
This approach may be fasterthan the default approach using <code>R.matlab::readMat()</code>, especially for large <code>.mat</code> files.
To enable this functionality, ensure Python is properly configured with the required dependencies.
You can initialize the Python environment and install necessary packages using <code>ifcb_py_install()</code>.
</p>
<p>If <code>use_python = FALSE</code> or if <code>SciPy</code> is not available, the function falls back to using <code>R.matlab::readMat()</code>.
</p>


<h3>Value</h3>

<p>None. The function saves the extracted PNG images to the specified output directory.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_extract_pngs">ifcb_extract_pngs</a></code> <code><a href="#topic+ifcb_extract_classified_images">ifcb_extract_classified_images</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ifcb_extract_annotated_images(
  manual_folder = "path/to/manual_folder",
  class2use_file = "path/to/class2use_file.mat",
  roi_folders = "path/to/roi_folder",
  out_folder = "path/to/out_folder",
  skip_class = 1
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_extract_biovolumes'>Extract Biovolumes from IFCB Data and Compute Carbon Content</h2><span id='topic+ifcb_extract_biovolumes'></span>

<h3>Description</h3>

<p>This function reads biovolume data from feature files generated by the <code>ifcb-analysis</code> repository (Sosik and Olson 2007)
and matches them with corresponding classification results or manual annotations. It calculates biovolume in cubic micrometers and
determines if each class is a diatom based on the World Register of Marine Species (WoRMS). Carbon content
is computed for each region of interest (ROI) using conversion functions from Menden-Deuer and Lessard (2000),
depending on whether the class is identified as a diatom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_extract_biovolumes(
  feature_files,
  mat_folder = NULL,
  custom_images = NULL,
  custom_classes = NULL,
  class2use_file = NULL,
  micron_factor = 1/3.4,
  diatom_class = "Bacillariophyceae",
  marine_only = FALSE,
  threshold = "opt",
  multiblob = FALSE,
  feature_recursive = TRUE,
  mat_recursive = TRUE,
  use_python = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_extract_biovolumes_+3A_feature_files">feature_files</code></td>
<td>
<p>A path to a folder containing feature files or a character vector of file paths.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_mat_folder">mat_folder</code></td>
<td>
<p>(Optional) Path to the folder containing class or manual annotation files.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_custom_images">custom_images</code></td>
<td>
<p>(Optional) A character vector of image filenames in the format DYYYYMMDDTHHMMSS_IFCBXXX_ZZZZZ.png,
where &quot;XXX&quot; represents the IFCB number and &quot;ZZZZZ&quot; represents the ROI number.
These filenames should match the <code>roi_number</code> assignment in the <code>feature_files</code> and can be
used as a substitute for MATLAB files.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_custom_classes">custom_classes</code></td>
<td>
<p>(Optional) A character vector of corresponding class labels for <code>custom_images</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_class2use_file">class2use_file</code></td>
<td>
<p>A character string specifying the path to the file containing the <code>class2use</code> variable (default: NULL).</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_micron_factor">micron_factor</code></td>
<td>
<p>Conversion factor for biovolume to cubic micrometers. Default is <code>1 / 3.4</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_diatom_class">diatom_class</code></td>
<td>
<p>A character vector specifying diatom class names in WoRMS. Default: <code>"Bacillariophyceae"</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_marine_only">marine_only</code></td>
<td>
<p>Logical. If <code>TRUE</code>, restricts the WoRMS search to marine taxa only. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for selecting classification information (<code>"opt"</code> for above-threshold classification, otherwise <code>"all"</code>). Default: <code>"opt"</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_multiblob">multiblob</code></td>
<td>
<p>Logical. If <code>TRUE</code>, includes multiblob features. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_feature_recursive">feature_recursive</code></td>
<td>
<p>Logical. If <code>TRUE</code>, searches recursively for feature files when <code>feature_files</code> is a folder. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_mat_recursive">mat_recursive</code></td>
<td>
<p>Logical. If <code>TRUE</code>, searches recursively for MATLAB files in <code>mat_folder</code>. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read <code>.mat</code> files using a Python-based method (<code>SciPy</code>). Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_biovolumes_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If <code>TRUE</code>, prints progress messages. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><strong>Classification Data Handling:</strong>
</p>

<ul>
<li><p> If <code>mat_folder</code> is provided, the function reads class annotations from MATLAB <code>.mat</code> files.
</p>
</li>
<li><p> If <code>custom_images</code> and <code>custom_classes</code> are supplied, they override MATLAB classification data (e.g. data from a CNN model).
</p>
</li>
<li><p> If both <code>mat_folder</code> and <code>custom_images/custom_classes</code> are given, <code>mat_folder</code> takes precedence.
</p>
</li></ul>

</li>
<li> <p><strong>MAT File Processing:</strong>
</p>

<ul>
<li><p> If <code>use_python = TRUE</code>, the function reads <code>.mat</code> files using <code>ifcb_read_mat()</code> (requires Python + <code>SciPy</code>).
</p>
</li>
<li><p> Otherwise, it falls back to <code>R.matlab::readMat()</code>.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>A data frame containing:
</p>

<ul>
<li> <p><code>sample</code>: The sample name.
</p>
</li>
<li> <p><code>classifier</code>: The classifier used (if applicable).
</p>
</li>
<li> <p><code>roi_number</code>: The region of interest (ROI) number.
</p>
</li>
<li> <p><code>class</code>: The identified taxonomic class.
</p>
</li>
<li> <p><code>biovolume_um3</code>: Computed biovolume in cubic micrometers.
</p>
</li>
<li> <p><code>carbon_pg</code>: Estimated carbon content in picograms.
</p>
</li></ul>



<h3>References</h3>

<p>Menden-Deuer Susanne, Lessard Evelyn J., (2000), Carbon to volume relationships for dinoflagellates, diatoms, and other protist plankton, Limnology and Oceanography, 3, doi: 10.4319/lo.2000.45.3.0569.
</p>
<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_read_features">ifcb_read_features</a></code> <code><a href="#topic+ifcb_is_diatom">ifcb_is_diatom</a></code> <a href="https://www.marinespecies.org/">https://www.marinespecies.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Using MATLAB results:
feature_files &lt;- "data/features"
mat_folder &lt;- "data/classified"
biovolume_df &lt;- ifcb_extract_biovolumes(feature_files,
                                        mat_folder)
print(biovolume_df)

# Using custom classification result:
class = c("Mesodinium_rubrum",
          "Mesodinium_rubrum")
image &lt;- c("D20220522T003051_IFCB134_00002",
           "D20220522T003051_IFCB134_00003")
biovolume_df_custom &lt;- ifcb_extract_biovolumes(feature_files,
                                        custom_images = image,
                                        custom_classes = class)
print(biovolume_df_custom)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_extract_classified_images'>Extract Taxa Images from MATLAB Classified Sample</h2><span id='topic+ifcb_extract_classified_images'></span>

<h3>Description</h3>

<p>This function reads a MATLAB classified sample file (.mat) generated
by the <code>start_classify_batch_user_training</code> function from the <code>ifcb-analysis</code> repository (Sosik and Olson 2007),
extracts specified taxa images from the corresponding ROI files,
and saves each image in a specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_extract_classified_images(
  sample,
  classified_folder,
  roi_folder,
  out_folder,
  taxa = "All",
  threshold = "opt",
  overwrite = FALSE,
  use_python = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_extract_classified_images_+3A_sample">sample</code></td>
<td>
<p>A character string specifying the sample name.</p>
</td></tr>
<tr><td><code id="ifcb_extract_classified_images_+3A_classified_folder">classified_folder</code></td>
<td>
<p>A character string specifying the directory containing the classified files.</p>
</td></tr>
<tr><td><code id="ifcb_extract_classified_images_+3A_roi_folder">roi_folder</code></td>
<td>
<p>A character string specifying the directory containing the ROI files.</p>
</td></tr>
<tr><td><code id="ifcb_extract_classified_images_+3A_out_folder">out_folder</code></td>
<td>
<p>A character string specifying the directory to save the extracted images.</p>
</td></tr>
<tr><td><code id="ifcb_extract_classified_images_+3A_taxa">taxa</code></td>
<td>
<p>A character string specifying the taxa to extract. Default is &quot;All&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_extract_classified_images_+3A_threshold">threshold</code></td>
<td>
<p>A character string specifying the threshold to use (&quot;none&quot;, &quot;opt&quot;, &quot;adhoc&quot;). Default is &quot;opt&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_extract_classified_images_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical value indicating whether to overwrite existing PNG files. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_extract_classified_images_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read the <code>.mat</code> file using a Python-based method. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_extract_classified_images_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_python = TRUE</code>, the function tries to read the <code>.mat</code> file using <code>ifcb_read_mat()</code>, which relies on <code>SciPy</code>.
This approach may be faster than the default approach using <code>R.matlab::readMat()</code>, especially for large <code>.mat</code> files.
To enable this functionality, ensure Python is properly configured with the required dependencies.
You can initialize the Python environment and install necessary packages using <code>ifcb_py_install()</code>.
</p>
<p>If <code>use_python = FALSE</code> or if <code>SciPy</code> is not available, the function falls back to using <code>R.matlab::readMat()</code>.
</p>


<h3>Value</h3>

<p>No return value, called for side effects. Extracts and saves taxa images to a directory.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_extract_pngs">ifcb_extract_pngs</a></code> <code><a href="#topic+ifcb_extract_annotated_images">ifcb_extract_annotated_images</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Define the parameters
sample &lt;- "D20230311T092911_IFCB135"
classified_folder &lt;- "path/to/classified_folder"
roi_folder &lt;- "path/to/roi_folder"
out_folder &lt;- "path/to/outputdir"
taxa &lt;- "All"  # or specify a particular taxa
threshold &lt;- "opt"  # or specify another threshold

# Extract taxa images from the classified sample
ifcb_extract_classified_images(sample, classified_folder, roi_folder, out_folder, taxa, threshold)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_extract_pngs'>Extract Images from IFCB ROI File</h2><span id='topic+ifcb_extract_pngs'></span>

<h3>Description</h3>

<p>This function reads an IFCB (.roi) file and its corresponding .adc file, extracts regions of interest (ROIs),
and saves each ROI as a PNG image in a specified directory. Optionally, you can specify ROI numbers
to extract, useful for specific ROIs from manual or automatic classification results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_extract_pngs(
  roi_file,
  out_folder = dirname(roi_file),
  ROInumbers = NULL,
  taxaname = NULL,
  gamma = 1,
  verbose = TRUE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_extract_pngs_+3A_roi_file">roi_file</code></td>
<td>
<p>A character string specifying the path to the .roi file.</p>
</td></tr>
<tr><td><code id="ifcb_extract_pngs_+3A_out_folder">out_folder</code></td>
<td>
<p>A character string specifying the directory where the PNG images will be saved. Defaults to the directory of the ROI file.</p>
</td></tr>
<tr><td><code id="ifcb_extract_pngs_+3A_roinumbers">ROInumbers</code></td>
<td>
<p>An optional numeric vector specifying the ROI numbers to extract. If NULL, all ROIs with valid dimensions are extracted.</p>
</td></tr>
<tr><td><code id="ifcb_extract_pngs_+3A_taxaname">taxaname</code></td>
<td>
<p>An optional character string specifying the taxa name for organizing images into subdirectories. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="ifcb_extract_pngs_+3A_gamma">gamma</code></td>
<td>
<p>A numeric value for gamma correction applied to the image. Default is 1 (no correction). Values &lt;1 increase contrast in dark regions, while values &gt;1 decrease contrast.</p>
</td></tr>
<tr><td><code id="ifcb_extract_pngs_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_extract_pngs_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical value indicating whether to overwrite existing PNG files. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effects: it writes PNG images to a directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_extract_classified_images">ifcb_extract_classified_images</a></code> for extracting ROIs from automatic classification.
</p>
<p><code><a href="#topic+ifcb_extract_annotated_images">ifcb_extract_annotated_images</a></code> for extracting ROIs from manual annotation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Convert ROI file to PNG images
ifcb_extract_pngs("path/to/your_roi_file.roi")

# Extract specific ROI numbers from ROI file
ifcb_extract_pngs("path/to/your_roi_file.roi", "output_directory", ROInumbers = c(1, 2, 3))

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_get_ecotaxa_example'>Get Ecotaxa Column Names</h2><span id='topic+ifcb_get_ecotaxa_example'></span>

<h3>Description</h3>

<p>This function reads an example EcoTaxa metadata file included in the <code>iRfcb</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_get_ecotaxa_example(example = "ifcb")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_get_ecotaxa_example_+3A_example">example</code></td>
<td>
<p>A character string specifying which example EcoTaxa metadata file to load.
Options are:
</p>

<dl>
<dt>&quot;minimal&quot;</dt><dd><p>Loads a minimal example, for fully manual entry.</p>
</dd>
<dt>&quot;full_unknown&quot;</dt><dd><p>Loads a full featured example, with unknown objects only.</p>
</dd>
<dt>&quot;full_classified&quot;</dt><dd><p>Loads a full featured example, with already classified objects.</p>
</dd>
<dt>&quot;ifcb&quot;</dt><dd><p>(Default) Loads a full IFCB-specific dataset used for EcoTaxa submissions.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>This function loads different types of EcoTaxa metadata examples
based on the user's need. The examples include a minimal template for manual data entry,
as well as fully featured datasets with or without classified objects. The default is
an IFCB-specific example, originating from <a href="https://github.com/VirginieSonnet/IFCBdatabaseToEcotaxa">https://github.com/VirginieSonnet/IFCBdatabaseToEcotaxa</a>.
The example headers can used when submitting data from Imaging FlowCytobot (IFCB)
instruments to EcoTaxa at <a href="https://ecotaxa.obs-vlfr.fr/">https://ecotaxa.obs-vlfr.fr/</a>.
</p>


<h3>Value</h3>

<p>A data frame containing EcoTaxa example metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ecotaxa_example &lt;- ifcb_get_ecotaxa_example()

# Print the first five columns
dplyr::tibble(ecotaxa_example)
</code></pre>

<hr>
<h2 id='ifcb_get_ferrybox_data'>Retrieve Ferrybox Data for Specified Timestamps</h2><span id='topic+ifcb_get_ferrybox_data'></span>

<h3>Description</h3>

<p>This internal SMHI function reads <code>.txt</code> files from a specified folder containing Ferrybox data,
filters them based on a specified ship name (default is &quot;SveaFB&quot; for R/V Svea), and extracts
data (including GPS coordinates) for timestamps (rounded to the nearest minute) falling within the date ranges defined in the file names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_get_ferrybox_data(
  timestamps,
  ferrybox_folder,
  parameters = c("8002", "8003"),
  ship = "SveaFB",
  latitude_param = "8002",
  longitude_param = "8003"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_get_ferrybox_data_+3A_timestamps">timestamps</code></td>
<td>
<p>A vector of POSIXct timestamps for which GPS coordinates and associated parameter data are to be retrieved.</p>
</td></tr>
<tr><td><code id="ifcb_get_ferrybox_data_+3A_ferrybox_folder">ferrybox_folder</code></td>
<td>
<p>A string representing the path to the folder containing Ferrybox <code>.txt</code> files.</p>
</td></tr>
<tr><td><code id="ifcb_get_ferrybox_data_+3A_parameters">parameters</code></td>
<td>
<p>A character vector specifying the parameters to extract from the Ferrybox data. Defaults to <code>c("8002", "8003")</code>.</p>
</td></tr>
<tr><td><code id="ifcb_get_ferrybox_data_+3A_ship">ship</code></td>
<td>
<p>A string representing the name of the ship to filter Ferrybox files. The default is &quot;SveaFB&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_get_ferrybox_data_+3A_latitude_param">latitude_param</code></td>
<td>
<p>A string specifying the header name for the latitude column in the Ferrybox data. Default is &quot;8002&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_get_ferrybox_data_+3A_longitude_param">longitude_param</code></td>
<td>
<p>A string specifying the header name for the longitude column in the Ferrybox data. Default is &quot;8003&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts data from files whose names match the specified ship and fall within the date ranges defined in the file names. The columns corresponding to <code>latitude_param</code> and <code>longitude_param</code> will be renamed to <code>gpsLatitude</code> and <code>gpsLongitude</code>, respectively, if they are present in the <code>parameters</code> argument.
</p>
<p>The function also handles cases where the exact timestamp is missing by attempting to interpolate the data using floor and ceiling rounding methods. The final output will ensure that all specified parameters are numeric.
</p>


<h3>Value</h3>

<p>A data frame containing the input timestamps and corresponding data for the specified parameters.
Columns include 'timestamp', 'gpsLatitude', 'gpsLongitude' (if applicable), and the specified parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ferrybox_folder &lt;- "/path/to/ferrybox/data"
timestamps &lt;- as.POSIXct(c("2016-08-10 10:47:34 UTC",
                           "2016-08-10 11:12:21 UTC",
                           "2016-08-10 11:35:59 UTC"))

result &lt;- ifcb_get_ferrybox_data(timestamps, ferrybox_folder)
print(result)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_get_mat_names'>Get Variable Names from a MAT File</h2><span id='topic+ifcb_get_mat_names'></span>

<h3>Description</h3>

<p>This function reads a .mat file generated the <code>ifcb-analysis</code> repository (Sosik and Olson 2007) and retrieves the
names of all variables stored within it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_get_mat_names(mat_file, use_python = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_get_mat_names_+3A_mat_file">mat_file</code></td>
<td>
<p>A character string specifying the path to the .mat file.</p>
</td></tr>
<tr><td><code id="ifcb_get_mat_names_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read the <code>.mat</code> file using a Python-based method. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_python = TRUE</code>, the function tries to read the <code>.mat</code> file using <code>ifcb_read_mat()</code>, which relies on <code>SciPy</code>.
This approach may be faster than the default approach using <code>R.matlab::readMat()</code>, especially for large <code>.mat</code> files.
To enable this functionality, ensure Python is properly configured with the required dependencies.
You can initialize the Python environment and install necessary packages using <code>ifcb_py_install()</code>.
</p>
<p>If <code>use_python = FALSE</code> or if <code>SciPy</code> is not available, the function falls back to using <code>R.matlab::readMat()</code>.
</p>


<h3>Value</h3>

<p>A character vector of variable names.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_get_mat_variable">ifcb_get_mat_variable</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Get variable names from a MAT file
variables &lt;- ifcb_get_mat_names("path/to/file.mat")
print(variables)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_get_mat_variable'>Get Classes from a MAT File</h2><span id='topic+ifcb_get_mat_variable'></span>

<h3>Description</h3>

<p>This function reads a specified variable from a .mat file generated by the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
It can be used, for example, to extract lists of classes from the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_get_mat_variable(
  mat_file,
  variable_name = "class2use",
  use_python = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_get_mat_variable_+3A_mat_file">mat_file</code></td>
<td>
<p>A character string specifying the path to the .mat file containing the class information.</p>
</td></tr>
<tr><td><code id="ifcb_get_mat_variable_+3A_variable_name">variable_name</code></td>
<td>
<p>A character string specifying the variable name in the .mat file that contains the class information.
The default is &quot;class2use&quot;. Other examples include &quot;class2use_manual&quot; from a manual file, or &quot;class2use_auto&quot;
for a class list used for automatic assignment. You can find available variable names using the function <code><a href="#topic+ifcb_get_mat_names">ifcb_get_mat_names</a></code>.</p>
</td></tr>
<tr><td><code id="ifcb_get_mat_variable_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read the <code>.mat</code> file using a Python-based method. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_python = TRUE</code>, the function tries to read the <code>.mat</code> file using <code>ifcb_read_mat()</code>, which relies on <code>SciPy</code>.
This approach may be faster than the default approach using <code>R.matlab::readMat()</code>, especially for large <code>.mat</code> files.
To enable this functionality, ensure Python is properly configured with the required dependencies.
You can initialize the Python environment and install necessary packages using <code>ifcb_py_install()</code>.
</p>
<p>If <code>use_python = FALSE</code> or if <code>SciPy</code> is not available, the function falls back to using <code>R.matlab::readMat()</code>.
</p>


<h3>Value</h3>

<p>A character vector of class names.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_get_mat_names">ifcb_get_mat_names</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Get class names from a class2use file
classes &lt;- ifcb_get_mat_variable("path/to/class2use.mat", "class2use")
print(classes)

# Get class names from a classifier file
class2useTB &lt;- ifcb_get_mat_variable("path/to/classified/sample.mat", "class2useTB")
print(class2useTB)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_get_runtime'>Read IFCB Header File and Extract Runtime Information</h2><span id='topic+ifcb_get_runtime'></span>

<h3>Description</h3>

<p>This function imports an IFCB header file (either from a local path or URL),
extracts specific target values such as runtime and inhibittime,
and returns them in a structured format (in seconds). This is
the R equivalent function of <code>IFCBxxx_readhdr</code> from the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_get_runtime(hdr_file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_get_runtime_+3A_hdr_file">hdr_file</code></td>
<td>
<p>A character string specifying the full path to the .hdr file or URL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (hdr) containing runtime, inhibittime, and runType (if available) extracted from the header file.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example: Read and extract information from an IFCB header file
hdr_info &lt;- ifcb_get_runtime("path/to/IFCB_hdr_file.hdr")
print(hdr_info)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_get_shark_colnames'>Get Shark Column Names</h2><span id='topic+ifcb_get_shark_colnames'></span>

<h3>Description</h3>

<p>This function reads SHARK column names from a specified tab-separated values (TSV) file included in the package.
These columns are used for submitting IFCB data to <a href="https://shark.smhi.se/">https://shark.smhi.se/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_get_shark_colnames(minimal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_get_shark_colnames_+3A_minimal">minimal</code></td>
<td>
<p>A logical value indicating whether to load only the minimal set of column names required for data submission to SHARK. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed example of a data submission, see <code><a href="#topic+ifcb_get_shark_example">ifcb_get_shark_example</a></code>.
</p>


<h3>Value</h3>

<p>An empty data frame containing the SHARK column names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_get_shark_example">ifcb_get_shark_example</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shark_colnames &lt;- ifcb_get_shark_colnames()
print(shark_colnames)

shark_colnames_minimal &lt;- ifcb_get_shark_colnames(minimal = TRUE)
print(shark_colnames_minimal)
</code></pre>

<hr>
<h2 id='ifcb_get_shark_example'>Get Shark Column Example</h2><span id='topic+ifcb_get_shark_example'></span>

<h3>Description</h3>

<p>This function reads a SHARK submission example from a file included in the package.
This format is used for submitting IFCB data to <a href="https://shark.smhi.se/">https://shark.smhi.se/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_get_shark_example()
</code></pre>


<h3>Value</h3>

<p>A data frame containing example data following the SHARK submission format.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_get_shark_colnames">ifcb_get_shark_colnames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>shark_example &lt;- ifcb_get_shark_example()

# Print example as tibble
dplyr::tibble(shark_example)
</code></pre>

<hr>
<h2 id='ifcb_get_trophic_type'>Get Trophic Type for a List of Plankton Taxa</h2><span id='topic+ifcb_get_trophic_type'></span>

<h3>Description</h3>

<p>This function matches a specified list of taxa with a summarized list of trophic types
for various plankton taxa from Northern Europe (data sourced from <code style="white-space: pre;">&#8288;SMHI Trophic Type&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_get_trophic_type(taxa_list = NULL, print_complete_list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_get_trophic_type_+3A_taxa_list">taxa_list</code></td>
<td>
<p>A character vector of scientific names for which trophic types are to be retrieved.</p>
</td></tr>
<tr><td><code id="ifcb_get_trophic_type_+3A_print_complete_list">print_complete_list</code></td>
<td>
<p>Logical, if TRUE, prints the complete list of summarized trophic types.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are multiple trophic types for a scientific name (i.e. AU and HT size classes),
the summarized trophic type is &quot;NS&quot;.
</p>


<h3>Value</h3>

<p>A character vector of trophic types corresponding to the scientific names in <code>taxa_list</code>,
or a data frame containing all taxa and trophic types available in the <code style="white-space: pre;">&#8288;SMHI Trophic Type&#8288;</code> list.
The available trophic types are autotrophic (AU), heterotrophic (HT), mixotrophic (MX) or not specified (NS).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
taxa_list &lt;- c("Acanthoceras zachariasii",
               "Nodularia spumigena",
               "Acanthoica quattrospina",
               "Noctiluca",
               "Gymnodiniales")

ifcb_get_trophic_type(taxa_list)

</code></pre>

<hr>
<h2 id='ifcb_is_diatom'>Identify Diatoms in Taxa List</h2><span id='topic+ifcb_is_diatom'></span>

<h3>Description</h3>

<p>This function takes a list of taxa names, cleans them, retrieves their
corresponding classification records from the World Register of Marine Species (WoRMS),
and checks if they belong to the specified diatom class. The function only uses the
first name (genus name) of each taxa for classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_is_diatom(
  taxa_list,
  diatom_class = "Bacillariophyceae",
  max_retries = 3,
  sleep_time = 10,
  marine_only = FALSE,
  fuzzy = deprecated(),
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_is_diatom_+3A_taxa_list">taxa_list</code></td>
<td>
<p>A character vector containing the list of taxa names.</p>
</td></tr>
<tr><td><code id="ifcb_is_diatom_+3A_diatom_class">diatom_class</code></td>
<td>
<p>A character string or vector specifying the class name(s) to be identified as diatoms, according to WoRMS.
Default is &quot;Bacillariophyceae&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_is_diatom_+3A_max_retries">max_retries</code></td>
<td>
<p>An integer specifying the maximum number of attempts to retrieve WoRMS records in case of an error.
Default is 3.</p>
</td></tr>
<tr><td><code id="ifcb_is_diatom_+3A_sleep_time">sleep_time</code></td>
<td>
<p>A numeric value indicating the number of seconds to wait between retry attempts.
Default is 10 seconds.</p>
</td></tr>
<tr><td><code id="ifcb_is_diatom_+3A_marine_only">marine_only</code></td>
<td>
<p>Logical. If TRUE, restricts the search to marine taxa only. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_is_diatom_+3A_fuzzy">fuzzy</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
The fuzzy argument is no longer available</p>
</td></tr>
<tr><td><code id="ifcb_is_diatom_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector indicating whether each cleaned taxa name belongs to the specified diatom class.
</p>


<h3>See Also</h3>

<p><a href="https://www.marinespecies.org/">https://www.marinespecies.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
taxa_list &lt;- c("Nitzschia_sp", "Chaetoceros_sp", "Dinophysis_norvegica", "Thalassiosira_sp")
ifcb_is_diatom(taxa_list)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_is_in_basin'>Check if Points are in a Specific Sea Basin</h2><span id='topic+ifcb_is_in_basin'></span>

<h3>Description</h3>

<p>This function checks if vectors of latitude and longitude points are within a user-supplied sea basin.
The Baltic Sea basins are included as a pre-packaged shapefile in the <code>iRfcb</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_is_in_basin(latitudes, longitudes, plot = FALSE, shape_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_is_in_basin_+3A_latitudes">latitudes</code></td>
<td>
<p>A numeric vector of latitude points.</p>
</td></tr>
<tr><td><code id="ifcb_is_in_basin_+3A_longitudes">longitudes</code></td>
<td>
<p>A numeric vector of longitude points.</p>
</td></tr>
<tr><td><code id="ifcb_is_in_basin_+3A_plot">plot</code></td>
<td>
<p>A boolean indicating whether to plot the points and the sea basin. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_is_in_basin_+3A_shape_file">shape_file</code></td>
<td>
<p>The absolute path to a custom polygon shapefile in WGS84 (EPSG:4326) that represents the specific sea basin.
Default is a land-buffered shapefile of the Baltic Sea basins, included in the <code>iRfcb</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads a pre-packaged shapefile of the Baltic Sea Basin from the <code>iRfcb</code> package by default, or a user-supplied
shapefile if provided. It sets the CRS, transforms the CRS to WGS84 (EPSG:4326) if necessary, and checks if the given points
fall within the specified sea basin. Optionally, it plots the points and the sea basin polygons together.
</p>


<h3>Value</h3>

<p>A logical vector indicating whether each point is within the specified sea basin, or a plot with the points and basins if <code>plot = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define example latitude and longitude vectors
latitudes &lt;- c(55.337, 54.729, 56.311, 57.975)
longitudes &lt;- c(12.674, 14.643, 12.237, 10.637)

# Check if the points are in the Baltic Sea Basin
points_in_the_baltic &lt;- ifcb_is_in_basin(latitudes, longitudes)
print(points_in_the_baltic)

# Plot the points and the basin
ifcb_is_in_basin(latitudes, longitudes, plot = TRUE)

</code></pre>

<hr>
<h2 id='ifcb_is_near_land'>Determine if Positions are Near Land</h2><span id='topic+ifcb_is_near_land'></span>

<h3>Description</h3>

<p>Determines whether given positions are near land based on a coastline shape file.
The Natural Earth 1:10m land vectors are included as default shapefile in <code>iRfcb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_is_near_land(
  latitudes,
  longitudes,
  distance = 500,
  shape = NULL,
  crs = 4326,
  utm_zone = 33,
  remove_small_islands = TRUE,
  small_island_threshold = 2e+06
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_is_near_land_+3A_latitudes">latitudes</code></td>
<td>
<p>Numeric vector of latitudes for positions.</p>
</td></tr>
<tr><td><code id="ifcb_is_near_land_+3A_longitudes">longitudes</code></td>
<td>
<p>Numeric vector of longitudes for positions.</p>
</td></tr>
<tr><td><code id="ifcb_is_near_land_+3A_distance">distance</code></td>
<td>
<p>Buffer distance in meters around the coastline. Default is 500 m.</p>
</td></tr>
<tr><td><code id="ifcb_is_near_land_+3A_shape">shape</code></td>
<td>
<p>Optional path to a shapefile containing coastline data. If provided,
the function will use this shapefile instead of the default Natural Earth 1:10m land vectors.
Using a more detailed shapefile allows for a smaller buffer distance.
For detailed European coastlines, download polygons from the EEA at
<a href="https://www.eea.europa.eu/data-and-maps/data/eea-coastline-for-analysis-2/gis-data/eea-coastline-polygon">https://www.eea.europa.eu/data-and-maps/data/eea-coastline-for-analysis-2/gis-data/eea-coastline-polygon</a>.
For more detailed world maps, download from Natural Earth at
<a href="https://www.naturalearthdata.com/downloads/10m-physical-vectors/">https://www.naturalearthdata.com/downloads/10m-physical-vectors/</a>.</p>
</td></tr>
<tr><td><code id="ifcb_is_near_land_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system (CRS) to use for positions and output.
Default is EPSG code 4326 (WGS84).</p>
</td></tr>
<tr><td><code id="ifcb_is_near_land_+3A_utm_zone">utm_zone</code></td>
<td>
<p>UTM zone for buffering the coastline. Default is 33 (between 12Â°E and 18Â°E, northern hemisphere).</p>
</td></tr>
<tr><td><code id="ifcb_is_near_land_+3A_remove_small_islands">remove_small_islands</code></td>
<td>
<p>Logical indicating whether to remove small islands from
the coastline if a custom shapefile is provided. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_is_near_land_+3A_small_island_threshold">small_island_threshold</code></td>
<td>
<p>Area threshold in square meters below which islands
will be considered small and removed, if remove_small_islands is set to TRUE. Default is 2 sqkm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates a buffered area around the coastline and checks if
given positions (specified by longitudes and latitudes) are within this buffer
or intersect with land.
</p>


<h3>Value</h3>

<p>Logical vector indicating whether each position is near land.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define coordinates
latitudes &lt;- c(62.500353, 58.964498, 57.638725, 56.575338)
longitudes &lt;- c(17.845993, 20.394418, 18.284523, 16.227174)

# Call the function
near_land &lt;- ifcb_is_near_land(latitudes, longitudes, distance = 300, crs = 4326)

# Print the result
print(near_land)

</code></pre>

<hr>
<h2 id='ifcb_match_taxa_names'>Retrieve WoRMS Records with Retry Mechanism</h2><span id='topic+ifcb_match_taxa_names'></span>

<h3>Description</h3>

<p>This function attempts to retrieve WoRMS records using the provided taxa names.
It retries the operation if an error occurs, up to a specified number of attempts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_match_taxa_names(
  taxa_names,
  best_match_only = TRUE,
  max_retries = 3,
  sleep_time = 10,
  marine_only = FALSE,
  return_list = FALSE,
  verbose = TRUE,
  fuzzy = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_match_taxa_names_+3A_taxa_names">taxa_names</code></td>
<td>
<p>A character vector of taxa names to retrieve records for.</p>
</td></tr>
<tr><td><code id="ifcb_match_taxa_names_+3A_best_match_only">best_match_only</code></td>
<td>
<p>A logical value indicating whether to automatically select the first match and return a single match. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_match_taxa_names_+3A_max_retries">max_retries</code></td>
<td>
<p>An integer specifying the maximum number of attempts to retrieve records.</p>
</td></tr>
<tr><td><code id="ifcb_match_taxa_names_+3A_sleep_time">sleep_time</code></td>
<td>
<p>A numeric value indicating the number of seconds to wait between retry attempts.</p>
</td></tr>
<tr><td><code id="ifcb_match_taxa_names_+3A_marine_only">marine_only</code></td>
<td>
<p>Logical. If TRUE, restricts the search to marine taxa only. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_match_taxa_names_+3A_return_list">return_list</code></td>
<td>
<p>A logical value indicating whether to to return the output as a list. Default is FALSE, where the result is returned as a dataframe.</p>
</td></tr>
<tr><td><code id="ifcb_match_taxa_names_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_match_taxa_names_+3A_fuzzy">fuzzy</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
The fuzzy argument is no longer available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame (or list if return_list is TRUE) of WoRMS records or NULL if the retrieval fails after the maximum number of attempts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example: Retrieve WoRMS records for a list of taxa names
taxa &lt;- c("Calanus finmarchicus", "Thalassiosira pseudonana", "Phaeodactylum tricornutum")
records &lt;- ifcb_match_taxa_names(taxa_names = taxa,
                                 max_retries = 3,
                                 sleep_time = 5,
                                 marine_only = TRUE,
                                 verbose = TRUE)

print(records)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_merge_manual'>Merge IFCB Manual Classification Data</h2><span id='topic+ifcb_merge_manual'></span>

<h3>Description</h3>

<p>This function merges two sets of manual classification data by combining
and aligning class labels from a base set and an additional set of classifications.
The merged <code>.mat</code> data can be used with the code in the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_merge_manual(
  class2use_file_base,
  class2use_file_additions,
  class2use_file_output = NULL,
  manual_folder_base,
  manual_folder_additions,
  manual_folder_output,
  do_compression = TRUE,
  temp_index_offset = 50000,
  skip_class = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_merge_manual_+3A_class2use_file_base">class2use_file_base</code></td>
<td>
<p>Character. Path to the <code>class2use</code> file of the base manual classifications.
The base set contains the original manual classifications list that form the foundation for merging.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_class2use_file_additions">class2use_file_additions</code></td>
<td>
<p>Character. Path to the <code>class2use</code> file of the additions manual classifications.
The additions set contains additional classifications that need to be merged with the base set.
Class labels from the <code>class2use_file_additions</code> that are not already included in the <code>class2use_file_base</code> will be added to generate the <code>class2use_file_output</code>.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_class2use_file_output">class2use_file_output</code></td>
<td>
<p>Character. Path where the merged <code>class2use</code> file will be saved.
If <code>NULL</code>, the merged file will be stored in the same directory as <code>class2use_file_base</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_manual_folder_base">manual_folder_base</code></td>
<td>
<p>Character. Path to the folder containing the base set of manual classification <code>.mat</code> files.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_manual_folder_additions">manual_folder_additions</code></td>
<td>
<p>Character. Path to the folder containing the additions set of manual classification <code>.mat</code> files.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_manual_folder_output">manual_folder_output</code></td>
<td>
<p>Character. Path to the output folder where the merged classification files will be stored.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_do_compression">do_compression</code></td>
<td>
<p>A logical value indicating whether to compress the <code>.mat</code> file. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_temp_index_offset">temp_index_offset</code></td>
<td>
<p>Numeric. A large integer used to generate temporary indices during the merge process. Default is 50000.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_skip_class">skip_class</code></td>
<td>
<p>Character. A vector of class names to skip from the <code>class2use_file_additions</code> during the merge process. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="ifcb_merge_manual_+3A_quiet">quiet</code></td>
<td>
<p>Logical. If <code>TRUE</code>, suppresses output messages. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a python interpreter to be installed. The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
</p>
<p>The <strong>base</strong> set consists of the original classifications that are used as a reference for the merging process.
The <strong>additions</strong> set contains the additional classifications that need to be merged with the base set.
When merging, unique class names from the additions set that are not present in the base set are appended.
</p>
<p>The function works by aligning the class labels from the additions set with those in the base set,
handling conflicts by using a temporary index system. It copies <code>.mat</code> files from both the base and
additions folders into the output folder, while adjusting indices and and class names for the additions.
</p>
<p>Note that the maximum limit for <code>uint16</code> is 65,535, so ensure that <code>temp_index_offset</code> remains below this value.
</p>


<h3>Value</h3>

<p>No return value. Outputs the combined <code>class2use</code> file in the same folder as <code>class2use_file_base</code> is located or at a user-specified location,
and merged <code>.mat</code> files into the output folder.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_py_install">ifcb_py_install</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ifcb_merge_manual("path/to/class2use_base.mat", "path/to/class2use_additions.mat",
                  "path/to/class2use_combined.mat", "path/to/manual/base_folder",
                  "path/to/manual/additions_folder", "path/to/manual/output_folder",
                  do_compression = TRUE, temp_index_offset = 50000, quiet = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_psd'>Plot and Save IFCB PSD Data</h2><span id='topic+ifcb_psd'></span>

<h3>Description</h3>

<p>This function generates and saves data about a dataset's Particle Size Distribution (PSD) from Imaging FlowCytobot (IFCB)
feature and hdr files, which can be used for data quality assurance and quality control.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_psd(
  feature_folder,
  hdr_folder,
  save_data = FALSE,
  output_file = NULL,
  plot_folder = NULL,
  use_marker = FALSE,
  start_fit = 10,
  r_sqr = 0.5,
  beads = NULL,
  bubbles = NULL,
  incomplete = NULL,
  missing_cells = NULL,
  biomass = NULL,
  bloom = NULL,
  humidity = NULL,
  micron_factor = 1/3.4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_psd_+3A_feature_folder">feature_folder</code></td>
<td>
<p>The absolute path to a directory containing all of the v2 feature files for the dataset.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_hdr_folder">hdr_folder</code></td>
<td>
<p>The absolute path to a directory containing all of the hdr files for the dataset.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_save_data">save_data</code></td>
<td>
<p>A boolean indicating whether to save data to CSV files. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_output_file">output_file</code></td>
<td>
<p>A string with the base file name for the .csv to use (including path). Set to NULL to not save data (default).</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_plot_folder">plot_folder</code></td>
<td>
<p>The folder where graph images for each file will be saved. Set to NULL to not save graphs (default).</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_use_marker">use_marker</code></td>
<td>
<p>A boolean indicating whether to show markers on the plot. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_start_fit">start_fit</code></td>
<td>
<p>An integer indicating the start fit value for the plot. Default is 10.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_r_sqr">r_sqr</code></td>
<td>
<p>The lower limit of acceptable R^2 values (any curves below it will be flagged). Default is 0.5.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_beads">beads</code></td>
<td>
<p>The maximum multiplier for the curve fit. Any files with higher curve fit multipliers will be flagged as bead runs. If this argument is included, files with &quot;runBeads&quot; marked as TRUE in the header file will also be flagged as a bead run. Optional.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_bubbles">bubbles</code></td>
<td>
<p>The minimum difference between the starting ESD and the ESD with the most targets.  Any files with a difference higher than this threshold will be flagged as mostly bubbles. Optional.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_incomplete">incomplete</code></td>
<td>
<p>A tuple with the minimum volume of cells (in c/L) and the minimum mL analyzed for a complete run. Any files with values below these thresholds will be flagged as incomplete. Optional.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_missing_cells">missing_cells</code></td>
<td>
<p>The minimum image count to trigger count ratio. Any files with lower ratios will be flagged as missing cells. Optional.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_biomass">biomass</code></td>
<td>
<p>The minimum number of targets in the most populated ESD bin for any given run. Any files with fewer targets will be flagged as having low biomass. Optional.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_bloom">bloom</code></td>
<td>
<p>The minimum difference between the starting ESD and the ESD with the most targets. Any files with a difference less than this threshold will be flagged as a bloom. Will likely be lower than the bubbles threshold. Optional.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_humidity">humidity</code></td>
<td>
<p>The maximum percent humidity. Any files with higher values will be flagged as high humidity. Optional.</p>
</td></tr>
<tr><td><code id="ifcb_psd_+3A_micron_factor">micron_factor</code></td>
<td>
<p>The conversion factor to microns. Default is 1/3.4.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PSD function originates from the <code>PSD</code> python repository (Hayashi et al. in prep), which can be found at <a href="https://github.com/kudelalab/PSD">https://github.com/kudelalab/PSD</a>.
This function requires a python interpreter to be installed. The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
The function requires v2 features generated by the <code>ifcb-analysis</code> MATLAB package (Sosik and Olson 2007) found at <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>.
</p>


<h3>Value</h3>

<p>A list with data, fits, and flags DataFrames if <code>save_data</code> is FALSE; otherwise, NULL.
</p>


<h3>References</h3>

<p>Hayashi, K., Walton, J., Lie, A., Smith, J. and Kudela M. Using particle size distribution (PSD) to automate imaging flow cytobot (IFCB) data quality in coastal California, USA. In prep.
Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_py_install">ifcb_py_install</a></code> <a href="https://github.com/kudelalab/PSD">https://github.com/kudelalab/PSD</a> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize the python session if not already set up
ifcb_py_install()

ifcb_psd(
  feature_folder = 'path/to/features',
  hdr_folder = 'path/to/hdr_data',
  save_data = TRUE,
  output_file = 'psd/svea_2021',
  plot_folder = 'psd/plots',
  use_marker = FALSE,
  start_fit = 13,
  r_sqr = 0.5,
  beads = 10 ** 9,
  bubbles = 150,
  incomplete = c(1500, 3),
  missing_cells = 0.7,
  biomass = 1000,
  bloom = 5,
  humidity = NULL,
  micron_factor = 1/3.0
)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_psd_plot'>Generate PSD Plot for a Given Sample</h2><span id='topic+ifcb_psd_plot'></span>

<h3>Description</h3>

<p>This function generates a plot for a given sample from Particle Size Distribution (PSD) data and fits from Imaging FlowCytobot (IFCB).
The PSD data and fits can be generated by <code>ifcb_psd</code> (Hayashi et al. in prep).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_psd_plot(sample_name, data, fits, start_fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_psd_plot_+3A_sample_name">sample_name</code></td>
<td>
<p>The name of the sample to plot in DYYYYMMDDTHHMMSS.</p>
</td></tr>
<tr><td><code id="ifcb_psd_plot_+3A_data">data</code></td>
<td>
<p>A data frame containing the PSD data (data output from <code>ifcb_psd</code>), where each row represents a sample and each column represents different particle sizes in micrometers.</p>
</td></tr>
<tr><td><code id="ifcb_psd_plot_+3A_fits">fits</code></td>
<td>
<p>A data frame containing the fit parameters for the power curve (fits output from <code>ifcb_psd</code>), where each row represents a sample and the columns include the parameters <code>a</code>, <code>k</code>, and <code>R2</code>.</p>
</td></tr>
<tr><td><code id="ifcb_psd_plot_+3A_start_fit">start_fit</code></td>
<td>
<p>The x-value threshold below which data should be excluded from the plot and fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the PSD plot for the sample.
</p>


<h3>References</h3>

<p>Hayashi, K., Walton, J., Lie, A., Smith, J. and Kudela M. Using particle size distribution (PSD) to automate imaging flow cytobot (IFCB) data quality in coastal California, USA. In prep.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_psd">ifcb_psd</a></code> <a href="https://github.com/kudelalab/PSD">https://github.com/kudelalab/PSD</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Analyze PSD
psd &lt;- ifcb_psd(feature_folder = 'path/to/features',
                hdr_folder = 'path/to/hdr_data',
                save_data = TRUE,
                output_file = 'psd/svea_2021',
                plot_folder = NULL,
                use_marker = FALSE,
                start_fit = 13,
                r_sqr = 0.5,
                beads = 10 ** 9,
                bubbles = 150,
                incomplete = c(1500, 3),
                missing_cells = 0.7,
                biomass = 1000,
                bloom = 5,
                humidity = NULL)

# Plot PSD of the first sample
plot &lt;- ifcb_psd_plot(sample_name = "D20230316T101514",
                      data = psd$data,
                      fits = psd$fits,
                      start_fit = 10)
# Inspect plot
print(plot)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_py_install'>Install iRfcb Python Environment</h2><span id='topic+ifcb_py_install'></span>

<h3>Description</h3>

<p>This function sets up the Python environment for <code>iRfcb</code>. By default, it creates and activates a Python virtual environment (<code>venv</code>) named &quot;iRfcb&quot; and installs the required Python packages from the &quot;requirements.txt&quot; file.
Alternatively, users can opt to use the system Python instead of creating a virtual environment by setting <code>use_venv = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_py_install(
  envname = ".virtualenvs/iRfcb",
  use_venv = TRUE,
  packages = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_py_install_+3A_envname">envname</code></td>
<td>
<p>A character string specifying the name of the virtual environment to create. Default is &quot;.virtualenvs/iRfcb&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_py_install_+3A_use_venv">use_venv</code></td>
<td>
<p>Logical. If <code>TRUE</code> (default), a virtual environment is created. If <code>FALSE</code>, the system Python is used instead, and missing packages are installed globally for the user.</p>
</td></tr>
<tr><td><code id="ifcb_py_install_+3A_packages">packages</code></td>
<td>
<p>A character vector of additional Python packages to install. If NULL (default), only the packages from &quot;requirements.txt&quot; are installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. This function is called for its side effect of configuring the Python environment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Install the iRfcb Python environment using a virtual environment (default)
ifcb_py_install()

# Install the iRfcb Python environment with additional packages
ifcb_py_install(packages = c("numpy", "plotly"))

# Use system Python instead of a virtual environment
ifcb_py_install(use_venv = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_read_features'>Read Feature Files from a Specified Folder or File Paths</h2><span id='topic+ifcb_read_features'></span>

<h3>Description</h3>

<p>This function reads feature files from a given folder or a specified set of file paths,
optionally filtering them based on whether they are multiblob or single blob files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_read_features(feature_files = NULL, multiblob = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_read_features_+3A_feature_files">feature_files</code></td>
<td>
<p>A path to a folder containing feature files or a character vector of file paths.</p>
</td></tr>
<tr><td><code id="ifcb_read_features_+3A_multiblob">multiblob</code></td>
<td>
<p>Logical indicating whether to filter for multiblob files (default: FALSE).</p>
</td></tr>
<tr><td><code id="ifcb_read_features_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to display progress information. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of data frames, where each element corresponds to a feature file read from <code>feature_files</code>.
The list is named with the base names of the feature files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Read feature files from a folder
features &lt;- ifcb_read_features("path/to/feature_folder")

# Read only multiblob feature files
multiblob_features &lt;- ifcb_read_features("path/to/feature_folder", multiblob = TRUE)

# Read feature files from a list of file paths
features &lt;- ifcb_read_features(c("path/to/file1.csv", "path/to/file2.csv"))

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_read_hdr_data'>Reads HDR Data from IFCB HDR Files</h2><span id='topic+ifcb_read_hdr_data'></span>

<h3>Description</h3>

<p>This function reads all IFCB instrument settings information files (.hdr) from a specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_read_hdr_data(
  hdr_files,
  gps_only = FALSE,
  verbose = TRUE,
  hdr_folder = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_read_hdr_data_+3A_hdr_files">hdr_files</code></td>
<td>
<p>A character string specifying the path to feature files or a folder path.</p>
</td></tr>
<tr><td><code id="ifcb_read_hdr_data_+3A_gps_only">gps_only</code></td>
<td>
<p>A logical value indicating whether to include only GPS information (latitude and longitude). Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_read_hdr_data_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_read_hdr_data_+3A_hdr_folder">hdr_folder</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Use <code>hdr_files</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with sample names, GPS latitude, GPS longitude, and optionally timestamps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Extract all HDR data
hdr_data &lt;- ifcb_read_hdr_data("path/to/data")
print(hdr_data)

# Extract only GPS data
gps_data &lt;- ifcb_read_hdr_data("path/to/data", gps_only = TRUE)
print(gps_data)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_read_mat'>Read a MATLAB .mat File in R</h2><span id='topic+ifcb_read_mat'></span>

<h3>Description</h3>

<p>This function reads a MATLAB .mat file using a Python function via <code>reticulate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_read_mat(file_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_read_mat_+3A_file_path">file_path</code></td>
<td>
<p>A character string representing the full path to the .mat file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a Python interpreter with <code>SciPy</code> installed.
</p>
<p>This function requires a python interpreter to be installed.
The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
</p>


<h3>Value</h3>

<p>A list containing the MATLAB variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_py_install">ifcb_py_install</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- read_mat_file_r("C:/data/sample.mat")

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_read_summary'>Read and Summarize Classified IFCB Data</h2><span id='topic+ifcb_read_summary'></span>

<h3>Description</h3>

<p>This function reads a MATLAB .mat file containing aggregated and classified IFCB (Imaging FlowCytobot)
data generated by the <code>countcells_allTBnew_user_training</code> function from the <code>ifcb-analysis</code> repository (Sosik and Olson 2007),
or a list of classified data generated by <code>ifcb_summarize_class_counts</code>.
It returns a data frame with species counts and optionally biovolume information based on specified thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_read_summary(
  summary,
  hdr_directory = NULL,
  biovolume = FALSE,
  threshold = "opt",
  use_python = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_read_summary_+3A_summary">summary</code></td>
<td>
<p>A character string specifying the path to the .mat summary file or a list generated by <code>ifcb_summarize_class_counts</code>.</p>
</td></tr>
<tr><td><code id="ifcb_read_summary_+3A_hdr_directory">hdr_directory</code></td>
<td>
<p>A character string specifying the path to the directory containing header (.hdr) files. Default is NULL.</p>
</td></tr>
<tr><td><code id="ifcb_read_summary_+3A_biovolume">biovolume</code></td>
<td>
<p>A logical indicating whether the file contains biovolume data. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_read_summary_+3A_threshold">threshold</code></td>
<td>
<p>A character string specifying the threshold type for counts and biovolume. Options are &quot;opt&quot; (default), &quot;adhoc&quot;, and &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_read_summary_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read the <code>.mat</code> file using a Python-based method. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_python = TRUE</code>, the function tries to read the <code>.mat</code> file using <code>ifcb_read_mat()</code>, which relies on <code>SciPy</code>.
This approach may be faster than the default approach using <code>R.matlab::readMat()</code>, especially for large <code>.mat</code> files.
To enable this functionality, ensure Python is properly configured with the required dependencies.
You can initialize the Python environment and install necessary packages using <code>ifcb_py_install()</code>.
</p>
<p>If <code>use_python = FALSE</code> or if <code>SciPy</code> is not available, the function falls back to using <code>R.matlab::readMat()</code>.
</p>


<h3>Value</h3>

<p>A data frame containing the summary information including file list, volume analyzed, species counts, optionally biovolume, and other metadata.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summary_data &lt;- ifcb_read_summary("path/to/summary_file.mat", biovolume = TRUE, threshold = "opt")
print(summary_data)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_replace_mat_values'>Replace Values in MATLAB Classlist</h2><span id='topic+ifcb_replace_mat_values'></span>

<h3>Description</h3>

<p>This function replaces a target class ID with a new ID in MATLAB classlist files,
generated by the code in the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_replace_mat_values(
  manual_folder,
  out_folder,
  target_id,
  new_id,
  column_index = 1,
  do_compression = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_replace_mat_values_+3A_manual_folder">manual_folder</code></td>
<td>
<p>A character string specifying the path to the folder containing MAT classlist files to be updated.</p>
</td></tr>
<tr><td><code id="ifcb_replace_mat_values_+3A_out_folder">out_folder</code></td>
<td>
<p>A character string specifying the path to the folder where updated MAT classlist files will be saved.</p>
</td></tr>
<tr><td><code id="ifcb_replace_mat_values_+3A_target_id">target_id</code></td>
<td>
<p>The target class ID to be replaced.</p>
</td></tr>
<tr><td><code id="ifcb_replace_mat_values_+3A_new_id">new_id</code></td>
<td>
<p>The new class ID to replace the target ID.</p>
</td></tr>
<tr><td><code id="ifcb_replace_mat_values_+3A_column_index">column_index</code></td>
<td>
<p>An integer value specifying which classlist column to edit. Default is 1 (manual).</p>
</td></tr>
<tr><td><code id="ifcb_replace_mat_values_+3A_do_compression">do_compression</code></td>
<td>
<p>A logical value indicating whether to compress the .mat file. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires a python interpreter to be installed. The required python packages can be installed in a virtual environment using <code>ifcb_py_install</code>.
</p>


<h3>Value</h3>

<p>This function does not return any value; it updates the classlist files in the specified directory.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_py_install">ifcb_py_install</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initialize a python session if not already set up
ifcb_py_install()

# Replace class ID 99 with 1 in .mat classlist files
ifcb_replace_mat_values("output/manual", "output/manual", 99, 1, column_index = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_run_image_gallery'>Run IFCB Image Gallery</h2><span id='topic+ifcb_run_image_gallery'></span>

<h3>Description</h3>

<p>Launches a Shiny application that provides an interactive interface for
browsing and managing IFCB (Imaging FlowCytobot) image galleries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_run_image_gallery()
</code></pre>


<h3>Details</h3>

<p>Users can specify a folder containing .png images, navigate through the images,
select and unselect images, and download a list of selected images.
This feature is particularly useful for quality control of annotated images.
A downloaded list of images from the app can also be uploaded to filter and
view only the selected images.
</p>


<h3>Value</h3>

<p>No return value. This function launches a Shiny application for interactive image browsing and management.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Run the IFCB image gallery Shiny app
ifcb_run_image_gallery()

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_summarize_biovolumes'>Summarize Biovolumes and Carbon Content from IFCB Data</h2><span id='topic+ifcb_summarize_biovolumes'></span>

<h3>Description</h3>

<p>This function calculates aggregated biovolumes and carbon content from Imaging FlowCytobot (IFCB)
samples based on biovolume information from feature files. Images are grouped into classes either
based on MATLAB classification, manually annotated files, or a user-supplied list of images and
their corresponding class labels (e.g. from a CNN model).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_summarize_biovolumes(
  feature_folder,
  mat_folder = NULL,
  class2use_file = NULL,
  hdr_folder = NULL,
  custom_images = NULL,
  custom_classes = NULL,
  micron_factor = 1/3.4,
  diatom_class = "Bacillariophyceae",
  marine_only = FALSE,
  threshold = "opt",
  feature_recursive = TRUE,
  mat_recursive = TRUE,
  hdr_recursive = TRUE,
  use_python = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_summarize_biovolumes_+3A_feature_folder">feature_folder</code></td>
<td>
<p>Path to the folder containing feature files (e.g., CSV format).</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_mat_folder">mat_folder</code></td>
<td>
<p>(Optional) Path to the folder containing MATLAB classification or manual annotation files.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_class2use_file">class2use_file</code></td>
<td>
<p>(Optional) A character string specifying the path to the file containing the class2use variable (default NULL). Only needed when summarizing manual MATLAB results.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_hdr_folder">hdr_folder</code></td>
<td>
<p>(Optional) Path to the folder containing HDR files. Needed for calculating cell, biovolume and carbon concentration per liter.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_custom_images">custom_images</code></td>
<td>
<p>(Optional) A character vector of image filenames in the format DYYYYMMDDTHHMMSS_IFCBXXX_ZZZZZ,
where &quot;XXX&quot; represents the IFCB number and &quot;ZZZZZ&quot; represents the ROI number.
These filenames should match the <code>roi_number</code> assignment in the <code>feature_files</code> and can be
used as a substitute for MATLAB files.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_custom_classes">custom_classes</code></td>
<td>
<p>(Optional) A character vector of corresponding class labels for <code>custom_images</code>.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_micron_factor">micron_factor</code></td>
<td>
<p>Conversion factor from microns per pixel (default: 1/3.4).</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_diatom_class">diatom_class</code></td>
<td>
<p>A string vector of diatom class names in the World Register of Marine Species (WoRMS). Default is &quot;Bacillariophyceae&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_marine_only">marine_only</code></td>
<td>
<p>Logical. If TRUE, restricts the WoRMS search to marine taxa only. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for classification (default: &quot;opt&quot;).</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_feature_recursive">feature_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for feature files recursively within the <code>feature_folder</code>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_mat_recursive">mat_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for MATLAB files recursively within the <code>mat_folder</code>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_hdr_recursive">hdr_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for HDR files recursively within the <code>hdr_folder</code> (if provided). Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read the <code>.mat</code> file using a Python-based method. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_biovolumes_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the following steps:
</p>

<ol>
<li><p> Extracts biovolumes and carbon content from feature and classification results using <code>ifcb_extract_biovolumes</code>.
</p>
</li>
<li><p> Optionally incorporates volume data from HDR files to calculate volume analyzed per sample.
</p>
</li>
<li><p> Computes biovolume and carbon content per liter of sample analyzed.
</p>
</li></ol>

<p>The MATLAB classification or manual annotation files are generated by the <code>ifcb-analysis</code> repository
(Sosik and Olson 2007). Users can optionally provide a <strong>custom classification</strong> by supplying a vector of image filenames
(<code>custom_images</code>) along with corresponding class labels (<code>custom_classes</code>). This allows summarization
of biovolume and carbon content without requiring MATLAB classification or manual annotation files
(e.g. results from a CNN model).
</p>
<p>Biovolumes are converted to carbon according to Menden-Deuer and Lessard 2000
for individual regions of interest (ROI), applying different conversion factors to diatoms and
non-diatom protists. If provided, the function also incorporates sample volume data from HDR files
to compute biovolume and carbon content per liter of sample.
</p>
<p>If <code>use_python = TRUE</code>, the function tries to read the <code>.mat</code> file using <code>ifcb_read_mat()</code>, which relies on <code>SciPy</code>.
This approach may be faster than the default approach using <code>R.matlab::readMat()</code>, especially for large <code>.mat</code> files.
To enable this functionality, ensure Python is properly configured with the required dependencies.
You can initialize the Python environment and install necessary packages using <code>ifcb_py_install()</code>.
</p>


<h3>Value</h3>

<p>A data frame summarizing aggregated biovolume and carbon content per class per sample.
Columns include 'sample', 'classifier', 'class', 'biovolume_mm3', 'carbon_ug', 'ml_analyzed',
'biovolume_mm3_per_liter', and 'carbon_ug_per_liter'.
</p>


<h3>References</h3>

<p>Menden-Deuer Susanne, Lessard Evelyn J., (2000), Carbon to volume relationships for dinoflagellates, diatoms, and other protist plankton, Limnology and Oceanography, 3, doi: 10.4319/lo.2000.45.3.0569.
</p>
<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example usage:
ifcb_summarize_biovolumes("path/to/features", "path/to/mat", hdr_folder = "path/to/hdr")

# Using custom classification result:
images &lt;- c("D20220522T003051_IFCB134_00002",
            "D20220522T003051_IFCB134_00003")
classes = c("Mesodinium_rubrum",
            "Mesodinium_rubrum")

ifcb_summarize_biovolumes(feature_folder = "path/to/features",
                          hdr_folder = "path/to/hdr",
                          custom_images = images,
                          custom_classes = classes)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_summarize_class_counts'>Count Cells from TreeBagger Classifier Output</h2><span id='topic+ifcb_summarize_class_counts'></span>

<h3>Description</h3>

<p>This function summarizes class results for a series of classifier output files
and returns a summary data list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_summarize_class_counts(
  classpath_generic,
  hdr_folder,
  year_range,
  use_python = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_summarize_class_counts_+3A_classpath_generic">classpath_generic</code></td>
<td>
<p>Character string specifying the location of the classifier output files.
The path should include 'xxxx' in place of the 4-digit year (e.g., 'classxxxx_v1/').</p>
</td></tr>
<tr><td><code id="ifcb_summarize_class_counts_+3A_hdr_folder">hdr_folder</code></td>
<td>
<p>Character string specifying the directory where the data (hdr files) are located.
This can be a URL for web services or a full path for local files.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_class_counts_+3A_year_range">year_range</code></td>
<td>
<p>Numeric vector specifying the range of years (e.g., 2013:2014) to process.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_class_counts_+3A_use_python">use_python</code></td>
<td>
<p>Logical. If <code>TRUE</code>, attempts to read the <code>.mat</code> file using a Python-based method. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>use_python = TRUE</code>, the function tries to read the <code>.mat</code> file using <code>ifcb_read_mat()</code>, which relies on <code>SciPy</code>.
This approach may be faster than the default approach using <code>R.matlab::readMat()</code>, especially for large <code>.mat</code> files.
To enable this functionality, ensure Python is properly configured with the required dependencies.
You can initialize the Python environment and install necessary packages using <code>ifcb_py_install()</code>.
</p>
<p>If <code>use_python = FALSE</code> or if <code>SciPy</code> is not available, the function falls back to using <code>R.matlab::readMat()</code>.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>class2useTB</code></td>
<td>
<p>Classes used in the TreeBagger classifier.</p>
</td></tr>
<tr><td><code>classcountTB</code></td>
<td>
<p>Counts of each class considering each target placed in the winning class.</p>
</td></tr>
<tr><td><code>classcountTB_above_optthresh</code></td>
<td>
<p>Counts of each class considering only classifications above the optimal threshold for maximum accuracy.</p>
</td></tr>
<tr><td><code>ml_analyzedTB</code></td>
<td>
<p>Volume analyzed for each file.</p>
</td></tr>
<tr><td><code>mdateTB</code></td>
<td>
<p>Dates associated with each file.</p>
</td></tr>
<tr><td><code>filelistTB</code></td>
<td>
<p>List of files processed.</p>
</td></tr>
<tr><td><code>classpath_generic</code></td>
<td>
<p>The generic classpath provided as input.</p>
</td></tr>
<tr><td><code>classcountTB_above_adhocthresh (optional)</code></td>
<td>
<p>Counts of each class considering only classifications above the adhoc threshold.</p>
</td></tr>
<tr><td><code>adhocthresh (optional)</code></td>
<td>
<p>The adhoc threshold used for classification.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ifcb_summarize_class_counts('C:/work/IFCB/user_training_test_data/class/classxxxx_v1/',
                            'C:/work/IFCB/user_training_test_data/data/', 2014)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_summarize_png_counts'>Summarize Image Counts by Class and Sample</h2><span id='topic+ifcb_summarize_png_counts'></span>

<h3>Description</h3>

<p>This function summarizes the number of images per class for each sample and timestamps,
and optionally retrieves GPS positions, and IFCB information using <code>ifcb_read_hdr_data</code> and <code>ifcb_convert_filenames</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_summarize_png_counts(
  png_folder,
  hdr_folder = NULL,
  sum_level = "sample",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_summarize_png_counts_+3A_png_folder">png_folder</code></td>
<td>
<p>A character string specifying the path to the main directory containing subfolders (classes) with .png images.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_png_counts_+3A_hdr_folder">hdr_folder</code></td>
<td>
<p>A character string specifying the path to the directory containing the .hdr files. Default is NULL.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_png_counts_+3A_sum_level">sum_level</code></td>
<td>
<p>A character string specifying the level of summarization. Options: &quot;sample&quot; (default) or &quot;class&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_png_counts_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If sum_level is &quot;sample&quot;, returns a data frame with columns: sample, ifcb_number, class_name, n_images, gpsLatitude, gpsLongitude, timestamp, year, month, day, time, roi_numbers.
If sum_level is &quot;class&quot;, returns a data frame with columns: class_name, n_images.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_read_hdr_data">ifcb_read_hdr_data</a></code> <code><a href="#topic+ifcb_convert_filenames">ifcb_convert_filenames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example usage:
# Assuming the following directory structure:
# path/to/png_folder/
# |- class1/
# |  |- sample1_00001.png
# |  |- sample1_00002.png
# |  |- sample2_00001.png
# |- class2/
# |  |- sample1_00003.png
# |  |- sample3_00001.png

png_folder &lt;- "path/to/png_folder"
hdr_folder &lt;- "path/to/hdr_folder" # This folder should contain corresponding .hdr files

# Summarize by sample
summary_sample &lt;- ifcb_summarize_png_counts(png_folder,
                                          hdr_folder,
                                          sum_level = "sample",
                                          verbose = TRUE)
print(summary_sample)

# Summarize by class
summary_class &lt;- ifcb_summarize_png_counts(png_folder,
                                         hdr_folder,
                                         sum_level = "class",
                                         verbose = TRUE)
print(summary_class)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_summarize_png_data'>Summarize Image Counts by Class and Sample</h2><span id='topic+ifcb_summarize_png_data'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This function was deprecated as it has been replaced by a function with a more accurate
name: <code>ifcb_summarize_png_counts</code>.
</p>
<p>This function summarizes the number of images per class for each sample and timestamps,
and optionally retrieves GPS positions, and IFCB information using <code>ifcb_read_hdr_data</code> and <code>ifcb_convert_filenames</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_summarize_png_data(
  png_folder,
  hdr_folder = NULL,
  sum_level = "sample",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_summarize_png_data_+3A_png_folder">png_folder</code></td>
<td>
<p>A character string specifying the path to the main directory containing subfolders (classes) with .png images.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_png_data_+3A_hdr_folder">hdr_folder</code></td>
<td>
<p>A character string specifying the path to the directory containing the .hdr files. Default is NULL.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_png_data_+3A_sum_level">sum_level</code></td>
<td>
<p>A character string specifying the level of summarization. Options: &quot;sample&quot; (default) or &quot;class&quot;.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_png_data_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If sum_level is &quot;sample&quot;, returns a data frame with columns: sample, ifcb_number, class_name, n_images, gpsLatitude, gpsLongitude, timestamp, year, month, day, time, roi_numbers.
If sum_level is &quot;class&quot;, returns a data frame with columns: class_name, n_images.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_read_hdr_data">ifcb_read_hdr_data</a></code> <code><a href="#topic+ifcb_convert_filenames">ifcb_convert_filenames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example usage:
# Assuming the following directory structure:
# path/to/png_folder/
# |- class1/
# |  |- sample1_00001.png
# |  |- sample1_00002.png
# |  |- sample2_00001.png
# |- class2/
# |  |- sample1_00003.png
# |  |- sample3_00001.png

png_folder &lt;- "path/to/png_folder"
hdr_folder &lt;- "path/to/hdr_folder" # This folder should contain corresponding .hdr files

# Summarize by sample
summary_sample &lt;- ifcb_summarize_png_data(png_folder,
                                          hdr_folder,
                                          sum_level = "sample",
                                          verbose = TRUE)
print(summary_sample)

# Summarize by class
summary_class &lt;- ifcb_summarize_png_data(png_folder,
                                         hdr_folder,
                                         sum_level = "class",
                                         verbose = TRUE)
print(summary_class)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_summarize_png_metadata'>Summarize PNG Image Metadata</h2><span id='topic+ifcb_summarize_png_metadata'></span>

<h3>Description</h3>

<p>This function processes IFCB data by reading images, matching them to the corresponding
header and feature files, and joining them into a single dataframe. This function may be
useful when preparing metadata files for an Ecotaxa submission.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_summarize_png_metadata(
  png_folder,
  feature_folder = NULL,
  hdr_folder = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_summarize_png_metadata_+3A_png_folder">png_folder</code></td>
<td>
<p>Character. The file path to the folder containing the PNG images.</p>
</td></tr>
<tr><td><code id="ifcb_summarize_png_metadata_+3A_feature_folder">feature_folder</code></td>
<td>
<p>Character. The file path to the folder containing the feature files (optional).</p>
</td></tr>
<tr><td><code id="ifcb_summarize_png_metadata_+3A_hdr_folder">hdr_folder</code></td>
<td>
<p>Character. The file path to the folder containing the header files (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe that joins image data, header data, and feature data based on the sample and roi number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
png_folder &lt;- "path/to/pngs"
feature_folder &lt;- "path/to/features"
hdr_folder &lt;- "path/to/hdr_data"
result_df &lt;- ifcb_summarize_png_metadata(png_folder, feature_folder, hdr_folder)

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_volume_analyzed'>Estimate Volume Analyzed from IFCB Header File</h2><span id='topic+ifcb_volume_analyzed'></span>

<h3>Description</h3>

<p>This function reads an IFCB header file to extract sample run time and inhibittime,
and returns the associated estimate of sample volume analyzed (in milliliters).
The function assumes a standard IFCB configuration with a sample syringe operating
at 0.25 mL per minute. For IFCB instruments after 007 and higher (except 008). This is
the R equivalent function of <code>IFCB_volume_analyzed</code> from the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_volume_analyzed(hdr_file, hdrOnly_flag = FALSE, flowrate = 0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_volume_analyzed_+3A_hdr_file">hdr_file</code></td>
<td>
<p>A character vector specifying the path(s) to one or more .hdr files or URLs.</p>
</td></tr>
<tr><td><code id="ifcb_volume_analyzed_+3A_hdronly_flag">hdrOnly_flag</code></td>
<td>
<p>An optional flag indicating whether to skip ADC file estimation (default is FALSE).</p>
</td></tr>
<tr><td><code id="ifcb_volume_analyzed_+3A_flowrate">flowrate</code></td>
<td>
<p>Milliliters per minute for syringe pump (default is 0.25).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the estimated sample volume analyzed for each header file.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example: Estimate volume analyzed from an IFCB header file
hdr_file &lt;- "path/to/IFCB_hdr_file.hdr"
ml_analyzed &lt;- ifcb_volume_analyzed(hdr_file)
print(ml_analyzed)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_volume_analyzed_from_adc'>Estimate Volume Analyzed from IFCB ADC File</h2><span id='topic+ifcb_volume_analyzed_from_adc'></span>

<h3>Description</h3>

<p>This function reads an IFCB ADC file to extract sample run time and inhibittime,
and returns the associated estimate of sample volume analyzed (in milliliters).
The function assumes a standard IFCB configuration with a sample syringe operating
at 0.25 mL per minute. For IFCB instruments after 007 and higher (except 008). This is
the R equivalent function of <code>IFCB_volume_analyzed_fromADC</code> from the <code style="white-space: pre;">&#8288;ifcb-analysis repository&#8288;</code> (Sosik and Olson 2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_volume_analyzed_from_adc(adc_file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_volume_analyzed_from_adc_+3A_adc_file">adc_file</code></td>
<td>
<p>A character vector specifying the path(s) to one or more .adc files or URLs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><strong>ml_analyzed</strong>: A numeric vector of estimated sample volume analyzed for each ADC file.
</p>
</li>
<li> <p><strong>inhibittime</strong>: A numeric vector of inhibittime values extracted from ADC files.
</p>
</li>
<li> <p><strong>runtime</strong>: A numeric vector of runtime values extracted from ADC files.
</p>
</li></ul>



<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example: Estimate volume analyzed from an IFCB ADC file
adc_file &lt;- "path/to/IFCB_adc_file.csv"
adc_info &lt;- ifcb_volume_analyzed_from_adc(adc_file)
print(adc_info$ml_analyzed)

## End(Not run)
</code></pre>

<hr>
<h2 id='ifcb_which_basin'>Determine if Points are in a Specified Sea Basin</h2><span id='topic+ifcb_which_basin'></span>

<h3>Description</h3>

<p>This function identifies which sub-basin a set of latitude and longitude points belong to, using a user-specified or default shapefile.
The default shapefile includes the Baltic Sea, Kattegat, and Skagerrak basins and is included in the <code>iRfcb</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_which_basin(latitudes, longitudes, plot = FALSE, shape_file = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_which_basin_+3A_latitudes">latitudes</code></td>
<td>
<p>A numeric vector of latitude points.</p>
</td></tr>
<tr><td><code id="ifcb_which_basin_+3A_longitudes">longitudes</code></td>
<td>
<p>A numeric vector of longitude points.</p>
</td></tr>
<tr><td><code id="ifcb_which_basin_+3A_plot">plot</code></td>
<td>
<p>A boolean indicating whether to plot the points along with the sea basins. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_which_basin_+3A_shape_file">shape_file</code></td>
<td>
<p>The absolute path to a custom polygon shapefile in WGS84 (EPSG:4326) that represents the sea basin.
Defaults to the Baltic Sea, Kattegat, and Skagerrak basins included in the <code>iRfcb</code> package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads a pre-packaged shapefile of the Baltic Sea, Kattegat, and Skagerrak basins from the <code>iRfcb</code> package by default, or a user-supplied
shapefile if provided. The shapefiles originate from SHARK (https://shark.smhi.se/). It sets the CRS, transforms the CRS to WGS84 (EPSG:4326) if necessary, and checks if the given points
fall within the specified sea basin. Optionally, it plots the points and the sea basin polygons together.
</p>


<h3>Value</h3>

<p>A vector indicating the basin each point belongs to, or a ggplot object if <code>plot = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define example latitude and longitude vectors
latitudes &lt;- c(55.337, 54.729, 56.311, 57.975)
longitudes &lt;- c(12.674, 14.643, 12.237, 10.637)

# Check in which Baltic sea basin the points are in
points_in_the_baltic &lt;- ifcb_which_basin(latitudes, longitudes)
print(points_in_the_baltic)

# Plot the points and the basins
ifcb_which_basin(latitudes, longitudes, plot = TRUE)

</code></pre>

<hr>
<h2 id='ifcb_zip_matlab'>Create a Zip Archive of Manual MATLAB Files</h2><span id='topic+ifcb_zip_matlab'></span>

<h3>Description</h3>

<p>This function creates a zip archive containing specified files and directories for manually
annotated IFCB images, organized into a structured format suitable for distribution or storage.
The MATLAB files are generated by the <code>ifcb-analysis</code> repository (Sosik and Olson 2007).
The zip archive can be used to submit IFCB data to repositories like in the SMHI IFCB Plankton Image Reference Library (Torstensson et al., 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_zip_matlab(
  manual_folder,
  features_folder,
  class2use_file,
  zip_filename,
  data_folder = NULL,
  readme_file = NULL,
  matlab_readme_file = NULL,
  email_address = "",
  version = "",
  print_progress = TRUE,
  feature_recursive = TRUE,
  manual_recursive = FALSE,
  data_recursive = TRUE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_zip_matlab_+3A_manual_folder">manual_folder</code></td>
<td>
<p>The directory containing .mat files to be included in the zip archive.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_features_folder">features_folder</code></td>
<td>
<p>The directory containing .csv files, including subfolders, to be included in the zip archive.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_class2use_file">class2use_file</code></td>
<td>
<p>The path to the file (class2use_file) that will be renamed and included in the 'config' directory of the zip archive.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_zip_filename">zip_filename</code></td>
<td>
<p>The filename for the zip archive to be created.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_data_folder">data_folder</code></td>
<td>
<p>Optionally, the directory containing additional data files (.roi, .adc, .hdr) to be included in the zip archive.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_readme_file">readme_file</code></td>
<td>
<p>Optionally, the path to a README file that will be updated with metadata and included in the zip archive.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_matlab_readme_file">matlab_readme_file</code></td>
<td>
<p>Optionally, the path to a MATLAB README file whose content will be appended to the end of the README file in the zip archive.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_email_address">email_address</code></td>
<td>
<p>The email address to be included in the README file for contact information.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_version">version</code></td>
<td>
<p>Optionally, the version number to be included in the README file.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_print_progress">print_progress</code></td>
<td>
<p>A logical value indicating whether to print progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_feature_recursive">feature_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for feature files recursively within the <code>feature_folder</code>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_manual_recursive">manual_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for MATLAB files recursively within the <code>manual_folder</code>. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_data_recursive">data_recursive</code></td>
<td>
<p>Logical. If TRUE, the function will search for data files recursively within the <code>data_folder</code> (if provided). Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_zip_matlab_+3A_quiet">quiet</code></td>
<td>
<p>Logical. If TRUE, suppresses messages about the progress and completion of the zip process. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the following operations:
</p>

<ul>
<li><p> Lists <code>.mat</code> files from <code>manual_folder</code>.
</p>
</li>
<li><p> Lists <code>.csv</code> files from <code>features_folder</code> (including subfolders).
</p>
</li>
<li><p> Lists <code>.roi</code>, <code>.adc</code>, <code>.hdr</code> files from <code>data_folder</code> if provided.
</p>
</li>
<li><p> Copies listed files to temporary directories (<code>manual_dir</code>, <code>features_dir</code>, <code>data_dir</code>, <code>config_dir</code>).
</p>
</li>
<li><p> Renames and copies <code>class2use_file</code> to <code>config_dir</code> as <code>class2use.mat</code>.
</p>
</li>
<li><p> Updates <code>readme_file</code> with metadata (if provided) and appends PNG image statistics and MATLAB README content.
</p>
</li>
<li><p> Creates a manifest file (<code>MANIFEST.txt</code>) listing all files in the zip archive.
</p>
</li>
<li><p> Creates a zip archive (<code>zip_filename</code>) containing all copied and updated files.
</p>
</li>
<li><p> Cleans up temporary directories after creating the zip archive.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value. This function creates a zip archive containing the specified files and directories.
</p>


<h3>References</h3>

<p>Sosik, H. M. and Olson, R. J. (2007), Automated taxonomic classification of phytoplankton sampled with imaging-in-flow cytometry. Limnol. Oceanogr: Methods 5, 204â€“216.
Torstensson, Anders; Skjevik, Ann-Turi; Mohlin, Malin; Karlberg, Maria; Karlson, Bengt (2024). SMHI IFCB Plankton Image Reference Library. SciLifeLab. Dataset. <a href="https://doi.org/10.17044/scilifelab.25883455">doi:10.17044/scilifelab.25883455</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_zip_pngs">ifcb_zip_pngs</a></code> <a href="https://github.com/hsosik/ifcb-analysis">https://github.com/hsosik/ifcb-analysis</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ifcb_zip_matlab("path/to/manual_files", "path/to/feature_files",
                 "path/to/class2use.mat", "output_zip_archive.zip",
                 data_folder = "path/to/data_files",
                 readme_file = system.file("exdata/README-template.md", package = "iRfcb"),
                 matlab_readme_file = system.file("inst/exdata/MATLAB-template.md",
                                                  package = "iRfcb"),
                 email_address = "example@email.com",
                 version = "1.0")

## End(Not run)

</code></pre>

<hr>
<h2 id='ifcb_zip_pngs'>Zip PNG Folders</h2><span id='topic+ifcb_zip_pngs'></span>

<h3>Description</h3>

<p>This function zips directories containing .png files and optionally includes README and MANIFEST files.
It can also split the resulting zip file into smaller parts if it exceeds a specified size.
The zip archive can be used to submit IFCB data to repositories like in the SMHI IFCB Plankton Image Reference Library (Torstensson et al., 2024).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifcb_zip_pngs(
  png_folder,
  zip_filename,
  readme_file = NULL,
  email_address = "",
  version = "",
  print_progress = TRUE,
  include_txt = FALSE,
  split_zip = FALSE,
  max_size = 500,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifcb_zip_pngs_+3A_png_folder">png_folder</code></td>
<td>
<p>The directory containing subdirectories with .png files.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_zip_filename">zip_filename</code></td>
<td>
<p>The name of the zip file to create.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_readme_file">readme_file</code></td>
<td>
<p>Optional path to a README file for inclusion in the zip package.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_email_address">email_address</code></td>
<td>
<p>Optional email address to include in the README file.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_version">version</code></td>
<td>
<p>Optional version information to include in the README file.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_print_progress">print_progress</code></td>
<td>
<p>A logical value indicating whether to print progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_include_txt">include_txt</code></td>
<td>
<p>A logical value indicating whether to include text (.txt, .tsv and .csv) files located in the subdirectories. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_split_zip">split_zip</code></td>
<td>
<p>A logical value indicating whether to split the zip file into smaller parts if its size exceeds <code>max_size</code>. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_max_size">max_size</code></td>
<td>
<p>The maximum size (in MB) for the zip file before it gets split. Only used if <code>split_zip</code> is TRUE. Default is 500 MB.</p>
</td></tr>
<tr><td><code id="ifcb_zip_pngs_+3A_quiet">quiet</code></td>
<td>
<p>Logical. If TRUE, suppresses messages about the progress and completion of the zip process. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return any value; it creates a zip archive and optionally splits it into smaller files if specified.
</p>


<h3>References</h3>

<p>Torstensson, Anders; Skjevik, Ann-Turi; Mohlin, Malin; Karlberg, Maria; Karlson, Bengt (2024). SMHI IFCB Plankton Image Reference Library. SciLifeLab. Dataset. <a href="https://doi.org/10.17044/scilifelab.25883455">doi:10.17044/scilifelab.25883455</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifcb_zip_matlab">ifcb_zip_matlab</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Zip all subdirectories in the 'images' folder with a README file
ifcb_zip_pngs("path/to/images",
             "images.zip",
             readme_file = system.file("exdata/README-template.md", package = "iRfcb"),
             email_address = "example@example.com",
             version = "1.0")

# Zip all subdirectories in the 'images' folder without a README file
ifcb_zip_pngs("path/to/images", "images.zip")

## End(Not run)

</code></pre>

<hr>
<h2 id='read_hdr_file'>Function to Read Individual Files and Extract Relevant Lines</h2><span id='topic+read_hdr_file'></span>

<h3>Description</h3>

<p>This function reads an HDR file and extracts relevant lines containing parameters and their values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_hdr_file(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_hdr_file_+3A_file">file</code></td>
<td>
<p>A character string specifying the path to the HDR file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns: parameter, value, and file.
</p>

<hr>
<h2 id='retrieve_worms_records'>Retrieve WoRMS Records with Retry Mechanism</h2><span id='topic+retrieve_worms_records'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This helper function was deprecated as it has been replaced by a main function: <code>ifcb_match_taxon_name</code>.
</p>
<p>This helper function attempts to retrieve WoRMS records using the provided taxa names.
It retries the operation if an error occurs, up to a specified number of attempts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve_worms_records(
  taxa_names,
  max_retries = 3,
  sleep_time = 10,
  marine_only = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retrieve_worms_records_+3A_taxa_names">taxa_names</code></td>
<td>
<p>A character vector of taxa names to retrieve records for.</p>
</td></tr>
<tr><td><code id="retrieve_worms_records_+3A_max_retries">max_retries</code></td>
<td>
<p>An integer specifying the maximum number of attempts to retrieve records.</p>
</td></tr>
<tr><td><code id="retrieve_worms_records_+3A_sleep_time">sleep_time</code></td>
<td>
<p>A numeric value indicating the number of seconds to wait between retry attempts.</p>
</td></tr>
<tr><td><code id="retrieve_worms_records_+3A_marine_only">marine_only</code></td>
<td>
<p>Logical. If TRUE, restricts the search to marine taxa only. Default is FALSE.</p>
</td></tr>
<tr><td><code id="retrieve_worms_records_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of WoRMS records or NULL if the retrieval fails after the maximum number of attempts.
</p>

<hr>
<h2 id='split_large_zip'>Split Large Zip File into Smaller Parts</h2><span id='topic+split_large_zip'></span>

<h3>Description</h3>

<p>This helper function takes an existing zip file, extracts its contents,
and splits it into smaller zip files without splitting subfolders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_large_zip(zip_file, max_size = 500, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_large_zip_+3A_zip_file">zip_file</code></td>
<td>
<p>The path to the large zip file.</p>
</td></tr>
<tr><td><code id="split_large_zip_+3A_max_size">max_size</code></td>
<td>
<p>The maximum size (in MB) for each split zip file. Default is 500 MB.</p>
</td></tr>
<tr><td><code id="split_large_zip_+3A_quiet">quiet</code></td>
<td>
<p>Logical. If TRUE, suppresses messages about the progress and completion of the zip process. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function does not return any value; it creates multiple smaller zip files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Split an existing zip file into parts of up to 500 MB
split_large_zip("large_file.zip", max_size = 500)

## End(Not run)
</code></pre>

<hr>
<h2 id='summarize_TBclass'>Summarize TreeBagger Classifier Results</h2><span id='topic+summarize_TBclass'></span>

<h3>Description</h3>

<p>This function reads a TreeBagger classifier result file (.mat format) and summarizes
the number of targets in each class based on the classification scores and thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_TBclass(classfile, adhocthresh = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_TBclass_+3A_classfile">classfile</code></td>
<td>
<p>Character string specifying the path to the TreeBagger classifier result file (.mat format).</p>
</td></tr>
<tr><td><code id="summarize_TBclass_+3A_adhocthresh">adhocthresh</code></td>
<td>
<p>Numeric vector specifying the adhoc thresholds for each class. If NULL (default), no adhoc thresholding is applied.
If a single numeric value is provided, it is applied to all classes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing three elements:
</p>
<table role = "presentation">
<tr><td><code>classcount</code></td>
<td>
<p>Numeric vector of counts for each class based on the winning class assignment.</p>
</td></tr>
<tr><td><code>classcount_above_optthresh</code></td>
<td>
<p>Numeric vector of counts for each class above the optimal threshold for maximum accuracy.</p>
</td></tr>
<tr><td><code>classcount_above_adhocthresh</code></td>
<td>
<p>Numeric vector of counts for each class above the specified adhoc thresholds (if provided).</p>
</td></tr>
</table>

<hr>
<h2 id='vol2C_lgdiatom'>Convert Biovolume to Carbon for Large Diatoms</h2><span id='topic+vol2C_lgdiatom'></span>

<h3>Description</h3>

<p>This function converts biovolume in microns^3 to carbon in picograms
for large diatoms (&gt; 2000 micron^3) according to Menden-Deuer and Lessard 2000.
The formula used is: log pgC cell^-1 = log a + b * log V (um^3),
with log a = -0.933 and b = 0.881 for diatoms &gt; 3000 um^3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol2C_lgdiatom(volume)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol2C_lgdiatom_+3A_volume">volume</code></td>
<td>
<p>A numeric vector of biovolume measurements in microns^3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of carbon measurements in picograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Volumes in microns^3
volume &lt;- c(5000, 10000, 20000)

# Convert biovolume to carbon for large diatoms
vol2C_lgdiatom(volume)
</code></pre>

<hr>
<h2 id='vol2C_nondiatom'>Convert Biovolume to Carbon for Non-Diatom Protists</h2><span id='topic+vol2C_nondiatom'></span>

<h3>Description</h3>

<p>This function converts biovolume in microns^3 to carbon in picograms
for protists besides large diatoms (&gt; 3000 micron^3) according to Menden-Deuer and Lessard 2000.
The formula used is: log pgC cell^-1 = log a + b * log V (um^3),
with log a = -0.665 and b = 0.939.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vol2C_nondiatom(volume)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vol2C_nondiatom_+3A_volume">volume</code></td>
<td>
<p>A numeric vector of biovolume measurements in microns^3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of carbon measurements in picograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Volumes in microns^3
volume &lt;- c(5000, 10000, 20000)

# Convert biovolume to carbon for non-diatom protists
vol2C_nondiatom(volume)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
