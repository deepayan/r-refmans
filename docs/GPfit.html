<!DOCTYPE html><html><head><title>Help for package GPfit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GPfit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#corr_matrix'><p>Power Exponential or Matern Correlation Matrix</p></a></li>
<li><a href='#GP_deviance'><p>Computes the Deviance of a GP model</p></a></li>
<li><a href='#GP_fit'><p>Gaussian Process Model fitting</p></a></li>
<li><a href='#GPfit-package'><p>Gaussian Process Modeling</p></a></li>
<li><a href='#plot'><p>Plotting GP model fits</p></a></li>
<li><a href='#predict'><p>Model Predictions from GPfit</p></a></li>
<li><a href='#print.GP'><p>GP model fit Summary</p></a></li>
<li><a href='#scale_norm'><p>Scale variable into normal range 0, 1</p></a></li>
<li><a href='#sig_invb'><p>Internal tools</p></a></li>
<li><a href='#summary.GP'><p>Summary of GP model fit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Gaussian Processes Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-02-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Blake MacDoanld [aut],
  Hugh Chipman [aut, cre],
  Chris Campbell [ctb],
  Pritam Ranjan [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hugh Chipman &lt;hugh.chipman@acadiau.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A computationally stable approach of fitting a Gaussian Process (GP) model to a deterministic simulator. </td>
</tr>
<tr>
<td>Imports:</td>
<td>lhs (&ge; 0.5), lattice (&ge; 0.18-8)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-07 22:56:43 UTC; ccampbell</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-08 09:13:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='corr_matrix'>Power Exponential or Matern Correlation Matrix</h2><span id='topic+corr_matrix'></span>

<h3>Description</h3>

<p>Computes the power exponential or Matern correlation matrix for a set of
<em>n</em> design points in <em>d</em>-dimensional input region and a vector of
<em>d</em> correlation hyper-parameters (beta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_matrix(X, beta, corr = list(type = "exponential", power = 1.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_matrix_+3A_x">X</code></td>
<td>
<p>the (<code>n x d</code>) design matrix</p>
</td></tr>
<tr><td><code id="corr_matrix_+3A_beta">beta</code></td>
<td>
<p>a (<code>d x 1</code>) vector of correlation hyper-parameters in
<code class="reqn">(-\infty, \infty)</code></p>
</td></tr>
<tr><td><code id="corr_matrix_+3A_corr">corr</code></td>
<td>
<p>a list that specifies the <code>type</code> of correlation function
along with the smoothness parameter. The default corresponds to power
exponential correlation with smoothness parameter &quot;<code>power=1.95</code>&quot;. One
can specify a different power (between 1.0 and 2.0) for the power
exponential, or use the Matern correlation function, specified as
<code>corr=list(type = "matern", nu=(2*k+1)/2)</code>, where <code class="reqn">k \in
\{0,1,2,...\}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power exponential correlation function is given by
</p>
<p><code class="reqn">R_{ij} = \prod_{k=1}^{d} \exp({-10^{\beta_k}|x_{ik}-x_{jk}|^{power}})</code>. <br />
</p>
<p>The Matern correlation function given by Santner, Williams, and Notz (2003)
is
</p>
<p><code class="reqn">R_{ij} = \prod_{k=1}^{d}
\frac{1}{\Gamma(\nu)2^{\nu-1}}(2\sqrt{\nu}|x_{ik} - </code><code class="reqn">x_{jk}|10^{\beta_k})^\nu
\kappa_{\nu}(2\sqrt{\nu}|x_{ik} - </code><code class="reqn">x_{jk}|10^{\beta_k})</code>,
</p>
<p>where <code class="reqn">\kappa_{\nu}</code> is the modified Bessel function of
order <code class="reqn">\nu</code>.<br />
</p>


<h3>Value</h3>

<p>The (<code>n x n</code>) correlation matrix, R, for the design matrix
(<code>X</code>) and the hyper-parameters (<code>beta</code>).
</p>


<h3>Note</h3>

<p>Both Matern and power exponential correlation functions use the new
<code class="reqn">\beta</code> parametrization of hyper-parameters given by <code class="reqn">\theta_k =
10^{\beta_k}</code> for easier likelihood optimization.  That is, <code>beta</code> is a
log scale parameter (see MacDonald et al. (2015)).
</p>


<h3>Author(s)</h3>

<p>Blake MacDonald, Hugh Chipman, Pritam Ranjan
</p>


<h3>References</h3>

<p>MacDonald, K.B., Ranjan, P. and Chipman, H. (2015). 
GPfit: An R Package for Fitting a Gaussian Process Model to 
Deterministic Simulator Outputs.  
Journal of Statistical Software, 64(12), 1-23.
<a href="http://www.jstatsoft.org/v64/i12/">http://www.jstatsoft.org/v64/i12/</a> <br />
</p>
<p>Ranjan, P., Haynes, R., and Karsten, R. (2011). 
A Computationally Stable
Approach to Gaussian Process Interpolation of 
Deterministic Computer Simulation Data, 
Technometrics, 53(4), 366 - 378. <br />
</p>
<p>Santner, T.J., Williams, B., and Notz, W. (2003), 
The design and analysis of computer experiments, 
Springer Verlag, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1D Example - 1
n = 5
d = 1
set.seed(3)
library(lhs)
x = maximinLHS(n,d)
beta =  rnorm(1)
corr_matrix(x,beta)

## 1D Example - 2
beta = rnorm(1)
corr_matrix(x,beta,corr = list(type = "matern"))

## 2D example - 1
n = 10
d = 2
set.seed(2)
library(lhs)
x = maximinLHS(n,d) 
beta = rnorm(2)
corr_matrix(x, beta,
    corr = list(type = "exponential", power = 2))

## 2D example - 2
beta = rnorm(2)
R = corr_matrix(x,beta,corr = list(type = "matern", nu = 5/2))
print(R)

</code></pre>

<hr>
<h2 id='GP_deviance'>Computes the Deviance of a GP model</h2><span id='topic+GP_deviance'></span>

<h3>Description</h3>

<p>Evaluates the deviance (negative 2*log-likelihood), as 
defined in Ranjan et al. (2011), however the correlation 
is reparametrized and can be either power exponential or 
Matern as discussed in <code><a href="#topic+corr_matrix">corr_matrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GP_deviance(beta, X, Y, nug_thres = 20, corr = list(type =
  "exponential", power = 1.95))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GP_deviance_+3A_beta">beta</code></td>
<td>
<p>a (<em>d</em> x 1) vector of correlation hyper-parameters, as
described in <code><a href="#topic+corr_matrix">corr_matrix</a></code></p>
</td></tr>
<tr><td><code id="GP_deviance_+3A_x">X</code></td>
<td>
<p>the (<em>n</em> x <em>d</em>) design matrix</p>
</td></tr>
<tr><td><code id="GP_deviance_+3A_y">Y</code></td>
<td>
<p>the (<em>n</em> x 1) vector of simulator outputs</p>
</td></tr>
<tr><td><code id="GP_deviance_+3A_nug_thres">nug_thres</code></td>
<td>
<p>a parameter used in computing the nugget. See
<code><a href="#topic+GP_fit">GP_fit</a></code>.</p>
</td></tr>
<tr><td><code id="GP_deviance_+3A_corr">corr</code></td>
<td>
<p>a list of parameters for the specifing the correlation to be
used. See <code><a href="#topic+corr_matrix">corr_matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the deviance (negative 2 * log-likelihood)
</p>


<h3>Author(s)</h3>

<p>Blake MacDonald, Hugh Chipman, Pritam Ranjan
</p>


<h3>References</h3>

<p>Ranjan, P., Haynes, R., and Karsten, R. (2011). A
Computationally Stable Approach to Gaussian Process Interpolation of
Deterministic Computer Simulation Data, Technometrics, 53(4), 366 - 378.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+corr_matrix">corr_matrix</a></code> for computing the correlation matrix; <br />
<code><a href="#topic+GP_fit">GP_fit</a></code> for estimating the parameters of the GP model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 1D Example 1
n = 5
d = 1
computer_simulator &lt;- function(x) {
    x = 2 * x + 0.5
    y = sin(10 * pi * x)/(2 * x) + (x - 1)^4
    return(y)
}
set.seed(3)
library(lhs)
x = maximinLHS(n,d)
y = computer_simulator(x)
beta =  rnorm(1)
GP_deviance(beta,x,y)


## 1D Example 2
n = 7
d = 1
computer_simulator &lt;- function(x) {
    y &lt;- log(x + 0.1) + sin(5 * pi * x)
    return(y)
}
set.seed(1)
library(lhs)
x = maximinLHS(n, d)
y = computer_simulator(x)
beta = rnorm(1)
GP_deviance(beta, x, y,
    corr = list(type = "matern", nu = 5/2))

## 2D Example: GoldPrice Function
computer_simulator &lt;- function(x) {
    x1 = 4 * x[, 1] - 2
    x2 = 4 * x[, 2] - 2
    t1 = 1 + (x1 + x2 + 1)^2 * 
        (19 - 14 * x1 + 3 * x1^2 - 
        14 * x2 + 6 * x1 * x2 + 3 * x2^2)
    t2 = 30 + (2 * x1 - 3 * x2)^2 * 
        (18 - 32 * x1 + 12 * x1^2 + 
        48 * x2 - 36 * x1 * x2 + 27 * x2^2)
    y = t1 * t2
    return(y)
}
n = 10
d = 2
set.seed(1)
library(lhs)
x = maximinLHS(n, d) 
y = computer_simulator(x)
beta = rnorm(2)
GP_deviance(beta, x, y)

</code></pre>

<hr>
<h2 id='GP_fit'>Gaussian Process Model fitting</h2><span id='topic+GP_fit'></span>

<h3>Description</h3>

<p>For an (<em>n</em> x <em>d</em>) design matrix, <code>X</code>, 
and the corresponding (<em>n</em> x 1) simulator output <code>Y</code>, 
this function fits the GP model and returns the parameter estimates. 
The optimization routine assumes that
the inputs are scaled to the unit hypercube <code class="reqn">[0,1]^d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GP_fit(X, Y, control = c(200 * d, 80 * d, 2 * d), nug_thres = 20,
  trace = FALSE, maxit = 100, corr = list(type = "exponential", power
  = 1.95), optim_start = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GP_fit_+3A_x">X</code></td>
<td>
<p>the (<code>n x d</code>) design matrix</p>
</td></tr>
<tr><td><code id="GP_fit_+3A_y">Y</code></td>
<td>
<p>the (<code>n x 1</code>) vector of simulator outputs.</p>
</td></tr>
<tr><td><code id="GP_fit_+3A_control">control</code></td>
<td>
<p>a vector of parameters used in the search for optimal beta
(search grid size, percent, number of clusters). See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="GP_fit_+3A_nug_thres">nug_thres</code></td>
<td>
<p>a parameter used in computing the nugget. See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="GP_fit_+3A_trace">trace</code></td>
<td>
<p>logical, if <code>TRUE</code>, will provide information on the
<code><a href="stats.html#topic+optim">optim</a></code> runs</p>
</td></tr>
<tr><td><code id="GP_fit_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations within <code><a href="stats.html#topic+optim">optim</a></code>,
defaults to 100</p>
</td></tr>
<tr><td><code id="GP_fit_+3A_corr">corr</code></td>
<td>
<p>a list of parameters for the specifing the correlation to be
used. See <code><a href="#topic+corr_matrix">corr_matrix</a></code>.</p>
</td></tr>
<tr><td><code id="GP_fit_+3A_optim_start">optim_start</code></td>
<td>
<p>a matrix of potentially likely starting values for
correlation hyperparameters for the <code><a href="stats.html#topic+optim">optim</a></code> runs, i.e., initial
guess of the d-vector <code>beta</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the following GP model, 
<code class="reqn">y(x) = \mu + Z(x)</code>, 
<code class="reqn">x \in [0,1]^{d}</code>, where <code class="reqn">Z(x)</code> is
a GP with mean 0, <code class="reqn">Var(Z(x_i)) = \sigma^2</code>, and
<code class="reqn">Cov(Z(x_i),Z(x_j)) = \sigma^2R_{ij}</code>.  Entries in covariance matrix R are determined by
<code>corr</code> and parameterized by <code>beta</code>, a <code>d</code>-vector of
parameters. For computational stability <code class="reqn">R^{-1}</code> is replaced with
<code class="reqn">R_{\delta_{lb}}^{-1}</code>, where <code class="reqn">R_{\delta{lb}} = R + \delta_{lb}I</code>
and <code class="reqn">\delta_{lb}</code> is the nugget parameter described in Ranjan et al.
(2011).
</p>
<p>The parameter estimate <code>beta</code> is obtained by minimizing 
the deviance using a multi-start gradient based search (L-BFGS-B) 
algorithm. The starting points are selected using the k-means 
clustering algorithm on a large maximin LHD for values of 
<code>beta</code>, after discarding <code>beta</code> vectors
with high deviance. The <code>control</code> parameter determines the 
quality of the starting points of the L-BFGS-B algoritm.
</p>
<p><code>control</code> is a vector of three tunable parameters used 
in the deviance optimization algorithm. The default values 
correspond to choosing 2*d clusters (using k-means clustering 
algorithm) based on 80*d best points (smallest deviance, 
refer to <code><a href="#topic+GP_deviance">GP_deviance</a></code>) from a 200*d - point
random maximin LHD in <code>beta</code>. One can change these values 
to balance the trade-off between computational cost and robustness 
of likelihood optimization (or prediction accuracy).  
For details see MacDonald et al. (2015).
</p>
<p>The <code>nug_thres</code> parameter is outlined in Ranjan et al. (2011) and is
used in finding the lower bound on the nugget
(<code class="reqn">\delta_{lb}</code>).
</p>


<h3>Value</h3>

<p>an object of class <code>GP</code> containing parameter estimates
<code>beta</code> and <code>sig2</code>, nugget parameter <code>delta</code>, the data
(<code>X</code> and <code>Y</code>), and a specification of the correlation structure
used.
</p>


<h3>Author(s)</h3>

<p>Blake MacDonald, Hugh Chipman, Pritam Ranjan
</p>


<h3>References</h3>

<p>MacDonald, K.B., Ranjan, P. and Chipman, H. (2015). GPfit: An R
Package for Fitting a Gaussian Process Model to Deterministic Simulator
Outputs. Journal of Statistical Software, 64(12), 1-23.
<a href="http://www.jstatsoft.org/v64/i12/">http://www.jstatsoft.org/v64/i12/</a> <br />
</p>
<p>Ranjan, P., Haynes, R., and Karsten, R. (2011). A Computationally Stable
Approach to Gaussian Process Interpolation of Deterministic Computer
Simulation Data, Technometrics, 53(4), 366 - 378.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code> for plotting in 1 and 2 dimensions; <br />
<code><a href="#topic+predict">predict</a></code> for predicting the response and error surfaces; <br />
<code><a href="stats.html#topic+optim">optim</a></code> for information on the L-BFGS-B procedure; <br />
<code><a href="#topic+GP_deviance">GP_deviance</a></code> for computing the deviance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 1D Example 1
n = 5
d = 1 
computer_simulator &lt;- function(x){
    x = 2 * x + 0.5
    y = sin(10 * pi * x) / (2 * x) + (x - 1)^4
    return(y)
}
set.seed(3)
library(lhs)
x = maximinLHS(n, d)
y = computer_simulator(x)
GPmodel = GP_fit(x, y)
print(GPmodel)


## 1D Example 2
n = 7
d = 1
computer_simulator &lt;- function(x) {
    y &lt;- log(x + 0.1) + sin(5 * pi * x)
    return(y)
}
set.seed(1)
library(lhs)
x = maximinLHS(n, d)
y = computer_simulator(x)
GPmodel = GP_fit(x, y)
print(GPmodel, digits = 4)


## 2D Example: GoldPrice Function
computer_simulator &lt;- function(x) {
    x1 = 4 * x[, 1] - 2
    x2 = 4 * x[, 2] - 2
    t1 = 1 + (x1 + x2 + 1)^2 * (19 - 14 * x1 + 3 * x1^2 - 14 * x2 + 
        6 * x1 *x2 + 3 * x2^2)
    t2 = 30 + (2 * x1 - 3 * x2)^2 * (18 - 32 * x1 + 12 * x1^2 + 48 * x2 - 
        36 * x1 * x2 + 27 * x2^2)
    y = t1 * t2
    return(y)
}
n = 30
d = 2
set.seed(1)
library(lhs)
x = maximinLHS(n, d) 
y = computer_simulator(x)
GPmodel = GP_fit(x, y)
print(GPmodel)

</code></pre>

<hr>
<h2 id='GPfit-package'>Gaussian Process Modeling</h2><span id='topic+GPfit-package'></span><span id='topic+GPfit'></span>

<h3>Description</h3>

<p>A computationally stable approach of fitting a Gaussian process (GP) model
to simulator outputs. It is assumed that the input variables are continuous
and the outputs are obtained from scalar valued deterministic computer
simulator.
</p>


<h3>Details</h3>

<p>This package implements a slightly modified version of the regularized GP
model proposed in Ranjan et al. (2011). For details see MacDonald et al.
(2015). A new parameterization of the Gaussian correlation is used for the
ease of optimization. This package uses a multi-start gradient based search
algorithm for optimizing the deviance (negative 2*log-likelihood).<br />
</p>
<p>For a complete list of functions, use <code>library(help="GPfit")</code>. <br /> The
main function for fitting the GP model is <code><a href="#topic+GP_fit">GP_fit</a></code>.
</p>


<h3>Author(s)</h3>

<p>Blake MacDoanld, Hugh Chipman, Pritam Ranjan <br /> Maintainer: Hugh
Chipman &lt;hugh.chipman@acadiau.ca&gt;
</p>


<h3>References</h3>

<p>MacDonald, K.B., Ranjan, P. and Chipman, H. (2015). GPfit: An R
Package for Fitting a Gaussian Process Model to Deterministic Simulator
Outputs. Journal of Statistical Software, 64(12), 1-23.
<a href="http://www.jstatsoft.org/v64/i12/">http://www.jstatsoft.org/v64/i12/</a> <br />
</p>
<p>Ranjan, P., Haynes, R., and Karsten, R. (2011). A Computationally Stable
Approach to Gaussian Process Interpolation of Deterministic Computer
Simulation Data, Technometrics, 53(4), 366 - 378. <br />
</p>
<p>Santner, T.J., Williams, B., and Notz, W. (2003), The design and analysis of
computer experiments, Springer Verlag, New York. <br />
</p>

<hr>
<h2 id='plot'>Plotting GP model fits</h2><span id='topic+plot'></span><span id='topic+plot.GP'></span>

<h3>Description</h3>

<p>Plots the predicted response and mean squared error (MSE) surfaces for
simulators with 1 and 2 dimensional inputs (i.e. d = 1,2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
plot(x, M = 1, range = c(0, 1), resolution = 50,
  colors = c("black", "blue", "red"), line_type = c(1, 2), pch = 20,
  cex = 1, legends = FALSE, surf_check = FALSE, response = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>a class <code>GP</code> object estimated by <code>GP_fit</code></p>
</td></tr>
<tr><td><code id="plot_+3A_m">M</code></td>
<td>
<p>the number of iterations for use in prediction. See
<code><a href="#topic+predict.GP">predict.GP</a></code></p>
</td></tr>
<tr><td><code id="plot_+3A_range">range</code></td>
<td>
<p>the input range for plotting (default set to <code>[0, 1]</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_resolution">resolution</code></td>
<td>
<p>the number of points along a coordinate in the specified
<code>range</code></p>
</td></tr>
<tr><td><code id="plot_+3A_colors">colors</code></td>
<td>
<p>a vector of length 3 assigning <code>colors[1]</code> to training
design points, <code>colors[2]</code> to model predictions, and <code>colors[3]</code>
to the error bounds</p>
</td></tr>
<tr><td><code id="plot_+3A_line_type">line_type</code></td>
<td>
<p>a vector of length 2 assigning <code>line_type[1]</code> to model
predictions, and <code>line_type[2]</code> to the error bounds</p>
</td></tr>
<tr><td><code id="plot_+3A_pch">pch</code></td>
<td>
<p>a parameter defining the plotting character for the training
design points, see &lsquo;pch&rsquo; for possible options in <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot_+3A_cex">cex</code></td>
<td>
<p>a parameter defining the size of the <code>pch</code> used for plotting
the training design points, see &lsquo;cex&rsquo; for possible options in
<code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot_+3A_legends">legends</code></td>
<td>
<p>a parameter that controls the inclusion of a
<code><a href="graphics.html#topic+legend">legend</a></code>; by default it is &lsquo;FALSE&rsquo;</p>
</td></tr>
<tr><td><code id="plot_+3A_surf_check">surf_check</code></td>
<td>
<p>logical, switch between 3d surface and 2d level/contour
plotting, the default of <code>FALSE</code> implies level/contour plotting</p>
</td></tr>
<tr><td><code id="plot_+3A_response">response</code></td>
<td>
<p>logical, switch between predicted response and error (MSE)
plots, the default of <code>TRUE</code> displays the response surface</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>additional arguments from <code><a href="lattice.html#topic+wireframe">wireframe</a></code> or
<code><a href="lattice.html#topic+levelplot">levelplot</a></code></p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>GP</code>: The <code>plot</code> method 
creates a <span class="pkg">graphics</span> plot for 1-D fits and
<span class="pkg">lattice</span> plot for 2-D fits.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Blake MacDonald, Hugh Chipman, Pritam Ranjan
</p>


<h3>References</h3>

<p>Ranjan, P., Haynes, R., and Karsten, R. (2011). A
Computationally Stable Approach to Gaussian Process Interpolation of
Deterministic Computer Simulation Data, Technometrics, 53(4), 366 - 378.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GP_fit">GP_fit</a></code> for estimating the parameters of the GP model;
<br /> <code><a href="#topic+predict.GP">predict.GP</a></code> for predicting the response and error surfaces;
<br /> <code><a href="graphics.html#topic+par">par</a></code> for additional plotting characters and line types for
1 dimensional plots; <br /> <code><a href="lattice.html#topic+wireframe">wireframe</a></code> and <code><a href="lattice.html#topic+levelplot">levelplot</a></code>
for additional plotting settings in 2 dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 1D Example 1
n &lt;- 5
d &lt;- 1 
computer_simulator &lt;- function(x){
    x &lt;- 2 * x + 0.5
    y &lt;- sin(10 * pi * x) / (2 * x) + (x - 1)^4
    return(y)
}
set.seed(3)
library(lhs)
x &lt;- maximinLHS(n,d)
y &lt;- computer_simulator(x)
GPmodel &lt;- GP_fit(x,y)
plot(GPmodel)

## 1D Example 2
n &lt;- 7
d &lt;- 1
computer_simulator &lt;- function(x) {
    y &lt;- log(x + 0.1) + sin(5 * pi * x)
    return(y)
}
set.seed(1)
library(lhs)
x &lt;- maximinLHS(n,d)
y &lt;- computer_simulator(x)
GPmodel &lt;- GP_fit(x, y)
## Plotting with changes from the default line type and characters
plot(GPmodel, resolution = 100, line_type = c(6,2), pch = 5)


## 2D Example: GoldPrice Function
computer_simulator &lt;- function(x) {
    x1 &lt;- 4 * x[, 1] - 2
    x2 &lt;- 4 * x[, 2] - 2
    t1 &lt;- 1 + (x1 + x2 + 1)^2 * (19 - 14 * x1 + 3 * x1^2 - 14 * x2 + 
        6 * x1 * x2 + 3 * x2^2)
    t2 &lt;- 30 + (2 * x1 - 3 * x2)^2 * (18 - 32 * x1 + 12 * x1^2 + 48 * x2 - 
        36 * x1 * x2 + 27 * x2^2)
    y &lt;- t1 * t2
    return(y)
}
n &lt;- 30 
d &lt;- 2
set.seed(1)
x &lt;- lhs::maximinLHS(n, d) 
y &lt;- computer_simulator(x)
GPmodel &lt;- GP_fit(x, y)
## Basic level plot
plot(GPmodel)
## Adding Contours and increasing the number of levels
plot(GPmodel, contour = TRUE, cuts = 50, pretty = TRUE)
## Plotting the Response Surface
plot(GPmodel, surf_check = TRUE)
## Plotting the Error Surface with color
plot(GPmodel, surf_check = TRUE, response = FALSE, shade = TRUE)

</code></pre>

<hr>
<h2 id='predict'>Model Predictions from GPfit</h2><span id='topic+predict'></span><span id='topic+predict.GP'></span><span id='topic+fitted.GP'></span>

<h3>Description</h3>

<p>Computes the regularized predicted response <code class="reqn">\hat{y}_{\delta_{lb},M}(x)</code>
and the mean squared error <code class="reqn">s^2_{\delta_{lb},M}(x)</code> for a new set of
inputs using the fitted GP model.
</p>
<p>The value of <code>M</code> determines the number of iterations (or terms) in
approximating <code class="reqn">R^{-1} \approx R^{-1}_{\delta_{lb},M}</code>. The iterative use
of the nugget <code class="reqn">\delta_{lb}</code>, as outlined in Ranjan et al. (2011), is
used in calculating <code class="reqn">\hat{y}_{\delta_{lb},M}(x)</code> and
<code class="reqn">s^2_{\delta_{lb},M}(x)</code>, where <code class="reqn">R_{\delta,M}^{-1} = \sum_{t =
1}^{M} \delta^{t - 1}(R+\delta I)^{-t}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
predict(object, xnew = object$X, M = 1, ...)

## S3 method for class 'GP'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>a class <code>GP</code> object estimated by <code>GP_fit</code></p>
</td></tr>
<tr><td><code id="predict_+3A_xnew">xnew</code></td>
<td>
<p>the (<code>n_new x d</code>) design matrix of test points where model
predictions and MSEs are desired</p>
</td></tr>
<tr><td><code id="predict_+3A_m">M</code></td>
<td>
<p>the number of iterations. See 'Details'</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>for compatibility with generic method <code><a href="#topic+predict">predict</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the predicted values (<code>Y_hat</code>), the
mean squared errors of the predictions (<code>MSE</code>), and a matrix
(<code>complete_data</code>) containing <code>xnew</code>, <code>Y_hat</code>, and <code>MSE</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>GP</code>: The <code>predict</code> method 
returns a list of elements Y_hat (fitted values), 
Y (dependent variable), MSE (residuals), and 
completed_data (the matrix of independent variables, 
Y_hat, and MSE).
</p>
</li>
<li> <p><code>GP</code>: The <code>fitted</code> method extracts the complete data.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Blake MacDonald, Hugh Chipman, Pritam Ranjan
</p>


<h3>References</h3>

<p>Ranjan, P., Haynes, R., and Karsten, R. (2011). A
Computationally Stable Approach to Gaussian Process Interpolation of
Deterministic Computer Simulation Data, Technometrics, 53(4), 366 - 378.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GP_fit">GP_fit</a></code> for estimating the parameters of the GP model;
<br /> <code><a href="#topic+plot">plot</a></code> for plotting the predicted and error surfaces.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 1D Example
n &lt;- 5
d &lt;- 1
computer_simulator &lt;- function(x){
    x &lt;- 2*x+0.5
    sin(10*pi*x)/(2*x) + (x-1)^4
}
set.seed(3)
library(lhs)
x &lt;- maximinLHS(n,d)
y &lt;- computer_simulator(x)
xvec &lt;- seq(from = 0, to = 1, length.out = 10)
GPmodel &lt;- GP_fit(x, y)
head(fitted(GPmodel))
lapply(predict(GPmodel, xvec), head)


## 1D Example 2
n &lt;- 7
d &lt;- 1
computer_simulator &lt;- function(x) {
    log(x+0.1)+sin(5*pi*x)
}
set.seed(1)
library(lhs)
x &lt;- maximinLHS(n,d)
y &lt;- computer_simulator(x)
xvec &lt;- seq(from = 0,to = 1, length.out = 10)
GPmodel &lt;- GP_fit(x, y)
head(fitted(GPmodel))
predict(GPmodel, xvec)

## 2D Example: GoldPrice Function
computer_simulator &lt;- function(x) {
    x1 &lt;- 4*x[,1] - 2
    x2 &lt;- 4*x[,2] - 2
    t1 &lt;- 1 + (x1 + x2 + 1)^2*(19 - 14*x1 + 3*x1^2 - 14*x2 + 
        6*x1*x2 + 3*x2^2)
    t2 &lt;- 30 + (2*x1 -3*x2)^2*(18 - 32*x1 + 12*x1^2 + 48*x2 - 
        36*x1*x2 + 27*x2^2)
    y &lt;- t1*t2
    return(y)
}
n &lt;- 10
d &lt;- 2
set.seed(1)
library(lhs)
x &lt;- maximinLHS(n,d) 
y &lt;- computer_simulator(x)
GPmodel &lt;- GP_fit(x,y)
# fitted values
head(fitted(GPmodel))
# new data
xvector &lt;- seq(from = 0,to = 1, length.out = 10)
xdf &lt;- expand.grid(x = xvector, y = xvector)
predict(GPmodel, xdf)
</code></pre>

<hr>
<h2 id='print.GP'>GP model fit Summary</h2><span id='topic+print.GP'></span>

<h3>Description</h3>

<p>Prints the summary of a class <code>GP</code> object estimated by <code>GP_fit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GP_+3A_x">x</code></td>
<td>
<p>a class <code>GP</code> object estimated by <code>GP_fit</code></p>
</td></tr>
<tr><td><code id="print.GP_+3A_...">...</code></td>
<td>
<p>for compatibility with generic method <code><a href="base.html#topic+print">print</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the summary of the class <code>GP</code> object. It returns the number of
observations, input dimension, parameter estimates of the GP model, lower
bound on the nugget, and the nugget threshold parameter (described in
<code><a href="#topic+GP_fit">GP_fit</a></code>).
</p>


<h3>Author(s)</h3>

<p>Blake MacDonald, Hugh Chipman, Pritam Ranjan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GP_fit">GP_fit</a></code> for more information on estimating the model;
<br /> <code><a href="base.html#topic+print">print</a></code> for more description on the <code>print</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 1D example
n &lt;- 5
d &lt;- 1 
computer_simulator &lt;- function(x){
    x &lt;- 2 * x + 0.5
    y &lt;- sin(10 * pi * x) / (2 * x) + (x - 1)^4
    return(y)
}
set.seed(3)
x &lt;- lhs::maximinLHS(n, d)
y &lt;- computer_simulator(x)
GPmodel &lt;- GP_fit(x, y)
print(GPmodel)


## 2D Example: GoldPrice Function
computer_simulator &lt;- function(x) {
    x1 &lt;- 4*x[,1] - 2
    x2 &lt;- 4*x[,2] - 2
    t1 &lt;- 1 + (x1 + x2 + 1)^2*(19 - 14*x1 + 3*x1^2 - 14*x2 + 
        6*x1*x2 + 3*x2^2)
    t2 &lt;- 30 + (2*x1 -3*x2)^2*(18 - 32*x1 + 12*x1^2 + 48*x2 - 
        36*x1*x2 + 27*x2^2)
    y &lt;- t1*t2
    return(y)
}
n &lt;- 30 
d &lt;- 2
set.seed(1)
x &lt;- lhs::maximinLHS(n, d) 
y &lt;- computer_simulator(x)
GPmodel &lt;- GP_fit(x,y)
print(GPmodel, digits = 3)

</code></pre>

<hr>
<h2 id='scale_norm'>Scale variable into normal range 0, 1</h2><span id='topic+scale_norm'></span>

<h3>Description</h3>

<p>Perform calculation:
(x - min(x)) / (max(x) - min(x))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_norm(x, range = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_norm_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="scale_norm_+3A_range">range</code></td>
<td>
<p>numeric vector additional values for shrinking
distribution of values within the 0-1 space, without affecting
limits of x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale_norm(x = c(-1, 4, 10, 182))
# lower bound extended beyond -1
# upper bound still range of data
scale_norm(x = c(-1, 4, 10, 182), range = c(-100, 100))
</code></pre>

<hr>
<h2 id='sig_invb'>Internal tools</h2><span id='topic+sig_invb'></span>

<h3>Description</h3>

<p>shared utilities between <code><a href="#topic+GP_deviance">GP_deviance</a></code>
and <code><a href="#topic+GP_fit">GP_fit</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_invb(X, Y, beta, corr = list(type = "exponential", power = 1.95),
  nug_thres = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_invb_+3A_x">X</code></td>
<td>
<p>the (<em>n</em> x <em>d</em>) design matrix</p>
</td></tr>
<tr><td><code id="sig_invb_+3A_y">Y</code></td>
<td>
<p>the (<em>n</em> x 1) vector of simulator outputs</p>
</td></tr>
<tr><td><code id="sig_invb_+3A_beta">beta</code></td>
<td>
<p>a (<em>d</em> x 1) vector of correlation hyper-parameters, as
described in <code><a href="#topic+corr_matrix">corr_matrix</a></code></p>
</td></tr>
<tr><td><code id="sig_invb_+3A_corr">corr</code></td>
<td>
<p>a list of parameters for the specifing the correlation to be
used. See <code><a href="#topic+corr_matrix">corr_matrix</a></code>.</p>
</td></tr>
<tr><td><code id="sig_invb_+3A_nug_thres">nug_thres</code></td>
<td>
<p>a parameter used in computing the nugget. See
<code><a href="#topic+GP_fit">GP_fit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements delta, L, mu_hat, Sig_invb
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(3234)
GPfit:::sig_invb(
    X = matrix((0:10) / 10), 
    Y = runif(11), 
    beta = 1.23)
</code></pre>

<hr>
<h2 id='summary.GP'>Summary of GP model fit</h2><span id='topic+summary.GP'></span>

<h3>Description</h3>

<p>Prints the summary of a class <code>GP</code> object estimated by <code>GP_fit</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GP'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.GP_+3A_object">object</code></td>
<td>
<p>a class <code>GP</code> object estimated by <code>GP_fit</code></p>
</td></tr>
<tr><td><code id="summary.GP_+3A_...">...</code></td>
<td>
<p>for compatibility with generic method <code><a href="base.html#topic+summary">summary</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>prints the summary of the GP object (<code>object</code>), by calling
<code><a href="#topic+print.GP">print.GP</a></code>
</p>


<h3>Author(s)</h3>

<p>Blake MacDonald, Hugh Chipman, Pritam Ranjan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.GP">print.GP</a></code> for more description of the output; <br />
<code><a href="#topic+GP_fit">GP_fit</a></code> for more information on estimating the model; <br />
<code><a href="base.html#topic+summary">summary</a></code> for more description on the <code>summary</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## 1D example
n &lt;- 5
d &lt;- 1 
computer_simulator &lt;- function(x){
    x &lt;- 2 * x + 0.5
    y &lt;- sin(10 * pi * x) / (2 * x) + (x - 1)^4
    return(y)
}
set.seed(3)
x &lt;- lhs::maximinLHS(n, d)
y &lt;- computer_simulator(x)
GPmodel &lt;- GP_fit(x, y)
summary(GPmodel)

## 2D Example: GoldPrice Function
computer_simulator &lt;- function(x) {
    x1 = 4*x[, 1] - 2
    x2 = 4*x[, 2] - 2
    t1 = 1 + (x1 + x2 + 1)^2*(19 - 14*x1 + 3*x1^2 - 14*x2 + 
           6*x1*x2 + 3*x2^2)
    t2 = 30 + (2*x1 -3*x2)^2*(18 - 32*x1 + 12*x1^2 + 48*x2 - 
           36*x1*x2 + 27*x2^2)
    y = t1*t2
    return(y)
}
n &lt;- 10
d &lt;- 2
set.seed(1)
x &lt;- lhs::maximinLHS(n, d) 
y &lt;- computer_simulator(x)
GPmodel &lt;- GP_fit(x, y)
summary(GPmodel)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
