<!DOCTYPE html><html><head><title>Help for package randomizr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {randomizr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#block_and_cluster_ra'><p>Blocked and Clustered Random Assignment</p></a></li>
<li><a href='#block_and_cluster_ra_probabilities'><p>probabilities of assignment: Blocked and Clustered Random Assignment</p></a></li>
<li><a href='#block_ra'><p>Block Random Assignment</p></a></li>
<li><a href='#block_ra_probabilities'><p>probabilities of assignment: Block Random Assignment</p></a></li>
<li><a href='#cluster_ra'><p>Cluster Random Assignment</p></a></li>
<li><a href='#cluster_ra_probabilities'><p>probabilities of assignment: Cluster Random Assignment</p></a></li>
<li><a href='#cluster_rs'><p>Cluster Random Sampling</p></a></li>
<li><a href='#cluster_rs_probabilities'><p>Inclusion Probabilities: Cluster Sampling</p></a></li>
<li><a href='#complete_ra'><p>Complete Random Assignment</p></a></li>
<li><a href='#complete_ra_probabilities'><p>probabilities of assignment: Complete Random Assignment</p></a></li>
<li><a href='#complete_rs'><p>Complete Random Sampling</p></a></li>
<li><a href='#complete_rs_probabilities'><p>Inclusion Probabilities: Complete Random Sampling</p></a></li>
<li><a href='#conduct_ra'><p>Conduct a random assignment</p></a></li>
<li><a href='#custom_ra'><p>Custom Random Assignment</p></a></li>
<li><a href='#custom_ra_probabilities'><p>probabilities of assignment: Custom Random Assignment</p></a></li>
<li><a href='#declare_ra'><p>Declare a random assignment procedure.</p></a></li>
<li><a href='#declare_rs'><p>Declare a random sampling procedure.</p></a></li>
<li><a href='#draw_rs'><p>Draw a random sample</p></a></li>
<li><a href='#obtain_condition_probabilities'><p>Obtain the probabilities of units being in the conditions that they are in.</p></a></li>
<li><a href='#obtain_inclusion_probabilities'><p>Obtain inclusion probabilities</p></a></li>
<li><a href='#obtain_num_permutations'><p>Obtain the Number of Possible Permutations from a Random Assignment Declaration</p></a></li>
<li><a href='#obtain_permutation_matrix'><p>Obtain Permutation Matrix from a Random Assignment Declaration</p></a></li>
<li><a href='#obtain_permutation_probabilities'><p>Obtain the probabilities of permutations</p></a></li>
<li><a href='#randomizr'><p>randomizr</p></a></li>
<li><a href='#simple_ra'><p>Simple Random Assignment</p></a></li>
<li><a href='#simple_ra_probabilities'><p>probabilities of assignment: Simple Random Assignment</p></a></li>
<li><a href='#simple_rs'><p>Simple Random Sampling</p></a></li>
<li><a href='#simple_rs_probabilities'><p>Inclusion Probabilities: Simple Random Sampling</p></a></li>
<li><a href='#strata_and_cluster_rs'><p>Stratified and Clustered Random Sampling</p></a></li>
<li><a href='#strata_and_cluster_rs_probabilities'><p>Inclusion Probabilities: Stratified and Clustered Random Sampling</p></a></li>
<li><a href='#strata_rs'><p>Stratified Random Sampling</p></a></li>
<li><a href='#strata_rs_probabilities'><p>Inclusion Probabilities: Stratified Random Sampling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Easy-to-Use Tools for Common Forms of Random Assignment and
Sampling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates random assignments for common experimental designs and 
	    random samples for common sampling designs.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://declaredesign.org/r/randomizr/">https://declaredesign.org/r/randomizr/</a>,
<a href="https://github.com/DeclareDesign/randomizr">https://github.com/DeclareDesign/randomizr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DeclareDesign/randomizr/issues">https://github.com/DeclareDesign/randomizr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, dplyr, testthat, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-08 19:54:09 UTC; gblair</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Coppock <a href="https://orcid.org/0000-0002-5733-2386"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jasper Cooper <a href="https://orcid.org/0000-0002-8639-3188"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Neal Fultz [ctb] (C version of restricted partitions),
  Graeme Blair <a href="https://orcid.org/0000-0001-9164-2102"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Coppock &lt;acoppock@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-10 06:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='block_and_cluster_ra'>Blocked and Clustered Random Assignment</h2><span id='topic+block_and_cluster_ra'></span>

<h3>Description</h3>

<p>A random assignment procedure in which units are assigned as clusters and clusters are nested within blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_and_cluster_ra(
  blocks = NULL,
  clusters = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  m = NULL,
  m_unit = NULL,
  block_m = NULL,
  block_m_each = NULL,
  block_prob = NULL,
  block_prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_and_cluster_ra_+3A_blocks">blocks</code></td>
<td>
<p>A vector of length N that indicates which block each unit belongs to.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N_clusters_block*prob) or ceiling(N_clusters_block*prob) clusters are assigned to treatment within each block. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N_clusters_block*prob) clusters will be assigned to treatment and with probability prob, ceiling(N_clusters_block*prob) clusters will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two arm design. Must of be of length N. tapply(prob_unit, blocks, unique) will be passed to <code>block_prob</code>.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of clusters assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which the scalar m describes the fixed number of clusters assigned in each block. This number does not vary across blocks.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm design. Must be of length N. tapply(m_unit, blocks, unique) will be passed to <code>block_m</code>.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_block_m">block_m</code></td>
<td>
<p>Use for a two-arm design in which block_m describes the number of clusters to assign to treatment within each block. block_m must be a numeric vector that is as long as the number of blocks and is in the same order as sort(unique(blocks)).</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_block_m_each">block_m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_m_each determine the number of clusters assigned to each condition. block_m_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the number of clusters to be assigned to each treatment arm within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). The columns should be in the order of conditions, if specified.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_block_prob">block_prob</code></td>
<td>
<p>Use for a two-arm design in which block_prob describes the probability of assignment to treatment within each block. Must be in the same order as sort(unique(blocks)). Differs from prob in that the probability of assignment can vary across blocks.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_block_prob_each">block_prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_prob_each determine the probabilities of assignment to each treatment condition. block_prob_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the probabilities of assignment to treatment within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). Use only if the probabilities of assignment should vary by block, otherwise use prob_each. Each row of block_prob_each must sum to 1.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length N that indicates the treatment condition of each unit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clusters &lt;- rep(letters, times=1:26)

blocks &lt;- rep(NA, length(clusters))
blocks[clusters %in% letters[1:5]] &lt;- "block_1"
blocks[clusters %in% letters[6:10]] &lt;- "block_2"
blocks[clusters %in% letters[11:15]] &lt;- "block_3"
blocks[clusters %in% letters[16:20]] &lt;- "block_4"
blocks[clusters %in% letters[21:26]] &lt;- "block_5"


table(blocks, clusters)

Z &lt;- block_and_cluster_ra(blocks = blocks,
                          clusters = clusters)

table(Z, blocks)
table(Z, clusters)

Z &lt;- block_and_cluster_ra(blocks = blocks,
                          clusters = clusters,
                          num_arms = 3)

table(Z, blocks)
table(Z, clusters)

Z &lt;- block_and_cluster_ra(blocks = blocks,
                          clusters = clusters,
                          prob_each = c(.2, .5, .3))

block_m_each &lt;- rbind(c(2, 3),
                      c(1, 4),
                      c(3, 2),
                      c(2, 3),
                      c(5, 1))

Z &lt;- block_and_cluster_ra(blocks = blocks,
                          clusters = clusters,
                          block_m_each = block_m_each)

table(Z, blocks)
table(Z, clusters)

</code></pre>

<hr>
<h2 id='block_and_cluster_ra_probabilities'>probabilities of assignment: Blocked and Clustered Random Assignment</h2><span id='topic+block_and_cluster_ra_probabilities'></span>

<h3>Description</h3>

<p>probabilities of assignment: Blocked and Clustered Random Assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_and_cluster_ra_probabilities(
  blocks = NULL,
  clusters = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  m = NULL,
  m_unit = NULL,
  block_m = NULL,
  block_m_each = NULL,
  block_prob = NULL,
  block_prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_blocks">blocks</code></td>
<td>
<p>A vector of length N that indicates which block each unit belongs to.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N_clusters_block*prob) or ceiling(N_clusters_block*prob) clusters are assigned to treatment within each block. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N_clusters_block*prob) clusters will be assigned to treatment and with probability prob, ceiling(N_clusters_block*prob) clusters will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two arm design. Must of be of length N. tapply(prob_unit, blocks, unique) will be passed to <code>block_prob</code>.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of clusters assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which the scalar m describes the fixed number of clusters assigned in each block. This number does not vary across blocks.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm design. Must be of length N. tapply(m_unit, blocks, unique) will be passed to <code>block_m</code>.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_block_m">block_m</code></td>
<td>
<p>Use for a two-arm design in which block_m describes the number of clusters to assign to treatment within each block. block_m must be a numeric vector that is as long as the number of blocks and is in the same order as sort(unique(blocks)).</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_block_m_each">block_m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_m_each determine the number of clusters assigned to each condition. block_m_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the number of clusters to be assigned to each treatment arm within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). The columns should be in the order of conditions, if specified.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_block_prob">block_prob</code></td>
<td>
<p>Use for a two-arm design in which block_prob describes the probability of assignment to treatment within each block. Must be in the same order as sort(unique(blocks)). Differs from prob in that the probability of assignment can vary across blocks.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_block_prob_each">block_prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_prob_each determine the probabilities of assignment to each treatment condition. block_prob_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the probabilities of assignment to treatment within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). Use only if the probabilities of assignment should vary by block, otherwise use prob_each. Each row of block_prob_each must sum to 1.</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="block_and_cluster_ra_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities of assignment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
clusters &lt;- rep(letters, times=1:26)
blocks &lt;- rep(NA, length(clusters))
blocks[clusters %in% letters[1:5]] &lt;- "block_1"
blocks[clusters %in% letters[6:10]] &lt;- "block_2"
blocks[clusters %in% letters[11:15]] &lt;- "block_3"
blocks[clusters %in% letters[16:20]] &lt;- "block_4"
blocks[clusters %in% letters[21:26]] &lt;- "block_5"


prob_mat &lt;- block_and_cluster_ra_probabilities(clusters = clusters,
                                               blocks = blocks)
head(prob_mat)
                                    
prob_mat &lt;- block_and_cluster_ra_probabilities(clusters = clusters,
                                               blocks = blocks,
                                               num_arms = 3)
head(prob_mat)
                                    
prob_mat &lt;- block_and_cluster_ra_probabilities(clusters = clusters,
                                               blocks = blocks,
                                               prob_each = c(.2, .5, .3))
head(prob_mat)                                    

block_m_each &lt;- rbind(c(2, 3),
                      c(1, 4),
                      c(3, 2),
                      c(2, 3),
                      c(5, 1))

prob_mat &lt;- block_and_cluster_ra_probabilities(clusters = clusters, 
                                               blocks = blocks, 
                                               block_m_each = block_m_each)
head(prob_mat)                                    


</code></pre>

<hr>
<h2 id='block_ra'>Block Random Assignment</h2><span id='topic+block_ra'></span>

<h3>Description</h3>

<p>block_ra implements a random assignment procedure in which units that are grouped into blocks defined by pre-treatment covariates are assigned using complete random assignment within block. For example, imagine that 50 of 100 men are assigned to treatment and 75 of 200 women are assigned to treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_ra(
  blocks = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  m = NULL,
  m_unit = NULL,
  block_m = NULL,
  block_m_each = NULL,
  block_prob = NULL,
  block_prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_ra_+3A_blocks">blocks</code></td>
<td>
<p>A vector of length N that indicates which block each unit belongs to. Can be a character, factor, or numeric vector. (required)</p>
</td></tr>
<tr><td><code id="block_ra_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N_block*prob) or ceiling(N_block*prob) units are assigned to treatment within each block. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N_block*prob) units will be assigned to treatment and with probability prob, ceiling(N_block*prob) units will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="block_ra_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two arm design. Must of be of length N. tapply(prob_unit, blocks, unique) will be passed to <code>block_prob</code>.</p>
</td></tr>
<tr><td><code id="block_ra_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of units assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="block_ra_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which the scalar m describes the fixed number of units to assign in each block. This number does not vary across blocks.</p>
</td></tr>
<tr><td><code id="block_ra_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm design. Must be of length N. tapply(m_unit, blocks, unique) will be passed to <code>block_m</code>.</p>
</td></tr>
<tr><td><code id="block_ra_+3A_block_m">block_m</code></td>
<td>
<p>Use for a two-arm design in which the vector block_m describes the number of units to assign to treatment within each block. block_m must be a numeric vector that is as long as the number of blocks and is in the same order as sort(unique(blocks)).</p>
</td></tr>
<tr><td><code id="block_ra_+3A_block_m_each">block_m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_m_each determine the number of units assigned to each condition. block_m_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the number of units to be assigned to each treatment arm within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). The columns should be in the order of conditions, if specified.</p>
</td></tr>
<tr><td><code id="block_ra_+3A_block_prob">block_prob</code></td>
<td>
<p>Use for a two-arm design in which block_prob describes the probability of assignment to treatment within each block. Must be in the same order as sort(unique(blocks)). Differs from prob in that the probability of assignment can vary across blocks.</p>
</td></tr>
<tr><td><code id="block_ra_+3A_block_prob_each">block_prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_prob_each determine the probabilities of assignment to each treatment condition. block_prob_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the probabilities of assignment to treatment within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). Use only if the probabilities of assignment should vary by block, otherwise use prob_each. Each row of block_prob_each must sum to 1.</p>
</td></tr>
<tr><td><code id="block_ra_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="block_ra_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="block_ra_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length N that indicates the treatment condition of each unit. Is numeric in a two-arm trial and a factor variable (ordered by conditions) in a multi-arm trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Two-arm Designs

blocks &lt;- rep(c("A", "B","C"), times = c(50, 100, 200))
Z &lt;- block_ra(blocks = blocks)
table(blocks, Z)

Z &lt;- block_ra(blocks = blocks, prob = .3)
table(blocks, Z)

Z &lt;- block_ra(blocks = blocks, block_prob = c(.1, .2, .3))
table(blocks, Z)

Z &lt;- block_ra(blocks = blocks, 
              prob_unit = rep(c(.1, .2, .3), 
                              times = c(50, 100, 200)))
table(blocks, Z)

Z &lt;- block_ra(blocks = blocks, m = 20)
table(blocks, Z)

Z &lt;- block_ra(blocks = blocks, block_m = c(20, 30, 40))
table(blocks, Z)

Z &lt;- block_ra(blocks = blocks, 
              m_unit = rep(c(20, 30, 40),
                           times = c(50, 100, 200)))
table(blocks, Z)

block_m_each &lt;- rbind(c(25, 25),
                 c(50, 50),
                 c(100, 100))

Z &lt;- block_ra(blocks = blocks, block_m_each = block_m_each)
table(blocks, Z)

block_m_each &lt;- rbind(c(10, 40),
                 c(30, 70),
                 c(50, 150))

Z &lt;- block_ra(blocks = blocks, block_m_each = block_m_each,
              conditions = c("control", "treatment"))
table(blocks, Z)

# Multi-arm Designs
Z &lt;- block_ra(blocks = blocks, num_arms = 3)
table(blocks, Z)

block_m_each &lt;- rbind(c(10, 20, 20),
                 c(30, 50, 20),
                 c(50, 75, 75))
Z &lt;- block_ra(blocks = blocks, block_m_each = block_m_each)
table(blocks, Z)

Z &lt;- block_ra(blocks = blocks, block_m_each = block_m_each,
              conditions = c("control", "placebo", "treatment"))
table(blocks, Z)

Z &lt;- block_ra(blocks = blocks, prob_each = c(.1, .1, .8))
table(blocks, Z)



</code></pre>

<hr>
<h2 id='block_ra_probabilities'>probabilities of assignment: Block Random Assignment</h2><span id='topic+block_ra_probabilities'></span>

<h3>Description</h3>

<p>probabilities of assignment: Block Random Assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block_ra_probabilities(
  blocks = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  m = NULL,
  m_unit = NULL,
  block_m = NULL,
  block_m_each = NULL,
  block_prob = NULL,
  block_prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_ra_probabilities_+3A_blocks">blocks</code></td>
<td>
<p>A vector of length N that indicates which block each unit belongs to. Can be a character, factor, or numeric vector. (required)</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N_block*prob) or ceiling(N_block*prob) units are assigned to treatment within each block. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N_block*prob) units will be assigned to treatment and with probability prob, ceiling(N_block*prob) units will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two arm design. Must of be of length N. tapply(prob_unit, blocks, unique) will be passed to <code>block_prob</code>.</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of units assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which the scalar m describes the fixed number of units to assign in each block. This number does not vary across blocks.</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm design. Must be of length N. tapply(m_unit, blocks, unique) will be passed to <code>block_m</code>.</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_block_m">block_m</code></td>
<td>
<p>Use for a two-arm design in which the vector block_m describes the number of units to assign to treatment within each block. block_m must be a numeric vector that is as long as the number of blocks and is in the same order as sort(unique(blocks)).</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_block_m_each">block_m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_m_each determine the number of units assigned to each condition. block_m_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the number of units to be assigned to each treatment arm within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). The columns should be in the order of conditions, if specified.</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_block_prob">block_prob</code></td>
<td>
<p>Use for a two-arm design in which block_prob describes the probability of assignment to treatment within each block. Must be in the same order as sort(unique(blocks)). Differs from prob in that the probability of assignment can vary across blocks.</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_block_prob_each">block_prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_prob_each determine the probabilities of assignment to each treatment condition. block_prob_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the probabilities of assignment to treatment within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). Use only if the probabilities of assignment should vary by block, otherwise use prob_each. Each row of block_prob_each must sum to 1.</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="block_ra_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities of assignment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
blocks &lt;- rep(c("A", "B","C"), times = c(50, 100, 200))
prob_mat &lt;- block_ra_probabilities(blocks = blocks)
head(prob_mat)

prob_mat &lt;- block_ra_probabilities(blocks = blocks, m = 20)
head(prob_mat)

block_m_each &lt;- rbind(c(25, 25),
                 c(50, 50),
                 c(100, 100))

prob_mat &lt;- block_ra_probabilities(blocks = blocks, block_m_each = block_m_each)
head(prob_mat)

block_m_each &lt;- rbind(c(10, 40),
                 c(30, 70),
                 c(50, 150))

prob_mat &lt;- block_ra_probabilities(blocks = blocks,
                                   block_m_each = block_m_each,
                                   conditions = c("control", "treatment"))
head(prob_mat)

prob_mat &lt;- block_ra_probabilities(blocks = blocks, num_arms = 3)
head(prob_mat)

block_m_each &lt;- rbind(c(10, 20, 20),
                 c(30, 50, 20),
                 c(50, 75, 75))
prob_mat &lt;- block_ra_probabilities(blocks = blocks, block_m_each = block_m_each)
head(prob_mat)

prob_mat &lt;- block_ra_probabilities(blocks=blocks, block_m_each=block_m_each,
                       conditions=c("control", "placebo", "treatment"))
head(prob_mat)

prob_mat &lt;- block_ra_probabilities(blocks=blocks, prob_each=c(.1, .1, .8))
head(prob_mat)

</code></pre>

<hr>
<h2 id='cluster_ra'>Cluster Random Assignment</h2><span id='topic+cluster_ra'></span>

<h3>Description</h3>

<p>cluster_ra implements a random assignment procedure in which groups of units are assigned together (as a cluster) to treatment conditions. This function conducts complete random assignment at the cluster level, unless simple = TRUE, in which case <code><a href="#topic+simple_ra">simple_ra</a></code> analogues are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_ra(
  clusters = NULL,
  m = NULL,
  m_unit = NULL,
  m_each = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  simple = FALSE,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_ra_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which m clusters are assigned to treatment and N_clusters-m clusters are assigned to control. (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm design in which exactly unique(m_unit) clusters are assigned to treatment and the remainder are assigned to control. m_unit must be of length N and must be the same for all units (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_m_each">m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of m_each determine the number of clusters assigned to each condition. m_each must be a numeric vector in which each entry is a nonnegative integer that describes how many clusters should be assigned to the 1st, 2nd, 3rd... treatment condition. m_each must sum to N. (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N_clusters*prob) or ceiling(N_clusters*prob) clusters are assigned to treatment. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N_clusters*prob) clusters will be assigned to treatment and with probability prob, ceiling(N_clusters*prob) clusters will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two-arm design. unique(prob_unit) will be passed to the prob argument and must be the same for all units.</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of clusters assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_num_arms">num_arms</code></td>
<td>
<p>The total number of treatment arms. If unspecified, will be determined from the length of m_each or conditions.</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named T1, T2, T3, etc.</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random assignment of clusters to conditions is used. When simple = TRUE, please do not specify m or m_each.</p>
</td></tr>
<tr><td><code id="cluster_ra_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length N that indicates the treatment condition of each unit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two Group Designs
clusters &lt;- rep(letters, times=1:26)

Z &lt;- cluster_ra(clusters = clusters)
table(Z, clusters)

Z &lt;- cluster_ra(clusters = clusters, m = 13)
table(Z, clusters)

Z &lt;- cluster_ra(clusters = clusters, m_each = c(10, 16),
                conditions = c("control", "treatment"))
table(Z, clusters)

# Multi-arm Designs
Z &lt;- cluster_ra(clusters = clusters, num_arms = 3)
table(Z, clusters)

Z &lt;- cluster_ra(clusters = clusters, m_each = c(7, 7, 12))
table(Z, clusters)

Z &lt;- cluster_ra(clusters = clusters, m_each = c(7, 7, 12),
                conditions = c("control", "placebo", "treatment"))
table(Z, clusters)

Z &lt;- cluster_ra(clusters = clusters,
                conditions = c("control", "placebo", "treatment"))
table(Z, clusters)
</code></pre>

<hr>
<h2 id='cluster_ra_probabilities'>probabilities of assignment: Cluster Random Assignment</h2><span id='topic+cluster_ra_probabilities'></span>

<h3>Description</h3>

<p>probabilities of assignment: Cluster Random Assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_ra_probabilities(
  clusters = NULL,
  m = NULL,
  m_unit = NULL,
  m_each = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  simple = FALSE,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_ra_probabilities_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which m clusters are assigned to treatment and N_clusters-m clusters are assigned to control. (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm design in which exactly unique(m_unit) clusters are assigned to treatment and the remainder are assigned to control. m_unit must be of length N and must be the same for all units (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_m_each">m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of m_each determine the number of clusters assigned to each condition. m_each must be a numeric vector in which each entry is a nonnegative integer that describes how many clusters should be assigned to the 1st, 2nd, 3rd... treatment condition. m_each must sum to N. (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N_clusters*prob) or ceiling(N_clusters*prob) clusters are assigned to treatment. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N_clusters*prob) clusters will be assigned to treatment and with probability prob, ceiling(N_clusters*prob) clusters will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two-arm design. unique(prob_unit) will be passed to the prob argument and must be the same for all units.</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of clusters assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_num_arms">num_arms</code></td>
<td>
<p>The total number of treatment arms. If unspecified, will be determined from the length of m_each or conditions.</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named T1, T2, T3, etc.</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random assignment of clusters to conditions is used. When simple = TRUE, please do not specify m or m_each.</p>
</td></tr>
<tr><td><code id="cluster_ra_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities of assignment
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Two Group Designs
clusters &lt;- rep(letters, times = 1:26)
prob_mat &lt;- cluster_ra_probabilities(clusters = clusters)
head(prob_mat)

prob_mat &lt;- cluster_ra_probabilities(clusters = clusters, m = 10)
head(prob_mat)

prob_mat &lt;- cluster_ra_probabilities(clusters = clusters,
                                     m_each = c(9, 17),
                                     conditions = c("control", "treatment"))

# Multi-arm Designs
prob_mat &lt;- cluster_ra_probabilities(clusters = clusters, num_arms = 3)
head(prob_mat)

prob_mat &lt;- cluster_ra_probabilities(clusters = clusters, m_each = c(7, 7, 12))
head(prob_mat)

prob_mat &lt;- cluster_ra_probabilities(clusters = clusters, m_each = c(7, 7, 12),
                         conditions=c("control", "placebo", "treatment"))
head(prob_mat)

prob_mat &lt;- cluster_ra_probabilities(clusters = clusters,
                         conditions=c("control", "placebo", "treatment"))
head(prob_mat)

prob_mat &lt;- cluster_ra_probabilities(clusters = clusters,
                                     prob_each = c(.1, .2, .7))
head(prob_mat)



</code></pre>

<hr>
<h2 id='cluster_rs'>Cluster Random Sampling</h2><span id='topic+cluster_rs'></span>

<h3>Description</h3>

<p>cluster_rs implements a random sampling procedure in which groups of units are sampled together (as a cluster). This function conducts complete random sampling at the cluster level, unless simple = TRUE, in which case <code><a href="#topic+simple_rs">simple_rs</a></code> analogues are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_rs(
  clusters = NULL,
  n = NULL,
  n_unit = NULL,
  prob = NULL,
  prob_unit = NULL,
  simple = FALSE,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_rs_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="cluster_rs_+3A_n">n</code></td>
<td>
<p>Use for a design in which n clusters are sampled. (optional)</p>
</td></tr>
<tr><td><code id="cluster_rs_+3A_n_unit">n_unit</code></td>
<td>
<p>unique(n_unit) will be passed to <code>n</code>. Must be the same for all units (optional)</p>
</td></tr>
<tr><td><code id="cluster_rs_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N_clusters*prob) or ceiling(N_clusters*prob) clusters are sampled. The probability of being sampled is exactly prob because with probability 1-prob, floor(N_clusters*prob) clusters will be sampled and with probability prob, ceiling(N_clusters*prob) clusters will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="cluster_rs_+3A_prob_unit">prob_unit</code></td>
<td>
<p>unique(prob_unit) will be passed to the prob argument and must be the same for all units.</p>
</td></tr>
<tr><td><code id="cluster_rs_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random sampling of clusters. When simple = TRUE, please do not specify n.</p>
</td></tr>
<tr><td><code id="cluster_rs_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length N that indicates if a unit is sampled (1) or not (0).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clusters &lt;- rep(letters, times=1:26)

S &lt;- cluster_rs(clusters = clusters)
table(S, clusters)

S &lt;- cluster_rs(clusters = clusters, n = 13)
table(S, clusters)

</code></pre>

<hr>
<h2 id='cluster_rs_probabilities'>Inclusion Probabilities: Cluster Sampling</h2><span id='topic+cluster_rs_probabilities'></span>

<h3>Description</h3>

<p>Inclusion Probabilities: Cluster Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_rs_probabilities(
  clusters = NULL,
  n = NULL,
  n_unit = NULL,
  prob = NULL,
  prob_unit = NULL,
  simple = FALSE,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_rs_probabilities_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="cluster_rs_probabilities_+3A_n">n</code></td>
<td>
<p>Use for a design in which n clusters are sampled. (optional)</p>
</td></tr>
<tr><td><code id="cluster_rs_probabilities_+3A_n_unit">n_unit</code></td>
<td>
<p>unique(n_unit) will be passed to <code>n</code>. Must be the same for all units (optional)</p>
</td></tr>
<tr><td><code id="cluster_rs_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N_clusters*prob) or ceiling(N_clusters*prob) clusters are sampled. The probability of being sampled is exactly prob because with probability 1-prob, floor(N_clusters*prob) clusters will be sampled and with probability prob, ceiling(N_clusters*prob) clusters will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="cluster_rs_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>unique(prob_unit) will be passed to the prob argument and must be the same for all units.</p>
</td></tr>
<tr><td><code id="cluster_rs_probabilities_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random sampling of clusters. When simple = TRUE, please do not specify n.</p>
</td></tr>
<tr><td><code id="cluster_rs_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector length N indicating the probability of being sampled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Two Group Designs
clusters &lt;- rep(letters, times = 1:26)
probs &lt;- cluster_rs_probabilities(clusters = clusters)
table(probs, clusters)

prob_mat &lt;- cluster_rs_probabilities(clusters = clusters, n = 10)
table(probs, clusters)

prob_mat &lt;- cluster_rs_probabilities(clusters = clusters, prob = .3)
table(probs, clusters)


</code></pre>

<hr>
<h2 id='complete_ra'>Complete Random Assignment</h2><span id='topic+complete_ra'></span>

<h3>Description</h3>

<p>complete_ra implements a random assignment procedure in which fixed numbers of units are assigned to treatment conditions. The canonical example of complete random assignment is a procedure in which exactly m of N units are assigned to treatment and N-m units are assigned to control.<br /> <br />
Users can set the exact number of units to assign to each condition with m or m_each. Alternatively, users can specify probabilities of assignment with prob or prob_each and complete_ra will infer the correct number of units to assign to each condition.
In a two-arm design, complete_ra will either assign floor(N*prob) or ceiling(N*prob) units to treatment, choosing between these two values to ensure that the overall probability of assignment is exactly prob.
In a multi-arm design, complete_ra will first assign floor(N*prob_each) units to their respective conditions, then will assign the remaining units using simple random assignment, choosing these second-stage probabilities so that the overall probabilities of assignment are exactly prob_each.<br /> <br />
In most cases, users should specify N and not more than one of m, m_each, prob, prob_each, or num_arms. <br /> <br />
If only N is specified, a two-arm trial in which N/2 units are assigned to treatment is assumed. If N is odd, either floor(N/2) units or ceiling(N/2) units will be assigned to treatment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_ra(
  N,
  m = NULL,
  m_unit = NULL,
  m_each = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_ra_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which m units are assigned to treatment and N-m units are assigned to control. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm design in which exactly unique(m_unit) units are assigned to treatment and the remainder are assigned to control. m_unit must be of length N and must be the same for all units (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_m_each">m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of m_each determine the number of units assigned to each condition. m_each must be a numeric vector in which each entry is a nonnegative integer that describes how many units should be assigned to the 1st, 2nd, 3rd... treatment condition. m_each must sum to N. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N*prob) or ceiling(N*prob) units are assigned to treatment. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N*prob) units will be assigned to treatment and with probability prob, ceiling(N*prob) units will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two-arm design. unique(prob_unit) will be passed to the prob argument and must be the same for all units.</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of units assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length N that indicates the treatment condition of each unit. Is numeric in a two-arm trial and a factor variable (ordered by conditions) in a multi-arm trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two-arm Designs
Z &lt;- complete_ra(N = 100)
table(Z)

Z &lt;- complete_ra(N = 100, m = 50)
table(Z)

Z &lt;- complete_ra(N = 100, m_unit = rep(50, 100))
table(Z)

Z &lt;- complete_ra(N = 100, prob = .111)
table(Z)

Z &lt;- complete_ra(N = 100, prob_unit = rep(0.1, 100))
table(Z)

Z &lt;- complete_ra(N = 100, conditions = c("control", "treatment"))
table(Z)


# Multi-arm Designs
Z &lt;- complete_ra(N = 100, num_arms = 3)
table(Z)

Z &lt;- complete_ra(N = 100, m_each = c(30, 30, 40))
table(Z)

Z &lt;- complete_ra(N = 100, prob_each = c(.1, .2, .7))
table(Z)

Z &lt;- complete_ra(N = 100, conditions = c("control", "placebo", "treatment"))
table(Z)

# Special Cases
# Two-arm trial where the conditions are by default "T1" and "T2"
Z &lt;- complete_ra(N = 100, num_arms = 2)
table(Z)

# If N = m, assign with 100% probability
complete_ra(N=2, m=2)

# Up through randomizr 0.12.0, 
complete_ra(N=1, m=1) # assigned with 50% probability
# This behavior has been deprecated

</code></pre>

<hr>
<h2 id='complete_ra_probabilities'>probabilities of assignment: Complete Random Assignment</h2><span id='topic+complete_ra_probabilities'></span>

<h3>Description</h3>

<p>probabilities of assignment: Complete Random Assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_ra_probabilities(
  N,
  m = NULL,
  m_unit = NULL,
  m_each = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_ra_probabilities_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which m units are assigned to treatment and N-m units are assigned to control. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm design in which exactly unique(m_unit) units are assigned to treatment and the remainder are assigned to control. m_unit must be of length N and must be the same for all units (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_m_each">m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of m_each determine the number of units assigned to each condition. m_each must be a numeric vector in which each entry is a nonnegative integer that describes how many units should be assigned to the 1st, 2nd, 3rd... treatment condition. m_each must sum to N. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N*prob) or ceiling(N*prob) units are assigned to treatment. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N*prob) units will be assigned to treatment and with probability prob, ceiling(N*prob) units will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two-arm design. unique(prob_unit) will be passed to the prob argument and must be the same for all units.</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of units assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="complete_ra_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities of assignment
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2-arm designs
prob_mat &lt;- complete_ra_probabilities(N=100)
head(prob_mat)

prob_mat &lt;- complete_ra_probabilities(N=100, m=50)
head(prob_mat)

prob_mat &lt;- complete_ra_probabilities(N=100, prob = .3)
head(prob_mat)

prob_mat &lt;- complete_ra_probabilities(N=100, m_each = c(30, 70),
                          conditions = c("control", "treatment"))
head(prob_mat)

# Multi-arm Designs
prob_mat &lt;- complete_ra_probabilities(N=100, num_arms=3)
head(prob_mat)

prob_mat &lt;- complete_ra_probabilities(N=100, m_each=c(30, 30, 40))
head(prob_mat)

prob_mat &lt;- complete_ra_probabilities(N=100, m_each=c(30, 30, 40),
                          conditions=c("control", "placebo", "treatment"))
head(prob_mat)

prob_mat &lt;- complete_ra_probabilities(N=100, conditions=c("control", "placebo", "treatment"))
head(prob_mat)

prob_mat &lt;- complete_ra_probabilities(N=100, prob_each = c(.2, .7, .1))
head(prob_mat)

</code></pre>

<hr>
<h2 id='complete_rs'>Complete Random Sampling</h2><span id='topic+complete_rs'></span>

<h3>Description</h3>

<p>complete_rs implements a random sampling procedure in which fixed numbers of units are sampled. The canonical example of complete random sampling is a procedure in which exactly n of N units are sampled.<br /> <br />
Users can set the exact number of units to sample with n. Alternatively, users can specify the probability of being sampled with prob and complete_rs will infer the correct number of units to sample.
complete_rs will either sample floor(N*prob) or ceiling(N*prob) units, choosing between these two values to ensure that the overall probability of being sampled is exactly prob.
Users should specify N and not more than one of n or prob. <br /> <br />
If only N is specified, N/2 units will be sampled. If N is odd, either floor(N/2) units or ceiling(N/2) units will be sampled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_rs(
  N,
  n = NULL,
  n_unit = NULL,
  prob = NULL,
  prob_unit = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_rs_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="complete_rs_+3A_n">n</code></td>
<td>
<p>Use for a design in which exactly n units are sampled. (optional)</p>
</td></tr>
<tr><td><code id="complete_rs_+3A_n_unit">n_unit</code></td>
<td>
<p>unique(n_unit) will be passed to <code>n</code>. Must be the same for all units (optional)</p>
</td></tr>
<tr><td><code id="complete_rs_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N*prob) or ceiling(N*prob) units are sampled. The probability of being sampled is exactly prob because with probability 1-prob, floor(N*prob) units will be sampled and with probability prob, ceiling(N*prob) units will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="complete_rs_+3A_prob_unit">prob_unit</code></td>
<td>
<p>unique(prob_unit) will be passed to the prob argument and must be the same for all units.</p>
</td></tr>
<tr><td><code id="complete_rs_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length N that indicates if a unit is sampled (1) or not (0).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- complete_rs(N = 100)
table(S)

S &lt;- complete_rs(N = 100, n = 50)
table(S)

S &lt;- complete_rs(N = 100, n_unit = rep(50, 100))
table(S)

S &lt;- complete_rs(N = 100, prob = .111)
table(S)

S &lt;- complete_rs(N = 100, prob_unit = rep(.1, 100))
table(S)

# If N = n, sample with 100% probability...
complete_rs(N=2, n=2)

# Up through randomizr 0.12.0, 
# This behavior has been deprecated
complete_rs(N=1, n=1) # sampled with 50% probability


</code></pre>

<hr>
<h2 id='complete_rs_probabilities'>Inclusion Probabilities: Complete Random Sampling</h2><span id='topic+complete_rs_probabilities'></span>

<h3>Description</h3>

<p>Inclusion Probabilities: Complete Random Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete_rs_probabilities(
  N,
  n = NULL,
  n_unit = NULL,
  prob = NULL,
  prob_unit = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complete_rs_probabilities_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="complete_rs_probabilities_+3A_n">n</code></td>
<td>
<p>Use for a design in which exactly n units are sampled. (optional)</p>
</td></tr>
<tr><td><code id="complete_rs_probabilities_+3A_n_unit">n_unit</code></td>
<td>
<p>unique(n_unit) will be passed to <code>n</code>. Must be the same for all units (optional)</p>
</td></tr>
<tr><td><code id="complete_rs_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N*prob) or ceiling(N*prob) units are sampled. The probability of being sampled is exactly prob because with probability 1-prob, floor(N*prob) units will be sampled and with probability prob, ceiling(N*prob) units will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="complete_rs_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>unique(prob_unit) will be passed to the prob argument and must be the same for all units.</p>
</td></tr>
<tr><td><code id="complete_rs_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector length N indicating the probability of being sampled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probs &lt;- complete_rs_probabilities(N = 100)
table(probs)

probs &lt;- complete_rs_probabilities(N = 100, n = 50)
table(probs)

probs &lt;- complete_rs_probabilities(N=100, prob = .3)
table(probs)

</code></pre>

<hr>
<h2 id='conduct_ra'>Conduct a random assignment</h2><span id='topic+conduct_ra'></span>

<h3>Description</h3>

<p>You can either give conduct_ra() an declaration, as created by <code><a href="#topic+declare_ra">declare_ra</a></code> or you can specify the other arguments to describe a random assignment procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conduct_ra(
  declaration = NULL,
  N = NULL,
  blocks = NULL,
  clusters = NULL,
  m = NULL,
  m_unit = NULL,
  m_each = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  block_m = NULL,
  block_m_each = NULL,
  block_prob = NULL,
  block_prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  simple = FALSE,
  permutation_matrix = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conduct_ra_+3A_declaration">declaration</code></td>
<td>
<p>A random assignment declaration, created by <code><a href="#topic+declare_ra">declare_ra</a></code>.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_blocks">blocks</code></td>
<td>
<p>A vector of length N that indicates which block each unit belongs to.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which m units (or clusters) are assigned to treatment and N-m units (or clusters) are assigned to control. In a blocked design, exactly m units in each block will be treated. (optional)</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm trial. Under complete random assignment, must be constant across units. Under blocked random assignment, must be constant within blocks.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_m_each">m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of m_each determine the number of units (or clusters) assigned to each condition. m_each must be a numeric vector in which each entry is a nonnegative integer that describes how many units (or clusters) should be assigned to the 1st, 2nd, 3rd... treatment condition. m_each must sum to N. (optional)</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N*prob) or ceiling(N*prob) units (or clusters) are assigned to treatment. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N*prob) units (or clusters) will be assigned to treatment and with probability prob, ceiling(N*prob) units (or clusters) will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two arm design. Must of be of length N. Under simple random assignment, can be different for each unit or cluster.  Under complete random assignment, must be constant across units. Under blocked random assignment, must be constant within blocks.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of units assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_block_m">block_m</code></td>
<td>
<p>Use for a two-arm design in which block_m describes the number of units to assign to treatment within each block. Note that in previous versions of randomizr, block_m behaved like block_m_each.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_block_m_each">block_m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_m_each determine the number of units (or clusters) assigned to each condition. block_m_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the number of units (or clusters) to be assigned to each treatment arm within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). The columns should be in the order of conditions, if specified.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_block_prob">block_prob</code></td>
<td>
<p>Use for a two-arm design in which block_prob describes the probability of assignment to treatment within each block. Differs from prob in that the probability of assignment can vary across blocks.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_block_prob_each">block_prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_prob_each determine the probabilities of assignment to each treatment condition. block_prob_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the probabilities of assignment to treatment within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). Use only if the probabilities of assignment should vary by block, otherwise use prob_each. Each row of block_prob_each must sum to 1.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random assignment is used. When <code>simple = TRUE</code>, please do not specify m, m_each, block_m, or block_m_each. If <code>simple = TRUE</code>, <code>prob</code> and <code>prob_each</code> may vary by unit.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_permutation_matrix">permutation_matrix</code></td>
<td>
<p>for custom random assignment procedures.</p>
</td></tr>
<tr><td><code id="conduct_ra_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>declaration &lt;- declare_ra(N = 100, m_each = c(30, 30, 40))
Z &lt;- conduct_ra(declaration = declaration)
table(Z)

# equivalent to

Z &lt;- conduct_ra(N = 100, m_each = c(30, 30, 40))
table(Z)

</code></pre>

<hr>
<h2 id='custom_ra'>Custom Random Assignment</h2><span id='topic+custom_ra'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_ra(permutation_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_ra_+3A_permutation_matrix">permutation_matrix</code></td>
<td>
<p>A permutation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length N that indicates the treatment condition of each unit. Is numeric in a two-arm trial and a factor variable (ordered by conditions) in a multi-arm trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='custom_ra_probabilities'>probabilities of assignment: Custom Random Assignment</h2><span id='topic+custom_ra_probabilities'></span>

<h3>Description</h3>

<p>probabilities of assignment: Custom Random Assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>custom_ra_probabilities(permutation_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="custom_ra_probabilities_+3A_permutation_matrix">permutation_matrix</code></td>
<td>
<p>A permutation matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities of assignment
</p>


<h3>Examples</h3>

<pre><code class='language-R'># TODO
</code></pre>

<hr>
<h2 id='declare_ra'>Declare a random assignment procedure.</h2><span id='topic+declare_ra'></span>

<h3>Description</h3>

<p>Declare a random assignment procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>declare_ra(
  N = NULL,
  blocks = NULL,
  clusters = NULL,
  m = NULL,
  m_unit = NULL,
  m_each = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  block_m = NULL,
  block_m_each = NULL,
  block_prob = NULL,
  block_prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  simple = FALSE,
  permutation_matrix = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="declare_ra_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_blocks">blocks</code></td>
<td>
<p>A vector of length N that indicates which block each unit belongs to.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which m units (or clusters) are assigned to treatment and N-m units (or clusters) are assigned to control. In a blocked design, exactly m units in each block will be treated. (optional)</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm trial. Under complete random assignment, must be constant across units. Under blocked random assignment, must be constant within blocks.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_m_each">m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of m_each determine the number of units (or clusters) assigned to each condition. m_each must be a numeric vector in which each entry is a nonnegative integer that describes how many units (or clusters) should be assigned to the 1st, 2nd, 3rd... treatment condition. m_each must sum to N. (optional)</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N*prob) or ceiling(N*prob) units (or clusters) are assigned to treatment. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N*prob) units (or clusters) will be assigned to treatment and with probability prob, ceiling(N*prob) units (or clusters) will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two arm design. Must of be of length N. Under simple random assignment, can be different for each unit or cluster.  Under complete random assignment, must be constant across units. Under blocked random assignment, must be constant within blocks.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of units assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_block_m">block_m</code></td>
<td>
<p>Use for a two-arm design in which block_m describes the number of units to assign to treatment within each block. Note that in previous versions of randomizr, block_m behaved like block_m_each.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_block_m_each">block_m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_m_each determine the number of units (or clusters) assigned to each condition. block_m_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the number of units (or clusters) to be assigned to each treatment arm within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). The columns should be in the order of conditions, if specified.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_block_prob">block_prob</code></td>
<td>
<p>Use for a two-arm design in which block_prob describes the probability of assignment to treatment within each block. Differs from prob in that the probability of assignment can vary across blocks.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_block_prob_each">block_prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_prob_each determine the probabilities of assignment to each treatment condition. block_prob_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the probabilities of assignment to treatment within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). Use only if the probabilities of assignment should vary by block, otherwise use prob_each. Each row of block_prob_each must sum to 1.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random assignment is used. When <code>simple = TRUE</code>, please do not specify m, m_each, block_m, or block_m_each. If <code>simple = TRUE</code>, <code>prob</code> and <code>prob_each</code> may vary by unit.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_permutation_matrix">permutation_matrix</code></td>
<td>
<p>for custom random assignment procedures.</p>
</td></tr>
<tr><td><code id="declare_ra_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;declaration&quot;.  The list has five entries:
$ra_function, a function that generates random assignments according to the declaration.
$ra_type, a string indicating the type of random assignment used
$probabilities_matrix, a matrix with N rows and num_arms columns, describing each unit's probabilities of assignment to conditions.
$blocks, the blocking variable.
$clusters, the clustering variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The declare_ra function is used in three ways:

# 1. To obtain some basic facts about a randomization:
declaration &lt;- declare_ra(N=100, m_each=c(30, 30, 40))
declaration

# 2. To conduct a random assignment:

Z &lt;- conduct_ra(declaration)
table(Z)

# 3. To obtain observed condition probabilities

probs &lt;- obtain_condition_probabilities(declaration, Z)
table(probs, Z)

# Simple Random Assignment Declarations

declare_ra(N=100, simple = TRUE)
declare_ra(N=100, prob = .4, simple = TRUE)
declare_ra(N=100, prob_each=c(0.3, 0.3, 0.4),
           conditions=c("control", "placebo", "treatment"), simple=TRUE)

# Complete Random Assignment Declarations

declare_ra(N=100)
declare_ra(N=100, m_each = c(30, 70),
           conditions = c("control", "treatment"))
declare_ra(N=100, m_each=c(30, 30, 40))


# Block Random Assignment Declarations

blocks &lt;- rep(c("A", "B","C"), times = c(50, 100, 200))

block_m_each &lt;- rbind(c(10, 40),
                 c(30, 70),
                 c(50, 150))
declare_ra(blocks = blocks, block_m_each = block_m_each)


# Cluster Random Assignment Declarations

clusters &lt;- rep(letters, times = 1:26)
declare_ra(clusters = clusters)
declare_ra(clusters = clusters, m_each = c(7, 7, 12))

# Blocked and Clustered Random Assignment Declarations

clusters &lt;- rep(letters, times=1:26)
blocks &lt;- rep(NA, length(clusters))
blocks[clusters %in% letters[1:5]] &lt;- "block_1"
blocks[clusters %in% letters[6:10]] &lt;- "block_2"
blocks[clusters %in% letters[11:15]] &lt;- "block_3"
blocks[clusters %in% letters[16:20]] &lt;- "block_4"
blocks[clusters %in% letters[21:26]] &lt;- "block_5"

table(blocks, clusters)

declare_ra(clusters = clusters, blocks = blocks)
declare_ra(clusters = clusters, blocks = blocks, prob_each = c(.2, .5, .3))

</code></pre>

<hr>
<h2 id='declare_rs'>Declare a random sampling procedure.</h2><span id='topic+declare_rs'></span>

<h3>Description</h3>

<p>Declare a random sampling procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>declare_rs(
  N = NULL,
  strata = NULL,
  clusters = NULL,
  n = NULL,
  n_unit = NULL,
  prob = NULL,
  prob_unit = NULL,
  strata_n = NULL,
  strata_prob = NULL,
  simple = FALSE,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="declare_rs_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_strata">strata</code></td>
<td>
<p>A vector of length N that indicates which stratum each unit belongs to.</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_n">n</code></td>
<td>
<p>Use for a design in which n units (or clusters) are sampled. In a stratified design, exactly n units in each stratum will be sampled. (optional)</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_n_unit">n_unit</code></td>
<td>
<p>Under complete random sampling, must be constant across units. Under stratified random sampling, must be constant within strata.</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N*prob) or ceiling(N*prob) units (or clusters) are sampled. The probability of being sampled is exactly prob because with probability 1-prob, floor(N*prob) units (or clusters) will be sampled and with probability prob, ceiling(N*prob) units (or clusters) will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Must of be of length N. Under simple random sampling, can be different for each unit or cluster.  Under complete random sampling, must be constant across units. Under stratified random sampling, must be constant within strata.</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_strata_n">strata_n</code></td>
<td>
<p>Use for a design in which strata_n describes the number of units to sample within each stratum.</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_strata_prob">strata_prob</code></td>
<td>
<p>Use for a design in which strata_prob describes the probability of being sampled within each stratum. Differs from prob in that the probability of being sampled can vary across strata.</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random sampling is used. When <code>simple = TRUE</code>, please do not specify n or strata_n. When <code>simple = TRUE</code>, <code>prob</code> may vary by unit.</p>
</td></tr>
<tr><td><code id="declare_rs_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class &quot;declaration&quot;.  The list has five entries:
$rs_function, a function that generates random samplings according to the declaration.
$rs_type, a string indicating the type of random sampling used
$probabilities_vector, A vector length N indicating the probability of being sampled.
$strata, the stratification variable.
$clusters, the clustering variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The declare_rs function is used in three ways:

# 1. To obtain some basic facts about a sampling procedure:
declaration &lt;- declare_rs(N = 100, n = 30)
declaration

# 2. To draw a random sample:

S &lt;- draw_rs(declaration)
table(S)

# 3. To obtain inclusion probabilities

probs &lt;- obtain_inclusion_probabilities(declaration)
table(probs, S)

# Simple Random Sampling Declarations

declare_rs(N = 100, simple = TRUE)
declare_rs(N = 100, prob = .4, simple = TRUE)

# Complete Random Sampling Declarations

declare_rs(N = 100)
declare_rs(N = 100, n = 30)

# Stratified Random Sampling Declarations

strata &lt;- rep(c("A", "B","C"), times=c(50, 100, 200))
declare_rs(strata = strata)
declare_rs(strata = strata, prob = .5)


# Cluster Random Sampling Declarations

clusters &lt;- rep(letters, times = 1:26)
declare_rs(clusters = clusters)
declare_rs(clusters = clusters, n = 10)

# Stratified and Clustered Random Sampling Declarations

clusters &lt;- rep(letters, times = 1:26)
strata &lt;- rep(NA, length(clusters))
strata[clusters %in% letters[1:5]] &lt;- "stratum_1"
strata[clusters %in% letters[6:10]] &lt;- "stratum_2"
strata[clusters %in% letters[11:15]] &lt;- "stratum_3"
strata[clusters %in% letters[16:20]] &lt;- "stratum_4"
strata[clusters %in% letters[21:26]] &lt;- "stratum_5"

table(strata, clusters)

declare_rs(clusters = clusters, strata = strata)
declare_rs(clusters = clusters, strata = strata, prob = .3)

</code></pre>

<hr>
<h2 id='draw_rs'>Draw a random sample</h2><span id='topic+draw_rs'></span>

<h3>Description</h3>

<p>You can either give draw_rs() an declaration, as created by <code><a href="#topic+declare_rs">declare_rs</a></code> or you can specify the other arguments to describe a random sampling procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_rs(
  declaration = NULL,
  N = NULL,
  strata = NULL,
  clusters = NULL,
  n = NULL,
  n_unit = NULL,
  prob = NULL,
  prob_unit = NULL,
  strata_n = NULL,
  strata_prob = NULL,
  simple = FALSE,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_rs_+3A_declaration">declaration</code></td>
<td>
<p>A random sampling declaration, created by <code><a href="#topic+declare_rs">declare_rs</a></code>.</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_strata">strata</code></td>
<td>
<p>A vector of length N that indicates which stratum each unit belongs to.</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_n">n</code></td>
<td>
<p>Use for a design in which n units (or clusters) are sampled. In a stratified design, exactly n units in each stratum will be sampled. (optional)</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_n_unit">n_unit</code></td>
<td>
<p>Under complete random sampling, must be constant across units. Under stratified random sampling, must be constant within strata.</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N*prob) or ceiling(N*prob) units (or clusters) are sampled. The probability of being sampled is exactly prob because with probability 1-prob, floor(N*prob) units (or clusters) will be sampled and with probability prob, ceiling(N*prob) units (or clusters) will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Must of be of length N. Under simple random sampling, can be different for each unit or cluster.  Under complete random sampling, must be constant across units. Under stratified random sampling, must be constant within strata.</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_strata_n">strata_n</code></td>
<td>
<p>Use for a design in which strata_n describes the number of units to sample within each stratum.</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_strata_prob">strata_prob</code></td>
<td>
<p>Use for a design in which strata_prob describes the probability of being sampled within each stratum. Differs from prob in that the probability of being sampled can vary across strata.</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random sampling is used. When <code>simple = TRUE</code>, please do not specify n or strata_n. When <code>simple = TRUE</code>, <code>prob</code> may vary by unit.</p>
</td></tr>
<tr><td><code id="draw_rs_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>declaration &lt;- declare_rs(N = 100, n = 30)
S &lt;- draw_rs(declaration = declaration)
table(S)

# equivalent to
S &lt;- draw_rs(N = 100, n = 30)
table(S)

</code></pre>

<hr>
<h2 id='obtain_condition_probabilities'>Obtain the probabilities of units being in the conditions that they are in.</h2><span id='topic+obtain_condition_probabilities'></span>

<h3>Description</h3>

<p>You can either give obtain_condition_probabilities() an declaration, as created by <code><a href="#topic+declare_ra">declare_ra</a></code> or you can specify the other arguments to describe a random assignment procedure.<br /> <br />
This function is especially useful when units have different probabilities of assignment and the analyst plans to use inverse-probability weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_condition_probabilities(
  declaration = NULL,
  assignment,
  N = NULL,
  blocks = NULL,
  clusters = NULL,
  m = NULL,
  m_unit = NULL,
  m_each = NULL,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  block_m = NULL,
  block_m_each = NULL,
  block_prob = NULL,
  block_prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  simple = FALSE,
  permutation_matrix = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_condition_probabilities_+3A_declaration">declaration</code></td>
<td>
<p>A random assignment declaration, created by <code><a href="#topic+declare_ra">declare_ra</a></code>.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_assignment">assignment</code></td>
<td>
<p>A vector of random assignments, often created by <code><a href="#topic+conduct_ra">conduct_ra</a></code>.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_blocks">blocks</code></td>
<td>
<p>A vector of length N that indicates which block each unit belongs to.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_m">m</code></td>
<td>
<p>Use for a two-arm design in which m units (or clusters) are assigned to treatment and N-m units (or clusters) are assigned to control. In a blocked design, exactly m units in each block will be treated. (optional)</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_m_unit">m_unit</code></td>
<td>
<p>Use for a two-arm trial. Under complete random assignment, must be constant across units. Under blocked random assignment, must be constant within blocks.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_m_each">m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of m_each determine the number of units (or clusters) assigned to each condition. m_each must be a numeric vector in which each entry is a nonnegative integer that describes how many units (or clusters) should be assigned to the 1st, 2nd, 3rd... treatment condition. m_each must sum to N. (optional)</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design in which either floor(N*prob) or ceiling(N*prob) units (or clusters) are assigned to treatment. The probability of assignment to treatment is exactly prob because with probability 1-prob, floor(N*prob) units (or clusters) will be assigned to treatment and with probability prob, ceiling(N*prob) units (or clusters) will be assigned to treatment. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two arm design. Must of be of length N. Under simple random assignment, can be different for each unit or cluster.  Under complete random assignment, must be constant across units. Under blocked random assignment, must be constant within blocks.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. Because of integer issues, the exact number of units assigned to each condition may differ (slightly) from assignment to assignment, but the overall probability of assignment is exactly prob_each. (optional)</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_block_m">block_m</code></td>
<td>
<p>Use for a two-arm design in which block_m describes the number of units to assign to treatment within each block. Note that in previous versions of randomizr, block_m behaved like block_m_each.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_block_m_each">block_m_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_m_each determine the number of units (or clusters) assigned to each condition. block_m_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the number of units (or clusters) to be assigned to each treatment arm within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). The columns should be in the order of conditions, if specified.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_block_prob">block_prob</code></td>
<td>
<p>Use for a two-arm design in which block_prob describes the probability of assignment to treatment within each block. Differs from prob in that the probability of assignment can vary across blocks.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_block_prob_each">block_prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of block_prob_each determine the probabilities of assignment to each treatment condition. block_prob_each must be a matrix with the same number of rows as blocks and the same number of columns as treatment arms. Cell entries are the probabilities of assignment to treatment within each block. The rows should respect the ordering of the blocks as determined by sort(unique(blocks)). Use only if the probabilities of assignment should vary by block, otherwise use prob_each. Each row of block_prob_each must sum to 1.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random assignment is used. When <code>simple = TRUE</code>, please do not specify m, m_each, block_m, or block_m_each. If <code>simple = TRUE</code>, <code>prob</code> and <code>prob_each</code> may vary by unit.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_permutation_matrix">permutation_matrix</code></td>
<td>
<p>for custom random assignment procedures.</p>
</td></tr>
<tr><td><code id="obtain_condition_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Conduct a block random assignment
blocks &lt;- rep(c("A", "B","C"), times=c(50, 100, 200))
block_m_each &lt;- rbind(c(10, 40),
                 c(30, 70),
                 c(50, 150))
declaration &lt;- declare_ra(blocks = blocks, block_m_each = block_m_each)
Z &lt;- conduct_ra(declaration = declaration)
table(Z, blocks)

observed_probabilities &lt;-
   obtain_condition_probabilities(declaration = declaration, assignment = Z)


# Probabilities in the control group:
table(observed_probabilities[Z == 0], blocks[Z == 0])

# Probabilities in the treatment group:
table(observed_probabilities[Z == 1], blocks[Z == 1])


# Sometimes it is convenient to skip the declaration step
Z &lt;- conduct_ra(blocks = blocks, block_m_each = block_m_each)
observed_probabilities &lt;-
   obtain_condition_probabilities(assignment = Z,
                                  blocks = blocks,
                                  block_m_each = block_m_each)
table(observed_probabilities[Z == 0], blocks[Z == 0])
table(observed_probabilities[Z == 1], blocks[Z == 1])

</code></pre>

<hr>
<h2 id='obtain_inclusion_probabilities'>Obtain inclusion probabilities</h2><span id='topic+obtain_inclusion_probabilities'></span>

<h3>Description</h3>

<p>You can either give obtain_inclusion_probabilities() an declaration, as created by <code><a href="#topic+declare_rs">declare_rs</a></code> or you can specify the other arguments to describe a random sampling procedure.<br /> <br />
This function is especially useful when units have different inclusion probabilities and the analyst plans to use inverse-probability weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_inclusion_probabilities(
  declaration = NULL,
  N = NULL,
  strata = NULL,
  clusters = NULL,
  n = NULL,
  n_unit = NULL,
  prob = NULL,
  prob_unit = NULL,
  strata_n = NULL,
  strata_prob = NULL,
  simple = FALSE,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_inclusion_probabilities_+3A_declaration">declaration</code></td>
<td>
<p>A random sampling declaration, created by <code><a href="#topic+declare_rs">declare_rs</a></code>.</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_strata">strata</code></td>
<td>
<p>A vector of length N that indicates which stratum each unit belongs to.</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_n">n</code></td>
<td>
<p>Use for a design in which n units (or clusters) are sampled. In a stratified design, exactly n units in each stratum will be sampled. (optional)</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_n_unit">n_unit</code></td>
<td>
<p>Under complete random sampling, must be constant across units. Under stratified random sampling, must be constant within strata.</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N*prob) or ceiling(N*prob) units (or clusters) are sampled. The probability of being sampled is exactly prob because with probability 1-prob, floor(N*prob) units (or clusters) will be sampled and with probability prob, ceiling(N*prob) units (or clusters) will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Must of be of length N. Under simple random sampling, can be different for each unit or cluster.  Under complete random sampling, must be constant across units. Under stratified random sampling, must be constant within strata.</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_strata_n">strata_n</code></td>
<td>
<p>Use for a design in which strata_n describes the number of units to sample within each stratum.</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_strata_prob">strata_prob</code></td>
<td>
<p>Use for a design in which strata_prob describes the probability of being sampled within each stratum. Differs from prob in that the probability of being sampled can vary across strata.</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_simple">simple</code></td>
<td>
<p>logical, defaults to FALSE. If TRUE, simple random sampling is used. When <code>simple = TRUE</code>, please do not specify n or strata_n. When <code>simple = TRUE</code>, <code>prob</code> may vary by unit.</p>
</td></tr>
<tr><td><code id="obtain_inclusion_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Draw a stratified random sample
strata &lt;- rep(c("A", "B","C"), times=c(50, 100, 200))

declaration &lt;- declare_rs(strata = strata)

observed_probabilities &lt;-
   obtain_inclusion_probabilities(declaration = declaration)

table(strata, observed_probabilities)


# Sometimes it is convenient to skip the declaration step
observed_probabilities &lt;-
   obtain_inclusion_probabilities(strata = strata)

table(strata, observed_probabilities)

</code></pre>

<hr>
<h2 id='obtain_num_permutations'>Obtain the Number of Possible Permutations from a Random Assignment Declaration</h2><span id='topic+obtain_num_permutations'></span>

<h3>Description</h3>

<p>Obtain the Number of Possible Permutations from a Random Assignment Declaration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_num_permutations(declaration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_num_permutations_+3A_declaration">declaration</code></td>
<td>
<p>A random assignment or sampling declaration, created by <code><a href="#topic+declare_ra">declare_ra</a></code> or <code><a href="#topic+declare_rs">declare_rs</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Random assignment
## complete

declaration &lt;- declare_ra(N = 4)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

## blocked

blocks &lt;- c("A", "A", "B", "B", "C", "C", "C")
declaration &lt;- declare_ra(blocks = blocks)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

## clustered

clusters &lt;- c("A", "B", "A", "B", "C", "C", "C")
declaration &lt;- declare_ra(clusters = clusters)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

## large

declaration &lt;- declare_ra(20)
choose(20, 10)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)

# Random sampling
## complete

declaration &lt;- declare_rs(N = 4)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

## stratified

strata &lt;- c("A", "A", "B", "B", "C", "C", "C")
declaration &lt;- declare_rs(strata = strata)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

## clustered

clusters &lt;- c("A", "B", "A", "B", "C", "C", "C")
declaration &lt;- declare_rs(clusters = clusters)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

## large

declaration &lt;- declare_rs(N = 20)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)


</code></pre>

<hr>
<h2 id='obtain_permutation_matrix'>Obtain Permutation Matrix from a Random Assignment Declaration</h2><span id='topic+obtain_permutation_matrix'></span>

<h3>Description</h3>

<p>Obtain Permutation Matrix from a Random Assignment Declaration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_permutation_matrix(declaration, maximum_permutations = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_permutation_matrix_+3A_declaration">declaration</code></td>
<td>
<p>A random assignment declaration, created by <code><a href="#topic+declare_ra">declare_ra</a></code>.</p>
</td></tr>
<tr><td><code id="obtain_permutation_matrix_+3A_maximum_permutations">maximum_permutations</code></td>
<td>
<p>If the number of possible random assignments exceeds maximum_permutations, obtain_permutation_matrix will return a random sample of maximum_permutations permutations. Defaults to 10,000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of all possible (or a random sample of all possible) random assignments consistent with a declaration.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# complete

declaration &lt;- declare_ra(N = 4)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

# blocked

blocks &lt;- c("A", "A", "B", "B", "C", "C", "C")
declaration &lt;- declare_ra(blocks = blocks)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

# clustered

clusters &lt;- c("A", "B", "A", "B", "C", "C", "C")
declaration &lt;- declare_ra(clusters = clusters)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)
obtain_num_permutations(declaration)

# large

declaration &lt;- declare_ra(20)
choose(20, 10)
perms &lt;- obtain_permutation_matrix(declaration)
dim(perms)


</code></pre>

<hr>
<h2 id='obtain_permutation_probabilities'>Obtain the probabilities of permutations</h2><span id='topic+obtain_permutation_probabilities'></span>

<h3>Description</h3>

<p>Obtain the probabilities of permutations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_permutation_probabilities(declaration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_permutation_probabilities_+3A_declaration">declaration</code></td>
<td>
<p>A random assignment declaration, created by <code><a href="#topic+declare_ra">declare_ra</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of probabilities
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
declaration &lt;- declare_ra(N = 5, prob_each = c(.49, .51))
obtain_num_permutations(declaration)
perm_probs &lt;- obtain_permutation_probabilities(declaration)
perms &lt;- obtain_permutation_matrix(declaration)

# probabilities of assignment from declaration *should* match the average over all permutations
true_probabilities &lt;- declaration$probabilities_matrix[,2]
true_probabilities

# correctly WRONG because the perms have different probs!
rowMeans(perms)

# correctly correct!
perms %*% perm_probs

</code></pre>

<hr>
<h2 id='randomizr'>randomizr</h2><span id='topic+randomizr'></span>

<h3>Description</h3>

<p>Easy-to-Use Tools for Common Forms of Random Assignment and Sampling
</p>

<hr>
<h2 id='simple_ra'>Simple Random Assignment</h2><span id='topic+simple_ra'></span>

<h3>Description</h3>

<p>simple_ra implements a random assignment procedure in which units are independently assigned to treatment conditions. Because units are assigned independently, the number of units that are assigned to each condition can vary from assignment to assignment. For most experimental applications in which the number of experimental units is known in advance, <code><a href="#topic+complete_ra">complete_ra</a></code> is better because the number of units assigned to each condition is fixed across assignments.<br /><br />
In most cases, users should specify N and not more than one of prob, prob_each, or num_arms. <br /> <br />
If only N is specified, a two-arm trial with prob = 0.5 is assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_ra(
  N,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  check_inputs = TRUE,
  simple = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_ra_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="simple_ra_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design. prob is the probability of assignment to treatment and must be a real number between 0 and 1 inclusive and must be length 1. (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two-arm design. prob is the probability of assignment to treatment and must be a real number between 0 and 1 inclusive and must be length N. (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. It may be a conditions-length vector or a N-by-conditions matrix.  (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="simple_ra_+3A_simple">simple</code></td>
<td>
<p>logical. internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length N that indicates the treatment condition of each unit. Is numeric in a two-arm trial and a factor variable (ordered by conditions) in a multi-arm trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two Group Designs

Z &lt;- simple_ra(N=100)
table(Z)

Z &lt;- simple_ra(N=100, prob=0.5)
table(Z)

Z &lt;- simple_ra(N=100, prob_each = c(0.3, 0.7),
               conditions = c("control", "treatment"))
table(Z)

# Multi-arm Designs
Z &lt;- simple_ra(N=100, num_arms=3)
table(Z)

Z &lt;- simple_ra(N=100, prob_each=c(0.3, 0.3, 0.4))
table(Z)

Z &lt;- simple_ra(N=100, prob_each=c(0.3, 0.3, 0.4),
               conditions=c("control", "placebo", "treatment"))
table(Z)

Z &lt;- simple_ra(N=100, conditions=c("control", "placebo", "treatment"))
table(Z)
</code></pre>

<hr>
<h2 id='simple_ra_probabilities'>probabilities of assignment: Simple Random Assignment</h2><span id='topic+simple_ra_probabilities'></span>

<h3>Description</h3>

<p>probabilities of assignment: Simple Random Assignment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_ra_probabilities(
  N,
  prob = NULL,
  prob_unit = NULL,
  prob_each = NULL,
  num_arms = NULL,
  conditions = NULL,
  check_inputs = TRUE,
  simple = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_ra_probabilities_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="simple_ra_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a two-arm design. prob is the probability of assignment to treatment and must be a real number between 0 and 1 inclusive and must be length 1. (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Use for a two-arm design. prob is the probability of assignment to treatment and must be a real number between 0 and 1 inclusive and must be length N. (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_probabilities_+3A_prob_each">prob_each</code></td>
<td>
<p>Use for a multi-arm design in which the values of prob_each determine the probabilities of assignment to each treatment condition. prob_each must be a numeric vector giving the probability of assignment to each condition. All entries must be nonnegative real numbers between 0 and 1 inclusive and the total must sum to 1. It may be a conditions-length vector or a N-by-conditions matrix.  (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_probabilities_+3A_num_arms">num_arms</code></td>
<td>
<p>The number of treatment arms. If unspecified, num_arms will be determined from the other arguments. (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_probabilities_+3A_conditions">conditions</code></td>
<td>
<p>A character vector giving the names of the treatment groups. If unspecified, the treatment groups will be named 0 (for control) and 1 (for treatment) in a two-arm trial and T1, T2, T3, in a multi-arm trial. An exception is a two-group design in which num_arms is set to 2, in which case the condition names are T1 and T2, as in a multi-arm trial with two arms. (optional)</p>
</td></tr>
<tr><td><code id="simple_ra_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="simple_ra_probabilities_+3A_simple">simple</code></td>
<td>
<p>logical. internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities of assignment
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Two Group Designs
prob_mat &lt;- simple_ra_probabilities(N=100)
head(prob_mat)

prob_mat &lt;- simple_ra_probabilities(N=100, prob=0.5)
head(prob_mat)

prob_mat &lt;- simple_ra_probabilities(N=100, prob_each = c(0.3, 0.7),
                        conditions = c("control", "treatment"))
head(prob_mat)

# Multi-arm Designs
prob_mat &lt;- simple_ra_probabilities(N=100, num_arms=3)
head(prob_mat)

prob_mat &lt;- simple_ra_probabilities(N=100, prob_each=c(0.3, 0.3, 0.4))
head(prob_mat)

prob_mat &lt;- simple_ra_probabilities(N=100, prob_each=c(0.3, 0.3, 0.4),
                        conditions=c("control", "placebo", "treatment"))
head(prob_mat)

prob_mat &lt;- simple_ra_probabilities(N=100, conditions=c("control", "placebo", "treatment"))
head(prob_mat)

</code></pre>

<hr>
<h2 id='simple_rs'>Simple Random Sampling</h2><span id='topic+simple_rs'></span>

<h3>Description</h3>

<p>simple_rs implements a random sampling procedure in which units are independently sampled. Because units are sampled independently, the number of units that are sampled can vary from sample to sample. For most applications in which the number of units in the sampling frame is known in advance, <code><a href="#topic+complete_rs">complete_rs</a></code> is better because the number of units sampled is fixed across sampled.<br /><br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_rs(N, prob = NULL, prob_unit = NULL, check_inputs = TRUE, simple = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_rs_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="simple_rs_+3A_prob">prob</code></td>
<td>
<p>prob is the probability of being sampled must be a real number between 0 and 1 inclusive, and must be of length 1. (optional)</p>
</td></tr>
<tr><td><code id="simple_rs_+3A_prob_unit">prob_unit</code></td>
<td>
<p>prob is the probability of being sampled must be a real number between 0 and 1 inclusive, and must be of length N. (optional)</p>
</td></tr>
<tr><td><code id="simple_rs_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="simple_rs_+3A_simple">simple</code></td>
<td>
<p>logical. internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length N that indicates if a unit is sampled (1) or not (0).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S &lt;- simple_rs(N = 100)
table(S)

S &lt;- simple_rs(N = 100, prob = 0.3)
table(S)

</code></pre>

<hr>
<h2 id='simple_rs_probabilities'>Inclusion Probabilities: Simple Random Sampling</h2><span id='topic+simple_rs_probabilities'></span>

<h3>Description</h3>

<p>Inclusion Probabilities: Simple Random Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_rs_probabilities(
  N,
  prob = NULL,
  prob_unit = NULL,
  check_inputs = TRUE,
  simple = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_rs_probabilities_+3A_n">N</code></td>
<td>
<p>The number of units. N must be a positive integer. (required)</p>
</td></tr>
<tr><td><code id="simple_rs_probabilities_+3A_prob">prob</code></td>
<td>
<p>prob is the probability of being sampled must be a real number between 0 and 1 inclusive, and must be of length 1. (optional)</p>
</td></tr>
<tr><td><code id="simple_rs_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>prob is the probability of being sampled must be a real number between 0 and 1 inclusive, and must be of length N. (optional)</p>
</td></tr>
<tr><td><code id="simple_rs_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="simple_rs_probabilities_+3A_simple">simple</code></td>
<td>
<p>logical. internal use only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector length N indicating the probability of being sampled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>probs &lt;- simple_ra_probabilities(N = 100)
table(probs)

probs &lt;- simple_ra_probabilities(N = 100, prob = 0.3)
table(probs)

</code></pre>

<hr>
<h2 id='strata_and_cluster_rs'>Stratified and Clustered Random Sampling</h2><span id='topic+strata_and_cluster_rs'></span>

<h3>Description</h3>

<p>A random sampling procedure in which units are sampled as clusters and clusters are nested within strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata_and_cluster_rs(
  strata = NULL,
  clusters = NULL,
  prob = NULL,
  prob_unit = NULL,
  n = NULL,
  n_unit = NULL,
  strata_n = NULL,
  strata_prob = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata_and_cluster_rs_+3A_strata">strata</code></td>
<td>
<p>A vector of length N that indicates which stratum each unit belongs to.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N_clusters_stratum*prob) or ceiling(N_clusters_stratum*prob) clusters are sampled within each stratum. The probability of being sampled is exactly prob because with probability 1-prob, floor(N_clusters_stratum*prob) clusters will be sampled and with probability prob, ceiling(N_clusters_stratum*prob) clusters will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Must of be of length N. tapply(prob_unit, blocks, unique) will be passed to <code>strata_prob</code>.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_+3A_n">n</code></td>
<td>
<p>Use for a design in which the scalar n describes the fixed number of units to sample in each stratum. This number does not vary across strata.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_+3A_n_unit">n_unit</code></td>
<td>
<p>Must be of length N. tapply(m_unit, blocks, unique) will be passed to <code>strata_n</code>.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_+3A_strata_n">strata_n</code></td>
<td>
<p>Use for a design in which strata_n describes the number of units to sample within each stratum.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_+3A_strata_prob">strata_prob</code></td>
<td>
<p>Use for a design in which strata_prob describes the probability of being sampled within each stratum. Differs from prob in that the probability of being sampled can vary across strata.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length N that indicates if a unit is sampled (1) or not (0).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clusters &lt;- rep(letters, times = 1:26)

strata &lt;- rep(NA, length(clusters))
strata[clusters %in% letters[1:5]] &lt;- "stratum_1"
strata[clusters %in% letters[6:10]] &lt;- "stratum_2"
strata[clusters %in% letters[11:15]] &lt;- "stratum_3"
strata[clusters %in% letters[16:20]] &lt;- "stratum_4"
strata[clusters %in% letters[21:26]] &lt;- "stratum_5"

table(strata, clusters)

S &lt;- strata_and_cluster_rs(strata = strata,
                          clusters = clusters)

table(S, strata)
table(S, clusters)


S &lt;- strata_and_cluster_rs(clusters = clusters,
                           strata = strata,
                           prob = .5)

table(S, clusters)
table(S, strata)

S &lt;- strata_and_cluster_rs(clusters = clusters,
                           strata = strata,
                           strata_n = c(2, 3, 2, 3, 2))

table(S, clusters)
table(S, strata)

S &lt;- strata_and_cluster_rs(clusters = clusters,
                           strata = strata,
                           strata_prob = c(.1, .2, .3, .4, .5))

table(S, clusters)
table(S, strata)


</code></pre>

<hr>
<h2 id='strata_and_cluster_rs_probabilities'>Inclusion Probabilities: Stratified and Clustered Random Sampling</h2><span id='topic+strata_and_cluster_rs_probabilities'></span>

<h3>Description</h3>

<p>Inclusion Probabilities: Stratified and Clustered Random Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata_and_cluster_rs_probabilities(
  strata = NULL,
  clusters = NULL,
  prob = NULL,
  prob_unit = NULL,
  n = NULL,
  n_unit = NULL,
  strata_n = NULL,
  strata_prob = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_strata">strata</code></td>
<td>
<p>A vector of length N that indicates which stratum each unit belongs to.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_clusters">clusters</code></td>
<td>
<p>A vector of length N that indicates which cluster each unit belongs to.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N_clusters_stratum*prob) or ceiling(N_clusters_stratum*prob) clusters are sampled within each stratum. The probability of being sampled is exactly prob because with probability 1-prob, floor(N_clusters_stratum*prob) clusters will be sampled and with probability prob, ceiling(N_clusters_stratum*prob) clusters will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Must of be of length N. tapply(prob_unit, blocks, unique) will be passed to <code>strata_prob</code>.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_n">n</code></td>
<td>
<p>Use for a design in which the scalar n describes the fixed number of units to sample in each stratum. This number does not vary across strata.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_n_unit">n_unit</code></td>
<td>
<p>Must be of length N. tapply(m_unit, blocks, unique) will be passed to <code>strata_n</code>.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_strata_n">strata_n</code></td>
<td>
<p>Use for a design in which strata_n describes the number of units to sample within each stratum.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_strata_prob">strata_prob</code></td>
<td>
<p>Use for a design in which strata_prob describes the probability of being sampled within each stratum. Differs from prob in that the probability of being sampled can vary across strata.</p>
</td></tr>
<tr><td><code id="strata_and_cluster_rs_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector length N indicating the probability of being sampled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
clusters &lt;- rep(letters, times = 1:26)

strata &lt;- rep(NA, length(clusters))
strata[clusters %in% letters[1:5]] &lt;- "stratum_1"
strata[clusters %in% letters[6:10]] &lt;- "stratum_2"
strata[clusters %in% letters[11:15]] &lt;- "stratum_3"
strata[clusters %in% letters[16:20]] &lt;- "stratum_4"
strata[clusters %in% letters[21:26]] &lt;- "stratum_5"

table(strata, clusters)

probs &lt;- strata_and_cluster_rs_probabilities(strata = strata,
                                         clusters = clusters)

table(probs, strata)
table(probs, clusters)


probs &lt;- strata_and_cluster_rs_probabilities(clusters = clusters,
                                         strata = strata,
                                         prob = .5)

table(probs, clusters)
table(probs, strata)

probs &lt;- strata_and_cluster_rs_probabilities(clusters = clusters,
                                         strata = strata,
                                         strata_n = c(2, 3, 2, 3, 2))

table(probs, clusters)
table(probs, strata)

probs &lt;- strata_and_cluster_rs_probabilities(clusters = clusters,
                                         strata = strata,
                                         strata_prob = c(.1, .2, .3, .4, .5))

table(probs, clusters)
table(probs, strata)


</code></pre>

<hr>
<h2 id='strata_rs'>Stratified Random Sampling</h2><span id='topic+strata_rs'></span>

<h3>Description</h3>

<p>strata_rs implements a random sampling procedure in which units that are grouped into strata defined by covariates are sample using complete random sampling within stratum For example, imagine that 50 of 100 men are sampled and 75 of 200 women are sampled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata_rs(
  strata = NULL,
  prob = NULL,
  prob_unit = NULL,
  n = NULL,
  n_unit = NULL,
  strata_n = NULL,
  strata_prob = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata_rs_+3A_strata">strata</code></td>
<td>
<p>A vector of length N that indicates which stratum each unit belongs to. Can be a character, factor, or numeric vector. (required)</p>
</td></tr>
<tr><td><code id="strata_rs_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N_stratum*prob) or ceiling(N_stratum*prob) units are sampled within each stratum. The probability of  being sampled is exactly prob because with probability 1-prob, floor(N_stratum*prob) units will be sampled and with probability prob, ceiling(N_stratum*prob) units will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="strata_rs_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Must of be of length N. tapply(prob_unit, strata, unique) will be passed to <code>strata_prob</code>.</p>
</td></tr>
<tr><td><code id="strata_rs_+3A_n">n</code></td>
<td>
<p>Use for a design in which the scalar n describes the fixed number of units to sample in each stratum. This number does not vary across strata.</p>
</td></tr>
<tr><td><code id="strata_rs_+3A_n_unit">n_unit</code></td>
<td>
<p>Must be of length N. tapply(m_unit, strata, unique) will be passed to <code>strata_n</code>.</p>
</td></tr>
<tr><td><code id="strata_rs_+3A_strata_n">strata_n</code></td>
<td>
<p>Use for a design in which the numeric vector strata_n describes the number of units to sample within each stratum.</p>
</td></tr>
<tr><td><code id="strata_rs_+3A_strata_prob">strata_prob</code></td>
<td>
<p>Use for a design in which strata_prob describes the probability of being sampled within each stratum. Differs from prob in that the probability of being sampled can vary across strata.</p>
</td></tr>
<tr><td><code id="strata_rs_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length N that indicates if a unit is sampled (1) or not (0).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
strata &lt;- rep(c("A", "B","C"), times = c(50, 100, 200))
Z &lt;- strata_rs(strata = strata)
table(strata, Z)

Z &lt;- strata_rs(strata = strata, prob = .3)
table(strata, Z)

Z &lt;- strata_rs(strata = strata, n = 20)
table(strata, Z)

Z &lt;- strata_rs(strata = strata, strata_prob = c(.1, .2, .3))
table(strata, Z)

Z &lt;- strata_rs(strata = strata, 
               prob_unit = rep(c(.1, .2, .3), times = c(50, 100, 200)))
table(strata, Z)

Z &lt;- strata_rs(strata = strata, strata_n = c(20, 30, 40))
table(strata, Z)

Z &lt;- strata_rs(strata = strata, 
               n_unit = rep(c(20, 30, 40), times = c(50, 100, 200)))
table(strata, Z)


</code></pre>

<hr>
<h2 id='strata_rs_probabilities'>Inclusion Probabilities: Stratified Random Sampling</h2><span id='topic+strata_rs_probabilities'></span>

<h3>Description</h3>

<p>Inclusion Probabilities: Stratified Random Sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strata_rs_probabilities(
  strata = NULL,
  prob = NULL,
  prob_unit = NULL,
  n = NULL,
  n_unit = NULL,
  strata_n = NULL,
  strata_prob = NULL,
  check_inputs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strata_rs_probabilities_+3A_strata">strata</code></td>
<td>
<p>A vector of length N that indicates which stratum each unit belongs to. Can be a character, factor, or numeric vector. (required)</p>
</td></tr>
<tr><td><code id="strata_rs_probabilities_+3A_prob">prob</code></td>
<td>
<p>Use for a design in which either floor(N_stratum*prob) or ceiling(N_stratum*prob) units are sampled within each stratum. The probability of  being sampled is exactly prob because with probability 1-prob, floor(N_stratum*prob) units will be sampled and with probability prob, ceiling(N_stratum*prob) units will be sampled. prob must be a real number between 0 and 1 inclusive. (optional)</p>
</td></tr>
<tr><td><code id="strata_rs_probabilities_+3A_prob_unit">prob_unit</code></td>
<td>
<p>Must of be of length N. tapply(prob_unit, strata, unique) will be passed to <code>strata_prob</code>.</p>
</td></tr>
<tr><td><code id="strata_rs_probabilities_+3A_n">n</code></td>
<td>
<p>Use for a design in which the scalar n describes the fixed number of units to sample in each stratum. This number does not vary across strata.</p>
</td></tr>
<tr><td><code id="strata_rs_probabilities_+3A_n_unit">n_unit</code></td>
<td>
<p>Must be of length N. tapply(m_unit, strata, unique) will be passed to <code>strata_n</code>.</p>
</td></tr>
<tr><td><code id="strata_rs_probabilities_+3A_strata_n">strata_n</code></td>
<td>
<p>Use for a design in which the numeric vector strata_n describes the number of units to sample within each stratum.</p>
</td></tr>
<tr><td><code id="strata_rs_probabilities_+3A_strata_prob">strata_prob</code></td>
<td>
<p>Use for a design in which strata_prob describes the probability of being sampled within each stratum. Differs from prob in that the probability of being sampled can vary across strata.</p>
</td></tr>
<tr><td><code id="strata_rs_probabilities_+3A_check_inputs">check_inputs</code></td>
<td>
<p>logical. Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector length N indicating the probability of being sampled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
strata &lt;- rep(c("A", "B","C"), times = c(50, 100, 200))
probs &lt;- strata_rs_probabilities(strata = strata)
table(strata, probs)

probs &lt;- strata_rs_probabilities(strata = strata, prob = .2)
table(strata, probs)

probs &lt;- strata_rs_probabilities(strata = strata, strata_prob = c(.1, .2, .3))
table(strata, probs)

probs &lt;- strata_rs_probabilities(strata = strata, strata_n = c(10, 40, 70))
table(strata, probs)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
