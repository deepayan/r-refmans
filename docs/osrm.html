<!DOCTYPE html><html><head><title>Help for package osrm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {osrm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#osrm'><p>Shortest Paths and Travel Time from OpenStreetMap via an OSRM API</p></a></li>
<li><a href='#osrmIsochrone'><p>Get Polygons of Isochrones</p></a></li>
<li><a href='#osrmIsodistance'><p>Get Polygons of Isodistances</p></a></li>
<li><a href='#osrmIsometric'><p>deprecated</p></a></li>
<li><a href='#osrmNearest'><p>Get the Nearest Point on the Street Network</p></a></li>
<li><a href='#osrmRoute'><p>Get the Shortest Path Between Two Points</p></a></li>
<li><a href='#osrmTable'><p>Get Travel Time Matrices Between Points</p></a></li>
<li><a href='#osrmTrip'><p>Get the Travel Geometry Between Multiple Unordered Points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interface Between R and the OpenStreetMap-Based Routing Service
OSRM</td>
</tr>
<tr>
<td>Version:</td>
<td>4.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface between R and the 'OSRM' API. 'OSRM' is a routing
    service based on 'OpenStreetMap' data. See <a href="http://project-osrm.org/">http://project-osrm.org/</a> for more
    information. This package enables the computation of routes, trips, isochrones and
    travel distances matrices (travel time and kilometric distance).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>RcppSimdJson, curl, utils, mapiso, googlePolylines, sf</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mapsf, tinytest, covr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/riatelab/osrm">https://github.com/riatelab/osrm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/riatelab/osrm/issues">https://github.com/riatelab/osrm/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-06 13:22:24 UTC; tim</td>
</tr>
<tr>
<td>Author:</td>
<td>Timothée Giraud <a href="https://orcid.org/0000-0002-1932-3323"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Robin Cura <a href="https://orcid.org/0000-0001-5926-1828"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Matthieu Viry <a href="https://orcid.org/0000-0002-0693-8556"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Robin Lovelace <a href="https://orcid.org/0000-0001-5679-6536"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Timothée Giraud &lt;timothee.giraud@cnrs.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-06 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='osrm'>Shortest Paths and Travel Time from OpenStreetMap via an OSRM API</h2><span id='topic+osrm-package'></span><span id='topic+osrm'></span>

<h3>Description</h3>

<p>An interface between R and the OSRM API.<br />
OSRM is a routing
service based on OpenStreetMap data. See &lt;http://project-osrm.org/&gt; for more
information. This package enables the computation of routes, trips, isochrones and
travel distances matrices (travel time and kilometric distance).<br />
</p>

<ul>
<li><p><code><a href="#topic+osrmTable">osrmTable</a></code>: Build and send OSRM API queries to get travel
time matrices between points. This function interfaces the <em>table</em>
OSRM service.
</p>
</li>
<li><p><code><a href="#topic+osrmRoute">osrmRoute</a></code>: Build and send an OSRM API query to get the
travel geometry between two points. This function interfaces with the
<em>route</em> OSRM service.
</p>
</li>
<li><p><code><a href="#topic+osrmTrip">osrmTrip</a></code>: Build and send an OSRM API query to get the
shortest travel geometry between multiple unordered points. This function
interfaces the <em>trip</em> OSRM service. Use this function to resolve the
travelling salesman problem.
</p>
</li>
<li><p><code><a href="#topic+osrmNearest">osrmNearest</a></code>: Build and send an OSRM API query to get the
nearest point on the street network. This function interfaces the
<em>nearest</em> OSRM service.
</p>
</li>
<li><p><code><a href="#topic+osrmIsochrone">osrmIsochrone</a></code>: This function computes areas that are
reachable within a given time span from a point and returns the reachable
regions as polygons. These areas of equal travel time are called isochrones.
</p>
</li>
<li><p><code><a href="#topic+osrmIsodistance">osrmIsodistance</a></code>: This function computes areas that are
reachable within a given road distance from a point and returns the reachable
regions as polygons. These areas of equal travel distance are called
isodistances.
</p>
</li></ul>



<h3>Note</h3>

<p>This package relies on the usage of a running OSRM service (tested with
version 5.27.0 of the OSRM API).<br />
</p>
<p>To set the OSRM server, change the <code>osrm.server</code> option:<br />
<code>options(osrm.server = "http://address.of.the.server/")</code> <br /><br />
To set the profile, use the <code>osrm.profile</code> option:<br />
<code>options(osrm.profile = "name.of.the.profile")</code><br />
The &quot;car&quot; profile is set by default. Other possible profiles are &quot;foot&quot; and &quot;bike&quot;.<br /><br />
</p>
<p>A typical setup, corresponding to the Docker example, would be:<br />
<code>options(osrm.server = "http://0.0.0.0:5000/", osrm.profile = "car")</code>
</p>
<p>The package ships a sample dataset of 100 random pharmacies in Berlin
(© OpenStreetMap contributors - <a href="https://www.openstreetmap.org/copyright/en">https://www.openstreetmap.org/copyright/en</a>).<br />
The sf dataset uses the projection WGS 84 / UTM zone 34N (EPSG:32634).<br />
The csv dataset uses WGS 84 (EPSG:4326).<br />
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Timothée Giraud <a href="mailto:timothee.giraud@cnrs.fr">timothee.giraud@cnrs.fr</a> (<a href="https://orcid.org/0000-0002-1932-3323">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Robin Cura (<a href="https://orcid.org/0000-0001-5926-1828">ORCID</a>) [contributor]
</p>
</li>
<li><p> Matthieu Viry (<a href="https://orcid.org/0000-0002-0693-8556">ORCID</a>) [contributor]
</p>
</li>
<li><p> Robin Lovelace (<a href="https://orcid.org/0000-0001-5679-6536">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/riatelab/osrm">https://github.com/riatelab/osrm</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/riatelab/osrm/issues">https://github.com/riatelab/osrm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='osrmIsochrone'>Get Polygons of Isochrones</h2><span id='topic+osrmIsochrone'></span>

<h3>Description</h3>

<p>This function computes areas that are reachable within a
given time span from a point and returns the reachable regions as
polygons. These areas of equal travel time are called isochrones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osrmIsochrone(
  loc,
  breaks = seq(from = 0, to = 60, length.out = 7),
  exclude,
  res = 30,
  returnclass,
  osrm.server = getOption("osrm.server"),
  osrm.profile = getOption("osrm.profile")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osrmIsochrone_+3A_loc">loc</code></td>
<td>
<p>origin point. <code>loc</code> can be: </p>

<ul>
<li><p> a vector of coordinates (longitude and latitude, WGS 84),
</p>
</li>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>If <code>loc</code> is a data.frame, a matrix, an sfc object or an sf object then
only the first row or element is considered.</p>
</td></tr>
<tr><td><code id="osrmIsochrone_+3A_breaks">breaks</code></td>
<td>
<p>a numeric vector of break values to define isochrone areas,
in minutes.</p>
</td></tr>
<tr><td><code id="osrmIsochrone_+3A_exclude">exclude</code></td>
<td>
<p>pass an optional &quot;exclude&quot; request option to the OSRM API.</p>
</td></tr>
<tr><td><code id="osrmIsochrone_+3A_res">res</code></td>
<td>
<p>number of points used to compute isochrones, one side of the square
grid, the total number of points will be res*res. Increase res to obtain more
detailed isochrones.</p>
</td></tr>
<tr><td><code id="osrmIsochrone_+3A_returnclass">returnclass</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="osrmIsochrone_+3A_osrm.server">osrm.server</code></td>
<td>
<p>the base URL of the routing server.
getOption(&quot;osrm.server&quot;) by default.</p>
</td></tr>
<tr><td><code id="osrmIsochrone_+3A_osrm.profile">osrm.profile</code></td>
<td>
<p>the routing profile to use, e.g. &quot;car&quot;, &quot;bike&quot; or &quot;foot&quot;
(when using the routing.openstreetmap.de test server).
getOption(&quot;osrm.profile&quot;) by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of this function is an sf MULTIPOLYGON of isochrones.<br />
It contains 3 fields: </p>

<ul>
<li><p> id, an identifier
</p>
</li>
<li><p> isomin, the minimum value of the isochrone polygon in minutes
</p>
</li>
<li><p> isomax, the maximum value of the isochrone polygon in minutes
</p>
</li></ul>

<p>If loc is a vector, a data.frame or a matrix the coordinate
reference system (CRS) of the output is EPSG:4326 (WGS84).<br />
If loc is an sfc or sf object, the output has the same CRS
as loc.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
apotheke.sf &lt;- st_read(system.file("gpkg/apotheke.gpkg", package = "osrm"),
  quiet = TRUE
)
# Get isochones with lon/lat coordinates
iso &lt;- osrmIsochrone(loc = c(13.43, 52.47), breaks = seq(0, 12, 2))
# Map
plot(iso["isomax"], breaks = sort(unique(c(iso$isomin, iso$isomax))))

# Get isochones with an sf POINT
iso2 &lt;- osrmIsochrone(loc = apotheke.sf[11, ], breaks = seq(0, 12, 2))
# Map
if (require("mapsf")) {
  mapsf::mf_map(
    x = iso2, var = "isomin", type = "choro",
    breaks = sort(unique(c(iso2$isomin, iso2$isomax))),
    pal = "Burg", border = NA, leg_pos = "topleft",
    leg_val_rnd = 0,
    leg_frame = TRUE, leg_title = "Isochrones\n(min)"
  )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='osrmIsodistance'>Get Polygons of Isodistances</h2><span id='topic+osrmIsodistance'></span>

<h3>Description</h3>

<p>This function computes areas that are reachable within a
given road distance from a point and returns the reachable regions as
polygons. These areas of equal travel distance are called isodistances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osrmIsodistance(
  loc,
  breaks = seq(from = 0, to = 10000, length.out = 4),
  exclude,
  res = 30,
  returnclass,
  osrm.server = getOption("osrm.server"),
  osrm.profile = getOption("osrm.profile")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osrmIsodistance_+3A_loc">loc</code></td>
<td>
<p>origin point. <code>loc</code> can be: </p>

<ul>
<li><p> a vector of coordinates (longitude and latitude, WGS 84),
</p>
</li>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>If <code>loc</code> is a data.frame, a matrix, an sfc object or an sf object then
only the first row or element is considered.</p>
</td></tr>
<tr><td><code id="osrmIsodistance_+3A_breaks">breaks</code></td>
<td>
<p>a numeric vector of break values to define isodistance areas,
in meters.</p>
</td></tr>
<tr><td><code id="osrmIsodistance_+3A_exclude">exclude</code></td>
<td>
<p>pass an optional &quot;exclude&quot; request option to the OSRM API.</p>
</td></tr>
<tr><td><code id="osrmIsodistance_+3A_res">res</code></td>
<td>
<p>number of points used to compute isodistances, one side of the
square grid, the total number of points will be res*res. Increase res to
obtain more detailed isodistances.</p>
</td></tr>
<tr><td><code id="osrmIsodistance_+3A_returnclass">returnclass</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="osrmIsodistance_+3A_osrm.server">osrm.server</code></td>
<td>
<p>the base URL of the routing server.
getOption(&quot;osrm.server&quot;) by default.</p>
</td></tr>
<tr><td><code id="osrmIsodistance_+3A_osrm.profile">osrm.profile</code></td>
<td>
<p>the routing profile to use, e.g. &quot;car&quot;, &quot;bike&quot; or &quot;foot&quot;
(when using the routing.openstreetmap.de test server).
getOption(&quot;osrm.profile&quot;) by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of this function is an sf MULTIPOLYGON of isodistances.<br />
It contains 3 fields: </p>

<ul>
<li><p> id, an identifier
</p>
</li>
<li><p> isomin, the minimum value of the isodistance polygon in meters
</p>
</li>
<li><p> isomax, the maximum value of the isodistance polygon in meters
</p>
</li></ul>

<p>If loc is a vector, a data.frame or a matrix the coordinate
reference system (CRS) of the output is EPSG:4326 (WGS84).<br />
If loc is an sfc or sf object, the output has the same CRS
as loc.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
apotheke.sf &lt;- st_read(system.file("gpkg/apotheke.gpkg", package = "osrm"),
  quiet = TRUE
)
# Get isochones with lon/lat coordinates
iso &lt;- osrmIsodistance(loc = c(13.43, 52.47), breaks = seq(0, 500, 100))
# Map
plot(iso["isomax"], breaks = sort(unique(c(iso$isomin, iso$isomax))))

# Get isochones with an sf POINT
iso2 &lt;- osrmIsodistance(loc = apotheke.sf[11, ], breaks = seq(0, 500, 100))
# Map
if (require("mapsf")) {
  mapsf::mf_map(
    x = iso2, var = "isomin", type = "choro",
    breaks = sort(unique(c(iso2$isomin, iso2$isomax))),
    pal = "Burg", border = NA, leg_pos = "topleft",
    leg_val_rnd = 0,
    leg_frame = TRUE, leg_title = "Isochrones\n(min)"
  )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='osrmIsometric'>deprecated</h2><span id='topic+osrmIsometric'></span>

<h3>Description</h3>

<p>deprecated, use <a href="#topic+osrmIsodistance">osrmIsodistance</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osrmIsometric(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osrmIsometric_+3A_...">...</code></td>
<td>
<p>deprecated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>deprecated
</p>

<hr>
<h2 id='osrmNearest'>Get the Nearest Point on the Street Network</h2><span id='topic+osrmNearest'></span>

<h3>Description</h3>

<p>This function interfaces with the <em>nearest</em> OSRM
service.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osrmNearest(
  loc,
  exclude,
  osrm.server = getOption("osrm.server"),
  osrm.profile = getOption("osrm.profile")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osrmNearest_+3A_loc">loc</code></td>
<td>
<p>a point to snap to the street network. <code>loc</code> can be: </p>

<ul>
<li><p> a vector of coordinates (longitude and latitude, WGS 84),
</p>
</li>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>If <code>src</code> is a data.frame, a matrix, an sfc object or an sf object then
only the first row or element is considered.</p>
</td></tr>
<tr><td><code id="osrmNearest_+3A_exclude">exclude</code></td>
<td>
<p>pass an optional &quot;exclude&quot; request option to the OSRM API.</p>
</td></tr>
<tr><td><code id="osrmNearest_+3A_osrm.server">osrm.server</code></td>
<td>
<p>the base URL of the routing server.</p>
</td></tr>
<tr><td><code id="osrmNearest_+3A_osrm.profile">osrm.profile</code></td>
<td>
<p>the routing profile to use, e.g. &quot;car&quot;, &quot;bike&quot; or &quot;foot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of this function is an sf POINT of the point on the street
network.<br />
It contains 2 fields: </p>

<ul>
<li><p> id, the point identifierv
</p>
</li>
<li><p> distance, the distance in meters to the supplied input point.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
apotheke.sf &lt;- st_read(system.file("gpkg/apotheke.gpkg", package = "osrm"),
  quiet = TRUE
)
pt &lt;- osrmNearest(apotheke.sf[56, ])
pt$distance

## End(Not run)
</code></pre>

<hr>
<h2 id='osrmRoute'>Get the Shortest Path Between Two Points</h2><span id='topic+osrmRoute'></span>

<h3>Description</h3>

<p>Build and send an OSRM API query to get the travel geometry
between two points. This function interfaces with the <em>route</em> OSRM
service.<br />
Use <code>src</code> and <code>dst</code> to get the shortest direct route between
two points.<br />
Use <code>loc</code> to get the shortest route between two points using
ordered waypoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osrmRoute(
  src,
  dst,
  loc,
  overview = "simplified",
  exclude,
  returnclass,
  osrm.server = getOption("osrm.server"),
  osrm.profile = getOption("osrm.profile")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osrmRoute_+3A_src">src</code></td>
<td>
<p>starting point of the route.
<code>src</code> can be: </p>

<ul>
<li><p> a vector of coordinates (longitude and latitude, WGS 84),
</p>
</li>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>If relevant, row names are used as identifiers.<br />
If <code>src</code> is a data.frame, a matrix, an sfc object or an sf object then
only the first row or element is considered.</p>
</td></tr>
<tr><td><code id="osrmRoute_+3A_dst">dst</code></td>
<td>
<p>destination of the route.
<code>dst</code> can be: </p>

<ul>
<li><p> a vector of coordinates (longitude and latitude, WGS 84),
</p>
</li>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>If relevant, row names are used as identifiers.<br />
If <code>dst</code> is a data.frame, a matrix, an sfc object or an sf object then
only the first row or element is considered.</p>
</td></tr>
<tr><td><code id="osrmRoute_+3A_loc">loc</code></td>
<td>
<p>starting point, waypoints (optional) and destination of the
route. <code>loc</code> can be: </p>

<ul>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>The first row or element is the starting point then waypoints are used in
the order they are stored in <code>loc</code> and the last row or element is
the destination.<br />
If relevant, row names are used as identifiers.<br /></p>
</td></tr>
<tr><td><code id="osrmRoute_+3A_overview">overview</code></td>
<td>
<p>&quot;full&quot;, &quot;simplified&quot; or FALSE. Use &quot;full&quot; to return the
detailed geometry, use &quot;simplified&quot; to return a simplified geometry, use
FALSE to return only time and distance.</p>
</td></tr>
<tr><td><code id="osrmRoute_+3A_exclude">exclude</code></td>
<td>
<p>pass an optional &quot;exclude&quot; request option to the OSRM API.</p>
</td></tr>
<tr><td><code id="osrmRoute_+3A_returnclass">returnclass</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="osrmRoute_+3A_osrm.server">osrm.server</code></td>
<td>
<p>the base URL of the routing server.</p>
</td></tr>
<tr><td><code id="osrmRoute_+3A_osrm.profile">osrm.profile</code></td>
<td>
<p>the routing profile to use, e.g. &quot;car&quot;, &quot;bike&quot; or &quot;foot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of this function is an sf LINESTRING of the shortest route.<br />
It contains 4 fields: </p>

<ul>
<li><p> starting point identifier
</p>
</li>
<li><p> destination identifier
</p>
</li>
<li><p> travel time in minutes
</p>
</li>
<li><p> travel distance in kilometers.
</p>
</li></ul>

<p>If src (or loc) is a vector, a data.frame or a matrix, the coordinate
reference system (CRS) of the route is EPSG:4326 (WGS84).<br />
If src (or loc) is an sfc or sf object, the route has the same CRS
as src (or loc).<br /><br />
If overview is FALSE, a named numeric vector is returned. It contains travel
time (in minutes) and travel distance (in kilometers).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
apotheke.df &lt;- read.csv(system.file("csv/apotheke.csv", package = "osrm"))
apotheke.sf &lt;- st_read(system.file("gpkg/apotheke.gpkg", package = "osrm"),
  quiet = TRUE
)
# Travel path between points
route1 &lt;- osrmRoute(src = apotheke.sf[1, ], dst = apotheke.sf[16, ])
# Display paths
plot(st_geometry(route1))
plot(st_geometry(apotheke.sf[c(1, 16), ]), col = "red", pch = 20, add = TRUE)

# Return only duration and distance
route3 &lt;- osrmRoute(
  src = apotheke.df[1, c("lon", "lat")],
  dst = apotheke.df[16, c("lon", "lat")],
  overview = FALSE
)
route3

# Using only coordinates
route4 &lt;- osrmRoute(
  src = c(13.412, 52.502),
  dst = c(13.454, 52.592)
)
plot(st_geometry(route4))

# Using via points
route5 &lt;- osrmRoute(loc = apotheke.sf[c(1, 2, 4, 3), ])
plot(st_geometry(route5), col = "red", lwd = 2)
plot(st_geometry(apotheke.sf[c(1, 2, 4, 3), ]), add = TRUE)

# Using a different routing server
u &lt;- "https://routing.openstreetmap.de/routed-foot/"
route5 &lt;- osrmRoute(apotheke.sf[1, ], apotheke.sf[16, ], osrm.server = u)
route5

# Using an open routing service with support for multiple modes
# see https://github.com/riatelab/osrm/issues/67
u &lt;- "https://routing.openstreetmap.de/"
options(osrm.server = u)
route6 &lt;- osrmRoute(apotheke.sf[1, ], apotheke.sf[16, ],
  osrm.profile = "bike"
)
route7 &lt;- osrmRoute(apotheke.sf[1, ], apotheke.sf[16, ],
  osrm.profile = "car"
)
plot(st_geometry(route7), col = "green") # car
plot(st_geometry(route6), add = TRUE) # bike
plot(st_geometry(route5), col = "red", add = TRUE) # foot

## End(Not run)
</code></pre>

<hr>
<h2 id='osrmTable'>Get Travel Time Matrices Between Points</h2><span id='topic+osrmTable'></span>

<h3>Description</h3>

<p>Build and send OSRM API queries to get travel time matrices
between points. This function interfaces the <em>table</em> OSRM service.<br />
Use <code>src</code> and <code>dst</code> to set different origins and destinations.<br />
Use <code>loc</code> to compute travel times or travel distances between all
points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osrmTable(
  src,
  dst = src,
  loc,
  exclude,
  measure = "duration",
  osrm.server = getOption("osrm.server"),
  osrm.profile = getOption("osrm.profile")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osrmTable_+3A_src">src</code></td>
<td>
<p>origin points.
<code>src</code> can be: </p>

<ul>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>If relevant, row names are used as identifiers.</p>
</td></tr>
<tr><td><code id="osrmTable_+3A_dst">dst</code></td>
<td>
<p>destination.
<code>dst</code> can be: </p>

<ul>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>If relevant, row names are used as identifiers.</p>
</td></tr>
<tr><td><code id="osrmTable_+3A_loc">loc</code></td>
<td>
<p>points. <code>loc</code> can be: </p>

<ul>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>If relevant, row names are used as identifiers.</p>
</td></tr>
<tr><td><code id="osrmTable_+3A_exclude">exclude</code></td>
<td>
<p>pass an optional &quot;exclude&quot; request option to the OSRM API
(not allowed with the OSRM demo server).</p>
</td></tr>
<tr><td><code id="osrmTable_+3A_measure">measure</code></td>
<td>
<p>a character indicating what measures are calculated. It can
be &quot;duration&quot; (in minutes), &quot;distance&quot; (meters), or both c('duration',
'distance').</p>
</td></tr>
<tr><td><code id="osrmTable_+3A_osrm.server">osrm.server</code></td>
<td>
<p>the base URL of the routing server.</p>
</td></tr>
<tr><td><code id="osrmTable_+3A_osrm.profile">osrm.profile</code></td>
<td>
<p>the routing profile to use, e.g. &quot;car&quot;, &quot;bike&quot; or &quot;foot&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of this function is a list composed of one or two matrices
and 2 data.frames
</p>

<ul>
<li><p>durations: a matrix of travel times (in minutes)
</p>
</li>
<li><p>distances: a matrix of distances (in meters)
</p>
</li>
<li><p>sources: a data.frame of the coordinates of the points actually
used as starting points (EPSG:4326 - WGS84)
</p>
</li>
<li><p>sources: a data.frame of the coordinates of the points actually
used as destinations (EPSG:4326 - WGS84)
</p>
</li></ul>



<h3>Note</h3>

<p>The OSRM demo server does not allow large queries (more than 10000 distances
or durations).<br />
If you use your own server and if you want to get a large number of distances
make sure to set the &quot;max-table-size&quot; option (Max. locations supported in
table) of the OSRM server accordingly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Inputs are data frames
apotheke.df &lt;- read.csv(system.file("csv/apotheke.csv", package = "osrm"))
# Travel time matrix
distA &lt;- osrmTable(loc = apotheke.df[1:50, c("lon", "lat")])
# First 5 rows and columns
distA$durations[1:5, 1:5]

# Travel time matrix with different sets of origins and destinations
distA2 &lt;- osrmTable(
  src = apotheke.df[1:10, c("lon", "lat")],
  dst = apotheke.df[11:20, c("lon", "lat")]
)
# First 5 rows and columns
distA2$durations[1:5, 1:5]

# Inputs are sf points
library(sf)
apotheke.sf &lt;- st_read(system.file("gpkg/apotheke.gpkg", package = "osrm"),
  quiet = TRUE
)
distA3 &lt;- osrmTable(loc = apotheke.sf[1:10, ])
# First 5 rows and columns
distA3$durations[1:5, 1:5]

# Travel time matrix with different sets of origins and destinations
distA4 &lt;- osrmTable(src = apotheke.sf[1:10, ], dst = apotheke.sf[11:20, ])
# First 5 rows and columns
distA4$durations[1:5, 1:5]

# Road distance matrix with different sets of origins and destinations
distA5 &lt;- osrmTable(
  src = apotheke.sf[1:10, ], dst = apotheke.sf[11:20, ],
  measure = "distance"
)
# First 5 rows and columns
distA5$distances[1:5, 1:5]

## End(Not run)
</code></pre>

<hr>
<h2 id='osrmTrip'>Get the Travel Geometry Between Multiple Unordered Points</h2><span id='topic+osrmTrip'></span>

<h3>Description</h3>

<p>Build and send an OSRM API query to get the shortest travel
geometry between multiple unordered points.
This function interfaces the <em>trip</em> OSRM service.<br />
Use this function to resolve the travelling salesman problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osrmTrip(
  loc,
  exclude = NULL,
  overview = "simplified",
  returnclass,
  osrm.server = getOption("osrm.server"),
  osrm.profile = getOption("osrm.profile")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="osrmTrip_+3A_loc">loc</code></td>
<td>
<p>starting point and waypoints to reach along the
route. <code>loc</code> can be: </p>

<ul>
<li><p> a data.frame of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> a matrix of longitudes and latitudes (WGS 84),
</p>
</li>
<li><p> an sfc object of type POINT,
</p>
</li>
<li><p> an sf object of type POINT.
</p>
</li></ul>

<p>The first row or element is the starting point.<br />
Row names, if relevant, or element indexes are used as identifiers.</p>
</td></tr>
<tr><td><code id="osrmTrip_+3A_exclude">exclude</code></td>
<td>
<p>pass an optional &quot;exclude&quot; request option to the OSRM API.</p>
</td></tr>
<tr><td><code id="osrmTrip_+3A_overview">overview</code></td>
<td>
<p>&quot;full&quot;, &quot;simplified&quot;. Add geometry either full (detailed) or simplified
according to highest zoom level it could be display on.</p>
</td></tr>
<tr><td><code id="osrmTrip_+3A_returnclass">returnclass</code></td>
<td>
<p>deprecated.</p>
</td></tr>
<tr><td><code id="osrmTrip_+3A_osrm.server">osrm.server</code></td>
<td>
<p>the base URL of the routing server.</p>
</td></tr>
<tr><td><code id="osrmTrip_+3A_osrm.profile">osrm.profile</code></td>
<td>
<p>the routing profile to use, e.g. &quot;car&quot;, &quot;bike&quot; or &quot;foot&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As stated in the OSRM API, if input coordinates can not be joined by a single trip
(e.g. the coordinates are on several disconnected islands) multiple trips for
each connected component are returned.
</p>


<h3>Value</h3>

<p>A list of connected components is returned. Each component contains:
</p>

<dl>
<dt>trip</dt><dd>
<p>An sf LINESTRING. If loc is a data.frame or a matrix the coordinate
reference system (CRS) of the route is EPSG:4326 (WGS84). If loc is an sfc or
sf object, the route has the same CRS as loc.<br />
Each line of the returned route is a step of the trip. The object has four
columns: start (identifier of the starting point),
end (identifier of the destination), duration (duration of the step in minutes),
distance (length of the step in kilometers).
</p>
</dd>
<dt>summary</dt><dd><p>A list with 2 components: total duration (in minutes)
and total distance (in kilometers) of the trip.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
apotheke.sf &lt;- st_read(system.file("gpkg/apotheke.gpkg", package = "osrm"),
  quiet = TRUE
)
# Get a trip with a set of points (sf POINT)
trips &lt;- osrmTrip(loc = apotheke.sf[1:5, ])
mytrip &lt;- trips[[1]]$trip
# Display the trip
plot(st_geometry(mytrip), col = "black", lwd = 4)
plot(st_geometry(mytrip), col = c("red", "white"), lwd = 1, add = TRUE)
plot(st_geometry(apotheke.sf[1:5, ]),
  pch = 21, bg = "red", cex = 1,
  add = TRUE
)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
