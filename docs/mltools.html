<!DOCTYPE html><html lang="en"><head><title>Help for package mltools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mltools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alien.test'><p>Alien test dataset</p></a></li>
<li><a href='#alien.train'><p>Alien training dataset</p></a></li>
<li><a href='#auc_roc'><p>Area Under the ROC Curve</p></a></li>
<li><a href='#bin_data'><p>Map a vector of numeric values into bins</p></a></li>
<li><a href='#date_factor'><p>Date Factor</p></a></li>
<li><a href='#empirical_cdf'><p>Empirical Cumulative Distribution Function</p></a></li>
<li><a href='#explore_dataset'><p>Explore Dataset</p></a></li>
<li><a href='#exponential_weight'><p>Exponential Weight</p></a></li>
<li><a href='#folds'><p>Cross Validation Folds</p></a></li>
<li><a href='#geometric_weight'><p>Geometric Weight</p></a></li>
<li><a href='#gini_impurities'><p>Gini Impurities</p></a></li>
<li><a href='#gini_impurity'><p>Gini Impurity</p></a></li>
<li><a href='#mcc'><p>Matthews correlation coefficient</p></a></li>
<li><a href='#mse'><p>Mean Square Error</p></a></li>
<li><a href='#msle'><p>Mean Square Logarithmic Error</p></a></li>
<li><a href='#one_hot'><p>One Hot Encode</p></a></li>
<li><a href='#relative_position'><p>Relative Position</p></a></li>
<li><a href='#replace_na'><p>Replace NA Values</p></a></li>
<li><a href='#rmse'><p>Root Mean Square Error</p></a></li>
<li><a href='#rmsle'><p>Root Mean Square Logarithmic Error</p></a></li>
<li><a href='#roc_scores'><p>ROC scores</p></a></li>
<li><a href='#set_factor'><p>Set Factor</p></a></li>
<li><a href='#skewness'><p>Skewness</p></a></li>
<li><a href='#sparsify'><p>Sparsify</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Machine Learning Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Gorman</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Gorman &lt;bgorman@GormAnalysis.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of machine learning helper functions, particularly assisting in the Exploratory Data Analysis phase. Makes heavy use of the 'data.table' package for optimal speed and memory efficiency. Highlights include a versatile bin_data() function, sparsify() for converting a data.table to sparse matrix format with one-hot encoding, fast evaluation metrics, and empirical_cdf() for calculating empirical Multivariate Cumulative Distribution Functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ben519/mltools">https://github.com/ben519/mltools</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ben519/mltools/issues">https://github.com/ben519/mltools/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table(&ge; 1.9.7), Matrix, methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-11 23:15:32 UTC; Ben</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-12 03:12:45 UTC</td>
</tr>
</table>
<hr>
<h2 id='alien.test'>Alien test dataset</h2><span id='topic+alien.test'></span>

<h3>Description</h3>

<p>A dataset describing features of living beings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alien.test
</code></pre>


<h3>Format</h3>

<p>A data.table with 8 rows and 5 variables:
</p>

<dl>
<dt>SkinColor</dt><dd><p>Skin color of the individual</p>
</dd>
<dt>IQScore</dt><dd><p>IQ score of the individual</p>
</dd>
<dt>Cat1</dt><dd><p>Categorical descriptor</p>
</dd>
<dt>Cat2</dt><dd><p>Categorical descriptor</p>
</dd>
<dt>Cat3</dt><dd><p>Categorical descriptor</p>
</dd>
</dl>


<h3>Details</h3>

<p>library(data.table)
</p>
<p>alien.test &lt;- data.table::data.table(
SkinColor=c(&quot;white&quot;, &quot;green&quot;, &quot;brown&quot;, &quot;white&quot;, &quot;red&quot;),
IQScore=c(79, 100, 125, 90, 115),
Cat1=c(&quot;type4&quot;, &quot;type4&quot;, &quot;type3&quot;, &quot;type1&quot;, &quot;type1&quot;),
Cat2=c(&quot;type5&quot;, &quot;type5&quot;, &quot;type9&quot;, &quot;type8&quot;, &quot;type2&quot;),
Cat3=c(&quot;type2&quot;, &quot;type2&quot;, &quot;type7&quot;, &quot;type4&quot;, &quot;type4&quot;)
)
</p>
<p>save(alien.test, file=&quot;data/alien_test.rda&quot;)
</p>

<hr>
<h2 id='alien.train'>Alien training dataset</h2><span id='topic+alien.train'></span>

<h3>Description</h3>

<p>A dataset describing features of living beings and whether or not they are an alien
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alien.train
</code></pre>


<h3>Format</h3>

<p>A data.table with 8 rows and 6 variables:
</p>

<dl>
<dt>SkinColor</dt><dd><p>Skin color of the individual</p>
</dd>
<dt>IQScore</dt><dd><p>IQ score of the individual</p>
</dd>
<dt>Cat1</dt><dd><p>Categorical descriptor</p>
</dd>
<dt>Cat2</dt><dd><p>Categorical descriptor</p>
</dd>
<dt>Cat3</dt><dd><p>Categorical descriptor</p>
</dd>
<dt>IsAlien</dt><dd><p>Is this being an alien?</p>
</dd>
</dl>


<h3>Details</h3>

<p>library(data.table)
</p>
<p>alien.train &lt;- data.table::data.table(
SkinColor=c(&quot;green&quot;, &quot;white&quot;, &quot;brown&quot;, &quot;white&quot;, &quot;blue&quot;, &quot;white&quot;, &quot;green&quot;, &quot;white&quot;),
IQScore=c(300, 95, 105, 250, 115, 85, 130, 115),
Cat1=c(&quot;type1&quot;, &quot;type1&quot;, &quot;type2&quot;, &quot;type4&quot;, &quot;type2&quot;, &quot;type4&quot;, &quot;type1&quot;, &quot;type1&quot;),
Cat2=c(&quot;type1&quot;, &quot;type2&quot;, &quot;type6&quot;, &quot;type5&quot;, &quot;type7&quot;, &quot;type5&quot;, &quot;type2&quot;, &quot;type1&quot;),
Cat3=c(&quot;type4&quot;, &quot;type4&quot;, &quot;type11&quot;, &quot;type2&quot;, &quot;type11&quot;, &quot;type2&quot;, &quot;type4&quot;, &quot;type4&quot;),
IsAlien=c(TRUE, FALSE, FALSE, TRUE, TRUE, FALSE, TRUE, FALSE)
)
</p>
<p>save(alien.train, file=&quot;data/alien_train.rda&quot;)
</p>

<hr>
<h2 id='auc_roc'>Area Under the ROC Curve</h2><span id='topic+auc_roc'></span>

<h3>Description</h3>

<p>Calculates Area Under the ROC Curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc_roc(preds, actuals, returnDT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="auc_roc_+3A_preds">preds</code></td>
<td>
<p>A vector of prediction values</p>
</td></tr>
<tr><td><code id="auc_roc_+3A_actuals">actuals</code></td>
<td>
<p>A vector of actuals values (numeric or ordered factor)</p>
</td></tr>
<tr><td><code id="auc_roc_+3A_returndt">returnDT</code></td>
<td>
<p>If TRUE, a data.table of (FalsePositiveRate, TruePositiveRate) pairs is returned, otherwise AUC ROC score is returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>returnDT=FALSE</code>, returns Area Under the ROC Curve.If <code>returnDT=TRUE</code>, returns a data.table object with
False Positive Rate and True Positive Rate for plotting the ROC curve.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve">https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
preds &lt;- c(.1, .3, .3, .9)
actuals &lt;- c(0, 0, 1, 1)
auc_roc(preds, actuals)
auc_roc(preds, actuals, returnDT=TRUE)
</code></pre>

<hr>
<h2 id='bin_data'>Map a vector of numeric values into bins</h2><span id='topic+bin_data'></span>

<h3>Description</h3>

<p>Takes a vector of values and bin parameters and maps each value to an ordered factor whose levels are a set of bins like [0,1), [1,2), [2,3).
</p>
<p>Values may be provided as a vector or via a pair of parameters - a data.table object and the name of the column to bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_data(x = NULL, binCol = NULL, bins = 10, binType = "explicit",
  boundaryType = "lcro]", returnDT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bin_data_+3A_x">x</code></td>
<td>
<p>A vector of values or a data.table object</p>
</td></tr>
<tr><td><code id="bin_data_+3A_bincol">binCol</code></td>
<td>
<p>A column of <code>dt</code> specifying the values to bin</p>
</td></tr>
<tr><td><code id="bin_data_+3A_bins">bins</code></td>
<td>

<ul>
<li><p><b>integer</b> specifying the number of bins to generate
</p>
</li>
<li><p><b>numeric vector</b> specifying sequential bin boundaries {(x0, x1), (x1, x2), ..., (xn-1, xn)}
</p>
</li>
<li><p><b>2-column data.frame/data.table</b> each row defines a bin
</p>
</li></ul>
</td></tr>
<tr><td><code id="bin_data_+3A_bintype">binType</code></td>
<td>

<ul>
<li><p><b>&quot;explicit&quot;</b> interpret bins as they are given
</p>
</li>
<li><p><b>&quot;quantile&quot;</b> interpret bins as quantiles (empty quantile bins will be discarded)
</p>
</li></ul>
</td></tr>
<tr><td><code id="bin_data_+3A_boundarytype">boundaryType</code></td>
<td>

<ul>
<li><p><b>&quot;lcro]&quot;</b> bins are [left-closed, right-open) except for last bin which is [left-closed, right-closed]
</p>
</li>
<li><p><b>&quot;lcro)&quot;</b> bins are [left-closed, right-open)
</p>
</li>
<li><p><b>&quot;[lorc&quot;</b> bins are (left-open, right-closed] except for first bin which is [left-closed, right-closed]
</p>
</li>
<li><p><b>&quot;(lorc&quot;</b> bins are (left-open, right-closed]
</p>
</li></ul>
</td></tr>
<tr><td><code id="bin_data_+3A_returndt">returnDT</code></td>
<td>
<p>If <b>FALSE</b>, return an ordered factor of bins corresponding to the values given, else return
a data.table object which includes all bins and values (makes a copy of data.table object if given)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can return two different types of output, depending on whether <code>returnDT</code> is <code>TRUE</code> or <code>FALSE</code>.
</p>
<p>If <code>returnDT=FALSE</code>, returns an ordered factor vector of bins like [1, 2), [-3,-2), ... corresponding to the values which were
binned and whose levels correspond to all the generated bins. (Note that empty bins may be present as unused factor levels).
</p>
<p>If <code>returnDT=TRUE</code>, returns a data.table object with all values and all bins (including empty bins). If <code>dt</code> is provided
instead of <code>vals</code>, a full copy of <code>dt</code> is created and merged with the set of generated bins.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
iris.dt &lt;- data.table(iris)

# custom bins
bin_data(iris.dt, binCol="Sepal.Length", bins=c(4, 5, 6, 7, 8))

# 10 equally spaced bins
bin_data(iris$Petal.Length, bins=10, returnDT=TRUE)

# make the last bin [left-closed, right-open)
bin_data(c(0,0,1,2), bins=2, boundaryType="lcro)", returnDT=TRUE)

# bin values by quantile
bin_data(c(0,0,0,0,1,2,3,4), bins=4, binType="quantile", returnDT=TRUE)

</code></pre>

<hr>
<h2 id='date_factor'>Date Factor</h2><span id='topic+date_factor'></span>

<h3>Description</h3>

<p>Map a vector of dates to a factor at one of these levels &quot;yearmonth&quot;, &quot;yearquarter&quot;, &quot;quarter&quot;, &quot;month&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_factor(dateVec, type = "yearmonth", minDate = min(dateVec, na.rm =
  TRUE), maxDate = max(dateVec, na.rm = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="date_factor_+3A_datevec">dateVec</code></td>
<td>
<p>A vector of date values</p>
</td></tr>
<tr><td><code id="date_factor_+3A_type">type</code></td>
<td>
<p>One of &quot;year&quot;, &quot;yearquarter&quot;, &quot;yearmonth&quot;, &quot;quarter&quot;, &quot;month&quot;</p>
</td></tr>
<tr><td><code id="date_factor_+3A_mindate">minDate</code></td>
<td>
<p>(Default = min(dateVec)) When determining factor levels, use this date to set the min level, after coercing 
dates to the specified <code>type</code>. For example, if dateVec = (2016-01-15, 2016-02-15), type = &quot;yearmonth&quot;, and minDate = 2016-02-01,
the result will be (NA, Feb 2016).</p>
</td></tr>
<tr><td><code id="date_factor_+3A_maxdate">maxDate</code></td>
<td>
<p>(Default = max(dateVec)) When determining factor levels, use this date to set the max level. (See minDate, above)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting vector is an ordered factor of the specified <code>type</code> (e.g. yearmonth)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
dts &lt;- as.Date(c("2014-1-1", "2015-1-15", "2015-6-1"))
date_factor(dts, type = "yearmonth")
date_factor(dts, type = "yearquarter")
date_factor(
  dateVec = dts, 
  type = "yearquarter", 
  minDate = as.Date("2015-1-1"), 
  maxDate = as.Date("2015-12-31")
)
date_factor(
  dateVec = as.Date(character(0)), 
  type = "yearmonth", 
  minDate = as.Date("2016-1-1"), 
  as.Date("2016-12-31")
)

</code></pre>

<hr>
<h2 id='empirical_cdf'>Empirical Cumulative Distribution Function</h2><span id='topic+empirical_cdf'></span>

<h3>Description</h3>

<p>Given a vector x, calculate P(x &lt;= X) for a set of upper bounds X.
Can be applied to a data.table object for multivariate use. That is, 
calculate P(x &lt;= X, y &lt;= Y, z &lt;= Z, ...)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empirical_cdf(x, ubounds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="empirical_cdf_+3A_x">x</code></td>
<td>
<p>Numeric vector or a data.table object for multivariate use.</p>
</td></tr>
<tr><td><code id="empirical_cdf_+3A_ubounds">ubounds</code></td>
<td>
<p>A vector of upper bounds on which to evaluate the CDF.
For multivariate version, a data.table whose names correspond to columns of x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the empirical CDF of a vector, or data.table with multiple columns for multivariate use.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
dt &lt;- data.table(x=c(0.3, 1.3, 1.4, 3.6), y=c(1.2, 1.2, 3.8, 3.9))
empirical_cdf(dt$x, ubounds=1:4)
empirical_cdf(dt, ubounds=CJ(x = 1:4, y = 1:4))

</code></pre>

<hr>
<h2 id='explore_dataset'>Explore Dataset</h2><span id='topic+explore_dataset'></span>

<h3>Description</h3>

<p>(Experimental) Automated Exploratory Data Analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explore_dataset(dt1, dt2 = NULL, targetCol = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="explore_dataset_+3A_dt1">dt1</code></td>
<td>
<p>dataset to analyze</p>
</td></tr>
<tr><td><code id="explore_dataset_+3A_dt2">dt2</code></td>
<td>
<p>(optional) second dataset to analyze, with the same columns as dt1</p>
</td></tr>
<tr><td><code id="explore_dataset_+3A_targetcol">targetCol</code></td>
<td>
<p>Name of the column you're trying to model/predict</p>
</td></tr>
<tr><td><code id="explore_dataset_+3A_verbose">verbose</code></td>
<td>
<p>Should the exploratory process steps be displayed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Expirimental. Evaluates and summarizes the data in every column of a data.table. 
Can identify columns with hierarchical structure and columns with perfectly correlated 
values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
explore_dataset(alien.train)
</code></pre>

<hr>
<h2 id='exponential_weight'>Exponential Weight</h2><span id='topic+exponential_weight'></span>

<h3>Description</h3>

<p>Generate exponential weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponential_weight(k, base = exp(1), offset = 0, slope = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exponential_weight_+3A_k">k</code></td>
<td>
<p>1-base^(offset-slope*k)</p>
</td></tr>
<tr><td><code id="exponential_weight_+3A_base">base</code></td>
<td>
<p>1-base^(offset-slope*k)</p>
</td></tr>
<tr><td><code id="exponential_weight_+3A_offset">offset</code></td>
<td>
<p>1-base^(offset-slope*k)</p>
</td></tr>
<tr><td><code id="exponential_weight_+3A_slope">slope</code></td>
<td>
<p>1-base^(offset-slope*k)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a weight based on the formula 1-base^(offset-slope*k)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exponential_weight(1:3, slope=.1)
exponential_weight(1:3, slope=1)
exponential_weight(1:3, slope=10)

</code></pre>

<hr>
<h2 id='folds'>Cross Validation Folds</h2><span id='topic+folds'></span>

<h3>Description</h3>

<p>Map an object <code>x</code> into equal (or nearly equal) size folds.
If <code>x</code> is a positive integer, a vector of FoldIDs of length matching x is returned, otherwise
If <code>x</code> is a vector, a matching vector of FoldIDs is returned.
If <code>x</code> is a data.table, a list of partitions of x is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>folds(x, nfolds = 5L, stratified = FALSE, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="folds_+3A_x">x</code></td>
<td>
<p>A positive integer, a vector of values or a data.table object</p>
</td></tr>
<tr><td><code id="folds_+3A_nfolds">nfolds</code></td>
<td>
<p>How many folds?</p>
</td></tr>
<tr><td><code id="folds_+3A_stratified">stratified</code></td>
<td>
<p>If x is a vector then TRUE or FALSE indicating whether x's split the class's of x proportionally. If x
is a data.table then <code>stratified</code> should be FALSE or the name of a column in x on which to perform stratification. Note
that stratification is implemented for categorical, logical, AND numeric x</p>
</td></tr>
<tr><td><code id="folds_+3A_seed">seed</code></td>
<td>
<p>Random number seed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convenient method for mapping an object into equal size folds, potentially with stratification
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
folds(8, nfolds=2)
folds(alien.train$IsAlien, nfolds=2)
folds(alien.train$IsAlien, nfolds=2, stratified=TRUE, seed=2016)
folds(alien.train$IQScore, nfolds=2, stratified=TRUE, seed=2016)
folds(alien.train, nfolds=2, stratified="IsAlien", seed=2016)

</code></pre>

<hr>
<h2 id='geometric_weight'>Geometric Weight</h2><span id='topic+geometric_weight'></span>

<h3>Description</h3>

<p>Generate geometric weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometric_weight(k, n, r = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geometric_weight_+3A_k">k</code></td>
<td>
<p>r^k/sum(r^(1, 2, ... n))</p>
</td></tr>
<tr><td><code id="geometric_weight_+3A_n">n</code></td>
<td>
<p>r^k/sum(r^(1, 2, ... n))</p>
</td></tr>
<tr><td><code id="geometric_weight_+3A_r">r</code></td>
<td>
<p>r^k/sum(r^(1, 2, ... n))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a weight based on the formula r^k/sum(r^seq_len(n)). The sequence of weights for k=1, 2, ..., n sum to 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geometric_weight(1:3, n=3, r=1)
geometric_weight(1:3, n=3, r=.5)
geometric_weight(1:3, n=3, r=2)

</code></pre>

<hr>
<h2 id='gini_impurities'>Gini Impurities</h2><span id='topic+gini_impurities'></span>

<h3>Description</h3>

<p>Identify group weighted gini impurities using pairs of columns within a dataset. Can be used to located hierarchical data, or 1-1 correspondences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini_impurities(dt, wide = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gini_impurities_+3A_dt">dt</code></td>
<td>
<p>A data.table with at least two columns</p>
</td></tr>
<tr><td><code id="gini_impurities_+3A_wide">wide</code></td>
<td>
<p>Should the results be in wide format?</p>
</td></tr>
<tr><td><code id="gini_impurities_+3A_verbose">verbose</code></td>
<td>
<p>Should progress be printed to the screen?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For pairs of columns (Var1, Var2) in a dataset, calculates the weighted gini impurity of Var2 relative to the groups determined by Var1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
gini_impurities(alien.train)
gini_impurities(alien.train, wide=TRUE)
</code></pre>

<hr>
<h2 id='gini_impurity'>Gini Impurity</h2><span id='topic+gini_impurity'></span>

<h3>Description</h3>

<p>Calculates the Gini Impurity of a set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini_impurity(vals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gini_impurity_+3A_vals">vals</code></td>
<td>
<p>A vector of values. Values can be given as raw instances like c(&quot;red&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot;) or as a named vector
of class frequencies like c(red=2, blue=1, green=1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gini Impurity is a measure of how often a randomly chosen element from a set would be
incorrectly labeled if it was randomly labeled according to the distribution of labels in the set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gini_impurity(c("red", "red", "blue", "green"))
gini_impurity(c(red=2, blue=1, green=1))

</code></pre>

<hr>
<h2 id='mcc'>Matthews correlation coefficient</h2><span id='topic+mcc'></span>

<h3>Description</h3>

<p>Calculate Matthews correlation coefficient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcc(preds = NULL, actuals = NULL, TP = NULL, FP = NULL, TN = NULL,
  FN = NULL, confusionM = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcc_+3A_preds">preds</code></td>
<td>
<p>A vector of prediction values, or a data.frame or matrix of TRUE/FALSE or 1/0 whose columns correspond to the 
possible classes</p>
</td></tr>
<tr><td><code id="mcc_+3A_actuals">actuals</code></td>
<td>
<p>A vector of actuals values, or a data.frame or matrix of TRUE/FALSE or 1/0 whose columns correspond to the 
possible classes</p>
</td></tr>
<tr><td><code id="mcc_+3A_tp">TP</code></td>
<td>
<p>Count of true positives (correctly predicted 1/TRUE)</p>
</td></tr>
<tr><td><code id="mcc_+3A_fp">FP</code></td>
<td>
<p>Count of false positives (predicted 1/TRUE, but actually 0/FALSE)</p>
</td></tr>
<tr><td><code id="mcc_+3A_tn">TN</code></td>
<td>
<p>Count of true negatives (correctly predicted 0/FALSE)</p>
</td></tr>
<tr><td><code id="mcc_+3A_fn">FN</code></td>
<td>
<p>Count of false negatives (predicted 0/FALSE, but actually 1/TRUE)</p>
</td></tr>
<tr><td><code id="mcc_+3A_confusionm">confusionM</code></td>
<td>
<p>Confusion matrix whose (i,j) element represents the number of samples with predicted class i and true class j</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Matthews correlation coefficient. Provide either
</p>

<ul>
<li><p><code>preds</code> and <code>actuals</code> or
</p>
</li>
<li><p><code>TP</code>, <code>FP</code>, <code>TN</code>, and <code>FN</code>
</p>
</li>
<li><p><code>confusionM</code>
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Matthews_correlation_coefficient">https://en.wikipedia.org/wiki/Matthews_correlation_coefficient</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>preds &lt;- c(1,1,1,0,1,1,0,0)
actuals &lt;- c(1,1,1,1,0,0,0,0)
mcc(preds, actuals)
mcc(actuals, actuals)
mcc(TP=3, FP=2, TN=2, FN=1)

# Multiclass
preds &lt;- data.frame(
  setosa = rnorm(n = 150), 
  versicolor = rnorm(n = 150), 
  virginica = rnorm(n = 150)
)
preds &lt;- preds == apply(preds, 1, max)
actuals &lt;- data.frame(
  setosa = rnorm(n = 150), 
  versicolor = rnorm(n = 150), 
  virginica = rnorm(n = 150)
)
actuals &lt;- actuals == apply(actuals, 1, max)
mcc(preds = preds, actuals = actuals)

# Confusion matrix
mcc(confusionM = matrix(c(0,3,3,3,0,3,3,3,0), nrow = 3))
mcc(confusionM = matrix(c(1,0,0,0,1,0,0,0,1), nrow = 3))

</code></pre>

<hr>
<h2 id='mse'>Mean Square Error</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>Calculate Mean-Square Error (Deviation)
</p>
<p>For the ith sample, Squared Error is calculated as SE = (prediction - actual)^2. MSE is then mean(squared errors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(preds = NULL, actuals = NULL, weights = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mse_+3A_preds">preds</code></td>
<td>
<p>A vector of prediction values in [0, 1]</p>
</td></tr>
<tr><td><code id="mse_+3A_actuals">actuals</code></td>
<td>
<p>A vector of actuals values in 0, 1, or FALSE, TRUE</p>
</td></tr>
<tr><td><code id="mse_+3A_weights">weights</code></td>
<td>
<p>Optional vectors of weights</p>
</td></tr>
<tr><td><code id="mse_+3A_na.rm">na.rm</code></td>
<td>
<p>Should (prediction, actual) pairs with at least one NA value be ignored?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Mean-Square Error (Deviation)
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Mean_squared_error">https://en.wikipedia.org/wiki/Mean_squared_error</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>preds &lt;- c(1.0, 2.0, 9.5)
actuals &lt;- c(0.9, 2.1, 10.0)
mse(preds, actuals)

</code></pre>

<hr>
<h2 id='msle'>Mean Square Logarithmic Error</h2><span id='topic+msle'></span>

<h3>Description</h3>

<p>Calculate Mean-Square-Logarithmic Error (Deviation)
</p>
<p>For the ith sample, Squared Logarithmic Error is calculated as SLE = (log(prediction + 1) - log(actual + 1))^2. 
MSE is then mean(squared logarithmic errors). Note the '+1' in the calculation of SLE which avoids taking the logarithm of 0
for data which may include 0s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msle(preds = NULL, actuals = NULL, weights = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msle_+3A_preds">preds</code></td>
<td>
<p>A vector of prediction values in [0, 1]</p>
</td></tr>
<tr><td><code id="msle_+3A_actuals">actuals</code></td>
<td>
<p>A vector of actuals values in 0, 1, or FALSE, TRUE</p>
</td></tr>
<tr><td><code id="msle_+3A_weights">weights</code></td>
<td>
<p>Optional vectors of weights</p>
</td></tr>
<tr><td><code id="msle_+3A_na.rm">na.rm</code></td>
<td>
<p>Should (prediction, actual) pairs with at least one NA value be ignored?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Mean-Square-Logarithmic Error (Deviation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>preds &lt;- c(1.0, 2.0, 9.5)
actuals &lt;- c(0.9, 2.1, 10.0)
msle(preds, actuals)

</code></pre>

<hr>
<h2 id='one_hot'>One Hot Encode</h2><span id='topic+one_hot'></span>

<h3>Description</h3>

<p>One-Hot-Encode unordered factor columns of a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_hot(dt, cols = "auto", sparsifyNAs = FALSE, naCols = FALSE,
  dropCols = TRUE, dropUnusedLevels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="one_hot_+3A_dt">dt</code></td>
<td>
<p>A data.table</p>
</td></tr>
<tr><td><code id="one_hot_+3A_cols">cols</code></td>
<td>
<p>Which column(s) should be one-hot-encoded? DEFAULT = &quot;auto&quot; encodes all unordered factor columns</p>
</td></tr>
<tr><td><code id="one_hot_+3A_sparsifynas">sparsifyNAs</code></td>
<td>
<p>Should NAs be converted to 0s?</p>
</td></tr>
<tr><td><code id="one_hot_+3A_nacols">naCols</code></td>
<td>
<p>Should columns be generated to indicate the present of NAs? Will only apply to factor columns with at least one NA</p>
</td></tr>
<tr><td><code id="one_hot_+3A_dropcols">dropCols</code></td>
<td>
<p>Should the resulting data.table exclude the original columns which are one-hot-encoded?</p>
</td></tr>
<tr><td><code id="one_hot_+3A_dropunusedlevels">dropUnusedLevels</code></td>
<td>
<p>Should columns of all 0s be generated for unused factor levels?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One-hot-encoding converts an unordered categorical vector (i.e. a factor) to multiple binarized vectors where each binary vector of
1s and 0s indicates the presence of a class (i.e. level) of the of the original vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)

dt &lt;- data.table(
  ID = 1:4,
  color = factor(c("red", NA, "blue", "blue"), levels=c("blue", "green", "red"))
)

one_hot(dt)
one_hot(dt, sparsifyNAs=TRUE)
one_hot(dt, naCols=TRUE)
one_hot(dt, dropCols=FALSE)
one_hot(dt, dropUnusedLevels=TRUE)

</code></pre>

<hr>
<h2 id='relative_position'>Relative Position</h2><span id='topic+relative_position'></span>

<h3>Description</h3>

<p>Scale a vector of values to the range [0, 1] based on rank/position
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relative_position(vals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relative_position_+3A_vals">vals</code></td>
<td>
<p>vector of values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values are ranked and then scaled to the range [0, 1]. Ties result in the same relative position 
(e.g. <code>relative_position(c(1, 2, 2, 3))</code> returns the vector <code>c(0.0 0.5 0.5 1.0))</code>. NAs remain as NAs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>relative_position(1:10)
relative_position(c(1, 2, 2, 3))
relative_position(c(1, NA, 3, 4))

</code></pre>

<hr>
<h2 id='replace_na'>Replace NA Values</h2><span id='topic+replace_na'></span>

<h3>Description</h3>

<p>Convenience method for returning a copy of a vector such that NA values are substituted with a replacement value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_na(x, repl = "auto")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_na_+3A_x">x</code></td>
<td>
<p>vector of values</p>
</td></tr>
<tr><td><code id="replace_na_+3A_repl">repl</code></td>
<td>
<p>what to substitute in place of NAs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a copy of <code>x</code> such that NAs get replaced with a replacement value.  Default replacement value is 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>replace_na(c(1, NA, 1, 0))

</code></pre>

<hr>
<h2 id='rmse'>Root Mean Square Error</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p>Calculate Root-Mean-Square Error (Deviation)
</p>
<p>For the ith sample, Squared Error is calculated as SE = (prediction - actual)^2. 
RMSE is then sqrt(mean(squared errors)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(preds = NULL, actuals = NULL, weights = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmse_+3A_preds">preds</code></td>
<td>
<p>A vector of prediction values in [0, 1]</p>
</td></tr>
<tr><td><code id="rmse_+3A_actuals">actuals</code></td>
<td>
<p>A vector of actuals values in 0, 1, or FALSE, TRUE</p>
</td></tr>
<tr><td><code id="rmse_+3A_weights">weights</code></td>
<td>
<p>Optional vectors of weights</p>
</td></tr>
<tr><td><code id="rmse_+3A_na.rm">na.rm</code></td>
<td>
<p>Should (prediction, actual) pairs with at least one NA value be ignored?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Root-Mean-Square Error (Deviation)
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">https://en.wikipedia.org/wiki/Root-mean-square_deviation</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>preds &lt;- c(1.0, 2.0, 9.5)
actuals &lt;- c(0.9, 2.1, 10.0)
rmse(preds, actuals)

</code></pre>

<hr>
<h2 id='rmsle'>Root Mean Square Logarithmic Error</h2><span id='topic+rmsle'></span>

<h3>Description</h3>

<p>Calculate Root-Mean-Square-Logarithmic Error (Deviation)
</p>
<p>For the ith sample, Squared Logarithmic Error is calculated as SLE = (log(prediction + 1) - log(actual + 1))^2. 
RMSLE is then sqrt(mean(squared logarithmic errors)). Note the '+1' in the calculation of SLE which avoids taking the logarithm of 0
for data which may include 0s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmsle(preds = NULL, actuals = NULL, weights = 1, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmsle_+3A_preds">preds</code></td>
<td>
<p>A vector of prediction values in [0, 1]</p>
</td></tr>
<tr><td><code id="rmsle_+3A_actuals">actuals</code></td>
<td>
<p>A vector of actuals values in 0, 1, or FALSE, TRUE</p>
</td></tr>
<tr><td><code id="rmsle_+3A_weights">weights</code></td>
<td>
<p>Optional vectors of weights</p>
</td></tr>
<tr><td><code id="rmsle_+3A_na.rm">na.rm</code></td>
<td>
<p>Should (prediction, actual) pairs with at least one NA value be ignored?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate Root-Mean-Square-Logarithmic Error (Deviation)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>preds &lt;- c(1.0, 2.0, 9.5)
actuals &lt;- c(0.9, 2.1, 10.0)
rmsle(preds, actuals)

</code></pre>

<hr>
<h2 id='roc_scores'>ROC scores</h2><span id='topic+roc_scores'></span>

<h3>Description</h3>

<p>This function provides a way to identify the worst predictions when measuring Area Under the ROC curve. Simply
put, the worst predictions are the ones with very low or high relative prediction scores (usually probabilities) 
which relate to the positive and negative samples respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roc_scores(preds, actuals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roc_scores_+3A_preds">preds</code></td>
<td>
<p>vector of predictions (need not be in range [0-1] - only order matters)</p>
</td></tr>
<tr><td><code id="roc_scores_+3A_actuals">actuals</code></td>
<td>
<p>vector of actuals - either logical or vector of 1s and 0s</p>
</td></tr>
</table>


<h3>Details</h3>

<p>How it works
</p>

<ul>
<li><p>First the relative position (between 0 and 1) of each prediction is determined
</p>
</li>
<li><p>Next the mean of actuals is determined
</p>
</li>
<li><p>For samples whose position is on the correct side of the overall mean, 0 is given
</p>
</li>
<li><p>For samples whose position is on the wrong side of the overall mean, its distance from the mean is given
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>roc_scores(c(1,2,3,4), actuals=c(1,1,0,0))
roc_scores(c(0.1, 0.2, 0.3, 0.4), actuals=c(TRUE, FALSE, TRUE, FALSE))

</code></pre>

<hr>
<h2 id='set_factor'>Set Factor</h2><span id='topic+set_factor'></span>

<h3>Description</h3>

<p>Convience method for dealing with factors. Map a list of vectors to a list of factor vectors (1-1 mapping) such that
the factor vectors all have the same levels - the unique values of the union of all the vectors in the list. Optionally
group all low frequency values into a &quot;_other_&quot; level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_factor(vectorList, aggregationThreshold = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_factor_+3A_vectorlist">vectorList</code></td>
<td>
<p>A list of values to convert to factors</p>
</td></tr>
<tr><td><code id="set_factor_+3A_aggregationthreshold">aggregationThreshold</code></td>
<td>
<p>Values which appear this many times or less will be grouped into the level &quot;_other_&quot;</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", "b", "c", "c")
y &lt;- c("a", "d", "d")
set_factor(list(x, y))
set_factor(list(x, y), aggregationThreshold=1)
</code></pre>

<hr>
<h2 id='skewness'>Skewness</h2><span id='topic+skewness'></span>

<h3>Description</h3>

<p>Calculates the skewness of each field in a data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skewness_+3A_dt">dt</code></td>
<td>
<p>A data.table</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Counts the frequency of each value in each column, then displays the results in descending order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
skewness(alien.train)
</code></pre>

<hr>
<h2 id='sparsify'>Sparsify</h2><span id='topic+sparsify'></span>

<h3>Description</h3>

<p>Convert a data.table object into a sparse matrix (with the same number of rows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparsify(dt, sparsifyNAs = FALSE, naCols = "none")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparsify_+3A_dt">dt</code></td>
<td>
<p>A data.table object</p>
</td></tr>
<tr><td><code id="sparsify_+3A_sparsifynas">sparsifyNAs</code></td>
<td>
<p>Should NAs be converted to 0s and sparsified?</p>
</td></tr>
<tr><td><code id="sparsify_+3A_nacols">naCols</code></td>
<td>

<ul>
<li><p><b>&quot;none&quot;</b> Don't generate columns to identify NA values
</p>
</li>
<li><p><b>&quot;identify&quot;</b> For each column of dt with an NA value, generate a column in the 
sparse matrix with 1s indicating NAs. Columns will be named like &quot;color_NA&quot;
</p>
</li>
<li><p><b>&quot;efficient&quot;</b> For each column of dt with an NA value, generate a column in the 
sparse matrix with 1s indicating either NAs or Non NAs - whichever is more memory efficient. 
Columns will be named like &quot;color_NA&quot; or &quot;color_NotNA&quot;
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts a data.table object to a sparse matrix (class &quot;dgCMatrix&quot;). Requires the <span class="pkg">Matrix</span> package. 
All sparsified data is assumed to take on the value 0/FALSE 
</p>
<p>### Data Type | Description &amp; NA handling
</p>
<p>numeric | If <code>sparsifyNAs</code> = FALSE, only 0s will be sparsified
If <code>sparsifyNAs</code> = TRUE, 0s and NAs will be sparsified
</p>
<p>factor (unordered) | Each level will generate a sparsified binary column
Column names are feature_level, e.g. &quot;color_red&quot;, &quot;color_blue&quot;
</p>
<p>factor (ordered) | Levels are converted to numeric, 1 - NLevels
If <code>sparsifyNAs</code> = FALSE, NAs will remain as NAs
If <code>sparsifyNAs</code> = TRUE, NAs will be sparsified
</p>
<p>logical | TRUE and FALSE values will be converted to 1s and 0s
If <code>sparsifyNAs</code> = FALSE, only FALSEs will be sparsified
If <code>sparsifyNAs</code> = TRUE, FALSEs and NAs will be sparsified
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
library(Matrix)

dt &lt;- data.table(
  intCol=c(1L, NA_integer_, 3L, 0L),
  realCol=c(NA, 2, NA, NA),
  logCol=c(TRUE, FALSE, TRUE, FALSE),
  ofCol=factor(c("a", "b", NA, "b"), levels=c("a", "b", "c"), ordered=TRUE),
  ufCol=factor(c("a", NA, "c", "b"), ordered=FALSE)
)

sparsify(dt)
sparsify(dt, sparsifyNAs=TRUE)
sparsify(dt[, list(realCol)], naCols="identify")
sparsify(dt[, list(realCol)], naCols="efficient")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
