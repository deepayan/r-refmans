<!DOCTYPE html><html lang="en"><head><title>Help for package LS2W</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LS2W}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LS2W-package'>
<p>Estimates the locally stationary wavelet spectrum for locally stationary 2-D wavelets processes</p></a></li>
<li><a href='#A'><p>Examples of textured images</p></a></li>
<li><a href='#A2name'><p>Return a D2Amat list object style name.</p></a></li>
<li><a href='#AvBasis.wst2D'><p>Perform basis averaging for (packet-ordered) 2D non-decimated wavelet transform.</p></a></li>
<li><a href='#cddews'><p>Compute the local wavelet spectrum estimate</p></a></li>
<li><a href='#cdtoimwd'>
<p>Convert a cddews type object to an imwd type object</p></a></li>
<li><a href='#convertimwd'>
<p>Convert a non-decimated imwd object to a wst2D object.</p></a></li>
<li><a href='#D1Amat'><p>Inner product matrix of ac wavelets(1-D)</p></a></li>
<li><a href='#D2ACW'><p> Compute 2-D discrete autocorrelation wavelets.</p></a></li>
<li><a href='#D2ACWmat'><p>Compute 2-D discrete autocorrelation wavelets but return in array form.</p></a></li>
<li><a href='#D2Amat'><p>Creates the A matrix required for analysing LS2W processes.</p></a></li>
<li><a href='#D2autoplot'><p>Plots a two-dimensional autocorrelation wavelet.</p></a></li>
<li><a href='#DWEnv'>
<p>Environment containing precomputed objects.</p></a></li>
<li><a href='#example.ls2w'><p>Example of how the LS2W package can be used in texture analysis</p></a></li>
<li><a href='#getdata'><p>Extracts detail coefficients from imwd object</p></a></li>
<li><a href='#Haar2MA.diag'><p>Generate 2-D Haar MA process (diagonal/vertical/horizontal direction).</p></a></li>
<li><a href='#Haar2MA.horiz'><p>Generate 2-D Haar MA process (horizontal direction).</p></a></li>
<li><a href='#Haar2MA.vert'><p>Generate 2-D Haar MA process (vertical direction).</p></a></li>
<li><a href='#HaarMontage'><p>Generate a 2-D Haar MA process.</p></a></li>
<li><a href='#imwd'><p>Two-dimensional wavelet transform (decomposition).</p></a></li>
<li><a href='#imwr.imwd'><p>Inverse two-dimensional discrete wavelet transform.</p></a></li>
<li><a href='#LS2Wsim'>
<p>Generic method for simulation of LS2W processes</p></a></li>
<li><a href='#LS2Wsim.cddews'>
<p>Simulate an LS2W process with underlying Daubechies wavelet.</p></a></li>
<li><a href='#packetj'>
<p>Converts an imwd object to a wst2D object at a given level.</p></a></li>
<li><a href='#Phi1Dname'><p>Return a PhiJ list object style name.</p></a></li>
<li><a href='#PhiJ'><p>Compute discrete autocorrelation scaling function.</p></a></li>
<li><a href='#print.cddews'><p>Print out information about a cddews object in readable form.</p></a></li>
<li><a href='#Psi1Dname'><p>Return a PsiJ list object style name.</p></a></li>
<li><a href='#Psi2Dname'><p>Return a D2ACW list object style name.</p></a></li>
<li><a href='#PsiJ'><p>Compute discrete autocorrelation wavelets.</p></a></li>
<li><a href='#sample.stats'><p>A function to calculate sample statistics for textured images using LS2W</p></a></li>
<li><a href='#specplot'><p>Plot the LWP associated with a cddews object</p></a></li>
<li><a href='#summary.cddews'><p>Use summary on a cddews object</p></a></li>
<li><a href='#threshold.imwd'><p>Threshold two-dimensional wavelet decomposition object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.3.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-01</td>
</tr>
<tr>
<td>Title:</td>
<td>Locally Stationary Two-Dimensional Wavelet Process Estimation
Scheme</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Idris Eckley &lt;i.eckley@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0), wavethresh (&ge; 4.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS,methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates two-dimensional local wavelet spectra.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Idris Eckley [aut, cre],
  Guy Nason [aut],
  Sarah Taylor [ctb],
  Matthew Nunes [ctb]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-01 15:42:15 UTC; grosedj</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-01 21:54:37 UTC</td>
</tr>
</table>
<hr>
<h2 id='LS2W-package'>
Estimates the locally stationary wavelet spectrum for locally stationary 2-D wavelets processes
</h2><span id='topic+LS2W-package'></span><span id='topic+LS2W'></span>

<h3>Description</h3>

<p>The LS2W package which provides an implementation of the modelling approach proposed by 
Eckley, Nason, and Treloar (2010) for locally stationary spatial
covariance structure of (regular) lattice processes, such as images. 
</p>
<p>The approach, which is an extension of NvSK's time series modelling paradigm, is in part 
motivated by a frequently erent scales. Moreover, several researchers have highlighted that 
the human and mammalian visual systems process images in a multiscale manner, preserving both 
local and global information (see for example, Daugman (1990) or Field (1999)). 
The LS2W package which we introduce implements the estimation scheme described by Eckley
et al. (2010) for such processes. Note that LS2W should be used in conjunction with the
WaveThresh package developed by Nason (1998).
</p>


<h3>Details</h3>

<p>Note that this package should be used in conjunction with the WaveThresh package. It is
advised that WaveThresh should be loaded first, followed by LS2W. This is because LS2W
currently overwrites a couple of WaveThresh functions to, e.g.,  provide consistent naming structures
for some of the objects created during estimation of  2-D LSW processes.
</p>
<p>The central function within the LS2W package is cddews. This executes the LS2W estimation
algorithm as summarised in Algorithm 1, drawing on other functions to calculate the
autocorrelation (ac) wavelets and their inner product matrix. The output of this function is
stored in an object of class &quot;cddews&quot;. Print and summary methods are provided for this class
of objects.
</p>
<p>Below we provide brief descriptions of the main functions contained within the package. Please
see individual help files for additional information.
</p>
<p><code>PhiJ:</code> Computes discrete autocorrelation father wavelets. These are automatically stored
within the R session, using a naming convention governed by Phi1Dname. 
</p>
<p><code>PsiiJ:</code> Computes discrete autocorrelation mother wavelets. These are automatically
stored within the R session, using a naming convention governed by Psi1Dname.
</p>
<p><code>D2ACW:</code> Computes two-dimensional autocorrelation wavelets. These are automatically
stored within the R session, using a naming convention governed by Psi2Dname.
</p>
<p><code>D2autoplot:</code> Can be used to generate images of two-dimensional discrete autocorrelation
wavelets.
</p>
<p><code>D2Amat:</code> Computes the inner product matrix of two-dimensional discrete autocorrelation
wavelets. These objects are automatically stored within a session following a naming
convention governed by A2name. 
</p>
<p><code>cddews:</code> Computes the local wavelet spectrum estimate as described in Eckley et al.
(2010), returning an object of class cddews. 
</p>
<p><code>specplot:</code> Plots the local wavelet periodogram associated with a cddews object. 
</p>
<p><code>Haar2MA.diag:</code> Generates a two-dimentional Haar MA object (diagonal direction) of
specied size and order. The functions Haar2MA.vert, Haar2MA.horiz can be used to
construct equivalent realisations for process in the vertical and horizontal direction respectively
whilst HaarMontage generates a realisation of a concatenated two-dimensional
Haar MA process (for an example, see Fig 3 of Eckley and Nason 2009). 
</p>


<h3>Author(s)</h3>

<p>Idris Eckley and Guy Nason, with contributions from Sarah Taylor and Matt Nunes
Maintainer: Who to complain to &lt;i.eckley@lancs.ac.uk&gt; 
</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    #
    # See comprehensive examples in the help pages for the major functions
    # outlined above.
    #
</code></pre>

<hr>
<h2 id='A'>Examples of textured images</h2><span id='topic+A'></span><span id='topic+B'></span><span id='topic+C'></span>

<h3>Description</h3>

<p>A, B, and C are examples of different textured images 
(grayscale). Each matrix object contains an image. Each entry of the 
matrix contains an image intentsity value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(textures)</code></pre>


<h3>Format</h3>

<p>Matricies of varying sizes which each contain a textured image</p>


<h3>References</h3>

 
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>

<hr>
<h2 id='A2name'>Return a D2Amat list object style name.</h2><span id='topic+A2name'></span>

<h3>Description</h3>

<p>This function returns a character string according to a particular format for naming D2Amat objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A2name(J, filter.number, family, switch = "direction")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A2name_+3A_j">J</code></td>
<td>
<p>Discrete autocorrelation wavelets will be computed for scales -1 up to scale J. This number should be a negative integer.</p>
</td></tr>
<tr><td><code id="A2name_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number of the wavelet used to build the PsiJ/PhiJ object.</p>
</td></tr>
<tr><td><code id="A2name_+3A_family">family</code></td>
<td>
<p>The wavelet family used to build the PhiJIE object.</p>
</td></tr>
<tr><td><code id="A2name_+3A_switch">switch</code></td>
<td>
<p>Allows the user to define how they wish their inner product matrix to be formed. There are two available options:
<code>switch = "direction"</code> - structures the matrix by scale within each 
decomposition direction. Thus, the ordering goes as follows (-1, V), (-2, V), ...
<code>switch = "scale"</code> - structures the matrix by direction within each 
scale.  Thus the ordering is as follows (-1,V), (-1, H), (-1, D), (-2, V),(-2, H), ... </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some of the matrices computed by D2Amat take a long time to compute. Hence it is a good idea to store and re-use them. This function generates a name according to a particular naming scheme that permits a search algorithm to easily find the matrices.
Each matrix has three defining characteristics: its order, filter.number, family and the method of construction of the matrix (switch=&quot;direction&quot; or &quot;level&quot;). Each of these characteristics are concatenated together to form a name.
</p>


<h3>Value</h3>

<p>A character string containing the name of a matrix according to a particular naming scheme.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+D2Amat">D2Amat</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What's the name of the order 4 Haar matrix when structured by scale within decompositon direction?
#
A2name(J=-4, filter.number=1, family="DaubExPhase", switch="direction")
#[1] "D2Amat.d.4.1.DaubExPhase"
#
# What's the name of the order 15 Daubechies least-asymmetric wavelet
# with 7 vanishing moments, when ordered by direction within each scale?
#
A2name(J=-15, filter.number=7, family="DaubLeAsymm")
#[1] "D2Amat.l.15.7.DaubLeAsymm"
</code></pre>

<hr>
<h2 id='AvBasis.wst2D'>Perform basis averaging for (packet-ordered) 2D non-decimated wavelet transform.</h2><span id='topic+AvBasis.wst2D'></span>

<h3>Description</h3>

<p>Perform basis averaging for (packet-ordered) 2D non-decimated wavelet transform.  Note:  This is a copy of the function from wavethresh, but this version uses the LS2W C code implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wst2D'
AvBasis(wst2D, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AvBasis.wst2D_+3A_wst2d">wst2D</code></td>
<td>
<p>An object of class <code>wst2D</code> that contains coefficients of a packet ordered 2D non-decimated wavelet transform (e.g. produced by the <code>wst2D</code> function.</p>
</td></tr>
<tr><td><code id="AvBasis.wst2D_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The packet-ordered 2D non-decimated wavelet transform computed by <code>wst2D</code> computes the coefficients of an input matrix with respect to a library of all shifts of wavelet basis functions at all scales. Here &quot;all shifts&quot; means all integral shifts with respect to the finest scale coefficients with shifts in both the horizontal and vertical directions, and &quot;all scales&quot; means all dyadic scales from 0 (the coarsest) to J-1 (the finest) where <code>2^J = n</code> where <code>n</code> is the dimension of the input matrix. As such the packet-ordered 2D non-decimated wavelet transform contains a library of all possible shifted wavelet bases.
</p>
<p><b>Basis averaging</b>. Rather than select <em>a</em> basis it is often useful to preserve information from all of the bases. For examples, in curve estimation, after thresholding, the coefficients are coefficients of an estimate of the truth with respect to all of the shifted basis functions. Rather than select one of them we can average over all estimates. This sometimes gives a better curve estimate and can, for examples, get rid of Gibbs effects. See Coifman and Donoho (1995) for more information on how to do curve estimation using the packet ordered non-decimated wavelet transform, thresholding and basis averaging. See Lang et al. (1995) for further details of surface/image estimation using the 2D non-decimated DWT. 
</p>


<h3>Value</h3>

<p>A square matrix of dimension $2^nlevels$ containing the average-basis &ldquo;reconstruction&rdquo; of the <code>wst2D</code> object. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code>wst2D</code>, <code>wst2D.object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate some test data
#
#test.data &lt;- matrix(rnorm(16), 4,4)
#
# Now take the 2D packet ordered DWT 
#
#tdwst2D &lt;- wst2D(test.data)
#
# Now "invert" it using basis averaging
#
#tdwstAB &lt;- AvBasis(tdwst2D)
#
# Let's compare it to the original
#
#sum( (tdwstAB - test.data)^2)
#
# [1] 1.61215e-17
#
# Very small. They're essentially same.
#
</code></pre>

<hr>
<h2 id='cddews'>Compute the local wavelet spectrum estimate</h2><span id='topic+cddews'></span>

<h3>Description</h3>

<p>This function computes the local wavelet spectrum (LWS) estimate of an image (or non-decimated wavelet transform of a time series). The estimate is computed by taking the non-decimated wavelet transform of the image, squaring the detail coefficients, smoothing using wavelet shrinkage and then correcting the redundancy caused by use of the non-decimated wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cddews(data, filter.number = 1, family = "DaubExPhase", switch = "direction", 
correct = TRUE, verbose = FALSE, smooth = TRUE, 
sm.filter.number = 4, sm.family = "DaubExPhase", levels = 3:6, type = "hard", 
policy = "LSuniversal", by.level = FALSE, value = 0, dev = var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cddews_+3A_data">data</code></td>
<td>
<p>The image you want to analyse.</p>
</td></tr>
<tr><td><code id="cddews_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the index of the wavelet used in the analysis of the time series (i.e.\ the wavelet basis functions used to model the time series). For Daubechies compactly supported wavelets the filter number is the number of vanishing moments.</p>
</td></tr>
<tr><td><code id="cddews_+3A_family">family</code></td>
<td>
<p>This selects the wavelet family to use in the analysis of the time series (i.e.\ which wavelet family to use to model the time 
series). Only use the Daubechies compactly supported wavelets <code>DaubExPhase</code> and <code>DaubLeAsymm</code>.</p>
</td></tr>
<tr><td><code id="cddews_+3A_switch">switch</code></td>
<td>
<p> This allows one to order the corrected spectrum by scale or decomposition direction. Two options are available 
<code>switch = "direction"</code>: structures the matrix by scale within each decomposition direction.  Thus, the ordering goes as 
follows $(-1, V), (-2, V), (-3, V)\ ...$. 
<code>switch = "level"</code> structures the matrix by direction within  each scale. Thus the ordering is as follows $(-1,V), (-1, H), (-1, D), 
(-2, V), (-2, H), (-2, D), ...$.  For further details, see Eckley Nason and Treloar (2010). </p>
</td></tr>
<tr><td><code id="cddews_+3A_correct">correct</code></td>
<td>
<p>Eckley, Nason and Treloar (2009) have  demonstrated that, as a consequence of the inherent redundancy of the non-decimated wavelet 
transform, the raw wavelet spectrum  is biased. However, an asymptotically unbiased estimator may be obtained by applying the inverse of the inner 
product matrix of discrete autocorrelation wavelets. This argument permits the user to decide whether or not to correct for this inherent bias.</p>
</td></tr>  
<tr><td><code id="cddews_+3A_verbose">verbose</code></td>
<td>
<p>Allows certain informative messages to be printed on screen.</p>
</td></tr>
<tr><td><code id="cddews_+3A_smooth">smooth</code></td>
<td>
<p>This binary argument allows the user to specify whether or not the resulting local wavelet periodogram 
should  be smoothed to obtain. It is advised that this option be set to <code>TRUE</code> in order that consistent estimates be obtained.</p>
</td></tr>
<tr><td><code id="cddews_+3A_sm.filter.number">sm.filter.number</code></td>
<td>
<p>Selects the index number of the wavelet that smooths each scale of the wavelet periodogram.</p>
</td></tr>
<tr><td><code id="cddews_+3A_sm.family">sm.family</code></td>
<td>
<p>Selects the wavelet family that smooths each scale of the wavelet periodogram.</p>
</td></tr>
<tr><td><code id="cddews_+3A_levels">levels</code></td>
<td>
<p>This specifies the levels which are smoothed when performing the wavelet shrinkage.</p>
</td></tr>
<tr><td><code id="cddews_+3A_type">type</code></td>
<td>
<p>The type of shrinkage: either <code>"hard"</code> or <code>"soft"</code>.</p>
</td></tr>
<tr><td><code id="cddews_+3A_policy">policy</code></td>
<td>
<p>This dictates the threshold selection method used for smoothing. For LWS estimation <code>LSuniversal</code> is recommended for thi 
Chi-squared nature of the periodogram coefficients.</p>
</td></tr>
<tr><td><code id="cddews_+3A_by.level">by.level</code></td>
<td>
<p>If <code>TRUE</code> then the wavelet shrinkage is performed by computing and applying a separate threshold to each level in the 
transform of each scale. Note that each scale in the LWS is smoothed separately and independently. Each smooth consists of taking the (second-stage) 
non-decimated wavelet transform and applying a threshold to each level of a wavelet transformed scale.
</p>
<p>If <code>FALSE</code> then the same threshold is applied to the discrete wavelet transform of a scale. Different thresholds may be computed for different 
scales but the threshold will be the same for each level arising from the non-decimated transform of a scale.
</p>
</td></tr>
<tr><td><code id="cddews_+3A_value">value</code></td>
<td>
<p>This argument supplies the threshold value used when a manual policy is adopted.</p>
</td></tr>
<tr><td><code id="cddews_+3A_dev">dev</code></td>
<td>
<p>The method for estimating the variance of the empirical wavelet coefficients for smoothing purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes an estimate of the directionally dependent wavelet spectrum of an image according to the work of  Eckley, Nason and Treloar 
(2010). The  function works as follows: 
</p>
<p>1. The non-decimated wavelet transform of the series is computed.
</p>
<p>2. The squared modulus of the non-decimated wavelet transform is computed (this is the raw 
wavelet periodogram, which is returned).
</p>
<p>3. The squared modulus is smoothed using wavelet shrinkage.
</p>
<p>4. The smoothed coefficients are corrected using the inverse of the inner product matrix of 
the autocorrelation wavelets. 
To display the LWS use the <code>specplot</code> function on the <code>S</code> component (see the examples below).</p>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table role = "presentation">
<tr><td><code>S:</code></td>
<td>
<p>The directionally dependent wavelet spectral estimate of the input data. This is a <em>large</em> array, the first
dimension refers  to a specific scale-direction pair (see Eckley et al. (2009) for further details). The next dimension refers to the rows of the 
spectral image, whilst the third element refers to the columns of the image. </p>
</td></tr>
<tr><td><code>datadim</code></td>
<td>
<p>The dimension of the original image.</p>
</td></tr>
<tr><td><code>filter.number:</code></td>
<td>
<p>This gives the index of the wavelet used in the analysis of the image (i.e. the wavelet basis functions used in the 
modelling). For Daubechies compactly supported wavelets the filter number is the number of vanishing moments.</p>
</td></tr>
<tr><td><code>family:</code></td>
<td>
<p>This contains the wavelet family used in the analysis of the image (i.e. the wavelet family used in the modelling).</p>
</td></tr>
<tr><td><code>structure:</code></td>
<td>
<p>Explains the structure of the inner product matrix and S. It can only take two values, <code>direction</code> and 
<code>scale</code>.</p>
</td></tr>
<tr><td><code>nlevels:</code></td>
<td>
<p>The number of levels in the decomposition.</p>
</td></tr>
<tr><td><code>correct:</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, depending on whether the user corrected for the bias.</p>
</td></tr>
<tr><td><code>smooth:</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, depending on whether the LWP has been smoothed.</p>
</td></tr>
<tr><td><code>date:</code></td>
<td>
<p>The date when the analysis was perfromed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D2Amat">D2Amat</a></code>, <code><a href="#topic+specplot">specplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Apply the cddews estimate function to a HaarMontage realisation
#
monty &lt;- HaarMontage(direction="diagonal")
monty.cddews &lt;- cddews(monty, filter.number=1, family="DaubExPhase")
monty.cddews
</code></pre>

<hr>
<h2 id='cdtoimwd'>
Convert a cddews type object to an imwd type object
</h2><span id='topic+cdtoimwd'></span>

<h3>Description</h3>

<p>Converting from a cddews object to an imwd object required for simulating an LS2W process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdtoimwd(cddews)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdtoimwd_+3A_cddews">cddews</code></td>
<td>

<p>A cddews object, which may be the output of <code><a href="#topic+cddews">cddews</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simulation of an LS2W process for Daubechies wavelets requires that our spectral structure is ordered as an <code>imwd</code> object rather than a <code>cddews</code> object. This function works by extracting the spectral information from the given <code>cddews</code> object, determining where in the (null) <code>imwd</code> object it should be and adding the power to this appropriate location. This function is used within the function <code><a href="#topic+LS2Wsim.cddews">LS2Wsim.cddews</a></code> and as such does not need to be made use of directly by the user. 
</p>


<h3>Value</h3>

<p>An object of class imwd.
</p>


<h3>Author(s)</h3>

<p>Sarah L Taylor
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="#topic+cddews">cddews</a></code>, <code><a href="#topic+LS2Wsim.cddews">LS2Wsim.cddews</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#Obtain a cddews type object from an image X
#
X&lt;-matrix(rnorm(32*32),nrow=32,ncol=32)
#
CDDEWS &lt;- cddews(X,correct=FALSE,smooth=FALSE)
#
#Verify the class of Matxcddews
#
class(CDDEWS)
#
#Convert to imwd
#
CDDEWSimwd&lt;-cdtoimwd(CDDEWS)
#
#Verify new class
#
class(CDDEWSimwd) 
#
</code></pre>

<hr>
<h2 id='convertimwd'>
Convert a non-decimated imwd object to a wst2D object.
</h2><span id='topic+convertimwd'></span>

<h3>Description</h3>

<p>Converting from a spatially ordered <code>imwd</code> object to a packet-ordered <code>wst2D</code> object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertimwd(imwd, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertimwd_+3A_imwd">imwd</code></td>
<td>

<p>A imwd type object obtained by a stationary wavelet transform, i.e. <code>imwd$type</code> must be <code>"station"</code>.
</p>
</td></tr>
<tr><td><code id="convertimwd_+3A_...">...</code></td>
<td>

<p>Any additional arguments.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Inverting a 2-D non-decimated wavelet transform requires that the output is structured as a packet ordered transform. This function allows us to convert from the non-decimated (time ordered) <code>imwd</code> object to the packet ordered <code>wst2D</code> object. The function extracts information at a given scale/direction from the <code>imwd</code> object, converts it into the appropriate format and inserts it in the appropriate location of a (null) <code>wst2D</code> object. This function is used when simulating an LS2W process within the function <code>LS2Wsim.cddews</code> and does not need to be used separately. 
</p>


<h3>Value</h3>

<p>An object of class <code>wst2D</code>
</p>


<h3>Author(s)</h3>

<p>Matt Nunes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code><a href="wavethresh.html#topic+wst2D">wst2D</a></code>, <code><a href="#topic+packetj">packetj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#Obtain an imwd class object
#
testimage &lt;- HaarMontage(256, "diagonal")
#
IMWDobject&lt;- imwd(testimage, type="station")

# Verify the class of this object
#
class(IMWDobject) 
#
#Convert to packet ordered
#
IMWDconverted&lt;-convertimwd(IMWDobject)
#
#Verify new class
#
class(IMWDconverted)
#
</code></pre>

<hr>
<h2 id='D1Amat'>Inner product matrix of ac wavelets(1-D)</h2><span id='topic+D1Amat'></span>

<h3>Description</h3>

<p>This function calculates the inner product matrix of discrete autocorrelation wavelets (1D).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D1Amat(J, filter.number = 10, family = "DaubLeAsymm", tol = 1e-100, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D1Amat_+3A_j">J</code></td>
<td>
<p>The level to which the decomposition must extend. This number should
be a positive integer. </p>
</td></tr>
<tr><td><code id="D1Amat_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the correction m
atrix A.</p>
</td></tr>
<tr><td><code id="D1Amat_+3A_family">family</code></td>
<td>
<p>The wavelet family used to compute A.</p>
</td></tr>
<tr><td><code id="D1Amat_+3A_tol">tol</code></td>
<td>
<p>In the brute force computation for Daubechies compactly supported wavelets many inner product computations are performed. This 
tolerance discounts any results which are smaller than tol which effectively defines how long the inner product/autocorrelation products 
are. </p>
</td></tr>
<tr><td><code id="D1Amat_+3A_verbose">verbose</code></td>
<td>
<p>Logical variable, if set to <code>TRUE</code> informative statements are printed to screen during execution of the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of order (-J)x(-J) containing the inner product matrix of the discrete non-decimated autocorrelation matrices. 
</p>


<h3>Note</h3>

 
<p>An equivalent function <code>ipndacw</code> already exists in WaveThresh. This function is added to help create a consistent naming convention 
across both the one- and two-dimensional inner product matrix of ac wavelets.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (2000) Wavelet processes and adaptive estimation of the evolutionary wavelet 
spectrum. J. R. Statist. Soc. Series B, 62, 271-292. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D2Amat">D2Amat</a></code></p>

<hr>
<h2 id='D2ACW'> Compute 2-D discrete autocorrelation wavelets.</h2><span id='topic+D2ACW'></span>

<h3>Description</h3>

<p>This function computes two-dimensional discrete autocorrelation wavelets.  The inner products of these wavelets are required for correction of the (biased) raw wavelet periodograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2ACW(J, filter.number = 1, family = "DaubExPhase", switch = "direction", 
tol = 1e-100, OPLENGTH = 2000, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D2ACW_+3A_j">J</code></td>
<td>
<p> Discrete autocorrelation wavelets will be computed for scales 1 to J within each decomposition direction (horizontal, vertical and diagonal). This number should be a positive integer.</p>
</td></tr>
<tr><td><code id="D2ACW_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="D2ACW_+3A_family">family</code></td>
<td>
<p> The wavelet family used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="D2ACW_+3A_switch">switch</code></td>
<td>
<p>Allows the user to define how they wish their inner product matrix to be formed. There are two available options:\
<code>switch = "direction"</code> - structures the matrix by scale within each decomposition direction. Thus, the ordering goes as follows $(1, V), 
(2, V), ...$.\
<code>switch = "level"</code> - structures the matrix by direction within each scale. Thus the ordering is as follows $(-1,V), (-1, H), (-1, D), (-2, 
V), (-2, H),...$.
</p>
</td></tr>
<tr><td><code id="D2ACW_+3A_tol">tol</code></td>
<td>
<p> In the brute force computation for Daubechies compactly supported wavelets many inner product computations are performed. This tolerance 
discounts any results which are smaller than  <code>tol</code> which effectively defines how long the inner product/autocorrelation products are.
</p>
</td></tr>
<tr><td><code id="D2ACW_+3A_oplength">OPLENGTH</code></td>
<td>
<p> This integer variable defines some workspace of length OPLENGTH. The code uses this workspace. If the workspace is not long enough then the routine will stop and tell you what OPLENGTH should be set to.</p>
</td></tr>
<tr><td><code id="D2ACW_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> various informative statements are printed to screen.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the 2-D discrete autocorrelation wavelets. It does not have any direct use for space-scale analysis.  The construction method 
is a brute force approach &ndash; a more elegant solution would be based on the recursive schemes as described in Eckley and Nason (2005). The routine 
returns only the values of the discrete autocorrelation wavelets, not their spatial positions. Each discrete autocorrelation wavelet is compactly supported. This support is determined from the discrete wavelets upon which these autocorrelations are based.
</p>


<h3>Value</h3>

<p>A list containing $3J$ components, numbered from 1 to $3J$.
If switch=&quot;direction&quot;, the first $J$ components contain the vertical autocorrelation wavelet coefficients, the second set of $J$ components contains the horizontal autocorrelation wavelet coefficients (scales $1,..., J$) and the last $J$ components constitute the diagonal autocorrelation wavelet coefficients.
However, if switch=&quot;level&quot;, then the first 3 components contain the finest scale autocorrelation wavelet coefficients in the vertical, horizontal and diagonal decomposition directions respectively. The second set of 3 contains the vertical, horizontal and diagonal coefficients at scale 2 etc. \
\
Note that these 2-D autocorrelation wavelets are stored as matrices. The central element of the matrix refers to lag 0.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D2autoplot">D2autoplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let us create the discrete autocorrelation wavelets for the Haar wavelet.
# We shall create up to scale 2.
#
D2ACW(J=-2, filter.number=1, family="DaubExPhase", switch="direction")
#[[1]]:
#      [,1] [,2]  [,3]
#[1,] -0.25 -0.5 -0.25
#[2,]  0.50  1.0  0.50
#[3,] -0.25 -0.5 -0.25
#
#[[2]]:
#        [,1]   [,2]    [,3]  [,4]    [,5]   [,6]    [,7]
#[1,] -0.0625 -0.125 -0.1875 -0.25 -0.1875 -0.125 -0.0625
#[2,] -0.1250 -0.250 -0.3750 -0.50 -0.3750 -0.250 -0.1250
#[3,]  0.0625  0.125  0.1875  0.25  0.1875  0.125  0.0625
#[4,]  0.2500  0.500  0.7500  1.00  0.7500  0.500  0.2500
#[5,]  0.0625  0.125  0.1875  0.25  0.1875  0.125  0.0625
#[6,] -0.1250 -0.250 -0.3750 -0.50 -0.3750 -0.250 -0.1250
#[7,] -0.0625 -0.125 -0.1875 -0.25 -0.1875 -0.125 -0.0625
#
#... and the remaining terms follow suit. 
</code></pre>

<hr>
<h2 id='D2ACWmat'>Compute 2-D discrete autocorrelation wavelets but return in array form.</h2><span id='topic+D2ACWmat'></span><span id='topic+D2ACWmat.d'></span><span id='topic+D2ACWmat.l'></span>

<h3>Description</h3>

<p>This function computes two-dimensional discrete autocorrelation wavelets, but results in a matrix form, rather than a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2ACWmat(J, filter.number = 10, family = "DaubLeAsymm", switch = "direction", 
OPLENGTH = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D2ACWmat_+3A_j">J</code></td>
<td>
<p>Discrete autocorrelation wavelets will be computed for scales -1 up to scale J within each decomposition direction (horiznotal, vertical and diagonal). This number should be a negative integer.</p>
</td></tr>
<tr><td><code id="D2ACWmat_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="D2ACWmat_+3A_family">family</code></td>
<td>
<p>The family of wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="D2ACWmat_+3A_switch">switch</code></td>
<td>
<p>Allows the user to define how they wish their inner product matrix to be formed. There are two available options:
</p>
<p><code>switch = "direction"</code> - structures the matrix by scale within each decomposition direction. Thus, the ordering goes as follows (-1, V), (-2, V), ...
</p>
<p><code>switch</code> = &quot;direction&quot;</p>
</td></tr></table>
<p> - structures the matrix by direction within each scale. Thus the ordering is as follows (-1,V), (-1, H), (-1, D), (-2, V), (-2, H), ...
</p>
<table role = "presentation">
<tr><td><code id="D2ACWmat_+3A_oplength">OPLENGTH</code></td>
<td>
<p>This integer variable defines some workspace of length OPLENGTH. The code uses this workspace. If the workspace is not long enough then the routine will stop and probably tell you what OPLENGTH should be set to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the 2-D discrete autocorrelation wavelets. It does not have any direct use for space-scale analysis (e.g. cddews). However, it 
is useful to be able to numerically compute the discrete autocorrelation wavelets for arbitrary wavelets and scales as there are still unanswered 
theoretical questions concerning the wavelets. The method is a brute force &ndash; a more elegant solution would probably be based on interpolatory 
schemes (see Eckley and Nason (2005) for example).
</p>
<p>This routine returns only the values of the discrete autocorrelation wavelets and not their spatial positions. Each discrete autocorrelation wavelet 
is compactly supported with the support determined from the compactly supported wavelet that generates it. See the paper by Eckley, Nason, and 
Treloar which defines the spatial scale (but basically the finer scale discrete autocorrelation wavelets are interpolated versions of the coarser 
ones. When one goes from scale j to j-1 (negative j remember) an extra point is inserted between all of the old points and the discrete 
autocorrelation wavelet value is computed there. Thus as J tends to negative infinity the numerical approximation tends towards the continuous 
autocorrelation wavelet.
</p>
<p>This function stores any 2-D discrete autocorrelation wavelet sets that it computes. The Psiname2D function defines the naming convention for 
objects returned by this function. The storage mechanism is not as advanced as that for ipndacw and its subsidiary routines rmname and firstdot but helps a 
little bit.
</p>
<p>Sometimes it is useful to have the discrete autocorrelation wavelets stored in matrix form. The D2ACWmat does this. 
</p>


<h3>Value</h3>

<p>A matrix containing -3J sub-matrices, each of dimension 2L_J-1 x 2L_J-1, where L_J denotes the support of the coarsest discret autocorrelation 
wavelet. Each sub-matrix, contains the values of the discrete autocorrelation wavelet for a different scale-direction pair.
</p>
<p>The middle position of each sub-matrix is the value of the discrete autocorrelation wavelet at zero &mdash; by definition, this is always 1. The discrete 
autocorrelation wavelet is symmetric about this point.
</p>
<p>If <code>switch="direction"</code>, the first -J sub-matrices contain the vertical autocorrelation wavelet coefficients, the second set of -J components 
contains 
the horizontal autocorrelation wavelet coefficients (scales -1, ...-J) and the last -J components constitute the diagonal autocorrelation wavelet 
coefficients.
</p>
<p>However, if <code>switch="level"</code>, then the first 3 rows contain the finest scale autocorrelation wavelet coefficients in the vertical, horizontal and 
diagonal decomposition directions respectively. The second set of 3 contains the vertical, horizontal and diagonal coefficients at scale -2 etc, etc. 
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley IA, Nason GP (2005). Efficient computation of the inner-product matrix of discrete
autocorrelation wavelets. Statistics and Computing, 15, 83-92.
</p>
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D2ACW">D2ACW</a></code>, <code><a href="#topic+D2Amat">D2Amat</a></code>, <code><a href="#topic+D2autoplot">D2autoplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let us create the discrete autocorrelation wavelets for the Haar wavelet.
# We shall create up to scale 4.
#
D2ACWmat(J=-2, filter.number=1, family="DaubExPhase")
#Computing The two-dimensional (discrete) autocorrelation coefficients: 
#
#The output will be structured as follows .... 
#
#
#
#Levels 1 to  2  contain the vertical autocorrelation wavelet coefficients. 
#
#Levels  3  to  4  contain the horizontal autocorrelation wavelet coefficients. 
#
#Levels  5  to  6  contain the horizontal autocorrelation wavelet coefficients. 
#
# 
# 
#Returning precomputed version
#Returning precomputed version 
#Returning precomputed version 
#Took  NA  seconds 
#         [,1]   [,2]    [,3]  [,4]    [,5]   [,6]    [,7] 
# [1,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
# [2,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
# [3,]  0.0000  0.000 -0.2500 -0.50 -0.2500  0.000  0.0000
# [4,]  0.0000  0.000  0.5000  1.00  0.5000  0.000  0.0000
# [5,]  0.0000  0.000 -0.2500 -0.50 -0.2500  0.000  0.0000
# [6,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
# [7,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
# [8,] -0.0625 -0.125 -0.1875 -0.25 -0.1875 -0.125 -0.0625
# [9,] -0.1250 -0.250 -0.3750 -0.50 -0.3750 -0.250 -0.1250
#[10,]  0.0625  0.125  0.1875  0.25  0.1875  0.125  0.0625
#[11,]  0.2500  0.500  0.7500  1.00  0.7500  0.500  0.2500
#[12,]  0.0625  0.125  0.1875  0.25  0.1875  0.125  0.0625
#[13,] -0.1250 -0.250 -0.3750 -0.50 -0.3750 -0.250 -0.1250
#[14,] -0.0625 -0.125 -0.1875 -0.25 -0.1875 -0.125 -0.0625
#[15,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
#[16,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
#[17,]  0.0000  0.000 -0.2500  0.50 -0.2500  0.000  0.0000
#[18,]  0.0000  0.000 -0.5000  1.00 -0.5000  0.000  0.0000
#[19,]  0.0000  0.000 -0.2500  0.50 -0.2500  0.000  0.0000
#[20,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
#[21,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
#[22,] -0.0625 -0.125  0.0625  0.25  0.0625 -0.125 -0.0625
#[23,] -0.1250 -0.250  0.1250  0.50  0.1250 -0.250 -0.1250
#[24,] -0.1875 -0.375  0.1875  0.75  0.1875 -0.375 -0.1875
#[25,] -0.2500 -0.500  0.2500  1.00  0.2500 -0.500 -0.2500
#[26,] -0.1875 -0.375  0.1875  0.75  0.1875 -0.375 -0.1875
#[27,] -0.1250 -0.250  0.1250  0.50  0.1250 -0.250 -0.1250
#[28,] -0.0625 -0.125  0.0625  0.25  0.0625 -0.125 -0.0625
#[29,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
#[30,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
#[31,]  0.0000  0.000  0.2500 -0.50  0.2500  0.000  0.0000
#[32,]  0.0000  0.000 -0.5000  1.00 -0.5000  0.000  0.0000
#[33,]  0.0000  0.000  0.2500 -0.50  0.2500  0.000  0.0000
#[34,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
#[35,]  0.0000  0.000  0.0000  0.00  0.0000  0.000  0.0000
#[36,]  0.0625  0.125 -0.0625 -0.25 -0.0625  0.125  0.0625
#[37,]  0.1250  0.250 -0.1250 -0.50 -0.1250  0.250  0.1250
#[38,] -0.0625 -0.125  0.0625  0.25  0.0625 -0.125 -0.0625
#[39,] -0.2500 -0.500  0.2500  1.00  0.2500 -0.500 -0.2500
#[40,] -0.0625 -0.125  0.0625  0.25  0.0625 -0.125 -0.0625
#[41,]  0.1250  0.250 -0.1250 -0.50 -0.1250  0.250  0.1250
#[42,]  0.0625  0.125 -0.0625 -0.25 -0.0625  0.125  0.0625
</code></pre>

<hr>
<h2 id='D2Amat'>Creates the A matrix required for analysing LS2W processes.</h2><span id='topic+D2Amat'></span>

<h3>Description</h3>

<p>This function creates the matrix used to correct the raw periodogram of a LS2W process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2Amat(J, filter.number = 10, family = "DaubLeAsymm", OPLENGTH = 10000, 
switch = "direction", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D2Amat_+3A_j">J</code></td>
<td>
<p>The level to which the decomposition must extend. This number should be a positive integer. </p>
</td></tr>
<tr><td><code id="D2Amat_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the correction matrix A.</p>
</td></tr>
<tr><td><code id="D2Amat_+3A_family">family</code></td>
<td>
<p>The wavelet family used to compute A.</p>
</td></tr>
<tr><td><code id="D2Amat_+3A_oplength">OPLENGTH</code></td>
<td>
<p>This integer variable defines some workspace of length OPLENGTH which is used by the code. If the workspace is not long enough, then the routine will stop and tell you what OPLENGTH should be set to.</p>
</td></tr>
<tr><td><code id="D2Amat_+3A_switch">switch</code></td>
<td>
<p>Dictates the structure of the matrix [by direction or by scale].</p>
</td></tr>
<tr><td><code id="D2Amat_+3A_verbose">verbose</code></td>
<td>
<p>Allows certain informative messages to be printed on screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of order (3J)*(3J) containing the elements A_(j,l) defined in Eckley, Nason and Treloar 
(2010). Each element is the sum over all lags of the product of the matrix coefficients of a 2-D DACW 
matrix at level $j_1$ in direction $ l_1$ with that of another (not necessarily different) matrix of DACW 
coefficients at level $j_2$ in direction $l_2$. The structure of this matrix is as follows: the rows and 
columns of the matrix are labeled $1,..., 3J$ in accordance with the notation of Eckley, Nason and 
Treloar (2010). When <code>switch="direction"</code> the matrix has the following structure:
</p>
<table role = "presentation">
<tr><td><code>Levels 1 to J</code></td>
<td>
<p>the different levels of the decomposition in the vertical direction. $1=$fine and $J =$coarse scale.</p>
</td></tr>
<tr><td><code>Levels J+1 to 2J</code></td>
<td>
<p>the different levels in the horizontal direction.</p>
</td></tr>
<tr><td><code>Levels 2J+1 to 3J</code></td>
<td>
<p>the different directions in the diagonal direction.</p>
</td></tr>
</table>
<p>When <code>switch="level"</code>, the row and column elements cycle as follows:\
level 1 vertical, level 1 horizontal, level 1 diagonal, level 2 vertical, etc.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let's compute the A matrix for the Haar wavelet in 2-D.
#
D2Amat(J=-2, filter.number=1, family="DaubExPhase", switch="direction")
#       1      2      3      4      5      6
#1 2.2500 1.3125 0.2500 0.3125 0.7500 0.9375
#2 1.3125 4.8125 0.3125 0.5625 0.1875 1.3125
#3 0.2500 0.3125 2.2500 1.3125 0.7500 0.9375
#4 0.3125 0.5625 1.3125 4.8125 0.1875 1.3125
#5 0.7500 0.1875 0.7500 0.1875 2.2500 0.5625
#6 0.9375 1.3125 0.9375 1.3125 0.5625 3.0625
#
# And now for the same matrix structured by level
#
D2Amat(J=-2, filter.number=1, family="DaubExPhase", switch="level")
#       1      2      3      4      5      6
#1 2.2500 0.2500 0.7500 1.3125 0.3125 0.9375
#2 0.2500 2.2500 0.7500 0.3125 1.3125 0.9375
#3 0.7500 0.7500 2.2500 0.1875 0.1875 0.5625
#4 1.3125 0.3125 0.1875 4.8125 0.5625 1.3125
#5 0.3125 1.3125 0.1875 0.5625 4.8125 1.3125
#6 0.9375 0.9375 0.5625 1.3125 1.3125 3.0625
</code></pre>

<hr>
<h2 id='D2autoplot'>Plots a two-dimensional autocorrelation wavelet.</h2><span id='topic+D2autoplot'></span>

<h3>Description</h3>

<p>Plots a 2-D autocorrelation wavelet for a given wavelet ata specific scale and decomposition direction. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D2autoplot(J, filter.number = 1, family = "DaubExPhase", direction = 3,
main = "2-D Autocorrelation Wavelet", OPLENGTH = 10000, scaling = "other", box="TRUE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="D2autoplot_+3A_j">J</code></td>
<td>
<p>A negative integer representing the order of the autocorrelation wavelet to be displayed.</p>
</td></tr>
<tr><td><code id="D2autoplot_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet to be used.</p>
</td></tr>
<tr><td><code id="D2autoplot_+3A_family">family</code></td>
<td>
<p>The wavelet family employed.</p>
</td></tr>
<tr><td><code id="D2autoplot_+3A_direction">direction</code></td>
<td>
<p>This variable dictates which of the three possible wavelets at a given level is being displayed. Recall from the work of Daubechies, that one way of constructing 2-D wavelets results in three wavelets. One corresponds to the vertical components of an image, another refers to the horizontal components whilst the final wavelet deals with the diagonal. Thus, keeping this construction in mind, it is easy to see that there are three autocorrelation wavelets when we are in two dimensions. This argument simply allows the user to specify which decomposition direction is to be displayed. Direction 1 corresponds to the Vertical direction, Direction 2 to the Horizontal direction whilst specifying direction=3 means that we wish the Diagonal ACW to be displayed.</p>
</td></tr>
<tr><td><code id="D2autoplot_+3A_main">main</code></td>
<td>
<p>Allows the user to specify a common title for each of the various spectral plots generated</p>
</td></tr>
<tr><td><code id="D2autoplot_+3A_oplength">OPLENGTH</code></td>
<td>
<p>This integer variable defines some workspace of length OPLENGTH which is used by the code. If the workspace is not long enough, then the routine will stop and tell you what OPLENGTH should be set to.</p>
</td></tr>
<tr><td><code id="D2autoplot_+3A_scaling">scaling</code></td>
<td>
<p>Allows the user to scale the x and y-axes (of minimal use!). There are currently two options. The first is Haar, which scales the x and y axes so that their entries are those of the actual Haar 2-D ACW. The second is other - which basically allows S-plus to do its ow</p>
</td></tr>
<tr><td><code id="D2autoplot_+3A_box">box</code></td>
<td>
<p>Allows the user to specify whether the resulting plotted is boxed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Side Effects</h3>

<p>Produces an image corresponding to the 2-D discrete autocorrelation wavelet of a given wavelet at a specific scale and decomposition direction.</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# To produce the Haar 2-D discrete autocorrelation wavelet at level -6 
# in the diagonal horizontal direction type
#
 D2ACW(J=-6, filter.number=1, family="DaubExPhase")
#
#Now let's look at the actual autocorrelation wavelet at that level
#

 D2autoplot(J=-6, filter.number=1, family="DaubExPhase", scaling="Haar")
</code></pre>

<hr>
<h2 id='DWEnv'>
Environment containing precomputed objects.
</h2><span id='topic+DWEnv'></span>

<h3>Description</h3>

<p>Package environment for commonly used objects in the LS2W methodology.
</p>


<h3>Details</h3>

<p>The <code>DWEnv</code> environment is used to store precomputed objects for the LS2W methodology.  Certain computations can be fairly long or intensive, and thus it is useful to store precomputed objects for reuse. 
These objects are namely autocorrelation wavelets (output from <code>PsiJ</code> and <code>PhiJ</code>), and bias correction matrices produced by <code>D2Amat</code>. 
</p>

<hr>
<h2 id='example.ls2w'>Example of how the LS2W package can be used in texture analysis</h2><span id='topic+example.ls2w'></span>

<h3>Description</h3>

<p>This function provides an example of how LS2W can be used to 
discriminate between three different textures. The approach provided 
simply consists of (i) sampling a number of subimages from the specified 
data sets; (ii) estimating the local wavelet spectrum  properties for 
each sub-image; (iii) summarising this information in a feature vector; 
(iv) using all feature vectors to identify whether it is possible to 
discriminate between the different image types. Linear Discriminant 
Analysis is the approach which we adopt in this example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.ls2w(n=25, size=64)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="example.ls2w_+3A_n">n</code></td>
<td>
<p>The number of sub-images to be sampled from each texture type.</p>
</td></tr>
<tr><td><code id="example.ls2w_+3A_size">size</code></td>
<td>
<p>The number of rows-columns required for each sub-image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lda</code>.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>

<hr>
<h2 id='getdata'>Extracts detail coefficients from imwd object  </h2><span id='topic+getdata'></span>

<h3>Description</h3>

<p>This function is called by cddews to extract the detail coefficients from an object of class imwd.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getdata(imwd, switch, co.type = "sqr", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getdata_+3A_imwd">imwd</code></td>
<td>
<p>An object of class imwd.</p>
</td></tr>
<tr><td><code id="getdata_+3A_switch">switch</code></td>
<td>
<p>Dictates whether the extracted information is structured by <code>"direction"</code> or 
<code>"scale"</code>.</p>
</td></tr>
<tr><td><code id="getdata_+3A_co.type">co.type</code></td>
<td>
<p>Dictates the coefficient type which is used. For cddews this must be <code>"sqr"</code>. </p>
</td></tr>
<tr><td><code id="getdata_+3A_verbose">verbose</code></td>
<td>
<p>Allows certain informative statements to be printed to the screen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array which can be used by cddews.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cddews">cddews</a></code></p>

<hr>
<h2 id='Haar2MA.diag'>Generate 2-D Haar MA process (diagonal/vertical/horizontal direction).</h2><span id='topic+Haar2MA.diag'></span>

<h3>Description</h3>

<p>These functions generate an arbitrary number of observations from a Haar MA process of any order with a particular variance. We will focus here on 
<code>Haar2MA.diag</code> &mdash; the routine which generates processes having spectral structure solely in the diagonal decomposition direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Haar2MA.diag(n, sd = 1, order = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Haar2MA.diag_+3A_n">n</code></td>
<td>
<p>The dimension of the realisation that you want to create. Note that <code>n</code> does NOT have to be a power of two, though it is square 
(nxn).</p>
</td></tr>
<tr><td><code id="Haar2MA.diag_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the innovations.</p>
</td></tr>
<tr><td><code id="Haar2MA.diag_+3A_order">order</code></td>
<td>
<p>The order of the MA process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A two-dimensional Haar MA process is a special kind of moving-average (MA) field. A <em>diagonal</em> Haar MA process of order $k$ is a MA field of order $2^k-1$, the coefficients of the process being given by the filter coefficients of the two-dimensional, discrete Haar wavelet at various scales within the diagonal direction. For example: the diagonal Haar MA field of order 1 is an MA process of order 1. 
It is possible to define such processes for other wavelets as well.
</p>


<h3>Value</h3>

<p>A matrix containing a realisation of the specified dimension, order and standard deviation.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HaarMontage">HaarMontage</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate a realisation of a diagonal component 2-D MA field
# of order 4.
#
image1 &lt;- Haar2MA.diag(n=128, sd=3, order=4)
#
#
#
</code></pre>

<hr>
<h2 id='Haar2MA.horiz'>Generate 2-D Haar MA process (horizontal direction).</h2><span id='topic+Haar2MA.horiz'></span>

<h3>Description</h3>

<p>These functions generate an arbitrary number of observations from a Haar MA process of any order with a particular variance. We will focus here on 
<code>Haar2MA.horiz</code> &mdash; the routine which generates processes having spectral structure solely in the horizonal decomposition direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Haar2MA.horiz(n, sd = 1, order = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Haar2MA.horiz_+3A_n">n</code></td>
<td>
<p>The dimension of the realisation that you want to create. Note that <code>n</code> does NOT have to be a power of two, though it is square 
(nxn).</p>
</td></tr>
<tr><td><code id="Haar2MA.horiz_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the innovations.</p>
</td></tr>
<tr><td><code id="Haar2MA.horiz_+3A_order">order</code></td>
<td>
<p>The order of the MA process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A two-dimensional Haar MA process is a special kind of moving-average (MA) field. A <em>horizontal</em> Haar MA process of order $k$ is a MA field of 
order 
$2^k-1$, the coefficients of the process being given by the filter coefficients of the two-dimensional, discrete Haar wavelet at various scales within 
the horizontal direction. For example the horizontal Haar MA field of order 1 is an MA process of order 1. 
It is possible to define such processes for other wavelets as well.
</p>


<h3>Value</h3>

<p>A matrix containing a realisation of the specified dimension, order and standard deviation.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Haar2MA.diag">Haar2MA.diag</a></code>,<code><a href="#topic+HaarMontage">HaarMontage</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate a realisation of a diagonal component 2-D MA field
# of order 4.
#
image1 &lt;- Haar2MA.horiz(n=128, sd=3, order=4)
#
#
#
</code></pre>

<hr>
<h2 id='Haar2MA.vert'>Generate 2-D Haar MA process (vertical direction).</h2><span id='topic+Haar2MA.vert'></span>

<h3>Description</h3>

<p>These functions generate an arbitrary number of observations from a Haar MA process of any order with a particular variance. We will focus here on 
<code>Haar2MA.vert</code> &mdash; the routine which generates processes having spectral structure solely in the vertical decomposition direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Haar2MA.vert(n, sd = 1, order = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Haar2MA.vert_+3A_n">n</code></td>
<td>
<p>The dimension of the realisation that you want to create. Note that <code>n</code> does NOT have to be a power of two, though it is square 
(nxn).</p>
</td></tr>
<tr><td><code id="Haar2MA.vert_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the innovations.</p>
</td></tr>
<tr><td><code id="Haar2MA.vert_+3A_order">order</code></td>
<td>
<p>The order of the MA process.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A two-dimensional Haar MA process is a special kind of moving-average (MA) field. A <em>vertical</em> Haar MA process of order $k$ is a MA field of 
order 
$2^k-1$, the coefficients of the process being given by the filter coefficients of the two-dimensional, discrete Haar wavelet at various scales within 
the vertical direction. For example: the vertical Haar MA field of order 1 is an MA process of order 1. 
It is possible to define such processes for other wavelets as well.
</p>


<h3>Value</h3>

<p>A matrix containing a realisation of the specified dimension, order and standard deviation.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Haar2MA.diag">Haar2MA.diag</a></code>, <code><a href="#topic+HaarMontage">HaarMontage</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate a realisation of a diagonal component 2-D MA field
# of order 4.
#
image1 &lt;- Haar2MA.vert(n=128, sd=3, order=4)
#
#
#
</code></pre>

<hr>
<h2 id='HaarMontage'>Generate a 2-D Haar MA process.</h2><span id='topic+HaarMontage'></span>

<h3>Description</h3>

<p>This function generates a particular set of four 2-D Haar MA processes. These are subsequently collated to form a montage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HaarMontage(n=128, direction = "diagonal", sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HaarMontage_+3A_n">n</code></td>
<td>

<p>The dimension of the realisations that you want to create. Note that n does NOT have to be a power of two, though the output will always be square (n x n).
</p>
</td></tr>
<tr><td><code id="HaarMontage_+3A_direction">direction</code></td>
<td>
<p>Three directions can be specified: <code>horizontal</code>, <code>vertical</code> and <code>diagonal</code>. The direction chosen dictates the
decomposition direction in which the wavelet spectral structure exists.
</p>
</td></tr>
<tr><td><code id="HaarMontage_+3A_sd">sd</code></td>
<td>

<p>The standard deviation of the innovations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a realisation of a particular kind of non-stationary lattice model, an example of which is displayed in figure 3 of Eckley, 
Nason and Treloar (2009). 
The returned lattice is the result of combining four HaarMA processes. One process is of order 1, whilst another is of order 2. The two remaining processes are of order 3 and 4 respectively. Each individual lattice has dimension <code>n/2*n/2</code>. The standard deviation of the innovations is <code>sd</code>.
</p>


<h3>Value</h3>

<p>A vector containing <code>n*n</code> observations from four collated 2-D Haar MA processes.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley and Sarah Taylor</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Haar2MA.diag">Haar2MA.diag</a></code>,<code><a href="#topic+Haar2MA.horiz">Haar2MA.horiz</a></code>,<code><a href="#topic+Haar2MA.vert">Haar2MA.vert</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a realisation of the non-stationary combined Haar MA
# process with structure in the vertical direction. 
MyHaar2 &lt;- HaarMontage(128,direction="diagonal",sd=1) 
# Plot it.
#
 image(MyHaar2)
</code></pre>

<hr>
<h2 id='imwd'>Two-dimensional wavelet transform (decomposition). </h2><span id='topic+imwd'></span>

<h3>Description</h3>

<p>This function replaces WaveThresh's imwd which currently contains a minor bug (for the case 
<code>type="station"</code>_.The function can perform two types of two-dimensional discrete wavelet transform 
(DWT). The standard transform (<code>type="wavelet"</code>) computes the 2D DWT according to Mallat's pyramidal 
algorithm (Mallat, 1989). 
The spatially ordered non-decimated 2D DWT (NDWT) (<code>type="station"</code>) contains all possible spatially 
shifted versions of the DWT. The order of computation of the DWT is O(n), and it is O(n log n) for the 
NDWT if n is the number of pixels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imwd(image, filter.number = 10, family = "DaubLeAsymm", type = "wavelet", 
bc = "periodic", RetFather = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imwd_+3A_image">image</code></td>
<td>
<p>A square matrix containing the image data you wish to decompose. The sidelength of this 
matrix must be a power of 2. </p>
</td></tr>
<tr><td><code id="imwd_+3A_filter.number">filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. 
By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 
vanishing moments.</p>
</td></tr>
<tr><td><code id="imwd_+3A_family">family</code></td>
<td>
<p>Specifies the family of wavelets that you want to use. The options are &quot;DaubExPhase&quot; and 
&quot;DaubLeAsymm&quot;.</p>
</td></tr>
<tr><td><code id="imwd_+3A_type">type</code></td>
<td>
<p>Specifies the type of wavelet transform. This can be &quot;wavelet&quot; (default) in which case the 
standard 2D DWT is performed (as in previous releases of WaveThresh). If type is &quot;station&quot; then the 2D 
spatially-ordered non-decimated DWT is performed. At present, only periodic boundary conditions can be 
used with the 2D spatially ordered non-decimated wavelet transform.</p>
</td></tr>
<tr><td><code id="imwd_+3A_bc">bc</code></td>
<td>
<p>specifies the boundary handling. If bc==&quot;periodic&quot; the default, then the function you 
decompose is assumed to be periodic on it's interval of definition, if bc==&quot;symmetric&quot; then the function 
beyond its boundaries is assumed to be a symmetric reflection of the function in the boundary. The 
symmetric option was the implicit default in releases prior to 2.2. Note that only periodic boundary 
conditions are valid for the 2D spatially-ordered non-decimated wavelet transform.</p>
</td></tr>
<tr><td><code id="imwd_+3A_retfather">RetFather</code></td>
<td>
<p>If TRUE then this argument causes the scaling function coefficients at each 
resolution level to be returned as well as the wavelet coefficients. If FALSE then no scaling function 
coefficients are returned. The opportunity of returning father wavelet coefficients has been added since 
previous versions of WaveThresh.</p>
</td></tr>
<tr><td><code id="imwd_+3A_verbose">verbose</code></td>
<td>
<p>Controls the printing of &quot;informative&quot; messages whilst the computations progress. Such 
messages are generally annoying so it is turned off by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class imwd object containing the two-dimensional wavelet transform (possibly 
spatially-ordered non-decimated). 
</p>


<h3>Author(s)</h3>

<p>Idris Eckley  and Guy Nason</p>


<h3>References</h3>

<p>Mallat, S.G. (1989b). 
A theory for multiresolution signal decomposition: the wavelet representation. IEEE Trans. Pattn Anal. 
Mach. Intell., 11, 674-693. </p>


<h3>See Also</h3>

<p><code><a href="#topic+cddews">cddews</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#First let's create an image
#
tmp &lt;- HaarMontage(direction="diagonal")
#
# Now let's do the 2D discrete wavelet transform on the image.
#
lwd &lt;- imwd(tmp)
#
# Let's look at the coefficients
#
plot(lwd)
</code></pre>

<hr>
<h2 id='imwr.imwd'>Inverse two-dimensional discrete wavelet transform.</h2><span id='topic+imwr.imwd'></span>

<h3>Description</h3>

<p>This functions performs the reconstruction stage of Mallat's pyramid algorithm (i.e. the inverse discrete wavelet transform) for images. NOTE:  This function replaces the wavethresh version to use LS2W C code due to memory reasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
imwr(imwd, bc=imwd$bc, verbose=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imwr.imwd_+3A_imwd">imwd</code></td>
<td>
<p>An object of class '<code><a href="#topic+imwd">imwd</a></code>'. This type of object is returned by '<code><a href="#topic+imwd">imwd</a></code>'.</p>
</td></tr>
<tr><td><code id="imwr.imwd_+3A_bc">bc</code></td>
<td>
<p>This argument specifies the boundary handling, it is best left to be the boundary handling specified by that in the supplied imwd (as is the default).</p>
</td></tr>
<tr><td><code id="imwr.imwd_+3A_verbose">verbose</code></td>
<td>
<p>If this argument is true then informative messages are printed detailing the computations to be performed</p>
</td></tr>
<tr><td><code id="imwr.imwd_+3A_...">...</code></td>
<td>
<p>any other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the algorithm are to be found in Mallat (1989). Similarly to the decomposition function, <code><a href="#topic+imwd">imwd</a></code> the inverse algorithm works by applying many 1D reconstruction algorithms to the coefficients. The filters in these 1D reconstructions are incorporated in the supplied <code>imwd.object</code> and originally created by the <code>filter.select</code> function in WaveThresh3.
</p>
<p>This function is a method for the generic function <code>imwr</code> for class <code>imwd.object</code>. It can be invoked by calling <code>imwr</code> for an object of the appropriate class, or directly by calling imwr.imwd regardless of the class of the object. 
</p>


<h3>Value</h3>

<p>A matrix, of dimension determined by the original data set supplied to the initial decomposition (more precisely, determined by the <code><a href="base.html#topic+nlevels">nlevels</a></code> component of the <code>imwd.object</code>). This matrix is the highest resolution level of the reconstruction. If a <code><a href="#topic+imwd">imwd</a></code> two-dimensional wavelet transform is followed immediately by a <code>imwr</code> inverse two-dimensional wavelet transform then the returned matrix will be exactly the same as the original image. 
</p>


<h3>RELEASE</h3>

<p>Version 3.5.3 Copyright Guy Nason 1994 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code>, <code>imwd.object</code>, <code>imwr</code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Do a decomposition, then exact reconstruction
# Look at the error
#
test.image &lt;- matrix(rnorm(32*32), nrow=32)
#
# Test image is just some sort of  square matrix whose side length
# is a power of two.
#
max( abs(imwr(imwd(test.image)) - test.image))
# [1] 1.014611e-11
</code></pre>

<hr>
<h2 id='LS2Wsim'>
Generic method for simulation of LS2W processes
</h2><span id='topic+LS2Wsim'></span>

<h3>Description</h3>

<p>Simulates a realisation of an LS2W process of a given spectral structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS2Wsim(spectrum,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS2Wsim_+3A_spectrum">spectrum</code></td>
<td>

<p>True spectrum from which to simulate data.
</p>
</td></tr>
<tr><td><code id="LS2Wsim_+3A_...">...</code></td>
<td>

<p>Any other arguments passed into the simulation function methods, such as the distribution of the LS2W innovations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generic method for simulating LS2W processes as defined by Eckley et al. (2010). 
</p>


<h3>Value</h3>

<p>Returns a single image matrix
</p>


<h3>Author(s)</h3>

<p>Aimee Gott
</p>


<h3>References</h3>

<p>Eckley, I.A., Nason, G.P., and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture <em>Journal of the Royal Statistical Society Series C</em>, <b>59</b>, 595-616.
</p>

<hr>
<h2 id='LS2Wsim.cddews'>
Simulate an LS2W process with underlying Daubechies wavelet.
</h2><span id='topic+LS2Wsim.cddews'></span>

<h3>Description</h3>

<p>Simulates a realisation of an LS2W process of a given spectral structure for Daubechies wavelets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cddews'
LS2Wsim(spectrum,innov=rnorm,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS2Wsim.cddews_+3A_spectrum">spectrum</code></td>
<td>

<p>True spectrum of class <code>cddews</code> which may be the output of <code>cddews</code>. 
</p>
</td></tr>
<tr><td><code id="LS2Wsim.cddews_+3A_innov">innov</code></td>
<td>

<p>The distribution of the innovations of the LS2W process.  Defaults to the (unit) normal distribution.
</p>
</td></tr>
<tr><td><code id="LS2Wsim.cddews_+3A_...">...</code></td>
<td>

<p>Any other arguments passed into the <code>innov</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the provided spectral structure to simulate an LS2W process. The provided spectral structure should take positive values, any negative values will be set to zero by the function.
</p>
<p>The process of simulation for Daubechies wavelets follows by firstly extracting the coefficients from the provided spectrum and squaring. They are then multiplied by random increments (from <code>rnorm()</code>) and an appropriate multiple of 4 (depending on the scale) which allows for the effect of basis averaging. After converting to the appropriate form (a <code>wst2D</code> object) the basis average is taken to give a realisation of an LS2W process. 
</p>


<h3>Value</h3>

<p>A simulated image matrix that will exhibit the spectral characteristics defined by <code>spectrum</code>.
</p>


<h3>Author(s)</h3>

<p>Sarah L Taylor
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HaarMontage">HaarMontage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Generate an empty spectrum
#
Spectrum&lt;-cddews(matrix(0,64,64),smooth=FALSE)
#
#Add power at the first scale, in the vertical direction
#
Spectrum$S[1,,]&lt;-matrix(1,64,64)
#                                                          
# Simulate an LS2W process with this structure
#           
testimage&lt;- LS2Wsim(Spectrum)
#
  </code></pre>

<hr>
<h2 id='packetj'>
Converts an imwd object to a wst2D object at a given level. 
</h2><span id='topic+packetj'></span>

<h3>Description</h3>

<p>Reorders the informtion at a given level of an <code>imwd</code> object to be in the form required for a <code>wst2D</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>packetj(imwd, level, o)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="packetj_+3A_imwd">imwd</code></td>
<td>

<p>An <code>imwd</code> object from a non-decimated wavelet transform, i.e. <code>type</code> is <code>station</code>.
</p>
</td></tr>
<tr><td><code id="packetj_+3A_level">level</code></td>
<td>

<p>The level we wish to convert. 
</p>
</td></tr>
<tr><td><code id="packetj_+3A_o">o</code></td>
<td>

<p>Computes weaving permutation for conversion from imwd to wst2D.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function combines the information from an <code>imwd</code> object at a given level and reorders it to be in the approriate form for a <code>wst2D</code> object. This function is required by <code><a href="#topic+convertimwd">convertimwd</a></code>.   
</p>


<h3>Value</h3>

<p>Returns a matrix to be put into a <code>wst2D</code> object.
</p>


<h3>Note</h3>

<p>Not intended to be used</p>


<h3>Author(s)</h3>

<p>Matt Nunes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Obtain an imwd object
#
testimage &lt;- HaarMontage(256, "diagonal")
testimageIMWD&lt;- imwd(testimage, type="station")
#
#Specify our weaving permutation
#
arrvec &lt;- getarrvec(9, sort=FALSE)
#
#Convert level 6 coefficients into packet ordered object
#
o &lt;- arrvec[,2]
packmat &lt;- packetj(testimageIMWD, 6, o)
#
</code></pre>

<hr>
<h2 id='Phi1Dname'>Return a PhiJ list object style name.</h2><span id='topic+Phi1Dname'></span>

<h3>Description</h3>

<p>This function returns a character string according to a particular format for naming PhiJ objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Phi1Dname(J, filter.number, family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Phi1Dname_+3A_j">J</code></td>
<td>
<p>A negative integer representing the order of the PhiJ object.</p>
</td></tr>
<tr><td><code id="Phi1Dname_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number of the wavelet used to build the PhiJ object.</p>
</td></tr>
<tr><td><code id="Phi1Dname_+3A_family">family</code></td>
<td>
<p>The wavelet family used to build the PhiJ object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some of the objects computed by PhiJ take a long time to compute. Hence it is a good idea to store them and reuse them. This function generates a name according to a particular naming scheme that permits a search algorithm to easily find the matrices.
</p>
<p>Each object has three defining characteristics: its order, filter.number and family. Each of these three characteristics are concatenated together to form a name.
</p>
<p>This function performs exactly the same role as rmname except for objects produced by PhiJ. 
</p>


<h3>Value</h3>

<p>A character string containing the name of an object according to a particular naming scheme.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What's the name of the order 4 Haar PhiJ object?
#
 Phi1Dname(-4, filter.number=1, family="DaubExPhase")
#[1] "D1Phi.4.1.DaubExPhase"
#
# What's the name of the order 12 Daubechies least-asymmetric wavelet PhiJ
# with 7 vanishing moments?
#
 Phi1Dname(-12, filter.number=7, family="DaubLeAsymm")             
#[1] "D1Phi.12.7.DaubLeAsymm"
</code></pre>

<hr>
<h2 id='PhiJ'>Compute discrete autocorrelation scaling function.</h2><span id='topic+PhiJ'></span>

<h3>Description</h3>

<p>This function computes discrete autocorrelation scaling function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PhiJ(J, filter.number = 10, family = "DaubLeAsymm", tol = 1e-100, 
OPLENGTH = 2000, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PhiJ_+3A_j">J</code></td>
<td>
<p>Discrete autocorrelation wavelets will be computed for scales -1 up to scale J. This number should be a negative integer.</p>
</td></tr>
<tr><td><code id="PhiJ_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="PhiJ_+3A_family">family</code></td>
<td>
<p>The family of wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="PhiJ_+3A_tol">tol</code></td>
<td>
<p>In the brute force computation for Daubechies compactly supported wavelets many inner product computations are performed. This tolerance discounts any results which are smaller than tol which effectively defines how long the inner product/autocorrelation products are.</p>
</td></tr>
<tr><td><code id="PhiJ_+3A_oplength">OPLENGTH</code></td>
<td>
<p>    This integer variable defines some workspace of length OPLENGTH. The code uses this workspace. If the workspace is not long enough then the routine will stop and probably tell you what OPLENGTH should be set to.
</p>
</td></tr>
<tr><td><code id="PhiJ_+3A_verbose">verbose</code></td>
<td>
<p>A logical variable. If set to <code>TRUE</code> certain helpful statements are printed to screen during execution of this  fundcion. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the discrete autocorrelation scaling function. It does not have any direct use for location-scale analysis (e.g. ewspec). However, it is useful to be able to numerically compute the discrete autocorrelation wavelets for arbitrary wavelets and scales as there are still unanswered theoretical questions concerning the wavelets. The method is a brute force &ndash; a more elegant solution would probably be based on interpolatory schemes.
</p>
<p>Horizontal scale. This routine returns only the values of the discrete autocorrelation scaling function and not their horizontal positions. Each discrete autocorrelation scaling function is compactly supported with the support determined from the compactly supported wavelet that generates it. See the paper by Nason, von Sachs and Kroisandt which defines the horizontal scale (but basically the finer scale discrete autocorrelation scaling function are interpolated versions of the coarser ones. When one goes from scale j to j-1 (negative j remember) an extra point is inserted between all of the old points and the discrete autocorrelation scaling function value is computed there. Thus as J tends to negative infinity the numerical approximation tends towards the continuous autocorrelation scaling function.
</p>
<p>This function stores any discrete autocorrelation wavelet sets that it computes. The storage mechanism is not as advanced as that for ipndacw and its subsidiary routines rmget and firstdot but helps a little bit. The PhinameIE function defines the naming convention for objects returned by this function.
</p>
<p>Sometimes it is useful to have the discrete autocorrelation scaling functions stored in matrix form. The PhiJmat does this. 
</p>


<h3>Value</h3>

<p>A list containing -J components, numbered from 1 to -J. The [[j]]th component contains the discrete autocorrelation scaling function at scale j.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PsiJ">PsiJ</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let us create the discrete autocorrelation wavelets for the Haar wavelet.
# We shall create up to scale 4.
#
haardw4&lt;- PhiJ(-4, filter.number=1, family="DaubExPhase")
haardw4
#[[1]]:
#[1] 0.5  1.0 0.5
#
#[[2]]:
#[1] 0.25 0.50  0.75  1.00  0.75 0.50 0.25
#
#[[3]]:
# [1] 0.125 0.250 0.375 0.500 0.625  0.750  0.875  1.000  0.875  0.750
#[11] 0.625 0.500 0.375 0.250 0.125
#
#[[4]]:
# [1] 0.0625 0.1250 0.1875 0.2500 0.3125 0.3750 0.4375 0.5000 0.5625
#[10] 0.6250  0.6875  0.7500  0.8125  0.8750  0.9375  1.0000  0.9375  0.8750
#[19]  0.8125  0.7500  0.6875 0.6250 0.5625 0.5000 0.4375 0.3750 0.3125
#[28] 0.2500 0.1875 0.1250 0.0625
#
# You can plot the fourth component to get an idea of what the
# autocorrelation wavelet looks like.
#
# Note that the previous call stores the autocorrelation wavelet
# in D1.Phi.4.1.DaubExPhase in the environment DWEnv. This is mainly so that 
# it doesn't have to be recomputed. 
#
# Note that the x-coordinates in the following are approximate.
#
 plot(seq(from=-1, to=1, length=length(haardw4[[4]])),haardw4[[4]], type="l",
xlab = "t", ylab = "Haar Autocorrelation Scaling function")
</code></pre>

<hr>
<h2 id='print.cddews'>Print out information about a cddews object in readable form.</h2><span id='topic+print.cddews'></span>

<h3>Description</h3>

<p>This function prints out information about an cddews object in a nice human-readable form.
</p>
<p>Note that this function is automatically called by R whenever the name of an ccdews object is typed or whenever such an object is returned to the top level of the R interpreter. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cddews'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.cddews_+3A_x">x</code></td>
<td>
<p>An object of class ccdews that you wish to print out.</p>
</td></tr>
<tr><td><code id="print.cddews_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function! </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See description.
</p>


<h3>Side Effects</h3>

<p>Prints out information about ccdews objects in nice readable format.</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cddews">cddews</a></code>, <code><a href="#topic+summary.cddews">summary.cddews</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate a cddews object for a HaarMontage realisation 
#
monty &lt;- HaarMontage(direction="diagonal")
tmp &lt;- cddews(monty, filter.number=1, family="DaubExPhase", switch="direction",correct=FALSE)
#
# Now get R to use print.cddews
#
tmp
</code></pre>

<hr>
<h2 id='Psi1Dname'>Return a PsiJ list object style name.</h2><span id='topic+Psi1Dname'></span>

<h3>Description</h3>

<p>This function returns a character string according to a particular format for naming PsiJ objects. Note that this construct is different from that used in WaveThresh as we wish to be able to differentiate between one and two-dimensional autocorrelation wavelets!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Psi1Dname(J, filter.number, family)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Psi1Dname_+3A_j">J</code></td>
<td>
<p>A negative integer representing the order of the PsiJ object.</p>
</td></tr>
<tr><td><code id="Psi1Dname_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number of the wavelet used to build the PsiJ object.</p>
</td></tr>
<tr><td><code id="Psi1Dname_+3A_family">family</code></td>
<td>
<p>The wavelet family used to build the PsiJ object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some of the objects computed by PsiJ take a long time to compute. Hence it is a good idea to store them and reuse them. This function generates a name according to a particular naming scheme that permits a search algorithm to easily find the matrices.
</p>
<p>Each object has three defining characteristics: its order, filter.number and family. Each of these three characteristics are concatenated together to form a name.
</p>
<p>This function performs exactly the same role as rmname except for objects produced by PsiJ. 
</p>


<h3>Value</h3>

<p>A character string containing the name of an object according to a particular naming scheme.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (1998). Wavelet processes and adaptive estimation of the evolutionary wavelet spectrum. Technical Report, Department of Mathematics University of Bristol/ Fachbereich Mathematik, Kaiserslautern.
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PsiJ">PsiJ</a></code>,<code><a href="#topic+Psi1Dname">Psi1Dname</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What's the name of the order 4 Haar PsiJ object?
#
 Psiname(-4, filter.number=1, family="DaubExPhase")
#[1] "D1Psi.4.1.DaubExPhase"
#
# What's the name of the order 12 Daubechies least-asymmetric wavelet PsiJ
# with 7 vanishing moments?
#
 Psiname(-12, filter.number=7, family="DaubLeAsymm")             
#[1] "D1Psi.12.7.DaubLeAsymm"
</code></pre>

<hr>
<h2 id='Psi2Dname'>Return a D2ACW list object style name.</h2><span id='topic+Psi2Dname'></span>

<h3>Description</h3>

<p>This function returns a character string according to a particular format for naming D2ACW objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Psi2Dname(J, filter.number, family, switch)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Psi2Dname_+3A_j">J</code></td>
<td>
<p>A negative integer representing the order of the D2ACW object.</p>
</td></tr>
<tr><td><code id="Psi2Dname_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number of the wavelet used to build the D2ACW object.</p>
</td></tr>
<tr><td><code id="Psi2Dname_+3A_family">family</code></td>
<td>
<p>The wavelet family used to build the D2ACW object.</p>
</td></tr>
<tr><td><code id="Psi2Dname_+3A_switch">switch</code></td>
<td>
<p>Can take the values <code>direction</code> or <code>level</code> - enabling control of whether the returned value is structured by scales within a given direction (-1, D), (-2, D), (-3, D), ... or by direction within scales (-1, H), (-1, V), (-1, D), (-2, H), ... </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some of the objects computed by D2ACW take a long time to compute. Hence it is a good idea to store them and reuse them. This function generates a name according to a particular naming scheme that permits a search algorithm to easily find the matrices.
</p>
<p>Each object has three defining characteristics: its order, filter.number and family. Each of these three characteristics are concatenated together to form a name.
</p>
<p>This function performs exactly the same role as rmname except for objects produced by D2ACW. 
</p>


<h3>Value</h3>

<p>A character string containing the name of an object according to a particular naming scheme.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

<p>Eckley, I.A. and  Nason, G.P. (2005). Efficient computation of the inner-product matrix of discrete
autocorrelation wavelets. Statistics and Computing, 15, 83-92.
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+D2ACW">D2ACW</a></code>,<code><a href="#topic+Psi1Dname">Psi1Dname</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# What's the name of the order 4 Haar PsiJ object?
#
 Psi2Dname(-4, filter.number=1, family="DaubExPhase", switch="direction")
#[1] "D1Psi.d.4.1.DaubExPhase"
</code></pre>

<hr>
<h2 id='PsiJ'>Compute discrete autocorrelation wavelets.</h2><span id='topic+PsiJ'></span>

<h3>Description</h3>

<p>This function computes discrete autocorrelation wavelets.
</p>
<p>The inner products of the discrete autocorrelation wavelets are computed by the routine ipndacw. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PsiJ(J, filter.number = 10, family = "DaubLeAsymm", tol = 1e-100, 
OPLENGTH = 2000, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PsiJ_+3A_j">J</code></td>
<td>
<p>Discrete autocorrelation wavelets will be computed for scales -1 up to scale J. This number should be a negative integer.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_filter.number">filter.number</code></td>
<td>
<p>The index of the wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_family">family</code></td>
<td>
<p>The family of wavelet used to compute the discrete autocorrelation wavelets.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_tol">tol</code></td>
<td>
<p>In the brute force computation for Daubechies compactly supported wavelets many inner product computations are performed. This tolerance discounts any results which are smaller than tol which effectively defines how long the inner product/autocorrelation products are.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_oplength">OPLENGTH</code></td>
<td>
<p>This integer variable defines some workspace of length OPLENGTH. The code uses this workspace. If the workspace is not long enough then the routine will stop and probably tell you what OPLENGTH should be set to.</p>
</td></tr>
<tr><td><code id="PsiJ_+3A_verbose">verbose</code></td>
<td>
<p>If this <code>TRUE</code> certain informative statements are printed to the screen when this function is being executed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the discrete autocorrelation wavelets. It does not have any direct use for time-scale analysis (e.g. ewspec). However, it is useful to be able to numerically compute the discrete autocorrelation wavelets for arbitrary wavelets and scales as there are still unanswered theoretical questions concerning the wavelets. The method is a brute force &ndash; a more elegant solution would probably be based on interpolatory schemes.
</p>
<p>Horizontal scale. This routine returns only the values of the discrete autocorrelation wavelets and not their horizontal positions. Each discrete autocorrelation wavelet is compactly supported with the support determined from the compactly supported wavelet that generates it. See the paper by Nason, von Sachs and Kroisandt which defines the horizontal scale (but basically the finer scale discrete autocorrelation wavelets are interpolated versions of the coarser ones. When one goes from scale j to j-1 (negative j remember) an extra point is inserted between all of the old points and the discrete autocorrelation wavelet value is computed there. Thus as J tends to negative infinity the numerical approximation tends towards the continuous autocorrelation wavelet.
</p>
<p>This function stores any discrete autocorrelation wavelet sets that it computes. The storage mechanism is not as advanced as that for ipndacw and its subsidiary routines rmget and firstdot but helps a little bit. The Psiname function defines the naming convention for objects returned by this function.
</p>
<p>Sometimes it is useful to have the discrete autocorrelation wavelets stored in matrix form. The PsiJmat does this. 
</p>


<h3>Value</h3>

<p>A list containing -J components, numbered from 1 to -J. The [[j]]th component contains the discrete autocorrelation wavelet at scale j.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Psi1Dname">Psi1Dname</a></code>,<code><a href="#topic+PhiJ">PhiJ</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Let us create the discrete autocorrelation wavelets for the Haar wavelet.
# We shall create up to scale 4.
#
haardw4&lt;-PsiJ(-4, filter.number=1, family="DaubExPhase", verbose=TRUE)
haardw4
#Computing PsiJ
#Returning precomputed version
#Took  0.00999999  seconds
#
#[[1]]:
#[1] -0.5  1.0 -0.5
# 
#[[2]]:
#[1] -0.25 -0.50  0.25  1.00  0.25 -0.50 -0.25
# 
#[[3]]:
# [1] -0.125 -0.250 -0.375 -0.500 -0.125  0.250  0.625  1.000  0.625  0.250
#[11] -0.125 -0.500 -0.375 -0.250 -0.125
# 
#[[4]]:
# [1] -0.0625 -0.1250 -0.1875 -0.2500 -0.3125 -0.3750 -0.4375 -0.5000 -0.3125
#[10] -0.1250  0.0625  0.2500  0.4375  0.6250  0.8125  1.0000  0.8125  0.6250
#[19]  0.4375  0.2500  0.0625 -0.1250 -0.3125 -0.5000 -0.4375 -0.3750 -0.3125
#[28] -0.2500 -0.1875 -0.1250 -0.0625
#
#
# You can plot the fourth component to get an idea of what the
# autocorrelation wavelet looks like.
#
# Note that the previous call stores the autocorrelation wavelet
# in D1Psi.4.1.DaubExPhase in the environment DWEnv. This is mainly so that it doesn't have to
# be recomputed.  
#
# Note that the x-coordinates in the following are approximate.
#
 plot(seq(from=-1, to=1, length=length(haardw4[[4]])),haardw4[[4]], type="l",
xlab = "t", ylab = "Haar Autocorrelation Wavelet")
#
#
# Now let us repeat the above for the Daubechies Least-Asymmetric wavelet
# with 10 vanishing moments.
# We shall create up to scale 6, a higher resolution version than last
# time.
#
PsiJ(-6, filter.number=10, family="DaubLeAsymm", OPLENGTH=5000)
#[[1]]:
# [1]  3.537571e-07  5.699601e-16 -7.512135e-06 -7.705013e-15  7.662378e-05
# [6]  5.637163e-14 -5.010016e-04 -2.419432e-13  2.368371e-03  9.976593e-13
#[11] -8.684028e-03 -1.945435e-12  2.605208e-02  6.245832e-12 -6.773542e-02
#[16]  4.704777e-12  1.693386e-01  2.011086e-10 -6.209080e-01  1.000000e+00
#[21] -6.209080e-01  2.011086e-10  1.693386e-01  4.704777e-12 -6.773542e-02
#[26]  6.245832e-12  2.605208e-02 -1.945435e-12 -8.684028e-03  9.976593e-13
#[31]  2.368371e-03 -2.419432e-13 -5.010016e-04  5.637163e-14  7.662378e-05
#[36] -7.705013e-15 -7.512135e-06  5.699601e-16  3.537571e-07
#
#[[2]]
#        scale 2 etc. etc.
# 
#[[3]]   scale 3 etc. etc.
# 
#scales [[4]] and [[5]]...
#
#[[6]]
#...
#   remaining scale 6 elements...
#...
#[2371] -1.472225e-31 -1.176478e-31 -4.069848e-32 -2.932736e-41  6.855259e-33
#[2376]  5.540202e-33  2.286296e-33  1.164962e-42 -3.134088e-35  3.427783e-44
#[2381] -1.442993e-34 -2.480298e-44  5.325726e-35  9.346398e-45 -2.699644e-36
#[2386] -4.878634e-46 -4.489527e-36 -4.339365e-46  1.891864e-36  2.452556e-46
#[2391] -3.828924e-37 -4.268733e-47  4.161874e-38  3.157694e-48 -1.959885e-39
#
#
# Let's now plot the 6th component (6th scale, this is the finest
# resolution, all the other scales will be coarser representations)
#
# Note that the previous call stores the autocorrelation wavelet
# in D1Psi.6.10.DaubLeAsymm in the DWEnv environment.
#
# Note that the x-coordinates in the following are non-existant!
#
 #
LA10l6&lt;-get("D1Psi.6.10.DaubLeAsymm",envir=DWEnv)

 plot(seq(from=-1, to=1, length=length(LA10l6[[6]])),LA10l6[[6]], type="l", 
xlab="t", ylab ="Daubechies N=10 least-asymmetric Autocorrelation Wavelet") 

</code></pre>

<hr>
<h2 id='sample.stats'>A function to calculate sample statistics for textured images using LS2W</h2><span id='topic+sample.stats'></span>

<h3>Description</h3>

<p>This is one, of many, possible ways of calculating a feature vector for a given textured image using the LS2W modelling framework. Please refer 
to Eckley et al. (2010) for details about the texture statistic being used. This function is only 
intended to be used with sample.stats.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.stats(x, n=25, size=64)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample.stats_+3A_x">x</code></td>
<td>
<p>The textured image which is going to be analysed.</p>
</td></tr>
<tr><td><code id="sample.stats_+3A_n">n</code></td>
<td>
<p>The number of sub-images to be sampled from the main texture.</p>
</td></tr> 
<tr><td><code id="sample.stats_+3A_size">size</code></td>
<td>
<p>The number of rows-columns required for each sub-image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the feature vectors for each sub-image. Each row 
contains the feature vector for one specific subimage
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+example.ls2w">example.ls2w</a></code></p>

<hr>
<h2 id='specplot'>Plot the LWP associated with a cddews object</h2><span id='topic+specplot'></span>

<h3>Description</h3>

<p>This function displays the LWP associated with a cddews object, allowing the user to dictate display type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specplot(cddews, scaling = "by.level", arrangement = c(3, 3), page = TRUE, 
dataname = "Image", verbose =  FALSE, display = "persp", reset = TRUE, wtitle="TRUE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="specplot_+3A_cddews">cddews</code></td>
<td>
<p>An object of class <code>cddews</code> must be supplied to the function.</p>
</td></tr>
<tr><td><code id="specplot_+3A_scaling">scaling</code></td>
<td>
<p>Two scaling options are available. The default setting is to scale <code>"by.level"</code> 
&ndash; an option which is useful if you wish to compare coefficients within a resolution level. The 
alternative setting is <code>global</code>, whereby one scale factor is chosen for all plots. This factor 
depends on the largest coefficient which is to be included in the suite of plots.
</p>
</td></tr>
<tr><td><code id="specplot_+3A_arrangement">arrangement</code></td>
<td>
<p>Allows the user to specify the number of spectral plots which are to appear on any given page.</p>
</td></tr>
<tr><td><code id="specplot_+3A_page">page</code></td>
<td>
<p>An argument which allows the user to request that they be prompted when a new page of plots 
appears. Two options are available: <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="specplot_+3A_dataname">dataname</code></td>
<td>
<p>A name for the image whose LWP is being displayed. This will appear as part of the title associated with each plot.</p>
</td></tr>
<tr><td><code id="specplot_+3A_verbose">verbose</code></td>
<td>
<p>If set to <code>TRUE</code> certain informative statements are printed to screen during execution.</p>
</td></tr>
<tr><td><code id="specplot_+3A_display">display</code></td>
<td>
<p>Two display methods are available. Using the option <code>display="persp"</code> 
displays a 3-dimensional plot of the LWP, using the routine <code>persp</code>. The option 
<code>display="image"</code> displays the LWP as a collection of images.</p>
</td></tr>
<tr><td><code id="specplot_+3A_reset">reset</code></td>
<td>
<p>If set to <code>TRUE</code>, this restores the plot settings to their default configuration 
(i.e. <code>par(mfrow=c(1,1))</code>). If <code>FALSE</code>, then the current settings will remain in operation.</p>
</td></tr>
<tr><td><code id="specplot_+3A_wtitle">wtitle</code></td>
<td>
<p>A logical variable which dictates whether a common title is displayed on all spectral plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason, G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cddews">cddews</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# First let us create a textured image and create a cddews object.
#
## Not run: 
monty &lt;- HaarMontage(direction="diagonal")
monty.cddews &lt;- cddews(monty, filter.number=1, family="DaubExPhase")
#
# Finally let's view this using a perspective plot.
#
specplot(monty.cddews, display = "persp")

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.cddews'>Use summary on a cddews object</h2><span id='topic+summary.cddews'></span>

<h3>Description</h3>

<p>This function prints out more information about a <code>cddews</code>  object in a nice readable format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cddews'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.cddews_+3A_object">object</code></td>
<td>
<p>An object of class cddews about which you wish to print out more information.</p>
</td></tr>
<tr><td><code id="summary.cddews_+3A_...">...</code></td>
<td>
<p>This argument actually does nothing in this function!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Author(s)</h3>

<p>Idris Eckley</p>


<h3>References</h3>

 
<p>Eckley, I.A., Nason, G.P. and Treloar, R.L. (2010) Locally stationary wavelet fields with application to the modelling and analysis of image texture. Journal of the Royal Statistical Society (Series C), 59, 595 - 616. 
</p>
<p>Eckley, I.A. and Nason G.P. (2011). LS2W: Implementing the Locally Stationary 2D Wavelet Process Approach in R, Journal of Statistical Software, 43(3), 1-23.
URL http://www.jstatsoft.org/v43/i03/.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cddews">cddews</a></code>, <code><a href="#topic+print.cddews">print.cddews</a></code></p>

<hr>
<h2 id='threshold.imwd'>Threshold two-dimensional wavelet decomposition object</h2><span id='topic+threshold.imwd'></span>

<h3>Description</h3>

<p>This funcion provides various ways to threshold a <code>imwd</code> class 
object. It contains a minor variation of the equivalent WaveThresh 
function, which is necessary for the LS2W package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'imwd'
threshold(x, levels = 3:(x$nlevels - 1), type = "hard", policy = "universal", 
by.level = FALSE, value = 0, dev = var, verbose = FALSE, 
return.threshold = FALSE, compression = TRUE, Q = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threshold.imwd_+3A_x">x</code></td>
<td>
<p>The two-dimensional wavelet decomposition object that 
you wish to threshold. </p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_levels">levels</code></td>
<td>
<p>a vector of integers which determines which scale 
levels are thresholded in the decomposition. Each integer in the 
vector must refer to a valid level in the <code>imwd</code> object 
supplied. This is usually any integer from 0 to 
<code>nlevels(wd)-1</code> inclusive. Only the levels in this vector 
contribute to the computation of the threshold and it application.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_type">type</code></td>
<td>
<p>Determines whether the type of thresholding is 
<code>"hard"</code> or <code>"soft"</code>.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_policy">policy</code></td>
<td>
<p>selects the technique by which the threshold value 
is selected. Each policy corresponds to a method in the literature. 
At present the different policies are: <code>"universal"</code>, 
<code>"manual"</code>, <code>"fdr"</code>, <code>"probability"</code>.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_by.level">by.level</code></td>
<td>
<p>If <code>FALSE</code> then a global threshold is 
computed on  and applied to all scale levels defined in levels. If 
<code>TRUE</code> a threshold is computed and applied separately to each 
scale level.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_value">value</code></td>
<td>
<p>This argument conveys the user supplied threshold. 
If the <code>policy="manual"</code> then value is the actual threshold 
value; if 
<code>policy="probability"</code> then value conveys the the user supplied 
quantile level. </p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_dev">dev</code></td>
<td>
<p>This argument supplies the function to be used to 
compute the spread of the absolute values coefficients. The 
function supplied must return a value of spread on the variance 
scale (i.e. not standard deviation) such as the <code>var()</code> 
function. A popular, useful and robust alternative is the <code>madmad</code> 
function.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then the function prints out 
informative messages as it progresses.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_return.threshold">return.threshold</code></td>
<td>
<p>If this option is <code>TRUE</code> then the 
actual value of the threshold is returned. If this option is <code>FALSE</code>
then a thresholded version of the input is returned.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_compression">compression</code></td>
<td>
<p>If this option is <code>TRUE</code> then this 
function returns a comressed two-dimensional wavelet transform object of 
class imwdc. This can be useful as the resulting object will be 
smaller than if it was not compressed. The compression makes use of 
the fact that many coefficients in a thresholded object will be 
exactly zero. If this option is <code>FALSE</code> then a larger imwd 
object will be returned.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_q">Q</code></td>
<td>
<p>Parameter for the false discovery rate <code>"fdr"</code> policy.</p>
</td></tr>
<tr><td><code id="threshold.imwd_+3A_...">...</code></td>
<td>
<p>There are no other arguments for this function!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>imwdc</code> if the compression option above is 
<code>TRUE</code>, 
otherwise a <code>imwd</code> object is returned. In either case the 
returned 
object contains the thresholded coefficients. Note that if the 
<code>return.threshold</code> option is set to TRUE then the threshold 
values 
will be returned rather than the thresholded object. 
</p>


<h3>Author(s)</h3>

<p>Idris Eckley and Guy Nason</p>


<h3>References</h3>

<p>Please refer to the equivalent wavethresh help page.
</p>
<p>Guy Nason (2010). wavethresh: Wavelets statistics and transforms. R package
version 4.5. URL http://CRAN.R-project.org/package=wavethresh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imwd">imwd</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
