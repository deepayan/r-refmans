<!DOCTYPE html><html><head><title>Help for package HDtweedie</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {HDtweedie}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auto'><p>A motor insurance dataset</p></a></li>
<li><a href='#coef.cv.HDtweedie'><p>get coefficients or make coefficient predictions from a &quot;cv.HDtweedie&quot; object.</p></a></li>
<li><a href='#coef.HDtweedie'><p>get coefficients or make coefficient predictions from an &quot;HDtweedie&quot; object.</p></a></li>
<li><a href='#cv.HDtweedie'><p>Cross-validation for HDtweedie</p></a></li>
<li><a href='#HDtweedie'><p>Fits the regularization paths for lasso-type methods of the Tweedie model</p></a></li>
<li><a href='#plot.cv.HDtweedie'><p>plot the cross-validation curve produced by cv.HDtweedie</p></a></li>
<li><a href='#plot.HDtweedie'><p>Plot solution paths from a &quot;HDtweedie&quot; object</p></a></li>
<li><a href='#predict.cv.HDtweedie'><p>make predictions from a &quot;cv.HDtweedie&quot; object.</p></a></li>
<li><a href='#predict.HDtweedie'><p>make predictions from a &quot;HDtweedie&quot; object.</p></a></li>
<li><a href='#print.HDtweedie'><p>print a HDtweedie object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The Lasso for Tweedie's Compound Poisson Model Using an IRLS-BMD
Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Wei Qian &lt;weiqian@stat.umn.edu&gt;, Yi Yang &lt;yiyang@umn.edu&gt;, Hui Zou &lt;hzou@stat.umn.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wei Qian &lt;weiqian@stat.umn.edu&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Description:</td>
<td>The Tweedie lasso model implements an iteratively reweighed least square (IRLS) strategy that incorporates a blockwise majorization decent (BMD) method, for efficiently computing solution paths of the (grouped) lasso and the (grouped) elastic net methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-09 23:15:03 UTC; weiqian</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-10 02:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auto'>A motor insurance dataset</h2><span id='topic+auto'></span>

<h3>Description</h3>

<p>The motor insurance dataset is originially retrieved from the SAS Enterprise Miner database. The included dataset is generated by re-organization and transformation as described in Qian et al. (2016). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(auto)
</code></pre>


<h3>Details</h3>

<p> This data set contains 2812 policy samples 
with 56 predictors. See Qian et al. (2016) for a detailed description of the generation of these predictors. The response is the aggregate claim loss (in thousand dollars). The predictors are expanded from the following original variables:
</p>

<dl>
<dt><code>CAR_TYPE</code>:</dt><dd><p>car type, 6 categories</p>
</dd>
<dt><code>JOBCLASS</code>:</dt><dd><p>job class, 8 categories</p>
</dd>
<dt><code>MAX_EDUC</code>:</dt><dd><p>education level, 5 categories</p>
</dd>
<dt><code>KIDSDRIV</code>:</dt><dd><p>number of children passengers</p>
</dd>
<dt><code>TRAVTIME</code>:</dt><dd><p>time to travel from home to work</p>
</dd>
<dt><code>BLUEBOOK</code>:</dt><dd><p>car value</p>
</dd>
<dt><code>NPOLICY</code>:</dt><dd><p>number of policies</p>
</dd>
<dt><code>MVR_PTS</code>:</dt><dd><p>motor vehicle record point</p>
</dd>
<dt><code>AGE</code>:</dt><dd><p>driver age</p>
</dd>
<dt><code>HOMEKIDS</code>:</dt><dd><p>number of children at home</p>
</dd>
<dt><code>YOJ</code>:</dt><dd><p>years on job</p>
</dd>
<dt><code>INCOME</code>:</dt><dd><p>income</p>
</dd>
<dt><code>HOME_VAL</code>:</dt><dd><p>home value</p>
</dd>
<dt><code>SAMEHOME</code>:</dt><dd><p>years in current address</p>
</dd>
<dt><code>CAR_USE</code>:</dt><dd><p>whether the car is for commercial use</p>
</dd>
<dt><code>RED_CAR</code>:</dt><dd><p>whether the car color is red</p>
</dd>
<dt><code>REVOLKED</code>:</dt><dd><p>whether the driver's license was revoked in the past</p>
</dd>
<dt><code>GENDER</code>:</dt><dd><p>gender</p>
</dd>
<dt><code>MARRIED</code>:</dt><dd><p>whether married</p>
</dd>
<dt><code>PARENT1</code>:</dt><dd><p>whether a single parent</p>
</dd>
<dt><code>AREA</code>:</dt><dd><p>whether the driver lives in urban area</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> a [2812 x 56] matrix giving 2812 policy records with 56 predictors</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> the aggregate claim loss</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yip, K. C. H. and Yau, K. K. W. (2005), &ldquo;On Modeling Claim Frequency Data In General Insurance With Extra Zeros&rdquo;, <em>Insurance: Mathematics and Economics</em>, 36, 153-163. <br />
</p>
<p>Zhang, Y (2013). &ldquo;<code>cplm</code>: Compound Poisson Linear Models&rdquo;. A vignette for R package <code>cplm</code>. Available from <a href="https://CRAN.R-project.org/package=cplm">https://CRAN.R-project.org/package=cplm</a><br />
</p>
<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load data set
data(auto)

# how many samples and how many predictors ?
dim(auto$x)

# repsonse y
auto$y
</code></pre>

<hr>
<h2 id='coef.cv.HDtweedie'>get coefficients or make coefficient predictions from a &quot;cv.HDtweedie&quot; object.</h2><span id='topic+coef.cv.HDtweedie'></span>

<h3>Description</h3>

<p>This function gets coefficients or makes coefficient predictions from a cross-validated <code>HDtweedie</code> model,
using the <code>"cv.HDtweedie"</code> object, and the optimal value
chosen for <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.HDtweedie'
coef(object,s=c("lambda.1se","lambda.min"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cv.HDtweedie_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.HDtweedie">cv.HDtweedie</a></code> object.</p>
</td></tr>
<tr><td><code id="coef.cv.HDtweedie_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code> stored
on the CV <code>object</code>, it is the largest value of <code>lambda</code> such that error is
within 1 standard error of the minimum. Alternatively <code>s="lambda.min"</code> can be
used, it is the optimal value of <code>lambda</code> that gives minimum
cross validation error <code>cvm</code>. If <code>s</code> is numeric, it is taken as the value(s) of
<code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="coef.cv.HDtweedie_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of
cross-validation to get coefficients or make coefficient predictions.</p>


<h3>Value</h3>

<p>The coefficients at the requested values for <code>lambda</code>.</p>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian  &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010), &quot;Regularization paths for generalized
linear models via coordinate descent,&quot; <em>Journal of Statistical Software, 33, 1.</em><br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.HDtweedie">cv.HDtweedie</a></code>, and <code><a href="#topic+predict.cv.HDtweedie">predict.cv.HDtweedie</a></code> methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load data set
data(auto)

# 5-fold cross validation using the lasso
cv0 &lt;- cv.HDtweedie(x=auto$x,y=auto$y,p=1.5,nfolds=5)

# the coefficients at lambda = lambda.1se
coef(cv0)

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# 5-fold cross validation using the grouped lasso 
cv1 &lt;- cv.HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5,nfolds=5)

# the coefficients at lambda = lambda.min
coef(cv1, s = cv1$lambda.min)
</code></pre>

<hr>
<h2 id='coef.HDtweedie'>get coefficients or make coefficient predictions from an &quot;HDtweedie&quot; object.</h2><span id='topic+coef.HDtweedie'></span>

<h3>Description</h3>

<p>Computes the coefficients at the requested values for <code>lambda</code> from a fitted <code><a href="#topic+HDtweedie">HDtweedie</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HDtweedie'
coef(object, s = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.HDtweedie_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+HDtweedie">HDtweedie</a></code> model object.</p>
</td></tr>
<tr><td><code id="coef.HDtweedie_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which predictions are required. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="coef.HDtweedie_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict. </p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are requested. If <code>s</code> is not in the lambda sequence used for fitting the model, the <code>coef</code> function will use linear interpolation to make predictions. The new values are interpolated using a fraction of coefficients from both left and right <code>lambda</code> indices. 
</p>


<h3>Value</h3>

<p>The coefficients at the requested values for <code>lambda</code>.</p>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian  &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.HDtweedie">predict.HDtweedie</a></code> method</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load data set
data(auto)

# fit the lasso
m0 &lt;- HDtweedie(x=auto$x,y=auto$y,p=1.5)

# the coefficients at lambda = 0.01
coef(m0,s=0.01)

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# fit grouped lasso
m1 &lt;- HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5)

# the coefficients at lambda = 0.01 and 0.04
coef(m1,s=c(0.01,0.04))
</code></pre>

<hr>
<h2 id='cv.HDtweedie'>Cross-validation for HDtweedie</h2><span id='topic+cv.HDtweedie'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for HDtweedie, produces a plot,
and returns a value for <code>lambda</code>. This function is modified based on the <code>cv</code> function from the <code>glmnet</code> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.HDtweedie(x, y, group = NULL, p, weights, lambda = NULL, 
	pred.loss = c("deviance", "mae", "mse"), 
	nfolds = 5, foldid, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.HDtweedie_+3A_x">x</code></td>
<td>
<p>matrix of predictors, of dimension <code class="reqn">n \times p</code>; each row is an observation vector.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_y">y</code></td>
<td>
<p>response variable. This argument should be non-negative.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_group">group</code></td>
<td>
<p>To apply the grouped lasso, it is a vector of consecutive integers describing the grouping of the coefficients (see example below). To apply the lasso, the user can ignore this argument, and the vector is automatically generated by treating each variable as a group.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_p">p</code></td>
<td>
<p>the power used for variance-mean relation of Tweedie model. Default is 1.50.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_weights">weights</code></td>
<td>
<p>the observation weights. Default is equal weight.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_lambda">lambda</code></td>
<td>
<p>optional user-supplied lambda sequence; default is
<code>NULL</code>, and <code><a href="#topic+HDtweedie">HDtweedie</a></code> chooses its own sequence.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_pred.loss">pred.loss</code></td>
<td>
<p>loss to use for cross-validation error. Valid options are:
</p>

<ul>
<li> <p><code>"deviance"</code> Deviance. 
</p>
</li>
<li> <p><code>"mae"</code> Mean absolute error.
</p>
</li>
<li> <p><code>"mse"</code> Mean square error.
</p>
</li></ul>

<p>Default is <code>"deviance"</code>.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds - default is 5. Although <code>nfolds</code>
can be as large as the sample size (leave-one-out CV), it is not
recommended for large datasets. Smallest value allowable is <code>nfolds=3</code>.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing.</p>
</td></tr>
<tr><td><code id="cv.HDtweedie_+3A_...">...</code></td>
<td>
<p>other arguments that can be passed to HDtweedie.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code><a href="#topic+HDtweedie">HDtweedie</a></code> <code>nfolds</code>+1 times; the
first to get the <code>lambda</code> sequence, and then the remainder to
compute the fit with each of the folds omitted. The average error and standard deviation over the
folds are computed. 
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+cv.HDtweedie">cv.HDtweedie</a></code> is returned, which is a
list with the ingredients of the cross-validation fit.
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>the mean cross-validated error - a vector of length
<code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td></tr>
<tr><td><code>cvupper</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlower</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td></tr>
<tr><td><code>name</code></td>
<td>
<p>a text string indicating type of measure (for plotting
purposes).</p>
</td></tr>
<tr><td><code>HDtweedie.fit</code></td>
<td>
<p>a fitted <code><a href="#topic+HDtweedie">HDtweedie</a></code> object for the full data.</p>
</td></tr>
<tr><td><code>lambda.min</code></td>
<td>
<p>The optimal value of <code>lambda</code> that gives minimum
cross validation error <code>cvm</code>.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error is
within 1 standard error of the minimum.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian  &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HDtweedie">HDtweedie</a></code>, <code><a href="#topic+plot.cv.HDtweedie">plot.cv.HDtweedie</a></code>, <code><a href="#topic+predict.cv.HDtweedie">predict.cv.HDtweedie</a></code>, and <code><a href="#topic+coef.cv.HDtweedie">coef.cv.HDtweedie</a></code> methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load data set
data(auto)

# 5-fold cross validation using the lasso
cv0 &lt;- cv.HDtweedie(x=auto$x,y=auto$y,p=1.5,nfolds=5) 

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# 5-fold cross validation using the grouped lasso 
cv1 &lt;- cv.HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5,nfolds=5)
</code></pre>

<hr>
<h2 id='HDtweedie'>Fits the regularization paths for lasso-type methods of the Tweedie model</h2><span id='topic+HDtweedie'></span>

<h3>Description</h3>

<p>Fits regularization paths for lasso-type methods of the Tweedie model at a sequence of regularization parameters lambda.</p>


<h3>Usage</h3>

<pre><code class='language-R'>HDtweedie(x, y, group = NULL, 
		p = 1.50,
		weights = rep(1,nobs),
		alpha = 1,
		nlambda = 100, 
		lambda.factor = ifelse(nobs &lt; nvars, 0.05, 0.001), 
		lambda = NULL, 
		pf = sqrt(bs), 
		dfmax = as.integer(max(group)) + 1, 
		pmax = min(dfmax * 1.2, as.integer(max(group))), 
		standardize = FALSE,
		eps = 1e-08, maxit = 3e+08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HDtweedie_+3A_x">x</code></td>
<td>
<p>matrix of predictors, of dimension <code class="reqn">n \times p</code>; each row is an observation vector.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_y">y</code></td>
<td>
<p>response variable. This argument should be non-negative.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_group">group</code></td>
<td>
<p> To apply the grouped lasso, it is a vector of consecutive integers describing the grouping of the coefficients (see example below). To apply the lasso, the user can ignore this argument, and the vector is automatically generated by treating each variable as a group.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_p">p</code></td>
<td>
<p>the power used for variance-mean relation of Tweedie model. Default is 1.50.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_weights">weights</code></td>
<td>
<p>the observation weights. Default is equal weight.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>. The penalty is defined
as </p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>
 <p><code>alpha=1</code>
is the lasso penalty, and <code>alpha=0</code> the ridge penalty. Default is 1.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of <code>lambda</code> values - default is 100.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>the factor for getting the minimal lambda in <code>lambda</code> sequence, where <code>min(lambda)</code> = <code>lambda.factor</code> * <code>max(lambda)</code>.  <code>max(lambda)</code> is the smallest value of <code>lambda</code> for which all coefficients are zero. The default depends on the relationship between <code class="reqn">n</code> (the number of rows in the matrix of predictors) and <code class="reqn">p</code> (the number of predictors). If <code class="reqn">n &gt;= p</code>, the default is <code>0.001</code>,
close to zero.  If <code class="reqn">n&lt;p</code>, the default is <code>0.05</code>.
A very small value of <code>lambda.factor</code> will lead to a saturated fit. It takes no effect if there is user-defined <code>lambda</code> sequence.</p>
</td></tr> 
<tr><td><code id="HDtweedie_+3A_lambda">lambda</code></td>
<td>
<p>a user supplied <code>lambda</code> sequence. Typically, by leaving this option unspecified users can have 
the program compute its own <code>lambda</code> sequence based on
<code>nlambda</code> and <code>lambda.factor</code>. Supplying a value of
<code>lambda</code> overrides this. It is better to supply
a decreasing sequence of <code>lambda</code> values than a single (small) value. If not, the program will sort user-defined <code>lambda</code> sequence in decreasing order automatically.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_pf">pf</code></td>
<td>
<p>penalty factor, a vector in length of bn (bn is the total number of groups). Separate penalty weights can be applied to each group to allow
differential shrinkage. Can be 0 for some groups, which implies
no shrinkage, and results in that group always being included in the
model. Default value for each entry is the square-root of the corresponding size of each group (for the lasso, it is 1 for each variable).</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_dfmax">dfmax</code></td>
<td>
<p>limit the maximum number of groups in the model. Default is <code>bs+1</code>.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_pmax">pmax</code></td>
<td>
<p>limit the maximum number of groups ever to be nonzero. For example once a group enters the model, no matter how many times it exits or re-enters model through the path, it will be counted only once. Default is <code>min(dfmax*1.2,bs)</code>.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_eps">eps</code></td>
<td>
<p>convergence termination tolerance. Defaults value is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_standardize">standardize</code></td>
<td>
<p>logical flag for variable standardization, prior to fitting the model sequence. If <code>TRUE</code>, x matrix is normalized such that each column is centered and sum squares of each column <code class="reqn">\sum^N_{i=1}x_{ij}^2/N=1</code>. The coefficients are always returned on the original scale. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="HDtweedie_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of inner-layer BMD iterations allowed. Default is 3e8.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of models implied by <code>lambda</code> is fit by the IRLS-BMD algorithm. This gives a (grouped) lasso or (grouped) elasticnet regularization path for fitting the Tweedie generalized linear regression paths, by maximizing the corresponding penalized Tweedie log-likelihood. If the <code>group</code> argument is ignored, the function fits the lasso. Users can tweak the penalty by choosing different <code class="reqn">alpha</code> and penalty factor.  
</p>
<p>For computing speed reason, if models are not converging or running slow, consider increasing <code>eps</code>, decreasing
<code>nlambda</code>, or increasing <code>lambda.factor</code> before increasing
<code>maxit</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code><a href="#topic+HDtweedie">HDtweedie</a></code>.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>b0</code></td>
<td>
<p>intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a <code>p*length(lambda)</code> matrix of coefficients.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the number of nonzero groups for each value of
<code>lambda</code>.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of coefficient matrix (ices)</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>total number of iterations (the most inner loop) summed over all lambda values</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors, 0 if no error.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>a vector of consecutive integers describing the grouping of the coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>


<h3>See Also</h3>

<p><code>plot.HDtweedie</code></p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load auto data set
data(auto)

# fit the lasso
m0 &lt;- HDtweedie(x=auto$x,y=auto$y,p=1.5)

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# fit the grouped lasso
m1 &lt;- HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5)

# fit the grouped elastic net
m2 &lt;- HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5,alpha=0.7)
</code></pre>

<hr>
<h2 id='plot.cv.HDtweedie'>plot the cross-validation curve produced by cv.HDtweedie</h2><span id='topic+plot.cv.HDtweedie'></span>

<h3>Description</h3>

<p>Plots the cross-validation curve, and upper and lower standard deviation
curves, as a function of the <code>lambda</code> values used. This function is modified based on the <code>plot.cv</code> function from the <code>glmnet</code> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.HDtweedie'
plot(x, sign.lambda, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.HDtweedie_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+cv.HDtweedie">cv.HDtweedie</a></code> object</p>
</td></tr>
<tr><td><code id="plot.cv.HDtweedie_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>either plot against <code>log(lambda)</code> (default) or
its negative if <code>sign.lambda=-1</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.HDtweedie_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot is produced.</p>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian  &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010), &ldquo;Regularization paths for generalized
linear models via coordinate descent,&rdquo; <em>Journal of Statistical Software</em>, 33, 1.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.HDtweedie">cv.HDtweedie</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load data set
data(auto)

# 5-fold cross validation using the lasso
cv0 &lt;- cv.HDtweedie(x=auto$x,y=auto$y,p=1.5,nfolds=5,lambda.factor=.0005)

# make a CV plot
plot(cv0)

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# 5-fold cross validation using the grouped lasso 
cv1 &lt;- cv.HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5,nfolds=5,lambda.factor=.0005)

# make a CV plot
plot(cv1)
</code></pre>

<hr>
<h2 id='plot.HDtweedie'>Plot solution paths from a &quot;HDtweedie&quot; object</h2><span id='topic+plot.HDtweedie'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for a
fitted <code><a href="#topic+HDtweedie">HDtweedie</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HDtweedie'
plot(x, group = FALSE, log.l = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.HDtweedie_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+HDtweedie">HDtweedie</a></code> model</p>
</td></tr>
<tr><td><code id="plot.HDtweedie_+3A_group">group</code></td>
<td>
<p>what is on the Y-axis. Plot the norm of each group
if <code>TRUE</code>. Plot each coefficient if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.HDtweedie_+3A_log.l">log.l</code></td>
<td>
<p>what is on the X-axis. Plot against the log-lambda
sequence if <code>TRUE</code>. Plot against the lambda sequence if <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.HDtweedie_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coefficient profile plot is produced.
</p>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian  &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load data set
data(auto)

# fit the lasso
m0 &lt;- HDtweedie(x=auto$x,y=auto$y,p=1.5)

# make plot
plot(m0) # plots the coefficients against the log-lambda sequence

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# fit group lasso
m1 &lt;- HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5)

# make plots
par(mfrow=c(1,3))
plot(m1) # plots the coefficients against the log-lambda sequence 
plot(m1,group=TRUE) # plots group norm against the log-lambda sequence 
plot(m1,log.l=FALSE) # plots against the lambda sequence
</code></pre>

<hr>
<h2 id='predict.cv.HDtweedie'>make predictions from a &quot;cv.HDtweedie&quot; object.</h2><span id='topic+predict.cv.HDtweedie'></span>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated <code>HDtweedie</code> model,
using the stored <code>"cv.HDtweedie"</code> object, and the optimal value
chosen for <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.HDtweedie'
predict(object, newx, s=c("lambda.1se","lambda.min"),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.HDtweedie_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.HDtweedie">cv.HDtweedie</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.cv.HDtweedie_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are
to be made. Must be a matrix. See documentation for <code>predict.HDtweedie</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.HDtweedie_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code> stored
on the CV object. Alternatively <code>s="lambda.min"</code> can be
used. If <code>s</code> is numeric, it is taken as the value(s) of
<code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="predict.cv.HDtweedie_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict. </p>
</td></tr> </table>


<h3>Details</h3>

<p>This function makes it easier to use the results of
cross-validation to make a prediction.</p>


<h3>Value</h3>

<p>The returned object depends on the ... argument which is passed on
to the <code><a href="stats.html#topic+predict">predict</a></code> method for <code><a href="#topic+HDtweedie">HDtweedie</a></code> objects.</p>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian  &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.HDtweedie">cv.HDtweedie</a></code>, and <code><a href="#topic+coef.cv.HDtweedie">coef.cv.HDtweedie</a></code> methods.</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load data set
data(auto)

# 5-fold cross validation using the lasso
cv0 &lt;- cv.HDtweedie(x=auto$x,y=auto$y,p=1.5,nfolds=5) 

# predicted mean response at lambda = lambda.1se, newx = x[1,]
pre = predict(cv0, newx = auto$x[1,], type = "response")

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# 5-fold cross validation using the grouped lasso 
cv1 &lt;- cv.HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5,nfolds=5)

# predicted the log mean response at lambda = lambda.min, x[1:5,]
pre = predict(cv1, newx = auto$x[1:5,], s = cv1$lambda.min, type = "link")
</code></pre>

<hr>
<h2 id='predict.HDtweedie'>make predictions from a &quot;HDtweedie&quot; object.</h2><span id='topic+predict.HDtweedie'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values  from a <code><a href="#topic+HDtweedie">HDtweedie</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HDtweedie'
predict(object, newx, s = NULL,
type=c("response","link"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.HDtweedie_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+HDtweedie">HDtweedie</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.HDtweedie_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are
to be made. Must be a matrix.</p>
</td></tr>
<tr><td><code id="predict.HDtweedie_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the entire sequence used to
create the model. </p>
</td></tr>
<tr><td><code id="predict.HDtweedie_+3A_type">type</code></td>
<td>

<p>type of prediction required:
</p>

<ul>
<li><p> Type <code>"response"</code> gives the mean response estimate.
</p>
</li>
<li><p> Type <code>"link"</code> gives the estimate for log mean response.</p>
</li></ul>

</td></tr>
<tr><td><code id="predict.HDtweedie_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict. </p>
</td></tr> </table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are requested. If <code>s</code> is not in the lambda sequence used for fitting the model, the <code>predict</code> function will use linear interpolation to make predictions. The new values are interpolated using a fraction of predicted values from both left and right <code>lambda</code> indices. </p>


<h3>Value</h3>

<p>The object returned depends on type.</p>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian  &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> method</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load auto data set
data(auto)

# fit the lasso
m0 &lt;- HDtweedie(x=auto$x,y=auto$y,p=1.5)

# predicted mean response at x[10,]
print(predict(m0,type="response",newx=auto$x[10,]))

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# fit the grouped lasso
m1 &lt;- HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5)

# predicted the log mean response at x[1:5,]
print(predict(m1,type="link",newx=auto$x[1:5,]))
</code></pre>

<hr>
<h2 id='print.HDtweedie'>print a HDtweedie object</h2><span id='topic+print.HDtweedie'></span>

<h3>Description</h3>

<p>Print the nonzero group counts at each lambda along the HDtweedie path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'HDtweedie'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.HDtweedie_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+HDtweedie">HDtweedie</a></code> object</p>
</td></tr>
<tr><td><code id="print.HDtweedie_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout</p>
</td></tr>
<tr><td><code id="print.HDtweedie_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print the information about the nonzero group counts at each lambda step in the <code><a href="#topic+HDtweedie">HDtweedie</a></code> object. The result is a two-column matrix with columns <code>Df</code> and <code>Lambda</code>. The <code>Df</code> column is the number of the groups that have nonzero within-group coefficients, the <code>Lambda</code> column is the the corresponding lambda.
</p>


<h3>Value</h3>

<p>a two-column matrix, the first columns is the number of nonzero group counts and the second column is <code>Lambda</code>.</p>


<h3>Author(s)</h3>

<p>Wei Qian, Yi Yang and Hui Zou<br />
Maintainer: Wei Qian  &lt;weiqian@stat.umn.edu&gt;</p>


<h3>References</h3>

<p>Qian, W., Yang, Y., Yang, Y. and Zou, H. (2016), &ldquo;Tweedie's Compound
Poisson Model With Grouped Elastic Net,&rdquo; <em>Journal of Computational and Graphical Statistics</em>, 25, 606-625.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load HDtweedie library
library(HDtweedie)

# load auto data set
data(auto)

# fit the lasso
m0 &lt;- HDtweedie(x=auto$x,y=auto$y,p=1.5)

# print out results
print(m0)

# define group index
group1 &lt;- c(rep(1,5),rep(2,7),rep(3,4),rep(4:14,each=3),15:21)

# fit the grouped lasso
m1 &lt;- HDtweedie(x=auto$x,y=auto$y,group=group1,p=1.5)

# print out results
print(m1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
