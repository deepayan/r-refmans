<!DOCTYPE html><html><head><title>Help for package descstat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {descstat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bin'><p>Bin series</p></a></li>
<li><a href='#bivariate'><p>Functions to compute statistics on bivariate distributions</p></a></li>
<li><a href='#cont_table'><p>Contingency table</p></a></li>
<li><a href='#descstat-package'><p>descstat: a toolbox for descriptive statistics</p></a></li>
<li><a href='#employment'><p>French employment survey</p></a></li>
<li><a href='#freq_table'><p>Frequency table</p></a></li>
<li><a href='#income'><p>Income of French households</p></a></li>
<li><a href='#padova'><p>Housing prices in Padova</p></a></li>
<li><a href='#pre_plot'><p>Put a tibble in form to plot</p></a></li>
<li><a href='#print_method'><p>Print methods for bin, freq_table and cont_table objects</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rgp'><p>Extract of the French census</p></a></li>
<li><a href='#univariate'><p>Functions to compute statistics on univariate distributions</p></a></li>
<li><a href='#wages'><p>DADS survey</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-02-17</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Descriptive Statistics</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, purrr, dplyr, tidyr, tibble, tidyselect, forcats, cli,
magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ggplot2, rmarkdown</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for descriptive statistics, based on the computation of frequency and contingency tables. Several statistical functions and plot methods are provided to describe univariate or bivariate distributions of factors, integer series and numerical series either provided as individual values or as bins.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-17 16:11:34 UTC; yves</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Croissant [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yves Croissant &lt;yves.croissant@univ-reunion.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-17 16:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bin'>Bin series</h2><span id='topic+bin'></span><span id='topic+as_bin'></span><span id='topic+is_bin'></span><span id='topic+as_numeric'></span><span id='topic+cut.bin'></span><span id='topic+cut.character'></span><span id='topic+cut.factor'></span><span id='topic+extract.character'></span><span id='topic+extract.factor'></span>

<h3>Description</h3>

<p>A new class called <code>bin</code> is provided, along with different
functions which enable to deal easily with bins, ie creating <code>bin</code>
objects (<code>as_bin</code>) coercing bins to numerical values
(<code>as_numeric</code>), merging bins (<code>cut</code>) and checking than an object is
a bin (<code>is_bin</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_bin(x)

is_bin(x)

as_numeric(x, pos = 0, xfirst = NULL, xlast = NULL, wlast = NULL)

## S3 method for class 'bin'
cut(x, breaks = NULL, ...)

## S3 method for class 'character'
cut(x, breaks = NULL, ...)

## S3 method for class 'factor'
cut(x, breaks = NULL, ...)

## S3 method for class 'character'
extract(data, ..., .name_repair = "check_unique")

## S3 method for class 'factor'
extract(data, ..., .name_repair = "check_unique")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_+3A_x">x</code></td>
<td>
<p>a character or a factor: the first and last characters
should be any of <code>[</code>, <code>(</code>, <code style="white-space: pre;">&#8288;]&#8288;</code>, <code style="white-space: pre;">&#8288;)&#8288;</code> and the other characters
should be interpreted as two numerical values separated by a
comma,</p>
</td></tr>
<tr><td><code id="bin_+3A_pos">pos</code></td>
<td>
<p>a numeric between 0 and 1, 0 for the lower bond, 1 for
the upper bond, 0.5 for the center of the class (or any other
value between 0 and 1), which indicates to <code>as_numeric</code> how the
bins should be coerced to numerical values,</p>
</td></tr>
<tr><td><code id="bin_+3A_xfirst">xfirst</code>, <code id="bin_+3A_xlast">xlast</code></td>
<td>
<p>the center of the first (last) class, if one
wants to specify something different from the average of the
lower and the upper bonds,</p>
</td></tr>
<tr><td><code id="bin_+3A_wlast">wlast</code></td>
<td>
<p>in the case where the upper bond is infinite and
<code>xlast</code> is not provided, the width of the last class is set to
the one of the before last class. If <code>wlast</code> is provided, it is
set to the width of the before last class times <code>wlast</code>,</p>
</td></tr>
<tr><td><code id="bin_+3A_breaks">breaks</code></td>
<td>
<p>a numerical vector of breaks which should be a subset
of the initial set of breaks. If only one break is provided,
all the bins with greater values are merged,</p>
</td></tr>
<tr><td><code id="bin_+3A_...">...</code></td>
<td>
<p>see <code><a href="base.html#topic+cut">base::cut()</a></code> for the <code>cut</code> method and
<code><a href="tidyr.html#topic+extract">tidyr::extract()</a></code> for the <code>extract</code> method,</p>
</td></tr>
<tr><td><code id="bin_+3A_data">data</code></td>
<td>
<p>a character or a factor containing bins,</p>
</td></tr>
<tr><td><code id="bin_+3A_.name_repair">.name_repair</code></td>
<td>
<p>see <code><a href="tidyr.html#topic+extract">tidyr::extract()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>extract</code> methods for characters and factors are provided which
split the character strings in a four tibble columns: the open
bracket, the lower bound, the upper bound and the closing bracket.
</p>
</li>
<li> <p><code>as_bin</code> takes as argument a character or a factor that
represents a bin, check the consistency of the string and return a
bin object with levels in the correct order and NAs when the
strings are malformed,
</p>
</li>
<li><p> the default <code>cut</code> method takes a numerical series as argument and
returns a factor containing bins according to a <code>break</code> vector; for
the bin's method, the break should be a subset of the original
set of breaks and a bin with fewer levels results,
</p>
</li>
<li> <p><code>as_numeric</code> converts a bin to a value of the underlying variable
defined by its relative position (from 0 lower bound to 1 upper
bound in the bin),
</p>
</li>
<li> <p><code>is_bin</code> check if the argument is a bin.
</p>
</li></ul>



<h3>Value</h3>

<p><code>as_bin</code> returns a <code>bin</code> object, <code>is_bin</code> a logical, the
<code>extract</code> method a tibble, <code>as_numeric</code> a numeric and the <code>cut</code>
method a <code>bin</code> object with fewer levels.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a factor containing bins using cut on a numeric
z &lt;- c(1, 5, 10, 12, 4, 9, 8)
bin1 &lt;- cut(z, breaks = c(1, 8, 12, Inf), right = FALSE)
# extract the elements of the levels in a tibble
extract(bin1)
# coerce to a bin object
bin2 &lt;- as_bin(bin1)
# coerce to a numeric using the center of the bins
as_numeric(bin2, pos = 0.5)
# special values for the center of the first and of the last bin
as_numeric(bin2, pos = 0.5, xfirst = 5, xlast = 16)
# same, but indicating that the width of the last class should be
# twice the one of the before last
as_numeric(bin2, pos = 0.5, xfirst = 5, wlast = 2)
# merge in order to get only two bins
cut(bin2, breaks = c(1, 12))
# if length of breaks is 1, this is the value for which all the bins
# containing greater values are merged
cut(bin2, breaks = 8)
# check that bin1 and bin2 are objects of class bin
is_bin(bin1)
is_bin(bin2)
</code></pre>

<hr>
<h2 id='bivariate'>Functions to compute statistics on bivariate distributions</h2><span id='topic+bivariate'></span><span id='topic+covariance'></span><span id='topic+correlation'></span><span id='topic+covariance.cont_table'></span><span id='topic+correlation.cont_table'></span><span id='topic+anova.cont_table'></span><span id='topic+summary.anova.cont_table'></span><span id='topic+regline'></span>

<h3>Description</h3>

<p>These functions are intended to compute from a <code>cont_table</code> objects
covariation statistics, ie the covariance, the correlation
coefficient, variance decomposition and regression line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covariance(data, ...)

correlation(data, ...)

## S3 method for class 'cont_table'
covariance(data, ...)

## S3 method for class 'cont_table'
correlation(data, ...)

## S3 method for class 'cont_table'
anova(object, x, ...)

## S3 method for class 'anova.cont_table'
summary(object, ...)

regline(formula, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bivariate_+3A_data">data</code>, <code id="bivariate_+3A_object">object</code></td>
<td>
<p>a <code>cont_table</code> object,</p>
</td></tr>
<tr><td><code id="bivariate_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="bivariate_+3A_x">x</code></td>
<td>
<p>the series for which the analyse of variance should be
computed,</p>
</td></tr>
<tr><td><code id="bivariate_+3A_formula">formula</code></td>
<td>
<p>symbolic description of the model,</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric or a tibble
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the covariance and the linear correlation coefficient are
# computed using only the `cont_table`
# First reduce the number of bins
wages2 &lt;- wages %&gt;%
          dplyr::mutate(size = cut(as_bin(size), c(20, 50, 100)),
                        wage = cut(as_bin(wage), c(10, 30, 50)))
wages2 %&gt;% cont_table(wage, size) %&gt;% covariance
wages2 %&gt;% cont_table(wage, size) %&gt;% correlation
# For the analyse of variance, one of the two series should be
# indicated
wages2 %&gt;% cont_table(wage, size) %&gt;% anova(wage)
wages2 %&gt;% cont_table(wage, size) %&gt;% anova(wage) %&gt;% summary
# For the regression line, a formula should be provided
wages2 %&gt;% cont_table(wage, size) %&gt;% regline(formula = wage ~ size)
</code></pre>

<hr>
<h2 id='cont_table'>Contingency table</h2><span id='topic+cont_table'></span><span id='topic+joint'></span><span id='topic+conditional'></span><span id='topic+marginal'></span>

<h3>Description</h3>

<p>A contingency table returns the counts of all the combinations of
the modalities of two series in a table for which every modality of
the first series is a row and every modality of the second series
is a column. The <code>joint</code>, <code>marginal</code> and <code>conditional</code> functions
compute these three distributions from the contingency table (by
indicating one series for the last two).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cont_table(
  data,
  x1,
  x2,
  weights = NULL,
  freq = NULL,
  total = FALSE,
  xfirst1 = NULL,
  xlast1 = NULL,
  wlast1 = NULL,
  xfirst2 = NULL,
  xlast2 = NULL,
  wlast2 = NULL
)

joint(data)

conditional(data, x = NULL)

marginal(data, x = NULL, f = "f", vals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cont_table_+3A_data">data</code></td>
<td>
<p>a tibble,</p>
</td></tr>
<tr><td><code id="cont_table_+3A_x1">x1</code>, <code id="cont_table_+3A_x2">x2</code></td>
<td>
<p>the two series used the construct the contingency
table, the distinct values of the first and the second will
respectively be the rows and the columns of the contingency
table,</p>
</td></tr>
<tr><td><code id="cont_table_+3A_weights">weights</code></td>
<td>
<p>a series containing the weights that should be used
to mimic the population,</p>
</td></tr>
<tr><td><code id="cont_table_+3A_freq">freq</code></td>
<td>
<p>the frequencies (in the case where data is already
contingency table),</p>
</td></tr>
<tr><td><code id="cont_table_+3A_total">total</code></td>
<td>
<p>if <code>TRUE</code>, a total is added to the table,</p>
</td></tr>
<tr><td><code id="cont_table_+3A_xfirst1">xfirst1</code>, <code id="cont_table_+3A_xfirst2">xfirst2</code>, <code id="cont_table_+3A_xlast1">xlast1</code>, <code id="cont_table_+3A_xlast2">xlast2</code>, <code id="cont_table_+3A_wlast1">wlast1</code>, <code id="cont_table_+3A_wlast2">wlast2</code></td>
<td>
<p>see <code><a href="#topic+as_numeric">as_numeric()</a></code>,</p>
</td></tr>
<tr><td><code id="cont_table_+3A_x">x</code></td>
<td>
<p>the series on which the operation should be computed,</p>
</td></tr>
<tr><td><code id="cont_table_+3A_f">f</code></td>
<td>
<p>see <code><a href="#topic+freq_table">freq_table()</a></code>,</p>
</td></tr>
<tr><td><code id="cont_table_+3A_vals">vals</code></td>
<td>
<p>see <code><a href="#topic+freq_table">freq_table()</a></code>,</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>cont_table</code> actually returns a tibble in &quot;long format&quot;, as the
<code>dplyr::count</code> table does. As the returned object is of class
<code>cont_table</code>, this is the <code>format</code> and <code>print</code> methods that turns
the tibble in a wide format before printing.
</p>
<p>The <code>conditional</code> and <code>joint</code> functions return a <code>cont_table</code>
object, as the <code>marginal</code> function returns a <code>freq_table</code> object.
</p>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
# get a contingency table containing education and sex
cont_table(employment, education, sex)
# instead of counts, sum the weights
cont_table(employment, education, sex, weights = weights)
# get the joint distribution and the conditional and marginal
# distribution of sex
cont_table(employment, education, sex) %&gt;% joint
cont_table(employment, education, sex) %&gt;% marginal(sex)
cont_table(employment, education, sex) %&gt;% conditional(sex)
</code></pre>

<hr>
<h2 id='descstat-package'>descstat: a toolbox for descriptive statistics</h2><span id='topic+descstat-package'></span>

<h3>Description</h3>

<p>Descriptive statistics consist on presenting the distribution of
series for a sample in tables (frequency table for one series,
contingency tables for two series), ploting this distribution and
computing some statistics that summarise it. <strong>descstat</strong> provides
a complete toolbox to perform this tasks. It has been writen using
some packages of the tidyverse (especially <strong>dplyr</strong>, <strong>tidyr</strong> and
<strong>purrr</strong>) and its usage follow the tidyverse conventions,
especially the selection of series using their unquoted names and
the use of the pipe operator and of tibbles.
</p>


<h3>The bin class</h3>

<p>In a frequency (or contingency table), continuous numerical series
are presented as bins. Moreover, for some surveys, the individual
values are not known, but only the fact that these values belongs to
a bin. Therefore, it is crucial to be able to work easily with
bins, ie:
</p>

<ul>
<li><p> creating bins from numerical values, which is performed by the
<code>base::cut</code> function which turns a numerical series to a bin,
</p>
</li>
<li><p> coercing bins to numerical values, eg getting from the <code style="white-space: pre;">&#8288;[10,20)&#8288;</code>
bin the lower bound (10), the upper bound (20), the center (15) or
whatever other value of the bin,
</p>
</li>
<li><p> reducing the number of bins by merging some of them (for example
<code style="white-space: pre;">&#8288;[0,10)&#8288;</code>, <code style="white-space: pre;">&#8288;[10, 20)&#8288;</code>, <code style="white-space: pre;">&#8288;[20,30)&#8288;</code>, <code style="white-space: pre;">&#8288;[30,Inf)&#8288;</code> to <code style="white-space: pre;">&#8288;[0,20)&#8288;</code>, <code style="white-space: pre;">&#8288;[20,Inf)&#8288;</code>
</p>
</li></ul>

<p>these latter two tasks are performed using the new <code>bin</code> class
provided by this package and the accompanying <code>as_numeric</code> function
for the coercion to numeric and the <code>cut</code> method for bins
merging. Especially, coercing bins to their center values is the
basis of the computation of descripting statistics for bins.
</p>


<h3>Frequency and contingency tables</h3>

<p>The <code>freq_table</code> and <code>cont_table</code> are based on the <code>dplyr::count</code>
function but offer a much richer interface and performs easily
usual operations which are tedious to obtain with <code>dplyr::count</code> or
<code>base::table</code> functions. This includes:
</p>

<ul>
<li><p> adding a total,
</p>
</li>
<li><p> for frequency tables, computing other kind of frequencies than
the counts, for example relative frequencies, percentage,
cummulative frequencies, etc.,
</p>
</li>
<li><p> for contingency tables, computing easily the joint, marginal and
conditional distributions,
</p>
</li>
<li><p> printing easily the contingency table as a double entry table.
</p>
</li></ul>



<h3>Plotting the distribution</h3>

<p>A <code>pre_plot</code> function is provided to put the tibble in form in
order to use classic plots for univariate or bivariate
distributions. This includes histogram, frequency plot, pie chart,
cummulative plot and Lorenz curve. The final plot can then be
obtained using some geoms of <strong>ggplot2</strong>.
</p>


<h3>Descriptive statistics</h3>

<p>A full set of statistical functions (of central tendency,
dispersion, shape, concentration and covariation) are provided and
can be applied directly on objects of class <code>freq_table</code> or
<code>cont_table</code>. Some of them are methods of generics defined by the
<code>base</code> or <code>stats</code> package, some other are defined as methods for
generics function provided by the <strong>descstat</strong> function when the
corresponding <strong>R</strong> function is not generic. For example,
</p>

<ul>
<li> <p><code>mean</code> is generic, so that we wrote a
<code>mean.freq_table</code> method to compute directly the mean of a series
from a frequency table.
</p>
</li>
<li> <p><code>var</code> is not generic, so that we provide the <code>variance</code> generic
and a method for <code>freq_table</code> objects.
</p>
</li></ul>


<hr>
<h2 id='employment'>French employment survey</h2><span id='topic+employment'></span>

<h3>Description</h3>

<p>The employment survey gives information about characteristics of a
sample of individuals (employed/unemployed, part/full time job,
education, etc.).
</p>


<h3>Format</h3>

<p>a tibble containing
</p>

<ul>
<li><p> activity : a factor with levels <code>occupied</code>, <code>unemployed</code> and
<code>inactive</code>,
</p>
</li>
<li><p> time : job time a factor with levels <code>part</code>, <code>full</code> and
<code>unknown</code>,
</p>
</li>
<li><p> education : level of education,
</p>
</li>
<li><p> age : age in years,
</p>
</li>
<li><p> sex : one of <code>male</code> or <code>female</code>,
</p>
</li>
<li><p> household : kind of household, <code>single</code>, <code>monop</code> (mono-parental
family), <code>couple</code> (couple without children), <code>family</code> (couple with
families) and <code>other</code>,
</p>
</li>
<li><p> weights : weights to mimic the population.
</p>
</li></ul>



<h3>Source</h3>

<p>Employment survey 2018,
<a href="https://www.insee.fr/fr/statistiques/4191029">INSEE</a>'s
website.
</p>

<hr>
<h2 id='freq_table'>Frequency table</h2><span id='topic+freq_table'></span>

<h3>Description</h3>

<p>Compute the frequency table of a categorical or a numerical series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_table(
  data,
  x,
  f = "n",
  vals = NULL,
  weights = NULL,
  total = FALSE,
  max = NULL,
  breaks = NULL,
  right = NULL,
  xfirst = NULL,
  xlast = NULL,
  wlast = NULL,
  freq = NULL,
  mass = NULL,
  center = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_table_+3A_data">data</code></td>
<td>
<p>a tibble,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_x">x</code></td>
<td>
<p>a categorical or numerical series,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_f">f</code></td>
<td>
<p>a string containing <code>n</code> for counts, <code>f</code> for relative
frequencies, <code>p</code> for percentages and <code>m</code> for mass frequencies.
Cumulative series are obtained using the same letters in upper
caps,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_vals">vals</code></td>
<td>
<p>a character containing letters indicating the values of
the variable that should be returned; <code>x</code> for the center of the
class, <code>l</code> and <code>u</code> for the lower and upper limit of the class,
<code>a</code> for the range,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_weights">weights</code></td>
<td>
<p>a series that contain the weights that enable the
sample to mimic the population,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_total">total</code></td>
<td>
<p>a logical indicating whether the total should be
returned,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_max">max</code></td>
<td>
<p>if the series is a discrete numerical value, this
argument indicates that all the values greater than <code>max</code>
should be merged in the same modality,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_breaks">breaks</code></td>
<td>
<p>a numerical vector of class limits,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_right">right</code></td>
<td>
<p>a logical indicating whether classes should be closed
(<code>right = TRUE</code>) or open (<code>right = FALSE</code>) on the right,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_xfirst">xfirst</code>, <code id="freq_table_+3A_xlast">xlast</code>, <code id="freq_table_+3A_wlast">wlast</code></td>
<td>
<p>see <code><a href="#topic+as_numeric">as_numeric()</a></code>,</p>
</td></tr>
<tr><td><code id="freq_table_+3A_freq">freq</code></td>
<td>
<p>a series that contains the frequencies (only relevant
if <code>data</code> is already a frequency table),</p>
</td></tr>
<tr><td><code id="freq_table_+3A_mass">mass</code></td>
<td>
<p>a series that contains the masses of the variable (only
relevant if <code>data</code> is already a frequency table),</p>
</td></tr>
<tr><td><code id="freq_table_+3A_center">center</code></td>
<td>
<p>a series that contains the center of the class of the
variable (only relevant if <code>data</code> is already a frequency
table).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble containing the specified values of <code>vals</code> and
<code>f</code>.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'># in table padova, price is a numeric variable, a vector of breaks should be provided
library("dplyr")
padova %&gt;% freq_table(price,
                      breaks = c(50, 100, 150, 200, 250, 300, 350, 400),
                      right = TRUE)
# return relative frequencies and densities, and the center value
# of the series and the width of the bin
padova %&gt;% freq_table(price,
                      breaks = c(50, 100, 150, 200, 250, 300, 350, 400),
                      right = TRUE, f = "fd", vals = "xa")
# in table wages, wage is a factor that represents the classes
wages %&gt;% freq_table(wage, "d")
# a breaks argument is provided to reduce the number of classes
wages %&gt;% freq_table(wage, breaks = c(10, 20, 30, 40, 50))
# a total argument add a total to the frequency table
wages %&gt;% freq_table(wage, breaks = c(10, 20, 30, 40, 50), total = TRUE)
# ìncome is already a frequency table, the freq argument
# is mandatory
income %&gt;% freq_table(inc_class, freq = number)
# the mass argument can be indicated if on column contains the
# mass of the series in each bin. In this case, the center of the
# class are exactly the mean of the series in each bin
income %&gt;% freq_table(inc_class, freq = number, mass = tot_inc)
# rgp contains a children series which indicates the number of
# children of the households
rgp %&gt;% freq_table(children)
# a max argument can be indicated to merge the unusual high
# values of number of childre
rgp %&gt;% freq_table(children, max = 4)
# employment is a non random survey, there is a weights series
# that can be used to compute the frequency table according to the
# sum of weights and not to counts
employment %&gt;% freq_table(education)
employment %&gt;% freq_table(education, weights = weights)
</code></pre>

<hr>
<h2 id='income'>Income of French households</h2><span id='topic+income'></span>

<h3>Description</h3>

<p>Bins of income classes, number of households and mass of income.
</p>


<h3>Format</h3>

<p>a tibble containing :
</p>

<ul>
<li><p> bin: bin of income,
</p>
</li>
<li><p> number: number of households in the bin,
</p>
</li>
<li><p> income: mass of income in the bin.
</p>
</li></ul>



<h3>Source</h3>

<p>Impot sur le revenu par commune (IRCOM)
<a href="https://www.impots.gouv.fr/portail/statistiques">DGI</a>'s
website.
</p>

<hr>
<h2 id='padova'>Housing prices in Padova</h2><span id='topic+padova'></span>

<h3>Description</h3>

<p>This data set documents characteristics (including the prices) of a
sample of housings in Padova.
</p>


<h3>Format</h3>

<p>a tibble containing
</p>

<ul>
<li><p> zone : one of the 12 zones of Padova,
</p>
</li>
<li><p> condition : <code>new</code> for new housings, <code>ordinary</code> or <code>good</code> for old ones,
</p>
</li>
<li><p> house : dummy for houses,
</p>
</li>
<li><p> floor : floor,
</p>
</li>
<li><p> rooms : number of rooms,
</p>
</li>
<li><p> bathrooms : number of bathrooms,
</p>
</li>
<li><p> parking : dummy for parkings,
</p>
</li>
<li><p> energy : energy cathegory for the house (A for the best, G for the worst),
</p>
</li>
<li><p> area : area of the house in square meters,
</p>
</li>
<li><p> price : price of the house in thousands of euros.
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://www.sciencedirect.com/science/article/pii/S2352340915003224">Data in Brief</a>'s website.
</p>


<h3>References</h3>

<p>Bonifaci P, Copiello S
(2015). &quot;Real estate market and building energy performance: Data for a mass appraisal approach.&quot;
<em>Data in Brief</em>, <em>5</em>, 1060-1065. ISSN 2352-3409.
</p>

<hr>
<h2 id='pre_plot'>Put a tibble in form to plot</h2><span id='topic+pre_plot'></span><span id='topic+pre_plot.freq_table'></span><span id='topic+pre_plot.cont_table'></span>

<h3>Description</h3>

<p>Convert a tibble built using <code>freq_table</code> or <code>cont_table</code> in a
shape that makes it easy to plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_plot(data, f = NULL, plot = NULL, ...)

## S3 method for class 'freq_table'
pre_plot(
  data,
  f = NULL,
  plot = c("histogram", "freqpoly", "lorenz", "stacked", "cumulative"),
  ...
)

## S3 method for class 'cont_table'
pre_plot(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pre_plot_+3A_data">data</code></td>
<td>
<p>a tibble returned by the <code>freq_table</code> or the
<code>cont_table</code> function, which should contain the center of the
classes (<code>x</code>) and at least one measure of the frequencies or
densities (one of <code>f</code>, <code>n</code>, <code>p</code>, <code>d</code>),</p>
</td></tr>
<tr><td><code id="pre_plot_+3A_f">f</code></td>
<td>
<p>mandatory argument if the tibble contains more than one
frequency or density,</p>
</td></tr>
<tr><td><code id="pre_plot_+3A_plot">plot</code></td>
<td>
<p>for object of class <code>freq_table</code> one of <code>histogram</code>,
<code>freqpoly</code>, <code>stacked</code>, <code>cumulative</code> and <code>lorenz</code> (see the
details section),</p>
</td></tr>
<tr><td><code id="pre_plot_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pre_plot</code> function returns a tibble containing:
</p>

<ul>
<li><p> if <code>plot = histogram</code>, <code>x</code>, <code>y</code> that should be
passed to <code>geom_polygon</code>,
</p>
</li>
<li><p> if <code>plot = freqpoly</code> <code>x</code> and <code>y</code> that should be passed to <code>geom_line</code>,
</p>
</li>
<li><p> if <code>plot = stacked</code> <code>x</code> and <code>ypos</code> that should be passed
respectively to <code>geom_col</code> and to <code>geom_text</code> to draw labels on
the right position,
</p>
</li>
<li><p> if <code>plot = cumulative</code> <code>x</code>, <code>y</code>, <code>xend</code> and <code>yend</code> that should be passed to
<code>geom_segment</code>,
</p>
</li>
<li><p> if <code>plot = lorenz</code> for the Lorenz curve, <code>F</code> and <code>M</code> for the
coordinates of the polygons under the Lorenz curve, <code>pts</code> is
logical which the defines the subset of points that belongs to the
Lorenz curve.
</p>
</li></ul>



<h3>Value</h3>

<p>a tibble
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
library("ggplot2")
pad &lt;- padova %&gt;%
       freq_table(price, breaks = c(100, 200, 300, 400, 500, 1000),
       right = TRUE, f = "Npd")
pad %&gt;% pre_plot(f = "d") %&gt;% ggplot() + geom_polygon(aes(x, y))
pad %&gt;% pre_plot(f = "d", plot = "freqpoly") %&gt;%
ggplot() + geom_line(aes(x, y))
## A pie chart
wages %&gt;% freq_table(sector, "p", total = FALSE) %&gt;%
  pre_plot("p", plot = "stacked") %&gt;% ggplot(aes(x = 2, y = p, fill = sector)) +
  geom_col() + geom_text(aes(y = ypos, label = sector)) +
  coord_polar(theta = "y") + theme_void() + guides(fill = FALSE)

</code></pre>

<hr>
<h2 id='print_method'>Print methods for bin, freq_table and cont_table objects</h2><span id='topic+print_method'></span><span id='topic+pre_print'></span><span id='topic+pre_print.freq_table'></span><span id='topic+pre_print.cont_table'></span><span id='topic+format.freq_table'></span><span id='topic+format.cont_table'></span><span id='topic+print.cont_table'></span><span id='topic+print.bin'></span>

<h3>Description</h3>

<p><code>freq_table</code> and <code>cont_table</code> are tibbles with specific format and
print methods for pretty printing. A <code>pre_print</code> generic is
provided with specific methods to put in form <code>freq_table</code> and
<code>cont_table</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_print(x, ...)

## S3 method for class 'freq_table'
pre_print(x, ...)

## S3 method for class 'cont_table'
pre_print(x, ..., row_name = TRUE, total_name = "Total")

## S3 method for class 'freq_table'
format(x, ..., n = NULL, width = NULL, n_extra = NULL)

## S3 method for class 'cont_table'
format(
  x,
  ...,
  n = NULL,
  width = NULL,
  n_extra = NULL,
  row_name = TRUE,
  total_name = "Total"
)

## S3 method for class 'cont_table'
print(
  x,
  ...,
  n = NULL,
  width = NULL,
  n_extra = NULL,
  row_name = TRUE,
  total_name = "Total"
)

## S3 method for class 'bin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_method_+3A_x">x</code></td>
<td>
<p>a <code>bin</code>, a <code>freq_table</code> or a <code>cont_table</code> object,</p>
</td></tr>
<tr><td><code id="print_method_+3A_...">...</code></td>
<td>
<p>further arguments,</p>
</td></tr>
<tr><td><code id="print_method_+3A_row_name">row_name</code></td>
<td>
<p>a logical that indicates whether the first column
in the two-ways contingency table, that contains the levels of
the first series, should be named,</p>
</td></tr>
<tr><td><code id="print_method_+3A_total_name">total_name</code></td>
<td>
<p>the name of the line (and of the column for
<code>cont_table</code>) that contains the total (default is <code>"Total"</code>),</p>
</td></tr>
<tr><td><code id="print_method_+3A_n">n</code>, <code id="print_method_+3A_width">width</code>, <code id="print_method_+3A_n_extra">n_extra</code></td>
<td>
<p>see <a href="tibble.html#topic+formatting">tibble::formatting</a> and
<a href="tibble.html#topic+formatting">tibble::formatting</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble, for the <code>cont_table</code> it is a tibble in wide
format as the <code>cont_table</code> object is in long format.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+extract'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+extract">extract</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rgp'>Extract of the French census</h2><span id='topic+rgp'></span>

<h3>Description</h3>

<p>This extract of the French census gives information about a sample
of French households.
</p>


<h3>Format</h3>

<p>a tibble containing :
</p>

<ul>
<li><p> cars : number of cars,
</p>
</li>
<li><p> rooms : number of rooms of the housing,
</p>
</li>
<li><p> children : number of children,
</p>
</li>
<li><p> type : type of household ; <code>couple</code> or <code>monop</code> (for mono-parental families),
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://www.insee.fr/fr/statistiques/4507685?sommaire=4508161">INSEE</a>'s
website.
</p>

<hr>
<h2 id='univariate'>Functions to compute statistics on univariate distributions</h2><span id='topic+univariate'></span><span id='topic+variance'></span><span id='topic+gmean'></span><span id='topic+gini'></span><span id='topic+stdev'></span><span id='topic+madev'></span><span id='topic+modval'></span><span id='topic+medial'></span><span id='topic+kurtosis'></span><span id='topic+skewness'></span><span id='topic+variance.default'></span><span id='topic+gmean.default'></span><span id='topic+stdev.default'></span><span id='topic+madev.default'></span><span id='topic+skewness.default'></span><span id='topic+kurtosis.default'></span><span id='topic+mean.freq_table'></span><span id='topic+gmean.freq_table'></span><span id='topic+variance.freq_table'></span><span id='topic+stdev.freq_table'></span><span id='topic+skewness.freq_table'></span><span id='topic+kurtosis.freq_table'></span><span id='topic+madev.freq_table'></span><span id='topic+modval.freq_table'></span><span id='topic+quantile.freq_table'></span><span id='topic+median.freq_table'></span><span id='topic+medial.freq_table'></span><span id='topic+gini.freq_table'></span><span id='topic+modval.cont_table'></span><span id='topic+gini.cont_table'></span><span id='topic+skewness.cont_table'></span><span id='topic+kurtosis.cont_table'></span><span id='topic+madev.cont_table'></span><span id='topic+mean.cont_table'></span><span id='topic+variance.cont_table'></span><span id='topic+stdev.cont_table'></span>

<h3>Description</h3>

<p><strong>descstat</strong> provide functions to compute statistics on an
univariate distribution. This includes central tendency,
dispersion, shape and concentration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variance(x, ...)

gmean(x, r = 1, ...)

gini(x, ...)

stdev(x, ...)

madev(x, ...)

modval(x, ...)

medial(x, ...)

kurtosis(x, ...)

skewness(x, ...)

## Default S3 method:
variance(x, w = NULL, ...)

## Default S3 method:
gmean(x, r = 1, ...)

## Default S3 method:
stdev(x, w = NULL, ...)

## Default S3 method:
madev(x, w = NULL, center = c("median", "mean"), ...)

## Default S3 method:
skewness(x, ...)

## Default S3 method:
kurtosis(x, ...)

## S3 method for class 'freq_table'
mean(x, ...)

## S3 method for class 'freq_table'
gmean(x, r = 1, ...)

## S3 method for class 'freq_table'
variance(x, ...)

## S3 method for class 'freq_table'
stdev(x, ...)

## S3 method for class 'freq_table'
skewness(x, ...)

## S3 method for class 'freq_table'
kurtosis(x, ...)

## S3 method for class 'freq_table'
madev(x, center = c("median", "mean"), ...)

## S3 method for class 'freq_table'
modval(x, ...)

## S3 method for class 'freq_table'
quantile(x, y = c("value", "mass"), probs = c(0.25, 0.5, 0.75), ...)

## S3 method for class 'freq_table'
median(x, ..., y = c("value", "mass"))

## S3 method for class 'freq_table'
medial(x, ...)

## S3 method for class 'freq_table'
gini(x, ...)

## S3 method for class 'cont_table'
modval(x, ...)

## S3 method for class 'cont_table'
gini(x, ...)

## S3 method for class 'cont_table'
skewness(x, ...)

## S3 method for class 'cont_table'
kurtosis(x, ...)

## S3 method for class 'cont_table'
madev(x, center = c("median", "mean"), ...)

## S3 method for class 'cont_table'
mean(x, ...)

## S3 method for class 'cont_table'
variance(x, ...)

## S3 method for class 'cont_table'
stdev(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="univariate_+3A_x">x</code></td>
<td>
<p>a series or a <code>freq_table</code> or a <code>cont_table</code> object,</p>
</td></tr>
<tr><td><code id="univariate_+3A_...">...</code></td>
<td>
<p>further arguments,</p>
</td></tr>
<tr><td><code id="univariate_+3A_r">r</code></td>
<td>
<p>the order of the mean for the <code>gmean</code> function,</p>
</td></tr>
<tr><td><code id="univariate_+3A_w">w</code></td>
<td>
<p>a vector of weights,</p>
</td></tr>
<tr><td><code id="univariate_+3A_center">center</code></td>
<td>
<p>the center value used to compute the mean absolute
deviations, one of <code>"median"</code> or <code>"mean"</code>,</p>
</td></tr>
<tr><td><code id="univariate_+3A_y">y</code></td>
<td>
<p>for the quantile method, one of <code>"value"</code> or <code>"mass"</code>,</p>
</td></tr>
<tr><td><code id="univariate_+3A_probs">probs</code></td>
<td>
<p>the probabilities for which the quantiles have to be
computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions are provided:
</p>

<ul>
<li><p> central tendency: <code>mean</code>, <code>median</code>, <code>medial</code>, <code>modval</code> (for the mode),
</p>
</li>
<li><p> dispersion: <code>variance</code>, <code>stdev</code>, <code>maddev</code> (for mean absolute
deviation) and quantile,
</p>
</li>
<li><p> shape: <code>skewness</code> and <code>kurtosis</code>,
</p>
</li>
<li><p> concentration: <code>gini</code>.
</p>
</li></ul>

<p>When a generic function exists in base <strong>R</strong> (or in the <code>stats</code>
package), methods are provided for <code>freq_table</code> or <code>cont_table</code>,
this is a case for <code>mean</code>, <code>median</code> and <code>quantile</code>. When a function
exists, but is not generic, we provide a generic and relevant
methods using different names (<code>stdev</code>, <code>variance</code> and <code>madev</code>
instead respectively of <code>sd</code>, <code>var</code> and <code>mad</code>). Finally some
function don't exist in base <strong>R</strong> and recommended packages, we
therefore provide a <code>modval</code> function to compute the mode, <code>gini</code>
for the Gini concentration index, <code>skewness</code> and <code>kurtosis</code> for
Fisher's shape statistics and <code>gmean</code> for generalized means (which
include the geometric, the quadratic and the harmonic means).
</p>
<p><code>madev</code> has a center argument which indicates whether the
deviations should be computed respective to the mean or to the
median.
</p>
<p><code>gmean</code> has a <code>r</code> argument: values of -1, 0, 1 and 2 lead
respectively to the harmonic, geometric, arithmetic and quadratic
means.
</p>


<h3>Value</h3>

<p>a numeric or a tibble.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
z &lt;- wages %&gt;% freq_table(wage)
z %&gt;% median
# the medial is the 0.5 quantile of the mass of the distribution
z %&gt;% medial
# the modval function returns the mode, it is a one line tibble
z %&gt;% modval
z %&gt;% quantile(probs = c(0.25, 0.5, 0.75))
# quantiles can compute for the frequency (the default) or the mass
# of the series
z %&gt;% quantile(y = "mass", probs = c(0.25, 0.5, 0.75))
# univariate statistics can be computed on the joint, marginal or
# conditional distributions for cont_table objects
wages %&gt;% cont_table(wage, size) %&gt;% joint
wages %&gt;% cont_table(wage, size) %&gt;% marginal(size) %&gt;% mean
wages %&gt;% cont_table(wage, size) %&gt;% conditional(size) %&gt;% mean

</code></pre>

<hr>
<h2 id='wages'>DADS survey</h2><span id='topic+wages'></span>

<h3>Description</h3>

<p>The DADS survey (Declaration Annuelle des Données Sociales)
provides characteristics of wage earners (wages in class, number
of working hours, etc.).
</p>


<h3>Format</h3>

<p>a tibble containing
</p>

<ul>
<li><p> sector : activity sector, <code>industry</code>, <code>building</code>, <code>business</code>,
<code>services</code> and <code>administration</code>,
</p>
</li>
<li><p> age :  the age in years,
</p>
</li>
<li><p> hours : annual number of hours worked,
</p>
</li>
<li><p> sex : sex of the wage earner, <code>male</code> or <code>female</code>,
</p>
</li>
<li><p> wage : class of yearly wages, in thousands of euros,
</p>
</li>
<li><p> size : class of working force size of the firm.
</p>
</li></ul>



<h3>Source</h3>

<p>DADS survey 2015,
<a href="https://www.insee.fr/fr/statistiques/3536754">INSEE</a>'s
website.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
