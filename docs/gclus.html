<!DOCTYPE html><html><head><title>Help for package gclus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gclus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ac'><p> Clustering coefficients from package cluster.</p></a></li>
<li><a href='#bank'><p>Swiss bank notes data</p></a></li>
<li><a href='#body'><p>Exploring Relationships in Body Dimensions</p></a></li>
<li><a href='#colpairs'><p> Applies a function to all pairs of columns</p></a></li>
<li><a href='#cpairs'><p> Enhanced scatterplot matrix</p></a></li>
<li><a href='#cparcoord'><p>Enhanced parallel coordinate plot</p></a></li>
<li><a href='#diameter'><p> Cluster heterogeneity of 2-d data</p></a></li>
<li><a href='#dmat.color'><p> Colors a symmetric matrix</p></a></li>
<li><a href='#order.clusters'><p>Orders clustered objects using hierarchical clustering</p></a></li>
<li><a href='#order.single'><p>Orders objects using hierarchical clustering</p></a></li>
<li><a href='#ozone'><p>Ozone data from Breiman and Friedman, 1985</p></a></li>
<li><a href='#partition.crit'><p> Combines the results of appplying an index to each group of</p>
observations</a></li>
<li><a href='#pclen'><p> Profile smoothness measures</p></a></li>
<li><a href='#plotcolors'><p>Plots a matrix of colors</p></a></li>
<li><a href='#reorder.hclust'><p>Reorders object order of hclust, keeping objects within a cluster</p>
contiguous to each other.</a></li>
<li><a href='#vec2distm'><p> Various utility functions</p></a></li>
<li><a href='#wine'><p>Wine recognition data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Catherine Hurley</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-01-07</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Catherine Hurley &lt;catherine.hurley@mu.ie&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering Graphics</td>
</tr>
<tr>
<td>Description:</td>
<td>Orders panels in scatterplot matrices and parallel coordinate
 displays by some merit index. Package contains various indices of merit,
 ordering functions, and enhanced versions of pairs and parcoord which
 color panels according to their merit level.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), cluster</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-01-07 17:20:54 UTC; catherine</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-01-07 20:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='ac'> Clustering coefficients from package cluster.</h2><span id='topic+ac'></span><span id='topic+sil'></span>

<h3>Description</h3>

<p>Computes clustering coefficients from <code>cluster</code>,
where <code>x</code> and  <code>y</code> give the object coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ac(x, y, ...)
sil(x, y, groups, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ac_+3A_x">x</code></td>
<td>
<p>is a numeric vector. </p>
</td></tr>
<tr><td><code id="ac_+3A_y">y</code></td>
<td>
<p>is a numeric vector. </p>
</td></tr>
<tr><td><code id="ac_+3A_groups">groups</code></td>
<td>
<p>is a vector of group memberships, used by <code>sil</code> only.</p>
</td></tr>
<tr><td><code id="ac_+3A_...">...</code></td>
<td>
<p>are passed to <code>agnes</code> in <code>ac</code> and to <code>dist</code> 
in <code>sil</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ac</code> - Computes clustering coefficient from <code>agnes{cluster}</code>.
</p>
<p><code>sil</code> - Computes the silhouette coefficient from from package 
<code>cluster</code>.
</p>


<h3>Value</h3>

<p>The clustering coefficient is returned.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley</p>


<h3>References</h3>

<p> Kaufman, L. and Rousseeuw, P.J. (1990). Finding Groups in Data: An Introduction to Cluster Analysis . Wiley, New York.  </p>


<h3>See Also</h3>

  <p><code><a href="cluster.html#topic+agnes">agnes</a></code>, <code><a href="cluster.html#topic+silhouette">silhouette</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>.  </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
y &lt;- runif(20)
g &lt;- rep(c("a","b"),10)

ac(x,y)
sil(x,y,g)
</code></pre>

<hr>
<h2 id='bank'>Swiss bank notes data</h2><span id='topic+bank'></span>

<h3>Description</h3>

<p>Data from &quot;Multivariate Statistics  A practical approach&quot;, by
Bernhard Flury and Hans Riedwyl, Chapman and Hall, 1988,
Tables 1.1 and 1.2 pp. 5-8.  Six measurements made on 100 genuine
Swiss banknotes and 100 counterfeit ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bank)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Status:</dt><dd><p>0 = genuine, 1 = counterfeit</p>
</dd>
<dt>Length:</dt><dd><p>Length of bill, mm</p>
</dd>
<dt>Left:</dt><dd><p> Width of left edge, mm</p>
</dd>
<dt>Right:</dt><dd><p>Width of right edge, mm</p>
</dd>
<dt>Bottom:</dt><dd><p>Bottom margin width, mm </p>
</dd>
<dt>Top:</dt><dd><p>Top margin width, mm</p>
</dd>
<dt>Diagonal:</dt><dd><p> Length of image diagonal, mm</p>
</dd>    
</dl>



<h3>Source</h3>

<p>Flury, B. and Riedwyl, H. (1988), 
<em>Multivariate Statistics  A Practical Approach</em>,
London: Chapman and Hall.
</p>

<hr>
<h2 id='body'>Exploring Relationships in Body Dimensions</h2><span id='topic+body'></span>

<h3>Description</h3>

<p>This dataset contains 21 body dimension measurements as well as age, 
weight, height, and gender on 507 individuals. The 247 men and 260 
women were primarily individuals in their twenties and thirties, with a 
scattering of older men and women, all exercising several hours a week.
</p>
<p>Measurements were initially taken by Grete 
Heinz and Louis J. Peterson - at San Jose State University and at the 
U.S. Naval Postgraduate School in Monterey, California. Later, 
measurements were taken at dozens of California health and fitness 
clubs by technicians under the supervision of one of these authors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(body)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Biacrom:</dt><dd><p>Biacromial diameter (cm)</p>
</dd>
<dt>Biiliac:</dt><dd><p>Biiliac diameter, or &quot;pelvic breadth&quot; (cm)</p>
</dd>
<dt>Bitro:</dt><dd><p>Bitrochanteric diameter (cm)</p>
</dd>
<dt>ChestDp:</dt><dd><p>Chest depth between spine and sternum at nipple level, 
mid-expiration (cm)</p>
</dd>
<dt>ChestD:</dt><dd><p>Chest diameter at nipple level, mid-expiration (cm)</p>
</dd>
<dt>ElbowD:</dt><dd><p>Elbow diameter, sum of two elbows (cm)</p>
</dd>
<dt>WristD:</dt><dd><p>Wrist diameter, sum of two wrists (cm)</p>
</dd>
<dt>KneeD:</dt><dd><p>Knee diameter, sum of two knees (cm)</p>
</dd>
<dt>AnkleD:</dt><dd><p>Ankle diameter, sum of two ankles (cm)</p>
</dd>
<dt>ShoulderG:</dt><dd><p>Shoulder girth over deltoid muscles (cm)</p>
</dd>
<dt>ChestG:</dt><dd><p>Chest girth, nipple line in males and just above breast 
tissue in females, mid-expiration (cm)</p>
</dd>
<dt>WaistG:</dt><dd><p>Waist girth, narrowest part of torso below the rib cage, 
average of contracted and relaxed position (cm)</p>
</dd>
<dt>AbdG:</dt><dd><p>Navel (or &quot;Abdominal&quot;) girth at umbilicus and iliac crest, 
iliac crest as a landmark (cm)</p>
</dd>
<dt>HipG:</dt><dd><p>Hip girth at level of bitrochanteric diameter (cm)</p>
</dd>
<dt>ThighG:</dt><dd><p>Thigh girth below gluteal fold, average of right and left 
girths (cm)</p>
</dd>
<dt>BicepG:</dt><dd><p>Bicep girth, flexed, average of right and left girths (cm)</p>
</dd>
<dt>ForearmG:</dt><dd><p>Forearm girth, extended, palm up, average of right and 
left girths (cm)</p>
</dd>
<dt>KneeG:</dt><dd><p>Knee girth over patella, slightly flexed position, average 
of right and left girths (cm)</p>
</dd>
<dt>CalfG:</dt><dd><p>Calf maximum girth, average of right and left girths (cm)</p>
</dd>
<dt>AnkleG:</dt><dd><p>Ankle minimum girth, average of right and left girths
(cm)</p>
</dd>
<dt>WristG:</dt><dd><p>Wrist minimum girth, average of right and left girths (cm)</p>
</dd>
<dt>Age:</dt><dd><p>in years</p>
</dd>
<dt>Weight:</dt><dd><p>in kg</p>
</dd>
<dt>Height:</dt><dd><p>in cm</p>
</dd>
<dt>Gender:</dt><dd><p>1 - male, 0 - female</p>
</dd>
</dl>


<h3>Source</h3>

<p>Heinz, G., Peterson, L.J., Johnson, R.W. and Kerk, C.J. (2003),
&ldquo;Exploring Relationships in Body Dimensions&rdquo;,
<em>Journal of Statistics Education </em>, 11.
</p>


<h3>References</h3>

<p>The data file is taken from 
<a href="http://jse.amstat.org/datasets/body.dat.txt">http://jse.amstat.org/datasets/body.dat.txt</a>
This information file is based on
<a href="http://jse.amstat.org/datasets/body.txt">http://jse.amstat.org/datasets/body.txt</a>
</p>

<hr>
<h2 id='colpairs'> Applies a function to all pairs of columns </h2><span id='topic+colpairs'></span>

<h3>Description</h3>

<p>Given an nxp matrix <code>m</code> and a function <code>f</code>,
returns the pxp matrix got by applying <code>f</code>  to all pairs of columns of <code>m</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colpairs(m, f, diag = 0, na.omit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colpairs_+3A_m">m</code></td>
<td>
<p> a matrix </p>
</td></tr>
<tr><td><code id="colpairs_+3A_f">f</code></td>
<td>
<p> a function of two vectors, which returns a single result. </p>
</td></tr>
<tr><td><code id="colpairs_+3A_diag">diag</code></td>
<td>
<p> if supplied, this value is placed on the diagonal of the
result. </p>
</td></tr>
<tr><td><code id="colpairs_+3A_na.omit">na.omit</code></td>
<td>
<p> If <code>TRUE</code>, rows with missing values are omitted for each pair
of columns. </p>
</td></tr>
<tr><td><code id="colpairs_+3A_...">...</code></td>
<td>
<p> argments are passed to <code>f</code>. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix matrix got by applying <code>f</code>  to all pairs of columns of <code>m</code> .
</p>


<h3>Author(s)</h3>

<p>Catherine B. Hurley </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gave">gave</a></code>, <code><a href="#topic+partition.crit">partition.crit</a></code>, 
<code><a href="#topic+order.single">order.single</a></code>,<code><a href="#topic+order.endlink">order.endlink</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state)
state.m &lt;- colpairs(state.x77, 
function(x,y)  cor.test(x,y,"two.sided","kendall")$estimate, diag=1)
state.col &lt;- dmat.color(state.m)
# This is equivalent to state.m &lt;- cor(state.x77,method="kendall")


layout(matrix(1:2,nrow=1,ncol=2))
cparcoord(state.x77, panel.color= state.col)
# Get rid of the panels with lots of line crossings (yellow) by reorderings
cparcoord(state.x77, order.endlink(state.m), state.col)
layout(matrix(1,1))


# m is a homogeneity measure of each pairwise variable plot
m &lt;- -colpairs(scale(state.x77), gave)

o&lt;- order.single(m)
pcols = dmat.color(m)
# Color panels by level of m and reorder variables so that
# pairs with high m are near the diagonal.
cpairs(state.x77,order=o, panel.colors=pcols)

# In this case panels showing either of Area or Population
# exhibit the most clumpiness because these variables
# are skewed.

</code></pre>

<hr>
<h2 id='cpairs'> Enhanced scatterplot matrix </h2><span id='topic+cpairs'></span>

<h3>Description</h3>

<p>This function draws a scatterplot matrix of data. Variables
may be reordered and panels colored in the display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpairs(data, order = NULL, panel.colors = NULL, border.color = "grey70", 
show.points = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpairs_+3A_data">data</code></td>
<td>
<p>a numeric matrix </p>
</td></tr>
<tr><td><code id="cpairs_+3A_order">order</code></td>
<td>
<p>the order of variables. Default is the order in data.</p>
</td></tr>
<tr><td><code id="cpairs_+3A_panel.colors">panel.colors</code></td>
<td>
<p>a matrix of panel colors. If supplied, dimensions 
should match those of the pairs plot. Diagonal entries are ignored. </p>
</td></tr>
<tr><td><code id="cpairs_+3A_border.color">border.color</code></td>
<td>
<p>used for panel border. </p>
</td></tr>
<tr><td><code id="cpairs_+3A_show.points">show.points</code></td>
<td>
<p> If FALSE, no points are drawn. </p>
</td></tr>
<tr><td><code id="cpairs_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code>pairs.default</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Catherine B. Hurley </p>


<h3>References</h3>

<p>Hurley, Catherine B.  &ldquo;Clustering Visualisations of Multidimensional 
Data&rdquo;, to appear in JCGS. </p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pairs">pairs</a></code>, <code><a href="#topic+cparcoord">cparcoord</a></code>, 
<code><a href="#topic+dmat.color">dmat.color</a></code>,<code><a href="#topic+colpairs">colpairs</a></code>, <code><a href="#topic+order.single">order.single</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(USJudgeRatings)
judge.cor &lt;- cor(USJudgeRatings)
judge.color &lt;- dmat.color(judge.cor)
# Colors variables by their correlation.
cpairs(USJudgeRatings,panel.colors=judge.color,pch=".",gap=.5)
judge.o &lt;- order.single(judge.cor)
# Reorder variables so that those with highest correlation 
# are close to the  diagonal.
cpairs(USJudgeRatings,judge.o,judge.color,pch=".",gap=.5)

# Specify your own color scheme
judge.color &lt;- dmat.color(judge.cor, breaks=c(-1,0,.5,.9,1), colors = 
cm.colors(4))

data(bank)
# m is a homogeneity measure of each pairwise variable plot
m &lt;- -colpairs(scale(bank[,-1]), partition.crit,gfun=gave,groups=bank[,1])

# Color panels by level of m and reorder variables so that
# pairs with high m are near the diagonal. Panels shown
# in pink have the highest amount of group homogeneity, as measured by 
# gave.
cpairs(bank[,-1],order=order.single(m), panel.colors=dmat.color(m),
gap=.3,col=c("purple","black")[bank[,"Status"]+1],
pch=c(5,3)[bank[,"Status"]+1])

</code></pre>

<hr>
<h2 id='cparcoord'>Enhanced parallel coordinate plot </h2><span id='topic+cparcoord'></span>

<h3>Description</h3>

<p>This function draws a parallel coordinate plot of data. Variables
may be reordered and panels colored in the display. It is a modified
version of <code>parcoord {MASS}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cparcoord(data, order = NULL, panel.colors = NULL, col = 1, lty = 1, 
horizontal = FALSE, mar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cparcoord_+3A_data">data</code></td>
<td>
<p>a numeric matrix </p>
</td></tr>
<tr><td><code id="cparcoord_+3A_order">order</code></td>
<td>
<p>the order of variables. Default is the order in data.</p>
</td></tr>
<tr><td><code id="cparcoord_+3A_panel.colors">panel.colors</code></td>
<td>
<p>either a vector or a matrix of panel colors. If a 
vector is supplied, the ith color is used for the ith panel. If a matrix, dimensions 
should match those of the variables. Diagonal entries are ignored. </p>
</td></tr>
<tr><td><code id="cparcoord_+3A_col">col</code></td>
<td>
<p> a vector of colours, recycled as necessary for each observation.  </p>
</td></tr>
<tr><td><code id="cparcoord_+3A_lty">lty</code></td>
<td>
<p> a vector of line types, 
recycled as necessary for each observation.  </p>
</td></tr>
<tr><td><code id="cparcoord_+3A_horizontal">horizontal</code></td>
<td>
<p> If TRUE, orientation is horizontal. </p>
</td></tr>
<tr><td><code id="cparcoord_+3A_mar">mar</code></td>
<td>
<p> margin parameters, passed to <code>par</code>. </p>
</td></tr>
<tr><td><code id="cparcoord_+3A_...">...</code></td>
<td>
<p> graphics parameters which are passed to matplot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>panel.colors</code> is a matrix and <code>order</code> is supplied, <code>panel.colors</code> is 
reordered.</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley </p>


<h3>References</h3>

<p>Hurley, Catherine B.  &ldquo;Clustering Visualisations of Multidimensional 
Data&rdquo;, Journal of Computational and Graphical Statistics,
vol. 13, (4), pp 788-806, 2004. </p>


<h3>See Also</h3>

<p><code><a href="#topic+cpairs">cpairs</a></code>, <code><a href="MASS.html#topic+parcoord">parcoord</a></code>,
<code><a href="#topic+dmat.color">dmat.color</a></code>, <code><a href="#topic+colpairs">colpairs</a></code>, <code><a href="#topic+order.endlink">order.endlink</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state)
state.m &lt;- colpairs(state.x77, 
function(x,y)  cor.test(x,y,"two.sided","kendall")$estimate, diag=1)
# OR, Works only in R1.8,  state.m &lt;-cor(state.x77,method="kendall")  


state.col &lt;- dmat.color(state.m)

cparcoord(state.x77, panel.color= state.col)
# Get rid of the panels with lots of line crossings (yellow) by reordering:
cparcoord(state.x77, order.endlink(state.m), state.col)

# To get rid of the panels with lots of long line segments:
#  use a different panel merit measure- pclen:

mins &lt;- apply(state.x77,2,min)
ranges &lt;- apply(state.x77,2,max) - mins
state.m &lt;- -colpairs(scale(state.x77,mins,ranges), pclen)
cparcoord(state.x77, order.endlink(state.m), dmat.color(state.m))



</code></pre>

<hr>
<h2 id='diameter'> Cluster heterogeneity of 2-d data </h2><span id='topic+diameter'></span><span id='topic+star'></span><span id='topic+km2'></span><span id='topic+gtot'></span><span id='topic+gave'></span>

<h3>Description</h3>

<p>Computes measures of cluster heterogeneity of 2-d data,
where <code>x</code> and  <code>y</code> give the object coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diameter(x, y, ...)
star(x, y, ...)
km2(x,y)
gtot(x,y, ...)
gave(x,y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diameter_+3A_x">x</code></td>
<td>
<p>is a numeric vector. </p>
</td></tr>
<tr><td><code id="diameter_+3A_y">y</code></td>
<td>
<p>is a numeric vector. </p>
</td></tr>
<tr><td><code id="diameter_+3A_...">...</code></td>
<td>
<p>are passed to <code>dist</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>diameter</code> computes the cluster diameter- the maximum distance
between objects. 
</p>
<p><code>star</code> computes the cluster star distance- the smallest
total distance from one object to another.
</p>
<p><code>km2</code> computes the kmeans distance.
</p>
<p><code>gtot</code> computes the sum of all inter-object distances.
</p>
<p><code>gave</code> computes the per-object average of all 
inter-object distances.
</p>


<h3>Value</h3>

<p>The cluster measure is returned.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley</p>


<h3>References</h3>

<p> See Gordon, A. D. (1999).&ldquo;Classification&rdquo;. Second Edition. London:
Chapman and Hall / CRC </p>


<h3>See Also</h3>

 <p><code><a href="#topic+colpairs">colpairs</a></code>, <code><a href="#topic+cpairs">cpairs</a></code>, <code><a href="#topic+order.single">order.single</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
y &lt;- runif(20)
diameter(x,y)
</code></pre>

<hr>
<h2 id='dmat.color'> Colors a symmetric matrix</h2><span id='topic+dmat.color'></span><span id='topic+default.dmat.color'></span>

<h3>Description</h3>

<p>Accepts a dissimilarity matrix or <code>dist</code> <code>m</code>, and
returns a  matrix of colors.
Values in <code>m</code> are <code>cut</code> into categories using <code>breaks</code> (ranked distances if 
<code>byrank</code> is <code>TRUE</code>) and categories  are assigned the values 
in <code>colors</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmat.color(m, colors = default.dmat.color, byrank = NULL, breaks = length(colors))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmat.color_+3A_m">m</code></td>
<td>
<p>a dissimilarity matrix or the result of <code>dist</code></p>
</td></tr>
<tr><td><code id="dmat.color_+3A_colors">colors</code></td>
<td>
<p>a vector of colors. The default is 
<code>default.dmat.color</code>.</p>
</td></tr>
<tr><td><code id="dmat.color_+3A_byrank">byrank</code></td>
<td>
<p>boolean, default <code>TRUE</code> is unless <code>breaks</code> 
has length &gt; 1.</p>
</td></tr>
<tr><td><code id="dmat.color_+3A_breaks">breaks</code></td>
<td>
<p>the number of break points. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>breaks</code> are passed to the  function<code>cut</code>.
If <code>byrank</code> is <code>TRUE</code>, values in <code>m</code> are 
ranked before they are categorized. 
If <code>byrank</code> is <code>TRUE</code> and <code>breaks</code> is an integer, then
there are <code>breaks</code> equal-sized categories.</p>


<h3>Value</h3>

<p>Returns a matrix of colors. The matrix is symmetric, with NAs on the 
diagonal.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+cut">cut</a></code>, <code><a href="#topic+cpairs">cpairs</a></code>, <code><a href="#topic+cparcoord">cparcoord</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(longley)
longley.cor &lt;- cor(longley)
# A matrix with equal (or nearly equal) number of entries of each color.
longley.color &lt;- dmat.color(longley.cor)

# Plot the colors
plotcolors(longley.color,dlabels=rownames(longley.color))

# Try different color schemes

# A matrix where each color represents an equal-length interval.
longley.color &lt;- dmat.color(longley.cor, byrank=FALSE)
# Specify colors and breaks

longley.color &lt;- dmat.color(longley.cor, breaks=c(-1,0,.5,.8,1), 
cm.colors(4))


# Could also reorder variables prior to plotting:

longley.o &lt;- order.single(longley.cor)
longley.color &lt;- longley.color[longley.o,longley.o]

# The colors can be used in a scatterplot matrix or parallel
# coordinate display:

cpairs(longley, panel.color= longley.color)
cparcoord(longley, panel.color= longley.color)

</code></pre>

<hr>
<h2 id='order.clusters'>Orders clustered objects using hierarchical clustering</h2><span id='topic+order.clusters'></span>

<h3>Description</h3>

<p>Reorders objects so that  similar (or high-merit) object pairs are adjacent.
The clusters argument specifies (possibly ordered) groups, and objects
within a group are kept together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.clusters(merit,clusters,within.order = order.single, 
    between.order= order.single,...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.clusters_+3A_merit">merit</code></td>
<td>
<p>is either a symmetric matrix of merit or similarity score, 
or a <code>dist</code>.</p>
</td></tr>
<tr><td><code id="order.clusters_+3A_clusters">clusters</code></td>
<td>
<p>specifies a partial grouping. It should either be a list whose 
ith element contains 
the indices of the  objects in the ith cluster, or a vector of integers whose ith element 
gives the cluster membership of the ith object. Either representation may 
be used to specify grouping, the first is preferrable to specify 
adjacencies.</p>
</td></tr>
<tr><td><code id="order.clusters_+3A_within.order">within.order</code></td>
<td>
<p>is a function used to order the objects within each 
cluster.</p>
</td></tr>
<tr><td><code id="order.clusters_+3A_between.order">between.order</code></td>
<td>
<p>is a function used to order the clusters.</p>
</td></tr>
<tr><td><code id="order.clusters_+3A_...">...</code></td>
<td>
<p>arguments are passed to <code>within.order</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>within.order</code> may be NULL, in which case objects within a 
cluster are assumed to be in order. Otherwise, <code>within.order</code>
should be one of the ordering functions 
<code>order.single</code>,<code>order.endlink</code> or <code>order.hclust</code>.
</p>
<p><code>between.order</code> may be NULL, in which case cluster order
is preserved. 
Otherwise, <code>betweem.order</code>
should be one of the ordering functions that uses a partial ordering,
<code>order.single</code> or <code>order.endlink</code>.
</p>


<h3>Value</h3>

<p>A permutation of the objects represented by <code>merit</code> is returned.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley </p>


<h3>See Also</h3>

<p><a href="#topic+order.single">order.single</a>,<a href="#topic+order.endlink">order.endlink</a>,<a href="#topic+order.hclust">order.hclust</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state)
state.d &lt;- dist(state.x77)


# Order the states, keeping states in a division together.
state.o &lt;- order.clusters(-state.d, as.numeric(state.division))
cmat &lt;- dmat.color(as.matrix(state.d), rev(cm.colors(5)))


op &lt;- par(mar=c(1,6,1,1))
rlabels &lt;- state.name[state.o]
plotcolors(cmat[state.o,state.o], rlabels=rlabels)
par(op)


# Alternatively, use kmeans to place the  states into 6 clusters
state.km &lt;- kmeans(state.d,6)$cluster

# An ordering obtained from the kmeans clustering...
state.o &lt;- unlist(memship2clus(state.km))


layout(matrix(1:2,nrow=1,ncol=2),widths=c(0.1,1))
op &lt;- par(mar=c(1,1,1,.2))
state.colors &lt;- cbind(state.km,state.km)
plotcolors(state.colors[state.o,])

par(mar=c(1,6,1,1))
rlabels &lt;- state.name[state.o]
plotcolors(cmat[state.o,state.o], rlabels=rlabels)

par(op)
layout(matrix(1,1))



# In the ordering above, the ordering of clusters and the
# ordering of objects within the clusters is arbitrary.
# order.clusters gives an improved order but preserves the kmeans clusters.

state.o &lt;- order.clusters(-state.d, state.km)

# and replot
layout(matrix(1:2,nrow=1,ncol=2),widths=c(0.1,1))
op &lt;- par(mar=c(1,1,1,.2))
state.colors &lt;- cbind(state.km,state.km)
plotcolors(state.colors[state.o,])

par(mar=c(1,6,1,1))
rlabels &lt;- state.name[state.o]
plotcolors(cmat[state.o,state.o], rlabels=rlabels)

par(op)
layout(matrix(1,1))

</code></pre>

<hr>
<h2 id='order.single'>Orders objects using hierarchical clustering</h2><span id='topic+order.single'></span><span id='topic+order.endlink'></span><span id='topic+order.hclust'></span>

<h3>Description</h3>

<p>Reorders objects so that  similar (or high-merit) object pairs are adjacent.
A permutation vector is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.single(merit,clusters=NULL)
order.endlink(merit,clusters=NULL)
order.hclust(merit, reorder=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.single_+3A_merit">merit</code></td>
<td>
<p>is either a symmetric matrix of merit or similarity score, 
or a <code>dist</code>.</p>
</td></tr>
<tr><td><code id="order.single_+3A_clusters">clusters</code></td>
<td>
<p>if non-null, specifies a partial ordering. It should be a list whose 
ith element contains 
the indices the  objects in the ith ordered cluster.</p>
</td></tr>
<tr><td><code id="order.single_+3A_reorder">reorder</code></td>
<td>
<p>if TRUE, reorders the default ordering from <code>hclust</code>.</p>
</td></tr>
<tr><td><code id="order.single_+3A_...">...</code></td>
<td>
<p>arguments are passed to <code>hclust</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

 <p><code>order.single</code> performs a variation on single-link cluster analysis,
devised by Gruvaeus and Wainer (1972).
When two ordered clusters are merged, the new cluster is formed by placing the
most similar endpoints of the joining clusters adjacent to each other.
When applied to variables, the resulting order is useful for scatterplot 
matrices.
</p>
<p><code>order.endlink</code> is another variation on single-link cluster analysis,
where the similarity between two ordered clusters is defined as the minimum distance
between their endpoints. When two ordered clusters are merged, the new cluster is formed by placing the
most similar endpoints of the joining clusters adjacent to each other.
When applied to variables, the resulting order is useful for parallel 
coordinate displays.
</p>
<p><code>order.hclust</code> returns the order of objects from <code>hclust</code> if
<code>reorder</code> is <code>FALSE</code>. Otherwise, it reorders the objects using
<code>hclust.reorder</code>
so that
when two ordered clusters are merged, the new cluster is formed by placing the
most similar endpoints of the joining clusters adjacent to each other.
<code>order.hclust(m,method="single")</code> is equivalent to 
<code>order.single</code> when <code>clusters</code> is <code>NULL</code>.
The default method of <code>hclust</code> is &quot;complete&quot;, see <code><a href="stats.html#topic+hclust">hclust</a></code> for other 
possibilities.
</p>


<h3>Value</h3>

<p>A permutation of the objects represented by <code>merit</code> is returned.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley </p>


<h3>References</h3>

<p>Hurley, Catherine B.  &ldquo;Clustering Visualisations of Multidimensional 
Data&rdquo;, Journal of Computational and Graphical Statistics,
vol. 13, (4), pp 788-806, 2004. 
</p>
<p>Gruvaeus, G. and Wainer, H. (1972),
&ldquo;Two Additions to Hierarchical Cluster Analysis&rdquo;,
British Journal of Mathematical and Statistical Psychology, 25, 200-206.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cpairs">cpairs</a></code>, 
<code><a href="#topic+cparcoord">cparcoord</a></code>,<code><a href="#topic+plotcolors">plotcolors</a></code>, 
<code><a href="#topic+reorder.hclust">reorder.hclust</a></code>,<code><a href="#topic+order.clusters">order.clusters</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(state)
state.cor &lt;- cor(state.x77)
order.single(state.cor)
order.endlink(state.cor)
order.hclust(state.cor,method="average")

# Use for plotting...

cpairs(state.x77, panel.colors=dmat.color(state.cor), order.single(state.cor),pch=".",gap=.4)
cparcoord(state.x77, order.endlink(state.cor),panel.colors=dmat.color(state.cor))


# Order the states instead of the variables...

state.d &lt;- dist(state.x77)
state.o &lt;- order.single(-state.d)

op &lt;- par(mar=c(1,6,1,1))
cmat &lt;- dmat.color(as.matrix(state.d), rev(cm.colors(5)))
plotcolors(cmat[state.o,state.o], rlabels=state.name[state.o])
par(op)


</code></pre>

<hr>
<h2 id='ozone'>Ozone data from Breiman and Friedman, 1985</h2><span id='topic+ozone'></span>

<h3>Description</h3>

<p>This is the Ozone data discussed in Breiman and Friedman (JASA, 1985, p. 580).
These data are for 330 days in 1976.  All measurements are in the area of
Upland, CA, east of Los Angeles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ozone)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Ozone:</dt><dd><p>Ozone conc., ppm, at Sandbug AFB.</p>
</dd>
<dt>Temp:</dt><dd><p>Temperature F. (max?).</p>
</dd>
<dt>InvHt:</dt><dd><p>Inversion base height, feet</p>
</dd>
<dt>Pres:</dt><dd><p>Daggett pressure gradient (mm Hg)</p>
</dd>
<dt>Vis:</dt><dd><p>Visibility (miles)</p>
</dd>
<dt>Hgt:</dt><dd><p>Vandenburg 500 millibar height (m)</p>
</dd>
<dt>Hum:</dt><dd><p>Humidity, percent</p>
</dd>
<dt>InvTmp:</dt><dd><p>Inversion base temperature, degrees F.</p>
</dd>
<dt>Wind:</dt><dd><p>Wind speed, mph</p>
</dd>
</dl>


<h3>Source</h3>

<p>Breiman, L and  Friedman, J.  (1985),
&ldquo;Estimating Optimal Transformations for Multiple 
Regression and Correlation&rdquo;,
<em>Journal of the American Statistical Association</em>, 80,  580-598.
</p>

<hr>
<h2 id='partition.crit'> Combines the results of appplying an index to each group of 
observations </h2><span id='topic+partition.crit'></span>

<h3>Description</h3>

<p>Applies the function <code>gfun</code>  to each group of x and y values
and combines the results using the function <code>cfun</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition.crit(x, y, groups, gfun = gave, cfun = sum, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition.crit_+3A_x">x</code></td>
<td>
<p>is a numeric vector. </p>
</td></tr>
<tr><td><code id="partition.crit_+3A_y">y</code></td>
<td>
<p>is a numeric vector. </p>
</td></tr>
<tr><td><code id="partition.crit_+3A_groups">groups</code></td>
<td>
<p> is a vector of group memberships. </p>
</td></tr>
<tr><td><code id="partition.crit_+3A_gfun">gfun</code></td>
<td>
<p> is applied to the <code>x</code>  and <code>y</code> data in each group. </p>
</td></tr>
<tr><td><code id="partition.crit_+3A_cfun">cfun</code></td>
<td>
<p> combines the values returned by <code>gfun</code>. </p>
</td></tr>
<tr><td><code id="partition.crit_+3A_...">...</code></td>
<td>
<p> arguements are passed to  <code>gfun</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>gfun</code> is applied to each group of <code>x</code>  and <code>y</code>
values. The function <code>cfun</code> is applied to the vector or matrix of
<code>gfun</code> results.
</p>


<h3>Value</h3>

<p>The result of applying <code>cfun</code>.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley</p>


<h3>References</h3>

<p> See Gordon, A. D. (1999). <em>Classification</em>. Second Edition. London:
Chapman and Hall / CRC </p>


<h3>See Also</h3>

 <p><code><a href="#topic+gave">gave</a></code>, <code><a href="#topic+colpairs">colpairs</a></code>, 
<code><a href="#topic+order.single">order.single</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
y &lt;- runif(20)
g &lt;- rep(c("a","b"),10)

partition.crit(x,y,g)


data(bank)
# m is a homogeneity measure of each pairwise variable plot
m &lt;- -colpairs(scale(bank[,-1]), partition.crit,gfun=gave,groups=bank[,1])

# Color panels by level of m and reorder variables so that
# pairs with high m are near the diagonal. Panels shown
# in pink have the highest amount of group homogeneity, as measured by 
# gave.
cpairs(bank[,-1],order=order.single(m), panel.colors=dmat.color(m),
gap=.3,col=c("purple","black")[bank[,"Status"]+1],
pch=c(5,3)[bank[,"Status"]+1])

# Try  a different measure
m &lt;- -colpairs(scale(bank[,-1]), partition.crit,gfun=diameter,groups=bank[,1])

cpairs(bank[,-1],order=order.single(m), panel.colors=dmat.color(m),
gap=.3,col=c("purple","black")[bank[,"Status"]+1],
pch=c(5,3)[bank[,"Status"]+1])


# Result is the same, in this case.

</code></pre>

<hr>
<h2 id='pclen'> Profile smoothness measures </h2><span id='topic+pclen'></span><span id='topic+pcglen'></span>

<h3>Description</h3>

<p>Computes measures of profile smoothness of 2-d data,
where <code>x</code> and  <code>y</code> give the object coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pclen(x, y)
pcglen(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pclen_+3A_x">x</code></td>
<td>
<p>is a numeric vector. </p>
</td></tr>
<tr><td><code id="pclen_+3A_y">y</code></td>
<td>
<p>is a numeric vector. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pclen</code> computes the total line length in a parallel coordinate plot
of x and y.
</p>
<p><code>pcglen</code> computes the average (per object) line length in a parallel coordinate plot
where all pairs of objects are connected.
</p>
<p>Usually, the data is standardized prior to using these functions.
</p>


<h3>Value</h3>

<p>The panel measure is returned.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley </p>


<h3>References</h3>

<p>Hurley, Catherine B.  &ldquo;Clustering Visualisations of Multidimensional 
Data&rdquo;, Journal of Computational and Graphical Statistics,
vol. 13, (4), pp 788-806, 2004. </p>


<h3>See Also</h3>

<p><code><a href="#topic+cparcoord">cparcoord</a></code>, 
<code><a href="#topic+colpairs">colpairs</a></code>, <code><a href="#topic+order.endlink">order.endlink</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(20)
y &lt;- runif(20)
pclen(x,y)


data(state)
mins &lt;- apply(state.x77,2,min)
ranges &lt;- apply(state.x77,2,max) - mins
state.m &lt;- -colpairs(scale(state.x77,mins,ranges), pclen)
state.col &lt;- dmat.color(state.m)
cparcoord(state.x77, panel.color= state.col)
# Get rid of the panels with long line segments (yellow) by reordering:
cparcoord(state.x77, order.endlink(state.m), state.col)

</code></pre>

<hr>
<h2 id='plotcolors'>Plots a matrix of colors</h2><span id='topic+plotcolors'></span><span id='topic+imageinfo'></span>

<h3>Description</h3>

<p><code>plotcolors</code> plots a matrix of colors 
as an image or as points.
</p>
<p><code>imageinfo</code> is a utility that given a matrix of colors,
returns a structure useful for the <code>image</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotcolors(cmat, na.color = "white", dlabels = NULL, rlabels = FALSE, clabels = FALSE, 
ptype = "image", border.color = "grey70", pch = 15, cex = 3, label.cex = 0.6, ...)

imageinfo(cmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotcolors_+3A_cmat">cmat</code></td>
<td>
<p>a matrix of numbers, nas are allowed.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_na.color">na.color</code></td>
<td>
<p>used for NAs in <code>cmat</code>.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_dlabels">dlabels</code></td>
<td>
<p>vector of labels for the diagonals.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_rlabels">rlabels</code></td>
<td>
<p>vector of labels for the rows.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_clabels">clabels</code></td>
<td>
<p>vector of labels for the columns.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_ptype">ptype</code></td>
<td>
<p>should be &quot;image&quot; or &quot;points&quot;</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_border.color">border.color</code></td>
<td>
<p>color of border drawn around the plot.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_pch">pch</code></td>
<td>
<p>point type used when ptype=&quot;points&quot;.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_cex">cex</code></td>
<td>
<p>point cex used when ptype=&quot;points&quot;.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_label.cex">label.cex</code></td>
<td>
<p>cex parameter used for labels.</p>
</td></tr>
<tr><td><code id="plotcolors_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>imageinfo</code> returns a list with components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a vector of x coordinates.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a vector of y coordinates.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>a matrix containing values to be plotted.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>the colors to be used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Catherine B. Hurley </p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="Matrix.html#topic+image">image</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotcolors(matrix(1:20,nrow=4,ncol=5))

plotcolors(matrix(1:20,nrow=4,ncol=5),ptype="points",cex=6)

plotcolors(matrix(1:20,nrow=4,ncol=5),rlabels = c("a","b","c","d"))


data(longley)
longley.cor &lt;- cor(longley)
# A matrix with equal (or nearly equal) number of entries of each color.
longley.color &lt;- dmat.color(longley.cor)


plotcolors(longley.color, dlabels=rownames(longley.color))

# Could also reorder variables prior to plotting:
longley.o &lt;- order.single(longley.cor)
longley.color &lt;- longley.color[longley.o,longley.o]

op &lt;- par(mar=c(1,6,6,1))
plotcolors(longley.color,rlabels=rownames(longley.color),clabels=rownames(longley.color) )
par(op)

</code></pre>

<hr>
<h2 id='reorder.hclust'>Reorders object order of hclust, keeping objects within a cluster
contiguous to each other. </h2><span id='topic+reorder.hclust'></span>

<h3>Description</h3>

<p>Reorders objects so that  nearby object pairs are adjacent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'hclust'
reorder(x,dis,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder.hclust_+3A_x">x</code></td>
<td>
<p>is the result of <code>hclust</code>.</p>
</td></tr>
<tr><td><code id="reorder.hclust_+3A_dis">dis</code></td>
<td>
<p>is a distance matrix or <code>dist</code>.</p>
</td></tr>  
<tr><td><code id="reorder.hclust_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>  
</table>


<h3>Details</h3>

 
<p>In hierarchical cluster displays, a decision is needed at 
each merge to specify which subtree should go on the left 
and which on the right. 
This algorithm uses the order suggested by Gruvaeus and Wainer (1972).
At a merge of clusters A and B, the new cluster is one of
(A,B), (A',B), (A,B'),(A',B'), where A' denotes A in reverse order.
The new cluster is chosen to minimize the distance between
the object in A placed adjacent to an object from B.
</p>


<h3>Value</h3>

<p>A permutation of the objects represented by <code>dis</code> is returned.
</p>


<h3>Author(s)</h3>

<p> Catherine B. Hurley </p>


<h3>References</h3>

<p>Hurley, Catherine B.  &ldquo;Clustering Visualisations of Multidimensional 
Data&rdquo;, Journal of Computational and Graphical Statistics,
vol. 13, (4), pp 788-806, 2004.
</p>
<p>Gruvaeus, G. and Wainer, H. (1972),
&ldquo;Two Additions to Hierarchical Cluster Analysis&rdquo;,
British Journal of Mathematical and Statistical Psychology, 25, 200-206.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, 
<code><a href="#topic+order.hclust">order.hclust</a></code> .</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eurodist)
dis &lt;- as.dist(eurodist)
hc &lt;- hclust(dis, "ave")


layout(matrix(1:2,nrow=2,ncol=1))
op &lt;- par(mar=c(1,1,1,1))
plot(hc)
hc1 &lt;- reorder.hclust(hc, dis)
plot(hc1)
par(op)
layout(matrix(1,1))

# Both dedrograms correspond to the same tree structure,
# but the second one shows that
# Paris is closer to Cherbourg than Munich, and
# Rome is closer to Gibralter than to Barcelona.


# We can also compare both orderings with an
# image plot of the colors.
# The second ordering seems to place nearby cities
# closer to each other.


layout(matrix(1:2,nrow=2,ncol=1))
op &lt;- par(mar=c(1,6,1,1))
cmat &lt;- dmat.color(eurodist, rev(cm.colors(5)))
plotcolors(cmat[hc$order,hc$order], rlabels=labels(eurodist)[hc$order])

plotcolors(cmat[hc1$order,hc1$order], rlabels=labels(eurodist)[hc1$order])

layout(matrix(1,1))
par(op)

</code></pre>

<hr>
<h2 id='vec2distm'> Various utility functions</h2><span id='topic+vec2distm'></span><span id='topic+vec2dist'></span><span id='topic+lower2upper.tri.inds'></span><span id='topic+diag.off'></span><span id='topic+clus2memship'></span><span id='topic+memship2clus'></span>

<h3>Description</h3>

<p><code>vec2distm</code> converts a vector to a distance matrix.
</p>
<p><code>vec2dist</code> converts a vector to a <code>dist</code> structure.
</p>
<p><code>lower2upper.tri.inds</code> is the same as <code>lower.to.upper.tri.inds</code>
from package cluster. It computes an index vector for extracting or reordering a lower     
triangular matrix that is stored as a contiguous vectors. 
</p>
<p><code>diag.off</code>  returns a vector of off-diagonal elements of a matrix.
<code>off</code> specifies the distance above the main (0) diagonal.
</p>
<p><code>clus2memship</code> converts  a list whose ith element contains the indices
of objects in the ith cluster into a vector whose ith 
element gives the cluster number of the ith object.
</p>
<p><code>memship2clus</code> converts  a vector whose ith 
element gives the cluster number of the ith object into a list 
whose ith element contains the indices
of objects in the ith cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2distm(vec)
vec2dist(vec)
lower2upper.tri.inds(n)
diag.off(m,off=1)
clus2memship(clusters)
memship2clus(memship)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2distm_+3A_vec">vec</code></td>
<td>
<p>is a vector. </p>
</td></tr>
<tr><td><code id="vec2distm_+3A_n">n</code></td>
<td>
<p>is an integer &gt; 1. </p>
</td></tr>
<tr><td><code id="vec2distm_+3A_m">m</code></td>
<td>
<p>is a matrix.</p>
</td></tr>
<tr><td><code id="vec2distm_+3A_clusters">clusters</code></td>
<td>
<p>is a list whose ith element contains the indices of the 
objects belonging to the ith cluster.</p>
</td></tr>
<tr><td><code id="vec2distm_+3A_off">off</code></td>
<td>
<p>is an integer specifying the distance above the main (0) diagonal.</p>
</td></tr>
<tr><td><code id="vec2distm_+3A_memship">memship</code></td>
<td>
<p>is a vector whose ith element gives the cluster number of 
the ith object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Catherine B. Hurley</p>


<h3>See Also</h3>

  <p><code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="base.html#topic+diag">diag</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- 1:15
vec2distm(vec)
vec2dist(vec)
diag.off(vec2distm(vec))
lower2upper.tri.inds(5)
clus2memship(list(c(1,3,5),c(2,6),4))
memship2clus(c(1,3,4,2,1,4,2,3,2,3))
</code></pre>

<hr>
<h2 id='wine'>Wine recognition data</h2><span id='topic+wine'></span>

<h3>Description</h3>

<p>Data from the machine learning repository.
A chemical analysis
of 178 Italian wines from three different cultivars yielded 13  measurements.
This dataset is often used to test and compare the performance of various
classification algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wine)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Class:</dt><dd><p>There are 3 classes</p>
</dd>
<dt>Alcohol:</dt><dd><p>Alcohol</p>
</dd>
<dt>Malic:</dt><dd><p>Malic acid</p>
</dd>
<dt>Ash:</dt><dd><p>Ash</p>
</dd>
<dt>Alcalinity:</dt><dd><p>Alcalinity of ash</p>
</dd>
<dt>Magnesium:</dt><dd><p>Magnesium</p>
</dd>
<dt>Phenols:</dt><dd><p>Total phenols</p>
</dd>
<dt>Flavanoids:</dt><dd><p>Flavanoids</p>
</dd>
<dt>Nonflavanoid:</dt><dd><p>Nonflavanoid phenols</p>
</dd>
<dt>Proanthocyanins:</dt><dd><p>Proanthocyanins</p>
</dd>
<dt>Intensity:</dt><dd><p>Color intensity</p>
</dd>
<dt>Hue:</dt><dd><p>Hue</p>
</dd>
<dt>OD280:</dt><dd><p>OD280/OD315 of diluted wines</p>
</dd>
<dt>Proline:</dt><dd><p>Proline</p>
</dd>
</dl>


<h3>Source</h3>

<p>Forina, M. et al, PARVUS - An Extendible Package for Data
Exploration, Classification and Correlation. Institute of Pharmaceutical
and Food Analysis and Technologies, Via Brigata Salerno, 
16147 Genoa, Italy.
</p>


<h3>References</h3>

<p>Blake, C.L. and Merz, C.J. (1998), UCI Repository of machine learning databases, \
<a href="http://www.ics.uci.edu/~mlearn/MLRepository.html">http://www.ics.uci.edu/~mlearn/MLRepository.html</a>. Irvine, CA: University of California, Department of
Information and Computer Science. 
</p>
<p>The database does not list the variable names. These were
located at 
<a href="http://www.radwin.org/michael/projects/learning/about-wine.html">http://www.radwin.org/michael/projects/learning/about-wine.html</a>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
